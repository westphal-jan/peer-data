{"id": "1307.8182", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Jul-2013", "title": "POMDPs Make Better Hackers: Accounting for Uncertainty in Penetration Testing", "abstract": "Penetration Testing is a methodology for assessing network security, by generating and executing possible hacking attacks. Doing so automatically allows for regular and systematic testing. A key question is how to generate the attacks. This is naturally formulated as planning under uncertainty, i.e., under incomplete knowledge about the network configuration. Previous work uses classical planning, and requires costly pre-processes reducing this uncertainty by extensive application of scanning methods. By contrast, we herein model the attack planning problem in terms of partially observable Markov decision processes (POMDP). This allows to reason about the knowledge available, and to intelligently employ scanning actions as part of the attack. As one would expect, this accurate solution does not scale. We devise a method that relies on POMDPs to find good attacks on individual machines, which are then composed into an attack on the network as a whole. This decomposition exploits network structure to the extent possible, making targeted approximations (only) where needed. Evaluating this method on a suitably adapted industrial test suite, we demonstrate its effectiveness in both runtime and solution quality.", "histories": [["v1", "Wed, 31 Jul 2013 01:03:00 GMT  (143kb,D)", "http://arxiv.org/abs/1307.8182v1", "Twenty-Sixth Conference on Artificial Intelligence (AAAI-12), Toronto, Canada"]], "COMMENTS": "Twenty-Sixth Conference on Artificial Intelligence (AAAI-12), Toronto, Canada", "reviews": [], "SUBJECTS": "cs.AI cs.CR", "authors": ["carlos sarraute", "olivier buffet", "j\u00f6rg hoffmann 0001"], "accepted": true, "id": "1307.8182"}, "pdf": {"name": "1307.8182.pdf", "metadata": {"source": "META", "title": "POMDPs Make Better Hackers: Accounting for Uncertainty in Penetration Testing", "authors": ["Carlos Sarraute", "Olivier Buffet", "J\u00f6rg Hoffmann"], "emails": ["carlos@coresecurity.com", "buffet@loria.fr", "hoffmann@cs.uni-saarland.de"], "sections": [{"heading": "Introduction", "text": "This year it is so far that it will only be a matter of time before an agreement is reached."}, {"heading": "Preliminaries", "text": "We list some details about the network structure and penetration tests and give a brief background on POMDPs."}, {"heading": "Network Structure", "text": "Networks can be regarded as directed graphs whose vertices are given by the setM of the machines, and whose arcs connect pairs of m \u00b2 M. In practice, however, these network graphs have a specific structure. They tend to consist of subnets, i.e. clusters of machines where every m \u00b2 N is directly connected to every m \u00b2 N. In contrast, not every subnetwork N \u00b2 is connected to every other subnetwork N \u00b2, and if such a connection exists, it is typically filtered by a firewall. From an attacker's perspective, the firewalls filter the connections, limiting the attacks that can be carried out when attempting to hack into a subnetwork N \u00b2 from another subnetwork. On the other hand, access to all machines within N is easy once the hacker has managed to get into a subnetwork N."}, {"heading": "Penetration Testing", "text": "Uncertainty arises because it is impossible to track all the configuration details of individual machines, i.e. exactly which versions of which programs are installed, etc. However, it is safe to assume that the pentesting tool knows the structure of the network, i.e. the graph LN and the filtering performed by each firewall. A controlled machine has already been hacked and can easily be registered. The aim of pentesting is to gain control over certain machines (with critical content) in the network. At any given time, each machine has a unique status. A controlled machine has already been started. A controlled machine is connected to a controlled machine, i.e. either m is in a subnetwork N \u00b2 whose machines are controlled, or m is located in a subnetwork N \u00b2 with an LN sheet N \u2212 \u2192 N \u00b2, where one of the machines is controlled in N \u00b2. All other machines are not reached."}, {"heading": "POMDPs", "text": "POMDPs are usually defined (e.g. (Monahan 1982; Kaelbling, Littman and Cassandra 1998) by a tuple < S, A, O, T, O, r, b0 >. If the system is in state S (of the state space) and the actor performs an act A (of the state space), this leads to (1) a transition to a state s (according to the transitional function T (s, a, s) = Pr (s, s), (2) to an observation o (of the observation space) according to the observation function O (s, a, o) = Pr (o, s, a) and (3) a scalar reward r (s, a, s). b0, the initial belief, is a probability distribution over the state. The actor must find a decision policy based on each step of the best action."}, {"heading": "POMDP Model", "text": "A preliminary version of our POMDP model was presented at the SecArt '11 workshop (Sarraute, Buffet, and Hoffmann 2011). Readers may refer to this paper for a more detailed example that lists complete transition and observation models for some actions and illustrates the evolution of beliefs in the application of these actions. Below, we will keep the description brief in the interest of space."}, {"heading": "States", "text": "Several aspects of the problem - in particular, the network structure and firewall filtering rules - are known and static. POMDP variables encoding these aspects can be compiled in a preliminary process and are not included in our model; states capture the status of each machine (controlled / reached / not reached); for non-controlled machines, they also specify the software configuration (operating system, servers, open ports, etc.); we specify the vulnerable programs and programs that provide information about them (e.g. the VulP protection mechanism in our running example is relevant to both exploits); states also specify whether a given machine or program has crashed; and finally, we insert a special terminal state into the POMDP model (of the entire network, not individual machines), corresponding to the task of the attack if for each available action (if any) the potential benefit is not worth the cost of the action."}, {"heading": "Actions", "text": "There are two types of actions, scans and exploits, both of which are aimed at accessible machines. Scans can be OS detection actions or port scans. In most cases, they have no effect on the condition of the target machine. Their purpose is to gain knowledge about the configuration of a machine through an observation that normally allows some states to be circumvented out of faith (e.g. the observation that the operating system must be a Windows XP version). Exploits use use use of a vulnerability - if present - to gain control over a machine. The result of the exploitation is observed by the attacker, so that a failed exploit can provide information about the configuration (e.g. that a protection mechanism is likely to be executed)."}, {"heading": "Rewards", "text": "The immediate reward of any scan / exploit action depends on the transition it causes in its current state. Our simple model is to additively decompose the immediate reward r (s, a, s) into r (s, a, s) = re (s, s) + rt (a). Here, (i) re (s, a, s) is the value of the attacked machine, if the transition (s, a) corresponds to a successful exploitation, and is 0 for all other transitions. (ii) rt (a) is a cost factor depending on the duration of the action; and (iii) rd (a) is a cost factor reflecting the detection risk of using this action. (iii) It is orthogonal to the risk of crashing a program / machine, which we describe as a possible result of exploitation."}, {"heading": "Designing the Initial Belief", "text": "We assume that the original belief - our knowledge of the network in which we launch the updates - is based on (a) what was known at the end of the previous pentest, and (b) what has changed since then. We assume that the knowledge (a) is perfect, that is, that each machine has a specific configuration at the time of the attack. (b) We assume that the original belief is as a function b0 (I, T), where the number of days that have passed since the last pentest is entangled, and the uncertainty in this belief arises because we do not know which software updates have been applied. We assume that the updates are made independently of each machine (simplified, but reasonably given that updates are controlled by individual users). A simple model of the updates (Sarraute, Buffet and Hoffmann 2011) encodes the uncertain development of each program independently of each other."}, {"heading": "Technicalities", "text": "To provide a more detailed understanding of the 4AL arcs in LN, we will now discuss pseudo-code for the algorithms provided in Figure 3. Let us first consider algorithm 1. It should be clear how the overall structure of the algorithm corresponds to our previous discussion. It calls the Hopcroft and Tarjan Linear Age Algorithm (1973) (hereinafter HT) to find the decomposition. The loop i = k,., 1 processes the components in reverse topological order. The rotatable reward function encodes the propagation of rewards up in the tree; this should be self-explanatory for the expression \"the parents\" of Ci in LN. The latter is based on the fact that each component is just such a parent.To explain the cleanup, we note that HT works on undirected graphs; when we apply it, we ignore the direction of the arcs in LN."}, {"heading": "Policy Construction", "text": "At level 1, the global policy is built from the guidelines of level 2, simply following the decomposition of the tree: starting from the tree root, we execute the guidelines of level 2 for all the components reached (in any order); once a hack into a component succeeds, the corresponding components of the children are reached; at level 2, i.e. within a bi-connected component C, the policy corresponds to the set of paths P, which is taken into account in algorithm 2. each P is processed successively; for each node N in P (until entry into this subnetwork fails), we designate the corresponding policy of level 3. At level 3, i.e. taking into account a single subnet N, our policy simply attacks the machine m \u00b2 N, which has yielded the maximum in algorithm 3. The first attack of the policy by the firewall, using the corresponding policy of level 4, the policy of the MDP attacks the remaining machines m \u00b2 N in any order (i.e., for each level 4, we return the policy to the PODP)."}, {"heading": "Experiments", "text": "We compared 4AL with the \"global\" POMDP model and encoded the entire attack problem in a single POMDP. Experiments are run on a machine with an Intel Core2 Duo 2.2 GHz CPU and 3 GB of RAM. 4AL algorithm is implemented in Python."}, {"heading": "Test Scenario", "text": "Our test scenario is based on the network structure shown in Figure 5. The attack starts on the Internet (\u0445 is the cloud in the upper left corner), the network consists of three areas - exposed, sensitive, users - separated by firewalls. Internally, each of exposed and sensitive is completely connected (i.e., these areas are subnetworks), while the user consists of a tree of subnets separated by empty firewalls. Only two machines are rewarded, one in sensitive (reward 9000) and one in a leaf subnetwork of the user (reward 5000). The cost of port scans and exploits is 10, the cost of detecting the operating system is 50. We allow to scale the number of machines | M | by distributing them, with the first machine exposed, the second to sensitive, and the remaining 38 to the user. The exploits are taken from the Core Security database."}, {"heading": "Approximation Loss", "text": "Figure 4 (a) shows the relative loss of quality when operating 4AL instead of a global POMDP solution at values of | E | and | M |, where the latter is feasible. We show quality (global -POMDP) quality (4AL) as a percentage of quality (global -POMDP). The quality of the policy is estimated here by 2000 simulations, this measurement results in a variance that is almost greater than the very small quality advantage of the global POMDP solution. The maximum loss for each combination of | E | and | M | is 14.1% (for | E | = 7, | M | = 6), the average loss over all combinations is 1.96%. The average loss grows monotonously above | M |, from \u2212 1.14% for | M | = 1 to 4.37% for | M | = 6. Above | E |, the behavior is less regular; the maximum average loss, 5.4%, results from the fixation of | E | = 5."}, {"heading": "Scaling Up", "text": "Figure 4 (b) shows the runtime of 4AL when scaling to much larger values of | E | and | M |. Scaling behavior via | M | clearly reflects the fact that 4AL is polynomial in this parameter, except for the size of bi-connected components (which is 3 here). Scaling E leads to more sophisticated POMDPs of individual machines, resulting in a sometimes steep increase in runtime. However, even with | M | and | E | both by 100, which is a realistic size in practice, runtime is always less than 37 seconds."}, {"heading": "Conclusion", "text": "We have developed a POMDP penetration testing model that enables many features of this application to be represented in a natural way, in particular, incomplete knowledge of network configuration and dependencies between different attack options and firewalls. Unlike all previous methods, the approach is capable of intelligently mixing scans with exploits.An important open question is to what extent our POMDP + decomposition approach is more cost-effective than the classical planning solution currently used by Core Security. Our next step will be to answer this question experimentally by comparing the attack quality of 4AL with the policy that performs extensive scans and then bines the FF plan to the most likely configuration."}], "references": [], "referenceMentions": [], "year": 2013, "abstractText": "Penetration Testing is a methodology for assessing network security, by generating and executing possible hacking attacks. Doing so automatically allows for regular and systematic testing. A key question is how to generate the attacks. This is naturally formulated as planning under uncertainty, i.e., under incomplete knowledge about the network configuration. Previous work uses classical planning, and requires costly pre-processes reducing this uncertainty by extensive application of scanning methods. By contrast, we herein model the attack planning problem in terms of partially observable Markov decision processes (POMDP). This allows to reason about the knowledge available, and to intelligently employ scanning actions as part of the attack. As one would expect, this accurate solution does not scale. We devise a method that relies on POMDPs to find good attacks on individual machines, which are then composed into an attack on the network as a whole. This decomposition exploits network structure to the extent possible, making targeted approximations (only) where needed. Evaluating this method on a suitably adapted industrial test suite, we demonstrate its effectiveness in both runtime and solution quality.", "creator": "TeX"}}}