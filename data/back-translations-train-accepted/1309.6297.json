{"id": "1309.6297", "review": {"conference": "aaai", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Sep-2013", "title": "Generating Explanations for Biomedical Queries", "abstract": "We introduce novel mathematical models and algorithms to generate (shortest or k different) explanations for biomedical queries, using answer set programming. We implement these algorithms and integrate them in BIOQUERY-ASP. We illustrate the usefulness of these methods with some complex biomedical queries related to drug discovery, over the biomedical knowledge resources PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA. To appear in Theory and Practice of Logic Programming (TPLP).", "histories": [["v1", "Tue, 24 Sep 2013 19:28:44 GMT  (617kb,D)", "http://arxiv.org/abs/1309.6297v1", "42 pages, 14 figures, 4 tables, online appendix (proofs, 24 pages)"]], "COMMENTS": "42 pages, 14 figures, 4 tables, online appendix (proofs, 24 pages)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["esra erdem", "umut oztok"], "accepted": true, "id": "1309.6297"}, "pdf": {"name": "1309.6297.pdf", "metadata": {"source": "CRF", "title": "Generating Explanations for Biomedical Queries", "authors": ["ESRA ERDEM", "UMUT OZTOK", "Esra Erdem", "Umut Oztok"], "emails": ["esraerdem@sabanciuniv.edu)", "uoztok@sabanciuniv.edu)"], "sections": [{"heading": null, "text": "KEYWORDS: answer set programming, explain generation, query answering, biomedical queries1 Introduction Recent advances in health and life sciences have led to the generation of a large amount of biomedical data represented in various biomedical databases or ontologies. Presenting these databases and ontologies in different formats and constructing / maintaining them independently in different locations has presented many challenges for answering complex biomedical questions that require the integration of knowledge represented in these ontologies and databases. One of the challenges for users is to present such biomedical queries in a natural language and to obtain their answers in an understandable form. Another challenge is to extract relevant knowledge from different knowledge resources and integrate it appropriately using definitions, such as chains of gene-gene interactions, cliques of genes, gene relationships based / drugs."}, {"heading": "2 Esra Erdem, Umut Oztok", "text": "In fact, most of them are able to go in search of a solution that puts them in the position in which they find themselves."}, {"heading": "4 Esra Erdem, Umut Oztok", "text": "BIOGRID (Stark et al. 2006), 3 CTD (Davis et al. 2011), 4 SIDER (Kuhn et al. 2010), 5 DISEASE ONTOLOGY (Schriml et al. 2012), 6 and ORPHADA.7 In sections 8 and 9 we discuss how to present explanations in a natural language to the user, and in section 11 we briefly discuss other related work in section 12, summarizing our contributions and indicating possible future work. Evidence is provided in the paper's online appendix. 3 http: / / thebiogrid.org / 4 http: / ctd.mdibl.org / 6 http: / /."}, {"heading": "6 Esra Erdem, Umut Oztok", "text": "We say that a rule r is a fact if B (r) = \"false,\" and we usually ignore the \"q\" characters. Furthermore, we say that a rule r is a constraint if the header of r is \"different,\" and we usually ignore the \"c\" characters. (\"q\") A program's answers are defined by basic programs (\"q\"). We call an atom, rule, or program reason if it does not contain variables. (\"c\") Answers to basic rules that are achieved by substituting all possible constants, and the set B represents all basic atoms that can be constructed from atoms in relation to constants. Ground (\"c\") also refers to the set of principles that are achieved by substituting all possible constants in Ui."}, {"heading": "8 Esra Erdem, Umut Oztok", "text": "\"We can see the Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene Gene"}, {"heading": "10 Esra Erdem, Umut Oztok", "text": "The answer to this question is: \"We can find answers to the question of how to find the answer to the question of the answer of these two programs with CLASP.\" For the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the answer to the answer to the question of the answer to the answer to the question of the answer to the answer to the question of the answer to the answer to the question of the answer to the question of the answer to the question of the question of the answer to the question of the question of the answer to the question of the answer to the question of the question of the answer to the question of the answer to the question of the answer to the answer to the answer to the question of the question of the answer to the answer to the answer to the question of the question of the answer to the answer to the question of the answer to the question of the answer to the answer to the answer to the question of the answer to the answer to the question of the answer to the answer to the question of the answer to the answer to the answer to the question of the answer to the answer to the answer to the question of the answer to the answer to the question of the answer to the answer to the answer to the question of the answer to the answer to the answer to the question of the answer to the question of the question of the answer to the answer to the answer to the question of the answer to the question of the answer to the answer to the answer to the answer to the question of the answer to the question of the answer to the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer to the question of the answer of the answer to the question of the answer to the question of the question of the question of the answer of the answer of the answer to the question of the answer of the question of the answer of the answer of the answer of the answer of the"}, {"heading": "12 Esra Erdem, Umut Oztok", "text": "(iii). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V.). V. (V.). V. (V.). V. (V.). V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V. (V.). V. (V.). V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). V. (V.). (V.). V. (V.). (V.). (V.). (V.). V. (V.). (V.). (V.). V. (V.). (V.). V.). V. (V.). (V.). V. (V.). (V.). V. (V.). (V.). (V.). (V.). V. (V.). V. (V.). (V.). V. (V.). (V.). (V.). V. (V.). (V.). (V.). V. (V. (V.). (V.). (V.). (V.). V. (V.). (V.). V. (V. (V.). V. (V.). V. (V. (V.). (V.). (V.). V. (V. (V.). V. (V. (V.). V. (V.). V. (V. (V.). V. (V. (V.). V. (V.). (V. (V.). (V.). (V.). V. (V. (V.). V. (V.). (V. (V.). (V.). V. (V. (V.). V. (V. (V.). (V.). V. (V.). (V. (V.). (V.)."}, {"heading": "18 Esra Erdem, Umut Oztok", "text": "Algorithm 2: = V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V"}, {"heading": "22 Esra Erdem, Umut Oztok", "text": "The answer to the question whether the question is about the question, whether the question is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question is about the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question is about the question, whether it is about the question is about the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question, whether it is about the question is the question, whether it is about the question is about the question, whether it is about the question, whether it is about the question, whether it is about the question is about the question is about the question, whether it is about the question is about the question is about the question, whether it is about the question, whether it is about the question is"}, {"heading": "24 Esra Erdem, Umut Oztok", "text": "The following explanation shows how to calculate the longest explanations. (7) Let's be a down-to-earth ASP program. (7) Let's be a down-to-earth ASP program. (7) Let's calculate the number of explanations for p in relation to p and X. (7) Let's calculate the number of explanations for p in relation to p and X. (7) Let's calculate the number of explanations for p in relation to p and X. (7) Let's calculate the number of explanations in relation to Qi-1, Qi-1, Qi-1, RVertices (Ki). (5) This result leads to some useful consequences. (5) Algorithm 5 calculates \"longest\" explanations if k = 1. The following corollary shows how to calculate the longest explanations. (1) Let's calculate the longest explanations."}, {"heading": "26 Esra Erdem, Umut Oztok", "text": "The last column of Table 2 presents the number of cases in which GRINGO is called for such incremental grounding. For example, the Q1, Q3, and Q5 queries are never called, but GRINGO is called 193 times during the calculation of a shorter explanation for the Q10 query. Calculation time is not very dependent on the size of the explanation, just as the complexity results of Algorithm 1 (i.e., O), which depend on the calculation time for generating the shortest explanations, depend on how the size of the answer and the explanation tree is."}, {"heading": "28 Esra Erdem, Umut Oztok", "text": "\u2022 a predicate table, and the results are \u2022 a shortest explanation for p in terms of \"b\" and \"X\" in a natural language (if the shortest explanation option is chosen), \u2022 k various explanations for p in terms of \"c\" and \"X\" in a natural language (if k is chosen another explanation option). To provide experts with further informative explanations about the answers of biomedical queries, we have embedded EXPGEN-ASP in BIOQUERY-ASP, relying on Table 4 as the predicate table of the system. Figure 10 shows a snapshot of the explanatory mechanism of BIOQUERY-ASP. Generating Explanations for Biomedical Queries 2910 Relating Explanations to Justice Class."}, {"heading": "30 Esra Erdem, Umut Oztok", "text": "It is not as if utopia is an atom or a formula of form in which an atom is not an atom; the number of atoms that appear as negated letters in a program is designated by NANT as a noteworthy letter; the number of atoms that appear as negated letters in a program is designated by NANT as a noteworthy letter; for an atom, an answer to the fact that the atom is a true and a noteworthy word; then a + and a - the annotated versions of a are designated; furthermore, it is defined that atoms (a +) = a and atom (a \u2212) = a. For a number of atoms, the following sets of atoms are designated as false."}, {"heading": "32 Esra Erdem, Umut Oztok", "text": "In a series of elements that directly contribute to the finding of the truth of an atom J (J), it is assumed that b) J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J (J) = J) = J (J) = J (J) = J (J) = J (J) = J) = J (J) = J (J) = G (J) = J (J) = J) = J (J) = J (J) = J) = J (J) = J (J) = J = J = J (J) = J) = J (J) = J (J) = J = J (J) = J) = J (J) = J (J) = J = J (J) = J = J) = J (J) = J (J) = J (J) = J = J) = J (J) = J (J) = J = J (J) = J = J (J) = J = J (J) = J = J (J) = J = J (J) = J = J (J) = J = J (J) = J = J = J (J) = J = J = J (J) = J = J (J) = J = J (J) = J (J) = J = J = J (J) = J = J (J = J = J) = J (J = J = J (J) = J = J (J) = J = J (J) = J (J = J) = J (J = J (J) = J = J (J) = J (J = J) = J (J = J (J) = J (J = J) = J (J) = J (J = J (J) = J (J = J) = J (J) = J (J) = J (J (J) = J (J) = J (J) = J (J = J (J) = J) = J (J (J) = J (J (J)"}, {"heading": "34 Esra Erdem, Umut Oztok", "text": "In fact, the assumptions that we have made our own are very different. (...) The assumptions that we have made our own are very different. (...) The assumptions that we have made our own are very different. (...) The assumptions that we have made our own are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have taken to ourselves are very different. (...) The assumptions that we have set to ourselves. (...) The assumptions that we have set to ourselves are very different."}, {"heading": "36 Esra Erdem, Umut Oztok", "text": "Algorithm 7: Justification for the explanation Input: erd normal ASP program, X: Answer set for \"Q,\" p: Atom in X, (V, E): Justification of p + w.r.t. \"and some U.\" Assumptions. \"Output: A Vertex-marked tree < V,\" E, l, \"X\".V. \".V.\".V. \".V.\".V. \"\".V. \"\".V. \"\" \".V.\".V. \".V.\".V. \".V.\".V. \"\".V. \"\".V. \"\" \".V.\" \".V.\" \".V.\" \".V.\" \"\".V. \"\" \".V.\" \"\".V. \"\" V. \"\" \".V.\" V.. \"\" \"\" \"\".V. \"V.\" \"\".V. \"V.\" \".V..\" \"\" \"\".V.. \"\" \"\" \".V..\" \"\" \"\" \".V..\" \"\" \"\" \".V.\".V.. \"\" \"\".V.. \"\" \""}, {"heading": "38 Esra Erdem, Umut Oztok", "text": "Algorithm 8: Justification Statement Input: \"Basic Normal ASP Program,\" \"Q\" (\"Q\"), \"Q\" (\"Q\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V\" (\"V\"), \"V (\" V \"),\" V \"(\" V \"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" V (\"),\" (\"V,\" (\"),\" V (\"),\" V (\"),\" V (\"),\" (\"(\"), \"V (\"), \"(\"), \"V (\" (\"),\" (\"),\" (\"V (\"), \"(\"), \"V (\"), \"(\" V (\"),\" (\"),\" (\"),\" V (\"(\"), \"V (\"), \"(\"), \"(\" V (\"),\"), \"(\"), \"(\" V (\"),\" (\"),\" (\"),\" (\"(\"), \"V (\"), \"(\" V), \"(\"), \"(\" (\"),\" (\"),\" (\"),\" (\"),\" (\"V),\" (\"(\"), \"(\"), \"),\" (\"(\"), \"(\" V (\"),\"), \"(\"), \"(\" (\"),\" (\"),\" (\"V (\"), \"),\" (\""}, {"heading": "40 Esra Erdem, Umut Oztok", "text": "In fact, most of them will be able to move to another world in which they will be able to integrate."}, {"heading": "BODENREIDER, O., COBAN, Z. H., DOGANAY, M. C., ERDEM, E., AND KOSUCU, H. 2008. A", "text": "In Proc., G., EITER, T., AND TRUSZCZYNSKI, M. 2011. Debugging logic programs under the answer set semantics. In Proc., G., EITER, T., AND TRUSZCZYNSKI, M. 2011. Answer set programming at a glance. Commun. ACM 54, 12, 92-103.CHONG, C. R. AND SULLIVAN, D. J. 2007. New uses for old drugs. Nature 448, 645-646. DAVIS, A. P., KING, B. L., MOCKUS, MURPHY G., SARACENI-RICHARDS, C., WIEGE-STEINE, WERS, T. DAVON."}, {"heading": "42 Esra Erdem, Umut Oztok", "text": "GELFOND, M. AND LIFSCHITZ, V. 1991. Classical negation in logic programs and disjunctive databases. New Generation Computing 9, 365-385.GOWER, T. 2009. Reborn. Proto Magazine Summer, 14-19."}, {"heading": "KNOX, C., LAW, V., JEWISON, T., LIU, P., LY, S., FROLKIS, A., PON, A., BANCO, K., MAK, C.,", "text": "NEVEU, V., DJOUMBOU, Y., EISNER, R., GUO, A. C., AND WISHART, D. S. 2010. Drugbank 3.0: a comprehensive resource for \"omics\" research on drugs. Nucleic Acids Research 39, Database issue, D1035-D1041.KUHN, M., CAMPILLOS, M., LETUNIC, I., JENSEN, L. J., AND BORK, P. 2010. A side effect resource to capture phenotypic effects of drugs. Molecular Systems Biology 6, 343.LIFSCHITZ, V. 2002. Answer set programming and plan generation. Artificial Intelligence 138, 39-54.LIFSCHITZ, V. 2008. What is answer set programming? In Proc. of AAAI. MIT Press, 1594-1597. MAREK, V. AND TRUSZCZYN \u2012 SKI, M. 1999. Stable models and alternative programming year 70mlogic 3th programming Springer - Lodiginglogic Springer."}, {"heading": "MCDONAGH, E. M., WHIRL-CARRILLO, M., GARTEN, Y., ALTMAN, R. B., AND KLEIN, T. E.", "text": "2011. From Acquisition of Pharmacogenomic Knowledge to Clinical Applications: the PharmGKB as Clinical Pharmacogenomic Biomarker Resource. Biomarker in Medicine 5, 6, 795-806.NIEMEL\u00c4, I. 1999. Logic Programs with Stable Model Semantics as Restriction Programming Paradigm. Annals of Mathematics and Artificial Intelligence 25, 241-273.NOGUEIRA, M., BALDUCCINI, M., GELFOND, M., WATSON, R., AND BARRY, M. 2001. An A-Prolog Decision Support System for the Space Shuttle. In Proc. of PADL. Springer, 169-183.OETSCH, J., PUEHRER, J., AND TOMPITS, H. 2010. Catching the ouroboros: On debugging nonground answer-set programs. TPLP 10, 4-6, 513-S. PUEHRER, J., PUEHRER, J. PUE.J., P.P.P.P.MP.P.P.P.P...P.MP..P.P.P.MP.P...P.P...P.P.P.P.P.P.S.P.P.P.S., P.S., P.MP.P.P.P.P...P.S.P.S., P.S., P.P.S., P.P.S.P.P.P.S., P.S., P.S.P.P.P.S.P.P.S.P.P.P.S.P.S.P.S.P.S.P.P.P.S.P.S.P.S.P.P.S.P.S.P.S.P.S.P.P.S.P.S.P.S.P.S.P.P.S.P.S.P.S.P.S.P.P.S.P.S.P.P.S.P.S.P.S.P.P.P.S.P.P.P.P.S.P.P.S.P.P.P.P.P.P.P.P."}, {"heading": "RICCA, F., GRASSO, G., ALVIANO, M., MANNA, M., LIO, V., IIRITANO, S., AND LEONE, N.", "text": "2012. Team building with programming of response sets in the port of Gioia-Tauro. Theory and practice of logic programming 12."}, {"heading": "SCHRIML, L. M., ARZE, C., NADENDLA, S., CHANG, Y.-W. W., MAZAITIS, M., FELIX, V.,", "text": "FENG, G., AND KIBBE, W. A. 2012. Disease Ontology: a backbone for disease semantic integration. Nucleic Acids Research 40, Database issue, D940-D946.SIMONS, P., NIEMEL\u00c4, I., AND SOININEN, T. 2002. Extending and implementing the stable model semantics. Artificial Intelligence 138, 181-234.STARK, C., BREITKREUTZ, B.-J., REGULY, T., BOUCHER, L., BREITKREUTZ, A., AND TYERS, M. 2006. BioGRID: a general repository for interaction datasets. Nucleic Acids Research 34, Database issue, D535-D539.SYREUTZ, L., L., BREITKREUTZ, A., AND TYERS, M. 2006."}, {"heading": "Proof of Lemma 1", "text": "Suffice it to say that the recursion tree generated by algorithm 2 is finite, that is, the branching factor of the recursion tree and the height of the recursion tree are finite. Note that each node of the recursion tree means a call to createTree (2) for any atom or rule d and a series of atoms. Part (1) We show that the branching factor of the tree is finite. Branches in the tree are rendered in loops on lines 5 and 13. The loop on line 5 iterates at most the number of rules on line 5, and the loop on line 13 iterates at most the number of atoms on line 13. Since they are finite, the branching factor of the tree is finite.2 Part (2) We show that the height of the recursion tree on line 5 iterates at most the number of rules on line 3. Let us first make the following observation."}, {"heading": "Proof of Proposition 2", "text": "Algorithm 1 ends only when algorithms 2, 3, and 4 end. We know from Lemma 1 that Algorithm 2 ends and that the tree T labeled with a vertex returned by Algorithm 2 is finite. Since Algorithm 3 and Algorithm 4 simply traverse T (see lines 2 and 6 in Algorithm 3 and lines 5 and 10 in Algorithm 4), they also end. So ends Algorithm 1. A.1.2 Proof of Proposition 3 - Soundness of Algorithm 1To prove Proposition 3, we need the following necessary expressions. Lemma 2 Let us be an ASP basic program, X be an answer, be an atom in X or a rule in E, and L be a subset of X. If the vertex-labeled tree < V, E, l, X > is returned by createTree, then the following part of X and L is a subset of X."}, {"heading": "Proof of Lemma 2", "text": "Leave < V, E, L, X > the non-empty vertex-marked tree (V, X, D, L) is returned by createTree (V, V, D, L). We show one by one that every condition in the lemon (V, D, L) is an atom in X. Note that d / L, because otherwise < V, E > = < \u2205, \u2205 >. Caused by the call createTree (X, D, L), the algorithm, on line 3, creates a vertex v, so that l (v) = d. We know that E 6 = < 4, X >. Then there are some outgoing edges of v. In line 9, the outgoing edges of v are shaped. Because of line 8, each vertex v in (v, V) is the root of a vertex-marked tree. Also, there is no part of the algorithm that adds \"a parent\" to a tex."}, {"heading": "Proof of Lemma 3", "text": "(i) Let's assume d is an atom. (i) Let's assume d is an atom. (i) Then let's call createTree on line 6. Since L was not changed before this call, L = L.4 should be a basic ASP program. (ii) Let's assume d is a rule. (ii) Let's assume d is a rule. (i) Then let's call createTree on line 13. Since L was not changed before this call, let's say L is a basic ASP program, X a response for E and < V, E, L, L, L, E, Tree on line 13. Since L was not changed before this call, let's call createTree on line 4 be a basic ASP program, X an answer for E and < V, L, L, l, Tree on line and Tree on line 2."}, {"heading": "Proof of Lemma 4", "text": "Note that either d is an atom and d \u00b2 is a rule or vice versa. We show that the lemmas apply to the former case, the latter case can be represented in a similar way. Suppose d \u00b2 is an atom and d \u00b2 is a rule. Then, createTree must be called on line 6 within createTree. Since none of the calls on the path returns an empty tree with the vertex label, the condition on line 7 applies to createTree. Then, E is added an edge (v, v \u00b2) on line 9. Note that v is created in createTree (\u01d0, X, d, L) on line 3 and l (v) = d. Because of line 8, v \u00b2 is also the root of the tree labeled on line 9. Note that v is created in createTree."}, {"heading": "Proof of Lemma 5", "text": "Suppose T is not empty."}, {"heading": "Proof of Proposition 12", "text": "Suppose that T is not empty. We want to show that T is the and-or explanation tree for d in relation to \"V\" and \"X.\" For this, T must meet the conditions (i) \u2212 (iv) in definition 2. Since T is not empty, the conditions (i), (iii) and (iv) apply in relation to Lemma 2. To prove this, we show the state (ii) also in the sequence. Leave Sv = (v, v \") | (v, v\") in relation to E, l (v \") in relation to\" X, ancT, ancT (v \") in relation to\" X. \"Our goal is to show that for each atomic point v\" V, outE (v) = Sv. \"To do this, we show that outE (v) Sv and Sv\" outE (v) in relation to. \"6 in relation to\" V. \"6 in relation to\" v. \""}, {"heading": "Proof of Lemma 6", "text": "Note that recursive calls in line 5 and 10. Since the fifth parameter is a control vertex only when called in line 5, the call where v is added to V must be initiated in line 5. Then, due to line 3, WT (v) = min {WT (s) | s \u00b2 siblingET (v \u00b2)}.Lemma 7 Let us be an ASP program, X be a response for E, X = an atom in X, T = < VT, ET, l, E, X > the and / or explanation tree for d with respect to E and X, V, V the root of T, and < V, E, L, E > an atom in X, T = < VT, L, X > the and / or explanation tree with respect to T, and X, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V,"}, {"heading": "Proof of Lemma 7", "text": "Then the algorithm is called recursively on line 10 for each child of v1. Since (v1, v) and E (on line 4) c is a minimally weighted child of v (on line 3), we add (v1, c) and E (on line 4). Since (v, v2) and v2 are a minimally weighted child of v on line 6, c is equal to v2. Therefore, (v1, v2) and (v1, v2) applies to E.7 Lemma 8 Make it a basic ASP program, X is an answer set on line 1, d is an atom on X, T = < VT, ET, l, ECT, X > be the and / or explanation tree for d in relation to it and X, and then a string, algorithm on line 4 and vice versa."}, {"heading": "Proof of Lemma 8", "text": "Let us examine the root of T and S = < V, l, l, l, l, l, l, l, l, l, l, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V, V"}, {"heading": "Proof of Lemma 9", "text": "We prove the problem by induction at the height of a rule vertex in the declaration tree.Base case: Let u be a rule vertex in V \u00b2 at height 0. Then u \u00b2 is a leaf vertex. After the definition of the weight function, WT (u) = 1. Then (A3) applies to each rule vertex w \u00b2 in height n + 1. Leave w \u00b2 a rule vertex in height n + 1. Then, according to the definition of the weight function, WT (w) = ChildE (w) WT (w) (w \u00b2) applies. Let w \u00b2 be a rule vertex in height n + 1. Leave w \u00b2 a rule vertex in height n + 1. Then, WT (w) applies in the definition of the weight function WT (w) = X \u00b2 w \u00b2 in childE (w \u00b2). Let w \u00b2 be a child of w. Note that w \u00b2 is a control vertex. By defining an explanation tree, w \u00b2 in height W \u00b2 W and W \u00b2 in weight W \u00b2."}, {"heading": "Proof of Lemma 10", "text": "We would like to show that the weight of v, WT (v), is at most the number of regal leaks in V. Note that v is the root of T and there is exactly one vertex v (v), so v (by definition 3) v (v). Then we have WT (v) = min {WT (c) | c (by definition 6) \u2264 WT (v) (as v) childE (v)) \u2264 1 + | v (by definition 9) | (by Lemma 9) = | u | u is a rule vertex inV. \"(since v\" is the only child of v in T) Lemma 11 Let it be a basic ASP program, X is an answer set in X, p is an atom in X, T is the and / or explanation tree in relation to p and X, v is the root of T and > V, in relation to V, < V, V, V, V and V, V, and V, and V, and V."}, {"heading": "Proof of Lemma 11", "text": "We show that the weight of v, WT (v), is at most V. After defining an explanation, there is an explanation tree T \"(with vertices V\") of T, so that | V \"is a rule vertex inV.\" According to Lemma 10, WT (v) \u2264 \"V\" | V \"is a rule vertex inV.\" Therefore, WT (v) \u2264 | V. \"Lemma 12 Let us be a basic ASP program, X > be an explanation tree in T, p\" an atom in X, T = < V, E, l, \"and X > the and / or explanation tree for p in relation to E\" and X \"and T\" < V, \"E, l,\" X > an explanation tree in T. \"If we use WT (v) \u2264 min {WT (s) | s\" siblingE (v) and T. \"4) for each rule following V.\""}, {"heading": "Proof of Lemma 12", "text": "Let us assume that (A4) applies to each rule that (V) is an explanation. (Then we prove the problem by inducing at the height of a rule vertex in the explanation. (V) If we assume that for each rule vertex i (V) in height is smaller than n, (A5) applies that (A5) for each rule vertex w (V) in height n + 1. Let us assume that for each rule vertex i (V) in height is smaller than n, (A5) w w w applies. We show that (A5) for each rule vertex w (V) in height n + 1. Let us assume that w (V) is a rule vertex in height n + 1. Then Lemberg i (V) is in the definition of the weight function WT (w) = 1 + W (W) in the definition WT."}, {"heading": "Proof of Lemma 13", "text": "Then we want to show that the weight of v, WT (v), corresponds to the number of regal leaks in V. Note that v is the root of T and that there is exactly one vertex v, \"V,\" so that v, \"childE (v) (according to definition 3). Then we have WT (v) = min {WT (c) | c\" childE (v)} (according to definition 6) = WT (v \") (according to (A6)) = 1 + | u,\" desT \"(v\") | (according to Lemma 12) = | u | u is a rule point inV. \"(since v is\" the only child of v in T. \") We are now ready to prove Proposition 3."}, {"heading": "Proof of Proposition 3", "text": "Algorithm 1 has two explanations; lines 6 and 8. On line 8, it returns an empty tree labeled V. We show that what algorithm 1 returns on line 6, S = < V \u2032, E \u2032, l \u2032, X > is an explanation for p in terms of \"X\" and \"X,\" and that there is no other explanation for p in terms of \"X\" and \"X,\" so that the tree on line 1 is not empty. Then, on line 12, we know that T is the and / or explanation tree for p in terms of \"X\" and \"X.\" Then, on line 8, we know that < V \u2032, l, X > in line 5 is an explanation for p in terms of \"and\" X. \"Now, let's assume that there is another explanation for p in terms of\" and \"X,\" in line V. \""}, {"heading": "Proof of Proposition 4", "text": "In line 1, algorithm 2 is called. This algorithm creates the and / or explanation tree recursively. As shown in line 5, the branching factor of a vertex in the recursion tree is O (max. | X | |}) and the height of the tree is O (max. | X |). Also in line 5, we check whether a rule in line 1 supports the d in O (| Bump |]. Thus, the temporal complexity of algorithm 2 shows in the worst case O (max."}, {"heading": "Proof of Proposition 5", "text": "To show that algorithm 5 ends, we must show that the loop ends between lines 4-10. On the basis of line 4, the loop iterates at most k times. If it iterates less than k times, this means that it ends at line 6. So let's assume that it iterates k times. Then, it is enough to show that every iteration of the loop ends. Consider the ith (1 \u2264 i \u2264 k) iteration of the loop. First, at line 5, algorithm 6 is invoked. Note that this algorithm simply traverses the and / or explanation tree T created in line 2 (compare lines 2, 3, 8 and 9 in algorithm 6). Since T is infinite, algorithm 6 is terminated at line 7. Similar to algorithm 6, this part of the X loop is simply linked to verse 3."}, {"heading": "Proof of Proposition 13", "text": "Let < V, E, l, X > be the output of algorithm 2. By condition (i) in definition 2, the root of T is an atomic vertex with caption p. Since p is in X and L = \u2205 at the beginning of algorithm 2, a vertex v is generated with caption p in line 3 and in V in line 4. Take an atomic vertex v, V. Note that the specified L in algorithm 2 is essentially ancT (v), and l (v) that l (v) (v)) is (due to condition (ii) in definition 2. Note that the specified L in algorithm 2 is essentially ancT (v), and l (v) that the condition X (v), L (v), l (v)) is the condition in line 5.13Furthermore, we must make sure that v is a rule point."}, {"heading": "Proof of Lemma 14", "text": "Consider the ith (1 \u2264 i \u2264 min {n, k}) iteration of the loop. In line 5, we call algorithm 6 and calculate WT, Ri \u2212 1 for each vertex v in V. According to algorithm 6, for an atomic vertex v, V, based on line 4, WT, Ri \u2212 1 (v) = max {WT, Ri \u2212 1 (v \u2032) | v \u00b2, where xu \u2212 1, if u \u2212 Ri \u2212 1, xu = 0 otherwise. Let us leave v an atomic vertex in V, Ri \u2212 1 (u) = xu \u00b2 u \u00b2, KinderE (u), Ri \u2212 1 (u \u2212 1), if u \u2212 1, xu = 0 otherwise. Let us leave v an atomic vertex in V,. Let us leave {v \u2032 1, v \u00b2, v \u00b2, v \u00b2, v \u00b2, a series of rule inversions in WT, v."}, {"heading": "Proof of Proposition 6", "text": "First, we assume that n \u2265 k. Then we show that algorithm 5 on line 11 contains a series of K different explanations for p with respect to \"and\" X. \"< p > p > p > p (line 4-10) However, since this loop iterates k-times, we must show that two properties apply to each iteration: (i) for each iteration i < j \u2264 k), Ki and Kj are different. (i) For each iteration i (1) and X (ii) for all iterations i, j (1 \u2264 i < j \u2264 k), Ki and Kj are different. Below, we consider these two properties. (1 \u2264 i), Ki is formed in line 8. According to line 7, Ki is an output of algorithm 4. Then, based on Lemma 8, we conclude that Ki is an explanation for p with respect to X and.\""}, {"heading": "Proof of Lemma 15", "text": "We prove the problem by induction at the level of a rule vertex in the declaration tree.Base case: Let v be a rule vertex in height 0. Then, (A7) is a leaf vertex. By Definition 18, WT, R (v) = xv = 1 if v / 2 if v / 0 else. Then, (A7) is a leaf vertex in height n + 1. Let v be a rule vertex in height n + 1. Then, by Definition 18, WT, R (v) = 1 if v / 1, (A7) holds. We show that (A7) for each rule vertex v \u00b2 v \u00b2 V \u00b2 is valid in height n + 1. Let v be a rule vertex in height n + 1. Then, by Definition 18, WT (v) = xv + 2 children in height v \u00b2."}, {"heading": "Proof of Lemma 16", "text": "We would like to show that WT, R (v) corresponds at least to the number of control nodes in V, but R. Let us remember that v is the root of T and there is exactly one vertex v (V), so that v (v) (due to the condition (iii) in definition 3). Then let us consider two cases. Case 1. Let us suppose that v (v) / V (v) follows. Then we can deduce the following. WT, (v) = max (WT), R (|) childE (according to definition 18) \u2265 WT, R (v) (as) < v (v) \u0432\u043e\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0438\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441"}, {"heading": "Proof of Lemma 17", "text": "We show that WT, R (v) is equal at least | RVertices (T \u2032)\\ R |. According to definition 4, there is an explanation tree T \u2032 (with vertices V \u2032) in T, so V \u2032 = {v \u2032 | v \u2032 is a rule vertex inV \u2032}. That is, RVertices (T \u2032) = RVertices (T \u2032). According to Lemma 16, we know that WT, R (v) \u2265 | {u | u (RVertices (T \u2032)\\ R)}} |. Therefore, we conclude that WT, R (v) \u2265 | RVertices (T \u2032)\\ R |.We can now prove our main result, which simply indicates that for each iteration i the loop in algorithm 5 maximizes the distance \u0445D (Ri \u2212 1, Ki \u2212 tices).Proposal 7 Let it be an ASP program, X is an answer to each iteration i \u00b2 in relation to the respective vertices (K) and then a K."}, {"heading": "Proof of Proposition 7", "text": "The proof is a contradiction. Suppose there is an explanation K \u00b2, so \u2206 D (Ri \u2212 1, RVertices (Ki) < \u2206 D (Ri \u2212 1, RVertices (K \u2032))), that is, | RVertices (K \u2032)\\ Ri \u2212 1 | > | RVertices (Ki)\\ Ri \u2212 1 |. Let us vr be the root of T."}, {"heading": "Proof of Corollary 1", "text": "Since k = 1, the loop in algorithm 5 iterates once. In this iteration, at Proposition 6, we know that an explanation K1 is calculated for p in relation to \u0442 and X. In Proposition 7, we also know that \u2206 D (R0, RVertices (K1)) is maximized, meaning that there is no explanation K \u00b2 for p in relation to \u0442 and X in relation to | RVertices (K \u2032) | > | RVertices (K1) |. Since each vertex of an explanation is a rule vertex, we conclude that R0 is an empty set. Therefore, there is no explanation K \u00b2 for p in relation to \u0438 and X such that | RVertices (K \u2032) | | RVertices (K1) |. Since each vertex of an explanation is a rule vertex, we have come to the conclusion that K1 is an explanation for p and X.18Next is an explanation for p."}, {"heading": "Proof of Corollary 2", "text": "Through Proposition 6 we know that K1,.., Kmin {n, k} are different explanations for each i (2 \u2264 i \u2264 min {n, k}) min {n, k} for p in relation to \u0430 and X. Furthermore, through Proposition 7 we obtain for each i (2 \u2264 i \u2264 min {n, k}) that \u2206 D (Ri \u2212 1, Ki) is maximized. On the basis of lines 1 and 10 of algorithm 5, Ri \u2212 1 = i \u2212 1 j = 0 RVertices (Kj). Since R0 is an empty quantity, we conclude that \u2206 D (i \u2212 1 j = 1 RVertices (Kj), Ki) can be maximized.A.2.4 Proof Proposition 8 - Complexity of algorithm 5We prove that the time complexity of the algorithm 5 is exponentially in the size of the given response set.Proposition 8 In a basic ASP program, an answer X, an atom, and an integer in relation to the time of the algorithm 5."}, {"heading": "Proof of Proposition 8", "text": "Algorithm 5 calls algorithm 2 on line 2. In the proof of Proposition 4 it is shown that the worst possible time complexity of algorithm 2 on line 4-10 iterates at most k times. In each iteration of the loop, algorithm 6 and algorithm 4 on line 5 and 7 become recursive. Algorithm 6 simply passes through the and / or explanation tree T (compare lines 2, 3, 8 and 9 in algorithm 6). The height of T is O (compare line 6) and the branching factor of a vertex in T is simple O (compare line 8 in algorithm 6, 3, 8 and 9 in algorithm 6). The height of T is O (compare line 6) and the branching factor in line X (compare line 8 in algorithm 6), we check whether a rule vertex in R. Like R is a subset of rule branches in V, we can see line 6."}, {"heading": "Proof of Lemma 18", "text": "Since vi + 1 is an atom vertex, its outgoing edges are formed in line 15 of algorithm 7. Since vi + 1 is a rule vertex, its outgoing edges are formed in line 10. Then, vi + 2 is an atom vertex based on lines 8 and 9, with l (vi + 2), l (vi + 2), l (vi + 1))). Since B (l (vi + 1) = support (l (vi) +, G) and l (vi + 2) by definition 10, (l (vi) +, l (vi + 2) +, +) and L (lt.3) Let us be a normal ASP program, X < p is an answer to the question whether an atom in X, a justification in U G, an assumption in V, an assumption in V, an assumption in V (T), an assumption in V, an assumption in V (V) and an assumption in V (V)."}, {"heading": "Proof of Corollary 3", "text": "Note that an edge in E \u00b2 is defined either by an atom vertex to a rule vertex, or vice versa, based on lines 10 and 15 of algorithm 7. According to this observation, vi is an atom vertex (or rule vertex) if i is an odd number (or an even number), so for 1 \u2264 i \u2264 n \u2212 2 and i mod 2 there is 6 = 0 (i.e., i is an odd number), (l (vi) +, l (vi + 2) +, +), so there is a positive path l (v1) +, l (v3) +, l (v5) +,.. l (v + n \u2212 2), l (vn) + in G. That is, l (vn) is reachable from l (v1) + by a positive path in G. Lemma 19 Leave some measure for a normal P (vn \u2212 2), an answer in V, v \u00b2 in a row v \u00b2, v \u00b2 in V."}, {"heading": "Proof of Lemma 19", "text": "The proof is by induction on the length of the S. base case: Suppose that S has two elements, i.e., S = < v1 = v, v2 >. Since v is the first vertex recorded by definition in Q, it is the first vertex added by Q in line 5. Since v is an atomic vertex, the second vertex is added by definition in line 16."}, {"heading": "Proof of Proposition 10", "text": "We show what algorithm 7 returns to line 17, when it is inserted into the queue, then to line 3. We show what algorithm 7 returns to line 17, T \u2032 = < V \u2032, E \u2032, Q \u2032, Q >, Q >, is an explanation tree in the and-or explanation tree T = < VT \u2032, ET \u2032, L \u2032, X \u2032, for P in relation to H and X. That is, T \u2032 fulfills the conditions (i) - (iv) in definition 3. In the following, we examine each condition separately.21 (ii) to show that the root of < V \u2032, E > is a vertex whose designation is p, we must show three cases we hold; (1) there is a vertex v in V \u2032 with the designation p, (2) each vertex v. \"V\" is reachable by a path in T \u2032. (3) v has no incoming element in Qom. In the following, we show that everyone holds."}, {"heading": "Proof of Proposition 1", "text": "With sentence 9 we know that there is an offline justification of p + in relation to X and X \u2212\\ WF \u2212 and an explanation tree for p in relation to \u0438 and X. That is, the and-or explanation tree for p in relation to \u0438 and Xis not empty.A.3.2 Proof of sentence 11 - Solidity of algorithm 8Before we provide the proof for sentence 11, we provide the necessary dimmata. Lemma 20 Let us be a normal ASP program for p, X be an answer in relation to \u0438, p be an atom in X, T = < V \u2032, E \u2032, l, \u0430, X > be an explanation tree in relation to p and X, so that for each v, v \u00b2, v \u00b2 V \u00b2 V \u2032, l (v) = l (v \u00b2), if and only, (V, E) the output of algorithm 8 is mentioned with inputs, X and T, v \u00b2 V (v2) and vlt3 (vlt3)."}, {"heading": "Proof of Lemma 20", "text": "All nodes, except the one labeled >, are added to V. Since l (v1) + val V, v1 is extracted from the queue Q on line 4. Since < v1, v2, v3 > is a path in T, and every atom vertex in V has exactly one child due to the condition (iii) on line 3, v2 is extracted on line 6. Because of the condition on line 9, every child of v2 is then considered in the loop. Accordingly, in line 10 the edge (l (v1) +, l (v3) +, + in E. In addition, v3 is added to Q on line 11. Then, due to the condition on line 3 and the statements on line 4 and 5 l (v3) + ltV."}, {"heading": "Proof of Corollary 4", "text": "Since < v1, v2, v3 > is a path in T and l (v1) + V, of Lemma 20, (l (v1) +, l (v3) +, l (v3) +, l (v3) +, l (v5) +, l (v5) +, l (v5) +, l (v5) +, + \u00b2 (v5) E and l (v5) +. Then this step-by-step application of Lemma 20 results in < l (v1) +, l (v3) +, l (v5) +, l (v5) V V V, + > a path in (V, E). We now prove that the 8 algorithm creates an offline justification of the given atom in the reduction of the given ASP program with respect to the given response quantity V V V V V V V V, V > a path in (vn) V V V \u00b2 V V V, V \u00b2 V \u00b2 V V V, V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V, V \u00b2 V \u00b2 V \u00b2 V, V, V \u00b2 V"}, {"heading": "Proof of Proposition 11", "text": "To show that the output (V, E) of algorithm 8 on line 13 is an offline justification of p + in relation to X and V, one must show that the following conditions apply. (1) < (2) (V, E) is an offline E graph for X; (3) (V, E) is an (X, E) -based E graph of p +; (4) (V, E) is an offline E graph of p + in relation to X and. Condition (1) We show that this graph (X, X) is a positive program, i.e. it does not contain negative atoms, by definition 14, T, X (X) is an offline graph of p +."}], "references": [{"title": "Logic programming and negation: A survey", "author": ["APT K.R.", "BOL R.N."], "venue": "J. Log. Program. 19/20, 9\u201371.", "citeRegEx": "R. and N.,? 1994", "shortCiteRegEx": "R. and N.", "year": 1994}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. BARAL"], "venue": "Cambridge University Press.", "citeRegEx": "BARAL,? 2003", "shortCiteRegEx": "BARAL", "year": 2003}, {"title": "A preliminary report on answering complex queries related to drug discovery using answer set programming", "author": ["O. BODENREIDER", "Z.H. COBAN", "M.C. DOGANAY", "E. ERDEM", "H. KOSUCU"], "venue": "Proc. of ALPSWS.", "citeRegEx": "BODENREIDER et al\\.,? 2008", "shortCiteRegEx": "BODENREIDER et al\\.", "year": 2008}, {"title": "Debugging logic programs under the answer set semantics", "author": ["M. BRAIN", "M.D. VOS"], "venue": "Proc. of ASP.", "citeRegEx": "BRAIN and VOS,? 2005", "shortCiteRegEx": "BRAIN and VOS", "year": 2005}, {"title": "Answer set programming at a glance", "author": ["G. BREWKA", "T. EITER", "M. TRUSZCZYNSKI"], "venue": "Commun. ACM 54, 12, 92\u2013103.", "citeRegEx": "BREWKA et al\\.,? 2011", "shortCiteRegEx": "BREWKA et al\\.", "year": 2011}, {"title": "New uses for old drugs", "author": ["C.R. CHONG", "D.J. SULLIVAN"], "venue": "Nature 448, 645\u2013646.", "citeRegEx": "CHONG and SULLIVAN,? 2007", "shortCiteRegEx": "CHONG and SULLIVAN", "year": 2007}, {"title": "The Comparative Toxicogenomics Database: update 2011", "author": ["A.P. DAVIS", "B.L. KING", "S. MOCKUS", "C.G. MURPHY", "C. SARACENI-RICHARDS", "M. ROSENSTEIN", "T. WIEGERS", "C.J. MATTINGLY"], "venue": "Nucleic Acids Research 39, Database issue, D1067\u2013D1072.", "citeRegEx": "DAVIS et al\\.,? 2011", "shortCiteRegEx": "DAVIS et al\\.", "year": 2011}, {"title": "Effective integration of declarative rules with external evaluations for Semantic-Web reasoning", "author": ["T. EITER", "G.IANNI", "R.SCHINDLAUER", "H.TOMPITS."], "venue": "Proc. of ESWC.", "citeRegEx": "EITER et al\\.,? 2006", "shortCiteRegEx": "EITER et al\\.", "year": 2006}, {"title": "Finding answers and generating explanations for complex biomedical queries", "author": ["E. ERDEM", "Y. ERDEM", "H. ERDOGAN", "U. OZTOK"], "venue": "Proc. of AAAI.", "citeRegEx": "ERDEM et al\\.,? 2011", "shortCiteRegEx": "ERDEM et al\\.", "year": 2011}, {"title": "BIOQUERY-ASP: Querying biomedical ontologies using answer set programming", "author": ["E. ERDEM", "H. ERDOGAN", "U. OZTOK"], "venue": "Proc. of RuleML2011@BRF Challenge.", "citeRegEx": "ERDEM et al\\.,? 2011", "shortCiteRegEx": "ERDEM et al\\.", "year": 2011}, {"title": "Transforming controlled natural language biomedical queries into answer set programs", "author": ["E. ERDEM", "R. YENITERZI"], "venue": "Proc. of the Workshop on BioNLP. 117\u2013124.", "citeRegEx": "ERDEM and YENITERZI,? 2009", "shortCiteRegEx": "ERDEM and YENITERZI", "year": 2009}, {"title": "Weight constraints as nested expressions", "author": ["P. FERRARIS", "V. LIFSCHITZ"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374.", "citeRegEx": "FERRARIS and LIFSCHITZ,? 2005", "shortCiteRegEx": "FERRARIS and LIFSCHITZ", "year": 2005}, {"title": "Advances in gringo series 3", "author": ["M. GEBSER", "R. KAMINSKI", "A. KOENIG", "T. SCHAUB"], "venue": "Proc of. LPNMR. Vol. 6645. 345\u2013351.", "citeRegEx": "GEBSER et al\\.,? 2011", "shortCiteRegEx": "GEBSER et al\\.", "year": 2011}, {"title": "clasp: A conflict-driven answer set solver", "author": ["M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB"], "venue": "Proc. of LPNMR. 260\u2013265.", "citeRegEx": "GEBSER et al\\.,? 2007", "shortCiteRegEx": "GEBSER et al\\.", "year": 2007}, {"title": "A meta-programming technique for debugging answer-set programs", "author": ["M. GEBSER", "J. PUEHRER", "T. SCHAUB", "H. TOMPITS"], "venue": "Proc. of AAAI.", "citeRegEx": "GEBSER et al\\.,? 2008", "shortCiteRegEx": "GEBSER et al\\.", "year": 2008}, {"title": "The well-founded semantics for general logic programs", "author": ["A.V. GELDER", "K.A. ROSS", "J.S. SCHLIPF"], "venue": "J. ACM 38, 3, 620\u2013650.", "citeRegEx": "GELDER et al\\.,? 1991", "shortCiteRegEx": "GELDER et al\\.", "year": 1991}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proc. of ICLP. MIT Press, 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1991", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1991}, {"title": "Born again", "author": ["T. GOWER"], "venue": "Proto Magazine Summer, 14\u201319.", "citeRegEx": "GOWER,? 2009", "shortCiteRegEx": "GOWER", "year": 2009}, {"title": "A side effect resource to capture phenotypic effects of drugs", "author": ["M. KUHN", "M. CAMPILLOS", "I. LETUNIC", "L.J. JENSEN", "P. BORK"], "venue": "Molecular Systems Biology 6, 343.", "citeRegEx": "KUHN et al\\.,? 2010", "shortCiteRegEx": "KUHN et al\\.", "year": 2010}, {"title": "Answer set programming and plan generation", "author": ["V. LIFSCHITZ"], "venue": "Artificial Intelligence 138, 39\u201354.", "citeRegEx": "LIFSCHITZ,? 2002", "shortCiteRegEx": "LIFSCHITZ", "year": 2002}, {"title": "What is answer set programming? In Proc", "author": ["V. LIFSCHITZ"], "venue": "of AAAI. MIT Press, 1594\u20131597.", "citeRegEx": "LIFSCHITZ,? 2008", "shortCiteRegEx": "LIFSCHITZ", "year": 2008}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. MAREK", "M. TRUSZCZY\u0143SKI"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013 398.", "citeRegEx": "MAREK and TRUSZCZY\u0143SKI,? 1999", "shortCiteRegEx": "MAREK and TRUSZCZY\u0143SKI", "year": 1999}, {"title": "From pharmacogenomic knowledge acquisition to clinical applications: the PharmGKB as a clinical pharmacogenomic biomarker resource", "author": ["E.M. MCDONAGH", "M. WHIRL-CARRILLO", "Y. GARTEN", "R.B. ALTMAN", "T.E. KLEIN"], "venue": "Biomarkers in Medicine 5, 6, 795\u2013806.", "citeRegEx": "MCDONAGH et al\\.,? 2011", "shortCiteRegEx": "MCDONAGH et al\\.", "year": 2011}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. NIEMEL\u00c4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273.", "citeRegEx": "NIEMEL\u00c4,? 1999", "shortCiteRegEx": "NIEMEL\u00c4", "year": 1999}, {"title": "An A-Prolog decision support system for the space shuttle", "author": ["M. NOGUEIRA", "M. BALDUCCINI", "M. GELFOND", "R. WATSON", "M. BARRY"], "venue": "Proc. of PADL. Springer, 169\u2013183.", "citeRegEx": "NOGUEIRA et al\\.,? 2001", "shortCiteRegEx": "NOGUEIRA et al\\.", "year": 2001}, {"title": "Catching the ouroboros: On debugging nonground answer-set programs", "author": ["J. OETSCH", "J. PUEHRER", "H. TOMPITS"], "venue": "TPLP 10, 4-6, 513\u2013529.", "citeRegEx": "OETSCH et al\\.,? 2010", "shortCiteRegEx": "OETSCH et al\\.", "year": 2010}, {"title": "Stepping through an answer-set program", "author": ["J. OETSCH", "J. PUEHRER", "H. TOMPITS"], "venue": "LPNMR. 134\u2013147.", "citeRegEx": "OETSCH et al\\.,? 2011", "shortCiteRegEx": "OETSCH et al\\.", "year": 2011}, {"title": "Generating explanations for complex biomedical queries", "author": ["U. OZTOK"], "venue": null, "citeRegEx": "OZTOK,? \\Q2012\\E", "shortCiteRegEx": "OZTOK", "year": 2012}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. PONTELLI", "T.C. SON", "O. EL-KHATIB"], "venue": "Theory and Practice of Logic Programming, 1\u201356.", "citeRegEx": "PONTELLI et al\\.,? 2009", "shortCiteRegEx": "PONTELLI et al\\.", "year": 2009}, {"title": "Team-building with answer set programming in the Gioia-Tauro seaport", "author": ["F. RICCA", "G. GRASSO", "M. ALVIANO", "M. MANNA", "V. LIO", "S. IIRITANO", "N. LEONE"], "venue": "Theory and Practice of Logic Programming 12.", "citeRegEx": "RICCA et al\\.,? 2012", "shortCiteRegEx": "RICCA et al\\.", "year": 2012}, {"title": "Disease Ontology: a backbone for disease semantic integration", "author": ["L.M. SCHRIML", "C. ARZE", "S. NADENDLA", "CHANG", "Y.-W.W.", "M. MAZAITIS", "V. FELIX", "G. FENG", "W.A. KIBBE"], "venue": "Nucleic Acids Research 40, Database issue, D940\u2013D946.", "citeRegEx": "SCHRIML et al\\.,? 2012", "shortCiteRegEx": "SCHRIML et al\\.", "year": 2012}, {"title": "Extending and implementing the stable model semantics", "author": ["P. SIMONS", "I. NIEMEL\u00c4", "T. SOININEN"], "venue": "Artificial Intelligence 138, 181\u2013234.", "citeRegEx": "SIMONS et al\\.,? 2002", "shortCiteRegEx": "SIMONS et al\\.", "year": 2002}, {"title": "BioGRID: a general repository for interaction datasets", "author": ["C. STARK", "BREITKREUTZ", "B.-J.", "T. REGULY", "L. BOUCHER", "A. BREITKREUTZ", "M. TYERS"], "venue": "Nucleic Acids Research 34, Database issue, D535\u2013D539.", "citeRegEx": "STARK et al\\.,? 2006", "shortCiteRegEx": "STARK et al\\.", "year": 2006}, {"title": "Debugging inconsistent answer set programs", "author": ["T. SYRJANEN"], "venue": "Proc. of NMR.", "citeRegEx": "SYRJANEN,? 2006", "shortCiteRegEx": "SYRJANEN", "year": 2006}, {"title": "A practical tool for mass-customising configurable products", "author": ["J. TIIHONEN", "T. SOININEN", "R. SULONEN"], "venue": "Proc. of the International Conference on Engineering Design. 1290\u2013 1299.", "citeRegEx": "TIIHONEN et al\\.,? 2003", "shortCiteRegEx": "TIIHONEN et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 8, "context": ", representing complex queries in natural language and finding answers to queries efficiently), novel methods and a software system, called BIOQUERY-ASP (Erdem et al. 2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al.", "startOffset": 153, "endOffset": 172}, {"referenceID": 20, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 1, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 21, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 4, "context": "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):", "startOffset": 73, "endOffset": 180}, {"referenceID": 10, "context": "\u2022 Erdem and Yeniterzi (Erdem and Yeniterzi 2009) developed a controlled natural language, BIOQUERY-CNL, for expressing biomedical queries related to drug discovery.", "startOffset": 22, "endOffset": 48}, {"referenceID": 2, "context": "(Bodenreider et al. 2008) introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer.", "startOffset": 0, "endOffset": 25}, {"referenceID": 8, "context": "(Erdem et al. 2011) have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query.", "startOffset": 0, "endOffset": 19}, {"referenceID": 23, "context": "Next, Section 7 illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources PHARMGKB (McDonagh et al. 2011), DRUGBANK (Knox et al.", "startOffset": 136, "endOffset": 158}, {"referenceID": 33, "context": "BIOGRID (Stark et al. 2006), CTD (Davis et al.", "startOffset": 8, "endOffset": 27}, {"referenceID": 6, "context": "2006), CTD (Davis et al. 2011), SIDER (Kuhn et al.", "startOffset": 11, "endOffset": 30}, {"referenceID": 19, "context": "2011), SIDER (Kuhn et al. 2010), DISEASE ONTOLOGY (Schriml et al.", "startOffset": 13, "endOffset": 31}, {"referenceID": 31, "context": "2010), DISEASE ONTOLOGY (Schriml et al. 2012) and ORPHADATA.", "startOffset": 24, "endOffset": 45}, {"referenceID": 29, "context": "In Section 10, we provide a detailed analysis of the related work on \u201cjustifications\u201d (Pontelli et al. 2009) in comparison to explanations; and in Section 11, we briefly discuss other related work.", "startOffset": 86, "endOffset": 108}, {"referenceID": 20, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 1, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 21, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 4, "context": "Answer Set Programming (ASP) (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.", "startOffset": 29, "endOffset": 136}, {"referenceID": 16, "context": "The idea is to represent a problem as a \u201cprogram\u201d whose models (called \u201canswer sets\u201d (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.", "startOffset": 85, "endOffset": 141}, {"referenceID": 17, "context": "The idea is to represent a problem as a \u201cprogram\u201d whose models (called \u201canswer sets\u201d (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.", "startOffset": 85, "endOffset": 141}, {"referenceID": 13, "context": "ASP also provides efficient solvers, such as CLASP (Gebser et al. 2007).", "startOffset": 51, "endOffset": 71}, {"referenceID": 25, "context": "Here are, for instance, three applications of ASP used in industry: \u2022 Decision Support Systems: An ASP-based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks (Nogueira et al. 2001) (used by United Space Alliance).", "startOffset": 215, "endOffset": 237}, {"referenceID": 35, "context": "\u2022 Automated Product Configuration: A web-based commercial system uses an ASPbased product configuration technology (Tiihonen et al. 2003) (used by Variantum Oy).", "startOffset": 115, "endOffset": 137}, {"referenceID": 30, "context": ", skills, fairness, regulations (Ricca et al. 2012) (used by Gioia Tauro seaport).", "startOffset": 32, "endOffset": 51}, {"referenceID": 21, "context": "The idea of ASP (Lifschitz 2008) is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem, and to find the answer sets for that program using an answer set solver.", "startOffset": 16, "endOffset": 32}, {"referenceID": 32, "context": "(called cardinality expressions) where each Ai is an atom and l and u are nonnegative integers denoting the \u201clower bound\u201d and the \u201cupper bound\u201d (Simons et al. 2002).", "startOffset": 144, "endOffset": 164}, {"referenceID": 11, "context": "Programs using these constructs can be viewed as abbreviations for normal nested programs defined in (Ferraris and Lifschitz 2005).", "startOffset": 101, "endOffset": 130}, {"referenceID": 12, "context": "For CLASP, we use the \u201cgrounder\u201d GRINGO (Gebser et al. 2011).", "startOffset": 40, "endOffset": 60}, {"referenceID": 8, "context": "We have earlier developed the software system BIOQUERY-ASP (Erdem et al. 2011) (see Figure 1) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drugdrug interactions, cliques of genes based on gene-gene relations, or similar/diverse genes.", "startOffset": 59, "endOffset": 78}, {"referenceID": 7, "context": "If the biomedical ontology is in RDF(S)/OWL then we can extract such knowledge using the ASP solver DLVHEX (Eiter et al. 2006) by making use of external predicates.", "startOffset": 107, "endOffset": 126}, {"referenceID": 5, "context": "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer\u2019s Viagra (Gower 2009).", "startOffset": 69, "endOffset": 94}, {"referenceID": 18, "context": "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer\u2019s Viagra (Gower 2009).", "startOffset": 205, "endOffset": 217}, {"referenceID": 8, "context": "Once the query and the rule layer are in ASP, the parts of the rule layer that are relevant to the given query are identified by an algorithm (Erdem et al. 2011).", "startOffset": 142, "endOffset": 161}, {"referenceID": 29, "context": "The most similar work to ours is (Pontelli et al. 2009) that study the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d.", "startOffset": 33, "endOffset": 55}, {"referenceID": 29, "context": "As an answer to this question, the authors of (Pontelli et al. 2009) finds a \u201cjustification\u201d, which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set.", "startOffset": 46, "endOffset": 68}, {"referenceID": 29, "context": "To relate offline justifications and explanations, we need to introduce the following definitions and notations about justifications defined in (Pontelli et al. 2009).", "startOffset": 144, "endOffset": 166}, {"referenceID": 29, "context": "First, let us introduce notations related to ASP programs used in (Pontelli et al. 2009).", "startOffset": 66, "endOffset": 88}, {"referenceID": 15, "context": "Apart from the answer set semantics, there is another important semantics of logic programs, called the well-founded semantics (Gelder et al. 1991).", "startOffset": 127, "endOffset": 147}, {"referenceID": 15, "context": "We consider the definition proposed in (Apt and Bol 1994), instead of the original definition proposed in (Gelder et al. 1991), as the authors of (Pontelli et al.", "startOffset": 106, "endOffset": 126}, {"referenceID": 29, "context": "1991), as the authors of (Pontelli et al. 2009) considered.", "startOffset": 25, "endOffset": 47}, {"referenceID": 29, "context": "In (Pontelli et al. 2009), the authors prove the following proposition which shows that for every atom in the program, there exists an offline justification.", "startOffset": 3, "endOffset": 25}, {"referenceID": 34, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al.", "startOffset": 13, "endOffset": 28}, {"referenceID": 14, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.", "startOffset": 84, "endOffset": 124}, {"referenceID": 26, "context": "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.", "startOffset": 84, "endOffset": 124}, {"referenceID": 3, "context": "In (Brain and Vos 2005), similar to our work, the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d is studied.", "startOffset": 3, "endOffset": 23}, {"referenceID": 3, "context": "As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in \u03a0 that supports X with respect to \u03a0; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules).", "startOffset": 46, "endOffset": 66}, {"referenceID": 27, "context": "In (Oetsch et al. 2011), a framework where the users can construct interpretations through an interactive stepping process is introduced.", "startOffset": 3, "endOffset": 23}, {"referenceID": 29, "context": "As a result, (Pontelli et al. 2009) and (Oetsch et al.", "startOffset": 13, "endOffset": 35}, {"referenceID": 27, "context": "2009) and (Oetsch et al. 2011) can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping.", "startOffset": 10, "endOffset": 30}, {"referenceID": 3, "context": "In (Brain and Vos 2005), similar to our work, the question \u201cwhy is an atom p in an answer set X for an ASP program \u03a0\u201d is studied. As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in \u03a0 that supports X with respect to \u03a0; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules). Pontelli et al. (2009) also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set.", "startOffset": 4, "endOffset": 382}], "year": 2013, "abstractText": "We introduce novel mathematical models and algorithms to generate (shortest or k different) explanations for biomedical queries, using answer set programming. We implement these algorithms and integrate them in BIOQUERY-ASP. We illustrate the usefulness of these methods with some complex biomedical queries related to drug discovery, over the biomedical knowledge resources PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA.", "creator": "LaTeX with hyperref package"}}}