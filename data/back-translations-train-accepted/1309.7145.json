{"id": "1309.7145", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Sep-2013", "title": "Propagating Regular Counting Constraints", "abstract": "Constraints over finite sequences of variables are ubiquitous in sequencing and timetabling. Moreover, the wide variety of such constraints in practical applications led to general modelling techniques and generic propagation algorithms, often based on deterministic finite automata (DFA) and their extensions. We consider counter-DFAs (cDFA), which provide concise models for regular counting constraints, that is constraints over the number of times a regular-language pattern occurs in a sequence. We show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints based on the frequent case of a cDFA with only accepting states and a single counter that can be incremented by transitions. We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3]. Regular counting constraints are closely related to the CostRegular constraint but contribute both a natural abstraction and some computational advantages.", "histories": [["v1", "Fri, 27 Sep 2013 08:23:52 GMT  (26kb)", "http://arxiv.org/abs/1309.7145v1", "Includes a SICStus Prolog source file with the propagator"]], "COMMENTS": "Includes a SICStus Prolog source file with the propagator", "reviews": [], "SUBJECTS": "cs.AI cs.FL", "authors": ["nicolas beldiceanu", "pierre flener", "justin pearson", "pascal van hentenryck"], "accepted": true, "id": "1309.7145"}, "pdf": {"name": "1309.7145.pdf", "metadata": {"source": "CRF", "title": "Propagating Regular Counting Constraints", "authors": ["Nicolas Beldiceanu", "Pierre Flener", "Justin Pearson", "Pascal Van Hentenryck"], "emails": ["Nicolas.Beldiceanu@mines-nantes.fr", "pvh@nicta.com.au"], "sections": [{"heading": null, "text": "ar Xiv: 130 9.71 45v1 [cs.AI] 27 SE"}, {"heading": "1 Introduction", "text": "In fact, it is such that we are able to assert ourselves in a position to assert that we are able to assert ourselves in the world, that we are able to assert ourselves in the world, that we are able to assert ourselves in the world, and that we are able to assert ourselves in the world, in which we live, in the world in which we live, in which we live, in the world in which we live, in which we live, in the world in which we live, in the world in which we live, in which we live, in which we live, in which we live, in the world in which we live, in which we live, in which we live, in which we live, in the world, in which we live, in the world, in which we live, in which we live, in which we live, in the world, in which we live, in which we live, in which we live, in which we live, in which we live, in the world, in which we live, in which we live, in which we live, in which we live, in which we live in the world, in which we live, in which we live in which we live, in which we live in which we live, in which we live in the world, in which we live, in which we live in which we live, in which we live in which we live, in which we live in which we live, we live in which we live in the world, in which we live, in which we live, we live in which we live in the world, in which we live, in which we live in which, we live in which we live in which we live, we live in which we live in the world, in which we live, we live in the world, in which we live, in which we live in which we live, we live in which we live, we live in which we live in the world, in which we live in which we live, we live in which we live, we live in which we live in the world, in which we live, we live in which we live in the world, in which we live, in which we live, we live in which we live in which we live in the world, in which we live, we live, in which we live, we live in which we live in the world, in the world, in which we live in which we"}, {"heading": "2 Background", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Deterministic Finite Counter Automata", "text": "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="}, {"heading": "2.2 Regular Counting Constraints", "text": "The cAutomaton (N, X, A) constraint applies if the value of the variable N, which is called the counter variable, corresponds to the final value of the counter after cDFA A has consumed the values of the entire variable sequence X. Consider the constraint NumberWord (N, X, w), which applies if N is the number of occurrences of the non-empty word w in the variable sequence X. Constraint NumberWord (N, X, \"aab\") can be modeled by the cAutomaton (N, X, AAB) constraint with the automaton AAB specified in Figure 1."}, {"heading": "2.3 Signature Constraints", "text": "Restriction to a sequence X of variables can sometimes be modeled using a DFA or cDFA that is not based on X, but on a sequence of signature variables that functionally depend on signature constraints on a movable variable window within X [3]. For example, the sub (N, X, V) constraint [4] requires N to be the number of variables in the sequence X to which a value from the given set V. With signature constraints xi-V \u21d4 si = 1 and xi-V \u21d4 si = 0 (with xi-X) we get a sequence of | X | signature variables si that can be used in a cDFA that counts the number of events of value 1 in that sequence. Instead of labeling the transitions of such a cDFA with values from the range of signature variables (the set {0, 1} constraints as acronym."}, {"heading": "3 The Propagator", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Feasibility Test and Domain Consistency Filtering", "text": "\u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="}, {"heading": "3.2 Complexity", "text": "The complexity of a non-incremental implementation of the multiplier is as follows: Each set of QCF (i) has O (| Q |) elements and takes O (| \u03a3 | | Q |) time to construct and trim (provided it is implemented as an equivalent array indexed by Q, with all cells initialized to + \u221e. There are n + 1 such records, so the entire QCF (\u00b7) vector takes O (n \u00b7 | Q |) time and the entire QCB (\u00b7 Q |) space. Likewise, the entire QCB (\u00b7) vector takes O (n \u00b7 | Q |) time and the entire QCF (n \u00b7 Q |) space. Each value m (i,) takes time to construct a value, since the entire QCB (\u00b7) vector is O (n \u00b7 Q \u00b7 \u00b7 \u00b2 pairs) time and the corresponding value Z (n) time."}, {"heading": "3.3 The Exact Regular Counting Constraint", "text": "Unsurprisingly, the decomposition of cAutomaton (N, X, A) into the conjunction of cAutomatonAtMost (N, X, A) and cAutomatonAtLeast (N, X, A) does not yield domain consistency at the fixed point of its propagators: for cDFA B in Figure 4 and the restriction cAutomaton (N, [2, x, 2], B), with N, 1, 2} and x (1, 2), it misses the conclusion of N 6 = 1. Word, achieving domain consistency to exact regular counting is actually NP-hard: Theorem 3. The feasibility of cAutomaton constraints is NP-hard.Proof. By reducing subset sum. Consider an instance < {a1,. ak}, s > of subset sum that holds when there is a subset sum."}, {"heading": "3.4 Evaluation", "text": "We implemented in SICStus Prolog version 4.2.1 [5] the described distribution areas of cAutomatonMost, cAutomatonAtLeast and cAutomaton. As a random control, we tested them extensively as the following. We generated random cDFAs of up to five states (with a probability of 20%). For each random cDFA, we have random instances with random lengths (up to 10%) of X."}, {"heading": "4 Conclusion", "text": "This paper examines limitations on regular counting via finite sequences of variables that are ubiquitous and very diverse in sequencing and timetable (e.g. limitation of the number of monthly weekends or two-day periods in which a nurse works at night and in the afternoon), and examines a class of counter-deterministic finite automata (cDFA) that provides much more concise models for regular counting restrictions than representations that use standard DFAs."}, {"heading": "4.1 Summary and Extensions", "text": "Our main contribution is to show how to enforce domain consistency in the polynomial time of q for at most and at least regular counting constraints, based on the frequent case of a counter-DFA with only acceptable states and a single counter that can be incremented by transitions. We have also proven that determining the feasibility of exact regular counting constraints is NP-hard. It is possible to lift our restriction on counter machines where all states accept, although we are then technically outside the scope of regular counting. This would, for example, allow us to restrict the number N of occurrences of a pattern recognized by cDFA A1 in a sequence of X variables, while X may not include the occurrence of another pattern recognized by cDFA A2. Instead of placing this constraint in the conjunction of cAutomaton (N, X, A1) and cAutomaton (X, X, we may not include an occurrence of another pattern recognized by cDFA A2, by first composing DFA to a pattern of 12)."}, {"heading": "4.2 Related Work", "text": "Our regular counting constraints refer to the CostRegular (X, A, N, C) costs associated with regular costs (6), an extension of the Regular (X, A) constraint [9]: a ground instance holds if the sum of variable value allocation costs is exactly N after DFA has accepted where the two-dimensional cost matrix C, indexed by A and X, has the cost of assigning each value of the alphabet from A to each variable of the sequence X. In fact, both the abstractions and the underlying regular counting algorithms are closely related. However, we now argue that regular counting constraints sometimes offer a more natural abstraction and some computational advantages, namely more propagation and asymptotically less space, within the same asymptotic time.At the conceptual level, the regular counting constraints and CostRegular constraints are expressed differently."}, {"heading": "4.3 Future Work", "text": "There are many open questions, including the following: Can we implement our propagator to run in O (n \u00b7 | \u03a3 |) time? What counter-DFAs allow a propagator to achieve domain consistency for an exact regular count? Can we generalize our domain consistency result to non-universal signature constraints? Can we generalize our results to non-deterministic counters (since our entire notation depends on the transition function \u03b4 being total)?"}, {"heading": "Acknowledgements", "text": "The second and third authors are supported by the 2011-6133 and 2012-4908 fellowships of the Swedish Research Council (VR). NICTA is funded by the Australian government, represented by the Ministry of Broadband, Communications and the Digital Economy, and the Australian Research Council under the ICT Centre of Excellence Programme. We would like to thank Mats Carlsson for his help with SICStus Prologue, Joseph Scott for his help with FAdo, and Arnaud Letord for his help in carrying out the test with CostRegular in Choco."}, {"heading": "Appendix: SICStus Prolog Implementation", "text": "s).: \u2212 n (A, N, Vars, Vars, Vars, Vars, Vars, Vars, Vars, Vars, Vars, Vars, Vars). (A, N, Vars). (A, Vars). (A, Vars). (A, Vars, Vars, Vars, Vars, Vars). (A, Vars, Vars). (A, Vars, Vars). (A, Vars, Vars). (A, Vars). (A, Vars). (A, Vars, Vars, Vars). (A, Vars, Vars). (A, Vars). (A, Vars). (A, Vars, Vars). (A, Vars, Vars). (A, Vars). (A, Vars). (A, Vars, Vars). (A, Vars, Vars, Vars). (A, Vars, Vars, Vars)."}], "references": [{"title": "Enumeration and generation with a string automata representation", "author": ["M. Almeida", "N. Moreira", "R. Reis"], "venue": "Theoretical Computer Science 387(2),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Global constraint catalogue: Past, present, and future", "author": ["N. Beldiceanu", "M. Carlsson", "S. Demassey", "T. Petit"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Deriving filtering algorithms from constraint checkers", "author": ["N. Beldiceanu", "M. Carlsson", "T. Petit"], "venue": "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 107\u2013122. Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2004}, {"title": "Introducing global constraints in CHIP", "author": ["N. Beldiceanu", "E. Contejean"], "venue": "Journal of Mathematical and Computer Modelling 20(12), 97\u2013123", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1994}, {"title": "An open-ended finite domain constraint solver", "author": ["M. Carlsson", "G. Ottosson", "B. Carlson"], "venue": "Glaser, H., Hartel, P., Kuchen, H. (eds.) PLILP 1997. LNCS, vol. 1292, pp. 191\u2013206. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1997}, {"title": "A Cost-Regular based hybrid column generation approach", "author": ["S. Demassey", "G. Pesant", "L.M. Rousseau"], "venue": "Constraints 11(4), 315\u2013333", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2006}, {"title": "The SEQBIN constraint revisited", "author": ["G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "Milano, M. (ed.) CP 2012. LNCS, vol. 7514, pp. 332\u2013347. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Choco solver: Documentation, version", "author": ["F. Laburthe", "N. Jussien"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "A regular language membership constraint for finite sequences of variables", "author": ["G. Pesant"], "venue": "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 482\u2013495. Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2004}], "referenceMentions": [{"referenceID": 2, "context": "We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3].", "startOffset": 236, "endOffset": 239}, {"referenceID": 2, "context": "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].", "startOffset": 169, "endOffset": 174}, {"referenceID": 8, "context": "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].", "startOffset": 169, "endOffset": 174}, {"referenceID": 2, "context": "This paper is concerned with the concept of counter-DFA (cDFA), an extension of DFAs proposed in [3], and uses it to model regular counting constraints, that is constraints on the number of regular-language patterns occurring in a sequence of variables.", "startOffset": 97, "endOffset": 100}, {"referenceID": 5, "context": "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .", "startOffset": 39, "endOffset": 42}, {"referenceID": 7, "context": "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "A constraint on a sequence X of variables can sometimes be modelled with the help of a DFA or cDFA that operates not on X , but on a sequence of signature variables that functionally depend via signature constraints on a sliding window of variables within X [3].", "startOffset": 258, "endOffset": 261}, {"referenceID": 3, "context": "For example, the Among(N,X,V) constraint [4] requires N to be the number of variables in the sequence X that are assigned a value from the given set V .", "startOffset": 41, "endOffset": 44}, {"referenceID": 2, "context": "Comparison between cAutomaton and Automaton [3] of SICStus Prolog", "startOffset": 44, "endOffset": 47}, {"referenceID": 4, "context": "1 [5] the described propagators for cAutomatonAtMost, cAutomatonAtLeast, and cAutomaton.", "startOffset": 2, "endOffset": 5}, {"referenceID": 1, "context": "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.", "startOffset": 117, "endOffset": 120}, {"referenceID": 0, "context": "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.", "startOffset": 178, "endOffset": 181}, {"referenceID": 2, "context": "Also, our propagator for cAutomaton never propagates less but often more, to the point of detecting more failures, than the built-in Automaton [3] of SICStus Prolog, and that it is already often up to twice faster than the latter, even though it is currently n\u00e4\u0131vely implemented in Prolog while the built-in works by decomposition into a conjunction of other global constraints, all of which are very carefully implemented in C.", "startOffset": 143, "endOffset": 146}, {"referenceID": 1, "context": "For example, the Inflexion(N,X) constraint holds if there are N inflexions (local optima) in the integer sequence X ; a cDFA is given in [2], with signature constraints using the predicates xi {<,=, >} xi+1 on the sliding window [xi, xi+1] of size 2.", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "Our exact regular counting propagator outperforms the built-in Automaton [3] of SICStus Prolog, as shown in the last line of Table 1.", "startOffset": 73, "endOffset": 76}, {"referenceID": 5, "context": "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by \u03a3 and X , gives the costs of assigning each value of the alphabet \u03a3 of A to each variable of the sequence X .", "startOffset": 86, "endOffset": 89}, {"referenceID": 8, "context": "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by \u03a3 and X , gives the costs of assigning each value of the alphabet \u03a3 of A to each variable of the sequence X .", "startOffset": 135, "endOffset": 138}, {"referenceID": 5, "context": "Footnote 1 of [6, page 318] points out that the cost matrix C can be made three-dimensional, indexed also by the states Q of A, but this is not discussed further in [6].", "startOffset": 165, "endOffset": 168}, {"referenceID": 7, "context": "This generalisation is implemented in the Choco solver [8].", "startOffset": 55, "endOffset": 58}, {"referenceID": 8, "context": "It is only with such a three-dimensional cost matrix that it is possible for the modeller to post a regular counting constraint by using the CostRegular constraint: first unroll the counter automaton for the length |X | into a directed acyclic weighted graph G (as described in [9], and the counter increments become the weights) and then post CostRegular(X,N,G); the Choco implementation [8, page 95] of CostRegular features this option.", "startOffset": 278, "endOffset": 281}, {"referenceID": 5, "context": "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .", "startOffset": 218, "endOffset": 223}, {"referenceID": 7, "context": "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .", "startOffset": 218, "endOffset": 223}, {"referenceID": 5, "context": "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N \u2208 {1, 3} and x, y \u2208 {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.", "startOffset": 26, "endOffset": 31}, {"referenceID": 7, "context": "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N \u2208 {1, 3} and x, y \u2208 {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.", "startOffset": 26, "endOffset": 31}, {"referenceID": 6, "context": "The SeqBin constraint [10,7] can be represented by a regular counting constraint, but it would require non-unary signature constraints.", "startOffset": 22, "endOffset": 28}], "year": 2013, "abstractText": "Constraints over finite sequences of variables are ubiquitous in sequencing and timetabling. Moreover, the wide variety of such constraints in practical applications led to general modelling techniques and generic propagation algorithms, often based on deterministic finite automata (DFA) and their extensions. We consider counter-DFAs (cDFA), which provide concise models for regular counting constraints, that is constraints over the number of times a regular-language pattern occurs in a sequence. We show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints based on the frequent case of a cDFA with only accepting states and a single counter that can be incremented by transitions. We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3]. Regular counting constraints are closely related to the CostRegular constraint but contribute both a natural abstraction and some computational advantages.", "creator": "LaTeX with hyperref package"}}}