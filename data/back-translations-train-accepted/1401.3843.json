{"id": "1401.3843", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Theta*: Any-Angle Path Planning on Grids", "abstract": "Grids with blocked and unblocked cells are often used to represent terrain in robotics and video games. However, paths formed by grid edges can be longer than true shortest paths in the terrain since their headings are artificially constrained. We present two new correct and complete any-angle path-planning algorithms that avoid this shortcoming. Basic Theta* and Angle-Propagation Theta* are both variants of A* that propagate information along grid edges without constraining paths to grid edges. Basic Theta* is simple to understand and implement, fast and finds short paths. However, it is not guaranteed to find true shortest paths. Angle-Propagation Theta* achieves a better worst-case complexity per vertex expansion than Basic Theta* by propagating angle ranges when it expands vertices, but is more complex, not as fast and finds slightly longer paths. We refer to Basic Theta* and Angle-Propagation Theta* collectively as Theta*. Theta* has unique properties, which we analyze in detail. We show experimentally that it finds shorter paths than both A* with post-smoothed paths and Field D* (the only other version of A* we know of that propagates information along grid edges without constraining paths to grid edges) with a runtime comparable to that of A* on grids. Finally, we extend Theta* to grids that contain unblocked cells with non-uniform traversal costs and introduce variants of Theta* which provide different tradeoffs between path length and runtime.", "histories": [["v1", "Thu, 16 Jan 2014 04:55:01 GMT  (486kb)", "http://arxiv.org/abs/1401.3843v1", null]], "reviews": [], "SUBJECTS": "cs.CG cs.AI", "authors": ["alex nash", "kenny daniel", "sven koenig", "ariel felner"], "accepted": true, "id": "1401.3843"}, "pdf": {"name": "1401.3843.pdf", "metadata": {"source": "CRF", "title": "Theta*: Any-Angle Path Planning on Grids", "authors": ["Kenny Daniel", "Alex Nash", "Sven Koenig", "Ariel Felner"], "emails": ["KFDANIEL@USC.EDU", "ANASH@USC.EDU", "SKOENIG@USC.EDU", "FELNER@BGU.AC.IL"], "sections": [{"heading": null, "text": "We present two new, correct and complete algorithms for planning paths at every angle that avoid this deficiency. Basic theta * and angular propagation theta * are both variants of A * that disseminate information along lattice margins without limiting paths on lattice margins. Basic theta * is easy to understand and implement, fast and finds short paths. However, it is not guaranteed to find really shortest paths. Angular propagation theta * achieves the worst possible complexity per apex extension as basic theta * by extending angular ranges, but is more complex, does not find as fast and slightly longer paths. We refer to Basic theta * and Angular propagation theta * together as theta *. Theta * has unique properties that we analyze in detail."}, {"heading": "1. Introduction", "text": "In this article, we study the Robotics and Video Game Route Planning (Choset, Lynch, Hutchinson, Kantor, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002), where a two-dimensional continuous terrain is transformed into a grid of blocked and unblocked cells, with the goal of finding a short, unblocked path from a given starting point to a given target vertex (both at the corners of the cells)."}, {"heading": "2. Path-Planning Problem and Notation", "text": "In this section we will describe the problem of route planning that we will explore in this article, namely route planning on eight adjacent networks with blocked and unblocked cells of the same size. Cells are called either blocked (gray) or unblocked (white). We use the corners of the cells (and not their centers) as vertices. S is the set of all vertices. The problem of route planning is to find an unblocked path from a given starting point to a given destination point. A path is released if each vertex on the path has a line of sight to its successor on the path. The vertex has a line of vision to vertices, written as LineOfSight (s, s), when the straight line from vertex s leads neither through the interior of blocked cells nor between blocked cells dividing an edge."}, {"heading": "3. Existing Terrain Discretizations", "text": "This is essential when route planning is used in a dynamic environment and needs to interact with a navigation planner. For example, when a robot or video game character encounters its path, it can easily determine whether it best turns left (Tozour, 2004) or right (Tozour, 2004). In this section, we can store information on other existing terrain. We use grids to discredit terrain as they are commonly used in robotics and video games (Deloura, 2000; Rabin, 2004) and have several desirable properties: \u2022 Grids are simple data structures and allow for simple route planning algorithms. This is essential when route planning algorithms are used in a dynamic environment and need to interact with a navigation planner. For example, when a robot or video game character encounters its path, it can easily determine whether it best turns left (Tozour, 2004)."}, {"heading": "4. Existing Path-Planning Algorithms", "text": "In this section we describe some existing path planning algorithms, which are all variants of A * (Hart, Nilsson, & Raphael, 1968). A * is a popular path planning algorithm in robotics and video games. Algorithm 1 shows the pseudo-code of A *. Line 13 is to be ignored. \u2022 User-supplied h-value x x x s: \u2022 The g-value g (s) is the length of the shortest path from the start vertex to the vertex s, making it an estimate of the start distance of the vertex. \u2022 The h-value h (s) provided by the user is an estimate of the target distance of the vertex. A * uses the h-value to calculate a f-value to focus the A * search. The f-value f (s) is an estimate of the length f (s) + h (s) is an estimate of the length of the shortest path from the start tex."}, {"heading": "4.1 A* on Grids", "text": "The resulting paths are artificially limited to be formed by the edges of the grid, as can be seen in Figure 1 (a). Consequently, the paths A * has found on grids are not the same as the really shortest paths and look unrealistic because they either differ considerably from the really shortest paths or have many other changes in direction, which provides the motivation for smoothing them out. We use the ocular distances, which can be calculated with Algorithm 5, as h values in the experiments."}, {"heading": "4.2 A* with Post-Smoothed Paths (A* PS)", "text": "You can run A * with smoothed paths (A * PS), i.e. shorten the path (Thorpe, 1984). A * PS executes A * on grids and then smoothes the resulting path in a post-processing step, which often shortens it as runtime increases. Algorithm 2 shows the pseudo-code of the simple smoothing algorithm that A * PS uses in our experiments (Botea, Mu M\u00fcller, & Schaeffer, 2004), which provides a good compromise between runtime and path length. Suppose A * on grids finds the path [s0, s1,... sn] with s0 = sstart and sgoal. A * PS uses the first vertex on the path as the current vertex. It then checks whether the current vertex s0 has a real line of sight and the successor s2 has its successor on the path."}, {"heading": "4.3 Field D* (FD*)", "text": "You can't necessarily make the D * field (Ferguson & Stentz, 2006) (FD *) a dot (X). FD * propagates information along the edges of the net without limiting the paths to the edges of the net. FD * is designed to use D * Lite (Koenig & Likhachev, 2002) for quick replanning (by reusing information from the previous A * search to speed up the next one) and searches from the target dot to the start dot. (Our version of FD * uses A * and searches from the start dot to the target dot, like all the other path planning algorithms in this article, allowing us to compare them fairly except for their replanning capabilities. (Theta * is currently in the expansion process for fast rescheduling in Nash, Koenig, & Likhachev, 2009) If FD * does not expand the g value and parent of a."}, {"heading": "4.4 A* on Visibility Graphs", "text": "The visibility graph of a grid with blocked and unblocked cells contains the initial apex, the target apex and the corners of all blocked cells (Lozano-Pe-rez & Wesley, 1979).We use the even distances h (s) = c (s, sgoal) as h-values in the experiments. A * on the visibility charts finds the truly shortest paths, as shown in Figure 6 (a).True shortest paths change only at the corners of blocked cells, while the paths found by A * on the grids may have A * PS and FD * unnecessary changes. On the other hand, A * can be slow on the visibility graphs. It propagates information along the edges of the visibility graph, the number of which can grow quadratically in the number of cells, while A * on the grids, A * PS and FD * spread information along the edges, the number of which only increases linearly if the number of cells is reduced before the search."}, {"heading": "5. Basic Theta*", "text": "In this section, we present Theta * (Nash et al., 2007), our version of A * for planning paths at arbitrary angles that disseminate information along grid margins without restricting paths to grid margins, combining the ideas behind A * in visibility graphs (where changes in heading occur only at the corners of blocked cells) and A * in grids (where the number of edges grows only linearly in the number of cells), whose orbits are only slightly longer than true shortest paths (as found by A * in visibility graphs), but only slightly slower than A * in grids, as shown in Figure 2. The main difference between Theta * and A * in grids is that the parent of a vertex can be any vertex when used with Theta *, while the parent of a vertex must be a neighbor of the vertex when used."}, {"heading": "5.1 Operation of Basic Theta*", "text": "It is identical to A * except that when it updates the g-value and the parent of an unexpanded visible neighbor s of the vertex s in the procedure UpdateVertex, it looks at two paths instead of only the one path taken into account by A *. Figure 7 (a) shows an example. Basic Theta * expands the vertex B3 with the parent and must update the G-value and the parent of the unexpanded visible neighboring angle C3. Basic Theta * looks at two paths: \u2022 Path 1: Basic Theta * looks at the path from the starting point to the vertex s [= g (s)] and from the vertex s s to vertex s \u00b2 in a straight line [= c, s \u2032), resulting in a length of g (s) + c (s, s). Path 1 is the path x (line 52). Path 1 is the path x that corresponds from A * to the dotted path, A4, B3."}, {"heading": "5.2 Example Trace of Basic Theta*", "text": "Figure 8 shows an example track of Basic Theta *. The vertices are labeled with their G values and parents, the arrows point to their parents, red circles indicate vertices that are expanded, and blue arrows indicate vertices generated during the current expansion. First, Basic Theta * extends the initial apex A4 with the parent A4, as shown in Figure 8 (a). It sets the parent of the inextended visible neighbors of the apex A4 to apex A4, just as A * would do. Second, Basic Theta * extends the apex B3 with the parent A4, as shown in Figure 8 (b). Vertex B2 is an unexpanded visible neighbor of the apex B3, which has no line of sight to the apex A4. Basic Theta * updates it accordingly path 1 and sets its parent to apex B3."}, {"heading": "5.3 Properties of Basic Theta*", "text": "We will now discuss the properties of Basic Theta *."}, {"heading": "5.3.1 CORRECTNESS AND COMPLETENESS", "text": "If there is an unblocked path between two vertices, then there is an unblocked path between two vertices, then there is also an unblocked path between the two vertices. If you look at all paths, there is also an unblocked path between the two vertices. If you look at the path segment sksk + 1 of this arbitrary angle path. If the path segment is horizontal or vertical, then you look at the unblocked grid path of the parents themselves iff an unblocked arbitrary path [s0,., sn] exists between the same two vertices. If you look at the sequence (b0, bm) of the unblocked cells."}, {"heading": "5.3.2 OPTIMALITY", "text": "Basic Theta * is not optimal (i.e. it is not guaranteed to find true shortest paths), because the parent of a vertex must be either a visible neighbor of the vertex or the parent of a visible neighbor, which is not always the case with true shortest paths. Figure 9 (a) shows an example where the dotted red path [E1, B9] is a true shortest path from the beginning vertex E1 to the vertex B9, since the vertex E1 has no line of sight to the vertex B9. Figure 9 (a), however, is neither a visible neighbor nor the parent of a visible neighbor of the vertex B9, since the vertex E1 has no line of vision to these vertex points (highlighted in red). Therefore, Basic Theta * cannot place the parent of the vertex B9 on the vertex E1 and the vertex not on the shortest vertex EX."}, {"heading": "5.3.3 HEADING CHANGES", "text": "s assume that the open list contains both vertices C5 and D5. The f-value of Vertex C5 is f (C5) = g (C5) = g (C5) = g (C5) + h (C5) + h (C5) + h (C5) + h (C5) + h (C5) + h (C5) = 4.61 + 1.41 = 6.02 s and its parents are Vertex C4. The f-value of Vertex D5 is f (D5) = 5.00 = 6.00 and its parents are Vertex A1. Thus Basic Theta * Vertex D5 expands (since its f-value is smaller)."}, {"heading": "6. Angle-Propagation Theta* (AP Theta*)", "text": "The runtime of Basic Theta * per vertex expansion (i.e. the runtime consumed in generating the unextended visible neighbors during the expansion of a vertex) can be linear in the number of cells, since the runtime of each line-of-sight test can be linear in the number of cells. In this section, we introduce Angle Propagation Theta * (AP Theta *), which reduces the runtime of BasicTheta * per vertex expansion from linear to constant. The main difference between AP Theta * and Basic Theta * is that AP Theta * propagates angle ranges and uses them to determine whether two vertex points have a line-of-sight. If there is a light source at one vertex and light cannot pass through blocked cells, then cells in the shadows have no line-of-sight values, while all other cells have a line-of-of-sight vertex, while all other cells have a vertex to the vertex during the other vertex."}, {"heading": "6.1 Definition of Angle Ranges", "text": "We will now discuss the key concept of an angular range. AP Theta * maintains two additional values for each vertex, namely a lower angular range of vertices and a higher angular range of vertices which together form the angular range [lb (s), ub (s)] of vertices. Angular boundaries correspond to the headings of rays (measured in degrees) emanating from the parent of the vertex s. The heading of the beam from the parent of the vertex to the visible neighbor of the vertex s is zero degrees. A visible neighbor of the vertex is guaranteed to have a line of sight (measured in degrees) of the vertex (but not necessarily only if the headline of the beam from the parent of the vertex s to the visible neighbor of the vertex s is zero degrees. A visible neighbor of the vertex is guaranteed to have the vertex vertex vertex. While AP Theta * shows a significant improvement in complexity compared to the parent's vertex."}, {"heading": "6.2 Update of Angle Ranges", "text": "This calculation is complicated by the fact that AP Theta * does not have sufficient information to determine the angular range accurately, since the order of vertex expansions depends on a variety of factors such as the h-values. In this case, AP Theta * can more than necessarily restrict the angular range to guarantee that the visibility property is maintained and that it finds unblocked paths. If AP Theta * widens the angular range of the vertex, it first sets [\u2212), which means that all visible neighbors of the vertex are guaranteed to have a line of vision to the parent of the vertex. It then increasingly restricts the angular range when the vertex is not the starting point. AP Theta * conconconconconins is the angular range of the vertex based on each blocked cell b adjacent to the vertex (which is that it is not the starting point)."}, {"heading": "6.3 Example Trace of AP Theta*", "text": "Figure 13 shows an exemplary trace of AP Theta * based on the path planning problem in Figure 8. The labels of the vertices now contain the angle ranges."}, {"heading": "6.4 Properties of AP Theta*", "text": "We will discuss the properties of AP Theta *. AP Theta * operates in the same way as Basic Theta * and therefore has properties similar to Basic Theta *. For example, AP Theta * is correct and complete. It is not guaranteed that its line-of-sight checks are sometimes incorrect, and its paths may indeed have unnecessary transitions. AP Theta * is still complete because it finds an unchecked network path when all line-of-sight checks fail, and there is the possibility to update links with the path."}, {"heading": "7. Experimental Results", "text": "In this section, we compare Basic Theta * and AP Theta * to A * on grids, A * PS, FD * and A * on visibility graphs in terms of their path length, number of vertex extensions, runtime (measured in seconds) and number of target changes. We compare these path planning algorithms to 100 x 100 and 500 x 500 grids with different percentages of randomly blocked cells and scaled maps from the real-time strategy game Baldur's Gate II (Game Maps). Figure 15 (Bulitko, Sturtevant, & Kazakevich, 2005) shows an example of a game card, the start and finish vertices are the southwest corners of the cells. For random grids, the start vertex is in the southwest cell. The target vertex is selected the farthest east in a cell."}, {"heading": "8. Extensions of Theta*", "text": "In this section, we expand Basic Theta * to find paths from a given starting point to all other vertices, and to find paths on grids that contain unblocked cells with uneven traverse costs."}, {"heading": "8.1 Single Source Paths", "text": "So far, Basic Theta * has found paths from a given starting point to a given destination point. We are now discussing a version of Basic Theta * that finds single source paths (i.e. paths from a given starting point to all other vertices) by only exiting when the open list is empty, rather than when either the open list is empty or it extends the destination point. Finding individual source paths requires that all path planning algorithms extend the same number of vertices, minimizing the impact of the h values on the runtime and thus leading to a clean comparison, since the h values are sometimes selected to act between runtime and path length. Runtimes of A * PS and FD * are executed more than those of Basic Theta * and AP Theta * when individual source paths are found, as they require smoothing or path extraction steps for each path, and therefore many paths are processed after each of these two algorithmic steps *, as the AP reports both of these 5 runtimes after each other."}, {"heading": "8.2 Non-Uniform Traversal Costs", "text": "(.). (.). (.). (.). (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).\" (.). \"(.).).\" (. \"(.).\" (.). \"(.).).\" (. \"(.).).\" (.). \"(.).).\" (. \"(.).\" (.). \"(.).\" (.). \"(.).).\" (. \"(.).\" (.). \"(.).\" (.). \"(.).\" (.).). \"(.).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).).\" (.).).).). (. (.)."}, {"heading": "9. Trading Off Runtime and Path Length: Exploiting h-Values", "text": "This year it is as far as never before in the history of the Federal Republic of Germany."}, {"heading": "9.1 Weighted h-Values", "text": "So far, Basic Theta * has used consistent h-values h (s). A * with consistent h-values finds paths of the same length no matter how small or large the h-values are. Decreasing consistent h-values typically increases the number of vertex expansions for A *. Therefore, we are now discussing a version of Basic Theta * that may be able to find shorter paths at an increase in runtime by using weighted h-values with weights of less than one. This version of Basic Theta * uses the h-values h (s) = w \u00b7 c (s, sgoal) for a given weight 0 \u2264 w < 1 and is therefore similar to weighted A * (Pohl, 1973), except that weighted A * typically uses weights of more than one. Figure 20 (a) shows an example of the resulting effect on the number of vertex expansions and threads of c-values."}, {"heading": "9.2 Tie Breaking", "text": "So far, so good."}, {"heading": "9.3 Re-Expanding Vertices", "text": "In fact, it is as if it is a reactionary project, which is a reactionary project, which is a reactionary project, which is a reactionary project, which is a reactionary project."}, {"heading": "10. Trading Off Runtime and Path Length: Other Approaches", "text": "In this section, we will develop versions of Basic Theta * that may be able to find shorter paths while increasing runtime by examining more paths, including versions that maintain visual contact with the parent, use keycorners to identify promising parents, and increase the number of visible neighbors and thus the number of potential parents when updating corners according to path 1."}, {"heading": "10.1 Three Paths", "text": "So far, Basic Theta * has considered two paths (namely paths 1 and 2) when updating the gvalue and parent of an unexpanded visible neighbor of the vertex. We are now discussing a version of Basic Theta * that takes into account a third path, namely the path from the beginning vertex to the parent of the vertex s [= g (parent (s)]] and from that to the vertex s \u00b2 in a straight line [= c (parent (s), s)]], resulting in a length of g (parent (s) + c (parent (s), s). This version of Basic Theta * might find shorter paths with an increase in runtime, as the third path is no longer than path 2 due to triangular inequality. However, our experimental results (not reported here) show that the third path does not significantly reduce the path length, because the original version of Basic Theta * is already the parent of the vertex *, which is the vertex parent's probable."}, {"heading": "10.2 Key Vertices", "text": "So far, Basic Theta * has considered two paths (paths 1 and 2) when updating the g-value and parent of an unexpanded visible neighbor of the vertex, which is not always the case with real shortest paths. We are now discussing a version of Basic Theta * that takes into account additional paths, namely the paths from the initial vertex to tiled key vertex and from them to the vertex in a straight line. This version of Basic Theta * could find shorter paths with an increase in runtime, as the parent of a vertex can now also be one of the key vertex. However, our experimental results (which are not reported here) show that key vertex only slightly decreases the path length with a larger increase in runtime, as they need to be selected from the overhead, maintain it, and consider a larger number of waypoints."}, {"heading": "10.3 Larger Branching Factors", "text": "We are now discussing a version of Basic Theta * that works on networks with different number of neighbors and thus different branching factors. Figure 23 shows the neighbors of the center for the branching factors 4, 8 and 16. This version of Basic Theta * could find shorter paths with an increase in runtime, since larger branching factors increase the number of visible neighbors of vertices and thus their number of potential parents when updated according to path 1. Figure 24 reports on the effects of larger branching factors on the path length and runtime of Basic Theta * on random 500 x 500 grids with 20 percent blocked cells. Larger branching factors actually reduce the path length with an increase in runtime."}, {"heading": "11. Conclusions", "text": "In fact, most of them are able to play by the rules that they have shown in recent years, and they are able to play by the rules that they have shown."}, {"heading": "Appendix A. Checking Line-of-Sight", "text": "In this appendix, we explain how to perform visual character checks quickly. For simplicity, we allow straight lines to pass between diagonally touched locked cells. Performing visual character checks is similar to determining which points are displayed on a grid display when drawing a straight line between two points. Drawn points correspond to the cells that the straight line passes through. LineOfSight (s, s') 106 x0: = s.x; 107 y0: = s.y; 108 x1: = s \u2032.x; 109 y1: = s \u2032.y; 110 dy: = y1 \u2212 y0 \u2212 y0; 111 dx: = x1 \u2212 \u2212 x0; 112 f: = 0; 113 if dy < 0 then114 dy: = \u2212 dy; 115 sy: = \u2212 1; 116else117 sy: = = = 1; 118 if dx < 0 then119 dx: \u2212 dx = 12x = 12x = 12x = 12x = 12x = 12x."}, {"heading": "Appendix B. AP Theta* Returns Unblocked Paths", "text": "In this appendix, we prove that AP Theta * never returns a blocked path. Theorem 4. AP Theta * never returns a blocked path. Proof. We define a path to be blocked iff at least one vertex on the path. We first prove that AP Theta * never returns a path with a path segment leading through the inside of a blocked cell. We prove by contradiction that AP Theta * cannot assign any parent p to a vertex, so the path segment goes from parent p to vertex s."}, {"heading": "Appendix C. Acknowledgments", "text": "This article is an extension of an earlier publication (Nash et al., 2007) and contains additional representations, examples and evidence. We thank Vadim Bulitko of the University of Alberta for providing us with maps of the real-time game Baldur's Gate II. Our research was carried out while Ariel Felner was on sabbatical at the University of Southern California and visited Sven Koenig. This research was supported in part by a prize from the U.S. Army Research Laboratory (ARL) and the U.S. Army Research Office (ARO) to Sven Koenig as part of the W911NF-08-1-0468 scholarship, by a prize from the Office of Naval Research (ONR) to Sven Koenig as part of the N00014-09-1-1031 scholarship, by a prize from the National Science Foundation (NSF) to Sven Koenig as part of the W911NF-08-1-0468 scholarship, and by an Israeli Science Foundation prize (ISF) as part of the National Science Foundation Fellowship (NISF) to Ariel 13001-041 by the Israeli Science Foundation."}], "references": [{"title": "Voronoi diagrams\u2014a survey of a fundamental geometric data structure", "author": ["F. Aurenhammer"], "venue": null, "citeRegEx": "Aurenhammer,? \\Q1991\\E", "shortCiteRegEx": "Aurenhammer", "year": 1991}, {"title": "Algorithm for computer control of a digital plotter", "author": ["J. Bresenham"], "venue": "IBM Systems Journal, 4(1), 25\u201330.", "citeRegEx": "Bresenham,? 1965", "shortCiteRegEx": "Bresenham", "year": 1965}, {"title": "Speeding up learning in real-time search via automatic state abstraction", "author": ["V. Bulitko", "N. Sturtevant", "M. Kazakevich"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,", "citeRegEx": "Bulitko et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bulitko et al\\.", "year": 2005}, {"title": "Principles of Robot Motion: Theory, Algorithms, and Implementations", "author": ["H. Choset", "K. Lynch", "S. Hutchinson", "G. Kantor", "W. Burgard", "L. Kavraki", "S. Thrun"], "venue": null, "citeRegEx": "Choset et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Choset et al\\.", "year": 2005}, {"title": "Game Programming Gems", "author": ["M. Deloura"], "venue": "Charles River Media.", "citeRegEx": "Deloura,? 2000", "shortCiteRegEx": "Deloura", "year": 2000}, {"title": "Using interpolation to improve path planning: The Field D* algorithm", "author": ["D. Ferguson", "A. Stentz"], "venue": "Journal of Field Robotics,", "citeRegEx": "Ferguson and Stentz,? \\Q2006\\E", "shortCiteRegEx": "Ferguson and Stentz", "year": 2006}, {"title": "Computer Graphics: Principles and Practice", "author": ["J. Foley", "A. van Dam", "S. Feiner", "J. Hughes"], "venue": null, "citeRegEx": "Foley et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Foley et al\\.", "year": 1992}, {"title": "A formal basis for the heuristic determination of minimum cost paths", "author": ["P. Hart", "N. Nilsson", "B. Raphael"], "venue": "IEEE Transactions on Systems Science and Cybernetics,", "citeRegEx": "Hart et al\\.,? \\Q1968\\E", "shortCiteRegEx": "Hart et al\\.", "year": 1968}, {"title": "Probabilistic roadmaps for path planning in high-dimensional configuration spaces", "author": ["L. Kavraki", "P. Svestka", "J. Latombe", "M. Overmars"], "venue": "IEEE Transactions on Robotics and Automation,", "citeRegEx": "Kavraki et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Kavraki et al\\.", "year": 1996}, {"title": "Rapidly-exploring random trees: Progress and prospects", "author": ["S. LaValle", "J. Kuffner"], "venue": "Algorithmic and Computational Robotics: New Directions,", "citeRegEx": "LaValle and Kuffner,? \\Q2001\\E", "shortCiteRegEx": "LaValle and Kuffner", "year": 2001}, {"title": "Proximity and reachability in the plane", "author": ["Lee", "D.-T."], "venue": "Ph.D. thesis, University of Illinois at Urbana-Champaign.", "citeRegEx": "Lee and D..T.,? 1978", "shortCiteRegEx": "Lee and D..T.", "year": 1978}, {"title": "Path planning using a tangent graph for mobile robots among polygonal and curved obstacles", "author": ["Liu", "Y.-H", "S. Arimoto"], "venue": "International Journal Robotics Research,", "citeRegEx": "Liu et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Liu et al\\.", "year": 1992}, {"title": "An algorithm for planning collision-free paths among polyhedral obstacles", "author": ["T. Lozano-P\u00e9rez", "M. Wesley"], "venue": "Communication of the ACM,", "citeRegEx": "Lozano.P\u00e9rez and Wesley,? \\Q1979\\E", "shortCiteRegEx": "Lozano.P\u00e9rez and Wesley", "year": 1979}, {"title": "The weighted region problem: Finding shortest paths through a weighted planar subdivision", "author": ["J. Mitchell", "C. Papadimitriou"], "venue": "Journal of the ACM,", "citeRegEx": "Mitchell and Papadimitriou,? \\Q1991\\E", "shortCiteRegEx": "Mitchell and Papadimitriou", "year": 1991}, {"title": "Introduction to AI Robotics", "author": ["R. Murphy"], "venue": "MIT Press.", "citeRegEx": "Murphy,? 2000", "shortCiteRegEx": "Murphy", "year": 2000}, {"title": "Theta*: Any-angle path planning on grids", "author": ["A. Nash", "K. Daniel", "S. Koenig", "A. Felner"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,", "citeRegEx": "Nash et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nash et al\\.", "year": 2007}, {"title": "Incremental Phi*: Incremental any-angle path planning on grids", "author": ["A. Nash", "S. Koenig", "M. Likhachev"], "venue": "In Proceedings of the International Joint Conference on Aritificial Intelligence,", "citeRegEx": "Nash et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Nash et al\\.", "year": 2009}, {"title": "Amit\u2019s Game Programming Information", "author": ["A. Patel"], "venue": "available online at http://theory.stanford.edu/\u223camitp/GameProgramming/MapRepresentations.html.", "citeRegEx": "Patel,? 2000", "shortCiteRegEx": "Patel", "year": 2000}, {"title": "Heuristics: Intelligent Search Strategies for Computer Problem Solving", "author": ["J. Pearl"], "venue": "AddisonWesley.", "citeRegEx": "Pearl,? 1984", "shortCiteRegEx": "Pearl", "year": 1984}, {"title": "The avoidance of (relative) catastrophe, heuristic competence, genuine dynamic weighting and computational issues in heuristic problem solving", "author": ["I. Pohl"], "venue": "Proceedings of the International Joint Conference on Artificial Intelligence, pp. 12\u201317.", "citeRegEx": "Pohl,? 1973", "shortCiteRegEx": "Pohl", "year": 1973}, {"title": "AI Game Programming Wisdom", "author": ["S. Rabin"], "venue": "Charles River Media.", "citeRegEx": "Rabin,? 2002", "shortCiteRegEx": "Rabin", "year": 2002}, {"title": "AI Game Programming Wisdom 2", "author": ["S. Rabin"], "venue": "Charles River Media.", "citeRegEx": "Rabin,? 2004", "shortCiteRegEx": "Rabin", "year": 2004}, {"title": "Path relaxation: Path planning for a mobile robot", "author": ["C. Thorpe"], "venue": "Proceedings of the AAAI Conference on Artificial Intelligence, pp. 318\u2013321.", "citeRegEx": "Thorpe,? 1984", "shortCiteRegEx": "Thorpe", "year": 1984}, {"title": "Search space representations", "author": ["P. Tozour"], "venue": "Rabin, S. (Ed.), AI Game Programming Wisdom 2, pp. 85\u2013102. Charles River Media.", "citeRegEx": "Tozour,? 2004", "shortCiteRegEx": "Tozour", "year": 2004}, {"title": "Framed-quadtree path planning for mobile robots operating in sparse environments", "author": ["A. Yahja", "A. Stentz", "S. Singh", "B. Brumitt"], "venue": "In Proceedings of the International Conference on Robotics and Automation,", "citeRegEx": "Yahja et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Yahja et al\\.", "year": 1998}, {"title": "Grid-based path-finding", "author": ["P. Yap"], "venue": "Proceedings of the Canadian Conference on Artificial Intelligence, pp. 44\u201355.", "citeRegEx": "Yap,? 2002", "shortCiteRegEx": "Yap", "year": 2002}], "referenceMentions": [{"referenceID": 4, "context": "Introduction In this article, we study path planning for robotics and video games (Choset, Lynch, Hutchinson, Kantor, Burgard, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002), where a two-dimensional continuous terrain is discretized into a grid with blocked and unblocked cells.", "startOffset": 82, "endOffset": 205}, {"referenceID": 17, "context": "Introduction In this article, we study path planning for robotics and video games (Choset, Lynch, Hutchinson, Kantor, Burgard, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002), where a two-dimensional continuous terrain is discretized into a grid with blocked and unblocked cells.", "startOffset": 82, "endOffset": 205}, {"referenceID": 14, "context": "Introduction In this article, we study path planning for robotics and video games (Choset, Lynch, Hutchinson, Kantor, Burgard, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002), where a two-dimensional continuous terrain is discretized into a grid with blocked and unblocked cells.", "startOffset": 82, "endOffset": 205}, {"referenceID": 20, "context": "Introduction In this article, we study path planning for robotics and video games (Choset, Lynch, Hutchinson, Kantor, Burgard, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002), where a two-dimensional continuous terrain is discretized into a grid with blocked and unblocked cells.", "startOffset": 82, "endOffset": 205}, {"referenceID": 25, "context": "A* finds grid paths (that is, paths constrained to grid edges) quickly, but grid paths are often not true shortest paths (that is, shortest paths in the terrain) since their potential headings are artificially constrained to multiples of 45 degrees, as shown in Figure 1(a) (Yap, 2002).", "startOffset": 274, "endOffset": 285}, {"referenceID": 4, "context": "We use grids to discretize terrain since they are widely used in robotics and video games (Deloura, 2000; Murphy, 2000; Rabin, 2004) and have several desirable properties: \u2022 Grids are simple data structures and allow for simple path-planning algorithms.", "startOffset": 90, "endOffset": 132}, {"referenceID": 14, "context": "We use grids to discretize terrain since they are widely used in robotics and video games (Deloura, 2000; Murphy, 2000; Rabin, 2004) and have several desirable properties: \u2022 Grids are simple data structures and allow for simple path-planning algorithms.", "startOffset": 90, "endOffset": 132}, {"referenceID": 21, "context": "We use grids to discretize terrain since they are widely used in robotics and video games (Deloura, 2000; Murphy, 2000; Rabin, 2004) and have several desirable properties: \u2022 Grids are simple data structures and allow for simple path-planning algorithms.", "startOffset": 90, "endOffset": 132}, {"referenceID": 23, "context": "For example if a robot or video game character encounters a temporary blockage to its path, it can easily determine whether it is best to divert left (unblocked) or right (blocked) (Tozour, 2004).", "startOffset": 181, "endOffset": 195}, {"referenceID": 0, "context": "\u2022 Voronoi graphs (Aurenhammer, 1991) discretize the terrain by biasing paths away from blocked polygons.", "startOffset": 17, "endOffset": 36}, {"referenceID": 0, "context": "\u2022 Voronoi graphs (Aurenhammer, 1991) discretize the terrain by biasing paths away from blocked polygons. The resulting paths can thus be much longer than true shortest paths. \u2022 The discretization in the work of Mitchell and Papadimitriou (1991) partitions the terrain into regions with linear and hyperbolic edges, which allows one to find true shortest paths with time and space complexity O(m5/3), where m is the number of corners of blocked polygons.", "startOffset": 18, "endOffset": 245}, {"referenceID": 22, "context": "2 A* with Post-Smoothed Paths (A* PS) One can run A* with post-smoothed paths (A* PS) (Thorpe, 1984).", "startOffset": 86, "endOffset": 100}, {"referenceID": 23, "context": "If one constructed the visibility graphs before the A* search, one would need to perform a line-of-sight check for every pair of corners of blocked cells to determine whether or not there should be a visibility graph edge between them, which requires at least 2,556 line-of-sight checks for the room in Figure 6(b) (Tozour, 2004).", "startOffset": 315, "endOffset": 329}, {"referenceID": 15, "context": "Basic Theta* In this section, we introduce Theta* (Nash et al., 2007), our version of A* for any-angle path planning that propagates information along grid edges without constraining the paths to grid edges.", "startOffset": 50, "endOffset": 69}, {"referenceID": 7, "context": "Consistent h-values satisfy the triangle inequality, that is, the h-value of the goal vertex is zero and the h-value of any potential non-goal parent of any vertex is no greater than the distance from the potential non-goal parent of the vertex to the vertex plus the h-value of the vertex (Hart et al., 1968; Pearl, 1984).", "startOffset": 290, "endOffset": 322}, {"referenceID": 18, "context": "Consistent h-values satisfy the triangle inequality, that is, the h-value of the goal vertex is zero and the h-value of any potential non-goal parent of any vertex is no greater than the distance from the potential non-goal parent of the vertex to the vertex plus the h-value of the vertex (Hart et al., 1968; Pearl, 1984).", "startOffset": 290, "endOffset": 322}, {"referenceID": 5, "context": "We compare these path-planning algorithms on 1000 \u00d7 1000 grids, where each cell is assigned an integer traversal cost from 1 to 15 (corresponding to an unblocked cell) and infinity (corresponding to a blocked cell), similar to the technique used in the work of Ferguson and Stentz (2006) .", "startOffset": 261, "endOffset": 288}, {"referenceID": 18, "context": "A* on grids then has the following properties (Pearl, 1984): The f-value of any expanded vertex is no larger than the f-value of any of its unexpanded visible neighbors after updating them according to Path 1, which implies that the f-value of any vertex that is expanded before some other vertex is no larger than the f-value of this other vertex.", "startOffset": 46, "endOffset": 59}, {"referenceID": 19, "context": "This version of Basic Theta* uses the h-values h(s) = w \u00d7 c(s, sgoal) for a given weight 0 \u2264 w < 1 and thus is similar to Weighted A* (Pohl, 1973), except that Weighted A* typically uses weights greater than one.", "startOffset": 134, "endOffset": 146}, {"referenceID": 1, "context": "This allows Basic Theta* to perform its line-of-sight checks with the standard Bresenham line-drawing algorithm from computer graphics (Bresenham, 1965), that uses only fast logical and integer operations rather than floating-point operations.", "startOffset": 135, "endOffset": 152}], "year": 2010, "abstractText": "Grids with blocked and unblocked cells are often used to represent terrain in robotics and video games. However, paths formed by grid edges can be longer than true shortest paths in the terrain since their headings are artificially constrained. We present two new correct and complete anyangle path-planning algorithms that avoid this shortcoming. Basic Theta* and Angle-Propagation Theta* are both variants of A* that propagate information along grid edges without constraining paths to grid edges. Basic Theta* is simple to understand and implement, fast and finds short paths. However, it is not guaranteed to find true shortest paths. Angle-Propagation Theta* achieves a better worst-case complexity per vertex expansion than Basic Theta* by propagating angle ranges when it expands vertices, but is more complex, not as fast and finds slightly longer paths. We refer to Basic Theta* and Angle-Propagation Theta* collectively as Theta*. Theta* has unique properties, which we analyze in detail. We show experimentally that it finds shorter paths than both A* with post-smoothed paths and Field D* (the only other version of A* we know of that propagates information along grid edges without constraining paths to grid edges) with a runtime comparable to that of A* on grids. Finally, we extend Theta* to grids that contain unblocked cells with non-uniform traversal costs and introduce variants of Theta* which provide different tradeoffs between path length and runtime.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}