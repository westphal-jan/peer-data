{"id": "1411.5410", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Nov-2014", "title": "Stable Model Counting and Its Application in Probabilistic Logic Programming", "abstract": "Model counting is the problem of computing the number of models that satisfy a given propositional theory. It has recently been applied to solving inference tasks in probabilistic logic programming, where the goal is to compute the probability of given queries being true provided a set of mutually independent random variables, a model (a logic program) and some evidence. The core of solving this inference task involves translating the logic program to a propositional theory and using a model counter. In this paper, we show that for some problems that involve inductive definitions like reachability in a graph, the translation of logic programs to SAT can be expensive for the purpose of solving inference tasks. For such problems, direct implementation of stable model semantics allows for more efficient solving. We present two implementation techniques, based on unfounded set detection, that extend a propositional model counter to a stable model counter. Our experiments show that for particular problems, our approach can outperform a state-of-the-art probabilistic logic programming solver by several orders of magnitude in terms of running time and space requirements, and can solve instances of significantly larger sizes on which the current solver runs out of time or memory.", "histories": [["v1", "Thu, 20 Nov 2014 00:54:45 GMT  (129kb,D)", "http://arxiv.org/abs/1411.5410v1", "Accepted in AAAI, 2015"]], "COMMENTS": "Accepted in AAAI, 2015", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["rehan abdul aziz", "geoffrey chu", "christian j muise", "peter james stuckey"], "accepted": true, "id": "1411.5410"}, "pdf": {"name": "1411.5410.pdf", "metadata": {"source": "CRF", "title": "Stable Model Counting and Its Application in Probabilistic Logic Programming", "authors": ["Rehan Abdul Aziz", "Geoffrey Chu", "Christian Muise", "Peter Stuckey"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In fact, it is such that most of them are able to survive themselves without there being a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is a process in which there is in which there is a process in which there is a process in which"}, {"heading": "2 Preliminaries", "text": "We consider the statement variables V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-"}, {"heading": "2.1 DPLL-Based Model Counting", "text": "The second important optimization is caching. The second important optimization is caching. Different subtasks can lead to identical subtasks that contain the same number of solutions. The second important optimization is caching. We can lead to identical subtasks that contain the same number of solutions."}, {"heading": "2.2 Answer Set Programming", "text": "An ASP-SAT program P is a Tupel (V, R, C), whereby R is a series of formalities: a) b) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c (v) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c) c))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"}, {"heading": "3 SAT-Based Stable Model Counting", "text": "Most of them are unable to abide by the rules they have imposed on themselves. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. \""}, {"heading": "3.1 Searching on Standard Variables for Stratified Programs", "text": "The first strategy is simply to restrict the search to default variables. If the program is stratified, then the program based variables are functionally defined by the program's default variables. Once the default variables are fixed, all based variables are fixed by propagation (unity propagation to rules and unfounded propagation).In this approach, it is important that the interpretation of the based variables is executed only according to the program's rules and not according to the constraints. Restrictions affecting the founded variables should not be checked until the founded variables are fixed. In Example 1, if we first opt for default variables, then none of the problems occur. E.g. in P1, if s is either fixed to true or false, then we do not get false stable model cubes. Likewise, in P2, if we replace the second assignment with {\u20acu, s} propagating {a, b}, we can still get the same resilience of the program, but in this case it is one for all of the programs."}, {"heading": "3.2 Modifying the Residual Program", "text": "In the ASP solution, we show that it is very useful to make decisions about established variables because they are not justified. (For this reason, we present a newer approach to solve the problem that is pointed out in Example 1 in both cases. (...) In the example, a and b is a problem that applies through search (and possibly propagation), but they are not justified because they do not necessarily have external supporting rules (they are not true under stable model semantics). In the ASP solution, this is not a problem, as the existing unfounded detection algorithms guarantee that in full mappings, a variable being is true. (...) This is not valid for submappings that we need to define stable models. (...) Next, we show that we define the residual rules (not justified)."}, {"heading": "4 PROBLOG2 via Stable Model Counting", "text": "In this context, it should be noted that this project is a project which is, first and foremost, a project."}, {"heading": "5 Experiments", "text": "In fact, most of them are able to start looking for a new partner."}, {"heading": "6 Conclusion", "text": "We show that the current approach of busily translating logic programs into propositional theories is not scalable, because translation explodes when there is a large number of recursive rules in the basic program. To avoid this problem, we give two methods that make it possible to think about much larger logic programs with a high probability."}, {"heading": "A Proofs of theorems and their corollaries", "text": "Theorem 1: \"We are not able to have a rule in S, then it must be wrong.\" Theorem 1: \"We are not able to make the assumptions.\" Theorem 1: \"We must be able to make the assumptions.\" Theorem 2: \"We cannot be able to make the assumptions.\" Theorem 2: \"We cannot be able to make the assumptions.\" Theorem 1: \"We cannot be able to make the assumptions.\" Theorem 2: \"We cannot be able to make the assumptions.\" Theorem 1: \"We cannot be able to make the assumptions.\" Theorem 1: \"We cannot be able to make the assumptions.\" Theorem 1: \"We cannot be able to make the assumptions.\" Theorem 2: \"We cannot be able to make the assumptions.\""}], "references": [{"title": "Computational complexity - a modern approach (Chapter: Complexity of Counting)", "author": ["Arora", "S. Barak 2009] Arora", "B. Barak"], "venue": null, "citeRegEx": "Arora et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Arora et al\\.", "year": 2009}, {"title": "DPLL with Caching: A new algorithm for #SAT and Bayesian Inference", "author": ["Dalmao Bacchus", "F. Pitassi 2003] Bacchus", "S. Dalmao", "T. Pitassi"], "venue": "Electronic Colloquium on Computational Complexity", "citeRegEx": "Bacchus et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Bacchus et al\\.", "year": 2003}, {"title": "Magic sets and other strange ways to implement logic programs", "author": ["Bancilhon"], "venue": "In Proceedings of the fifth ACM SIGACT-SIGMOD symposium on Principles of database systems,", "citeRegEx": "Bancilhon,? \\Q1985\\E", "shortCiteRegEx": "Bancilhon", "year": 1985}, {"title": "Inference in probabilistic logic programs using weighted CNF\u2019s", "author": ["Fierens"], "venue": "Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Fierens,? \\Q2011\\E", "shortCiteRegEx": "Fierens", "year": 2011}, {"title": "Inference and learning in probabilistic logic programs using weighted boolean formulas", "author": ["Fierens"], "venue": "CoRR abs/1304.6810", "citeRegEx": "Fierens,? \\Q2013\\E", "shortCiteRegEx": "Fierens", "year": 2013}, {"title": "Conflict-driven answer set solving", "author": ["Gebser"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Gebser,? \\Q2007\\E", "shortCiteRegEx": "Gebser", "year": 2007}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["Kaufmann Gebser", "M. Schaub 2012] Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Artificial Intelligence", "citeRegEx": "Gebser et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2012}, {"title": "The stable model semantics for logic programming", "author": ["Gelfond", "M. Lifschitz 1988] Gelfond", "V. Lifschitz"], "venue": "ICLP/SLP,", "citeRegEx": "Gelfond et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1988}, {"title": "Modularity aspects of disjunctive stable models", "author": ["Janhunen"], "venue": "In Logic Programming and Nonmonotonic Reasoning, 9th International Conference,", "citeRegEx": "Janhunen,? \\Q2007\\E", "shortCiteRegEx": "Janhunen", "year": 2007}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["Leone"], "venue": "ACM Trans. Comput", "citeRegEx": "Leone,? \\Q2006\\E", "shortCiteRegEx": "Leone", "year": 2006}, {"title": "Why are there so many loop formulas", "author": ["Lifschitz", "Razborov 2006] Lifschitz", "Razborov"], "venue": "ACM Transactions on Computational Logic 7(2):261\u2013268", "citeRegEx": "Lifschitz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2006}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["Lin", "F. Zhao 2004] Lin", "Y. Zhao"], "venue": "Artificial Intelligence", "citeRegEx": "Lin et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Lin et al\\.", "year": 2004}, {"title": "DSHARP: Fast d-DNNF Compilation with sharpSAT", "author": ["Muise"], "venue": "In Canadian Conference on AI,", "citeRegEx": "Muise,? \\Q2012\\E", "shortCiteRegEx": "Muise", "year": 2012}, {"title": "Probabilistic programming concepts", "author": ["Raedt", "L.D. Kimmig 2013] Raedt", "A. Kimmig"], "venue": "In Programming Languages,", "citeRegEx": "Raedt et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Raedt et al\\.", "year": 2013}, {"title": "Combining component caching and clause learning for effective model counting", "author": ["Sang"], "venue": "In Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing (SAT-2004)", "citeRegEx": "Sang,? \\Q2004\\E", "shortCiteRegEx": "Sang", "year": 2004}, {"title": "The complexity of enumeration and reliability problems", "author": ["L.G. Valiant 1979] Valiant"], "venue": null, "citeRegEx": "Valiant,? \\Q1979\\E", "shortCiteRegEx": "Valiant", "year": 1979}, {"title": "Unfounded sets and wellfounded semantics for general logic programs", "author": ["Ross Van Gelder", "A. Schlipf 1988] Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "In Proceedings of the ACM Symposium on Principles of Database Systems,", "citeRegEx": "Gelder et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1988}, {"title": "Compiling probabilistic logic programs into sentential decision diagrams", "author": ["Vlasselaer"], "venue": "In Workshop on Probabilistic Logic Programming (PLP), Vienna", "citeRegEx": "Vlasselaer,? \\Q2014\\E", "shortCiteRegEx": "Vlasselaer", "year": 2014}], "referenceMentions": [{"referenceID": 15, "context": "Consider the counting version of graph reachability problem: given a directed graph, count the number of subgraphs in which node t is reachable from node s (Valiant 1979).", "startOffset": 156, "endOffset": 170}], "year": 2017, "abstractText": "Model counting is the problem of computing the number of models that satisfy a given propositional theory. It has recently been applied to solving inference tasks in probabilistic logic programming, where the goal is to compute the probability of given queries being true provided a set of mutually independent random variables, a model (a logic program) and some evidence. The core of solving this inference task involves translating the logic program to a propositional theory and using a model counter. In this paper, we show that for some problems that involve inductive definitions like reachability in a graph, the translation of logic programs to SAT can be expensive for the purpose of solving inference tasks. For such problems, direct implementation of stable model semantics allows for more efficient solving. We present two implementation techniques, based on unfounded set detection, that extend a propositional model counter to a stable model counter. Our experiments show that for particular problems, our approach can outperform a state-of-the-art probabilistic logic programming solver by several orders of magnitude in terms of running time and space requirements, and can solve instances of significantly larger sizes on which the current solver runs out of time or memory.", "creator": "LaTeX with hyperref package"}}}