{"id": "1606.06900", "review": {"conference": "ACL", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Jun-2016", "title": "Inferring Logical Forms From Denotations", "abstract": "A core problem in learning semantic parsers from denotations is picking out consistent logical forms--those that yield the correct denotation--from a combinatorially large space. To control the search space, previous work relied on restricted set of rules, which limits expressivity. In this paper, we consider a much more expressive class of logical forms, and show how to use dynamic programming to efficiently represent the complete set of consistent logical forms. Expressivity also introduces many more spurious logical forms which are consistent with the correct denotation but do not represent the meaning of the utterance. To address this, we generate fictitious worlds and use crowdsourced denotations on these worlds to filter out spurious logical forms. On the WikiTableQuestions dataset, we increase the coverage of answerable questions from 53.5% to 76%, and the additional crowdsourced supervision lets us rule out 92.1% of spurious logical forms.", "histories": [["v1", "Wed, 22 Jun 2016 11:07:43 GMT  (178kb,D)", "http://arxiv.org/abs/1606.06900v1", null], ["v2", "Tue, 15 Nov 2016 21:24:08 GMT  (178kb,D)", "http://arxiv.org/abs/1606.06900v2", "Published at the Association for Computational Linguistics (ACL) conference, 2016"]], "reviews": [], "SUBJECTS": "cs.CL cs.AI", "authors": ["panupong pasupat", "percy liang"], "accepted": true, "id": "1606.06900"}, "pdf": {"name": "1606.06900.pdf", "metadata": {"source": "CRF", "title": "Inferring Logical Forms From Denotations", "authors": ["Panupong Pasupat", "Percy Liang"], "emails": ["ppasupat@cs.stanford.edu", "pliang@cs.stanford.edu"], "sections": [{"heading": "1 Introduction", "text": "In fact, most of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to, to move, to move, to move, to move, to, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to, to"}, {"heading": "2 Setup", "text": "rE \"s rf\u00fc ide rf\u00fc ide rf\u00fc ide rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf"}, {"heading": "3 Deduction rules", "text": "In this setting, any constructed logical form is a category (Set, Rel, or Map), and these categories are similarly used to construct categories in syntactic parameters. Each deduction rule defines the categories of arguments, categories of the resulting logical form, and how the logical form of arguments is constructed is divided into basic rules and compositional rules. A basic rule follows one of the following templates: TokenSpan [span] \u2192 c [f (span)]] [f [f)."}, {"heading": "4 Dynamic programming on denotations", "text": "Our first step towards finding all correct logical forms is to represent all consistent logical forms (those that lead to the correct designation). Formally, since x, w and y, we want to generate the sentence Z of all logical forms z in such a way that JzKw = y.As mentioned in the previous section, beam searching cannot restore the full sentence Z due to circumcision. Our key observation is that while the number of logical forms explodes, the number of different denotations of these logical forms is much more controlled, since several logical forms can share the same denotation. So, instead of directly enumerating the logical forms, we use dynamic programming on denotations (DPD) inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).The main idea of the DPD is to break off logical forms with the same denotation together, using sumic as a dynamic instead of using cells."}, {"heading": "5 Fictitious worlds", "text": "In fact, it is a way in which people in the USA, in Europe, in the USA, in Europe, in Europe, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA, in the USA"}, {"heading": "6 Experiments", "text": "For the experiments, we use the training part of the WIKITABLEQUESTIONS data set (Pasupat and Liang, 2015), which consists of 14,152 questions on 1,679 Wikipedia tables compiled by crowdworkers, and answering these complex questions requires different types of operations; the same process can be formulated in different ways (e.g. \"best,\" \"best,\" \"worst,\" or \"worst\") and the interpretation of some phrases depends on the context (e.g. \"number\" could be looking up the table or a counting operation); the lexical content of the questions is also quite varied: even without numbers and symbols, the 14,152 training examples contain 9,671 unique words, of which only 10% occur for longer than 10 time periods. We tried to comment the first 300 examples manually using Lambda DCS logical shapes, with 84% of these examples successfully using correct logical shapes, e.g. if the table was constructed by 16 people, which is a good number to reflect the quadruple number, but that they could remain in the table."}, {"heading": "6.1 Generality of deduction rules", "text": "In our more general deduction rules, we use DPD to verify that the rules are able to generate the commented logical form in 76% of the first 300 examples, within the logical size limit smax of 7. These are 90.5% of the examples that were successfully commented. Figure 6 shows some examples of logical forms that we cover that PL15 was not able to. Since DPD is guaranteed to find all consistent logical forms, we can be sure that the uncovered logical forms are due to limitations of the deduction rules. In fact, the remaining examples either have logical forms with a size greater than 7 or require other operations such as addition, merging arbitrary sets, etc."}, {"heading": "6.2 Dynamic programming on denotations", "text": "To demonstrate the savings achieved by breaking down logical forms with the same designation, we are tracking the growth in the number of unique logical forms and designations as the size of the logical form increases. The graph in Figure 7 shows that the space of logical forms explodes much faster than the space of names. The use of designations also saves us from considering a significant number of irrelevant logical subforms. On average, over 14,152 training examples, DPD generates about 25,000 consistent logical forms. The first pass of DPD generates \u2248 153,000 cells (c, s, d), while the second pass only generates \u2248 2,000 cells resulting from \u2248 8,000 rule combinations, resulting in a 98.7% reduction in the number of cells to be considered. Comparison with the bar search. We are comparing DPD with the bar search based on the ability to generate (but not rank) the commented logical forms. We are considering two settings: If the bar search parameters are laser-based (i.e., if the bar search parameters are not laser-based)."}, {"heading": "6.3 Fictitious worlds", "text": "We explore how fictional worlds divide the set of logical forms into equivalent classes, and how the annotated names of the selected worlds help us to circumvent false logical forms. Equivalence classes. Using 30 fictional worlds per example, we produce an average of 1,237 equivalence classes. One possible concern with the use of a limited number of fictional worlds is that we cannot distinguish some pairs of non-equivalent logical forms. We verify the equivalence classes against those calculated on the basis of 300 fictional worlds. We found that only 5% of the logical forms are separated from the original equivalence classes. Ideal annotation of equivalence classes, we choose a subset of 5 fictional worlds commented on the basis of the information theory objective. For each of the 252 examples with an annotated logical form z, we use a different form of equivalence classes."}, {"heading": "7 Related Work and Discussion", "text": "This work evolved from a long tradition of executable semantic parsers, initially from commented logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasdgat and Liang, 2015). A key challenge in learning from denotations is finding consistent logical forms (those that trigger a particular denotation)."}], "references": [{"title": "UW SPF: The University of Washington semantic parsing framework", "author": ["Artzi", "Zettlemoyer2013] Y. Artzi", "L. Zettlemoyer"], "venue": "arXiv preprint arXiv:1311.3011", "citeRegEx": "Artzi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Artzi et al\\.", "year": 2013}, {"title": "Semantic parsing via paraphrasing. In Association for Computational Linguistics (ACL)", "author": ["Berant", "Liang2014] J. Berant", "P. Liang"], "venue": null, "citeRegEx": "Berant et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Berant et al\\.", "year": 2014}, {"title": "Semantic parsing on Freebase from question-answer pairs. In Empirical Methods in Natural Language Processing (EMNLP)", "author": ["Berant et al.2013] J. Berant", "A. Chou", "R. Frostig", "P. Liang"], "venue": null, "citeRegEx": "Berant et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Berant et al\\.", "year": 2013}, {"title": "Driving semantic parsing from the world\u2019s response", "author": ["Clarke et al.2010] J. Clarke", "D. Goldwasser", "M. Chang", "D. Roth"], "venue": "In Computational Natural Language Learning (CoNLL),", "citeRegEx": "Clarke et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Clarke et al\\.", "year": 2010}, {"title": "Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints", "author": ["Cousot", "Cousot1977] P. Cousot", "R. Cousot"], "venue": "In Principles of Programming Languages (POPL),", "citeRegEx": "Cousot et al\\.,? \\Q1977\\E", "shortCiteRegEx": "Cousot et al\\.", "year": 1977}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["S. Gulwani"], "venue": "ACM SIGPLAN Notices,", "citeRegEx": "Gulwani.,? \\Q2011\\E", "shortCiteRegEx": "Gulwani.", "year": 2011}, {"title": "Traversing knowledge graphs in vector space. In Empirical Methods in Natural Language Processing (EMNLP)", "author": ["Guu et al.2015] K. Guu", "J. Miller", "P. Liang"], "venue": null, "citeRegEx": "Guu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Guu et al\\.", "year": 2015}, {"title": "Learning to transform natural to formal languages", "author": ["Kate et al.2005] R.J. Kate", "Y.W. Wong", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Kate et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kate et al\\.", "year": 2005}, {"title": "Inducing probabilistic CCG grammars from logical form with higher-order unification", "author": ["L. Zettlemoyer", "S. Goldwater", "M. Steedman"], "venue": "In Empirical Methods in Natural Language Processing", "citeRegEx": "Kwiatkowski et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2010}, {"title": "Scaling semantic parsers with on-the-fly ontology matching", "author": ["E. Choi", "Y. Artzi", "L. Zettlemoyer"], "venue": "In Empirical Methods in Natural Language Processing (EMNLP)", "citeRegEx": "Kwiatkowski et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2013}, {"title": "Programming by demonstration using version space algebra", "author": ["T. Lau", "S. Wolfman", "P. Domingos", "D.S. Weld"], "venue": "Machine Learning,", "citeRegEx": "Lau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lau et al\\.", "year": 2003}, {"title": "Learning programs: A hierarchical Bayesian approach", "author": ["Liang et al.2010] P. Liang", "M.I. Jordan", "D. Klein"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "Liang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2010}, {"title": "Learning dependency-based compositional semantics", "author": ["Liang et al.2011] P. Liang", "M.I. Jordan", "D. Klein"], "venue": "In Association for Computational Linguistics (ACL),", "citeRegEx": "Liang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2011}, {"title": "Lambda dependencybased compositional semantics. arXiv", "author": ["P. Liang"], "venue": null, "citeRegEx": "Liang.,? \\Q2013\\E", "shortCiteRegEx": "Liang.", "year": 2013}, {"title": "An empirical study of the reliability of UNIX utilities", "author": ["B.P. Miller", "L. Fredriksen", "B. So"], "venue": "Communications of the ACM,", "citeRegEx": "Miller et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Miller et al\\.", "year": 1990}, {"title": "Neural programmer: Inducing latent programs with gradient descent", "author": ["Q.V. Le", "I. Sutskever"], "venue": "In International Conference on Learning Representations (ICLR)", "citeRegEx": "Neelakantan et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Neelakantan et al\\.", "year": 2016}, {"title": "Compositional semantic parsing on semistructured tables. In Association for Computational Linguistics (ACL)", "author": ["Pasupat", "Liang2015] P. Pasupat", "P. Liang"], "venue": null, "citeRegEx": "Pasupat et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Pasupat et al\\.", "year": 2015}, {"title": "Neural programmer-interpreters", "author": ["Reed", "de Freitas2016] S. Reed", "N. de Freitas"], "venue": "In International Conference on Learning Representations (ICLR)", "citeRegEx": "Reed et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Reed et al\\.", "year": 2016}, {"title": "Active learning literature survey", "author": ["B. Settles"], "venue": "Technical report,", "citeRegEx": "Settles.,? \\Q2010\\E", "shortCiteRegEx": "Settles.", "year": 2010}, {"title": "Learning with relaxed supervision", "author": ["Steinhardt", "Liang2015] J. Steinhardt", "P. Liang"], "venue": "In Advances in Neural Information Processing Systems (NIPS)", "citeRegEx": "Steinhardt et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Steinhardt et al\\.", "year": 2015}, {"title": "Neural enquirer: Learning to query tables with natural language. arXiv", "author": ["Yin et al.2016] P. Yin", "Z. Lu", "H. Li", "B. Kao"], "venue": null, "citeRegEx": "Yin et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Yin et al\\.", "year": 2016}, {"title": "Learning to parse database queries using inductive logic programming", "author": ["Zelle", "Mooney1996] M. Zelle", "R.J. Mooney"], "venue": "In Association for the Advancement of Artificial Intelligence (AAAI),", "citeRegEx": "Zelle et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Zelle et al\\.", "year": 1996}, {"title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars", "author": ["Zettlemoyer", "Collins2005] L.S. Zettlemoyer", "M. Collins"], "venue": "In Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Zettlemoyer et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Zettlemoyer et al\\.", "year": 2005}, {"title": "Online learning of relaxed CCG grammars for parsing to logical form", "author": ["Zettlemoyer", "Collins2007] L.S. Zettlemoyer", "M. Collins"], "venue": "In Empirical Methods in Natural Language Processing and Computational Natural Language Learning", "citeRegEx": "Zettlemoyer et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Zettlemoyer et al\\.", "year": 2007}], "referenceMentions": [{"referenceID": 3, "context": ", \u201cWhere did the last 1st place finish occur?\u201d) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).", "startOffset": 96, "endOffset": 187}, {"referenceID": 12, "context": ", \u201cWhere did the last 1st place finish occur?\u201d) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).", "startOffset": 96, "endOffset": 187}, {"referenceID": 2, "context": ", \u201cWhere did the last 1st place finish occur?\u201d) using only question-answer pairs as supervision (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013).", "startOffset": 96, "endOffset": 187}, {"referenceID": 1, "context": ", 2011; Berant et al., 2013; Artzi and Zettlemoyer, 2013). Semantic parsers map the question into a logical form (e.g., R[Venue].argmax(Position.1st, Index)) that can be executed on a knowledge source to obtain the answer (denotation). Logical forms are very expressive since they can be recursively composed, but this very expressivity makes it more difficult to search over the space of logical forms. Previous work sidesteps this obstacle by restricting the set of possible logical form compositions, but this is limiting. For instance, for the system in Pasupat and Liang (2015), in only 53.", "startOffset": 8, "endOffset": 583}, {"referenceID": 13, "context": "5% in Pasupat and Liang (2015). Moreover, unlike beam search, DPD is guaranteed to find all consistent logical forms up to a bounded size.", "startOffset": 18, "endOffset": 31}, {"referenceID": 13, "context": "We follow the construction in Pasupat and Liang (2015) for converting a table into a directed graph (see Figure 2).", "startOffset": 42, "endOffset": 55}, {"referenceID": 13, "context": "We use lambda DCS (Liang, 2013) as the language of logical forms.", "startOffset": 18, "endOffset": 31}, {"referenceID": 10, "context": "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).", "startOffset": 159, "endOffset": 212}, {"referenceID": 11, "context": "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).", "startOffset": 159, "endOffset": 212}, {"referenceID": 5, "context": "So instead of directly enumerating logical forms, we use dynamic programming on denotations (DPD), which is inspired by similar methods from program induction (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011).", "startOffset": 159, "endOffset": 212}, {"referenceID": 18, "context": "This is analogous to standard practices in active learning (Settles, 2010).", "startOffset": 59, "endOffset": 74}, {"referenceID": 13, "context": "We compare our set of deduction rules with the one given in Pasupat and Liang (2015) (henceforth PL15).", "startOffset": 72, "endOffset": 85}, {"referenceID": 7, "context": "This work evolved from a long tradition of learning executable semantic parsers, initially from annotated logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al.", "startOffset": 120, "endOffset": 251}, {"referenceID": 8, "context": "This work evolved from a long tradition of learning executable semantic parsers, initially from annotated logical forms (Zelle and Mooney, 1996; Kate et al., 2005; Zettlemoyer and Collins, 2005; Zettlemoyer and Collins, 2007; Kwiatkowski et al., 2010), but more recently from denotations (Clarke et al.", "startOffset": 120, "endOffset": 251}, {"referenceID": 3, "context": ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).", "startOffset": 44, "endOffset": 157}, {"referenceID": 12, "context": ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).", "startOffset": 44, "endOffset": 157}, {"referenceID": 2, "context": ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).", "startOffset": 44, "endOffset": 157}, {"referenceID": 9, "context": ", 2010), but more recently from denotations (Clarke et al., 2010; Liang et al., 2011; Berant et al., 2013; Kwiatkowski et al., 2013; Pasupat and Liang, 2015).", "startOffset": 44, "endOffset": 157}, {"referenceID": 8, "context": "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the \u201cschema mismatch\u201d\u2014words in the utterance do not map cleanly onto the predicates in the logical form.", "startOffset": 3, "endOffset": 29}, {"referenceID": 8, "context": "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the \u201cschema mismatch\u201d\u2014words in the utterance do not map cleanly onto the predicates in the logical form.", "startOffset": 3, "endOffset": 57}, {"referenceID": 8, "context": "As Kwiatkowski et al. (2013) and Berant and Liang (2014) both noted, a chief difficulty with executable semantic parsing is the \u201cschema mismatch\u201d\u2014words in the utterance do not map cleanly onto the predicates in the logical form. This mismatch is especially pronounced in the WIKITABLEQUESTIONS of Pasupat and Liang (2015). In the second example of Figure 6, \u201chow long\u201d is realized by a logical form that computes a difference between two dates.", "startOffset": 3, "endOffset": 322}, {"referenceID": 10, "context": "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.", "startOffset": 86, "endOffset": 139}, {"referenceID": 11, "context": "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.", "startOffset": 86, "endOffset": 139}, {"referenceID": 5, "context": "Here, previous work has also leveraged the idea of dynamic programming on denotations (Lau et al., 2003; Liang et al., 2010; Gulwani, 2011), though for more constrained spaces of programs.", "startOffset": 86, "endOffset": 139}, {"referenceID": 14, "context": "Continuing the program analogy, generating fictitious worlds is similar in spirit to fuzz testing for generating new test cases (Miller et al., 1990), but the goal there is coverage in a single program rather than identifying the correct (equivalence class of) programs.", "startOffset": 128, "endOffset": 149}, {"referenceID": 6, "context": "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).", "startOffset": 368, "endOffset": 457}, {"referenceID": 15, "context": "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).", "startOffset": 368, "endOffset": 457}, {"referenceID": 20, "context": "For more complex logical forms and larger knowledge graphs, there are many possible angles worth exploring: performing abstract interpretation to collapse denotations into equivalence classes (Cousot and Cousot, 1977), relaxing the notion of getting the correct denotation (Steinhardt and Liang, 2015), or working in a continuous space and relying on gradient descent (Guu et al., 2015; Neelakantan et al., 2016; Yin et al., 2016; Reed and de Freitas, 2016).", "startOffset": 368, "endOffset": 457}], "year": 2017, "abstractText": "A core problem in learning semantic parsers from denotations is picking out consistent logical forms\u2014those that yield the correct denotation\u2014from a combinatorially large space. To control the search space, previous work relied on restricted set of rules, which limits expressivity. In this paper, we consider a much more expressive class of logical forms, and show how to use dynamic programming to efficiently represent the complete set of consistent logical forms. Expressivity also introduces many more spurious logical forms which are consistent with the correct denotation but do not represent the meaning of the utterance. To address this, we generate fictitious worlds and use crowdsourced denotations on these worlds to filter out spurious logical forms. On the WIKITABLEQUESTIONS dataset, we increase the coverage of answerable questions from 53.5% to 76%, and the additional crowdsourced supervision lets us rule out 92.1% of spurious logical forms.", "creator": "LaTeX with hyperref package"}}}