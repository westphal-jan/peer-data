{"id": "0912.5511", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Dec-2009", "title": "A general approach to belief change in answer set programming", "abstract": "We address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs. We introduce methods for revising and merging logic programs, respectively. For the former, we study both subset-based revision as well as cardinality-based revision, and we show that they satisfy the majority of the AGM postulates for revision. For merging, we consider operators following arbitration merging and IC merging, respectively. We also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.", "histories": [["v1", "Wed, 30 Dec 2009 18:33:43 GMT  (190kb,S)", "http://arxiv.org/abs/0912.5511v1", "44 pages"]], "COMMENTS": "44 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["james delgrande", "torsten schaub", "hans tompits", "stefan woltran"], "accepted": false, "id": "0912.5511"}, "pdf": {"name": "0912.5511.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["jim@cs.sfu.ca.", "torsten@cs.uni-potsdam.de."], "sections": [{"heading": null, "text": "The idea behind this is that the people who stay in the city, move in the city and in the city, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they, in which they live, in which they, in which they, in which they, in which they live, in which they, in which they, in which they, in which they live, in which they, in which they, in which they, in which they, in which they live, in which they, in which they live, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they, in which they live, in which they, in which they, in which they, in which they, in which they, in which they, in which they, live, in which they, in which they, in which they, in which they, in which they, in which, live, in which they, in which they, live, in which they, in which they, in the city, in which they, in which they, in the city, in which they, in the city, in which they, in the city, they live, in which they live, in which they live, in which they, in which they, in which they live, in which they live, in which they live, in which they, in which they, in the city, in which they, in the city, in which they live, in which they live, in which they live,"}, {"heading": "1. INTRODUCTION", "text": "This is an essential area of knowledge representation and reasoning (KRR) research. On the one hand, ASP has an elegant and conceptually simple theoretical foundation, while on the other hand, there are efficient implementations of ASP solvers that have found applications for practical problems. However, as is the case with any large program or body of knowledge, a logical program is not a static object in general, but rather it is subject to change, whether as a result of correcting information in the program, adding to the existing information, or in another way that modifies the knowledge presented in the programs. As knowledge is continuously evolving and subjected, there is a need to revise logical programs as new information. In KRR, the area of faith revision is received."}, {"heading": "2. BACKGROUND AND FORMAL PRELIMINARIES", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Answer Set Programming", "text": "The answer is a standard response for which a rule r \u2264 m < j \u2264 n < l \u2264 p. Operators \"; and\" express disjunctive and conjunctive connectives. \"A standard response is a standard response or its negation. A rule r as in (1) is referred to as fact if p = 1, normal if n = 1, positive if m = n and o = p, disjunctive, disjunctive and connective."}, {"heading": "2.2 Belief Change", "text": "2.2.1 The best known and indeed secondary work in faith revision is the AGM approach [Alchourro \"n et al. 1985; Ga\" rdenfors 1988], which sets standards for faith revision and contraction functions. In the revision of a knowledge base K by a formula \u03c6, the intention is that the resulting knowledge should be consistent with respect to our approach (unless we no longer consider it consistent), while any information from K can be \"reasonably maintained.\" Faith contraction is a dual term in which information is removed from a knowledge base K; given that it is of limited interest with respect to our approach, we do not consider it further. Furthermore, it is generally accepted that a contradiction function is achieved by the so-called Harper identity and the reversal of the Levi identity; see Ga \"rdenfors [1988] for details assuming that a knowledge base is maintained in relation to a static domain."}, {"heading": "2.3 Belief Change in Logic Programming", "text": "Most previous work on faith changes for logic programs has been titled update [Foo and Zhang 1997; Przymusinski and Turner 1997; Zhang and Foo 1998; Alferes et al. 1998; 2000; Leite 2003; Inoue and Sakama 1999; Eiter et al. 2002; Zacar\u0131 as et al. 2005; Delgrande et al. 2007]. Strictly speaking, however, such approaches generally do not address \"updating,\" at least insofar as the term is understood in the faith revision community, where updating refers to a faith change in response to a change in the world being modeled [Katsuno and Mendelzon 1992]; this notion of change is not taken into account in traditional work. A common feature of most updating approaches is a sequence P1, P2,..., pn of programs in which each pi is a logic program."}, {"heading": "Initialisation. \u2205 \u2217 P \u2261 P .", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Idempotency. (P \u2217 P ) \u2261 P .", "text": "If Q is tautologous, then P \u043d P.Absorbation. If Q = R, then (P \u0445 Q) \u0445 R) \u2261 (P \u0445 Q).Augmentation. if Q'R, then (P \u0445 Q) \u0445 R) \u0445 (P \u0445 R).Considering the failure of several of the postulates discussed in the approach of Eiter et al. [2002] (as well as in others), Osorio and Cuevas [2007] noted that for the reinterpretation of the standard AGM postulates in the context of logic programs, the strong equivalence underlying the logic should be assumed. Since Osorio and Cuevas [2007] studied programs with strong negation, this led them to consider logic N2, an extension of HT by introducing strong negation.3 They also introduced a new principle, which they called weak independence of syntax (WIS)."}, {"heading": "3. BELIEF CHANGE IN ASP BASED ON SE MODELS", "text": "The beliefs of an agent can also be characterized abstractly by a series of interpretations or possible worlds; these would correspond to the models of the beliefs of the agent. Finally, as proposed in the Katsuno-Mendelzon formulation, and assuming a finite language, the beliefs of an agent can be specified by a formula. In view of a finite language, it is easy to translate between these representations. In ASP, there are terms analogous to the above for indicating the beliefs of an agent. Although we will not go into this, the notion of a strong equivalence of logical programs can be used to define a (logical program) conviction set. In fact, a set of well-defined SE models characterizes a class of equivalent logic programs."}, {"heading": "3.1 Expanding Logic Programs", "text": "Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q"}, {"heading": "3.2 Revising Logic Programs", "text": "Next, we turn to specific revision operators. As discussed above, for a revision Q-Q Q-Q-Q-Q-Q-Q-SE, we propose that the most natural distance-based term of revision for logical programs (SE-2) is set containment as a suitable means of referring to SE interpretations. Consequently, we begin to consider set-containment-based revision. While these two approaches correspond to the two best-known ways of including distance-based models of Q, they are not exhaustive and other reasonable models of distance. 3.2.1 Set-containment-based revision. The following definition gives us for interpretations E1, E2, the subset of E1 closest to E2, where the notion of the \"narrowest\" symmetric revision is given."}, {"heading": "3.3 Complexity of Revision", "text": "We now turn to the complexity of our approach to the revision. First, we recapitulate the complexity classes which are relevant for the following questions: Q = > NP = Q. As usual, the notation CA stands for the relativized version of C, consisting of all the problems which can be decided by Turing machines of the same type and time bound as in C, only that the machines have access to an oracle for problems in A.Four complexity classes which are here relevant, viz. NP: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: P2: 2: P2: P2: P2: P2: P2: P2: P2: P2: 2: P2: P2: 2: P2: P2: P2: 2: 2: P2: 2: P2: 2: P2: 2: P2: 2: 2: P2: 2: P2: 2: P2: 2: 2: P2: 2: 2: 2: P2: 2: 2: P2: 2: 2: P2: 2: 2: P2: 2: 2: 2: 2: P2: 2: 2: 2: 2: P2: 2: 2: P2: 2: 2: 2: 2: P2: P2: 2: 2: P2: 2: 2: 2: 2: 2: P2: 2: 2: 2: 2: 2: 2: P2: 2: 2: 2: 2: 2: 2: 2:"}, {"heading": "4. MERGING LOGIC PROGRAMS", "text": "We designate (generalized) logic programs by P1, P2,.., reserve P0 for a program that represents global constraints as described later. For logic programs P1, P2, we define P1 P2 as a program with SE models corresponding to SE (P1) and SE (P2), and P1 P2 as a program with SE models corresponding to SE (P1). By a faith profile we mean a sequence of (generalized) logic programs 6 < P1,.., Pn >."}, {"heading": "4.1 Arbitration Merging", "text": "The result of the conciliation is a logical program composed of models that differ from each of these minimally varying models. Note that, especially if a set of programs is common consistent, there are then models in which all the constituent SE models are equal. That is, the second models that vary minimally are those in which Si = Sj for each 1 \u2264 i, j \u2264 n; and the merger is the same, as if one would simply take the unification of the programs. The first definition provides an idea of a distance between the models of the two, while the second then defines the merger in relation to this provision. 6This departs from usual practice, where a belief profile is usually to be a multiset.ACM Transactions on Computational Logic, Vol. V, No. N, Month 20Y.FINI.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I.I"}, {"heading": "4.2 Basic Merging", "text": "For the second approach to the merger, the programs P1,.., Pn are merged with the target logic program P0, so that the SE models are taken from the models of P0 during the merger. This operator is referred to as the (fundamental) merger of P1,..., Pn with respect to P0. The information in P0 must be valid during the merger and can therefore be regarded as necessarily holding. Konieczny and Pino Pe'rez [2002] refer to P0 as a set of integrity limitations, although this use of the term differs from its use in logic programs. Note that in the case where SE (P0) is the totality of all SE models, the two approaches (this section and the previous section) do not coincide and that merger is generally a weaker operator than arbitrariness."}, {"heading": "Then, define S \u2264b T , if S0 \u2296 Sj \u2286 T0 \u2296 Tj for every 1 \u2264 j \u2264 n.", "text": "As in the case of arbitral fusion \u2264 b is a partial ordinance. < b > q = > q = < v (N) all the minimal elements of a SettN of tuples become relative to \u2264 b. In the extension of our notation for the reference to components of tuples, we also define N0 = > q (S). Therefore, we can formulate our definition of basic fusion as follows: DEFINITION 15. Let it be: < Pn > a faith profile. Then the basic fusion or simply fusion of tuples is a logical program (L)."}, {"heading": "4.3 Complexity Analysis", "text": "In the previous section, the following decision problem regarding the revision provider was examined: (1) GLPs P, Q, R, does P \u043a Q | = s R? This problem has proven to be \"P2 -complete.\" Accordingly, here we give results for the following problems: (1) Does the faith profile and the revision problem also apply to the respective problems related to the merger? (2) Does the faith profile and the program \"R\" apply? Theorem 12 can show that the hardness result for the revision problem also applies to the respective problems related to the merger. On the other hand, a \"P2\" membership can be achieved by a slight extension of the codes given in the next section, so that these extensions have an answer to the respective problem (1) or (2). Since the test whether a program has at least one answer is a problem on the second layer of the polynomial hierarchy, and our (extended decision) the problem (iff) is not the respective (1) of the affiliation."}, {"heading": "5. COMPUTING BELIEF CHANGE VIA ANSWER SET PROGRAMMING", "text": "In this section we follow the tradition of meta-programming (see, for example, the works of Delde Fixed 2003 et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et et.).)."}, {"heading": "5.1 Basic Modules", "text": "We start with a simple fragment containing some domain predicates and fixes for certain identifiers. DEFINITION Q (SE = Q-Q) 17.\u03c0domain = {prog rule (P, R) \u2190 \u03b1 (P, R, A) \u2190 (P, A) | Q (Q, pbody, nhead, nbody) {prog (P) \u2190 Prog rule (P, R), model (c) \u2190 (t), model (h), prog model (c) \u2190 (c), prog model (c), prog model (t), prog model (h), prog model (P), prog rule (\u00b7), dom (\u00b7), and prog model (\u00b7) are only used to collect some information from a consolidated input field; the constants assigned c, t, h are later used to differentiate between different guesses for models."}, {"heading": "5.2 Encodings for Revision", "text": "amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp; amp;"}, {"heading": "Moreover, let", "text": "Rather, the question we need to ask ourselves is whether we need to use a particular saturation technology (also called spoiling), which is quite common to encode problems from the second level of the polynomial hierarchy, since we can no longer fall back on weak constraints (which implicitly compared different models and SE models). First, let's look at the two main modules for the revision we are applying:"}, {"heading": "5.3 Encodings for Merging", "text": "5.3.1 Basic Merging (t). Continuing with the problem of basic merging, we now assume that we have all faith profiles (Pn > with an arbitrary number of programs). < Pn > with an arbitrary number of programs, we will not have to add any more concepts and only define the pernicious conditions: DEFINITION 26.basic = {spoil) win (P, h), wout (P, A, t), spoil (P, R, M), spoilcond (M) notsubseteq (M, 0, J), prog model (M), spoilcond (c), samediff all (c), spoilcond all (c), spoilcond (t)."}, {"heading": "6. DISCUSSION", "text": "We have addressed the problem of changing belief in logic programming within the framework of response set semantics. Our general approach is based on a monotonous characterization of logic programs, in terms of the amount of SE models of a program. On the basis of the latter, we first define and examine operators for the extension and revision of logical programs. Both subset-based revision and cardinality-based revision were considered. In addition to the characteristics of these operators, we also looked at their complexity. This work is new as it relates to belief changes in terms familiar to researchers in revision: expansion is characterized in terms of intersections of models, and revision is characterized in terms of minimal distances between models. We have also addressed the problem of merging logical programs within the framework of response set semantics. Again, the approaches are based on a monotonical characterization of logical programs given in terms of the set of models."}, {"heading": "A. APPENDIX", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "A.1 Proof of Theorem 1", "text": "Most parts result directly from the fact that SE (P + Q) = SE (P) = SE (P) = SE (Q) Q (Q) SE (Q). (1) We must show that definition 6 leads to a well-defined set of SE models. (2) For SE (P) SE (Q) SE (Q) (Q) we have a trivially well-defined (and R can be given by E). (3) Otherwise for SE (P) SE (Q) results in 6 = E (Q): If (X, Y) SE (P) and SE (Q), then (X, Y) SE (P) and SE (P) SE (P); whence (Y, Y) SE (P) and (Y) SE (Q) are well-defined."}, {"heading": "A.2 Proof of Theorem 2", "text": "(RA1).This postulate follows directly from definition 8. Note that (X, Y) Q (Q) Q (Q) Q (P) Q (Q) Q (Q) Q (Q) only if Y (Q), Mod (P))) and thus (Y) Q (SE) Q (Q). So, SE (P) Q (Q) is well defined. (RA2). If P + Q (P) is satisfactory, then we have that both models (Q), Mod (P) 6 = and (SE) 6 (Q), SE (P) 6 = unresolved. (Next, for Y) Mod (Q) (or (X, Y) Mod (Q)), it isACM transactions on Computational Logic, Vol. V, No. N, Month 20Y.some Y (P) Mod (P)."}, {"heading": "A.3 Proof of Theorem 3", "text": "For initialization, idempotence and tautology on the left side of the given equivalence, the revision corresponds to the expansion via (RA2), from which the result is immediate; for absorption we have Q = R, and so (((P \u0445 Q) \u0445 R) = (P \u0445 Q) \u0445 Q)); since SE (P \u0445 Q) SE (Q), then from Theorem 1, part 3, we have the (P \u0445 Q) + Q \u2261 s P \u0445 Q. Likewise (P \u0445 Q) \u0445 Q) = (P \u0445 Q) + Q), which results in our result. 2ACM transactions on computational logic, band V, no. N, month 20yy."}, {"heading": "A.4 Proof of Theorem 4", "text": "If SE (P) = \u2205, then SE (P \u0445 Q) = SE (Q) = SE (P \u0445 w Q). Otherwise, there are two cases to consider: (1) (X, Y), SE (P \u0445 Q), where X-Y), (X, Y), (SE (Q) and (X, Y) according to definition 8. Definition 8 implies that Y (Mod (Q), Mod (P) and SE (P) according to definition 9. (2) (Y, Y) and SE (P \u0445 Q). Definition 8 implies that Y (Mod (Q), Mod (P), Mod (P)), Mod (Y) and SE (SE (Q), SE (P), SE (P) and thus according to definition 9, (Y, Y) and SE (P)."}, {"heading": "A.5 Proof of Theorem 5", "text": "Before providing the proof, we first present a problem that is crucial for the postulates (RA5) and (RA6). (LEMMA) (E1, E2, and E3 (E2, E2). (E1, E2) (E3, E3) (E1, E2). (E1, E2) (E2) (E3, E2). (PROOF.) (E1, E2) (E3, E3). (E3) (E3, E3). (X, Y) (X, Y). (X, Y) (E1, Y). (E2) (E2, E2). (E2). (E1, E2). (E2). (E2). (E1, Y). (X, Y). (E2). (E1, E2). (E2). (E2)."}, {"heading": "A.6 Proof of Theorem 6", "text": "The proof is the same as for theorem 3."}, {"heading": "A.7 Proof of Theorem 7", "text": "Since we are dealing with a global fixed language, we need a few lemmata.LEMMA 2. Let P, Q, Q, Q, Q, Q, Q, Q, Q, Q, Q, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE, SE"}, {"heading": "A.8 Proof of Theorem 9", "text": "The definitions of arbitration and fundamental merger (definitions 13 and 15) consist essentially of two parts (as well as the definitions for revision): There is a formulation that deals with classic statement models (or SE form models (Y, Y) and then general SE models. For brevity reasons, and because the case for statement models arises directly from the case of general SE models, here we look at general SE models in the evidence. (LS1) - (LS7) These all follow trivially or directly from the definition of P1 P2. (LS8) Assuming that P1 and P2 > are satisfactory, it follows that SE (< P1, P2 >) 6 = and so Mina (SE (< P1, P2 >) 6 = satisfactory."}, {"heading": "A.9 Proof of Theorem 10", "text": "Let us assume a faith profile, P0 a program that represents global constraints, and \"as it is defined in Definition 15\" (b), \"as it is\" (b), \"as it is\" (b), \"as it is\" (b), \"as it is\" (b), \"as it is\" (b), \"as it is\" (b), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is\" (c), \"as it is.\""}, {"heading": "A.10 Proof of Theorem 11", "text": "Let's first prove a helpful lemma.LEMMA 5. Let's be a faith profile. If X-Mina (SE) then for Xi-X we have < Xi, X-Minb (SE (< \u2205, EY >).PROOF. Let's be a faith profile, and let X-Mina (SE). Therefore, for each Y-SE (EX) we have this Y-X implied that X-X. Let X0 = Xi for it i. So let's replace that Yi-Yj Xi Xj for each 1 \u2264 i, j \u2264 |. So for each fixed i, we have that Yi Yj Xi Xj implies that Xi Xj. Let X0 = Xi for it i. So we get that Yi Yj X0 XJ Yi Yi. But that means that & lt0 X.Minol (EX)."}, {"heading": "A.11 Proof of Theorem 12", "text": "These results are directly derived from the corresponding definitions."}], "references": [], "referenceMentions": [], "year": 2009, "abstractText": "We address the problem of belief change in (nonmonotonic) logic programming under answer set semantics. Unlike previous approaches to belief change in logic programming, our formal techniques are analogous to those of distance-based belief revision in propositional logic. In developing our results, we build upon the model theory of logic programs furnished by SE models. Since SE models provide a formal, monotonic characterisation of logic programs, we can adapt techniques from the area of belief revision to belief change in logic programs. We first consider belief revision: given logic programs P and Q, the goal is to determine a program R that corresponds to the revision of P by Q, denoted P \u2217 Q. We investigate several specific operators, including (logic program) expansion and two revision operators based on the distance between the SE models of logic programs. It proves to be the case that expansion is an interesting operator in its own right, unlike in classical AGM-style belief revision where it is relatively uninteresting. Expansion and revision are shown to satisfy a suite of interesting properties; in particular, our revision operators satisfy the majority of the AGM postulates for revision. Second, we consider approaches for merging logic programs. Given logic programs P1, . . . , Pn, the goal is to provide characterisations of the merging of these programs. Again, our formal techniques are based on notions of relative distance between the underlying SE models of the logic programs. Two approaches are examined. The first informally selects those models of the programs that vary the least from the models of the other programs. The second approach informally selects those models of a program P0 that are closest to the models of programs P1, . . . , Pn. In this case, P0 can be thought of as analogous to a set of database integrity constraints. We examine properties of these operators with regards to how they satisfy relevant postulate sets. We also present encodings for computing the revision as well as the merging of logic programs within the same logic programming framework, giving rise to a direct implementation of our approach in terms of off-the-shelf answer set solvers. These encodings reflect in turn the fact that our change operators do not increase the complexity of the base formalism.", "creator": "dvips(k) 5.95a Copyright 2005 Radical Eye Software"}}}