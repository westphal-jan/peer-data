{"id": "1001.0820", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jan-2010", "title": "Abstract Answer Set Solvers with Learning", "abstract": "Nieuwenhuis, Oliveras, and Tinelli (2006) showed how to describe enhancements of the Davis-Putnam-Logemann-Loveland algorithm using transition systems, instead of pseudocode. We design a similar framework for several algorithms that generate answer sets for logic programs: Smodels, Smodels-cc, Asp-Sat with Learning (Cmodels), and a newly designed and implemented algorithm Sup. This approach to describing answer set solvers makes it easier to prove their correctness, to compare them, and to design new systems.", "histories": [["v1", "Wed, 6 Jan 2010 05:53:29 GMT  (191kb,S)", "http://arxiv.org/abs/1001.0820v1", "Long version of the paper that will appear in special issue of Theory and Practice of Logic Programming"]], "COMMENTS": "Long version of the paper that will appear in special issue of Theory and Practice of Logic Programming", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["yuliya lierler"], "accepted": false, "id": "1001.0820"}, "pdf": {"name": "1001.0820.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["yuliya@cs.utexas.edu"], "sections": [{"heading": null, "text": "ar Xiv: 100 1.08 20v1 [cs.AI] 6J an2 010"}, {"heading": "Abstract Answer Set Solvers with Backjumping", "text": "and learning (long version)"}, {"heading": "YULIYA LIERLER", "text": "Department of Computer ScienceUniversity of Texas at Austin1 University Station C0500Taylor Hall 2.124Austin, USAE-mail: yuliya @ cs.utexas.edu"}, {"heading": "Abstract", "text": "Nieuwenhuis, Oliveras and Tinelli (2006) demonstrated how to describe extensions of the Davis-Putnam-Logemann-Loveland algorithm using transitional systems instead of pseudo codes. We are designing a similar framework for several algorithms that generate response sets for logic programs: Smodels, Smodelscc, Rapsat with Learning (cmodels), and a newly designed and implemented algorithm sup. This approach to describing response solvers makes it easier to prove their accuracy, compare them, and design new systems.KEYWORDS: answer set programming, inference, learning"}, {"heading": "1 Introduction", "text": "This is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. It is a matter of time until there will be a solution. \""}, {"heading": "2 Review: Abstract DPLL and Logic Programs", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Abstract Classical DPLL", "text": "For a set of atoms, a data set M is relative to a list of words above an intersection in which (i) some dictionaries in M are commented on by a set of words that identify them as decision literature, (ii) M contains no repetitions, but the concatenation of two such lists is indicated by a series of dictionaries. (i) Often, we consider a data set as a set of dictionaries that ignores both the annotations and the order between its elements. A literal l is not assigned by a data set if neither l nor its complement l belongs to it. (8) http: / / www.cs.uni-potsdam.de / clasp /.A State relative to the annotations is either a differentiated state FailState or a record relativeto. For example, the states are relative to a singleton series {a} of atoms areFailState, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a."}, {"heading": "Proof", "text": "The characteristic of X that we must prove is trivial in the initial state. < M, so that there is no satisfaction if it satisfies all the decision-makers. M, so that there is no satisfaction if it satisfies all the decision-makers. M, so that M, so that it satisfies all the decision-makers. M, so that it satisfies all the decision-makers who contain at least one decision. It is clear that the rule justifying the transition from M to M differs from failure. For each of the other three rules is M, so that M, from a list of letters containing at least one decision, is literal. It is clear that the rule justifying the transition from M to M is sufficient. If X satisfies all the decision-letters in M, then we satisfy all M. Unit propagate: M, so it is. By the inductive hypothesis, for every literal question."}, {"heading": "2.2 Logic Programs", "text": "We will consider programs consisting of endless rules of forma-b1,. bl, not bl + 1,.. b), not b), not b), not (3), but (3), not (4), and also not (5), if a sentence of a rule (3) is an atom, then we will identify (3) with the rule that (3), not (4), and also not (5), if a sentence of a rule (3) is an atom, then we will identify (3) with the rule that (3). b), not (4), and not (5)."}, {"heading": "3 Generating Supported Models", "text": "In Section 4, for an arbitrary program, we will define a graph sm\u044b, which represents the application of the modelling algorithm to \"; the terminal nodes of sm\u044b are response sets of.\" As a step in this direction, we describe a simpler graph atleast\u044b here."}, {"heading": "3.1 Graph atleast\u03a0", "text": "The transitional rules that define atleast\u044b are closely related to the Atleast approach (Simons 2000, Section 4.1), which is one of the core procedures of the Smodel algorithm. The nodes of atleast\u044b are the states relative to the set of atoms that occur in the group. The edges of the graph atleast\u044b are described by the transitional rules Decide, Fail, Backtrack introduced in Section 2.1 and the additional transitional rules9 Episode 2 from (Sacca \"and Zaniolo 1990) refers to\" assumptions \"and not to baseless propositions. But, as the authors have noted, in the context of this episode the two concepts are equivalent in equivalents.10 The names of some of these rules follow (Ward 2004).in Figure 2. Note: Each of the rules Unit Propagate LP and Backchain False is comparable to Unit Propagate."}, {"heading": "Proof", "text": "We will show that ownership is called into question when it challenges all decision-makers; we will show that ownership is called into question when it challenges all decision-makers; we will show that X satisfies all decision-makers in M and that X satisfies all decision-makers in M. Unit Propagate LP: M \u2032 is M a. By the inductive hypothesis that every model in M satisfies all the decision-makers in question; we will show that X satisfies all decision-makers in M. Unit Propagate LP: M \u2032 is M \u2032 is M a. By the inductive hypothesis that every model in question is satisfied; we will show that ownership is in question."}, {"heading": "4 Answer Set Solver Smodels", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1 Abstract Smodels", "text": "We now describe the graph sm\u0430, which represents the application of the Smodels algorithm to the program. (sm\u0430) This graph is a graph whose nodes are the same as the nodes of the graph atleast\u0442. The edges of sm\u0430 are described by the transition rules of atleast\u044b and the additional transition rule: Unfounded: M = \u21d2 M \u00ac a if {M is consistent, and a \"U\" for a set U for a set U on M w.r.t. This transition rule of sm\u0430 is closely related to the Atmost procedure (Simons 2000, Section 4.2), which, together with the Atleast procedure, forms the core of the Smodels algorithm. The graph sm\u0430 can be used to decide whether the program has an answer by constructing a path from an end node: Proposition 4 For each program, (a) graph smb is a finite and acyclic is a finite, (c) the graph c is a mass (c), and the prech is a mass (M)."}, {"heading": "Proof", "text": "It follows from Lemma 3 that X is unfounded. Therefore, any non-empty subset of X, including X-U, is not unfounded on X. This means that for some rules a-B applies in a way that A-X-U, B-X-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-"}, {"heading": "Proof", "text": "Remember that for each assignment X, if X + is an answer set for \u0438, then X is a supported model, and that the transition system extends only through the transition rule Unfounded. Given our proof of Lemma 2, we only need to show that the application of Unfounded is property. Consider any assignment X as an unfounded assignment M = \u21d2 M \u00b2, where M is a sequence l1.... lk. M \u00b2 is M \u00b2 a, so that a \"U,\" where U is an unfounded set on M w.r.t. Let us take each assignment X as an answer set for \u0435 and X fulfills all decision letters l \u00b2 j \u2264 k. By the inductive hypothesis X | = M. Then X | = \u00ac a. Otherwise, an assignment would be a common element of X and U vacant, which is Lemma 4.\u0131b \u00b2."}, {"heading": "4.2 Smodels Algorithm", "text": "Therefore, we can consider a path in the sm\u0442 graph as a description of a process of searching for an answer set for a program by applying inference rules. In particular, a strategy can be based on assigning priorities to some or all of the sm\u0442's inference rules, so that a solver in a state will never apply a transitional rule when a higher priority rule is applicable to the same state. We use this method to describe the sm\u0442 algorithm. System models the sm\u0442's inference rules as follows: Backtrack, Fail, Unit Propagate LP, All Rules Cancelled, Backchain True, Backchain False, Unfunded, Undefined, Decide.For example, the smodel algorithm can follow a path (8)."}, {"heading": "4.3 Tight Programs", "text": "We will now review the definitions of a positive dependency graph and a strict program. G's positive dependency graph is the directed graph G in such a way that the nodes of G are the atoms that occur in \"a,\" and \u2022 G contains the edges from a to bi (1 \"i\") for each rule (8) is not narrow because its positive dependency graph has a cycle based on rule d \"c\" d. On the other hand, the program constructed by (8) by eliminating this rule is narrow if its positive dependency graph is acyclic. Program (8) is not narrow because its positive dependency graph has a cycle based on rule d \"d\" d. On the other hand, the program constructed by (8) by eliminating this rule is narrow. Recall that for each program and each assignment M, ifM + is an answer that is a supported \"model of M.\""}, {"heading": "Proof", "text": "From the definition of an unfounded quantity it follows that there is an unfounded quantity for each atom; from the definition of an unfounded quantity it follows that there is an unfounded quantity for each atom; from sentence 5 it follows that the subgraph of the positive dependence of the quantity induced by U has no end nodes; then the program is not tight; in view of sentence 5 it is sufficient to prove that sm \u2212 \u0442 is equal to atleast\u0442 or, in other words, that every edge of the odour unjustified by the rule is only singular. Consider such an edge M = \u21d2 M. We must show that another transition rule is applicable to M. From the definition of Unfounded or Decide, M is consistent and there is a non-empty quantity U based on M w.r.From sentence 6 it follows that another transition rule is applicable to M as Unfounded or Decide."}, {"heading": "5 Generate and Test", "text": "D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-D-"}, {"heading": "Proof", "text": "We will show that the property in question is maintained by the transition rule test. Let's take a model X of F-G and consider an edge M = \u21d2 M where M is a listl1... lk so that X li satisfies if it satisfies all decision literals l-j with j-i. Let's assume that X satisfies all decision literals of M. From the inductive hypothesis it follows that X | = M. We will show that the rule justifying the transition from M to M differs from test. By contradiction. M \u00b2 is M \u00b2 M \u00b2. By the definition of test, G is | = M. Since X is a model of F-G, it follows that X | = M. This contradicts the fact that X | = M \u00b2. The production of 6 part (a) and part (c) from right to left is a model that is literally applicable."}, {"heading": "6 Review: Abstract DPLL with Learning", "text": "Most modern SAT solutions are not capable of reflecting a change in a newly learned state. \"Most modern SAT solutions are not suitable to capture such a technology because it is not able to reflect a change.\" \"Most modern SAT solutions can be considered a prototype of such a transition.\" \"Most modern SAT solutions are designed as a prototype of such a transition.\" \"Most modern SAT solutions implement so-called conflict-driven rebound and learning processes.\" \"In this section we will expand the graphics dpF to capture the ideas behind rebound and learning processes.\" \"The new graphics will be closely related to the DPLL system that introduced the learning curve (Nieuwenhuis et al. 2006, Section 2.4). We note that the graphics dpF is not suitable to capture such a technique because it is unable to reflect a change in a newly learned state."}, {"heading": "7 Answer Set Solver with Learning", "text": "In this section we will expand the graph sm\u0442 to capture jumping backwards and learning. As a result, we will be able to model the algorithms of the systems modelscc and sup."}, {"heading": "7.1 Graph sml\u03a0", "text": "An (advanced) state in relation to a program is either a distinguishable state or a pair of form M-State, in which M-Land is a record with respect to the number of atoms occurring in that country, and a (multi) series of constraints formed from atomic techniques occurring in that country, which are implemented in each program, we will define a graph that represents the advanced states in relation to other countries.The Transition Rules Unit Propagate LP, All Rules Cancelled, Backchain True, Decide and Fail of smouth are expanded as a graph as follows: M-Land is an advanced graph-graph-graph-graph-graph graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph-graph"}, {"heading": "8 Generate and Test with Learning", "text": "In this section we model jumping backwards and learning for generating and testing procedures by defining a graph gtlF, GAn (extended) state relative to a CNF formula F and a formula G formed from atoms that occur in F is either a differentiated state failstate or a pair of the form M | E, where M is a record (Section 2.1) relative to a set of atoms that occur in F, and a (multi-) set of clauses that are formed from atoms that occur in F. The node of the graph gtlF, G are the extended states relative to a group of atoms that occur in F, and a formula G is a set of clauses that are formed from atoms that occur in F. The edges of gtlF, G are the augmented states relative to a CNF formula F and a formula G consisting of atoms that occur in F."}, {"heading": "8.2 Cmodels Algorithm", "text": "In fact, it is not that one has been able to abide by the rules, as was the case in the past. (...) It is not as if one has been able to abide by the rules. (...) It is not as if one has been able to abide by the rules. (...) It is not as if one has been able to abide by the rules. (...) It is not as if one has been able to abide by the rules. (...) It is not as if one has been able to abide by the rules. (...) It is not as if one has been able to abide by them. (...) It is not as if one has been able to abide by them. (...) It is not as if one has been able to abide by them. (...) It is not in a position to abide by them. (...) It is not in a position to abide by them. (...) It is not in a position to abide by them. (...) It is not in a position to abide by them."}, {"heading": "9 Backjumping and Extended Graph", "text": "We remember that the Backjump LP transition rule can be derived from the results of the later answer to this question. \"The Backjump LP transition rule.\" \"The Backjump LP transition rule.\" \"The Backjump LP transition rule.\" \"The Backjump LP transition rule is applicable to a backjump state and if so, to which state the Backjump LP transition rule is applicable, these questions are important if we want to base an algorithm on this framework.\" The Backjump LP transition rule is applicable to a backjump state. \"\" The Backjump LP jump rule is applicable to any backjump state in sml. The Backjump LP jump rule is applicable to a backjump state in sml. Skip rule 11 guarantees that a backjump state in sml. The Backjump LP transition rule is never semi-terminal."}, {"heading": "10 Proofs of Proposition 8\u2191, Lemma 8, Proposition 11\u2191", "text": "10.1 Proof of the sentence 8 \u2191 Lemma 9 For any program, an extended record M relative to N and any assignment X, so that X + is an answer set for N, if X fulfills all decision literals in M, then X | = M."}, {"heading": "Proof", "text": "Let us assume that the property is valid for any state with n elements. Let us consider any state M with n + 1 elements. Let X be an assignment, so that X + is an answer set in M and X fulfills all decision literals in M. We will now show that X | = M. Case 1. M has the form P l. Due to the inductive hypothesis X | = P. Since X. fulfills all decision letters in M, it follows from (ii) C P. From (ii) it follows that P | = l. C has the form P l. From the inductive hypothesis follows X | = P. From the definition of a reason it follows that X + represents an answer for each assignment X, X = l."}, {"heading": "Proof", "text": "(a) For each list N of letters by | N | we denote the length of N \u00b2. Each state M | | 2 has the form M0 l \u00b2 1 M1... l \u00b2 p Mp | 2, where l \u00b2 1.. l \u00b2 p are all decision letters of M; we define \u03b1 (M | 2) as a sequence of non-negative integers | M0 | M1 |,... l \u00b2 p \u00b2 p \u00b2, and \u03b1 (FailState) =. For all states S and S \u00b2 of sml \u00b2 p \u00b2, we understand \u03b1 (S) < \u03b1 (S \u00b2) as a lexicographic order. We first state that for each state M | 3, value of \u03b1 is applicable only to the first component M of the state. Secondly, there is a finite number of different values of \u03b1 due to the fact that there is a finite number of different M \u00b2 s. We come to the conclusion that there is a finite number of different values."}, {"heading": "10.2 Proof of Lemma 8", "text": "The proof uses the term loop formula (Lin and Zhao 2004). Faced with a group A of atoms of bodies (\u044e, A), we denote the set consisting of the elements of bodies (\u207b, a) for all a in A. Let's be a program. For each group Y of atoms, the external support formula (Lee 2005) is for Y \"B\" solids (\u044e, Y), B + \"Y\" = \u2205 B. (20) We will denote the external support formula by ESA, Y. For each group Y of atoms, the loop formula for Y is the implication of \"a\" Ya \"\u2192 ESA, Y. We can paraphrase this formula as a disjunction:\" a \"Y\" a \"ESA, Y.\" (21) From the main theorem in (Lee 2005) we conclude:"}, {"heading": "Lemma on Loop Formulas", "text": "For each program, there are loop formulas (21) for all sets Y of atoms that appear in the diagram sml \u2191 \u0438. For a state S in the diagram sml \u2191 \u0438 we say that S \u2193 in the diagram sml 1978 is the image of S.Lemma 8. For each program, if S \u2032 is a state that can be reached in the diagram sml\u0438, then in the diagram sml 1970s there is a state S \u2193 = S \u2032."}, {"heading": "Proof", "text": "Since the property trivial applies to the initial state, we just have to prove that all the transition rules of sml\u0442 get them. Consider an edge M | | servation = \u21d2 M \"| | servation\" in the diagram sml \"i\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c. \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c \"c\" c c \"c c c c c\" c c c c c c \"c c c c c c\" c c c c c \"c c c c c c\" c c c c c c \"c c c c c c\" c c c c c \"c c c c c c\" c c c c c \"c c c c\" c c c \"c c c c c\" c c \"c c\" c c c \"c c c c\" c c \"c\" c c c c \"c\" c c \"c c c\" c c c \"c c c c c c\" c c c \"c c c c c c c\" c c \"c c c"}, {"heading": "Unit Propagate LP :", "text": "It is enough to demonstrate that M1 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2."}, {"heading": "10.3 Proof of Proposition 11\u2191", "text": "For example, let M be the first component of the last state in (27): a) b) f (c) f (c) f f) f (f) f (f) f (f) f) f (f) f (f) f f (f) f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f) f (f) f (f) f) f (f) f (f) f (f) f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f (f) f) f (f) f (f) f (f) f (f) f (f) f (f) f) f (f) f (f) f) f (f) f) f (f) f) f (f) f (f) f) f (f) f) f (f) f) f (f) f) f (f) f (f) f) f (f) f (f) f) f (f) f (f) f) f (f) f) f (f (f) f (f) f) f (f (f) (f) f) f) f (f (f) (f) (f) f) f (f) (f (f) (f) (f) (f) f (f) (f) f (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) (f) ("}, {"heading": "Proof", "text": "By requiring (iii) the definition of an extended record, the dictionary immediately following lcp (M) lC cannot be annotated with any annotation. Consequently, the dictionary has the form lC. We now show that C is a contradictory clause on M. Since l immediately follows the largest consistent prefix on M, it immediately follows that l is in lcp (M) lcp (M). From this we conclude that C is in fact a contradictory clause on M. For every contradictory clause C follows this clause, by \u03b2l1 \u00b7 ln (C) lcp (M). We conclude that C is in fact a contradictory clause on M."}, {"heading": "Proof", "text": "(i) Clause D is a resolution of B and C at some literal level. (i) Clause D is a resolution of B and C at some literal level. (i) Clause D is a resolution of B and C. To show that D is a contradictory clause, we must show that D lcp (M) is a contradictory clause and that D lcp (M) is a contradictory clause on M. Since C is a contradictory clause on M, C lcp (M) is a reason to be in lcp (M). From the fact that lcp (M) is consistent, it follows that there is no literal word in B, so that its completion occurs in C. Consequently, l \"B\" is a contradictory clause, so that l \"l\" and D are a decision of B. We conclude that D is \"lcp.\""}, {"heading": "Proof", "text": "We must show that (i) l 6, lcp (M) dec (C)] and (ii) l, lcp (M) dec (C)] l, i.e. that l, l, c, lcp (M) dec (C)] are related. Da l, c, lcp (M) dec (M)].Da l, c, lcp (M) and l, lcp (M) are related, this is followed by l, 6, lcp (M).Da l, c, lcp (M) dec (C)].Since l, lcp (M) is contradictory, l results in l, c and l, c, lcp (M). Consequently, c, lcp (M).From the definition of decM (C) it follows that decM (C) is the decision level of the letter in C."}, {"heading": "Proof", "text": "It is clear that this process ends after deriving some clauses in C1, C2 and some clauses in C2. It is contradictory. From Lemma 11 (i) and the choice of C1 and R follows that every clause in C1, C2. It is contradictory. From Lemma 11 (i) and the choice of C1 and R follows that each clause in C2, C2. It is contradictory. From Lemma 11 (ii) we conclude that \u03b2M) < \u03b2M (Cj \u2212 1) (j > 1). It is clear that this process ends after deriving some clauses in Cm, since the number of contradictory clauses in Cm is not sufficient."}, {"heading": "BackjumpClause (M ||\u0393);", "text": "The reason for the leap clause is that the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause and in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause in the leap clause."}, {"heading": "11 FirstUIP Conflict-Driven Backjumping and Learning", "text": "In addition, the authors in (Zhang et al. 2001) examined the performance of various tutorials and experimentally determined that the FirstUIP clause is the most useful single clause for learning. Success in conflict-driven learning led to the implementation of its ASP counterpart in systems moddelscc, clasp, and sup. There are two common methods of describing a construction of a backjump clause in SAT literature: the first clause deals with the implication graph (Marques-Silva and Sakallah 1996), and the second clause deals with resolution (Mitchell 2005). Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the Smodels algorithm and implemented FirstUIP learning clause in response to the solution concept moddelscc. In the previous section, we used sml-Uumpse formalism and resolution to implement the BackjumpClause algorithm for calculating an ASP part of a definition."}, {"heading": "BackjumpClauseFirstUIP (M ||\u0393);", "text": "In other words: \"It is an imperfect state in which it comes to an imperfect state.\" In other words: \"It is an imperfect state in which it comes to an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\" In other words: \"It is an imperfect state.\""}, {"heading": "12 Extended Graph: Generate and Test", "text": "In this section we present an extended diagram gtl \u2191 F, G for generating and testing abstract frame gtlF, G similar to in section 9 we introduced sml \u2191 for sml.A for a formula H, say that a formula l \u00b2 C is a reason that l in a list P lQof Literals w.r.t. H, if H | l \u00b2 C and C \u00b2 P \u00b2.A (extended) record M is relative to a formula H, is a list of literals about the Setof atoms that occur in H, where (i) every literal l is annotated in M, either by a reason for l in Mw.r.t. H, (ii) M contains no repetitions, (ii) M its last letter is annotated by a reasoning. A (extended) state relative to a CNF formula F, and a formula G of atoms that is formed from F."}, {"heading": "13 Proofs of Proposition 9\u2191, Lemma 13, Proposition 10\u2191", "text": "13.1 Proof of theorem 9 \u2191 Lemma 14For each CNF formula F, a formula G formed from atoms occurring in F, an extended dataset M relative to F-G, and any model X of F-G, if X meets all decision literals in M, then X | = M."}, {"heading": "Proof", "text": "Let us assume that the property is valid for any state with n elements. Let us consider any state M with n + 1 elements. Let X be a model of F-G, so that X fulfils all decision literature in M. Case 1. M has the form P l-C. From the inductive hypothesis follows X | = P. From the definition of a mind (i) F-G follows l-C and (ii) C-P. From (ii) follows that P-C. Consequently, from the inductive hypothesis follows X-l-C. From the definition of a mind (i) F-G follows an l-terminal C and (ii) C-t. from (ii) follows that P-c."}, {"heading": "13.2 Proof of Lemma 13", "text": "For a state S in the diagram gtl \u2191 F, G we say that S \u2193 in gtlF, G is the picture of S. Lemma 13 For each CNF formula F and a formula G formed from atoms occurring in F, there is a state S in the diagram gtl \u2191 F, G, so that S \u2193 = S \u2032 can be reached."}, {"heading": "Proof", "text": "Since the property is trivial to the initial state, all we have to prove is that all the transition rules of gtlF, G obtain it. Consider an edge M, which appears in the diagram gtlF, G so that there is a state M1, G that fulfills its image in gtlF, G. Consider several cases that correspond to a transition rule corresponding to M, E, M, G, G, G, G, G, G, G, G, M, M, M, M, M, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, M, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G"}, {"heading": "13.3 Proof of Proposition 10\u2191", "text": "In this section, F is an arbitrary and fixed CNF formula, and G is an arbitrary and fixed formula formed from atoms occurring in F. For a record M, lcp (M) is the largest consistent prefix. We say that a sentence C on a list of M words is contradictory when F-G entails C and C-lcp (M). Lemmas 10, 11, 12 apply in the case of an extended data set relative to a formula. The proofs of the lemmata only need to be changed by replacing them with F-G. Proposition 10 \u2191. BackjumpClause and BackjumpClauseFirstUIP algorithms apply to the states of the diagram gtl 4, G."}, {"heading": "14 Experiments with Sup", "text": "Here we present experimental analyses that compare the performance of the system sup against cmodels, clasp, models, and modelscc. We begin by describing the implementation details of sup.The implementation used by sup \u2022 the interface of SAT solver minisat (v1.12b), which supports non-clausal constraints described in (Een and So \ufffd rensson 2003) to introduce additional inference possibilities, but the propagation of units. Specifically, sup implements backchain True and All Rules Cancelled by non-clausal constraints and it uses the unit propagate of minisat to capture Unit Propagate LP and Backchain False. \u2022 Parts of cmodels code that eliminate weight and selection rules; perform modeling; and forced loop formulas. Specifically, sup uses the latter two parts of cmodels code to capture the unfounded."}, {"heading": "15 Related Work", "text": "Simons (2000) and Ward (2004) described the Smodel and Smodelscc algorithms using pseudo-code and demonstrated their accuracy. In this paper, we designed an abstract framework that was used as an alternative method of describing these algorithms and demonstrating their accuracy. Gebser and Schaub (2006) provided a deductive system to describe conclusions that are used in calculating response sentences by tableaux methods. The abstract framework presented here can also be considered a deductive system, but of a very different kind. First, it takes into account phenomena such as backjumping and learning (and also forgetting and restarting), while the Gebser-Schaub system does not. Second, we do not describe traceability by an inference rule, and the Gebser-Schaub system. Accordingly, the derivatives considered in this paper do not describe the search process and derivations in the Gebser-Schaub system. Nor do the abstract frame works discussed here describe traceability by an inference rule, and the Gebser-Schaub system does not."}, {"heading": "16 Conclusions", "text": "In this paper, we have shown how to model advanced algorithms for calculating a program's response sets using simple mathematical objects, graphs. We have expanded the abstract frameworks proposed in (Lierler 2008) to describe native and SAT-based ASP algorithms to capture such complex features as backjumping and learning. We characterize the algorithms of systems moddelscc, sup and cmodels that implement these features. We note that working on this abstract framework suggested the implementation of Response Set Solver sup, and the experimental analysis presented here shows that sup is a competitive representative in the family of Response Set Solvers. The abstract framework simplifies the analysis of the correctness of algorithms and allows us to study the relationship between different algorithms by analyzing the differences in strategies to choose a path in the graph. For example, the description of the algorithm and the simple way it reflects the differences in the response model in the algorithm."}, {"heading": "Acknowledgments", "text": "We are grateful to Marco Maratea for drawing our attention to the work of Nieuwenhuis et al. (2006), Vladimir Lifschitz for the numerous discussions, Martin Gebser, Michael Gelfond and Miros law Truszczyn \u0301 ski for valuable ideas and comments, anonymous arbitrators for their proposals. The author was supported by the National Science Foundation under grant IIS-0712113."}], "references": [{"title": "Negation as failure", "author": ["K. Clark"], "venue": "Logic and Data Bases, H. Gallaire and J. Minker, Eds. Plenum Press, New York, 293\u2013322.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "A machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7), 394\u2013397.", "citeRegEx": "Davis et al\\.,? 1962", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "An extensible sat-solver", "author": ["N. Een", "N. S\u00f6rensson"], "venue": "SAT.", "citeRegEx": "Een and S\u00f6rensson,? 2003", "shortCiteRegEx": "Een and S\u00f6rensson", "year": 2003}, {"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science 1, 51\u201360.", "citeRegEx": "Fages,? 1994", "shortCiteRegEx": "Fages", "year": 1994}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907). MIT Press, 386\u2013392.", "citeRegEx": "Gebser et al\\.,? 2007", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Tableau calculi for answer set programming", "author": ["M. Gebser", "T. Schaub"], "venue": "Proceedings of 22nd International Conference on Logic Programming (ICLP\u201906). Springer, 11\u201325.", "citeRegEx": "Gebser and Schaub,? 2006", "shortCiteRegEx": "Gebser and Schaub", "year": 2006}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning 36, 345\u2013377.", "citeRegEx": "Giunchiglia et al\\.,? 2006", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "On the relation between answer set and SAT procedures (or, between smodels and cmodels)", "author": ["E. Giunchiglia", "M. Maratea"], "venue": "Proceedings of 21st International Conference on Logic Programming (ICLP\u201905). Springer, 37\u201351.", "citeRegEx": "Giunchiglia and Maratea,? 2005", "shortCiteRegEx": "Giunchiglia and Maratea", "year": 2005}, {"title": "Satisfiability solvers", "author": ["C.P. Gomes", "H. Kautz", "A. Sabharwal", "B. Selman"], "venue": "Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 89\u2013134.", "citeRegEx": "Gomes et al\\.,? 2008", "shortCiteRegEx": "Gomes et al\\.", "year": 2008}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503\u2013508.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "Abstract answer set solvers", "author": ["Y. Lierler"], "venue": "Proceedings of International Conference on Logic Programming (ICLP\u201908). Springer, 377\u2013391.", "citeRegEx": "Lierler,? 2008", "shortCiteRegEx": "Lierler", "year": 2008}, {"title": "What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence", "author": ["V. Lifschitz"], "venue": "MIT Press, 1594\u20131597.", "citeRegEx": "Lifschitz,? 2008", "shortCiteRegEx": "Lifschitz", "year": 2008}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 112\u2013117.", "citeRegEx": "Lin and Zhao,? 2002", "shortCiteRegEx": "Lin and Zhao", "year": 2002}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157, 115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Fast SAT-based answer set solver", "author": ["Z. Lin", "Y. Zhang", "H. Hernandez"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 92\u201397.", "citeRegEx": "Lin et al\\.,? 2006", "shortCiteRegEx": "Lin et al\\.", "year": 2006}, {"title": "Conflict analysis in search algorithms for propositional satisfiability", "author": ["J.P. Marques-Silva", "K.A. Sakallah"], "venue": "Proceedings of IEEE Conference on Tools with Artificial Intelligence.", "citeRegEx": "Marques.Silva and Sakallah,? 1996", "shortCiteRegEx": "Marques.Silva and Sakallah", "year": 1996}, {"title": "A SAT solver primer", "author": ["D.G. Mitchell"], "venue": "EATCS Bulletin (The Logic in Computer Science Column). Vol. 85. 112\u2013133.", "citeRegEx": "Mitchell,? 2005", "shortCiteRegEx": "Mitchell", "year": 2005}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM 53(6), 937\u2013977.", "citeRegEx": "Nieuwenhuis et al\\.,? 2006", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "A backjumping technique for disjunctive logic programming", "author": ["F. Ricca", "W. Faber", "N. Leone"], "venue": "AI Commun. 19, 2, 155\u2013172.", "citeRegEx": "Ricca et al\\.,? 2006", "shortCiteRegEx": "Ricca et al\\.", "year": 2006}, {"title": "Stable models and non-determinism in logic programs with negation", "author": ["D. Sacc\u00e1", "C. Zaniolo"], "venue": "Proceedings of ACM Symposium on Principles of Database Systems (PODS). 205\u2013217.", "citeRegEx": "Sacc\u00e1 and Zaniolo,? 1990", "shortCiteRegEx": "Sacc\u00e1 and Zaniolo", "year": 1990}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons"], "venue": "Ph.D. thesis, Helsinki University of Technology. Adviser-Niemel\u00e4, Ilkka.", "citeRegEx": "Simons,? 2000", "shortCiteRegEx": "Simons", "year": 2000}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K. Ross", "J. Schlipf"], "venue": "Journal of ACM 38, 3, 620\u2013650.", "citeRegEx": "Gelder et al\\.,? 1991", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "Answer set programming with clause learning", "author": ["J. Ward"], "venue": "Ph.D. thesis. AdviserLong, Timothy J. and Adviser-Schlipf, Johns S.", "citeRegEx": "Ward,? 2004", "shortCiteRegEx": "Ward", "year": 2004}, {"title": "Answer set programming with clause learning", "author": ["J. Ward", "J. Schlipf"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904). 302\u2013313.", "citeRegEx": "Ward and Schlipf,? 2004", "shortCiteRegEx": "Ward and Schlipf", "year": 2004}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.W. Moskewicz", "S. Malik"], "venue": "Proceedings ICCAD-01. 279\u2013285.", "citeRegEx": "Zhang et al\\.,? 2001", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 12, "context": "Answer Set Programming (ASP) is a methodology commonly used for solving combinatorial search problems (Lifschitz 2008).", "startOffset": 102, "endOffset": 118}, {"referenceID": 9, "context": "In the development of ASP solvers, computational ideas behind SAT solvers (Gomes et al. 2008) play an important role.", "startOffset": 74, "endOffset": 93}, {"referenceID": 19, "context": "For instance, dlv implements backjumping (Ricca et al. 2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven", "startOffset": 41, "endOffset": 60}, {"referenceID": 24, "context": "2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven", "startOffset": 23, "endOffset": 46}, {"referenceID": 11, "context": "The ASP solver sup (Lierler 2008) implements these features also.", "startOffset": 19, "endOffset": 33}, {"referenceID": 18, "context": "In this paper our main goal is to show how the \u201cabstract\u201d approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features.", "startOffset": 105, "endOffset": 130}, {"referenceID": 18, "context": "In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures.", "startOffset": 3, "endOffset": 28}, {"referenceID": 11, "context": "In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning.", "startOffset": 3, "endOffset": 17}, {"referenceID": 17, "context": "Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.", "startOffset": 160, "endOffset": 175}, {"referenceID": 16, "context": "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).", "startOffset": 34, "endOffset": 67}, {"referenceID": 17, "context": "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).", "startOffset": 101, "endOffset": 116}, {"referenceID": 11, "context": "In (Lierler 2008), we introduced the basic algorithm underlining the system sup but neglected some of its features: conflict-driven backjumping, learning, forgetting, and restarts.", "startOffset": 3, "endOffset": 17}, {"referenceID": 11, "context": "The ASP solver sup (Lierler 2008) implements these features also. In this paper our main goal is to show how the \u201cabstract\u201d approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features. Usually computation procedures are described in terms of pseudocode. In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures. They introduced an abstract framework that captures what \u201dstates of computation\u201d are, and what transitions between states are allowed. In this way, it defines a directed graph such that every execution of the dpll procedure corresponds to a path in this graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking. This allows the authors to model a dpll-like algorithm by a mathematically simple and elegant object, graph, rather than a collection of pseudocode statements. In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning. In this paper, we expand our previous work on abstract answer set solvers to cover such features as backjumping and learning (and also forgetting and restart). We start by introducing an abstract framework that captures a general mechanism of these sophisticated features in ASP solvers. For instance, this framework provides the transition underlying the process of learning a clause, but it does not suggest which clause shall be learned. Similarly, it provides a general description of backjumping but it does not supply the means for computing a \u201cbackjump clause\u201d necessary for an answer set solver to perform backjumping. We then enhance this abstract framework to capture enough information about a state of computation for deriving a backjump clause. Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. There are two common methods for describing a backjump clause construction. One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005). Ward and Schlipf (2004) extended the notion of an implication graph to the smodels algorithm.", "startOffset": 20, "endOffset": 2322}, {"referenceID": 17, "context": "7 The names of the backjump clauses follow (Mitchell 2005).", "startOffset": 43, "endOffset": 58}, {"referenceID": 18, "context": "We start the paper with Section 2 that reviews the abstract DPLL framework introduced in (Nieuwenhuis et al. 2006) and some logic programming concepts.", "startOffset": 89, "endOffset": 114}, {"referenceID": 1, "context": "Path (1) corresponds to an execution of dpll in the sense of (Davis et al. 1962); path (2) does not, because it applies Decide to a even though Unit Propagate could be applied in this state.", "startOffset": 61, "endOffset": 80}, {"referenceID": 6, "context": "A set X of atoms is an answer set for a program \u03a0 if X is minimal (with respect to set inclusion) among the sets of atoms that satisfy the reduct \u03a0 (Gelfond and Lifschitz 1988).", "startOffset": 148, "endOffset": 176}, {"referenceID": 20, "context": "\u03a0 (Corollary 2 from (Sacc\u00e1 and Zaniolo 1990)).", "startOffset": 20, "endOffset": 44}, {"referenceID": 20, "context": "9 The Corollary 2 from (Sacc\u00e1 and Zaniolo 1990) refers to \u201dassumption sets\u201d rather than unfounded sets.", "startOffset": 23, "endOffset": 47}, {"referenceID": 23, "context": "10 The names of some of these rules follow (Ward 2004).", "startOffset": 43, "endOffset": 54}, {"referenceID": 0, "context": "It is well known that the supported models of a program can be characterized as models of program\u2019s completion in the sense of (Clark 1978).", "startOffset": 127, "endOffset": 139}, {"referenceID": 20, "context": "Lemma 3 (Corollary 2 from (Sacc\u00e1 and Zaniolo 1990)) For any model M of a program \u03a0, M is an answer set for \u03a0 if and only if M is unfounded-free.", "startOffset": 26, "endOffset": 50}, {"referenceID": 3, "context": "For the case of tight programs, the converse holds also: M is an answer set for \u03a0 if and only if M is a supported model of \u03a0 (Fages 1994) or, in other words, is a model of the completion of \u03a0.", "startOffset": 125, "endOffset": 137}, {"referenceID": 21, "context": "With respect to the actual smodels algorithm (Simons 2000), singular edges of the graph sm\u03a0 are inessential: in view of priorities for choosing a path in sm\u03a0 described in Section 4.", "startOffset": 45, "endOffset": 58}, {"referenceID": 8, "context": "A similar relationship, in terms of pseudocode representations of smodels and dpll, is established in (Giunchiglia and Maratea 2005).", "startOffset": 102, "endOffset": 132}, {"referenceID": 13, "context": "This modification of the graph dpF is of interest, for example, in connection with the fact that answer sets of a program \u03a0 can be characterized as models of its completion extended by so called loop formulas of \u03a0 (Lin and Zhao 2002).", "startOffset": 214, "endOffset": 233}, {"referenceID": 13, "context": "This is important because LF (\u03a0) can be very long (Lin and Zhao 2002).", "startOffset": 50, "endOffset": 69}, {"referenceID": 7, "context": "asp-sat with Backtracking (Giunchiglia et al. 2006) is a procedure that computes models of the completion of the given program using dpll, and tests them until an answer set is found.", "startOffset": 26, "endOffset": 51}, {"referenceID": 18, "context": "12 from (Nieuwenhuis et al. 2006).", "startOffset": 8, "endOffset": 33}, {"referenceID": 18, "context": "8 from (Nieuwenhuis et al. 2006)).", "startOffset": 7, "endOffset": 32}, {"referenceID": 18, "context": "The transition rules Restart and Forget LP are similar to the analogous rules in (Nieuwenhuis et al. 2006) for extending dpll procedure with restart and forgetting techniques.", "startOffset": 81, "endOffset": 106}, {"referenceID": 24, "context": "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of sml\u03a0.", "startOffset": 61, "endOffset": 84}, {"referenceID": 11, "context": "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of sml\u03a0.", "startOffset": 93, "endOffset": 107}, {"referenceID": 11, "context": "In (Lierler 2008), we introduced the simplified sup algorithm that relies on backtracking rather than conflict-driven backjumping and learning that are actually implemented in the system.", "startOffset": 3, "endOffset": 17}, {"referenceID": 14, "context": "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al.", "startOffset": 75, "endOffset": 94}, {"referenceID": 7, "context": "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2006) (see Section 8.", "startOffset": 107, "endOffset": 132}, {"referenceID": 7, "context": "System cmodels implements an algorithm called asp-sat with Learning (Giunchiglia et al. 2006) that extends asp-sat with Backtracking by backjumping and learning.", "startOffset": 68, "endOffset": 93}, {"referenceID": 7, "context": "The clause learned due to this application of Learn GT is derived by means of loop formulas (see (Giunchiglia et al. 2006)).", "startOffset": 97, "endOffset": 122}, {"referenceID": 15, "context": "Systems sag (Lin et al. 2006) and clasp (Gebser et al.", "startOffset": 12, "endOffset": 29}, {"referenceID": 4, "context": "2006) and clasp (Gebser et al. 2007) are answer set solvers that are enhancements of cmodels.", "startOffset": 16, "endOffset": 36}, {"referenceID": 14, "context": "The proof uses the notion of loop formula (Lin and Zhao 2004).", "startOffset": 42, "endOffset": 61}, {"referenceID": 10, "context": "For any set Y of atoms, the external support formula (Lee 2005) for Y is", "startOffset": 53, "endOffset": 63}, {"referenceID": 10, "context": "From the Main Theorem in (Lee 2005) we conclude: Lemma on Loop Formulas For any program \u03a0, \u03a0 entails loop formulas (21) for all sets Y of atoms that occur in \u03a0.", "startOffset": 25, "endOffset": 35}, {"referenceID": 17, "context": "instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.", "startOffset": 31, "endOffset": 46}, {"referenceID": 25, "context": "Furthermore, in (Zhang et al. 2001) the authors investigated the performance of various learning schemes and established experimentally that FirstUIP clause is the most useful single clause to learn.", "startOffset": 16, "endOffset": 35}, {"referenceID": 16, "context": "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).", "startOffset": 45, "endOffset": 78}, {"referenceID": 17, "context": "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).", "startOffset": 118, "endOffset": 133}, {"referenceID": 24, "context": "Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the smodels algorithm and implemented FirstUIP learning schema in answer set solver smodelscc.", "startOffset": 17, "endOffset": 40}, {"referenceID": 4, "context": "In (Gebser et al. 2007) the authors used the concepts from constraint processing to implement FirstUIP learning schema in answer set solver clasp.", "startOffset": 3, "endOffset": 23}, {"referenceID": 2, "context": "12b) that supports non-clausal constraints described in (Een and S\u00f6rensson 2003) in order to introduce additional inference possibilities, but unit propagation.", "startOffset": 56, "endOffset": 80}, {"referenceID": 5, "context": "Gebser and Schaub (2006) provided a deductive system for describing inferences involved in computing answer sets by tableaux methods.", "startOffset": 0, "endOffset": 25}, {"referenceID": 11, "context": "We extended the abstract frameworks proposed in (Lierler 2008) for describing native and SATbased ASP algorithms to capture such sophisticated features as backjumping and learning.", "startOffset": 48, "endOffset": 62}, {"referenceID": 17, "context": "We are grateful to Marco Maratea for bringing to our attention the work by Nieuwenhuis et al. (2006), to Vladimir Lifschitz for the numerous discussions, to Martin Gebser, Michael Gelfond, and Miros law Truszczy\u0144ski for valuable ideas and comments, to anonymous referees for their suggestions.", "startOffset": 75, "endOffset": 101}], "year": 2010, "abstractText": "Answer Set Solvers with Backjumping and Learning (long version)", "creator": "LaTeX with hyperref package"}}}