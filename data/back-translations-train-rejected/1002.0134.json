{"id": "1002.0134", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Jan-2010", "title": "Constraint solvers: An empirical evaluation of design decisions", "abstract": "This paper presents an evaluation of the design decisions made in four state-of-the-art constraint solvers; Choco, ECLiPSe, Gecode, and Minion. To assess the impact of design decisions, instances of the five problem classes n-Queens, Golomb Ruler, Magic Square, Social Golfers, and Balanced Incomplete Block Design are modelled and solved with each solver. The results of the experiments are not meant to give an indication of the performance of a solver, but rather investigate what influence the choice of algorithms and data structures has.", "histories": [["v1", "Sun, 31 Jan 2010 15:36:36 GMT  (84kb,D)", "http://arxiv.org/abs/1002.0134v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.PF", "authors": ["lars kotthoff"], "accepted": false, "id": "1002.0134"}, "pdf": {"name": "1002.0134.pdf", "metadata": {"source": "CRF", "title": "Constraint solvers: An empirical evaluation of design decisions", "authors": ["Lars Kotthoff"], "emails": [], "sections": [{"heading": null, "text": "To assess the impact of design decisions, instances of the five problem classes n-Queens, Golomb Ruler, Magic Square, Social Golfers and Balanced Incomplete Block Design are modeled and solved with each solver. The results of the experiments are not intended to indicate the performance of a solver, but rather to investigate the influence of the choice of algorithms and data structures.The analysis of the impacts of design decisions focuses on the different types of memory management, behavior with increasing problem size, and specialized algorithms for certain types of variables. Other, less important decisions are also briefly considered."}, {"heading": "1 Introduction", "text": "Contemporary constraint solvers are very complex software systems. Each of the many systems available today has its own characteristics, its own design decisions made by the implementors, and its own philosophy. It is often not easy to determine the characteristics of a solver that affect performance for a particular problem class or instance. Therefore, selecting a particular solver is a difficult task that requires expertise about each solver and is likely to have a significant impact on performance. In addition, each solver has different ways of modeling problems. Not only do users need experience with a particular solver to model a problem in such a way that it can be solved efficiently, but it is also difficult to objectively compare solutions.This paper examines a small selection of constraint solvers and evaluates their performance against problem models designed to be as similar as possible."}, {"heading": "2 Background", "text": "The first constraint solvers were implemented as constraint logic programming environments in logical programming languages such as Prolog in the early 1980s. The logic programming paradigm is a natural way to solve constraint problems, since things like deep-first backtracking search and non-determinism are already built into the host language. Similar ideas arose in the operative field and in research on artificial intelligence. Xiv: 100 2.01 34v1 [cs. AI] 31 January 2010Notable developments at the time include extensions of prolog and the CHIP constraint programming system. Since the 1990s, constraint programming has found its way into procedural and object-oriented languages, in particular C + +. ILog Solver was a pioneer in this area. It was shown that it would be advantageous to divide the solution of constraint problems into two phases; modeling of the problem and the search for the solver have improved significantly in terms of both constraint and performance since then."}, {"heading": "3 Surveyed constraint solvers", "text": "The constraint solvers selected for this work are Choco [12], version 2.0.0.3, ECLiPSe [1], version 6.0 42, Gecode [10], version 2.2.0 and Minion [2], version 0.7. Solvers were chosen because they are currently in active development and are open source; implementation details not described in papers or the manual can be examined by looking at the source code. Table 1 presents a brief summary of the solvers and their basic properties. Choco Choco was originally developed in the CLAIRE programming language, as a national effort by French researchers for an open constraint solver for teaching and research purposes."}, {"heading": "4 Surveyed constraint problems", "text": "/ / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /"}, {"heading": "4.1 Amount of search", "text": "The number of searches that each solver performs for each instance of problems is roughly the same. This has been ensured by comparing the number of nodes for each instance for the solvers that provide nodes, by visually inspecting the search tree for solvers that provide visualization tools, and by manually comparing the decisions made on each node of the search tree for smaller instances."}, {"heading": "5 Results", "text": "This year, it has come to the point where it is a reactionary party that is able to establish itself in the region."}, {"heading": "5.1 Specialised variable implementations", "text": "The aforementioned persons are in a position to abide by the rules that they are in a position to put themselves in, and in a position to put themselves in a position, to put themselves in a position, to put themselves in a position, to put themselves in a position, to put themselves in a position, to put themselves in a position, to put themselves in a position, to put themselves in the position they are in."}, {"heading": "5.2 Setup costs and scaling", "text": "In all experiments except the Golomb-Ruler problem, Gecode is the fastest solver for the problem that takes the least CPU time to solve. As the time needed to solve the problem increases, its CPU time increases relative to that of the other solvers, so it is no longer the fastest solver. Choco and ECLiPSe run in abstract machines that need to be set up at program startup. Minion reads an input file, analyzes it, and constructs the problem to solve it. Overhead explains the differences in CPU time compared to Gecode for the small problems."}, {"heading": "5.3 Memory management", "text": "Table 4 summarizes the storage management approaches used for the different solutions. The following sections mainly cover the different ways to implement backtrack storage, as this is the most important storage management decision that needs to be made in a constraint problem solver."}, {"heading": "5.3.1 Recomputation versus copying", "text": "This year, it is so far that it is only a matter of time before it is ready, until it is ready."}, {"heading": "5.3.2 Copying versus trailing", "text": "The n-Queens, the Social Golfers and the Balanced Incomplete Block Design problems were repeated with copying rather than copying, because the correlation between the CPU time and the number of backtracks is stronger than the correlation between the CPU time and the number of variables. Figure 9 shows the results. In all cases of problems, trailing works better than copying. In the n-Queens problem, the differences are only up to about 20% due to the small number of variables (see Table 2). The results for the Social Golfers and the Balanced Incomplete Block Design problems show that the relative difference between trailing and copying backtrack storage increases with the number of backtracks."}, {"heading": "5.3.3 Sensitivity to number of variables", "text": "This year, it is only a matter of time before an agreement is reached."}, {"heading": "5.3.4 Garbage collection", "text": "The n-Queens, the Social Golfers and the Balanced Incomplete Block Design problem classes were repeated, with garbage collection turned off. Results were compared with the results where garbage collection was turned on with the Wilcoxon test. Differences are statistically significant at the level of 0.01. Results are presented in relation to the number of backtracks, because the correlation between the CPU time and the number of backtracks turned on is stronger than the correlation between the CPU time and the number of variables. Figure 11 shows that the CPU times for runs with garbage collection are up to 35% higher than the correlation between the CPU time and the number of backtracks turned on for the Social Golfers problem. CPU times for Balanced Incomplete Block Design are similar, but less pronounced. One possible reason for this is the lower number of backtracks. The amount of memory that the CPU Queens use is so small that the overall problems for Balanced Incomplete Block Design cannot be significantly improved, the results are not only related to the number of backtracks."}, {"heading": "5.4 Order of propagators", "text": "Choco, ECLiPSe, and Gecode offer ways to prioritize propagators, i.e., changes are not propagated in the order in which they are made, but according to a priority value. Minion does not offer such a possibility. Choco does not use the priorities for the problems investigated, i.e. the priority is the same for everything. In ECLiPSe, some of the global constraints are treated as alldifferent and element with a higher priority than lower-type constraints. Only the all-different constraints are used in the n-Queens, Golomb Ruler, and MagicSquare problems. Gecode ranks the propagators according to the complexity of the propagator function defined when the propagator is implemented. Experiments for some problem cases were conducted with the reverse propagator queue. No differences were observed at all for the Balanced Incomplete Block Design problem, whereas for the n-Queens problem time differences in the PU were only a maximum time difference from the total CU."}, {"heading": "5.5 Types of constraints", "text": "Choco, ECLiPSe, and Gecode offer basic constraints that can be combined to a greater extent into more complex constraints than Minion. For the specific models used in this paper, the same constraints have been used, and this has not had a negative impact on performance; however, for other applications, it simplifies problem modeling and is therefore likely to have an impact on performance. For example, the n-Queens problem could be modeled in Choco, ECLiPSe, and Gecode without auxiliary variables, and is likely to work better than a model of the same problem in Minion, which needs to use auxiliary variables. On the other hand, Minion offers an implementation of the sum constraints with considered words, which could improve its performance [3]. Interestingly, Minion does not have a sum-same constraint, but only implements sum-larger-or-equal-or-same constraints."}, {"heading": "5.6 Optimisation problems", "text": "The solvers studied implement different approaches to dealing with optimization problems; Choco and Minion handle the value to be minimized in specialized search implementations; ECLiPSe adjusts the limits of cost variables, while Gecode imposes additional constraints on it. Figure 2 suggests that there is no intrinsic advantage of one possibility over the other."}, {"heading": "6 Conclusion", "text": "The experiments provide not only a qualitative but also a quantitative comparison of different implementation approaches; the results show that choosing one design decision over another does not usually offer a general performance advantage when implementing a constraint solver, with the exception of specialized variable implementations - implementing special versions of constraints and propagators for the different types of variables significantly improves performance, depending not only on the nature of the problem, but also on the size of the problem, such as backtrack memory. However, the results show that memory management can consider a significant portion of the CPU time required to solve a problem as a solution to a problem, but the large differences between the CPU times in which the individual problems are solved are crucial for deciding which solution is appropriate for the world."}, {"heading": "7 Acknowledgements", "text": "The author thanks Ian Miguel and Ian Gent for many helpful comments on the drafts of this paper. Thanks to the participants of the ECLiPSe and Gecode mailing lists for answering questions on implementing the respective solutions. Thanks also to Warwick Harvey for modelling the social golfers problem in ECLiPSe and Mikael Lagerkvist for pointing out an error in an earlier version of this paper."}], "references": [{"title": "MINION: A fast scalable constraint solver", "author": ["Ian P. Gent", "Christopher A. Jefferson", "Ian Miguel"], "venue": "In Proceedings of the Seventeenth European Conference on Artificial Intelligence,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Watched literals for constraint propagation in Minion", "author": ["Ian P. Gent", "Christopher A. Jefferson", "Ian Miguel"], "venue": "In Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "CSPLib: a benchmark library for constraints", "author": ["Ian P. Gent", "Toby Walsh"], "venue": "Technical report, Technical report APES-09-1999,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}, {"title": "Use of ranks in one-criterion variance analysis", "author": ["William H. Kruskal", "W. Allen Wallis"], "venue": "Journal of the American Statistical Association,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1952}, {"title": "Third international CSP solver competition", "author": ["C. Lecoutre", "O. Roussel", "M.R.C. van Dongen"], "venue": "In Proceedings of the 14th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}, {"title": "Programming Constraint Services, volume", "author": ["Christian Schulte"], "venue": "Lecture Notes in Artificial Intelligence. Springer-Verlag,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2002}, {"title": "Paltzer, and Patrick Pekczynski", "author": ["Christian Schulte", "Gabor Szokoli", "Guido Tack", "Mikael Lagerkvist", "Niko"], "venue": "Gecode Reference Documentation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "The proof and measurement of association between two things", "author": ["Charles Spearman"], "venue": "The American Journal of Psychology,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1904}, {"title": "Individual comparisons by ranking methods", "author": ["Frank Wilcoxon"], "venue": "Biometrics Bulletin,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1945}], "referenceMentions": [{"referenceID": 6, "context": "0 42, Gecode [10], version 2.", "startOffset": 13, "endOffset": 17}, {"referenceID": 0, "context": "0, and Minion [2][5], version 0.", "startOffset": 14, "endOffset": 17}, {"referenceID": 2, "context": "The characteristics of the problems are [4]:-", "startOffset": 40, "endOffset": 43}, {"referenceID": 4, "context": "For such a comparison, see [7].", "startOffset": 27, "endOffset": 30}, {"referenceID": 7, "context": "The CPU time is shown in relation with the number of backtracks because the correlation between the CPU time and the number of backtracks is stronger than the correlation between the CPU time and the number of variables [11].", "startOffset": 220, "endOffset": 224}, {"referenceID": 8, "context": "The results were compared with the Wilcoxon signed-rank test [13].", "startOffset": 61, "endOffset": 65}, {"referenceID": 5, "context": "The adaptive recomputation distance was left at the default value of 2 [9].", "startOffset": 71, "endOffset": 74}, {"referenceID": 3, "context": "The results were compared with the Kruskal-Wallis one-way analysis of variance test [6].", "startOffset": 84, "endOffset": 87}, {"referenceID": 1, "context": "On the other hand Minion provides an implementation of the sum constraints with watched literals, which could improve its performance [3].", "startOffset": 134, "endOffset": 137}], "year": 2010, "abstractText": "This paper presents an evaluation of the design decisions made in four state-of-the-art constraint solvers; Choco, ECLiPSe, Gecode, and Minion. To assess the impact of design decisions, instances of the five problem classes n-Queens, Golomb Ruler, Magic Square, Social Golfers, and Balanced Incomplete Block Design are modelled and solved with each solver. The results of the experiments are not meant to give an indication of the performance of a solver, but rather investigate what influence the choice of algorithms and data structures has. The analysis of the impact of the design decisions focuses on the different ways of memory management, behaviour with increasing problem size, and specialised algorithms for specific types of variables. It also briefly considers other, less significant decisions.", "creator": "LaTeX with hyperref package"}}}