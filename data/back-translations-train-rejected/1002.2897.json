{"id": "1002.2897", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Feb-2010", "title": "Model-Driven Constraint Programming", "abstract": "Constraint programming can definitely be seen as a model-driven paradigm. The users write programs for modeling problems. These programs are mapped to executable models to calculate the solutions. This paper focuses on efficient model management (definition and transformation). From this point of view, we propose to revisit the design of constraint-programming systems. A model-driven architecture is introduced to map solving-independent constraint models to solving-dependent decision models. Several important questions are examined, such as the need for a visual highlevel modeling language, and the quality of metamodeling techniques to implement the transformations. A main result is the s-COMMA platform that efficiently implements the chain from modeling to solving constraint problems", "histories": [["v1", "Mon, 15 Feb 2010 15:47:29 GMT  (217kb)", "http://arxiv.org/abs/1002.2897v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["raphael chenouard", "laurent granvilliers", "ricardo soto"], "accepted": false, "id": "1002.2897"}, "pdf": {"name": "1002.2897.pdf", "metadata": {"source": "CRF", "title": "Model-Driven Constraint Programming", "authors": ["Rapha\u00ebl Chenouard", "Laurent Granvilliers", "Ricardo Soto"], "emails": ["raphael.chenouard@univ-nantes.fr", "laurent.granvilliers@univ-nantes.fr", "ricardo.soto@univ-nantes.fr"], "sections": [{"heading": null, "text": "ar Xiv: 100 2.28 97v1 [cs.AI] 15 Feb 20Categories and Specialist Descriptions D.3.2 [Programming Languages]: Language Classifications - Restriction and Logic Languages; D.2.2 [Software Engineering]: Design Tools and Techniques - User Interfaces; D.3.3 [Programming Languages]: Language Constructs and Features - Classes and Objects, Restrictions General Term Languages Keywords Restriction Programming, Metamodeling, Model Transformation"}, {"heading": "1. Introduction", "text": "This year, it has come to the point where we are dealing with a process of this kind, a process, a process, a process, a process, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time, a time."}, {"heading": "2. A MDD approach for CP", "text": "In fact, most of them will be able to play by the rules they have imposed on themselves."}, {"heading": "3. Modeling Tool", "text": "We have developed our s-COMMA GUI modeling tool based on the sCOMMA language. s-COMMA is defined by its metamodel and is designed to represent the concepts of Constraint Problems, also known as Constraint Satisfaction Problems (CSPs). In this metamodel, the CSP concepts such as variables and domains were merged with object-oriented concepts to represent CSPs using an object-oriented style. The result is an object-oriented visual language for modeling CSPs. These decisions are supported by the following advantages: \u2022 A problem generally consists of several parts that can represent objects. Naturally, they are specified by classes. In this way, we obtain a more modular model, rather than forcing the modelers to represent the entire problem in a single block of code. \u2022 We gain similar advantages - constraint and variable encapsulation, notation, inheritance, re-use, re-use of the MMA for a unique representation of the language that is explained in the MMA structure."}, {"heading": "3.1 s-COMMA models", "text": "The s-COMMA metamodel defines the concepts that occur in sCOMMA models. According to this metamodel, an s-COMMA model must consist of two main parts, the model and the data. The model describes the structure of the problem and the data contain the constant values used by the model. In our s-COMMA GUI front tool, the structure of this problem is represented by class artifacts and the data concept by the data artifact1 (see Figure 4)."}, {"heading": "3.1.1 Class artifacts", "text": "Class artifacts by default have three compartments, the upper compartment for the class name, the middle compartment for attributes, and the lower compartment for constraint zones. By clicking on the class artifact, its specification can be opened to define its class name, its attributes, and constraint zones. Relationships can be used to define inheritance (a subclass inherits all attributes and constraint zones of its superclass) or the composition between classes."}, {"heading": "3.1.2 Data artifacts", "text": "Data artefacts have two partitions, one for the file name and another for the constants and variable assignments. Constants, also called data variables, can be defined with a real, integer or enumerated type. Arrays of one dimension and arrays of two dimensions of constants are allowed. Variable assignment is equivalent to assigning a value to an object variable. Variable assignments can also be performed when objects are within an array (see an example in Section 3.2).1 Artifacts used on the s-COMMA GUI have been customized from the class artifact of the UML Infrastructure Library Basic Package. This customization is fully permitted by the UML Infrastructure Specification [23]."}, {"heading": "3.1.3 Attributes", "text": "Attributes can represent decision variables, sets, objects or arrays. Decision variables can be defined by an integer, real or Boolean type. Sentences can consist of integers or enumeration values. Objects are instances of classes that must be entered with their class name. Arrays of one and two dimensions are allowed, they can contain decision variables, sets or objects. Decision variables, sets and arrays can be limited to a specific domain."}, {"heading": "3.1.4 Constraint Zones", "text": "A constraint zone is specified by a name and may contain the following elements: \u2022 Constraints: Typical operations and relationships are provided to post constraints, such as comparative relationships (<, >, < =, > =, < >), arithmetic operations (+, *, -, /), logical relationships (and, or, xor, - >, < -, < - >) and set operations (in, subset, superset, union, diff, symdiff, cut, cardinality). \u2022 Statements: Forall and conditional statements are supported; the format (e.g. forall (i in 1.. 5) is specified by declaring a loop variable (i) and the set of values to traverse (1.. 5)."}, {"heading": "3.2 The stable marriage problem", "text": "We illustrate some of these concepts in the s-COMMA GUI by means of the stable marriage problems.Consider a group of n women and a group of n men who need to get married. Each woman has a preference ranking for her possible husband, and each man has a preference ranking for his possible wife. The problem is to find a match between the groups so that the marriages are stable, i.e. there is no pair of people of different genders who resemble each other better than their respective spouses. Figure 5 shows a snapshot of the s-COMMA GUI, where the stable marriage problem is represented by a class diagram. This diagram consists of three classes, a class to represent women, and a main class to describe the stable marriages. Once the user specifies a visual artifact, the corresponding s-COMMA textual version of the tool is automatically generated. For readability, we illustrate the textual version of the problem in Fig."}, {"heading": "3.3 Flat s-COMMA models", "text": "Before explaining how to arrive at the equivalent solution models, we have to deal with the intermediate SCOMMA systems in order to simplify the transformation process from the classical solution models. In the SCOMMA, many of the constructions supported by the SCOMMA systems are transformed so that they are closer to the form required by the classical solution models. In the SCOMMA, the main elements of the SCOMMA systems are also presented."}, {"heading": "4. Mapping Tool", "text": "In this section, we will explain the mechanisms of the MDD approach to the development of our solver translators. These translators are designed to perform the mapping of Flat s-COMMA to solver models. We use the AMMA platform as our base tool to build them. AMMA platform allows to develop this task using two languages: KM3 [18] and ATL [17]. KM3 is used to define meta models, and ATL is used to describe the transformation rules and also to generate the target file."}, {"heading": "4.1 KM3", "text": "The Kernel Meta Meta Model (KM3) is a language for defining meta-models. KM3 is designed to support most meta-modelling standards, and it is based on the simple notion of classes to define each concept of a meta-model, which is then used by the transformation rules and to generate the target file. Figure 9 illustrates an excerpt from the Flat s-COMMA meta-model written in KM3. Line 3 simply states that the Flat s-COMMA KM3 meta-model consists of a series of objects in the class variable. The reserved word reference is used to explain associations with instances of other classes, and the statement [1- *] defines the diversity of the relationship. If the multiplication statement is omitted, the relationship is defined as [1] problem defined by lines that also consist of 5 classes."}, {"heading": "4.2 ATL", "text": "This year, it will be able to fix and fix the mentioned bugs."}, {"heading": "4.3 TCS", "text": "TCS [19] (Textual Concrete Syntax) is another language provided by the AMMA platform. TCS is not required to add a new translator, but it is included in the process because it is the language used to parse the Flat s-COMMA file. TCS is able to accomplish this task by combining the Flat s-COMMA metamodel with the Flat sCOMMA grammar. Figure 14 shows an excerpt from the TCS file for Flat s-COMMA. Each class of the Flat s-COMMA metamodel has its own template with the same name. Within templates, words between double quotation marks are used in the grammar (e.g. \"Variables\": \") to introduce the corresponding list of concepts."}, {"heading": "4.4 Transformation process", "text": "TCS and KM3 work together to generate a Java package (which includes editors, parsers and code generators) for Flat s-COMMA (FsC), which is then used by the ATL files to generate the target model. The Flat s-COMMA file is the output of models relating to their concepts to facilitate the task of transformation."}, {"heading": "4.5 Direct code generation", "text": "There is a different approach to developing translators on the AMMA platform. For example, if we want to use only the flat s-COMMA features supported by the solver, we can omit the transformation rules and apply the ATL2text directly to the source metamodel. Figure 16 shows this direct code generation process. Although this approach is simpler, it is less flexible as we lose the ability to use interesting rule transformations such as the set matrix decomposition described in Section 4.2."}, {"heading": "5. Experiments", "text": "In fact, most of them will be able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move."}, {"heading": "6. Related Work", "text": "s-COMMA is related to solution-independent languages as well as to object-oriented languages. In the next few paragraphs, we will compare our approach to languages belonging to these groups.4 In comparison, we do not consider solver files created by Java translators. They show no relevant differences compared to solver files created by AMMA translators."}, {"heading": "6.1 Solver-Independent Constraint Modeling", "text": "One example is MiniZinc, which consists mainly of a rules-based system called Cadmium [5], which can be considered an extension of Term Rewriting (TR) and Constraint Handling Rules (CHR). This process also includes an intermediate model called FlatZinc, which plays a similar role to Flat s-COMMA. Implementation of our approach is very different from that of Cadmium Rules (CHR)."}, {"heading": "6.2 Object-Oriented Constraint Modeling and Visual Environments", "text": "The ability to define constraints in an object-oriented modeling language is the basis of the object-oriented constraint modeling paradigm. The first attempt to do this combination was in the development of ThingLab [3]. This approach was designed for interactive graphical simulation. Objects were used to represent graphical elements and constraints that defined the composition rules of these objects. COB [16] is also an object-oriented language, but its framework is not exclusively based on this paradigm. In fact, the language is a combination of objects, first-order formulas, and CLP (Constraint Logic Programming). A GUI tool is also intended for modeling problems with CUML, an UML-like language. The focus of this language was engineering design. Modelica [10] is another object-oriented approach to modeling problems from the technical field, but it is mostly based on the simulation language [25]."}, {"heading": "7. Conclusions and Future Work", "text": "In this thesis, we introduced s-COMMA, an expandable MDD platform for modeling CSPs. The entire system consists of two main parts: a modeling tool and a mapping tool, which offer users the following three important possibilities: \u2022 A visual modeling language that combines the declarative aspects of constraint programming with the useful properties of object-oriented languages. Users can present modular models in an intuitive way, while the compositional structure of the problem can be easily maintained by using objects under restrictions. \u2022 Models are specified independently of solver languages. Users can design only one model and address different solvers, which clearly facilitates experimentation and benchmarking. \u2022 A model transformation system supported by the AMMA platform, which follows the standards of the software engineering field, will allow users to plug in new solvers by hand without having to write translators."}, {"heading": "Acknowledgments", "text": "We are grateful for the support of this research by the Pontificia Universidad Cato'lica de Valpara\u0131'so within the framework of the scholarship \"Beca de Estudios Ba'sica\" and Fre'de'ric Jouault for his support in introducing the AMMA translators."}], "references": [{"title": "Term rewriting and all", "author": ["F. Baader", "T. Nipkow"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1998}, {"title": "The Programming Languages Aspects of ThingLab, a Constraint-Oriented Simulation Laboratory", "author": ["A. Borning"], "venue": "ACM Transactions on Programming Languages and Systems (ACM TOPLAS),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1981}, {"title": "CoJava: Optimization Modeling by Nondeterministic Simulation", "author": ["A. Brodsky", "H. Nash"], "venue": "In Proceedings of the 12th International  Conference on Principles and Practice of Constraint Programming (CP 2006) 3(4). LNCS,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2006}, {"title": "Flexible, Rule- Based Constraint Model Linearisation", "author": ["S. Brand", "G.J. Duck", "J. Puchinger", "P.J. Stuckey"], "venue": "In Proceedings of the 10th Symposium on Practical Aspects of Declarative Languages (PADL 2008). LNCS,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "The GNU Prolog System and its Implementation", "author": ["D. Diaz", "P. Codognet"], "venue": "In Proceedings of the 2000 ACM Symposium on Applied Computing (SAC", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2000}, {"title": "The Rules of Constraint Modelling", "author": ["A.M. Frisch", "C. Jefferson", "B. Mart\u0131\u0301nez Hern\u00e1ndez", "I. Miguel"], "venue": "In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "The Design of ESSENCE: A Constraint Language for Specifying Combinatorial Problems", "author": ["A.M. Frisch", "M. Grum", "C. Jefferson", "B. Mart\u0131\u0301nez Hern\u00e1ndez", "I. Miguel"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Modelica \u2013 A Unified Object-Oriented Language for System Modeling and Simulation", "author": ["P. Fritzson", "V. Engelson"], "venue": "In Proceedings of the 12th European Conference on Object-Oriented Programming (ECOOP 1998). LNCS,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1998}, {"title": "Theory and Practice of Constraint Handling Rules", "author": ["T.W. Fr\u00fchwirth"], "venue": "Journal of Logic Programming", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1998}, {"title": "Minion: A Fast Scalable Constraint Solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "In Proceedings of the 17th European Conference on Artificial Intelligence (ECAI", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "Algorithm 852: RealPaver: an interval solver using constraint satisfaction techniques", "author": ["L. Granvilliers", "F. Benhamou"], "venue": "ACM Transactions on Mathematical Software (ACM TOMS),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2006}, {"title": "Constraint Logic Programming", "author": ["J. Jaffar", "J.-L. Lassez"], "venue": "In Proceedings of the 14th Annual ACM Symposium on Principles of Programming Languages (POPL", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1987}, {"title": "Modeling Engineering Structures with Constrained Objects", "author": ["B. Jayaraman", "P. Tambay"], "venue": "In Proceedings of the 4th Symposium on Practical Aspects of Declarative Languages (PADL 2002). LNCS,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2002}, {"title": "Transforming Models with ATL", "author": ["F. Jouault", "I. Kurtev"], "venue": "In Proceedings of Satellite Events at the 8th International Conference on Model Driven Engineering Languages and Systems (MoDELS Satellite Events 2005). LNCS,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2005}, {"title": "KM3: A DSL for Metamodel Specification", "author": ["F. Jouault", "J. B\u00e9zivin"], "venue": "In Proceedings of the 8th IFIP WG 6.1 International Conferenceon Formal Methods for Open Object-Based Distributed Systems (FMOODS 2006). LNCS,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2006}, {"title": "KM3: A DSL for Metamodel Specification", "author": ["F. Jouault", "J. B\u00e9zivin", "I. Kurtev"], "venue": "In Proceedings of the 5th International Conference on Generative Programming and Component Engineering (GPCE", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2006}, {"title": "Model-based DSL frameworks", "author": ["I. Kurtev", "J. B\u00e9zivin", "F. Jouault", "P. Valduriez"], "venue": "In Proceedings of Companion to the 21th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA Companion", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "MiniZinc: Towards a Standard CP Modelling Language", "author": ["N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "G.J. Duck", "G. Tack"], "venue": "In Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming (CP 2007) 3(4). LNCS,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "A Visual Constraint-Programming Environment", "author": ["M. Paltrinieri"], "venue": "Proceedings of the 1st International Conference on Principles and Practice of Constraint Programming (CP 1995) 3(4). LNCS,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "A C++ implementation of CLP", "author": ["J.-F. Puget"], "venue": "In Proceedings of the Second Singapore International Conference on Intelligent Systems (SCIS 1994),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1994}, {"title": "From Zinc to Design Model", "author": ["R. Rafeh", "M.J. Garc\u0131\u0301a de la Banda", "K. Marriott", "M. Wallace"], "venue": "In Proceedings of the 9th Symposium on Practical Aspects of Declarative Languages (PADL 2007). LNCS,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2007}, {"title": "The Design of COMMA: An Extensible Framework for Mapping Constrained Objects to Native Solver Models", "author": ["R. Soto", "L. Granvilliers"], "venue": "In Proceedings of the 19th IEEE International Conference on Tools with Artificial Intelligence (ICTAI", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}, {"title": "The OPL Language", "author": ["P. Van Hentenryck"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1999}], "referenceMentions": [{"referenceID": 11, "context": "In a CLP system, the constraint language is embedded in a logic language, and the solving procedure combines the SLD-resolution with calls to constraint solvers [15].", "startOffset": 161, "endOffset": 165}, {"referenceID": 19, "context": "C++ in ILOG Solver [26] or Java in Gecode/J [12]) and even term rewriting [11].", "startOffset": 19, "endOffset": 23}, {"referenceID": 8, "context": "C++ in ILOG Solver [26] or Java in Gecode/J [12]) and even term rewriting [11].", "startOffset": 74, "endOffset": 78}, {"referenceID": 22, "context": "In response to this problem, almost pure modeling languages have been built, such as OPL [30] and Zinc [27].", "startOffset": 89, "endOffset": 93}, {"referenceID": 20, "context": "In response to this problem, almost pure modeling languages have been built, such as OPL [30] and Zinc [27].", "startOffset": 103, "endOffset": 107}, {"referenceID": 6, "context": "Essence [9] and MiniZinc [21]).", "startOffset": 8, "endOffset": 11}, {"referenceID": 17, "context": "Essence [9] and MiniZinc [21]).", "startOffset": 25, "endOffset": 29}, {"referenceID": 21, "context": "It is made on top of a general object-oriented constraint language [29].", "startOffset": 67, "endOffset": 71}, {"referenceID": 4, "context": "Many solvers have been plugged in the platform such as ECLPS [31], Gecode/J [12], GNU Prolog [6] and Realpaver [14].", "startOffset": 93, "endOffset": 96}, {"referenceID": 10, "context": "Many solvers have been plugged in the platform such as ECLPS [31], Gecode/J [12], GNU Prolog [6] and Realpaver [14].", "startOffset": 111, "endOffset": 115}, {"referenceID": 16, "context": "Upgrades are supported at the mapping tool, new solver-translators can be added by means of the AMMA platform [20].", "startOffset": 110, "endOffset": 114}, {"referenceID": 21, "context": "Additional constraints can be integrated to this basic set by means of extension mechanisms (for details refer to [29]).", "startOffset": 114, "endOffset": 118}, {"referenceID": 3, "context": "womenList man_wife[5] in [1,5]; 4.", "startOffset": 18, "endOffset": 21}, {"referenceID": 3, "context": "womenList man_wife[5] in [1,5]; 4.", "startOffset": 25, "endOffset": 30}, {"referenceID": 3, "context": "menList woman_husband[5] in [1,5];", "startOffset": 21, "endOffset": 24}, {"referenceID": 3, "context": "menList woman_husband[5] in [1,5];", "startOffset": 28, "endOffset": 33}, {"referenceID": 0, "context": "woman_husband[man_wife[2]]=2;", "startOffset": 22, "endOffset": 25}, {"referenceID": 1, "context": "woman_husband[man_wife[3]]=3; 11.", "startOffset": 22, "endOffset": 25}, {"referenceID": 0, "context": "man_wife[woman_husband[2]]=2;", "startOffset": 22, "endOffset": 25}, {"referenceID": 1, "context": "man_wife[woman_husband[3]]=3; 16.", "startOffset": 22, "endOffset": 25}, {"referenceID": 0, "context": "woman_2_rank[woman_husband[2]]<3; 25.", "startOffset": 26, "endOffset": 29}, {"referenceID": 0, "context": "3<woman_2_rank[woman_husband[2]] -> 26.", "startOffset": 28, "endOffset": 31}, {"referenceID": 3, "context": "The domain [1,5] is also given by this step which states as domain an integer range corresponding to the number of elements of the enumeration used as a type (womenList) by the attribute wife.", "startOffset": 11, "endOffset": 16}, {"referenceID": 14, "context": "The AMMA platform allows one to develop this task by means of two languages: KM3 [18] and ATL [17].", "startOffset": 81, "endOffset": 85}, {"referenceID": 13, "context": "The AMMA platform allows one to develop this task by means of two languages: KM3 [18] and ATL [17].", "startOffset": 94, "endOffset": 98}, {"referenceID": 3, "context": "which is initialized with size 5 and domain [1,5].", "startOffset": 44, "endOffset": 49}, {"referenceID": 15, "context": "TCS [19] (Textual Concrete Syntax) is another language provided by the AMMA platform.", "startOffset": 4, "endOffset": 8}, {"referenceID": 3, "context": "This model transformation is performed by a rule-based system called Cadmium [5] which can be regarded as an extension of Term-Rewriting (TR) [2] and Constraint Handling Rules (CHR) [11].", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "This model transformation is performed by a rule-based system called Cadmium [5] which can be regarded as an extension of Term-Rewriting (TR) [2] and Constraint Handling Rules (CHR) [11].", "startOffset": 142, "endOffset": 145}, {"referenceID": 8, "context": "This model transformation is performed by a rule-based system called Cadmium [5] which can be regarded as an extension of Term-Rewriting (TR) [2] and Constraint Handling Rules (CHR) [11].", "startOffset": 182, "endOffset": 186}, {"referenceID": 9, "context": "The Essence execution platform allows to map specifications into ECLPS and Minion solver [13].", "startOffset": 89, "endOffset": 93}, {"referenceID": 1, "context": "The first attempt in performing this combination was on the development of ThingLab [3].", "startOffset": 84, "endOffset": 87}, {"referenceID": 12, "context": "COB [16] is another object-oriented language, but its framework is not purely based on this paradigm.", "startOffset": 4, "endOffset": 8}, {"referenceID": 7, "context": "Modelica [10] is another object-oriented approach for modeling problems from the engineering field, but it is mostly oriented towards simulation.", "startOffset": 9, "endOffset": 13}, {"referenceID": 18, "context": "Gianna [25] is a precursor visual environment for modeling CSP.", "startOffset": 7, "endOffset": 11}, {"referenceID": 2, "context": "It is important to clarify too, that object-oriented capabilities are also provided by languages such as CoJava [4]; and in libraries such as Gecode or ILOG SOLVER.", "startOffset": 112, "endOffset": 115}], "year": 2013, "abstractText": "Constraint programming can definitely be seen as a model-driven paradigm. The users write programs for modeling problems. These programs are mapped to executable models to calculate the solutions. This paper focuses on efficient model management (definition and transformation). From this point of view, we propose to revisit the design of constraint-programming systems. A modeldriven architecture is introduced to map solving-independent constraint models to solving-dependent decision models. Several important questions are examined, such as the need for a visual highlevel modeling language, and the quality of metamodeling techniques to implement the transformations. A main result is the sCOMMA platform that efficiently implements the chain from modeling to solving constraint problems.", "creator": "LaTeX with hyperref package"}}}