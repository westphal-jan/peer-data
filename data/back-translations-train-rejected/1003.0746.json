{"id": "1003.0746", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Mar-2010", "title": "Automatically Discovering Hidden Transformation Chaining Constraints", "abstract": "Model transformations operate on models conforming to precisely defined metamodels. Consequently, it often seems relatively easy to chain them: the output of a transformation may be given as input to a second one if metamodels match. However, this simple rule has some obvious limitations. For instance, a transformation may only use a subset of a metamodel. Therefore, chaining transformations appropriately requires more information. We present here an approach that automatically discovers more detailed information about actual chaining constraints by statically analyzing transformations. The objective is to provide developers who decide to chain transformations with more data on which to base their choices. This approach has been successfully applied to the case of a library of endogenous transformations. They all have the same source and target metamodel but have some hidden chaining constraints. In such a case, the simple metamodel matching rule given above does not provide any useful information.", "histories": [["v1", "Wed, 3 Mar 2010 08:04:45 GMT  (365kb)", "http://arxiv.org/abs/1003.0746v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["raphael chenouard", "fr\\'ed\\'eric jouault"], "accepted": false, "id": "1003.0746"}, "pdf": {"name": "1003.0746.pdf", "metadata": {"source": "META", "title": "Automatically Discovering Hidden Transformation Chaining Constraints", "authors": ["Rapha\u00ebl Chenouard"], "emails": ["raphael.chenouard@univ-nantes.fr,", "frederic.jouault@inria.fr"], "sections": [{"heading": null, "text": "ar Xiv: 100 3.07 46v1 [cs.AI] 3M ar"}, {"heading": "1 Introduction", "text": "In fact, most of them are able to go to another world, in which they are able to go to another world, in which they are able to go to another world, in which they are able, in which they are able, in which they are in."}, {"heading": "2 Motivating Example", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Interoperability of Constraint Programming Languages", "text": "In fact, most of them will be able to play by the rules they have set themselves, and they will be able to play by the rules they have set themselves."}, {"heading": "2.2 Problem", "text": "Since source and target metamodels are similar, no additional information can be extracted from the header of an ATL transformation. Considering only this knowledge, one might think that endogenous transformations can be concatenated easily, but this is not true. Therefore, the solution proposed by [21] is not sufficient to solve this problem, since it only takes into account the signature (or header) of transformations. As shown in the motivating example, endogenous transformations achieve model reformulation or optimization steps. They must be efficiently and correctly concatenated to avoid useless steps - some steps can produce elements that are removed by another step - and to meet the requirements of the target language. Our goal is to discover the role of endogenous model transformations in order to evaluate the endogenous transformations. Endogenous transformations can be typed using their source and target element types, i.e. a subset of the source metrics of the source models we can use to evaluate these source transformations."}, {"heading": "3 Transformation Analysis", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Identifying Domains and Codomains", "text": "In order to control the transformations of the model correctly, it is necessary to have a certain understanding of what they do then. Although it is not sufficient, information about the source and target meta-models is essential. MB, which is generated by a certain transformation, corresponds to its target meta-model MMB. It can only be used as input for another transformation t2 with the same meta-model MMB as the source meta-model. This limitation can be expressed in functional terms as shown in [21]: Transformations are considered functions, and meta-models enter their parameters in the case of simple transformations (Higher). For example, if the source meta-model is a meta-model of t1 MMA and the target meta-model of t2 is MMC then: t1: MMA and t2: Meta-models enter their parameters in the case of simple transformations (Higher)."}, {"heading": "3.2 Abstracting Rules", "text": "rE \"s rf\u00fc ide rf\u00fc ide rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf"}, {"heading": "3.3 Implementing Transformation Analysis", "text": "Transformation analysis is a case of higher order transformation [19] (HOT): it is a transformation that takes another transformation to be analyzed as input and produces as output a model with the result of the analysis. This HOT uses OCL expressions via the ATL metamodel, which is the metamodel of the language in which the transformations to be analyzed are written. These expressions recognize the patterns depicted in Section 3.2. Subsequently, an analysis model is created that relates concepts of the rotary model to recognized patterns. The main goal is to provide a result that a user can understand and interpret. Consequently, particular care has been taken in the representation of the results. Figure 3 shows how the entire process is implemented. It begins with a collection of n ATL transformations T1 to Tn that coincide with the ATL metamodel."}, {"heading": "4 Experiments", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1 Application to the Motivating Example", "text": "In the motivational example presented in Section 2 (see Figure 2), we look at five endogenous transformations that perform the following reformulation tasks: - Class and object removal. This complex endogenous transformation is broken down in two steps: the first step removes classes and does not copy their properties; variables with a class type are mutated into an atypical record definition that represents a duplication of class characteristics; other variables - with a primitive type such as Integer, Real, or Boolean - are simply copied like other elements that are not included in a class declaration; the second step flattens the data sets to obtain only variables with a primitive type. - Enumeration removal. Some CP solvers do not accept symbolic domains; for example, variables with a type that represents an enumeration are replaced by integral variables that range from a domain to a possible number of symbolic values."}, {"heading": "4.2 Interpreting the Results", "text": "This year, it is more than ever before in the history of mankind."}, {"heading": "5 Discussions", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.1 Application to Exogenous Transformations", "text": "The approach presented in this paper could be expanded to support exogenous transformations, so if we look at the source patterns and all the OCL expressions, we can define the more refined type of source models of a transformation (i.e. a more precise definition of their domain). In order to obtain the more refined type of target models (i.e. a more precise definition of the codomain), we only need to collect the set of concepts that occur in target patterns. Furthermore, we can consider most endogenous transformations as exogenous transformations between two sub-meta models of the same meta model. Then, the concatenation of endogenous transformations can be transformed into a problem of concatenation of exogenous transformations. In addition, deriving the meaning of an endogenous transformation may not be necessary (in most cases), as its main task may be to remove or add elements of a certain type. 3 More complex endogenous transformations may be more difficult to understand than deriving their meaning from the knowledge, as it is necessary to derive their meaning from eptual."}, {"heading": "5.2 Debugging Transformations", "text": "When a metamodel contains many concepts, a software engineer can forget to define all the rules that apply to it. Thus, the results from Table 2 can be used directly, but also the column from Table 3, which corresponds to elements that have never been copied and never mutated. Other columns can also be useful to check whether concepts are well classified and no copy or mutation rule is wrong. Data from Table 3 can also be used to detect errors in naming metamodeling concepts in some rules or tools. In fact, some concepts of metamodeling rarely have instances in models, and rules that deal with them must not be invoked. Thus, no error occurs, even if the transformation contains some unforeseen errors. In our motivating example, we discovered several poorly written rules and helpers that deal with certain CP concepts that do not occur in our CP models."}, {"heading": "6 Conclusion", "text": "In this paper, we addressed the problem of concatenation of model transformations. This problem is illustrated by a pivot metamodel for constraint programming (CP), which is used for translations between CP languages. Several problems are tackled to safely concatenate transformations. Therefore, a higher order transformation is proposed to statically analyze model transformations. It focuses on source and target concepts, thus defining sophisticated metamodels that correspond to models (i.e. more precise definitions of domains and codomains of model transformations). It also extracts a certain knowledge of how source concepts are processed and assigns properties to each concept: Always copied, conditionally copied, lazy copied, never copied, always mutated, etc. Considering these characteristics, we are able to find element types that are largely processed. This process is not precise enough to deduce the meaning of model transformations, but it does allow us to derive some problems (it is)."}], "references": [{"title": "Language  (ATL)  Library", "author": ["ATLAS  Transformation"], "venue": "http://www.eclipse.org/m2m/atl/atlTransformations/,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2009}, {"title": "Constraint Logic Programming using Eclipse", "author": ["Krzysztof R. Apt", "Mark Wallace"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "On the unification power of models", "author": ["Jean B\u00e9zivin"], "venue": "Software and System Modeling,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Model-Driven Constraint Programming", "author": ["Rapha\u00ebl Chenouard", "Laurent Granvilliers", "Ricardo Soto"], "venue": "In Proceedings of ACM SIGPLAN PPDP,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Rewriting Constraint Models with Metamodels", "author": ["Rapha\u00ebl Chenouard", "Laurent Granvilliers", "Ricardo Soto"], "venue": "In Proceedings of SARA2009. AAAI Press,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2009}, {"title": "Applying generic model management to data mapping", "author": ["Marcos Didonet Del Fabro", "Jean B\u00e9zivin", "Fr\u00e9d\u00e9ric Jouault", "Patrick Valduriez"], "venue": "In Proceedings of the Journe\u0301es Bases de Donne\u0301es Avance\u0301es (BDA05),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "The Design of ESSENCE: A Constraint Language for Specifying Combinatorial Problems", "author": ["Alan M. Frisch", "Matthew Grum", "Chris Jefferson", "Bernadette Mart\u00ednez Hern\u00e1ndez", "Ian Miguel"], "venue": "In Proceedings of IJCAI,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "The OPL Optimization Programming Language", "author": ["Pascal Van Hentenryck"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1999}, {"title": "Atl: a model transformation tool", "author": ["Fr\u00e9d\u00e9ric Jouault", "Freddy Allilaire", "Jean B\u00e9zivin", "Ivan Kurtev"], "venue": "Science of Computer Programming,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "Km3: a dsl for metamodel specification", "author": ["Fr\u00e9d\u00e9ric Jouault", "Jean B\u00e9zivin"], "venue": "In Proceedings of 8th IFIP International Conference on Formal Methods for Open ObjectBased Distributed Systems,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "On the architectural alignment of atl and qvt", "author": ["Fr\u00e9d\u00e9ric Jouault", "Ivan Kurtev"], "venue": "In Proceedings of the 2006 ACM Symposium on Applied Computing (SAC", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Transforming models with atl", "author": ["Fr\u00e9d\u00e9ric Jouault", "Ivan Kurtev"], "venue": "Satellite Events at the MoDELS 2005 Conference: MoDELS 2005 International Workshops OCLWS,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2005}, {"title": "A C++ Implementation of CLP", "author": ["Jean-Fran\u00e7ois Puget"], "venue": "In Proceedings of SPICIS\u201994, Singapore,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1994}, {"title": "Constraint Programming Next Challenge: Simplicity of Use", "author": ["Jean-Fran\u00e7ois Puget"], "venue": "In Proceedings of CP,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2004}, {"title": "Handbook of Constraint Programming (Foundations of Artificial Intelligence)", "author": ["Francesca Rossi", "Peter van Beek", "Toby Walsh"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2006}, {"title": "Views and Iterators for Generic Constraint Implementations", "author": ["Christian Schulte", "Guido Tack"], "venue": "In Recent Advances in Constraints,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "The Design of COMMA: An Extensible Framework for Mapping Constrained Objects to Native Solver Models", "author": ["Ricardo Soto", "Laurent Granvilliers"], "venue": "In Proceedings of ICTAI,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "On the use of higher-order model transformations", "author": ["Massimo Tisi", "Fr\u00e9d\u00e9ric Jouault", "Piero Fraternali", "Stefano Ceri", "Jean B\u00e9zivin"], "venue": "In Proceedings of the Fifth European Conference on Model-Driven Architecture Foundations and Applications (ECMDA),", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2009}, {"title": "Measuring model repositories", "author": ["Eric V\u00e9pa", "Jean B\u00e9zivin", "Hugo Bruneli\u00e8re", "Fr\u00e9d\u00e9ric Jouault"], "venue": "In Proceedings of the Model Size Metrics Workshop at the MoDELS/UML", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "Typing in Model Management", "author": ["Andr\u00e9s Vignaga", "Fr\u00e9d\u00e9ric Jouault", "Mar\u00eda Cecilia Bastarrica", "Hugo Bruneli\u00e8re"], "venue": "In Proceedings of ICMT2009,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "Some model transformation libraries such as [1] are already available to leverage this possibility.", "startOffset": 44, "endOffset": 47}, {"referenceID": 17, "context": "A Higher-Order Transformation [19] that takes as input the transformations to analyze produces a model containing the analysis results.", "startOffset": 30, "endOffset": 34}, {"referenceID": 11, "context": "All transformations take the same pivot metamodel as source and target metamodel and are written in ATL [12,11,9] (AtlanMod Transformation Language).", "startOffset": 104, "endOffset": 113}, {"referenceID": 10, "context": "All transformations take the same pivot metamodel as source and target metamodel and are written in ATL [12,11,9] (AtlanMod Transformation Language).", "startOffset": 104, "endOffset": 113}, {"referenceID": 8, "context": "All transformations take the same pivot metamodel as source and target metamodel and are written in ATL [12,11,9] (AtlanMod Transformation Language).", "startOffset": 104, "endOffset": 113}, {"referenceID": 14, "context": "In Constraint Programming (CP), one of the main goals is to define problems based on variables, domains and constraints such that a CP solver can compute their solutions [16].", "startOffset": 170, "endOffset": 174}, {"referenceID": 1, "context": "For instance, the language of the ECLPS solver [2] is based on logic and Prolog, whereas OPL [8] (Optimization Programming Language) is a solver-independent language based on high-level modeling constructs.", "startOffset": 47, "endOffset": 50}, {"referenceID": 7, "context": "For instance, the language of the ECLPS solver [2] is based on logic and Prolog, whereas OPL [8] (Optimization Programming Language) is a solver-independent language based on high-level modeling constructs.", "startOffset": 93, "endOffset": 96}, {"referenceID": 12, "context": "Some solvers have only programming APIs like ILOG Solver [14] or Gecode [17].", "startOffset": 57, "endOffset": 61}, {"referenceID": 15, "context": "Some solvers have only programming APIs like ILOG Solver [14] or Gecode [17].", "startOffset": 72, "endOffset": 76}, {"referenceID": 13, "context": "More recently, the definition of high-level modeling languages is becoming a hot topic in CP [15].", "startOffset": 93, "endOffset": 97}, {"referenceID": 6, "context": "Then, new modeling languages have been developed such as Zinc and MiniZinc [13], Essence [7] and s-COMMA [18].", "startOffset": 89, "endOffset": 92}, {"referenceID": 16, "context": "Then, new modeling languages have been developed such as Zinc and MiniZinc [13], Essence [7] and s-COMMA [18].", "startOffset": 105, "endOffset": 109}, {"referenceID": 3, "context": "In a recent work [4], model engineering was used to carry out this process from s-COMMA models to some solver languages.", "startOffset": 17, "endOffset": 20}, {"referenceID": 4, "context": "extended to get more freedom in the choice of the user modeling language [5] (see Figure 1).", "startOffset": 73, "endOffset": 76}, {"referenceID": 4, "context": "The main part of the generic CP pivot metamodel introduced in [5] is shown on Figure 2.", "startOffset": 62, "endOffset": 65}, {"referenceID": 19, "context": "The solution proposed by [21] is therefore not sufficient to address this problem because it only considers the signature (or header) of transformations.", "startOffset": 25, "endOffset": 29}, {"referenceID": 19, "context": "This constraint may be expressed in functional terms as shown in [21]: transformations are considered as functions, and metamodels type their parameters in the case of simple transformations (Higher).", "startOffset": 65, "endOffset": 69}, {"referenceID": 5, "context": "Model weaving may be used for this purpose as shown in [6,11].", "startOffset": 55, "endOffset": 61}, {"referenceID": 10, "context": "Model weaving may be used for this purpose as shown in [6,11].", "startOffset": 55, "endOffset": 61}, {"referenceID": 17, "context": "Transformation analysis is a case of Higher-Order Transformation [19] (HOT): it is a transformation that takes as input another transformation to be analyzed, and produces as output a model containing the analysis result.", "startOffset": 65, "endOffset": 69}, {"referenceID": 18, "context": "The HTML rendering leverages the metamodels and transformation presented in [20], and available from Eclipse.", "startOffset": 76, "endOffset": 80}, {"referenceID": 9, "context": "All metamodels conform to the KM3 [10] (Kernel MetaMetaModel) metametamodel.", "startOffset": 34, "endOffset": 38}, {"referenceID": 2, "context": "This is an example of the unification power of models [3].", "startOffset": 54, "endOffset": 57}, {"referenceID": 19, "context": "The contributions of this paper are of a different nature and complementary to the results presented in [21].", "startOffset": 104, "endOffset": 108}], "year": 2013, "abstractText": "Model transformations operate on models conforming to precisely defined metamodels. Consequently, it often seems relatively easy to chain them: the output of a transformation may be given as input to a second one if metamodels match. However, this simple rule has some obvious limitations. For instance, a transformation may only use a subset of a metamodel. Therefore, chaining transformations appropriately requires more information. We present here an approach that automatically discovers more detailed information about actual chaining constraints by statically analyzing transformations. The objective is to provide developers who decide to chain transformations with more data on which to base their choices. This approach has been successfully applied to the case of a library of endogenous transformations. They all have the same source and target metamodel but have some hidden chaining constraints. In such a case, the simple metamodel matching rule given above does not provide any useful information.", "creator": "LaTeX with hyperref package"}}}