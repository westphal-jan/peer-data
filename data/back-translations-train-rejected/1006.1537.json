{"id": "1006.1537", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2010", "title": "New worst upper bound for #SAT", "abstract": "The rigorous theoretical analyses of algorithms for #SAT have been proposed in the literature. As we know, previous algorithms for solving #SAT have been analyzed only regarding the number of variables as the parameter. However, the time complexity for solving #SAT instances depends not only on the number of variables, but also on the number of clauses. Therefore, it is significant to exploit the time complexity from the other point of view, i.e. the number of clauses. In this paper, we present algorithms for solving #2-SAT and #3-SAT with rigorous complexity analyses using the number of clauses as the parameter. By analyzing the algorithms, we obtain the new worst-case upper bounds O(1.1892m) for #2-SAT and O(1.4142m) for #3-SAT, where m is the number of clauses.", "histories": [["v1", "Tue, 8 Jun 2010 11:48:12 GMT  (152kb)", "http://arxiv.org/abs/1006.1537v1", "6 pages; proceedings of AAAI 2010"]], "COMMENTS": "6 pages; proceedings of AAAI 2010", "reviews": [], "SUBJECTS": "cs.AI cs.CC", "authors": ["junping zhou", "minghao yin", "chunguang zhou"], "accepted": false, "id": "1006.1537"}, "pdf": {"name": "1006.1537.pdf", "metadata": {"source": "CRF", "title": "New Worst-Case Upper Bound for #2-SAT and #3-SAT with the Number of Clauses as the Parameter", "authors": ["Junping Zhou", "Minghao Yin", "Chunguang Zhou"], "emails": ["zhoujp08@mails.jlu.edu.cn,", "mhyin@nenu.edu.cn,", "cgzhou@jlu.edu.cn", "mhyin@nenu.edu.cn)"], "sections": [{"heading": null, "text": "It is a question of whether it is a kind of system in which it is a kind of system that has evolved in a way, a kind of system, a generalization of the known problem of satisfaction (SAT), a satisfaction of satisfaction (SAT), a satisfaction of satisfaction (SAT), a satisfaction of satisfaction (SAT), which has been well studied. In fact, the model counting has proved difficult to be considered as a standard SAT problem. 2003) Therefore, improvements in exponential time limits are crucial in determining the size of the model that can be solved."}, {"heading": "Problem Definitions", "text": "In fact, it is such that most of them will be able to move into a different world, in which they are able to move, in which they are able to move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they live."}, {"heading": "The Complexity Measure", "text": "In this subsection we will explain how to calculate the complexity of our algorithms. Suppose a node is labeled with a formula F, then its sons are labeled with the subformulas F1, F2,..., Fj, each of which we can recognize by assigning a value to one of the variables in F. From the definition, we can see that the process of constructing a branching tree is the same as the process of executing DPLL-like algorithms, so we use the branching tree to estimate the time complexity. In the branching tree, each node has a branching vector. Consider a node labeled with F0, and its children labeled with F, F2,..., Fk. The branching vector of the node with F0 is a branching vector."}, {"heading": "Algorithm for #2-SAT", "text": "In this section we present the algorithm MC2 for # 2-SAT and demonstrate an upper limit O (1.1892m)."}, {"heading": "Preliminaries", "text": "We begin the subsection by specifying some terms similar to those proposed in (Dahll\u00f6f et al. 2002). {x1, x2} represents a formula consisting of the variables x1 and x2. Faced with a formula F expressed as a constraint diagram G and a vertex, LF (x) is the number of vertices adjacent not only to x but also to other vertices that are not in the neighborhood of x, i.e. LF (x) = {(,) {}} G Gu v G u v G u v G u n x x x x, where U (8) and v are vertices, (u, v) is an edge and NG (x) is the neighborhood of x in the constraint diagram G. If LF (x) = 1, the unique variable corresponding to the vertex is denoted by U (x), exactly as described in Figure 1."}, {"heading": "Helpful Function and Principle", "text": "The subsection deals with some functions and principles used to simplify formulas; the first functional unit (F, l) in Figure 2 is to record the variables that appear in the unified clauses after assigning the literal l; the second function \u03a9 (F, R, l) in Figure 3 performs the unified rule recursively; the function inputs formula F; a variable R that records the eliminated variables; and a literal l that is assigned as true. The detailed process of the function is presented as follows. (1) Remove all clauses that contain the literal l from F.; (2) Delete all occurrences of the negation of the literal l from the other clauses; (3) Perform the process as far as possible."}, {"heading": "Algorithm MC2 for Solving #2-SAT", "text": "The basic idea of the algorithm is to choose a variable and recursively count the number of satisfactory assignments where the variable is true and the variable is false. This allows us to eliminate variables whose degree is in a formula 3, and therefore improve the efficiency of the algorithm by transforming a formula into a formula, we analyze the relationship between the adjacent variables in the constant graph that can select better variables in the branch."}, {"heading": "Algorithm for #3-SAT", "text": "In this section we present our algorithm MC3 for solving # 3-SAT and give an upper limit O (1.4142m)."}, {"heading": "Algorithm MC3 for Solving #3-SAT", "text": "The algorithm MC3 for # 3-SAT is also based on the DPLL algorithm for space exploration, which has been modified to count all satisfactory assignments. First, we present a term used in this part. The frequency of a variable xi in a formula F is the number of clauses in F in which xi appears. Then, we propose the framework of the algorithm MC3 in Figure 6. The main idea of the algorithm is to select the maximum frequency variable in all 3 clauses so that the input formula is simplified into 3 clauses to 2 clauses. Then, we recursively count the number of satisfactory assignments of these simplified 2 clauses by the algorithm MC2. In the algorithm MC3, there is a helpful function (F, R, l) which is described in formula 2 clauses."}, {"heading": "Complexity Analysis", "text": "In this subsection we explain how to calculate the complexity of the algorithm MC3. As we have already described, we also use the branching tree to estimate the complexity of time. However, the difference between the complexity analysis of the algorithm MC3 and the other is that we use the time complexity of the algorithm MC3 only to estimate the complexity of time by using the time complexity of the algorithm MC2. Detailed proof is given in Theorem 2.Theorem 2. Algorithm MC3 runs in O (1,4142m), where m is the number of records MC3. Proof. Let us analyze the algorithm in detail. Case 1 and 2 can fully solve the problems. In these cases, the case MC3 runs in O (1,4142m), where m is the number of records. Proof."}, {"heading": "Conclusion", "text": "This paper deals with the least favorable upper limit for # 2-SAT and # 3-SAT problems with the number of sets as parameters. The presented algorithms are algorithms in the DPLL style. To improve the algorithms, we present a new five-vertex principle to simplify the formulas. After a skillful analysis of these algorithms, we obtain the least favorable upper limit O (1,1892m) for # 2-SAT and O (1,4142m) for # 3-SAT."}, {"heading": "Acknowledgement", "text": "This work was fully supported by the National Natural Science Foundation of China (grant numbers 60673099, 60803102, 60773097 and 60873146)."}], "references": [{"title": "Algorithms and complexity results for #SAT and Bayesian inference", "author": ["F. Bacchus", "Dalmao S.", "Pitassi T.."], "venue": "FOCS\u201903, 340\u2212351. Bolette Ammitzboll Madsen. 2006. An algorithm for exact satisfiability analysed with the number of clauses as", "citeRegEx": "Bacchus et al\\.,? 2003", "shortCiteRegEx": "Bacchus et al\\.", "year": 2003}, {"title": "Counting satisfying assignments in 2-SAT and 3-SAT", "author": ["V. Dahll\u00f6f", "P. Jonsson", "M.. Wahlstr\u00f6m"], "venue": "In 8th COCOON,", "citeRegEx": "Dahll\u00f6f et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Dahll\u00f6f et al\\.", "year": 2002}, {"title": "New upper bound for the #3SAT problem", "author": ["Hirsch E. A"], "venue": "Theoretical Comput. Sci", "citeRegEx": "A..,? \\Q2007\\E", "shortCiteRegEx": "A..", "year": 2007}, {"title": "An improved O(1.234)-time deterministic algorithm for SAT", "author": ["Masaki Yamamoto"], "venue": "SAT. J. Auto. Reasoning", "citeRegEx": "Yamamoto.,? \\Q2005\\E", "shortCiteRegEx": "Yamamoto.", "year": 2005}, {"title": "Algorithms for counting 2-SAT solutions and colorings with applications", "author": ["F\u00fcrer M", "Prasad Kasiviswanathan S"], "venue": "In 3rd AAIM,", "citeRegEx": "M. and S..,? \\Q2007\\E", "shortCiteRegEx": "M. and S..", "year": 2007}], "referenceMentions": [{"referenceID": 0, "context": "Actually, model counting has been proved to be #P-complete, harder than standard SAT problems (Bacchus et al. 2003).", "startOffset": 94, "endOffset": 115}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.", "startOffset": 0, "endOffset": 295}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.6180) for #2-SAT and O(1.8393) for #3-SAT, where n is the number of variables of a formula. Based on a more elaborate analysis of the relationship among the variables, Dahllof et al. (2002) presented algorithms running in O(1.", "startOffset": 0, "endOffset": 529}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.6180) for #2-SAT and O(1.8393) for #3-SAT, where n is the number of variables of a formula. Based on a more elaborate analysis of the relationship among the variables, Dahllof et al. (2002) presented algorithms running in O(1.3247) for #2-SAT and O(1.6894) for #3-SAT. Furer et al. (2007) presented an algorithm performing in O(1.", "startOffset": 0, "endOffset": 628}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.6180) for #2-SAT and O(1.8393) for #3-SAT, where n is the number of variables of a formula. Based on a more elaborate analysis of the relationship among the variables, Dahllof et al. (2002) presented algorithms running in O(1.3247) for #2-SAT and O(1.6894) for #3-SAT. Furer et al. (2007) presented an algorithm performing in O(1.246) for #2-SAT by using a standard reduction. Further improved algorithms in (Kutzkov 2007) presented a new upper time bound for the #3-SAT (O(1.6423)), which is the best upper bound so far. Different from complexity analyses regarding the number of variables as the parameter, Hirsch (2000) introduced a SAT algorithm with a time bound O(1.", "startOffset": 0, "endOffset": 962}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.6180) for #2-SAT and O(1.8393) for #3-SAT, where n is the number of variables of a formula. Based on a more elaborate analysis of the relationship among the variables, Dahllof et al. (2002) presented algorithms running in O(1.3247) for #2-SAT and O(1.6894) for #3-SAT. Furer et al. (2007) presented an algorithm performing in O(1.246) for #2-SAT by using a standard reduction. Further improved algorithms in (Kutzkov 2007) presented a new upper time bound for the #3-SAT (O(1.6423)), which is the best upper bound so far. Different from complexity analyses regarding the number of variables as the parameter, Hirsch (2000) introduced a SAT algorithm with a time bound O(1.239), where m is the number of clauses of a formula. An improved algorithm for SAT with an upper bound O(1.234) was proposed in (Masaki 2005). Skjernaa (2004) presented an algorithm for Exact Satisfiability with a time bound O(2).", "startOffset": 0, "endOffset": 1170}, {"referenceID": 2, "context": "All rights reserved. improvement from O(c) to O((c-\u03b5)) may significantly increase the size of the problem being tractable. Recently, tremendous efforts have been made on efficient #SAT algorithms with complexity analyses. By introducing independent clauses and combining formulas, Dubois (1991) presented a #SAT algorithm which ran in O(1.6180) for #2-SAT and O(1.8393) for #3-SAT, where n is the number of variables of a formula. Based on a more elaborate analysis of the relationship among the variables, Dahllof et al. (2002) presented algorithms running in O(1.3247) for #2-SAT and O(1.6894) for #3-SAT. Furer et al. (2007) presented an algorithm performing in O(1.246) for #2-SAT by using a standard reduction. Further improved algorithms in (Kutzkov 2007) presented a new upper time bound for the #3-SAT (O(1.6423)), which is the best upper bound so far. Different from complexity analyses regarding the number of variables as the parameter, Hirsch (2000) introduced a SAT algorithm with a time bound O(1.239), where m is the number of clauses of a formula. An improved algorithm for SAT with an upper bound O(1.234) was proposed in (Masaki 2005). Skjernaa (2004) presented an algorithm for Exact Satisfiability with a time bound O(2). Bolette (2006) addressed an algorithm for Exact Satisfiability with a time bound O(m!).", "startOffset": 0, "endOffset": 1257}], "year": 2010, "abstractText": "The rigorous theoretical analyses of algorithms for #SAT have been proposed in the literature. As we know, previous algorithms for solving #SAT have been analyzed only regarding the number of variables as the parameter. However, the time complexity for solving #SAT instances depends not only on the number of variables, but also on the number of clauses. Therefore, it is significant to exploit the time complexity from the other point of view, i.e. the number of clauses. In this paper, we present algorithms for solving #2-SAT and #3-SAT with rigorous complexity analyses using the number of clauses as the parameter. By analyzing the algorithms, we obtain the new worst-case upper bounds O(1.1892) for #2-SAT and O(1.4142) for #3-SAT, where m is the number of clauses.", "creator": "Acrobat PDFMaker 8.0 for Word"}}}