{"id": "1007.3858", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Jul-2010", "title": "CHR(PRISM)-based Probabilistic Logic Learning", "abstract": "PRISM is an extension of Prolog with probabilistic predicates and built-in support for expectation-maximization learning. Constraint Handling Rules (CHR) is a high-level programming language based on multi-headed multiset rewrite rules.", "histories": [["v1", "Thu, 22 Jul 2010 11:32:21 GMT  (87kb)", "http://arxiv.org/abs/1007.3858v1", null]], "reviews": [], "SUBJECTS": "cs.PL cs.AI cs.LG cs.LO", "authors": ["jon sneyers", "wannes meert", "joost vennekens", "yoshitaka kameya", "taisuke sato"], "accepted": false, "id": "1007.3858"}, "pdf": {"name": "1007.3858.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Jon Sneyers"], "emails": ["jon.sneyers@cs.kuleuven.be)", "wannes.meert@cs.kuleuven.be)", "joost.vennekens@cs.kuleuven.be)", "kameya@mi.cs.titech.ac.jp)", "sato@mi.cs.titech.ac.jp)"], "sections": [{"heading": null, "text": "ar Xiv: 100 7.38 58v1 [cs.PL] In this paper, we introduce a new probabilistic logic formalism called CHRiSM, which is based on a combination of CHR and PRISM. It can be used to rapidly prototype complex statistical models at a high level using \"random rules.\" The underlying PRISM system can then be used for several probabilistic inference tasks, including probability calculation and parameter learning. We define the CHRiSM language in terms of syntax and operational semantics and illustrate it using examples. We define the term ambiguous programs and define a distribution semantics for unique programs. Next, we describe an implementation of CHRiSM based on CHR (PRISM). We discuss the relationship between CHRiSM and other probable logical programming languages, in particular PCHR. Finally, we identify potential areas of application."}, {"heading": "1 Introduction", "text": "In fact, it is so that most of them are able to survive themselves if they are not able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are not able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are not able to survive themselves. (...) Most of them are not able to survive themselves. (...)"}, {"heading": "2.1 Syntax and Informal Semantics", "text": "The only question is whether it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is, whether it is a question, whether it is, whether it is a question, whether it is, whether it is, whether it is a question, whether it is, whether it is, whether it is a question, whether it is, whether it is, whether it is a question, whether it is, whether it is, whether it is, whether it is, whether it is a question, whether it is, whether it is, whether it is a question, whether it is, whether it is a question, whether it is, whether it is a question, whether it is, whether it"}, {"heading": "2.2 Operational Semantics", "text": "The abstract operational semantics of a CHRiSM program P are given by a statetransition system similar to the abstract operational semantics (Sneyers et al. 2010).The execution states are defined analogously, except that we additionally define a unique failed execution state called \"fail\" (because we do not want to distinguish between different failed states).We use the p?? t symbol to refer to the abstract operational semantics of CHRiSM.Definition 2.1 (identified constraint) An identified constraint c # i is a CHRiSM constraint associated with some unique integer states. This number is used to distinguish between copies of the same constraint. We present the functions chr (c # i) = c and id (c # i)."}, {"heading": "2.3 Full and Partial Observations", "text": "A complete observation Q < = = > A means that there are a number of probability decisions, so that a derivative starting with query Q yields the answer A. A partial observation Q = = = > A means that an answer to query Q contains at least A: In other words, Q = = > A applies to iff Q < = > B with A F B.Definition 2.3 (observation) A is a complete observation of the form Q < = = > A, where Q and A are conjunctions of constraints. In the face of a program P, a complete observation refers to derivatives of the form < Q, \u2205, true > 0. \u2212 \u2212 \u2212 \u2192 pP, < Snapchat, A \u2032, B > n 6, \u2212 \u2212 \u2212 \u2212 \u2192 Such that A = chr (A \u2032) is a complete observation on the form Q = = = = = > Set value: a partial observation on the form Q = = = = = = Set value."}, {"heading": "3 Example programs", "text": "As a first toy example, we consider the following CHRiSM program for throwing a coin: Toss < = > Head: 0.5; Tail: 0.5. The query \"Sample Throw\" leads to \"Head\" or \"Tail,\" each with a 50% chance. The query \"Sample Throw, Toss\" has four possible results, each with a 25% chance: \"Head, Head,\" \"Head, Tail, Head\" and \"Tail, Tail.\" Players (Tom) Player (jon) ss1 / 3ssgggg gggggggg gg gg 1 / 3 + 1 / 3 + XXX XXXXXXXXXXXXXX (tom) Player (jon) 1 / 31 / 3 $1 / 3 $J JJJscissors (tom) Player (jon) ss1 / 3 xrrr gggg gggg gg gg gg gg 1 / 3 + + 1 / 3 + XXX XXXXXXXXXXXXXX (tom) Player (tom) 1 / isstom $isstom $1 $1 $jor $1 jrrr (1rrr) Player (tom) (tom isstom) 1 / 31 / 3 $1 jisstom $1 $jor $1 jor $1 jr (jr) (1rrr)..."}, {"heading": "3.1 Rock-paper-scissors", "text": "Consider the following CHRiSM program, which simulates \"Rock Paper Scissors\" players: Player (P) < = > Example (P) < Election (P)? Rock (P). Rock (P1), Scissors (P2) = > Winner (P1). Scissors (P1), Paper (P2) = = Winner (P1). Paper (P1), Rock (P2) = > Winner (P1).We assume that each player has his own fixed probability distribution to choose between Rock, Scissors and Paper. This is indicated by the use of Election (P) as a probability expression for the election in the first rule: the probability distribution depends on the value of P and thus each player has his own distribution. However, these distributions are not known to us. By default, the unknown probability distributions for, say, tom and jon are both set to uniform distribution, which implies that we should each win a third player."}, {"heading": "3.2 Random graphs", "text": "The following rule generates any directed edge with a 50% probability: 0.5?? node (A), node (B) = = > edge (A, B). The above rule generates dense graphs; if we want to get a sparse graph, for example with an average (out-) degree of 3, we can apply the following rule: The auxiliary condition nb node (s) contains the total number of nodes n; the probability of the rule is such that each of the n (n \u2212 1) possible edges is created with the probability of 3 / (n \u2212 1), i.e. creates an average of 3n edges: even (3 / (N-1)?? nb _ node (N), node (A), node (B) = > edge (A, B)."}, {"heading": "3.3 Bayesian networks", "text": "The probability that the alarm goes off also depends on whether John calls the police, whether the alarm is triggered, and also on the probability that Mary calls. This Bayesian network can be easily described in CHRiSM: go = = >? burglary (yes). go = >? earthquake (yes), earthquake (B), earthquake (E) = > B? alarm (yes); alarm (yes)."}, {"heading": "4.2 Distribution Semantics", "text": "First, we define the equivalence of the execution states. We use a definition based on (Raiser et al. 2009) but adapted to our needs. Intuitively, we say that two states are equivalent if the execution states are equal and the built-in memory is equivalent; we do not care about identifiers and propagation histories. Definition 4.3 (equivalent states) equivalence between the execution states is the smallest equivalence relationship. s.t.: 1. < G, S, x = t, B, T > n. < G, S, S [x / t], T > n. < G, S [x / t], 3. < G, S [x / t], 3. < G, S, B, T > n. < G > n."}, {"heading": "4.3 Ambiguity", "text": "Some programs are ambiguous in the sense that they do not define a unique probability distribution of possible end states. Consider the following example: 0.5?? a < = > b. 0.5?? a < 0.5?? a < = 0.5. \"If we use an execution strategy starting with the first rule, then this rule is applied with a 50% probability and we get the end result\" b, \"with a 50% probability the second rule is considered\" c \"with a 25% probability, and if no rule is applied, the result is\" a \"with a 25% probability. However, if we use an execution strategy that takes the second rule into account, then we get a different distribution:\" c \"has a 50% probability, and\" b \"a 25% probability. A program is unambiguous if the probability of an observation does not depend on the execution class. The program in the above example is ambiguous, but it is unambiguous."}, {"heading": "5.1 PRISM", "text": "PRISM (Sato 2008) is a programming language with probabilistic logic. It is an extension of prologue with a built-in probabilistic multi-value random switch (msw).A multi-value switch atom msw (exp, Result) represents a probabilistic experiment called exp (a ground prolog term) that leads to a result.The possible results of such an experiment are defined by a predicate value (term, [v1,..., vn]) and the term unites with exp. By default, a uniform distribution is assumed (all values are equally probable).Different probabilities can be assigned using set _ sw (term, [p1,..., pn]).A PRISM program consists of two parts, rules R and facts F. Facts F define a uniform probability distribution (all values are equally probable)."}, {"heading": "5.2 Transformation to CHR(PRISM)", "text": "The transformation from CHRiSM to CHR (PRISM) is relatively simple and can be done efficiently (linear time), illustrated by an example. Let's look again at the rule \"player (P) < = > choice (P)? rock (P); scissors (P); paper (P)\" from Section 3.1. It is translated into the following CHR (PRISM) code: values (choice (_), [1,2,3]). player (P) < msw (choice (P), X), (X = 1- > rock (P); X = 2- > scissors (P): values (choice (P), [1,2,3])."}, {"heading": "6 Related Work", "text": "The idea of a probable version of PCHR is not new. In (Fru Fr\u00fchwirth et al.) \"We have only a limited number of terms that move in the real world,\" according to PCHR, \"but there is only a limited number of terms that move in the real world.\" (PCHR) \"There is only a limited number of terms that differ in the real world from the real world from the real world.\" (PCHR) \"There is only a limited number of terms that move in the real world.\" (PCHR) \"There is only a limited number of terms that differ in the real world from the real world from the real world.\" (PCHR) There is only the possibility that their semantic derivatives can be understood. \"(PCHR) It is that their semantic interpretation instantiates the abstract operative semantics of CHR (Sneyers et al. 2010): Every PCHR derivative we can derive (PCHR)."}, {"heading": "7 Potential Applications", "text": "Since the characteristics of PRISM and CHR are largely orthogonal, we can assume that CHRiSM is highly suitable for applications at the interface of the application areas of PRISM and CHR. An example of an application area at the interface is kidnapping, which has been investigated in the context of PRISM (Sato and Kameya 2002) and also in the context of CHR (Sneyers et al. (2010), Section 7.3.2). Computational linguistics and bioinformatics are two other areas in which PRISM and CHR have proven to be very valuable tools (Sato 2008; Christiansen 2005; Christiansen and Lassen 2009). Furthermore, there is clear potential for probable extensions of existing approaches in many application areas of CHR, for example for dealing with uncertain information. Examples are (section numbers refer to Sneability and Lassen 2009)."}, {"heading": "8 Conclusion", "text": "In this exploratory paper, we have introduced a novel rule-based probabilistic-logical formalism called CHRiSM, based on a combination of CHR and PRISM. We have defined operational semantics for any CHRiSM program and distribution semantics for unique CHRiSM programs. We have illustrated the CHRiSM system using examples and outlined some potential areas of application where CHRiSM can be used. Finally, we have outlined the implementation of the CHRiSM system and discussed related languages, especially PCHR. We believe CHR has important advantages over prologue, including the complexity and expressivity of multi-headed rules. We expect CHRiSM to have the same advantages over simple PRISM. There are several directions for future work. The notion of ambiguity and its relationship to confluence needs to be explored; in particular, the existence of a decipherable ambiguity test for the PRISM simple method."}], "references": [], "referenceMentions": [], "year": 2010, "abstractText": "PRISM is an extension of Prolog with probabilistic predicates and built-in support for<lb>expectation-maximization learning. Constraint Handling Rules (CHR) is a high-level pro-<lb>gramming language based on multi-headed multiset rewrite rules.<lb>In this paper, we introduce a new probabilistic logic formalism, called CHRiSM, based<lb>on a combination of CHR and PRISM. It can be used for high-level rapid prototyping<lb>of complex statistical models by means of \u201cchance rules\u201d. The underlying PRISM system<lb>can then be used for several probabilistic inference tasks, including probability compu-<lb>tation and parameter learning. We define the CHRiSM language in terms of syntax and<lb>operational semantics, and illustrate it with examples. We define the notion of ambigu-<lb>ous programs and define a distribution semantics for unambiguous programs. Next, we<lb>describe an implementation of CHRiSM, based on CHR(PRISM). We discuss the rela-<lb>tion between CHRiSM and other probabilistic logic programming languages, in particular<lb>PCHR. Finally, we identify potential application domains.", "creator": "LaTeX with hyperref package"}}}