{"id": "1102.2125", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Feb-2011", "title": "Improving DPLL Solver Performance with Domain-Specific Heuristics: the ASP Case", "abstract": "In spite of the recent improvements in the performance of the solvers based on the DPLL procedure, it is still possible for the search algorithm to focus on the wrong areas of the search space, preventing the solver from returning a solution in an acceptable amount of time. This prospect is a real concern e.g. in an industrial setting, where users typically expect consistent performance. To overcome this problem, we propose a framework that allows learning and using domain-specific heuristics in solvers based on the DPLL procedure. The learning is done off-line, on representative instances from the target domain, and the learned heuristics are then used for choice-point selection. In this paper we focus on Answer Set Programming (ASP) solvers. In our experiments, the introduction of domain-specific heuristics improved performance on hard instances by up to 3 orders of magnitude (and 2 on average), nearly completely eliminating the cases in which the solver had to be terminated because the wait for an answer had become unacceptable.", "histories": [["v1", "Thu, 10 Feb 2011 14:21:57 GMT  (93kb,S)", "http://arxiv.org/abs/1102.2125v1", "Presented at the ASPOCP10 workshop of ICLP10"]], "COMMENTS": "Presented at the ASPOCP10 workshop of ICLP10", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["marcello balduccini"], "accepted": false, "id": "1102.2125"}, "pdf": {"name": "1102.2125.pdf", "metadata": {"source": "CRF", "title": "Improving DPLL Solver Performance with Domain-Specific Heuristics: the ASP Case", "authors": ["Marcello Balduccini"], "emails": ["marcello.balduccini@gmail.com"], "sections": [{"heading": null, "text": "ar Xiv: 110 2.21 25v1 [cs.AI] 10 Fe"}, {"heading": "1 Introduction", "text": "In recent years, it has become clear that this project is a project to put people's interests at the heart of society."}, {"heading": "2 Answer Set Programming", "text": "We refer the reader to [6,8] for a specification of formal semantics. Let \u03a3 be a signature containing constant, function and predicate symbols. Terms and atoms are formed as usual in first order logic. A rule is either an atom a or its strong (also classical or epistemic) negation a. The set of words formed from the signature is characterized by lit (\u03a3). A rule is a statement of the form: h1. A rule is either an atom a or its strong (also called classical or epistemic) negation a. The series of words formed from the signature is characterized by lit (\u03a3). A rule is a statement of the form: h1. An explanation of the form of the word is either an answer, lm, not literal, not literal, not literal, and not literal. The signature of hi's and li's are basic letters, and the rule is not a reason, the meaning being an intuition that reason is an intuition."}, {"heading": "3 Search in ASP Solvers", "text": "The search algorithm used by many ASP solvers is not l when e = is partially solved. [9], DLV [10]) is not based on the DPLL algorithm (1,2]. However, the basic algorithm for calculating a single answer, which we will later call the standard algorithm, is in Figure 1. Thealgorithm is based on the idea of developing a specific set of (ground) literals, which are often referred to as partial words, until it is either shown to be a response of the program, or it becomes inconsistent. To achieve this, guesses must be made about which literals can be included in the answer. Let us now describe the algorithms more precisely, literally we mean a literal l or the expression not l, which intuitively means that l is known not to be in the answer (but its completeness, l, may or may not hold)."}, {"heading": "4 The DORS Framework", "text": "It is obvious that a good strategy for selecting the letters from {p, not q} and only later (if necessary) must be worked out in relation to the general problem in which one is interested in solving a series of problem cases from a particular problem domain. [11] In addition, this is particularly the case in industrial applications where the application contains the domain description, and the user describes the instance that uses a particular interface (let us refer, for example, to [12]), which then automatically instance.Program P1, which was previously shown, can be considered to consist of a domain description and a problem instance: the first 7 rules are the former, while the definition of the prediction t is the problem instance. [t (5), t (6), t (7), t (7)}, it is obvious that a good strategy for selecting the letters from {p, not p, q} and can only be defined later (if necessary)."}, {"heading": "5 Experimental Evaluation", "text": "In fact, the fact is that most of us are able to move to another world, in which we are able, in which we are able to move, and in which we are able to change the world, \"he told the German Press Agency."}, {"heading": "6 Conclusions", "text": "In this paper, we have described a framework that allows learning and using domain specific heuristics to select selection points, and we have its application9 The actual acceleration may actually be higher because SMODELS is limited in time. As a test, we have run SMODELS over 60,000 seconds (16 hours) on some of these cases without getting a solution.Our experimental evaluation has shown that domain specific heuristics can provide remarkable accelerations and make it possible to find answers that otherwise cannot be calculated in a reasonable time span. In the case of the RCS domain, a large number of cases for which the default solver has been delayed could be solvable within seconds using domain specific heuristics, with an average acceleration of more than 2 orders of magnitude and peaks of more than 3. This is the kind of consistent performance that makes a solver viable for industrial applications."}], "references": [{"title": "A Computing Procedure for Quantification Theory", "author": ["M. Davis", "H. Putnam"], "venue": "Communications of the ACM 7", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1960}, {"title": "A Machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1962}, {"title": "The Conflict-Driven Answer Set Solver clasp: Progress Report", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR09).", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "In Veloso, M.M., ed.: Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI\u201907), MIT Press", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "BerkMin: A Fast and Robust Sat-Solver", "author": ["E. Goldberg", "Y. Novikov"], "venue": "Proceedings of Design, Automation and Test in Europe Conference (DATE-2002).", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1991}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V.W. Marek", "M. Truszczynski"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, Berlin", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1999}, {"title": "Extending the Smodels System with Cardinality and Weight Constraints", "author": ["I. Niemela", "P. Simons"], "venue": "Logic-Based Artificial Intelligence. Kluwer Academic Publishers", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2000}, {"title": "Extending and implementing the stable model semantics", "author": ["I. Niemela", "P. Simons", "T. Soininen"], "venue": "Artificial Intelligence 138(1\u20132)", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2002}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7(3)", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "The Second Answer Set Programming Competition", "author": ["M. Denecker", "J. Vennekens", "S. Bond", "M. Gebser", "M. Truszczynski"], "venue": "10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR09).", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "Answer Set Based Design of Knowledge Systems", "author": ["M. Balduccini", "M. Gelfond", "M. Nogueira"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Reinforcement learning: an introduction", "author": ["A.G. Barto", "R.S. Sutton"], "venue": "MIT Press", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1998}, {"title": "Building Knowledge Systems in A-Prolog", "author": ["M. Nogueira"], "venue": "PhD thesis, University of Texas at El Paso", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 0, "context": "In recent years, solvers based on the DPLL procedure [1,2] have become amazingly fast.", "startOffset": 53, "endOffset": 58}, {"referenceID": 1, "context": "In recent years, solvers based on the DPLL procedure [1,2] have become amazingly fast.", "startOffset": 53, "endOffset": 58}, {"referenceID": 2, "context": "An interesting step in that direction is provided by CLASPFOLIO [3], which makes", "startOffset": 64, "endOffset": 67}, {"referenceID": 3, "context": "use of different configurations of the CLASP solver [4].", "startOffset": 52, "endOffset": 55}, {"referenceID": 4, "context": "[5,4]), and have brought about substantial performance improvements.", "startOffset": 0, "endOffset": 5}, {"referenceID": 3, "context": "[5,4]), and have brought about substantial performance improvements.", "startOffset": 0, "endOffset": 5}, {"referenceID": 5, "context": "Although here we focus on solvers for Answer Set Programming (ASP) [6,7], the DORS framework can be applied to any solver based on the DPLL procedure, including SAT and constraint solvers.", "startOffset": 67, "endOffset": 72}, {"referenceID": 6, "context": "Although here we focus on solvers for Answer Set Programming (ASP) [6,7], the DORS framework can be applied to any solver based on the DPLL procedure, including SAT and constraint solvers.", "startOffset": 67, "endOffset": 72}, {"referenceID": 5, "context": "We refer the reader to [6,8] for a specification of the formal semantics.", "startOffset": 23, "endOffset": 28}, {"referenceID": 7, "context": "We refer the reader to [6,8] for a specification of the formal semantics.", "startOffset": 23, "endOffset": 28}, {"referenceID": 7, "context": "Because a convenient representation of alternatives is often important in the formalization of knowledge, the language of ASP has been extended with constraint literals [8], which are expressions of the form m{l1, l2, .", "startOffset": 169, "endOffset": 172}, {"referenceID": 8, "context": "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].", "startOffset": 8, "endOffset": 11}, {"referenceID": 9, "context": "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].", "startOffset": 17, "endOffset": 21}, {"referenceID": 0, "context": "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].", "startOffset": 54, "endOffset": 59}, {"referenceID": 1, "context": "SMODELS [9], DLV [10]) is based on the DPLL procedure [1,2].", "startOffset": 54, "endOffset": 59}, {"referenceID": 8, "context": "Function expand [9] is then used to add to the partial answer set all the literals that must hold given \u03a0 and A.", "startOffset": 16, "endOffset": 19}, {"referenceID": 8, "context": "For example, in SMODELS the selection is roughly based on maximizing the number of consequences that can be derived after selecting the given extended literal [9].", "startOffset": 159, "endOffset": 162}, {"referenceID": 4, "context": "[5,4]).", "startOffset": 0, "endOffset": 5}, {"referenceID": 3, "context": "[5,4]).", "startOffset": 0, "endOffset": 5}, {"referenceID": 10, "context": "the Second Answer Set Programming Competition [11].", "startOffset": 46, "endOffset": 50}, {"referenceID": 11, "context": "to [12]), which then automatically encodes the problem instance.", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "[13] for a comprehensive introduction on the topic), that is, in general terms, of a mapping from states to probabilities of selecting each available action.", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "[8].", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5]) rather than DPLL.", "startOffset": 0, "endOffset": 3}, {"referenceID": 10, "context": "The 15 puzzle problem was one of the benchmarks used for the Second ASP Programming Competition [11].", "startOffset": 96, "endOffset": 100}, {"referenceID": 13, "context": "[14,12], the RCS is the Shuttle\u2019s system that has primary responsibility for maneuvering the Shuttle while it is in space.", "startOffset": 0, "endOffset": 7}, {"referenceID": 11, "context": "[14,12], the RCS is the Shuttle\u2019s system that has primary responsibility for maneuvering the Shuttle while it is in space.", "startOffset": 0, "endOffset": 7}, {"referenceID": 13, "context": "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).", "startOffset": 24, "endOffset": 31}, {"referenceID": 11, "context": "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).", "startOffset": 24, "endOffset": 31}, {"referenceID": 11, "context": "The system described in [14,12] uses a model of the RCS, as well as ASP-based reasoning algorithms, to provide ground control with a decision-support system that automatically generates configuration procedures for the RCS and that can be used when faulty components are present (incidentally, the system can also perform diagnostic reasoning [12]).", "startOffset": 343, "endOffset": 347}, {"referenceID": 13, "context": "8 The interested reader may refer to [14] for a description of the instances.", "startOffset": 37, "endOffset": 41}, {"referenceID": 13, "context": "For our testing, we have selected a set of 425 instances from the collection, corresponding to the public instances with no electrical faults and 3, 8, and 10 mechanical faults respectively, for which a plan of length 6 or less (determined by parameter lasttime) was found in the experiments discussed in [14,12], and we have analyzed the performance of the solver on planning with maximum lengths ranging between 6 and 10.", "startOffset": 305, "endOffset": 312}, {"referenceID": 11, "context": "For our testing, we have selected a set of 425 instances from the collection, corresponding to the public instances with no electrical faults and 3, 8, and 10 mechanical faults respectively, for which a plan of length 6 or less (determined by parameter lasttime) was found in the experiments discussed in [14,12], and we have analyzed the performance of the solver on planning with maximum lengths ranging between 6 and 10.", "startOffset": 305, "endOffset": 312}], "year": 2013, "abstractText": "In spite of the recent improvements in the performance of the solvers based on the DPLL procedure, it is still possible for the search algorithm to focus on the wrong areas of the search space, preventing the solver from returning a solution in an acceptable amount of time. This prospect is a real concern e.g. in an industrial setting, where users typically expect consistent performance. To overcome this problem, we propose a framework that allows learning and using domain-specific heuristics in solvers based on the DPLL procedure. The learning is done off-line, on representative instances from the target domain, and the learned heuristics are then used for choice-point selection. In this paper we focus on Answer Set Programming (ASP) solvers. In our experiments, the introduction of domain-specific heuristics improved performance on hard instances by up to 3 orders of magnitude (and 2 on average), nearly completely eliminating the cases in which the solver had to be terminated because the wait for an answer had become unacceptable.", "creator": "LaTeX with hyperref package"}}}