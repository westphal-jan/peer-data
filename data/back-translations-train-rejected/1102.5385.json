{"id": "1102.5385", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Feb-2011", "title": "Back and Forth Between Rules and SE-Models (Extended Version)", "abstract": "Rules in logic programming encode information about mutual interdependencies between literals that is not captured by any of the commonly used semantics. This information becomes essential as soon as a program needs to be modified or further manipulated.", "histories": [["v1", "Sat, 26 Feb 2011 03:06:55 GMT  (30kb)", "https://arxiv.org/abs/1102.5385v1", "25 pages"], ["v2", "Tue, 1 Mar 2011 18:08:20 GMT  (30kb)", "http://arxiv.org/abs/1102.5385v2", "25 pages; extended version of the paper accepted for LPNMR 2011"]], "COMMENTS": "25 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["martin slota", "jo\\~ao leite"], "accepted": false, "id": "1102.5385"}, "pdf": {"name": "1102.5385.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Jo\u00e3o Leite"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 110 2.53 85v2 [cs.AI] 1M ar"}, {"heading": "1 Motivation", "text": "In fact, most people who are able to survive themselves are not able to survive themselves, \"he told the German Press Agency in an interview with\" Welt am Sonntag \":\" I don't think we will be able to change the world. \""}, {"heading": "2 Preliminaries", "text": "We assume that a non-empty, finite series of propositional atoms is given. We assume that a series of propositional formulas is given. We construct both propositional formulas and rules.Propositional formulas are formed in the usual way by propositional formulas. If a formula is true, then we also say that I am a model of the propositional formulas. I.S. calls the set of all interpretations similar to propositional formulas. The basic syntactical building blocks of rules are propositional atoms of L. A negative letter is a preceding denotic negation. A literal negative negative negative negative negative negative negative model is either an atom or a negative dictionary."}, {"heading": "3 Rule Equivalence Classes and their Canonical Rules", "text": "Our aim is to gain useful insights into the inner workings of SE model semantics with regard to individual rules. To this end, we first present a series of representatives of the rule equivalence classes induced by SE models and show how the representative of a class can be constructed using one of its members. Then, we show how to reconstruct a representative from the set of his SE models. Finally, we show the conditions under which a number of SE interpretations are rule-representative."}, {"heading": "3.1 Canonical Rules", "text": "Most of these results have already been formulated in various ways [20, 2, 21]. The following result summarizes the conditions under which a rule is SE-tautological: Lemma 2 (sequence of theorems 4.4 in [2]; part i) of Lemma 2 in [21]. Let H and B are sentences of words and p is an atom. Then a rule is SE-tautological when it assumes one of the following forms: p; H \u2190 p; B; B; B; B; p; p, p; Proof. Proof. p; A; p. 16; the repetition of an atom in different \"components\" of the rule often causes the rule SE-tautological. In particular, this happens when the same atom occurs in the positive head and positive body."}, {"heading": "3.2 Reconstructing Rules", "text": "In order to reconstruct a rule r from the set S of its SE models, if I do not need to examine a J model of the J-J situation, we need to understand how exactly each of these conditions affects their models. & & r > J + J (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S (R) -S) S (R) S (R) S (R) S (S) S (S) S (S) S (R) S (R) S (R) S (R) S (R) S (R) S (R) S (S) -S (R) S (R) S (R) S (S) -S (R) S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R) S (R) S (R) S (S (R) S (R) -S (R) -S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R (R) S (R) S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R) -S (R) S (R) S (R) -S (R) S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R) S (R) -S (R) S (R) S (R) S (R) S (R) S (R) S (R) S (R) S (R)"}, {"heading": "4 Discussion", "text": "The main purpose of the presented results is to facilitate the transition between a rule and the set of its SE models; they also make it possible to find out when a particular set of SE models can be represented by a single rule. We believe that in situations where information about literal dependencies, expressed in individual rules, is essential for defining operations on logical programs, the advantages of dealing with rules at the level of semantics rather than at the level of syntax are significant; the semantic point of view takes care of removing unnecessary detail; and since the introduced terms and operators are defined in relation to semantic objects, it should be much easier to introduce and prove their semantic properties; these results can be used, for example, in the context of program updates, to define an update of semantics based on the rule rejection principle [4] and to operate on sets of SE models. Such semantics can serve as a bridge between syntax-based rule-making approaches."}, {"heading": "Acknowledgement", "text": "We would like to thank Han The Anh, Matthias Knorr and the anonymous reviewers for their comments, which have contributed to the improvement of the work. Martin Slota is supported by the FCT scholarship SFRH / BD / 38214 / 2007."}, {"heading": "A Proofs", "text": "Lemma 2: Drop H and B: sets of letters and p: a model of J-R is wrong. < J > J > J SE: a rule is SE: p; H \u2190 p, B. H: p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 p \u00b7 B, p > p.Proof. J > J > J SE: a rule r is, however, of the first form. We must show that any SE interpretation is either an SE model of r. < I, J > is some SE interpretation. So rule r is C-tautological, so J is a C model of r. Moreover, rJ is either an S model of r, or it inherits p in its head and body from r. In any case, R is tautological, so I am a C model of rJ. Consequently: I > is an SE model of rJ > is an SE model of r."}, {"heading": "H ;\u223cp \u2190 p,B. H \u2190 p,B.", "text": "Proving that the first rule is a C model of r J 2. < I > J > J SE is just an SE interpretation. If p is wrong under J, then J is a C model of r1 and r2. Furthermore, rJ1 is an SE model of both r1 and r2 equivalent. On the other hand, if p is true under J, then J is a C model of r1, if it is a C model of r2, then < I > is an SE model of both r1 and r2 equivalent. On the other hand, if p is true, then J is a C model of r1, if and only if it is a C model of r2, then < J > is an SE model of r1 identical to r2. Also, rJ1 is identical to r J 2, so is a C model of rJ 1."}], "references": [{"title": "Strongly equivalent logic programs", "author": ["Vladimir Lifschitz", "David Pearce", "Agust\u0131\u0301n Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2001}, {"title": "Equivalence of logic programs under updates", "author": ["Katsumi Inoue", "Chiaki Sakama"], "venue": "Proceedings of the 9th European Conference on Logics in Artificial Intelligence,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2004}, {"title": "REVISE: Logic programming and diagnosis", "author": ["Carlos Viegas Dam\u00e1sio", "Lu\u0131\u0301s Moniz Pereira", "Michael Schroeder"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1997}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["Jos\u00e9 J\u00falio Alferes", "Jo\u00e3o Alexandre Leite", "Lu\u0131\u0301s Moniz Pereira", "Halina Przymusinska", "Teodor C. Przymusinski"], "venue": "The Journal of Logic Programming,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2000}, {"title": "On properties of update sequences based on causal rejection", "author": ["Thomas Eiter", "Michael Fink", "Giuliana Sabbatini", "Hans Tompits"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "An abductive framework for computing knowledge base updates", "author": ["Chiaki Sakama", "Katsumi Inoue"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Logic program-based updates", "author": ["Yan Zhang"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2006}, {"title": "The refined extension principle for semantics of dynamic logic programming", "author": ["Jos\u00e9 J\u00falio Alferes", "Federico Banti", "Antonio Brogi", "Jo\u00e3o Alexandre Leite"], "venue": "Studia Logica,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "A preference-based framework for updating logic programs", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Belief revision of logic programs under answer set semantics", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics", "author": ["James P. Delgrande"], "venue": "Theory and Practice of Logic Programming, 26th Int\u2019l. Conference on Logic Programming Special Issue,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Belief Revision, chapter Belief Revision: An Introduction, pages 1\u201328", "author": ["Peter G\u00e4rdenfors"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1992}, {"title": "On semantic update operators for answer-set programs", "author": ["Martin Slota", "Jo\u00e3o Leite"], "venue": "Proceedings of the 19th European Conference on Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Towards a theory of declarative knowledge", "author": ["Krzysztof R. Apt", "Howard A. Blair", "Adrian Walker"], "venue": "In Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1988}, {"title": "A classification theory of semantics of normal logic programs: II", "author": ["J\u00fcrgen Dix"], "venue": "Weak properties. Fundamenta Informaticae,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1995}, {"title": "Die Logik und das Grundlagenproblem", "author": ["Jan \u0141ukasiewicz"], "venue": "In Les Entretiens de Zu\u0308rich sue les Fondements et la me\u0301thode des sciences mathe\u0301matiques", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1938}, {"title": "A new logical characterisation of stable models and answer sets", "author": ["David Pearce"], "venue": "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1997}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["Hudson Turner"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2003}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proceedings of the 5th International Conference and Symposium on Logic Programming,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1988}, {"title": "Negation as failure in the head", "author": ["Katsumi Inoue", "Chiaki Sakama"], "venue": "Journal of Logic Programming,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1998}, {"title": "Minimal logic programs", "author": ["Pedro Cabalar", "David Pearce", "Agust\u0131\u0301n Valverde"], "venue": "Proceedings of the 23rd International Conference on Logic Programming (ICLP 2007),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "Introduction to Lattices and Order", "author": ["Brian A. Davey", "Hilary A. Priestley"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1990}], "referenceMentions": [{"referenceID": 0, "context": "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "startOffset": 106, "endOffset": 109}, {"referenceID": 1, "context": "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "startOffset": 152, "endOffset": 155}, {"referenceID": 0, "context": "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].", "startOffset": 103, "endOffset": 106}, {"referenceID": 1, "context": "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].", "startOffset": 149, "endOffset": 152}, {"referenceID": 2, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 3, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 4, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 5, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 6, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 7, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 8, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 9, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 10, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 11, "context": "Moreover, such a more semantic approach could facilitate the establishment of bridges with the area of Belief Change (see [12] for an introduction), and benefit from the many years of research where semantic change operations on monotonic logics have been studied, desirable properties for such operations have been identified, and constructive definitions of operators satisfying these properties have been introduced.", "startOffset": 122, "endOffset": 126}, {"referenceID": 3, "context": "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.", "startOffset": 57, "endOffset": 64}, {"referenceID": 12, "context": "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.", "startOffset": 57, "endOffset": 64}, {"referenceID": 3, "context": "Though their definition and analysis is technically possible and leads to very elegant and seemingly desirable properties, there are a number of simple examples for which these methods fail to provide results that would be in line with basic intuitions [4].", "startOffset": 253, "endOffset": 256}, {"referenceID": 12, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 18, "endOffset": 22}, {"referenceID": 13, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 249, "endOffset": 257}, {"referenceID": 14, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 249, "endOffset": 257}, {"referenceID": 0, "context": "\u2013 identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; \u2013 show how to reconstruct canonical rules from their sets of SE-models; \u2013 based on the above, characterise the sets of SE-interpretations that are representable by a single rule; \u2013 reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; \u2013 introduce two new notions of equivalence \u2013 stronger than strong equivalence [1] and weaker than strong update equivalence [2] \u2013 and argue that they are more suitable when rules are to be treated as first-class citizens.", "startOffset": 510, "endOffset": 513}, {"referenceID": 1, "context": "\u2013 identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; \u2013 show how to reconstruct canonical rules from their sets of SE-models; \u2013 based on the above, characterise the sets of SE-interpretations that are representable by a single rule; \u2013 reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; \u2013 introduce two new notions of equivalence \u2013 stronger than strong equivalence [1] and weaker than strong update equivalence [2] \u2013 and argue that they are more suitable when rules are to be treated as first-class citizens.", "startOffset": 556, "endOffset": 559}, {"referenceID": 15, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 50, "endOffset": 58}, {"referenceID": 16, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 50, "endOffset": 58}, {"referenceID": 17, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 173, "endOffset": 177}, {"referenceID": 18, "context": "This second semantics is strictly more expressive than both classical models and the stable model semantics [19].", "startOffset": 108, "endOffset": 112}, {"referenceID": 19, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 1, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 20, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 1, "context": "4 in [2]; part i) of Lemma 2 in [21]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 20, "context": "4 in [2]; part i) of Lemma 2 in [21]).", "startOffset": 32, "endOffset": 36}, {"referenceID": 20, "context": "Lemma 3 (Consequence of (3) and (4) in Lemma 1 in [21]).", "startOffset": 50, "endOffset": 54}, {"referenceID": 19, "context": "10 in [20] and Corollary 1 in [21]).", "startOffset": 6, "endOffset": 10}, {"referenceID": 20, "context": "10 in [20] and Corollary 1 in [21]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "This definition is closely related with the notion of a fundamental rule introduced in Definition 1 of [21].", "startOffset": 103, "endOffset": 107}, {"referenceID": 20, "context": "Lemma 8 (Different formulation of Theorem 4 in [21]).", "startOffset": 47, "endOffset": 51}, {"referenceID": 9, "context": "Moreover, for every well-defined set of SE-interpretations S there exists a program P such that S = modSE (P) [10].", "startOffset": 110, "endOffset": 114}, {"referenceID": 21, "context": "[22].", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "These results can be used for example in the context of program updates to define an update semantics based on the rule rejection principle [4] and operating on sets of sets of SE-models.", "startOffset": 140, "endOffset": 143}, {"referenceID": 1, "context": "Related to this is the very strong notion of equivalence which was introduced in [2]:", "startOffset": 81, "endOffset": 84}, {"referenceID": 1, "context": "1 in [2]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 1, "context": "Two programs are strongly update equivalent only under very strict conditions \u2013 it is shown in [2] that two programs are SU-equivalent if and only if their symmetric difference contains only SE-tautological rules.", "startOffset": 95, "endOffset": 98}, {"referenceID": 1, "context": "The other notion of program equivalence introduced in [2], strong update equivalence on common rules, or SUC-equivalence, is incomparable in terms of strength to our new notions of equivalence.", "startOffset": 54, "endOffset": 57}, {"referenceID": 3, "context": "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently \u2013 while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].", "startOffset": 357, "endOffset": 363}, {"referenceID": 7, "context": "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently \u2013 while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].", "startOffset": 357, "endOffset": 363}, {"referenceID": 15, "context": "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].", "startOffset": 261, "endOffset": 269}, {"referenceID": 16, "context": "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].", "startOffset": 261, "endOffset": 269}], "year": 2017, "abstractText": "Rules in logic programming encode information about mutual interdependencies between literals that is not captured by any of the commonly used semantics. This information becomes essential as soon as a program needs to be modified or further manipulated. We argue that, in these cases, a program should not be viewed solely as the set of its models. Instead, it should be viewed and manipulated as the set of sets of models of each rule inside it. With this in mind, we investigate and highlight relations between the SE-model semantics and individual rules. We identify a set of representatives of rule equivalence classes induced by SE-models, and so pinpoint the exact expressivity of this semantics with respect to a single rule. We also characterise the class of sets of SE-interpretations representable by a single rule. Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}