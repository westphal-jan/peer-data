{"id": "1103.3123", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Mar-2011", "title": "Reduced Ordered Binary Decision Diagram with Implied Literals: A New knowledge Compilation Approach", "abstract": "Knowledge compilation is an approach to tackle the computational intractability of general reasoning problems. According to this approach, knowledge bases are converted off-line into a target compilation language which is tractable for on-line querying. Reduced ordered binary decision diagram (ROBDD) is one of the most influential target languages. We generalize ROBDD by associating some implied literals in each node and the new language is called reduced ordered binary decision diagram with implied literals (ROBDD-L). Then we discuss a kind of subsets of ROBDD-L called ROBDD-i with precisely i implied literals (0 \\leq i \\leq \\infty). In particular, ROBDD-0 is isomorphic to ROBDD; ROBDD-\\infty requires that each node should be associated by the implied literals as many as possible. We show that ROBDD-i has uniqueness over some specific variables order, and ROBDD-\\infty is the most succinct subset in ROBDD-L and can meet most of the querying requirements involved in the knowledge compilation map. Finally, we propose an ROBDD-i compilation algorithm for any i and a ROBDD-\\infty compilation algorithm. Based on them, we implement a ROBDD-L package called BDDjLu and then get some conclusions from preliminary experimental results: ROBDD-\\infty is obviously smaller than ROBDD for all benchmarks; ROBDD-\\infty is smaller than the d-DNNF the benchmarks whose compilation results are relatively small; it seems that it is better to transform ROBDDs-\\infty into FBDDs and ROBDDs rather than straight compile the benchmarks.", "histories": [["v1", "Wed, 16 Mar 2011 08:12:05 GMT  (476kb)", "http://arxiv.org/abs/1103.3123v1", "18 pages, 13 figures"], ["v2", "Thu, 24 Mar 2011 04:23:05 GMT  (477kb)", "http://arxiv.org/abs/1103.3123v2", "18 pages, 13 figures"]], "COMMENTS": "18 pages, 13 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["yong lai", "dayou liu", "shengsheng wang"], "accepted": false, "id": "1103.3123"}, "pdf": {"name": "1103.3123.pdf", "metadata": {"source": "CRF", "title": "Reduced Ordered Binary Decision Diagram with Implied Literals: A New knowledge Compilation Approach", "authors": ["Yong Lai", "Dayou Liu", "Shengsheng Wang"], "emails": ["laiy07@mails.jlu.edu.cn"], "sections": [{"heading": null, "text": "Keywords: knowledge compilation, target language, ROBDD, implicit dictionaries"}, {"heading": "1 Introduction", "text": "The basic idea of knowledge compilation is to divide the argumentation process into two phases: an offline compilation phase, in which the meaningful theory can be amortized by an (potentially) exponential number of online source texts. Target language is one of the key aspects of any compilation approach. Dozens of target languages exist, such as Horn theories [1], Prime implies / implies [6, 7], Reduced Binary Decision Diagrams (ROBDD)."}, {"heading": "2 Reduced Ordered Binary Decision Diagram with Implied Literals", "text": "In the sequence X = x1, xn \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\""}, {"heading": "4 The Operations of ROBDD-\u221e", "text": "The following queries and transformations have been taken into account in the Knowledge Chart. We only remember them and the readers are referred to [5] for their import formula. Definition 8: Since each subset L of NNF, L satisfies CO (resp. VA) iff, there is a multipart algorithm that maps every formula from L to 1 if it is consistent (resp. L satisfies CE iff, there is a multipart algorithm that maps every formula from L to 1). L satisfies CE iff, there is a multipart algorithm that maps every formula from L to 1. L satisfies CE iff, there is a multipart algorithm that maps every formula from L and every clause C to 1, and to 0 otherwise. L satisfies IM iff, there is a multipart algorithm that maps every formula from L to 1."}, {"heading": "5.1 Compilation Algorithm", "text": "The assembly algorithm Build is shown in Figure 10. Its correctness is guaranteed by the following efficiency. (Proposition 10) In view of any proposition formula, Build can be finished in finite time and its output is the corresponding ROBDD-i. Let X be the quantity of variables that appears in consideration of the size of the production line. We prove the proposition by the production line, when the production line can be finished in finite time, and its output is the ROBDD-i corresponding with the root v such variables that VARS (v) the production line, when the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the assembly line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production line, the production"}, {"heading": "5.2 Some Techniques to Improve the Performance of Build-inf", "text": "The algorithmic foundations of horn theory can only be applied if we greatly reduce the number of algorithms called. (1) The efficiency of the algorithm depends greatly on the number of languages called. (2) The number of algorithms called depends greatly on the number of languages called. (3) Horn theory implies a literal approximation, so that any approximation is only possible if it implies a lower approximation to the number of algorithms called. (2) And it is well known that all the implicit principles of horn theory are applied to reduce the number of algorithms called. (2) We use these properties to reduce the number of algorithms called."}, {"heading": "5.3 Transforming ROBDD-\u221e into ROBDD", "text": "As already mentioned, the algorithm Build in algorithm 5 can be converted to [20] if the input is done in CNF. However, the experimental results in [20] show that the efficiency of algorithm 5 needs to be further improved. In this section we present an alternative: We show that each ROBDD- \u221e can be converted to the corresponding ROBDD using the algorithm Inf2ROBDD in Figure 13. and we will see that this approach exceeds algorithm 5 in [20] in the next section. Note that in line 10 we only need to move the node whose root u2 is with u1 to get the conjpoint, because each variable in VARS (u2) is smaller than the one in VARS (u1)."}, {"heading": "6 Preliminary Experimental Results", "text": "In this section we report some experimental results to our ROBDD-L package BDDjLu, which we have developed depending on dependencies. In this section we report some experimental results to our ROBDD-L package BDDjLu 3. In BDDjLu, any CNF formula can be compiled in ROBD- 3 in polytime. BDDjLu also contains the algorithms Inf2ROBDD and Inf2FBDD. As mentioned before, in Build and Build-inf, SAT Solver we cannot decide whether a CNF formula is satisfactory or not. BDDjLu also contains the implied literals in a CNF formula, deciding whether the variables can be transferred to CNF formula. Thus, we also implement a DPLL-based SAT solution based on the one used in the other."}, {"heading": "7 Conclusions", "text": "In this paper, we present a new ROBDD-L compilation approach by associating some implicit letters in each node of ROBDD-L. Then, an interesting type of subsets of ROBDD-L are discussed: Given a number of i, we call the corresponding subset ROBDD-i, which requires that all its nodes should be associated exactly with the implicit letters as many as possible. Given a number i and a Boolean formula, we show exactly a ROBDD-i that it represents via specific variables.In addition, we show that any set of OBDD-L can be transformed into an equivalent set of ROBDD-L."}], "references": [{"title": "Knowledge compilation and theory approximation", "author": ["B. Selman", "H. Kautz"], "venue": "Journal of the Association for Computing Machinery,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1996}, {"title": "A survey on knowledge compilation", "author": ["M. Cadoli", "F. Donini"], "venue": "AI Communications,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1997}, {"title": "Decomposable negation normal form", "author": ["A. Darwiche"], "venue": "Journal of the Association for Computing Machinery,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "Knowledge Compilation Using Extension Rule", "author": ["H. Lin", "J.G. Sun"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2004}, {"title": "A knowledge compilation map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "Compilation for critically constrained knowledge bases", "author": ["R. Schrag"], "venue": "Proceedings of the Thirteenth National Conference on Artificial Intelligence,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1996}, {"title": "Knowledge compilation using theory prime implicates", "author": ["P. Marquis"], "venue": "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1995}, {"title": "Graph-based algorithms for Boolean function manipulation", "author": ["R. Bryant"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1986}, {"title": "An introduction to binary decision diagrams", "author": ["H. Andersen"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1998}, {"title": "Efficient analysis and manipulation of OBDDs can be extended to FBDDs", "author": ["J. Gergov", "C. Meinel"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1994}, {"title": "On the tractability of counting theory models and its application to truth maintenance and belief revision", "author": ["A. Darwiche"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2001}, {"title": "New compilation languages based on structured decomposability", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Extending the knowledge compilation map: Krom, Horn, Affine and Beyond", "author": ["H. Fargier", "P. Marquis"], "venue": "Proc. of AAAI'08, Menlo Park: AAAI press,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2008}, {"title": "Extending the knowledge compilation map: Closure principles", "author": ["H. Fargier", "P Marquis"], "venue": "Proceedings of the 18th European Conference on Artificial Intelligence, Amsterdam: IOS press,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Model Checking", "author": ["E. Clarke", "O. Grumberg", "D. Peled"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2000}, {"title": "Conformant planning via symbolic model checking", "author": ["A. Cimatti", "M. Roveri"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2000}, {"title": "Terminological reasoning in SHIQ with ordered binary decision diagrams", "author": ["S. Rudolph", "M. Kr\u00f6tzsch", "P. Hitzler"], "venue": "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "Evaluating abductive hypotheses using an EM algorithm on BDDs", "author": ["K. Inoue", "T. Sato", "M. Ishihata", "Y. Kameya", "H. Nabeshima"], "venue": "Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2009}, {"title": "The language of search", "author": ["J. Huang", "A. Darwiche"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2007}, {"title": "Semantical and computational aspects of Horn approximations", "author": ["M. Cadoli", "F. Scarcello"], "venue": "Artificial Intelligence,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2000}, {"title": "An Extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Proceedings of 6th International Conference on Theory and Applications of Satisfiability Testing,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}, {"title": "Lingeling, Plingeling, PicoSAT and PrecoSAT at SAT Race", "author": ["A. Biere"], "venue": "Technical Report", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Extending SAT Solvers to Cryptographic Problems", "author": ["M. Soos", "K. Nohl", "C. Castelluccia"], "venue": "Proceedings of 12th International Conference on Theory and Applications of Satisfiability Testing,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2009}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the Association for Computing Machinery,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1960}, {"title": "Algorithms for propositional KB approximation", "author": ["Y. Boufkhad"], "venue": "Proceedings of the Fifteenth AAAI Conference on Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1998}, {"title": "New advances in compiling CNF to decomposable negation normal form", "author": ["A. Darwiche"], "venue": "Proceedings of Sixteenth European Conference on Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2004}, {"title": "Model counting and planning using extension rule", "author": ["Y. Lai", "D. Ouyang", "D. Cai", "S. Lu"], "venue": "Journal of Computer Research and Development,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].", "startOffset": 177, "endOffset": 182}, {"referenceID": 1, "context": "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].", "startOffset": 177, "endOffset": 182}, {"referenceID": 2, "context": "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].", "startOffset": 177, "endOffset": 182}, {"referenceID": 3, "context": "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].", "startOffset": 177, "endOffset": 182}, {"referenceID": 4, "context": "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].", "startOffset": 177, "endOffset": 182}, {"referenceID": 0, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 109, "endOffset": 115}, {"referenceID": 6, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 109, "endOffset": 115}, {"referenceID": 7, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 165, "endOffset": 171}, {"referenceID": 8, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 165, "endOffset": 171}, {"referenceID": 4, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 209, "endOffset": 216}, {"referenceID": 9, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 209, "endOffset": 216}, {"referenceID": 2, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 300, "endOffset": 311}, {"referenceID": 10, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 300, "endOffset": 311}, {"referenceID": 11, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 300, "endOffset": 311}, {"referenceID": 3, "context": "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.", "startOffset": 326, "endOffset": 333}, {"referenceID": 4, "context": "Darwiche and Marquis argue that the choice of a target language must be based on two key aspects: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime [5].", "startOffset": 235, "endOffset": 238}, {"referenceID": 11, "context": "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].", "startOffset": 69, "endOffset": 81}, {"referenceID": 12, "context": "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].", "startOffset": 69, "endOffset": 81}, {"referenceID": 13, "context": "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].", "startOffset": 69, "endOffset": 81}, {"referenceID": 4, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 256, "endOffset": 267}, {"referenceID": 11, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 256, "endOffset": 267}, {"referenceID": 14, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 343, "endOffset": 347}, {"referenceID": 15, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 361, "endOffset": 365}, {"referenceID": 16, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 387, "endOffset": 391}, {"referenceID": 17, "context": "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.", "startOffset": 444, "endOffset": 448}, {"referenceID": 2, "context": "A practical representation of NNF formula [3, 5] is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false or a literal; and each internal node is labeled with \u2227 or \u2228 and can have arbitrarily many children.", "startOffset": 42, "endOffset": 48}, {"referenceID": 4, "context": "A practical representation of NNF formula [3, 5] is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false or a literal; and each internal node is labeled with \u2227 or \u2228 and can have arbitrarily many children.", "startOffset": 42, "endOffset": 48}, {"referenceID": 7, "context": "From above Definition 1, we know that the only difference between BDD-L and BDD [8] is the implied literals.", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "First, we give the definition of Condition [3, 5], which is a useful logical operation in practical applications.", "startOffset": 43, "endOffset": 49}, {"referenceID": 4, "context": "First, we give the definition of Condition [3, 5], which is a useful logical operation in practical applications.", "startOffset": 43, "endOffset": 49}, {"referenceID": 2, "context": "Given any formula \u03c6, variable x, literal l and consistent term T, by Theorem 1 in [3], we have that: \u03c6 \u21d4 (\u03c6 | l) \u2227 l if \u03c6 \u21d2 l; \u03c6 \u21d4 \u03c6 | x if \u03c6 | x \u21d4 \u03c6 | \u00acx (we say x can be omitted in \u03c6).", "startOffset": 82, "endOffset": 85}, {"referenceID": 8, "context": "Every step in a single call (without consideration of the recursive calls) of Reduce can terminal in constant time, include the call of MK, whose running time is constant (readers are referred to [9] for the reason).", "startOffset": 196, "endOffset": 199}, {"referenceID": 4, "context": "The definition of succinctness is as follows [5]: Definition 7.", "startOffset": 45, "endOffset": 48}, {"referenceID": 4, "context": "1 in [5], and the transitivity of succinctness, we know that: Corollary 1.", "startOffset": 5, "endOffset": 8}, {"referenceID": 4, "context": "We just recall them here and readers are referred to [5] for their importance.", "startOffset": 53, "endOffset": 56}, {"referenceID": 4, "context": "7 in [5], we know that ROBDD-\u221e satisfies ME, CE and IM.", "startOffset": 5, "endOffset": 8}, {"referenceID": 2, "context": "The same situation occurs in computing the minimum cardinality [3], which is useful in model-based diagnose, we only need an extra data unit in implied literals table to pre-record the number of negative literals in implied literals set.", "startOffset": 63, "endOffset": 66}, {"referenceID": 18, "context": "We focus on top-down compilation algorithms rather than bottom-up ones for the reasons that: we do not know whether ROBDD-\u221e satisfies \u2227BC or not; a well-known problem with the bottom-up methods is that the intermediate results that arise in the process can grow so large as to make further manipulation impossible, even when the final result would have a tractable size [20] (in the extreme case when the knowledge base is unsatisfiable, the final compilation result of ROBDD-i will has only one node, but the intermediate results may be satisfiable and have many nodes).", "startOffset": 370, "endOffset": 374}, {"referenceID": 18, "context": "Particularly, we do not even need to Line 1 and Lines 4-9 if i = 0, then Build is equivalent to Algorithm 5 in [20] when the input is in CNF.", "startOffset": 111, "endOffset": 115}, {"referenceID": 0, "context": "The idea of Horn theory approximation in [1] is generating a greatest lower bound (GLB).", "startOffset": 41, "endOffset": 44}, {"referenceID": 19, "context": "However, [21] showed that this problem is at least NP[ (log )] p O n -hard.", "startOffset": 9, "endOffset": 13}, {"referenceID": 20, "context": "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.", "startOffset": 85, "endOffset": 89}, {"referenceID": 21, "context": "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.", "startOffset": 100, "endOffset": 104}, {"referenceID": 22, "context": "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.", "startOffset": 120, "endOffset": 124}, {"referenceID": 23, "context": "All these modern complete SAT solvers are based on the classic DPLL procedure [25], which employs a systematic search to find a model of the inputting CNF formula.", "startOffset": 78, "endOffset": 82}, {"referenceID": 24, "context": "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.", "startOffset": 13, "endOffset": 17}, {"referenceID": 18, "context": "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.", "startOffset": 85, "endOffset": 89}, {"referenceID": 11, "context": "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.", "startOffset": 227, "endOffset": 231}, {"referenceID": 18, "context": "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].", "startOffset": 224, "endOffset": 235}, {"referenceID": 20, "context": "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].", "startOffset": 224, "endOffset": 235}, {"referenceID": 21, "context": "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].", "startOffset": 224, "endOffset": 235}, {"referenceID": 22, "context": "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].", "startOffset": 224, "endOffset": 235}, {"referenceID": 25, "context": "(3) CNF caching In order to save the compiling time, the function Build-inf-sub will be trying to not compiling the same CNF formula twice, we exploit the CNF caching scheme introduced in [27] to do this.", "startOffset": 188, "endOffset": 192}, {"referenceID": 18, "context": "As pointed out previously, the algorithm Build can be turned into Algorithm 5 in [20] when the input is in CNF.", "startOffset": 81, "endOffset": 85}, {"referenceID": 18, "context": "However, the experimental results in [20] show that the efficiency of Algorithm 5 is needed to be further improved.", "startOffset": 37, "endOffset": 41}, {"referenceID": 18, "context": "And we will see that this approach outperforms Algorithm 5 in [20] in the next section.", "startOffset": 62, "endOffset": 66}, {"referenceID": 26, "context": "So we also implement a DPLL-based SAT solver based on the one used in [13, 28], in which we exploit some techniques including two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, variable ordering heuristics VSIDS.", "startOffset": 70, "endOffset": 78}, {"referenceID": 24, "context": "We compare BDDjLu against a d-DNNF compiler called c2d [26].", "startOffset": 55, "endOffset": 59}, {"referenceID": 18, "context": "It seems that a ROBDD compiler and a FBDD compiler were implemented by Huang and Darwiche in [20].", "startOffset": 93, "endOffset": 97}, {"referenceID": 18, "context": "Compared with the experimental results in [20], the FBDD generated by Inf2FBDD is obviously smaller for flat200-* and uf200-*.", "startOffset": 42, "endOffset": 46}, {"referenceID": 18, "context": "flat200-2, flat200-3 and uf200-* can be compiled by transforming the corresponding ROBDD-\u221e into ROBDD now, while the ROBDD compiler reported in [20] cannot compile them in 900s with a 2.", "startOffset": 144, "endOffset": 148}, {"referenceID": 18, "context": "Compared with the compilers reported in [20], it seems that Inf2FBDD and Inf2ROBDD are two good alternatives to compile CNF formulas into FBDDs and ROBDDs, respectively.", "startOffset": 40, "endOffset": 44}], "year": 2011, "abstractText": "Knowledge compilation is an approach to tackle the computational intractability of general reasoning problems. According to this approach, knowledge bases are converted off-line into a target compilation language which is tractable for on-line querying. Reduced ordered binary decision diagram (ROBDD) is one of the most influential target languages. We generalize ROBDD by associating some implied literals in each node and the new language is called reduced ordered binary decision diagram with implied literals (ROBDD-L). Then we discuss a kind of subsets of ROBDD-L called ROBDD-i with precisely i implied literals (0 \u2264 i \u2264 \u221e). In particular, ROBDD-0 is isomorphic to ROBDD; ROBDD-\u221e requires that each node should be associated by the implied literals as many as possible. We show that ROBDD-i has uniqueness over some specific variables order, and ROBDD-\u221e is the most succinct subset in ROBDD-L and can meet most of the querying requirements involved in the knowledge compilation map. Finally, we propose an ROBDD-i compilation algorithm for any i and a ROBDD-\u221e compilation algorithm. Based on them, we implement a ROBDD-L package called BDDjLu and then get some conclusions from preliminary experimental results: ROBDD-\u221e is obviously smaller than ROBDD for all benchmarks; ROBDD-\u221e is smaller than the d-DNNF the benchmarks whose compilation results are relatively small; it seems that it is better to transform ROBDDs-\u221e into FBDDs and ROBDDs rather than straight compile the benchmarks.", "creator": "Acrobat PDFMaker 7.0 for Word"}}}