{"id": "1103.4558", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2011", "title": "Representing First-Order Causal Theories by Logic Programs", "abstract": "Nonmonotonic causal logic, introduced by Norman McCain and Hudson Turner, became a basis for the semantics of several expressive action languages. McCain's embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.", "histories": [["v1", "Wed, 23 Mar 2011 15:48:44 GMT  (46kb)", "http://arxiv.org/abs/1103.4558v1", "29 pages. To appear in Theory and Practice of Logic Programming (TPLP); Theory and Practice of Logic Programming, May, 2011"]], "COMMENTS": "29 pages. To appear in Theory and Practice of Logic Programming (TPLP); Theory and Practice of Logic Programming, May, 2011", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["paolo ferraris", "joohyung lee", "yuliya lierler", "vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1103.4558"}, "pdf": {"name": "1103.4558.pdf", "metadata": {"source": "CRF", "title": "Representing First-Order Causal Theories by Logic Programs", "authors": ["Paolo Ferraris", "Joohyung Lee", "Yuliya Lierler", "Fangkai Yang"], "emails": ["otto@cs.utexas.edu)", "joolee@asu.edu)", "yuliya@cs.utexas.edu)", "vl@cs.utexas.edu)", "fkyang@cs.utexas.edu)"], "sections": [{"heading": null, "text": "ar Xiv: 1a Basis for the semantics of several expressive action languages. McCain's embedding of unambiguous causal theories in logic programming paved the way for the use of solvers for answer sentences to answer questions about actions described in such languages. In this paper, we extend this embedding to undefined theories and first-order causal allology. KEYWORDS: Argumentation about actions, non-monotonous causal logic, answer-set programming"}, {"heading": "1 Introduction", "text": "This is an essential basis for the semantics of several meaningful storylines (Giunchiglia and Lifschitz).The Causal Calculator (Causa) 1 is a partial argumentation of the problems, including the problems of non-trivial size (Akman et al. 2004), which allows us to automate some types of reasoning and planning in action domains described in such languages. It has been used to solve several common sense arguments, including the problems of non-trivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009) to give executable specifications of the computing societies."}, {"heading": "2 McCain\u2019s Translation Revisited", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Incorporating Constraints", "text": "In causal logic, a limitation is a rule with the head. McCain's translation can easily be extended to limitations with a connection of words in the body - causal rules of the form that accompanies the head (falsehood). McCain's translation can easily be extended to limitations with a connection of words in the body - causal rules of the form that accompanies the head (falsehood). \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 Am + 1, \u00b7 \u00b7 \u00b7 An \u00b7 (6) In the language of logical programming, (6) can be represented by a rule similar to the rule that is translated with (3): \"not am, not am, not am, not am, not + 1,..., not an \u00b7 (7) Furthermore, any of the combinations not contained in (7) can be dropped without destroying the validity of the translation; that is, the rule that A1,... not am, not am, not + 1,..., not in place of (8) (7) can be used."}, {"heading": "2.2 Eliminating Strong Negation", "text": "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms. Name the new atom that represents a negative literal \"A\" by \"A.\" Then (3) becomes \"A0,\" not \"A,\" not \"A,\" not \"Am + 1,\".., not \"An\" (10) if \"L\" is a negative literal \"A0.\" McCain's modified translation of a causal theory consisting of rules of forms (2) and (6) contains \"rules\" (8) that correspond to the limitations (6) of \"T,\" rules \"(9),\" 10 \"that correspond to the other rules of\" T, \"and\" the limitations of completeness \"(A) and\" not A. \""}, {"heading": "2.3 Rules as Formulas", "text": "The definition of a stable model for expressive formulas (Ferraris 2005) and the definition of a stable model for sentences of the first order (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas. Thus, for example, rules (9) and (10) that are rewritten as expressive formulas become an \"A\" formula (14) rule (8) -Am + 1 \"\u00b7 \u00b7 To\" A0 \"(13) and\" A \"-1\" instance \"instance\" \u00b7 \u00b7 \u00b7 \u00b7 To \"A\" -0 \"-1\" rule \"\u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 One\" Am + 1 instance \"\u00b7 \u00b7 \u00b7 One\" instance \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 One \"instance \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7\" -1 \"rule.\""}, {"heading": "2.4 Translating Arbitrary Definite Theories", "text": "The requirement in the definition of McCain's translation that the bodies of all causal rules should be conjunctions of words can be overturned by slight modification of the translation process. Let's take any set of T causal rules of formulas A-G, (19) A-G, (20) G-G, (21) where A is an atom and G is an arbitrary statement formula (rules of these forms are defined as). Let's take for each rule (19) the formula G-A; for each rule (20) the formula G-A-A; for each rule (21) the formula G. Then add completeness constraints (17) for all atoms A. Answer sentences of this collection of statement formulas correspond to the models of T-A. Applied to example (1), this modification of McCap's translation corresponds to the formulas two Euro-Euro-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-g-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-"}, {"heading": "3 Review: First-Order Causal Theories", "text": "According to (Lifschitz 1997) the causal theory of the first order T is defined by (a list p of different predicate constants, 4 called the explainable symbols of T, 5 and \u2022 a finite series of causal formulas of the form F-G, where F and G stand for the list of all these variables. By T-Prop we denote the conjunction of the causal theories of the first order x-proportions x. (G-Prop) for all rules F-Proceptvariable formula of T, where x is the list of all free variables of F-G. (The expression Fp denotes the result of the substitution of the variable p for the corresponding constants p in F.) We consider T as an abbreviation and for the proposition."}, {"heading": "4 Review: Stable Models", "text": "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectors are treated as primitives and which are considered abbreviations. (F) In this paper, we take the view that the former first-order connectors are formed with a greater number of propositional connectors if they have the shape of the connectors (F) and do not have quantifiers. (F) On the other hand, stable models are defined only for sentences of a special syntactic form. (F) and have no occurrences other than those explicitly shown.8 If a sentence F contains no implication, we will identify it with the rule."}, {"heading": "5 Turning a Causal Theory into a Logic Program", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.1 Four Types of Causal Rules", "text": "In the rest of the work, we assume that the bodies of causal rules do not contain any implications. \u00b7 However, this is not a major limitation, because in classical logic we can express ourselves in terms of other connectives, and the meaning of a causal rule does not change if we replace its body (or head) with a classically equivalent formulae.Here are four types of rules that we will consider in order to increase the complexity of their heads. \u2022 The head has the form L1, that is, the rule is a limitation. Such causal rules are also called C rules. \u2022 The head is a literal one that contains an explainable predicate symbol. \u2022 The head has the form L1, where each Li contains an explainable predicate symbol. These are synonymity rules, or S rules. \u2022 The head contains an explainable predicate symbol that contains an explainable predicate sign. \u2022 The head has an explainable predicate sign of L1, which contains the form L1."}, {"heading": "5.2 Translating C-Rules and L-Rules", "text": "The transformation described in this section generalizes McCains translation in the form described in section 2.4. (...) The transformation described in this section is equivalent to the form described in section 2.4. (...) The transformation (...) which transforms any L rule into a program rule (...), is in the form of formulas p (...) x x x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x"}, {"heading": "5.3 Translating S-Rules", "text": "We now turn to the translation of synonymity rules (Section 5.1). The Trs operator, which converts such a rule into a logic program, is defined by the formulas \"Trs\" [p1 (t 1), \"p2\" (t2), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (t2), \"p\" (t2), \"p\" (t2), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (t1), \"p\" (2), \"t1,\" t1, \"t1,\" t1, \"t1,\" t1, \"t1,\" t1, \"t1,\" (t1), \"t1,\" t1, \"t1,\" t1, \"t1,\" t1, \"t1,\" t1, \"t1,\" t1, \"(t1),\" t1, \"(t1),\" t1, \"t1,\" (t1, \"(t1),\" t1, \"(t1),\" (t1, \"(t1),\" (t1), \"t1,\" (t1, \"(t1),\" (t1), \"t1,\" (t1, \"(t1),\" (t1, \"(t1),\" (t1), \"(t1),\" t1, \"(t1),\" (t1, \"(t1),\" (t1), \"(t1,\" (t1), \"(t1,\" (t1), \"(t1,\" (t1), \"(t1),\" (t1, \"(t1),\" (t1), \"(t1),\" (t1, \"(t1),\" (t1), \"(t1),\" (t1), \"(t1),\" (t1), \""}, {"heading": "5.4 Translating D-Rules", "text": "A D rule (Section 5.1) has the form of a P (t) for some sentences Pos, Neg of atomic formulas, where p (p) p and t are a tuple of terms, then we will use A (a) to denote the formula p (t). The operator Trd transforms the D rule (38) into the program rule P (t), where p (A) p and t are a tuple of terms, then we will use A (A) Neg (A) to denote the formula P (t). The operator Trd transforms the D rule (38) into the program rule P (A) Pos (A)."}, {"heading": "6 Using Answer Set Solvers to Generate Models of a Causal Theory", "text": "The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\" The answer to this question is, \"I don't think there will be a solution.\""}, {"heading": "7 Proof of Soundness", "text": "In order to prove claim (40), which expresses the soundness of our translation, we will first determine it for the case where C = L = S = \u2205 (section 7.1). In this \"leading special case,\" all the rules of the given causal theory are D rules, and they are converted into program rules using the translation Trd. Afterwards, we will derive the proposition of correctness in full generality (section 7.2)."}, {"heading": "7.1 Leading Special Case", "text": "Let T be a finite set of causal rules of form (38). Let T be the conjunction of the corresponding program rules (39) and let CC stand for the conjunction of the completeness constraints (29) for all explainable symbols p of T. Let us show that SMpp-CC signs are equivalent to T-CC signs. (41) The most important steps in the proof below are Lemma 5 (one half of the equivalence) and Lemma 8 (the other half). In the explanation of the following problem \u00ac p stands for the list of predicate expressions 18 \u03bbx-p (x), where x is a list of different object variables, for all p of p. p."}, {"heading": "Proof", "text": "First of all, note that (p, p) < (p, p) (p, p) (p, p) (p, p)) (p, p) (p, p) (p, p) (p, p) (p) (p, p) (p, p)) (p, p)) (p, p) (x) (p) (p) (p) (p) (p) (x) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p)) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p) (p (p) (p) (p) (p (p) (p (p) (p (p) (p (p) (p (p) (p (p) (p (p) (p) (p (p (p) (p (p) (p (p) (p) (p (p) (p (p (p) (p (p (p) (p) (p (p) (p) (p (p (p) (p) (p) (p (p) (p) (p (p) (p (p (p) (p) (p) (p) (p) (p (p) (p) (p (p (p) (p) (p) (p) (p (p) (p) (p (p) (p) (p) (p) (p"}, {"heading": "Proof", "text": "Given that Lemma 1, (2), (3), (3), (3), (3), (4), (4), (4), (4), (5), (5), (5), (5), (5), (5), (6), (6), (7), (8), (8), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9, (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9), (9, (9), (9), (9), (9), (9), (9), (9), (9), (9"}, {"heading": "Proof", "text": "Each occurrence of an intensive predicate in CC falls within the scope of application of a negation. Consequently, SMpp-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A"}, {"heading": "Proof", "text": "Formula T \u2020 (b) The conjunction of formulas (a) (a) (b) (c) (a) (c) (c) (c) (a) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (a) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c)) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) (c) ("}, {"heading": "Proof", "text": "Remember that according to Lemma 3, the first conjunctive term is equivalent to T \u2020 (p). From the other two terms, we conclude that this formula is equivalent to \"p\" (((p, p) < (p, p) < (p, p)) < (1) \u00b7 By \"Lemma 2\" and \"Lemma 4,\" this formula is equivalent to \"p\" ((p, p) < (p, p) < (p, p) and consequently to \"p\" (T) ((p, p)) \u00b7 The combination of the last formula with \"p\" (p) is equivalent to \"24).\" For each formula F, we denote \"f\" (p), \"p\" (p), \"p\" (p), \"p\" (p), \"p\" (p), p \"p\" (p), p \"p\" (p), p \"(p), p\" (p)."}, {"heading": "Proof", "text": "Formula (2) is tantamount to p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p-p"}, {"heading": "Proof", "text": "Remember that T \u2020 (\u03c5p) is the conjunction of implications (46) for all rules (38) in T. Consequently, T \u2020 (\u03c5p) \"2\" is the conjunction of the formulas that T \u00b2 obj (((\u03c5p, \u03c5p)."}, {"heading": "Proof", "text": "Remember that T is equivalent to the first conjunctive term, T to the second conjunctive term of (55) \u00b7 (55) Since the first conjunctive is equivalent to the second, T is equivalent to the second conjunctive term of (55) \u00b7 (56) \u00b7 From the second conjunctive term of (55) we conclude that this is equivalent to the second and consequently equivalent to the third (2) (3) ((3) (3) (3) (3) (4) (4) (4) (4) (4) (4) (4) (4) (5) (5) (5) (5) (5) (5)."}, {"heading": "Proof", "text": "If R is a G, then Trc [R] is a G and Trd [R] is a G (G). Lemma 10 For each L rule R, the conjunction CC of completeness constraints intuitively means Trl [R] \u2194 Trd [R] \u00b7"}, {"heading": "Proof", "text": "If R is p (t) and G, then Trl [R] is equivalent to \"p (t)\" and Trd [R] is equivalent to \"p (t)\" \"p (t)\" \"p (t).\" \u00b7 Since CC intuitively means \"p (t),\" it is sufficient to check whether p (t) from (57) and p (t) \"p (t)\" (t) \"p (t)\" (58) can be derived by the deductive means of intuitionist propositional logic. Since (58) in classical propositional logic p (t) is equivalent to \"p (t), it is easy to see that p (t) can be derived from (57) and (58) in classical propositional logic p (58)."}, {"heading": "Proof", "text": "In fact, it is that we are able to assert ourselves, that we are able, that we are able to achieve our objectives."}, {"heading": "8 Conclusion", "text": "In this paper, we have generalized McCain's embedding of certain causal theories in logical programming. We expect this work to provide a theoretical basis for extending the system koala to more expressive action languages, including the modular action language MAD (Ren 2009). From this perspective, it is critical that our translation is applicable to synonymity rules, since such rules are closely related to the most important new feature of MAD, its import construct. However, our translation is not applicable to causal rules with quantifiers in mind. It may be possible to extend it to positive occurrences of existential quantifiers, since an existentially quantified formula can be conceived as an infinite separation, but translation would be a formula with positive occurrences of existential quantifiers, and it is not clear how to translate such a formula into executable codifiers."}, {"heading": "Acknowledgements", "text": "We are grateful to the anonymous arbitrators for their useful comments. Joohyung Lee was partially supported by the National Science Foundation under the grant IIS-0916116 and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), supported by the US Army. Yuliya Lierler was supported by a Computing Innovation Fellowship in 2010. Vladimir Lifschitz and Fangkai Yang were supported by the National Science Foundation under the grant IIS0712113. Any factual statements, opinions or conclusions contained therein are those of the authors and should not be construed to represent the official views or guidelines of IARPA, the ODNI or the US government."}], "references": [{"title": "Representing the Zoo World and the Traffic World in the language of the Causal Calculator", "author": ["V. Akman", "S. Erdo\u011fan", "J. Lee", "V. Lifschitz", "H. Turner"], "venue": "Artificial Intelligence 153(1\u20132), 105\u2013140.", "citeRegEx": "Akman et al\\.,? 2004", "shortCiteRegEx": "Akman et al\\.", "year": 2004}, {"title": "Formal specification and automatic analysis of business processes under authorization constraints: an actionbased approach", "author": ["A. Armando", "E. Giunchiglia", "S.E. Ponta"], "venue": "Proceedings of the 6th International Conference on Trust, Privacy and Security in Digital Business (TrustBus\u201909).", "citeRegEx": "Armando et al\\.,? 2009", "shortCiteRegEx": "Armando et al\\.", "year": 2009}, {"title": "Specifying norm-governed computational societies", "author": ["A. Artikis", "M. Sergot", "J. Pitt"], "venue": "ACM Transactions on Computational Logic 9, 1.", "citeRegEx": "Artikis et al\\.,? 2009", "shortCiteRegEx": "Artikis et al\\.", "year": 2009}, {"title": "Bridging the gap between high-level reasoning and low-level control", "author": ["O. Caldiran", "K. Haspalamutgil", "A. Ok", "C. Palaz", "E. Erdem", "V. Patoglu"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 242\u2013354. Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,", "citeRegEx": "Caldiran et al\\.,? 2009", "shortCiteRegEx": "Caldiran et al\\.", "year": 2009}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 119\u2013131. Ferraris, P. 2006. Causal theories as logic programs. In Proceedings of Workshop on Logic Programming (WLP). 35\u201344. Ferraris, P. 2007. A logic program characterization of causal theories. In Proceedings", "citeRegEx": "Ferraris,? 2005", "shortCiteRegEx": "Ferraris", "year": 2005}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175, 236\u2013263.", "citeRegEx": "Ferraris et al\\.,? 2011", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 797\u2013803.", "citeRegEx": "Ferraris et al\\.,? 2009", "shortCiteRegEx": "Ferraris et al\\.", "year": 2009}, {"title": "Coala: a compiler from action languages to ASP", "author": ["M. Gebser", "T. Grote", "T. Schaub"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA). 169\u2013181.", "citeRegEx": "Gebser et al\\.,? 2010", "shortCiteRegEx": "Gebser et al\\.", "year": 2010}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Nonmonotonic causal theories", "author": ["E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner"], "venue": "Artificial Intelligence 153(1\u20132), 49\u2013104.", "citeRegEx": "Giunchiglia et al\\.,? 2004", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2004}, {"title": "An action language based on causal explanation: Preliminary report", "author": ["E. Giunchiglia", "V. Lifschitz"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). AAAI Press, 623\u2013630. Glivenko, V. 1929. Sur quelques points de la logique de M. Brouwer. Acad\u00e9mie Royale de Belgique. Bulletins de la Classe des Sciences, se\u2019rie 5 15, 183\u2013188.", "citeRegEx": "Giunchiglia and Lifschitz,? 1998", "shortCiteRegEx": "Giunchiglia and Lifschitz", "year": 1998}, {"title": "Representing synonymity in causal logic and in logic programming", "author": ["J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang"], "venue": "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).", "citeRegEx": "Lee et al\\.,? 2010", "shortCiteRegEx": "Lee et al\\.", "year": 2010}, {"title": "System F2LP \u2014 computing answer sets of first-order formulas", "author": ["J. Lee", "R. Palla"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 515\u2013521. Lifschitz, V. 1985. Computing circumscription. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 121\u2013127.", "citeRegEx": "Lee and Palla,? 2009", "shortCiteRegEx": "Lee and Palla", "year": 2009}, {"title": "Circumscription", "author": ["V. Lifschitz"], "venue": "Handbook of Logic in AI and Logic Programming, D. Gabbay, C. Hogger, and J. Robinson, Eds. Vol. 3. Oxford University Press, 298\u2013352.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "On the logic of causal explanation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence 96, 451\u2013465. Lifschitz, V. 2008. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence. MIT Press, 1594\u20131597. Lifschitz, V. and Ren, W. 2006. A modular action description language. In Proceedings of National Conference on Artificial Intelligence (AAAI). 853\u2013859.", "citeRegEx": "Lifschitz,? 1997", "shortCiteRegEx": "Lifschitz", "year": 1997}, {"title": "The semantics of variables in action descriptions", "author": ["V. Lifschitz", "W. Ren"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). 1025\u20131030.", "citeRegEx": "Lifschitz and Ren,? 2007", "shortCiteRegEx": "Lifschitz and Ren", "year": 2007}, {"title": "Translating first-order causal theories into answer set programming", "author": ["V. Lifschitz", "F. Yang"], "venue": "Proceedings of the European Conference on Logics in Artificial Intelligence (JELIA). 247\u2013259.", "citeRegEx": "Lifschitz and Yang,? 2010", "shortCiteRegEx": "Lifschitz and Yang", "year": 2010}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013398. McCain, N. 1997. Causality in commonsense reasoning about actions. Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1999", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Causal theories of action and change", "author": ["N. McCain", "H. Turner"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). 460\u2013465.", "citeRegEx": "McCain and Turner,? 1997", "shortCiteRegEx": "McCain and Turner", "year": 1997}, {"title": "Applications of circumscription to formalizing common sense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence 26, 3, 89\u2013116. Mints, G. 2000. A Short Introduction to Intuitionistic Logic. Kluwer.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273. Ren, W. 2009. A modular language for describing actions . Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia", "author": ["M. Shanahan"], "venue": "MIT Press.", "citeRegEx": "Shanahan,? 1997", "shortCiteRegEx": "Shanahan", "year": 1997}], "referenceMentions": [{"referenceID": 19, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al.", "startOffset": 40, "endOffset": 64}, {"referenceID": 11, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 10, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 16, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 0, "context": "It has been used to solve several challenging commonsense reasoning problems, including problems of nontrivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al.", "startOffset": 116, "endOffset": 135}, {"referenceID": 3, "context": "2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed computational societies (Artikis et al.", "startOffset": 62, "endOffset": 84}, {"referenceID": 2, "context": "2009), to give executable specifications of norm-governed computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al.", "startOffset": 82, "endOffset": 103}, {"referenceID": 1, "context": "2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).", "startOffset": 90, "endOffset": 111}, {"referenceID": 9, "context": "7) shows how to embed a fragment of propositional causal logic into the language of logic programming under the answer set semantics (Gelfond and Lifschitz 1991).", "startOffset": 133, "endOffset": 161}, {"referenceID": 7, "context": "This result, reviewed below, paved the way to the development of an attractive alternative to CCalc\u2014the software system coala (Gebser et al. 2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 126, "endOffset": 146}, {"referenceID": 18, "context": "2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 39, "endOffset": 98}, {"referenceID": 21, "context": "2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 39, "endOffset": 98}, {"referenceID": 19, "context": "A causal theory in the sense of (McCain and Turner 1997) is a set of \u201ccausal rules\u201d of the form F \u21d0 G, where F and G are propositional formulas (the head and the body of the rule).", "startOffset": 32, "endOffset": 56}, {"referenceID": 19, "context": "has one model, according to the semantics from (McCain and Turner 1997).", "startOffset": 47, "endOffset": 71}, {"referenceID": 15, "context": "If, for instance, G in (5) is a literal then the following group of nondisjunctive rules will do: L1 \u2190 L2, not G L2 \u2190 L1, not G L1 \u2190 L2, not G L2 \u2190 L1, not G \u00b7 Finally, we extend the translation from propositional causal rules to first-order causal rules in the sense of (Lifschitz 1997).", "startOffset": 271, "endOffset": 287}, {"referenceID": 16, "context": "This version of causal logic is useful for defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).", "startOffset": 102, "endOffset": 126}, {"referenceID": 12, "context": "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).", "startOffset": 50, "endOffset": 122}, {"referenceID": 17, "context": "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).", "startOffset": 50, "endOffset": 122}, {"referenceID": 9, "context": "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms.", "startOffset": 15, "endOffset": 43}, {"referenceID": 4, "context": "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al.", "startOffset": 69, "endOffset": 84}, {"referenceID": 5, "context": "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.", "startOffset": 160, "endOffset": 182}, {"referenceID": 8, "context": "2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.", "startOffset": 56, "endOffset": 84}, {"referenceID": 8, "context": "2 The term \u201cstable model\u201d was introduced in (Gelfond and Lifschitz 1988) to describe the meaning of logic programs with negation as failure but without strong negation.", "startOffset": 44, "endOffset": 72}, {"referenceID": 9, "context": "When the stable model semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the term \u201canswer set\u201d was proposed as a replacement.", "startOffset": 81, "endOffset": 109}, {"referenceID": 15, "context": "According to (Lifschitz 1997), a first-order causal theory T is defined by \u2022 a list p of distinct predicate constants, called the explainable symbols of T , and \u2022 a finite set of causal rules of the form F \u21d0 G, where F and G are first-order formulas.", "startOffset": 13, "endOffset": 29}, {"referenceID": 19, "context": "4) second-order formula (24) can be replaced by an equivalent first-order formula using a process similar to Clark\u2019s completion (Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997, Section 5).", "startOffset": 168, "endOffset": 192}, {"referenceID": 15, "context": "5 To be precise, the definition in (Lifschitz 1997) is more general: object and function constants can be treated as explainable as well.", "startOffset": 35, "endOffset": 51}, {"referenceID": 5, "context": "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectives are treated as primitives, and which are viewed as abbreviations.", "startOffset": 61, "endOffset": 83}, {"referenceID": 5, "context": "The definition of a stable model below is more limited than the definition from (Ferraris et al. 2011) because it is only applicable to programs, not to arbitrary sentences.", "startOffset": 80, "endOffset": 102}, {"referenceID": 14, "context": "We need the following notation from (Lifschitz 1994).", "startOffset": 36, "endOffset": 52}, {"referenceID": 8, "context": "The original definition of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional.", "startOffset": 42, "endOffset": 70}, {"referenceID": 20, "context": "First, if we drop from the definition of SM the words \u201cthat is not in the scope of negation\u201d then it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985).", "startOffset": 159, "endOffset": 190}, {"referenceID": 5, "context": "Second, the operator of SM as defined in (Ferraris et al. 2011) produces, in application to a logic program, a second-order formula that is usually more complex than (27) but is equivalent to it.", "startOffset": 41, "endOffset": 63}, {"referenceID": 5, "context": "11 Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al. 2011).", "startOffset": 83, "endOffset": 105}, {"referenceID": 22, "context": "The second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by postulating that if the value of that fluent at time 1 is equal to its previous value then there is a cause for this.", "startOffset": 41, "endOffset": 56}, {"referenceID": 13, "context": "There exists a tool, called f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general kind into logic programs accepted by lparse.", "startOffset": 33, "endOffset": 53}, {"referenceID": 6, "context": "This can be proved using the splitting theorem from (Ferraris et al. 2009).", "startOffset": 52, "endOffset": 74}], "year": 2011, "abstractText": "Nonmonotonic causal logic, introduced by Norman McCain and Hudson Turner, became a basis for the semantics of several expressive action languages. McCain\u2019s embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}