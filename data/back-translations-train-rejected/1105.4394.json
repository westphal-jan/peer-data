{"id": "1105.4394", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-May-2011", "title": "Integrating Testing and Interactive Theorem Proving", "abstract": "Using an interactive theorem prover to reason about programs involves a sequence of interactions where the user challenges the theorem prover with conjectures. Invariably, many of the conjectures posed are in fact false, and users often spend considerable effort examining the theorem prover's output before realizing this. We present a synergistic integration of testing with theorem proving, implemented in the ACL2 Sedan (ACL2s), for automatically generating concrete counterexamples. Our method uses the full power of the theorem prover and associated libraries to simplify conjectures; this simplification can transform conjectures for which finding counterexamples is hard into conjectures where finding counterexamples is trivial. In fact, our approach even leads to better theorem proving, e.g., if testing shows that a generalization step leads to a false conjecture, we force the theorem prover to backtrack, allowing it to pursue more fruitful options that may yield a proof. The focus of the paper is on the engineering of a synergistic integration of testing with interactive theorem proving; this includes extending ACL2 with new functionality that we expect to be of general interest. We also discuss our experience in using ACL2s to teach freshman students how to reason about their programs.", "histories": [["v1", "Mon, 23 May 2011 03:05:44 GMT  (29kb)", "https://arxiv.org/abs/1105.4394v1", "16 pages; ACL2"], ["v2", "Fri, 21 Oct 2011 02:09:20 GMT  (34kb,D)", "http://arxiv.org/abs/1105.4394v2", "In Proceedings ACL2 2011,arXiv:1110.4473"]], "COMMENTS": "16 pages; ACL2", "reviews": [], "SUBJECTS": "cs.SE cs.AI cs.LO", "authors": ["harsh raju chamarthi", "peter c dillinger", "matt kaufmann", "panagiotis manolios"], "accepted": false, "id": "1105.4394"}, "pdf": {"name": "1105.4394.pdf", "metadata": {"source": "CRF", "title": "Integrating Testing and Interactive Theorem Proving", "authors": ["Harsh Raju Chamarthi", "Peter C. Dillinger", "Matt Kaufmann", "Panagiotis Manolios"], "emails": ["harshrc@ccs.neu.edu", "pcd@ccs.neu.edu", "kaufmann@cs.utexas.edu", "pete@ccs.neu.edu"], "sections": [{"heading": null, "text": "Hardin and Schmaltz (Eds): ACL2 2011 EPTCS 70, 2011, pp. 4-19, doi: 10.4204 / EPTCS.70.1Integrating Testing and Interactive Theorem ProvingHarsh Raju Chamarthi Peter C. Dillinger College of Computer and Information Science, Northeastern University harshrc @ ccs.neu.edu pcd @ ccs.neu.eduMatt Kaufmann Dept. of Computer Science, University of Texas at Austin kaufmann @ cs.utexas.eduPanagiotis Manolios College of Computer and Information Science, Northeastern University pete @ ccs.neu.eduUsing an interactive theorem prover to reason about programs includes a sequence of theorem prover with conjectures. Inevitably, many of the assumptions presented are wrong, and users often spend considerable efforts to examine the results of the theorem before they are realized."}, {"heading": "1 Introduction", "text": "This year it is more than ever before."}, {"heading": "2 Related Work", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Counterexample Generation in Interactive Theorem Provers", "text": "Random testing is a well-studied, scalable, lightweight technique for finding counterexamples to executable formulas. Random testing is widely used in the functional linguistic community, as demonstrated by the recent success of QuickCheck [8]. The community that tests theorems is also committed to random testing, for example in Isabelle / HOL [1], Agda [11], and PVS [26]. The other standard method for generating counterexamples to a conjecture is the use of a SAT or SMT solver, which requires translating a rich, expressive logic into a limited logic with limited meaningfulness. The main obstacle to such approaches is that a counterexample to the translated formula should also be a counterexample to the original formula. However, the absence of a counterexample does not imply that the conjecture is true. Some tools that use the above technique are Pythia [27], Refute [29] and NAT [28] [Checking]."}, {"heading": "2.2 Combining testing and theorem proving", "text": "One of the first compelling examples of combining testing and evidence was done using Agda [11], although the ideas for combining formal specifications (and tools) and testing date back to at least 1981. Agda uses random testing to look for counterexamples to the top-level target, and the authors point out that the user could also apply random testing to subtargets. Unlike our work, the integration of testing is not automatic. There is a lot of work on the use of formal methods to perform model-based testing, since the groundbreaking work of Dick and Faivre [9]. We limit our attention to some recent work that set theories toward this goal."}, {"heading": "3 Test Generation", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "4 Improved Random Testing with Theorem Proving", "text": "This year it is as far as it has ever been until the next round in order to pave the way to the next round."}, {"heading": "5 Improved Theorem Proving with Random Testing", "text": "In this case, it is as if it were a purely reactionary project."}, {"heading": "6 ACL2 Enhancements", "text": "This year, it has reached the point where it will be able to leave the country without being able to leave it."}, {"heading": "7 Experiences", "text": "We describe two experiences with the counter-example generation of ACL2s. One involves the use of counter-examples to teach their programs, and the other includes an example from an expert. For several years, we have had chair holders on the Northeast Coast thinking about programs. We use ACL2s and it has been an invaluable learning tool. A place where students are in written form. They have logical and conceptual errors, and they often ignore required hypotheses, so they try to prove their assumptions that the motivation for this work is to provide them with counter-examples. In this case, we succeed because our exam frameworks are easy to find. The counter-examples are wrong, which is wrong with their terms."}, {"heading": "8 Conclusions and Future Work", "text": "We identify four contributions. First, we will show how we can harness the power of an interactive theorem tester for better testing; second, we will show how we can use tests to make interactive theorems more powerful and automatic; third, we will show a series of extensions to the ACL2 theorem tester, which was developed to support this work and which we expect to be of interest to the broader interactive theorem tester community; fourth, we plan to explore more powerful algorithms for generating counter-examples; and, we plan to explore support for intersection types and more powerful methods to determine where within the partial sequence of user-defined types we will include automated data generation rules (including J); and, finally, we will identify four contributions that will help us use the power of an interactive theorem tester for better testing; and, secondly, we will show how we can use tests to make interactive theorems more powerful and automated; and, we expect them to be of interest to be of interest to the broader interactive theorem tester community."}, {"heading": "9 Acknowledgements", "text": "This research was partially funded by NASA Cooperative Agreement NNX08AE37A, DARPA Grant 10655648 and NSF Grant CCF-0429924, IIS-0417413, CCF-0438871, CNS-0910913 and CCF-0945316. Kaufmann also thanks the Texas - United Kingdom Collaborative for providing travel assistance to Cambridge, England, and the Computer Laboratory of Cambridge University for recording during the preparation of this paper."}], "references": [{"title": "Random Testing in Isabelle/HOL", "author": ["Stefan Berghofer", "Tobias Nipkow"], "venue": "SEFM, IEEE Computer Society,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Nitpick: A Counterexample Generator for Higher- Order Logic Based on a Relational Model Finder", "author": ["Jasmin Christian Blanchette", "Tobias Nipkow"], "venue": "editors: ITP, Lecture Notes in Computer Science 6172,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "A Computational Logic", "author": ["R.S. Boyer", "J S. Moore"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1979}, {"title": "Symbolic Test Case Generation for Primitive Recursive Functions", "author": ["Achim D. Brucker", "Burkhart Wolff"], "venue": "editors: FATES, Lecture Notes in Computer Science", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2004}, {"title": "Functional Testing in the Focal Environment", "author": ["Matthieu Carlier", "Catherine Dubois"], "venue": "editors: TAP, Lecture Notes in Computer Science", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Formal Program Testing", "author": ["Robert Cartwright"], "venue": "POPL, pp. 125\u2013132. Available at http://doi", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1981}, {"title": "QuickCheck: a lightweight tool for random testing of Haskell programs", "author": ["Koen Claessen", "John Hughes"], "venue": "In: ICFP,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2000}, {"title": "Automating the Generation and Sequencing of Test Cases from Model- Based Specifications", "author": ["Jeremy Dick", "Alain Faivre"], "venue": "editors: FME, Lecture Notes in Computer Science", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1993}, {"title": "ACL2s: \u201dThe ACL2 Sedan", "author": ["Peter C. Dillinger", "Panagiotis Manolios", "Daron Vroon", "J. Strother Moore"], "venue": "Electr. Notes Theor. Comput. Sci", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2007}, {"title": "Combining Testing and Proving in Dependent Type Theory", "author": ["Peter Dybjer", "Qiao Haiyan", "Makoto Takeyama"], "venue": "editors: TPHOLs, Lecture Notes in Computer Science", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "Backtracking and Induction in ACL2", "author": ["John D. Erickson"], "venue": "Seventh International Workshop on the ACL2 Theorem prover and its Applications", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Using ACL2 Arrays to Formalize Matrix Algebra. In: Fourth International Workshop on the ACL2 Theorem Prover and Its Applications (ACL2 \u201903)", "author": ["Ruben Gamboa", "John Cowles", "Jeff Van Baalen"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2003}, {"title": "Testing Can Be Formal, Too", "author": ["Marie-Claude Gaudel"], "venue": "editors: TAPSOFT, Lecture Notes in Computer Science", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1995}, {"title": "A SAT-based procedure for verifying finite state machines in ACL2", "author": ["Warren A. Hunt Jr.", "Erik Reeber"], "venue": "editors: ACL2,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2006}, {"title": "Computer-Aided Reasoning: An Approach", "author": ["Matt Kaufmann", "Panagiotis Manolios", "J Strother Moore"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2000}, {"title": "Verification of executable pipelined machines with bit-level interfaces", "author": ["Panagiotis Manolios", "Sudarshan K. Srinivasan"], "venue": "ICCAD, IEEE Computer Society,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2005}, {"title": "A Framework for Verifying Bit-Level Pipelined Machines Based on Automated Deduction and Decision Procedures", "author": ["Panagiotis Manolios", "Sudarshan K. Srinivasan"], "venue": "J. Autom. Reasoning", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2006}, {"title": "Termination Analysis with Calling Context Graphs", "author": ["Panagiotis Manolios", "Daron Vroon"], "venue": "CAV, Lecture Notes in Computer Science", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2006}, {"title": "Automatic generation of counterexamples for ACL2 using Alloy", "author": ["Alexander Spiridonov", "Sarfraz Khurshid"], "venue": "Seventh International Workshop on the ACL2 Theorem prover and its Applications", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2007}, {"title": "Checking ACL2 Theorems via SAT Checking", "author": ["Rob Sumners"], "venue": "Third International Workshop on the ACL2 Theorem Prover and its Applications", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2002}, {"title": "SAT-Based Finite Model Generation for Higher-Order Logic", "author": ["T. Weber"], "venue": "Ph.D. thesis, Dept. of Informatics, T.U.Mu\u0308nchen,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}], "referenceMentions": [{"referenceID": 8, "context": "All of our work has been implemented in ACL2s, the ACL2 Sedan [10].", "startOffset": 62, "endOffset": 66}, {"referenceID": 17, "context": "In particular, ACL2s provides a modern integrated development environment in Eclipse, supports several modes of interaction, and incorporates a powerful automated termination analysis engine [25].", "startOffset": 191, "endOffset": 195}, {"referenceID": 6, "context": "Random testing has been widely adopted in the functional language community, as seen by the recent success of QuickCheck [8].", "startOffset": 121, "endOffset": 124}, {"referenceID": 0, "context": "The theorem-proving community has also embraced random testing, for example in Isabelle/HOL [1], Agda [11] and PVS [26].", "startOffset": 92, "endOffset": 95}, {"referenceID": 9, "context": "The theorem-proving community has also embraced random testing, for example in Isabelle/HOL [1], Agda [11] and PVS [26].", "startOffset": 102, "endOffset": 106}, {"referenceID": 18, "context": "Some tools making use of the above technique are Pythia [27], SAT Checking [28], Refute [29] and Nitpick [2].", "startOffset": 56, "endOffset": 60}, {"referenceID": 19, "context": "Some tools making use of the above technique are Pythia [27], SAT Checking [28], Refute [29] and Nitpick [2].", "startOffset": 75, "endOffset": 79}, {"referenceID": 20, "context": "Some tools making use of the above technique are Pythia [27], SAT Checking [28], Refute [29] and Nitpick [2].", "startOffset": 88, "endOffset": 92}, {"referenceID": 1, "context": "Some tools making use of the above technique are Pythia [27], SAT Checking [28], Refute [29] and Nitpick [2].", "startOffset": 105, "endOffset": 108}, {"referenceID": 15, "context": "Another line of work translates to SAT or other decidable fragments of first order logic for which efficient decision procedures exist, but only when the original conjecture is in fact expressible in the decidable fragment [23, 24, 15].", "startOffset": 223, "endOffset": 235}, {"referenceID": 16, "context": "Another line of work translates to SAT or other decidable fragments of first order logic for which efficient decision procedures exist, but only when the original conjecture is in fact expressible in the decidable fragment [23, 24, 15].", "startOffset": 223, "endOffset": 235}, {"referenceID": 13, "context": "Another line of work translates to SAT or other decidable fragments of first order logic for which efficient decision procedures exist, but only when the original conjecture is in fact expressible in the decidable fragment [23, 24, 15].", "startOffset": 223, "endOffset": 235}, {"referenceID": 9, "context": "One of the first convincing examples of combining testing and proving was carried out using Agda [11], although the ideas for combining formal specifications (and tools) and testing date back to at least", "startOffset": 97, "endOffset": 101}, {"referenceID": 5, "context": "1981 [6].", "startOffset": 5, "endOffset": 8}, {"referenceID": 7, "context": "There has been a lot of work on employing formal methods technology to perform model-based testing since the seminal work of Dick and Faivre [9].", "startOffset": 141, "endOffset": 144}, {"referenceID": 3, "context": "In the tool HOL-TESTGEN [4], specifications are analyzed symbolically (unfolding definitions) using Isabelle/HOL to derive formulas in conjunctive normal form.", "startOffset": 24, "endOffset": 27}, {"referenceID": 12, "context": "To handle recursion, a uniformity hypothesis [14] is used to bound the number of unfoldings.", "startOffset": 45, "endOffset": 49}, {"referenceID": 4, "context": "A similar tool with less focus on user interaction is FocalTest [5].", "startOffset": 64, "endOffset": 67}, {"referenceID": 10, "context": "In [12], Erickson describes an extension to ACL2 allowing it to backtrack from a failed proof to alternative proof strategies.", "startOffset": 3, "endOffset": 7}, {"referenceID": 7, "context": "Often type restrictions are more complex than datatype hypotheses; we consider a variation of another classic example [9] below.", "startOffset": 118, "endOffset": 121}, {"referenceID": 2, "context": "This organization is called the waterfall [3, 16, 21].", "startOffset": 42, "endOffset": 53}, {"referenceID": 14, "context": "This organization is called the waterfall [3, 16, 21].", "startOffset": 42, "endOffset": 53}, {"referenceID": 14, "context": "Instead, we test checkpoints, subgoals that users of ACL2 are encouraged to examine when their proof fails [16].", "startOffset": 107, "endOffset": 111}, {"referenceID": 11, "context": "In particular, as an example, consider the following lemma6 proved as part of an effort to formalize matrix algebra in ACL2 [13]:", "startOffset": 124, "endOffset": 128}], "year": 2011, "abstractText": "Using an interactive theorem prover to reason about programs involves a sequence of interactions where the user challenges the theorem prover with conjectures. Invariably, many of the conjectures posed are in fact false, and users often spend considerable effort examining the theorem prover\u2019s output before realizing this. We present a synergistic integration of testing with theorem proving, implemented in the ACL2 Sedan (ACL2s), for automatically generating concrete counterexamples. Our method uses the full power of the theorem prover and associated libraries to simplify conjectures; this simplification can transform conjectures for which finding counterexamples is hard into conjectures where finding counterexamples is trivial. In fact, our approach even leads to better theorem proving, e.g., if testing shows that a generalization step leads to a false conjecture, we force the theorem prover to backtrack, allowing it to pursue more fruitful options that may yield a proof. The focus of the paper is on the engineering of a synergistic integration of testing with interactive theorem proving; this includes extending ACL2 with new functionality that we expect to be of general interest. We also discuss our experience in using ACL2s to teach freshman students how to reason about their programs.", "creator": "LaTeX with hyperref package"}}}