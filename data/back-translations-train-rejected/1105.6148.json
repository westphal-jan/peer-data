{"id": "1105.6148", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-May-2011", "title": "Overcoming Misleads In Logic Programs by Redefining Negation", "abstract": "Negation as failure and incomplete information in logic programs have been studied by many researchers In order to explains HOW a negated conclusion was reached, we introduce and proof a different way for negating facts to overcoming misleads in logic programs. Negating facts can be achieved by asking the user for constants that do not appear elsewhere in the knowledge base.", "histories": [["v1", "Tue, 31 May 2011 02:19:21 GMT  (154kb)", "http://arxiv.org/abs/1105.6148v1", "8 pages, 1 figure"], ["v2", "Mon, 4 Mar 2013 23:40:11 GMT  (188kb)", "http://arxiv.org/abs/1105.6148v2", "8 pages, 1 figure"]], "COMMENTS": "8 pages, 1 figure", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["m a el-dosuky", "t t hamza", "m z rashad", "a h naguib"], "accepted": false, "id": "1105.6148"}, "pdf": {"name": "1105.6148.pdf", "metadata": {"source": "CRF", "title": "Overcoming Misleads In Logic Programs by Redefining Negation", "authors": ["M. A. El-Dosuky", "T. T. Hamza", "M. Z. Rashad", "A. H. Naguib"], "emails": ["mouh_sal_010@mans.edu.eg"], "sections": [{"heading": null, "text": "Overcoming Misconceptions in Logic Programs by Redefining Negation M. A. El-Dosuky a, T. T. Hamza a, M. Z. Rashad a and A. H. Naguib ba Faculty of Computer and Information Sciences, Mansoura University, Egypt Email: mouh _ sal _ 010 @ mans.edu.egb Faculty of Sciences, Mansoura University, EgyptKeywords: Logic Programming, Negation as Failure, Incomplete Information, Justification"}, {"heading": "1. Introduction", "text": "Negation as failure and incomplete information in logic programs has been studied by many researchers, mainly because of its role in the fundamentals of declarative reading of logic programs. This paper provides an overview of some of the definitions of the concepts related to declarative reading of logic programs. Then, the paper provides a framework for overcoming misconceptions and solving a misleading case study. The essay begins by reviewing the relevant work of contributions to logic programming, highlighting many concepts such as negation as failure, closed world assumption, incomplete information and its consequences (Section 2). Then, we comment on the standard definitions of relevant logic programming concepts such as: compound terms, substitution, common instance, facts, rules, reduction, quantification of variables, unification, most general unifications (MGU), calculation and structured data (Section 3). Then, briefly, we discuss the semantics of general logic programming according to the logic program's many characteristics."}, {"heading": "2. Related work", "text": "In fact, the fact is that most people who are able to move are able to move, to move and to move, to move, to move, to move, to move and to move, to move, to move and to move, to move, to move and to move, to move and to move, to move, to move and to move, to move, to move and to move, to move and to move, to move and to move, to move and to move, to move and to move, to move and to move, to move and to move, to move, to move, to move and to move."}, {"heading": "3. Preliminaries", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Definition: Facts", "text": "A relationship between objects is called predicate. A relationship is summarized in a simple phrase called fact and consists of the relationship name, followed by the object or objects (in parentheses). Facts end with a period (.). Facts can also express properties of objects as well as relationships, depending on their nature. Examples: A relationship: Jack likes Sarah (Jack, sarah) A property: Kermit is green (kermit)."}, {"heading": "Definition: Rules", "text": "A rule consists of two parts Head and Body Head < Sub-Goal 1 >, < Sub-Goal 2 >,..., < Sub-Goal N > The rule body consists of one or more sub-targets."}, {"heading": "Definition: Compound terms", "text": "Composite terms have the form: f (t1, t2,...., tn). where f is called radio gate, ti the arguments and n the ararity. A functor looks like a fact, but is not a fact. It is only a data object that can be treated like a symbol or a number. A functor does not stand for a calculation to be performed. It is only a name that identifies a kind of composite data object and holds its arguments together. Example: Successor (zero)"}, {"heading": "Definition: Structured Data", "text": "Structured data is constructed by grouping similar arguments of a fact and giving this group a name. Facts are the counterpart of tables, while structured data correspond to data sets with combined fields. Example: A fact about a lecture on logic given on Monday, 9-11 by Prof. Jack in Victory Building, Room A, can be presented as a course (Logic, Monday, 9, 11, socket, victory, a). Using structured data, we can define this fact as a course (Logic, Time (Monday, 9, 11), Lecturer (socket), Location (Victory, a). In a logic language commonly called prologue, we can do this by explaining a domain containing the compound object date. For example, by explaining time: time _ compound = time (symbol, integer, integer), varnish. With the concept of the basic key, we can circumscribe this fact in relation to binary relationships."}, {"heading": "Definition: Substitution", "text": "Substitution is a finite set of pairs of the form Xi = ti. Where: Xi is a variable and ti is a term. Note that Xi \u0445 Xj does not occur in tj for each i-j and Xi. Example: {X = socket}"}, {"heading": "Definition: common instance", "text": "C is a common instance of A and B if there is an instance of A and an instance of B. In other words, if there are substitutions \u03b81 and \u03b82, so that C = A\u03b81 is syntactically identical to B\u03b82 Example: A = plus (0, 3, Y) \u03b81 = {Y = 3} B = plus (0, X, X) \u03b82 = {X = 3} C = plus (0, 3, 3)"}, {"heading": "Definition: Reduction", "text": "A reduction of target G by a program P is the replacement of G by the body of an instance of a sentence in P, whose head is identical to the selected target. Example: the target grandparent (Abraham, X)? Can be reduced in relation to the sentence to parent (Abraham, Y), parent (Y, X): grandparent (Z, X) parent (Z, Y), parent (Y, X). Definition: Variable quantification variables in queries are existentially quantified, while in facts are universally quantified. A query p (T1, T2,..., Tn)? containing variables X1, X2,..., Xk reads: \"Is there X1, X2,..., Xk so that p (T1, T2,..., Tn)?\" Normally, the existential quantification (T1, T2) is omitted. Example: the aberrant father (Abraham, X)? \"Is there such an example (T1, Tn is a fact)."}, {"heading": "Definition: Most General Unifier (MGU)", "text": "A unifier of two terms is a replacement that makes the terms identical. If two terms have a unifier, let's say that they unify. MGU of two terms is a unifier, so the corresponding common instance is the most general. If two terms have a unifier, all MGUs are equal."}, {"heading": "Definition: Computation", "text": "Calculation of a target Q = Q0 by a program P is a sequence of triples (Qi, Gi, Ci) where: Qi is a conjunctive target, Gi is a target occurring in Qi and Ci is a clause A B1,..., Bk in P that contains new variables that do not occur in Qj, 0 \u2264 j \u2264 i. For a detailed introductory discussion, refer to ([Sterling & Shapiro 1994] and [Bochman1998]). 4.Semantics of logic programs A logic program can have many semantic statements. Common semantics are operative, denotational and declarative. Operational semantics of logic programs is considered as a way to describe the meaning of programs procedurally. It is a set of basic goals that are instances of queries that are solved by a logic program P. The declarative semantics of logic programs are considered a way to describe the meaning of programs procedurally. It is a set of basic objectives that are instances of queries that are solved by a logic program P. The declarative semantics of logic programs are interpreted as a function that is a coalgorithm that is a basic function in the coalgorithm."}, {"heading": "4.1. Interpreting logic programs", "text": "In the following, we show the algorithm of an abstract interpreter for logic programs. It is used to construct the operative semantics of a logic program. Note that this algorithm depends on a Unify function mentioned in line 5. This function is defined by the unification algorithm. Abstract interpreter for logic programs Input: a target G and a program P Output: an instance of G, which is a logical sequence of P, or nothing else. Algorithm: 1 2 3 4 5 6 7 8 9initialize the resolver on G while the solvent is not empty. Select a target A from the solvent and select a (renamed) set A 'B1,..., Bn from Pso that A and A' merge with MGU. (If no such target and this set exists, leave the while loop). Replace A with B1,..., Bn in the solvent apply to the solvent, the G is empty, and the output is not for G."}, {"heading": "Unification algorithm", "text": "Input: two terms to be standardized T1 and T2 Output: \u0443, the MGU of T1 and T2, or failure Algorithm: 1 2 3 4 5 6 8 9 10 11 13 14 15 16 17 18 20Initialize the substitutioncase X is a variable that does not occur in Y: replace Y in the stack and in area size X = Y is a variable that does not occur in X: replace X for Y in the stack case X = Y is a variable: continue X is f (X1,..., Xn) and Y is add X = Y in area size Y is a variable that does not occur in X: replace X for Y in area size X and in area size Y are identical constants or variables: continue X is f (Xn) and Y is decing: f (Y1,..., Yn) for some functor f and n > 0: push Xi = Yi, in area size."}, {"heading": "Implementation of Negation as failure", "text": "Negation as failure is implemented as non-predicate; it is a metalogical predicate, which means that it takes predicate as argument. In order not to implement predicate, predicate is used as follows: not (X): - X,!, fail. not (X). Failure always fails when the search reaches it. It corresponds to any impossible condition called 2 = 3. Intersection!, is always successful when the search reaches it. Intersection is procedural and cannot be understood procedurally. Shorten can be useful to reduce the search space of a program [Colmerauer & Roussel1996]."}, {"heading": "Dynamic Database", "text": "The bottleneck of any system written in Prolog is the knowledge base (dynamic database), an internal database of facts that you can insert directly into the program and remove from the program at runtime. There are three predicates to add a single fact at runtime: \u2022 asserta asserts a new fact over the existing facts for the predicate, \u2022 assertz asserts a new fact after the existing facts for this predicate, \u2022 assert behaves as assertz. to remove facts from the databases. retract can be used with the form: retract (< the fact >) Retract removes the first fact in the database that matches < the fact >, and initiates all free variables in < the fact >. For a detailed review of interpreting logical programs, refer to ([Sterling & Shapiro 1994], [Colmerauer1985] and [Krzysztof1996]."}, {"heading": "4.2. Declarative reading of logic programs", "text": "A feature of the declarative reading of logic programs that makes them very useful is the justification and explanation of HOW and WHY this semantics characterizes this declarative reading [Denecker 2000]. Explanation is an important device provided by expert systems [Merritt1989]. The system must be able to explain HOW it has come to a conclusion and WHY it is performing a calculation. To answer how a conclusion was reached, work back through the sequence. To answer why a calculation is being made, the system must state its current goal. Figure 1 applies this concept to a simple rule. Decision 1 was made because the facts 1, 2, 3 are true. The system can ask the user if fact 3 is true because it tries to determine whether decision 1 should be made. Definition: Interpretation Let P be a logic program. Let U P () Herbrand of and Herbrand of B (P) Theories can be formed from P (P) Universe Brand of B (P) Theories."}, {"heading": "Definition: Model", "text": "Let P be a logical program. Let me be an interpretation: I am a model for P, if for each basic instance of a sentence A B1,..., Bn in P A is in I, if B1,..., Bn in I."}, {"heading": "Definition: Minimal Model", "text": "Let P be a logical program. Let M (P) be a minimal model of P. M (P) is the intersection of all models. The minimal model is the declarative meaning of a logic program."}, {"heading": "Definition: Mapping", "text": "Let P be a logical program. Let TP be a natural mapping of interpretations to interpretations. TP (I) = {A in B (P): A B1,..., Bn, n \u2265 0, is a basic instance of a set in P, and B1,..., Bn are in I}. Definition: Intended Meaning Let P be a logical program. Let M be the intended meaning of P. M is a set of goals determined by the programmer for the program to be calculated. Definition: Let P be a logical program. Let M be the intended meaning of P. P is correct with respect to M if M (P) is contained in M. Let M be a logical program."}, {"heading": "Definition: Completeness", "text": "Let P be a logical program. Let M know the intended meaning of P. P is complete with respect to M. For a comprehensive overview of declarative reading of logical programs, see [Sterling & Shapiro 1994], [Lyaletski2006] and [Denecker 2000])."}, {"heading": "5. Overcoming Misleads In Logic Programs by Redefining Negation", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.1 Motivation", "text": "Consider the following verbal problem [Dow & Mayer 2004]: Marsha and Marjorie were born on the same day of the same year by the same mother and father, but they are not twins. How is this possible? To show that Marsha and Marjorie were born on the same day of the same year by the same mother and father, we can use the person predicate as follows: person (Marsha, father1, mother1, year1), person (Marjorie, father1, mother1, year1). To show that twins were born on the same day of the same month and year by the same mother and father, we can use the twin predicate as the successor predicate (A, B) person (A, father, mother, month, year1). By following the twin predicate of the same mother and father, we cannot use the twin predicate as an explanation that twins in section 1 are not twins."}, {"heading": "5.2 Methodology", "text": "In this section, we present the key characteristics of our framework and demonstrate them to explain HOW a negative conclusion can be reached, but let us first review some important rules of conclusion."}, {"heading": "Definition: Skolemization", "text": "Scolemization is a method of eliminating existential quantifiers. Variables bound by existential quantifiers that are not within the scope of universal quantifiers can be replaced by constants. Example: x [x < 5] can be changed to c < 5, where c is a suitable constant depending on the existential instance."}, {"heading": "Definition: Existential Instantiation", "text": "For each sentence a, variable v and constant symbol k that does not appear elsewhere in the knowledge base: \u03b1),} / {SUBST (\u03b1 kv'm example from x kill (x, Victim), we can infer kill (murderer, victim) as long as the murderer does not appear elsewhere in the knowledge base [Russel & Norvig 2003]. Theorem Negative facts can be achieved by asking the user for constants that do not occur elsewhere in the knowledge base. Proof As mentioned in Section 3, variables are universally quantified in facts, so that a fact p (x1,..., xn, t1,... tm) actually means that the user introduces p (x1,... xn, xn, t1, tm) where x1.. xn, variables and t1.. tm are concepts."}, {"heading": "5.3 Asking the user and Remembering the answer", "text": "The Ask predicate [Merritt1989] must be used by the user to determine whether a given attribute-value pair applies to a particular person or not. A new predicate, known, is used to remember the user's answers to questions. It is not specified directly in the program, but is applied dynamically when questions receive new information from the user. Each time ask is called, it first checks whether the answer is already known or not. If it is not already known, then ask will assert it after it has received a response from the user. The arguments that are known: Yes / No, attribute, person and value. Our new version of the question looks like this: ask (A, P, V) known (yes, A, P, V) known,!.% successful if true and stop asking (A, P, V) known (_, A, P, V), known (gell, Y), gell (known), l (known), l (), l (known), l (A, V)%."}, {"heading": "5.4 Case study", "text": "Consider the verbal problem that was reintroduced in Section 5.2. Using the concept of structured data, we can define missing information as something that relates to the existing data and does not occur in the knowledge base. Example: Consider \"family,\" which can be derived from \"father\" and \"mother.\" Consider also \"day,\" which can be derived from \"month\" and \"year.\" Now, two people who share mother, father and mother can have another person with the same father, mother and mother P, so they are not twins. Another option is to add one or more new objects that do not occur in the knowledge base. Thus, all two people who share father, mother and date of birth can have another person with the same father, mother and P, another person with the same father, mother and P, so they are triplets, not twins. The complete corresponding PROLOG listing is shown below: domain name, father, mother, symbol, year, symbol, (symbol, year, =) missing."}, {"heading": "6. Conclusion and Future work", "text": "To explain HOW a negated conclusion has been reached, we introduce negating facts in a different way. Negating facts can be achieved by asking the user for constants that do not occur elsewhere in the Knowledge Base. In future work, we aim at a detailed study of efficient implementation. We aim to introduce a predicate that does not automatically perform the required work. Another promising direction for future research is the inclusion of the negating methodology proposed in this paper in one of the various extensions of PROLOG. The resulting more flexible support for the representation of negation could represent an important step towards overcoming misconceptions in logic programs and represent a qualitative leap towards introducing creativity into machines."}], "references": [{"title": "A logical foundation for logic programming, I and II, Journal of Logic Programming, pages 151\u2013194", "author": ["A. Bochman"], "venue": null, "citeRegEx": "Bochman,? \\Q1998\\E", "shortCiteRegEx": "Bochman", "year": 1998}, {"title": "A Causal Logic of Logic Programming", "author": ["A. Bochman"], "venue": "Proceedings of the Ninth International Conference", "citeRegEx": "Bochman,? \\Q2004\\E", "shortCiteRegEx": "Bochman", "year": 2004}, {"title": "\"On Skolemization in constrained logics", "author": ["B\u00fcrckert", "H.J. et al 1996] B\u00fcrckert", "B. Hollunder", "A. Laux"], "venue": "Annals of Mathematics and Artificial Intelligence ,", "citeRegEx": "B\u00fcrckert et al\\.,? \\Q1996\\E", "shortCiteRegEx": "B\u00fcrckert et al\\.", "year": 1996}, {"title": "Negation as failure", "author": ["K. Clark"], "venue": "In Herve Gallaire and Jack Minker, editors, Logic and Data Bases,", "citeRegEx": "Clark,? \\Q1978\\E", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "Prolog in 10 Figures", "author": ["A. Colmerauer"], "venue": "Communications of the ACM,", "citeRegEx": "Colmerauer,? \\Q1985\\E", "shortCiteRegEx": "Colmerauer", "year": 1985}, {"title": "The birth of Prolog\", dans History of Programming Languages, edited by Thomas", "author": ["A. Colmerauer", "P. Roussel"], "venue": "ACM Press/Addison-Wesley,", "citeRegEx": "Colmerauer and Roussel,? \\Q1996\\E", "shortCiteRegEx": "Colmerauer and Roussel", "year": 1996}, {"title": "A note on the Declarative reading of Logic Programming", "author": ["M. Denecker"], "venue": "In Proc of AAAI-2000,", "citeRegEx": "Denecker,? \\Q2000\\E", "shortCiteRegEx": "Denecker", "year": 2000}, {"title": " What\u2019s in a Model? Epistemological Analysis of Logic Programming", "author": ["M. Denecker"], "venue": "In Proc of AAAI-2004,", "citeRegEx": "Denecker,? \\Q2004\\E", "shortCiteRegEx": "Denecker", "year": 2004}, {"title": "Teaching students to solve insight problems. Evidence for domain specificity in training", "author": ["Dow", "G.T. Mayer 2004] Dow", "R.E. Mayer"], "venue": "Creativity Research Journal,", "citeRegEx": "Dow et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Dow et al\\.", "year": 2004}, {"title": "Logic Programming and Reasoning with Incomplete Information'", "author": ["M. Gelfond"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Gelfond,? \\Q1994\\E", "shortCiteRegEx": "Gelfond", "year": 1994}, {"title": "From Logic Programming to Prolog", "author": ["R. Krzysztof"], "venue": "Prentice Hall; 1st Ed,", "citeRegEx": "Krzysztof,? \\Q1996\\E", "shortCiteRegEx": "Krzysztof", "year": 1996}, {"title": "Sequent forms of Herbrand theorem and their applications", "author": ["A. Lyaletski"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "Lyaletski,? \\Q2006\\E", "shortCiteRegEx": "Lyaletski", "year": 2006}, {"title": "On indenite data bases and the closed world assumption", "author": ["J. Minker"], "venue": "In Proc of CADE-82,", "citeRegEx": "Minker,? \\Q1982\\E", "shortCiteRegEx": "Minker", "year": 1982}, {"title": "On closed world data bases", "author": ["R. Reiter"], "venue": "Logic and Data Bases,", "citeRegEx": "Reiter,? \\Q1978\\E", "shortCiteRegEx": "Reiter", "year": 1978}, {"title": "Minimal belief and negation as failure in multi-agent systems", "author": ["R. Rosati"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Rosati,? \\Q2003\\E", "shortCiteRegEx": "Rosati", "year": 2003}, {"title": "Artificial Intelligence A Modern Approach\" 2 Ed, page 273", "author": ["S. Russel", "P. Norvig"], "venue": "Pearson Education,", "citeRegEx": "Russel and Norvig,? \\Q2003\\E", "shortCiteRegEx": "Russel and Norvig", "year": 2003}, {"title": "Selected Works in Logic\", edited by Fenstad", "author": ["T. Skolem"], "venue": "J. E., Universitetsforlaget,", "citeRegEx": "Skolem,? \\Q1970\\E", "shortCiteRegEx": "Skolem", "year": 1970}, {"title": "The Art of Prolog", "author": ["L. Sterling", "E. Shapiro"], "venue": "Advanced Programming Techniques\",", "citeRegEx": "Sterling and Shapiro,? \\Q1994\\E", "shortCiteRegEx": "Sterling and Shapiro", "year": 1994}], "referenceMentions": [{"referenceID": 1, "context": "The causal logic [Bochman 2004] is shown to make any causal logic program satisfies the Negation As Default principle (alias Closed World Assumption).", "startOffset": 17, "endOffset": 31}, {"referenceID": 6, "context": "In this view, negation as failure is the classical objective negation [Denecker 2000].", "startOffset": 70, "endOffset": 85}, {"referenceID": 7, "context": "There is an epistemological ambiguity that arises in the context of logic programming [Denecker 2004].", "startOffset": 86, "endOffset": 101}, {"referenceID": 7, "context": "[Denecker 2004] falsifies our assumptions that that each such pair has a unique declarative reading and for a program in several formal logics shall its declarative reading is the same in each of them.", "startOffset": 0, "endOffset": 15}, {"referenceID": 6, "context": "One feature of the declarative reading of logic programs that makes it very useful is the justification and explanation of HOW and WHY this semantics characterizes this declarative reading [Denecker 2000].", "startOffset": 189, "endOffset": 204}, {"referenceID": 6, "context": "For a comprehensive review for declarative reading of logic programs, you can refer to ([Sterling& Shapiro 1994] , [Lyaletski2006] , and [Denecker 2000]).", "startOffset": 137, "endOffset": 152}], "year": 2011, "abstractText": "interpreter for logic programs Input: a goal G and a program P Output: an instance of G that is a logical consequence of P, or no otherwise. Algorithm: 1 2 3 4 5 6 7 8 9 initialize the resolvent to G. while the resolvent is not empty do choose a goal A from the resolvent choose a (renamed) clause A\u2019 B1, ..., Bn from P such that A and A\u2019 unify with MGU \u0398. (if no such goal and clause exist, exit the while loop) replace A by B1, ..., Bn in the resolvent apply \u0398 to the resolvent and to G if the resolvent is empty, then output G, else output no.", "creator": "PScript5.dll Version 5.2"}}}