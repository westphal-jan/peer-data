{"id": "1106.1803", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jun-2011", "title": "Improving the Efficiency of Inductive Logic Programming Through the Use of Query Packs", "abstract": "Inductive logic programming, or relational learning, is a powerful paradigm for machine learning or data mining. However, in order for ILP to become practically useful, the efficiency of ILP systems must improve substantially. To this end, the notion of a query pack is introduced: it structures sets of similar queries. Furthermore, a mechanism is described for executing such query packs. A complexity analysis shows that considerable efficiency improvements can be achieved through the use of this query pack execution mechanism. This claim is supported by empirical results obtained by incorporating support for query pack execution in two existing learning systems.", "histories": [["v1", "Thu, 9 Jun 2011 13:19:53 GMT  (149kb)", "http://arxiv.org/abs/1106.1803v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["h blockeel", "l dehaspe", "b demoen", "g janssens", "j ramon", "h vandecasteele"], "accepted": false, "id": "1106.1803"}, "pdf": {"name": "1106.1803.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "Improving inductive Logi programming by using Query Pa ksHendrik Blo keel hendrik.blo keel s.kuleuven.a.be Katholieke Universiteit Leuven, Department of Computer S ien e Celestijnenlaan 200A, B-3001 Leuven, BelgiumLu Dehaspe lu.dehaspe pharmadm. om PharmaDM, Amba htenlaan 54D, B-3001 Leuven, BelgiumBart Demoen bart.demoen s.kuleuven.a.be Gerda Janssens gerda.janssens s.kuleuven.a.be Jan Ramon jan.ramon s.kuleuven.a.be Katholieke Universiteit Leuven, Department of Computer S ien e Celestijnenlaan 200A, B-3001 Leuven, BelgiumHenk Vande asteele henk.vande asteele pharmadm."}, {"heading": "1. Introdu tion", "text": "This year, we have reached the point where we are able to live in a country where most people are able to move around in order to develop, and where most of them are able to move around in order to develop."}, {"heading": "2. Indu tive Logi Programming", "text": "It is about the question of whether and to what extent it is about a way, in which it is about the question, whether and to what extent it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, and in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way and in which it is about a way, in which it is about a way, in which it is about a way and in which it is about a way, in which it is about a way and in which it is about a way and in which it is about a way, in which it is about a way and in which it is about a way, and in which it is about which it is about a way and in which it is about which it is about a way and in which it is about a way and in which it is about which it is about a way and in which it is about a way, in which it is about which it is about a way and in which it is about which it is about which it is about which it is about a way and in which it is about a way and in which it is about which it is about which it is about which it is about a way and in which it is about which it is about which it is about which it is about a way and in which it is about a way and in which it is about which it is about which it is about which it is about which it is about a way and in which it is about a way and in which it is about which it is about which it is about which it is about which it is"}, {"heading": "3. Query Pa ks", "text": "For simplicity (X, a), I = 2) to (X = 3) to (X = 3) (X) to (X, a) (X, a) (X, a) to (X, a) to (X, a) to (X, c) (X, c) (X, c) to (X, c) to (X, a) to (X, a) to (X, c) to (X, a) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c) to (X, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c (X, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c (X, c, c, c, c, c, c, c, c, c, c, c, c, c, c,"}, {"heading": "3.1 E\u00c6 ient Exe ution of Query Pa ks", "text": "In Se tion 3.1.2, a meta-interpreter is given that the behavior of the query pa ks. In Pra ti e, this meta-interpreter is not useful, because in many cases the meta-interpreter itself causes more overhead than the use of query pa ks an omen for. Indeed, previously reported results (Demoen et al., 1999; Blo keel, 1998) show that the overhead involved in a high-level implementation of the prolog destroys the gain achieved by redundant y reaction. Moreover, as used in Se tion 3.1.2, the meta-interpreter does not have the desired time omplexity. This shows that the desired pro edural semanti s or an implemented in prolog itself, but not with the desired performan e be pause prolog ks the appropriate primitives.The on lusion is that it hanges be at the level of the prolog itself."}, {"heading": "3.1.1 Prin iples of Query Pa ks (Exe ution)", "text": "Before we work out the solutions for the Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-"}, {"heading": "3.1.2 A Meta-interpreter for Query Pa ks", "text": "The rst implementation of the Pa k exe ution algorithm is the Meta-interpreter-Q-Q-Q then Q-Q-Q-Q-Q (Q). The meta-interpreter-E (Q) -E (Q) -E (Q) -E (H) -E (H) -E (H) -E (H) -E (H) -E (H) -E (A) -E (H) -E (H) -E (H) -E (H) -E (H) -E) -E (H) -E (H) -E (H) -E) -E (H) -E (H) E (H) E (E) (E) (H) (E) (E) (H) (E) (E) (H) (E) (E) (E) (H) (E) (E) (E) (E) (H) (E) (E) (E) (H) (E) (E) (E) (E) (H) (E) (E) (E) (H) (E) (E) (H) (E) (E) (H) (E) (E) (E) (H) (E) (E) (E) (E) (H (E) (H) (E) (E (E) (H) (E) (E (E) (H) (E (H) (E) (E (E) (H) (E (H) (E (E) (E (E) (H) (E (H) (E (E) (H) (E (E) (E (H) (E (E) (E (E) (E) (H), E (H) (E (H) (E (E (E) (E) (E (E) (E) (E) (E (H) (E), E (H) (E (E) (E (E) (E) (E (E (E) (E) (H), E) (H) (E (H) (E (E) (H) (E (E), E), E (E (E) (E) (E) (E ("}, {"heading": "3.1.3 WAM Extensions", "text": "rE \"s tis rf\u00fc ide rf\u00fc ide rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the r"}, {"heading": "3.2 Using Query Pa ks", "text": "Figure 7 shows an algorithm that uses the Pa k exution me hanism to represent the result set R as it is contained in our problem. Here, the query set is merely the totality of all queries of a given query, i.e. it does not correspond to the whole hypothesis spa e. from a query pa k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k. The (pro edural) task of the report su ess (K, i) is simply to add R (K; i) to the query result. Obviously, a spe i k k k k k k k k k k p system that has no interest in the result set is itself a separate report su ess / 2 literally to the sheet of pa k k k k k k k k."}, {"heading": "3.3 Computational Complexity", "text": "We estimate the speed at which we can use the Pa-a-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A"}, {"heading": "4. Adapting ILP Algorithms to Use Query Pa ks", "text": "In this article, we will explain how the solution method described above can be integrated into ILP algorithms, and illustrate this in detail for two existing ILP algorithms. Experimental results for actually improving these results will be presented in the next issue."}, {"heading": "4.1 Re nement of a Single Rule", "text": "Many systems for indu tive logi programming use an algorithm that consists of repeated detours, and each of these systems could be rewritten in principle to use a query pa k evaluation of Hanism to achieve a significant eaigen gain. We show this first for an on-rete algorithm for de-isolation tree induction, then for the more general ase."}, {"heading": "4.1.1 Indu tion of De ision Trees", "text": "In fact, it is the case that one sees oneself in a position to put oneself at the top, and in the way in which one puts oneself at the top. () In the way in which one puts oneself at the top, it is also the way in which one puts oneself at the top. () In the way in which one puts oneself at the top, one has to put oneself at the top. () In the way in which one puts oneself at the top, one has to put oneself at the top. () In the way in which one puts oneself at the top, one has to put oneself at the top. ()"}, {"heading": "4.1.2 Other Algorithms Based on Rule Refinement", "text": "As already mentioned, any ILP algorithm based on repeated repetitions should in principle be rewritten to use a query of the Pa k evaluation with Hanism and thus a hieve asigni ant eaufs ien y gain. Consider, for example, a rule induction system that performs an A sear h by a re-nement latti e, su h as a progol (Muggleton, 1995). Sin e A establishes an ertain order in which the lauses for re-nementation are taken into consideration, it is difficult to reorganize the theomputation at this level. However, if one node is included in the list of open nodes and all their re-nements, the evaluation of the re-nements implies that they are all executed; this would be replaced by a Pa k-Exe level in which a positive point of evolution and profit is guaranteed."}, {"heading": "4.2 Level-wise Frequent Pattern Dis overy", "text": "An alternative family of data mining algorithms is the Apriori method for determining common item sets (Agrawal et al., 1996).Warmr (Dehaspe & Toivonen, 1999) is an ILP variant of this attribute-based apriori. Query pa ks in Warmr or reply to hash trees of item sets in Apriori: Both are used to subgraph the entire re-nement latti e down to level n.The paths from root down to level n1 in this subgraph correspond to common patterns. The paths from root to leaves in depth n or respond to candidates whose frequency must be y. Like hash trees in Apriori, query pa ks in Warmr use massive similarities to shift all Warpa algorithms to another level."}, {"heading": "5. Experiments", "text": "The eeisrdBnree\u00fcgn rf\u00fc ide eeisrVnlrtee\u00fcgn nvo edn eeisrVnlrteeu, n \"o so rf\u00fc ide eeisrVnlrteeu, n\" os os rf\u00fc ide eeisrVnlrteeu, n os rf\u00fc ide eeisrBnlrteeu zu.nlrwdeeu eDr \"eeisn, eeisn os rf\u00fc ide eeisn-eSrteeaeBnlrVnlrteeaeeeeeeeoiugnnlrmnlrrteeoVn\" i \"n, eSe os os rf\u00fc ide eeisn-eeeaeBnlPnlrlllrteeeaeeeeeeaeeBnln,\" iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"}, {"heading": "5.1 Tilde", "text": "It's about the question of to what extent it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way and a way, in which it's about a way and a way and a way, in which it's about a way and a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way in which it's about a way and a way and a way in which it's about a way and a way in which it's about a way and a way in which it's about a way and a way in which it's about a way and a way in which it's about a way and a way in which it's about a way and a way it's about a way and a way in which it's about a way and a way in which it's about a way and a way and a way it's about a way and a way it's about a way and a way and a way it's about a way and a way it's about a way and a way and a way it's about a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a way and a way and a way it's about a"}, {"heading": "5.2 Warmr", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.2.1 Used Implementations", "text": "For Warmr, we consider the following implementations: 1. No pa ks: the normal implementation of Warmr, where requests are generated, and for all examples, the requests are evaluated individually; 2. With pa ks: An implementation where all requests for a level are first generated and entered into a pa k, and then this pa k is evaluated using an example."}, {"heading": "5.2.2 Datasets", "text": "Mutagenesis We used the dataset of mutagenesis of 230 molehill modules, in which an h example is repeated ten times to allow for more precise timing and a better idea of time on larger datasets. We used three different language distortions. \"small\" is a language5. In one case, with a relatively small pa k, the system was equally slower. Timing revealed that this was not due to the omilation time, but to other slopes in implementing this relatively simple problem, due to the faster resolution of the pa ks.Mutagenesisbias that was hated to generate a limited number of requirements (i.e. a relatively small bran in the sear h latti e); this allows us to generate query pa ks that are relatively deep but narrow. \"medium\" and \"large\" use broader but less flat pa ks."}, {"heading": "5.2.3 Results", "text": "Tables 4, 5 and 6 show the trigger times from Warmr to Mutagenesis, with the maximum trigger depth varying between 3 for the major language and 9 levels for the minor language. \"Total\" is the total trigger time and \"Exe\" is the time it takes to test the queries on the basis of the examples. Table 7 shows the trigger times from Warmr to Bongard."}, {"heading": "5.2.4 Dis ussion", "text": "The time of execution of Warmr has a great significance, which is not used for the evaluation of requests. This is caused by the fact that Warmr has a lot of administrative work to do. In the time in which these tests should be performed, these tests are very simple, but in the first order they require an exponential time in the size of the queries, or if a query is a spe ialisation of a rare query. In our time in which larger datasets are used, the relative distribution of these administrative east will decrease proportionally. It is an observation that these east are less suitable for the setting of pa ks."}, {"heading": "5.3 Comparison with Other Engines", "text": "Implementing a new prolog motor for special purposes that differs from the existing motors carries a risk: given the complexity of the popular prolog motors, it is useful for him to know whether the new motor is compatible with these existing motors, at least for the tasks to be performed here. The gain obtained from the query should not be determined by a less uncompromising implementation of the motor itself. Originally, the Tilde- and Warmr-systems were implemented in MasterProLog. In an attempt to run them on other platforms, parts of these systems were reimplemented in a kind of prolog from the implementation of prolog motes (SICStus, ilProlog) (the low degree of standardization of prolog made them necessary on other platforms). In view of this situation, there are two questions to be answered: (a) Is the transition from prolog to other prolog motes easy to derive (the low degree of standardization of prolog made them unnecessary) and does not lead to the loss of the latter motor)."}, {"heading": "5.4 Summary of Experimental Results", "text": "Our experiments with rm, which (a) query the execution per se, are in themselves much more efficient than many highly similar queries individually; (b) existing ILP systems (we use Tilde and Warmr as examples) use this I-Hanism to their advantage to accelerate the execution; and) although a new prolog engine is required to achieve this, the current level of development of this engine is so high that it is consistent with state-of-the-art engines in order to accelerate the execution. Furthermore, the experiments contradict our Olympicity analysis of the execution time of pics."}, {"heading": "6. Related Work", "text": "The re-implementation of Tilde refers to the work of Mehta et al. (1996) The rst to ribe ribe the examples in the outside world. (1999) The re-implementation of Tilde is related to the work of Mehta et al. (1996) The rst to ribe ribe the examples in the outside world. (1999) The rst-oS-S-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E"}, {"heading": "7. Con lusions", "text": "In this thesis, we found a lot of redundancy in the execution performed by most ILP systems and proposed a method to avoid it: Exe ution of query-Pa ks. We investigated how query-Pa k-Exe ution can be implemented in ILP systems. The query-Pa k-Exe-ution mir Hanismus was implemented in a new prolog system called ilProlog and thus dedi ted to data mining tasks, and two ILP systems were newly implemented to take advantage of the I-Hanismus. We have experimentally evaluated these re-implementations, and the results of these experiments at the RM show that large accelerations can be achieved in this way. We found that the query-Pa-Exe implements me Hanism in other ILP systems and that similar accelerations represent another Exe-Exase."}, {"heading": "A knowledgements", "text": "Hendrik Blo keel is a post-do Fellow of the Fund for S ienti Resear h (FWO) of Flanders. Jan Ramon is funded by the Flemish Institute for the Promotion of S ienti Resear h in Industry (IWT). Henk Vande asteele was partly funded by FWO proje t G.0246.99,\\ Query languages for database mining. \"The authors thank Lu De Raedt for his detailed work on this work, Ashwin Srinivasan for proposing the term\" query pa ks, \"the anonymous reviewers for their useful comments and Kurt Driessens for proofreading this text. This work was motivated in part by the Esprit proje t 28623, Aladin."}, {"heading": "Appendix A. Preparing the Query for the Meta-interpreter", "text": "It is that the following prevNode, NovNode, NodeNr1, LeafNr1).prepro Es (A, B), PrevNode, NodeNr0, LeafNr0, Bran hNr1, LeafNr1, LeafNr1).prepro Es (A, B), PrevNode, NodeNr0, LeafNr0, LeafNr1, LeafNr1, LeafNr1, LeafNr1).prepro Es (B, PrevNode, PrevNode, NodeNr0, LeafNr0, LeafNr1, LeafNr1).prepro Es (or (Querys, PrevNodeNr0, PrevNode, Bran hNr0, LeafNr1, LeafNr1).prepro"}], "references": [], "referenceMentions": [], "year": 2013, "abstractText": "Indu tive logi programming, or relational learning, is a powerful paradigm for ma hine learning or data mining. However, in order for ILP to be ome pra ti ally useful, the e\u00c6 ien y of ILP systems must improve substantially. To this end, the notion of a query pa k is introdu ed: it stru tures sets of similar queries. Furthermore, a me hanism is des ribed for exe uting su h query pa ks. A omplexity analysis shows that onsiderable e\u00c6 ien y improvements an be a hieved through the use of this query pa k exe ution me hanism. This laim is supported by empiri al results obtained by in orporating support for query pa k exe ution in two existing learning systems.", "creator": "dvips(k) 5.86 Copyright 1999 Radical Eye Software"}}}