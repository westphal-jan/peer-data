{"id": "1106.2692", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2011", "title": "Generating Schemata of Resolution Proofs", "abstract": "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata. The first one handles the most efficient version of the tableau calculus but generates very complex derivations (denoted by rather elaborate rewrite systems). The second one has the advantage that much simpler systems can be obtained, however the considered proof procedure is less efficient.", "histories": [["v1", "Tue, 14 Jun 2011 12:40:07 GMT  (101kb,S)", "http://arxiv.org/abs/1106.2692v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["vincent aravantinos", "nicolas peltier"], "accepted": false, "id": "1106.2692"}, "pdf": {"name": "1106.2692.pdf", "metadata": {"source": "CRF", "title": "Generating Schemata of Resolution Proofs", "authors": ["Vincent Aravantinos", "Nicolas Peltier"], "emails": [], "sections": [{"heading": null, "text": "That is to say, we have to examine carefully the validity of logical formulas based on a set of indexed propositional symbols. A scheme is unsatisfactory iff, it is unsatisfactory for each value of n, the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case analysis of the value of parameters n. Termination is ensured for a specific class of schemes called regular, thanks to a loop recognition rule that is able to conceive itself."}, {"heading": "1 Propositional schemata", "text": "The definitions used in this paper differ from the previous ones, but the logic considered is equivalent to the class of regular schemes considered in [2] (it is therefore strictly less meaningful than general schemes for which the satisfaction formula cannot be decided).We consider three distinct sets of symbols: a set of arithmetic variables V, a set of probability variables, and a set of defined symbols. Let me be a set of index expressions.The set F (I) of formulas built on me is inextricably defined as follows: if the natural number or shape of the form n + k, where n is an arithmetic variable and k is a natural number. Let me be a set of index expressions."}, {"heading": "2 Proof procedure", "text": "In this section, we define the evidentiary procedure used to decide the validity of proposition schemes. We assume, for the sake of simplicity, that the considered schemes are in negative normal form, and that the defined symbols only occur when a defined formula occurs negatively, then it is easy to replace any letter of the form defined by an atom indicating the complementarity of the rules."}, {"heading": "3 Constructing resolution proofs", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Propositional resolution calculus", "text": "A letter is either an atom pk or the negation of an atom pk (where p as well as k and N). A proposition is a (possibly empty) disjunction (or set) of words. A derivative from a set of sentences S is a finite sequence C1,... Cm in such a way that for each i [1, m] Ci is either an element of S or is derived from C1........ Cm \u2212 1 by applying the resolution rule defined as follows: pk, X, pk, YX, Y. A rebuttal is a derivative that contains a sequence (the empty proposition). For each formula, it is a derivative from wire if it is a derivative from a clauses form of sequences. It is well known [9] that every unsatisfactory sequence of (proposition) sequences has a sequence."}, {"heading": "3.2 A language for representing refutations", "text": "Further definitions are needed to provide suitable formal languages for designating such schemes of derivatives. Let D and X be two distinct sets of symbols (disjunctions of V, 0 and 0). The symbols in D are the \"symbols\" and those in X are the \"variables.\" The symbols in X are meant to be defined by schemes, whereas the symbols \"d\" and \"p\" are implicitly a scheme of refutations, defined by induction (and possibly depending on an additional argument denoting a formula). We assume that the symbols in X are extended to a well-founded order of \"expressions.\" Formally, the set of \"expressions\" is defined as follows. \"All schemes and all\" variables \"are.\" This \"trick\" does not simulate the whole process in [3], because the latter schemes are more complex than those considered in the present work."}, {"heading": "3.3 From closed tableaux to resolution proofs", "text": "Leave T a closed tableau of a scheme \u03c6. The general idea is to construct from T a D system R (T), which represents a scheme of refutation of digits for digits. Obviously, R (T) is an inductive proof of the assertion: \"For each n n n n n x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x"}, {"heading": "4 Globally looping tableaux", "text": "Compared to the previous approach, the second algorithm generates much easier rewriting of systems, but it has the disadvantage that a more restrictive version of the loop detection rule must be used to turn the tableaus into finite ones."}, {"heading": "5 Conclusion", "text": "Two different algorithms have been designed to extract schemes of resolution proofs from closed tableaus. This work is motivated by the fact that such rebuttals are required for some natural applications of schema calculation (detection of dissatisfaction is not always sufficient).In particular, the explicit creation of the proofs (even in the form of proof proofs) allows the certification of the results produced by the auditors. The first algorithm treats the tableau calculation in its full universality, but provides very complex representations of the derivatives (making them less usable in practice, in particular they are not very informative for a human user).The second algorithm uses a less powerful calculation, but it generates schemes of rebuttals in a much simpler format (propositional rewrite systems are obtained).Thus, there is a natural trade-off between the two presented methods: none of them is uniformly superior to the othere.The choice between the two algorithms should be designed according to the general application or two presented."}], "references": [{"title": "A schemata calculus for propositional logic", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods), volume 5607 of LNCS, pages 32\u2013 46. Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "A Decidable Class of Nested Iterated Schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "IJCAR 2010 (International Joint Conference on Automated Reasoning), LNCS, pages 293\u2013308. Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Decidability and undecidability results for propositional schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "Journal of Artificial Intelligence Research, 40:599\u2013 656", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Cut-elimination and Redundancy-elimination by Resolution", "author": ["M. Baaz", "A. Leitsch"], "venue": "Journal of Symbolic Computation, 29(2):149\u2013176", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Towards understanding and harnessing the potential of clause learning", "author": ["P. Beame", "H. Kautz", "A. Sabharwal"], "venue": "Journal of Artificial Intelligence Research, 22:319\u2013351", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2004}, {"title": "A simple and flexible way of computing small unsatisfiable cores in SAT modulo theories", "author": ["A. Cimatti", "A. Griggio", "R. Sebastiani"], "venue": "SAT, LNCS, pages 334\u2013339. Springer", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "The resolution calculus", "author": ["A. Leitsch"], "venue": "Springer. Texts in Theoretical Computer Science", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1997}, {"title": "Automatic abstraction without counterexamples", "author": ["K.L. McMillan", "N. Amla"], "venue": "Proceedings of TACAS\u201903, pages 2\u201317. Springer-Verlag", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "Proof theory in the USSR 1925-1969", "author": ["G. Mints"], "venue": "J. Symb. Log., 56(2):385\u2013424", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1991}, {"title": "First-Order Logic", "author": ["R.M. Smullyan"], "venue": "Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1968}, {"title": "Optimization and translation of tableau-proofs into resolution", "author": ["A. Wolf"], "venue": "Journal of Information Processing and Cybernetics, 30(5/6):311\u2013325", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1994}, {"title": "Validating SAT Solvers Using an Independent Resolution- Based Checker: Practical Implementations and Other Applications", "author": ["L. Zhang", "S. Malik"], "venue": "DATE, pages 10880\u201310885. IEEE Computer Society", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 2, "context": "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4].", "startOffset": 129, "endOffset": 132}, {"referenceID": 0, "context": "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.", "startOffset": 3, "endOffset": 9}, {"referenceID": 2, "context": "In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems.", "startOffset": 3, "endOffset": 9}, {"referenceID": 1, "context": "A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3].", "startOffset": 124, "endOffset": 127}, {"referenceID": 6, "context": "More precisely, we present an algorithm that, given a closed tableau T for a schema \u03c6n, returns a schema of a refutation of \u03c6n in the resolution calculus [9].", "startOffset": 154, "endOffset": 157}, {"referenceID": 8, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 171, "endOffset": 179}, {"referenceID": 10, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 171, "endOffset": 179}, {"referenceID": 4, "context": "In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6].", "startOffset": 205, "endOffset": 211}, {"referenceID": 11, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 87, "endOffset": 91}, {"referenceID": 7, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 120, "endOffset": 124}, {"referenceID": 5, "context": "The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8].", "startOffset": 156, "endOffset": 159}, {"referenceID": 3, "context": "Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies", "startOffset": 61, "endOffset": 64}, {"referenceID": 3, "context": "2 in [5]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable).", "startOffset": 159, "endOffset": 162}, {"referenceID": 0, "context": "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].", "startOffset": 49, "endOffset": 52}, {"referenceID": 9, "context": "The procedure is similar to the one presented in [2] and based on propositional block tableaux [12].", "startOffset": 95, "endOffset": 99}, {"referenceID": 0, "context": "Note that the notion of pure literal is much simpler here than in [2].", "startOffset": 66, "endOffset": 69}, {"referenceID": 1, "context": "The Dpll procedure in [3] can be simulated by the previous expansion rules, simply by adding for each propositional symbol p \u2208 \u03a9, a defined symbol \u03c5 with two rules: \u03c5 i+1 \u2192 ((pi\u2228\u00acpi)\u2227\u03c5 p i ) and \u03c5 0 \u2192 \u22a4.", "startOffset": 22, "endOffset": 25}, {"referenceID": 6, "context": "It is well-known [9] that every unsatisfiable set of (propositional) clauses has a refutation.", "startOffset": 17, "endOffset": 20}, {"referenceID": 1, "context": "This \u201ctrick\u201d does not actually simulate the full procedure in [3], because the latter handles schemata that are more complex than the ones considered in the present paper, possibly containing nested iterations.", "startOffset": 62, "endOffset": 65}], "year": 2017, "abstractText": "Two distinct algorithms are presented to extract (schemata of) resolution proofs from closed tableaux for propositional schemata [4]. The first one handles the most efficient version of the tableau calculus but generates very complex derivations (denoted by rather elaborate rewrite systems). The second one has the advantage that much simpler systems can be obtained, however the considered proof procedure is less efficient. In [2, 4] a tableau calculus (called Stab) is presented for reasoning on schemata of propositional problems. This proof procedure is able to test the validity of logical formul\u00e6 built on a set of indexed propositional symbols, using generalized connectives such as \u2228 n i=1 or \u2227 n i=1, where i, n are part of the language (n denotes a parameter, i.e. an existentially quantified variable). A schema is unsatisfiable iff it is unsatisfiable for every value of n. Stab combines the usual expansion rules of propositional logic with some delayed instantiation schemes that perform a case-analysis on the value of the parameter n. Termination is ensured for a specific class of schemata, called regular, thanks to a loop detection rule which is able to prune infinite tableaux into finite ones, by encoding a form a mathematical induction (by \u201cdescente infinie\u201d). A related algorithm, called Dpll and based on an extension of the Davis-Putnam-Logemann-Loveland procedure, is presented in [3]. In the present work, we show that resolution proofs can be automatically extracted from the closed tableaux constructed by Stab or Dpll on unsatisfiable schemata. More precisely, we present an algorithm that, given a closed tableau T for a schema \u03c6n, returns a schema of a refutation of \u03c6n in the resolution calculus [9]. In the usual propositional case, it is well-known that algorithms exist to extract resolution proofs from closed tableaux constructed either by the usual structural rules [11, 13] or by the DPLL algorithm [7, 6]. The resolution proofs are used in various applications, for instance for certification [14], for abstraction-refinement [10] or for explanations generation [8]. The present paper extends these techniques to propositional schemata. Beside the previously mentioned applications, this turned out to be particularly important in the context of the ASAP project [1] in which schemata calculi are applied to the formalisation and analysis of mathematical proofs via cut-elimination. Indeed, the algorithm used for cut-elimination, called CERES [5], explicitly relies on the existence of a resolution proof of the so-called characteristic clause set extracted from the initial proof. The cut-free proof is reconstructed from this refutation, by replacing the clauses occurring in this set by some \u201cprojections\u201d of the original proof. While Stab and Dpll are able to detect the unsatisfiability of characteristic clause sets, as such this is completely useless since actually it is known that those sets are always unsatisfiable (see Proposition 3.2 in [5]). It is thus essential to be able to generate explicitly a representation of the resolution proof. This is precisely the aim of the present paper. Since the initial formula depends on a parameter n, its proof will also depend on n (except in very particular and trivial cases), i.e. it must be a schema of resolution proof (which will be encoded by recursive definitions). The rest of the paper is structured as follows. In Section 1 we introduce the basic notions and notations used throughout our work, in particular the logic of propositional schemata (syntax and semantics). In Section 2 we define a tableau-based proof procedure for this logic. This calculus simulates both Stab and Dpll (for the specific class of schemata considered in the present paper). In Section 3 we provide an algorithm to extract resolution proofs from closed tableaux. Similarly to the formul\u00e6 themselves, the constructed derivations are represented by rewrite systems. In Section 4 we introduce a second algorithm which generates simpler derivations but that requires that one of the closure rules defined in Section 2 (the so-called Loop Detection rule) be replaced by a less powerful rule, called the Global Loop Detection rule. Section 5 briefly concludes our work. 1 Propositional schemata The definitions used in the present paper differ from the previous ones, but the considered logic is equivalent to the class of regular schemata considered in [2] (it is thus strictly less expressive than general schemata, for which the satisfiability problem is undecidable). We consider three disjoint sets of symbols: a set of arithmetic variables V , a set of propositional variables \u03a9 and a set of defined symbols \u03a5. Let \u227a be a total well-founded ordering on the symbols in \u03a5. An index expression is either a natural number or of the form n + k, where n is an arithmetic variable and k is a natural number. Let I be a set of index expressions. The set F(I) of formul\u00e6 built on I is inductively defined as follows: if p \u2208 \u03a9 \u222a \u03a5 and \u03b1 \u2208 I then p\u03b1 \u2208 F(I); \u22a4,\u22a5 \u2208 F(I); and if \u03c6, \u03c8 \u2208 F(I) then \u00ac\u03c6, \u03c6 \u2228 \u03c8, \u03c6 \u2227 \u03c8, \u03c6 \u21d2 \u03c8 and \u03c6 \u21d4 \u03c8 are in F(I). Definition 1 We assume that each element \u03c5 \u2208 \u03a5 is mapped to two rewrite rules \u03c1\u03c5 and \u03c1 0 \u03c5 that are respectively of the form \u03c5i+1 \u2192 \u03c6 (inductive case) and \u03c50 \u2192 \u03c8 (base case), where \u03c6 \u2208 F({i+ 1, i, 0}), \u03c8 \u2208 F({0}) and: 1. For every atom \u03c4\u03b1 occurring in \u03c6 such that \u03c4 \u2208 \u03a5 we have either \u03c4 \u227a \u03c5 and \u03b1 \u2208 {i+ 1, i, 0} or \u03c4 = \u03c5 and \u03b1 \u2208 {0, i}. 2. For every atom \u03c4\u03b1 occurring in \u03c8 such that \u03c4 \u2208 \u03a5 we have \u03c4 \u227a \u03c5 and \u03b1 = 0. \u2738 We denote by R the rewrite system: {\u03c1\u03c5, \u03c1 0 \u03c5 | \u03c5 \u2208 \u03a5}. The rules \u03c1 1 \u03c5 and \u03c1 0 \u03c5 are provided by the user, they encode the semantics of the defined symbols. Proposition 2 R is convergent. Proof. By Conditions 1 and 2 in Definition 1, the rules in R either strictly decrease the values of the defined symbols occurring in the formula w.r.t. \u227a or do not increase the value of these symbols but strictly decreases the value of their indices. Thus termination is obvious. Confluence is then immediate since the system is orthogonal. For every formula \u03c6, we denote by \u03c6\u2193R the unique normal form of \u03c6. A schema (of parameter n) is an element of F({0, n, n+ 1}). We denote by \u03c6{n \u2190 k} the formula obtained from \u03c6 by replacing every occurrence of n by k. Obviously for any schema \u03c6, \u03c6{n \u2190 k} \u2208 F({0, k, k + 1}). A propositional formula is a formula \u03c6 \u2208 F(N) containing no defined symbols. Notice that if \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula. Proposition 3 If \u03c6 \u2208 F(N) then \u03c6\u2193R is a propositional formula. Proof. By definition ofR, \u03c6\u2193R\u2208 F(N). Furthermore, if \u03c6\u2193R contains a defined symbol \u03c5 then either \u03c1\u03c5 or \u03c1 0 \u03c5 applies, which is impossible. An interpretation is a function mapping every arithmetic variable n to a natural number and every atom of the form pk (where k \u2208 N) to a truth value true or false. An interpretation I validates a propositional formula \u03c6 iff one of the following conditions holds: \u03c6 is of the form pk and I(pk) = true; \u03c6 is of the form \u00ac\u03c8 and I does not validate \u03c8; or \u03c6 is of the form \u03c81 \u2228 \u03c82 (resp. \u03c81 \u2227 \u03c82) and I validates \u03c81 or \u03c82 (resp. \u03c81 and \u03c82). I validates a schema \u03c6 (written I |= \u03c6) iff I validates \u03c6{n \u2190 I(n)}\u2193R. We write \u03c6 |= \u03c8 if every interpretation I validating \u03c6 also validates \u03c8 and \u03c6 \u2261 \u03c8 if \u03c6 |= \u03c8 and \u03c8 |= \u03c6. Example 4 The schema p0\u2227 \u2227 n i=1(pi\u22121 \u21d2 pi)\u2227\u00acpn is encoded by p0\u2227\u03c5n\u2227\u00acpn, where \u03c5 is defined by the rules: \u03c5i+1 \u2192 (\u00acpi \u2228 pi+1) \u2227 \u03c5i and \u03c50 \u2192 \u22a4. The schema \u2228 n i=1 pi \u2227 \u2227 n i=1 \u00acpi is encoded by \u03c4n \u2227 \u03c4 \u2032 n , where \u03c4 and \u03c4 \u2032 are defined by the rules: \u03c4i+1 \u2192 pi+1 \u2228 \u03c4i, \u03c40 \u2192 \u22a5, \u03c4 \u2032 i+1 \u2192 \u00acpi+1 \u2227 \u03c4 \u2032 i and \u03c4 \u2032 0 \u2192 \u22a4. Both schemata are obviously unsatisfiable. The schema (pn \u21d4 (pn\u22121 \u21d4 (. . . (p1 \u21d4 p0) . . .))) is defined by \u03c5 \u2032 n , where: \u03c5 i+1 \u2192 (pi+1 \u21d4 \u03c5 \u2032 i ) and \u03c5 0 \u2192 p0. \u2663", "creator": "LaTeX with hyperref package"}}}