{"id": "1106.3457", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Jun-2011", "title": "Extensional Higher-Order Logic Programming", "abstract": "We propose a purely extensional semantics for higher-order logic programming. In this semantics program predicates denote sets of ordered tuples, and two predicates are equal iff they are equal as sets. Moreover, every program has a unique minimum Herbrand model which is the greatest lower bound of all Herbrand models of the program and the least fixed-point of an immediate consequence operator. We also propose an SLD-resolution proof procedure which is proven sound and complete with respect to the minimum model semantics. In other words, we provide a purely extensional theoretical framework for higher-order logic programming which generalizes the familiar theory of classical (first-order) logic programming.", "histories": [["v1", "Fri, 17 Jun 2011 12:01:01 GMT  (51kb)", "http://arxiv.org/abs/1106.3457v1", "45 pages"]], "COMMENTS": "45 pages", "reviews": [], "SUBJECTS": "cs.PL cs.AI cs.LO", "authors": ["a charalambidis", "k handjopoulos", "p rondogiannis", "w w wadge"], "accepted": false, "id": "1106.3457"}, "pdf": {"name": "1106.3457.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 110 6,34 57v1 ["}, {"heading": "1 Introduction", "text": "In fact, it is so that most of them are able to survive themselves, and that they are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...)"}, {"heading": "2 The Proposed Approach: an Intuitive Overview", "text": "In fact, it is the case that you are able to be in a position without being able to play by the rules, and you are able to change the rules."}, {"heading": "3 The Higher-Order Language H: Syntax", "text": "In this section we will introduce the binary operator \u2192 right associative. A functional type that is different from the written one is often described differently from the original one."}, {"heading": "4 Algebraic Lattices", "text": "This year it is so far that it only takes a few days until it is so far, until it is so far."}, {"heading": "5 The Semantics of H", "text": "The semantics of H is based on the concept of the algebraic lattice. Remember that an algebraic lattice is a complete lattice L, with the additional property that each element x of L represents the least upper limit of K (L) [x]."}, {"heading": "5.1 The Semantics of Types", "text": "Before defining the semantics of the expressions of H, we must provide the quantitative meaning of the types of expressions of H in relation to a series D (where D will later be the domain of our interpretations).The fact that a certain type Celsius denotes a set [[number]] D. means that an expression of type Celsius denotes an element of [[number] D. In other words, the semantics of the types helps us understand what the meanings of the expressions of our language are. In the following definition, we define two things simultaneously and recursively: the semantics [number] D of a type and the corresponding subdivision [number] D is a non-empty set. Then: \u2022 [number] D = D, and [number] is the trivial suborder so that d \u00b2 d is the subdivision so that we are d \u00b2 d, for all d. \u2022 [number] D."}, {"heading": "5.2 The Semantics of Expressions", "text": "We can continue to give meaning to the expressions of H. This is done by first defining the concepts of interpretation and state for H. (Definition 5.5 An interpretation I of H consists of: 1. of a nonempty set D, called the domain of I2. an assignment to every single constant symbol c, an element I (c).D3Consider this, let us suppose: 1 = o and let D be an infinite set. Then, K ([\u03b9 o] D) consists of all finite subsets of D and is not a complete grid (since the at least upper limit of a finite set of finite sets itself can be infinite).3. an assignment to every constant p of type \u03c0, an element I (p).D4. an assignment to every function symbol f of type sp."}, {"heading": "5.3 A Comparison with the Continuous Semantics", "text": "In this subsection we give a brief comparison of the proposed seantics with the semantics introduced in [Wad91]. A complete description of such a comparison would require a detailed description of the approach presented in [Wad91] and its adaptation to the richer language. We avoid such an extensive comparison by outlining the most important points in an intuitive way. As already mentioned, the source language proposed in [Wad91] is limited compared to H. However, the semantics of [Wad91] can be adequately extended to apply to H. In view of a non-empty set D, let us consider the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the seantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the seantics of the semantics of the semantics of the semantics of the semantics of the seantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the seantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the seantics of the semantics of the semantics of the seantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the semantics of the"}, {"heading": "6 Minimum Herbrand Model Semantics", "text": "We assume that in practice we often refer to a \"herbrand state s,\" i.e. a state whose underlying domain is UH."}, {"heading": "7 Proof Procedure", "text": "An important aspect that we must first solve is the presentation of basic elements (see definition 5.3) in our source language. In the following section we will introduce a class of positive expressions, namely basic expressions that are syntactic analogies to basic elements. Basic expressions are used to formalize the concept of the answer (to a given question), as well as in our development of SLD resolution for H."}, {"heading": "7.1 Basic Expressions", "text": "As we have already seen, fundamental elements play an important role in the development of the semantics of our higher order. \u00b7 VII \u00b7 VII \u00b7 VII \u00b7 VII \u00b7 VII \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V \u00b7 V"}, {"heading": "7.2 Substitutions and Unifiers", "text": "Substitutions are crucial in the development of the evidentiary process E. Such definitions are usually complicated by the fact that one often applies the limited variable before applying the variable. \u00b7 Substitutions are a finite proposition of the form {V1 / E1,.., Vn / En}, where the Vi's are different argument variables of H and each egg, is a positive expression of H, which has the same type as Vi. A substitution is called a zero order if the type (Vi) = V1,., for all i-expressions (Vn). (Note that any zero-order substitution is also fundamental).The substitution corresponding to the empty proposition is called identity substitution and is called by the others. We are now ready to define what it means to apply a substitution process to an expression."}, {"heading": "7.3 SLD-Resolution", "text": "Definition 7.16 Let P be a program and G be a target. An answer for P {G} is a basic substitution for (certain) free variables of G.Definition 7.17 Let P be a program that contains a target clause and an answer for P (G. We say that this answer is a correct answer for P (G) if for each model M is derived from P and for each state s is derived from the domain of M. (M) = 1.Definition 7.18 Let P be a program and let G (A) and G (A) be a target clauses. Then we say that A \"is derived from A in a step using basic substitution steps (or equivalent that G\" is derived from G in a step of G)."}, {"heading": "7.4 Soundness of SLD-resolution", "text": "In this subsection, we note the solidity of the SLD proof process. The following quotations are very useful for proving the solidity theory: Lemma 7.23 Let P be a program, let me be an interpretation of P and let us be a state over the range of I. Let E1 and E2 be positive expressions of type E (E2 E) and E be expression of type E (I). If [E1] s (I) be an interpretation of P (I), then [(E1 E)] s (I) positive expressions of type E (I). Proof. Linear using the definition of application.Lemma 7.24 Let P be a program, let G = A and G \u2032 = be an answer A and let us be a basic substitution, which is such that we have such a replacement. Then applies to each model M of P and to each state."}, {"heading": "7.5 Completeness of SLD-resolution", "text": "To determine the completeness of the proposed SLD resolution, we must first show a result that corresponds to the annulment quandary of the first order case (see [Llo87]). We first have a state (and prove in the appendix) of a more technical problem that, as a special case, has the desired annulment of the SLD refutation of P \u00b2 whenever we refer to a \"substitution,\" a \"fundamental substitution.\" Lemma 7.27 Let P be a program, G a goal and a substitution. Suppose that there is an SLD refutation of P (using substitution). Then there is an SLD refutation of P {G} using a substitution program in which it applies to some substitution programs that there is an SLD refutation of P. (possibly blank) SLD variables that are introduced during the refutation of P."}, {"heading": "8 Related Work", "text": "As already discussed in Section 1, research in higher order logic programming can be categorized into two main streams: the extensional approaches and the intense ones.Work on extensively higher-order logic programming is rather limited. Apart from the results of [Wad91] 5, the only other work that has attracted our attention is that of M. Bezem [Bez99, Bez01], who considers quantum logic programming languages with syntax similar to that of [Wad91]. In [Bez01] a notion of extensionality is defined (called the extensional collapse) and it is demonstrated that many logic programs under this term are extensional, which differ from the classical extensionality and have a rather prolonsional language. On the other hand, we are working on intensive higher order logic, which is much broader. The two main existing approaches in this area are represented by the languages prolog and hilog."}, {"heading": "9 Implementation and Future Work", "text": "A detailed description of the implementation is outside the scope of this work, but in the following we outline certain points that we consider important, the main difference being that the proof method must produce an infinite (as yet unquantifiable) number of basic templates. (In order to make the production of the basic templates more efficient, a fundamental optimization has been adopted. (As we have already mentioned in Definition 7.3, a basic template is a non-empty finite association of basic expressions of a particularly simple form.) In the implementation, the members of this association are generated in a \"needs-oriented manner,\" as the following examples illustrate. (Example 9.1 Consider the query), (R c d), (R c d). The proposed proof method would try some basic templates until it finds a satisfactory solution. (If it first tries the basic relationships.) X.X."}, {"heading": "A Proof of Lemma 4.17", "text": "To establish Lemma 4.17, we first need to show the following auxiliary propositions: Proposal A.1 Lass A = each x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x"}, {"heading": "B Proof of Lemma 5.10", "text": "Lemma 5.10 Let us be E: an expression of H and let D be a non-empty proposition. Moreover, let s (s1, s2) be states above D and let me give an interpretation of D. Then: 1. [E] s (I). The two statements are simultaneously induced by a structural induction to E.Induction (Base: The cases for E-Being 0, 1, c, p or V, are all straight forward. The interesting cases are E = (E1E2) and E = (V.E1). The other cases are simpler and immediate. Case 1: (E1E2). Let us examine the two statements of the problem: Statement 1: Statement 1 and E2: Statement I."}, {"heading": "C Proof of Lemma 6.5", "text": "Lemma 6,5 Let P be a program and let E: \u03c1 be a positive expression of P. Let I, J be (J) (J) (Herbrand interpretations and s a state of P. If I IP J then [[E] s (I) \u03c1 [E] s (J).Proof is by a structural induction based on E.Induction: The cases for E are 0, 1, c, p or V, are all uncomplicated.Induction Step: The interesting cases are E = (E1E2) and E = (V.E1).The other cases are simpler and omitted.Case 1: E = (E1E2). Suffice it to show that [[(E1E2)] s (I) [(E1E2)] s (J)] s (J), or equivalent, that b2 B2 B2 (E1)."}, {"heading": "D Proof of Lemma 6.6", "text": "Let me be a program and let me be a positive expression of P. Let me be a controlled theorem of Herbrand's interpretations (b). (b) The proof can be furnished in two steps: First, we show that [E] s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (B) s (B) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I (I) s (I) s (I) s (I) s (I (I) s (I) s (I) s (I (I) s (I (I) s (I (I) s (I) s (I (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I) s (I (I) s (I) s (I) s (I) s (I (I) s (I) s (I) s (I (I) s (I) s (I) s (I (I) s (I) s (I (I) s (I (I) s (I (I) s (I (I) s (I (I) s (I (I) s (I (I (I) s (I (I) s (I (I) s (I (I) s (I (I) s (I (I (I) s (I (I) s) s (I s (I (I (I) s) s (I (I (I (I (I) s) s (I (I) s) s (I (I s (I (I (I (I (I) s) s) s (I (I (I (I (I) s) s (I s (I (I) s) s ("}, {"heading": "E Proof of Lemma 7.27", "text": "s say that there is an SLD refutation of the P question (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question) (Ekp question). Then there is a (possibly empty) set of template variables introduced during the refutation of P question. \u00b7 Proof. The proof is by induction on the length n of the SLD refutation of P question (Ekp question). Basis: The basis is for n = 1. We must distinguish cases based on the structure of G. The most interesting case is G = (E1) (the rest are simpler and omitted). We assume that there is no solution (E1p question)."}, {"heading": "F Proof of Lemma 7.35", "text": "Lemma 7.35 Let P be a program and G = \u2190 A be a goal such that [A] s (Q = Q = 1 for all Herbrand states). Then there is an SLD refutation if every expression is closed within reach. We show that for every closed basic substitution. if [A] s (VP) s (1 for all Herbrand states) = 1 for all Herbrand states, then there is an SLD refutation if every expression is closed within reach. We show that for every closed basic substitution. s (VP) = 1 for all Herbrand states, then there is an SLD refutation for P states with identical answer. The statement of the problem is then a direct consequence for these countries. We start with the statement that A is always of the form (A0 A1 \u00b7 An), n = 0 then A0 of type o."}], "references": [{"title": "Domain theory", "author": ["S. Abramsky", "A. Jung"], "venue": "Handbook of Logic in Computer Science III,", "citeRegEx": "Abramsky and Jung.,? \\Q1994\\E", "shortCiteRegEx": "Abramsky and Jung.", "year": 1994}, {"title": "Logic Programming", "author": ["K.R. Apt"], "venue": "In: J. van Leeuwen, editor, Handbook of Theoretical Computer Science vol. B, Elsevier Science Publishers B.V.", "citeRegEx": "Apt90", "shortCiteRegEx": null, "year": 1990}, {"title": "The Lambda Calculus: Its Syntax and Semantics", "author": ["H.P. Barendregt"], "venue": "North-Holland", "citeRegEx": "Bar84", "shortCiteRegEx": null, "year": 1984}, {"title": "Extensionality of Simply Typed Logic Programs", "author": ["M. Bezem"], "venue": "International Conference on Logic Programming (ICLP), pages 395\u2013410", "citeRegEx": "Bez99", "shortCiteRegEx": null, "year": 1999}, {"title": "An Improved Extensionality Criterion for Higher-Order Logic Programs", "author": ["M. Bezem"], "venue": "Computer Science Logic (CSL), pages 203\u2013216", "citeRegEx": "Bez01", "shortCiteRegEx": null, "year": 2001}, {"title": "Lattice Theory", "author": ["G. Birkhoff"], "venue": "American Mathematical Society", "citeRegEx": "Bir67", "shortCiteRegEx": null, "year": 1967}, {"title": "HiLog as a Platform for Database Languages", "author": ["W.C. Chen", "M. Kifer", "D.S. Warren"], "venue": "IEEE Data Eng. Bull., 12(3): 37\u201344", "citeRegEx": "CKW89", "shortCiteRegEx": null, "year": 1989}, {"title": "HILOG: A Foundation for Higher-Order Logic Programming", "author": ["W.C. Chen", "M. Kifer", "D.S. Warren"], "venue": "J. of Logic Programming, 15(3):187\u2013230", "citeRegEx": "CKW93", "shortCiteRegEx": null, "year": 1993}, {"title": "Predicate Logic as a Computational Formalism", "author": ["K.L. Clark"], "venue": "Research Report DOC 79/59, Dept. of Computing, Imperial College, London", "citeRegEx": "Cla79", "shortCiteRegEx": null, "year": 1979}, {"title": "Functional Programming", "author": ["A.J. Field", "P. Harrison"], "venue": "Addison-Wesley", "citeRegEx": "FH88", "shortCiteRegEx": null, "year": 1988}, {"title": "General Lattice Theory", "author": ["G. Gr\u00e4tzer"], "venue": "Academic Press", "citeRegEx": "Gra78", "shortCiteRegEx": null, "year": 1978}, {"title": "LUSH-Resolution and its Completeness", "author": ["R. Hill"], "venue": "DCL Memo 78, Dept. of Artificial Intelligence, University of Edinburgh", "citeRegEx": "H74", "shortCiteRegEx": null, "year": 1974}, {"title": "Introduction to Combinators and \u03bb-calculus", "author": ["J.R. Hindley", "J.P. Seldin"], "venue": "London Mathematical Society", "citeRegEx": "HS86", "shortCiteRegEx": null, "year": 1986}, {"title": "Extensional Higher-Order Datalog", "author": ["V. Kountouriotis", "P. Rondogiannis", "W.W. Wadge"], "venue": "short paper proceedings of the 12th International Conference on Logic for Programming, Artificial Intelligence and Reasoning (LPAR-12), pages 1\u20135", "citeRegEx": "KRW05", "shortCiteRegEx": null, "year": 2005}, {"title": "Foundations of Logic Programming", "author": ["J. Lloyd"], "venue": "Springer-Verlag", "citeRegEx": "Llo87", "shortCiteRegEx": null, "year": 1987}, {"title": "Higher Order Logic Programming", "author": ["D.A. Miller", "G. Nadathur"], "venue": "Proceedings of the Third International Conference on Logic Programming, pages 448\u2013462", "citeRegEx": "MN86", "shortCiteRegEx": null, "year": 1986}, {"title": "A Higher-Order Logic as the Basis for Logic Programming", "author": ["G. Nadathur"], "venue": "Ph.D. thesis, University of Pennsylvania", "citeRegEx": "Nad87", "shortCiteRegEx": null, "year": 1987}, {"title": "Higher-Order Horn Clauses", "author": ["G. Nadathur", "D. Miller"], "venue": "Journal of the ACM, 37(4):777\u2013814", "citeRegEx": "NM90", "shortCiteRegEx": null, "year": 1990}, {"title": "Higher-Order Logic Programming", "author": ["G. Nadathur", "D. Miller"], "venue": "Dov M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, Handbook of Logics for Artificial Intelligence and Logic Programming, pages 499\u2013590. Clarendon Press, Oxford", "citeRegEx": "NM98", "shortCiteRegEx": null, "year": 1998}, {"title": "Minimum Model Semantics for Logic Programs with Negation-as-Failure", "author": ["P. Rondogiannis", "W.W. Wadge"], "venue": "ACM TOCL, 6(2): 441\u2013467", "citeRegEx": "RW05", "shortCiteRegEx": null, "year": 2005}, {"title": "Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory", "author": ["J.E. Stoy"], "venue": "MIT Press", "citeRegEx": "Sto77", "shortCiteRegEx": null, "year": 1977}, {"title": "Semantics of Programming Languages", "author": ["R.D. Tennent"], "venue": "Prentice Hall", "citeRegEx": "Ten91", "shortCiteRegEx": null, "year": 1991}, {"title": "Higher-Order Horn Logic Programming", "author": ["W.W. Wadge"], "venue": "Proceedings of the International Symposium on Logic Programming, pages 289\u2013303", "citeRegEx": "Wad91", "shortCiteRegEx": null, "year": 1991}, {"title": "Higher-Order Extensions to Prolog: are they needed? Machine Intelligence", "author": ["D.H.D. Warren"], "venue": "10:441\u2013454", "citeRegEx": "War82", "shortCiteRegEx": null, "year": 1982}], "referenceMentions": [{"referenceID": 23, "context": "The initial attitude of logic programmers towards higher-order logic programming was somewhat skeptical: it was often argued (see for example [War82]) that there exist ways of encoding or simulating higher-order programming inside Prolog itself.", "startOffset": 142, "endOffset": 149}, {"referenceID": 22, "context": "Wadge in [Wad91] and answered in the affirmative.", "startOffset": 9, "endOffset": 16}, {"referenceID": 22, "context": "Contributions: In this paper we extend the study initiated in [Wad91] and derive the first, to our knowledge, complete theoretical framework for extensional higher-order logic programming, both from a semantic as-well-as from a proof theoretic point of view.", "startOffset": 62, "endOffset": 69}, {"referenceID": 10, "context": "Our first contribution is the development of a novel extensional semantics for higher-order logic programming that is based on algebraic lattices (see for example [Gra78]), a subclass of the familiar complete lattices that have traditionally been used in the theory of first-order logic programming.", "startOffset": 163, "endOffset": 170}, {"referenceID": 22, "context": "In other words, the proposed semantics reflects in a direct way the finitary nature of continuity that is implicit in [Wad91].", "startOffset": 118, "endOffset": 125}, {"referenceID": 22, "context": "The benefit of the new approach compared to that of [Wad91] is that all basic properties and results of classical logic programming are now transferred in the higher-order setting in a natural way.", "startOffset": 52, "endOffset": 59}, {"referenceID": 22, "context": "Moreover, the new semantics leads to a relatively simple sound and complete proof procedure (see below) even for a language that is genuinely more powerful than the one considered in [Wad91].", "startOffset": 183, "endOffset": 190}, {"referenceID": 22, "context": "The first problem we consider is to bypass one important restriction of [Wad91], namely the inability to handle programs in which clauses contain uninstantiated predicate variables.", "startOffset": 72, "endOffset": 79}, {"referenceID": 22, "context": "According to the semantics of [Wad91], the least Herbrand model of the program assigns to predicate p a continuous relation which is true of all unary relations that contain at least 0 and s(0).", "startOffset": 30, "endOffset": 37}, {"referenceID": 22, "context": "The above example illustrates why uninstantiated predicate variables in clauses were disallowed in [Wad91].", "startOffset": 99, "endOffset": 106}, {"referenceID": 22, "context": "In more formal terms, the least Herbrand model of a higher-order program under the semantics of [Wad91] is in general an uncountable set; in our example, this is evidenced by the fact that there exists an uncountable number of unary relations over the natural numbers that contain both 0 and s(0).", "startOffset": 96, "endOffset": 103}, {"referenceID": 22, "context": "How can one define a proof procedure that is sound and complete with respect to this semantics? The key idea for bypassing these problems was actually anticipated in the concluding section of [Wad91]:", "startOffset": 192, "endOffset": 199}, {"referenceID": 22, "context": "1) range over finite relations (and not over arbitrary relations as in [Wad91]).", "startOffset": 71, "endOffset": 78}, {"referenceID": 20, "context": "Actually, this is an old and well-known assumption in the area of denotational semantics, as the following excerpt from [Sto77][page 98] indicates:", "startOffset": 120, "endOffset": 127}, {"referenceID": 10, "context": "In fact, as we are going to see, for every predicate type of our language, the set of possible meanings of this type forms an algebraic lattice [Gra78]; then, the above property is nothing more than the key property which characterizes algebraic lattices (see Proposition 4.", "startOffset": 144, "endOffset": 151}, {"referenceID": 14, "context": "As it is well-known, the standard semantics of classical (first-order) logic programming, is based on complete lattices (see for example [Llo87]).", "startOffset": 137, "endOffset": 144}, {"referenceID": 10, "context": "As we are going to see, the development of the semantics of H is based on a special class of complete lattices, namely algebraic lattices (see for example [Gra78]).", "startOffset": 155, "endOffset": 162}, {"referenceID": 21, "context": "An easy proof using basic properties of posets (see for example the corresponding proof for domains [Ten91][Lemma 5.", "startOffset": 100, "endOffset": 107}, {"referenceID": 10, "context": "We can now define the notion of algebraic lattice (see for example [Gra78]), which will prove to be the key lattice-theoretic concept applicable to our context.", "startOffset": 67, "endOffset": 74}, {"referenceID": 5, "context": "Birkhoff [Bir67] (who did not assume completeness at that time).", "startOffset": 9, "endOffset": 16}, {"referenceID": 22, "context": "The results of [Wad91] indicate that (due to continuity), if a relation satisfies a predicate, then some \u201cfinite representative\u201d of this relation also satisfies it.", "startOffset": 15, "endOffset": 22}, {"referenceID": 22, "context": "It should be noted at this point that the semantics of types of our language is in some sense a finitary version of the one given in [Wad91], where the denotation of a type of the form \u03c01 \u2192 \u03c02 is the set of all continuous functions from the denotation of \u03c01 to the denotation of \u03c02 (more details on the connections between the two approaches will be given in Section 5.", "startOffset": 133, "endOffset": 140}, {"referenceID": 22, "context": "In this subsection we give a brief comparison of the proposed semantics with the semantics introduced in [Wad91].", "startOffset": 105, "endOffset": 112}, {"referenceID": 22, "context": "A complete presentation of such a comparison would require a detailed presentation of the approach introduced in [Wad91] and its adaptation to the richer language H introduced in this paper.", "startOffset": 113, "endOffset": 120}, {"referenceID": 22, "context": "As already mentioned, the source language considered in [Wad91] is restricted compared to H.", "startOffset": 56, "endOffset": 63}, {"referenceID": 22, "context": "However, the semantics of [Wad91] can be appropriately extended to apply to H as well.", "startOffset": 26, "endOffset": 33}, {"referenceID": 22, "context": "Given a non-empty set D, let us denote by [[\u03c1]]\u2217D the semantics of an argument type \u03c1 in D under the approach of [Wad91].", "startOffset": 113, "endOffset": 120}, {"referenceID": 22, "context": "Roughly speaking, one can say that the semantics of [Wad91] is the logic programming analogue of the standard denotational semantics of functional programming languages [Ten91].", "startOffset": 52, "endOffset": 59}, {"referenceID": 21, "context": "Roughly speaking, one can say that the semantics of [Wad91] is the logic programming analogue of the standard denotational semantics of functional programming languages [Ten91].", "startOffset": 169, "endOffset": 176}, {"referenceID": 22, "context": "In the following, we will refer to the semantics of [Wad91] as the \u201ccontinuous semantics\u201d.", "startOffset": 52, "endOffset": 59}, {"referenceID": 14, "context": "Using exactly the same reasoning as in the first-order case (see for example the corresponding proof in [Llo87]).", "startOffset": 104, "endOffset": 111}, {"referenceID": 2, "context": "In order to simplify matters, we follow the simple approach suggested in [Bar84][pages 26-27], which consists of the following two conventions:", "startOffset": 73, "endOffset": 80}, {"referenceID": 21, "context": "We now have the following Substitution Lemma (see for example [Ten91] for a corresponding lemma in the case of functional programming).", "startOffset": 62, "endOffset": 69}, {"referenceID": 14, "context": "In order to establish the completeness of the proposed SLD-resolution, we need to first demonstrate a result that is analogous to the lifting lemma of the first-order case (see [Llo87]).", "startOffset": 177, "endOffset": 184}, {"referenceID": 1, "context": "We can now prove the analogue of a theorem due to Apt and van Emden (see [Apt90][Lemma 3.", "startOffset": 73, "endOffset": 80}, {"referenceID": 14, "context": "17] or [Llo87][Theorem 8.", "startOffset": 7, "endOffset": 14}, {"referenceID": 11, "context": "The following theorem generalizes a result of Hill [H74] (see also [Apt90][Theorem 3.", "startOffset": 51, "endOffset": 56}, {"referenceID": 1, "context": "The following theorem generalizes a result of Hill [H74] (see also [Apt90][Theorem 3.", "startOffset": 67, "endOffset": 74}, {"referenceID": 8, "context": "Finally, the following theorem is a generalization of Clark\u2019s theorem [Cla79] (see also the more accessible [Apt90][Theorem 3.", "startOffset": 70, "endOffset": 77}, {"referenceID": 1, "context": "Finally, the following theorem is a generalization of Clark\u2019s theorem [Cla79] (see also the more accessible [Apt90][Theorem 3.", "startOffset": 108, "endOffset": 115}, {"referenceID": 22, "context": "Apart from the results of [Wad91]5, the only other work that has come to our attention is that of M.", "startOffset": 26, "endOffset": 33}, {"referenceID": 22, "context": "Bezem [Bez99, Bez01], who considers higher-order logic programming languages with syntax similar to that of [Wad91].", "startOffset": 108, "endOffset": 115}, {"referenceID": 4, "context": "In [Bez01] a notion of extensionality is defined (called the extensional collapse) and it is demonstrated that many logic programs are extensional under this notion; however, this notion appears to differ from classical extensionality and has a more proof-theoretical flavor.", "startOffset": 3, "endOffset": 10}, {"referenceID": 18, "context": "For a more detailed discussion on this issue, see [NM98][section 7.", "startOffset": 50, "endOffset": 56}, {"referenceID": 22, "context": "The work in [Wad91] has also been used in order to define a higher-order extension of Datalog [KRW05].", "startOffset": 12, "endOffset": 19}, {"referenceID": 13, "context": "The work in [Wad91] has also been used in order to define a higher-order extension of Datalog [KRW05].", "startOffset": 94, "endOffset": 101}, {"referenceID": 18, "context": "The semantics of \u03bbProlog is not extensional (see for example the discussion in [NM98]).", "startOffset": 79, "endOffset": 85}, {"referenceID": 18, "context": ", predicate terms) for R that one could think of (see the relevant discussion in [NM98][page 50]).", "startOffset": 81, "endOffset": 87}, {"referenceID": 7, "context": "As remarked in [CKW93], \u201cequality in (a fragment of) \u03bbProlog corresponds to \u03bb-equivalence and is not extensional: there may exist predicates that are not \u03bb-equivalent but still extensionally equal\u201d.", "startOffset": 15, "endOffset": 22}, {"referenceID": 7, "context": "The above program behavior can be best explained by the following comment from [CKW93]: \u201cin HiLog predicates and other higher-order syntactic objects are not equal unless they (ie.", "startOffset": 79, "endOffset": 86}, {"referenceID": 9, "context": "We believe that ideas originating from graph-reduction [FH88] will also prove vital in the development of this extended implementation.", "startOffset": 55, "endOffset": 61}, {"referenceID": 19, "context": "The semantics of negation in a higher-order setting could probably be captured model-theoretically using the recent purely logical characterization of the well-founded semantics through an appropriate infinite-valued logic [RW05].", "startOffset": 223, "endOffset": 229}], "year": 2011, "abstractText": "We propose a purely extensional semantics for higher-order logic programming. In this semantics program predicates denote sets of ordered tuples, and two predicates are equal iff they are equal as sets. Moreover, every program has a unique minimum Herbrand model which is the greatest lower bound of all Herbrand models of the program and the least fixed-point of an immediate consequence operator. We also propose an SLD-resolution proof procedure which is proven sound and complete with respect to the minimum model semantics. In other words, we provide a purely extensional theoretical framework for higher-order logic programming which generalizes the familiar theory of classical (firstorder) logic programming.", "creator": "LaTeX with hyperref package"}}}