{"id": "1106.3498", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Jun-2011", "title": "On the expressive power of unit resolution", "abstract": "This preliminary report addresses the expressive power of unit resolution regarding input data encoded with partial truth assignments of propositional variables. A characterization of the functions that are computable in this way, which we propose to call propagatable functions, is given. By establishing that propagatable functions can also be computed using monotone circuits, we show that there exist polynomial time complexity propagable functions requiring an exponential amount of clauses to be computed using unit resolution. These results shed new light on studying CNF encodings of NP-complete problems in order to solve them using propositional satisfiability algorithms.", "histories": [["v1", "Fri, 17 Jun 2011 14:35:28 GMT  (19kb)", "http://arxiv.org/abs/1106.3498v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.CC", "authors": ["olivier bailleux"], "accepted": false, "id": "1106.3498"}, "pdf": {"name": "1106.3498.pdf", "metadata": {"source": "CRF", "title": "On the expressive power of unit resolution", "authors": ["Olivier Bailleux"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 110 6.34 98v1 [cs.AI] 17 Jun 2011"}, {"heading": "1 Introduction and motivations", "text": "The resolution of the unit is a key feature of modern satellite solutions [13] [7] [5], where it accelerates the search for solutions and inconsistencies. It is well known that different cnf representations of a particular problem do not always allow the same resolution of the unit. This is not the case with the encoding proposed in [16], which does not allow the cnf encoding for pseudo-Boolean limitations to derive as much information as the previous encoding. In some ways, the expressiveness of the resolution of the unit can best be exploited using the encoding proposed in [3], with remarkable consequences for the resolution time. Two important related questions are: \"What information can be derived from the resolution of the unit?\" and \"What clauses are needed to derive this information?\" These questions are strongly linked to the characterization of the application of satellite functions."}, {"heading": "2 Related works", "text": "This year it is so far that it will only be a matter of time before an agreement is reached."}, {"heading": "3 Propagatable functions", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Unit resolution", "text": "This section recalls the terminology and principles contained in the formula of unity, and introduces the notations used in the rest of the formula. (A) The dictionary is either a propositional variable or a negated formula. (A) The formula of the formula is defined as a conjunction c1). (A) The dictionary of clauses, where each clause is a function representing some of the variables in this sentence, is a disjunction of letters. (A) The size of a cnf formula is its number of literal operations. (A) The truth assignment to a set of propositional variables is a function of the variables in this set of truth values, i.e., these variables are fixed to true or false formula. If a truth assignment does not fix all variables, it is said to be partial; otherwise, it is said to be complete. (A) a truth assignment is represented as a set of words."}, {"heading": "3.2 Reified formulae", "text": "In this section, the term matured cnf formula is introduced, which is then used as a tool to test several results.Informally speaking, the matured counterpart to each cnf formula \u03c6 is a satisfactory cnf formula \u03c3 = mature (\u03c6) in such a way that the application of unity resolution to n variables simulates all the conclusions reached by applying unity resolution to true. Let var (\u03c6) denotes the set of variables that are obtained in true. Definition 1 (matured formula with n variables) will be a cnf formula with n variables. The matured counterpart of the p formula is the following formula: \u2022 There are 2n (n + 2) variables that are obtained in truth. Definition 1 (matured formula) is a cnf formula with n variables."}, {"heading": "3.3 Computing with unit resolution", "text": "This section explains how to use unit resolution to calculate functions."}, {"heading": "3.3.1 Definitions and terminology", "text": "Let us be a false formula, var (\u03c6) = false unit, which only works if it does not work when it does not work. Input of data is a partial truth assignment I of the variables in V, i.e., some variables are associated with truth, some are associated with truth, and the others are not associated with it. \u2022 Output can act as a computer in the following way: \u2022 Input of data is a partial truth assignment I of the variables in V, i.e., some variables are associated with truth, and the others are not associated with it. \u2022 Output can take four possible values according to the result of the measure resolution applied: - fail if it does not work, - true if it does not work."}, {"heading": "3.3.2 Propagability versus \u03bd-propagability", "text": "In this section, we will show that reproducible and reproducible adaptation functions have the same expressiveness and similar spatial complexities. Theorem 3. Let f be an adaptation function. f is reproducible if and only if f is reproducible. Proof 1. Let f be a reproducible adaptation function with domain D. f is polynomically reproducible if and only if f is polynomically reproducible. Proof 1. Let f be a reproducible adaptation function with domain D. f is a reproducible adaptation function with domain D, and P = < p, V, s > be a reproductive mechanism that calculates f. Obvious for a partial truth assignment I \u0448D, the application of unity resolution to the formula (s) and the application of unity resolution I."}, {"heading": "3.3.3 Filtering functions versus matching functions", "text": "In this section we will show that without loss of generality, the examination of the spatial complexity of < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "3.3.4 Boolean representations", "text": "Given V = {v1,. < vn} of a set of statement variables, D IV of a set of partial truth assignments of V, f of any function coinciding with domain D, and I of any partial assignment in D, let us define: \u2022 the Boolean representation of I as IB = (x1,.., xn, y1,., yn) - {0, 1} n as for any 1 \u2264 i \u2264 n, xi = 1 if and only if vi-I, and yi = 1 if and only vi-I, \u2022 the Boolean representation of D as DB = {IB, I-D}, \u2022 the Boolean representation of f as fB: DB 7 \u2192 {0, 1}, so that for each I-D, fB (IB) = 1 and only if and only f (I) - (I) = yv0, Example 4. The following table gives an example of a matching function f and its Boolean equivalent vB: v0, vB}, {- 1, fja, {- - 1, B (1) {- B, 1."}, {"heading": "3.4 Synthesis", "text": "In this section, we first introduced the concept of the filter function as a general model of functions that can be calculated by unit resolution, and then we showed that each filter function is reduced to three matching functions that are binary code domain functions ({yes, no} without loss of generality) that can be calculated either by unit resolution in two different ways: (1) unit resolution detects inconsistency if the output value is yes, (2) it sets a predefined output variable to true if the output value is yes. The main result of this section is that without loss of generality, the study of the meaningfulness of unit resolution can be reduced to studying the traceability and complexity of unit resolution matching functions."}, {"heading": "4 Expressive power of propagators", "text": "Using a complete truth assignment as an input value, the resolution of the unit has the same significance as Boolean circuits, since elementary gates can be translated directly into sentences. In this section, we show that if some input variables are not specified, the significance of unit resolution decreases to the significance of monotonous Boolean circuits, i.e. circuits with only or / and gates."}, {"heading": "4.1 Boolean circuits", "text": "A Boolean circuit is a directed acyclic graph representing a Boolean formula, which is said to be monotonous if it contains only and or gates. In the following, a Boolean circuit is represented by a triplet < L, G, w >, where L is a series of input labels, while the output label and G is a group of gates. A or gate (and gate) is the input label of the gate or (E, t) (and (E, t), where E is the input label and t is the output label of the gate. A not gate is not called not (q, t), where q is the input label of the gate and t is its output label.If a Boolean circuit is C = < {e1,., en}, G, w > and each x = (x1, xn) is an arbitrary input label."}, {"heading": "4.2 Circuits computing propagatable functions", "text": "In this section, we will show that any matching function is expandable if and only if its Boolean counterpart can be calculated with a monotone circuit. Furthermore, we will establish a relationship between the spatial complexity of propagatable matching functions and monoton circuits, which each have only one monoton circuit with the most k inputs that calculate fB, then there is a propagator with O (nk) clauses, the f.Proof. Let us assume that the number of input labels is from L = {v1,., vn} and any monoton circuit Q = < L, uk > Calculation of fB.Without loss of generality, let us assume that the number of input labels is from L = {v1,."}, {"heading": "5 Synthesis and perspectives", "text": "The results of this study provide important information about the expressiveness of unit resolution. In particular, we can show that there is a polynomial time complexity that only allows propagators with an exponential number of clauses. As an example, we consider the Boolean functions pm (n), so for each n-bit Boolean encoding G, pm (n) = 1 if and only if there is a perfect association for G that exactly covers each vertex. Next, we look at the variants vpm (n) so that the domain Dvpm (n) is of vpm (n)."}], "references": [{"title": "GAC via unit propagation", "author": ["Fahiem Bacchus"], "venue": "Notes in Computer Science,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Efficient cnf encoding of boolean cardinality constraints", "author": ["Olivier Bailleux", "Yacine Boufkhad"], "venue": "In Proceedings of the 9th International Conference on Principles and Practice of Constraint Programming", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2003}, {"title": "A translation of pseudo boolean constraints to sat", "author": ["Olivier Bailleux", "Yacine Boufkhad", "Olivier Roussel"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "New encodings of pseudo-boolean constraints into cnf", "author": ["Olivier Bailleux", "Yacine Boufkhad", "Olivier Roussel"], "venue": "In Theory and Applications of Satisfiability Testing - SAT 2009 (SAT\u201909),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "An extensible sat-solver", "author": ["Niklas E\u00e9n", "Niklas So\u00f6rensson"], "venue": "In Proceedings of SAT", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Arc consistency in sat", "author": ["Ian P. Gent"], "venue": "In Proceedings of ECAI 2002,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2002}, {"title": "Berkmin: A fast and robust sat solver", "author": ["E. Goldberg", "Y. Novikov"], "venue": "In Proc. of DATE", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "The monotone and planar circuit value problems are log space complete for p", "author": ["Leslie M. Goldschlager"], "venue": "SIGACT News,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1977}, {"title": "Unit refutations and horn sets", "author": ["L. Henschen", "L. Wos"], "venue": "J. ACM,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1974}, {"title": "Complete problems for deterministic polynomial time", "author": ["Neil D. Jones", "William T. Laaser"], "venue": "Theoretical Computer Science,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1976}, {"title": "Look-ahead versus look-back for satisfiability problems", "author": ["Chu Li", "Anbulagan"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1997}, {"title": "Towards robust cnf encodings of cardinality constraints", "author": ["Joao Marques-Silva", "In\u00eas Lynce"], "venue": "In Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Chaff: Engineering an efficient sat solver", "author": ["M. Moskewicz", "C. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "In 39th Design Automation Conference,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2001}, {"title": "Towards an optimal cnf encoding of boolean cardinality constraints", "author": ["Carsten Sinz"], "venue": "In Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2005}, {"title": "The gap between the monotone and non monotone circuit complexity is exponential", "author": ["E. Tardos"], "venue": null, "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1988}, {"title": "A linear-time transformation of linear inequalities into conjunctive normal form", "author": ["J.P. Warners"], "venue": "Information Processing Letters,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1998}], "referenceMentions": [{"referenceID": 12, "context": "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.", "startOffset": 65, "endOffset": 69}, {"referenceID": 6, "context": "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.", "startOffset": 70, "endOffset": 73}, {"referenceID": 4, "context": "Unit resolution is a key feature of state of the art sat solvers [13] [7] [5], where it speeds up the search for solutions and inconsistencies.", "startOffset": 74, "endOffset": 77}, {"referenceID": 2, "context": "For example, the cnf encoding for pseudo Boolean constraints proposed in [3] allows unit resolution to restore generalized arc consistency.", "startOffset": 73, "endOffset": 76}, {"referenceID": 15, "context": "This is not the case with the encoding proposed in [16], which does not allow unit resolution to deduce as much information as the former encoding does.", "startOffset": 51, "endOffset": 55}, {"referenceID": 2, "context": "As a manner of speaking, the expressive power of unit resolution is best exploited using the encoding proposed in [3], with notable consequences on the resolution time.", "startOffset": 114, "endOffset": 117}, {"referenceID": 8, "context": "For example, this property holds for the formulae containing only Horn clauses [9].", "startOffset": 79, "endOffset": 82}, {"referenceID": 9, "context": "This decision problem denoted unit is known to be p-complete, meaning that for any problem \u03c0 with polynomial time complexity, there exists a log space reduction from \u03c0 to unit [10].", "startOffset": 176, "endOffset": 180}, {"referenceID": 7, "context": "Circuit value and monotone circuit value, which consist to determine the output value of a Boolean circuit (monotone Boolean circuit, respectively), given its input values, are both p-complete too [8].", "startOffset": 197, "endOffset": 200}, {"referenceID": 14, "context": "In this context, circuit value and monotone circuit value have not the same expressive power for at least two reasons : (1) monotone circuits can only compute monotone Boolean functions, while any Boolean function can be computed using a general Boolean circuit, and (2) there exist monotone Boolean functions which can be computed by polynomially sized Boolean circuits, but requiring an exponential number of gates to be computed using monotone circuits [15].", "startOffset": 456, "endOffset": 460}, {"referenceID": 5, "context": "In [6], a cnf encoding for enumerative constraints is proposed, which allows unit propagation to make the same deductions on the resulting formula as restoring arc consistency on the initial constraints does.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.", "startOffset": 116, "endOffset": 119}, {"referenceID": 3, "context": "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.", "startOffset": 151, "endOffset": 154}, {"referenceID": 0, "context": "It has been followed by various similar works on other kinds of constraints such as Boolean cardinality constraints [2] and pseudo-Boolean constraints [4], while in [1], a general way to construct such an encoding for any constraint is proposed.", "startOffset": 165, "endOffset": 168}, {"referenceID": 10, "context": "This is why some authors seek a trade-off between the size of the formulae and the inference power of unit resolution and other deduction rules implemented in sat solvers, such as the failed literal rule [11].", "startOffset": 204, "endOffset": 208}, {"referenceID": 13, "context": "For example, this approach is developed in [14] and [12] in the context of Boolean cardinality constraints.", "startOffset": 43, "endOffset": 47}, {"referenceID": 11, "context": "For example, this approach is developed in [14] and [12] in the context of Boolean cardinality constraints.", "startOffset": 52, "endOffset": 56}, {"referenceID": 10, "context": "As an interesting corollary of Theorem 1, the failed literal rule [11], which is a speed up technique implemented in some modern sat solver, can be simulated by unit propagation.", "startOffset": 66, "endOffset": 70}, {"referenceID": 14, "context": "It is known that pm(n), then vpm(n), have polynomial time computational complexity but exponential monotone circuit complexity [15].", "startOffset": 127, "endOffset": 131}], "year": 2013, "abstractText": "This preliminary report addresses the expressive power of unit resolution regarding input data encoded with partial truth assignments of propositional variables. A characterization of the functions that are computable in this way, which we propose to call propagatable functions, is given. By establishing that propagatable functions can also be computed using monotone circuits, we show that there exist polynomial time complexity propagable functions requiring an exponential amount of clauses to be computed using unit resolution. These results shed new light on studying cnf encodings of np-complete problems in order to solve them using propositional satisfiability algorithms. A paper is being drafted, which aims to present the concepts introduced in the present report and the underlying scientific issues in a more simple way.", "creator": "LaTeX with hyperref package"}}}