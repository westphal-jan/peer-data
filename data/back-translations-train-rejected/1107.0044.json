{"id": "1107.0044", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Towards Understanding and Harnessing the Potential of Clause Learning", "abstract": "Efficient implementations of DPLL with the addition of clause learning are the fastest complete Boolean satisfiability solvers and can handle many significant real-world problems, such as verification, planning and design. Despite its importance, little is known of the ultimate strengths and limitations of the technique. This paper presents the first precise characterization of clause learning as a proof system (CL), and begins the task of understanding its power by relating it to the well-studied resolution proof system. In particular, we show that with a new learning scheme, CL can provide exponentially shorter proofs than many proper refinements of general resolution (RES) satisfying a natural property. These include regular and Davis-Putnam resolution, which are already known to be much stronger than ordinary DPLL. We also show that a slight variant of CL with unlimited restarts is as powerful as RES itself. Translating these analytical results to practice, however, presents a challenge because of the nondeterministic nature of clause learning algorithms. We propose a novel way of exploiting the underlying problem structure, in the form of a high level problem description such as a graph or PDDL specification, to guide clause learning algorithms toward faster solutions. We show that this leads to exponential speed-ups on grid and randomized pebbling problems, as well as substantial improvements on certain ordering formulas.", "histories": [["v1", "Thu, 30 Jun 2011 20:39:28 GMT  (264kb)", "http://arxiv.org/abs/1107.0044v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["p beame", "h kautz", "a sabharwal"], "accepted": false, "id": "1107.0044"}, "pdf": {"name": "1107.0044.pdf", "metadata": {"source": "CRF", "title": "Towards Understanding and Harnessing the Potential of Clause Learning", "authors": ["Paul Beame", "Henry Kautz", "Ashish Sabharwal"], "emails": ["beame@cs.washington.edu", "kautz@cs.washington.edu", "ashish@cs.washington.edu"], "sections": [{"heading": "1. Introduction", "text": "In fact, most of them are able to survive on their own if they do not put themselves in a position to survive on their own."}, {"heading": "2. Preliminaries", "text": "It is natural to think of F as a set of clauses and each clause as a set of words. A clause that is a subset of another is called a subclause. F is the number of clauses in F. Let's call F a partial mapping to the variables of F. The limited formula F is obtained from F by replacing variables in B with their assigned values. F is called simplified when all clauses with at least one true dictionary are deleted and all occurrences of wrong dictionaries are removed from the clauses."}, {"heading": "2.2 Proof Systems", "text": "A Propositional Proof System (Cook & Reckhow, 1977) is a polynomial temporally calculable predicate S, so a Propositional Formula F is unsatisfactory if there is a proof p for which S (F, p) applies. In other words, it is an efficient method (in the size of the proof) to verify the correctness of proofs in a particular format. However, finding short proofs can still be difficult. In fact, the complexity of F in S, which is referred to as CS (F), can be the length of the shortest refutation of F in S. For a family {Fn} of formulas over an increasing number of variables n, the complexity of F in S, when referred to as CS (F), is the length of the shortest refutation of F in S."}, {"heading": "2.3 Resolution", "text": "Resolution (RES) is a widely studied simple system of proof that can be used to prove the dissatisfaction of CNF formulas. Our complexity results in terms of the power of clause learning are related to this system. The resolution rule states that the given clauses (A-x) and (B-x), which we can derive either from a clause (A-B) by deriving the resolution rule of C from a CNF formula F, is a derivation rule \u03c0 = (C1, C2,., Cs-C), with each clause Ci being either a clause of F (an initial clause) or a derivation rule of F (an initial clause). We assume that each clause of F = C is used in relation to resolution."}, {"heading": "2.4 Clause Learning", "text": "Learning clauses (see e.g. Marques-Silva & Sakallah, 1996) can be thought of as an extension of the DPLL process, which stores causes of failure in the form of learned clauses; it follows the normal branching process of the DPLL until there is a \"conflict\" after unity has spread; if this conflict occurs, when no variable is currently branched, the formula is declared unsatisfactory; otherwise, the \"conflict graph\" is analyzed and the \"cause\" of the conflict is learned in the form of a \"conflict clause.\" The process now goes back and continues as in the ordinary DPLL and treats the learned clause in the same way as the initial clause; a clause should be known at some point in time if it is either a starting clause or was learned beforehand; the learning process should prevent us from repeating the same calculation if we later have a task that causes conflicts as Baykets."}, {"heading": "2.5 Pebbling Formulas", "text": "In fact, most people who have chosen such a policy are also able to reactivate themselves."}, {"heading": "3. A Formal Framework for Studying Clause Learning", "text": "Although many SAT approaches have been proposed on the basis of clause learning and have proved empirically successful, a theoretical discussion of the underlying concepts and structures required for our analysis is lacking. This section focuses on this formal framework."}, {"heading": "3.1 Unit Propagation and Decision Levels", "text": "In this context, it is convenient to work with residual formulas at different stages of the DPLL. Let us call the partial assignment of variables to formula F. The residual formula at this stage is achieved by applying one-size-fits-all formulas to the simplified formula F. When using one-size-fits-all formulas, variables that are assigned by the actual branching process are called decision variables and these assigned values as a result of the spread of unity are called implicit variables. Decision and implicit literals are defined analogously. After traceability, the last decision variable no longer remains a decision variable and could instead become an implicit variable, depending on the clauses learned so far. The decision level of a decision variable is one more than the number of current decision variables when the last decision variable at the decision level is no longer a decision variable at the decision level."}, {"heading": "3.2 Branching Sequence", "text": "We use the term branching sequence to demonstrate an exponential separation between DPLL and clause learning. It generalizes the idea of a static variable order by distinguishing the order from branch to branch within the underlying DPLL procedure. It also determines which branch (true or false) needs to be examined first. This can be clearly useful for satisfactory formulas, and can also be helpful for unsatisfactory formulas by allowing the algorithm to learn meaningful clauses earlier in the process. Definition 3. A branching sequence for a CNF formula F is a sequence \u03c3 = (l1, l2,..., lk) of literals of F, possibly with repetitions. A DPLL-based algorithm A to F branches according to its definition, if it always selects the next variable v to branch in the literal order of F, is a branching clause that is assigned to branch when it jumps to branch v, and if it currently jumps to branch v."}, {"heading": "3.3 Clause Learning Proofs", "text": "If a given CNF formula F is unsatisfactory, clause learning ends with a decision-level zero conflict. Since all clauses used in this final conflict themselves follow directly or indirectly from F, this failure of clause learning in the search for a satisfactory task provides logical proof of the dissatisfaction of F. We refer to CL as the system of proof consisting of all such evidence. Our limitations compare the sizes of the evidence in CL with the sizes of the (possibly limited) resolution evidence. Remember that clause learning algorithms can use one of many learning schemes, leading to different evidences. Definition 5. Clause learning (CL) is evidence that an unsatisfactory CNF formula F is produced under the learning scheme S and by branching the sequence component distribution to F."}, {"heading": "3.4 Implication Graph and Conflicts", "text": "The implication graph G at a certain stage of the DPLL is an implicit graph with implicit edges labeled with sets of clauses. It is constructed as follows: 1. Create a node for each decision literally, labeled with this letter. This becomes the indegree zero source node of G.2. While there is a known sentence C = (l1), it contains a conflict as follows: 1. Create a node for each decision literally, labeled with this letter. (a) Add a node with l if it is not already present in G. (l, l) Add edges (l, l), 1 \u2264 i \u2264 k if they are not already present. (c) Add C to the label variant of these edges. These edges are considered valorized and associated with clause C.3. Add a special node to G."}, {"heading": "3.4.1 Conflict clauses", "text": "Look at the implication graph in a phase where there is a conflict and correct a conflict graph contained in that implication graph. Select an intersection in the conflict graph that has all the decision variables on one side, the so-called rational side, and also at least one conflict literally on the other side, the conflict side. All nodes on the rational side where at least one edge goes to the conflict side form a cause of the conflict. The denial of the corresponding literals forms the conflict clause associated with that intersection."}, {"heading": "3.5 Trivial Resolution and Learned Clauses", "text": "It is a trivial derivative that includes a trivial derivative of a clause that includes a trivial derivative of a clause, as well as a trivial derivative of a clause from a clause that includes a trivial derivative of a clause. It is a trivial derivative of a clause that propagates from F / F all the letters of C to a conflict by one entity. Proof. Let it be a trivial derivative of C. Let it be Ck = (l1) and the partial derivative."}, {"heading": "3.6 Different Learning Schemes", "text": "It is instructive to think of the non-deterministic scheme as the most general learning scheme. Here, we select the intersection non-deterministically and, whenever possible, select one whose associated clause is not yet known. Since we can repeatedly branch to the same last variable, non-deterministic learning summarizes several clauses from a single conflict as long as the sets of nodes on the rational side of the corresponding intersections form a (set-wise) decreasing sequence. For simplicity, we assume that only one clause is learned from each conflict. In practice, however, we apply variable schemes. The decision scheme (Zhang et al., 2001) uses the intersection whose sequence of reasoning decreases."}, {"heading": "3.6.1 The FirstNewCut Scheme", "text": "We propose a new tutorial called FirstNewCut, whose ease of analysis helps us demonstrate the power of clause learning. We would like to point out that we only use this tutorial to prove our theoretical limitations using certain formulas, its effectiveness to other formulas has certainly not been studied yet. We would also like to point out that the experimental results in this paper are for the 1UIP tutorial, but can also be extended to certain other schemes, including FirstNewCut.The key idea behind FirstNewCut is to make the conflict clause as relevant to the current conflict as possible by choosing a cut near the conflict letters. This is what the FirstUIP scheme also tries to achieve in a slightly different way. For the following definitions, fix a cut in a conflict diagram and let S be the row of nodes on the reason side that have an advantage for some nodes on the conflict side."}, {"heading": "3.7 Fast Backtracking and Restarts", "text": "Most clause learning algorithms use fast backtracking or conflict-oriented backjumping, in which the conflict diagram is used to undo not only the last branching decision, but also all other recent decisions that have not contributed to the current conflict (Stallman & Sussman, 1977). Specifically, the SAT solver zChaff, which we use for our experiments, goes back to decision level zero when learning a unity clause. This property affects the structure of the sequence generation algorithm presented in Section 6.1.1.1. More specifically, the level at which a clause learning algorithm traces this technique is one less than the maximum of the decision layers of all decision variables (i.e. the sources of conflict) present in the underlying conflict formula. Note that the current conflict sequence sequence clauses previously learned as a result of the branching of the apparently redundant variables can use sequence sequence, which is not a good sequence sequence sequence in general terms."}, {"heading": "4.1 The Proof Trace Extension", "text": "The final step in this process is to answer the question of whether there can be a solution at all if a formula for a short-term RES extension (F, p) contains all the initial clauses of F together with a trace clause (F, p) for each clause C (S) and each new x clause x (C). We first show that if a formula has a short-term RES extension, then the corresponding evidence for an extension of the CL is detectable. Intuitively, the new trace variables allow us to simulate each solution step of the original evidence without worrying about additional branches remaining after a derivative clauses. Lemma"}, {"heading": "5. Clause Learning and General Resolution", "text": "We start with this section by showing that CL evidence, regardless of the learning scheme, the branching strategy or the restarts, is not structurally influenced. We start with this section by showing that CL evidence, regardless of the branching strategy or the branching strategy, is not structurally enough to be efficiently simulated by RES. Conversely, we show that CL evidence for each formula F via n variables and CL with each learning scheme and each number of restarts can efficiently simulate RES in its full universality. The variation refers to the variables that can be applied to the branching of F. An RES proof can be constructed by sequentially deriving all clauses that comprise the empty clause. From position 4, all these derivatives are trivial and each require n steps."}, {"heading": "6. From Analysis to Practice", "text": "The limits of complexity set out in the preceding sections indicate that learning clauses is potentially very powerful, especially when compared to the ordinary DPLL. However, natural decisions, such as the conflict graph to be selected, what intersection to take into account, in what order variables branch, and when to restart, make the process highly non-deterministic. These decisions must be made deterministically (or randomly) when implementing a clauses learning algorithm. In order to exploit its full potential in a particular problem area, it is particularly necessary to implement a learning scheme and an industry-specific decision process that is appropriate for that area."}, {"heading": "6.1 Solving Pebbling Formulas", "text": "It's about the future of humanity, and it's about the future of humanity. It's about the future of humanity, \"he says,\" it's about the future. \"\" It's about the future. \"\" It's about the future. \"\" It's about the future. \"\" It's about the future. \"\" It's about the future. \"\" It's about the future. \"\" It's about the future. \"\" \"It's about the future.\" \"\" It's about the future. \"\" \"It's about the future.\" \"\" It's about the future. \"\" \"It's about the future.\" \"It's about the future.\" \"It's about the future.\" \"It's about the future.\" \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\" It's about the future. \"It's about the future.\""}, {"heading": "6.1.2 Complexity of Sequence Generation", "text": "The best case is if G is the network graphic, in PblG (l + d) ld, that the size of the CNF formula itself increases exponentially with the indegree size, and that we approximate the indegree size of the Pebbel formula PblG. (The best case is if G is the network graphic, where PblG (n) and PblG (n).D This is the best case if G is the network graphic, where the PblG formula exponentially increases with the indegree size. (The best case is if G is the network graphic, where PblG (n).D This explains the degradation of the CNF formula itself with the indegree size. (The best case is if G is the network graphic, where PblG). (n) This is the best case if G is the network graphic, where PblG (n)."}, {"heading": "6.3 Experimental Results", "text": "We conducted experiments on a Linux machine with a 1600 MHz AMD Athelon processor, 256 KB cache and 1024 MB RAM. The time limit was set at 6 hours and the memory limit at 512 MB; the program was set to abort as soon as one of the two was exceeded. We took the base code from zChaff (Moskewicz et al., 2001), version 2001.6.15, and modified it to include a branch sequence given as part of the input, along with a CNF formula. If an incomplete branch sequence is specified that is exhausted before a satisfactory match is found, or the formula proves unsatisfactory, the code returns to zChaff's standard variable VSIDS. For consistency, we analyzed performance with random reboots. For all other parameters, we used the default values of Chazff."}, {"heading": "7. Conclusion", "text": "This year it is more than ever before."}, {"heading": "Acknowledgments", "text": "The authors would like to thank the anonymous arbitrators for providing useful comments and for pointing out the existence of short tree-like RES (k) evidence of silica formulas. This research was supported by NSF grant ITR-0219468 and parts of this paper have already appeared at the IJCAI '03 and SAT' 03 conferences (Beame et al., 2003b; Sabharwal et al., 2003)."}], "references": [{"title": "A sharp threshold in proof complexity", "author": ["D. Achlioptas", "P. Beame", "M. Molloy"], "venue": "In Proceedings of the Thirty-Third Annual ACM Symposium on Theory of Computing,", "citeRegEx": "Achlioptas et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Achlioptas et al\\.", "year": 2001}, {"title": "An exponential separation between regular and general resolution", "author": ["M. Alekhnovich", "J. Johannsen", "T. Pitassi", "A. Urquhart"], "venue": "In Proceedings of the Thirty-Fourth Annual ACM Symposium on Theory of Computing,", "citeRegEx": "Alekhnovich et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Alekhnovich et al\\.", "year": 2002}, {"title": "Solving difficult SAT instances in the presence of symmetry", "author": ["F.A. Aloul", "A. Ramani", "I.L. Markov", "K.A. Sakallah"], "venue": "In Proceedings of the 39th Design Automation Conference,", "citeRegEx": "Aloul et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Aloul et al\\.", "year": 2002}, {"title": "Partition-based logical reasoning", "author": ["E. Amir", "S.A. McIlraith"], "venue": "In Proceedings of the 7th International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "Amir and McIlraith,? \\Q2000\\E", "shortCiteRegEx": "Amir and McIlraith", "year": 2000}, {"title": "On the automatizability of resolution and related propositional proof systems", "author": ["A. Atserias", "M.L. Bonet"], "venue": "In CSL \u201902: 16th Workshop on Computer Science Logic,", "citeRegEx": "Atserias and Bonet,? \\Q2002\\E", "shortCiteRegEx": "Atserias and Bonet", "year": 2002}, {"title": "BDD variable orderings for interacting finite state machines", "author": ["A. Aziz", "S. Tasiran", "R.K. Brayton"], "venue": "In Proceedings of the 31th Design Automation Conference,", "citeRegEx": "Aziz et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Aziz et al\\.", "year": 1994}, {"title": "Using randomization and learning to solve hard real-world instances of satisfiability", "author": ["L. Baptista", "J.P.M. Silva"], "venue": "In 6th Principles and Practice of Constraint Programming,", "citeRegEx": "Baptista and Silva,? \\Q2000\\E", "shortCiteRegEx": "Baptista and Silva", "year": 2000}, {"title": "Using CST look-back techniques to solve realworld SAT instances", "author": ["R.J. Bayardo Jr.", "R.C. Schrag"], "venue": "In Proceedings,", "citeRegEx": "Jr. and Schrag,? \\Q1997\\E", "shortCiteRegEx": "Jr. and Schrag", "year": 1997}, {"title": "Memoization and DPLL: Formula caching proof systems", "author": ["P. Beame", "R. Impagliazzo", "T. Pitassi", "N. Segerlind"], "venue": "In Proceedings 18th Annual IEEE Conference on Computational Complexity,", "citeRegEx": "Beame et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2003}, {"title": "Understanding the power of clause learning", "author": ["P. Beame", "H. Kautz", "A. Sabharwal"], "venue": "In Proceedings of the 18th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Beame et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2003}, {"title": "Near-optimal separation of treelike and general resolution", "author": ["E. Ben-Sasson", "R. Impagliazzo", "A. Wigderson"], "venue": "Tech. rep. TR00-005,", "citeRegEx": "Ben.Sasson et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Ben.Sasson et al\\.", "year": 2000}, {"title": "Symbolic model checking using SAT procedures instead of BDDs", "author": ["A. Biere", "A. Cimatti", "E.M. Clarke", "M. Fujita", "Y. Zhu"], "venue": "In Proceedings of the 36th Design Automation Conference,", "citeRegEx": "Biere et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Biere et al\\.", "year": 1999}, {"title": "Symbolic model checking without BDDs", "author": ["A. Biere", "A. Cimatti", "E.M. Clarke", "Y. Zhu"], "venue": "In 5th International Conference on Tools and Algorithms for the Construction and Analysis of Systems,", "citeRegEx": "Biere et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Biere et al\\.", "year": 1999}, {"title": "On the relative complexity of resolution refinements and cutting planes proof systems", "author": ["M.L. Bonet", "J.L. Esteban", "N. Galesi", "J. Johansen"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Bonet et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Bonet et al\\.", "year": 2000}, {"title": "Optimality of size-width tradeoffs for resolution", "author": ["M.L. Bonet", "N. Galesi"], "venue": "Computational Complexity,", "citeRegEx": "Bonet and Galesi,? \\Q2001\\E", "shortCiteRegEx": "Bonet and Galesi", "year": 2001}, {"title": "A simplifier for propositional formulas with many binary clauses", "author": ["R.I. Brafman"], "venue": "In Proceedings of the 17th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Brafman,? \\Q2001\\E", "shortCiteRegEx": "Brafman", "year": 2001}, {"title": "The complexity of resolution refinements", "author": ["J. Buresh-Oppenheim", "T. Pitassi"], "venue": "In 18th Annual IEEE Symposium on Logic in Computer Science,", "citeRegEx": "Buresh.Oppenheim and Pitassi,? \\Q2003\\E", "shortCiteRegEx": "Buresh.Oppenheim and Pitassi", "year": 2003}, {"title": "The relative efficiency of propositional proof systems", "author": ["S.A. Cook", "R.A. Reckhow"], "venue": "Journal of Symbolic Logic,", "citeRegEx": "Cook and Reckhow,? \\Q1977\\E", "shortCiteRegEx": "Cook and Reckhow", "year": 1977}, {"title": "A machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Communications of the ACM,", "citeRegEx": "Davis and Putnam,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam", "year": 1960}, {"title": "Diagnostic reasoning based on structure and behavior", "author": ["R. Davis"], "venue": "Artificial Intelligence,", "citeRegEx": "Davis,? \\Q1984\\E", "shortCiteRegEx": "Davis", "year": 1984}, {"title": "Diagnosing multiple faults", "author": ["J. de Kleer", "B.C. Williams"], "venue": "Artificial Intelligence,", "citeRegEx": "Kleer and Williams,? \\Q1987\\E", "shortCiteRegEx": "Kleer and Williams", "year": 1987}, {"title": "On the complexity of resolution with bounded conjunctions", "author": ["J.L. Esteban", "N. Galesi", "J. Messner"], "venue": "InAutomata, Languages, and Programming: 29th International Colloquium,", "citeRegEx": "Esteban et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Esteban et al\\.", "year": 2002}, {"title": "The use of design descriptions in automated diagnosis", "author": ["R. Genesereth"], "venue": "Artificial Intelligence,", "citeRegEx": "Genesereth,? \\Q1984\\E", "shortCiteRegEx": "Genesereth", "year": 1984}, {"title": "Dependent and independent variables in propositional satisfiability", "author": ["E. Giunchiglia", "M. Maratea", "A. Tacchella"], "venue": "In Proceedings of the 8th European Conference on Logics in Artificial Intelligence (JELIA),", "citeRegEx": "Giunchiglia et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2002}, {"title": "Boosting combinatorial search through randomization", "author": ["C.P. Gomes", "B. Selman", "H. Kautz"], "venue": "In Proceedings,", "citeRegEx": "Gomes et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 1998}, {"title": "Randomization in backtrack search: Exploiting heavy-tailed profiles for solving hard scheduling problems", "author": ["C.P. Gomes", "B. Selman", "K. McAloon", "C. Tretkoff"], "venue": "In Proceedings of the 4th International Conference on Artificial Intelligence Planning Systems,", "citeRegEx": "Gomes et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 1998}, {"title": "The intractability of resolution", "author": ["A. Haken"], "venue": "Theoretical Computer Science,", "citeRegEx": "Haken,? \\Q1985\\E", "shortCiteRegEx": "Haken", "year": 1985}, {"title": "Design of experiments in BDD variable ordering: Lessons learned", "author": ["J.E. Harlow", "F. Brglez"], "venue": "In Proceedings of the International Conference on Computer Aided Design,", "citeRegEx": "Harlow and Brglez,? \\Q1998\\E", "shortCiteRegEx": "Harlow and Brglez", "year": 1998}, {"title": "Cliques, Coloring and Satisfiability: Second DIMACS Implementation Challenge, Vol. 26 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science. AMS", "author": ["D.S. Johnson", "M.A. Trick"], "venue": null, "citeRegEx": "Johnson and Trick,? \\Q1996\\E", "shortCiteRegEx": "Johnson and Trick", "year": 1996}, {"title": "Planning as satisfiability", "author": ["H.A. Kautz", "B. Selman"], "venue": "In Proceedings of the 10th European Conference on Artificial Intelligence,", "citeRegEx": "Kautz and Selman,? \\Q1992\\E", "shortCiteRegEx": "Kautz and Selman", "year": 1992}, {"title": "Pushing the envelope: Planning, propositional logic, and stochastic search", "author": ["H.A. Kautz", "B. Selman"], "venue": "In Proceedings,", "citeRegEx": "Kautz and Selman,? \\Q1996\\E", "shortCiteRegEx": "Kautz and Selman", "year": 1996}, {"title": "Explorations of sequential ATPG using boolean satisfiability", "author": ["H. Konuk", "T. Larrabee"], "venue": "In 11th VLSI Test Symposium,", "citeRegEx": "Konuk and Larrabee,? \\Q1993\\E", "shortCiteRegEx": "Konuk and Larrabee", "year": 1993}, {"title": "On the weak pigeonhole principle", "author": ["J. Kraj\u0301\u0131\u010dek"], "venue": "Fundamenta Mathematicae,", "citeRegEx": "Kraj\u0301\u0131\u010dek,? \\Q2001\\E", "shortCiteRegEx": "Kraj\u0301\u0131\u010dek", "year": 2001}, {"title": "Short proofs for tricky formulas", "author": ["B. Krishnamurthy"], "venue": "Acta Informatica,", "citeRegEx": "Krishnamurthy,? \\Q1985\\E", "shortCiteRegEx": "Krishnamurthy", "year": 1985}, {"title": "Heuristics based on unit propagation for satisfiability problems", "author": ["C.M. Li"], "venue": "In Proceedings of the 15th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Li,? \\Q1997\\E", "shortCiteRegEx": "Li", "year": 1997}, {"title": "GRASP \u2013 a new search algorithm for satisfiability", "author": ["J.P. Marques-Silva", "K.A. Sakallah"], "venue": "In Proceedings of the International Conference on Computer Aided Design,", "citeRegEx": "Marques.Silva and Sakallah,? \\Q1996\\E", "shortCiteRegEx": "Marques.Silva and Sakallah", "year": 1996}, {"title": "An overview of backtrack search satisfiability algorithms", "author": ["J. Marques-Silva"], "venue": "In 5th International Symposium on Artificial Intelligence and Mathematics,", "citeRegEx": "Marques.Silva,? \\Q1998\\E", "shortCiteRegEx": "Marques.Silva", "year": 1998}, {"title": "Random k-satisfiability problem: From an analytic solution to an efficient algorithm", "author": ["M. M\u00e9zard", "R. Zecchina"], "venue": "Physical Review E,", "citeRegEx": "M\u00e9zard and Zecchina,? \\Q2002\\E", "shortCiteRegEx": "M\u00e9zard and Zecchina", "year": 2002}, {"title": "Chaff: Engineering an efficient SAT solver", "author": ["M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "In Proceedings of the 38th Design Automation Conference,", "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "Recovering and exploiting structural knowledge from cnf formulas", "author": ["R. Ostrowski", "E. Gr\u00e9goire", "B. Mazure", "L. Sais"], "venue": "In 8th Principles and Practice of Constraint Programming,", "citeRegEx": "Ostrowski et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Ostrowski et al\\.", "year": 2002}, {"title": "On the relation between SAT and BDDs for equivalence checking", "author": ["S. Reda", "R. Drechsler", "A. Orailoglu"], "venue": "In Proceedings of the International Symposium on Quality Electronic Design,", "citeRegEx": "Reda et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Reda et al\\.", "year": 2002}, {"title": "Using problem structure for efficient clause learning", "author": ["A. Sabharwal", "P. Beame", "H. Kautz"], "venue": "In Proceedings of the 6th International Conference on Theory and Applications of Satisfiability Testing,", "citeRegEx": "Sabharwal et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Sabharwal et al\\.", "year": 2003}, {"title": "Tuning SAT checkers for bounded model checking", "author": ["O. Shtrichman"], "venue": "In Proceedings of the 12th International Conference on Computer Aided Verification,", "citeRegEx": "Shtrichman,? \\Q2000\\E", "shortCiteRegEx": "Shtrichman", "year": 2000}, {"title": "Forward reasoning and dependency-directed backtracking in a system for computer-aided circuit analysis", "author": ["R. Stallman", "G.J. Sussman"], "venue": "Artificial Intelligence,", "citeRegEx": "Stallman and Sussman,? \\Q1977\\E", "shortCiteRegEx": "Stallman and Sussman", "year": 1977}, {"title": "Effective use of boolean satisfiability procedures in the formal verification of superscalar and vliw microprocessors", "author": ["M. Velev", "R. Bryant"], "venue": "In Proceedings of the 38th Design Automation Conference,", "citeRegEx": "Velev and Bryant,? \\Q2001\\E", "shortCiteRegEx": "Velev and Bryant", "year": 2001}, {"title": "Solving open quasigroup problems by propositional reasoning", "author": ["H. Zhang", "J. Hsiang"], "venue": "In Proceedings of the International Computer Symp.,", "citeRegEx": "Zhang and Hsiang,? \\Q1994\\E", "shortCiteRegEx": "Zhang and Hsiang", "year": 1994}, {"title": "SATO: An efficient propositional prover", "author": ["H. Zhang"], "venue": "In Proceedings of the 14th International Conference on Automated Deduction,", "citeRegEx": "Zhang,? \\Q1997\\E", "shortCiteRegEx": "Zhang", "year": 1997}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.H. Moskewicz", "S. Malik"], "venue": "In Proceedings of the International Conference on Computer Aided Design,", "citeRegEx": "Zhang et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 18, "context": "The most surprising aspect of such relatively recent practical progress is that the best complete satisfiability testing algorithms remain variants of the Davis-Putnam-LogemannLoveland or DPLL procedure (Davis & Putnam, 1960; Davis et al., 1962) for backtrack search in the space of partial truth assignments.", "startOffset": 203, "endOffset": 245}, {"referenceID": 23, "context": "Clause learning grew out of work in AI on explanation-based learning (EBL), which sought to improve the performance of backtrack search algorithms by generating explanations for failure (backtrack) points, and then adding the explanations as new constraints on the original problem (de Kleer & Williams, 1987; Stallman & Sussman, 1977; Genesereth, 1984; Davis, 1984).", "startOffset": 282, "endOffset": 366}, {"referenceID": 20, "context": "Clause learning grew out of work in AI on explanation-based learning (EBL), which sought to improve the performance of backtrack search algorithms by generating explanations for failure (backtrack) points, and then adding the explanations as new constraints on the original problem (de Kleer & Williams, 1987; Stallman & Sussman, 1977; Genesereth, 1984; Davis, 1984).", "startOffset": 282, "endOffset": 366}, {"referenceID": 47, "context": "A series of researchers (Bayardo Jr. & Schrag, 1997; Marques-Silva & Sakallah, 1996; Zhang, 1997; Moskewicz et al., 2001; Zhang et al., 2001) showed that clause learning can be efficiently implemented and used to solve hard problems that cannot be approached by any other technique.", "startOffset": 24, "endOffset": 141}, {"referenceID": 39, "context": "A series of researchers (Bayardo Jr. & Schrag, 1997; Marques-Silva & Sakallah, 1996; Zhang, 1997; Moskewicz et al., 2001; Zhang et al., 2001) showed that clause learning can be efficiently implemented and used to solve hard problems that cannot be approached by any other technique.", "startOffset": 24, "endOffset": 141}, {"referenceID": 48, "context": "A series of researchers (Bayardo Jr. & Schrag, 1997; Marques-Silva & Sakallah, 1996; Zhang, 1997; Moskewicz et al., 2001; Zhang et al., 2001) showed that clause learning can be efficiently implemented and used to solve hard problems that cannot be approached by any other technique.", "startOffset": 24, "endOffset": 141}, {"referenceID": 13, "context": "A basic result in proof complexity is that general resolution, denoted RES, is exponentially stronger than the DPLL procedure (Bonet et al., 2000; Ben-Sasson et al., 2000).", "startOffset": 126, "endOffset": 171}, {"referenceID": 10, "context": "A basic result in proof complexity is that general resolution, denoted RES, is exponentially stronger than the DPLL procedure (Bonet et al., 2000; Ben-Sasson et al., 2000).", "startOffset": 126, "endOffset": 171}, {"referenceID": 0, "context": "Nevertheless, Achlioptas et al. (2001) have shown how negative proof complexity results for unsatisfiable formulas can be used to derive time lower bounds for specific inference algorithms running on satisfiable formulas as well.", "startOffset": 14, "endOffset": 39}, {"referenceID": 37, "context": "It has been previously observed that clause learning can be viewed as adding resolvents to a tree-like proof (Marques-Silva, 1998).", "startOffset": 109, "endOffset": 130}, {"referenceID": 24, "context": "While there has been work on extracting structure after conversion into a CNF formula by exploiting variable dependency (Giunchiglia et al., 2002; Ostrowski et al., 2002), constraint redundancy (Ostrowski et al.", "startOffset": 120, "endOffset": 170}, {"referenceID": 40, "context": "While there has been work on extracting structure after conversion into a CNF formula by exploiting variable dependency (Giunchiglia et al., 2002; Ostrowski et al., 2002), constraint redundancy (Ostrowski et al.", "startOffset": 120, "endOffset": 170}, {"referenceID": 40, "context": ", 2002), constraint redundancy (Ostrowski et al., 2002), symmetry (Aloul et al.", "startOffset": 31, "endOffset": 55}, {"referenceID": 2, "context": ", 2002), symmetry (Aloul et al., 2002), binary clauses (Brafman, 2001), and partitioning (Amir & McIlraith, 2000), using the original higher level description itself to generate structural information is likely to be more effective.", "startOffset": 18, "endOffset": 38}, {"referenceID": 15, "context": ", 2002), binary clauses (Brafman, 2001), and partitioning (Amir & McIlraith, 2000), using the original higher level description itself to generate structural information is likely to be more effective.", "startOffset": 24, "endOffset": 39}, {"referenceID": 43, "context": "The latter approach, despite its intuitive appeal, remains largely unexplored, except for suggested use in bounded model checking (Shtrichman, 2000) and the separate consideration of cause variables and effect variables in planning (Kautz & Selman, 1996).", "startOffset": 130, "endOffset": 148}, {"referenceID": 48, "context": "Our sequence generators work for the 1UIP learning scheme (Zhang et al., 2001), which is one of the best known.", "startOffset": 58, "endOffset": 78}, {"referenceID": 39, "context": "Our empirical results are based on our extension of the popular SAT solver zChaff (Moskewicz et al., 2001).", "startOffset": 82, "endOffset": 106}, {"referenceID": 10, "context": "These formulas, more commonly occurring in theoretical proof complexity literature (Ben-Sasson et al., 2000; Beame et al., 2003a), can be thought of as representing precedence graphs in dependent task systems and scheduling scenarios.", "startOffset": 83, "endOffset": 129}, {"referenceID": 34, "context": "We also report significant gains obtained for the class of GTn formulas which, again, have appeared frequently in proof complexity results (Krishnamurthy, 1985; Bonet & Galesi, 2001; Alekhnovich et al., 2002).", "startOffset": 139, "endOffset": 208}, {"referenceID": 1, "context": "We also report significant gains obtained for the class of GTn formulas which, again, have appeared frequently in proof complexity results (Krishnamurthy, 1985; Bonet & Galesi, 2001; Alekhnovich et al., 2002).", "startOffset": 139, "endOffset": 208}, {"referenceID": 18, "context": "The basic idea of the Davis-Putnam-Logemann-Loveland (DPLL) procedure (Davis & Putnam, 1960; Davis et al., 1962) for testing satisfiability of CNF formulas is to branch on variables, setting them to true or false, until either an initial clause is violated (i.", "startOffset": 70, "endOffset": 112}, {"referenceID": 13, "context": "For instance, regular, linear, positive, negative, semantic, and Davis-Putnam resolution are all known to be exponentially stronger than tree-like resolution (Bonet et al., 2000; Bonet & Galesi, 2001; Buresh-Oppenheim & Pitassi, 2003) whereas tree-like, regular, and Davis-Putnam resolution are known to be exponentially weaker than RES (Bonet et al.", "startOffset": 158, "endOffset": 234}, {"referenceID": 13, "context": ", 2000; Bonet & Galesi, 2001; Buresh-Oppenheim & Pitassi, 2003) whereas tree-like, regular, and Davis-Putnam resolution are known to be exponentially weaker than RES (Bonet et al., 2000; Alekhnovich et al., 2002).", "startOffset": 166, "endOffset": 212}, {"referenceID": 1, "context": ", 2000; Bonet & Galesi, 2001; Buresh-Oppenheim & Pitassi, 2003) whereas tree-like, regular, and Davis-Putnam resolution are known to be exponentially weaker than RES (Bonet et al., 2000; Alekhnovich et al., 2002).", "startOffset": 166, "endOffset": 212}, {"referenceID": 13, "context": "Proposition 2 (Bonet et al., 2000; Alekhnovich et al., 2002).", "startOffset": 14, "endOffset": 60}, {"referenceID": 1, "context": "Proposition 2 (Bonet et al., 2000; Alekhnovich et al., 2002).", "startOffset": 14, "endOffset": 60}, {"referenceID": 48, "context": "Variations of such conflict-driven learning include different ways of choosing the clause to learn (different learning schemes) and possibly allowing multiple clauses to be learned from a single conflict (Zhang et al., 2001).", "startOffset": 204, "endOffset": 224}, {"referenceID": 47, "context": "In the last decade, many algorithms based on this idea have been proposed and demonstrated to be empirically successful on large problems that could not be handled using other methodologies (Bayardo Jr. & Schrag, 1997; Marques-Silva & Sakallah, 1996; Zhang, 1997; Moskewicz et al., 2001).", "startOffset": 190, "endOffset": 287}, {"referenceID": 39, "context": "In the last decade, many algorithms based on this idea have been proposed and demonstrated to be empirically successful on large problems that could not be handled using other methodologies (Bayardo Jr. & Schrag, 1997; Marques-Silva & Sakallah, 1996; Zhang, 1997; Moskewicz et al., 2001).", "startOffset": 190, "endOffset": 287}, {"referenceID": 10, "context": "Pebbling formulas are unsatisfiable CNF formulas whose variations have been used repeatedly in proof complexity to obtain theoretical separation results between different proof systems (Ben-Sasson et al., 2000; Beame et al., 2003a).", "startOffset": 185, "endOffset": 231}, {"referenceID": 10, "context": "The version we will use in this paper is known to be easy for regular resolution but hard for tree-like resolution, and hence for DPLL without learning (Ben-Sasson et al., 2000).", "startOffset": 152, "endOffset": 177}, {"referenceID": 33, "context": "They were first considered by Krishnamurthy (1985) and later used by Bonet and Galesi (2001) to show the", "startOffset": 30, "endOffset": 51}, {"referenceID": 14, "context": "They were first considered by Krishnamurthy (1985) and later used by Bonet and Galesi (2001) to show the", "startOffset": 69, "endOffset": 93}, {"referenceID": 1, "context": "Recently, Alekhnovich et al. (2002) used a variation, called GT \u2032 n, to show an exponential separation between RES and regular resolution.", "startOffset": 10, "endOffset": 36}, {"referenceID": 48, "context": "One can also create learning schemes based on cuts not involving conflict literals at all (Zhang et al., 2001), but the effectiveness of such schemes is not clear.", "startOffset": 90, "endOffset": 110}, {"referenceID": 48, "context": "The decision scheme (Zhang et al., 2001), for example, uses the cut whose reason side comprises all decision variables.", "startOffset": 20, "endOffset": 40}, {"referenceID": 39, "context": "Whereas rel-sat uses the decision variable as the obvious UIP, GRASP (Marques-Silva & Sakallah, 1996) and zChaff (Moskewicz et al., 2001) use FirstUIP, the one that is \u201cclosest\u201d to the conflict variable.", "startOffset": 113, "endOffset": 137}, {"referenceID": 37, "context": "This nice flipping property holds in general for all unique implication points (UIPs) (Marques-Silva & Sakallah, 1996). A UIP of an implication graph is a node at the current decision level d such that any path from the decision variable at level d to the conflict variable as well as its negation must go through it. Intuitively, it is a single reason at level d that causes the conflict. Whereas rel-sat uses the decision variable as the obvious UIP, GRASP (Marques-Silva & Sakallah, 1996) and zChaff (Moskewicz et al., 2001) use FirstUIP, the one that is \u201cclosest\u201d to the conflict variable. GRASP also learns multiple clauses when faced with a conflict. This makes it typically require fewer branching steps but possibly slower because of the time lost in learning and unit propagation. The concept of UIP can be generalized to decision levels other than the current one. The 1UIP scheme corresponds to learning the FirstUIP clause of the current decision level, the 2UIP scheme to learning the FirstUIP clauses of both the current level and the one before, and so on. Zhang et al. (2001) present a comparison of all these and other learning schemes and conclude that 1UIP is quite robust and outperforms all other schemes they consider on most of the benchmarks.", "startOffset": 87, "endOffset": 1092}, {"referenceID": 6, "context": "Note that Baptista and Silva (2000) showed that CL together with restarts is complete.", "startOffset": 10, "endOffset": 36}, {"referenceID": 22, "context": "Proposition 6 (Esteban et al., 2002).", "startOffset": 14, "endOffset": 36}, {"referenceID": 33, "context": "Here RES(k) denotes the extension of RES that allows resolving, instead of clauses, disjunctions of conjunctions of up to k literals (Kraj\u0301\u0131\u010dek, 2001).", "startOffset": 133, "endOffset": 150}, {"referenceID": 39, "context": "We took the base code of zChaff (Moskewicz et al., 2001), version 2001.", "startOffset": 32, "endOffset": 56}, {"referenceID": 27, "context": "On the other hand, the connection with resolution also implies that any problem that contains as a sub-problem a formula that is inherently hard even for RES, such as the pigeonhole principle (Haken, 1985), must be hard for any variant of clause learning.", "startOffset": 192, "endOffset": 205}, {"referenceID": 0, "context": "This, as mentioned in Section 1, can be explained by the idea of Achlioptas et al. (2001): any DPLL based algorithm run on a satisfiable problem instance will take a long time to run precisely when the algorithm encounters an unsatisfiable sub-problem of the original problem on which it must take a long time.", "startOffset": 65, "endOffset": 90}, {"referenceID": 41, "context": "There has been work on using BDD variable orders for DPLL algorithms without learning (Reda et al., 2002).", "startOffset": 86, "endOffset": 105}, {"referenceID": 42, "context": "This research was supported by NSF Grant ITR-0219468 and parts of this paper appeared earlier in IJCAI \u201903 and SAT \u201903 conferences (Beame et al., 2003b; Sabharwal et al., 2003).", "startOffset": 131, "endOffset": 176}], "year": 2011, "abstractText": "Efficient implementations of DPLL with the addition of clause learning are the fastest complete Boolean satisfiability solvers and can handle many significant real-world problems, such as verification, planning and design. Despite its importance, little is known of the ultimate strengths and limitations of the technique. This paper presents the first precise characterization of clause learning as a proof system (CL), and begins the task of understanding its power by relating it to the well-studied resolution proof system. In particular, we show that with a new learning scheme, CL can provide exponentially shorter proofs than many proper refinements of general resolution (RES) satisfying a natural property. These include regular and Davis-Putnam resolution, which are already known to be much stronger than ordinary DPLL. We also show that a slight variant of CL with unlimited restarts is as powerful as RES itself. Translating these analytical results to practice, however, presents a challenge because of the nondeterministic nature of clause learning algorithms. We propose a novel way of exploiting the underlying problem structure, in the form of a high level problem description such as a graph or PDDL specification, to guide clause learning algorithms toward faster solutions. We show that this leads to exponential speed-ups on grid and randomized pebbling problems, as well as substantial improvements on certain ordering formulas.", "creator": "dvips(k) 5.92b Copyright 2002 Radical Eye Software"}}}