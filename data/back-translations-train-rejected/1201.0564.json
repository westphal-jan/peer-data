{"id": "1201.0564", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Jan-2012", "title": "The RegularGcc Matrix Constraint", "abstract": "We study propagation of the RegularGcc global constraint. This ensures that each row of a matrix of decision variables satisfies a Regular constraint, and each column satisfies a Gcc constraint. On the negative side, we prove that propagation is NP-hard even under some strong restrictions (e.g. just 3 values, just 4 states in the automaton, or just 5 columns to the matrix). On the positive side, we identify two cases where propagation is fixed parameter tractable. In addition, we show how to improve propagation over a simple decomposition into separate Regular and Gcc constraints by identifying some necessary but insufficient conditions for a solution. We enforce these conditions with some additional weighted row automata. Experimental results demonstrate the potential of these methods on some standard benchmark problems.", "histories": [["v1", "Tue, 3 Jan 2012 03:30:18 GMT  (95kb)", "http://arxiv.org/abs/1201.0564v1", "Submitted to CPAIOR 2012"]], "COMMENTS": "Submitted to CPAIOR 2012", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["ronald de haan", "nina narodytska", "toby walsh"], "accepted": false, "id": "1201.0564"}, "pdf": {"name": "1201.0564.pdf", "metadata": {"source": "CRF", "title": "The RegularGcc Matrix Constraint", "authors": ["Ronald de Haan", "Nina Narodytska"], "emails": ["Haan@mailbox.tu-dresden.de,", "nina.narodytska@nicta.com.au", "toby.walsh@nicta.com.au"], "sections": [{"heading": null, "text": "ar Xiv: 120 1.05 64v1 [cs.AI] 3J to"}, {"heading": "1 Introduction", "text": "Many such models contain matrices of decision variables [1-3]. Matrix constraints are global constraints that apply to such matrices [4]. For example, the RegularGcc matrix constraint can be used to model roster problems. It ensures that each row of the matrix fulfills a regular constraint (representing the layer rules) and each column fulfills a Gcc constraint (representing the required capacity for each layer). Here, we prove that spreading the RegularGcc constraint is costly, even under very strict constraints. Therefore, as in [5], we look for submethods that force only a limited degree of consistency. These methods are based on necessary conditions that improve propagation via decomposition into separate Regular constraints on the rows, and separate Gcc constraints on the columns. We can increase these necessary conditions by extracting the additional properties by increasing the number of the columns."}, {"heading": "2 Intractable cases", "text": "We are the first to put ourselves in the next category. () We are the first to put ourselves in the next category. () We are the first to put ourselves in the next category. () We are the first to put ourselves in the next category. () We are the first to put ourselves in the second category. () We are the first to put ourselves in the third category. () We are the first to put ourselves in the second category. () We are the second to put ourselves in the third category. () We are the second to put ourselves in the third category. () We are the second to put ourselves in the third category. () We are the first to put ourselves in the second category. () We are the third to put ourselves in the third category. () We are the first to put ourselves in the third category."}, {"heading": "3 Fixed parameter tractable cases", "text": "We have seen that the spread of the RegularGcc matrix is fixed to a single sequence of Q variables. Q-hard self under the strict restriction that either the number of values or the number of columns is limited. But if we have automated the number of columns and the number of columns in the row and column, we finally have a case in which the size of the column is automated # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "4 Some necessary conditions", "text": "We have the opportunity to refer the necessary limitations to the corresponding string terms. We start with some preliminary definitions that we need for our exposure. The multi-cost global limitations are defined as follows: \"We have a sequence X = 2.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"\" We. \"\" \"We.\". \"\" We. \"\" \"We.\". \"\" We. \"\" \"We.\" \"\" \"We.\" \"\". \"\" We. \"\" \"\" We. \".\" \"\" We. \".\" \"\" We. \"\" \"\" We. \"\" \"\" We. \"\" \"\" We. \"\" \"\" We. \"\" \"\" \"We.\". \"\" \"\" \"\" We. \"\" \"\" \"\" We. \"\" \"\""}, {"heading": "5 Evaluation", "text": "This year is the highest in the history of the country."}, {"heading": "6 Conclusions", "text": "We investigated the spread of the RegularGcc matrix constraint. We showed that the spread is NP-hard even under some severe constraints, and also showed two cases where the propagation is tractable by fixed parameters. We also showed how to improve the spread over a decomposition into separate Regular constraints on the rows and Gcc constraints on the columns by identifying some necessary but insufficient conditions. We showed how the use of weighted automats can be advantageous for the row constraints. Experimental results on nurse scheduling problems show the potential of this method."}], "references": [{"title": "Matrix modelling", "author": ["P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of the International Workshop on Modelling and Problem Formulation.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2001}, {"title": "Matrix modelling: Exploiting common patterns in constraint programming", "author": ["P. Flener", "A.M. Frisch", "B.H.Z. Kzlltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of the International Workshop on Reformulating Constraint Satisfaction Problems.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2002}, {"title": "The Cardinality Matrix Constraint", "author": ["J.C. R\u00e9gin", "C.P. Gomes"], "venue": "In Wallace, M., ed.: Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP\u201904). Volume 3258 of Lecture Notes in Computer Science., Springer", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2004}, {"title": "Global matrix constraints", "author": ["George Katsirelos", "C.G.Q. Nina Narodytska", "T. Walsh"], "venue": "Proceedings of the International Workshop on Constraint Modelling and Reformulation.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "On matrices, automata, and double counting", "author": ["N. Beldiceanu", "M. Carlsson", "P. Flener", "J. Pearson"], "venue": "In Lodi, A., Milano, M., Toth, P., eds.: Proceedings of the 7th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR\u201910). Volume 6140 of Lecture Notes in Computer Science., Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Sequencing and Counting with the multicost-regular Constraint", "author": ["J. Menana", "S. Demassey"], "venue": "In van Hoeve, W.J., Hooker, J.N., eds.: Proceedings of the 6th International Conference on Integration of AI and OR Techniques in Constaint Programming for Combinatorial Optimization Problems (CPAIOR\u201909). Volume 5547 of Lecture Notes in Computer Science., Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2009}, {"title": "On the characterization and generation of nurse scheduling problem instances", "author": ["M. Vanhoucke", "B. Maenhout"], "venue": "European Journal of Operational Research 196(2)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2009}, {"title": "Global grammar constraints", "author": ["C.G. Quimper", "T. Walsh"], "venue": "In Benhamou, F., ed.: Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming (CP\u201906). Volume 4204., Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 0, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 1, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 2, "context": "Many such models contain matrices of decision variables [1\u20133].", "startOffset": 56, "endOffset": 61}, {"referenceID": 3, "context": "Matrix constraints are global constraints that apply to such matrices [4].", "startOffset": 70, "endOffset": 73}, {"referenceID": 4, "context": "Therefore, as in [5], we look for partial methods that only enforce a limited level of consistency.", "startOffset": 17, "endOffset": 20}, {"referenceID": 3, "context": "Proof: This follows directly from Observation 2 in [4], and the fact that Gcc over a sequence with fixed size can be encoded in a DFA with polynomially many states.", "startOffset": 51, "endOffset": 54}, {"referenceID": 1, "context": "Enforcing BC on RegularGcc is W[2]-hard in k = R the number of rows, even with just 2 values.", "startOffset": 31, "endOffset": 34}, {"referenceID": 3, "context": "Proof: This proof is similar to the proof of Theorem 3 in [4].", "startOffset": 58, "endOffset": 61}, {"referenceID": 1, "context": "Enforcing BC on the Regular matrix constraint is W[2]-hard in k the number of rows, even with just 2 values.", "startOffset": 50, "endOffset": 53}, {"referenceID": 1, "context": "Enforcing BC on the RegularSum matrix constraint is W[2]hard in k the number of rows, even with just 3 values.", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "Proof: (Sketch) The proof is similar to the proof of Theorem 7 and the proof of Theorem 3 in [4].", "startOffset": 93, "endOffset": 96}, {"referenceID": 0, "context": "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "Note that this result is strictly stronger than the W[1]-hardness proof of enforcing BC on RegularSum in [4].", "startOffset": 105, "endOffset": 108}, {"referenceID": 4, "context": "In fact, we will show how to extend the method of [5] to the (decomposed) setting of multicostRegular constraints on the rows andGcc constraints on the columns.", "startOffset": 50, "endOffset": 53}, {"referenceID": 5, "context": "The multicostRegular global constraint [7] is defined as follows.", "startOffset": 39, "endOffset": 42}, {"referenceID": 4, "context": "We annotate A with counters that represent stretchminlen(v\u0302, n) and stretchmaxlen(v\u0302, n), as described in [5].", "startOffset": 106, "endOffset": 109}, {"referenceID": 5, "context": "In this more general decomposed setting with multicostRegular constraints on the rows, a tractable option for propagation is the algorithm based on a Lagrangian relaxation of the Resource Constrained Shortest Path Problem (RCSPP) from [7].", "startOffset": 235, "endOffset": 238}, {"referenceID": 4, "context": "Consider the following CSP, similar to the one sketched in [5].", "startOffset": 59, "endOffset": 62}, {"referenceID": 4, "context": "Note that definitions (1) and (2) are exactly the same as in [5].", "startOffset": 61, "endOffset": 64}, {"referenceID": 4, "context": "This results in constraints (3) and (4) potentially leading to more propagation than their counterparts in [5].", "startOffset": 107, "endOffset": 110}, {"referenceID": 4, "context": "Note that the constraints from [5] on words occurring as a prefix or as a suffix correspond to particular cases of constraints (3) and (4).", "startOffset": 31, "endOffset": 34}, {"referenceID": 2, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 92, "endOffset": 98}, {"referenceID": 4, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 92, "endOffset": 98}, {"referenceID": 1, "context": "By using equation (3), we can directly detect unsatisfiability in this case, since lw1(\u0175) \u2208 [3, 5] and thus lw1(\u0175) 6\u2264 ( \u2211R\u22121 r=0 z \u0175 r,1) \u2208 [0, 2].", "startOffset": 140, "endOffset": 146}, {"referenceID": 4, "context": "[5]: K\u2212|\u0175| k=0 lwk(\u0175) \u2264 \u2211R\u22121 r=0 z \u0175 r .", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 13, "endOffset": 19}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 30, "endOffset": 36}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 45, "endOffset": 51}, {"referenceID": 2, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 61, "endOffset": 67}, {"referenceID": 4, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 61, "endOffset": 67}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 78, "endOffset": 84}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 93, "endOffset": 99}, {"referenceID": 1, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 109, "endOffset": 115}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 136, "endOffset": 142}, {"referenceID": 4, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 152, "endOffset": 158}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 179, "endOffset": 185}, {"referenceID": 0, "context": "1 1 lw0(\u0175) \u2208 [0, 2] z \u0175 0,1 \u2208 [0, 1] z \u0175 0 \u2208 [0, 1] lw1(\u0175) \u2208 [3, 5] z \u0175 1,1 \u2208 [0, 1] z \u0175 1 \u2208 [0, 1] lw2(\u0175) \u2208 [0, 2] z \u0175 2,1 = 0 z \u0175 2 \u2208 [0, 1] lw3(\u0175) \u2208 [0, 5] z \u0175 3,1 = 0 z \u0175 3 \u2208 [0, 1] lw4(\u0175) = 0 z \u0175 4,1 = 0 z \u0175 4 \u2208 [0, 1]", "startOffset": 217, "endOffset": 223}, {"referenceID": 4, "context": "Definitions (7) through (10) are exactly the same as in [5].", "startOffset": 56, "endOffset": 59}, {"referenceID": 6, "context": "To evaluate our method, we used NSPLib [8], a library of benchmark instances of the nurse scheduling problem (NSP).", "startOffset": 39, "endOffset": 42}, {"referenceID": 4, "context": "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.", "startOffset": 114, "endOffset": 117}, {"referenceID": 7, "context": "For each string property that we extract from the rows, we used automata annotated with counters (as described in [5]), unfolded into a DFA, expressed as a decomposition into ternary constraints [9] allowing us to extract the counter values.", "startOffset": 195, "endOffset": 198}, {"referenceID": 4, "context": "The methods used in [5] for automata annotated with counters are not implemented in the free major constraint programming libraries and solvers.", "startOffset": 20, "endOffset": 23}, {"referenceID": 4, "context": "In the setting of unweighted automata, the necessary constraints are derived as in [5].", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "Note that these benchmarking results are not directly comparable to the results in [5], since these results were obtained under a different experimental set-up (e.", "startOffset": 83, "endOffset": 86}], "year": 2016, "abstractText": "We study propagation of the RegularGcc global constraint. This ensures that each row of a matrix of decision variables satisfies a Regular constraint, and each column satisfies a Gcc constraint. On the negative side, we prove that propagation is NP-hard even under some strong restrictions (e.g. just 3 values, just 4 states in the automaton, or just 5 columns to the matrix). On the positive side, we identify two cases where propagation is fixed parameter tractable. In addition, we show how to improve propagation over a simple decomposition into separate Regular and Gcc constraints by identifying some necessary but insufficient conditions for a solution. We enforce these conditions with some additional weighted row automata. Experimental results demonstrate the potential of these methods on some standard benchmark problems.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}