{"id": "1202.3698", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2012", "title": "Extended Lifted Inference with Joint Formulas", "abstract": "The First-Order Variable Elimination (FOVE) algorithm allows exact inference to be applied directly to probabilistic relational models, and has proven to be vastly superior to the application of standard inference methods on a grounded propositional model. Still, FOVE operators can be applied under restricted conditions, often forcing one to resort to propositional inference. This paper aims to extend the applicability of FOVE by providing two new model conversion operators: the first and the primary is joint formula conversion and the second is just-different counting conversion. These new operations allow efficient inference methods to be applied directly on relational models, where no existing efficient method could be applied hitherto. In addition, aided by these capabilities, we show how to adapt FOVE to provide exact solutions to Maximum Expected Utility (MEU) queries over relational models for decision under uncertainty. Experimental evaluations show our algorithms to provide significant speedup over the alternatives.", "histories": [["v1", "Tue, 14 Feb 2012 16:41:17 GMT  (270kb)", "http://arxiv.org/abs/1202.3698v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["udi apsel", "ronen i brafman"], "accepted": false, "id": "1202.3698"}, "pdf": {"name": "1202.3698.pdf", "metadata": {"source": "CRF", "title": "Extended Lifted Inference with Joint Formulas", "authors": ["Udi Apsel"], "emails": ["apsel@cs.bgu.ac.il", "brafman@cs.bgu.ac.il"], "sections": [{"heading": null, "text": "The First-Order Variable Elimination (FOVE) algorithm enables the direct application of accurate conclusions to probabilistic relational models and has proven to be significantly superior to the application of standard inference methods to a grounded statement model. Nevertheless, FOVE operators can be applied under limited conditions, often forcing one to resort to statement inference. This paper aims to extend the applicability of FOVE by providing two new model conversion operators: the first and the primary is joint formula conversion and the second is simply different count conversion. These new operations enable the direct application of efficient inference methods to relational models where no efficient method has been applied to date. Furthermore, using these capabilities, we demonstrate how FOVE can be adapted to provide accurate solutions for Maximum Expected Utility (MEU) queries on relational models for decisions under uncertainty algorithms to show that there are significant alternatives to experimental evaluations."}, {"heading": "1 Introduction", "text": "In this context, it should be noted that this is a very complex matter."}, {"heading": "2 Model Representation", "text": "Based on the Markov Logic Decision Network (MLDN) [10] and the work of Milch et al. [9], we present a first-order model that describes two types of variables: random variables and decision variables, and two types of factors - probability factors and utility factors."}, {"heading": "2.1 Atoms, Constraints and Parfactors", "text": "Each variable induced by the model corresponds to a basic atom of the form p (c1,.., cn), where p is a predicate of the finite domain, range (p), and c1,.., cn are constant symbols. An atomic formula p (t1,.., tn), where ti is a constant or a logical variable, is called an atom. Each logical variable X is bound by a logical formula (X) with cardinality (X)., or | X |. LV (.) is the set of logical variables referred to by \u03b1, where \u03b1 is a formula or series of formulas. Under a series of logical mappings V, the notation \u03b1 (v) is used to represent the values associated with usefulness. A factor f is a pair (A, \u03b7) consisting of a set of basic formulas well as a potential function."}, {"heading": "2.2 Counting Formulas and Histograms", "text": "The counting formulas express a numerical distribution of values on a portion of the foundations of a formula by counting the number of foundations assigned to each possible value. Instead of covering any possible allocation, the counting formulas ignore the specific permutations corresponding to the counting formulas. The notation of the counting formulas is # X: C [\u03b1], where \u03b1 is the counted atom, X is the counted logical variable, and C is the limitation of the parameter relative to the counted population. Example: Formula # Y: {X # = Y} [Friends (X, Y)] counts the Y population of any arbitrary X in atomic friends (X, Y) under the constraint X \"= Y. The range of a counting formula \u03b3 = # X: C [\u03b1], represented by the range (\u03b3), is a set of all possible histograms. A histogram is a set of non-negative integers corresponding to a particular allocation in the range (\u03b1) in which is the sum X: C."}, {"heading": "3 Joint Formula Conversion", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Definition", "text": "A common formula is a composition of two formulas (atoms or counting formulas) whose assignment range is a cartesian product of the range of their components. Example: j (X, Y) = < a (X, Y), b (Y, X) > describes a common formula of atoms a (X, Y) and b (Y, X) via logical variables Xand Y. If a and b are boolean atoms with a range (a) = (b) = {0, 1}, then reach (j) = {0, 1} \u00d7 {0, 1}, the associated formulas must be of the same type. Namely, both decision formulas or random variable formulas. Common formula conversion is the replacement of all instances of the components of a common formula by the common formula itself (0, 1} \u00d7 {0, 1}. Similar to fragmentation [3] it can be applied at the beginning or during the inference problem."}, {"heading": "3.2 Motivation and Example Applications", "text": "In a sense, the common formula conversion is counterproductive; most lift operators aim to reduce the variable assignment space (> Y factor) or restructure the model without introducing unnecessary dependencies between variables. Common formula conversion does the opposite - it deliberately introduces dependencies between formulas. However, this structural change could allow the sequence task to group all random variables from a given parfactor. Specifically, the common formula conversion is highly efficient in cases where lifting operators are well defined on the common formula but not applicable to the individual components of the common formula. Let's show this with the task of summarizing all random variables from a given parfactor."}, {"heading": "3.3 Logical Variables Mapping", "text": "A mapping of logical variables (or simply a mapping) between two formulas \u03b1 and \u03b2, represented by M\u03b1, \u03b2, is an isomorphism from the ordered set of logical variables of \u03b1, 'LV (\u03b1) = < \u03b1 [1],.., \u03b1 [| LV (\u03b1) |] >, to the ordered set of logical variables of \u03b2,' LV (\u03b2) = < \u03b2 [1], \u03b2 [| LV (\u03b2) |] >, where \u03b1 [i] and \u03b2 [j] represent the i-th and j-th logical variables of \u03b2 and \u03b2 in the order of the arguments. Mapping of logical variables of \u03b1 and \u03b2 is allowed only in cases where they have the same domain. For example, a possible mapping between a (X, Y) and b (W, Z) is an mapping of the same variables of Ma, b = {1] an mapping of b [2], a mapping of b [1], a mapping of Y."}, {"heading": "3.4 Usage and Computational Complexity", "text": "In the context of current C-FOVE implementations, where a greedy algorithm is used to determine which operator is next to be used, common formulas can easily be used if (a) all other lifting attempts fail and (b) their placement permits subsequent counting conversions and reversals. However, given the correct heuristics, common formula conversion can be applied at any stage of the inference task. Calculation complexity of common formula conversion is limited by O (k \u00b7 rn + 1), where r is the maximum assignment range of each formula in the model, k is the number of parameters consisting of the components of the common formulas, and n is the maximum number of formulas in each of the theme parameters."}, {"heading": "3.5 Joint Shattering", "text": "Before applying a common formula conversion, a common fragmentation must be carried out. Common fragmentation is identical to the already known fragmentation process (3), except that the formulas to be put together, \u03b1 and \u03b2, are smashed. Their instances under the common formula. Namely, the common fragmentation splits the set of parameters in the model, so that parameters containing ('L\u03b1) are treated as if they also contained \u03b2 (' L\u03b2), where 'L\u03b2 = M\u03b1 \u2192 \u03b2:' L\u03b1. Similarly, parameters containing \u03b2 ('L\u03b2) are treated as if they contained \u03b1 (' L\u03b1). Let us show this with an example. Let's say a model? (a (X, Y), b (X, Z), CX # = Z), CX # = Z), CX # = Z), which is the same."}, {"heading": "4 Just-Different Counting Conversion", "text": "The notion of simply different atoms was introduced by Braz et al. [4] for the purpose of calculating Y substitutions, but has yet to be used for the purpose of conversion. As already mentioned, combining the conversion of simply different atoms with common formulas represents the scope of the deduction overridden and provides motivation to explore this variant of conversion. For the sake of simplicity and clarity, we present a version that simply converts pairs of simply different atoms. Note that the procedure can be generalized to any number of simply different atoms. The simple case of conversion, where a single formula is converted, derives directly from this more general case. Let the parameter g\u03b7 contain two substances of formula \u03b1: \u03b11 = \u03b1 (X, L) and \u03b12 = \u03b1 (L), where X and Y are logical variables, where L are a series of logical variables."}, {"heading": "5 FOVE for MEU", "text": "To capture the settings of relational decision-making, we use a model based on the Markov Logic Decision Network (MLDN) [10], which includes probability and benefit parameters as well as two types of formulas: random variable formulas and decision formulas."}, {"heading": "5.1 MEU", "text": "Formally, G = G?? Gp?, where Gp? contains a set of probability parameters, and Gp? contains a set of utility parameters. The expected utility value (EU) of model G by assigning vd to (all) its decision variables is determined by: eu [G] (vd) = 1Z \u2211 rv (G) \u2211 wg (vd) \u00b7 \u2211 g \u0439G\u00b5wg (vd) (5) In our setting, we can ignore Z, which is the normalizing constant of MLDN. To illustrate this model, we look at Figure 2, which represents a primary utility problem (MEU) of model G, where a product planner must decide on a product line. We strive for a decision that maximizes profit (vd) (6). Consider Figure 2, which represents a primary utility problem (MEU) of model G, whereby a product planner must decide on product demand."}, {"heading": "5.2 Challenges in Lifted MEU Computation", "text": "The first challenge stems from the existence of two types of formulas, decision and random variables, for which separate elimination procedures are defined. It is noteworthy that random variable atoms are eliminated by adding their effect on the network, while decision atoms from the network are maximized. [5] Consequently, the numerical comb (N), which is typically attributed to each histogram N, plays no role in the elimination process of decision formulas. Moreover, decision formulas can only be eliminated from parameters that do not contain random variable formulas. The second challenge stems from the two separate parts of the MEU expression, which represent the weights of two types of parameters: probability and benefit. The complex structure forces the inversion procedure to be more complicated than in faith testing, but most importantly - it represents a significant restriction on the inversion of decision formulas decision formulas can be inverted by inheriting this problem if the meaning of the formula is not specified in the formula."}, {"heading": "5.3 Framework", "text": "We have three lifting technicians: inversion elimination, counter conversion, and joint formula conversion. We also have two grounding operators: propositionalization and counter expansion, which are identical to C-FOVE. After applying the operator of choice, we have a transformed model, G \u2032, whose MEU solution includes the MEU of the original model. We continue to apply an operator of choice, repeated until all remaining formulas are (a) decision formulas and (b) soil formulas. Formulas without active logical variables are also considered soil formulas. Finally, an exhaustive search is performed in the assignment space to find the maximizing mappings of the remaining soil formulas. a final backward phase, similar to the one used in the upscale MPE [4], resolves the mappings of the eliminated decision formulas."}, {"heading": "5.4 Inversion Elimination", "text": "Let us allow G\u03b1 to designate the set of parameters containing formula \u03b1 in model G. The inversion selimination [3] of formula \u03b1 can be applied to model G under three conditions: (a) Model G is smashed. (b) For each g-G\u03b1, \u03b1 contains all the logical variables of g. (c) The set of formulas in each g-G\u03b1 contains only one instance of \u03b1. The inversion eliminates \u03b1 from the model and creates a residual model G \u2032. During the elimination process, product fusion and sum fusion are used repeatedly and form a parfactor with a single instance of \u03b1 containing all the logical variables of its container parfactor. Product fusion is defined in [3], and sum fusion is a similar procedure, with the distinction of sum potentials instead of the application of multiplication. We will now formally define the procedure for the elimination of random variable formulas well as the procedure for the elimination of decision formulas."}, {"heading": "5.4.1 Eliminating Random Variable Formulas", "text": "We assume that the formula \u03b1 lies in both probability and usefulness parfactors1. We start with the combination of all probability parfac-1If this is not the case, a \"stub\" parfactor \u03b7 (\u03b1) is added to the model, so that \u03b1 will then be contained in both types of parfactors. All table entries in a stub probability parfactor are 1, and all table entries in a stub usefulness parfactor are 0, toren, \u03b1 in g\u03c6 = (L\u03c6, C\u03c6, A\u03c6, \u03c6, \u03c6, \u03c6, \u03c6, \u03c6, \u03c6, \u03c6) will be a product merger with g\u00b5. Let us leave out the series of logical variables that are unique in the parameters g.1."}, {"heading": "5.4.2 Eliminating Decision Formulas", "text": "Two additional requirements are required: (a) Formula \u03b1 is contained exclusively in utility parameters or probability parameters, but not in both. (b) All formulas containing Sharea parameters with \u03b1 are decision formulas. Next, all parameters containing \u03b1 are merged into g\u03b7 = (L\u03b7, C\u03b7, A\u03b7, \u03b7). (g\u03b7 is determined by a product fusion if \u03b1 is contained in probability parameters, and otherwise by a sum fusion. A parameter g\u03b7 = (L\u03b7, C\u03b7, A\u03b7, \u03b7 \") is then calculated by maximizing the input of \u03b1 as follows: (max.): C | in probability parameters (11)."}, {"heading": "6 Experimental Evaluation", "text": "We present the results of three sets of experiments, all conducted on an E7400 Intel Duo core machine, with 2.8GHz CPU speed and 3Gb of RAM. The propositional variable elimination for MEU was implemented in Java, with emphasis on performance, using a minimum of deficiency / heuristics [1] for variable ordering, and our upscale implementation was also implemented in Java. Joint formula conversions were injected manually before the inference task.Figure 3 maps the results of the elevated probable inference in the model (p), q (X), r (Y), s (Y), s (Y). As you can see, without common formulas the model becomes unsustainable."}, {"heading": "7 Conclusion", "text": "We introduced a novel contribution in the field of elevated inference, a model conversion method known as a common formula conversion, and a subsequent contribution that expands the counting method. We then demonstrated how the new methods accelerate the task of elevated inference in some models, and the use of common formulas need not be limited to exact inference. In fact, we believe that the terms 012345 x 10 4domain sizes of X, Y and Zpropositional inference are general enough to be overridden by some other relational models, such as the relational MDP. To the best of our knowledge, our second contribution, the C-FOVE adaptation for MEU, is the first algorithm to override the MEU calculation. An interesting aspect of the elevated MEU is that it generalizes many common probable inference tasks. MPE and the MAP and the faith evaluation for MEU may be more important, for example, both MEU private cases are MEU cases, but MEU cases can still be generalized."}, {"heading": "Acknowledgements", "text": "We thank the anonymous reviewers for their comments and useful suggestions. The authors were partially supported by ISF Grant 1101 / 07, the Paul Ivanier Center for Robotics Research and Production Management, and the Lynn and William Frankel Center for Computer Science."}], "references": [{"title": "Nonserial Dynamic Programming", "author": ["U. Bertele", "F. Brioschi"], "venue": "Academic Press, Inc.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1972}, {"title": "Relational preference rules for control", "author": ["R.I. Brafman"], "venue": "Artif. Intell., 175(7-8):1180\u20131193", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Lifted firstorder probabilistic inference", "author": ["R. de Salvo Braz", "E. Amir", "D. Roth"], "venue": "In IJCAI,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Mpe and partial inversion in lifted probabilistic variable elimination", "author": ["R. de Salvo Braz", "E. Amir", "D. Roth"], "venue": "In AAAI,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2006}, {"title": "A new perspective on algorithms for optimizing policies under uncertainty", "author": ["R. Dechter"], "venue": "AIPS, pages 72\u201381", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Exploiting logical structure in lifted probabilistic inference", "author": ["V. Gogate", "P. Domingos"], "venue": "AAAI 2010 Workshop on Statistical and Relational Artificial Intelligence (STAR-AI)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "Influence diagrams", "author": ["R.A. Howard", "J.E. Matheson"], "venue": "Decision Analysis, 2(3):127\u2013143", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2005}, {"title": "Lifted inference seen from the other side : The tractable features", "author": ["A. Jha", "V. Gogate", "A. Meliou", "D. Suciu"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Lifted probabilistic inference with counting formulas", "author": ["B. Milch", "L.S. Zettlemoyer", "K. Kersting", "M. Haimes", "L.P. Kaelbling"], "venue": "AAAI, pages 1062\u20131068", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "A language for relational decision theory, in proceedings of the international workshop on statistical relational learning", "author": ["A. Nath", "P. Domingos"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Efficient belief propagation for utility maximization and repeated inference", "author": ["A. Nath", "P. Domingos"], "venue": "AAAI", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "First-order probabilistic inference", "author": ["D. Poole"], "venue": "IJ- CAI, pages 985\u2013991", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2003}, {"title": "Markov logic networks", "author": ["M. Richardson", "P. Domingos"], "venue": "Machine Learning, 62(1-2):107\u2013136", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "Practical solution techniques for first-order mdps", "author": ["S. Sanner", "C. Boutilier"], "venue": "Artif. Intell., 173(5- 6):748\u2013788", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2009}, {"title": "Lifted Probabilistic Inference by First-Order Knowledge Compilation", "author": ["G. Van den Broeck", "N. Taghipour", "W. Meert", "J. Davis", "L. De Raedt"], "venue": "In IJCAI,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "Generalized belief propagation", "author": ["J.S. Yedidia", "W.T. Freeman", "Y. Weiss"], "venue": "NIPS, pages 689\u2013695", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 0, "context": "One of their sought after features is the ability to compactly represent a set of interdependencies among random variables, providing a platform for efficient inference methods for both exact [1] and approximate [16] inference.", "startOffset": 192, "endOffset": 195}, {"referenceID": 15, "context": "One of their sought after features is the ability to compactly represent a set of interdependencies among random variables, providing a platform for efficient inference methods for both exact [1] and approximate [16] inference.", "startOffset": 212, "endOffset": 216}, {"referenceID": 11, "context": "This task can be carried out by a family of exact lifted inference algorithms, which are based on the idea of First-Order Variable Elimination (FOVE) [12, 3, 9].", "startOffset": 150, "endOffset": 160}, {"referenceID": 2, "context": "This task can be carried out by a family of exact lifted inference algorithms, which are based on the idea of First-Order Variable Elimination (FOVE) [12, 3, 9].", "startOffset": 150, "endOffset": 160}, {"referenceID": 8, "context": "This task can be carried out by a family of exact lifted inference algorithms, which are based on the idea of First-Order Variable Elimination (FOVE) [12, 3, 9].", "startOffset": 150, "endOffset": 160}, {"referenceID": 6, "context": "The tight connection between the two tasks is exemplified in the influence diagram model [7], a popular model for decision making.", "startOffset": 89, "endOffset": 92}, {"referenceID": 4, "context": "Under this principle, the best decision is achieved by maximizing the expected utility, a task that has been studied for both exact resolution [5] and approximation [11].", "startOffset": 143, "endOffset": 146}, {"referenceID": 10, "context": "Under this principle, the best decision is achieved by maximizing the expected utility, a task that has been studied for both exact resolution [5] and approximation [11].", "startOffset": 165, "endOffset": 169}, {"referenceID": 13, "context": "In the relational models realm, the study of decision making in influence diagrams has focused mainly on first-order MDP [14].", "startOffset": 121, "endOffset": 125}, {"referenceID": 8, "context": "First, we enrich the set of operators used by FOVE, by (a) introducing a novel model conversion method called joint formula conversion, and (b) generalizing the known counting conversion [9] operator to support the conversion of just-different atoms [4].", "startOffset": 187, "endOffset": 190}, {"referenceID": 3, "context": "First, we enrich the set of operators used by FOVE, by (a) introducing a novel model conversion method called joint formula conversion, and (b) generalizing the known counting conversion [9] operator to support the conversion of just-different atoms [4].", "startOffset": 250, "endOffset": 253}, {"referenceID": 8, "context": "As we explain and demonstrate empirically, the conversion allows a subsequent use of efficient inference operators: counting conversion [9] and inversion [3], where previously one would resort to grounding.", "startOffset": 136, "endOffset": 139}, {"referenceID": 2, "context": "As we explain and demonstrate empirically, the conversion allows a subsequent use of efficient inference operators: counting conversion [9] and inversion [3], where previously one would resort to grounding.", "startOffset": 154, "endOffset": 157}, {"referenceID": 6, "context": "Second, we present a solution to decision making in firstorder influence diagrams [7] based on the FOVE algorithm, the first lifted solution to the best of our knowledge.", "startOffset": 82, "endOffset": 85}, {"referenceID": 8, "context": "Our method applies a variation of C-FOVE [9] that computes", "startOffset": 41, "endOffset": 44}, {"referenceID": 4, "context": "maximum expected utility (MEU) [5].", "startOffset": 31, "endOffset": 34}, {"referenceID": 5, "context": "We note that recent works [6, 8, 15] demonstrate the advantage of exploiting the logical structure of first-order formulas (e.", "startOffset": 26, "endOffset": 36}, {"referenceID": 7, "context": "We note that recent works [6, 8, 15] demonstrate the advantage of exploiting the logical structure of first-order formulas (e.", "startOffset": 26, "endOffset": 36}, {"referenceID": 14, "context": "We note that recent works [6, 8, 15] demonstrate the advantage of exploiting the logical structure of first-order formulas (e.", "startOffset": 26, "endOffset": 36}, {"referenceID": 12, "context": "MLN features [13], preference rules [2]) for the benefit of efficient lifted inference.", "startOffset": 13, "endOffset": 17}, {"referenceID": 1, "context": "MLN features [13], preference rules [2]) for the benefit of efficient lifted inference.", "startOffset": 36, "endOffset": 39}, {"referenceID": 9, "context": "Based on Markov Logic Decision Network (MLDN) [10] and the work of Milch et al.", "startOffset": 46, "endOffset": 50}, {"referenceID": 8, "context": "[9], we present a first-order model which depicts two types of variables: random variables and decision variables, and two types of factors \u2013 probability factors and utility factors.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "Similarly to previous work [9], we require the constraints to be in some normal form, where for each logical variable X , |X : C| has a fixed value regardless of the binding of other logical variables in C.", "startOffset": 27, "endOffset": 30}, {"referenceID": 2, "context": "Similarly to shattering [3], it can be applied at the beginning or during the inference task.", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": "A logical variables mapping (or simply, mapping) between two formulas \u03b1 and \u03b2, depicted by M\u03b1,\u03b2 , is an isomorphism from the ordered set of logical variables of \u03b1, ' LV (\u03b1) = \u3008\u03b1[1], .", "startOffset": 177, "endOffset": 180}, {"referenceID": 0, "context": ",\u03b1[|LV (\u03b1)|]\u3009, to the ordered set of logical variables of \u03b2, ' LV (\u03b2) = \u3008\u03b2[1], .", "startOffset": 74, "endOffset": 77}, {"referenceID": 0, "context": "For example, a possible mapping between a(X,Y ) and b(W,Z) is Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]}, provided that dom(X) = dom(Z) and dom(Y ) = dom(W ).", "startOffset": 71, "endOffset": 74}, {"referenceID": 1, "context": "For example, a possible mapping between a(X,Y ) and b(W,Z) is Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]}, provided that dom(X) = dom(Z) and dom(Y ) = dom(W ).", "startOffset": 78, "endOffset": 81}, {"referenceID": 1, "context": "For example, a possible mapping between a(X,Y ) and b(W,Z) is Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]}, provided that dom(X) = dom(Z) and dom(Y ) = dom(W ).", "startOffset": 84, "endOffset": 87}, {"referenceID": 0, "context": "For example, a possible mapping between a(X,Y ) and b(W,Z) is Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]}, provided that dom(X) = dom(Z) and dom(Y ) = dom(W ).", "startOffset": 91, "endOffset": 94}, {"referenceID": 0, "context": "For example, in model \u03c6(a(X,Y ), b(Y,X)), a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]} results in the joint formula j(X,Y ) = \u3008a(X,Y ), b(Y,X)\u3009, and in a following conversion \u03c6\u2032(j(X,Y ), j(X,Y )), which can be simplified further to \u03c6\u2032\u2032(j(X,Y )).", "startOffset": 91, "endOffset": 94}, {"referenceID": 1, "context": "For example, in model \u03c6(a(X,Y ), b(Y,X)), a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]} results in the joint formula j(X,Y ) = \u3008a(X,Y ), b(Y,X)\u3009, and in a following conversion \u03c6\u2032(j(X,Y ), j(X,Y )), which can be simplified further to \u03c6\u2032\u2032(j(X,Y )).", "startOffset": 98, "endOffset": 101}, {"referenceID": 1, "context": "For example, in model \u03c6(a(X,Y ), b(Y,X)), a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]} results in the joint formula j(X,Y ) = \u3008a(X,Y ), b(Y,X)\u3009, and in a following conversion \u03c6\u2032(j(X,Y ), j(X,Y )), which can be simplified further to \u03c6\u2032\u2032(j(X,Y )).", "startOffset": 104, "endOffset": 107}, {"referenceID": 0, "context": "For example, in model \u03c6(a(X,Y ), b(Y,X)), a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[2], a[2] \u2194 b[1]} results in the joint formula j(X,Y ) = \u3008a(X,Y ), b(Y,X)\u3009, and in a following conversion \u03c6\u2032(j(X,Y ), j(X,Y )), which can be simplified further to \u03c6\u2032\u2032(j(X,Y )).", "startOffset": 111, "endOffset": 114}, {"referenceID": 0, "context": "On the other hand, a joint formula conversion of the same model over a different mapping, Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, results in the conversion \u03c6\u2032(j(X,Y ), j(Y,X)), yielding no computational gain.", "startOffset": 99, "endOffset": 102}, {"referenceID": 0, "context": "On the other hand, a joint formula conversion of the same model over a different mapping, Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, results in the conversion \u03c6\u2032(j(X,Y ), j(Y,X)), yielding no computational gain.", "startOffset": 106, "endOffset": 109}, {"referenceID": 1, "context": "On the other hand, a joint formula conversion of the same model over a different mapping, Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, results in the conversion \u03c6\u2032(j(X,Y ), j(Y,X)), yielding no computational gain.", "startOffset": 112, "endOffset": 115}, {"referenceID": 1, "context": "On the other hand, a joint formula conversion of the same model over a different mapping, Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, results in the conversion \u03c6\u2032(j(X,Y ), j(Y,X)), yielding no computational gain.", "startOffset": 119, "endOffset": 122}, {"referenceID": 2, "context": "Joint shattering is identical to the already known shattering [3] process, only that the formulas which are about to be joined, \u03b1 and \u03b2, are shattered w.", "startOffset": 62, "endOffset": 65}, {"referenceID": 0, "context": "Assume a model \u03c6(a(X,Y ), b(X,Z), CX #=Z) which is about to be applied with a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, where dom(X) = dom(Y ) = dom(Z) = {x1, x2}.", "startOffset": 125, "endOffset": 128}, {"referenceID": 0, "context": "Assume a model \u03c6(a(X,Y ), b(X,Z), CX #=Z) which is about to be applied with a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, where dom(X) = dom(Y ) = dom(Z) = {x1, x2}.", "startOffset": 132, "endOffset": 135}, {"referenceID": 1, "context": "Assume a model \u03c6(a(X,Y ), b(X,Z), CX #=Z) which is about to be applied with a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, where dom(X) = dom(Y ) = dom(Z) = {x1, x2}.", "startOffset": 138, "endOffset": 141}, {"referenceID": 1, "context": "Assume a model \u03c6(a(X,Y ), b(X,Z), CX #=Z) which is about to be applied with a joint formula conversion over mapping Ma,b = {a[1] \u2194 b[1], a[2] \u2194 b[2]}, where dom(X) = dom(Y ) = dom(Z) = {x1, x2}.", "startOffset": 145, "endOffset": 148}, {"referenceID": 3, "context": "[4] for the purpose of counting elimination, but has yet to be exploited for the purpose of counting conversion.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "To capture relational decision making settings, we use a model based on Markov Logic Decision Network (MLDN) [10].", "startOffset": 109, "endOffset": 113}, {"referenceID": 4, "context": "Notably, random variable atoms are eliminated by summing-out their effect on the network, whereas decision atoms are maximized-out from the network [5].", "startOffset": 148, "endOffset": 151}, {"referenceID": 3, "context": "A final backward phase, similar to the one used in lifted MPE [4], resolves the assignments of the eliminated decision formulas.", "startOffset": 62, "endOffset": 65}, {"referenceID": 2, "context": "Inversion elimination [3] of formula \u03b1 can be applied to modelG under three conditions: (a) ModelG is shattered w.", "startOffset": 22, "endOffset": 25}, {"referenceID": 2, "context": "Product fusion is defined in [3], and summation fusion is a similar procedure, with the distinction of summing potentials instead of applying multiplication.", "startOffset": 29, "endOffset": 32}, {"referenceID": 0, "context": "The propositional variable elimination for MEU was implemented in Java, with emphasis on performance, using a minimum deficiency heuristics [1] for variable ordering.", "startOffset": 140, "endOffset": 143}], "year": 2011, "abstractText": "The First-Order Variable Elimination (FOVE) algorithm allows exact inference to be applied directly to probabilistic relational models, and has proven to be vastly superior to the application of standard inference methods on a grounded propositional model. Still, FOVE operators can be applied under restricted conditions, often forcing one to resort to propositional inference. This paper aims to extend the applicability of FOVE by providing two new model conversion operators: the first and the primary is joint formula conversion and the second is just-different counting conversion. These new operations allow efficient inference methods to be applied directly on relational models, where no existing efficient method could be applied hitherto. In addition, aided by these capabilities, we show how to adapt FOVE to provide exact solutions to Maximum Expected Utility (MEU) queries over relational models for decision under uncertainty. Experimental evaluations show our algorithms to provide significant speedup over the alternatives.", "creator": "dvips(k) 5.99 Copyright 2010 Radical Eye Software"}}}