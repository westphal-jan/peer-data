{"id": "1204.5859", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Apr-2012", "title": "On the Complexity of Finding Second-Best Abductive Explanations", "abstract": "While looking for abductive explanations of a given set of manifestations, an ordering between possible solutions is often assumed. The complexity of finding/verifying optimal solutions is already known. In this paper we consider the computational complexity of finding second-best solutions. We consider different orderings, and consider also different possible definitions of what a second-best solution is.", "histories": [["v1", "Thu, 26 Apr 2012 08:18:38 GMT  (12kb)", "https://arxiv.org/abs/1204.5859v1", null], ["v2", "Thu, 24 Apr 2014 17:15:55 GMT  (12kb)", "http://arxiv.org/abs/1204.5859v2", null], ["v3", "Thu, 14 May 2015 13:11:02 GMT  (24kb)", "http://arxiv.org/abs/1204.5859v3", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["paolo liberatore", "marco schaerf"], "accepted": false, "id": "1204.5859"}, "pdf": {"name": "1204.5859.pdf", "metadata": {"source": "CRF", "title": "On the Complexity of Second-Best Abductive Explanations", "authors": ["Paolo Liberatore", "Marco Schaerf"], "emails": ["liberato@dis.uniroma1.it,", "marco.schaerf@uniroma1.it"], "sections": [{"heading": null, "text": "ar Xiv: 120 4.58 59v3 [cs.LO] When looking for abductive explanations for a particular set of manifestations, a sequence of possible solutions is often assumed. While the complexity of optimal solutions is already known, in this paper we consider second-best solutions in terms of different orders and different definitions of what is a second-best solution.Keywords: abduction; production logic; techniques of knowledge representation; knowledge-based systems"}, {"heading": "1 Introduction", "text": "This year, it has come to the point where it will only be once before a decision is taken on the question of the extent to which it is a decision, whether it is a decision or a decision for a decision."}, {"heading": "2 Definitions", "text": "The process of abduction starts from three elements: a propositional formula T, which formalizes the field of interest. < A > Variables M, which represent the current manifestations, and another set of variables H, which represent their possible explanations. In this article, abduction is formally defined as the following. Definition 1 A problem of abduction is a triple < H, M, T >, where T is a propositional formula, M is a set of propositional variables called hypotheses. Definition 1 A problem of abduction is a triple < H, M, T >, where T is a propositional formula, M is a set of propositional variables called hypotheses. Definition 1 A problem of abduction is a triple < A, M > a triple. Intuitively, T describes how the assumptions and manifestations and manifestations and manifestations are related to each other, where we want to know their series of manifestations to occur, and where we want to know their series of manifestations to be the most manifest."}, {"heading": "2.1 Second-Best Solution", "text": "Under the conditions of perfect knowledge, the set of minimum solutions to a kidnapping problem would always contain a single element: the hypotheses that actually caused the manifestations. Unfortunately, such complete information may not be available, leading to more than one minimum solution. Once one is found, it makes sense to continue the search for others. This process is formalized as follows. Definition 4 In the face of a non-empty set of minimum solutions {A1,...., Am} = min (SOL (< H, M, T >) of a kidnapping problem, the set of second-best solutions is: NEXT SOL (< H, M, T >, {A1,.., Am}) = min (SOL (< H, M, T >)\\ {A1, Am}),) The case of empty predetermined minimum solutions {A1,.., Bin} is excluded from consideration because it equates second-best solutions to minimum solutions."}, {"heading": "2.2 Other Best Solutions", "text": "A second best solution does not necessarily have to be a minimum solution to the original problem. If, for example, {A1,..., Am} includes all minimum solutions, all second best solutions are not minimum solutions. This is because the definition first excludes {A1,..., Am} from the group of solutions and then includes the minimum solutions among the remaining ones. If only minimum solutions are of interest, another definition is more appropriate: For a group of minimum solutions, another solution is a minimum solution that is not specified in the group of given solutions.Definition 5 For a non-empty group of minimum solutions {A1,..., Bin} SOL (< H, M, T >) of a problem of abduction, the group of other best solutions is: MIN SOL (P, {A1,.., Am}) = SOL (P)\\ {A1,."}, {"heading": "2.3 Use of Additional Information", "text": "In formulating the two problems of the second-best solutions and the most different solutions, we assumed that some solutions were already known. From the calculation that was carried out to find them, one assumes that only the final result is known, that is, the solutions. This is like discarding all intermediate data, even if they may have been useful for the subsequent search for other solutions. For example, if we were able to prove (while searching for the first solutions) that an assumption h exists in all solutions to the problem, then the problem of verifying other solutions is simplified (i.e., if a candidate solution does not contain an h, it is not a solution).In general, we can assume that the result of the original search does not only consist of the first solutions, but also of a polynomically large data structure. This is formulated as follows: In the case of a problem of abduction P = < H, M, T > and a number of previous solutions {A1,...}."}, {"heading": "2.4 Computational Problems of Abduction", "text": "There are several calculation problems relevant to an abduction, here we list those considered in this article. \u2022 Existence: Decide whether a kidnap problem P = < H, M, T > allows a (minimum solution, i.e., SOL (< H, M, T >) is not empty; \u2022 Check: Decide whether a set of hypotheses A is a minimum solution, i.e., whether a group of hypotheses is A, SOL (< H, M, T >); \u2022 Relevance: Decide whether a hypothesis h belongs to at least a minimum solution to an abduction problem P = < H, M, T >, i.e., A, SOL (< H, M, T >) so that h, A; Finding a solution can be solved iteratively on the basis of the relevance problem: for each h-H task, if it is relevant, add relevance to it and then remove it regardless of its H."}, {"heading": "2.5 Computational complexity", "text": "The complexity analysis of the second-best explanation problems considered in this article is carried out within the framework of the problems of the polynomic hierarchy 1. NP contains problems concerning the availability of the individual polynomic reductions. A number of books on the subject exist [2, 29, 1]. The problem of the decision formula (problems that have a yes / no answer) is currently divided into classes of increasing complexity. In summary, class P contains all problems that have a solution algorithm that is executed polynomially in time in the size of their inputs. NP contains all problems whose complementarity (the problem with the reverse yes / no answer of the original problem) is checked in NP. DP contains all problems that can be divided into a subproblem in NP and one in coNP, so that the answer is yes and only if the answers of the two subproblems are yes. The other classes of the polynomical hierarchy are defined in terms that are neglected in terms of the abstracts that are neglected."}, {"heading": "3 Second-Best Solution", "text": "In this section we look at the problem of second best solutions as formalized by definition 4: a set of minimum solutions predetermined, one that is minimal among the others. As usual in computer complexity studies, this search problem is therefore turned into a verification problem to evaluate its complexity: assuming a set of solutions and a candidate solution, it is checked whether the latter is a second best solution. A solution can be found by repeatedly solving problems of relevance, which are also analyzed. The technical means to prove the severity of these problems is the following problem, which shows how to introduce a new minimum solution to an abduction problem."}, {"heading": "A \u2208 SOL\u2264(\u3008H,M, T \u3009) holds.", "text": "Theorem 9 The existence of a solution in NEXT SOL \u2264 (< H, M, T >, {A1,.., Am}) containing a predetermined h-solution is \u2206 p3 [log n] -complete.Evidence. The problem of checking for the existence of a solution A with a size limited by a number k and containing h is in p2, since it amounts to creating a solution non-deterministically and then checking it for whether it is a second-best solution and whether its size is smaller or equal to k.The problem of relevance can therefore be solved by a binary search for the minimum size of solutions [14, Theorem 4.3.2]: start with k = | H | / 2, and if the result is a positive change k = | H | 3 / 4, otherwise k = | H-Am.Once the minimum size has been found, the problem can be solved by no longer viewing this solution as solvable."}, {"heading": "4 Other Minimal Solution", "text": "The implicit assumption in the second best solutions is that non-minimal solutions will be taken into account once all minimum solutions have been considered. < H, M, T >, Am}) includes all solutions that are minimal once A1,..., Am are excluded from consideration. Another approach is to allow only minimal solutions if the minimum solutions are all tested under the given solutions. The second definition does not apply to the minimum solutions that differ from the given ones; \u2022 other minimum solutions are solutions that are minimal and do not belong to the given ones. The difference is that the first definition allows non-minimal solutions if the minimum solutions are all of the given solutions. The difference only affects non-minimum solutions among the given solutions. Therefore, it disappears when the Emptiness precept E is taken into consideration, because no solution is not minimal."}, {"heading": "C, D, and E are sets of n fresh variables each.", "text": "In the second is every solution of P, in the third is every minimum solution of P, in the third is every minimum solution of P, in the third is every minimum solution of P, in the third is shown every minimum solution of P, in the third is shown only if it is not converted into a solution. In the third is every minimum solution of P, in the third minimum solution of P, in the third minimum solution of P, in the third minimum solution of P, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A, in the third minimum solution of A."}, {"heading": "5 Using Additional Information", "text": "In the previous sections, we have shown that the abduction problems remain insoluble even when we know a first solution. It seems that knowing a solution does not help to reduce the computational complexity. In this section, we examine whether, while searching for the first solution, we could obtain and store additional information (not just the solution) that would allow a faster search for another solution. < The complexity of such a problem can be evaluated by compiling ability classes [5] and self-reductions [23]. In short, a problem has the same complexity with and without additional information, if the part of the problem instance from which the additional information can be derived. < H, M, T > the additional information can be derived."}, {"heading": "It holds:", "text": "The first part of the proof is that A \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2."}, {"heading": "6 Conclusions", "text": "In this article we have examined the problem of finding a solution to a particular abduction problem when some solutions have already been found. Results show that the problems analyzed are mathematically insoluble, but this does not preclude the possibility of solving them. Only the most appropriate tools are proposed that can be used. Polynomial problems are best attacked by deterministic polynomial algorithms, while problems in NP can be solved by reducing them to the propositional satisfaction problem (SAT) and then passed on to a state-of-the-art SAT solver (for example, one of the participants in the SAT contest http: / / www.satcompetition.org /). Problems in higher classes of the polynomial hierarchy (like all the problems mentioned in the paper) can be solved by reducing them to the quantified Boolean formula problem (QBF) and using QBF solvers (http: / / qbf.satisfiability.org / gallery /)."}], "references": [{"title": "Computational Complexity: A Modern Approach", "author": ["S. Arora", "B. Barak"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Introduction to the Theory of Complexity. Prentice-Hall international series in computer science", "author": ["D. Bovet", "P. Crescenzi"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1994}, {"title": "Some results concerning the computational complexity of abduction", "author": ["T. Bylander", "D. Allemang", "M.C. Tanner", "J.R. Josephson"], "venue": "In Proceedings of the First International Conference on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1989}, {"title": "The computational complexity of abduction", "author": ["T. Bylander", "D. Allemang", "M.C. Tanner", "J.R. Josephson"], "venue": "Artificial Intelligence,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1991}, {"title": "Preprocessing of intractable problems", "author": ["M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Information and Computation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "The complexity of conjunctive query abduction in DL-Lite", "author": ["D. Calvanese", "M. Ortiz", "M. Simkus", "G. Stefanoni"], "venue": "In Proceedings of the twentyfourth International Workshop on Description Logics", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Abduction is not deduction-in-reverse", "author": ["M. Cialdea Mayer", "F. Pirri"], "venue": "Journal of the IGPL,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1996}, {"title": "Complexity classifications for propositional abduction in post\u2019s framework", "author": ["N. Creignou", "Schmidt. J", "M. Thomas"], "venue": "J. Log. Comput.,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "A complete classification of the complexity of propositional abduction", "author": ["N. Creignou", "B. Zanuttini"], "venue": "SIAM J. Comput.,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "An assumption-based TMS", "author": ["J. de Kleer"], "venue": "Artificial Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1986}, {"title": "A new method for consequence finding and compilation in restricted languages", "author": ["A. Del Val"], "venue": "In Proceedings of the Sixteenth National Conference on Artificial Intelligence", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "The complexity of restricted consequence finding and abduction", "author": ["A. Del Val"], "venue": "In Proceedings of the Seventeenth National Conference on Artificial Intelligence (AAAI", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2000}, {"title": "On some tractable classes in deduction and abduction", "author": ["A. Del Val"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "The complexity of logic-based abduction", "author": ["T. Eiter", "G. Gottlob"], "venue": "Journal of the ACM,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1995}, {"title": "Abduction from logic programs: Semantics and complexity", "author": ["T. Eiter", "G. Gottlob", "N. Leone"], "venue": "Theoretical Computer Science,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1997}, {"title": "Semantics and complexity of abduction from default theories", "author": ["T. Eiter", "G. Gottlob", "N. Leone"], "venue": "Artificial Intelligence,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1997}, {"title": "On computing all abductive explanations", "author": ["T. Eiter", "K. Makino"], "venue": "In Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "Abduction and the dualization problem", "author": ["T. Eiter", "K. Makino"], "venue": "In Discovery Science,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2003}, {"title": "Generating all abductive horn theories", "author": ["T. Eiter", "K. Makino"], "venue": "In Seventeenth International Workshop on Computer Science Logic,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2003}, {"title": "The parameterized complexity of abduction", "author": ["M.R. Fellows", "A. Pfandler", "F.A. Rosamond", "S. R\u00fcmmele"], "venue": "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2012}, {"title": "Counting complexity of propositional abduction", "author": ["M. Hermann", "R. Pichler"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2010}, {"title": "A knowledge-level account of abduction", "author": ["H.J. Levesque"], "venue": "In Proceedings of the Eleventh International Joint Conference on Artificial Intelligence", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1989}, {"title": "Monotonic reductions, representative equivalence, and compilation of intractable problems", "author": ["P. Liberatore"], "venue": "Journal of the ACM,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2001}, {"title": "What makes propositional abduction tractable", "author": ["G. Nordh", "B. Zanuttini"], "venue": "Artificial Intelligence,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2008}, {"title": "Abduction and induction", "author": ["C.S. Peirce"], "venue": "Philosophical Writings of Peirce,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1955}, {"title": "Foundations of assumption-based truth maintenace systems: Preliminary report", "author": ["R. Reiter", "J. de Kleer"], "venue": "In Proceedings of the Sixth National Conference on Artificial Intelligence", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1987}, {"title": "Support set selection for abductive and default reasoning", "author": ["B. Selman", "H. Levesque"], "venue": "Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1996}, {"title": "Abductive and default reasoning: A computational core", "author": ["B. Selman", "H.J. Levesque"], "venue": "In Proceedings of the Eighth National Conference on Artificial Intelligence", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1990}, {"title": "Introduction to the Theory of Computation", "author": ["M. Sipser"], "venue": "International Thomson Publishing,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1996}], "referenceMentions": [{"referenceID": 24, "context": "The three basic reasoning mechanisms used in computational logic are deduction, induction, and abduction [25].", "startOffset": 105, "endOffset": 109}, {"referenceID": 6, "context": "extent [7]): from the fact that the car is not starting up, we conclude that the battery is down.", "startOffset": 7, "endOffset": 10}, {"referenceID": 27, "context": "Selman and Levesque [28, 27] and Bylander et al.", "startOffset": 20, "endOffset": 28}, {"referenceID": 26, "context": "Selman and Levesque [28, 27] and Bylander et al.", "startOffset": 20, "endOffset": 28}, {"referenceID": 2, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 0, "endOffset": 6}, {"referenceID": 3, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 0, "endOffset": 6}, {"referenceID": 13, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 90, "endOffset": 94}, {"referenceID": 8, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 151, "endOffset": 154}, {"referenceID": 7, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 189, "endOffset": 192}, {"referenceID": 23, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 272, "endOffset": 276}, {"referenceID": 16, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 344, "endOffset": 356}, {"referenceID": 17, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 344, "endOffset": 356}, {"referenceID": 18, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 344, "endOffset": 356}, {"referenceID": 20, "context": "[3, 4] proved the first results about fragments of abductive reasoning, Eiter and Gottlob [14] presented an extensive analysis, Creignou and Zanuttini [9] and Creignou, Schmidt, and Thomas [8] classified the complexity under two kinds of restrictions, Nordh and Zanuttini [24] located the tractability/intractability frontier, Eiter and Makino [17, 18, 19] studied the complexity of computing all abductive explanations, Hermann and Pichler [21] proved the complexity of counting the number of solutions, Fellow et al.", "startOffset": 441, "endOffset": 445}, {"referenceID": 19, "context": "[20] analyzed the problem from the point of view of parametrized complexity.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "Some work on the complexity of abduction from non-classical theories has also been done [16, 15, 6].", "startOffset": 88, "endOffset": 99}, {"referenceID": 14, "context": "Some work on the complexity of abduction from non-classical theories has also been done [16, 15, 6].", "startOffset": 88, "endOffset": 99}, {"referenceID": 5, "context": "Some work on the complexity of abduction from non-classical theories has also been done [16, 15, 6].", "startOffset": 88, "endOffset": 99}, {"referenceID": 9, "context": "Abduction is also related to the ATMS [10, 26] and to the set of prime implicates of a propositional formula.", "startOffset": 38, "endOffset": 46}, {"referenceID": 25, "context": "Abduction is also related to the ATMS [10, 26] and to the set of prime implicates of a propositional formula.", "startOffset": 38, "endOffset": 46}, {"referenceID": 21, "context": "Indeed, Levesque [22] has proved that ATMS and prime implicates can be used to find the abductive explanations", "startOffset": 17, "endOffset": 21}, {"referenceID": 10, "context": "Kernel resolution [11] exploits the particular literals of the observation to drive the clause generation process.", "startOffset": 18, "endOffset": 22}, {"referenceID": 12, "context": "Using this algorithm, Del Val has been able to derive upper bounds on the number of generated clauses, and to prove that some restricted classes of abduction problems are polynomial [13, 12].", "startOffset": 182, "endOffset": 190}, {"referenceID": 11, "context": "Using this algorithm, Del Val has been able to derive upper bounds on the number of generated clauses, and to prove that some restricted classes of abduction problems are polynomial [13, 12].", "startOffset": 182, "endOffset": 190}, {"referenceID": 27, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 26, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 2, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 3, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 13, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 8, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 7, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 23, "context": "Other works studied the complexity of finding a solution for a problem of abduction [28, 27, 3, 4, 14, 9, 8, 24]; this one considers the problem of finding another solution once some other ones have been found.", "startOffset": 84, "endOffset": 112}, {"referenceID": 4, "context": "The complexity under such an assumption can be established using compilability classes [5] and monotonic reductions [23].", "startOffset": 87, "endOffset": 90}, {"referenceID": 22, "context": "The complexity under such an assumption can be established using compilability classes [5] and monotonic reductions [23].", "startOffset": 116, "endOffset": 120}, {"referenceID": 4, "context": "pilability classes [5, 23] characterize this kind of problems.", "startOffset": 19, "endOffset": 26}, {"referenceID": 22, "context": "pilability classes [5, 23] characterize this kind of problems.", "startOffset": 19, "endOffset": 26}, {"referenceID": 1, "context": "A number of books on the topic exist [2, 29, 1].", "startOffset": 37, "endOffset": 47}, {"referenceID": 28, "context": "A number of books on the topic exist [2, 29, 1].", "startOffset": 37, "endOffset": 47}, {"referenceID": 0, "context": "A number of books on the topic exist [2, 29, 1].", "startOffset": 37, "endOffset": 47}, {"referenceID": 1, "context": "More details about complexity classes and reductions can be found in the cited books on computational complexity [2, 29, 1].", "startOffset": 113, "endOffset": 123}, {"referenceID": 28, "context": "More details about complexity classes and reductions can be found in the cited books on computational complexity [2, 29, 1].", "startOffset": 113, "endOffset": 123}, {"referenceID": 0, "context": "More details about complexity classes and reductions can be found in the cited books on computational complexity [2, 29, 1].", "startOffset": 113, "endOffset": 123}, {"referenceID": 4, "context": "Compilability classes characterize the complexity when preprocessing part of the data is possible [5, 23].", "startOffset": 98, "endOffset": 105}, {"referenceID": 22, "context": "Compilability classes characterize the complexity when preprocessing part of the data is possible [5, 23].", "startOffset": 98, "endOffset": 105}, {"referenceID": 4, "context": "The reader is therefore referred to other articles on compilability classes [5, 23] for more explanations and for examples.", "startOffset": 76, "endOffset": 83}, {"referenceID": 22, "context": "The reader is therefore referred to other articles on compilability classes [5, 23] for more explanations and for examples.", "startOffset": 76, "endOffset": 83}, {"referenceID": 13, "context": "This and the corresponding problem of dispensability (no minimal solution contains h) have been analyzed by Eiter and Gottlob [14].", "startOffset": 126, "endOffset": 130}, {"referenceID": 13, "context": "Verifying a solution with the empty preorder is mentioned to be DP-hard by Eiter and Gottlob [14], but as far it was possible to verify no formal proof was published to date.", "startOffset": 93, "endOffset": 97}, {"referenceID": 13, "context": "This property is stated by Eiter and Gottlob [14] for an arbitrary candidate solution as an easy corollary of their results, but as far as we know,", "startOffset": 45, "endOffset": 49}, {"referenceID": 4, "context": "The complexity of such a problem can be evaluated using compilability classes [5] and self reductions [23].", "startOffset": 78, "endOffset": 81}, {"referenceID": 22, "context": "The complexity of such a problem can be evaluated using compilability classes [5] and self reductions [23].", "startOffset": 102, "endOffset": 106}, {"referenceID": 4, "context": "Membership follows from that in DP, which was proved in a previous section, and the fact that every compilability class \u2016 C contains the relative complexity class C [5].", "startOffset": 165, "endOffset": 168}], "year": 2015, "abstractText": "When we look for abductive explanations of a given set of manifestations, an ordering between possible solutions is often assumed. While the complexity of optimal solutions is already known, in this paper we consider second-best solutions with respect to different orderings, and different definitions of what a second-best solution is.", "creator": "LaTeX with hyperref package"}}}