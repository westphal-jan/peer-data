{"id": "1204.6346", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Apr-2012", "title": "Magic Sets for Disjunctive Datalog Programs", "abstract": "In this paper, a new technique for the optimization of (partially) bound queries over disjunctive Datalog programs with stratified negation is presented. The technique exploits the propagation of query bindings and extends the Magic Set (MS) optimization technique.", "histories": [["v1", "Fri, 27 Apr 2012 23:17:00 GMT  (217kb)", "http://arxiv.org/abs/1204.6346v1", "67 pages, 19 figures, preprint submitted to Artificial Intelligence"]], "COMMENTS": "67 pages, 19 figures, preprint submitted to Artificial Intelligence", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["mario alviano", "wolfgang faber", "gianluigi greco", "nicola leone"], "accepted": false, "id": "1204.6346"}, "pdf": {"name": "1204.6346.pdf", "metadata": {"source": "CRF", "title": "Magic Sets for Disjunctive Datalog Programs", "authors": ["Mario Alviano", "Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 120 4.63 46v1 [cs.AI] 27 April 201 2This paper introduces a new technique for optimizing (partially) bound queries via disjunctive datalog programs with stratified negation, using the proliferation of query bindings and extending the Magic Set optimization technology (originally defined for non-disjunctive programs).An important feature of disjunctive datalog programs is non-monotony, which requires non-deterministic implementations, such as search traceability. A characteristic feature of the new method is that optimization can also be used during the non-deterministic phase. Especially after some assumptions have been made during the calculation, parts of the program may become irrelevant to a query under these assumptions, enabling a dynamic printing of the search space and the effect of the previously defined magic set methods on disjunctive datalogs."}, {"heading": "1 Introduction", "text": "This year, it is more than ever before in the history of the city."}, {"heading": "2 Preliminaries", "text": "In this section, (disjunctive) Datalog programs with (layered) negation are briefly described, and the standard method Magic Set is presented together with the presentation of a lateral information transfer strategy (SIPS) for Datalog rules."}, {"heading": "2.1 Disjunctive Datalog Programs with Stratified Negation", "text": "In this paper, we assume the standard Datalog name convention: Alphanumeric strings starting with a lowercase letter. (DB) Each predicate is associated with a non-negative integer, which is designated as its species. (S) An atom p (t) is a predicate p (t) and a list t (t1) of terms, each of which is either a constant or a variable. (S) A letter is an atom p (t) or a negative atom not p (t). (S) in the first case, the dictionary is positive, while in the second it is a disjunctive rule with negation (Datalog for short)."}, {"heading": "2 Note that more complex queries can still be expressed using appropriate rules.", "text": "We assume that any constant that occurs in Q also occurs in P; if not, we can add a fact p (t) to P, so that p is a predicate that does not occur in P, and t) are the arguments of Q. Question marks are usually omitted when referring to queries in the text. Bold-equivalent in relation to Q, denoted by P-bQP, if Ansb (Q, P-F) is guaranteed for any set of facts F defined by predicates F, which are EDB predicates of P or P-P; similarly, P and P \u00b2 are cautious-equivalent in relation to Q, denoted by P-cQP, if Ansc (Q, P-F) = Ansc (Q, P-F) is defined for any set of facts F, defined by predicates F, which are EDB predicates of P or P-P."}, {"heading": "2.2 Bottom-up Disjunctive Datalog Computation", "text": "Most of the techniques used in this phase come from bottom-up methods developed for classical and deductive databases; see, for example, [1] or [28,43] for details. Essentially, it is important to note that instances that are known to be true or false are identified, and this knowledge is used to derive further instances of this kind. Ultimately, the truth values obtained in this way are used to produce rule instances that are already not fulfilled. It is important to note that this phase is deterministic in relation to stable models. No assumptions are made about the truth or falsehood of atoms, only defined knowledge is derived that must be valid in all stable models."}, {"heading": "2.3 Sideways Information Passing for Datalog Rules", "text": "The magic set method aims to simulate a top-to-bottom evaluation of a query Q, such as the procedure used by Prolog. According to this type of evaluation, all rules are handled in such a way that they are considered as a first step. Then, the atoms in B + (r) are taken as subqueries (remember that standard datalog rules have an empty negative body), and the procedure is iterated. Note that according to this process, if a (sub) query has some arguments tied to a constant value, this information is \"passed\" to the atoms in the body. Furthermore, the body is processed as in a certain sequence, and the processing of a body atom can bind some of its arguments, i.e. \"and\" pass. \""}, {"heading": "2.4 Magic Sets for Datalog Programs", "text": "The magic set method is a strategy for simulating the top-down evaluation of a query by modifying the original program by means of additional rules that limit the calculation to what is relevant for answering the question. (1) The key idea is to materialize the binding information for IDB predicates that would be propagated during a top-down compilation. (1) The fact that an IDB predicate p (t) is associated with binding information (i.e., a string of letters b and f is denoted for each term in t)."}, {"heading": "3 Magic Set Method for Datalog\u2228,\u00acs Programs", "text": "In this section we will introduce the Dynamic Magic Set Algorithm (DMS) for optimizing disjunctive programs with layered negation. Before discussing the details of the algorithm, we will informally present the main ideas used to enable the Magic Set Method to work on disjunctive programs (without negation)."}, {"heading": "3.1 Overview of Binding Propagation in Datalog\u2228 Programs", "text": "In fact, it is in such a way that one sees oneself in a position to live in a country in which most people are able to live in a country in which they are able to move, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live"}, {"heading": "3.3 Query Equivalence Result", "text": "We conclude the presentation of DMS algorithms by formally proving their correctness. < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "3.3.1 Soundness of the Magic Set Method", "text": "Let us now begin with the first part of the evidence, in particular by specifying some further definitions and notations. (Since a model M \u00b2 of DMS (Q, P), and a model N \u00b2 M \u00b2 of Ground (Q, P) M \u00b2, we next define the quantity of atoms relevant to Q \u00b2, but incorrect with respect to N \u00b2. Definition 3.14 (Killed Atoms) Given a model M \u00b2 of Ground (Q, P) M \u00b2, and a model N \u00b2 M \u00b2 of Ground (DMS, P) M \u00b2, the killedM \u00b2 of Magic (k.M \u00b2), the killedatoms relating to M \u00b2 and N \u00b2 s is defined as: {k \u00b2 M \u00b2 M \u00b2 s of Ground M \u00b2 s of Ground (Q, P) M \u00b2 s of Magic, the killedM \u00b2 of Magic (k.M \u00b2), the killedatoms relating to M \u00b2 and N \u00b2 s are defined as: {s \u00b2 M \u00b2 of Ground M \u00b2 M \u00b2 s, M \u00b2 of Ground (P) M \u00b2, P \u00b2 of Magic, P \u00b2 and P \u00b2 of Magic, the killedM \u00b2 of Magic (k.M \u00b2)."}, {"heading": "3.3.2 Completeness of the Magic Set Method", "text": "D (D). D (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D)."}, {"heading": "3.4 Magic Sets for Stratified Datalog Programs without Disjunction", "text": "In fact, the question of whether the rewritten program allows a unique stable model is also important. In fact, the rewritten program actually has a unique stable model. Theorem 3.27 Let P be a disjunction-free Datalog program with stratified negation and Q a query. Then DMS (Q, P) has a unique stable model."}, {"heading": "4 Implementation", "text": "The Dynamic Magic Set Method (DMS) has been implemented and integrated into the core of the DLV system [43]. In this section we first briefly describe the architecture of the system and its use. Then we briefly introduce an optimization to eliminate redundant rules that are sometimes introduced during the rewriting of the Magic Set."}, {"heading": "4.1 System Architecture and Usage", "text": "We have created a prototype system by implementing the magic set technique described in Section 3 within DLV, as shown in Figure 6. DLV supports both brave and cautious thinking, and for a fully grounded query it can also be used to calculate all stable models in which the query is true. DLV performs valiant reasoning when invoked with the command line option -FB, while -FC displays a cautious query. In our prototype, the DMS algorithm can be applied automatically when the user invokes DLV with -FB or -FC together with a (partially) bound query. Magic sets are not applied by default if the query does not contain a constant. The user can modify this default behavior by specifying the command line options -ODMS (for the use of magic sets) or -ODMS- (for the deactivation of the query of the magical set)."}, {"heading": "7 Since technically a SIPS has a definition for every single rule, implementations", "text": "This means that besides the head atom with which the rule is ornamented, only positive body atoms can produce variable bonds, and only if at least one of their arguments is bound, but both atoms with EDB and IDB predicates can do so. Furthermore, atoms with stronger bound arguments are processed before those with less bound arguments. Note that in this paper we did not study the effects of trying out different SIPS schemes, as we wanted to focus on showing the effects that our technique can have, rather than refining its parameters. Although we believe that the SIPS scheme used is well motivated, there is probably still some room for improvement that we will leave for future work. An executable version of the DLV system that supports optimizing the Magic Set is available at http: / / www.dlvsystem.com / magic /."}, {"heading": "4.2 Dealing with Redundant Rules", "text": "Even though our paraphrase algorithm keeps the number of rules generated low, some redundant rules may be generated when disjunctive rules are removed, making the optimization effort slightly worse. For example, in Example 3.6, the first two modified rules are semantically equivalent, and this could also happen if the two header predicates are different. Generally, not only duplicated rules could be created, but also rules that are logically subsumed by other rules in the program. First, let's specify the definition of the subsumption for datalog, \u20acs rules. Definition 4.1 Let P be a datalog, \u20acprogram, and let r and r rules be two rules for P. Then r will be subsumed by r rules (referred to as r rules) when there is a substitution for the variables of r, \"so that H (r rules) and B (r rules) are substituted."}, {"heading": "5 Experiments on Standard Benchmarks", "text": "In this section, we present the results of various standard benchmarks, most of which have been taken directly from the literature. Further experiments on an application scenario using real-world data are discussed in detail in Section 6. We also refer to [45,54], which contains performance evaluations with DMS; in [45], DLV was tested with DMS on semantic web reasoning tasks and confronted with a heterogeneous set of systems; in [54], the KAON2 system, which includes one version of DMS, is confronted with other ontology systems; and both publications explicitly describe the effect of magic sets."}, {"heading": "5.1 Compared Methods, Benchmark Problems and Data", "text": "To assess the impact of the proposed method, we compared DMS (using the SIPS relationships (X-Y edge) defined in Section 4) with both the traditional non-magic DLV evaluation and the SMS method proposed in [33]. With regard to SMS, we could not achieve implementation and therefore performed the parsing manually. Consequently, the run-time metrics obtained for SMS do not include the time required for parsing while they are included for DMS. For comparison, we consider the following benchmark problems, the first three of which have already been used to evaluate SMS in [33], to which we refer for details: \u2022 Easy path: Is there a directed graph G and two nodes a and b, is there a unique path linking a with b in G? The instances are encoded by facts edge (v1, v2) for each arc (v2) for the arc (v2) in G, while the problem itself is encoded by the program 8X (sp)."}, {"heading": "8 The first rule of the program models that for each node X of G, a unique path", "text": "The problem is that most of them are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules. (...) The problem is that they are not able to play by the rules."}, {"heading": "5.2 Results and Discussion", "text": "This year, it is only a matter of time before an agreement is reached."}, {"heading": "5.3 Experimenting DMS with other Disjunctive Datalog Systems", "text": "This year, it is at an all-time high in the history of the European Union."}, {"heading": "6 Application to Data Integration", "text": "In this section, we give a brief overview of a case study showing the impact of the Magic Set Method on programs that implement data integration systems. We first give an overview of data integration systems, show how they can be implemented using Datalog, euros, and finally evaluate the impact of Magic Sets on a data integration system with real data."}, {"heading": "6.1 Data Integration Systems in a Nutshell", "text": "The main objective of data integration systems is to provide transparent access to heterogeneous sources by providing users with a global schema that the user can query without knowing where the data comes from. In fact, the task of the data integration system is to identify and access the data sources that are relevant to finding the answer to a query via the global schema, followed by a combination of the data obtained in this way. The data integration system uses a series of mapping affirmations that specify the relationship between the data sources and the global schema. Following [41], we formalize a data integration system I as a triple < G, S, M >, where: (1) G is the global (relational) schema, i.e. a pair < GP >, which is a finite set of relationship symbols, each having an associated positive kind, and the other way around, representing an infinite relationship and vice versa."}, {"heading": "6.2 Consistent Query Answering via Datalog\u2228,\u00acs Queries", "text": "There is an intuitive relationship between consistent answers to questions about data integration systems and the availability of this approach. (...) In fact, if one could find a translation from data sources, the question of how the individual authors have a stable model for any possible repair and ask a question about them will correspond to consistent answers within the data integration system, so that the stable models of this program produce the repairs of the database that are retrieved from the sources. (...) Some of these approaches use logical programs with unstratified negation, [16] whereas disjunctive datalog programs are considered together with unstratified negation."}, {"heading": "6.3 Experimental Results", "text": "The effectiveness of the Magic Set method in this crucial application context was then assessed by a series of experiments carried out on the demonstration scenario of the INFOMIX project, which refers to the information system of the University of \"La Sapienza\" in Rome. The global scheme consists of 14 global relationships with 29 constraints, while the data sources comprise 29 relationships from 3 legacy databases and 12 wrappers generating relational data from web pages, amounting to more than 24 MB of data relating to students, professors and examinations in several faculties of the university. For a detailed description of the INFOMIX project, see https: / / www.mat.unical.it / infomix /. On this scheme, we have tested five typical queries with different characteristics that model different use cases. To ensure completeness, the full codes of the tested queries are published in the appendix."}, {"heading": "7 Related Work", "text": "This year, it is time for us to set out to find a solution that paves the way for the future, to pave the way for the future."}, {"heading": "8 Conclusion", "text": "In fact, most people who are able, are able, are not able to determine for themselves what they want and what they want to do."}, {"heading": "A Queries on the INFOMIX Demo Scenario", "text": "INFOMIX is a project funded by the European Commission under the Sixth Framework Programme for the provision of an advanced information integration system. A detailed description of the project, including references in the literature, can be found at https: / / www.mat.unical.it / infomix /. Five typical queries of the INFOMIX demo scenario have been taken into account for the evaluation of dynamic magic sets. The complete codes of the tested queries are shown in Figures A.1-A.2."}], "references": [{"title": "Scalar aggregation in fd-inconsistent databases", "author": ["Marcelo Arenas", "Leopoldo Bertossi", "Jan Chomicki"], "venue": "In International Conference on Database Theory (ICDT-2001),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "Consistent query answers in inconsistent databases", "author": ["Marcelo Arenas", "Leopoldo E. Bertossi", "Jan Chomicki"], "venue": "In Proc. of the 18th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}, {"title": "Specifying and querying database repairs using logic programs with exceptions", "author": ["Marcelo Arenas", "Leopoldo E. Bertossi", "Jan Chomicki"], "venue": "In Proc. of the 4th Int. Conf. on Flexible Query Answering Systems (FQAS", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2000}, {"title": "Magic Sets and Other Strange Ways to Implement Logic Programs", "author": ["Fran\u00e7ois Bancilhon", "David Maier", "Yehoshua Sagiv", "Jeffrey D. Ullman"], "venue": "In Proc. Int. Symposium on Principles of Database Systems,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1986}, {"title": "Repairing databases with annotated predicate logic", "author": ["Pablo Barcel\u00f3", "Leopoldo Bertossi"], "venue": "In Proc. the 10th Int. Workshop on Non-Monotonic Reasoning (NMR", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "Hyper Tableaux", "author": ["Peter Baumgartner", "Ulrich Furbach", "Ilkka Niemel\u00e4"], "venue": "In Proceedings of the European Workshop on Logics in Artificial Intelligence (JELIA\u201996),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1996}, {"title": "On the power of magic", "author": ["Catriel Beeri", "Raghu Ramakrishnan"], "venue": "Journal of Logic Programming,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1991}, {"title": "Soft stratification for magic set based query evaluation in deductive databases", "author": ["Andreas Behrend"], "venue": "Proceedings of the twenty-second ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Query answering in inconsistent databases", "author": ["Leo Bertossi", "Jan Chomicki"], "venue": "Logics for Emerging Applications of Databases,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "Consistent answers from integrated data sources", "author": ["Leopoldo Bertossi", "Jan Chomicki", "Alvaro Cortes", "Claudio Gutierrez"], "venue": "In Proc. of the 6th Int. Conf. on Flexible Query Answering Systems (FQAS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2002}, {"title": "Consistent query answers in virtual data integration systems", "author": ["Leopoldo E. Bertossi", "Loreto Bravo"], "venue": "In Inconsistency Tolerance,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}, {"title": "Logic programming for consistently querying data integration systems", "author": ["Loreto Bravo", "Leopoldo Bertossi"], "venue": "In Proc. of the 18th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2003}, {"title": "Default Logic as a Query Language", "author": ["Marco Cadoli", "Thomas Eiter", "Georg Gottlob"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1997}, {"title": "Query rewriting and answering under constraints in data integration systems", "author": ["Andrea Cal\u0300\u0131", "Domenico Lembo", "Riccardo Rosati"], "venue": "In Proc. of the 18th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2003}, {"title": "Minimal-change integrity maintenance using tuple deletions", "author": ["Jan Chomicki", "Jerzy Marcinkowski"], "venue": "Information and Computation,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2005}, {"title": "Computing consistent query answers using conflict hypergraphs", "author": ["Jan Chomicki", "Jerzy Marcinkowski", "Slawomir Staworko"], "venue": "In Proc. 13th ACM Conference on Information and Knowledge Management (CIKM-2004),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2004}, {"title": "Hippo: A System for Computing Consistent Answers to a Class of SQL Queries", "author": ["Jan Chomicki", "Jerzy Marcinkowski", "Slawomir Staworko"], "venue": "9th International Conference on Extending Database Technology (EDBT-2004),", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2004}, {"title": "Enhancing the magic-set method for disjunctive datalog programs", "author": ["Chiara Cumbo", "Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "venue": "In Proceedings of the the 20th International Conference on Logic Programming \u2013 ICLP\u201904,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2004}, {"title": "Conflict-Driven Disjunctive Answer Set Solving", "author": ["Christian Drescher", "Martin Gebser", "Torsten Grote", "Benjamin Kaufmann", "Arne K\u00f6nig", "Max Ostrowski", "Torsten Schaub"], "venue": "Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2008}, {"title": "Disjunctive Datalog", "author": ["Thomas Eiter", "Georg Gottlob", "Heikki Mannila"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1997}, {"title": "Enhancing Efficiency and Expressiveness in Answer Set Programming Systems", "author": ["Wolfgang Faber"], "venue": "PhD thesis, Institut fu\u0308r Informationssysteme, Technische Universita\u0308t Wien,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}, {"title": "Magic Sets and their Application to Data Integration", "author": ["Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2007}, {"title": "Conquer: Efficient management of inconsistent databases", "author": ["Ariel Fuxman", "Elham Fazli", "Ren\u00e9e J. Miller"], "venue": "In SIGMOD Conference,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2005}, {"title": "First-order query rewriting for inconsistent databases", "author": ["Ariel Fuxman", "Ren\u00e9e J. Miller"], "venue": "Proceedings of the 10th International Conference on Database Theory (ICDT 2005),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "Computers and Intractability, A Guide to the Theory of NP-Completeness", "author": ["Michael R. Garey", "David S. Johnson"], "venue": "W.H. Freeman and Company,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1979}, {"title": "Gringo : A new grounder for answer set programming", "author": ["Martin Gebser", "Torsten Schaub", "Sven Thiele"], "venue": "Logic Programming and Nonmonotonic Reasoning \u2014 9th International Conference, LPNMR\u201907,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2007}, {"title": "The Stable Model Semantics for Logic Programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In Logic Programming: Proceedings Fifth Intl Conference and Symposium,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1988}, {"title": "Expressive Planning and Explicit Knowledge", "author": ["R. Goldman", "M. Boddy"], "venue": "In Proceedings AIPS-96,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1996}, {"title": "A logic programming approach to the integration, repairing and querying of inconsistent databases", "author": ["Gianluigi Greco", "Sergio Greco", "Ester Zumpano"], "venue": "In Proc. of the 17th Int. Conf. on Logic Programming (ICLP\u201901),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2001}, {"title": "Optimization of Disjunction Queries", "author": ["Sergio Greco"], "venue": "Danny De Schreye, editor, Proceedings of the 16th International Conference on Logic Programming (ICLP\u201999),", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1999}, {"title": "Binding Propagation Techniques for the Optimization of Bound Disjunctive Queries", "author": ["Sergio Greco"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2003}, {"title": "The PushDown Method to Optimize Chain Logic Programs (Extended Abstract)", "author": ["Sergio Greco", "Domenico Sacc\u00e0", "Carlo Zaniolo"], "venue": "In Proc. Int. Colloquim on Automata, Languages and Programming,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1995}, {"title": "Magic-sets Transformation in Nonrecursive Systems", "author": ["Ashish Gupta", "Inderpal Singh Mumick"], "venue": "In Proceedings of the Thirteenth ACM SIGACT SIGMOD-SIGART Symposium on Principles of Database Systems", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 1992}, {"title": "Reasoning in description logics by a reduction to disjunctive datalog", "author": ["Ullrich Hustadt", "Boris Motik", "Ulrike Sattler"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "Unfolding Partiality and Disjunctions in Stable Model Semantics", "author": ["Tomi Janhunen", "Ilkka Niemel\u00e4", "Dietmar Seipel", "Patrik Simons", "Jia-Huai You"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2006}, {"title": "Bottom-up evaluation and query optimization of well-founded models", "author": ["David B. Kemp", "Divesh Srivastava", "Peter J. Stuckey"], "venue": "Theoretical Computer Science,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 1995}, {"title": "Efficient query answering on stratified databases", "author": ["Jean-Marc Kerisit", "Jean-Marc Pugin"], "venue": "In FGCS,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 1988}, {"title": "Loop Formulas for Disjunctive Logic Programs", "author": ["Joohyung Lee", "Vladimir Lifschitz"], "venue": "In Proceedings of the Nineteenth International Conference on Logic Programming", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2003}, {"title": "Data integration: A theoretical perspective", "author": ["Maurizio Lenzerini"], "venue": "In Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2002}, {"title": "The INFOMIX System for Advanced Integration of Incomplete and Inconsistent Data", "author": ["Nicola Leone", "Georg Gottlob", "Riccardo Rosati", "Thomas Eiter", "Wolfgang Faber", "Michael Fink", "Gianluigi Greco", "Giovambattista Ianni", "Edyta Ka  lka", "Domenico Lembo", "Maurizio Lenzerini", "Vincenzino Lio", "Bartosz Nowicki", "Marco Ruzzi", "Witold Staniszkis", "Giorgio Terracina"], "venue": "In Proceedings of the 24th ACM SIGMOD International Conference on Management of Data (SIGMOD", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2005}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["Nicola Leone", "Gerald Pfeifer", "Wolfgang Faber", "Thomas Eiter", "Georg Gottlob", "Simona Perri", "Francesco Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2006}, {"title": "Disjunctive Stable Models: Unfounded Sets, Fixpoint Semantics and Computation", "author": ["Nicola Leone", "Pasquale Rullo", "Francesco Scarcello"], "venue": "Information and Computation,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1997}, {"title": "OpenRuleBench: An analysis of the performance of rule engines", "author": ["Senlin Liang", "Paul Fodor", "Hui Wan", "Michael Kifer"], "venue": "Proceedings of the 18th International Conference on World Wide Web (WWW", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2009}, {"title": "Disjunctive Answer Set Programming via Satisfiability", "author": ["Yuliya Lierler"], "venue": "Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2005}, {"title": "ASSAT: Computing Answer Sets of a Logic Program by SAT Solvers", "author": ["Fangzhen Lin", "Yuting Zhao"], "venue": "In Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI-2002),", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2002}, {"title": "Foundations of Disjunctive Logic Programming", "author": ["Jorge Lobo", "Jack Minker", "Arcot Rajasekar"], "venue": null, "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1992}, {"title": "The HiLeX system for semantic information extraction. Transactions on Large-Scale Data- and Knowledge-Centered Systems", "author": ["Marco Manna", "Massimo Ruffolo", "Ermelinda Oro", "Mario Alviano", "Nicola Leone"], "venue": "Science 7100:91\u2013125,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2012}, {"title": "On the complexity of regular-grammars with integer attributes", "author": ["Marco Manna", "Francesco Scarcello", "Nicola Leone"], "venue": "Journal of Computer and System Sciences (JCSS),", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2011}, {"title": "The consistency extractor system: Querying inconsistent databases using answer set programs", "author": ["M\u00f3nica Caniup\u00e1n Marileo", "Leopoldo E. Bertossi"], "venue": "SUM", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2007}, {"title": "Foundations of Deductive Databases and Logic Programming", "author": ["Jack Minker", "editor"], "venue": null, "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1988}, {"title": "Reasoning in Description Logics using Resolution and Deductive Databases. PhD thesis, Fakult\u00e4t f\u00fcr Wirtschaftswissenschaften, Universit\u00e4t", "author": ["Boris Motik"], "venue": "Fridericiana zu Karlsruhe,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2006}, {"title": "A comparison of reasoning techniques for querying large description logic aboxes", "author": ["Boris Motik", "Ulrike Sattler"], "venue": "Logic for Programming, Artificial Intelligence, and Reasoning, 13th International Conference (LPAR 2006),", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2006}, {"title": "Magic is relevant", "author": ["Inderpal Singh Mumick", "Sheldon J. Finkelstein", "Hamid Pirahesh", "Raghu Ramakrishnan"], "venue": "In Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 1990}, {"title": "Logical Query Optimization by Proof-Tree Transformation", "author": ["Raghu Ramakrishnan", "Yehoshua Sagiv", "Jeffrey D. Ullman", "Moshe Y. Vardi"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 1993}, {"title": "A logic-based system for e-tourism", "author": ["Francesco Ricca", "Mario Alviano", "Antonella Dimasi", "Giovanni Grasso", "Salvatore Maria Ielpa", "Salvatore Iiritano", "Marco Manna", "Nicola Leone"], "venue": null, "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2010}, {"title": "Team-building with answer set programming in the Gioia-Tauro seaport", "author": ["Francesco Ricca", "Giovanni Grasso", "Mario Alviano", "Marco Manna", "Vincenzino Lio", "Salvatore Iiritano", "Nicola Leone"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2012}, {"title": "Modular Stratification and Magic Sets for Datalog Programs with Negation", "author": ["K.A. Ross"], "venue": "Journal of the ACM,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 1994}, {"title": "Cost-based optimization for magic: Algebra and implementation", "author": ["Praveen Seshadri", "Joseph M. Hellerstein", "Hamid Pirahesh", "T.Y. Cliff Leung", "Raghu Ramakrishnan", "Divesh Srivastava", "Peter J. Stuckey", "S. Sudarshan"], "venue": "Proceedings of the 1996 ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 1996}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["Patrik Simons", "Ilkka Niemel\u00e4", "Timo Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2002}, {"title": "Compiling query constraints", "author": ["Peter J. Stuckey", "S. Sudarshan"], "venue": "In Proceedings of the Thirteenth Symposium on Principles of Database Systems", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 1994}, {"title": "Principles of Database and Knowledge-Base Systems, Volume II", "author": ["Jeffrey D. Ullman"], "venue": "Computer Science Press,", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 1989}], "referenceMentions": [{"referenceID": 45, "context": "Disjunctive Datalog is a language that has been proposed for modeling incomplete data [48].", "startOffset": 86, "endOffset": 90}, {"referenceID": 19, "context": ", NP NP) [22], under the stable model semantics.", "startOffset": 9, "endOffset": 13}, {"referenceID": 19, "context": "As shown in [22], the high expressive power of disjunctive Datalog has also some positive practical implications in terms of modelling knowledge, since many problems in NP can be represented more simply and naturally in stratified disjunctive Datalog than in normal logic programming.", "startOffset": 12, "endOffset": 16}, {"referenceID": 39, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 46, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 47, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 54, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 55, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 40, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 208, "endOffset": 212}, {"referenceID": 34, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 218, "endOffset": 222}, {"referenceID": 43, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 232, "endOffset": 236}, {"referenceID": 18, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 248, "endOffset": 252}, {"referenceID": 3, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 6, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 60, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 17, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 46, "endOffset": 50}, {"referenceID": 29, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 156, "endOffset": 163}, {"referenceID": 30, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 156, "endOffset": 163}, {"referenceID": 30, "context": "For the static method SMS, an extension to disjunctive Datalog with stratified negation has previously only been sketched in [33].", "startOffset": 125, "endOffset": 129}, {"referenceID": 40, "context": "\u25ee We have implemented a DMS optimization module inside the DLV system [43].", "startOffset": 70, "endOffset": 74}, {"referenceID": 2, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 4, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 11, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 13, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 14, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 28, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 25, "context": "Most of the techniques used in this phase stem from bottom-up methods developed for classic and deductive databases; see for example [1] or [28,43] for details.", "startOffset": 140, "endOffset": 147}, {"referenceID": 40, "context": "Most of the techniques used in this phase stem from bottom-up methods developed for classic and deductive databases; see for example [1] or [28,43] for details.", "startOffset": 140, "endOffset": 147}, {"referenceID": 20, "context": "Details on this process can be found for example in [23].", "startOffset": 52, "endOffset": 56}, {"referenceID": 6, "context": "The specific propagation strategy adopted in the top-down evaluation scheme is called sideways information passing strategy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specification of how the bindings originated and propagate [9,33].", "startOffset": 291, "endOffset": 297}, {"referenceID": 30, "context": "The specific propagation strategy adopted in the top-down evaluation scheme is called sideways information passing strategy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specification of how the bindings originated and propagate [9,33].", "startOffset": 291, "endOffset": 297}, {"referenceID": 60, "context": "The reader is referred to [63] for a detailed presentation.", "startOffset": 26, "endOffset": 30}, {"referenceID": 60, "context": ", P\u2261bQP \u2032 and P\u2261cQP \u2032 hold [63].", "startOffset": 27, "endOffset": 31}, {"referenceID": 30, "context": "As first observed in [33], while in non-disjunctive programs bindings are propagated only head-to-body, a Magic Set transformation for disjunctive programs 3 The Magic Set rewriting of a program P affects only IDB(P), so we usually omit EDB(P) in examples.", "startOffset": 21, "endOffset": 25}, {"referenceID": 30, "context": "The method proposed in [33] circumvents this problem by using some auxiliary predicates that collect all facts coming from the different adornments.", "startOffset": 23, "endOffset": 27}, {"referenceID": 30, "context": "Dynamic Magic Set algorithm (DMS) for Datalog\u2228,\u00acs programs tation in [33], a consequence is that assumptions during the computation cannot be exploited for determining the relevant part of the program.", "startOffset": 69, "endOffset": 73}, {"referenceID": 30, "context": "Our proposal to enhance the Magic Set method for disjunctive Datalog programs has two crucial features compared to the one of [33]:", "startOffset": 126, "endOffset": 130}, {"referenceID": 12, "context": "1 (Strategic Companies [15]) Let C = {c1, .", "startOffset": 23, "endOffset": 27}, {"referenceID": 12, "context": "It is known that the problem retains its hardness (for the second level of the polynomial hierarchy; see [15]) under these restrictions.", "startOffset": 105, "endOffset": 109}, {"referenceID": 41, "context": "In the proofs, we use the well established notion of unfounded set for disjunctive Datalog programs (possibly with negation) defined in [44].", "startOffset": 136, "endOffset": 140}, {"referenceID": 41, "context": "6 in [44] to our notation.", "startOffset": 5, "endOffset": 9}, {"referenceID": 41, "context": "11 ([44]) Let \u3008T,N\u3009 be a partial interpretation for a Datalog program P.", "startOffset": 4, "endOffset": 8}, {"referenceID": 26, "context": "Stratified Datalog programs without disjunction have exactly one stable model [29].", "startOffset": 78, "endOffset": 82}, {"referenceID": 35, "context": "However, the Magic Set transformation can introduce new dependencies between predicates, possibly resulting in unstratified programs (we refer to the analysis in [38]).", "startOffset": 162, "endOffset": 166}, {"referenceID": 40, "context": "The Dynamic Magic Set method (DMS) has been implemented and integrated into the core of the DLV [43] system.", "startOffset": 96, "endOffset": 100}, {"referenceID": 24, "context": "Unfortunately, this approach is unlikely to be feasible in polynomial time, given that subsumption checking on first-order expressions is NP-complete (problem [LO18] in [27]).", "startOffset": 169, "endOffset": 173}, {"referenceID": 42, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 17, "endOffset": 24}, {"referenceID": 51, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 17, "endOffset": 24}, {"referenceID": 42, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 80, "endOffset": 84}, {"referenceID": 51, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 196, "endOffset": 200}, {"referenceID": 30, "context": "In order to evaluate the impact of the proposed method, we have compared DMS (using the SIPS defined outlined in Section 4) both with the traditional DLV evaluation without Magic Sets and with the SMS method proposed in [33].", "startOffset": 220, "endOffset": 224}, {"referenceID": 30, "context": "The first three of them had been already used to assess SMS in [33], to which we refer for details:", "startOffset": 63, "endOffset": 67}, {"referenceID": 30, "context": "The structure of the graph, which is the same as the one reported in [33], consists of a square matrix of nodes connected as shown in Figure 7, and the instances have been generated by varying of the number of nodes.", "startOffset": 69, "endOffset": 73}, {"referenceID": 30, "context": "The structure of the \u201cgenealogy\u201d graph is the same as the one presented in [33] and coincides with the one used for testing Simple Path.", "startOffset": 75, "endOffset": 79}, {"referenceID": 27, "context": "This problem is inspired by a setting in planning, in particular testing whether a given plan is conformant with respect to a state transition diagram [30].", "startOffset": 151, "endOffset": 155}, {"referenceID": 25, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 101, "endOffset": 105}, {"referenceID": 18, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 141, "endOffset": 145}, {"referenceID": 43, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 155, "endOffset": 159}, {"referenceID": 34, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 175, "endOffset": 179}, {"referenceID": 37, "context": "Cmodels is based on the definition of program completion and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing them.", "startOffset": 99, "endOffset": 106}, {"referenceID": 44, "context": "Cmodels is based on the definition of program completion and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing them.", "startOffset": 99, "endOffset": 106}, {"referenceID": 58, "context": "GnT1 is based on Smodels [61], a system handling Datalog programs with unstratified negation (normal programs): A disjunctive program is translated into a normal program, the stable models of which are computed by Smodels and represent stable model candidates of the orig-", "startOffset": 25, "endOffset": 29}, {"referenceID": 38, "context": "Following [41], we formalize a data integration system I as a triple \u3008G,S,M\u3009, where:", "startOffset": 10, "endOffset": 14}, {"referenceID": 0, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 8, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 9, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 11, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 13, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 14, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 15, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 16, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 22, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 23, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 1, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 107, "endOffset": 110}, {"referenceID": 2, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 4, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 11, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 13, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 14, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 28, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 13, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 72, "endOffset": 76}, {"referenceID": 10, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 175, "endOffset": 182}, {"referenceID": 48, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 175, "endOffset": 182}, {"referenceID": 21, "context": "Indeed, the benefits of Magic Sets in the context of optimizing logic programs with unstratified negation (but without disjunction) have been discussed in [24].", "startOffset": 155, "endOffset": 159}, {"referenceID": 21, "context": "The Magic Set technique defined in [24] is quite different from the one defined in this article, as it does not consider disjunctive rules, and works only for programs, which are consistent, that is, have at least one stable model.", "startOffset": 35, "endOffset": 39}, {"referenceID": 48, "context": "In [51] our preliminary work reported in [20], which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs with disjunction and unstratified negation.", "startOffset": 3, "endOffset": 7}, {"referenceID": 17, "context": "In [51] our preliminary work reported in [20], which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs with disjunction and unstratified negation.", "startOffset": 41, "endOffset": 45}, {"referenceID": 48, "context": "It is ad-hoc in the sense that it is tailored to programs which are created by the transformation described in [51].", "startOffset": 111, "endOffset": 115}, {"referenceID": 48, "context": "The experimental results reported in [51] show huge computational advantages when using Magic Sets.", "startOffset": 37, "endOffset": 41}, {"referenceID": 48, "context": "We now report an alternative transformation which produces Datalogs programs (therefore different to [51], there are no unstratified occurrences of negation).", "startOffset": 101, "endOffset": 105}, {"referenceID": 39, "context": "This rewriting has been devised and used within the INFOMIX system on data integration [42].", "startOffset": 87, "endOffset": 91}, {"referenceID": 13, "context": "Actually, within the INFOMIX project also inclusion dependencies have been considered according to the rewriting discussed in [16], whose details we omit for clarity.", "startOffset": 126, "endOffset": 130}, {"referenceID": 17, "context": "All these applications refer to the preliminary work published in [20].", "startOffset": 66, "endOffset": 70}, {"referenceID": 3, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 31, "endOffset": 34}, {"referenceID": 6, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 52, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 59, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 60, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 7, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 35, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 36, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 56, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 35, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 18, "endOffset": 25}, {"referenceID": 56, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 18, "endOffset": 25}, {"referenceID": 7, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 206, "endOffset": 213}, {"referenceID": 36, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 206, "endOffset": 213}, {"referenceID": 21, "context": "In [24] a Magic Set method for Datalog programs has been defined and proved to be correct for coherent programs, i.", "startOffset": 3, "endOffset": 7}, {"referenceID": 21, "context": "This method takes special precautions for relevant parts of the program that act as constraints, called dangerous rules in [24].", "startOffset": 123, "endOffset": 127}, {"referenceID": 29, "context": "The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the SMSmethod has been presented and proved to be correct for Datalog programs.", "startOffset": 80, "endOffset": 87}, {"referenceID": 30, "context": "The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the SMSmethod has been presented and proved to be correct for Datalog programs.", "startOffset": 80, "endOffset": 87}, {"referenceID": 29, "context": "Moreover, while the correctness of DMS has been formally established for Datalogs programs in general, the applicability of SMS to Datalogs programs has only been outlined in [32,33].", "startOffset": 175, "endOffset": 182}, {"referenceID": 30, "context": "Moreover, while the correctness of DMS has been formally established for Datalogs programs in general, the applicability of SMS to Datalogs programs has only been outlined in [32,33].", "startOffset": 175, "endOffset": 182}, {"referenceID": 10, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 33, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 48, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 50, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 10, "context": "In particular, in [13,51] a data integration system has been presented.", "startOffset": 18, "endOffset": 25}, {"referenceID": 48, "context": "In particular, in [13,51] a data integration system has been presented.", "startOffset": 18, "endOffset": 25}, {"referenceID": 33, "context": "In [36,53], instead, an algorithm for answering queries over description logic knowledge bases has been presented.", "startOffset": 3, "endOffset": 10}, {"referenceID": 50, "context": "In [36,53], instead, an algorithm for answering queries over description logic knowledge bases has been presented.", "startOffset": 3, "endOffset": 10}, {"referenceID": 31, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 53, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 60, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 3, "context": "After seminal papers [6,9], the viability of the approach was demonstrated e.", "startOffset": 21, "endOffset": 26}, {"referenceID": 6, "context": "After seminal papers [6,9], the viability of the approach was demonstrated e.", "startOffset": 21, "endOffset": 26}, {"referenceID": 32, "context": ", in [35,55].", "startOffset": 5, "endOffset": 12}, {"referenceID": 52, "context": ", in [35,55].", "startOffset": 5, "endOffset": 12}, {"referenceID": 59, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 23, "endOffset": 27}, {"referenceID": 35, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 58, "endOffset": 62}, {"referenceID": 57, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 117, "endOffset": 121}, {"referenceID": 21, "context": "For instance, in [24] an extension of the Magic Set method was discussed for the class of unstratified logic programs (without disjunction).", "startOffset": 17, "endOffset": 21}, {"referenceID": 7, "context": "In [10] a technique for the class of soft-stratifiable programs was given.", "startOffset": 3, "endOffset": 7}, {"referenceID": 30, "context": "Finally, in [33] the first variant of the technique for disjunctive programs (SMS) was described.", "startOffset": 12, "endOffset": 16}, {"referenceID": 29, "context": "In this paper, we have elaborated on the issues addressed in [32,33].", "startOffset": 61, "endOffset": 68}, {"referenceID": 30, "context": "In this paper, we have elaborated on the issues addressed in [32,33].", "startOffset": 61, "endOffset": 68}, {"referenceID": 40, "context": "\u2022 DMS is integrated into the DLV system [43], profitably exploiting the DLV internal data-structures and the ability of controlling the grounding module.", "startOffset": 40, "endOffset": 44}, {"referenceID": 48, "context": "Importantly, other authors have already recognized the benefits of our optimization strategies with respect to this very important application domain [51], thereby confirming the validity and the robustness of the work discussed in this paper.", "startOffset": 150, "endOffset": 154}, {"referenceID": 35, "context": ", in [38])", "startOffset": 5, "endOffset": 9}, {"referenceID": 5, "context": ", Hyper Tableaux [8]), for which similar relations might hold.", "startOffset": 17, "endOffset": 20}, {"referenceID": 35, "context": "While [38] has already evidenced that an advantage of Magic Sets over such methods is that they may be more easily combined with other optimization techniques, we believe that achieving a deeper comprehension of the relationships among these techniques constitutes an interesting avenue for further research.", "startOffset": 6, "endOffset": 10}], "year": 2012, "abstractText": "In this paper, a new technique for the optimization of (partially) bound queries over disjunctive Datalog programs with stratified negation is presented. The technique exploits the propagation of query bindings and extends the Magic Set optimization technique (originally defined for non-disjunctive programs). An important feature of disjunctive Datalog programs is nonmonotonicity, which calls for nondeterministic implementations, such as backtracking search. A distinguishing characteristic of the new method is that the optimization can be exploited also during the nondeterministic phase. In particular, after some assumptions have been made during the computation, parts of the program may become irrelevant to a query under these assumptions. This allows for dynamic pruning of the search space. In contrast, the effect of the previously defined Magic Set methods for disjunctive Datalog is limited to the deterministic portion of the process. In this way, the potential performance gain by using the proposed method can be exponential, as could be observed empirically. The correctness of the method is established and proved in a formal way thanks to a strong relationship between Magic Sets and unfounded sets that has not been studied in the literature before. This knowledge allows for extending the method and the correctness proof also to programs with stratified negation in a natural way. The proposed method has been implemented in the DLV system and various experiments on synthetic as well as on real-world data have been conducted. The experimental results on synthetic data confirm the utility of Magic Sets for disjunctive Datalog, and they highlight the computational gain that may be obtained by the new method with respect to the previously proposed Magic Set method for disjunctive Datalog programs. Further experiments on data taken from a real-life application show the benefits of the Magic Set method within an application scenario that has received considerable attention in recent years, the problem of answering user queries over possibly inconsistent databases originating from integration of autonomous sources of information.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}