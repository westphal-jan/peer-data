{"id": "1205.2644", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-May-2012", "title": "First-Order Mixed Integer Linear Programming", "abstract": "Mixed integer linear programming (MILP) is a powerful representation often used to formulate decision-making problems under uncertainty. However, it lacks a natural mechanism to reason about objects, classes of objects, and relations. First-order logic (FOL), on the other hand, excels at reasoning about classes of objects, but lacks a rich representation of uncertainty. While representing propositional logic in MILP has been extensively explored, no theory exists yet for fully combining FOL with MILP. We propose a new representation, called first-order programming or FOP, which subsumes both FOL and MILP. We establish formal methods for reasoning about first order programs, including a sound and complete lifted inference procedure for integer first order programs. Since FOP can offer exponential savings in representation and proof size compared to FOL, and since representations and proofs are never significantly longer in FOP than in FOL, we anticipate that inference in FOP will be more tractable than inference in FOL for corresponding problems.", "histories": [["v1", "Wed, 9 May 2012 15:25:08 GMT  (198kb)", "http://arxiv.org/abs/1205.2644v1", "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI2009)", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["geoffrey gordon", "sue ann hong", "miroslav dudik"], "accepted": false, "id": "1205.2644"}, "pdf": {"name": "1205.2644.pdf", "metadata": {"source": "CRF", "title": "First-Order Mixed Integer Linear Programming", "authors": ["Geoffrey J. Gordon"], "emails": ["ggordon@cs.cmu.edu", "sahong@cs.cmu.edu", "mdudik@cs.cmu.edu"], "sections": [{"heading": null, "text": "Mixed Integer Linear Programming (MILP) is a powerful representation that is often used to formulate decision-making problems under uncertainty, but lacks a natural mechanism for thinking about objects, classes of objects, and relationships. First Order Logic (FOL), on the other hand, is characterized by its ability to think about object classes, but lacks a rich representation of uncertainty. Although the logic of the statement has been extensively researched in MILP, there is still no theory for the full combination of FOL and MILP. We propose a new representation, called First Order Programming, or FOP, that summarizes both FOL and MILP. We are establishing formal methods for arguing first order programs, including a solid and completely eliminated inference method for integral first-order programs. Since FOP can offer exponential savings in representation and evidence size compared to FOL, and since representation and evidence in FOP are never significantly longer than FOL, we assume that FOL will be associated with FOL issues."}, {"heading": "1 INTRODUCTION", "text": "It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is. (it is.) It is. (it is.) It is. (it is.) It is. (it is. (it is.) It is. (it is.) It is. (it is. (it is.) It is. (it is. (it is.) It is. (it is. (it.) It is. (it. (it is.) It is. (it is. (it.). (it is. (it is.) It is. (it is. (it.). (it is. (it.) It is. (it is. (it.). (it is. (it is.). (it. (it is.). (it. (it.) It is. (it. (it is.). (it is. (it. (it is.). (it. (it is.). (it is. (it.). (it. (it is. (it.) It is. (it. (it.) It is. (it. (it.). (it is. (it is.). (it is.). (it is. (it is. (it. (it is.). (it.). (it is. (it is. (it. (it is.).) It is. (it is.). (it is. (it is. (it.). (it is.). (it. (it. (it is.). (it.). (it is. (it is.). (it. (it.). (it. (it is."}, {"heading": "2 RELATED WORK", "text": "It is well understood that we can combine propositional logic with integer programs, or translate one problem into another. For example, Hooker and Osrio [1999] allow an overview of the area and a general framework called mixed logical / linear programming. However, in order to deal with the more general language of FOL, we can herbrandize a sentence and translate it into a possibly-infinite MILP (cf.); results include compactness lemmas analogous to our Lemma 5.3 (but specializing in FOL) to carry optimization tools and theories that point to FOL inference [Borkar et al., 2002, Chandru and Hooker, 1999]. Results include compactness lemmas analogous to our Lemma 5.3 (but specializing in FOL), as well as ways to organize the search for a finite proof of impracticality. Some of these search methods can be regarded as canceled perceived inferences."}, {"heading": "3 DEFINITION OF FOP", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 SYNTAX", "text": "The syntax of FOP has parallels to FOL. Terms are expressions that represent objects; formulas are those that represent values. However, where there are only two values in FOL (true and false), values in FOP are limited realms or integers. Just as FOL has the constant literals T and F, FOP has scalars that are literals with predefined real values. Like FOL, FOP contains functions that map objects to objects and dictates that objects are mapped to numerical values. An atom is a predicate that is applied to a multiple of objects. A literal is a scalar multiple of an atom. A FOP formula is a chain of literals that combine operators and quantifiers as defined recursively in Figure 1. Quantifiers for FOP are supremum and infimum, analog to1Boundedness is critical to the completeness of our process."}, {"heading": "3.2 Relationship to FOL and MILP", "text": "We give a formal semantic for FOP (Sec. 5) as a direct generalization of the FOL resolution (Sec. 3.3). For us, the model (FOP) is a model (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOP). (FOL). (FOL). (FOP). (FOL). (FOP). (FOL). (FOP). (FOL). (FOL). (FOL). (FOL). (FOL). (FOL). (FOP. FOP. FOP. FOP. (FOL). FOP. (FOP. FOP. FOP. (FOL). (FOP. (FOL). (FOP). (FOP. FOP. (FOP). (FOP). (FOP). (FO. FO. FOP. FO. (FOP.). (FO. (FO.). (FOP). (FO. (FO.). FOP). (FO. (FOP). (FOP). FO. (FOP). FO. (FO. FO. FOP). (FO. FOP). (FO. (FO. FO. FOP). FO. FO. FO. (FOP). (FO. FO. FO. (FO. FOP). (FO. FOP). (FO. FO. FO. FO. FO. (FO. (FO. FO.). (FO. FO.). (FOP). FO. (FO. (FO. FO.). FO. (FO.). (FO.). FO. FO. (FO. FO.). (FO. (FO. (FO.). (FO. FO.). (FO.). (FO.). (FO. (FO.). (FO. (FO"}, {"heading": "3.3 SEMANTICS", "text": "A model M is a tuple (O, F, P) in which O is a list of objects, F is a table of function values, and P is a table of predicate values. A rating I (under M) is a mapping of syntactical variables on model objects. (We must use M for the set of possible models, and I (M) for the set of possible ratings under M. In the context of a model, we do not yet know how free variables are quantified.) A soil expression then evaluates a constant function by mapping each rating to the same object or a real number. (Especially in the context of a model M, a set S, it evaluates a constant function by mapping every real number."}, {"heading": "4 NORMAL FORMS", "text": "To facilitate the analysis, we need to translate sentences into one of two normal forms: the minimal normal form or the reduced normal form. The minimal normal form preserves the value of a sentence in all models, while the reduced normal form only maintains the sign of the value. In both forms, we can shift negation and scalar multiplication inwards to eliminate and reorder the normal form. Our translation into the minimal normal form is analogous to the well-known subjunctive normal form in FOL. We could also define a symmetrical translation into a maxnormal form that responds isomorphic to the minimum normal form."}, {"heading": "5 INFERENCE", "text": "Faced with a sentence in a reduced normal form, the most basic question of argumentation is to determine whether it is feasible, that is, whether its value is at least zero. By using our feasibility test as a primitive, we can limit the value of a general FOP sentence by binary search. In the following, we will also generalize the FOL concept of entanglement and use the feasibility test to test whether a FOP sentence is a logical match - is the set of predicates mentioned in Lij. We will say that conclusions are the problem of generalizing the consequences of a given judgment, and coeff (P, Lij) is the sum of the absolute values of scalar multipliers in the letters based on P in Lij. quence of another."}, {"heading": "5.1 ENTAILMENT", "text": "In this subsection, we focus on the integer fragment of FOP; we discuss the consequences for mixed-integer FOP in sec. 6. In FOL, the sentence S \"(written S\" = S \") includes iff S\" in any model that fulfills S. \"To extend this definition to FOP, we replace satisfaction with feasibility: Definition 5.1 (FOP withdrawal). It should be clear that FOP withdrawal generalizes the FOL problem. [Value (S,\" M) \u2265 0]. Using the translations from Table 1, along with an appropriate threshold (0 for trans. A \"12 for trans. B\"), it should be clear that FOP withdrawal generalizes the FOL problem. In FOL, we can reduce satisfaction testing to satisfaction testing: S \"= S\" iff S \"is satisfactory. (This evidence strategy is called refutation)."}, {"heading": "5.2 FEASIBILITY", "text": "To prove the value (S) < 0 for a mixed integer sentence S in reduced, normal form, we can apply the following noteworthy inference procedures: (a) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) D (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S n n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S n (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S n (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) S (n) n) S (n) S (n) S (n) n (n) S (n) S (n) n) S (n) n) S (n) n) S (n) n (n) S (n) n) S (n) n) S (n) n (n) n) S (n) n) n (n) S (n) S (n) n) n (n (n) S (n) n) n (n) S (n) n) n (n) S (n) n (n) n) S (n (n) n (n) S (n) n (n) S (n (n) n (n) n (n) S (n) n (n) n) n (n (n) S (n (n) S (n) n) S (n) n (n) n (n) S (n) n) S (n) n (n) n (n) S (n) n) n) n"}, {"heading": "5.3 LIFTED INFERENCE", "text": "In fact, it is so that most of us are able to abide by the rules that they have imposed on themselves. (...) In fact, it is so that they are able to determine for themselves. (...) It is not so that they do it. (...) It is as if they do it. (...) \"It is as if they do it. (...)\" \"It is as if they do it.\" (...) \"It is so.\" (...) \"It is as if\" (...). \"(...).\" (...). \"(...).\" (...). \"(...).\" (...). \"(...).\" (...). \"(...).\" (...). \"(...).\" (...). \"(...).\" (...). \"(.\" (). \"(...).\" (...). \"(.\" (). \"(...).\" (). \"(...).\" (). \"(...).\" (...). \"().\" (...). \"().\" (). \"(...).\" (). \").\" (... \"().\" (). \").\" (). \"(.\"). \"(...\"). \"(.\"). \"(.\"). \"(.\"). \"(.\"). \"(.\"). \").\" (. \").\" (. \").\" (. \").\" (. \").\" (. \").\" (. \").\" (. \").\"). \"(.\")."}, {"heading": "5.4 AN EXAMPLE PROOF", "text": "For a simple demonstration of evidence by upended gomory sections, we consider the FOP sentence F = x (i) \u2212 2x (S (i)) from paragraph 3.2. An interesting fact about F is that in any satisfactory model x (i) must be \"ultimately\" zero: every time we go from i to S (i), the corresponding xum must be decreased by at least a factor of two to reach 0 in at most one upended gomory section (8) = 3 steps. In particular, for all i, x (S (S (i))))) must be zero. Formally, we can point to F | = \u2212 x (S (S (S (i))) with a single upended gomory section: Choose four copies of F and one copy of the implicit sentence 8 \u2212 x (i). Standardize (say using the variables j, k, l, m, n, n) and apply the substitution {i, k, S, S, S (S), S (i) (m) i (m)."}, {"heading": "6 EXTENSIONS", "text": "As defined so far, FOP cannot think about object equality; that is, it cannot test whether two objects that appear syntactically different are actually the same. Instead, object equality is shown only because all the function and predicate expressions encompassing the two different names are the same in their entirety. To represent equality, we could add a differentiated equality predicate (x, y) to FOP, along with an appropriate new semantics. Another useful extension to FOP would be a sum more quantifying: when I define our context evaluation, we define x. P as a sum, across all the different objects y from our modelM, the value of P under I [x, y]."}, {"heading": "7 CONCLUSION AND FUTURE WORK", "text": "We have defined first-order programs and established formal methods of thinking about first-order programs, including a solid and complete sequencing process for integer FOP. Our future work includes expanding FOP to include equality and a sum quantifier. We also plan to experiment with overridden Gomory sections, demonstrating their ability to make evidence more compact than corresponding evidence in FOL or MILP. Finally, we plan to implement our sophisticated sample search procedure and test it with real-world examples such as first-order stochastic programs. To quickly find evidence in real-world examples, we need to generalize standard FOL search control heuristics to FOP."}, {"heading": "Acknowledgements", "text": "The authors are grateful for the support of the Computer Science Study Panel Program of DARPA (grant HR0011-07-10026, all authors), a Lucent-Alcatel Fellowship (author SAH) and the ARO scholarship W911NF-08-1-0301 (authors GJG and MD)."}], "references": [{"title": "Cooperative task assignment of unmanned aerial vehicles in adversarial environments", "author": ["M. Alighanbari", "J.P. How"], "venue": "In Proc. IEEE American Control Conference (ACC),", "citeRegEx": "Alighanbari and How.,? \\Q2005\\E", "shortCiteRegEx": "Alighanbari and How.", "year": 2005}, {"title": "Mathematical programming embeddings of logic", "author": ["V. Borkar", "V. Chandru", "S. Mitter"], "venue": "Journal of Automatic Reasoning,", "citeRegEx": "Borkar et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Borkar et al\\.", "year": 2002}, {"title": "Lifted first-order probabilistic inference", "author": ["R. Braz", "E. Amir", "D. Roth"], "venue": "In IJCAI-05,", "citeRegEx": "Braz et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Braz et al\\.", "year": 2005}, {"title": "Optimization methods for logical inference", "author": ["Vijay Chandru", "John Hooker"], "venue": null, "citeRegEx": "Chandru and Hooker.,? \\Q1999\\E", "shortCiteRegEx": "Chandru and Hooker.", "year": 1999}, {"title": "Formulation of linear problems and solution by a universal machine", "author": ["B.C. Eaves", "U.G. Rothblum"], "venue": "Mathematical Programming,", "citeRegEx": "Eaves and Rothblum.,? \\Q1994\\E", "shortCiteRegEx": "Eaves and Rothblum.", "year": 1994}, {"title": "AMPL: A Modeling Language for Mathematical Programming", "author": ["R. Fourer", "D.M. Gay", "B.W. Kernighan"], "venue": "http://ampl.com", "citeRegEx": "Fourer et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Fourer et al\\.", "year": 2002}, {"title": "Outline of an algorithm for integer solutions to linear programs", "author": ["R.E. Gomory"], "venue": "Bull. Amer. Math. Soc.,", "citeRegEx": "Gomory.,? \\Q1958\\E", "shortCiteRegEx": "Gomory.", "year": 1958}, {"title": "Dud\u0131\u0301k. First-order mixed integer linear programming", "author": ["G. Gordon", "S.A. Hong"], "venue": "Technical Report CMU-ML-09-108,", "citeRegEx": "Gordon et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gordon et al\\.", "year": 2009}, {"title": "Probabilistic entityrelationship models, PRMs, and plate models", "author": ["D. Heckerman", "C. Meek", "D. Koller"], "venue": "Introduction to statistical relational learning,", "citeRegEx": "Heckerman et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Heckerman et al\\.", "year": 2007}, {"title": "Mixed logical/linear programming", "author": ["J.N. Hooker", "M.A. Osrio"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "Hooker and Osrio.,? \\Q1999\\E", "shortCiteRegEx": "Hooker and Osrio.", "year": 1999}, {"title": "BLOG: Probabilistic models with unknown objects", "author": ["B. Milch", "B. Marthi", "D. Sontag", "S. Russell", "D.L. Ong"], "venue": "In IJCAI-05,", "citeRegEx": "Milch et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Milch et al\\.", "year": 2005}, {"title": "IBAL: A probabilistic rational programming language", "author": ["A. Pfeffer"], "venue": "In IJCAI-01,", "citeRegEx": "Pfeffer.,? \\Q2001\\E", "shortCiteRegEx": "Pfeffer.", "year": 2001}, {"title": "The independent choice logic and beyond", "author": ["D. Poole"], "venue": "Probabilistic Inductive Logic Programming: Theory and Application,", "citeRegEx": "Poole.,? \\Q2008\\E", "shortCiteRegEx": "Poole.", "year": 2008}, {"title": "A stochastic formulation of the dynamic assignment problem, with an application to truckload motor carriers", "author": ["W.B. Powell"], "venue": "Transportation Sci.,", "citeRegEx": "Powell.,? \\Q1996\\E", "shortCiteRegEx": "Powell.", "year": 1996}, {"title": "Integer linear programming inference for conditional random fields", "author": ["D. Roth", "W. Yih"], "venue": "In ICML-05,", "citeRegEx": "Roth and Yih.,? \\Q2005\\E", "shortCiteRegEx": "Roth and Yih.", "year": 2005}, {"title": "Artificial Intelligence: A modern Approach", "author": ["S. Russell", "P. Norvig"], "venue": "Pearson Education, Inc.,", "citeRegEx": "Russell and Norvig.,? \\Q2003\\E", "shortCiteRegEx": "Russell and Norvig.", "year": 2003}, {"title": "Mixed-integer programming methods for finding Nash equilibria", "author": ["T. Sandholm", "A. Gilpin", "V. Conitzer"], "venue": "In AAAI-05,", "citeRegEx": "Sandholm et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sandholm et al\\.", "year": 2005}, {"title": "Markov logic in infinite domains", "author": ["P. Singla", "P. Domingos"], "venue": "In UAI-07,", "citeRegEx": "Singla and Domingos.,? \\Q2007\\E", "shortCiteRegEx": "Singla and Domingos.", "year": 2007}, {"title": "Lifted first-order belief propagation", "author": ["P. Singla", "P. Domingos"], "venue": "In AAAI-08,", "citeRegEx": "Singla and Domingos.,? \\Q2008\\E", "shortCiteRegEx": "Singla and Domingos.", "year": 2008}, {"title": "On the use of integer programming models in AI planning", "author": ["T. Vossen", "M. Ball", "R.H. Smith"], "venue": "In IJCAI-99,", "citeRegEx": "Vossen et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Vossen et al\\.", "year": 1999}, {"title": "Integer and Combinatorial Optimization", "author": ["L. Wolsey", "G.L. Nemhauser"], "venue": null, "citeRegEx": "Wolsey and Nemhauser.,? \\Q1988\\E", "shortCiteRegEx": "Wolsey and Nemhauser.", "year": 1988}], "referenceMentions": [{"referenceID": 19, "context": "1996]); or, in AI, we can use MILPs for planning [Vossen et al., 1999] or to reason about uncertainty due to the actions of other agents in a nonzero-sum game [Sandholm et al.", "startOffset": 49, "endOffset": 70}, {"referenceID": 16, "context": ", 1999] or to reason about uncertainty due to the actions of other agents in a nonzero-sum game [Sandholm et al., 2005]; or, in ML, we can use MILPs for MAP inference in graphical models (e.", "startOffset": 96, "endOffset": 119}, {"referenceID": 14, "context": ", [Roth and Yih, 2005]); or, in cooperative control, we can use MILPs for task allocation under uncertainty [Alighanbari and How, 2005].", "startOffset": 2, "endOffset": 22}, {"referenceID": 0, "context": ", [Roth and Yih, 2005]); or, in cooperative control, we can use MILPs for task allocation under uncertainty [Alighanbari and How, 2005].", "startOffset": 108, "endOffset": 135}, {"referenceID": 5, "context": "One might try to add this capability to MILPs using a \u201cwrapper\u201d or \u201ccompiler\u201d such as AMPL [Fourer et al., 2002]: for example, to express a constraint that holds for all objects in a class, we can generate one copy of this constraint for every known object.", "startOffset": 91, "endOffset": 112}, {"referenceID": 7, "context": "For example, Hooker and Osrio [1999] give an overview of the area and a general framework called mixed logical/linear programming.", "startOffset": 13, "endOffset": 37}, {"referenceID": 8, "context": "Relational probabilistic languages (RPLs), such as plate models, probabilistic entity-relationship models [Heckerman et al., 2007], Markov logic networks [Richardson and Domingos, 2006], IBAL [Pfeffer, 2001], ICL [Poole, 2008], and BLOG [Milch et al.", "startOffset": 106, "endOffset": 130}, {"referenceID": 11, "context": ", 2007], Markov logic networks [Richardson and Domingos, 2006], IBAL [Pfeffer, 2001], ICL [Poole, 2008], and BLOG [Milch et al.", "startOffset": 69, "endOffset": 84}, {"referenceID": 12, "context": ", 2007], Markov logic networks [Richardson and Domingos, 2006], IBAL [Pfeffer, 2001], ICL [Poole, 2008], and BLOG [Milch et al.", "startOffset": 90, "endOffset": 103}, {"referenceID": 10, "context": ", 2007], Markov logic networks [Richardson and Domingos, 2006], IBAL [Pfeffer, 2001], ICL [Poole, 2008], and BLOG [Milch et al., 2005], combine probabilistic and logical representations, and allow us to reason about uncertain statements about classes of objects.", "startOffset": 114, "endOffset": 134}, {"referenceID": 10, "context": "(Exceptions include BLOG [Milch et al., 2005], which allows unknown numbers of objects; ICL [Poole, 2008], which allows unknown or infinite numbers of objects; and the work of Singla and Domingos [2007], which extends Markov logic to infinite domains, but makes strong assumptions in order to guarantee well-defined probability distributions.", "startOffset": 25, "endOffset": 45}, {"referenceID": 12, "context": ", 2005], which allows unknown numbers of objects; ICL [Poole, 2008], which allows unknown or infinite numbers of objects; and the work of Singla and Domingos [2007], which extends Markov logic to infinite domains, but makes strong assumptions in order to guarantee well-defined probability distributions.", "startOffset": 54, "endOffset": 67}, {"referenceID": 18, "context": "[2005] on lifted variable elimination requires a known set of objects, and lifted belief propagation [Singla and Domingos, 2008] was described in terms of finite MLNs, leaving infinite domains explicitly for future work.", "startOffset": 101, "endOffset": 128}, {"referenceID": 9, "context": "(Exceptions include BLOG [Milch et al., 2005], which allows unknown numbers of objects; ICL [Poole, 2008], which allows unknown or infinite numbers of objects; and the work of Singla and Domingos [2007], which extends Markov logic to infinite domains, but makes strong assumptions in order to guarantee well-defined probability distributions.", "startOffset": 26, "endOffset": 203}, {"referenceID": 2, "context": ", the work of Braz et al. [2005] on lifted variable elimination requires a known set of objects, and lifted belief propagation [Singla and Domingos, 2008] was described in terms of finite MLNs, leaving infinite domains explicitly for future work.", "startOffset": 14, "endOffset": 33}, {"referenceID": 2, "context": ", the work of Braz et al. [2005] on lifted variable elimination requires a known set of objects, and lifted belief propagation [Singla and Domingos, 2008] was described in terms of finite MLNs, leaving infinite domains explicitly for future work. In contrast, full lifted inference for firstorder logic is well understood (see, e.g., Russell and Norvig [2003]), and our inference procedure for FOP parallels the well-known resolution procedure for FOL.", "startOffset": 14, "endOffset": 360}, {"referenceID": 6, "context": "B allows us to identify our lifted Gomory cuts (Sec. 5) as a direct generalization of FOL resolution (see Gordon et al. [2009]).", "startOffset": 35, "endOffset": 127}, {"referenceID": 7, "context": "We can also translate the objective [Gordon et al., 2009], or simply test whether there is a solution of value c by adding the clause (x(1)\u2212 c).", "startOffset": 36, "endOffset": 57}, {"referenceID": 7, "context": "We show [Gordon et al., 2009] that the Tseitin transformation leads to at most a constant-factor growth in the length of our formula (compared to potentially-exponential growth for the simpler distributive procedure).", "startOffset": 8, "endOffset": 29}, {"referenceID": 7, "context": "Ensure that binary operators are applied only in the order \u2227, \u2228, +, using either distributive laws or a procedure analogous to the Tseitin transformation for propositional logic [Gordon et al., 2009].", "startOffset": 178, "endOffset": 199}, {"referenceID": 7, "context": "To do so, we need the following lemmas, whose proofs can be found in Gordon et al. [2009].", "startOffset": 69, "endOffset": 90}, {"referenceID": 7, "context": "A more detailed description of the procedure can be found in Gordon et al. [2009].", "startOffset": 61, "endOffset": 82}, {"referenceID": 7, "context": "Combined with the proofs of correctness for our construction of the feasibility problem and our propositionalization process [Gordon et al., 2009], Lemmas 5.", "startOffset": 125, "endOffset": 146}, {"referenceID": 6, "context": "For our purposes, a particularly convenient solver is based on Gomory cuts for integer linear programs [Gomory, 1958], along with their generalization to mixed-integer programs.", "startOffset": 103, "endOffset": 117}, {"referenceID": 20, "context": "The details of Gomory cuts are available in standard texts on optimization [Wolsey and Nemhauser, 1988]; here, we only require the following properties.", "startOffset": 75, "endOffset": 103}, {"referenceID": 6, "context": "We start by describing our inference rule, which we call lifted Gomory cuts. This rule is a generalization of FOL\u2019s resolution rule, in which we combine two clauses by eliminating a resolvent literal which appears positively in one and negatively in the other. (See Gordon et al. [2009] for a proof.", "startOffset": 64, "endOffset": 287}, {"referenceID": 7, "context": "Detailed proof sketches of the following two lemmas can be found in Gordon et al. [2009].", "startOffset": 68, "endOffset": 89}, {"referenceID": 7, "context": "1 does not hold for mixed-integer sentences (see Gordon et al. [2009] for a counterexample), so we can no longer reduce entailment to feasibility checking by using a margin to convert from a < bound to a \u2264 bound.", "startOffset": 49, "endOffset": 70}], "year": 2009, "abstractText": "Mixed integer linear programming (MILP) is a powerful representation often used to formulate decision-making problems under uncertainty. However, it lacks a natural mechanism to reason about objects, classes of objects, and relations. First-order logic (FOL), on the other hand, excels at reasoning about classes of objects, but lacks a rich representation of uncertainty. While representing propositional logic in MILP has been extensively explored, no theory exists yet for fully combining FOL with MILP. We propose a new representation, called first-order programming or FOP, which subsumes both FOL and MILP. We establish formal methods for reasoning about first order programs, including a sound and complete lifted inference procedure for integer first order programs. Since FOP can offer exponential savings in representation and proof size compared to FOL, and since representations and proofs are never significantly longer in FOP than in FOL, we anticipate that inference in FOP will be more tractable than inference in FOL for corresponding problems.", "creator": "TeX"}}}