{"id": "1206.3437", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jun-2012", "title": "Improving the Asymmetric TSP by Considering Graph Structure", "abstract": "Recent works on cost based relaxations have improved Constraint Programming (CP) models for the Traveling Salesman Problem (TSP). We provide a short survey over solving asymmetric TSP with CP. Then, we suggest new implied propagators based on general graph properties. We experimentally show that such implied propagators bring robustness to pathological instances and highlight the fact that graph structure can significantly improve search heuristics behavior. Finally, we show that our approach outperforms current state of the art results.", "histories": [["v1", "Fri, 15 Jun 2012 12:15:31 GMT  (108kb,D)", "http://arxiv.org/abs/1206.3437v1", "Technical report"]], "COMMENTS": "Technical report", "reviews": [], "SUBJECTS": "cs.DM cs.AI cs.DS", "authors": ["jean-guillaume fages", "xavier lorca"], "accepted": false, "id": "1206.3437"}, "pdf": {"name": "1206.3437.pdf", "metadata": {"source": "CRF", "title": "Improving the Asymmetric TSP by Considering Graph Structure", "authors": ["Jean-Guillaume Fages", "Xavier Lorca"], "emails": ["Jean-Guillaume.Fages@mines-nantes.fr", "Xavier.Lorca@mines-nantes.fr"], "sections": [{"heading": "1 Introduction", "text": "Faced with an n-node, m arc complete directed weighted graph G = (V, A, f: A \u2192 R), the Asymmetric Traveling Salesman Problem [1] (ATSP) consists in finding a sub-subgraph G \u2032 = (V, A \u2032, f) of G that forms a Hamiltonian circuit at minimal cost. This NP-Hard problem is one of the most studied by the Operation Research Community. It has various practical applications, such as vehicle routing problems of logistics, microchip production optimization or even scheduling. The symmetric TSP is well handled by linear programming techniques [1]. However, such methods suffer from the addition of lateral constraints and asymmetric cost matrix, whereas limitation does not have programming models. Since the real world is not symmetric and industrial, we include limitations such as time frames, transients, load capacities and several other constraints."}, {"heading": "2 Background", "text": "Consider a directed graph G = (V, A). A strongly networked component (SCC) is a maximum subgraph of G, so that for each pair of nodes {a, b} \u0445V 2 a path from a to b and from b to a. Such a graph is unique and contains no circuit. We associate G and GR with two functions: sccOf: V \u2192 VR and nodesOf: VR \u2192 V V. The method sccOf can be represented by an n-size integer array and remove any loop. Since each node of V belongs to exactly one SCC of VR, the method nodesOf can be represented by two integer arrays: sccOf: V \u2192 VR and nodesOf: VR \u2192 V V. The method sccOf can be represented by an n-size integer array. Since each node of V belongs to exactly one SCC of VR, the method nodesOf can be represented by two integer arrays."}, {"heading": "3 Related Work", "text": "This section describes the state of the art of existing approaches to solving ATSP with CP. We distinguish the structural filtering that ensures that a solution is a Hamiltonian path from the cost-based intersection that focuses mainly on solving costs. Then, we examine a few representative branching heuristics. Given a directed weighted graph G = (V, A, f) and a function f: A \u2192 R, the ATSP consists in finding a partial subgraph G \u2032 = (V, A \u2032, f) of G that forms a Hamiltonian cycle of minimal costs. A simple ATSP model in CP that includes a graph variable GV can essentially be described as minimizing the cost of GM arcs and maintaining a Hamiltonian circuit with a connectivity restriction and some limitation (one predecessor and one successor for each node)."}, {"heading": "3.1 Structural filtering algorithms", "text": "This year it has come to the point that it will be able to drown the aforementioned lcihsrcnlrVo in order to rouse them."}, {"heading": "3.2 Cost-based filtering algorithms", "text": "It's not like it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be a way, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, and how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied, how it's going to be applied"}, {"heading": "3.3 Branching heuristics", "text": "Branch strategies form a fundamental aspect of CP that can drastically reduce the search space. We are examining dedicated heuristics here, as the literature is not clear which branch euristics should be used. Pesant et al. have introduced a sparse heuristics [25] that has the singularity of taking into account the occurrence of successors and ignoring the costs. In this way, this heuristics is based on the graph structure. It behaves as follows: First, it selects the group of nodes X without successors in GM and the smallest group of successors in GP. Second, it finds the node x-X that maximizes the (x, y) \"AP.\""}, {"heading": "4 Considering the reduced graph", "text": "In this section we will consider a sub-problem that is not a subset of constraints as usual, but consists of the entire ATSP itself, which is applied to a more restrictive scope: the reduced graph of GP. The structure of the reduced graph has already been similarly considered for path distribution problems [3,5]. In this section we will first examine structural properties resulting from looking at the reduced graph. Second, we will show how such information can be adapted to some current implicit models, including cost-based considerations."}, {"heading": "4.1 Structural properties", "text": "This year it has come to the point that it is a purely reactionary, reactionary, reactionary, reactionary and reactionary project."}, {"heading": "4.2 Strengthening other models", "text": "It is a question to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what is a question to what is a question, to what is a question to what is a question, to what is a question to what is a question, to what is a question to what is a question, to what is a question to what is a question to what is a question, to what is a question to what is a question to what is a question, to what is a question to what is a question to what is a question, to what is a question to what is a question to what is a question to what is a question, to what is a question to what is a question to what is a question to what is a question to what is a question, to what is a question, to what is a question to what is a question to what extent it is a question to what is a question, what is a question to what is a question, to what is a question to what is a question to what is a question to what is a question, to what is a question to what is a question, to what is a question to what is a question to what is a question to what is a question, to what is a question to what is a question to"}, {"heading": "5 The Held and Karp method", "text": "The lagrange relaxation of Held and Karp has first been defined for the solution of symmetric TSP costs (then the costs are changed). Instead of converting asymmetric instances into symmetric ones by transforming Jonker and Volgenant [4], we can adapt them directly to the asymmetric scheme: However, for each iteration, we define k two penalties per node v, V, \u03c0 (k) in (v) and \u03c0 (k) from (v), respectively equal (g) (v) \u2212 1), (k) (v), (k), (k), (k), (k), (k), (k), (k), (k), (k), (k), (k), (v), (k), (k), (k, k, k, k, k, k, k, k, k, (k), k, k (k), k (k, k, k, k), k (k, k, k, k), k (k, k, k), k (k, k, k), k (k, k, k, k, k (k), k (k, k, k), k (k, k, k, k (k), k (k, k), k (k, k, k, k, k, k), k (k (k, k), k (k, k, k, k, k), k (k (k, k, k, k, k, k), k (k (k, k), k (k, k, k, k (k), k, k (k, k), k (k (k, k, k, k, k), k (k (k, k, k), k (k (k), k (k, k, k), k (, k (k), k (k), k (k (k, k, k, k, k), k (, k (k, k, k), k (, k (k), k (, k, k), k (, k, k, k (, k, k), k (, k), k ("}, {"heading": "6 Experimental study", "text": "In this section we will present some experiments we have done to measure the effects of the graph structure. We will show that branching by graph structure only exceeds the current state of the art, while implicit graph structure filtering avoids pathological behavior on hard instances at negligible time consumption. However, our implementations have been performed within the CHOCO solver, which is an open source Java library. Tests have been performed on a Macbook pro running OS X 10.7.2 and with a 2.7 GHz Intel core i7 and 8Go of DDR3. We set a limit of 3 Go to be associated with the JVM. We have tested TSP and ATSP instance of the TSPLIB. For each of us, we refer to the number of search nodes | and report time measurements in seconds."}, {"heading": "6.1 Dedicated heuristics", "text": "We experimentally compare the branching heuristics RemoveMaxRC and Sparse in Section 3.3. We also present three variants of these methods: - EnforceMaxRC consists in enforcing the arc of maximum replacement costs. It is the opposite of RemoveMaxRC. - RemoveMaxMC consists in removing the non-tree arc of maximum marginal costs, i.e. the arc that would bring the highest cost increase if enforced. - This heuristics can require an important number of decisions to solve the problem. There is little chance of making wrong decisions, but if an error is made early in the search tree, it could be catastrophic for resolution. - EnforceSparse, which first selects the group of nodes X without a successor in GM and the smallest group of successors in GP. - Second, it finds the node x, c, which maximizes the branches."}, {"heading": "6.2 Structural filtering", "text": "We then examine the benefit we could derive from adding some implicit filter algorithms with RemoveMaxMC and sparse heuristics to the BASIC model: - ARB: arborescence and antiarborescence propagators used together. - POS: The model is based on the position of the nodes, with an AllDifferent constraint bound consistency. - AD: AllDifferent propagator adapted to graph variables, with GAC. - BST: Reduced Path propagator with a lagrange relaxation based on a BST, in addition to the usual hero carp scheme. - ALL: combine all of the above propagators."}, {"heading": "6.3 Results and analysis", "text": "The main differences are the fact that we have a fixed point and an implementation of the system and that it is much more efficient."}, {"heading": "6.4 Consequences on symmetric instances", "text": "In this section, we will show the impact of our study on the (symmetric) Traveling Salesman Problem (TSP), which can be considered an undirected variant of the ATSP, using an undirected model, as in [4]: Each node now has two neighbors. Implicit structural filter algorithms mentioned above are defined for directed graphs and therefore cannot be used to solve the TSP. However, we propose to measure the impact of the EnforceSparse heuristics we introduced, which appeared to be the best choice for solving the ATSP. As can be seen in Table 3, the EnforceSparse heuristics cannot be defined for fixed variables that require two values. We propose to measure the impact of the EnforceSparse heuristics that we introduced and that appeared to be the best choice for solving the ATSP."}, {"heading": "7 Conclusion", "text": "We gave a brief overview of the solution of the ATSP in CP and showed how the general graph properties resulting from taking the reduced graph into account could improve existing models, such as the Minimum Spanning Tree Relaxation. As a future work, this could be extended to the Plan Oriented TSP (TSPTW for example), as Reduced Path finds some precedents in linear time. We also provided some implementation guidelines to have efficient algorithms, including the Held and Karp method. More specifically, the EnforceSparse heuristic delivers impressive results, while implicit structural filtering improves robustness for a negligible amount of time. Our experiments also allow us to determine that the graph structure has a serious impact on resolution: not just cost issues. More specifically, the EnforceSparse heuristic delivers impressive results, while structural filtering improves robustness for a negligible amount of time."}, {"heading": "Acknowledgement", "text": "The authors thank Pascal Benchimol and Louis-Martin Rousseau for interesting discussions and the provision of their C + + implementation, Charles Prud'Homme for useful implementation advice and the Pays de la Loire Regional Council for its financial support."}], "references": [{"title": "The Traveling Salesman Problem: A Computational Study", "author": ["David L. Applegate", "Robert E. Bixby", "Vasek Chv\u00e1tal", "William J. Cook"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2006}, {"title": "Combining Tree Partitioning, Precedence, and Incomparability", "author": ["Nicolas Beldiceanu", "Pierre Flener", "Xavier Lorca"], "venue": "Constraints. Constraints,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2008}, {"title": "Necessary Condition for Path Partitioning Constraints", "author": ["Nicolas Beldiceanu", "Xavier Lorca"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2007}, {"title": "Conception d\u2019une contrainte globale de chemin", "author": ["Hadrien Cambazard", "Eric Bourreau"], "venue": "In Journe\u0301es Nationales sur la re\u0301solution Pratique de Proble\u0300mes NP Complets,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "Algorithms and codes for the assignment problem", "author": ["Giorgio Carpaneto", "Silvano Martello", "Paolo Toth"], "venue": "Annals of Operations Research,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1988}, {"title": "Solving Small TSPs with Constraints", "author": ["Yves Caseau", "Fran\u00e7ois Laburthe"], "venue": "In International Conference on Logic Programming,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1997}, {"title": "A tabu search heuristic for the static multi-vehicle dial-a-ride problem", "author": ["Jean-Fran\u00e7ois Cordeau", "Gilbert Laporte"], "venue": "Transportation Research Part B: Methodological,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2003}, {"title": "CP(Graph): Introducing a Graph Computation Domain in Constraint Programming", "author": ["Gr\u00e9goire Dooms", "Yves Deville", "Pierre Dupont"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2005}, {"title": "The Minimum Spanning Tree Constraint", "author": ["Gr\u00e9goire Dooms", "Irit Katriel"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "The \u201dNot-Too-Heavy Spanning Tree", "author": ["Gr\u00e9goire Dooms", "Irit Katriel"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Revisiting the tree Constraint", "author": ["Jean-Guillaume Fages", "Xavier Lorca"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Lazy Clause Generation Reengineered", "author": ["Thibaut Feydy", "Peter J. Stuckey"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "An additive bounding procedure for the asymmetric travelling salesman problem", "author": ["Matteo Fischetti", "Paolo Toth"], "venue": "Mathematical Programming,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1992}, {"title": "Embedding Relaxations in Global Constraints for Solving TSP and TSPTW", "author": ["Filippo Focacci", "Andrea Lodi", "Michela Milano"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2002}, {"title": "A Hybrid Exact Algorithm for the TSPTW", "author": ["Filippo Focacci", "Andrea Lodi", "Michela Milano"], "venue": "INFORMS Journal on Computing,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2002}, {"title": "Efficient algorithms for finding minimum spanning trees in undirected and directed graphs", "author": ["Harold N. Gabow", "Zvi Galil", "Thomas H. Spencer", "Robert E. Tarjan"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1986}, {"title": "Incremental Cycle Detection, Topological Ordering, and Strong Component Maintenance", "author": ["Bernhard Haeupler", "Telikepalli Kavitha", "Rogers Mathew", "Siddhartha Sen", "Robert E. Tarjan"], "venue": "The Computing Research Repository, CoRR,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "The traveling-salesman problem and minimum spanning trees: Part II", "author": ["Michael Held", "Richard M. Karp"], "venue": "Mathematical Programming,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1971}, {"title": "An effective implementation of the Lin-Kernighan traveling salesman heuristic", "author": ["Keld Helsgaun"], "venue": "European Journal of Operational Research,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2000}, {"title": "A Filter for the Circuit Constraint", "author": ["Latife Gen\u00e7 Kaya", "John N. Hooker"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2006}, {"title": "A Simpler Minimum Spanning Tree Verification Algorithm", "author": ["Valerie King"], "venue": "In Workshop on Algorithms and Data Structures, WADS,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1995}, {"title": "The Hungarian Method for the Assignment Problem", "author": ["Harold W. Kuhn"], "venue": "Years of Integer Programming", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1958}, {"title": "Robust and Parallel Solving of a Network Design Problem", "author": ["Claude Le Pape", "Laurent Perron", "Jean-Charles R\u00e9gin", "Paul Shaw"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2002}, {"title": "An Exact Constraint Logic Programming Algorithm for the Traveling Salesman Problem with Time Windows", "author": ["Gilles Pesant", "Michel Gendreau", "Jean-Yves Potvin", "Jean-Marc Rousseau"], "venue": "Transportation Science,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1998}, {"title": "Using Dominators for Solving Constrained Path Problems", "author": ["Luis Quesada", "Peter Van Roy", "Yves Deville", "Rapha\u00ebl Collet"], "venue": "In Practical Aspects of Declarative Languages,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2006}, {"title": "A Filtering Algorithm for Constraints of Difference in CSPs", "author": ["Jean-Charles R\u00e9gin"], "venue": "In National Conference on Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1994}, {"title": "Tutorial: Modeling Problems in Constraint Programming", "author": ["Jean-Charles. R\u00e9gin"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2004}, {"title": "Simpler and Incremental Consistency Checking and Arc Consistency Filtering Algorithms for the Weighted Spanning Tree Constraint. In Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization", "author": ["Jean-Charles R\u00e9gin"], "venue": "Problems, CPAIOR,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "The Weighted Spanning Tree Constraint Revisited. In Integration of AI  and OR Techniques in Constraint Programming for Combinatorial Optimization", "author": ["Jean-Charles R\u00e9gin", "Louis-Martin Rousseau", "Michel Rueher", "Willem Jan van Hoeve"], "venue": "Problems, CPAIOR,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2010}, {"title": "Weakly Monotonic Propagators", "author": ["Christian Schulte", "Guido Tack"], "venue": "In Principles and Practice of Constraint Programming, CP,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2009}, {"title": "Depth-First Search and Linear Graph Algorithms", "author": ["Robert E. Tarjan"], "venue": "SIAM Journal on Computing,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1972}, {"title": "O(n log n) Filtering Algorithms for Unary Resource Constraint", "author": ["Petr Vi\u013a\u0131m"], "venue": null, "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2004}], "referenceMentions": [{"referenceID": 0, "context": "Given a n node, m arc complete directed weighted graph G = (V,A, f : A\u2192 R), the Asymmetric Traveling Salesman Problem [1] (ATSP) consists in finding a partial subgraph G\u2032 = (V,A\u2032, f) of G which forms a Hamiltonian circuit of minimum cost.", "startOffset": 118, "endOffset": 121}, {"referenceID": 0, "context": "The symmetric TSP is well handled by linear programming techniques [1].", "startOffset": 67, "endOffset": 70}, {"referenceID": 22, "context": "[24] and detailed by R\u00e9gin [28] and Dooms et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "[24] and detailed by R\u00e9gin [28] and Dooms et al.", "startOffset": 27, "endOffset": 31}, {"referenceID": 7, "context": "[9].", "startOffset": 0, "endOffset": 3}, {"referenceID": 13, "context": "However, it is often more interesting to convert such a model in order to find a path instead of a circuit [15,25].", "startOffset": 107, "endOffset": 114}, {"referenceID": 23, "context": "However, it is often more interesting to convert such a model in order to find a path instead of a circuit [15,25].", "startOffset": 107, "endOffset": 114}, {"referenceID": 25, "context": "A higher level of consistency can be achieved by using a graph-based AllDifferent constraint maintaining a node-successor perfect matching [27].", "startOffset": 139, "endOffset": 143}, {"referenceID": 5, "context": "Caseau and Laburthe [7] suggested the simple and efficient NoCycle constraint to remove circuits of the graph.", "startOffset": 20, "endOffset": 23}, {"referenceID": 24, "context": "For instance, Quesada [26] suggested the general propagator DomReachability which maintains the transitive closure and the dominance", "startOffset": 22, "endOffset": 26}, {"referenceID": 1, "context": "It is nothing else but a simplification of the Tree constraint [2] recently improved to a O(n+m) worst case time complexity [12].", "startOffset": 63, "endOffset": 66}, {"referenceID": 10, "context": "It is nothing else but a simplification of the Tree constraint [2] recently improved to a O(n+m) worst case time complexity [12].", "startOffset": 124, "endOffset": 128}, {"referenceID": 31, "context": "It has to be noticed that this approach is related to disjunctive scheduling [33]: nodes are tasks of duration 1 which are executed on the same machine.", "startOffset": 77, "endOffset": 81}, {"referenceID": 19, "context": "enforce some cut-sets of size two [4] while Kaya and Hooker use graph separators for pruning [21].", "startOffset": 93, "endOffset": 97}, {"referenceID": 12, "context": "Fischetti and Toth [14] suggested a general bounding procedure for combining different relaxations of the same problem.", "startOffset": 19, "endOffset": 23}, {"referenceID": 21, "context": "It requires O(n(m + n log n)) time [23] to compute a first minimum cost assignment but then O(n) time [6] to check consistency and filter incrementally.", "startOffset": 35, "endOffset": 39}, {"referenceID": 4, "context": "It requires O(n(m + n log n)) time [23] to compute a first minimum cost assignment but then O(n) time [6] to check consistency and filter incrementally.", "startOffset": 102, "endOffset": 105}, {"referenceID": 14, "context": "Some interesting evaluations are provided by [16], but are mainly related to the TSP with time windows constraints.", "startOffset": 45, "endOffset": 49}, {"referenceID": 15, "context": "compute a MST with a degree restriction at one node [17].", "startOffset": 52, "endOffset": 56}, {"referenceID": 15, "context": "The second option is to use Prim\u2019s algorithm which requires O(m+n log n) time with Fibonacci heaps [17] or O(m log n) time if binomial heaps are used instead.", "startOffset": 99, "endOffset": 103}, {"referenceID": 27, "context": "[29,30] made the Weighted Spanning Tree constraint which ensures consistency, provides a complete pruning and detects mandatory arcs incrementally, within O(\u03b1m) time.", "startOffset": 0, "endOffset": 7}, {"referenceID": 28, "context": "[29,30] made the Weighted Spanning Tree constraint which ensures consistency, provides a complete pruning and detects mandatory arcs incrementally, within O(\u03b1m) time.", "startOffset": 0, "endOffset": 7}, {"referenceID": 8, "context": "Dooms and Katriel [10,11] presented a more complex Minimum Spanning Tree constraint which maintains a graph and its spanning tree, pruning according to King\u2019s algorithm [22].", "startOffset": 18, "endOffset": 25}, {"referenceID": 9, "context": "Dooms and Katriel [10,11] presented a more complex Minimum Spanning Tree constraint which maintains a graph and its spanning tree, pruning according to King\u2019s algorithm [22].", "startOffset": 18, "endOffset": 25}, {"referenceID": 20, "context": "Dooms and Katriel [10,11] presented a more complex Minimum Spanning Tree constraint which maintains a graph and its spanning tree, pruning according to King\u2019s algorithm [22].", "startOffset": 169, "endOffset": 173}, {"referenceID": 17, "context": "An improvement of the MST relaxation is the approach of Held and Karp [19], adapted for CP by Benchimol et al.", "startOffset": 70, "endOffset": 74}, {"referenceID": 12, "context": "This relaxation has been studied by [14,15] who provide a O(n) time filtering algorithm based on primal/dual linear programs.", "startOffset": 36, "endOffset": 43}, {"referenceID": 13, "context": "This relaxation has been studied by [14,15] who provide a O(n) time filtering algorithm based on primal/dual linear programs.", "startOffset": 36, "endOffset": 43}, {"referenceID": 15, "context": "[17].", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "The Lagrangian MSA relaxation, with a MSA computation based on Edmonds\u2019 algorithm, has been suggested in [7].", "startOffset": 105, "endOffset": 108}, {"referenceID": 23, "context": "have introduced Sparse heuristic [25] which has the singularity of considering occurrences of successors and ignoring costs.", "startOffset": 33, "endOffset": 37}, {"referenceID": 13, "context": "solve the TSPTW [15] by guiding the search with time windows, which means that the efficiency of CP for solving the ATSP should not rely entirely on its branching heuristic.", "startOffset": 16, "endOffset": 20}, {"referenceID": 2, "context": "The structure of the reduced graph has already been considered in a similar way for path partitioning problems [3,5].", "startOffset": 111, "endOffset": 116}, {"referenceID": 3, "context": "The structure of the reduced graph has already been considered in a similar way for path partitioning problems [3,5].", "startOffset": 111, "endOffset": 116}, {"referenceID": 29, "context": "It is a monotonic generalization of the algorithm depicted in [31].", "startOffset": 62, "endOffset": 66}, {"referenceID": 3, "context": "Necessary conditions for this propagator have already been partially highlighted in [5].", "startOffset": 84, "endOffset": 87}, {"referenceID": 30, "context": "Data structures: Compute the SCC of GP (with Tarjan\u2019s algorithm [32]) and build the reduced graph GR = (VR, AR).", "startOffset": 64, "endOffset": 68}, {"referenceID": 16, "context": "[18] worked on maintaining SCC and a topological ordering of nodes in the reduced graph, but under the addition of arcs.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "Such information can be directly used to generate lazy clauses [13].", "startOffset": 63, "endOffset": 67}, {"referenceID": 24, "context": "Some propagators such as DomReachability [26], require the transitive closure of the graph.", "startOffset": 41, "endOffset": 45}, {"referenceID": 27, "context": "We assume that the reader is already familiar with this constraint, otherwise papers [29,30] should be considered as references.", "startOffset": 85, "endOffset": 92}, {"referenceID": 28, "context": "We assume that the reader is already familiar with this constraint, otherwise papers [29,30] should be considered as references.", "startOffset": 85, "endOffset": 92}, {"referenceID": 27, "context": "Finally, we run Kruskal\u2019s algorithm as described in [29,30] until the BST has n\u22121 arcs.", "startOffset": 52, "endOffset": 59}, {"referenceID": 28, "context": "Finally, we run Kruskal\u2019s algorithm as described in [29,30] until the BST has n\u22121 arcs.", "startOffset": 52, "endOffset": 59}, {"referenceID": 27, "context": "A faster way to compute a BST is to perform Prim\u2019s algorithm on successive SCC, but this method does not enable to use the efficient filtering algorithm of R\u00e9gin [29].", "startOffset": 162, "endOffset": 166}, {"referenceID": 17, "context": "in [19,20].", "startOffset": 3, "endOffset": 10}, {"referenceID": 18, "context": "in [19,20].", "startOffset": 3, "endOffset": 10}, {"referenceID": 27, "context": "Then, we run a Kruskal\u2019s based MST to apply the complete filtering of [4,29].", "startOffset": 70, "endOffset": 76}, {"referenceID": 6, "context": "One can see an analogy with local search techniques that explore infeasible solutions in order to reach the best (feasible) ones more quickly [8].", "startOffset": 142, "endOffset": 145}, {"referenceID": 29, "context": "1 A propagator P , involving a graph variable GV and a filtering function f : GV 7\u2192 GV is said to be monotonic [31] iff for any GV \u2032 \u2286 GV, f(GV \u2032) \u2286 f(GV ), where GV \u2032 \u2286 GV \u21d4 GP \u2286 GP \u2227GM \u2286 GM .", "startOffset": 111, "endOffset": 115}, {"referenceID": 5, "context": "Subtour elimination is performed by a special purpose incremental propagator, inspired from the NoCycle constraint [7].", "startOffset": 115, "endOffset": 118}], "year": 2012, "abstractText": "Recent works on cost based relaxations have improved Constraint Programming (CP) models for the Traveling Salesman Problem (TSP). We provide a short survey over solving asymmetric TSP with CP. Then, we suggest new implied propagators based on general graph properties. We experimentally show that such implied propagators bring robustness to pathological instances and highlight the fact that graph structure can significantly improve search heuristics behavior. Finally, we show that our approach outperforms current state of the art results.", "creator": "LaTeX with hyperref package"}}}