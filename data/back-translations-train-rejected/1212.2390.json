{"id": "1212.2390", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Dec-2012", "title": "On the complexity of learning a language: An improvement of Block's algorithm", "abstract": "Language learning is thought to be a highly complex process. One of the hurdles in learning a language is to learn the rules of syntax of the language. Rules of syntax are often ordered in that before one rule can applied one must apply another. It has been thought that to learn the order of n rules one must go through all n! permutations. Thus to learn the order of 27 rules would require 27! steps or 1.08889x10^{28} steps. This number is much greater than the number of seconds since the beginning of the universe! In an insightful analysis the linguist Block ([Block 86], pp. 62-63, p.238) showed that with the assumption of transitivity this vast number of learning steps reduces to a mere 377 steps. We present a mathematical analysis of the complexity of Block's algorithm. The algorithm has a complexity of order n^2 given n rules. In addition, we improve Block's results exponentially, by introducing an algorithm that has complexity of order less than n log n.", "histories": [["v1", "Tue, 11 Dec 2012 11:35:30 GMT  (4kb)", "http://arxiv.org/abs/1212.2390v1", "7 pages. Key Words: Language learning, rules of language, complexity, learning algorithms, evolution of language"]], "COMMENTS": "7 pages. Key Words: Language learning, rules of language, complexity, learning algorithms, evolution of language", "reviews": [], "SUBJECTS": "cs.CL cs.LG", "authors": ["eric werner"], "accepted": false, "id": "1212.2390"}, "pdf": {"name": "1212.2390.pdf", "metadata": {"source": "CRF", "title": "On the complexity of learning a language: An improvement of Block\u2019s algorithm", "authors": ["Eric Werner"], "emails": ["eric.werner@dpag.ox.ac.uk"], "sections": [{"heading": null, "text": "One of the hurdles to learning a language is learning the rules of the syntax of the language. Syntax rules are often arranged in such a way that, before one rule can be applied, another one must be applied. It has been assumed that in order to learn the order of the n! rules, one has to go through all the n! permutations. Thus, to learn the order of the 27 rules, 27! steps or 1,08889x1028 steps would be required, a number that is much greater than the number of seconds since the beginning of the universe! In a revealing analysis, the linguist Block ([Block 86], pp. 62-63, p. 238) showed that this enormous number of learning steps is reduced to a mere 377 steps assuming transitivity. We present a mathematical analysis of the complexity of Block's algorithm. The algorithm has a complexity of the order n2 that provides n rules. Furthermore, we improve the results of Block exponentially by introducing an algorithm that shows the complexity of Block's algorithm."}, {"heading": "1 Introduction 2", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 Block\u2019s algorithm 3", "text": "2.1 Block algorithm complexity...................... 32.2 A simpler formula that measures block algorithm complexity............. 3"}, {"heading": "3 A fast algorithm to learn the order of n rules 4", "text": "3.1 Faster Rule Algorithm..................... 43.2 Complexity of the Fast Rule Algorithm................. 53.3 A shorter but less precise complexity function................. 5"}, {"heading": "4 Examples comparing the performance of the algorithms 6", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 Introduction", "text": "One of the hurdles to learning a language is learning the rules of the syntax of the language. Rules of the syntax are often arranged in such a way that before you can apply one rule, you have to apply another. It was assumed that in order to learn the order of the n! rules, you have to go through all the n! permutations. Thus, to learn the order of the 27 rules, 27! steps or 1,08889x1028 steps would be required, a number that is much greater than the number of seconds since the beginning of the universe! In a brilliant analysis, the linguist Block ([Block 86], pp. 62-63, p. 238) showed that this enormous number of learning steps reduces to just 377 steps assuming transitivity."}, {"heading": "2 Block\u2019s algorithm", "text": "Given n rules R1... Rn we have to guess (learn) an unknown order of these rules. Starting with a given rule Y we have to position a rule X. To do this, we test (query, learn) whether X is before Y, if so, we put it before Y to give the order XY, otherwise we put it after Y, which leads to Y X. Now let's say we have i rules Y1..... Yi and we have a new place rule X, Block suggests that we test for each j if X < Yj, if so, all we have to do is put X before Yj in our order Y1...... Yi to give Y1..... Yi. The reason we can do this is because the rules are arranged linearly and therefore by transitivity we know that X is smaller than all rules beyond Y1."}, {"heading": "2.1 Complexity of Block\u2019s algorithm", "text": "If we know the order of the rules Y1... Yi, at most i-comparisons are needed to place our new rule X. So to learn the whole rule set R1... Rn it takes at most 1 + 2 +.. + i +.. + n steps. In this worst case, computer scientists measure the complexity of an algorithm. S (n) = n \u2211 i = 1i \u2212 1 = n \u2211 i = 2i (1) We subtract 1 (or start with 2 equivalent) because the first rule does not need to be tested or compared. Thus, we have defined a measure of the complexity of the block algorithm in terms of the number of queries or steps required to order n rules."}, {"heading": "2.2 A simpler formula measuring Block\u2019s algorithm\u2019s complex-", "text": "There is a simpler and shorter formula that eliminates the need to sum up the steps, and which can therefore be easily done with a calculator. It gives an accurate description of the steps required to order n rules: Exact complexity of Block's algorithm S (n) = (n2 \u2212 n) 2 + n \u2212 1 (2) Since the exponent of 2 ultimately exceeds any addition or division by a constant, the complexity of Block's algorithm is O (n2).For practical purposes, one would think that this is at most 27i = 1 i = 27 + 26 +.. + 2 = 377 This is, of course, a very modest number compared to the estimates of 27! = 1,08889x1028 steps of some linguists. For practical purposes, one would think that this is enough, and we should be content with such an amazing reduction in the steps needed to learn some 27 rules."}, {"heading": "3 A fast algorithm to learn the order of n rules", "text": "Block's algorithm moves linearly from beginning to end to find and test whether the rule is before or after the given rule. Instead, we adjust the binary search to start in the middle of the rule sequence and test the rule there, which will give us an exponential improvement over Block's method."}, {"heading": "3.1 A faster rule ordering algorithm", "text": "Given n rules and a rule X that needs to be put in the correct order, choose the middle rule, call it Y. This is possible because the rules are arranged linearly. Test whether the rule is applied before Y, if so, test the middle rule between Y and the first rule, otherwise test the middle rule between the end rule and rule Y. Repeat until it is finished."}, {"heading": "3.2 Complexity of the fast rule ordering algorithm", "text": "(In effect, we use the binary search to find the right place to insert our new rule Y, the n rules. And this process takes at most n logn steps. So, since we have n rules that we have to insert into most n rules, at most we have n log n steps to find the fully ordered sequence of n rules. In fact, the process takes fewer steps. Since we start gradually with n = 1, we call this one rule Y and a rule X and insert it. Faced with a sequence of n rules, we just need to run a test to see if X < Y or not. If it is smaller than Y, we insert X before we enter XY, which leads to the subsequence Y X. We then select the next rule Z and insert it. Given a sequence of n rules, we insert X in each step according to the binary search algorithm above."}, {"heading": "3.3 An shorter but less accurate complexity function", "text": "If we look at it from another perspective, we can shorten the description of the complexity function by using Factorial.n \u2212 1 \u2211 i = 0log (n \u2212 i) = log (n) + log (n \u2212 1) + log (n \u2212 2) +.. + log (n \u2212 1)) = log (n \u2212 1) (n \u2212 2)... (n \u2212 (n \u2212 1)) = log (n!) Thus, we can approximate the function B (n) in Equation 4 with the following formula: Bf (n) = log (n!). (5) However, this formulation has the disadvantage that the size of the factorial does not prove to be practicable from a mathematical point of view. Furthermore, the result is not as accurate in that it underestimates the complexity because the protocol is used instead of log (n!)."}, {"heading": "4 Examples comparing the performance of the al-", "text": "However, since there is an exponential improvement with the fast algorithm, the differences become more dramatic the greater the number of rules to be ordered. For example, some linguists would tell us that for 1,000 rules we have to search through 1000! possible combinations. If we use the block algorithm, we only need 500, 499 steps, a much smaller number. With our improved fast algorithm, we need less than 8,977 steps, which in this case is more than 55 times faster (smaller). So, if a child were to learn to order two rules per day (within its given set of rules), it would take 685 years to learn the sequence of 1,000 rules using the Block method. With our fast method, it would take about 12 years. The question is to what extent such considerations are relevant to learning a language."}], "references": [{"title": "Revolution und Revision in der generativen Theoriebildung", "author": ["R.L. Block"], "venue": "Gunter Narr Verlag, Tuebingen,", "citeRegEx": "Block,? \\Q1986\\E", "shortCiteRegEx": "Block", "year": 1986}], "referenceMentions": [], "year": 2012, "abstractText": "Language learning is thought to be a highly complex process. One of the hurdles in learning a language is to learn the rules of syntax of the language. Rules of syntax are often ordered in that before one rule can applied one must apply another. It has been thought that to learn the order of n rules one must go through all n! permutations. Thus to learn the order of 27 rules would require 27! steps or 1.08889x10 steps. This number is much greater than the number of seconds since the beginning of the universe! In an insightful analysis the linguist Block ([Block 86], pp. 62-63, p.238) showed that with the assumption of transitivity this vast number of learning steps reduces to a mere 377 steps. We present a mathematical analysis of the complexity of Block\u2019s algorithm. The algorithm has a complexity of order n given n rules. In addition, we improve Block\u2019s results exponentially, by introducing an algorithm that has complexity of order less than n log n.", "creator": "LaTeX with hyperref package"}}}