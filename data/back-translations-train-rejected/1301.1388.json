{"id": "1301.1388", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Utilizing ASP for Generating and Visualizing Argumentation Frameworks", "abstract": "Within the area of computational models of argumentation, the instantiation-based approach is gaining more and more attention, not at least because meaningful input for Dung's abstract frameworks is provided in that way. In a nutshell, the aim of instantiation-based argumentation is to form, from a given knowledge base, a set of arguments and to identify the conflicts between them. The resulting network is then evaluated by means of extension-based semantics on an abstract level, i.e. on the resulting graph. While several systems are nowadays available for the latter step, the automation of the instantiation process itself has received less attention. In this work, we provide a novel approach to construct and visualize an argumentation framework from a given knowledge base. The system we propose relies on Answer-Set Programming and follows a two-step approach. A first program yields the logic-based arguments as its answer-sets; a second program is then used to specify the relations between arguments based on the answer-sets of the first program. As it turns out, this approach not only allows for a flexible and extensible tool for instantiation-based argumentation, but also provides a new method for answer-set visualization in general.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:11 GMT  (115kb,D)", "http://arxiv.org/abs/1301.1388v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["g\\\"unther charwat", "johannes peter wallner", "stefan woltran"], "accepted": false, "id": "1301.1388"}, "pdf": {"name": "1301.1388.pdf", "metadata": {"source": "CRF", "title": "Utilizing ASP for Generating and Visualizing Argumentation Frameworks", "authors": ["G\u00fcnther Charwat", "Johannes Peter Wallner", "Stefan Woltran"], "emails": ["gcharwat@dbai.tuwien.ac.at", "wallner@dbai.tuwien.ac.at", "woltran@dbai.tuwien.ac.at"], "sections": [{"heading": "1 Introduction", "text": "In fact, most of them will be able to play by the rules."}, {"heading": "2 Preliminaries", "text": "We provide the necessary background of argumentation theory and ASP for this work. In particular, we will explain the argumentation process on the basis of argumentation frameworks [9] and briefly recall the concepts for disjunctive logic programs."}, {"heading": "2.1 Argumentation", "text": "In this section we will introduce formal reasoning, starting with the underlying process [7], which we will use in our context = 4 arguments available. The general process consists of three steps. Firstly, because there is a knowledge base, arguments and their relationships are instantiated, and after this instantiation, arguments are treated as abstract units, without taking into account their concrete content. Secondly, conflicts are resolved using appropriate semantics, with reasoning based on abstract instantiation, and finally conclusions are drawn. In this work, the knowledge base K is a (potentially inconsistent) set of arguments of logical formulas. We construct the formulas with the usual connectors."}, {"heading": "2.2 Answer-Set Programming", "text": "In this section we remember the basics of disjunctive logic programs in the context of the semantics answer sets [6, 22]. We fix a countable set of U of (domain) elements, also called constants. An atom is an expression p (t1,.., tn), where p is a predicate of unity n \u2265 0 and each ti is either a variable or an element of U. An atom is grounded if it is free of variables. BU denotes the set of all basic atoms above U. A (disjunctive) rule r is the forma1, and each ti is either a variable or an element of U.... bk, not bk + 1,., not bmwith n \u2265 0, m \u2265 k 0, n + m > 0, where a1,.. occond, an, b1,...., bm are atoms, and \"not\" stands for default negation. The header of r is the set (r) of H = a1."}, {"heading": "3 Instantiation-based Argumentation", "text": "In this section, we provide our ASP encodings for constructing arguments from a knowledge base K and a group of claims C. For input, each formula in K and C is given by the simple predicate kb (\u00b7) or kl (\u00b7), respectively. Example 5. Input is given by: {kb (a). kb (imp (a, b). kb (neg (b))). kb (b). cl (a). cl (a). cl (a). cl (imp (a, b). cl (neg (b). cl (b). cl (and (a, neg (b)))))). First, we introduce the ASP encodings to check whether a particular variable assignment is a model for a given formula (or not)."}, {"heading": "3.1 Model Checking", "text": "Propositional formulas provide the basis for constructing arguments and their attack relationships. In fact, we can express most of the defining properties of arguments (such as the inference of support for the claim) and attacks using formula formula formula F = wrong formula. In this section, we provide an ASP encoding that allows us to verify whether a formula \u03b1 is true under a given interpretation, i.e., I am a model for this formula. First, the formula is divided into sub-formulas until we obtain the contained atoms or constants. Due to previty, the following encodings are presented only as examples of the connectors."}, {"heading": "3.2 Forming Arguments", "text": "We derive the arguments from a knowledge base and a number of claims are false. Accordingly, [4] we must check whether the support implies the claim and whether the support is both minimal and consistent. To obtain arguments, we first guess exactly one claim and a subset of formulas from K. This assumption is encrypted as follows: The predicates fs () and S () are derived if the respective formula from K is included in the support of an argument. A = (S, C).Entailment: To be a valid argument, the support must include the claim, i.e. S | = C must hold."}, {"heading": "3.3 Identifying Conflicts between Arguments", "text": "We want to calculate attacks between arguments. Therefore, we first specify encodings that are used by each type of attack (such as defeat and outright defeat) and then present encodings to calculate these types of attack. To judge all arguments, we must first \"flatten\" the sets of responses obtained with arguments. We specify this using the predicates: (A, fs, \u00b7) and as (A, claim, \u00b7). A is a numerical key that identifies the argumentation.Example 8. We illustrate this using the a1, a2 and a3 responses from Example 7. This reasoning is given by the following facts: {as (1, fs, a). as (1, sclaim, a). as (2, imp (a, b). as (2, sclaim)."}, {"heading": "3.4 Overall Approach at a Glance", "text": "In summary, the overall process of our instantiation-based approach to generating argumentation frames consists of the following steps: 1. A knowledge base K and a number of claims are used as input; 2. The coding \u03c0argument = \u03c0modelcheck = \u03c0arg-horizontal-horizontal approach defines how arguments are derived from K and C: \u03c0modelcheck is generally used to evaluate formulas under truth assignments; within a framework, a claim C and a support argument S K are guessed for each argument A = (S, C); the resulting arguments are \"plated\" and used as input for follow-up attacks; 4. Minimize \u03c0ltations < horizontal coding and guarantee that support is minimal and that S is a consistent set of formulas; 3. The resulting arguments are \"plated\" and used as input for subsequent attacks."}, {"heading": "4 Visualization of Argumentation Frameworks", "text": "To visualize argumentation frames, we use the dedicated tool ARVis5. ARVis is intended for visualizing response sets and their relationships by means of a directed graph. Each node in the graph represents a response set and a directed edge between two arguments represents a relationship. We now describe the process of creating and visualizing argumentation frames by using the encryption of arguments and approaches. ARVis provides a wizard that handles the respective steps: 1. Obtaining arguments and a problem instance must be specified within ARVis. ARVis computes the arguments by calling an ASP solver. 2. Flatten arguments obtained in the previous step are \"plated,\" i.e. a single set of facts is generated to argue about all obtained arguments when calculated."}, {"heading": "5 Conclusion", "text": "In this article, we have presented a novel ASP-based tool for constructing reasoning frames from a given knowledge base. We have provided here the specific ASP encodings that are used to obtain such frames when using logic-based arguments cf. [4]. However, similar encodings are possible for further reasoning approaches and are the subject of future work, as well as a performance evaluation of the presented approach to test its scalability with large knowledge bases. In designing our tool ARVis, we have tried to keep it as flexible as possible so that the concrete construction of the frame can be specified in the logic programs. As has been shown, ARVis is therefore not only a tool for generating and visualizing reasoning frames, but also for graphically displaying relationships between answer sets in a user-specific way. Ongoing work therefore focuses on areas of application in which it is the relationship between the answer sets (and the programs cannot support the individual response-sets, or the specific relationship between the answers)."}], "references": [{"title": "Identifying the Core of Logic-Based Argumentation Systems", "author": ["L. Amgoud", "P. Besnard", "S. Vesic"], "venue": "In ICTAI\u201911,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "Learning by diagramming Supreme Court oral arguments", "author": ["K. Ashley", "N. Pinkwart", "C. Lynch", "V. Aleven"], "venue": "In ICAIL\u201907,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Semantics of Abstract Argument Systems", "author": ["P. Baroni", "M. Giacomin"], "venue": "Argumentation in Artificial Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "A logic-based theory of deductive arguments", "author": ["P. Besnard", "A. Hunter"], "venue": "Artif. Intell.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "DUNESDialogic and Argumentative Negotiation Educational Software-Technical Realization", "author": ["J. B\u00f6rding", "A. Voss", "J. Walther", "V. Wolff", "A. Ocakli", "R. Groot", "B. Baurens"], "venue": "In ICTE\u201902,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Commun. ACM,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "On the evaluation of argumentation formalisms", "author": ["M. Caminada", "L. Amgoud"], "venue": "Artif. Intell.,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "ASPVIZ: Declarative Visualisation and Animation Using Answer Set Programming", "author": ["O. Cliffe", "M.D. Vos", "M. Brain", "J.A. Padget"], "venue": "In ICLP\u201908,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "On the Acceptability of Arguments and its Fundamental Role in Nonmonotonic Reasoning, Logic Programming and n-Person Games", "author": ["P.M. Dung"], "venue": "Artif. Intell.,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1995}, {"title": "Complexity-Sensitive Decision Procedures for Abstract Argumentation", "author": ["W. Dvo\u0159\u00e1k", "M. J\u00e4rvisalo", "J.P. Wallner", "S. Woltran"], "venue": "In KR\u201912,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Answer-set programming encodings for argumentation frameworks", "author": ["U. Egly", "S.A. Gaggl", "S. Woltran"], "venue": "Argument and Computation,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "On the Computational Cost of Disjunctive Logic Programming: Propositional Case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1995}, {"title": "Answer Set Programming: A Primer", "author": ["T. Eiter", "G. Ianni", "T. Krennwallner"], "venue": "In Reasoning Web,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "ASPIDE: Integrated Development Environment for Answer Set Programming", "author": ["O. Febbraro", "K. Reale", "F. Ricca"], "venue": "In LPNMR,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Potassco: The Potsdam Answer Set Solving Collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": "AI Commun.,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "An Overview of the Carneades Argumentation Support System", "author": ["T. Gordon"], "venue": "Dialogue and Argumentation. An Examination of Douglas Walton\u2019s Theories of Reasoning,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "Instantiating abstract argumentation with classical logic arguments: Postulates and properties", "author": ["N. Gorogiannis", "A. Hunter"], "venue": "Artif. Intell.,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2011}, {"title": "Computer supported argumentation and collaborative decision making: the HERMES system", "author": ["N. Karacapilidis", "D. Papadias"], "venue": "Inf. Syst.,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2001}, {"title": "Kara: A System for Visualising and Visual Editing of Interpretations for Answer-Set Programs", "author": ["C. Kloim\u00fcllner", "J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "In WLP\u201911,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "Stable Models and an Alternative Logic Programming Paradigm. In The Logic Programming Paradigm \u2013 A 25-Year Perspective, pages 375\u2013398", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1999}, {"title": "Logic Programming with Stable Model Semantics as a Constraint Programming Paradigm", "author": ["I. Niemel\u00e4"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1999}, {"title": "Properties and Complexity of Some Formal Inter-agent Dialogues", "author": ["S. Parsons", "M. Wooldridge", "L. Amgoud"], "venue": "J. Log. Comput.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "Araucaria: Software for Argument Analysis, Diagramming and Representation", "author": ["C. Reed", "G. Rowe"], "venue": "Int. Journal on Artif. Intel. Tools,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2004}, {"title": "ArguNet a software tool for collaborative argumentation analysis and research", "author": ["D. Schneider", "C. Voigt", "G. Betz"], "venue": "In CMNA VII,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2007}, {"title": "Cohere: Towards Web 2.0 Argumentation", "author": ["S.B. Shum"], "venue": "In COMMA\u201908,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "ArguMed - A Template-Based Argument Mediation System for Lawyers", "author": ["B. Verheij"], "venue": "In JURIX\u201998,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1998}, {"title": "IDPDraw, a tool used for visualizing answer sets. https://dtai.cs", "author": ["J. Wittocx"], "venue": "kuleuven.be/krr/software/visualisation,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2009}], "referenceMentions": [{"referenceID": 6, "context": "Instantiation-based argumentation [7] is a central paradigm in nonmonotonic reasoning since it gives a formal handle to separate the logical and non-classical contents of reasoning in the presence of contradicting information.", "startOffset": 34, "endOffset": 37}, {"referenceID": 3, "context": "In [4] the process is described with an underlying propositional knowledge base using minimal sets of consistent support classically entailing the claim.", "startOffset": 3, "endOffset": 6}, {"referenceID": 8, "context": "The obtained arguments and the relation between them yield a so-called argumentation framework [9].", "startOffset": 95, "endOffset": 98}, {"referenceID": 2, "context": "Argumentation frameworks are then evaluated with one of the numerous semantics for abstract argumentation available, resulting in potentially multiple acceptable sets of arguments [3].", "startOffset": 180, "endOffset": 183}, {"referenceID": 15, "context": "Notable exceptions are the Carneades system, which can construct arguments using heuristics [16] and the recent TOAST implementation ar X iv :1 30 1.", "startOffset": 92, "endOffset": 96}, {"referenceID": 22, "context": "The reason for the lack of implementations is potentially twofold: First, due to the inherent high complexity of the problem; already constructing a single argument is hard for the second level of the polynomial hierarchy [23].", "startOffset": 222, "endOffset": 226}, {"referenceID": 0, "context": "Secondly, standard instantiation schemes for propositional knowledge bases result in infinite argumentation frameworks even for finite knowledge bases [1].", "startOffset": 151, "endOffset": 154}, {"referenceID": 5, "context": "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.", "startOffset": 88, "endOffset": 99}, {"referenceID": 20, "context": "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.", "startOffset": 88, "endOffset": 99}, {"referenceID": 21, "context": "The first obstacle calls for highly expressive languages, making answer-set programming [6, 21, 22] (ASP, for short) a well suited candidate.", "startOffset": 88, "endOffset": 99}, {"referenceID": 10, "context": "ASPARTIX [11] or CEGARTIX [10].", "startOffset": 9, "endOffset": 13}, {"referenceID": 9, "context": "ASPARTIX [11] or CEGARTIX [10].", "startOffset": 26, "endOffset": 30}, {"referenceID": 14, "context": "Thus we can make use of the high sophistication modern ASP systems have reached [15, 20].", "startOffset": 80, "endOffset": 88}, {"referenceID": 19, "context": "Thus we can make use of the high sophistication modern ASP systems have reached [15, 20].", "startOffset": 80, "endOffset": 88}, {"referenceID": 7, "context": "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].", "startOffset": 7, "endOffset": 10}, {"referenceID": 13, "context": "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].", "startOffset": 19, "endOffset": 23}, {"referenceID": 18, "context": "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].", "startOffset": 30, "endOffset": 34}, {"referenceID": 27, "context": "ASPViz [8], ASPIDE [14], Kara [19] and IDPDraw [29].", "startOffset": 47, "endOffset": 51}, {"referenceID": 1, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 4, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 10, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 17, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 23, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 24, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 25, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 26, "context": "[2, 5, 11, 18, 24\u201326, 28], including Debategraph2 and Rationale3).", "startOffset": 0, "endOffset": 25}, {"referenceID": 8, "context": "In particular we will explain the argumentation process based on argumentation frameworks [9] as well as briefly recall the concepts for disjunctive logic programs.", "startOffset": 90, "endOffset": 93}, {"referenceID": 6, "context": "We start with the underlying process [7], which we will utilize in our context.", "startOffset": 37, "endOffset": 40}, {"referenceID": 3, "context": "The instantiation step now constructs arguments and relations among them based on the information available in K according to [4].", "startOffset": 126, "endOffset": 129}, {"referenceID": 8, "context": "The abstract representation we utilize for this purpose is the widely studied argumentation framework [9].", "startOffset": 102, "endOffset": 105}, {"referenceID": 16, "context": "Indeed, [17] identify conditions for rational and consistent end results, which require the existence of specific arguments, which must be included in C.", "startOffset": 8, "endOffset": 12}, {"referenceID": 0, "context": "On the other hand, this restriction is in line with the concept of cores of argumentation frameworks [1], which try to preserve desired properties while using only a subset of all possible arguments.", "startOffset": 101, "endOffset": 104}, {"referenceID": 16, "context": "We take the attack definitions from [17] and illustrate two types, defeat and directed defeat.", "startOffset": 36, "endOffset": 40}, {"referenceID": 22, "context": "A more detailed computational complexity analysis can be found in [23].", "startOffset": 66, "endOffset": 70}, {"referenceID": 5, "context": "In this section we recall the basics of disjunctive logic programs under the answer-sets semantics [6, 22].", "startOffset": 99, "endOffset": 106}, {"referenceID": 21, "context": "In this section we recall the basics of disjunctive logic programs under the answer-sets semantics [6, 22].", "startOffset": 99, "endOffset": 106}, {"referenceID": 14, "context": "4 Note that the syntax of our encodings is specific to the grounder gringo [15].", "startOffset": 75, "endOffset": 79}, {"referenceID": 3, "context": "According to [4], we have to check whether the support entails the claim and if the support is subset minimal as well as consistent.", "startOffset": 13, "endOffset": 16}, {"referenceID": 11, "context": "Unsatisfiability of the formula S \u2227 \u00acC can be checked by making use of the saturation technique [12]: We first assign true(entail , x) or false(entail , x) to each atom x in the formula using a disjunctive rule.", "startOffset": 96, "endOffset": 100}, {"referenceID": 12, "context": "[13]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "Our approach is different from other available ASP visualization tools: ASPViz [8] takes two answer-set programs as input, one for the problem encoding and one for the visualization.", "startOffset": 79, "endOffset": 82}, {"referenceID": 27, "context": "IDPDraw [29] works in a similar fashion, which augments the presentation by providing also time points to show the result in different evolutionary states.", "startOffset": 8, "endOffset": 12}, {"referenceID": 18, "context": "Kara [19] from the SeaLion development environment for ASP also provides visualization of answer-sets using special predicates.", "startOffset": 5, "endOffset": 9}, {"referenceID": 13, "context": "ASPIDE [14] gives the user the opportunity to visualize the dependency graph of the input program and thus allows for another type of representation.", "startOffset": 7, "endOffset": 11}, {"referenceID": 3, "context": "[4] are employed.", "startOffset": 0, "endOffset": 3}], "year": 2013, "abstractText": "Within the area of computational models of argumentation, the instantiation-based approach is gaining more and more attention, not at least because meaningful input for Dung\u2019s abstract frameworks is provided in that way. In a nutshell, the aim of instantiation-based argumentation is to form, from a given knowledge base, a set of arguments and to identify the conflicts between them. The resulting network is then evaluated by means of extension-based semantics on an abstract level, i.e. on the resulting graph. While several systems are nowadays available for the latter step, the automation of the instantiation process itself has received less attention. In this work, we provide a novel approach to construct and visualize an argumentation framework from a given knowledge base. The system we propose relies on Answer-Set Programming and follows a two-step approach. A first program yields the logic-based arguments as its answer-sets; a second program is then used to specify the relations between arguments based on the answer-sets of the first program. As it turns out, this approach not only allows for a flexible and extensible tool for instantiation-based argumentation, but also provides a new method for answer-set visualization in general.", "creator": "TeX"}}}