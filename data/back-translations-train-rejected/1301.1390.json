{"id": "1301.1390", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Eliminating Unfounded Set Checking for HEX-Programs", "abstract": "HEX-programs are an extension of the Answer Set Programming (ASP) paradigm incorporating external means of computation into the declarative programming language through so-called external atoms. Their semantics is defined in terms of minimal models of the Faber-Leone-Pfeifer (FLP) reduct. Developing native solvers for HEX-programs based on an appropriate notion of unfounded sets has been subject to recent research for reasons of efficiency. Although this has lead to an improvement over naive minimality checking using the FLP reduct, testing for foundedness remains a computationally expensive task. In this work we improve on HEX-program evaluation in this respect by identifying a syntactic class of programs, that can be efficiently recognized and allows to entirely skip the foundedness check. Moreover, we develop criteria for decomposing a program into components, such that the search for unfounded sets can be restricted. Observing that our results apply to many HEX-program applications provides analytic evidence for the significance and effectiveness of our approach, which is complemented by a brief discussion of preliminary experimental validation.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:22 GMT  (38kb,D)", "http://arxiv.org/abs/1301.1390v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["thomas eiter", "michael fink", "thomas krennwallner", "christoph redl", "peter sch\\\"uller"], "accepted": false, "id": "1301.1390"}, "pdf": {"name": "1301.1390.pdf", "metadata": {"source": "CRF", "title": "Eliminating Unfounded Set Checking for HEX-Programs", "authors": ["Thomas Eiter", "Michael Fink", "Thomas Krennwallner", "Christoph Redl", "Peter Sch\u00fcller"], "emails": ["eiter@kr.tuwien.ac.at", "fink@kr.tuwien.ac.at", "tkren@kr.tuwien.ac.at", "redl@kr.tuwien.ac.at", "ps@kr.tuwien.ac.at"], "sections": [{"heading": null, "text": "Keywords: Answer Set Programming, Nonmonotonic Reasoning, Ununded Sets, FLP Semantics"}, {"heading": "1 Introduction", "text": "In fact, most of them will be able to play by the rules that they have set themselves, and they will be able to play by the rules that they have set themselves."}, {"heading": "2 Preliminaries", "text": "In this section we start with some basic definitions, and then we introduce the syntax and semantics of HEX programs."}, {"heading": "3 Deciding the Necessity of the UFS Check", "text": "An alternative to searching for unfounded sets is an explicit construction of the reduct and a search for smaller models. However, it has been found that the minimal verification of the unfounded sets is more efficient than any other sets that have not been discovered by the usual ASP solvers in order to include external sources, as their behavior is not fully captured by the ASP solvers. In this section, we have formalized these ideas and defined a decision that allows us to decide whether another unfounded set that has not been discovered by the ordinary ASP solvers is necessary. Finally, we define a class of programs that do not require additional unfounded sets."}, {"heading": "4 Program Decomposition", "text": "(U) (U) (U) (U) () (U) () (U) () () (U) () () (U) () () (U) () () (U) () () (U) () () () (U) () () (U) () () () (U) () () (U) () () () (U) () () () (U) () () (U) () () (U) () (U) () (U) () (U) () (U) (U) (U) (U) () (U) () () (U) () () () () (U) () () () () (U) () () () () (U) () () () (U) () () () (U) () () () (U) () () () (U) () () (U) () () (U) () () (U) () () (U) () (U) () () (U) () () (U) () () (U) () (U) () () (U) () (U) (U) () (U) () (U) () () (U) (U) () (U) () (U) () (U) (U) () (U) () (U) () (U) (U) (U) (U) (() (U) () () (U) (U) (U () (U) (U) ((U) (U () (() (() () () (U) (U) (U () (U) (() (U () (U) (U () (() (U () (U ((() () (() () () (U) (U () (U) (U () ((() (() () ((U) () (U) (() () () (U () () ((U (U"}, {"heading": "10 2 126.54 0 80.00 36.78% 40 278.98 16 214.81 23.00%", "text": "In fact, the only unsubstantiated quantity that is not recognized in the evaluation is {r} of any interpretation A {Tr}. Finally, it can also be shown that splitting, i.e. the component-by-component test for soundness, does not lead to false unfounded quantities. Sentence 4. If U is an unfounded quantity of A wrt C. A is like U C, then U is an unfounded quantity of A C. If U = \u2205, then the result is trivial. By definition of \u0421C, we have H (r), C = \u2205 for all R. Condition of the proposition is U C. But then we have H (r) that U is an unfounded quantity of A for all r C and U. A. 2"}, {"heading": "5 Implementation and Evaluation", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}, {"heading": "6 Conclusion", "text": "The evaluation of HEX programs requires a minimum verification of model candidates, which is realized as an equivalent search for unfounded sets (UFS). However, this verification is mathematically expensive. Furthermore, the ASP solver, which is used as a backend, already excludes a \"limited\" form of unfounded verification, i.e. it verifies the program by considering external atoms as ordinary. Therefore, it excludes certain unfounded candidates. Therefore, a complete UFS search is a waste of resources, and the goal is to minimize the number of additional found pieces."}], "references": [{"title": "Equilibria in Heterogeneous Nonmonotonic Multi-Context Systems", "author": ["G. Brewka", "T. Eiter"], "venue": "AAAI\u201907. pp. 385\u2013390. AAAI Press", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Commun. ACM 54(12), 92\u2013103", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven disjunctive answer set solving", "author": ["C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. K\u00f6nig", "M. Ostrowski", "T. Schaub"], "venue": "KR\u201908. pp. 422\u2013432. AAAI Press", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2008}, {"title": "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games", "author": ["P.M. Dung"], "venue": "Artif. Intell. 77(2), 321\u2013357", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1995}, {"title": "Pushing efficient evaluation of HEX programs by modular decomposition", "author": ["T. Eiter", "M. Fink", "G. Ianni", "T. Krennwallner", "P. Sch\u00fcller"], "venue": "LPNMR\u201911. pp. 93\u2013106", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven ASP solving with external sources", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl"], "venue": "Theory and Practice of Logic Programming: Special Issue ICLP", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Exploiting Unfounded Sets for HEX-Program Evaluation. In: JELIA\u201912", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Sch\u00fcller"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Improving HEX-Program Evaluation based on Unfounded Sets", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Sch\u00fcller"], "venue": "Tech. Rep. INFSYS RR-1843-12-08, Institut f\u00fcr Informationssysteme, Technische Universit\u00e4t Wien, A-1040 Vienna, Austria", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Finding explanations of inconsistency in Multi-Context Systems", "author": ["T. Eiter", "M. Fink", "P. Sch\u00fcller", "A. Weinzierl"], "venue": "KR\u201910. pp. 329\u2013339. AAAI Press", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Exploiting conjunctive queries in description logic programs", "author": ["T. Eiter", "G. Ianni", "T. Krennwallner", "R. Schindlauer"], "venue": "Ann. Math. Artif. Intell. 53(1\u20134),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programming", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "IJCAI\u201905. pp. 90\u201396. Professional Book Center", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2005}, {"title": "Effective Integration of Declarative Rules with External Evaluations for Semantic-Web Reasoning", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "ESWC\u201906. pp. 273\u2013287. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Unfounded sets for disjunctive logic programs with arbitrary aggregates", "author": ["W. Faber"], "venue": "LPNMR\u201905. pp. 40\u201352. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Artif. Intell. 175(1), 278\u2013298", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Artif. Intell. 187\u2013188, 52\u201389", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Classical Negation in Logic Programs and Disjunctive Databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generat. Comput. 9(3\u20134), 365\u2013386", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "J. Autom. Reason. 36(4), 345\u2013377", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Splitting a logic program", "author": ["V. Lifschitz", "H. Turner"], "venue": "ICLP\u201994. pp. 23\u201337", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1994}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Trans. Comput. Logic 7(3), 499\u2013562", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2006}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artif. Intell. 138, 181\u2013234", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [{"referenceID": 1, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 155, "endOffset": 158}, {"referenceID": 19, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 216, "endOffset": 220}, {"referenceID": 18, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 226, "endOffset": 230}, {"referenceID": 16, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 240, "endOffset": 244}, {"referenceID": 14, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 256, "endOffset": 260}, {"referenceID": 10, "context": "To cater for this need, HEX-programs [11] extend ASP with so called external atoms, through which the user can couple any external data source with a logic program.", "startOffset": 37, "endOffset": 41}, {"referenceID": 4, "context": "[5]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 13, "context": "The semantics of a HEX-program \u03a0 is defined in terms of answer sets based on the FLP reduct [14]: an interpretation A is an answer set of \u03a0 , if and only if it is a \u2286-minimal model of the FLP-reduct f\u03a0 of \u03a0 wrt.", "startOffset": 92, "endOffset": 96}, {"referenceID": 15, "context": "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of f\u03a0, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.", "startOffset": 97, "endOffset": 101}, {"referenceID": 13, "context": "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of f\u03a0, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.", "startOffset": 190, "endOffset": 194}, {"referenceID": 12, "context": "Step 2 then checks whether A is a \u2286-minimal model or, equivalently, whether A is unfounded-free [13], i.", "startOffset": 96, "endOffset": 100}, {"referenceID": 13, "context": "Unfortunately, Step 2 is computationally expensive in general, and it is intractable even for Horn programs with nonmonotonic external atoms of polynomial complexity, as follows from results in [14].", "startOffset": 194, "endOffset": 198}, {"referenceID": 0, "context": ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.", "startOffset": 52, "endOffset": 55}, {"referenceID": 3, "context": ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "In particular, for the HEX-encoding of a Dung-style argumentation semantics [4] which we consider, the decomposition approach yields a considerable gain, as shown in a preliminary experimental evaluation.", "startOffset": 76, "endOffset": 79}, {"referenceID": 6, "context": "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.", "startOffset": 81, "endOffset": 87}, {"referenceID": 7, "context": "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.", "startOffset": 81, "endOffset": 87}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 10, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 32, "endOffset": 36}, {"referenceID": 15, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 129, "endOffset": 133}, {"referenceID": 10, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 166, "endOffset": 170}, {"referenceID": 11, "context": "However, as suitable safety conditions allow for using a grounding procedure [12], we limit our investigation to ground programs.", "startOffset": 77, "endOffset": 81}, {"referenceID": 15, "context": "Satisfaction of ordinary rules and ASP programs [16] is then extended to HEX-rules and programs in the obvious way, and the notion of extension ext(\u00b7,A) for external predicates &g with input lists p is naturally defined by ext(&g [p],A) = {c | f&g(A,p, c) = 1}.", "startOffset": 48, "endOffset": 52}, {"referenceID": 13, "context": "Definition 2 (FLP-Reduct [14]).", "startOffset": 25, "endOffset": 29}, {"referenceID": 15, "context": "A compatible set of a program\u03a0 is an interpretation \u00c2 such that (i) \u00c2 is an answer set [16] of the guessing program \u03a0\u0302 , and (ii) f&g(\u00c2,p, c) = 1 iff Te&g[p](c) \u2208 \u00c2 for all external atoms &g [p](c) in \u03a0 , i.", "startOffset": 87, "endOffset": 91}, {"referenceID": 6, "context": "This is justified by the following Definitions 5 and 6 and Theorem 1 from [7].", "startOffset": 74, "endOffset": 77}, {"referenceID": 12, "context": "(These results lift unfounded sets for disjunctive logic programs with arbitrary aggregates [13] to HEX-programs.", "startOffset": 92, "endOffset": 96}, {"referenceID": 6, "context": "Definition 5 (Unfounded Set [7]).", "startOffset": 28, "endOffset": 31}, {"referenceID": 6, "context": "Definition 6 (Unfounded-free Interpretations [7]).", "startOffset": 45, "endOffset": 48}, {"referenceID": 6, "context": "Theorem 1 (Characterization of Answer Sets [7]).", "startOffset": 43, "endOffset": 46}, {"referenceID": 3, "context": "In this benchmark we compute ideal set extensions for randomized instances of abstract argumentation frameworks [4] of different sizes.", "startOffset": 112, "endOffset": 115}, {"referenceID": 0, "context": "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.", "startOffset": 5, "endOffset": 8}, {"referenceID": 8, "context": "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.", "startOffset": 70, "endOffset": 73}, {"referenceID": 8, "context": "For the MCS benchmarks we tested 68 consistent and 88 inconsistent MCSs for which we compute inconsistency explanations [9].", "startOffset": 120, "endOffset": 123}, {"referenceID": 9, "context": "Another application of HEX-programs is the DL-plugin [10], which integrates description logics ontologies with rules.", "startOffset": 53, "endOffset": 57}, {"referenceID": 5, "context": "We used variants of the benchmarks presented in [6], which query wines from an ontology and classify them as red or white wines, where a wine is assumed to be white unless the ontology explicitly entails the contrary.", "startOffset": 48, "endOffset": 51}, {"referenceID": 2, "context": "Related to our work is [3], where a similar program decomposition is used, yet for ordinary programs only.", "startOffset": 23, "endOffset": 26}, {"referenceID": 2, "context": "While we consider e-cycles, which are specific for HEXprograms, the interest in [3] is with head-cycles with respect to disjunctive rule heads.", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "In fact, our implementation may be regarded as an extension of the work in [3], since the evaluation of \u03a0\u0302 follows their principles of performing UFS checks in case of head-cycles.", "startOffset": 75, "endOffset": 78}, {"referenceID": 17, "context": "Note however, that the applied component splitting does not generalize the well-known splitting theorem [18] as we consider only positive dependencies for ordinary atoms.", "startOffset": 104, "endOffset": 108}], "year": 2013, "abstractText": "HEX-programs are an extension of the Answer Set Programming (ASP) paradigm incorporating external means of computation into the declarative programming language through so-called external atoms. Their semantics is defined in terms of minimal models of the Faber-Leone-Pfeifer (FLP) reduct. Developing native solvers for HEX-programs based on an appropriate notion of unfounded sets has been subject to recent research for reasons of efficiency. Although this has lead to an improvement over naive minimality checking using the FLP reduct, testing for foundedness remains a computationally expensive task. In this work we improve on HEX-program evaluation in this respect by identifying a syntactic class of programs, that can be efficiently recognized and allows to entirely skip the foundedness check. Moreover, we develop criteria for decomposing a program into components, such that the search for unfounded sets can be restricted. Observing that our results apply to many HEX-program applications provides analytic evidence for the significance and effectiveness of our approach, which is complemented by a brief discussion of preliminary experimental validation.", "creator": "TeX"}}}