{"id": "1301.1392", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Answer Set Programming for Stream Reasoning", "abstract": "The advance of Internet and Sensor technology has brought about new challenges evoked by the emergence of continuous data streams. Beyond rapid data processing, application areas like ambient assisted living, robotics, or dynamic scheduling involve complex reasoning tasks. We address such scenarios and elaborate upon approaches to knowledge-intense stream reasoning, based on Answer Set Programming (ASP). While traditional ASP methods are devised for singular problem solving, we develop new techniques to formulate and process problems dealing with emerging as well as expiring data in a seamless way.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:44 GMT  (40kb,D)", "http://arxiv.org/abs/1301.1392v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["martin gebser", "torsten grote", "roland kaminski", "philipp obermeier", "orkunt sabuncu", "torsten schaub"], "accepted": false, "id": "1301.1392"}, "pdf": {"name": "1301.1392.pdf", "metadata": {"source": "CRF", "title": "Answer Set Programming for Stream Reasoning", "authors": ["M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "T. Schaub"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In fact, it is a kind of vanity that is able to hide itself without being able to suffocate it."}, {"heading": "2 Background", "text": "We assume that familiarity with (traditional) ASP input languages (cf. 2.) and (extended) logical programs (cf. [16,6]) is given. They form the basis for incremental logic programs [17], which contain additional key terms, \"# Base\" and \"# Volatility,\" which allow the partitioning of rules into a static, an accumulative and a transient part of the program. The latter usually refer to some constants representing a step number. Indeed, when the gradual increase in the step count begins, the rules are successively generated in a # cumulative block and associated with the basic rules from earlier steps."}, {"heading": "3 Modeling and Reasoning", "text": "The case studies listed below aim to illustrate certain characteristics in modeling and reasoning with time-lapsed logic programs and stream data, such as reading (b, 1), reading (b, 2), and reading (a, 3) using \"# forget i.\" directives. Basic rules mentioning such atoms are simplified \"automatically\" by brackets (cf. [17]). Listing 1. Stream of user access with a lifespan of 3 steps 1. # fleeting: 3. 2. Access (Alice, granted, 1). 3. # Volatile: 3. 4. access (Alice, denied, 3). 5. access (bob, denied, 3), fleeting: 6. Step 3. # Volatil: 3. Access (alice, denied, 2)."}, {"heading": "3.1 Access Control", "text": "In fact, it is in such a way that most people who are in a position to feel themselves in a position to move in the world, to stay in the world, in the world in which they live, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in, in"}, {"heading": "3.2 Overtaking Maneuver Recognition", "text": "Our second scenario deals with the detection of the completion of overtaking manoeuvres by a car, e.g. for signaling to the driver. (The detection follows the transitions of the machine in Figure 1.5, starting from a state that represents that a manoeuvre has not yet been initiated, sensor information about being \"behind,\" \"behind,\" \"before,\" \"behind,\" \"behind,\" \"behind,\" \"behind,\" \"behind,\" \"behind,\" \"behind,\" \"\" behind, \"\" \"behind,\" \"\" behind, \"\" \",\" \"\" behind, \"\" \",\" \"\" behind, \"\" \"\" behind, \"\" \",\" \"\". Additional transitions model the progression from one point to the next in the absence of signals: while such transitions in the states are neutral, B, and N, the final state F is abandoned (after the output \"OT!\")."}, {"heading": "3.3 Online Job Scheduling", "text": "This means that the work requirements must be carried out within a certain period of time without overlapping with each other. Unlike offline job planning [22], where the work requirements are known in advance, we are assuming a stream of work requirements provided via (short-term) work requirements, assuming that the execution of a job that completes the execution of a job I submitted in step T. For example, a (initial) segment of a job request must be as follows: # Step 1: 0. # volatile: 21st Job (1,1,1,1). Job (3,1,5,1). Job (4,1,5,1). Job (5,1): 0."}, {"heading": "4 Discussion", "text": "We have developed novel modeling approaches for continuous reasoning based on ASP, which uses time-shifting logic programs to capture window data in a natural way. Such data is transient and subject to routine operations. Consequently, the reasoning also focuses on a fixed propositional representation (the parts of which are selectively activated), and the actual window contents allow the reuse of constraints collected by corresponding internal representation. Although we have illustrated the modeling principles, we rely on a fixed propositional representation (the parts of which are selectively activated)."}], "references": [{"title": "Stream reasoning with answer set programming: Preliminary report", "author": ["M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "O. Sabuncu", "T. Schaub"], "venue": "In Eiter, T., McIlraith, S., eds.: Proceedings of the Thirteenth International Conference on Principles of Knowledge Representation and Reasoning (KR\u201912), AAAI Press", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Stream reasoning with answer set programming: Extended version", "author": ["M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "O. Sabuncu", "T. Schaub"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Data Stream Management", "author": ["L. Golab", "M. \u00d6zsu"], "venue": "Synthesis Lectures on Data Management, Morgan and Claypool Publishers", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "It\u2019s a streaming world! reasoning upon rapidly changing information", "author": ["E. Della Valle", "S. Ceri", "F. van Harmelen", "D. Fensel"], "venue": "IEEE Intelligent Systems 24(6)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Handbook of Knowledge Representation", "author": ["V. Lifschitz", "F. van Harmelen", "B. Porter", "eds."], "venue": "Elsevier Science", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2008}, {"title": "Deductive and inductive stream reasoning for semantic social media analytics", "author": ["D. Barbieri", "D. Braga", "S. Ceri", "E. Della Valle", "Y. Huang", "V. Tresp", "A. Rettinger", "H. Wermser"], "venue": "IEEE Intelligent Systems 25(6)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "In Veloso, M., ed.: Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI\u201907), AAAI Press/MIT Press", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2007}, {"title": "Answer set programming and plan generation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence 138(1-2)", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2002}, {"title": "Handbook of Satisfiability", "author": ["A. Biere", "M. Heule", "H. van Maaren", "T. Walsh", "eds."], "venue": "Volume 185 of Frontiers in Artificial Intelligence and Applications, IOS Press", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence 138(1-2)", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2002}, {"title": "Engineering an incremental ASP solver", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "In Garcia de la Banda, M., Pontelli, E., eds.: Proceedings of the Twenty-fourth International Conference on Logic Programming (ICLP\u201908). Volume 5366 of Lecture Notes in Computer Science, Springer-Verlag", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2008}, {"title": "Automated Planning: Theory and Practice", "author": ["D. Nau", "M. Ghallab", "P. Traverso"], "venue": "Morgan Kaufmann Publishers", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "An incremental answer set programming based system for finite model computation", "author": ["M. Gebser", "O. Sabuncu", "T. Schaub"], "venue": "AI Communications 24(2)", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "A simple solution to the Yale shooting problem", "author": ["A. Baker"], "venue": "In Brachman, R., Levesque, H., Reiter, R., eds.: Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning (KR\u201989), Morgan Kaufmann Publishers", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1989}, {"title": "Nonmonotonic causal theories", "author": ["E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner"], "venue": "Artificial Intelligence 153(1-2)", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2004}, {"title": "Scheduling Algorithms", "author": ["P. Brucker"], "venue": "Springer-Verlag", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2007}, {"title": "Algorithm = logic + control", "author": ["R. Kowalski"], "venue": "Communications of the ACM 22(7)", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1979}, {"title": "Proceedings of the Eleventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201911)", "author": ["J. Delgrande", "W. Faber", "eds."], "venue": "Volume 6645 of Lecture Notes in Artificial Intelligence, Springer-Verlag", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 2, "context": "While existing data stream management systems [4] allow for high-throughput stream processing, they lack complex reasoning capacities [5].", "startOffset": 46, "endOffset": 49}, {"referenceID": 3, "context": "While existing data stream management systems [4] allow for high-throughput stream processing, they lack complex reasoning capacities [5].", "startOffset": 134, "endOffset": 137}, {"referenceID": 4, "context": "We address this shortcoming and elaborate upon approaches to knowledge-intense stream reasoning, based on Answer Set Programming (ASP; [6]) as a prime tool for Knowledge Representation and Reasoning (KRR; [7]).", "startOffset": 135, "endOffset": 138}, {"referenceID": 5, "context": "We address this shortcoming and elaborate upon approaches to knowledge-intense stream reasoning, based on Answer Set Programming (ASP; [6]) as a prime tool for Knowledge Representation and Reasoning (KRR; [7]).", "startOffset": 205, "endOffset": 208}, {"referenceID": 6, "context": "In contrast to traditional ASP methods, which are devised for singular problem solving, \u201cstream reasoning, instead, restricts processing to a certain window of concern, focusing on a subset of recent statements in the stream, while ignoring previous statements\u201d [8].", "startOffset": 262, "endOffset": 265}, {"referenceID": 0, "context": "Our modeling approaches rely on the novel concept of time-decaying logic programs [1], where logic program parts are associated with life spans to steer their emergence as well as expiration upon continuous reasoning.", "startOffset": 82, "endOffset": 85}, {"referenceID": 7, "context": "Time-decaying logic programs are implemented as a recent extension of the reactive ASP system oclingo [9], using the ASP grounder gringo [10] for the recurrent composition of a static \u201coffline\u201d encoding with dynamic \u201conline\u201d data into queries to the ASP solver clasp [11].", "startOffset": 267, "endOffset": 271}, {"referenceID": 0, "context": "? This paper complements a short KR\u201912 paper [1]; an extended draft [2] is available at [3].", "startOffset": 45, "endOffset": 48}, {"referenceID": 1, "context": "? This paper complements a short KR\u201912 paper [1]; an extended draft [2] is available at [3].", "startOffset": 68, "endOffset": 71}, {"referenceID": 8, "context": "frame axioms [12], need to be reconsidered in view of the expiration of obsolete program parts.", "startOffset": 13, "endOffset": 17}, {"referenceID": 9, "context": "[13]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "We here tackle such issues in continuous reasoning over data from a sliding window [4].", "startOffset": 83, "endOffset": 86}, {"referenceID": 10, "context": "[16,6]).", "startOffset": 0, "endOffset": 6}, {"referenceID": 4, "context": "[16,6]).", "startOffset": 0, "endOffset": 6}, {"referenceID": 11, "context": "They provide the basis of incremental logic programs [17], where additional keywords, \u201c#base,\u201d \u201c#cumulative,\u201d and \u201c#volatile,\u201d allow for partitioning rules into a static, an accumulating, and a transient program part.", "startOffset": 53, "endOffset": 57}, {"referenceID": 12, "context": "[18]) and finite model finding (cf.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[19]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[20]) can be modeled by an incremental logic program as follows:", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "3 For formal details on time-decaying logic programs and a discussion of related work in stream processing, we refer the interested reader to [1,2].", "startOffset": 142, "endOffset": 147}, {"referenceID": 1, "context": "3 For formal details on time-decaying logic programs and a discussion of related work in stream processing, we refer the interested reader to [1,2].", "startOffset": 142, "endOffset": 147}, {"referenceID": 0, "context": "[1,2]) presupposed by oclingo, which essentially object to the (re)definition of (ground) head atoms at different steps.", "startOffset": 0, "endOffset": 5}, {"referenceID": 1, "context": "[1,2]) presupposed by oclingo, which essentially object to the (re)definition of (ground) head atoms at different steps.", "startOffset": 0, "endOffset": 5}, {"referenceID": 0, "context": "To overcome the preexisting limitations, we introduced time-decaying logic programs [1] that allow for associating arbitrary life spans (rather than just 1) with transient program parts.", "startOffset": 84, "endOffset": 87}, {"referenceID": 11, "context": "[17]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[17]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "alice [1] [1] 3 [1] 2 3 2 3 2 4 4 6 4 6 8 6 7 8", "startOffset": 6, "endOffset": 9}, {"referenceID": 0, "context": "alice [1] [1] 3 [1] 2 3 2 3 2 4 4 6 4 6 8 6 7 8", "startOffset": 10, "endOffset": 13}, {"referenceID": 0, "context": "alice [1] [1] 3 [1] 2 3 2 3 2 4 4 6 4 6 8 6 7 8", "startOffset": 16, "endOffset": 19}, {"referenceID": 3, "context": "claude [5] 2 [5] 2 3 4 [5] 2 3 4 3 4 For instance, observe that the three denied accesses by bob logged in the second and fourth step are consecutive in view of the time stamps 3, 2, and 4 provided as argument values, eg.", "startOffset": 7, "endOffset": 10}, {"referenceID": 3, "context": "claude [5] 2 [5] 2 3 4 [5] 2 3 4 3 4 For instance, observe that the three denied accesses by bob logged in the second and fourth step are consecutive in view of the time stamps 3, 2, and 4 provided as argument values, eg.", "startOffset": 13, "endOffset": 16}, {"referenceID": 3, "context": "claude [5] 2 [5] 2 3 4 [5] 2 3 4 3 4 For instance, observe that the three denied accesses by bob logged in the second and fourth step are consecutive in view of the time stamps 3, 2, and 4 provided as argument values, eg.", "startOffset": 23, "endOffset": 26}, {"referenceID": 0, "context": "[1,2]), which is required for meaningful closed-world reasoning by oclingo in reactive settings.", "startOffset": 0, "endOffset": 5}, {"referenceID": 1, "context": "[1,2]), which is required for meaningful closed-world reasoning by oclingo in reactive settings.", "startOffset": 0, "endOffset": 5}, {"referenceID": 11, "context": "[17]) based on a history of actions.", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "extended draft [2]) in which outdated rules expire along with stream data.", "startOffset": 15, "endOffset": 18}, {"referenceID": 15, "context": "[21]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "Unlike in offline job scheduling [22], where requests are known in advance, we here assume a stream of job requests, provided via (transient) facts job(I,M,D,T) such that I is a job ID, M is a machine, D is a duration, and T is the arrival time of a request.", "startOffset": 33, "endOffset": 37}, {"referenceID": 17, "context": "[23]), to selectively (de)activate logic program parts.", "startOffset": 0, "endOffset": 4}], "year": 2013, "abstractText": "The advance of Internet and Sensor technology has brought about new challenges evoked by the emergence of continuous data streams. Beyond rapid data processing, application areas like ambient assisted living, robotics, or dynamic scheduling involve complex reasoning tasks. We address such scenarios and elaborate upon approaches to knowledge-intense stream reasoning, based on Answer Set Programming (ASP). While traditional ASP methods are devised for singular problem solving, we develop new techniques to formulate and process problems dealing with emerging as well as expiring data in a seamless way.", "creator": "LaTeX with hyperref package"}}}