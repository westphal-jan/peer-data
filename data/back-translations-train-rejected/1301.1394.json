{"id": "1301.1394", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Lloyd-Topor Completion and General Stable Models", "abstract": "We investigate the relationship between the generalization of program completion defined in 1984 by Lloyd and Topor and the generalization of the stable model semantics introduced recently by Ferraris et al. The main theorem can be used to characterize, in some cases, the general stable models of a logic program by a first-order formula. The proof uses Truszczynski's stable model semantics of infinitary propositional formulas.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:55 GMT  (27kb,D)", "http://arxiv.org/abs/1301.1394v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1301.1394"}, "pdf": {"name": "1301.1394.pdf", "metadata": {"source": "CRF", "title": "Lloyd-Topor Completion and General Stable Models", "authors": ["Vladimir Lifschitz", "Fangkai Yang"], "emails": ["vl@cs.utexas.edu", "fkyang@cs.utexas.edu"], "sections": [{"heading": "1 Introduction", "text": "The theory of Frank Lloyd and Rodney Topor [1], which describes a case in which the stable semantics of program completion is not equivalent, is one of the most important results in the theory of stable models. It was generalized in [2,3,4], it led to the invention of loop formulas [5], and it had a significant influence on the design of the answers q (4). The general stable semantics, which in [6] designates the stable models of a first-order set F as arbitrary models of a second-order set designated by SM [F]; 1 logical programs are considered there as first-order sentences written in \"logical programming notation.\" In this note, we define an extension of the theory of Fages, which can be used as a tool for transforming SM [F], into a first-order equivalent formula in some cases."}, {"heading": "2 Review: Operator SM, Lloyd-Topor Programs, and Completion", "text": "In this work, a formula is a first-order formula that can contain the sentence connective q (logical falsehood), q (logical falsehood), and the quantifier p. We treat \"F\" as an abbreviation for \"F\"; > stands for \"F\"; F \"G stands for\" G \"(G\" F). For all first-order sentences F and all other predicate constants (except equality) SMp [F] is the conjunction of \"F with a\" second-order stability condition \"; see [6, section 2] for details. The members of\" p \"are called more intense, and the other predicate constants are more expansive. We will drop the noun into the symbol\" SMp \"if p is the list of all predicate symbols that occur in\" F. \"For each sentence F is a p-stable (or simply stable) x-model of\" x. \""}, {"heading": "3 Review: Tight Programs", "text": "We will now review the definition of tightness of [6, Section 7.3]. Applying to a Lloyd Topor program q (11), if all predicate constants occurring in the formula are treated as intense, this definition can be defined as follows: The predicate dependency graph is the directed formula that negates all predicate constants occurring in the formula of the first order, and - an edge from p to q whenever it contains a rule (7) with p in mind, so that its body G has a positive non-negative occurrence of q.We say that the predicate constant constants occur in the formula of the first order, and - an edge from p to q whenever it contains a rule."}, {"heading": "4 Rule Dependency Graph", "text": "The following definition will help us answer the more general question: The rule dependency graph of a Lloyd Topor program is the directed graph that contains the rules of a Lloyd Topor graph labeled with an atomic formula, p \u2032. The formula p \u2032 (s) has a positive non-negated approach in G. Unlike the predicate dependence graph of a program, the rule dependency graph of a program is usually infinite. For example, the rule dependence graph of the program (11) has the nodes p \u00b2."}, {"heading": "5 Main Theorem", "text": "Let C make a chain p0 (t0) p1 (s1) pq (t) p2 (s2)......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "6 A Larger Example", "text": "Programs found in actual applications of ASP usually include constructs that are not allowed in Lloyd Topor programs, such as election rules and constraints. Election rules take the form of {p (t) p (n) p (n) p (n) p (t) p (t) p (t) p (t) p (t) p (t) p (t) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p) p (n) p (n) p (n) p n n n n n n (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (n) p (p) p) p (p (n) p (n) p (n) p (n) p (p (n) p) p (n) p (n) p (n) p (p (p) p (n) p (p) p (n) p (p) p (p (n) p (n) p (n) p (p (p) p (p) p) p (n) p (n) p (p (p (n) p) p) p (p (n) p (p (n) p (p) p (p) p (p) p (p (p) p) p (p (p) p (p) p (n) p"}, {"heading": "7 Review: Stable Models of Infinitary Formulas", "text": "In fact, it is that it is a way in which one sees oneself in a position to surpass oneself. (...) In fact, it is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is that people are able to surpass oneself. (...) It is as if they are able to surpass oneself. (...) It is as if they are able to surpass oneself. (...) It is as if they are able to surpass oneself. (...) It is as if they are able to surpass oneself. (...) It is as if they are able to surpass oneself."}, {"heading": "8 Proof Outline", "text": "In the statement of the main proposition, the implication from left to right SM [\u0441] \u2192 Comp [\u0441] logically applies to any Lloyd Topor program. This fact is derived from [6, Theorem 11] by the argument used in the above proof for proposition 1. In this section, we sketch the proof in the other direction:"}, {"heading": "If a Lloyd-Topor program \u03a0 is \u0393 -tight, and an interpretation I satisfies both \u0393 and Comp[\u03a0], then I satisfies SM[\u03a0].", "text": "This assertion follows from three lemmas, the first of which expresses an infinite property of infinite formulas (=). (It concerns infinite programs - conjunctions of (possibly infinite) implications G-A with A-A. Such an implication is called the (infinite) rule with the head A and body G, and we will write it as A-G. For example, if it is a Lloyd Topor program, for any interpretation I-A is an infinite program. We say that an interpretation I-A is supported by an infinite program supported by an infinite H-A."}, {"heading": "9 Conclusion", "text": "We proposed a new method for the representation of SM [F] in the language of first-order logic, which is more general than the approach of [6]. Its relationship to the ideas of [8] needs further investigation. In particular, this method allows us to prove the equivalence of some ASP descriptions of dynamic domains with axiomatizations based on succession axioms. Using the stable model semantics of infinite formulas [11] in the proof of the main theorem illustrates the potential of this semantics as a tool for the study of the operator SM."}, {"heading": "Acknowledgements", "text": "We are grateful to Joohyung Lee and the anonymous referees for their helpful comments."}], "references": [{"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science 1", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1994}, {"title": "Foundations of logic programming", "author": ["V. Lifschitz"], "venue": "In Brewka, G., ed.: Principles of Knowledge Representation. CSLI Publications", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1996}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 3", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "On tight logic programs and yet another translation from normal logic programs to propositional logic", "author": ["F. Lin", "J. Zhao"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI).", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2004}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Making Prolog more expressive", "author": ["J. Lloyd", "R. Topor"], "venue": "Journal of Logic Programming 3", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1984}, {"title": "First-order stable model semantics and first-order loop formulas", "author": ["J. Lee", "Y. Meng"], "venue": "J. Artif. Intell. Res. (JAIR) 42", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic 2", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2001}, {"title": "A characterization of strong equivalence for logic programs with variables", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "Procedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Connecting first-order asp and the logic fo(id) through reducts", "author": ["M. Truszczynski"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR).", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}], "referenceMentions": [{"referenceID": 0, "context": "The theorem by Fran\u00e7ois Fages [1] describing a case when the stable model semantics is equivalent to program completion is one of the most important results in the theory of stable models.", "startOffset": 30, "endOffset": 33}, {"referenceID": 1, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 2, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 3, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 22, "endOffset": 29}, {"referenceID": 4, "context": "It was generalized in [2,3,4], it has led to the invention of loop formulas [5], and it has had a significant impact on the design of answer set solvers.", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "The general stable model semantics defined in [6] characterizes the stable models of a first-order sentence F as arbitrary models of a certain second-order sentence, denoted by SM[F ];1 logic programs are viewed there as first-order sentences written in \u201clogic programming notation.", "startOffset": 46, "endOffset": 49}, {"referenceID": 6, "context": "That extension refers to the version of program completion introduced by John Lloyd and Rodney Topor in [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 5, "context": "Earlier work in this direction is reported in [6] and [8].", "startOffset": 46, "endOffset": 49}, {"referenceID": 7, "context": "Earlier work in this direction is reported in [6] and [8].", "startOffset": 54, "endOffset": 57}, {"referenceID": 8, "context": "Instead, they discuss ways to convert a logic program to \u201cClark normal form\u201d by strongly equivalent transformations [9,10] and completing programs in this normal form by replacing implications with equivalences.", "startOffset": 116, "endOffset": 122}, {"referenceID": 9, "context": "Instead, they discuss ways to convert a logic program to \u201cClark normal form\u201d by strongly equivalent transformations [9,10] and completing programs in this normal form by replacing implications with equivalences.", "startOffset": 116, "endOffset": 122}, {"referenceID": 5, "context": "The Clark normal form of (1) is tight in the sense of [6], and Theorem 11 from that paper shows that SM[F ] in this case is equivalent to the conjunction of the completed definitions of p and q: \u2200x(p(x)\u2194 x = a \u2228 q(x)), \u2200x(q(x)\u2194 x = b).", "startOffset": 54, "endOffset": 57}, {"referenceID": 5, "context": "This program is not tight in the sense of [6], so that the above-mentioned theorem is not applicable.", "startOffset": 42, "endOffset": 45}, {"referenceID": 7, "context": "This claim cannot be justified, however, by a reference to Corollary 5 from [8].", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "The class of tight programs is defined in [6] in terms of predicate dependency graphs; that definition is reproduced in Section 3 below.", "startOffset": 42, "endOffset": 45}, {"referenceID": 7, "context": "The definition of an atomictight program in [8] refers to more informative \u201cfirst-order dependency graphs.", "startOffset": 44, "endOffset": 47}, {"referenceID": 5, "context": "This is an easy corollary to the theorem from [6] mentioned in the introduction.", "startOffset": 46, "endOffset": 49}, {"referenceID": 5, "context": "By Theorem 11 from [6], SM[\u03a0 \u2032] is equivalent to the completion of \u03a0 \u2032 in the sense of [6, Section 6.", "startOffset": 19, "endOffset": 22}, {"referenceID": 7, "context": "Program M is not atomic-tight, so that methods of [8] are not directly applicable to it.", "startOffset": 50, "endOffset": 53}, {"referenceID": 10, "context": "Our proof of the main theorem employs the method proposed (for a different purpose) by Miroslaw Truszczynski [11], and in this section we review some of the definitions and results of that paper.", "startOffset": 109, "endOffset": 113}, {"referenceID": 11, "context": "The stable model semantics of propositional formulas due to Paolo Ferraris [12] is extended there to formulas with infinitely long conjunctions and disjunctions, and that generalization is related to the operator SM.", "startOffset": 75, "endOffset": 79}, {"referenceID": 11, "context": "The definition of the reduct F I of a formula F relative to an interpretation I proposed in [12] is extended to infinitary formulas as follows: \u2013 \u22a5 = \u22a5.", "startOffset": 92, "endOffset": 96}, {"referenceID": 2, "context": "The first of them expresses a Fagesstyle property of infinitary formulas similar to Theorem 1 from [3].", "startOffset": 99, "endOffset": 102}, {"referenceID": 5, "context": "It is more general than the approach of [6].", "startOffset": 40, "endOffset": 43}, {"referenceID": 7, "context": "Its relationship with the ideas of [8] requires further study.", "startOffset": 35, "endOffset": 38}, {"referenceID": 10, "context": "The use of the stable model semantics of infinitary formulas [11] in the proof of the main theorem illustrates the potential of that semantics as a tool for the study of the operator SM.", "startOffset": 61, "endOffset": 65}], "year": 2013, "abstractText": "We investigate the relationship between the generalization of program completion defined in 1984 by Lloyd and Topor and the generalization of the stable model semantics introduced recently by Ferraris et al. The main theorem can be used to characterize, in some cases, the general stable models of a logic program by a first-order formula. The proof uses Truszczynski\u2019s stable model semantics of infinitary propositional formulas.", "creator": "LaTeX with hyperref package"}}}