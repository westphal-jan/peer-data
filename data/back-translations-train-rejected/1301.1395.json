{"id": "1301.1395", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Extending FO(ID) with Knowledge Producing Definitions: Preliminary Results", "abstract": "Previous research into the relation between ASP and classical logic has identified at least two different ways in which the former extends the latter. First, ASP program typically contain sets of rules that can be naturally interpreted as inductive definitions, and the language FO(ID) has shown that such inductive definitions can elegantly be added to classical logic in a modular way. Second, there is of course also the well-known epistemic component of ASP, which was mainly emphasized in the early papers on stable model semantics. To investigate whether this kind of knowledge can also, and in a similarly modular way, be added to classical logic, the language of Ordered Epistemic Logic was presented in recent work. However, this logic views the epistemic component as entirely separate from the inductive definition component, thus ignoring any possible interplay between the two. In this paper, we present a language that extends the inductive definition construct found in FO(ID) with an epistemic component, making such interplay possible. The eventual goal of this work is to discover whether it is really appropriate to view the epistemic component and the inductive definition component of ASP as two separate extensions of classical logic, or whether there is also something of importance in the combination of the two.", "histories": [["v1", "Tue, 8 Jan 2013 02:30:01 GMT  (15kb,D)", "http://arxiv.org/abs/1301.1395v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["joost vennekens", "marc denecker"], "accepted": false, "id": "1301.1395"}, "pdf": {"name": "1301.1395.pdf", "metadata": {"source": "CRF", "title": "Extending FO(ID) with Knowledge Producing Definitions: Preliminary Results", "authors": ["Joost Vennekens", "Marc Denecker"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The roots of ASP lie in the fields of Logical Programming (LP) and Non-Monotonic Reasoning (NMR), both of which were initially motivated by dissatisfaction with classical first-order logic (FO), whether by its computational properties (in the case of ASP) or its ability to represent sound knowledge (in the case of NMR).The current success of ASP suggests that this domain has indeed been able to overcome these problems of classical logic on a large scale, but it is not yet entirely clear how exactly this has been done, which means that in our opinion the relationship between ASP and classical logic is not yet fully developed Xiv: 130 1.13 95v1 [cs.LO] 8 Junderstood."}, {"heading": "2 Preliminaries: the semantics of inductive definitions", "text": "The formal representation of such a definition in FO (ID) is simply the smallest relationship concluded under the application of the rules, and it can be constructed by fully applying it. For non-monotonous definitions, the relationship defined under the rules is no longer the smallest relationship concluded under the rules, and it can be constructed by fully applying them. For non-monotonous definitions, the relationship defined under the rules is no longer the smallest, and indeed there can be many minimal relationships concluded under the rules. In mathematical texts, such a non-monotonous definition is always accompanied by a well-founded order through which the induction is performed."}, {"heading": "3 Knowledge producing definitions", "text": "The aim of this work is to take the concept of an inductive definition as it exists in FO (ID) and expand it by allowing definitions that not only define the objective extension of their defined predicates, but at the same time define the approximate knowledge of a rational agent about these predicates. A modal letter pair is a formula of the form in which knowledge is a formula. By FO (K) we mean the language that extends to the form by allowing modal words to appear an atomic P (t) everywhere. Note that FO (K) therefore does not allow linking of the operator K. A knowledge that generates definition is a set of rules of form that is applicable either x x x x x x (P) or x (t)."}, {"heading": "4 Adding knowledge producing definitions to FO", "text": "FO added inductive definitions to FO. We become again only theories about the form T = {??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????"}, {"heading": "5 Examples", "text": "In the logic we have now defined, it is easy to represent the interview example. Therefore, each strong model is used by us to have an open one. \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7"}, {"heading": "5.2 Sensing actions", "text": "A successful area of application of ASP is planning. Of course, this also falls within the area of FO (ID), since theories in the situation or event calculation are essentially only an inductive definition of the values of the fluids at different times [6]. Here is an example of a theory in FO (ID), which represents a small action area in which there is a dirty glass that can be cleaned by wiping. {Clean (t + 1) \u2190 Clean (0).InitClean (0).InitCleanIf the active ingredient does not know whether the glass is clean at first, we might be interested in finding a plan with which it can know for certain that it will be clean at some point in time. This can be achieved, for example, by adding K Clean (2) as a restriction in FO (K). More interesting is that knowledge of producing definitions can also be used to add sensitive measures, such as an active ingredient, Clean (K) (Clean) (K)."}, {"heading": "6 Discussion", "text": "ASP is able to express epistemic examples by interpreting a series of words believed by a rational agent. This is one of the most radical ways in which ASP deviates from classical logic, in which models or interpretations always represent the objective state of the world. In the classical context, one typically resorts to interpretative propositions (or the associated concept of a Kripke structure) to represent convictions. In order to relate this aspect of ASP to classical logic, or even to integrate both, it is necessary to construct a formalization that adheres to these classical semantic objects. In this essay, we have introduced knowledge that generates definitions for this purpose. As our examples have shown, they are able to imitate the ASP representation, for example, of the interview example, while at the same time introducing some interesting new possibilities, such as the ability to distinguish between some atoms P (t) that have become objective (in the head) (by having a rule object) (in the head)."}], "references": [{"title": "Enfragmo: A system for modelling and solving search problems with logic", "author": ["A. Aavani", "X. Wu", "E. Ternovska", "D. Mitchell"], "venue": "In LPAR-18,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Negation as failure", "author": ["K. Clark"], "venue": "In Logic and Data Bases, pages 293\u2013322. Plenum Press,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1978}, {"title": "Extending classical logic with inductive definitions", "author": ["M. Denecker"], "venue": "In CL, volume 1861 of LNCS, pages 703\u2013717,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2000}, {"title": "Logic programming revisited: Logic programs as inductive definitions", "author": ["M. Denecker", "M. Bruynooghe", "V. Marek"], "venue": "ACM Transactions on Computational Logic (TOCL), 2(4):623\u2013654,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "A Tarskian informal semantics for ASP", "author": ["M. Denecker", "Y. Lierler", "M. Truszczynski", "J. Vennekens"], "venue": "In Technical Communications of the 28th International Conference on Logic Programming,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2012}, {"title": "Inductive situation calculus", "author": ["M. Denecker", "E. Ternovska"], "venue": "Artificial Intelligence, 171(5-6):332\u2013360,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2007}, {"title": "A logic of nonmonotone inductive definitions", "author": ["M. Denecker", "E. Ternovska"], "venue": "ACM Transactions on Computational Logic (TOCL), 9(2):Article 14,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2008}, {"title": "Well-founded semantics and the algebraic theory of non-monotone inductive definitions", "author": ["M. Denecker", "J. Vennekens"], "venue": "In LPNMR, pages 84\u201396,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "The second answer set programming system competition", "author": ["M. Denecker", "J. Vennekens", "S. Bond", "M. Gebser", "M. Truszczynski"], "venue": "In LPNMR, pages 637\u2013654,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2009}, {"title": "Answer set programming\u2019s contributions to classical logic", "author": ["M. Denecker", "J. Vennekens", "H. Vlaeminck", "J. Wittocx", "M. Bruynooghe"], "venue": "An analysis of ASP methodology. In MG-65: Symposium on Constructive Mathematics in Computer Science. Lexington, October 26-27,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Tableau Calculi for Answer Set Programming", "author": ["M. Gebser", "T. Schaub"], "venue": "In ICLP, pages 11-25,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In ICLP/SLP, pages 1070\u20131080. MIT Press,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1988}, {"title": "Logic programs with classical negation", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In ICLP, pages 579\u2013597. MIT Press,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1990}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing, 9(3/4):365\u2013386,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1991}, {"title": "On the relation among answer set solvers", "author": ["E. Giunchiglia", "N. Leone", "M. Maratea"], "venue": "In Ann. Math. Artif. Intell", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Abstract answer set solvers with backjumping and learning", "author": ["Y. Lierler"], "venue": "Theory and Practice of Logic Programming (TPLP) 11(2-3): 135-169,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Answer set programming and plan generation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence, 138:39\u201354,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2002}, {"title": "On the relation between ID-Logic and Answer Set Programming", "author": ["M. Mari\u00ebn", "D. Gilis", "M. Denecker"], "venue": "In JELIA, volume 3229 of LNCS, pages 108\u2013120. Springer,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "The IDP framework for declarative problem solving", "author": ["M. Mari\u00ebn", "J. Wittocx", "M. Denecker"], "venue": "In Search and Logic: Answer Set Programming and SAT, pages 19\u201334,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2006}, {"title": "A framework for representing and solving NP search problems", "author": ["D. Mitchell", "E. Ternovska"], "venue": "In AAAI, pages 430\u2013435,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "The alternating fixpoint of logic programs with negation", "author": ["A. Van Gelder"], "venue": "Journal of Computer and System Sciences, 47(1):185\u2013221,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1993}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K. Ross", "J. Schlipf"], "venue": "Journal of the ACM, 38(3):620\u2013650,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1991}, {"title": "Ordered epistemic logic", "author": ["H. Vlaeminck", "J. Vennekens", "M. Bruynooghe", "M. Denecker"], "venue": "In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 9, "context": "This paper is part of a research project that attempts to close this gap [10].", "startOffset": 73, "endOffset": 77}, {"referenceID": 19, "context": "For instance, [20] showed that the typical ASP way of encoding search problems can be captured quite elegantly in a classical context by the notion of modal expansion: given a theory T in an alphabet \u03a3 and an interpretation Io for some subvocabulary \u03a3o \u2286 \u03a3, find an interpretation I that extends Io to the entire vocabulary such that I |= T .", "startOffset": 14, "endOffset": 18}, {"referenceID": 8, "context": "Indeed, the 2011 edition of the ASP-competition [9] has had two modal expansion systems for (extensions of) classical logic among its competitors: Enfragmo [1] and IDP [19].", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "Indeed, the 2011 edition of the ASP-competition [9] has had two modal expansion systems for (extensions of) classical logic among its competitors: Enfragmo [1] and IDP [19].", "startOffset": 156, "endOffset": 159}, {"referenceID": 18, "context": "Indeed, the 2011 edition of the ASP-competition [9] has had two modal expansion systems for (extensions of) classical logic among its competitors: Enfragmo [1] and IDP [19].", "startOffset": 168, "endOffset": 172}, {"referenceID": 15, "context": ", [16,11,15]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 10, "context": ", [16,11,15]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 14, "context": ", [16,11,15]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 4, "context": "As pointed out by [5], one of the key problems lies in the interpretation of the semantic structures: whereas an answer set in ASP is traditionally interpreted in an epistemic way, as a representation of the knowledge of some rational agent, classical logic is based on the Tarskian view of a model as a representation of a possible objective state of affairs.", "startOffset": 18, "endOffset": 21}, {"referenceID": 3, "context": "[4,8,7] has shown that a substantial portion of ASP can be understood as a combination of classical FO axioms and inductive definitions.", "startOffset": 0, "endOffset": 7}, {"referenceID": 7, "context": "[4,8,7] has shown that a substantial portion of ASP can be understood as a combination of classical FO axioms and inductive definitions.", "startOffset": 0, "endOffset": 7}, {"referenceID": 6, "context": "[4,8,7] has shown that a substantial portion of ASP can be understood as a combination of classical FO axioms and inductive definitions.", "startOffset": 0, "endOffset": 7}, {"referenceID": 3, "context": "As shown in [4,8,7], we can view a set of normal logic programming rules as a formal representation of such an inductive definition.", "startOffset": 12, "endOffset": 19}, {"referenceID": 7, "context": "As shown in [4,8,7], we can view a set of normal logic programming rules as a formal representation of such an inductive definition.", "startOffset": 12, "endOffset": 19}, {"referenceID": 6, "context": "As shown in [4,8,7], we can view a set of normal logic programming rules as a formal representation of such an inductive definition.", "startOffset": 12, "endOffset": 19}, {"referenceID": 20, "context": "This is of course not overly surprising and it indeed goes back to the views of Van Gelder [21] and Clark [2].", "startOffset": 91, "endOffset": 95}, {"referenceID": 1, "context": "This is of course not overly surprising and it indeed goes back to the views of Van Gelder [21] and Clark [2].", "startOffset": 106, "endOffset": 109}, {"referenceID": 2, "context": "FO(ID) (previously known as ID-logic) is the language that does precisely this: it extends FO, in a completely modular way, with a rule-based representation for inductive definition [3].", "startOffset": 182, "endOffset": 185}, {"referenceID": 16, "context": "Representing a search problem as a model expansion problem in FO(ID) often yields results that are almost identical to a Generate-Define-Test program in ASP [17], apart from minor syntactic details [18,5].", "startOffset": 157, "endOffset": 161}, {"referenceID": 17, "context": "Representing a search problem as a model expansion problem in FO(ID) often yields results that are almost identical to a Generate-Define-Test program in ASP [17], apart from minor syntactic details [18,5].", "startOffset": 198, "endOffset": 204}, {"referenceID": 4, "context": "Representing a search problem as a model expansion problem in FO(ID) often yields results that are almost identical to a Generate-Define-Test program in ASP [17], apart from minor syntactic details [18,5].", "startOffset": 198, "endOffset": 204}, {"referenceID": 11, "context": "One class of examples that remains out of scope is that of the epistemic examples that originally motivated the stable model semantics [12,13].", "startOffset": 135, "endOffset": 142}, {"referenceID": 12, "context": "One class of examples that remains out of scope is that of the epistemic examples that originally motivated the stable model semantics [12,13].", "startOffset": 135, "endOffset": 142}, {"referenceID": 13, "context": "This is epitomized by the well-known interview example [14], which is expressed in ASP as:", "startOffset": 55, "endOffset": 59}, {"referenceID": 22, "context": "In [23], the language of Ordered Epistemic Logic (OEL) is developed for this.", "startOffset": 3, "endOffset": 7}, {"referenceID": 7, "context": "fact, the well-founded order is already entirely implicit in the structure of the rules! As shown in [8] and a series of prior papers, the well-founded semantics (WFS) [22] can actually be seen as a mathematical construct to recover the well-founded order from the structure of the rules.", "startOffset": 101, "endOffset": 104}, {"referenceID": 21, "context": "fact, the well-founded order is already entirely implicit in the structure of the rules! As shown in [8] and a series of prior papers, the well-founded semantics (WFS) [22] can actually be seen as a mathematical construct to recover the well-founded order from the structure of the rules.", "startOffset": 168, "endOffset": 172}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}], "year": 2013, "abstractText": "Previous research into the relation between ASP and classical logic has identified at least two different ways in which the former extends the latter. First, ASP program typically contain sets of rules that can be naturally interpreted as inductive definitions, and the language FO(ID) has shown that such inductive definitions can elegantly be added to classical logic in a modular way. Second, there is of course also the well-known epistemic component of ASP, which was mainly emphasized in the early papers on stable model semantics. To investigate whether this kind of knowledge can also, and in a similarly modular way, be added to classical logic, the language of Ordered Epistemic Logic was presented in recent work. However, this logic views the epistemic component as entirely separate from the inductive definition component, thus ignoring any possible interplay between the two. In this paper, we present a language that extends the inductive definition construct found in FO(ID) with an epistemic component, making such interplay possible. The eventual goal of this work is to discover whether it is really appropriate to view the epistemic component and the inductive definition component of ASP as two separate extensions of classical logic, or whether there is also something of importance in the combination of the two.", "creator": "LaTeX with hyperref package"}}}