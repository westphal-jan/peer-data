{"id": "1301.4272", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Jan-2013", "title": "View-based propagation of decomposable constraints", "abstract": "Constraints that may be obtained by composition from simpler constraints are present, in some way or another, in almost every constraint program. The decomposition of such constraints is a standard technique for obtaining an adequate propagation algorithm from a combination of propagators designed for simpler constraints. The decomposition approach is appealing in several ways. Firstly because creating a specific propagator for every constraint is clearly infeasible since the number of constraints is infinite. Secondly, because designing a propagation algorithm for complex constraints can be very challenging. Finally, reusing existing propagators allows to reduce the size of code to be developed and maintained. Traditionally, constraint solvers automatically decompose constraints into simpler ones using additional auxiliary variables and propagators, or expect the users to perform such decomposition themselves, eventually leading to the same propagation model. In this paper we explore views, an alternative way to create efficient propagators for such constraints in a modular, simple and correct way, which avoids the introduction of auxiliary variables and propagators.", "histories": [["v1", "Thu, 17 Jan 2013 23:37:47 GMT  (30kb,D)", "http://arxiv.org/abs/1301.4272v1", "The final publication is available at link.springer.com"]], "COMMENTS": "The final publication is available at link.springer.com", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["marco correia", "pedro barahona"], "accepted": false, "id": "1301.4272"}, "pdf": {"name": "1301.4272.pdf", "metadata": {"source": "CRF", "title": "View-based propagation of decomposable constraints", "authors": ["Marco Correia", "Pedro Barahona"], "emails": ["mvc@fct.unl.pt", "pb@fct.unl.pt"], "sections": [{"heading": null, "text": "{mvc, pb} @ fct.unl.pt CENTRIA - Centre for Artificial Intelligence Departamento de Inform\u00e1tica FCT / UNL Quinta da Torre 2829-516 CAPARICA - Portugal Tel. (+ 351) 21 294 8536 FAX (+ 351) 21 294 8541View-based propagation of decomposable constraintsMarco Correia Pedro Barahona June 1, 2017The final publication is available at http: / / link.springer.com Xiv: 130 1,42 72v1 [cs.AI] 17 Jan 2013Constraints that can be achieved by composition of simpler constraints are present in almost every constraint program in one way or another. Decomposition of such constraints is a standard technique for achieving an adequate propagation algorithm consisting of a combination of propagators designed for simpler constraints."}, {"heading": "1 Introduction", "text": "This year is the highest in the history of the country."}, {"heading": "2 Background: Domains and Propagators", "text": "In this section, the necessary concepts and notations are presented to describe the propagation in detail."}, {"heading": "2.1 Constraint Satisfaction Problems", "text": "A constraint satisfaction problem (CSP) is a triple < X, D, C > where X is a finite set of variables, D is a finite set of variable ranges, and C is a finite set of constraints. We are referring to the set of constraints that includes some variable x-X as C (x) and the set of variables in a constraint c-C as X (c). An n-ary constraint (on variables x1,... xn) is a set of tuples on its n variables (ntuples). Although tuples are most commonly used by integers, we only expect the elements in a tuple to come from completely ordered types. Generally, we will call an n-tuple as xn and a set of n-tuples as Sn (or simply x and S if there is no ambiguity in their nature) and the set of tuples of constraint c (implicit) as a constraint of Wi or simple constraints."}, {"heading": "2.2 Domain Approximations", "text": "In the following, we generalize the concept of domains from individual variables to more general n-domains (\u03b2-\u03b2 = \u03b2-S) and characterize their approximate values. First, we use conv (S1) to denote the convex shell of a series of S1 of an ordered type D i.e.convD (S1) = {z-D: min (S1) \u2264 z \u2264 max (S1)} We now introduce important tuple set operations: Cartesian approximation (see for example [2]) and caste approximation [4].Definition 2.1 (Cartesian approximation).The Cartesian approximation SB is the smallest Cartesian product containing S, i.e.: SD = projain (S) \u00d7."}, {"heading": "2.3 Propagation", "text": "The other two characteristics of propagators are of interest: Idempotence and completeness. A propagator is idempotent iff. (S) is idempotent iff. (S) = empirical (S) empirical (S) empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), S (S), S (S), S (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S), empirical (S, empirical (S), empirical (S), empirical (S), empirical (S), empirical (S, empirically (S), empirical (S), empirical (S, empirically), empirical (S, empirically (S), empirically (S), empirical (S, empirical (S, S), empirically (S, empirically (S), empirically (S, empirically (S), empirically (S, empirically (S), empirically (S, empirically (S), empirically (S), empirically (S, empirically (S), empirically (S), empirically (S, empirically (S), empiri"}, {"heading": "3 Views for Propagation of Decomposable Constraints", "text": "This section describes the propagation of dismountable constraints as a function of views, an abstraction that represents the senseless evaluation of a function over a given (tuple) set. First, we characterize dismountable constraints (3.1), then we introduce views (3.2) and show that they can be used to express sound propagators for dismountable constraints (3.3). Section 3.4 briefly discusses the propagation strength of sight-based propagators, a topic that will be dealt with later in Section 5.3.4 after the implementation details are presented. Finally, we present box-based propagators (3.5), a special case of sight-based propagators that can be easily implemented efficiently, as described in the rest of the article."}, {"heading": "3.1 Decomposable constraints", "text": "As discussed before, constraint solvers do not have specific propagators for all possible constraints, such as the use of constraint operators. Constraints that cannot be captured by a single specific propagator are usually broken down into a logically equivalent conjunction of simpler constraints for which specific propagators exist. Many types of constraints that are used in practice can be decomposed in this sense. Here are some examples (examples): a linear combination, such as [1] a linear combination, such as [2] an aixi class, or a product, such as [3] the most common type of decomposable constraints. While some solvers have specific propagators for these constraints (e.g. by using the term linear relationship), this approach does not work for more irregular arithmetic constraints that use any combination of.oletic operators as an example."}, {"heading": "3.2 Views", "text": "In fact, most of them will be able to move to another world, where they will be able to move to another world, where they will be able to move to another world, where they will be able to move, where they will be able to move, where they will be able to move."}, {"heading": "3.3 View-based Propagators", "text": "As shown above, an n-ary decomposable constraint can be considered a special case of functions of the form c-f, where f is a tuple function f: Zn \u2192 Zk and c is a constraint that maps k-tuples to the Boolean domain. Definition 3.17. Let c be a k-ary constraint for which \u03c0c is a propagator and f is a tuple function f: Zn \u2192 Zk. A visual propagator for the constraint c-f, referred to as \u03c0-c-f, is obtained by the k constraint f (S n) (\u03c011? c (\u042111?), f (S n), Sn), Example 3.18. Consider the visual propagator for the constraint d = & x1 + x2 = x3], and let us analyze the > function."}, {"heading": "3.4 Approximate view-based propagators", "text": "In this section, we present approximate view-based propagators and set them in relation to the completeness classes introduced in Table 1 on page 7.Definition 3.19. An image-based propagator for a constraint c-f is intuitively defined in such a way that the completeness of a view-based propagator for a decomposable constraint of the form c-f1-f1-fm-fm is achieved by approximating the input of the image function and the output of the object function, rather than by approximating the remaining view functions or propagators. For these view-based propagators, the following property can be demonstrated [8]."}, {"heading": "3.5 Box view-based propagators", "text": "A box view-based propagator (S) is a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S), a box view-based propagator (S)."}, {"heading": "4 Implementation", "text": "The implementation of views for any expression can be complex, depending on the type of approximations the view takes into account. In the particular case of box view broadeners, the code implementing a view of an expression e should not be more complex than the code implementing a view of an expression e = z, where e is an expression that includes variables (i.e. no other expressions) and z is a variable. For example, implementing a box view for the expressions e1 + e2 or e1 \u00d7 e2, where ei are expressions, is very similar to implementing the propagator for x1 + x2 = x3 or x1 \u00b7 x2 = x3, where xi are variables. Indeed, the simplicity of these implementations is a major advantage of box view broadeners. The following sections provide some examples of such implementations."}, {"heading": "4.1 Box view propagators in strongly typed programming languages", "text": "Most, if not all, popular highly typed programming languages have added support for subtype polymorphism, either by overloading or by using inheritance in the case of object-oriented programming languages. In addition, parametric polymorphism has been introduced in some object-oriented programming languages such as C + +, Java, and C #. Parametric polymorphism enables aggressive compiler optimizations, namely function code inlining (i.e. replacing function calls with actual code), which has a significant impact on performance, as we will see later. Because C + + supports both subtype and parametric polymorphism, we have been able to integrate both variants of our model within the Constraint Solver Engine and thus maintain a fair experimental platform."}, {"heading": "4.1.1 Subtype polymorphism", "text": "In this setting, we must define an abstract interface for box view objects: Class Box {virtual int getMin () = 0; virtual int getMax () = 0; virtual bool updMin (int i) = 0; virtual bool updMax (int i) = 0; virtual bool updMax (int i) = 0;}; A box view object for a specific function implements the object interface for box view (for convenience, the refresh methods return whether the operation does not result in an empty box).Example 4.1. The following class defines the subtype polymorphic box view object for the addition of two box view objects. Class Add2: Box {Add2 (Box ax, Box ay): x (ax), y () virtual int getMin () + x; x."}, {"heading": "4.1.2 Parametric polymorphism", "text": "The fact that the C + + compiler evaluates expressions from bottom to top makes the implementation of the parametric Polymorphic View objects somewhat more complex, since they must be compiled from top to bottom. The solution we propose cancels the compilation algorithm in two phases, the first phase generates a syntactical representation of the expression called a type parametric object. After the full constraint is compiled, we use the obtained relation object to instantiate the required view objects. We use templates to define the type parametric relations, as this is the language mechanism available in the C + + class to support the type of parametric polymorphisms."}, {"heading": "4.2 Incrementality", "text": "It is important to note that incremental propagandists (i.e. propagandists who maintain a state) can be used transparently with views. In practice, this can be very useful, for example, to model the boundaries of completely different propagandists versus expressions, such as the main limitation of the Golomb ruler problem (which is given in the next section), different ({xi \u2212 xj: 1 \u2264 j < i \u2264 m}) Nor does it seem to prevent us from creating views that maintain an internal state. Although we have implemented this for some expressions, namely the element expression, it does not seem to be useful for most \u03b2 views that are cheap in rating."}, {"heading": "4.3 Triggering", "text": "Trigger is a well-known method for reducing the number of redundant propagations during a fixed point calculation [23]. A trigger can be considered a propagation condition - propagators are known to be idempotent for the current domain until the condition is met, i.e., if they are allowed to propagate. The way in which triggering is used with views is not significantly different from their use in the variable decomposition approach. In addition to the methods shown above, each view object must apply methods for creating / deleting triggers to the relevant events available in the solver: For example, a trigger on both borders of an expression x + y should map the four boundaries of x and y, while a trigger maps to the minimum of \u2212 x maps to the maximum x. Given that each view object provides methods for creating and removing triggers, moving triggers on both boundaries of an expression x + y is also possible with Views expression to the maximum x."}, {"heading": "4.4 Persistent operations and idempotency checking", "text": "In this case, it is a purely diversionary manoeuvre, which is a diversionary manoeuvre."}, {"heading": "4.5 Complexity analysis", "text": "Conceptually, a view object over an expression serves the same purpose as the auxiliary variable introduced for that expression: the disclosure of its domain. However, these models have different operational tradeoffs. To illustrate this, we focus on an arithmetic constraint that includes n variables with a uniform domain size d, with an unbalanced syntax tree, that is, in which each operator in the expression contains at least one variable. Figure 1 shows a fragment of the expression syntax tree. We refer to the decomposition model using auxiliary variables such as Vars, a polymorphic view of the subtype as SViews, and parametric polymorphic views as PViews."}, {"heading": "4.5.1 Memory", "text": "A box-view object can be designed to free only the subset of the domain required for the expression client (e.g. the boundaries of the expression). In contrast, a variable retains the expression domain and may contain regions that are always ignored for propagation. In an expression that contains n \u2212 1 operators (fig. 1), the memory expenditure of the Vars model is in O (nD), where D is the size of the largest domain of an auxiliary variable. In practice, many solvers use [12, 13, 18] intervals to store the auxiliary variable domains (i.e. D = 2), eliminating this problem."}, {"heading": "4.5.2 Runtime", "text": "The analysis of runtime complexity focuses on the number of propagandists \"executions, function calls, arithmetic operations performed and updates of variable boundaries, for a single spread of the expression. We consider two worst-case situations: a) if the spread (to the root) is caused by a change in the domain of the leaf variables, and b) if the spread to leaf variables is caused by a change in the domain of the root. These situations correspond respectively to accessing and updating the boundaries of the expression. a) In the Vars model, propagators can force the changes in the boundaries of O (n)."}, {"heading": "5 Experimental Results", "text": "In this section, we evaluate the performance of the decomposition methods described in the previous sections using a number of benchmarks."}, {"heading": "5.1 Experiments", "text": "In particular, we are interested in comparing the following models."}, {"heading": "5.1.1 Models", "text": "Vars. This is the classic method of splitting constraints into primitive propagators, which introduce an auxiliary variable for each partial expression.Vars + Global. This model is similar to the previous one, but uses global constraints to reduce the number of auxiliary variables. Only a subset of problems supports this decomposition. In this case, we will explicitly mention which global constraints apply.PViews. The model that implements decomposition based on parametric polymorphic view objects. View. Decomposition based on subtype polymorphic view objects. View + Global. Like the Vars + Global model, this model uses a combination of some types of views and a global constraint propagator.All of the above decomposition models were implemented in CaSPER [9, 10]. Additionally, we also implemented the first two in Gecode-Vars and GecodeVars + Global to use the comparison method to clarify the overall situation."}, {"heading": "5.1.2 Problems", "text": "This year it is so far that it will be able to the mentionlcihsrcsrVo rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc-the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rfu the rfu the rfu the rfu the rfu the rfu the"}, {"heading": "5.2 Setup", "text": "The experiments were compiled with the gcc-4.5.3 C + + compiler and run on an Intel Core i7 @ 3.39 GHz with Mac OS X 10.7.4. Versions of the CaSPER and Gecode solvers were last available at the time of these experiments, respectively version 1.0.0rc2 and version 3.7.3. Each benchmark was repeated ten times and then repeated until the standard runtime deviation was less than 2% of the average time. Subsequently, the minimum runtime was used. Source code for all experiments can be provided on request (please email the first author)."}, {"heading": "5.3 Discussion", "text": "The results of all benchmarks are summarized in Tables 2 to 6 (more in detail in [8]), from which we can draw the following conclusions."}, {"heading": "5.3.1 Type parametric views versus Subtype polymorphic views", "text": "Let us remember from Section 4.1 on page 17 that solvers using type-parametric view objects are able to avoid a number of function calls due to code inlining optimizations. Table 2 shows how this optimization improves performance in practice. Overall, the acceleration of PViews wrt. SViews is 50% (i.e. 1 / 0.67 \u2212 1). Particularly for problems with a large number of sub-expressions, the acceleration can be up to 300%. Since type-parametric views are consistently better, we choose to use this model exclusively for the remaining experiments."}, {"heading": "5.3.2 Auxiliary variables versus Type parametric views", "text": "Table 3 compares the runtime of the best model using auxiliary variables, i.e. either Vars or Vars + Global, with the runtime of the best model using type parametric views, i.e. either PViews or PViews + Global. Viewing objects do not intend to be a substitute for global constraint propagators, so this table shows how much the runtime of a constraint program can be improved using the best tools available. Before taking a global view of the results in this table, we will focus on the specific case of benchmarking with systems of linear equations. Remember that this benchmark should not be considered part of a realistic application of views or auxiliary variables, as it can only be modeled using a global constraint propagator. However, modeling the global sum constraint using type parametric views of binary sums is only 10% worse on average, which is nonetheless noteworthy."}, {"heading": "5.3.3 Competitiveness", "text": "Furthermore, the modeling of dismountable constraints using type parametric views makes CaSPER competitive with the state-of-the-art gecode solver, as can be seen by comparing the results presented in Table 5 and Table 6. In the first table, we compare the runtimes achieved by running the same model on both solvers, i.e. Vars + Global and GecodeVars + Global. The second table compares the PViews model with GecodeVars + Global, the best models that can be implemented on both platforms using the available modeling primitives. While CaSPER is worse in all but one problem when auxiliary variables and global spreaders are used, it will be faster when type parametric views are used. We believe that the discrepancy observed in the fixed-length error code correction benchmarks is related to aspects of the architecture of both solutions, which are strongly related to the benchtop-level analogous parameters we have seen on the multiple language summaries."}, {"heading": "5.3.4 Monitoring Execution", "text": "The theoretical discussion in the previous section indicates the reasons why the Views models, in particular the PViews model, perform better than the Vars model. We checked to see if these indications were confirmed in the experiments described above. To do this, we monitored the execution of many cases of problems and consistently obtained results similar to those given below. Table 7 shows the results obtained in two cases of the problem with systems of nonlinear equations (see 5.1.2). Firstly, we found that in the first (satisfactory) instance of all models the same search trees were examined, while in the second (unsatisfactory) the Vars model examined a slightly smaller tree (1% fewer errors). As expected, the better performance of both views models (about 2 times faster) is due to the lower number of executions of propagators and domain updates (an order of magnitude less than in the Vars model). Furthermore, PViews improves the performance (20% less of the updates of the better model) of these views (in spite of 30% of the better views), as well as the addition of the addition of a vendors."}, {"heading": "6 Conclusion and Future Work", "text": "In this paper, we addressed the modeling of decomposable constraints, challenging the traditional view that such decomposition can best be achieved through the use of auxiliary variables. We demonstrated that the proliferation of such decomposable constraints can be carried out by vision-based extenders that do not require such auxiliary variables, and discussed the properties of several approaches to this approach. In particular, we focused on models that use box-based extenders for pragmatic reasons, and demonstrated that, notwithstanding the fact that asymptotic worst-case analyses lead to the same complexity when applied to a comprehensive set of benchmarks that work much better than those based on auxiliary variables, even if the latter models use stronger extenders. We deliberately limited the instantiation of visual models to those that consist only of box-view approximations, largely because box-view objects can be implemented efficiently."}], "references": [{"title": "An automated approach to generating efficient constraint solvers", "author": ["D. Balasubramaniam", "C. Jefferson", "L. Kotthoff", "I. Miguel", "P. Nightingale"], "venue": "Proceedings of the 2012 International Conference on Software Engineering, ICSE 2012, pages 661\u2013671, Piscataway, NJ, USA", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Boolean and Cartesian abstraction for model checking C programs", "author": ["T. Ball", "A. Podelski", "S.K. Rajamani"], "venue": "International Journal on Software Tools for Technology Transfer (STTT), 5(1):49\u201358", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2003}, {"title": "Global constraint catalog", "author": ["N. Beldiceanu", "M. Carlsson", "J.-X. Rampon"], "venue": "The Internet", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Interval constraint logic programming", "author": ["F. Benhamou"], "venue": "A. Podelski, editor, Constraint programming: basics and trends, volume 910 of Lecture Notes in Computer Science, pages 1\u201321. Springer", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1995}, {"title": "Heterogeneous constraint solving", "author": ["F. Benhamou"], "venue": "Algebraic and Logic Programming, ALP\u201996, volume 1139 of Lecture Notes in Computer Science, pages 62\u201376. Springer-Verlag", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1996}, {"title": "Compiling and executing finite domain constraints", "author": ["B. Carlson"], "venue": "PhD thesis, Uppsala University", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1995}, {"title": "Maintaining generalized arc consistency on ad hoc r-ary constraints", "author": ["K.C.K. Cheng", "R.H.C. Yap"], "venue": "Principles and Practice of Constraint Programming, CP\u201908,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}, {"title": "Modern Techniques for Constraint Solving: The CaSPER Experience", "author": ["M. Correia"], "venue": "PhD thesis,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "On the Efficiency of Impact Based Heuristics", "author": ["M. Correia", "P. Barahona"], "venue": "Principles and Practice of Constraint Programming, CP\u201908, volume 5202 of Lecture Notes in Computer Science, pages 608\u2013612. Springer", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "CaSPER: A programming environment for development and integration of constraint solvers", "author": ["M. Correia", "P. Barahona", "F. Azevedo"], "venue": "F. Azevedo, editor, Workshop on Constraint Programming Beyond Finite Integer Domains, BeyondFD\u201905", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2005}, {"title": "The essence of essence: A constraint language for specifying combinatorial problems", "author": ["A.M. Frisch", "M. Grum", "C. Jefferson", "B.M. Hernandez", "I. Miguel"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence, pages 73\u201388", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2005}, {"title": "Minion: A fast scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "European Conference on Artificial Intelligence, ECAI\u201906, pages 98\u2013102. IOS Press", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "Watched literals for constraint propagation in minion", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "F. Benhamou, editor, Principles and Practice of Constraint Programming, CP\u201906, volume 4204 of Lecture Notes in Computer Science, pages 182\u2013197. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2006}, {"title": "Data structures for generalised arc consistency for extensional constraints", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel", "P. Nightingale"], "venue": "Conference on Artificial Intelligence, AAAI\u201907, pages 191\u2013197. AAAI Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2007}, {"title": "CSPLib: a benchmark library for constraints", "author": ["I.P. Gent", "T. Walsh"], "venue": "Technical report, APES-09-1999", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1999}, {"title": "Constraint processing in cc(FD)", "author": ["P.V. Hentenryck", "V. Saraswat", "Y. Deville"], "venue": "Technical report, Brown University", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1992}, {"title": "A fast and simple algorithm for bounds consistency of the alldifferent constraint", "author": ["R. Lopez-Ortiz", "C.-G. Quimper", "J. Tromp", "P.V. Beek"], "venue": "International Joint Conference on Artificial Intelligence, IJCAI\u201903, pages 245\u2013250. Morgan Kaufmann Publishers, Inc", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2003}, {"title": "Propagation completeness of reactive constraints", "author": ["M.J. Maher"], "venue": "International Conference on Logic Programming, ICLP\u201902, volume 2401 of Lecture Notes in Computer Science, pages 148\u2013162. Springer", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2002}, {"title": "Minizinc: Towards a standard CP modelling language", "author": ["N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "G.J. Duck", "G. Tack"], "venue": "Principles and Practice of Constraint Programming, CP\u201907,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "editors", "author": ["F. Rossi", "P.V. Beek", "T. Walsh"], "venue": "Handbook of Constraint Programming. Foundations of Artificial Intelligence. Elsevier Science", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2006}, {"title": "Speeding up constraint propagation", "author": ["C. Schulte", "P.J. Stuckey"], "venue": "Principles and Practice of Constraint Programming, CP\u201904, volume 3258 of Lecture Notes on Computer Science, pages 619\u2013633. Springer", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "Views and iterators for generic constraint implementations", "author": ["C. Schulte", "G. Tack"], "venue": "Recent Advances in Constraints, volume 3978 of Lecture Notes in Computer Science, pages 118\u2013132. Springer", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2005}, {"title": "View-based propagator derivation", "author": ["C. Schulte", "G. Tack"], "venue": "Constraints, pages 1\u201333", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2012}, {"title": "Constraint Propagation \u2013 Models, Techniques, Implementation", "author": ["G. Tack"], "venue": "Doctoral dissertation,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2009}], "referenceMentions": [{"referenceID": 13, "context": "The problem of propagating decomposable constraints may be approached using knowledge compilation techniques [15, 7].", "startOffset": 109, "endOffset": 116}, {"referenceID": 6, "context": "The problem of propagating decomposable constraints may be approached using knowledge compilation techniques [15, 7].", "startOffset": 109, "endOffset": 116}, {"referenceID": 15, "context": "indexical constraints [17, 6]), do not require exponential memory.", "startOffset": 22, "endOffset": 29}, {"referenceID": 5, "context": "indexical constraints [17, 6]), do not require exponential memory.", "startOffset": 22, "endOffset": 29}, {"referenceID": 19, "context": "Rina Dechter [22] approaches decomposition of constraints from a different perspective.", "startOffset": 13, "endOffset": 17}, {"referenceID": 9, "context": "View based-propagation was introduced in [10] and [24].", "startOffset": 41, "endOffset": 45}, {"referenceID": 21, "context": "View based-propagation was introduced in [10] and [24].", "startOffset": 50, "endOffset": 54}, {"referenceID": 23, "context": "The present work can be seen as an extension of [26, 25] for allowing the use of a particular kind of view over functions involving multiple variables ([26] restricts the use of views to injective functions and therefore to unary functions mostly).", "startOffset": 48, "endOffset": 56}, {"referenceID": 22, "context": "The present work can be seen as an extension of [26, 25] for allowing the use of a particular kind of view over functions involving multiple variables ([26] restricts the use of views to injective functions and therefore to unary functions mostly).", "startOffset": 48, "endOffset": 56}, {"referenceID": 23, "context": "The present work can be seen as an extension of [26, 25] for allowing the use of a particular kind of view over functions involving multiple variables ([26] restricts the use of views to injective functions and therefore to unary functions mostly).", "startOffset": 152, "endOffset": 156}, {"referenceID": 23, "context": "In contrast, views as described in [26] are used essentially as a development tool for increasing the number of available propagators in the library.", "startOffset": 35, "endOffset": 39}, {"referenceID": 18, "context": "Compilers for constraint modeling languages [21, 11, 1] generate efficient constraint solvers from a high level description of a constraint problem.", "startOffset": 44, "endOffset": 55}, {"referenceID": 10, "context": "Compilers for constraint modeling languages [21, 11, 1] generate efficient constraint solvers from a high level description of a constraint problem.", "startOffset": 44, "endOffset": 55}, {"referenceID": 0, "context": "Compilers for constraint modeling languages [21, 11, 1] generate efficient constraint solvers from a high level description of a constraint problem.", "startOffset": 44, "endOffset": 55}, {"referenceID": 15, "context": "Indexicals [17, 6] and constrained expressions [18] are conceptually close to the idea of views described in this paper.", "startOffset": 11, "endOffset": 18}, {"referenceID": 5, "context": "Indexicals [17, 6] and constrained expressions [18] are conceptually close to the idea of views described in this paper.", "startOffset": 11, "endOffset": 18}, {"referenceID": 23, "context": "Following [26] we generalise the notion of domains from single variables to more general n-ary domains and characterize their approximations.", "startOffset": 10, "endOffset": 14}, {"referenceID": 1, "context": "We introduce now important tuple set operations: Cartesian approximation (see for example [2]) and box approximation [4].", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "We introduce now important tuple set operations: Cartesian approximation (see for example [2]) and box approximation [4].", "startOffset": 117, "endOffset": 120}, {"referenceID": 7, "context": "The following lemma (proofs for most propositions and lemmas in this paper are given in [8]) shows how the previously defined approximations are ordered for a given tuple set (or constraint).", "startOffset": 88, "endOffset": 91}, {"referenceID": 23, "context": "\u03c0c (S1) \u2286 \u03c0c (S2) if S1 \u2286 S2, although this property is not mandatory in modern constraint solvers, as shown in [26].", "startOffset": 112, "endOffset": 116}, {"referenceID": 23, "context": "We should note that when considering real box approximations, con (c) in the above definition corresponds to the relaxation of constraint c to the real numbers [26].", "startOffset": 160, "endOffset": 164}, {"referenceID": 23, "context": "Table 1 shows the correspondence between the constraint consistencies that are traditionally considered [26, 22, 20, 5] and the different \u03a6\u03a8-completeness of the propagators.", "startOffset": 104, "endOffset": 119}, {"referenceID": 19, "context": "Table 1 shows the correspondence between the constraint consistencies that are traditionally considered [26, 22, 20, 5] and the different \u03a6\u03a8-completeness of the propagators.", "startOffset": 104, "endOffset": 119}, {"referenceID": 17, "context": "Table 1 shows the correspondence between the constraint consistencies that are traditionally considered [26, 22, 20, 5] and the different \u03a6\u03a8-completeness of the propagators.", "startOffset": 104, "endOffset": 119}, {"referenceID": 4, "context": "Table 1 shows the correspondence between the constraint consistencies that are traditionally considered [26, 22, 20, 5] and the different \u03a6\u03a8-completeness of the propagators.", "startOffset": 104, "endOffset": 119}, {"referenceID": 2, "context": "Also known as ad-hoc constraints, they represent an access to an element of a data structure (a table, a matrix, a relation) [3].", "startOffset": 125, "endOffset": 128}, {"referenceID": 15, "context": "Notice some similarities of views with indexicals introduced in [17, 6] to create propagators for arithmetic constraints.", "startOffset": 64, "endOffset": 71}, {"referenceID": 5, "context": "Notice some similarities of views with indexicals introduced in [17, 6] to create propagators for arithmetic constraints.", "startOffset": 64, "endOffset": 71}, {"referenceID": 5, "context": "However, unlike views, indexicals do not define the inverse transformation \u03c6\u2212 and therefore are less powerful representing a decomposable constraint using indexicals requires the additional definition of the projection of the object function for each variable in the constraint, even if this projection may be performed automatically as shown in [6].", "startOffset": 346, "endOffset": 349}, {"referenceID": 7, "context": "For these view-based propagators the following property can be proved [8].", "startOffset": 70, "endOffset": 73}, {"referenceID": 7, "context": "A thorough analysis of the propagation achieved with box view propagators is complex and dependent on the constraints involved (see [8]).", "startOffset": 132, "endOffset": 135}, {"referenceID": 20, "context": "Triggering is a well known method for decreasing the number of redundant propagations during a fixpoint computation [23].", "startOffset": 116, "endOffset": 120}, {"referenceID": 12, "context": "[14].", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "In practice, although D may be as large as dn\u22121, many solvers [12, 13, 18] use intervals to store the domains of the auxiliary variable (i.", "startOffset": 62, "endOffset": 74}, {"referenceID": 8, "context": "All the above decomposition models were implemented in CaSPER [9, 10].", "startOffset": 62, "endOffset": 69}, {"referenceID": 9, "context": "All the above decomposition models were implemented in CaSPER [9, 10].", "startOffset": 62, "endOffset": 69}, {"referenceID": 14, "context": "For additional information, we provide references to detailed descriptions of the problems in the online constraint programming benchmark database CSPLib [16].", "startOffset": 154, "endOffset": 158}, {"referenceID": 16, "context": "Instead, the constraint is used directly as follows, distinct (all (1 \u2264 i \u2264 m, 1 \u2264 j \u2264 m, j < i, xi \u2212 xj)) and enforced with the bounds complete propagator introduced by [19].", "startOffset": 170, "endOffset": 174}, {"referenceID": 7, "context": "The results of all benchmarks are summarized in tables 2 to 6 (more detailed in [8]) from which we may draw the following conclusions.", "startOffset": 80, "endOffset": 83}, {"referenceID": 23, "context": "But it will be interesting to check whether this could be done for specific classes of functions, similarly to what was done in [26].", "startOffset": 128, "endOffset": 132}, {"referenceID": 18, "context": "Finally, given the superior performance of PViews compared with SViews, one may question what to do when the former cannot be used directly, as occurs when the problem at hand is specified in an interpreted environment such as MiniZinc [21] where there is no C++ compilation involved.", "startOffset": 236, "endOffset": 240}, {"referenceID": 0, "context": "Pre-processing constraint problems for generating specific solver binaries is shown in [1].", "startOffset": 87, "endOffset": 90}], "year": 2017, "abstractText": null, "creator": "TeX"}}}