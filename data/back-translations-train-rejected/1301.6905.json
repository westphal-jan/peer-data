{"id": "1301.6905", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Jan-2013", "title": "Towards a Logic-Based Unifying Framework for Computing", "abstract": "Computer Science today lacks a unified view of Computing. Instead, the main subareas, most notably artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem-solving and computation.", "histories": [["v1", "Tue, 29 Jan 2013 12:23:26 GMT  (756kb)", "http://arxiv.org/abs/1301.6905v1", null], ["v2", "Thu, 24 Apr 2014 07:25:29 GMT  (0kb,I)", "http://arxiv.org/abs/1301.6905v2", "An improved version of this paper will be published in the journal, New Generation Computing, with the title \"Reactive Computing as Model Generation\". In the meanwhile, a copy of the revised paper can be found onthis http URL"]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.DB cs.PL", "authors": ["robert kowalski", "fariba sadri"], "accepted": false, "id": "1301.6905"}, "pdf": {"name": "1301.6905.pdf", "metadata": {"source": "CRF", "title": "Towards a Logic-Based Unifying Framework for Computing", "authors": ["ROBERT KOWALSKI"], "emails": [], "sections": [{"heading": null, "text": "Towards a logical Unifying Framework for Computing ROBERT KOWALSKI, Imperial College London FARIBA SADRI, Imperial College LondonComputer Science, today there is a lack of a unified view of computing. Instead, the most important sub-areas, in particular artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem solving and calculation. In this paper, we propose a unified logical framework for computing, inspired by artificial intelligence but reduced to practical database and programming applications. Calculation within the framework is seen as the task of generating a sequence of state transitions with the aim of making the goals of an agent all come true. States are represented by sets of atomic sets (or facts) representing the values of program variables, tuples in a coordination language, facts in relative databases or herbrand models."}, {"heading": "1. INTRODUCTION", "text": "In fact, most of them are able to survive themselves by going in search of themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves, most of them are able to survive themselves."}, {"heading": "2. EXAMPLES", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Emergencies", "text": "This year, there is less than a year to go before an agreement can be reached."}, {"heading": "2.2 Dialogue", "text": "In this example, an agent \"me\" is trying to make a reactive rule come true by generating a starting set when it receives an input set from the agent \"you.\" The predicate set (agent, T1, T2) represents a composite event that from time to time T2.R sentence (you, T1, T2) sentence (me, T3, T4) must be within 3 seconds of the completed input.The utterance of an agent T3 \u2264 T2 + 3 secThe time limitation in the sequence of the rule indicates that the composite output action set (me, T3, T4) is within 3 seconds of the completed input.The utterance of an agent of a word is treated as a simple (or atomic) event that occurs over an interval of time, and is represented by an atomic sentence (A, W, T1, T2)."}, {"heading": "2.3 Blocks world", "text": "In recent years, it has been shown that the \"old,\" \"new,\" \"old,\" \"new,\" \"new,\" \"old,\" \"new,\" \"old,\" \"new,\" \"new,\" \"new,\" \"new,\" \"new,\" \"old,\" \"new,\" \"new,\" \"new,\" \",\" \"old,\" \"\" new, \"\" \",\" \"\" new, \"\" \",\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\" \",\" \"\" \",\" \"\" \",\" \"\" \",\" \"\" \",\" \"\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\", \"\" \",\" \"\", \"\", \"\", \"\" \",\" \",\" \"\", \"\" \",\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\" \"\" \",\" \"\", \"\" \"\", \"\" \"\", \"\" \"\" \",\" \"\" \"\" \""}, {"heading": "2.4 The Dining Philosophers", "text": "Although the problem of food philosophers was originally proposed as a problem of simultaneous programming, the problem can also be looked at in both databases and in AI knowledge representation and problem solving concepts: in the initial state, five philosophers sit around a round table with a bowl of spaghetti in the middle of the table and five forks, one to the left and one to the right of each philosopher. Each philosopher switches between thinking and eating. To eat, a philosopher needs two adjacent forks. A philosopher can pick up the two adjacent forks when they are both available.The setting of the problem is similar to that of the block world. The forks are like blocks that have a fork, like an object on a block, and being available a fork is like a block that is clear. Similar restrictions apply to picking up a block: A fork cannot be picked up and moved to two different places."}, {"heading": "S12 = S9 = S6 = S2 = S1 = S0", "text": "In model theory semantics, all events and states are combined into a single Herbrand model M by adding an additional temporal argument to the fluents and events. M also includes the extension of the temporal inequality relationship \u2264 and the composite actions: dine (philosopher (0), 2, 6) dine (philosopher (2), 2, 6) dine (philosopher (1), 2, 9) dine (philosopher (3), 2, 9) dine (philosopher (4), 2, 12) Operational semantics correctly generates a model M in which the reactive rule R and the integrity constraints Dpre are all true. In fact, the logic program L is used to generate the model and therefore also applies to M. Note that although the global state has information about the availability of all five forks, a single agent may only have access to information about the availability of neighboring forks. In fact, the agent can function simply by relying on the environment to communicate its actions, including when its actions are successful."}, {"heading": "3. THE LANGUAGE", "text": "This year, it has reached the point where it will be able to retaliate."}, {"heading": "3.1 Vocabulary", "text": "The reasoning locations of function symbols and predicate symbols are assigned accordingly, so formulas are only well formed when the arguments are filled in by terms of the allowed variety. However, the predicate symbols of the language are divided into (disjunct) sets representing fluents, events, auxiliary predicates, and meta-predicates: Flowing predicate symbols are divided into extensional predicates representing facts in the states Si, and more intense predicates representing in Lint.Event predicates are similarly divided into simple event predicates and compound event predicates. Simple events can represent either externally generated events or internally generated actions that define Si as temporally usuccessive predicates. Auxiliary predicates consist of temporally independent predicates, such as defined metadata, and other metadata, such as max and expiry."}, {"heading": "3.2 Internal and external syntax", "text": "The explicit representation of the time defined by Ltemp substantiates the model theory semantics Q (Q). < Q (Q) Q (Q) Q (Q) can similarly be translated into the model theory semantics of the language. < Q (Q), however, can also be expressed in an external syntax at the expense of limiting the expressiveness of the language in which time is implicit. For example, in [Kowalski and Sadri 2011] the temporal order is indicated by the order in which formulas are written, and by the use of special logical connective. this is similar to the syntax of TR Logic [Bonner and Kifer 1993], in which P Q means \"P and then Q. In LPS, this is translated into an internal syntax of T2, which is translated into an internal syntax of TP with an explicit logical representation of time, e.g. P as (T1, T2) T&lt3 T&lt3 T&lt3, T&lt3 T&lt3, T&lt3 (T< T< T< T< T< T< T< T< T< T< T< T< TQ) or T< T< T< T< T< T< T< T< TQ) 3, or T< T< T< T< T< T< T< T< T< TQ) 3, or T< T< T< T< TQ (T< T< T< T< TQ), or T< T< T< T< T< T< T< T< TQ) 3, T3, or T< T< T< T< T< T< T< T< T< T< TQ), T3, TQ (T"}, {"heading": "3.3 Reactive Rules", "text": "In this context, it should be noted that the solution to the problem is not a purely theoretical question, but a purely theoretical one."}, {"heading": "3.4 Goal clauses", "text": "In both model theory and operational semantics, whenever the background history of a reactive rule becomes true, it may be necessary to make a sequence of the rule a goal to be achieved in the future. In addition to satisfying such derived goals, it may also be necessary to make a first set of goals a reality in the future. For this purpose, and because operational semantics maintains a goal state containing goal clauses, we define goal clauses here more generally: Definition 3.2 (goal clause). A goal clause is an existentially quantified combination of FOL state conditions, event atoms and time constraints. All variables in the time constraints occur in the state conditions and event atoms of the goal clause.Note that a goal clause can also be regarded as a reactive rule with an empty (or true) history."}, {"heading": "3.5 Logic programs", "text": "In fact, most people who are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to"}, {"heading": "3 Replacing an FOL condition in an FOL-stratified program by one that is logically equivalent does not", "text": "In fact, the FOL prediction can be extended to several levels. For example, stratification can be extended to several levels. If the predicate is clear, then the predicate flat can be defined as an intense predicate in the bodies of clauses, without the layer of intensive predicates being evaluated. If the predicate flat can be defined as an intense predicate in a higher layer than the layer of clear.flat (place, place, T) block [on (block, T) block is clear, if the predicate is clear, then the predicate flat can be defined as an intense predicate in a higher layer than the layer of clear.flat is the predicate flat \"and\" flat \"flat."}, {"heading": "3.6 The domain theory D", "text": "The domain theory D of an LPS program < R, L, D > consists of two components D = Dpost Dpre. The first component Dpost is a FOL-stratified logic program that specifies the extensional fluents initiated and terminated by simple events. The second component Dpre is a set of integrity constraints that restrict the occurrence and simultaneous occurrence of simple events.4 Note that X may contain other time parameters, as in the emergency example of Section 2.Definition 3.5 (Domain Theory D). Dpost is a set of clauses of the form: header (T2) bodies (T1, T2) and Dpre is a set of integrity constraints of the form: false body (T1, T2) head (T2) is an atom of the form initiated (P, T2) or termined (P, T2), where P is an extended precondition (T1)."}, {"heading": "3.7 The environment", "text": "An LPS framework < R, L, D > represents the goals R and beliefs L of a single agent, embedded in an environment consisting of a current state Si and current events. For convenience, the current state includes both the agent's own local state and the entire external global state. In a closed system consisting of a single agent without an external environment, the entire state is internal, and all events are internal actions. Dpost uses the events evi to update the state Si, and Dpre ensures that the set evi of events is possible. Dpost updates both the local and the global components of the state by using both the local and the global environment. In the case of purely internal actions, these updates are carried out entirely by the agent himself."}, {"heading": "4. THE MODEL-THEORETIC SEMANTICS OF LPS", "text": "In this section, we present two alternative semantics: the first contains an event theory ET that uses a frame axiom to express that any fluid that is not terminated by a state transition persists from one state to the next; the second uses destructive state updates; and, in Section 8, we show that the two semantics generate the same intended models."}, {"heading": "4.1 The event theory ET", "text": "In fact, it is such that most of us will be able to move into another world, in which they are able, in which they are able, in which they are able, in which they are able, in which they are able, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they"}, {"heading": "4.2 An abstract specification of the computational task", "text": "In fact, it is a purely mental game, in which the focus is on those people who are able to understand the world and understand how they are able to change the world. (...) In fact, it is that people are able to understand the world. (...) It is that people are able to understand the world. (...) It is that people are able to understand the world. (...) It is that people are able to understand the world. (...) It is that they are able to understand the world. (...) It is that they are able to understand the world. (...) It is that they are able to understand the world. (...) It is that they are able to understand the world. (...) It is that they are able to understand in the world. \"(...) It is that they are able to understand in the world. (...)"}, {"heading": "5. THE OPERATIONAL SEMANTICS", "text": "Operational semantics (OS) can be imagined as a potentially never-ending cycle in which external events and internal actions merge, the state is destructively updated, and the actor thinks and decides what to do next. Thinking can be interrupted to observe changes in the environment and perform actions; the cycle is relatively abstract and compatible with many different implementations; in particular, while the OS is defined for programs written with an explicit representation of time, it can also be implemented directly, as in [Kowalski and Sadri 2011], for programs written in an external syntax, in which temporal order is specified by the order in which conditions and events are written; the cycle is also only semi-constructive; extended states can contain a countable number of soil atoms, and a FOL query can have a numerically infinite number of responses. In practice, these infinitencies can be avoided by eliminating functional symbols, such as data symbols."}, {"heading": "5.1 Goal States", "text": "In addition to maintaining the current state of Si, the OS maintains a target state Gi, which represents a set of (or a combination) target trees. Each node in a target tree is a target clause, which represents an alternative way of resolving the top-level target clause at the root of the tree. This top-level target clause is either an initial target clause, or an instance of the reactive rule, which is introduced when the vanguard of the rule comes true. To solve the arithmetic task, all target trees must ultimately be faithful to tru.Definition 5.1 (Goal State) is a set (or conjunction) of target fidelity.A target tree for a target clause C0 is a set (or disjunction) of target clauses organized in a tree."}, {"heading": "5.2 The OS Cycle", "text": "Given an LPS program < R, L >, D >, it would be necessary to ensure that these steps can be taken before these steps are necessary."}, {"heading": "6. FOL-STRATIFICATION", "text": "Operational semantics refers to abstract semantics sem (X, Y) 2. Definition. In this section, we define FOL stratification and instantiate sem to FOL perfect model semantics. FOL stratification is a generalization of local stratification in which the restriction to negative letters to non-atomic FOL formulas is generalized. Similarly, the construction of FOL perfect models generalizes the construction of perfect models. As usual in logic programming, we treat a logic program P with variables representing the specified ground (P) of all of its soil instances above the Herbrand universe. Through a ground instance of a clause head (X, Y) the body (X) becomes a clause of the shape head (x, y), where x and y sets of the basic terms are substituted. The variables in X and Y do not include variables bound by quantifiers, which are more in quantifiers."}, {"heading": "7. SOUNDNESS AND COMPLETENESS", "text": "In this section we discuss the solidity and completeness of the operational semantics of LPSs."}, {"heading": "8. SOLVING THE COMPUTATIONAL ASPECT OF THE", "text": "FRAME PROBLEMIn this section, we show that the models obtained by destructive updates in LPS are identical to the models obtained by applying the ET event theory: holds (P, T2) initiated (P, T1, T2) holds (P, T2) holds (P, T1) terminated (T1, T2). We also define a generalization of the FOL stratification necessary to define the natural, intended model of Q = ET Dpost L S0 * ev *. Subsequently, we will show that the intended model of Q is identical with the FOL perfect model of L S * ev *."}, {"heading": "8.1 Weak stratification and weakly perfect models", "text": "The intended model of Q is constructed by dividing the Herbrand base H of Q into strata (Q = 1). (Q = 1) The sequence of points of time t0,..., ti, ti + 1,... is determined by succ (ti, ti + 1) perfect (Ltemp Ltimeless): H0 = {holds (p, t0) | e is a simple event, and u is an atom with a contemporary predicate} {a is an atom with a temporal predicate, including succ} {happens (e, u) | e is a simple event, and t and u are points of time} Because i is an atom with a temporal predicate (ti)."}, {"heading": "8.2 The Frame Theorem", "text": "The following theorem links the two characterizations of the semantics of LPS.THEOREM 8.2 (FRAME THEOREM).perfect (L S * ev *) = weak-perfect (ET Dpost L S0 * ev *) - {head | head body ground (Dpost)}.equivalent, perfect (Dpost L S * ev *) = weak-perfect (ET Dpost L S0 * ev * SKETCH OF PROOF. Suffice it to show that perfect (Dpost Lint Ltimeless Ltemp S * ev *) = weak-perfect (ET Dpost Lint Ltimeless Ltemp S0 * ev *).This is because in both models levents is used only in the last layers to superimpose composite events of the underlying sequence of states and simple happenings.Note that floor (ET) = Q3 Q3i + 3..., where Q3i + 3 = {ti (p, + 1) + 1 (SET) can be perfect."}, {"heading": "9. COMPARISON WITH OTHER WORK", "text": "LPS arose from our attempts to reconcile and combine contradictory approaches to computing in fields as diverse as logical programming, production systems, active and deductive databases, agent programming languages, and the representation of causal theories in AI."}, {"heading": "9.1 Deductive databases", "text": "Our attention was initially drawn to the distinction between reactive rules and logic programs by the distinction of [Nicolas and Gallaire 1978] between derivative rules and integrity constraints in deductive databases, both of which have logical semantics. However, the exact nature of the relationship between their semantics was the subject of considerable debate in the early 1980s. Initially, the two main views were the consistency view and the theory view, both of which were defined relative to the completion of the database. In the consistency view, an integrity constraint is fulfilled if it is consistent with the completion of the database. In the theory view, it is satisfied if it is a theorem logically associated with the completion of the database. [Reiter 1988] also suggested an epistemic view, according to which integrity constraints are a database statement of what the database white riders are, [but 1988 also showed that all three are equal]."}, {"heading": "9.2 Abductive logic programming", "text": "The distinction between logic programs and integrity constraints also underpins Abductive Logic Programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002]. At ALP, a program consists of a triple < L, IC, A >, where L is a logic program, IC a set of integrity constraints, and A a set of \"deductible\" predicates that are not defined by L. A goal G is an observation that needs to be explained or a state achieved, and the goal is solved by generating a set of soil atoms in the vocabulary of the deductible predicates, so that L brings with it G, and L meets the integrity constraints IC. Similar to the case of deductive databases, different notions of withdrawal and integrity constraints of satisfaction have been proposed."}, {"heading": "9.3 Logic programming semantics", "text": "The inclusion of FOL conditions in LPS is an important feature motivated by their use in transactional logic to query database states during database updates. FOL stratification and weak FOL stratification with their associated models provide a natural environment for evaluating such FOL conditions. In addition, the weak FOL stratification also provides natural semantics for event theories such as ET. But the stratification is at odds with current trends in logical programming, where the prevailing approaches are sound semantics [Van Gelder et al. 1991] and stable model semantics [Gelfond and Lifschitz 1988]. Of course, it may be possible to repeat the semantics of FOL conditions in other approaches. In particular, there may be a natural way to present alternative sets of possible simultaneous events and the resulting states as alternative stable models. It may also be possible to modify the evaluation of FOL conditions to use three-stage semantics."}, {"heading": "9.3 Agent systems", "text": "In fact, it is a purely mental game, in which it is a matter of changing the world, of changing it and of changing it."}, {"heading": "9.4 Active databases", "text": "As I said, it is not that we are in a position to find a solution that addresses people's problems."}, {"heading": "9.5 Production systems", "text": "It was an attempt to understand the difference and relationship between production rules and logical programming rules that eventually led to our development of LPS. Several other authors have made similar attempts to provide production rules with declarative semantics. In most of these approaches, production rules are converted into logical programs. [Rashid 1994] focuses on the use of production rules as reactive rules and as predictive logic rules. She first paints rules that insert facts into logical programs, and rules that delete facts into integrity constraints. She then transforms the resulting combination of logic programs and integrity constraints into normal logic programs and uses the fixed point semantics of logic forward and simulates the production cycle."}, {"heading": "9.6 Causal theories in AI", "text": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al. 2004] use event calculation to represent and argue the relationship between fluents, actions and other events. In contrast to situation calculation, which objectifies global states or situations, event calculation objectifies times and events. However, in both situation calculation and event calculation, axioms are used to derive atomic propositions that represent the states of the world. Destructive updating is not possible because it is not possible to change the axioms in the middle of a piece of evidence. However, since ALP agents are embedded in an agent cycle, they can also directly observe the current state of the world and thus avoid the need to think about it. In other words, the world can serve as its own representation as it acts by Brooks 1991], rather than thinking out this representation of an agent's ability to observe the world."}, {"heading": "9.7 Parallelism and concurrency", "text": "The AI component results from the use of domain theory D to think about the combined effects of simultaneous actions, in the spirit of [Reiter 1996] \"s treatment of simultaneous actions in situational calculation and [Miller and Shanahan 2002]\" s treatment in event calculation. Recently, [Khandelwal and Fox 2012] have expanded Miller and Shanahan's approach to define the effects of multiple actions by using aggregated formulas in first-order logic. Our approach can be seen as an approximation to theirs and would benefit from a similar expansion through aggregated formulas. Unlike some other approaches that use news sharing to deal with conversion, LPS uses a Linda-like common state similar to the architecture of the table used in AI. Our assumption that the conventional environment does not explicitly determine what possible current events actually occur is not comparable to the use of goals. \""}, {"heading": "9.8 Reactive systems", "text": "An LPS framework < R, L, D > is essentially a reactive system in which logic programs L and causal theories D play a supporting role in reactive rules. [Harel 1986] contrasts reactive systems with \"transformational systems\" that turn inputs into outputs in a mathematically well-behaved manner. Unlike transformational systems, reactive systems are \"event-driven and must continuously respond to external and internal stimuli.\" He also characterizes them as an extension of state transitional systems that have the general form \"when an event occurs in state A when condition C is true at the time.\" [Harel 2009] notes that StateCharts, a graphical language for reactive systems, is \"the heart of the UML - what many people call its driving behavioral component.\""}, {"heading": "10 Future work", "text": "LPS has its origins in the representation of AI knowledge and argumentation languages, but in the interest of efficiency and focusing on the features required for databases and program applications, the AI features have been deliberately limited and simplified, ignoring, for example, the abductive explanation of observations, which was one of the main motivations of ALP. Likewise, the ability to perform preventive maintenance, which is a feature of the IFF detection method for ALP, has also been ignored. There are two complementary directions for future work. One direction is the reintroduction of LPS features, but also the more expensive features of ALP agents - for example, the planning clauses in earlier versions of ALP features."}, {"heading": "ACKNOWLEDGEMENTS", "text": "We are grateful to Imperial College for the EPSRC Pathways to Impact funding that has supported the implementation of LPS. Thanks also to David Kinny and Ken Satoh for helpful discussions and to Ken Satoh and Luis Pereira for their comments on an earlier draft of this paper."}], "references": [{"title": "An Event-Condition-Action Logic Programming Language", "author": ["J.J. Alferes", "F. Banti", "Brogi A."], "venue": "In: 10th European Conference on Logics in Artificial Intelligence, M. Fisher, W. van der Hoek, B. Konev and A. Lisitsa (eds.), JELIA06: Lecture Notes in Artificial Intelligence 4160, Springer-Verlag. 29- 42.", "citeRegEx": "Alferes et al\\.,? 2006", "shortCiteRegEx": "Alferes et al\\.", "year": 2006}, {"title": "Logic programming and negation: A survey", "author": ["K.R. Apt", "R.N. Bol"], "venue": "The Journal of Logic Programming,", "citeRegEx": "Apt and Bol,? \\Q1994\\E", "shortCiteRegEx": "Apt and Bol", "year": 1994}, {"title": "Active databases and agent systems\u2014A comparison", "author": ["J. Bailey", "M. Georgeff", "D. Kemp", "D. Kinny", "K. Ramamohanarao"], "venue": "Rules in Database Systems,", "citeRegEx": "Bailey et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Bailey et al\\.", "year": 1995}, {"title": "Characterizing production systems using logic programming and situation calculus http://www.cs.utep.edu/baral/papers/char-prod-systems.ps", "author": ["C. Baral", "J. Lobo"], "venue": null, "citeRegEx": "Baral and Lobo,? \\Q1995\\E", "shortCiteRegEx": "Baral and Lobo", "year": 1995}, {"title": "Transaction logic programming", "author": ["A. Bonner", "M. Kifer"], "venue": "Warren D. S., (ed.), Logic Programming: Proc. of the 10th International Conf., 257-279.", "citeRegEx": "Bonner and Kifer,? 1993", "shortCiteRegEx": "Bonner and Kifer", "year": 1993}, {"title": "Evolving Logic Programs", "author": ["A. Brogi", "J.A. Leite", "L.M. Pereira"], "venue": "In: 8th European Conference on Logics in Artificial Intelligence (JELIA'02), S. Flesca, S. Greco, N. Leone, G. Ianni (eds.), Spriger-Verlag, LNCS 2424, Springer-Verlag, 50-61.", "citeRegEx": "Brogi et al\\.,? 2002", "shortCiteRegEx": "Brogi et al\\.", "year": 2002}, {"title": "Intelligence Without Representation", "author": ["R.A. Brooks"], "venue": "Artificial Intelligence", "citeRegEx": "Brooks,? \\Q1991\\E", "shortCiteRegEx": "Brooks", "year": 1991}, {"title": "Declarative Semantics of Production Rules for Integrity Maintenance", "author": ["Caroprese", "S.L. Greco", "C. Sirangelo", "E. Zumpano"], "venue": "In: 22nd International Conference on Logic Programming, Etalle, S., Truszczynski, M. (eds.), LNCS 4079, 26\u201440.", "citeRegEx": "Caroprese et al\\.,? 2006", "shortCiteRegEx": "Caroprese et al\\.", "year": 2006}, {"title": "Linda in Context", "author": ["N. Carriero", "D. Gelernter"], "venue": "Communications of the ACM. Volume 32 Issue 4.", "citeRegEx": "Carriero and Gelernter,? 1989", "shortCiteRegEx": "Carriero and Gelernter", "year": 1989}, {"title": "Negation as Failure", "author": ["K. Clark"], "venue": "In: Readings in Nonmonotonic Reasoning, Morgan Kaufmann, 311\u2014325.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "The DALI Logic Programming Agent-Oriented Language", "author": ["S. Costantini", "A. Tocchio"], "venue": "In: Alferes, J.J., Leite, J. (eds.) JELIA 2004. LNCS (LNAI), vol. 3229, Springer, Heidelberg. 685\u2013688.", "citeRegEx": "Costantini and Tocchio,? 2004", "shortCiteRegEx": "Costantini and Tocchio", "year": 2004}, {"title": "About Declarative Semantics of Logic-Based Agent Languages, Dalt 2005, LNAI 3904, Baldoni, M", "author": ["S. Costantini", "A. Tocchio"], "venue": "et al (eds.), 106-123.", "citeRegEx": "Costantini and Tocchio,? 2006", "shortCiteRegEx": "Costantini and Tocchio", "year": 2006}, {"title": "Declarative semantics for the rule interchange format production rule dialect", "author": ["C. Dam\u00e1sio", "J. Alferes", "J. Leite"], "venue": "The Semantic Web\u2013ISWC", "citeRegEx": "Dam\u00e1sio et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Dam\u00e1sio et al\\.", "year": 2010}, {"title": "Abduction in logic programming", "author": ["M. Denecker", "A.C. Kakas"], "venue": "Computational Logic: Logic Programming and Beyond. Springer-Verlag, London, UK, 402\u2013436.", "citeRegEx": "Denecker and Kakas,? 2002", "shortCiteRegEx": "Denecker and Kakas", "year": 2002}, {"title": "Autonomous agents coordination: Action languages meet CLP() and Linda, Theory and Practice of Logic Programming", "author": ["A. Dovier", "A. Formisano", "E. Pontelli"], "venue": null, "citeRegEx": "Dovier et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dovier et al\\.", "year": 2012}, {"title": "Production Systems with Negation as Failure", "author": ["P.M. Dung", "P. Mancarella"], "venue": "IEEE Transactions on Knowledge and Data Engineering, Volume 14 , Issue 2, 336\u2014352.", "citeRegEx": "Dung and Mancarella,? 2002", "shortCiteRegEx": "Dung and Mancarella", "year": 2002}, {"title": "Heterogeneous active agents, I", "author": ["T. Eiter", "V.S. Subrahmanian", "G. G Pick"], "venue": "AI Journal, vol. 108, no. 1-2, 179-255.", "citeRegEx": "Eiter et al\\.,? 1999", "shortCiteRegEx": "Eiter et al\\.", "year": 1999}, {"title": "Simulating production rules using ACTHEX", "author": ["T. Eiter", "C. Feier", "M. Fink"], "venue": "Correct Reasoning,", "citeRegEx": "Eiter et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2012}, {"title": "The Semantics of Predicate Logic as a Programming", "author": ["M. van Emden", "R. Kowalski"], "venue": "Language, in JACM,", "citeRegEx": "Emden and Kowalski,? \\Q1976\\E", "shortCiteRegEx": "Emden and Kowalski", "year": 1976}, {"title": "A Logic-Based Integration of Active and Deductive Databases", "author": ["A.A.A. Fernandes", "M.H. Williams", "N. Paton"], "venue": "New Generation Computing, Volume 15, Number 2, 205\u2014244.", "citeRegEx": "Fernandes et al\\.,? 1997", "shortCiteRegEx": "Fernandes et al\\.", "year": 1997}, {"title": "A Survey of Concurrent METATEM - The Language and its Applications", "author": ["M. Fisher"], "venue": "Lecture notes in computer science, 827, Springer Verlag 480-505.", "citeRegEx": "Fisher,? 1994", "shortCiteRegEx": "Fisher", "year": 1994}, {"title": "A Structured Approach for the Definition of the Semantics of Active Databases", "author": ["P. Fraternali", "L. Tanca"], "venue": "ACM Transactions on Database Systems (TODS) Volume 20, Issue 4 (December 1995), 414\u2014471.", "citeRegEx": "Fraternali and Tanca,? 1995", "shortCiteRegEx": "Fraternali and Tanca", "year": 1995}, {"title": "The IFF Proof Procedure for Abductive Logic Programming", "author": ["T.H. Fung", "R. Kowalski"], "venue": "J. of Logic Programming.", "citeRegEx": "Fung and Kowalski,? 1997", "shortCiteRegEx": "Fung and Kowalski", "year": 1997}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "Lifschitz", "August"], "venue": "In Proceedings of the 5th International Conference on Logic programming (Vol", "citeRegEx": "Gelfond et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1988}, {"title": "Statecharts: A Visual Formalism for Complex Systems, Sci", "author": ["D. Harel"], "venue": "Comput. Programming 8 231-274.", "citeRegEx": "Harel,? 1987", "shortCiteRegEx": "Harel", "year": 1987}, {"title": "Statecharts in the making: a personal account", "author": ["D. Harel"], "venue": "Communications of the ACM,", "citeRegEx": "Harel,? \\Q2009\\E", "shortCiteRegEx": "Harel", "year": 2009}, {"title": "A new HTN planning framework for agents in dynamic environments", "author": ["H. Hayashi", "K. Cho", "A. Ohsuga"], "venue": "Computational Logic in Multi-Agent Systems,", "citeRegEx": "Hayashi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hayashi et al\\.", "year": 2005}, {"title": "Background Sensing Control for Planning Agents Working in the Real World", "author": ["H. Hayashi", "S. Tokura", "F. Ozaki", "Doi. M."], "venue": "International Journal of Intelligent Information and Database Systems, Inderscience Publishers, 3(4): 483-501.", "citeRegEx": "Hayashi et al\\.,? 2009", "shortCiteRegEx": "Hayashi et al\\.", "year": 2009}, {"title": "Complex Actions for Event Processing, Research Report, Institute for Informatics, University of Munich", "author": ["S. Hausmann", "M. Scherr", "F. Bry"], "venue": null, "citeRegEx": "Hausmann et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hausmann et al\\.", "year": 2012}, {"title": "A blackboard architecture for control, Artificial Intelligence, Volume 26, Issue", "author": ["B. Hayes-Roth"], "venue": null, "citeRegEx": "Hayes.Roth,? \\Q1985\\E", "shortCiteRegEx": "Hayes.Roth", "year": 1985}, {"title": "The Declarative Imperative: Experiences and Conjectures in Distributed Logic, SIGMOD Record 39(1)", "author": ["J.M. Hellerstein"], "venue": null, "citeRegEx": "Hellerstein,? \\Q2010\\E", "shortCiteRegEx": "Hellerstein", "year": 2010}, {"title": "The Role of Logic Programming in Abduction", "author": ["A.C. Kakas", "R. Kowalski", "F. Toni"], "venue": "Handbook of Logic in Artificial Intelligence and Programming", "citeRegEx": "Kakas et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Kakas et al\\.", "year": 1998}, {"title": "The KGP model of agency", "author": ["A.C. Kakas", "P. Mancarella", "F. Sadri", "K Stathis", "F. Toni"], "venue": "In Proc. ECAI-2004", "citeRegEx": "Kakas et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Kakas et al\\.", "year": 2004}, {"title": "General Descriptions of Additive Effects via Aggregates in the Circumscriptive Event Calculus", "author": ["A. Khandelwal", "P. Fox"], "venue": null, "citeRegEx": "Khandelwal and Fox,? \\Q2012\\E", "shortCiteRegEx": "Khandelwal and Fox", "year": 2012}, {"title": "Logic for Problem Solving", "author": ["R. Kowalski"], "venue": null, "citeRegEx": "Kowalski,? \\Q1979\\E", "shortCiteRegEx": "Kowalski", "year": 1979}, {"title": "Computational Logic and Human Thinking: How to be Artificially Intelligent", "author": ["R. Kowalski"], "venue": null, "citeRegEx": "Kowalski,? \\Q2011\\E", "shortCiteRegEx": "Kowalski", "year": 2011}, {"title": "From Logic Programming Towards Multi-agent Systems", "author": ["R. Kowalski", "F. Sadri"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Kowalski and Sadri,? \\Q1999\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 1999}, {"title": "Integrating Logic Programming and Production Systems in Abductive Logic Programming Agents", "author": ["R. Kowalski", "F. Sadri"], "venue": "Proceedings of The Third International Conference on Web Reasoning and Rule Systems, Chantilly, Virginia, USA.", "citeRegEx": "Kowalski and Sadri,? 2009", "shortCiteRegEx": "Kowalski and Sadri", "year": 2009}, {"title": "An Agent Language with Destructive Assignment and ModelTheoretic Semantics", "author": ["R. Kowalski", "F. Sadri"], "venue": "Proc. of the 11th International Workshop on Computational Logic in Multi-Agent Systems (CLIMA),", "citeRegEx": "Kowalski and Sadri,? \\Q2010\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2010}, {"title": "Abductive Logic Programming Agents with Destructive Databases", "author": ["R. Kowalski", "F. Sadri"], "venue": "Annals of Mathematics and Artificial Intelligence, Volume 62,", "citeRegEx": "Kowalski and Sadri,? \\Q2011\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2011}, {"title": "Teleo-Reactive abductive logic programs", "author": ["R. Kowalski", "F. Sadri"], "venue": "Logic Programs, Norms and Action,", "citeRegEx": "Kowalski and Sadri,? \\Q2012\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 2012}, {"title": "RuleML 2012, A Logic-Based Framework for Reactive Systems, Rules on the Web: Research and Applications, 2012 \u2013 Springer-Verlag", "author": ["R. Kowalski", "F. Sadri"], "venue": "A. Bikakis and A. Giurca (Eds.), LNCS 7438, pp. 1\u201315.", "citeRegEx": "Kowalski and Sadri,? 2012b", "shortCiteRegEx": "Kowalski and Sadri", "year": 2012}, {"title": "A Logic-based Calculus of Events", "author": ["R. Kowalski", "M. Sergot"], "venue": "In: New Generation Computing, Vol. 4, No.1, 67\u201495.", "citeRegEx": "Kowalski and Sergot,? 1986", "shortCiteRegEx": "Kowalski and Sergot", "year": 1986}, {"title": "Negation in Logic Programming", "author": ["K. Kunen"], "venue": "Journal of Logic Programming, 4:4 289\u2014 308.", "citeRegEx": "Kunen,? 1987", "shortCiteRegEx": "Kunen", "year": 1987}, {"title": "On Active Deductive Databases: The Statelog Approach", "author": ["G. Lausen", "B. Lud\u00e4scher", "W. May"], "venue": "In: Transactions and Change in Logic Databases, Decker, H., Freitag B., Kifer, M., Voronkov, A. (eds.), LNCS 1472, Springer.", "citeRegEx": "Lausen et al\\.,? 1998", "shortCiteRegEx": "Lausen et al\\.", "year": 1998}, {"title": "Making PROLOG More Expressive", "author": ["J.W. Lloyd", "R.W. Topor"], "venue": "Journal of Logic Programming", "citeRegEx": "Lloyd and Topor,? \\Q1984\\E", "shortCiteRegEx": "Lloyd and Topor", "year": 1984}, {"title": "Recent Advances in Declarative Networking, Practical Aspects of Declarative Languages-14th International Symposium, PADL", "author": ["B. Loo", "H. Gill", "C. Liu", "Y. Mao", "W. Marczak", "M. Sherr", "A. Wang", "W. Zhuo"], "venue": null, "citeRegEx": "Loo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Loo et al\\.", "year": 2012}, {"title": "Declarative Networking", "author": ["B.T. Loo", "B.T. Condie", "M. Garofalakis", "D.E. Gay", "J.M. Hellerstein", "P. Maniatis", "R. Ramakrishnan", "T. Roscoe", "I. Stoica"], "venue": "Communications of the ACM (CACM).", "citeRegEx": "Loo et al\\.,? 2009", "shortCiteRegEx": "Loo et al\\.", "year": 2009}, {"title": "The CIFF Proof Procedure for Abductive Logic Programming with Constraints: Theory, Implementation and Experiments", "author": ["P. Mancarella", "G. Terreni", "F. Sadri", "F. Toni", "U. Endriss"], "venue": "Theory and Practice of Logic Programming.", "citeRegEx": "Mancarella et al\\.,? 2009", "shortCiteRegEx": "Mancarella et al\\.", "year": 2009}, {"title": "Some Philosophical Problems from the Standpoint of Artificial Intelligence, Machine Intelligence 4, Edinburgh University Press", "author": ["J. McCarthy", "P. Hayes"], "venue": "463-502.", "citeRegEx": "McCarthy and Hayes,? 1969", "shortCiteRegEx": "McCarthy and Hayes", "year": 1969}, {"title": "Some Alternative Formulations of the Event Calculus", "author": ["Miller R.", "M. Shanahan"], "venue": "Computational logic: logic programming and beyond. Springer-Verlag, 452-490.", "citeRegEx": "R. and Shanahan,? 2002", "shortCiteRegEx": "R. and Shanahan", "year": 2002}, {"title": "Production Systems: Models of Control Structure", "author": ["A. Newell"], "venue": "In: Chase W. (ed.), Visual Information Processing, 463-526 New York, Academic Press, pp. 463\u2014526.", "citeRegEx": "Newell,? 1973", "shortCiteRegEx": "Newell", "year": 1973}, {"title": "Database: Theory vs", "author": ["J.M. Nicolas", "H. Gallaire"], "venue": "Interpretation. In: Gallaire, H., Minker, J. (eds.), Logic and Databases, Plenum, New York.", "citeRegEx": "Nicolas and Gallaire,? 1978", "shortCiteRegEx": "Nicolas and Gallaire", "year": 1978}, {"title": "Teleo-reactive Programs and the Triple-tower Architecture, Electronic Transactions on Artificial Intelligence, Vol", "author": ["N.J. Nilsson"], "venue": "5, Section B, 99-110.", "citeRegEx": "Nilsson,? 2001", "shortCiteRegEx": "Nilsson", "year": 2001}, {"title": "Definite clause grammars for language analysis\u2014A survey of the formalism and a comparison with augmented transition networks, Artificial Intelligence", "author": ["Pereira", "F.C.N", "Warren", "D.H.D"], "venue": "Volume 13,", "citeRegEx": "Pereira et al\\.,? \\Q1980\\E", "shortCiteRegEx": "Pereira et al\\.", "year": 1980}, {"title": "On the declarative semantics of stratified deductive databases and logic programs", "author": ["T. Przymusinski"], "venue": "Foundations of Deductive Databases and Logic Programming, Morgan Kaufmann, J. Minker (Ed.) 193 \u2013 216.", "citeRegEx": "Przymusinski,? 1987", "shortCiteRegEx": "Przymusinski", "year": 1987}, {"title": "Weakly perfect model semantics for logic programs, Fifth Int'l Conf", "author": ["H. Przymusinska", "T. Przymusinski"], "venue": "Symp. on Logic Programming.", "citeRegEx": "Przymusinska and Przymusinski,? 1988", "shortCiteRegEx": "Przymusinska and Przymusinski", "year": 1988}, {"title": "A Semantics for a Class of Stratified Production System Programs", "author": ["L. Raschid"], "venue": "J. Log. Program. 21(1): 31\u201457.", "citeRegEx": "Raschid,? 1994", "shortCiteRegEx": "Raschid", "year": 1994}, {"title": "AgentSpeak (L): BDI agents speak out in a logical computable language", "author": ["A. Rao"], "venue": "Agents Breaking Away,", "citeRegEx": "Rao,? \\Q1996\\E", "shortCiteRegEx": "Rao", "year": 1996}, {"title": "On Integrity Constraints", "author": ["R. Reiter"], "venue": "In: 2nd Conference on Theoretical Aspects of Reasoning about Knowledge, pp. 97\u2014111.", "citeRegEx": "Reiter,? 1988", "shortCiteRegEx": "Reiter", "year": 1988}, {"title": "Natural actions, concurrency and continuous time in the situation calculus", "author": ["R. Reiter"], "venue": "In Proceedings of Principles of Knowledge Representation", "citeRegEx": "Reiter,? \\Q1996\\E", "shortCiteRegEx": "Reiter", "year": 1996}, {"title": "The expressive power of abstract-state machines", "author": ["W. Reisig"], "venue": "Computing and Informatics,", "citeRegEx": "Reisig,? \\Q2012\\E", "shortCiteRegEx": "Reisig", "year": 2012}, {"title": "Formalizing production systems with rule-based ontologies", "author": ["M. Rezk", "M. Kifer"], "venue": "Foundations of Information and Knowledge Systems,", "citeRegEx": "Rezk and Kifer,? \\Q2012\\E", "shortCiteRegEx": "Rezk and Kifer", "year": 2012}, {"title": "Solving the frame problem: a mathematical investigation of the common sense law of inertia", "author": ["M. Shanahan"], "venue": null, "citeRegEx": "Shanahan,? \\Q1997\\E", "shortCiteRegEx": "Shanahan", "year": 1997}, {"title": "FLUX: A logic programming method for reasoning agents", "author": ["M. Thielscher"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Thielscher,? \\Q2005\\E", "shortCiteRegEx": "Thielscher", "year": 2005}, {"title": "Integrating Action Calculi and AgentSpeak", "author": ["M. Thielscher"], "venue": "Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR), Lin, F and Sattler, U. (eds.), Toronto.", "citeRegEx": "Thielscher,? 2010", "shortCiteRegEx": "Thielscher", "year": 2010}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "On the Unification of Active Databases and Deductive databases", "author": ["C. Zaniolo"], "venue": "In: 11th British National Conference on Databases, 23-39.", "citeRegEx": "Zaniolo,? 1993", "shortCiteRegEx": "Zaniolo", "year": 1993}], "referenceMentions": [{"referenceID": 37, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 38, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 39, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 41, "context": "Earlier versions of the work presented in this paper have been presented in [Kowalski and Sadri 2009; Kowalski and Sadri 2010; Kowalski and Sadri 2011; Kowalski and Sadri 2012a; Kowalski and Sadri 2012b].", "startOffset": 76, "endOffset": 203}, {"referenceID": 8, "context": "The state is like a relational database, but also like a set of program variables or tuples in a coordination language [Carriero and Gelernter 1989].", "startOffset": 119, "endOffset": 148}, {"referenceID": 49, "context": "The domain theory D is similar to the situation calculus [McCarthy and Hayes 1969] or event calculus [Kowalski and Sergot 1986], but instead of using frame axioms to update states, it performs destructive updates on the current state, deleting facts that are terminated by the set of all events occurring in the state transition and adding facts that are initiated by the set of events.", "startOffset": 57, "endOffset": 82}, {"referenceID": 42, "context": "The domain theory D is similar to the situation calculus [McCarthy and Hayes 1969] or event calculus [Kowalski and Sergot 1986], but instead of using frame axioms to update states, it performs destructive updates on the current state, deleting facts that are terminated by the set of all events occurring in the state transition and adding facts that are initiated by the set of events.", "startOffset": 101, "endOffset": 127}, {"referenceID": 4, "context": "These composite events can be viewed as state-connecting paths, as in transaction logic [Bonner and Kifer 1993].", "startOffset": 88, "endOffset": 111}, {"referenceID": 55, "context": "The semantics of these FOL conditions is given by generalising negative literals to FOL conditions in the definitions of local stratification [Przymusinski 1987] and weak stratification [Przymusinska and Przymusinski 1988].", "startOffset": 142, "endOffset": 161}, {"referenceID": 56, "context": "The semantics of these FOL conditions is given by generalising negative literals to FOL conditions in the definitions of local stratification [Przymusinski 1987] and weak stratification [Przymusinska and Przymusinski 1988].", "startOffset": 186, "endOffset": 222}, {"referenceID": 28, "context": "The following example is a variant of an example in [Hausmann et al. 2012].", "startOffset": 52, "endOffset": 74}, {"referenceID": 34, "context": "These programs are similar to the logical representation of definite clause grammars [Pereira and Warren 1980] in Prolog, and used in [Kowalski 1979] to illustrate parsing as reasoning:", "startOffset": 134, "endOffset": 149}, {"referenceID": 39, "context": "In an earlier version of LPS [Kowalski and Sadri 2011] we allowed \u201cplanning clauses\u201d, which in the case of make-clear could have the form:", "startOffset": 29, "endOffset": 54}, {"referenceID": 41, "context": "Such planning clauses allow a higher level of knowledge representation than the version of LPS presented in [Kowalski and Sadri 2012a; Kowalski and Sadri 2012b] and in this paper.", "startOffset": 108, "endOffset": 160}, {"referenceID": 8, "context": "The solution of the dining philosophers\u2019 problem presented below is similar to the solution in C-Linda [Carriero and Gelernter 1989].", "startOffset": 103, "endOffset": 132}, {"referenceID": 8, "context": "The extensional fluents are like tuples in a relational database, or in a coordination language [Carriero and Gelernter 1989].", "startOffset": 96, "endOffset": 125}, {"referenceID": 39, "context": "For example, in [Kowalski and Sadri 2011], temporal ordering is indicated by the order in which formulas are written and by the use of special logical connectives.", "startOffset": 16, "endOffset": 41}, {"referenceID": 4, "context": "[Bonner and Kifer 1993], in which P \uf0c4 Q means \u201cdo P and then do Q\u201d.", "startOffset": 0, "endOffset": 23}, {"referenceID": 41, "context": "1 In [Kowalski and Sadri 2012b] we allowed consequents of rules to be disjunctions of such conjunctions.", "startOffset": 5, "endOffset": 31}, {"referenceID": 45, "context": "Like the antecedents and consequents of rules, they can also contain non-atomic FOL conditions, as in the extended logic programs of [Lloyd and Topor 1984].", "startOffset": 133, "endOffset": 155}, {"referenceID": 39, "context": "In particular, although the OS is defined for programs written with an explicit representation of time, it can also be implemented, as in [Kowalski and Sadri 2011], directly for programs written in an external syntax in which temporal order is indicated by the order in which conditions and events are written.", "startOffset": 138, "endOffset": 163}, {"referenceID": 29, "context": "In this way, the global state serves as a coordination medium, in the manner of the Linda programming paradigm [Carriero and Gelenter 1989] and the blackboard model [Hayes-Roth 1985].", "startOffset": 165, "endOffset": 182}, {"referenceID": 41, "context": "As pointed out in [Kowalski and Sadri 2012b], the operational semantics is incomplete.", "startOffset": 18, "endOffset": 44}, {"referenceID": 1, "context": "The problem and its solution are similar to those for the program [Apt and Bol 1994]:", "startOffset": 66, "endOffset": 84}, {"referenceID": 52, "context": "Our attention was first drawn to the distinction between reactive rules and logic programs by the distinction made by [Nicolas and Gallaire 1978] between deduction rules and integrity constraints in deductive databases, both of which have a logical semantics.", "startOffset": 118, "endOffset": 145}, {"referenceID": 9, "context": "The two main views, to begin with, were the consistency view and the theoremhood view, both of which were defined relative to the completion of the database [Clark 1978].", "startOffset": 157, "endOffset": 169}, {"referenceID": 59, "context": "[Reiter 1988] also proposed an epistemic view, according to which integrity constraints are statements about what the database knows.", "startOffset": 0, "endOffset": 13}, {"referenceID": 59, "context": "However, [Reiter 1988] also showed that in many cases all three views are equivalent.", "startOffset": 9, "endOffset": 22}, {"referenceID": 4, "context": "The use of logic programs in LPS with FOL conditions was largely inspired by transaction logic [Bonner and Kifer 1993], which uses such programs to define database transactions.", "startOffset": 95, "endOffset": 118}, {"referenceID": 31, "context": "The distinction between logic programs and integrity constraints also underpins abductive logic programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002].", "startOffset": 114, "endOffset": 158}, {"referenceID": 13, "context": "The distinction between logic programs and integrity constraints also underpins abductive logic programming (ALP) [Kakas et al. 1998; Denecker and Kakas 2002].", "startOffset": 114, "endOffset": 158}, {"referenceID": 22, "context": "The operational semantics of LPS is a variant of the IFF proof procedure [Fung and Kowalski 1997], originally developed for Kunen\u2019s three valued completion semantics [Kunen 1987].", "startOffset": 73, "endOffset": 97}, {"referenceID": 43, "context": "The operational semantics of LPS is a variant of the IFF proof procedure [Fung and Kowalski 1997], originally developed for Kunen\u2019s three valued completion semantics [Kunen 1987].", "startOffset": 166, "endOffset": 178}, {"referenceID": 30, "context": "For example, the application of Datalog to declarative networking [Loo et al 2009; Hellerstein 2010; Loo et al 2012] makes heavy use of stratification, and the extensions of stratification in this paper might also be useful in that domain.", "startOffset": 66, "endOffset": 116}, {"referenceID": 32, "context": "The ALP agent approach was developed further in the KGP agent model [Kakas et al. 2004; Mancarella et al. 2009].", "startOffset": 68, "endOffset": 111}, {"referenceID": 48, "context": "The ALP agent approach was developed further in the KGP agent model [Kakas et al. 2004; Mancarella et al. 2009].", "startOffset": 68, "endOffset": 111}, {"referenceID": 5, "context": "For example in both DALI [Costantini and Tocchino 2004; Costantini and Tocchino 2006] and EVOLP [Brogi et al. 2002], events transform an initial agent logic program into a sequence of logic programs.", "startOffset": 96, "endOffset": 115}, {"referenceID": 64, "context": "FLUX [Thielscher 2005] is an agent language with several features similar to LPS, including the use of destructive assignment to update states.", "startOffset": 5, "endOffset": 22}, {"referenceID": 65, "context": "[Thielscher 2010] provides a declarative semantics for AgentSpeak by defining its cycle and procedures by means of a meta-interpreter represented as a logic program.", "startOffset": 0, "endOffset": 17}, {"referenceID": 26, "context": "Somewhat closer to LPS is the agent architecture of [Hayashi et al. 2005; Hayashi et al 2009], which separates the representation of reactive rules and planning clauses.", "startOffset": 52, "endOffset": 93}, {"referenceID": 16, "context": "38 [Eiter et al. 1999]] define an extension of logic programming in which the clauses represent the conditions under which actions are permitted, forbidden, obliged or waived.", "startOffset": 3, "endOffset": 22}, {"referenceID": 2, "context": "As pointed out by [Bailey et al. 1995], although they differ in their intended applications and research communities, agent systems and active databases employ similar approaches to programming reactive systems.", "startOffset": 18, "endOffset": 38}, {"referenceID": 58, "context": "For example, AgentSpeak [Rao 1996] employs agent programs that are plans consisting of a triggering event, a context, which specifies the conditions that should hold when the plan is triggered, and a body, which specifies the goals the agent should achieve or test, and the actions the agent should execute.", "startOffset": 24, "endOffset": 34}, {"referenceID": 67, "context": "[Zaniolo 1993], for example, uses a situation calculus-like representation with frame axioms, and reduces ECA rules to logic programs.", "startOffset": 0, "endOffset": 14}, {"referenceID": 44, "context": "Statelog [Lausen et al. 1998] also uses a situation-calculus-like representation for the succession of database states.", "startOffset": 9, "endOffset": 29}, {"referenceID": 0, "context": "ERA (Evolving Reactive Algebraic Programs) [Alferes et al. 2006] extends the dynamic logic programming system EVOLP [Brogi et al.", "startOffset": 43, "endOffset": 64}, {"referenceID": 5, "context": "2006] extends the dynamic logic programming system EVOLP [Brogi et al. 2002] by adding complex events and actions as well as external actions.", "startOffset": 57, "endOffset": 76}, {"referenceID": 21, "context": "[Fraternali and Tanca 1995] also consider active databases but provide a logic-based core syntax for representing low-level, procedural features of active database rules.", "startOffset": 0, "endOffset": 27}, {"referenceID": 51, "context": "Arguably, production systems [Newell 1973], in which programs are expressed as condition-action rules, are the simplest example of a reactive system, and the earliest ancestor both of agent systems and active databases.", "startOffset": 29, "endOffset": 42}, {"referenceID": 57, "context": "[Raschid 1994] focuses on the use of production rules as reactive rules and as forward-reasoning logic rules.", "startOffset": 0, "endOffset": 14}, {"referenceID": 3, "context": "[Baral and Lobo 1995] translate production rules into the situation calculus represented as a logic program with the stable model semantics.", "startOffset": 0, "endOffset": 21}, {"referenceID": 15, "context": "[Dung and Mancarella 2002], on the other hand, use an argumentation theoretic framework to provide semantics for production rules extended with negation as failure.", "startOffset": 0, "endOffset": 26}, {"referenceID": 62, "context": "[Rezk and Kifer 2012] combine production rules and ontologies, using transaction logic.", "startOffset": 0, "endOffset": 21}, {"referenceID": 36, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al.", "startOffset": 11, "endOffset": 51}, {"referenceID": 35, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al.", "startOffset": 11, "endOffset": 51}, {"referenceID": 32, "context": "ALP agents [Kowalski and Sadri 1999; Kowalski 2011] and the KGP agent model [Kakas et al. 2004] employ the event calculus to represent and reason about the relationship between fluents, actions and other events.", "startOffset": 76, "endOffset": 95}, {"referenceID": 6, "context": "In other words, the world can serve as its own representation, as advocated by [Brooks 1991].", "startOffset": 79, "endOffset": 92}, {"referenceID": 60, "context": "The AI component comes from the use of the domain theory D, to reason about the combined effects of concurrent actions, in the spirit of [Reiter 1996]\u2019s treatment of concurrent actions in the situation calculus and [Miller and Shanahan 2002]\u2019s treatment in the event calculus.", "startOffset": 137, "endOffset": 150}, {"referenceID": 33, "context": "Recently, [Khandelwal and Fox 2012] have extended Miller and Shanahan\u2019s approach, to define the effects of multiple actions by using aggregate formulas in first-order logic.", "startOffset": 10, "endOffset": 35}, {"referenceID": 14, "context": "Our assumption that the environment non-deterministically decides which sets of possible concurrent events actually occur is similar to the use of a \u201csupervisor\u201d in [Dovier et al. 2012], to arbitrate between the conflicting actions of different agents in the pursuit of different goals.", "startOffset": 165, "endOffset": 185}, {"referenceID": 14, "context": "In addition, [Dovier et al. 2012] also provides communication primitives, to allow agents to resolve conflicts through negotiation.", "startOffset": 13, "endOffset": 33}, {"referenceID": 30, "context": "In this respect, it is encouraging to note the recent developments [Hellerstein 2010] in the use of Datalog and the explicit", "startOffset": 67, "endOffset": 85}, {"referenceID": 30, "context": "Although frame axioms are represented explicitly in [Hellerstein 2010], they are not used in the implementation, using instead \u201ctraditional storage technology rather than rederiving tuples each timestep\u201d.", "startOffset": 52, "endOffset": 70}, {"referenceID": 25, "context": "[Harel 2009] notes that StateCharts, a graphical language for reactive systems, is \u201cthe heart of the UML - what many people refer to as its driving behavioral kernel\u201d.", "startOffset": 0, "endOffset": 12}, {"referenceID": 61, "context": "As [Reisig 2012] puts it, an initialized, deterministic transition system is \u201ca triple C = (Q, I, F) where Q is a set (its elements are denoted as states), I \u2286 Q (the initial", "startOffset": 3, "endOffset": 16}], "year": 2013, "abstractText": "Computer Science today lacks a unified view of Computing. Instead, the main subareas, most notably artificial intelligence, database systems and programming languages, offer different and often competing approaches to knowledge representation, problem-solving and computation. In this paper we propose a unifying logic-based, framework for Computing, inspired by artificial intelligence, but scaled down for practical database and programming applications. Computation in the framework is viewed as the task of generating a sequence of state transitions, with the purpose of making an agent\u2019s goals all true. States are represented by sets of atomic sentences (or facts), representing the values of program variables, tuples in a coordination language, facts in relational databases, or Herbrand models. In the model-theoretic semantics, the entire sequence of states and events are combined into a single model-theoretic structure, by associating time stamps with facts. But in the operational semantics, facts are updated destructively, without time stamps. We show that the model generated by destructive updates is identical to the model generated by reasoning with facts containing time stamps. We also extend the model with intentional predicates and composite event predicates defined by logic programs containing conditions in first-order logic (FOL). We extend the notions of local stratification and weak stratification to generate the associated model.", "creator": "Microsoft\u00ae Office Word 2007"}}}