{"id": "1303.2975", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Mar-2013", "title": "Towards Automated Proof Strategy Generalisation", "abstract": "The ability to automatically generalise (interactive) proofs and use such generalisations to discharge related conjectures is a very hard problem which remains unsolved. Here, we develop a notion of goal types to capture key properties of goals, which enables abstractions over the specific order and number of sub-goals arising when composing tactics. We show that the goal types form a lattice, and utilise this property in the techniques we develop to automatically generalise proof strategies in order to reuse it for proofs of related conjectures. We illustrate our approach with an example.", "histories": [["v1", "Tue, 12 Mar 2013 18:18:33 GMT  (1826kb,D)", "https://arxiv.org/abs/1303.2975v1", null], ["v2", "Sun, 9 Jun 2013 15:39:10 GMT  (2379kb,D)", "http://arxiv.org/abs/1303.2975v2", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["gudmund grov", "ewen maclean"], "accepted": false, "id": "1303.2975"}, "pdf": {"name": "1303.2975.pdf", "metadata": {"source": "CRF", "title": "Towards Automated Proof Strategy Generalisation", "authors": ["Gudmund Grov", "Ewen Maclean"], "emails": ["G.Grov@hw.ac.uk", "E.Maclean@ed.ac.uk"], "sections": [{"heading": "1 Introduction", "text": "\"If we focus on a subset of separation logic based on reason, we will use the same evidence strategy many times - albeit with small variations.\" (An experienced user / developer of a theorem proof system would often implement common evidence patterns as a so-called tactic and use them to automatically discharge \"similar\" conjectures. (However, other users often have to prove each conjecture manually.) Our ultimate goal is to automate the process of generalizing a proof (possibly a few proofs) into a sufficiently generic evidence strategy capable of proving \"similar\" concepts. \"In this paper, we take a small step toward this goal by developing an appropriate representation with necessary strong formal properties and giving two generic methods that use this representation to produce a proof.While the manual repetition of similar proofs via various formal methods, for example Event B, and VDM [we will focus on a subset of reason], the manual repetition of similar proofs via various formal methods, will become a subset of [see DM]."}, {"heading": "2 Background on the Proof Strategy Language", "text": "The graphical evidence tactic was introduced in [10], which builds on the mathematical formalism of string diagrams [6]. < A string diagram consists of boxes and wires where the wires are used to connect the boxes. Both boxes and wires can contain data, and data at the edges provide a type-safe mechanism to compose two diagrams. Crucially, string diagrams [10] are labeled with target types that allow tactical edges to be developed in the next section. A box is either a tactic or a list of targets, and if an edge is not a target, then it is the output of the diagram. In a proof strategy diagram [10], the wires are labeled with target types that will be developed in the next section."}, {"heading": "3 Towards a Theory of Goal Types", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Classes", "text": "\"(...). (.). (.). (.). (.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). (.). (.). (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).).\" (.). \"(.).\" (.). \"(.).).\" (.). \"(.).\" (.). \"(.).\" (.). \"(.).).\" (.).). \"(.\" (.). \"(.).). (.).). (.). (.). (.). (.).). (.\" (.).). (.). (.).). (.).). (.).). (.). (.). (.).). (.). (.).). (.).). (.).).). (.). (.). (.).). (.).).). (.). (.). (.).). (.).). (.).).). (.)."}, {"heading": "3.2 Links", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "3.3 Goal Types", "text": "A target type is a description of the conclusion, the related facts and the connections between them: Definition 10. A target type is a data set: Target type: = {link: link, facts: {class}, concl: class}, where concl is the class describing the conclusion of a goal, facts is a group of relevant facts, and link is a link between facts and concl.Note that we maintain a series of fact classes to account for the existence of several classes of hypotheses. In our example, hypothesis is a class P (with a pure top symbol), while h is a class H (with symbols). < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "4 Lifting of Goals and Tactics", "text": "\"We will briefly outline here how the evaluation is achieved with the target type, where we assume that we vary.\" First, we must remember that a single evaluation step is achieved by a tactic by applying the input of targets on the input and evaluation sketch to the respective target sketch. (Since a target node contains a list of targets, this can be captured by a meta-graphic paraphrase rule, which is presented in Figure 4.) The details are given in [10], but one evaluation step works as follows: 1. Game and partially instantiates the LHS of the meta rule.2. Evaluation of the tactical function for matching input and output types.3. Finish instantiating the RHS with the lists gsi from the tactic. 4. Application of the fully instantiated rule (s).1 \u03b22 \u03b2n... t\u03b22 \u03b2n... t2\u03b22 \u03b21 \u03b21 \u03b21 \u03b2n."}, {"heading": "5 Generalising Strategies", "text": "Evidence is generalized into a strategy by first collecting the evidence tree into a proof strategy graph and then applying graph transformation techniques that use the target type grid to generalize target types. Simple generalizations of tactics are also used. An important characteristic in carrying out such generalizations is that all valid evidence for a strategy should be valid even after what we informally justify below."}, {"heading": "5.1 Deriving Goal Types from Proof States", "text": "In this section, we will discuss how to generalize the evidence shown in Figure 1 into the mutation strategy shown in Figure 2, using the grid structure of the gate types. However, since the form is the same, we will first reduce the evidence tree of Figure 1 into a low-threshold evidence strategigraph of the same form. (1) To generalize the evidence state in target type, we have chosen an approach that can be considered a \"locally maximum\" derivation of the gate type, whereby each assumption becomes a separate class and makes each class as specific as possible. Consequently, the target type is filtered as far as possible along the grid, while there is the possibility of collecting the target type [locally maximum \"derivation of the gate type], with each assumption becoming a separate class and each linkage being as specific as possible."}, {"heading": "5.2 Generalising Tactics", "text": "Next, we need to generalize tactics: A simple example of this is when rule sets are used as arguments for the subst and rule tactics. Here, subst R1 and subst R2 can be generalized to subst (R1 and R2). Another example turns a tactic into a graph tactic that nests both tactics (and can be applied to both). A prerequisite for both is that their input and output target types can be generalized. Both generalizations only increase the search space and are therefore correct generalizations. Graph tactics can also be generalized by generalizing the graph they nest. We will return to this with an example below. We will use the notation gene (t1, t2) for generalizing the two given tactics."}, {"heading": "5.3 Generalising Goal Types", "text": "In the context of target types: generalization refers to the calculation of the most general target type for two existing target types; while the weakening applies only to one target type, making the description of that type more general. Crucial to generalization and weakening is that several possible generalized and weakened target types exist. We use the term of a minimum upper limit for a target type grid, described in \u00a7 3 using the join operator to define the generalization for target types. For a class C, we write: Definition 12. C is a generalization of C1 and C2, also written C = gene (C1, C2), if the generalization f = C (f) = C1 (f).Consider, for example, the two classes shown in (4) and (5). We can calculate G = gene (C1, C2) by referring back to the established theoretical semantics and the transition to class representation."}, {"heading": "5.4 (Re-)Discovering the Mutation Strategy", "text": "We can deal with the techniques for generalizing the edges and nodes of a chain of evidence, we are now developing two techniques that allow us to generate our evidence into the required mutation strategy. First, we need to abstract from the number of repeated sequential applications of the same tactic - i.e., we need to discover loops. If we are working in a standard LCF tactic, the problem is to know (a) which targets (in the case of side conditions) the tactic should be repeated, and (b) when to stop where a regular expression language closely related to common LCF tactics has been used to learn evidence tactics, and hand-crafted heuristic istististics have been defined to stop a loop (which would fail by the way of our example).The advantage of our approach is that we can use target types to identify termination conditions - and reduce the focus to the same case."}, {"heading": "6 Related Work", "text": "We expand [10], which introduces the underlying strategy language, by developing a theory for target types that we use as grids, and use this property to develop techniques for generalizing strategies. Our target types can be seen as a lightweight implementation of pre- / follow-up strategies used in correction planning [4] - with the additional property that language captures the flow of goals. They can be seen as further extending the marriage of procedural and explanatory approaches to evidence strategies [2, 13, 8] and as addressing techniques that are highlighted in terms of target flow and target focus [1] - for a more detailed comparison to which we refer [10]. The grid techniques developed for target type generalization are comparable to antiunification [22], which generalizes two terms into one (with substitutions back to the original terms), while each has multiple dimensions."}, {"heading": "7 Conclusion and Future Work", "text": "In this paper, we have reported on our initial results in creating a technique to generalize the evidence into high-grade evidence strategies that can be used to automatically discharge similar conjectures; this paper contains two contributions: (1) the introduction of the target type to describe the properties of targets using a grid structure to allow generalizations; (2) two generic techniques based on the discovery of loops to generalize a proof strategy; and the techniques were motivated and illustrated by an example from separation logic. We are in the process of implementation in Isabelle in combination with the quantomatic diagram machine [16]; the next plan to implement these methods to test them on more examples uses a larger set of properties to represent the target types; in particular, we are interested in less syntactical properties, such as the origin of a target, or if it is in a decideable sublogic."}, {"heading": "Acknowledgements", "text": "This work was supported by EPSRC grants: EP / H023852, EP / H024204 and EP / J001058. We would like to thank Alan Bundy, Aleks Kissinger, Lucas Dixon, members of the AI4FM project, Katya Komendantskaya, Jonathan Heras and Colin Farquhar for feedback and discussion."}], "references": [{"title": "A new type for tactics", "author": ["A. Asperti", "W. Ricciotti", "C. Sacerdoti", "C. Tassi"], "venue": "PLMMS\u201909, pages 229\u2013232", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2009}, {"title": "A tactic language for declarative proofs", "author": ["Serge Autexier", "Dominik Dietrich"], "venue": "In ITP\u201910,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "Graph abstraction and abstract graph transformation", "author": ["I.B. Boneva", "A. Rensink", "M.E. Kurban", "J. Bauer"], "venue": "Technical Report TR-CTI,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2007}, {"title": "The use of explicit plans to guide inductive proofs", "author": ["A. Bundy"], "venue": "R. Lusk and R. Overbeek, editors, CADE9, pages 111\u2013120. Springer-Verlag", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1988}, {"title": "Learning from experts to aid the automation of proof search", "author": ["A. Bundy", "G. Grov", "C.B. Jones"], "venue": "PreProc of AVoCS\u201909, pages 229\u2013232", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Open graphs and monoidal theories", "author": ["Lucas Dixon", "Aleks Kissinger"], "venue": "CoRR, abs/1011.4114,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "The use of Data-Mining for the Automatic Formation of Tactics", "author": ["Hazel Duncan"], "venue": "PhD thesis, University of Edinburgh,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "MMode, a mizar mode for the proof assistant coq", "author": ["M. Giero", "F. Wiedijk", "Mariusz Giero"], "venue": "Technical report, January", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2004}, {"title": "Edinburgh LCF, volume", "author": ["Michael J.C. Gordon", "Robin Milner", "Christopher P. Wadsworth"], "venue": "Lecture Notes in Computer Science. Springer,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1979}, {"title": "Hume box calculus: robust system development through software transformation", "author": ["G. Grov", "G. Michaelson"], "venue": "HOSC, 23:191\u2013226", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "A mizar mode for HOL", "author": ["John Harrison"], "venue": "In TPHOLs, volume 1125 of LNCS,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1996}, {"title": "Learning Method Outlines in Proof Planning", "author": ["M. Jamnik", "M. Kerber", "C. E Benzmuller"], "venue": "Technical Report CSRP-01-8, University of Birmingham (CS)", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2001}, {"title": "Theorem reuse by proof term transformation", "author": ["E.B. Johnsen", "C. L\u00fcth"], "venue": "TPHOLs 2004, volume 3223 of LNCS, pages 152\u2013167. Springer", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2004}, {"title": "and B", "author": ["A. Kissinger", "A. Merry", "L. Dixon", "R. Duncan", "M. Soloviev"], "venue": "Frot. Quantomatic", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Machine learning in proof general: Interfacing interfaces", "author": ["E. Komendantskaya", "J. Heras", "G. Grov"], "venue": "CoRR, abs/1212.3618", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "Restricted higher-order anti-unification for analogy making", "author": ["U. Krumnack", "A. Schwering", "H. Gust", "K-U K\u00fchnberger"], "venue": "AJAI 2007, volume 4830 of LNAI, pages 273\u2013282. Springer", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "Mutation in linked data structures", "author": ["Ewen Maclean", "Andrew Ireland"], "venue": "In ICFEM, volume 6991 of LNCS,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}, {"title": "Formalizing refactorings with graph transformations", "author": ["T. Mens", "N. Van Eetvelde", "S. Demeyer", "D. Janssens"], "venue": "Journal of Software Maintenance, 17(4):247\u2013276", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "A note on inductive generalization", "author": ["G.D. Plotkin"], "venue": "Machine Intelligence 5, pages 153\u2013163, Edinburgh", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1969}, {"title": "Separation logic: A logic for shared mutable data structures", "author": ["J.C. Reynolds"], "venue": "Logic in Computer Science, pages 55\u201374. IEEE Computer Society", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2002}, {"title": "Semantic graph kernels for automated reasoning", "author": ["E. Tsivtsivadze", "J. Urban", "H. Geuvers", "T. Heskes"], "venue": "Proc. 11th SIAM Int. Conf. on Data Mining, pages 795\u2013803. SIAM / Omnipress", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}, {"title": "Inferring the proof process", "author": ["Andrius Velykis"], "venue": "In Christine Choppy, David Delayahe, and Ka\u0131\u0308s Kla\u0131\u0308, editors,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "Towards formal proof script refactoring", "author": ["I. Whiteside", "D. Aspinall", "L. Dixon", "G. Grov"], "venue": "CICM\u201911, volume 6824 of LNCS, pages 260\u2013275. Springer", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 4, "context": "Whilst the manual repetition of similar proofs have been observed across different formal methods, for example Event-B, B and VDM (see [5]), we will focus on a subset of separation logic [23], used to reason about pointer-based programs1.", "startOffset": 135, "endOffset": 138}, {"referenceID": 19, "context": "Whilst the manual repetition of similar proofs have been observed across different formal methods, for example Event-B, B and VDM (see [5]), we will focus on a subset of separation logic [23], used to reason about pointer-based programs1.", "startOffset": 187, "endOffset": 191}, {"referenceID": 16, "context": "In fact, the proofs can be described as simple version of the the mutation proof strategy developed to reason about functional properties in separation logic [19].", "startOffset": 158, "endOffset": 162}, {"referenceID": 5, "context": "The graphical proof strategy language was introduced in [10] built upon the mathematical formalism of string diagrams [6].", "startOffset": 118, "endOffset": 121}, {"referenceID": 21, "context": "We utilise techniques described in [25] to get the initial proof tree.", "startOffset": 35, "endOffset": 39}, {"referenceID": 8, "context": "When working in a standard LCF tactic language [9], the problem is to know: (a) on which goals (in the case of side conditions) the tactic should be repeated, and (b) when to stop.", "startOffset": 47, "endOffset": 50}, {"referenceID": 6, "context": "This was highlighted in [7], where a regular expression language, closely aligned with common LCF tacticals, was used to learn proof tactics, and hand-crafted heuristics were defined to state when to stop a loop (which by the way would fail for our example).", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": "GT 1(link) = GT 2n(link) = {(symb at pos,G,H) 7\u2192 [[\u22a5]]} GT 3(link) = {(symb at pos,G,H) 7\u2192 [[1]]}", "startOffset": 92, "endOffset": 95}, {"referenceID": 5, "context": "Now, as shown in [6], in the category of string graphs, two graphs are composed by a push-out over a common boundary.", "startOffset": 17, "endOffset": 20}, {"referenceID": 3, "context": "Our goal types can be seen as a lightweight implementation of pre/post-condition used in proof planning [4] \u2013 with the additional property that the language captures the flow of goals.", "startOffset": 104, "endOffset": 107}, {"referenceID": 1, "context": "It can be seen as further extending the marriage of procedural and declarative approaches to proof strategies [2, 13, 8], and addressing issues related to goal flow and goal focus highlighted in [1] \u2013 for a more detailed comparison we refer to [10].", "startOffset": 110, "endOffset": 120}, {"referenceID": 10, "context": "It can be seen as further extending the marriage of procedural and declarative approaches to proof strategies [2, 13, 8], and addressing issues related to goal flow and goal focus highlighted in [1] \u2013 for a more detailed comparison we refer to [10].", "startOffset": 110, "endOffset": 120}, {"referenceID": 7, "context": "It can be seen as further extending the marriage of procedural and declarative approaches to proof strategies [2, 13, 8], and addressing issues related to goal flow and goal focus highlighted in [1] \u2013 for a more detailed comparison we refer to [10].", "startOffset": 110, "endOffset": 120}, {"referenceID": 0, "context": "It can be seen as further extending the marriage of procedural and declarative approaches to proof strategies [2, 13, 8], and addressing issues related to goal flow and goal focus highlighted in [1] \u2013 for a more detailed comparison we refer to [10].", "startOffset": 195, "endOffset": 198}, {"referenceID": 18, "context": "The lattice based techniques developed for goal type generalisation is similar to antiunification [22] which generalises two terms into one (with substitutions back to the original terms).", "startOffset": 98, "endOffset": 102}, {"referenceID": 15, "context": "More expressive class/link features, which is future work, may require higher-order anti-unification [18] \u2013 and such ideas may also be applicable to graph generalisations.", "startOffset": 101, "endOffset": 105}, {"referenceID": 2, "context": "Other work that may become relevant for our techniques are graph abstractions/transformations used in algorithmic heap-based program verification techniques, such as [3], and for parallelisation of functional programs [12].", "startOffset": 166, "endOffset": 169}, {"referenceID": 9, "context": "Other work that may become relevant for our techniques are graph abstractions/transformations used in algorithmic heap-based program verification techniques, such as [3], and for parallelisation of functional programs [12].", "startOffset": 218, "endOffset": 222}, {"referenceID": 6, "context": "This is the case for [7], which uses a regular expression language (close to LCF tactics), originally developed in [14] to learn proof plans.", "startOffset": 21, "endOffset": 24}, {"referenceID": 11, "context": "This is the case for [7], which uses a regular expression language (close to LCF tactics), originally developed in [14] to learn proof plans.", "startOffset": 115, "endOffset": 119}, {"referenceID": 11, "context": "[14] further claims that explanation based generalisation (EBG)[21] is applied to derive pre/post-conditions, but no details of this are provided.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "An EBG approach is also applied to generalise Isabelle proof terms into more generic theorems in [15].", "startOffset": 97, "endOffset": 101}, {"referenceID": 20, "context": "Further, note that our work focuses on proof of conjectures which requires structure, meaning machine learning techniques \u2013 such as [24], which learns heuristics to select relevant axioms/rules for automated provers \u2013 are not sufficient.", "startOffset": 132, "endOffset": 136}, {"referenceID": 14, "context": "However, in [11], an approach to combine essentially our techniques, with more probabilistic techniques to cluster interactive proofs [17], was outlined.", "startOffset": 134, "endOffset": 138}, {"referenceID": 22, "context": "We would also like to utilise work on proof and proof script refactoring [26].", "startOffset": 73, "endOffset": 77}, {"referenceID": 17, "context": "Finally, albeit for source code, [20] argues for the use of graphs to perform refactorings, which further justifies our graph based representation of proof strategies for the work presented here.", "startOffset": 33, "endOffset": 37}, {"referenceID": 13, "context": "We are in the process of implementation in Isabelle combined with the Quantomatic graph rewriting engine [16].", "startOffset": 105, "endOffset": 109}, {"referenceID": 21, "context": "org) we are working on utilising their work on capturing the full proof process, where the user may (interactively) highlight the key features of a proof (step) [25].", "startOffset": 161, "endOffset": 165}], "year": 2017, "abstractText": "The ability to automatically generalise (interactive) proofs and use such generalisations to discharge related conjectures is a very hard problem which remains unsolved; this paper shows how we hope to make a start on solving this problem. We develop a notion of goal types to capture key properties of goals, which enables abstractions over the specific order and number of sub-goals arising when composing tactics. We show that the goal types form a lattice, and utilise this property in the techniques we develop to automatically generalise proof strategies in order to reuse it for proofs of related conjectures. We illustrate our approach with an example.", "creator": "LaTeX with hyperref package"}}}