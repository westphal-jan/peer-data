{"id": "1303.5735", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Mar-2013", "title": "Non-monotonic Negation in Probabilistic Deductive Databases", "abstract": "In this paper we study the uses and the semantics of non-monotonic negation in probabilistic deductive data bases. Based on the stable semantics for classical logic programming, we introduce the notion of stable formula, functions. We show that stable formula, functions are minimal fixpoints of operators associated with probabilistic deductive databases with negation. Furthermore, since a. probabilistic deductive database may not necessarily have a stable formula function, we provide a stable class semantics for such databases. Finally, we demonstrate that the proposed semantics can handle default reasoning naturally in the context of probabilistic deduction.", "histories": [["v1", "Wed, 20 Mar 2013 15:32:08 GMT  (1065kb)", "http://arxiv.org/abs/1303.5735v1", "Appears in Proceedings of the Seventh Conference on Uncertainty in Artificial Intelligence (UAI1991)"]], "COMMENTS": "Appears in Proceedings of the Seventh Conference on Uncertainty in Artificial Intelligence (UAI1991)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["raymond t ng", "v s subrahmanian"], "accepted": false, "id": "1303.5735"}, "pdf": {"name": "1303.5735.pdf", "metadata": {"source": "CRF", "title": "Non-monotonic Negation in Probabilistic Deductive Databases", "authors": ["Raymond T. Ng"], "emails": [], "sections": [{"heading": null, "text": "n; < < < < < < < < < < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}], "references": [{"title": "Representing and Reasoning with Probabilistic Knowledge, Research Report CS-88-31", "author": ["F. Bacchus"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1988}, {"title": "Sta\u00ad ble and Extension Class Theor\u00b7y for Logic Pro-  256 Ng and Subrahmanian grams and Default Logics, to appear in: .Journal of Automated Reasoning", "author": ["C. Baral", "V.S. Subrahmanian"], "venue": "Prelim inar y version in: Proc. 1990 Inti. Workshop on Non-Monotonic Reasoning,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1990}, {"title": "Pamconsistcnt Logic Progmmming, Theoretical Computer Science, G8, pp :3:)-!i1", "author": ["V.S.H.A. Blair"], "venue": "Snhrahmanian", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1987}, {"title": "Modelling Default and Like\u00ad lihood Reasoning as l'mbab'l istic, Technical Re\u00ad port FIA-D0-09-11-01, NASA Ames Research CentN", "author": ["W. Buntine"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1990}, {"title": "Hi/altius and the Seman\u00ad tics of Logic Programming, l.o appear in: .Journal of Logic Progranuning", "author": ["M.C. F itting"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1988}], "referenceMentions": [{"referenceID": 0, "context": "Definition 1 An annotation function f of arity n IS a total function of type ( [0, 1])\"--+ [0, 1].", "startOffset": 79, "endOffset": 85}, {"referenceID": 0, "context": "Definition 1 An annotation function f of arity n IS a total function of type ( [0, 1])\"--+ [0, 1].", "startOffset": 91, "endOffset": 97}, {"referenceID": 0, "context": "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A \ufffd(abn(X) : [l, 1])", "startOffset": 7, "endOffset": 13}, {"referenceID": 0, "context": "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A \ufffd(abn(X) : [l, 1])", "startOffset": 7, "endOffset": 13}, {"referenceID": 0, "context": "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A \ufffd(abn(X) : [l, 1])", "startOffset": 27, "endOffset": 33}, {"referenceID": 0, "context": "fido): [1, 1] dog(brnjy) : [1, 1] lmrk(brnjy) : [0, 0] alm(X): [1, l ] doy(X): [1, l] A \ufffd(abn(X) : [l, 1])", "startOffset": 27, "endOffset": 33}, {"referenceID": 0, "context": "'i'p(h)(A) = Sp(h)(B) = [1, 1] .", "startOffset": 24, "endOffset": 30}, {"referenceID": 0, "context": "'i'p(h)(A) = Sp(h)(B) = [1, 1] .", "startOffset": 24, "endOffset": 30}, {"referenceID": 0, "context": "By regarding [ 1, 1] as trne and [0, 0] a.", "startOffset": 13, "endOffset": 20}, {"referenceID": 0, "context": "By regarding [ 1, 1] as trne and [0, 0] a.", "startOffset": 13, "endOffset": 20}, {"referenceID": 0, "context": "function h such that \\f F' E bf(BL ), h(F') = 0, and the j_ element is the one such that IfF' E bf(BL), h(F) = [0, 1].", "startOffset": 111, "endOffset": 117}, {"referenceID": 0, "context": "Suppose h1 is a formula function that assigns [0, 1] to q, and h2 is one that assigns [0.", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "1 and h2 assign [0,1] to all other basic formulas.", "startOffset": 16, "endOffset": 21}, {"referenceID": 0, "context": "o p, wbik 1;,(h2) assigns [0,1] to p .", "startOffset": 26, "endOffset": 31}, {"referenceID": 0, "context": "%, I] and hJ(q) = [0, 1], the ff-t.", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "\ufffd15, 1] top and [0,1] to q.", "startOffset": 16, "endOffset": 21}, {"referenceID": 0, "context": "o bark(bcnjy), [1,1] to abn(benj,q), [0.", "startOffset": 15, "endOffset": 20}, {"referenceID": 0, "context": "o bark(bcnjy), [1,1] to abn(benj,q), [0.", "startOffset": 15, "endOffset": 20}, {"referenceID": 0, "context": "dog(fido) : [1, 1] doy(benjy) : [!, 1]", "startOffset": 12, "endOffset": 18}, {"referenceID": 0, "context": "dog(fido) : [1, 1] doy(benjy) : [!, 1]", "startOffset": 12, "endOffset": 18}, {"referenceID": 0, "context": "95,1] and ht(q) = [0,1], and ii) h2 such that h2(p) = [0, 1] and h2(q) = [0.", "startOffset": 18, "endOffset": 23}, {"referenceID": 0, "context": "95,1] and ht(q) = [0,1], and ii) h2 such that h2(p) = [0, 1] and h2(q) = [0.", "startOffset": 54, "endOffset": 60}, {"referenceID": 0, "context": "1] top and [1,1] to q is a minim al fixpoint of7\ufffd .", "startOffset": 11, "endOffset": 16}, {"referenceID": 0, "context": "1] top and [1,1] to q is a minim al fixpoint of7\ufffd .", "startOffset": 11, "endOffset": 16}, {"referenceID": 1, "context": "In [2] Baral and Subrahmanian propose a st.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "See [2] for more details on stable class theory.", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "5, 1] and h2(p) = [0, 1].", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "p: [1, 1] ,__ a : [1, 1]", "startOffset": 3, "endOffset": 9}, {"referenceID": 0, "context": "p: [1, 1] ,__ a : [1, 1]", "startOffset": 3, "endOffset": 9}, {"referenceID": 0, "context": "p: [1, 1] ,__ a : [1, 1]", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "p: [1, 1] ,__ a : [1, 1]", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "p: [1, 1] ,__ b : [1, 1]", "startOffset": 3, "endOffset": 9}, {"referenceID": 0, "context": "p: [1, 1] ,__ b : [1, 1]", "startOffset": 3, "endOffset": 9}, {"referenceID": 0, "context": "p: [1, 1] ,__ b : [1, 1]", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "p: [1, 1] ,__ b : [1, 1]", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 4, "endOffset": 10}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 4, "endOffset": 10}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 20, "endOffset": 26}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 20, "endOffset": 26}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 32, "endOffset": 39}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 32, "endOffset": 39}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "a : [1, 1] ,__ \u00b7(b: [1, 1]) b : [ 1, 1] \u2022(a : [1, 1]).", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.", "startOffset": 67, "endOffset": 73}, {"referenceID": 0, "context": "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.", "startOffset": 67, "endOffset": 73}, {"referenceID": 0, "context": "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.", "startOffset": 115, "endOffset": 121}, {"referenceID": 0, "context": "This program has two stable formula functions: i) h 1 that assigns [1, 1] to both p and a, and ii) h2 that assigns [1, 1] to both p and b.", "startOffset": 115, "endOffset": 121}, {"referenceID": 0, "context": "Furthermore, suppose h3 is the function that assigns [1, 1] to all of p, a, b a.", "startOffset": 53, "endOffset": 59}, {"referenceID": 0, "context": "Furthermore, suppose h3 is the function that assigns [1, 1] to all of p, a, b a.", "startOffset": 53, "endOffset": 59}, {"referenceID": 0, "context": "nd h4 is the function that assigns [0, 1] to all of p, a, b.", "startOffset": 35, "endOffset": 41}, {"referenceID": 0, "context": "Hence, the Smyth\u00ad minimal stable class semantics assigns [1, 1] top.", "startOffset": 57, "endOffset": 63}, {"referenceID": 0, "context": "Hence, the Smyth\u00ad minimal stable class semantics assigns [1, 1] top.", "startOffset": 57, "endOffset": 63}, {"referenceID": 0, "context": "This Hoare-minimal class only allows us to conclude that p gets the value [0, 1].", "startOffset": 74, "endOffset": 80}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 8, "endOffset": 14}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 8, "endOffset": 14}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 29, "endOffset": 35}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 29, "endOffset": 35}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "abn(X): [1, 1] dropout( X) : [1, 1] adult(X): [1, 1] A \u2022(abn(X) :[I, 1]) dl\u00b7opout(X): [I, 1].", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "Suppos\ufffd initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.", "startOffset": 54, "endOffset": 60}, {"referenceID": 0, "context": "Suppos\ufffd initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.", "startOffset": 54, "endOffset": 60}, {"referenceID": 0, "context": "Suppos\ufffd initially ?1 contains the fact: adult(john) : [1, 1] ,_ _ Then it is easy to check that the only stable formula function with respect to ?1 assigns the range [0,95,1] to employed(john) correctly.", "startOffset": 166, "endOffset": 174}, {"referenceID": 0, "context": "Suppose d1\u00b7opmtt(john): [1, 1] ;- is added to ?1.", "startOffset": 24, "endOffset": 30}, {"referenceID": 0, "context": "Suppose d1\u00b7opmtt(john): [1, 1] ;- is added to ?1.", "startOffset": 24, "endOffset": 30}, {"referenceID": 0, "context": "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).", "startOffset": 45, "endOffset": 51}, {"referenceID": 0, "context": "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).", "startOffset": 45, "endOffset": 51}, {"referenceID": 0, "context": "Consider the formula function h that assigns [1 ,1] to adult(john), dropout(jolm) and alm(john), but [0,1] to employed(john).", "startOffset": 101, "endOffset": 106}, {"referenceID": 0, "context": "The unique stable formula function with respect to ?3 is the> one that assigns: [1,1] to dropout(john) and abn(john), [O.", "startOffset": 80, "endOffset": 85}, {"referenceID": 0, "context": "The unique stable formula function with respect to ?3 is the> one that assigns: [1,1] to dropout(john) and abn(john), [O.", "startOffset": 80, "endOffset": 85}, {"referenceID": 0, "context": "DG,l] to adult(john), and [0,1] to cmployrd(john).", "startOffset": 26, "endOffset": 31}, {"referenceID": 0, "context": "bird( X): [1, 1] aim Bini( X): [1, 1] <\u00ad fwnyu.", "startOffset": 10, "endOffset": 16}, {"referenceID": 0, "context": "bird( X): [1, 1] aim Bini( X): [1, 1] <\u00ad fwnyu.", "startOffset": 10, "endOffset": 16}, {"referenceID": 0, "context": "bird( X): [1, 1] aim Bini( X): [1, 1] <\u00ad fwnyu.", "startOffset": 31, "endOffset": 37}, {"referenceID": 0, "context": "bird( X): [1, 1] aim Bini( X): [1, 1] <\u00ad fwnyu.", "startOffset": 31, "endOffset": 37}, {"referenceID": 0, "context": "dy): [1, 1] bh\u00b7d(X) : (1, I] A", "startOffset": 5, "endOffset": 11}, {"referenceID": 0, "context": "dy): [1, 1] bh\u00b7d(X) : (1, I] A", "startOffset": 5, "endOffset": 11}, {"referenceID": 0, "context": "\u2022(abnBh\u00b7d(X): [1, 1])", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "\u2022(abnBh\u00b7d(X): [1, 1])", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "pengnin(X): [1, 1]A", "startOffset": 12, "endOffset": 18}, {"referenceID": 0, "context": "pengnin(X): [1, 1]A", "startOffset": 12, "endOffset": 18}, {"referenceID": 0, "context": "\u2022(abnPcny(X): [1, 1])", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "\u2022(abnPcny(X): [1, 1])", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "pengui11(X) : [1, 1]", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "pengui11(X) : [1, 1]", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "Consider the formula function h that assigns: [1, 1] to pcngnin(twcety), bird(tweety) and abnBird(tweety), [O,O.", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "Consider the formula function h that assigns: [1, 1] to pcngnin(twcety), bird(tweety) and abnBird(tweety), [O,O.", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "OGJ to fly(lwccty), and [0,1] to abnPeng(twcety).", "startOffset": 24, "endOffset": 29}, {"referenceID": 3, "context": "But our framework is not as expressive as the probabilistic frameworks proposed by Bacchus[! J and Buntine[4].", "startOffset": 106, "endOffset": 109}, {"referenceID": 2, "context": "These include the works by Blair and Subrahmanian [3], Fitting [D], Kifer et al [13, .", "startOffset": 50, "endOffset": 53}, {"referenceID": 0, "context": "On the other hand, the integration of logic and probability theory has been the subject of numerous studies [1, 5, 7, 8, 15, 22, 19].", "startOffset": 108, "endOffset": 132}], "year": 2011, "abstractText": "In this paper we study tlw uses and the se\u00ad mantics of non-monotonic negation in prob\u00ad abilistic deductive databases. Based on the stahl<semantics for classical logic program\u00ad ming, we in I roduce the notion of stable for\u00ad mula functions. We show that. stable for\u00ad mula functions are minimal fixpoints of op\u00ad erators associated with probabilistic dednc1 ive databases with negation. Furthermore, since a probabilistic deductive database may not n<xcssarily have a stable formula func\u00ad tion, we provick a stable class semantics for such databases. Finally, we demonstrate that tlu' proposed semantics can handle default reasoning naturally in tlw contc>xt of prob\u00ad abilist ic deduction.", "creator": "pdftk 1.41 - www.pdftk.com"}}}