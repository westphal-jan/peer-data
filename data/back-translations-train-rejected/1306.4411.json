{"id": "1306.4411", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Jun-2013", "title": "Event-Object Reasoning with Curated Knowledge Bases: Deriving Missing Information", "abstract": "The broader goal of our research is to formulate answers to why and how questions with respect to knowledge bases, such as AURA. One issue we face when reasoning with many available knowledge bases is that at times needed information is missing. Examples of this include partially missing information about next sub-event, first sub-event, last sub-event, result of an event, input to an event, destination of an event, and raw material involved in an event. In many cases one can recover part of the missing knowledge through reasoning. In this paper we give a formal definition about how such missing information can be recovered and then give an ASP implementation of it. We then discuss the implication of this with respect to answering why and how questions.", "histories": [["v1", "Wed, 19 Jun 2013 01:58:21 GMT  (1359kb,D)", "https://arxiv.org/abs/1306.4411v1", "13 pages"], ["v2", "Thu, 20 Jun 2013 00:19:24 GMT  (1362kb,D)", "http://arxiv.org/abs/1306.4411v2", "13 pages"]], "COMMENTS": "13 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["chitta baral", "nguyen h vo"], "accepted": false, "id": "1306.4411"}, "pdf": {"name": "1306.4411.pdf", "metadata": {"source": "CRF", "title": "Event-Object Reasoning with Curated Knowledge Bases: Deriving Missing Information", "authors": ["Chitta Baral", "Nguyen H. Vo"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Our work in this paper is part of two related long-term goals: answering \"how,\" \"why\" and \"what-if\" questions and arguing with the growing corpus of available knowledge bases 1, some of which are crowdsourced. Although answering \"how\" and \"why\" questions is important, little research has been done on these questions so far. Our starting point for answering them was to formulate answers to such questions in relation to abstract knowledge structures derived from knowledge bases. [3] Especially, in the recent past, we looked at event description graphs (EDGs) [1] and event description graphs (EODGs) [2] to formulate answers to some \"how\" and \"why\" questions related to the knowledge base biology aura [3]. Starting from the abstract structures to reasoning with real knowledge bases (BBs) noted knowledge bases (BBs), we have often noticed the relationship between two instances of information (such as a BBs)."}, {"heading": "2 Background: Frame-based Knowledge Bases; ASP", "text": "The KB we used in this paper is based on Aura [3] and has been described in detail in [6]. Aura is a frame-based KB that is manually curated by biology experts; it contains a large number of frames that describe biological entities events (or processes). An important aspect of our KB is the class hierarchy. Example 2: Its basic class is Thing, which has two classes of children: Entity and Event. Entity is the ancestor of all classes of biological entities; event, biological events. For example, spatial entity, eukaryote, nucleus, and mRNA are descendants of the entity, while \"eukaryotic translation,\" \"eukaryotic transcription\" are descendants of the event. Our KB is a set of facts of form \"(A, slot name, B) translation,\" where A and B are a translation (of classes)."}, {"heading": "3 Knowledge Description Graphs", "text": "In fact, it is the case that such a case is a case which is a case which is not a case but a case which is a case which is a case but a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which"}, {"heading": "4 Reasoning about Missing Info. in UDGs and KDGs", "text": "In this section we discuss missing information in the UDGs and the KDGs and how to recover some of it by reasoning."}, {"heading": "4.1 Event, Next Event, First Sub-event and Last Sub-event", "text": "You can get event names directly by looking at facts of the form \"(E, example, event)\" in the KB; and concluding E in it as an event. However, some events may lack such facts. In this case, we can deduce the fact from the edges of the UDG and the boundary constraints of the KDGs (Figure 1). More formally: Definition 4. Let E be a node in the UDG (Z). E is an event if there is (i) a participating edge or an ordering edge of E; (ii) a local edge or an ordering edge of E; (ii) a compositional edge (the subevent or first subevent relationship) from / to E; or (iv) a path of class edges from E to the class event. Based on definition 4, we can assume that photosynthesis is an event because it has compositional edges."}, {"heading": "4.2 Input/Output of Events", "text": "Two types of events: In our KB there are two types of events: transport events and operational events. In addition, there is only one change of locations; the input location and output location are different from each other, while the input unit and output unit are the same. All other events are operational events. In an operational event, there is usually no change of location. We have to distinguish two types of events by their ancestor classes; transport events are descendants of the classes going through, in and out. Input, Output, Input Location, Output Location, Output Location: To think about the KDG, we have to distinguish the input and output of each event as well as the input location and output location, which are not always available. Below, we show how to use different event relationships - such as raw material, location and others - to create four new relationships (IO relationships): Input, Output, Input Location and Output Position."}, {"heading": "4.3 Main Class of an Instance", "text": "In our KB, one class can belong to many classes. For example, dna strand19497 - the input of eukaryotic transcription - is an instance of DNA strand, DNA sequence, nucleic acid and polymer 4. However, to think about the equality between in-4, in the previous figures and descriptions we usually refer to the units and events by their \"main class\" (s) and not by the names of the instances, although our KB and our implementation work on the names of the instances. Attitudes: We need the \"main class\" (s), the most specific class (s) of that instance. Our formal definition of \"main class\" is given below. Definition 9. Let E be an instance in KDG (Z). ClassB is a main class of instance E if (1) it is the \"main class\" (s), the most specific class (s) of that instance."}, {"heading": "5 Entity Resolution", "text": "The results are in many cases, (i) two different instance names were used when they are likely to be the same instance; and (ii) parts of a particular biological process were encrypted as independent events. For example: the input of proteins in eukaryotic countries (Figure 2) is mrna4642, whereas the results of Move out is mrna211, the synthesis of RNA in eukaryotic countries and eukaryotic countries should be subevents of protein in eukaryote. In this section we propose methods for solving the first problem. These methods are then used to solve the second problem in the next section."}, {"heading": "6 Finding the Possible Next Events", "text": "This year, it has come to the point that it has never been as far as this year."}, {"heading": "7 ASP Encodings", "text": "In this section we give ASP encodings in the previous sections. Encoding the Entities and Events: Rules t1-t2 in the following states where an instance X is an event or entity if it is the instance of the eventclass or entity class. Rules t3-t4 identify E as an event if there is an ordering edge to E. \"Rule t5 encodes definition 4.iv.\" has (X, ancestorclass, Y) denotes the transitive closure of \"has (M, superclass, N)\" and is encoded the standard way (rules t6-t7). The rest of definition 4 is similar in rules t8-t21.t1: event (X, instance _ of, event)."}, {"heading": "8 Discussion: Answering \u201cHow\u201d and \u201cWhy\u201d Questions", "text": "In Section 4, we showed how to recover missing information using properties of the KDG structure. Completing this information allows us not only to improve the KB used to construct the KDG, but also to think about large curated KB using the KDG. In Sections 5 and 6, we also solved an important step to extract the use of KB from small examples: We proposed methods to compare instances and demonstrated its power in finding possible next events. These efforts have enabled us to answer profound questions such as \"how\" and \"why.\" We give examples of some of them below. Details of how to answer these questions are explained in another paper [2].1. The answer to \"How does X occur?\" is simply a structure that essentially contains KDG (X) and all nodes connected to / by the arrangement of edges. 2. The answer to \"How does X create paths Y?\""}, {"heading": "9 Conclusion", "text": "In this paper, we have shown how to derive certain missing information from large knowledge bases. Often, such knowledge bases are created by multiple people; sometimes even through crowdsourcing. This often results in some information not being explicitly stated, although the Knowledge Base contains pointers to derive this information. In our larger effort to formulate answers to \"why\" and \"how\" questions, we focused on the framework-based Knowledge Base AURA, noted several such omissions, and based on these examples developed several general formulations relating to missing knowledge about events. We also gave an ASP implementation of our formulations and used them in answering \"why\" and \"how\" questions. We discussed some of these question types briefly and how their answer can be derived from Knowledge Description Graphs (KDGs). By being able to obtain missing information and enrich the original KDGs, one can have more precise and intuitive answers to each of our questions based on different ways (but our method is different from ours)."}], "references": [{"title": "Answering why and how questions with respect to a frame-based knowledge base: a preliminary report", "author": ["C. Baral", "N.H. Vo", "S. Liang"], "venue": "Technical Communications of the 28th International Conference on Logic Programming (ICLP\u201912) 17", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Formulating question answering with respect to event-object description graphs", "author": ["C. Baral", "N. Vo"], "venue": "Unpublished paper submitted to a conference", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "AURA: capturing knowledge and answering questions on science textbooks", "author": ["V.K. Chaudhri", "P.E. Clark", "S. Mishra", "J. Pacheco", "A. Spaulding", "J. Tien"], "venue": "Technical report, SRI International", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "Link mining: a survey", "author": ["L. Getoor", "C.P. Diehl"], "venue": "ACM SIGKDD Explorations Newsletter 7(2)", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "A survey of entity resolution and record linkage methodologies", "author": ["D.G. Brizan", "A.U. Tansel"], "venue": "Communications of the IIMA 6(3)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2006}, {"title": "From knowledge represented in frame-based languages to declarative representation and reasoning via ASP", "author": ["C. Baral", "S. Liang"], "venue": "13th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In Kowalski, R., Bowen, K., eds.: Logic Programming: Proc. of the Fifth Int\u2019l Conf. and Symp., MIT Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1988}, {"title": "Knowledge representation, reasoning and declarative problem solving", "author": ["C. Baral"], "venue": "Cambridge University Press", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "KM: The knowledge machine 2.0: Users manual", "author": ["P. Clark", "B. Porter", "B. Works"], "venue": "Citeseer", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Data quality and record linkage techniques", "author": ["T.N. Herzog", "F.J. Scheuren", "W.E. Winkler"], "venue": "Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Data cleaning: Problems and current approaches", "author": ["E. Rahm", "H.H. Do"], "venue": "IEEE Data Engineering Bulletin 23(4)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2000}, {"title": "Conditional dependencies: A principled approach to improving data quality", "author": ["W. Fan", "F. Geerts", "X. Jia"], "venue": "Dataspace: The Final Frontier. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 80, "endOffset": 83}, {"referenceID": 1, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 128, "endOffset": 131}, {"referenceID": 2, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 235, "endOffset": 238}, {"referenceID": 3, "context": "Such finding of non-identical duplicates in the KB and merging them into one is referred in the literature as entity resolution [4, 5].", "startOffset": 128, "endOffset": 134}, {"referenceID": 4, "context": "Such finding of non-identical duplicates in the KB and merging them into one is referred in the literature as entity resolution [4, 5].", "startOffset": 128, "endOffset": 134}, {"referenceID": 2, "context": "The KB we used in this work is based on AURA [3] and was described in details in [6].", "startOffset": 45, "endOffset": 48}, {"referenceID": 5, "context": "The KB we used in this work is based on AURA [3] and was described in details in [6].", "startOffset": 81, "endOffset": 84}, {"referenceID": 6, "context": "For the declarative implementation of our formulations, we use ASP [7].", "startOffset": 67, "endOffset": 70}, {"referenceID": 5, "context": "That allows us to use our earlier work [6] on using ASP to reason with frame-based knowledge bases.", "startOffset": 39, "endOffset": 42}, {"referenceID": 7, "context": "ASP\u2019s strong theoretical foundation [8] and its default negation and recursion are useful in our encoding and in proving results about them.", "startOffset": 36, "endOffset": 39}, {"referenceID": 8, "context": "We used the slot names in KM [9] and AURA as a guide to categorize four types of edges (Table 1).", "startOffset": 29, "endOffset": 32}, {"referenceID": 1, "context": "A Knowledge Description Graph (KDG) (a slight generalization of EODGs in [2]) is constructed from an UDG.", "startOffset": 73, "endOffset": 76}, {"referenceID": 1, "context": "Details about answering them are explained in another work of ours [2].", "startOffset": 67, "endOffset": 70}, {"referenceID": 3, "context": "Our method is different from other methods in the literature [4,5].", "startOffset": 61, "endOffset": 66}, {"referenceID": 4, "context": "Our method is different from other methods in the literature [4,5].", "startOffset": 61, "endOffset": 66}, {"referenceID": 9, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}, {"referenceID": 10, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}, {"referenceID": 11, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}], "year": 2013, "abstractText": "The broader goal of our research is to formulate answers to why and how questions with respect to knowledge bases, such as AURA. One issue we face when reasoning with many available knowledge bases is that at times needed information is missing. Examples of this include partially missing information about next sub-event, first subevent, last sub-event, result of an event, input to an event, destination of an event, and raw material involved in an event. In many cases one can recover part of the missing knowledge through reasoning. In this paper we give a formal definition about how such missing information can be recovered and then give an ASP implementation of it. We then discuss the implication of this with respect to answering why and how questions.", "creator": "LaTeX with hyperref package"}}}