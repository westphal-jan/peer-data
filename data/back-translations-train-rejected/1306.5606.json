{"id": "1306.5606", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Jun-2013", "title": "Proteus: A Hierarchical Portfolio of Solvers and Transformations", "abstract": "In recent years, portfolio approaches to solving SAT problems and CSPs have become increasingly common. There are also a number of different techniques for converting SAT problems into CSPs. In this paper, we leverage advances in both areas and present a novel hierarchical portfolio-based approach to CSP solving that does not rely purely on CSP solvers, but may convert a problem to SAT choosing a conversion technique and the accommodating SAT solver. Our experimental evaluation relies on competition CSP instances and uses eight CSP solvers, three SAT encodings and eighteen SAT solvers. We demonstrate that significant performance improvements can be obtained by considering alternative view-points of a combinatorial problem.", "histories": [["v1", "Mon, 24 Jun 2013 13:11:54 GMT  (188kb,D)", "https://arxiv.org/abs/1306.5606v1", null], ["v2", "Mon, 17 Feb 2014 12:26:45 GMT  (123kb,D)", "http://arxiv.org/abs/1306.5606v2", "11th International Conference on Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems. The final publication is available at link.springer.com"]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["barry hurley", "lars kotthoff", "yuri malitsky", "barry o'sullivan"], "accepted": false, "id": "1306.5606"}, "pdf": {"name": "1306.5606.pdf", "metadata": {"source": "CRF", "title": "Proteus: A Hierarchical Portfolio of Solvers and Transformations", "authors": ["Barry Hurley", "Lars Kotthoff", "Yuri Malitsky", "Barry O\u2019Sullivan"], "emails": ["b.hurley@4c.ucc.ie", "l.kotthoff@4c.ucc.ie", "y.malitsky@4c.ucc.ie", "b.osullivan@4c.ucc.ie"], "sections": [{"heading": "1 Introduction", "text": "This year, it is closer than ever before in the history of the country."}, {"heading": "2 Multiple Encodings and Solvers", "text": "In fact, most of them will be able to feel as if they are able to save themselves."}, {"heading": "3 Background", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 The Constraint Satisfaction Problem", "text": "Constraint Satisfaction Problems (CSP) are a natural means of expressing and thinking about combinatorial problems. They have a large number of practical applications such as planning, vehicle guidance, configuration, network design, routing and wavelength assignment. [26] A case of CSP is represented by a set of variables, each of which can be assigned a value from its area. Assignment to the variables must be consistent with a set of constraints, with each constraint limiting the values that can be assigned to variables. Finding a solution to a CSP is typically done by systematic search based on backtracking. However, since the general problem NP is complete, systematic search algorithms have exponential worst-case runtimes, limiting the scalability of these methods. However, thanks to the development of effective heuristics and a variety of solvers with different strengths and weaknesses, many problems can be efficiently solved in practice."}, {"heading": "3.2 The Satisfiability Problem", "text": "The satisfaction problem (sat) consists of a sentence of Boolean variables and a statement formula about these variables. The task is to decide whether there is a truth association to the variables or not, so that the statement formula is evaluated as true, and, if this is the case, to find this assignment.sat instances are usually expressed in conjunctive normal form (cnf). The representation consists of a combination of clauses (x1, x2, x4), (x2, x3), (x4), a dictionary is either a variable or its negation. Each clause is a logical or its literal and the formula is a logical and each clause. The following sentence is in cnf: (x1, x2, x4), (x2, x3), (x4), This instance consists of four sat variables and the formula is a logical and of each clause. The following phrase is in cnf: (we, x2, x4, we), we, x3, we, x3, we, x3, we, x3, x3, we, x4, we, x4, x4, we, x4, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, we, x4, x4, x4, we, x4, we, x4, x4, we, x4, we, we, x4, x4, x4, we, x4, x4, we, x4, x4, x4, we, x4, x4, x4, x4, x4, we, x4, x4, x4, x4, x4, x4, x4, we, x4, x4, x4, x4, x4, x4, x4, we, x4, x4, x4, x4, x4, x4, x4, x4, x4, x4, x4, x4, x4,"}, {"heading": "3.3 Direct Encoding", "text": "Translating a csp variable X into sat by means of direct encoding [32] >, also known as the sparse encoding, creates a sat variable for each value in its domain: x1, x2,.., xd. If xv applies in the resulting sat formula, then X = v in the csp solution. This means that in order to represent a solution to the csp, we must assign exactly one of x1, x2,..., xd. We add a clause to the sat formula that contains at least one clause for each csp variable as follows: \"X,\" \"X,\" \"X,\" (x1, x2,.). Vice versa, to ensure that only one of these formula can be implicitly set to true, we add at-mostone clauses. For each pair of different values in domain X, we add a binary clause to force that at most one of the two clauses can be effective."}, {"heading": "3.4 Support Encoding", "text": "The support clause [9,18] uses the same mechanism as direct encoding to encode csp domains in sat - each value in the domain of a csp variable is encoded as a sat variable, representing whether it takes this value or not. However, the support encoding differs from how the constraints between variables are encoded. Given a constraint between two variables X and Y for each value v in domain X, let SY, X = v, D (Y) be the subset of values in domain Y that are consistent with the assignment of X = v. Either xv is wrong or one of the consistent assignments of y1.. yd must be true. This is in the support clause xv encoded in domain SY, X = v yi. Conversely, for each value w in the domain of Y, a constraint that consists of a constraint in sp."}, {"heading": "3.5 Order Encoding", "text": "Unlike the direct and supporting encoding, which represents X = v as a SAT variable for each value v (in the range of X), the order encoding (also known as the regular encoding [2]) must generate SAT variables to represent X \u2264 v. If X is smaller or equal to v (referred to as x \u2264 v), X must also be smaller or equal to v + 1 (x \u2264 v + 1). Therefore, we add clauses to enforce this consistency across the domain as follows: (\u00ac x \u2264 v + 1). This linear number of clauses is all that is needed to encode the domain of a CSP variable in the SAT order. In contrast, direct and supporting encodings require a square number of clauses in the domain size. Order encoding is, of course, suitable for modelling inequality constraints."}, {"heading": "3.6 Combining the Direct and Order Encodings", "text": "Direct encoding and order encoding can be combined to create a potentially more compact encoding. A variable's domain is encoded in representations, and clauses are added to the chain between them. This gives flexibility in the representation of any constraint. Here, we select the encoding that yields the most compact formula. For example, for inequalities, we use order encoding, as it is of course appropriate, but for (dis-) equality, we would use direct encoding, which is referred to as direct encoding throughout the paper."}, {"heading": "3.7 Algorithm Portfolios", "text": "The problem of algorithm selection [25] is the selection of the most suitable algorithm for solving a particular problem. It is particularly relevant in the context of algorithm portfolios [11,16], where a single solver is replaced by a series of solvers and a mechanism for selecting a subset to be used for a particular problem. Most approaches are similar in that they relate the properties of a problem to the performance of algorithms in the portfolio. The aim of an algorithm selection model is to predict which algorithm should be used to solve the problem. Most approaches are related to the properties of a problem to be solved."}, {"heading": "4 Experimental Evaluation", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1 Setup", "text": "This year it is more than ever before."}, {"heading": "4.2 Portfolio and Solver Results", "text": "This year it is more than ever before in the history of the city."}, {"heading": "4.3 Greater than the Sum of its Parts", "text": "Given the performance of Proteus, the question remains whether a different portfolio approach that only takes into account csp or only sat solver could perform better. Table 6 summarizes the virtually best performance that such portfolios could achieve. We use all csp and sat solvers for the respective portfolios to give us VB CSP or VB SAT, respectively. The former is the approach that always selects the best csp solver for the current instance, while the latter selects the best sat encoding / solver combination. VB Proteus is the portfolio that selects the best overall approach / encoding. We show the actual performance of Proteus for comparison. Proteus is better than the virtual bests for all portfolios that consider only one encoding. This result makes a very strong point for the need to consider coding and solver in combination. Proteus outperforms four other VB portfolios. Specifically, VB CPhydra is the best possible performance that could be achieved from this portfolio if a perfect choice of solver were taken into account."}, {"heading": "5 Conclusions", "text": "We have presented a portfolio approach that does not rely on a single problem or set of solvers, but uses our ability to convert between problem representations to expand the scope of possible solutions. To our knowledge, this is the first time that a portfolio approach such as this has been proposed. We have shown that it can be beneficial to translate it into a satisfaction problem in order to achieve the best performance on a satisfaction problem. In this translation, it is important to choose both the coding and satisfaction solver in combination, taking advantage of the contrasting performance between the solvers on different representations of the same problem. Overall performance can be significantly improved compared to limiting the portfolio to a single problem representation. We have empirically demonstrated the significant performance improvements that Proteus can achieve on a large number of different benchmarks, with a portfolio based on different representations of the same problem."}], "references": [{"title": "Mapping Problems with Finite-Domain Variables into Problems with Boolean Variables", "author": ["C. Ans\u00f3tegui", "F. Many\u00e0"], "venue": "The 7th International Conference on Theory and Applications of Satisfiability Testing \u2014 SAT\u201904", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2004}, {"title": "Glucose 2.3 in the SAT 2013 Competition", "author": ["G. Audemard", "L. Simon"], "venue": "Proceedings of SAT Competition 2013 p", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Lingeling, Plingeling and Treengeling Entering the SAT Competition 2013", "author": ["A. Biere"], "venue": "Proceedings of SAT Competition 2013", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "Handbook of Satisfiability, Frontiers in Artificial Intelligence and Applications, vol", "author": ["A. Biere", "M.J.H. Heule", "H. van Maaren", "Walsh", "T. (eds."], "venue": "185. IOS Press", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "clasp: A conflict-driven answer set solver", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Logic Programming and Nonmonotonic Reasoning 2007. pp. 260\u2013265. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Arc Consistency in SAT", "author": ["I.P. Gent"], "venue": "Proceedings of the 15th European Conference on Artificial Intelligence \u2014 ECAI\u20192002. pp. 121\u2013125", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2002}, {"title": "Machine learning for constraint solver design \u2013 a case study for the alldifferent constraint", "author": ["I.P. Gent", "L. Kotthoff", "I. Miguel", "P. Nightingale"], "venue": "3rd Workshop on Techniques for implementing Constraint Programming Systems (TRICS). pp. 13\u2013 25", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Algorithm portfolios", "author": ["C.P. Gomes", "B. Selman"], "venue": "Artificial Intelligence 126(1-2), 43\u2013 62", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2001}, {"title": "Restart strategy selection using machine learning techniques", "author": ["S. Haim", "T. Walsh"], "venue": "Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing \u2014 SAT\u201909. pp. 312\u2013325. Springer-Verlag, Berlin, Heidelberg", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}, {"title": "The WEKA data mining software: An update", "author": ["M. Hall", "E. Frank", "G. Holmes", "B. Pfahringer", "P. Reutemann", "I.H. Witten"], "venue": "SIGKDD Explor. Newsl. 11(1), 10\u201318", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Mistral, a Constraint Satisfaction Library", "author": ["E. Hebrard"], "venue": "Proceedings of the Third International CSP Solver Competition", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "Constraint Programming and Combinatorial Optimisation in Numberjack", "author": ["E. Hebrard", "E. O\u2019Mahony", "B. O\u2019Sullivan"], "venue": "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, 7th International Conference, CPAIOR 2010. pp. 181\u2013185", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2010}, {"title": "An economics approach to hard computational problems", "author": ["B.A. Huberman", "R.M. Lukose", "T. Hogg"], "venue": "Science 275(5296), 51\u201354", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1997}, {"title": "ISAC \u2013 Instance-Specific Algorithm Configuration", "author": ["S. Kadioglu", "Y. Malitsky", "M. Sellmann", "K. Tierney"], "venue": "Coelho, H., Studer, R., Wooldridge, M. (eds.) ECAI. Frontiers in Artificial Intelligence and Applications, vol. 215, pp. 751\u2013756. IOS Press", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2010}, {"title": "On the Parallel Complexity of Discrete Relaxation in Constraint Satisfaction Networks", "author": ["S. Kasif"], "venue": "Artificial Intelligence", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1990}, {"title": "LLAMA: leveraging learning to automatically manage algorithms", "author": ["L. Kotthoff"], "venue": "Tech. Rep. arXiv:1306.1031,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Algorithm Selection for Combinatorial Search Problems: A Survey", "author": ["L. Kotthoff"], "venue": "AI Magazine", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "CSP2SAT4J: A Simple CSP to SAT Translator", "author": ["D. Le Berre", "I. Lynce"], "venue": "Proceedings of the Second International CSP Solver Competition", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2008}, {"title": "Abscon 112, Toward more Robustness", "author": ["C. Lecoutre", "S. Tabary"], "venue": "Proceedings of the Third International CSP Solver Competition", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2008}, {"title": "The SAT Solver RISS3G at SC 2013", "author": ["N. Manthey"], "venue": "Proceedings of SAT Competition 2013 p. 72", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "Using Casebased Reasoning in an Algorithm Portfolio for Constraint Solving", "author": ["E. O\u2019Mahony", "E. Hebrard", "A. Holland", "C. Nugent", "B. O\u2019Sullivan"], "venue": "Proceeding of the 19th Irish Conference on Artificial Intelligence and Cognitive Science", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "The algorithm selection problem", "author": ["J.R. Rice"], "venue": "Advances in Computers 15, 65\u2013118", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1976}, {"title": "Handbook of Constraint Programming", "author": ["F. Rossi", "P. van Beek", "T. Walsh"], "venue": "Foundations of Artificial Intelligence, Elsevier, New York, NY, USA", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2006}, {"title": "XML Representation of Constraint Networks: Format XCSP", "author": ["O. Roussel", "C. Lecoutre"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "System Description of a SAT-based CSP Solver Sugar", "author": ["N. Tamura", "T. Tanjo", "M. Banbara"], "venue": "Proceedings of the Third International CSP Solver Competition. pp. 71\u201375", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2009}, {"title": "Azucar: A SAT-Based CSP Solver Using Compact Order Encoding \u2014 (Tool Presentation)", "author": ["T. Tanjo", "N. Tamura", "M. Banbara"], "venue": "Proceedings of the 15th International Conference on Theory and Applications of Satisfiability Testing \u2014 SAT\u201912. pp. 456\u2013462. Springer", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}, {"title": "SAT v CSP", "author": ["T. Walsh"], "venue": "Principles and Practice of Constraint Programming \u2014 CP 2000. vol. 1894, pp. 441\u2013456. Springer-Verlag", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2000}, {"title": "Hierarchical hardness models for SAT", "author": ["L. Xu", "H.H. Hoos", "K. Leyton-Brown"], "venue": "Principles and Practice of Constraint Programming \u2014 CP\u201907. pp. 696\u2013711", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2007}, {"title": "SATzilla: Portfolio-based Algorithm Selection for SAT", "author": ["L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown"], "venue": "Journal of Artificial Intelligence Research pp. 565\u2013606", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 24, "context": "Sugar [29] ar X iv :1 30 6.", "startOffset": 6, "endOffset": 10}, {"referenceID": 25, "context": "Azucar [30] is a related satbased csp solver that uses the compact order encoding.", "startOffset": 7, "endOffset": 11}, {"referenceID": 17, "context": "CSP2SAT4J [21] uses the SAT4J library as its sat back-end and a set of static rules to choose either the direct or the support encoding for each constraint.", "startOffset": 10, "endOffset": 14}, {"referenceID": 16, "context": "There has been a great deal of research in the area of algorithm selection and portfolios; we refer the reader to a recent survey of this work [20].", "startOffset": 143, "endOffset": 147}, {"referenceID": 20, "context": "CPhydra [24] contains an algorithm portfolio of csp solvers which partitions CPU-Time between components of the portfolio in order to maximize the probability of solving a given problem instance within a fixed time limit.", "startOffset": 8, "endOffset": 12}, {"referenceID": 28, "context": "SATzilla [34], at its core, uses costsensitive decision forests that vote on the sat solver to use for an instance.", "startOffset": 9, "endOffset": 13}, {"referenceID": 13, "context": "isac [17] is a clusterbased approach that groups instances based on their features and then finds the best solver for each cluster.", "startOffset": 5, "endOffset": 9}, {"referenceID": 22, "context": "They have a large number of practical applications such as scheduling, planning, vehicle routing, configuration, network design, routing and wavelength assignment [26].", "startOffset": 163, "endOffset": 167}, {"referenceID": 3, "context": "ing, planning, digital circuit design [5].", "startOffset": 38, "endOffset": 41}, {"referenceID": 26, "context": "Translating a csp variable X into sat using the direct encoding [32], also known as the sparse encoding, creates a sat variable for each value in its domain:", "startOffset": 64, "endOffset": 68}, {"referenceID": 5, "context": "The support encoding [9,18] uses the same mechanism as the direct encoding to encode csp domains into sat \u2013 each value in the domain of a csp variable is encoded as a sat variable which represents whether or not it takes that value.", "startOffset": 21, "endOffset": 27}, {"referenceID": 14, "context": "The support encoding [9,18] uses the same mechanism as the direct encoding to encode csp domains into sat \u2013 each value in the domain of a csp variable is encoded as a sat variable which represents whether or not it takes that value.", "startOffset": 21, "endOffset": 27}, {"referenceID": 5, "context": "Unit propagation on this sat instance establishes arc-consistency in optimal worst-case time for establishing arc-consistency [9].", "startOffset": 126, "endOffset": 129}, {"referenceID": 0, "context": "Unlike the direct and support encoding, which model X = v as a sat variable for each value v in the domain of X, the order encoding (also known as the regular encoding [2]) creates sat variables to represent X \u2264 v.", "startOffset": 168, "endOffset": 171}, {"referenceID": 21, "context": "The Algorithm Selection Problem [25] is to select the most appropriate algorithm for solving a particular problem.", "startOffset": 32, "endOffset": 36}, {"referenceID": 7, "context": "It is especially relevant in the context of algorithm portfolios [11,16], where a single solver is replaced with a set of solvers and a mechanism for selecting a subset to use on a particular problem.", "startOffset": 65, "endOffset": 72}, {"referenceID": 12, "context": "It is especially relevant in the context of algorithm portfolios [11,16], where a single solver is replaced with a set of solvers and a mechanism for selecting a subset to use on a particular problem.", "startOffset": 65, "endOffset": 72}, {"referenceID": 28, "context": "Algorithm portfolios have been used with great success for solving both sat and csp instances in systems such as SATzilla [34], isac [17] or CPhydra [24].", "startOffset": 122, "endOffset": 126}, {"referenceID": 13, "context": "Algorithm portfolios have been used with great success for solving both sat and csp instances in systems such as SATzilla [34], isac [17] or CPhydra [24].", "startOffset": 133, "endOffset": 137}, {"referenceID": 20, "context": "Algorithm portfolios have been used with great success for solving both sat and csp instances in systems such as SATzilla [34], isac [17] or CPhydra [24].", "startOffset": 149, "endOffset": 153}, {"referenceID": 27, "context": "[33] and [12] use hierarchical models in the context of a sat portfolio.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[33] and [12] use hierarchical models in the context of a sat portfolio.", "startOffset": 9, "endOffset": 13}, {"referenceID": 6, "context": "Our approach is closer to [10], which first predicts what level of consistency the alldifferent constraint should achieve before deciding on its implementation.", "startOffset": 26, "endOffset": 30}, {"referenceID": 11, "context": "For the sat-based approaches, Numberjack [15] was used to translate a csp instance specified in xcsp format [27] into sat (cnf).", "startOffset": 41, "endOffset": 45}, {"referenceID": 23, "context": "For the sat-based approaches, Numberjack [15] was used to translate a csp instance specified in xcsp format [27] into sat (cnf).", "startOffset": 108, "endOffset": 112}, {"referenceID": 28, "context": "In addition to the csp features, we computed the 54 sat features used by SATzilla [34] for each of the encoded instances and different encodings.", "startOffset": 82, "endOffset": 86}, {"referenceID": 18, "context": "\u2013 Abscon [22], \u2013 Choco [31], \u2013 Gecode [8], and \u2013 Mistral [14].", "startOffset": 9, "endOffset": 13}, {"referenceID": 10, "context": "\u2013 Abscon [22], \u2013 Choco [31], \u2013 Gecode [8], and \u2013 Mistral [14].", "startOffset": 57, "endOffset": 61}, {"referenceID": 4, "context": "\u2013 clasp [7], \u2013 cryptominisat [28], \u2013 glucose [3], \u2013 lingeling [4], \u2013 riss [23], and \u2013 MiniSat [6].", "startOffset": 8, "endOffset": 11}, {"referenceID": 1, "context": "\u2013 clasp [7], \u2013 cryptominisat [28], \u2013 glucose [3], \u2013 lingeling [4], \u2013 riss [23], and \u2013 MiniSat [6].", "startOffset": 45, "endOffset": 48}, {"referenceID": 2, "context": "\u2013 clasp [7], \u2013 cryptominisat [28], \u2013 glucose [3], \u2013 lingeling [4], \u2013 riss [23], and \u2013 MiniSat [6].", "startOffset": 62, "endOffset": 65}, {"referenceID": 19, "context": "\u2013 clasp [7], \u2013 cryptominisat [28], \u2013 glucose [3], \u2013 lingeling [4], \u2013 riss [23], and \u2013 MiniSat [6].", "startOffset": 74, "endOffset": 78}, {"referenceID": 9, "context": "We evaluate a number of regression, classification, and clustering algorithms using WEKA [13].", "startOffset": 89, "endOffset": 93}, {"referenceID": 15, "context": "We use the LLAMA toolkit [19] to train and test the algorithm selection models.", "startOffset": 25, "endOffset": 29}], "year": 2014, "abstractText": "In recent years, portfolio approaches to solving SAT problems and CSPs have become increasingly common. There are also a number of different encodings for representing CSPs as SAT instances. In this paper, we leverage advances in both SAT and CSP solving to present a novel hierarchical portfolio-based approach to CSP solving, which we call Proteus, that does not rely purely on CSP solvers. Instead, it may decide that it is best to encode a CSP problem instance into SAT, selecting an appropriate encoding and a corresponding SAT solver. Our experimental evaluation used an instance of Proteus that involved four CSP solvers, three SAT encodings, and six SAT solvers, evaluated on the most challenging problem instances from the CSP solver competitions, involving global and intensional constraints. We show that significant performance improvements can be achieved by Proteus obtained by exploiting alternative view-points and solvers for combinatorial problem-solving.", "creator": "LaTeX with hyperref package"}}}