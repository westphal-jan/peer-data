{"id": "1306.5667", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Jun-2013", "title": "Using Genetic Programming to Model Software", "abstract": "We study a generic program to investigate the scope for automatically customising it for a vital current task, which was not considered when it was first written. In detail, we show genetic programming (GP) can evolve models of aspects of BLAST's output when it is used to map Solexa Next-Gen DNA sequences to the human genome.", "histories": [["v1", "Mon, 24 Jun 2013 16:35:37 GMT  (180kb,D)", "http://arxiv.org/abs/1306.5667v1", "As UCL computer science Technical Report RN/13/12"]], "COMMENTS": "As UCL computer science Technical Report RN/13/12", "reviews": [], "SUBJECTS": "cs.NE cs.AI", "authors": ["w b langdon", "m harman"], "accepted": false, "id": "1306.5667"}, "pdf": {"name": "1306.5667.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Shin Yoo"], "emails": [], "sections": [{"heading": null, "text": "Research Note RN / 12 / 03Evolving Human Competitive Spectra-Based Fault LocalisationTechniques08 / 05 / 2012Shin YooAbstract Spectra-Based Fault Localisation (SBFL) aims to support troubleshooting by applying risk assessment formulas (sometimes referred to as mistrust indicators) to program spectra and evaluating statements based on predicted risk. Defining a risk assessment formula is often an intuitive process carried out by human software engineers. This paper presents an approach of genetic programming to developing risk assessment formulas empirical evaluation using 92 errors from four Unix tools yields promising results1. GP-evolved equations can consistently outperform many of the human-designed formulas Tarantula, Ochiai, Jaccard, Ample, and Wong1 / 2, up to 5.9 times more importantly, they can work just as well as Op2."}, {"heading": "1 Introduction", "text": "In fact, most of us will be able to play by the rules we have set ourselves in order to make them a reality."}, {"heading": "2 Background", "text": "In June 2013, Wikipedia listed more than 140 bioinformatics tools that perform some aspect of string analysis, either on protein databases or DNA sequences, representing a huge investment in manual labor. Many of these tools can be considered a search for a specific trade-off between performance (typically in terms of accuracy and number of matches found) and non-functional requirements (typically speed, or1Google Scholar says that BLAST has been cited more than 47,000 times and it is at the top of the Nucleic Acids Research Journal (June 1, 2013) list of most frequently cited articles. 2BLAST contains about 20,000 lines of C + +.RN / 13 / 12 page 1speed and storage requirements. As part of the GISMOE program [Langdon, 2012; Harman et al., 2012] [Harman et al.,; Petke et al., 2013; Langdon al, 2010; Langdon and Harman, 2010; and Harman, and Harman, 2010] we can examine these aspects in terms of automation."}, {"heading": "3 Training Data \u2013 NCBI Human Genome, BLAST and the 1000 Genomes Project", "text": "Similarly, we used the official NCBI 64-bit Linux version of BLAST (version 2.2.25 + was available via ftp: / / ftp.ncbi.nlm.nih.gov / blast / executables / blast + /). The 1000 Genome Project [Durbin, et al., 2010] is a consortium in which DNA from more than a thousand individuals from multiple institutions was sequenced using a variety of scanners. To avoid unknown data inconsistencies during the training, we decided to focus on a single scanner used by a laboratory. Similarly, we wanted to minimize real biological variation and focused on software technology."}, {"heading": "4 Genetic Programming", "text": "In this section, the genetic programming systems we use are described in sufficient detail to enable us to reproduce our results. In section 5 (page 8), the models they develop, their performance and also their functioning are described."}, {"heading": "4.1 Preparing the Training Data", "text": "Solexa scanners read DNA sequences from 60 or more square tiles. It was suggested that the data quality could be worse near the tiles \"boundaries. However, we do not see this effect. Nevertheless, for each of the three training data sets, we selected sequences in narrow (11 pixel wide) vertical and horizontal (10 pixel) strips that cross the entirety of a tile (at 511,779 pixels) (tile 119 was randomly selected for two scanner runs, but turned out to be a small data sample in the third case, so tile 78 was randomly selected for the last set of NA12878 training data.) This yielded 606, 565 and 1186 (total of 2357) DNA sequences, each with 36 bases for training. In addition to the standard BLAST parameters, we used -task blastn-short and -num-threads 6, as there are each DNA sequence sequence values in the NCome human reference BI."}, {"heading": "4.2 Randomised Test Suite Sub-sampling", "text": "When a large amount of training data is available, we have previously used a random partial sample of test data for each generation [Langdon, 2010] to reduce the test volume, but also to spread training data more evenly. We divided training data into non-overlapping containers based on the predicted value. (In the case of the two binary classification problems, Sections 4.5 and 4.6, there are only two containers.) Each generation randomly selects the same number of training examples from each container. If one container contains more examples than are needed, the examples are kept in the same random order and the next group is taken. Except for the cases where it is pointed out, this ensures that the examples used in the next generation are not the same as in the previous generation. If there are no more examples, the examples of the container are first placed in a new random order. (This reminds a little of Gathercole's DSS Gathercole [2001 and Ross, 1994, commercial]."}, {"heading": "4.3 Predicting the Quality (E value) of DNA Matches", "text": "Therefore, we simply took the E-value of the first match as the target value of the GP. Where BLAST could not find a match, this GP was represented as the E-value of 100. Due to the wide range of E-values, GP works directly with log10 (E) instead of the E-value. Using the integer part of log10 (E), we divided the training data into 13 groups (separated by powers of ten), each generation 35 examples are randomly selected from each group, meaning that each generation 12 \u00d7 35 + 11 = 431 (of 2357) examples are used. (The twelfth generation binRN / 13 / 12 page 3Table 1: GP parameters for predicting BLAST results with 1000 genomes Project Solexa short DNA sequences. Pass0 terminals: 1037 random constants pos. = 36 A C G Self Complement Samesize Opposite N."}, {"heading": "4.4 Predicting the size of the Best BLAST Match", "text": "Again, we took the best match as the goal of the GP and asked the GP to predict its length (i.e. the length of the first match reported by BLAST). There are 137 Solexa training sequences in which BLAST could not match, which are treated as if they had a length of zero and would automatically be grouped into a group. All reported matches have a length of at least 18 bases, and are divided into ten groups: 18-19, 20-21, 22-23,..., 34-35 and length 36.) Therefore, 11 \u00d7 35 = 385 of 2357 examples are randomly selected for use in each generation. Fitness is the correlation between the value of the GP and the actual length."}, {"heading": "4.5 Predicting High Quality BLAST Matches", "text": "We develop two classifiers for the number of BLAST matches: the first (this section) delivers a positive value if the physician believes that at least one high-quality match is found (i.e. E < 10 \u2212 5). Conversely, there are 997 (42%) training DNA sequences that either BLAST could not find matches or where the matches had poor E values (E \u2265 10 \u2212 5). For both classifiers (i.e. this section and the next), 300 positive and 300 negative randomly selected examples per generation are used to assess the fitness of each individual. Fitness is the number of training cases that are correctly classified."}, {"heading": "4.6 Predicting Repeats in the Human Genome", "text": "When predicting repetitions, a positive value is used to indicate that GP expects there to be several instances of DNA sequences in the human genome. (Repetitive sequences are quite common [IHGSC, 2001]. However, there are only 324 training sequences with several high-quality matches. The selection of 300 positive examples means that almost all of them are used per generation. In contrast, each of the 2033 negative examples will have to wait at least six generations (b2033 / 300c = 6) before it is even eligible to be reused by the fitness function. (On average, each negative example is used in 16 generations.) Like all our other predictors, the separate data used to validate the developed predictor is uniformly plotted."}, {"heading": "4.7 Genetic Programming Architecture and Primitives", "text": "The rest of Section 4 describes the GP representation, the data flow within the three components, terminal and function sets, and the speed of the GP system. We used a multi-tree GP (based on [Langdon, 1998]) with functions and terminals inspired by Koza's transmembrane prediction work [Koza, 1994]. (See Table 1 for details.)"}, {"heading": "4.7.1 Co-Evolving Three Trees", "text": "It seems clear that the developed classifiers need to scan the DNA sequence. It is unclear how often they want to scan this sequence. In order to support the serial processing of the sequence and still give evolution some freedom of choice, we have introduced a novel three-tree architecture (Figure 1). The first two trees scan the sequence and pass the data via the memory to the last one. GP can freely decide how to use this architecture. Thus, the first evolution tree is used 36 times to process the complete DNA sequence 0, 1 or 2 times. The first tree is called once for each member of the sequence from beginning to end. (In bioinformatics, this is known as the 5 '-3' order.) The first evolution tree is then called 36 times for each DNA base in the sequence in the same order. (Again 36 times per fitness evaluation.) Finally, the last tree is called once and its result is used to determine the fitness of the entire team members."}, {"heading": "4.7.2 Passing Data Between Trees via Memory", "text": "To support this, the sum of the 36 results produced by each of the prepass trees is stored and passed to the following parts of the GP individual via read-only terminals Sum0 and Sum1.RN / 13 / 12 page 5GP sheet M refers to 36 read-only memory cells, allowing the second prepass to use the result of the first pass. One can think of a result similar to that of an ADF [Koza, 1994] with a cache [Langdon, 1998]. We also have more conventional indexed memory cells [Teller, 1994]. There are two floating-point memory cells, called Aux1 and Aux2, and routines to write to them, set Aux1 and Aux2. As with [Langdon, 1998] functions are set to Aux1 and the new memory cell argument is assigned to Aux2."}, {"heading": "4.7.3 DNA bases", "text": "Inspired by Koza's work on protein sequences [Koza, 1994], we use five terminals (A, C, G, T, and N) to indicate (in both prepass trees) whether the current bases are A, C, G, or T. N indicates that the scanner did not know which of the four bases it was. The sheet has a value of 1 if it is true, and -1 otherwise. (So sheet N is always -1, unless the DNA scanner has stated that it cannot tell which of the four bases it is.)"}, {"heading": "4.7.4 Look Ahead", "text": "The LOOK function shifts the active position (denoted by terminal positions) before one. Within the general limitation of the program size, LOOK can be as deeply nested as evolution wants, allowing any view forward. That is, special inputs such as A react when LOOK's single argument is called, as they would if the prepass tree is called later along the sequence. LOOK applies to all position-dependent primitives (including Qual, Run, M, S, and pos itself). Appearance protection is given at the end of the DNA sequence."}, {"heading": "4.7.5 DNA Specific Terminals", "text": "The four terminals: Self, Complement, Samesize and Opposite compare the current base (as updated by LOOK) with the base at the default position (i.e. without LOOK). Like A, C, G, T and N, they signal true and false with 1 and -1. Self returns 1 if the current DNA base and the \"LOOKed\" at the DNA base are the same. Complement returns 1 if they are members of a complementary pair. Samesize returns 1 if they contain the same number of rings. (C and T are \"small\" and have a ring. A and G are large and have 2 rings. Any N gets 0 rings.) Opposite is only true if Self, Complement and Samesize are all wrong."}, {"heading": "4.7.6 Solexa Quality Terminals", "text": "In addition to N, the Solexa scanner contains a quality value for each base. These are presented to the GP via the Qual terminal as values in the range 0, 0.1, 0.2,..., 3.9, 4.0. (4.0 indicates that the DNA scanner has the highest confidence in its output. 0 means that it has no confidence in it.)"}, {"heading": "4.7.7 Runs of the Same DNA Base", "text": "It is known that sequences of the same base can affect bioinformatics devices [Upton et al., 2008], so we provide the general practitioner with a primitive that counts the length of identical bases up to and including the current point. (The value of Run is therefore in the range of 1, 2, 3,... theoretically up to 36.) No special treatment for N is provided, i.e. an N-value terminates a series of other letters, but we can also have passes of N. RN / 13 / 12 page 6"}, {"heading": "4.7.8 CountN", "text": "CountN is simply the number of \"N\" (i.e. unknown) bases in the current DNA sequence. Typically, CountN takes the value 0, 1, 2, or 3. Since the CG ratio is known for the Solexa scanner [Cheung et al., 2011], we could have provided similar CountA, CountC, CountG, and CountT terminals."}, {"heading": "4.7.9 Entropy S", "text": "Terminal S holds the entropy or information content of the string in bits from the start to the current position, i.e. S = \u2211 A, C, G, T \u2212 pi log2 (pi). Here, pA, for example, is the number of As in the current DNA sequence from the start to the current position divided by the number of all four bases to the current position. As N specifies an unknown base, it is calculated by adding 1 / 4 to each of the four bases. S in the third tree results in the entropy of the entire sequence."}, {"heading": "4.7.10 X and Y", "text": "The sheets X and Y tell the physician where the DNA sequence was on the Solexa tile (see section 4.1). Both are normalized by dividing by the width of the tile in pixels to the range 0.. 1."}, {"heading": "4.7.11 Ephemeral Random Constants", "text": "1000 values were randomly selected from a tangent distribution [Langdon, 1998]. (i.e. a value is randomly selected from the range 0.. \u03c0 and its tangent is taken.) This results in some very large numbers (the largest was 632.124324 and the smallest was -425.715953), but about half of the values are in the range \u2212 1.. + 1. This was complemented by the 37 integer values: 0, 1,... 36."}, {"heading": "4.7.12 Functions", "text": "In addition to LOOK and the four usual arithmetic operations (+, -, \u00d7 and protected division, which results in division by zero 1), we count If-less-than-or-equal [Langdon, 1998] and Koza's ORN [Koza, 1994]. If the first argument is true (i.e. > 0), the second is skipped and ORN returns 1. Otherwise, it evaluates its second argument and returns 1 if it is true. If the second argument is false (i.e. \u2264 0), ORN returns -1. Default behavior is usually used for special values such as NaN or infinity. However, care should be taken when calculating correlation-based fitness and protecting against rounding errors, etc., which cause numerical instabilities (i.e., negative variances). Members of the general practitioner population that cause unresolved numerical problems receive low fitness values."}, {"heading": "4.7.13 GP Speed", "text": "The special GPquick interpreter [Singleton, 1994], [Langdon, 1998] used an average of 213 million GP primitives per second. In [Langdon, 2010] we reported a GPU-based GP interpreter that ran more than a thousand times faster, but it was built to exploit both the graphics hardware accelerator and the bit-level parallelism inherent in Boolean problems [Poli and Langdon, 1999] rather than floating-point numbers as used here. Our GPquick compares well with tinyGP [Poli et al., 2008], which runs in the range of 20-80 MGPops \u2212 1 (C version). [Langdon, 2011] discusses the speed of recently created and interpreted GP approaches, especially those using graphics hardware accelerators. (See also [Langdon, Table 15.3].) RN / 13 / 12 page 7"}, {"heading": "5 Evolved Prediction of BLAST Matches", "text": "In each of the four problems, we extracted the best predictive data of generation ten and generation one hundred. (Details are in Table 1.) Figure 2 shows the evolution of the best fitness of the generations, both on their training data per generation (lines with +) and on the totality of training data (continuous lines). In each of the four predictive tasks and at generation ten and generation one hundred, we tested the smallest of the best of the population individuals on a validation set of 31,000 Solexa DNA sequences. The validation data came from completely new sequences, which were initially uniformly selected from the eleven NA12878 datasets (a 1000 from each). There were only two other individuals in the 1000 genome project with more than ten data scans from similar Illumina2 Solexa scanners. These are NA12891 and NA12892, each of which are their father and mother. Ten datasets were selected for each and then 1000 DNA sequences were selected from each scan."}, {"heading": "5.1 Predicting BLAST \u201cE\u201d Values", "text": "After 100 generations of GP have developed a program whose correlation with the E-value of BLAST r = 0.76 on the training data and whose mean correlation r = 0.77 on all 31 000 validation sequences, see \u00b7 in Figure 3.Generation 100's 77 primitive program can be simplified to an almost equivalent program (see Figure 7) whose final output depends on the sum of all 36 positions in the Solexa DNA sequence of the value calculated by prepas0. The use of sum Aux2 at the root of prepas0 occurs frequently and gives more weight to the 3 'end of the sequence. GP uses nested LOOKs to compare nearby DNA bases and their reported quality. In fact, the best sequence of generation 10 individuals from the same run uses only the quality indicator of Solexa to predict BLAST's E-value. Although the performance is not as good, it nevertheless receives r = 0.68 on the training data and is equivalent to almost 3 / 3."}, {"heading": "5.2 Predicting Match Length", "text": "Predicting the length of the match found by BLAST turned out to be more difficult with the smallest best of the generation 100 predictor, which has a correlation to all training data of r = 0.61. However, this is also an indication of the validation data, with a medial correlation of r = 0.60, see also the error bars, which distinguish results highly significantly from the zero hypothesis (no correlation).RN / 12 page 11prepas0 = (IFLTE) hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses = (IFLTE N) hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-1 = (IFLTE N) hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-hypotheses-"}, {"heading": "5.3 Predicting High Quality BLAST Matches", "text": "The smallest of the top 100 Generation 100 programs designed to predict whether BLAST will find a high-quality match (Figure 9) receives 80% of the training data correctly, and the graph in Figure 5 shows that this also applies to the verification sequences (median 79%), which is highly statistically significant, but whether all 31 000 verification sequences match (Figure 2 = 8400, 1 dof).RN / 13 / 12 page 12prepas0 = (SUB 1.744647 pos) prepas1 = (IFLTE 1.370267 N 0.496664 torture)) (ORN (sum _ Aux1 page 12prepas0 = (LOOK Aux2))) (Sum _ Aux2 pos) prepas1 = (DIV (MUL Aux2 G)) (sum _ Aux2 G)))))))))) (ORN Aux1 Samesize (Aux1) FLORIN (Aux1) (Aux1) (Aux1) (Aux1) (Aux1) (Aux1)."}, {"heading": "5.4 Predicting Repeats in the Human Genome", "text": "After a hundred generations, GP has developed a program that repeats 54% of all training data. Its median value is 46% of the validation data (see \u00d7 in Figure 6).Although obviously reduced from its performance to its training data, this is highly significant again. Across all 31,000 verification sequences, good multiple matches are very strong in the minority class.Only 14% of training data give rise to several high-quality BLAST matches. So, although each generation tests the fitness function of the developing population on a 50: 50 balanced dataset (see Section 4.6), good multiple matches are very strong in the minority class.Despite this class imbalance, the mean percentage of multiple matches correctly predicted is 83% on training data and 83% on the verification datasets (Figure 11).The three trees of the smallest Generation 100 program have a combined size of 254. So let's try to explain each part of the prediction individually."}, {"heading": "6 Conclusions", "text": "This year, it has reached the point where it will be able to retaliate."}, {"heading": "Acknowledgements", "text": "I would like to thank Caroline Johnston, Jeremy Leipzig, Keith James, Pablo Pareja, Pierre Lindenbaum and Larry Parnell. Supported by EPSRC grant EP / I033688 / 1.RN / 13 / 12 page 15"}], "references": [{"title": "47(6):1013\u20131016", "author": ["Estibaliz Aldecoa-Otalora", "William B. Langdon", "Phil Cunningham", "Matthew J. Arno. Unexpected presence of mycoplasma probes on human microarrays. BioTechniques"], "venue": "December", "citeRegEx": "Aldecoa.Otalora et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Nucleic Acids Research", "author": ["Stephen F. Altschul", "Thomas L. Madden", "Alejandro A. Schaffer", "Jinghui Zhang", "Zheng Zhang", "Webb Miller", "David J. Lipman. Gapped BLAST", "PSI-BLAST a new generation of protein database search programs"], "venue": "25(17):3389\u20133402,", "citeRegEx": "Altschul et al.. 1997", "shortCiteRegEx": null, "year": 1997}, {"title": "39(15):e103", "author": ["Ming-Sin Cheung", "Thomas A. Down", "Isabel Latorre", "Julie Ahringer. Systematic bias in high-throughput sequencing data", "its correction by BEADS. Nucleic Acids Research"], "venue": "August", "citeRegEx": "Cheung et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "et al", "author": ["Richard M. Durbin"], "venue": "A map of human genome variation from population-scale sequencing. Nature, 467(7319):1061\u20131073, 28 Oct", "citeRegEx": "Durbin. et al.. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Review: Discipulus: A commercial genetic programming system", "author": ["James A. Foster"], "venue": "Genetic Programming and Evolvable Machines, 2(2):201\u2013203, June", "citeRegEx": "Foster. 2001", "shortCiteRegEx": null, "year": 2001}, {"title": "Some training subset selection methods for supervised learning in genetic programming", "author": ["Chris Gathercole", "Peter Ross"], "venue": "Presented at ECAI\u201994 Workshop on Applied Genetic and other Evolutionary Algorithms,", "citeRegEx": "Gathercole and Ross. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "The GISMOE challenge: Constructing the Pareto program surface using genetic programming to find better programs", "author": ["Mark Harman", "William B. Langdon", "Yue Jia", "David R. White", "Andrea Arcuri", "John A. Clark"], "venue": "The 27th IEEE/ACM International Conference on Automated Software Engineering (ASE 12), pages 1\u201314, Essen, Germany, September 3-7", "citeRegEx": "Harman et al.. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Series B (Methodological)", "author": ["Harold Hotelling. New light on the correlation coefficient", "its transforms. Journal of the Royal Statistical Society"], "venue": "15(2):193\u2013232,", "citeRegEx": "Hotelling. 1953", "shortCiteRegEx": null, "year": 1953}, {"title": "409(6822):860\u2013921", "author": ["International Human Genome Sequencing Consortium. Initial sequencing", "analysis of the human genome. Nature"], "venue": "15 Feb", "citeRegEx": "IHGSC. 2001", "shortCiteRegEx": null, "year": 2001}, {"title": "Hidden Markov models for detecting remote protein homologies", "author": ["K Karplus", "C Barrett", "R Hughey"], "venue": "Bioinformatics, 14(10):846\u2013856", "citeRegEx": "Karplus et al.. 1998", "shortCiteRegEx": null, "year": 1998}, {"title": "Genetic Programming II Automatic Discovery of Reusable Programs", "author": ["John R. Koza"], "venue": "MIT Press,", "citeRegEx": "Koza. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "editors", "author": ["W.B. Langdon", "M.J. Arno. In Silico infection of the human genome. In Mario Giacobini", "Leonardo Vanneschi", "William S. Bush"], "venue": "10th European Conference on Evolutionary Computation, Machine Learning and Data Mining in Bioinformatics, EvoBIO 2012, volume 7246 of LNCS, pages 245\u2013249, Malaga, Spain, 11-13 April", "citeRegEx": "Langdon and Arno. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "editor", "author": ["W.B. Langdon", "M. Harman. Evolving a CUDA kernel from an nVidia template. In Pilar Sobrevilla"], "venue": "2010 IEEE World Congress on Computational Intelligence, pages 2376\u20132383, Barcelona, 18-23 July", "citeRegEx": "Langdon and Harman. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Kluwer", "author": ["William B. Langdon. Genetic Programming", "Data Structures"], "venue": "Boston,", "citeRegEx": "Langdon. 1998", "shortCiteRegEx": null, "year": 1998}, {"title": "editors", "author": ["W.B. Langdon. A many threaded CUDA interpreter for genetic programming. In Anna Isabel Esparcia-Alcazar", "Aniko Ekart", "Sara Silva", "Stephen Dignum", "A. Sima Uyar"], "venue": "Proceedings of the 13th European Conference on Genetic Programming, EuroGP 2010, volume 6021 of LNCS, pages 146\u2013158, Istanbul, 7-9 April", "citeRegEx": "Langdon. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Graphics processing units and genetic programming: An overview", "author": ["W.B. Langdon"], "venue": "Soft Computing, 15:1657\u20131669, August", "citeRegEx": "Langdon. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "editor", "author": ["W.B. Langdon. Genetic improvement of programs. In Radomil Matousek"], "venue": "18th International Conference on Soft Computing, MENDEL 2012, Brno, Czech Republic, 27-29 June", "citeRegEx": "Langdon. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Which is faster: Bowtie2GP> Bowtie> Bowtie2> BWA", "author": ["W.B. Langdon"], "venue": "Francisco Luna, editor, GECCO 2013 Late breaking abstracts workshop, Amsterdam, 6-10 July", "citeRegEx": "Langdon. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Fast gapped-read alignment with Bowtie 2", "author": ["Ben Langmead", "Steven L Salzberg"], "venue": "Nature Methods, 9(4):357\u2013359, 4 March", "citeRegEx": "Langmead and Salzberg. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Genome Biology", "author": ["Ben Langmead", "Cole Trapnell", "Mihai Pop", "Steven Salzberg. Ultrafast", "memory-efficient alignment of short DNA sequences to the human genome"], "venue": "10(3):R25,", "citeRegEx": "Langmead et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "editors", "author": ["Jose Garcia Moreno-Torres", "Xavier Llora", "David E. Goldberg", "Rohit Bhargava. On the homogenization of data from two laboratories using genetic programming. In Jaume Bacardit", "Will N. Browne", "Jan Drugowitsch", "Ester Bernad\u00f3-Mansilla", "Martin V. Butz"], "venue": "Learning Classifier Systems, volume 6471 of Lecture Notes in Computer Science, pages 185\u2013197. Springer,", "citeRegEx": "Moreno.Torres et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "editor", "author": ["Justyna Petke", "William B. Langdon", "Mark Harman. Applying genetic improvement to MiniSAT. In Gordon Fraser"], "venue": "Symposium on Search-Based Software Engineering, Leningrad, August 24-26", "citeRegEx": "Petke et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Una-May O\u2019Reilly", "author": ["Riccardo Poli", "William B. Langdon. Sub-machine-code genetic programming. In Lee Spector", "William B. Langdon"], "venue": "and Peter J. Angeline, editors, Advances in Genetic Programming 3, chapter 13, pages 301\u2013323. MIT Press,", "citeRegEx": "Poli and Langdon. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "A field guide to genetic programming", "author": ["Riccardo Poli", "William B. Langdon", "Nicholas Freitag McPhee"], "venue": "Published via http://lulu.com and freely available at http://www.gp-field-guide.org.uk,", "citeRegEx": "Poli et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "Memory with memory in genetic programming", "author": ["Riccardo Poli", "Nicholas Freitag McPhee", "Luca Citi", "Ellery Crane"], "venue": "Journal of Artificial Evolution and Applications,", "citeRegEx": "Poli et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Genetic programming with C++", "author": ["Andy Singleton"], "venue": "BYTE, pages 171\u2013176, February", "citeRegEx": "Singleton. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "editor", "author": ["Astro Teller. The evolution of mental models. In Kenneth E. Kinnear", "Jr."], "venue": "Advances in Genetic Programming, chapter 9, pages 199\u2013219. MIT Press,", "citeRegEx": "Teller. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "BMC Genomics", "author": ["Graham JG Upton", "William B Langdon", "Andrew P Harrison. G-spots cause incorrect expression measurement in Affymetrix microarrays"], "venue": "9:613,", "citeRegEx": "Upton et al.. 2008", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 1, "context": "We study a popular generic program BLAST [Altschul et al., 1997] to investigate the scope for automatically customising it for a popular current demand, mapping next generation DNA sequences.", "startOffset": 41, "endOffset": 64}, {"referenceID": 18, "context": "data compression algorithms [Langmead and Salzberg, 2012; Langdon and Harman, ; Langdon, 2013]).", "startOffset": 28, "endOffset": 94}, {"referenceID": 17, "context": "data compression algorithms [Langmead and Salzberg, 2012; Langdon and Harman, ; Langdon, 2013]).", "startOffset": 28, "endOffset": 94}, {"referenceID": 19, "context": "Also often the new performance comes at the price of losing some functionality [Langmead et al., 2009].", "startOffset": 79, "endOffset": 102}, {"referenceID": 16, "context": "As part of the GISMOE program [Langdon, 2012; Harman et al., 2012] [Harman et al.", "startOffset": 30, "endOffset": 66}, {"referenceID": 6, "context": "As part of the GISMOE program [Langdon, 2012; Harman et al., 2012] [Harman et al.", "startOffset": 30, "endOffset": 66}, {"referenceID": 21, "context": ", 2012] [Harman et al., ; Petke et al., 2013; Langdon and Harman, 2010; Langdon, 2013; Langdon and Harman, ] to mechanise aspects of software production we are investigating to what extent these trade-offs can be automated.", "startOffset": 8, "endOffset": 108}, {"referenceID": 12, "context": ", 2012] [Harman et al., ; Petke et al., 2013; Langdon and Harman, 2010; Langdon, 2013; Langdon and Harman, ] to mechanise aspects of software production we are investigating to what extent these trade-offs can be automated.", "startOffset": 8, "endOffset": 108}, {"referenceID": 17, "context": ", 2012] [Harman et al., ; Petke et al., 2013; Langdon and Harman, 2010; Langdon, 2013; Langdon and Harman, ] to mechanise aspects of software production we are investigating to what extent these trade-offs can be automated.", "startOffset": 8, "endOffset": 108}, {"referenceID": 3, "context": "The 1000 genomes project [Durbin, et al., 2010] is a consortium in which DNA from more than one thousand individuals has been sequenced by several institutions using a variety of scanners.", "startOffset": 25, "endOffset": 47}, {"referenceID": 0, "context": "The NCBI reference database for the human genome contains DNA sequences from a number of sources [Aldecoa-Otalora et al., 2009; Langdon and Arno, 2012].", "startOffset": 97, "endOffset": 151}, {"referenceID": 11, "context": "The NCBI reference database for the human genome contains DNA sequences from a number of sources [Aldecoa-Otalora et al., 2009; Langdon and Arno, 2012].", "startOffset": 97, "endOffset": 151}, {"referenceID": 14, "context": "When a large volume of training data is available we had previously used a random sub-sample of the test data at each generation [Langdon, 2010] to reduce the volume of testing but also found it helped with generalisation.", "startOffset": 129, "endOffset": 144}, {"referenceID": 5, "context": "(This is somewhat reminiscent of Gathercole\u2019s DSS [Gathercole and Ross, 1994], as used commercially [Foster, 2001].", "startOffset": 50, "endOffset": 77}, {"referenceID": 4, "context": "(This is somewhat reminiscent of Gathercole\u2019s DSS [Gathercole and Ross, 1994], as used commercially [Foster, 2001].", "startOffset": 100, "endOffset": 114}, {"referenceID": 8, "context": "(Repeated sequences are quite common [IHGSC, 2001].", "startOffset": 37, "endOffset": 50}, {"referenceID": 13, "context": "We used a multiple tree GP (based on [Langdon, 1998]) with functions and terminals inspired by Koza\u2019s transmembrane prediction work [Koza, 1994].", "startOffset": 37, "endOffset": 52}, {"referenceID": 10, "context": "We used a multiple tree GP (based on [Langdon, 1998]) with functions and terminals inspired by Koza\u2019s transmembrane prediction work [Koza, 1994].", "startOffset": 132, "endOffset": 144}, {"referenceID": 13, "context": "[Langdon, 1998] contains examples of teams of five and 15 agents.", "startOffset": 0, "endOffset": 15}, {"referenceID": 20, "context": "Recently GP has since been used to evolve even bigger teams [Moreno-Torres et al., 2009].", "startOffset": 60, "endOffset": 88}, {"referenceID": 10, "context": "It can be thought of a similar to an ADF [Koza, 1994] with a cache [Langdon, 1998].", "startOffset": 41, "endOffset": 53}, {"referenceID": 13, "context": "It can be thought of a similar to an ADF [Koza, 1994] with a cache [Langdon, 1998].", "startOffset": 67, "endOffset": 82}, {"referenceID": 26, "context": "We also have more conventional indexed memory [Teller, 1994].", "startOffset": 46, "endOffset": 60}, {"referenceID": 13, "context": "As with [Langdon, 1998], functions set Aux1 and set Aux2 take one argument, which is assigned to the memory cell and return the memory\u2019s new value.", "startOffset": 8, "endOffset": 23}, {"referenceID": 24, "context": "Inspired by the work on \u201cmemory with memory\u201d [Poli et al., 2009] we also introduce two functions: sum Aux1 and sum Aux2.", "startOffset": 45, "endOffset": 64}, {"referenceID": 13, "context": ") Alternatively these can be thought of as parametrised memory increment instructions [Langdon, 1998].", "startOffset": 86, "endOffset": 101}, {"referenceID": 10, "context": "3 DNA bases Inspired by Koza\u2019s work on protein sequences [Koza, 1994] we use five terminals (A, C, G, T and N) to indicate (in both prepass trees) if the current bases is an A, C, G or T.", "startOffset": 57, "endOffset": 69}, {"referenceID": 27, "context": "7 Runs of the Same DNA Base It is known that sequences of the same base can affect Bioinformatics equipment [Upton et al., 2008], so we provide GP with a primitive which counts the length of identical bases up to and including the current point.", "startOffset": 108, "endOffset": 128}, {"referenceID": 2, "context": "Since CG ratio is known to be important to the Solexa scanner [Cheung et al., 2011], we might also have provided similar CountA, CountC, CountG and CountT terminals.", "startOffset": 62, "endOffset": 83}, {"referenceID": 13, "context": "1000 values were randomly selected from a tangent distribution [Langdon, 1998].", "startOffset": 63, "endOffset": 78}, {"referenceID": 13, "context": "In addition to LOOK and the four usual arithmetic operations (+, -,\u00d7 and protected division, which returns 1 on divide by zero) we include if-less-than-or-equal [Langdon, 1998] and Koza\u2019s ORN [Koza, 1994].", "startOffset": 161, "endOffset": 176}, {"referenceID": 10, "context": "In addition to LOOK and the four usual arithmetic operations (+, -,\u00d7 and protected division, which returns 1 on divide by zero) we include if-less-than-or-equal [Langdon, 1998] and Koza\u2019s ORN [Koza, 1994].", "startOffset": 192, "endOffset": 204}, {"referenceID": 25, "context": "The special GPquick interpreter [Singleton, 1994], [Langdon, 1998] we used processes on average 213 million GP primitives per second.", "startOffset": 32, "endOffset": 49}, {"referenceID": 13, "context": "The special GPquick interpreter [Singleton, 1994], [Langdon, 1998] we used processes on average 213 million GP primitives per second.", "startOffset": 51, "endOffset": 66}, {"referenceID": 14, "context": "In [Langdon, 2010] we reported a GPU based GP interpreter running more than a thousand times faster, however this was build to exploit both the graphics hardware accelerator and the bit level parallelism inherent in Boolean problems [Poli and Langdon, 1999], rather than floating point numbers as used here.", "startOffset": 3, "endOffset": 18}, {"referenceID": 22, "context": "In [Langdon, 2010] we reported a GPU based GP interpreter running more than a thousand times faster, however this was build to exploit both the graphics hardware accelerator and the bit level parallelism inherent in Boolean problems [Poli and Langdon, 1999], rather than floating point numbers as used here.", "startOffset": 233, "endOffset": 257}, {"referenceID": 23, "context": "Our GPquick compares well with tinyGP [Poli et al., 2008], which processes in the region of 20\u201380 MGPops\u22121 (C version).", "startOffset": 38, "endOffset": 57}, {"referenceID": 15, "context": "[Langdon, 2011] discusses the speed of recent compiled and interpreted GP approaches, particularly those using graphics hardware accelerators.", "startOffset": 0, "endOffset": 15}], "year": 2013, "abstractText": "Spectra-Based Fault Localisation (SBFL) aims to assist debugging by applying risk evaluation formul\u00e6 (sometimes called suspiciousness metrics) to program spectra and ranking statements according to the predicted risk. Designing a risk evaluation formula is often an intuitive process done by human software engineer. This paper presents a Genetic Programming approach for evolving risk assessment formul\u00e6. The empirical evaluation using 92 faults from four Unix utilities produces promising results. GP-evolved equations can consistently outperform many of the human-designed formul\u00e6, such as Tarantula, Ochiai, Jaccard, Ample, and Wong1/2, up to 5.9 times. More importantly, they can perform equally as well as Op2, which was recently proved to be optimal against If-Then-Else-2 (ITE2) structure, or even outperform it against other program structures. 1 The program spectra data used in the paper, as well as the complete empirical results, are available from: http://www.cs.ucl.ac.uk/staff/s.yoo/evolving-sbfl.html. UCL DEPARTMENT OF COMPUTER SCIENCE Research Note RN/13/12 Using Genetic Programming to Model Software", "creator": "LaTeX with hyperref package"}}}