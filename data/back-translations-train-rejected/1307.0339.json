{"id": "1307.0339", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Jul-2013", "title": "Syntactic sensitive complexity for symbol-free sequence", "abstract": "This work uses the L-system to construct a tree structure for the text sequence and derives its complexity. It serves as a measure of structural complexity of the text. It is applied to anomaly detection in data transmission.", "histories": [["v1", "Mon, 1 Jul 2013 12:00:59 GMT  (243kb)", "https://arxiv.org/abs/1307.0339v1", "11 pages, 5 figures"], ["v2", "Tue, 2 Jul 2013 02:08:48 GMT  (256kb,D)", "http://arxiv.org/abs/1307.0339v2", "11 pages, 5 figures"]], "COMMENTS": "11 pages, 5 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["cheng-yuan liou", "bo-shiang huang", "daw-ran liou", "alex a simak"], "accepted": false, "id": "1307.0339"}, "pdf": {"name": "1307.0339.pdf", "metadata": {"source": "CRF", "title": "Syntactic sensitive complexity for symbol-free sequence", "authors": ["Cheng-Yuan Liou", "Bo-Shiang Huang", "Daw-Ran Liou", "Alex A. Simak"], "emails": [], "sections": [{"heading": null, "text": "keywords: text complexity, detection of anomalies, structural complexity, circumscription rule, context-free grammar, L-system"}, {"heading": "1 Introduction", "text": "The complexity of the text has been developed with varying degrees of success, [2] [3]. This work developed a novel measure based on the L system [1], which can calculate the structural complexity of a text sequence. Considering a text, we first convert it into a binary string. Then, we use the L system to model the tree structure of this string and maintain its structural complexity. In this section, we will introduce how to use the L system to model the string. The measure of complexity for the text sequence will be included in the next section."}, {"heading": "1.1 Transforming binary string into rewriting rules", "text": "The Lindenmayer system, or L system, is a parallel paraphrasing system introduced by the biologist Aristid Lindenmayer in 1968. The main operation of the L system is paraphrasing. A series of paraphrasing rules or productions are used to define a complex object by replacing parts of a simple source object one after the other. Operations for a hierarchical tree can be represented by a series of paraphrasing rules. These rules can be further transformed into a string inserted in brackets. \u2022 A binary tree can be represented by a string inserted in parentheses and the tree can be restored from the string. This paraphrased string contains five symbols, F, \u2212, [,] and these symbols are defined in the following paragraph. \u2212 F denotes the current position of a tree node. It can be replaced by any word or by an omission. Xiv: 130 7.03 39v2 [cs.AI] 2J + the following string represents the subtree."}, {"heading": "1.2 Classifying rewriting rules into different sets", "text": "Definition 1 Homomorphism when rewriting rules. We say that rewriting rule R1 and rewriting rule R2 are homomorphous to each other if and only if they have the same structure.Definition 2 Isomorphism at level X when rewriting rules. Rewriting rule R1 and rewriting rule R2 are isomorphic at depth X if they are homomphic and their non-terminals are relatively isomphic at depth X \u2212 1. We use the rule name at level 0 as a class name. For example, after we have defined the similarity between rules by homomorphism and isomorphism, we can divide all rules into different subgroups in which each subset has the same similarity relationship. We use the rule name as a class name. After we assign the terminal transcription rule to a class, \"C3.\""}, {"heading": "1.3 Complexity for classified rules", "text": "1. Suppose there are n classes of rules, {C1, C2,. \u2032, Cn}, and the class Ci contains ni rules. Suppose there are n classes of rules, {C1, C2,.. \u2032, n; j = 1, 2, ni}, and the class Ci contains ni rules. Suppose: x = 1, 2,., n}, where each Uij has the following form for a binary tree: Ui1 \u2192 Vai11Vai12 Ui2 \u2192 Vai22.. \u2192. Uini \u2192 Vaini1Vaini2.2.2. The generation function of Vi, Vi (z) has a form, Vi (z)."}, {"heading": "2 Complexity of encoded text", "text": "A text sequence is first converted into a binary string by specifying any character string. You can specify each character directly as a whole and get a binary string for the text. Another method, Lempel-Ziv-Welch (LZW), is also used to encode the text. LZW is designed for lossless data compression and is a dictionary-based encoding [4]. In LZW, a certain substring will often appear in the text, it is also used in the encoding of the text. LZW is designed for lossless data compression and is a dictionary encoding."}, {"heading": "Example", "text": "After removing all punctuations, the total number of characters is 7930. Apply the two encryption methods and you get the two binary strings. We calculate the complexity every 512 bits along the string. Figure 3 shows that the encryption features of BIN are roughly fixed in the text sequence. The encryption values of LZW at the front end of the text are lower than those at the back end of the text. These lower valves reveal the encryption features of LZW. Since the LZW dictionary stores many regular patterns at the front end and absorbs the regularity, there are no regular patterns at the back end. A string with high regularity has low complexity. Thus, the displayed string at the rear end becomes much more random with high complexity."}, {"heading": "3 Comparison with other Measures", "text": "Two further measures of complexity, topological entropy (TE) [2] and linguistic complexity (LC), are discussed and compared with the proposed method."}, {"heading": "Topological entropy", "text": "An information function Ai (s) is defined as, Al (s) = | {u: | u | = l and u is a unique substring in s} |, where Ai (s) represents the total number of different substrands with the length l in the sequence s. Entropy [5] is defined as, Hl (s) = logkAl (s) l, where k is the size of all alphabets of the sequence. Since there are many values for l and this definition cannot generate a single value of complexity for the entire sequence, a new definition [2] for topological entropy is found in the following paragraph. Definition 4 Let s be a finite sequence of length | s | and k be the size of the alphabet, let l be the unique integer like thatkl + l + l \u2212 1 \u2264 1 + (l + 1) \u2212 1We use sk l + l \u2212 11 to represent the first k + l of the letters (l) with l (l) length \u2212 l (1)."}, {"heading": "Linguistic complexity", "text": "Linguistic complexity [6, 8] is a measure of the vocabulary wealth of a text. LC is defined as the ratio of the number of substrings presented in the string in question to the maximum number of substrings of the same length across the same alphabet. The more complex a text string is, the richer its vocabulary is, while a repetitive sequence is relatively less complex. Let M (s) be the length of the binary string s. Let Ml (s) denote the maximum number of different substrings with length l, and Ml (s) is equal to min (2i, | i + 1). Let M (s) be the sum of M1 (s), M2 (s), and M | s (s) denote the maximum number of different substrings with length l, and M (s) the actual number of different substrings with length l. Let A (s) is equal."}, {"heading": "Comparison and analysis", "text": "Topological entropy focuses on only one subword length and calculates its complexity. In contrast, linguistic complexity calculates the complexity of all possible subword lengths. LC uses much more calculations than TE. The proposed method uses the binary tree to represent a binary sequence with a strength of 2. It reveals the structural information of the sequence. Finally, we discuss some potential applications. The proposed complexity can be used to support encoding and data compression. By monitoring the complexity of a text sequence, we can encode certain sections of lower complexity with better compression ratios and with fewer bits. We can also use the proposed complexity to detect data transmission anomalies."}], "references": [{"title": "Modeling complexity in musical rhythm", "author": ["C.Y. Liou", "T.H. Wu", "C.Y. Lee"], "venue": "Complexity", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "Topological entropy of DNA sequences", "author": ["D. Koslicki"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "Spatial representation of symbolic sequences through iterative function systems. Systems, Man and Cybernetics, Part A: Systems and Humans", "author": ["P. Ti\u00f1o"], "venue": "IEEE Transactions on", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1999}, {"title": "A technique for high-performance data compression", "author": ["T.A. Welch"], "venue": "IEEE Computer", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1984}, {"title": "Entropy concepts and DNA investigations", "author": ["O.V. Kirillova"], "venue": "Physics Letters A", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2000}, {"title": "Sequence complexity and DNA curvature", "author": ["A.E. Gabrielian", "A. Bolshoy"], "venue": "Computers & Chemistry", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1999}, {"title": "On the average complexity for the verification of compatible sequences", "author": ["C. Koukouvinos", "V. Pillwein", "D.E. Simos", "Z. Zafeirakopoulos"], "venue": "Inf. Process. Lett", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Making sense of the human genome. In: Structure and Methods: Human Genome Initiative and DNA Recombination", "author": ["E. Trifonov"], "venue": "Volume 1. Adenine Press", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1990}, {"title": "Sequence complexity profiles of prokaryotic genomic 10  sequences: A fast algorithm for calculating linguistic complexity", "author": ["O.G. Troyanskaya", "O. Arbell", "Y. Koren", "G.M. Landau", "A. Bolshoy"], "venue": "Bioinformatics", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2002}], "referenceMentions": [{"referenceID": 0, "context": "Abstract This work uses the L-system to construct a tree structure for the text sequence and derives its complexity [1].", "startOffset": 116, "endOffset": 119}, {"referenceID": 1, "context": "Complexity of the text has been developed with varying degrees of success, [2][3].", "startOffset": 75, "endOffset": 78}, {"referenceID": 2, "context": "Complexity of the text has been developed with varying degrees of success, [2][3].", "startOffset": 78, "endOffset": 81}, {"referenceID": 0, "context": "This work devised a novel measure based on L-system [1] that can compute the structural complexity of a text sequence.", "startOffset": 52, "endOffset": 55}, {"referenceID": 0, "context": "The parameter k is set to 1, k = 1, in [1].", "startOffset": 39, "endOffset": 42}, {"referenceID": 3, "context": "LZW is designed for lossless data compression and is a dictionary-based encoding [4].", "startOffset": 81, "endOffset": 84}, {"referenceID": 0, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 1, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 2, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 3, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 5, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 4, "context": "This string \u201cabcabcabc\u201d will be transformed into an array [1,2,3,4,6,5].", "startOffset": 58, "endOffset": 71}, {"referenceID": 0, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 1, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 2, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 3, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 5, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 4, "context": "By using binary numbers, the array [1,2,3,4,6,5] can be transformed into a binary string \u201d001 010 011 100 110 101\u201d.", "startOffset": 35, "endOffset": 48}, {"referenceID": 1, "context": "Two other measures of complexity, topological entropy (TE) [2] and linguistic complexity (LC) are discussed and compared with the proposed method.", "startOffset": 59, "endOffset": 62}, {"referenceID": 4, "context": "The entropy [5] is defined as,", "startOffset": 12, "endOffset": 15}, {"referenceID": 1, "context": "A new definition [2] for the topological entropy is in the following paragraph.", "startOffset": 17, "endOffset": 20}, {"referenceID": 5, "context": "Linguistic complexity [6, 8] is a measure of the vocabulary richness of a text.", "startOffset": 22, "endOffset": 28}, {"referenceID": 7, "context": "Linguistic complexity [6, 8] is a measure of the vocabulary richness of a text.", "startOffset": 22, "endOffset": 28}], "year": 2013, "abstractText": "This work uses the L-system to construct a tree structure for the text sequence and derives its complexity [1]. It serves as a measure of structural complexity of the text. It is applied to anomaly detection in data transmission. Keyword: text complexity, anomaly detection, structural complexity, rewriting rule, context-free grammar, L-system", "creator": "LaTeX with hyperref package"}}}