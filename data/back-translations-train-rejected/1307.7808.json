{"id": "1307.7808", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jul-2013", "title": "Automated Attack Planning", "abstract": "Penetration Testing is a methodology for assessing network security, by generating and executing possible attacks. Doing so automatically allows for regular and systematic testing. A key question then is how to automatically generate the attacks. A natural way to address this issue is as an attack planning problem. In this thesis, we are concerned with the specific context of regular automated pentesting, and use the term \"attack planning\" in that sense. The following three research directions are investigated.", "histories": [["v1", "Tue, 30 Jul 2013 04:19:25 GMT  (1987kb,D)", "http://arxiv.org/abs/1307.7808v1", "PhD Thesis. 171 pages"]], "COMMENTS": "PhD Thesis. 171 pages", "reviews": [], "SUBJECTS": "cs.AI cs.CR", "authors": ["carlos sarraute"], "accepted": false, "id": "1307.7808"}, "pdf": {"name": "1307.7808.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Carlos SARRAUTE", "Gerardo Richarte", "J\u00f6rg Hoffmann", "Hugo Scolnik", "Marcelo Frias"], "emails": [], "sections": [{"heading": null, "text": "Tesis para optar al t \"\u0131tulo deDoctor en Ingenier\" \u0131a Informa \"ticadelInstituto Tecnolo\" gico de Buenos Aires"}, {"heading": "Automatizacio\u0301n de Planning de Ataques", "text": "Informa \u0301 ticosAuthor: Carlos SARRAUTEDirector: Gerardo RicharteCo-Director: Eduardo BonelliBuenos Aires, ArgentineJulio 2012ar Xiv: 130 7.78 08v1 [cs.AI] 30 Jul 2,013"}, {"heading": "AUTOMATIZACIO\u0301N DE PLANNING DE ATAQUES", "text": "INFORMA \u0301 TICOSPORTS"}, {"heading": "En cumplimiento parcial de los requisitos", "text": "para optar al grado de"}, {"heading": "DOCTOR EN INGENIERI\u0301A INFORMA\u0301TICA", "text": ""}, {"heading": "INSTITUTO TECNOLO\u0301GICO DE BUENOS AIRES", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Buenos Aires, Argentina 2 de Julio de 2012", "text": "c \u00a9 Copyright Carlos SARRAUTE, 2012AUTOMATED ATTACK PLANNINGbyCarlos SARRAUTE"}, {"heading": "Submitted in partial fulfillment of the", "text": "Requirements for the degree of DOCTOR EN INGENIERI \"A INFORMA\" TICAat"}, {"heading": "INSTITUTO TECNOLO\u0301GICO DE BUENOS AIRES", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Buenos Aires, Argentina July 2nd, 2012", "text": "c \u00a9 Copyright by Carlos SARRAUTE, 2012"}, {"heading": "Instituto Tecnolo\u0301gico de Buenos Aires", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "School of Engineering", "text": "Department of Informatics EngineeringThe undersigned hereby confirm that they have reviewed the work entitled \"Automated Attack Planning\" by Carlos SARRAUTE in partial compliance with the requirements for the doctorate in philosophy and have recommended it for acceptance to the Faculty of Graduate Studies. Dated: Supervisor: Gerardo RicharteCo-Supervisor: Eduardo Bonelli Examiner: Jo \u00bc rg HoffmannHugo ScolnikMarcelo Friasii"}, {"heading": "Instituto Tecnolo\u0301gico de Buenos Aires", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "School of Engineering", "text": "FILE: AUTOR: Carlos SARRAUTE"}, {"heading": "TITLE: Automated Attack Planning", "text": "MAJOR SUBJECT: Informatics EngineeringDEGREE: Doctor of PhilosophyCONVOCATION: July 2012Permission is hereby granted to the Instituto Tecnolo'gico de Buenos Aires to circulate the aforementioned dissertation at its discretion, at the request of individuals or institutions, and to have it copied for non-commercial purposes. Author's signature The author reserves other publication rights, and neither the dissertation nor extensive extracts thereof may be printed or otherwise reproduced without the written permission of the author. Author confirms that permission has been obtained for the use of any copyrighted material contained in the dissertation (with the exception of short extracts requiring proper recognition in the scientific letter) and that any such use is clearly recognized.iii"}, {"heading": "Contents", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Abstract x", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Acknowledgements xii", "text": "The number of unemployed in Germany increased slightly compared to the previous year, while the number of unemployed in Germany rose slightly compared to the previous year."}, {"heading": "II Development of a Probabilistic Attack Planner 94", "text": "The personal tasks of the Ministry extend to the areas of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry. The personal tasks of the Ministry."}, {"heading": "III The Search for a Better Model 117", "text": "The personal data of each country is divided into the personal data of each country. The personal data of each country is divided into the personal data of each country. The personal data of each country is divided into the personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country. The personal data of each country."}, {"heading": "Abstract", "text": "Penetration testing (pentesting for short) is a methodology for assessing network security, by generating and executing possible attacks exploiting known vulnerabilities in operating systems and applications. This automatically allows regular and systematic testing without an unaffordable amount of human labor, and makes pentesting more accessible to non-experts. A key question is then how the attacks are automatically generated.One natural way to address this problem is an attack planning problem. In this thesis, we deal with the specific context of regular automated pentesting, and use the term \"attack planning\" in this sense. The following three research directions are examined. First, we introduce a conceptual model of computer network attacks based on an analysis of penetration testing practices. In this thesis, we examine how this attack model can be represented in the PDDL language. Then, we describe an implementation that integrates a classical planner with a penetration testing tool. This allows us to generate attack scenarios and validate these attacks."}, {"heading": "Acknowledgements", "text": "Above all, I would like to thank Gerardo Richarte, with whom I invented the idea and the project of attack planning, and with whom I continue to work on his various instances; and who has had the generosity to guide me in this particular phase that concludes the thesis. I have learned a lot to work with him, but there is one thing I would like to emphasize: Gera has taught me what it means to understand a problem deeply, and to conduct frenetic research, the one that does not let you sleep. Thanks to Emiliano Kargieman, who introduced me to the world of hacking and information security, and who also created the conditions that allowed me to begin the doctoral journey at ITBA, and to conduct the frenetic research with which I had countless conversations and discussions around the White Board. It is true that several ideas of this thesis and all my other research projects form.My appreciation for Eduardo Bonelli."}, {"heading": "Introduction", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1.1 Overview of the Thesis", "text": "In fact, most of them are able to survive on their own without having to move to another world."}, {"heading": "1.2 The Confluence", "text": "The work of this work was done while I was working as a researcher at CoreLabs, the research center of a company that produces software for penetration testing. This is an important part of the context, as it explains the original motivation, the original questions we tried to answer with Gerardo Richarte. 5 The work started with a strong foot in the world of industry, and thanks to my co-supervisor Eduardo Bonelli, it has also gained a foothold in the academic world. For the solutions we developed, we also wondered if this problem has already been investigated? How can our solutions be compared with those of other researchers, and thanks to my co-supervisor Eduardo Bonelli, it has gained a foothold in the academic world."}, {"heading": "Background on Penetration", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Testing", "text": "In this preliminary chapter we give a brief background on computer network interventions and penetration tests. The study of these tools and the need to automate their functionality form the basis for the work of this paper."}, {"heading": "2.1 Computer Network Intrusions", "text": "During a network intrusion, an attacker attempts to gain access to software systems that require authorization (web servers, database servers, accounting systems); the intrusion may be illegal (which is what people usually have in mind when they speak of intrusions), or may be an authorized audit performed by security experts. The latter is called a network penetration test, of which we give a definition hereinafter. Definition 2.1. A penetration test, also known as a pentest, is a method for evaluating the security of a computer system or network by conducting a controlled attack. The process involves an active analysis of the system for potential vulnerabilities that could arise from a poor or improper system configuration, both known and unknown hardware or software failures, or operational weaknesses in the process or technical countermeasures. This analysis is performed from the position of a potential attacker and involves an active exploitation of security gaps that can be exploited by combining the technologies and a multitude of technologies to ultimately achieve penetration."}, {"heading": "2.2 On Vulnerabilities and Exploits", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.2.1 Basic Definitions", "text": "Definition 2.2. A vulnerability (noun) is a bug in a system that, if exploited by an attacker, can potentially compromise the security of the system in question. Also, a vulnerability, a security hole, or a vulnerability called [Arc05]. It can also be an intentional property - in this case, it is called a backdoor. Definition 2.3. Exploiting (verb) means exploiting or manipulating a vulnerability for your own benefit. Definition 2.4. An exploit (noun) is a piece of software, a piece of data, or a sequence of commands that exploit a bug or a vulnerability to cause accidental or unforeseen behavior on a computer software, 9hardware, or an electronic device, often including things like gaining control of a computer system or enabling privilege extension or a denial of service attack."}, {"heading": "2.2.2 Anatomy of an Exploit", "text": "The exploits are the most important actions during an attack. In the literal meaning of \"exploit,\" it takes advantage and uses hidden functionality. In actual network attacks, it executes code that can modify, destroy or expose information. In investigating an exploit, three main components can be distinguished. In the case of Apache Chunked Encoding Exploit, the attack vector is the mechanism the exploit uses to manifest a vulnerability, in other words, how to reach and trigger the bug. In the case of Apache Chunked Encoding Exploit, for example, the attack vector is TCP Connectivity10, which must be set up on port 80 to access the application. In a client-side attack, the attack vector could be an email sent to a user with a specially crafted attachment that triggers a vulnerability in the application that is used to open it."}, {"heading": "Payload", "text": "Once the attacker manages to trigger and exploit a security vulnerability, he gains control of the vulnerable program. Payload is the functional component of the exploit, the code the attacker wants to execute. Classic payloads allow attackers to: \u2022 Add a user account: on Unix systems, this was done by adding a line to the system password file (/ etc / password) or by changing the root password. However, such changes are easy to detect and the attacker's account needs connectivity through legitimate paths (firewalls can block them). \u2022 This classic payload is no longer used. \u2022 System configuration changes: for example, to add a line to inetd (Internet services daemon) to open a port and later connect to the system via the newly opened port (firewalls can block them). \u2022 Opening a shell: The payload consists of opening a shell (a command that an attacker can use to interpret)."}, {"heading": "2.2.3 Syscall Proxy Agents", "text": "We present a solution to the limitations of payload development described in the previous section, called a \"syscall proxy\" and developed by Caceres et al. (see [Cac02] for more details), the idea being to build a kind of \"universal payload\" that allows an attacker to execute any system call on the vulnerable host. By installing a small payload (a thin syscall server), the attacker will be able to execute complex applications on his local host (a fat client), executing all system calls remotely."}, {"heading": "Background on Syscalls", "text": "An application normally interacts with certain resources: a file on a disk, the screen, a network card, a printer, etc. Applications can access these resources via system calls (syscalls for short), which are operating system services that are usually identified with the lowest level of communication between a user-mode process and the OS kernel. 12 Different operating systems implement system services differently, sometimes depending on the architecture of the processor. The main groups are UNIX and Windows.UNIX systems use a generic and homogeneous mechanism to call system services, usually in the form of a \"software interrupt.\" System calls are classified by number, and arguments are passed through either the stack, register, or a mix of both. The number of system services is usually kept to a minimum (about 380 system calls are found in a Linux with kernel version 3.01), as more complex functionality is provided at a higher user level."}, {"heading": "Syscall Proxy", "text": "The resources a process can access, and the type of access it has to them, define the \"context\" in which it is executed. For example, a process that reads data from a file can do so via the open, read, and closed Syscall.Syscall proxying adds two additional layers between the process and the underlying operating system, these layers being the Syscall client layer and the Syscall server layer. 1Updated since June 2012.13Syscall client (on local system), the Syscall client layer acts as a link between the running process and the underlying system services. This layer is responsible for forwarding each Syscall argument and generating a proper request that the Syscall server can understand. It is also responsible for sending this request to the Syscall server, usually via the Internet, and returning the syscall calls to the system (the process calling the Marshall)."}, {"heading": "2.3 Main Steps of an Attack", "text": "Traditionally, the pentesting process is divided into steps, and an attack follows the pattern of the steps described below. Of course, this division into steps is arbitrary and corresponds to good practice in this area (see [AM04,2In computer science, marshalling is the process of transforming the memory representation of an object into a data format suitable for storage or transmission. It is typically used when data has to be moved between different parts of a computer program or from one program to another. 14AR03, Ric03]). In the following chapters, we will show that this methodology can be improved by using planning techniques before executing the attack - and the result may be to mix actions from different steps to perform a faster or more reliable attack."}, {"heading": "2.3.1 Information Gathering", "text": "A successful attack depends on the ability to gather relevant information about the target network, including active IP addresses, operating systems and available services. This step is referred to in the context of pentesting as information gathering. It is also referred to as military reconnaissance and is considered part of the OODA loop 3 or Boyd cycle (see [Boy87, Hig90]). Measures performed at this stage include: \u2022 Network detection: occurs via mechanisms such as ARP, TCP-SYN packets, ICMP echo request, TCP connection and passive detection. \u2022 Port scanning: an exhaustive scan of open and closed ports of all network hosts. \u2022 OS identification: consists of detecting the operating system of a remote host by analyzing its responses to a series of tests. The fingerprint databases of the classic Nmap can be combined with a neural network to precisely coordinate OS responses with signatures."}, {"heading": "2.3.2 Attack and Penetrate", "text": "During this phase, the attacker selects remote exploits and executes them, taking advantage of the data obtained in the Information Gathering step. As defined in Section 2.2.1, an exploit is software that injects code into the memory of the vulnerable system and changes the execution flow so that the system executes the exploit code. As described in Section 2.2.3, the exploit can be thought of as a way to install an agent on a compromised host."}, {"heading": "2.3.3 Local Information Gathering", "text": "The Local Information Gathering step collects information about computers successfully compromised by the attacker. At this stage, the attacker can collect information about the operating system, network configuration, users and installed applications, browse the file system on compromised systems, view permissions obtained, and interact with compromised systems via shells and other applications (such as a remote desktop application)."}, {"heading": "2.3.4 Privilege Escalation", "text": "During the Privilege Escalation phase, the attacker attempts to penetrate deeper into a compromised computer by executing local exploits to gain administrative privileges."}, {"heading": "2.3.5 Pivoting", "text": "After Privilege Escalation, the attacker can use the newly controlled host as a starting point to launch attacks deeper into the network (i.e. using the syscall proxy agent technology introduced in Section 2.2.3), by sending instructions to an installed agent, the attacker can execute local exploits to attack systems internally rather than across the entire network, view the networks a compromised computer is connected to, and launch attacks from any compromised system to other computers on the same network, gaining access to higher-level systems, i.e., the attacker performs the previous steps (Information Gathering and Attacking) by using the new agent.16"}, {"heading": "2.3.6 Clean Up", "text": "The attacker must delete his footprints to avoid being recognized. To this end, all actions performed should minimize the noise generated, for example by making changes only in memory and avoiding writing files to the target's file system."}, {"heading": "2.4 The Need for Automation", "text": "To complete this background for penetration testing, we need to talk about a new type of information security tool that began to develop in 2001: the penetration tests. This type of tool facilitates the work of network penetration testers and makes network security assessment more accessible to non-experts. The most important tools available are: \u2022 Core Impact (since 2001) \u2022 Immunity Canvas (since 2002) 17 \u2022 Metasploit (open source project that began in 2003 and belongs to Rapid7 since 2009) The book [BKB + 07] provides an overview of computer security tools, especially penetration testing. The main difference between these tools and network security scanners such as Nessus, Qualys Guard or Retina is that pentesting frameworks have the ability to launch real exploits for vulnerabilities, which helps to expose the risk by executing an attack in the same way as a real external attacker would exploit it."}, {"heading": "Integrating a Pentesting Tool", "text": "with classical planners 18chapter 3"}, {"heading": "Conceptual Model of Network", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Attacks", "text": "In the first part of this thesis we present the basic model of penetration testing and a complete implementation that integrates a planner system with a penetration test frame and a network simulation tool."}, {"heading": "3.1 Introduction", "text": "Our work on the attack planning problem applied to pentesting began in 2003 with the construction of a conceptual model of an attack, distinguishing assets, actions and objectives [FNRS03, Ric03, AR03]. In this attack model, the assets represent both information and the changes in the network that an attacker must obtain during an intrusion, while the actions are the basic steps of an attack, such as operating a particular exploit against a target host. This model is designed to be realistic from an attacker's point of view, and considers the fact that the attacker has an initial incomplete knowledge of the network, and therefore information gathering should be considered as part of the attack. This model also has a theoretical value: \"We understand what we can build.\" Our motivation was to provide the information security community with a deeper and more detailed model of attacks against computer networks. It turned out that such a model is necessary for communicating with other communities, such as the planning and ideas."}, {"heading": "3.2 Assets", "text": "Definition 3.1. An asset can represent everything an attacker needs to gain during an attack. Specifically, it can represent the knowledge that an agent has about a real object or property of the network. In the following, we describe some examples of assets (and their parameters): AgentAsset (Agent, Capabilities, Host). An AgentAsset represents an agent with a collection of capabilities running on a host.BannerAsset (Banner, Host, Port).A BannerAsset represents the banner that an agent receives when he attempts to connect to a particular port on a host.OperatingSystemAsset (os, Host). An OperatingSystemAsset represents the knowledge that an agent has about the operating system of a host."}, {"heading": "IPConnectivityAsset (source, target).", "text": "TCPConnectivityAsset (source, destination, port): A TCPConnectivityAsset represents the fact that an agent is able to establish a TCP connection between a source host and a specific port of a destination host.In the PDDL language, assets are presented as predictors (see Section 4.3 for details of the PDDL representation).21"}, {"heading": "3.2.1 Representations and Assumptions", "text": "In chapters 4, 7 and 8 we describe different representations of this general model. Different assumptions can be made about the model components in order to make different trade-offs between the complexity of the resulting planning problem and the realism of the model. In the simpler case, the assets are deterministic and can be translated as theses. However, this assumption can be loosened with:"}, {"heading": "Probabilistic Assets", "text": "This allows us to show properties that the attacker believes to be true with a certain probability or negative properties (which the attacker knows to be false), as explained in Chapters 7 and 8. For example, an action that uses banners to determine the operating system of a host (OSDetectByBannerGrabber) may result in an OperatingSystemAsset os = linux with probability = 0.8 and a second with os = openbsd and probability = 0.2. Another example: an ApplicationAsset host = 192.168.13.1 and an application = # Apache with probability = 0 means that our agent has determined that this host is not running Apache."}, {"heading": "Level of Trust", "text": "Problem 3.2. Calculate the loss of trust for each asset as a function of time. When we first looked at this problem, we had no idea how to solve it. A few years later, we finally arrived (with Hoffman and Buffet) at the POMDP model, in which this question can be formulated precisely. In the POMDP formulation (examined in Chapter 8), the attacker does not directly observe the state of the target network, but observes a probability distribution over the states of the system, which is referred to as the state of faith (see Definition 8.11). The problem of how to assess the original state of faith (and thus an answer to problem 3.2) is considered in Section 8.4.4."}, {"heading": "3.2.2 The Environment Knowledge", "text": "Environmental knowledge is a collection of information about the computer network that is under attack or hosts an agent. Of course, this information is represented by assets (or predicates in the PDDL language), and by misuse of language we can speak of the environment, not of the environmental knowledge. At the beginning of an attack, the environment contains at least one AgentAsset: the localAgent that triggers the attack. The environment plays an important role during the planning phase and during the execution phase of an attack, as it continuously returns the behavior of the agent. Also, note that each agent has its own environmental knowledge and that the exchange of assets would be an important part of communication between autonomous agents. As we will discuss in Section 4.3, the input for a planner is divided into two files: the domain file that contains the PDDL representation of the attack model (in particular the actions available to the attacker); and the problem file that a collection of pre-tells the target state of the initial state of the PDDL file is therefore the problem 6."}, {"heading": "3.3 Goals", "text": "A goal can be quantified and linked to a list of measures that can complete its assets. In the 4.6 definition of a planning problem, the goals are represented by a number of states Sg S. Although the goals can be explicitly enumerated, in the earlier stages of our research we found it more convenient to consider quantifiers to simplify the representation.23"}, {"heading": "3.3.1 Goal Quantifiers", "text": "We looked at three types of quantifiers: Any, All, and AllPossible. An example illustrates their importance: Consider that PortAsset has attributes (Host, Port, Status), which means: Asset = PortAsset (Host = 192.168.13.1, status = # open), Quantifiers = (Any # port from: 1 to: 1024): Find an open port on the host 192.168.13.1 between ports 1 and 1024. To achieve this goal, an action like PortScan begins to examine the host's ports 192.168.13.1 until it finds an open port (completes the PortAsset and returns a success signal) - or reaches port 1024 (and returns a failure signal). Asset = ExplodingAsset (Host = 192.168.13.1, status = # open), Quantifiers = (All # port from: # (21,22,23.80) Port # Finds and returns all ports (and)."}, {"heading": "3.4 Actions", "text": "These are the basic steps that constitute an attack. Examples of actions are: Apache Chunked Encoding Exploit, WuFTPglobbing Exploit, Banner Graber, OS Detect By Banner, OS Fingerprint, Network Discovery, IP Connect, TCP Connect. In this section we look at the most important attributes of an action.24"}, {"heading": "3.4.1 Action Goal", "text": "An action has a goal: if it is successfully performed, the action completes the asset associated with its goal. It is also common to talk about the result of an action (e.g. to expand access, obtain information, corrupt information, use resources, refuse service). In Chapter 4, we will formalize the concept of action. In particular, in Definition 4.8, we will define a series of actions A and for each action A the effects of a. Conceptually, with the idea of the action goal, we only consider the expected result of the action. Undesirable results and other side effects fall into the category of noise (see Section 3.4.4). When formalizing chapter 4, the expected result and undesirable results are collectively considered as the effects of the action."}, {"heading": "3.4.2 Action Requirements", "text": "Requirements for an act are assets that must be obtained before the act under consideration can be performed. Requirements are the equivalent of child nodes in [Sch00] and sub-targets in [MEL01] and [TLFH01]. Therefore, an abstract act has the information about what assets it can fulfill and what assets it needs before it is performed. These relationships are used to construct the attack graph by linking the actions to the assets they need (see also Section 7.5.1, where a similar graph is constructed in the context of probabilistic planning). Figure 3.1 shows an example attack graph in which the actions are concatenated as red boxes and assets as blue ellipses. This is a multi-layered graph with changing layers of actions and assets. The figure also illustrates the relationship between the actions and their requirements in the formalization of Chapter 4 (the requirements for an act are defined as a)."}, {"heading": "3.4.3 The Execution Phase (or the Action Itself)", "text": "The information about the results and requirements of the actions is used during a planning phase to obtain an attack plan \u03c0 (see definition 4.11). Once the attack plan is available, it is used to control a penetration test frame within which the actions of the plan \u03c0 are effectively executed on the target network. During this execution phase, the actual code of the actions (e.g. the code of exploits or modules for obtaining information) is executed by the agent. An interesting point to mention here is that the action can be executed in a real network or in a simulated network (with simulated hosts and network topology). The difference between the work in these two environments will only become apparent during the execution phase, making our framework easily adaptable for both real and simulated attacks. Chapter 6 describes a network simulator specifically designed to provide realistic simulations of cyber attacks."}, {"heading": "3.4.4 Noise Produced and Stealthiness", "text": "The execution of the measure will cause noise: network traffic, protocol lines in IDS, etc. Given the most complete possible list of network sensors, we need to quantify the noise generated in relation to each of these sensors. Knowledge of the network configuration and which sensors are likely to be active will allow us to calculate a global estimate of the noise generated by the action. We will return to the question of refining the cost of the measures in Section 7.2.2 of Chapter 7, in which we reformulate the current attack model within the framework of probable planning. In relation to each network sensor, the noise generated can be divided into three categories: non-removable noise, noise that can be cleaned in the event of a successful (or further successful) action, noise that can also be cleaned in the event of a failure. Thus, we can also estimate the noise remaining after cleanup."}, {"heading": "3.4.5 Running Time and Probability of Success", "text": "The expected duration and probability of success depend on the nature of the action, but also on the environmental conditions, so their values must be updated each time the active substance receives new information about the environment. These values are necessary to make decisions and choose a path in the chart of possible actions. Together with secrecy, these values represent the cost of the action and can be used to assess action sequences, which will be discussed further in Chapter 7 in the context of probabilistic planning.Due to the uncertainties inherent in the execution environment, these values can be considered dependent on the faith of the active substance in the target network (we will discuss this in the POMDP model of Chapter 8)."}, {"heading": "3.4.6 Exploited Vulnerability", "text": "The information about the exploited vulnerability is not required by the attacker, but is useful for classifying and analyzing detected intrusions. This vulnerability can be: \u2022 Software vulnerability: a design or implementation error (buffer overflow, format string, race condition) \u2022 Network configuration vulnerability.27 \u2022 Trust relationship: This refers to higher-level, non-autonomous attack modules: hacking a software provider, getting an insider into a software provider, inserting backdoors into an open source project."}, {"heading": "3.5 Agents", "text": "We can imagine the actions as the verbs in a sequence of sentences describing the attack, and the agents will then be the subject of these verbs. Of course, an attack is always initiated by human attackers, but in the course of the attack, actions are typically carried out by software agents."}, {"heading": "3.5.1 Human Attackers", "text": "There are different types of attackers. They can be roughly classified as: \u2022 script kiddies who attack more or less arbitrarily using standard tools downloaded from the Internet; \u2022 hackers who attack computers for challenges, status or research; \u2022 security auditors (pin testers) who evaluate the security of a network; \u2022 government agencies and criminal organizations who have access to the highest skill levels and resources available to carry out attacks. The way we model these different types of attackers is determined by the attack parameters: stealthiness, non-traceability, expected duration, expected success; and a skill level given by the collection of measures available to the attacker. A scriptkiddy will not worry about stealthness or non-traceability. His attacks will have a low expected success and require a low skill level. On the other hand, a government agency will use maximum stealthiness, non-traceability, non-traceability, and non-traceability to the attacker with no expectation of traceability."}, {"heading": "3.5.2 Software Agents", "text": "Generally speaking, the execution of an action requires the execution of machine code and therefore requires a software agent A to execute that code. This is a generalization of the 2.5 definition, which refers to agents in the context of a penetration framework such as \"Core Impact.\" The command to execute that action could come from the agent himself, from another software agent, or from a human attacker: we will not distinguish between these cases, but merely say that the action was carried out by agent A. A software agent can take several forms: script, toolkit, or other types of program. Let's point out the autonomous agents who are able to make decisions and continue the attack without human intervention."}, {"heading": "3.5.3 Communication between Agents", "text": "This framework supports the interactions between agents working together to achieve the goal. Agents establish communication channels among themselves for the exchange of knowledge, information gained and missions to be carried out. For example, each agent has a collection of actions. Agents can learn new actions through the communication channels and exchange actions with each other. Communication between human attackers can take place through unlimited types of channels (direct interaction, telephone, email, chat, IRC, written mail). We will not go into detail here. Examples of communication channels between software agents are POP3 and SMTP, HTTP / HTTPS, DNS, TCP and covert channels such as Loki."}, {"heading": "3.5.4 Agent Mission", "text": "A scenario is given by a \"root agent\" who plans the attack and then gives orders (to perform actions) to the other agents, creates new agents if necessary, and asks the agents for feedback on the results of the actions in order to decide further steps. Another scenario is when the root agent delegates responsibility to the other agents and assigns them missions at a higher level. To accomplish the mission, the agent must carry out his own planning and communicate with other agents. This scenario29 probably occurs when stealth is a priority: communication is very expensive and it becomes necessary to rely on the agents to carry out their missions without feedback (or the slightest feedback or delayed feedback due to intermittent communication channels)."}, {"heading": "3.6 Building an Attack", "text": "An attack is a group of agents who perform a series of actions in order to reach a target (or a set of targets). Note that this target may change over the course of the attack. The target is the logical or physical entity that is the target of the attack. Normally, the target is a computer or a computer network or information hosted on a computer. The target may also change over the course of the attack. It is also possible that an attack has no specific target at all (for example, a script kiddy that executes a particular exploit against all computers it reaches until it is successful).The complete graph of all combinations of actions determines what targets we (as attackers) can achieve. Given the complete graph of possible actions, the structure of an attack is to find a way to the target (which specifically means finding a way through the physical networks to reach the target)."}, {"heading": "3.6.1 Attack Parameters", "text": "We will try to find the best way to reach the target, and to evaluate this, we must take into account the attack parameters: non-traceability, tolerated noise, expected success, execution time, zero daylight. These parameters have initial values for the whole attack, but they can vary from agent to agent, for example, an agent can create other agents with a different profile. Non-traceability: refers to the ability to disguise the origin of the attack. It could also be called \"deniability.\" To achieve non-traceability, special modules must be run that deploy intermediate agents (we call them \"pivots\" or stepping stones) between the original agent and the agents executing the target or part of the object."}, {"heading": "3.6.2 Evaluating Paths", "text": "A path is a sequence of actions (in a particular order and without branching). In order to be able to choose between different paths, we have to evaluate the paths according to the attack parameters: the probability of success, the likely noise generated, the runtime and the traceability. For the probability of success, we consider the success of each action to be independent of the previous ones, and that all actions in the paths are necessary, so the probability of success of the path is the product of the probability of success of each action. For the duration of the path, we consider three time estimates (minimum, average, maximum) that we have for each module, and add them up to obtain the minimum, average and maximum runtime of the path. The stealth of the path, which we define as the probability of not being discovered, decreases with each action performed. As with the probability of success, we consider it independent and calculate the stealth of the path as the product of petricity."}, {"heading": "3.7 Applications", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.7.1 Attack Planning", "text": "This is the main application we are considering in this work and which is examined in more detail in chapters 4, 5, 7 and 8."}, {"heading": "3.7.2 Simulations and Analysis of Network Security", "text": "As we mentioned in Section 3.4, our framework can be used to build attacks against a simulated network. Of course, the quality of this simulation depends on how accurately we simulate the machines. By using VMwares, we get a slow and precise simulation, for faster simulations a trade-off between accuracy and speed.The system administrator can simulate different types of attackers by using different attack parameters and different collections of available actions, and evaluate the response of his network to these attackers. For example, he can start with an attacker with a minimal portfolio of actions and gradually add actions to the arsenal of his simulated attacker until there is a successful attack that is not recognized by IDS. This gives him an indication of which attack actions he should defend his network again. Also, consider that the system administrator has a number of measures that make certain attack actions less effective (within our framework, a measure can reduce the likelihood of success of an attack or increase the noise he generates, for example by adding a huge system)."}, {"heading": "3.8 Related Work", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.8.1 Description of Security Incidents", "text": "In [HL98] Howard and Longstaff describe an event taxonomy that was the result of a project to establish a \"common language\" in the field of computer security. In [LJ97] Lindqvist and Jonsson also work on the classification of intrusions. We try to use the high-level terms suggested by Howard and Longstaff, in particular the attributes: vulnerability, plot, goal, outcome, and objectivity. A common flaw of these classifications is that they adopt exclusively the standpoint of the system owners or sensors for detecting intrusions, but an attack always consists of several steps, some of which may be invisible to the sensors. To the attributes considered in [HL98] and [LJ97] we will add some attributes that are only relevant to the attacker (or the risk assessment team)."}, {"heading": "3.8.2 Attack Models", "text": "In [Sch99] and [Sch00], Bruce Schneier proposes to describe attacks on a system using \"attack nodes,\" where each node requires the execution of child nodes and the root node is the target of the attack. There are two types of nodes: OR nodes and AND nodes. In [TLFH01], the authors propose an attack specification language that extends the attack node model. Each node has preconditions (system environment properties that facilitate the execution of the attack node), subtargets (these are the child nodes), and postal conditions (changes in systems and environments). [MEL01] is also based on the attack node model. Attack patterns and attack profiles are added to the model. The goal of these authors is to provide a means of documenting intrusions; their models are purely descriptive and do not allow the construction or prediction of new attacks."}, {"heading": "3.8.3 Attack Graphs", "text": "Because the actions have requirements (prerequisites) and outcomes, a graph of the actions / assets that lead to that goal can be created for a target. This graph refers 33 to the attack graphs studied in [PS98, JNO05, NEJ + 09] and many other studies. In [LI05], the authors analyzed past essays on attack graphs and noted that \"the first major limitation of these studies is that most attack graphs were only able to create attack graphs for small networks with less than 20 hosts.\" For example, Figure 3.2 shows an attack graph for a small network consisting of 14 hosts, from [NJ04]. This figure illustrates the fact that attack graphs quickly become too complex to display their integrity, whether visually or as a data structure in the computer's memory. In [SPG98] and [JWS02], the authors suggest the use of attack graphs to determine the security of networked systems."}, {"heading": "3.9 Summary", "text": "In this chapter, we presented a conceptual model for evaluating the cost of an attack, describing the location of operations, targets, missions, actions, plans and assets involved in cybernetic attacks. One contribution of this model concerns the cost of actions. We show that the cost is given by a tuple of values: not only the likelihood of success, but also the stealth (which depends on the noise generated), time-consuming, non-traceable and not up-to-date. The noise generated is particularly relevant, and when we first published these ideas, we had not seen it in other models.3 These dimensions, which are considered attack parameters, also allow us to model different types of attackers. The most important application of this model is automated planning. Integrated into a tool such as Core Impact, it leads the way to automated penetration tests. Used against simulated networks, it is a tool to work on assessing the actions of a network that has opened up a set of questions for this model, such as the one that:"}, {"heading": "Planning Representations", "text": "Along this thesis, we will develop several presentations of the attack model, which we have informally presented in Chapter 3. In order to understand and formulate the differences between these presentations in detail, we will consider them in the general model of the transitional state systems and explain the respective relaxed assumptions (in Section 4.1). Another important point of this chapter is how the attack model of Chapter 3 can be presented in the language of the PDDL. To define this representation precisely, we first recall the simpler presentations based on set theory and first-order logic in Section 4.2. Then, in Section 4.3, we will provide a detailed description of the PDDL representation of the attack plan problem. We will conclude this chapter with two exercises on the expressivity of this presentation and the complexity of the corresponding planning problem."}, {"heading": "4.1 Basic Formalization", "text": "To formalize the attack model, we use a general model of dynamic systems, the model of transitional state systems [GNT04]. Below, we give the basic definition, then give a list of common assumptions and discuss how they can be loosened to obtain different versions of the model."}, {"heading": "4.1.1 Formalization as a Dynamic System", "text": "Definition 4.1. In general, a state transition system is a tuple \u03a3 = < S, A, E, \u03b3 > where: \u2022 S = {s1, s2,...} is a finite set of states; \u2022 A = {a1, a2,...} is a finite set of actions; 3536 \u2022 E = {e1, e2,...} is a finite set of events; \u2022 \u03b3: S \u00b7 A \u00b7 E \u2192 2S is a state transition function. A state represents a \"state of the world,\" the combined knowledge that actors have about the environment (network topology, operating systems, ongoing services, agent distribution, etc.). Actions are transitions controlled by the plan executor. If A is an act and vice versa (s, a) 6 = 4.1, the act a is applicable to the state. Events are transitions that are conditional: instead of or correspond to the internal dynamics of the system."}, {"heading": "4.1.2 General Assumptions", "text": "Below is a list of common assumptions for modelling planning problems that limit the complexity of the problem."}, {"heading": "Assumption A1 (Fully Observable \u03a3).", "text": "The system \u03a3 is fully observable, the attacker has complete knowledge of the state \u03a3."}, {"heading": "Assumption A2 (Deterministic \u03a3).", "text": "For each State and each act a, | \u03b3 (s, a) | \u2264 1. If an act is applicable to one State, its application brings a deterministic system to a single other State."}, {"heading": "Assumption A3 (Static \u03a3).", "text": "System \u03a3 is static when the event set E is empty, and the system remains in the same state until the controller performs an action."}, {"heading": "Assumptions A4 (Restricted Goals).", "text": "The scheduler only handles restricted goals specified as explicit target states sg or as a set of target states sg. The goal is any sequence of state transitions ending at one of the target states. Advanced goals such as states that must be avoided and limitations on state paths or power functions are neither handled nor handled under this premise.37"}, {"heading": "Assumptions A5 (Sequential Plans).", "text": "A solution plan for a planning problem is a linearly ordered finite sequence of actions."}, {"heading": "Assumptions A6 (Implicit Time).", "text": "Actions and events have no duration. In systems of state transition, time is not explicitly represented."}, {"heading": "Assumptions A7 (Offline Planning).", "text": "The planner does not take care of any change that might occur during the planning process."}, {"heading": "4.1.3 Extending the Model", "text": "Several models can be obtained by relaxing some of these restrictive assumptions. In the development of the thesis we will make the following relaxations to obtain different versions of the model."}, {"heading": "Relaxing Assumption A1 (Fully Observable \u03a3).", "text": "If the system is partially observable, then the observation of \u03a3 will not fully clarify what state \u03a3 is in. For each observation o, there may be more than one state s that produces the observation o. This situation will be investigated with the model based on partially observable Markov decision processes (POMDP) in Chapter 8."}, {"heading": "Relaxing Assumption A2 (Deterministic \u03a3).", "text": "In a non-deterministic system, each action can lead to different possible states, so the planner must consider alternatives. Normally, non-determinism also requires adoption A5, as a plan must encode ways to deal with alternatives. Non-deterministic systems are examined in Chapter 7 on probabilistic algorithms and in Chapter 8 on the POMDP model."}, {"heading": "Relaxing Assumption A4 (Restricted Goals).", "text": "Expanded objectives allow the planner to set requirements not only about the final state, but also about the states traversed, such as critical states to be avoided, states the system should go through, states in which it should remain, and other limitations on its trajectories. Another option is to define a benefit function to be optimized. This is used in the POMDP model, with the planner's goal being to maximize the expected reward."}, {"heading": "Relaxing Assumption A5 (Sequential Plans).", "text": "A plan can be a mathematical structure that can be richer than a simple sequence of actions. A loose assumption A5 is often required when other assumptions are relaxed, as we have seen in the case of non-deterministic systems (assumption A2). In the POMDP model, the output of the planner is a policy that determines which action should be performed for each state of belief."}, {"heading": "Relaxing Assumption A6 (Implicit Time).", "text": "To handle time explicitly, an extension of the model is required: In the PDDL model (Chapter 5), the execution time of an action is defined as a numerical effect of a. In the POMDP model (Chapter 8), the execution time of an action a is encoded in the reward function r (s, a)."}, {"heading": "4.1.4 Number of States", "text": "We will give some estimates of the size of the state space S in several examples below. Example 4.2. To get an overview of the number of states involved, let's start with a very simple example. Let's be a scenario with M machines. Let's assume that the only information the attacker can get about each machine is its OS information. The number of states in this scenario is | S | = 2M.Example 4.3. To make the previous example a little more realistic, let's assume that for each machine there is m k-bits of information that the attacker can get: the knowledge of the operating system and the k \u2212 1 applications that can be run on that machine. The number of states in this scenario is | = 2M. To make the previous example a little more realistic, let's assume that for each machine there is k-bits of information that the attacker can get: the knowledge of the operating system and the k \u2212 1 applications that can be run on that machine."}, {"heading": "4.2 Classical Planning Representations", "text": "The importance of classical planning is given by the fact that there are several general purposes and efficient planners for this environment.40 In this sense, classical planners can be considered the \"hammers\" of planning that are better suited for real-world applications [Gef10].Definition 4.5. A limited system of state transition is one that meets the restrictive assumptions < A1,.., A7 > given in Section 4.1.2. It is a deterministic, static and fully observable system of state transition with limited goals and implicit time. Such a system is one that meets the restrictive assumptions < A1,. Since the system is deterministic when applicable to s, a) it contains a state s. \"To simplify the notations, we will say that vice versa (s, a) < s\" instead (s, a) is a problem when a. \""}, {"heading": "4.2.1 Set-Theoretic Representation", "text": "This representation is more concise and readable than the enumeration of all states and transitions. It can be precisely formulated and provides the basis for classical representation. We remember the basic definitions of {{} {{}} {{{}} {{{}} {{{}}} {{2}, {2}, {1}, {2}, {2}, {2}, {2}, {2}, {2}, {2}, {2}, {2}, {2), {2, {2}, {2, {2, {2,.}, {2,. The state s is a subset of L. The state s tells us which propositions are currently held. If p, then p, then p is represented in the state of the world. \u2022 Each action is a triple subset of L. We will asa (a), (a), effects (a), one (a), one (d), one (d), one (d), one (d), one (d), one of the conditions."}, {"heading": "State Reachability", "text": "We give below some basic definitions and facts relating to the attainability of the state. Definition 4.13. If s is a state, then the group of all successors of s is (s) = {\u03b3 (s), a) and a applies to s (s) definition 4.14. Let us consider the group of states reachable from s as a temporary closure: B (s) = B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s), B (s). (4.1) Definition 4.15. An act a shall be relevant to a goal g if and only if g (a) has an effect + (a) 6 = B (s) and g (s). In other words, these conditions state that an act can help to create a state in Sg = S (s). Definition g is relevant only if (a) has an effect + (a) and (a) is required in relation to (a)."}, {"heading": "4.2.2 First Order Logic Representation", "text": "This representation generalizes the set theory representation by means of logical notation of the first order. Let's start with a language of the first order (L), in which there is a finite number of predicate symbols and constant symbols. A state is a set of basic atoms of the L.44Definition 4.17. A planning operator o is a triple (name (o), predicate (o), effects (o) whose components are: \u2022 The name of the operator, name (o), is a syntactic expression of the form n (x1,..., xk), where n is a unique symbol and x1., xk are all variable symbols that occur somewhere in o. \u2022 The preconditions and effects are generalizations of set theory preconditions and effects: instead of sets of propositions they are sets of propositions and negations of atoms."}, {"heading": "4.3 The PDDL Representation in Detail", "text": "We use an extension of the classical representation that allows the use of typed variables and relationships. This extension improves the efficiency of a planning system by reducing the number of ground instances to be created. Specifically, we use the PDDL planning language notation [M + 98, FL03]. The PDDL description language serves as a bridge between the pentesting tool and the planner. Since explosions have strict platform and connectivity requirements, failure to precisely express these requirements in the PDDL model would lead to plans that cannot be executed against real networks. This forces our PDDL representation of the attack planning problem to be quite verbose. In addition, we use the optimization capabilities of planners who understand numerical effects1, and let the PDDL actions affect various metrics commonly associated with penetration tests, such as runtime, probability of success or possibility of detection (Stealth) the PDL will then focus on the details of the PDDL presented to us in the file that includes the description of the PDDL and the solution."}, {"heading": "4.3.1 Types", "text": "Table 4.1 shows a list of the types we use. Half of the object types are dedicated to the detailed description of the host operating systems, since the successful execution of an exploit depends on the peculiarities of the OS.1 Numerical effects allow actions in the PDDL representation to increase the value of various metrics defined in the PDDL scenario.46 The planner can then be asked to find a plan that minimizes a linear function of these metrics.46"}, {"heading": "4.3.2 Predicates", "text": "Since exploits also have non-trivial connectivity requirements, we have opted for a detailed representation of network connectivity in PDDL. We need to be able to express how hosts are connected to networks, and the fact that exploits require both IP and TCP or UDP connectivity between the source and destination hosts, usually on a specific TCP or UDP port. These predicates express the various forms of connectivity: (connected _ to _ network? s - host? n - network) (IP _ connectivity? s - host? t - host) (TCP _ connectivity? s - host? p - port) (TCP _ Listen _ Port? h - host? p - port) (UDP _ listen _ port? h - host? p - port) (IP _ connectivity? s - host? t - host? p - host) (TCost _ s - OS - OS? p? p h - h h - h - host? p - h) (TCOS - OS? s - OS? p? p)"}, {"heading": "4.3.3 Actions", "text": "In fact, it is as if most of them will be able to abide by the rules they have set themselves. (...) It is not as if they are able to change the rules. (...) It is as if they are able to change the rules. (...) It is not as if they are doing it. (...) It is not as if they are doing it. (...) It is not as if they are doing it. (...) It is as if they are doing it. (...) It is not as if they are doing it. (...)"}, {"heading": "4.3.4 An Attack Plan", "text": "The objective of the scenario is to compromise Host 10.0.5.12 on the target network, which is similar to the test network we will describe in detail in Section 5.3. The plan requires four pivotal steps and performs a total of five different exploits. The localagent object represents the pentesting framework running on the user / attacker's computer. The exploits shown are real exploits that are currently in the pentesting framework.0: Mark _ as _ compromised localagent localhost 1: IP _ connect localhost 10.0.1.1 2: TCP _ connect localconnect 10.0.1.1 port80 3: Phpmyadmin Server _ databases Remote Code Executionlocalhost 10.0.1.14: Mark _ as _ compromised localagent localhost 1010101010host 1: IP _ connect localhost 10.0.1.1 localhost 10.0.1.1 high IP port80 3: Phpmyadmin Server _ databases Remote Executionhost Code 10.0.Mark 10.0.14 10.Mark 10.10.10es 10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.0.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10.10"}, {"heading": "4.4 Expressivity of the PDDL Representation", "text": "The answer to that question is, \"I don't think we're going to be able to get the problem under control.\" The answer to that question is, \"I don't think we're going to be able to get the problem under control.\" The answer is, \"I don't think we're going to get the problem under control.\" The answer is, \"I don't think we're going to get the problem under control.\" The answer is, \"I don't think we're going to get the problem under control.\" The answer is, \"I don't think we're going to get the problem under control.\""}, {"heading": "4.5 The Hypergraph Representation", "text": "In this section we will briefly discuss the hypergraph representation and use it to prove that a version of the attack planning problem is NP-hard. Of course, this is not surprising, and the following section can therefore be considered an exercise carried out in the early stages of our research."}, {"heading": "4.5.1 Basic concepts", "text": "We remember some basic definitions.Definition 4.23. A directed hypergraph, or simply hypergraph, is a pair of H = (V, E), where V is the set of nodes and E is the set of hyperbows. A hyperbow is a pair of e = (T (e), h (e))), where T (e) V is the tail of e, while h (e) V is the head of e.The nodes represent the attack activities.The actions are modeled as hyperbows. The assets contained in the tail T (e) of an action are the requirements.The head of the hyperbow is the result of the action.56Action templates are immediately available.Definition 4.24. A directed hyperpath or simply hyperpath, PSt from the source set S V to the target node t V is a minimal accyclic sub-hypergraph of H containing the nodes in S and the node, so that each node has a hyperbow (except the S)."}, {"heading": "4.5.2 NP-Hardness of the Hypergraph Formulation", "text": "s tree problem) Example: A directed graph G = (V, E), a node s-V, a subset of nodes K = {i1,..., ik} and weights w: A \u2212 \u2192 Z +. Task: Find a directed subtree T, rooted at nodes s and with minimal weight, which all nodes in K.We specify the following version of attack planning problem 4.26. (Attack planning, hypergraph formulation) Example: A directed subtree G = (V, E), nodes s, t and weights w: E \u2212 \u2192 Z +. Task: Find the subhypergraph G1 of minimum weight of a node c."}, {"heading": "Integration with Classical", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Planners", "text": "Assessing network security is a complex and difficult task. Attack diagrams have been proposed as a tool to help network administrators understand the potential weaknesses of their networks (see Section 3.8). However, one problem has not yet been solved in previous work on this topic, namely the actual execution and validation of attack paths resulting from the analysis of the attack diagram. In Chapter 4, we presented a complete PDDL representation of an attack model. Later in this chapter, we will introduce an implementation that integrates a planner into a penetration test tool, allowing us to automatically generate attack paths for penetration test scenarios and validate these attacks against the real target network by executing the corresponding actions - including exploits. In Section 5.3, we will introduce an algorithm for transforming the information contained in the penetration testing tool into the planning area, and we will show how the scalability update diagrams can be solved with the help of attack diagrams."}, {"heading": "5.1 Attack Planning in the Real World", "text": "In medium-sized networks, the construction of complete attack diagrams quickly becomes unfeasible (their size increases exponentially with the number of machines and actions available).To solve the problem of attack planning, one proposed approach [SW08, Sar09a] is to translate the model into a PDDL representation and use 5758 classic planning algorithms to find attack paths. Planning algorithms manage to find paths in the attack diagram without constructing it completely, which helps to avoid the combinatorial explosion [BF97].A similar approach was presented at SecArt '09 [GG09], but the authors \"model is less meaningful than the one used in this thesis, since their goal was to use the attack paths to create a minimal attack diagram, and not carry out these attacks against real networks. In the following sections, we present a realization of these ideas. We have developed modules that integrate the resulting pentesting model back into an external framework and the planning framework."}, {"heading": "5.2 Architecture of our Solution", "text": "In this section, we describe the components of our solution and how they fit together to automate an attack. Figure 5.1 shows the relationship between these different components. The penetration test system is a tool that allows the user / attacker to execute exploits and other pre / post exploitation modules against the target network. Our implementation is based on Core Impact1. The planner is a tool that uses as input the description of a domain and a scenario in PDDL2. The domain contains the definition of the available actions in the model, 1As mentioned in the previous section, Metasploit is an open source alternative. 2See [FL03] for a description of the PDDL planning language. 59and the scenario contains the definition of the objects (networks, hosts and their properties) and the target that must be solved.The attack workspace contains the information about the current attack or penetration test. Specifically, the discovered networks and hosts, information about their future operating systems, the open ports we do not need, and the information about the execution of these machines, and the types of services we require in order to generate them."}, {"heading": "5.2.1 The \u201cTransform\u201d Algorithm", "text": "The transformation algorithm generates the PDDL representation of the problem of attack planning, including the initial conditions, the operators (PDDL actions), and the target. From the pentesting framework, we extract the description of the operators, in particular the requirements and results of the exploits that will make up most of the actions available in the PDDL representation, which is encoded in the Domain.pddl file, along with the predicates and types (which depend only on the details of our model).From the attack workstation, we extract the information that represents the initial conditions for the planner: networks, machines, operating systems, ports, and ongoing services. These are encoded in the proble.pddl file, along with the target of the attack, which is usually the compromise of a particular machine.A common feature of the pentesting frameworks is that it provides a 60-incomplete view of the attacked network. The pentester must view the structure of the network using the information that everyone sees in that machine's connectivity."}, {"heading": "5.2.2 The Planner", "text": "The advantage of using the PDDL language is that we can experiment with different planners and determine which model best fits our particular problem. We have evaluated our model with both SGPlan [CWH06] and Metric-FF [Hof02]. The planner is executed within the pentesting framework, as a plug-in module of the framework we call PlannerRunner. The result of the planner is a plan, a sequence of actions that lead to the completion of the goal when all the measures are successful. We make this distinction because even with proven exploit code not all the exploits started are successful. The plan is given as feedback to the pentesting framework and executed against the actual target network."}, {"heading": "5.3 Performance and Scalability Evaluation", "text": "This model, and its representation in the PDDL, is to be used to plan attacks on real networks, and run them with a pentesting framework. To verify that our proposed solution can take up to the domains and scenarios we need to address in the real world, we are conducting extensive performance and scaling tests - to see how far we can take the attack model and PDDL representation with the current planners. We are focusing our performance assessment on four metrics: \u2022 Number of machines in the attacked network \u2022 Number of explosions available in the pentest row \u2022 Number of individual predicates that need to be met in order to achieve the goal."}, {"heading": "5.3.1 Generating the Test Scenarios", "text": "We tested both real and simulated networks and generated the test scenarios using the same pentesting framework that we would later use for the attack. For the large-scale tests, we used a network simulator [FMOS09]. This simulator allows us to construct sizeable network7, but still view each machine independently and, for example, execute different system calls in each of them. The simulator integrates tightly into the pentesting framework, to the point where the frame ignores the fact that the attacked network is simulating and not real. This allowed us to use the pentesting tool to perform all the steps of the test, including information gathering during the attack. Once the information collection was complete, we converted the attack workspace into PDDL by using our transformer tool and are not real. 7We tested up to 1000 nodes in the simulator, in which two types of networks are connected for the performance evaluation of the machines are the number of operators connected to each other."}, {"heading": "5.3.2 Experimental Results", "text": "As expected, the planners produced the same plans in different forms in all cases where the goals could not be achieved. This is also why SGPlan considers Metric-FF as its basis. We believe that the performance and scalability of the individual exchange programs have led to a satisfactory result."}, {"heading": "5.3.3 Improving the Memory Usage of Metric-FF", "text": "In our first tests with Metric-FF, we could not even solve medium-sized scenarios without running out of memory on a machine with 4GB of RAM. We discovered that Metric-FF performed a very inefficient accessibility analysis before the actual planning, which led to the memory problems mentioned above. Specifically, the accessibility analysis assigned four integer arrays with space for all possible \"states\" of each predicate, which corresponded to all possible combinations of constants for each argument of the predicate. The problem was that Metric-FF did not use type information and therefore took into account all constants, regardless of type, for each argument of each predicate. Due to the fact that we have to represent many characteristics of the target machine and operating system for each exploitation, our domain contains a lot of constants that represent port numbers, operating system versions, editions, distributions, service packs and kernel versions. Metric-FF = for each FF variable, where we have a better array of constants (32 MB = 1 FF)."}, {"heading": "5.4 Related Work", "text": "Work on the attack model applied to penetration testing originated in the ability to program pentesting tools such as Metasploit or Core Impact. This model led to the use of attack graphs. Previous work on attack graphs such as [PS98, RA00, SHJ + 02] was based on the complete enumeration of attack states, which increases exponentially with the number of actions and machines. As we have described in Section 3.8 of the study of [LI05], the main limitations of past attack graphs are their lack of scalability of medium-sized networks. A notable exception is the Topological Vulnerability Analysis (TVA) conducted at George Mason University."}, {"heading": "5.5 Summary and Future Work", "text": "We have shown in this chapter that this model scales up to medium-sized networks: it can be used to automate attacks (and penetration tests) against networks with hundreds of machines.The solution presented shows that it is not necessary to create the full attack graph (one of the major limitations of previous attack graph studies). Instead, we rely on planners like Metric-FF and SGPlan to selectively explore government space to find attack pathways.We have successfully integrated these planners with a pentesting framework that allowed us to execute and validate the resulting plans against a test bed of scenarios, and we presented the details of how to transform the information contained in the pentesting tool into the planning area to verify these hypotheses, an important question relevant to future work on how to deal with incomplete knowledge of the target network."}, {"heading": "Simulation of Network Scenarios", "text": "In this chapter, we present a simulation platform called Insight, which was created to design and simulate cyber attacks against large arbitrary target scenarios, and which was used to test the implementation described in Chapter 5, namely the integration of a classical planner with a pentesting framework. To test our implementation, we had to run attack paths in networks with hundreds of machines, which was only possible in a simulated network (given our current infrastructure). The simulation platform we developed has surprisingly low hardware and configuration requirements, while the simulation is a realistic experience from the attacker's point of view. Scenarios include a number of simulated actors: network devices, hardware devices, software applications, protocols, users, etc. A novel feature of this tool is the simulation of weak points (including 0 days) and exploits, which allow an attacker to compromise machines and use them as turning blocks to continue the attack."}, {"heading": "6.1 Motivation", "text": "Computer security has become a necessity in most modern computer applications and practices. However, it is a broad issue and security problems can occur almost anywhere: binary errors (e.g. buffer overflows [One96]), web errors (e.g. SQL7273injection, remote file inclusion), protocol errors (e.g. TCP / IP errors [Bel89]), not to mention hardware, human, cryptographic and other known bugs. Although it may seem obvious, it is useless to secure a network of one hundred firewalls if the computers behind them are vulnerable to attacks on clients. Protection by an Intrusion Detection System (IDS) is worthless against new vulnerabilities and 0-day attacks. As networks become larger, they have implemented a greater variety of more complex configurations and incorporate new devices (e.g. embedded devices) and technologies. This has created new information flows and control mechanisms, and thus new attack vectors. As a result of job-type combinations, more complex areas of computer munities have emerged as well."}, {"heading": "6.1.1 Design Restrictions", "text": "In practice, simulation of complex networks requires resolving the tension between the scalability and accuracy of the simulated subsystems, devices and data. This is a complex problem, and in order to find a satisfactory solution to this trade-off, we have introduced the following design limitations: 1. Our goal is to have a simulator on a single desktop computer running hundreds of simulated machines, with simulated traffic realistic only from the attacker's point of view. 2. Attacks within the simulator are not carried out by real attackers in the wild (e.g. script kiddies, worms, black hats). As a result, the simulation does not have to deal with exploitative details such as stack overflows or heap overflows. Instead, attacks are carried out from an attack framework by Insight users who know they are playing in a simulated environment. 74"}, {"heading": "6.1.2 Main Features", "text": "To demonstrate that our approach is valid, we have developed a concept called Insight. This program introduces a platform for executing attack experiments and tools to construct these attacks. We show that users of this tool are able to design and adapt attack-related technologies, and have better tests to assess their quality. Attacks are executed from an attack framework that includes many information and exploitation modules. There are many ways to exploit security vulnerabilities. If a computer programmer makes a programming error in a computer program, it is sometimes possible to bypass security. An exploit is a piece of code that attempts to compromise a computer system through a specific vulnerability."}, {"heading": "6.2 Background and Related Work", "text": "This year, it will be able to leave the country to return to the EU and leave the EU."}, {"heading": "6.3 Insight Approach and Overview", "text": "In fact, it is such that most of them will be able to move into another world, in which they can move into another world, in which they are able to move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they, in which they live, in which they live, in which they are able to move, in which they are able to move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live in which they live, in which they live, in which they live, in which they live in which they live, in which they live, in which they live in which they live, in which they live, in which they live in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they live, in which they, in which they, in which they live, in which they, in which they, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they, in which they, in which they, in which they, in which they can, in which they, in which they are able to"}, {"heading": "6.4 The Simulated Attack Model", "text": "One of the features that distinguishes the scenarios simulated by Insight is the ability to compromise computers and use them as pivots to build complex multi-level attacks. Compromising a machine means installing an agent who will be able to execute arbitrary system calls (syscalls) as the user of that system.The agent architecture is based on a solution called the Syscall proxy (see [Cac02] for more details).The idea of syscall proxying is to build a kind of universal payload that allows an attacker to execute any system call on a compromised host.By installing a small payload (a thin Syscall server) on a vulnerable host, the5Available from http: / / trials.coresecurity.com /.81 attackers are able to execute complex applications on their local host, with all system calls executed remotely."}, {"heading": "6.4.1 Probabilistic Exploits", "text": "In this model, a real payload of an exploit is replaced by an ID or a \"magic string\" that is sent to a simulated application. If that application is defined as vulnerable (and some other requirements are met), an agent is installed in the computer hosting the vulnerable application, and the simulated payload of an exploit includes the above-mentioned magic string. If the simulator subsystem receives this information, it searches for the string in the exploits database. If it is found, the simulator decides whether the exploit worked or not, and with what effect, based on a probability distribution that depends on the actual scenario information of that computer and the specific exploit. For example, state that the penetration testing framework assumes that the attacked machine is (erroneously) a Red Hat Linux 8.0, but that machine is actually a Windows system. In this hypothetical situation, the exploit would fail with 100% probability."}, {"heading": "6.4.2 Remote Attack Model Overview", "text": "In Fig. 6.2, we see the sequence of events that occur when an attacker executes a remote exploit against a simulated machine; the rectangles at the top are the four most important components involved: The Penetration Testing Framework, the Simulator, and the Exploits Database are the subsystems described in Fig. 6.1; the Vulnerable Application is a simulated application or service that is executed within an Insight scenario and has an open port; in the diagram, the declared components are displayed as rectangles, messages are displayed as continuous arrows, and time is displayed as vertical progression; when an exploit is launched against a service that is executed in a simulated machine, a connection is established between the Penetration Testing Framework and the 83service6. Then, the simulated Payload Payload exploit is sent to the application; the targeted application reads the payload by reading the system call; each time the subsystem finds the file that is being read in the operating system, the subring is being analyzed."}, {"heading": "6.4.3 Local Attack Model Overview", "text": "Insight can also simulate local attacks: If an attacker gains control of a machine but does not have enough privileges to perform a specific action, a local attack can use a new agent with higher privileges. 6This connection is, for example, established by a real Windows socket or a simulated TCP / IP socket, see Section 6.5.2.84 Fig. 6.3, we see the sequence of events that occur when a local attack is launched against a particular machine. A running agent must be present on the target machine to start a local exploit. All local simulated attacks are executed identically by the simulator subsystem: The Penetration Testing Framework writes the magic exploit string using the write system call into the agent's default input, and the simulator finally detects the magic string that stops that system. Similar to the previous example, the magical exploit string is searched in the database and installed with a higher probability of a new agent."}, {"heading": "6.5 Detailed Description", "text": "One of the most challenging topics in the Insight architecture is solving the tension between realism and performance. The goal was to have a simulator on a single desktop computer running hundreds of simulated machines, with simulated traffic being realistic in terms of penetration testing, but there is a trade-off between realism and performance, and we will discuss some of these issues and other details of the architecture in the following sections."}, {"heading": "6.5.1 The Insight Development Library", "text": "New applications for the simulation platform can be developed using a minimal standard C library, a standardized collection of header files and library routines that are used to implement common operations such as: input, output, and string handling in the C programming language. This library - a sublibrary - implements the most common functions (e.g. read, write, open) and allows each developer to implement his own services using the usual compilers and development tools (e.g. gcc, g + +, MS Visual Studio). For example, a web server could be implemented that links to the provided library and is connected within the simulated Insight scenario.The library provided supports the most common system calls, but is still incomplete and we could not compile complex open source applications. Nevertheless, some services (e.g. a small DNS) and network network confidential are planned for the future, e.g. system calls for i5g and i5p."}, {"heading": "6.5.2 Simulating Sockets", "text": "A hierarchy of file descriptors has been developed, as shown in Figure 6.4. File descriptors can (but are not limited) refer to files, directories, sockets, or pipes. At the top of the hierarchy, the tree root displays the descriptor object that typically provides the operations to read and write data, close and duplicate file descriptors, and other generic system calls. Simulated socket implementation spans two types of supported socket subclasses: 1. SocketDirect. This socket variant is optimized for simulation on a computer. Socket direct is fast: Once a connection is established, the client holds a file descriptor that points directly to the server's descriptor. Routing is performed only during the connection and the protocol control blocks (PCBs) are created as expected, but are only used during connection establishment."}, {"heading": "6.5.3 The Exploits Database", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "6.5.4 Scheduler", "text": "The main task of the scheduler is to allocate the CPU resources to the various simulated actors (e.g. simulated machines and processes). Similarly, the scheduling iterates over the hierarchical machine process thread as a tree (like a depth search), with each machine executing its processes in round robin. Similarly, the execution of a process gives all its threads the order until a system call is required. Obviously, depending on the state of each thread, these threads are executed, change the state, or stop executing. The central problem is that threads execute system calls and then (if possible) continue their activity until they are finished or another system call is required. 89Insight threads are simulated within real threads of the underlying operating system. Simulated machines and processes all run within one or more work processes (execution of hundreds of threads), and all are coordinated by a unique scheduling process called the master process. Thanks to this 7. There is a very low level of performance loss due to the architecture."}, {"heading": "6.5.5 File System", "text": "In order to manage thousands of files without wasting a huge amount of disk space, the simulation of the file system is achieved by mounting shared file repositories. We will refer to these repositories as template file systems. For example, all simulated Windows XP systems could share a file repository with the default installation provided by Microsoft. These common templates would only have read permission, so if a virtual machine needs to read or modify a file, it will be copied within the local file system of the given machine. This technique is known as copy-on-write. The basic idea is to allow multiple callers to request resources that are initially indistinguishable and to give them pointers to the same resource. This function can be maintained until a caller attempts to change his copy of the resource. At this point, a real private copy is created to prevent the changes from being visible to everyone else."}, {"heading": "6.6 Performance Analysis", "text": "In order to evaluate the performance of the simulator, we perform a test with a scenario in which an increasing number of complete LANs of 250 computers each are simultaneously emulated. The tests are only about running a network analysis on the entire LANs via a TCP connection to port 80. An original pen-test module used for information was executed without modification, which was a constructive goal of the simulator to use true unmodified attack modules if possible."}, {"heading": "Performance of the simulator", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "LANs Computers Time (secs) Syscalls/sec", "text": "We can observe the decrease in the number of system calls processed per second, while increasing the number of simulated computers, since Insight is run on a single real computer with limited resources. Nevertheless, the simulation is efficient, as system calls are required when needed through the connections of the module that collects network information over TCP connections."}, {"heading": "6.7 Applications", "text": "This year is the highest in the history of the country."}, {"heading": "6.8 Summary", "text": "We have created a playground for experimenting with cyber attack scenarios, based on a probabilistic attack model - a model that is also used by attack planning tools developed in our laboratory. By using proxy syscalls technology and simulating multi-platform agents, we have been able to implement a simulation that is both realistic and lightweight, allowing the simulation of networks with thousands of hosts. The framework provides a global overview of the scenarios. It is geared to the attacker's point of view and designed to increase the size and complexity of simulated scenarios while remaining realistic for the attacker. The value of this framework is given by its multiple applications: \u2022 Systematic investigation of attack planning techniques. \u2022 Evaluation of network security measures. \u2022 Anticipation of risk through 0-day vulnerabilities. \u2022 Pentest training. \u2022 Worm dissemination analysis. \u2022 Data generation to test visualization techniques Part II."}, {"heading": "Development of a Probabilistic", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Attack Planner", "text": ""}, {"heading": "Probabilistic Attack Planning", "text": "In Chapter 5, we have presented an approach to the problem of attack planning, which is based on modeling actions and assets in the language of the PDDL and on the use of commercially available AI tools to create attack plans. However, this approach is limited. In particular, planning is classic (the actions are deterministic) and therefore unable to handle the uncertainties associated with this form of attack planning.In this chapter, we contribute a planning model that captures the uncertainty about the outcome of actions, which is modeled as the likelihood of success of each action. We present efficient planning algorithms that have been developed specifically for this problem and achieve runtime performance on an industrial scale (capable of solving scenarios with several hundred hosts and exploits).These algorithms take into account the probability of success of actions and their expected costs (for example, in terms of execution time or network traffic generated).We show that probabilistic attack planning is efficient for the scenarios that can be solved as the scenarios that result of certain networks (which may also be simplified by assessing the security of the large number of networks)."}, {"heading": "7.1 Introduction", "text": "This year, it has reached the point where it is only half way through until it is in a position to retaliate."}, {"heading": "7.2 The Attack Model", "text": "We summarize below the basic background information from the conceptual model of computer attacks presented in Chapter 3 (for more details see [AR03, FNRS03, Ric03, RT07]), and develop some aspects of the model such as the cost of actions. This model is based on the concepts of assets, targets, agents, and actions. In this description, an attack involves a series of agents who perform actions to obtain assets (which may be information or actual changes in the real network and systems) in order to achieve a number of objectives. An asset can represent everything an attacker needs to receive in the course of an attack, including the actual target. Examples of assets: information about the operating system (OS) of a host H; TCP connectivity with host H on port P; an agent installed on a particular host H. To install an agent, this means breaking into a host, taking control of its resources, and finally using it as a linchpin to continue the attack."}, {"heading": "7.2.1 Deterministic Actions with Numerical Effects", "text": "This idea was proposed in [SW08] and further analyzed in [LSR10] and discussed in Chapter 5 of this thesis, where the assets are presented as PDDL predicates and the actions are translated as PDDL operators; the authors show how this PDDL representation enabled them to integrate a penetration testing tool with an external planner and generate attack plans in realistic scenarios; the planners used - MetricFF [Hof02] and SGPlan [CWH06] - are state-of-the-art planners capable of handling numerical effects.Figure 7.1 shows an example of a PDDL action: An exploit for the IBM Tivoli vulnerability that will attempt to install an agent on the target host from an explosion tool previously installed on the source host."}, {"heading": "7.2.2 Actions\u2019 Costs", "text": "The execution of an action has multi-dimensional costs. Below are some values that can be measured (and optimized in the event of an attack): Execution time: Average runtime of the action. Network traffic: The amount of traffic sent over the network increases the level of noise generated. IDS detection: protocol lines and warnings triggered by the execution of the action increase the noise generated. Hostress resources: Execution of actions consumes resources from both the local and the remote host in terms of CPU, RAM, disk usage, etc. Attack traceability: Depending on the number of intermediate steps and topological factors. Zero-day exploits: exploits for vulnerabilities that are not publicly known valuable resources that should only be used when other exploits have failed (the attacker usually wants to minimize the use of \"0 days\"). In our experiments, we have decided to optimize the expected execution time."}, {"heading": "7.2.3 Probabilistic Actions", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "7.4.1 Predefined Strategies", "text": "In fact, it is not as if one sees oneself in a position to go in search of a solution, as was the case in the past. (...) It is not as if one can get involved in a solution. (...) It is not as if one can get involved in a solution. (...) It is not as if one can get involved in a solution. (...) It is not as if one can get involved in a solution. (...) It is as if one can get involved in a solution. (...) It is as if one gets involved in a solution. (...) It is not as if one gets involved in a solution. (...) It is as if one gets involved in a solution. (...) It is not as if one gets involved in a solution. (...) It is as if one does not get involved in a solution. (...) It is not as if one gets involved in a solution."}, {"heading": "7.4.2 Multiple Groups of Actions", "text": "The difference with problem 7.4 is that we now need to specify the order of execution within each group. Figure 7.4 shows an example of this situation. A system agent can be installed using a remote exploit, a client-side exploit, or an SQL injection in a web application. Each of these actions has requirements that can be met by the actions displayed on the second level. For example, before executing the remote exploit the attacker must have a host probe (to106verify connectivity with the target host), port probe (to check if the target port of the exploit is open), and an OS detection module (to verify the operating system of the target host).Problem 7.4. Same as problem 7.4, except that we have n groups. G1 if the actions of the group are successful."}, {"heading": "7.5 Using the Primitives in an Attack Tree", "text": "We apply the primitives below the Choose and Combine to a probabilistic attack tree in which the nodes are limited by AND relations and OR relations. The tree consists of two types of nodes distributed in alternating layers of asset nodes and action nodes (see Figure 7.5)."}, {"heading": "Asset", "text": "An asset node is connected by an OR relationship to all actions that provide that asset: For example, an agent asset is connected to the exploit actions that can install an agent on the target host. An action node is connected by an AND relationship to its requirements: For example, local exploitation of Microsoft NtUserMessageCall Kernel Privilege Escalation requires an agent asset (with low privileges) on the target host H and a Windows XP OS asset for H.108The proposed solution is obtained by combining the primitives from previous sections. In the AND-OR tree, the leaves that are limited by an AND relationship can be considered as a single node. In fact, this group G can be considered primitively as a single action using the combination with compound probability of success PG and execution time TG. The leaves that are limited by an AND-OR relationship can (temporarily) be considered a single node."}, {"heading": "7.5.1 Constructing the Tree", "text": "To ensure that the result is a tree, not a DAG, we assume an additional assumption of independence: the assets required for each action are considered independent (i.e., if an asset is required by two different actions, it appears twice in the tree).In this way, we obtain an AND-OR tree with alternating levels of asset nodes and action nodes (as in Fig. 7.5).The only actions added are exploits, TCP / UDP connectivity checks, and OS detection modules. These actions have no requirements that have already appeared in the tree, in particular, the tree has only one agent asset (the root node of the tree).Thus, by constructing it, we can be sure that no loops result that this agent, the completion of the tree is very likely."}, {"heading": "7.6 The Graph of Distinguished Assets", "text": "In this section, we use the previous primitives to create an algorithm for attack planning in arbitrary networks, making an additional assumption of independence between machines. First, we distinguish a class of assets, namely the assets associated with agents. We refer to them as distinguishable assets. At the PDDL level, the predicates associated with the agents contain distinct classes. Planning occurs at two different levels of abstraction: at the first level, we evaluate the cost of compromising a target's distinguishable asset from a fixed source. More specifically, we calculate the costs and probabilities of obtaining a target agent based on a source agent. At this level, the attack plan does not need to include a third agent. Therefore, the algorithm at the first level is there to construct the attack tree and calculate an attack plan, as described in Section 7.5.At the second level, we build a directed graph G = V, where we will differentiate the nodes used in our target network."}, {"heading": "7.7 Our implementation", "text": "We have developed a concept proof for the implementation of these ideas in the language of Python. This planner takes as input a description of the scenario in the language of the PPDDL, an extension of the PDDL to express probabilistic effects [YL04]. Our main objective was to build a probabilistic planner capable of solving scenarios with 500 machines, which was the limit reached with the classical (deterministic) 111algorithm 2 Modified Dijkstras algorithm T [s] = 0, P [v] = + \u221e, P [v] = 0, V [V], V 6 = s \u2190 V (where Q is a priority queue), while Q 6 = \u2205 Dijkstras algorithm minx, Q T [v] = + \u221e, P [v] = 0, V [V], S \u0432\u0430\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0438\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0438\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0441\u0438flifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifliflifli"}, {"heading": "7.7.1 Testing and Performance", "text": "The experiments were conducted on a machine with an Intel Core2 Duo CPU at 2.4 GHz and 8 GB of RAM. We focused our performance assessment on the number of machines M on the attacked network. We created a network consisting of five subnets with different numbers of machines, all connected to a main network to which the attacker initially has access. Figure 7.7 shows the memory usage of this planning solution, which clearly grows linearly with M. Our current implementation manages to shift the network size limit to 1000 machines, and brings memory usage under control. In contrast, the hard limit was the memory of 500 machines, which we ran out of the memory with 8 GB of RAM. Memory growth was clearly exponential, for example 400 machines used 4 GB of RAM. This was difficult to scale the M."}, {"heading": "7.8 Related Work", "text": "Early work on attack curve solving relied on model verification techniques [JSW02, SHJ + 02] with their inherent scalability limitations; or on monotonicity assumptions [AWK02, NEJ + 09, NJ05] that are unable to express situations where compromised resources are lost due to crashes, detection, or other unforeseen circumstances. [GG09] generates attack paths from the PDDL description of networks, hosts, and exploits, although the scenarios investigated do not cover realistic yardsticks. Previous work by the authors [LSR10] addresses this limitation by using scenarios with up to 500 penetration tools and using the penetration plans for the machines as a guide."}, {"heading": "7.9 Summary and Future Work", "text": "In this chapter we have shown an extension of the established attack diagrams, which contains probable effects, and numerical effects (e.g. the expected runtime of the actions).This model is more realistic than the deterministic setting, but it leads to additional difficulties in planning. We have shown that under certain conditions an efficient algorithm is available, which allows an optimal utilization of the network."}, {"heading": "The Search for a Better Model", "text": ""}, {"heading": "The POMDP Model", "text": "In Chapter 5, we presented an approach to the problem of attack planning that uses classical planning and therefore ignores all the incomplete knowledge that characterizes hacking. The newer approach of Chapter 7 assumes strong assumptions about scaling independence and lacks a clear formal concept of what the problem of attack planning actually is. In this chapter, we model this problem using partially observable Markov decision-making processes (POMDP), which establishes penetration testing in a well-researched formalism and highlights important aspects of the nature of the problem. POMDPs allow us to model information gathering as an integral part of the problem, providing, for the first time, a means of intelligently mixing scanning with actual exploits."}, {"heading": "8.1 Introduction", "text": "This year is the highest in the history of the country."}, {"heading": "8.2 Comment on Penetration Testing", "text": "The goal of a typical penetration test task is to gain control of as many computers in a network as possible, preferring some machines (e.g. because of their critical content), starting with a controlled computer: either outside the targeted network (so that the first targets are machines accessible via the Internet) or within that network (e.g. by using a Trojan horse). As shown in Figure 8.1, one can distinguish at any time between 3 types of computers: those that are under control (where an agent has been installed that can perform actions); those that are reachable from a controlled computer because they share a subnetwork with one of them; and those that are not reachable from a controlled computer. Given the machines currently under control, one can perform two types of actions aimed at an reachable machine: tests - to determine their configuration (OS, running applications,...) - and exploits - to install an agent by exploiting a vulnerability."}, {"heading": "8.3 Background on POMDPs", "text": "Before describing how penetration tests can be modelled in the sense of POMDPs in Section 8.4, we provide the necessary background and terminology. Planning based on Markov Decision Processes (MDPs) is designed to address non-determinism, probabilities, partial observability and extended objectives. It is based on the following conventions: \u2022 A planning area is modelled as a stochastic system, i.e. a non-deterministic system for the transition from one state to another that assigns probabilities for state transitions. \u2022 Targets are represented by utility functions, numerical functions that give preferences and / or actions to the states to be traversed. Utility functions can express preferences along the entire execution path of a plan and not just desired end states. \u2022 Plans are presented as guidelines that define the actions to be executed in each faith state. \u2022 The planning problem is considered an optimization problem, in which planning algorithms search for observability through an observability state."}, {"heading": "8.3.1 Basic Definitions of MDPs", "text": "Definition 8.1. A Markov Decision Process (MDP), also referred to as a stochastic system (GNT04), is a non-deterministic state transition system with a probability distribution on each state transition. It is defined by a tuple \u03a3 = < S, A, T > where: \u2022 The state space S is a finite set of states. \u2022 The space A is a finite set of actions. \u2022 T: S \u00b7 A \u2192 (S) is the state transition function that gives a probability distribution over the world states for each world state s and its action a. Wewrite T (s, a, s) for the probability that the state state s ends is given that the actor s begins and performs action a. \u2022 r: S \u00b7 A \u2192 R is the reward function that gives the expected immediate reward obtained by the agent for taking a measure."}, {"heading": "8.3.2 Basic Definitions of POMDPs", "text": "o Definition 8.10. POMDPs are usually defined [Mon82, Cas98, GNT04] by a tuple \u03a3 = < S, O, O, O, b0 > where: \u2022 \u2032 S, A, T, r > is a Markov decision-making process. \u2022 Observation space O is a finite series of observations. \u2022 b0 is the initial probability distribution across states. \u2022 At any time, the system located in a state performs an action by A that results in 1251. a transition to a state s, according to the transition function: T: S \u00b7 A \u00b7 S \u00b7 S \u2192 S \u2192 [0, 1] T (s, a, s \u2032) = Pr (s \u2032 s, S, a) 2. an observation o \u0432O according to the observation function: O: S \u00b7 A \u00b7 A \u00b7 O \u00b7 O \u2192 [0] O (s \u00b2 s, o) = Pr (o | s \"s\" s \"s\")."}, {"heading": "8.3.3 Reformulation as an MDP over B", "text": "Using beliefs, a POMDP = 1, if x = 0, if x = 8, b = 13, b = other words b = possible terms b = condition b = condition b = condition b = condition b = condition b = condition b = condition b = condition b = condition b = condition b = condition b (condition B, A, T, \u03c1 >, where the new transition and reward functions are both defined via B \u00d7 A \u00d7 B. With this reformulation, a number of theoretical results can be extended about condition B = condition B = condition B, e.g. the existence of a determinist policy that is optimal. One problem is that this condition MDP is defined via a continuous - and thus unlimited - faith space. Let us first calculate the transition probability for faith states B \u00b2. In a belief state b \u00b2 B B and an action a \u00b2 B and an action a \u00b2 B, each observation can produce a different successful state. The faith state can be written as a condition B = (condition B \u00b2) (condition B = B \u00b2)"}, {"heading": "8.3.4 POMDP Solving Algorithms", "text": "A number of algorithms take advantage of the fact that Vn (b) is a piecemeal linear and convex function (PWLC), which enables direct calculations or approximations in which the target function is the upper shell of a series of hyperplanes. As a result, algorithms perform precise updates such as Batch Enumeration [Mon82], Witness or Incremental Pruning [Cas98], but also approximate ones such as in Point-Based4In practice, we are looking at an infinite horizon.128 Value Iteration (PBVI) [PGT06], Heuristic Search Value Iteration (HSVI) [SS04], PERSEUS [SV05] or SARSOP [KHL08]. If you do not rely on PWLC functions, you can also solve a POMDP as an MDP on a continuous state space, e.g. with tree search algorithms - enabling online planning [RPP08 - dynamic elements] with a MKK structure, or a continuous state DP."}, {"heading": "SARSOP Solver", "text": "For our experiments, we use SARSOP [KHL08], a state-of-the-art point-based algorithm, i.e. an algorithm that approaches the value function as the upper shell of a series of hyperplanes, these hyperplanes correspond to a selection of specific points of belief. SARSOP is being developed at the National University of Singapore with the aim of developing practical POMDP algorithms and software for common robotic tasks - such as coastal navigation, capture, mobile robotic research and target tracking - which are all modeled as POMDPs with a large number of states. The basic idea of point-based POMDP algorithms is to take a set of points from B and use them as an approximate representation of B. Definition 8.13. Accessible space R (b0) is the subset of points of faith that are available from a certain starting point b0, b0 b0."}, {"heading": "8.4 Modeling Penetration Testing with POMDPs", "text": "Because penetration testing is about acting under partial observation, POMDPs are a natural candidate for modeling this particular problem. They allow us to model the problem of knowledge acquisition and take into account probabilistic information, such as the fact that certain configurations or vulnerabilities occur more frequently than others. In comparison, classical planning approaches [LSR10] assume that the entire network configuration is known, so no exploration is required. In this section, we discuss how penetration testing can be formalized using POMDPs. As we will see, the uncertainty is essentially in the original belief state. This differs from modelling uncertainty in pentestering using probabilistic outcomes, such as in [SRL11], which does not take into account the real dynamics of the system."}, {"heading": "8.4.1 States", "text": "First, any reasonable penetration test will have a finite execution. There is nothing here that can be gained by infinite execution of a looping behavior. Each pentest terminates either when an event (e.g. attack detection) stops it, or when the additional access rights that could still be gained (from the finite number of access rights) do not outweigh the associated costs, implying that there is an absorbing terminal state and that we need to solve a stochastic shortest path problem (SSP). Then, we do not need the full state of the system to describe the current situation. So, we will focus on aspects that are relevant to the task. For example, this state does not need to include network topology, as it is assumed to be static and known here, but it does need to be taken into account for the configuration of the system."}, {"heading": "8.4.2 Actions & Observations", "text": "Since we assume that the network topology is a priori known, there is no need for actions to find reachable machines, so there are two types of actions left: tests that make it possible to get information about the configuration of a computer, and exploits that attempt to install an agent on a computer by exploiting a vulnerability. Table 8.2 lists actions in our running example, which started in Table 8.1."}, {"heading": "Tests", "text": "Tests are typically performed with programs such as nmap [Lyo98], which scans a particular computer for open ports and through the analysis of the reaction behavior of the ports make guesses about which OS and services are executed. Note that such observational actions are performed either in terms of the time spent conducting analyses, or due to the probability of being recognized due to the generated network activity, costs. This is the reason why one must decide which tests are to be performed, rather than to perform them all.In our setting we consider only two types of tests: OS-recognition will return a list of possible OSes, theories that explain the observations of the analytical tool. As a result, one can derive from the state of faith (= set to zero probability) all states that do not agree, and then normalize the remaining non-zero probabilities. 0, Keep with the same ongoing example, table 8.3 presents the transition and the observational models, the detection models are set to zero probability) all states that do not agree, and then re-normalize the remaining non-zero probabilities. 0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0."}, {"heading": "Exploits", "text": "Exploits exploit the vulnerability of an application to (i) gain some control over a computer from another computer (Remote Exploit) or (ii) gain more control over a computer (Local Exploit / Privilege Escalation). Local exploits are not significantly different from remote exploits because they amount to treating each level of privilege as a different (virtual) machine in a subnetwork. Therefore, for clarity, we consider only one level of privilege per machine. Specifically, we consider that any successful exploitation provides the same level of control over the target machine, regardless of the exploit and its configuration, which allows (i) to assume that the same actions are available on each controlled machine, and (ii) to avoid giving details about what type of agent is installed on a computer. The success of a particular Exploit Action E depends deterministically on the configuration of the target machine, so that: (i) there is no benefit if the configuration is not likely to be compatible with - or is not -"}, {"heading": "T: Exploit-M0-win2003-SMB identity", "text": "In this chapter, we even assume that the configuration of a computer is fully monitored as soon as it is under control.Exploit-M0-win2003-SMB is modeled in Table 8.5, and is an exemplary evolution of faith in the context of this action: initial (0,0,0,0,0,0,0,0,0,0,18, 1 8, 1 8, 1 8, 1 8, 0,0,0,0,0,0,0) failure (0,0,0,0,0,0,0,0,0,0,0,0) failure (0,0,0,0,17, 1 7, 1 7, 1 7, 1 7, 1 7, 0,0,0,0,0)"}, {"heading": "8.4.3 Rewards", "text": "Otherwise, the reward function must consider several things: value of a computer (rc): The goal of a pentest is to gain access to a number of computers. At this point, we propose to assign a fixed reward for each successful exploitation (on a previously uncontrolled machine). In a more realistic environment, one could reward the first access to certain valuable data, regardless of which computer hosts the data. Time is money (rt): Every action - be it a test or an exploitation - has a ration, so that the expected duration of the pentest can be minimized by assigning a cost (negative reward) proportional to its duration to each transition. One could also consider a maximum time for the pentest instead of minimizing it."}, {"heading": "8.4.4 POMDP Model Generation", "text": "Creating a POMDP model for pentesting requires knowledge of possible states, actions and observations, plus the reward function and initial state of belief. First, that the POMDP model can be developed from one pentest to the next, as new applications, exploits or tests are required. Action and observational models for the various possible tests and exploits can be derived from documenting test tools (see, for example, nmap's manpage) and databases such as CVE (Common Vulnerabilities and Exposures) 5. Information could probably be automatically extracted from such databases, which are already highly structured. In our experiments, we will start with a proprietary database from Core Security Technologies. The two remaining components of the model - the initial belief state - contain quantitative information that is more difficult to acquire."}, {"heading": "8.5 Solving Penetration Testing with POMDPs", "text": "We now describe our experiments. First, we fill in some details about the setup, then discuss different scaling scenarios, before taking a closer look at some sample policies generated by the POMDP solver."}, {"heading": "8.5.1 Setup of Experiments", "text": "The experiments are run on a machine with an Intel Core2 Duo CPU with 2.2 GHz and 3 GB RAM. We use the APPL (Approximate POMDP Planning) toolkit6. This C + + implementation of the SARSOP algorithm is easy to compile and use and has reasonable performance. The solver is executed without time limitation until a target accuracy of 0.001 is reached. Since we solve a stochastic problem with the shortest route, no discount factor is required, but we use \u03b3 = 0.95 to improve performance. We will briefly discuss the effects of the change and acceleration. Our problem generator is implemented in Python. It has 3 parameters: \u2022 Number of machines M in the target network, \u2022 Number of exploits E in the pentesting tool applicable in the target network, \u2022 Time delay T since the last fifth, measured in days."}, {"heading": "8.5.2 Combined Scaling", "text": "We discuss performance - solver runtime - as a function of M, E, and T. To make data representation practicable, first of all, only 2 of the parameters are scaled. Let us first look at Figure 8.3, which scales M and T. E is fixed to the minimum value, i.e., each machine has a fixed OS version and a target application. In this setting, there are 3M states. For M = 8, the generated POMDP file has 6562 states and occupies 71 MB on the hard disk; the APPL solver runs out of memory when trying to analyze it. Thus, in this and all experiments to follow, M \u2264 7.139Of course, the runtime grows exponentially with M - finally also the solver input. As for T, interestingly, this exhibits a very pronounced simple-easy-simple pattern. Examining the reasons for this, we found that it is due to a low-high pattern of \"uncertainty\" as a function of T."}, {"heading": "8.5.3 The 2-Machines Case", "text": "As indicated, the case of the 2 machines is relevant because it can serve as an \"atomic building block\" in a solution on an industrial scale, cf. also the discussion in the outlook below. The question then is whether we can scale the number of exploits into a realistic region or not. We have already seen above that this is not possible with unfavorable values of T. But are these values to be expected in practice? As far as the Core Insight Enterprise tool from Core Security goes, the answer is \"No.\" In security-conscious environments, pentestering should be performed at regular intervals of no more than 1 month. Consequently, Figure 8.7 shows data for T \u2264 50. For the larger values of T, the data show a very steep inclination between E = 5 and E = 10, followed by an apparently linear growth. This behavior is kept cautious by an undesirable distortion in our current generator."}, {"heading": "8.5.4 POMDPs make Better Hackers", "text": "To illustrate the policies found by the POMDP solver, let us consider a simple example in which the pentester has four exploits: an SSH exploit (on OpenBSD, port 22), a wu-ftpd exploit (on Linux, port 21), an IIS exploit (on Windows, port 80), and an Apache exploit (on Linux, port 80). The probability of the target machine being Windows is higher than the probability of the other operating systems. Previous automated pentesting methods, such as Lucangeli et al. [LSR10] proceed by first running a port scan on shared ports, then executing the OS detection module (s), and finally starting exploits for potentially vulnerable services."}, {"heading": "8.6 Discussion", "text": "In fact, the fact is that most of them will be able to move to a different world in which they are able than to another world in which they are able, in which they live, in which they live, in which they live."}, {"heading": "Conclusions and Future Work", "text": "In fact, most of them will be able to move to another world, to move to another world, to move to another world, to move to another world, to move to another world, to move to another world, to move to another world, to move to another world, to move to another world, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move."}], "references": [{"title": "The Shellcoder\u2019s Handbook", "author": ["Chris Anley", "John Heasman", "Felix Lindner", "Gerardo Richarte"], "venue": null, "citeRegEx": "Anley et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Anley et al\\.", "year": 2007}, {"title": "An introduction to MOSDEF", "author": ["Dave Aitel"], "venue": "In Black Hat Briefings,", "citeRegEx": "Aitel.,? \\Q2004\\E", "shortCiteRegEx": "Aitel.", "year": 2004}, {"title": "A closer look at MOMDPs", "author": ["Mauricio Araya-L\u00f3pez", "Vincent Thomas", "Olivier Buffet", "Fran\u00e7ois Charpillet"], "venue": "In Proc. of ICTAI-10,", "citeRegEx": "Araya.L\u00f3pez et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Araya.L\u00f3pez et al\\.", "year": 2010}, {"title": "Why attacking systems is a good idea", "author": ["Ivan Arce", "Gary McGraw"], "venue": "IEEE Computer Society - Security & Privacy Magazine,", "citeRegEx": "Arce and McGraw.,? \\Q2004\\E", "shortCiteRegEx": "Arce and McGraw.", "year": 2004}, {"title": "State of the art security from an attacker\u2019s viewpoint", "author": ["Ivan Arce", "Gerardo Richarte"], "venue": "In PacSec Conference,", "citeRegEx": "Arce and Richarte.,? \\Q2003\\E", "shortCiteRegEx": "Arce and Richarte.", "year": 2003}, {"title": "On the quality of exploit code: An evaluation of publicly available exploit code", "author": ["Ivan Arce"], "venue": "In RSA Security Conference,", "citeRegEx": "Arce.,? \\Q2005\\E", "shortCiteRegEx": "Arce.", "year": 2005}, {"title": "Scalable, graph-based network vulnerability analysis", "author": ["Paul Ammann", "Duminda Wijesekera", "Saket Kaushik"], "venue": "In Proceedings of the 9th ACM Conference on Computer and Communications Security,", "citeRegEx": "Ammann et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Ammann et al\\.", "year": 2002}, {"title": "The internet motion sensor: A distributed blackhole monitoring system", "author": ["Michael Bailey", "Evan Cooke", "Farnam Jahanian", "Jose Nazario", "David Watson"], "venue": "In Proceedings of Network and Distributed System Security Symposium NDSS", "citeRegEx": "Bailey et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bailey et al\\.", "year": 2005}, {"title": "The theory of dynamic programming", "author": ["Richard Bellman"], "venue": "Bull. Amer. Math. Soc.,", "citeRegEx": "Bellman.,? \\Q1954\\E", "shortCiteRegEx": "Bellman.", "year": 1954}, {"title": "Security problems in the TCP/IP protocol suite", "author": ["Steven M. Bellovin"], "venue": "Computer Communications Review,", "citeRegEx": "Bellovin.,? \\Q1989\\E", "shortCiteRegEx": "Bellovin.", "year": 1989}, {"title": "Fast planning through planning graph analysis", "author": ["Avrim Blum", "Merrick L. Furst"], "venue": "Artificial intelligence,", "citeRegEx": "Blum and Furst.,? \\Q1997\\E", "shortCiteRegEx": "Blum and Furst.", "year": 1997}, {"title": "Solving POMDPs: RTDP-Bel vs. point-based algorithms", "author": ["Blai Bonet", "Hector Geffner"], "venue": "In Proc. of IJCAI-09,", "citeRegEx": "Bonet and Geffner.,? \\Q2009\\E", "shortCiteRegEx": "Bonet and Geffner.", "year": 2009}, {"title": "Course of action generation for cyber security using classical planning", "author": ["Mark S. Boddy", "Johnathan Gohde", "Thomas Haigh", "Steven A. Harp"], "venue": "In Proc. of ICAPS\u201905,", "citeRegEx": "Boddy et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Boddy et al\\.", "year": 2005}, {"title": "Quantitative Risk Analysis of Computer Networks", "author": ["Daniel Bilar"], "venue": "PhD thesis, Dartmouth College,", "citeRegEx": "Bilar.,? \\Q2003\\E", "shortCiteRegEx": "Bilar.", "year": 2003}, {"title": "Deterministic POMDPs revisited", "author": ["Blai Bonet"], "venue": "In Proc. of UAI\u201909,", "citeRegEx": "Bonet.,? \\Q2009\\E", "shortCiteRegEx": "Bonet.", "year": 2009}, {"title": "A discourse on winning and losing", "author": ["John R. Boyd"], "venue": "Technical report, USAF,", "citeRegEx": "Boyd.,? \\Q1987\\E", "shortCiteRegEx": "Boyd.", "year": 1987}, {"title": "Outrepasser les limites des techniques classiques de prise d\u2019empreintes grace aux r\u00e9seaux de neurones", "author": ["Javier Burroni", "Carlos Sarraute"], "venue": "In Symposium sur la Se\u0301curite\u0301 des Technologies de l\u2019Information et des Communications (SSTIC), Rennes, France,", "citeRegEx": "Burroni and Sarraute.,? \\Q2006\\E", "shortCiteRegEx": "Burroni and Sarraute.", "year": 2006}, {"title": "Application-level simulation for network security", "author": ["Rainer Bye", "Stephan Schmidt", "Katja Luther", "Sahin Albayrak"], "venue": "In Proceedings of the First International Conference on Simulation Tools and Techniques for Communications, Networks and Systems,", "citeRegEx": "Bye et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bye et al\\.", "year": 2008}, {"title": "Syscall Proxying - Simulating remote execution", "author": ["Max Caceres"], "venue": "Black Hat USA Conference,", "citeRegEx": "Caceres.,? \\Q2002\\E", "shortCiteRegEx": "Caceres.", "year": 2002}, {"title": "Exact and Approximate Algorithms for Partially Observable Markov Decision Processes", "author": ["Anthony R. Cassandra"], "venue": "PhD thesis,", "citeRegEx": "Cassandra.,? \\Q1998\\E", "shortCiteRegEx": "Cassandra.", "year": 1998}, {"title": "Modeling the spread of active worms", "author": ["Z. Chen", "L. Gao", "K. Kwiat"], "venue": "In Proceedings of IEEE INFOCOM", "citeRegEx": "Chen et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2003}, {"title": "Temporal planning using subgoal partitioning and resolution in SGPlan", "author": ["Yixin Chen", "Benjamin W. Wah", "Chihwei Hsu"], "venue": "J. of Artificial Intelligence Research,", "citeRegEx": "Chen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2006}, {"title": "VDE: virtual distributed Ethernet", "author": ["R. Davoli"], "venue": "In First International Conference on Testbeds and Research Infrastructures for the Development of Networks and Communities,", "citeRegEx": "Davoli.,? \\Q2005\\E", "shortCiteRegEx": "Davoli.", "year": 2005}, {"title": "A systematic approach to multi-stage network attack analysis", "author": ["J. Dawkins", "J. Hale"], "venue": "In Proc. of DISCEX III,", "citeRegEx": "Dawkins and Hale.,? \\Q2003\\E", "shortCiteRegEx": "Dawkins and Hale.", "year": 2003}, {"title": "Probabilistic planning via heuristic forward search and weighted model counting", "author": ["C. Domshlak", "J\u00f6rg Hoffmann"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Domshlak and Hoffmann.,? \\Q2007\\E", "shortCiteRegEx": "Domshlak and Hoffmann.", "year": 2007}, {"title": "Fidius: Intelligent support for vulnerability testing", "author": ["D. Elsbroek", "D. Kohlsdorf", "D. Menke", "L. Meyer"], "venue": "In Working Notes for the 2011 IJCAI Workshop on Intelligent Security (SecArt),", "citeRegEx": "Elsbroek et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Elsbroek et al\\.", "year": 2011}, {"title": "PDDL2.1: An extension to PDDL for expressing temporal planning domains", "author": ["M. Fox", "D. Long"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Fox and Long.,? \\Q2003\\E", "shortCiteRegEx": "Fox and Long.", "year": 2003}, {"title": "Large-scale vulnerability analysis", "author": ["Stefan Frei", "Martin May", "Ulrich Fiedler", "Bernhard Plattner"], "venue": "LSAD", "citeRegEx": "Frei et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Frei et al\\.", "year": 2006}, {"title": "Simulating cyber-attacks for fun and profit", "author": ["Ariel Futoransky", "Fernando Miranda", "Jose Orlicki", "Carlos Sarraute"], "venue": "In 2nd International Conference on Simulation Tools and Techniques (SIMUTools", "citeRegEx": "Futoransky et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Futoransky et al\\.", "year": 2009}, {"title": "Building computer network attacks", "author": ["Ariel Futoransky", "Luciano Notarfrancesco", "Gerardo Richarte", "Carlos Sarraute"], "venue": "Technical report, CoreLabs,", "citeRegEx": "Futoransky et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Futoransky et al\\.", "year": 2003}, {"title": "The Directed Steiner Network Problem is tractable for a constant number of terminals", "author": ["Jon Feldman", "Matthias Ruhl"], "venue": "In FOCS,", "citeRegEx": "Feldman and Ruhl.,? \\Q1999\\E", "shortCiteRegEx": "Feldman and Ruhl.", "year": 1999}, {"title": "The model-based approach to autonomous behavior: A personal view", "author": ["Hector Geffner"], "venue": "In Proceedings of AAAI-10. Atlanta,", "citeRegEx": "Geffner.,? \\Q2010\\E", "shortCiteRegEx": "Geffner.", "year": 2010}, {"title": "An intelligent technique for generating minimal attack graph", "author": ["Nirnay Ghosh", "S.K. Ghosh"], "venue": "In First Workshop on Intelligent Security (Security and Artificial Intelligence) (SecArt", "citeRegEx": "Ghosh and Ghosh.,? \\Q2009\\E", "shortCiteRegEx": "Ghosh and Ghosh.", "year": 2009}, {"title": "Automated Planning: theory and practice", "author": ["Malik Ghallab", "Dana Nau", "Paolo Traverso"], "venue": null, "citeRegEx": "Ghallab et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Ghallab et al\\.", "year": 2004}, {"title": "Historical applications of maneuver warfare in the 20th century", "author": ["Peter E. Higgins"], "venue": "Technical report,", "citeRegEx": "Higgins.,? \\Q1990\\E", "shortCiteRegEx": "Higgins.", "year": 1990}, {"title": "A common language for computer security incidents", "author": ["John D. Howard", "Thomas A. Longstaff"], "venue": "Sandia Report: SAND98-8667, Sandia National Laboratories,", "citeRegEx": "Howard and Longstaff.,? \\Q1998\\E", "shortCiteRegEx": "Howard and Longstaff.", "year": 1998}, {"title": "FF: The fast-forward planning system", "author": ["J\u00f6rg Hoffmann"], "venue": "AI magazine,", "citeRegEx": "Hoffmann.,? \\Q2001\\E", "shortCiteRegEx": "Hoffmann.", "year": 2001}, {"title": "Extending FF to numerical state variables", "author": ["J\u00f6rg Hoffmann"], "venue": "In Proceedings of the 15th European Conference on Artificial Intelligence", "citeRegEx": "Hoffmann.,? \\Q2002\\E", "shortCiteRegEx": "Hoffmann.", "year": 2002}, {"title": "Topological analysis of network attack vulnerability. Managing Cyber Threats: Issues, Approaches and Challenges", "author": ["S. Jajodia", "S. Noel", "B. O\u2019Berry"], "venue": null, "citeRegEx": "Jajodia et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Jajodia et al\\.", "year": 2005}, {"title": "Two formal analyses of attack graphs", "author": ["S. Jha", "O. Sheyner", "J. Wing"], "venue": "In 15th IEEE Computer Security Foundations Workshop,", "citeRegEx": "Jha et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2002}, {"title": "Minimization and reliability analyses of attack", "author": ["Somesh Jha", "Jeannette Wing", "Oleg Sheyner"], "venue": null, "citeRegEx": "Jha et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2002}, {"title": "Probabilistic Graphical Models: Principles and Techniques", "author": ["D. Koller", "N. Friedman"], "venue": null, "citeRegEx": "Koller and Friedman.,? \\Q2009\\E", "shortCiteRegEx": "Koller and Friedman.", "year": 2009}, {"title": "SARSOP: Efficient pointbased POMDP planning by approximating optimally reachable belief spaces", "author": ["H. Kurniawati", "D. Hsu", "W. Lee"], "venue": "In RSS IV,", "citeRegEx": "Kurniawati et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kurniawati et al\\.", "year": 2008}, {"title": "An annotated review of past papers on attack graphs", "author": ["Richard Lippmann", "Kyle Ingols"], "venue": "Technical Report ESC-TR-2005-054, Lincoln Laboratory,", "citeRegEx": "Lippmann and Ingols.,? \\Q2005\\E", "shortCiteRegEx": "Lippmann and Ingols.", "year": 2005}, {"title": "How to systematically classify computer security intrusions", "author": ["Ulf Lindqvist", "Erland Jonsson"], "venue": "Proceedings of the 1997 IEEE Symposium on Security and Privacy,", "citeRegEx": "Lindqvist and Jonsson.,? \\Q1997\\E", "shortCiteRegEx": "Lindqvist and Jonsson.", "year": 1997}, {"title": "Rinse: The real-time immersive network simulation environment for network security exercises", "author": ["Michael Liljenstam", "Jason Liu", "David Nicol", "Yougu Yuan", "Guanhua Yan", "Chris Grier"], "venue": "In Workshop on Principles of Advanced and Distributed Simulation,", "citeRegEx": "Liljenstam et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Liljenstam et al\\.", "year": 2005}, {"title": "Marionnet: A virtual network laboratory and simulation tool", "author": ["Jean-Vincent Loddo", "Luca Saiu"], "venue": "In First International Conference on Simulation Tools and Techniques for Communications, Networks and Systems,", "citeRegEx": "Loddo and Saiu.,? \\Q2008\\E", "shortCiteRegEx": "Loddo and Saiu.", "year": 2008}, {"title": "Attack Planning in the Real World", "author": ["Jorge Lucangeli", "Carlos Sarraute", "Gerardo Richarte"], "venue": "In Proceedings of the AAAI Workshop on Intelligent Security (SecArt", "citeRegEx": "Lucangeli et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Lucangeli et al\\.", "year": 2010}, {"title": "Remote OS detection via TCP/IP stack fingerprinting", "author": ["Gordon Fyodor Lyon"], "venue": "Phrack Magazine,", "citeRegEx": "Lyon.,? \\Q1998\\E", "shortCiteRegEx": "Lyon.", "year": 1998}, {"title": "The PDDL Planning Domain Definition Language", "author": ["Drew McDermott"], "venue": "The AIPS-98 Planning Competition Committee,", "citeRegEx": "McDermott,? \\Q1998\\E", "shortCiteRegEx": "McDermott", "year": 1998}, {"title": "Attack modeling for information security and survivability", "author": ["A.P. Moore", "R.J. Ellison", "R.C. Linger"], "venue": "Technical Note CMU/SEI-2001TN-001,", "citeRegEx": "Moore et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moore et al\\.", "year": 2001}, {"title": "A survey of partially observable Markov decision processes", "author": ["G. Monahan"], "venue": "Management Science,", "citeRegEx": "Monahan.,? \\Q1982\\E", "shortCiteRegEx": "Monahan.", "year": 1982}, {"title": "Penetration testing automation", "author": ["H.D. Moore"], "venue": "In SANS Penetration Testing Summit,", "citeRegEx": "Moore.,? \\Q2010\\E", "shortCiteRegEx": "Moore.", "year": 2010}, {"title": "Inside the slammer worm", "author": ["David Moore", "Vern Paxson", "Stefan Savage", "Colleen Shannon", "Stuart Staniford", "Nicholas Weaver"], "venue": "IEEE Security and Privacy,", "citeRegEx": "Moore et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Moore et al\\.", "year": 2003}, {"title": "Advances in Topological Vulnerability Analysis", "author": ["S. Noel", "M. Elder", "S. Jajodia", "P. Kalapa", "S. O\u2019Hare", "K. Prole"], "venue": "In Proceedings of the 2009 Cybersecurity Applications & Technology Conference for Homeland Security,", "citeRegEx": "Noel et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Noel et al\\.", "year": 2009}, {"title": "Managing attack graph complexity through visual hierarchical aggregation", "author": ["S. Noel", "S. Jajodia"], "venue": "In Proceedings of the 2004 ACM workshop on Visualization and data mining for computer security,", "citeRegEx": "Noel and Jajodia.,? \\Q2004\\E", "shortCiteRegEx": "Noel and Jajodia.", "year": 2004}, {"title": "Understanding complex network attack graphs through clustered adjacency matrices", "author": ["S. Noel", "S. Jajodia"], "venue": "In Proceedings of the 21st Annual Computer Security Applications Conference,", "citeRegEx": "Noel and Jajodia.,? \\Q2005\\E", "shortCiteRegEx": "Noel and Jajodia.", "year": 2005}, {"title": "Anytime point-based approximations for large POMDPs", "author": ["J. Pineau", "G. Gordon", "S. Thrun"], "venue": "JAIR, 27:335\u2013380,", "citeRegEx": "Pineau et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Pineau et al\\.", "year": 2006}, {"title": "A virtual honeypot framework", "author": ["Niels Provos"], "venue": "Proceedings of the 13th USENIX Security Symposium,", "citeRegEx": "Provos.,? \\Q2004\\E", "shortCiteRegEx": "Provos.", "year": 2004}, {"title": "A graph-based system for network-vulnerability analysis", "author": ["Cynthia A. Phillips", "Laura Painton Swiler"], "venue": "In Workshop on New Security Paradigms,", "citeRegEx": "Phillips and Swiler.,? \\Q1998\\E", "shortCiteRegEx": "Phillips and Swiler.", "year": 1998}, {"title": "Using model checking to analyze network vulnerabilities", "author": ["R. Ritchey", "Paul Ammann"], "venue": "In IEEE Symposium on Security and Privacy,", "citeRegEx": "Ritchey and Ammann.,? \\Q2000\\E", "shortCiteRegEx": "Ritchey and Ammann.", "year": 2000}, {"title": "Modern intrusion practices", "author": ["Gerardo Richarte"], "venue": "In Black Hat Briefings,", "citeRegEx": "Richarte.,? \\Q2003\\E", "shortCiteRegEx": "Richarte.", "year": 2003}, {"title": "Online planning algorithms for POMDPs", "author": ["S. Ross", "J. Pineau", "S. Paquet", "B. Chaib-draa"], "venue": "JAIR, 32:663\u2013704,", "citeRegEx": "Ross et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ross et al\\.", "year": 2008}, {"title": "Zombie 2.0", "author": ["F. Russ", "D. Tiscornia"], "venue": "In Hack.lu Conference,", "citeRegEx": "Russ and Tiscornia.,? \\Q2007\\E", "shortCiteRegEx": "Russ and Tiscornia.", "year": 2007}, {"title": "New algorithms for attack planning", "author": ["Carlos Sarraute"], "venue": "In FRHACK Conference,", "citeRegEx": "Sarraute.,? \\Q2009\\E", "shortCiteRegEx": "Sarraute.", "year": 2009}, {"title": "Probabilistic Attack Planning in Network + WebApps Scenarios", "author": ["Carlos Sarraute"], "venue": null, "citeRegEx": "Sarraute.,? \\Q2009\\E", "shortCiteRegEx": "Sarraute.", "year": 2009}, {"title": "Using AI Techniques to improve Pentesting Automation", "author": ["Carlos Sarraute"], "venue": "In Hackito Ergo Sum (HES), Paris, France,", "citeRegEx": "Sarraute.,? \\Q2010\\E", "shortCiteRegEx": "Sarraute.", "year": 2010}, {"title": "On exploit quality metrics \u2013 and how to use them for automated pentesting", "author": ["Carlos Sarraute"], "venue": null, "citeRegEx": "Sarraute.,? \\Q2011\\E", "shortCiteRegEx": "Sarraute.", "year": 2011}, {"title": "Some research directions in automated pentesting", "author": ["Carlos Sarraute"], "venue": null, "citeRegEx": "Sarraute.,? \\Q2011\\E", "shortCiteRegEx": "Sarraute.", "year": 2011}, {"title": "Decomposing the network to perform attack planning under uncertainty", "author": ["Carlos Sarraute"], "venue": "In Hackito Ergo Sum (HES), Paris, France,", "citeRegEx": "Sarraute.,? \\Q2012\\E", "shortCiteRegEx": "Sarraute.", "year": 2012}, {"title": "Penetration testing == POMDP planning", "author": ["Carlos Sarraute", "Olivier Buffet", "J\u00f6rg Hoffmann"], "venue": "In Proceedings of the 3rd Workshop on Intelligent Security (SecArt\u201911),", "citeRegEx": "Sarraute et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Sarraute et al\\.", "year": 2011}, {"title": "Les POMDP font de meilleurs hackers: Tenir compte de l\u2019incertitude dans les tests de p\u00e9n\u00e9tration", "author": ["Carlos Sarraute", "Olivier Buffet", "J\u00f6rg Hoffmann"], "venue": "In Proceedings of JFPDA-12,", "citeRegEx": "Sarraute et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Sarraute et al\\.", "year": 2012}, {"title": "POMDPs make better hackers: Accounting for uncertainty in penetration testing", "author": ["Carlos Sarraute", "Olivier Buffet", "J\u00f6rg Hoffmann"], "venue": "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence", "citeRegEx": "Sarraute et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Sarraute et al\\.", "year": 2012}, {"title": "Secrets & lies: digital security in a networked world, chapter 21", "author": ["Bruce Schneier"], "venue": null, "citeRegEx": "Schneier.,? \\Q2000\\E", "shortCiteRegEx": "Schneier.", "year": 2000}, {"title": "Automated generation and analysis of attack graphs", "author": ["O. Sheyner", "J. Haines", "S. Jha", "R. Lippmann", "J.M. Wing"], "venue": "In IEEE Symposium on Security and Privacy,", "citeRegEx": "Sheyner et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Sheyner et al\\.", "year": 2002}, {"title": "Symbolic heuristic search value iteration for factored POMDPs", "author": ["H.S. Sim", "K.-E. Kim", "J.H. Kim", "D.-S. Chang", "M.-W. Koo"], "venue": "In Proc. of AAAI\u201908,", "citeRegEx": "Sim et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Sim et al\\.", "year": 2008}, {"title": "A snapshot of global internet worm activity", "author": ["D. Song", "R. Malan", "R. Stone"], "venue": "Technical report, Arbor Networks,", "citeRegEx": "Song et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Song et al\\.", "year": 2001}, {"title": "A graphbased network-vulnerability analysis system", "author": ["Laura P. Swiler", "Cynthia Phillips", "Timothy Gaylor"], "venue": "Technical report,", "citeRegEx": "Swiler et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Swiler et al\\.", "year": 1998}, {"title": "Honeypots: Tracking Hackers", "author": ["L. Spitzner"], "venue": null, "citeRegEx": "Spitzner.,? \\Q2002\\E", "shortCiteRegEx": "Spitzner.", "year": 2002}, {"title": "An algorithm to find optimal attack paths in nondeterministic scenarios", "author": ["Carlos Sarraute", "Gerardo Richarte", "Jorge Lucangeli"], "venue": "In Proceedings of the ACM Workshop on Artificial Intelligence and Security (AISec\u201911),", "citeRegEx": "Sarraute et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Sarraute et al\\.", "year": 2011}, {"title": "Heuristic search value iteration for POMDPs", "author": ["T. Smith", "R.G. Simmons"], "venue": "In Proc. of UAI\u201904,", "citeRegEx": "Smith and Simmons.,? \\Q2004\\E", "shortCiteRegEx": "Smith and Simmons.", "year": 2004}, {"title": "Perseus: Randomized point-based value iteration for POMDPs", "author": ["M. Spaan", "N. Vlassis"], "venue": "JAIR, 24:195\u2013220,", "citeRegEx": "Spaan and Vlassis.,? \\Q2005\\E", "shortCiteRegEx": "Spaan and Vlassis.", "year": 2005}, {"title": "Advances in automated attack planning", "author": ["Carlos Sarraute", "Alejandro Weil"], "venue": "In PacSec Conference,", "citeRegEx": "Sarraute and Weil.,? \\Q2008\\E", "shortCiteRegEx": "Sarraute and Weil.", "year": 2008}, {"title": "Modeling internet attacks", "author": ["T. Tidwell", "R. Larson", "K. Fitch", "J. Hale"], "venue": "In Proceedings of the 2001 IEEE Workshop on Information Assurance and Security,", "citeRegEx": "Tidwell et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Tidwell et al\\.", "year": 2001}, {"title": "Scalability, fidelity, and containment in the Potemkin virtual honeyfarm", "author": ["Michael Vrable", "Justin Ma", "Jay Chen", "David Moore", "Erik Vandekieft", "Alex C. Snoeren", "Geoffrey M. Voelker", "Stefan Savage"], "venue": "SIGOPS Oper. Syst. Rev.,", "citeRegEx": "Vrable et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Vrable et al\\.", "year": 2005}, {"title": "Distributed worm simulation with a realistic internet model", "author": ["Songjie Wei", "Jelena Mirkovic", "Martin Swany"], "venue": "In PADS \u201905: Proceedings of the 19th Workshop on Principles of Advanced and Distributed Simulation,", "citeRegEx": "Wei et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Wei et al\\.", "year": 2005}, {"title": "The design and use of internet sinks for network abuse monitoring", "author": ["V. Yegneswaran", "P. Barford", "D. Plonka"], "venue": "In Proceedings of Recent Advances in Intrusion Detection (RAID),", "citeRegEx": "Yegneswaran et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Yegneswaran et al\\.", "year": 2004}, {"title": "PPDDL 1.0: The language for the probabilistic part of IPC-4", "author": ["H.L.S. Younes", "M.L. Littman"], "venue": "In Proc. International Planning Competition,", "citeRegEx": "Younes and Littman.,? \\Q2004\\E", "shortCiteRegEx": "Younes and Littman.", "year": 2004}], "referenceMentions": [], "year": 2013, "abstractText": "x Acknowledgements xii Chapter", "creator": "LaTeX with hyperref package"}}}