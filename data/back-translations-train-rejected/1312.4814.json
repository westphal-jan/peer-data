{"id": "1312.4814", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Dec-2013", "title": "Mining Malware Specifications through Static Reachability Analysis", "abstract": "The number of malicious software (malware) is growing out of control. Syntactic signature based detection cannot cope with such growth and manual construction of malware signature databases needs to be replaced by computer learning based approaches. Currently, a single modern signature capturing the semantics of a malicious behavior can be used to replace an arbitrarily large number of old-fashioned syntactical signatures. However teaching computers to learn such behaviors is a challenge. Existing work relies on dynamic analysis to extract malicious behaviors, but such technique does not guarantee the coverage of all behaviors. To sidestep this limitation we show how to learn malware signatures using static reachability analysis. The idea is to model binary programs using pushdown systems (that can be used to model the stack operations occurring during the binary code execution), use reachability analysis to extract behaviors in the form of trees, and use subtrees that are common among the trees extracted from a training set of malware files as signatures. To detect malware we propose to use a tree automaton to compactly store malicious behavior trees and check if any of the subtrees extracted from the file under analysis is malicious. Experimental data shows that our approach can be used to learn signatures from a training set of malware files and use them to detect a test set of malware that is 5 times the size of the training set.", "histories": [["v1", "Tue, 17 Dec 2013 15:08:39 GMT  (75kb,D)", "http://arxiv.org/abs/1312.4814v1", "Lecture notes in computer science (2013)"]], "COMMENTS": "Lecture notes in computer science (2013)", "reviews": [], "SUBJECTS": "cs.CR cs.AI cs.LO", "authors": ["hugo daniel macedo", "tayssir touili"], "accepted": false, "id": "1312.4814"}, "pdf": {"name": "1312.4814.pdf", "metadata": {"source": "CRF", "title": "Mining malware specifications through static reachability analysis", "authors": ["Hugo Daniel Macedo", "Tayssir Touili"], "emails": ["macedo@liafa.univ-paris-diderot.fr", "touili@liafa.univ-paris-diderot.fr"], "sections": [{"heading": "1 Introduction", "text": "This year it is so far that it will only take one year to move on to the next round."}, {"heading": "2 Binary code modeling", "text": "Malware detection takes place directly in the executable encoding of the software (binary code with machine instructions and data).By modelling the operational semantics of binary code, we are able to analyze it without having to rely on execution. In this section, the modeling framework and the modeling of executable files are presented."}, {"heading": "2.1 Pushdown systems", "text": "A Pushdown System (PDS) is a triple P = (P, P, Q), where P is a finite set of control points, and a finite alphabet of stack symbols, and we write < p, P \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2) a finite set of transition rules. The immediate succession rule P \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 (P) > > > \u00b2 \u00b2 is an element of P \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2, and the immediate succession rule P \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 (P) \u00b7 \u00b2 \u00b2 \u00b2 \u00b2 (P) \u00b7 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 (P) is defined as follows: If < p, P \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P < P > > < P < P; P < P < P; P < P; P < P < P < P; P < P < P > > > < P > > < P > < P; P < P > < P; P < P > > < P > > > > < P < P < P < P < P; P > < P > < P < P; P > < P, P > < P < P, P > < P, P, P, P, P, P and P < P < P < P < P < P < P < P < P < P < P < P < P, P > < P, P > < P > < P > < P > < P, P, P,"}, {"heading": "2.2 Modeling binary programs with PDSs", "text": "We use the approach described in [24, Section 2] to model each executable program P. The approach is based on the assumption that there is an oracle O that calculates from the binary program P = (P, \u0430, \u2206), where P corresponds to the control points of the program, where the API corresponds to the approximate set of values that are pushed onto the stack, and vice versa, the different statements of the program. The obtained PDS imitates the runs of program P. In addition to the approach of [24], the API should be the set of all function designations of the application program interface available in the program. We assume that the oracle O approximates the set PAPI P of the control points of a program that are compiled at program runtime (dynamically linked), the number of parameters of such functions, and the type of individual parameters of the PAPI lote parameters as parameters of a program."}, {"heading": "3 Malicious behavior specifications", "text": "As already mentioned, malicious behavior, data flow relationships between system function calls, are expressed as trees in which nodes represent system functions or parameter values and edges specify the data flow or number of the parameter to which the value was passed."}, {"heading": "3.1 Edge labeled trees", "text": "A disordered alphabet is a finite set of F symbols. In the face of a disordered alphabet F, a set of colors C may be an alphabet of simple symbols and disjunction of F, and X may be a set of variables separated from F. The set T (F, C, X) of colored terms above the disordered alphabet F, colors C, and variable X is the smallest set of terms such as: - F, C, X), - X T (F, C, X), and - f (tree) of colored terms above the disordered alphabet F, colors C, and variable X is the smallest set of terms such as: - F T (F, C, X), - X T (F, X).fbac1 c2Fig."}, {"heading": "3.2 System call dependency trees", "text": "We represent malware behavior as trees that encode data flow relationships between system function calls. Tree nodes represent either system functions or parameter values. 8 edge colors denote the properties of the data flow between functions, e.g. 2 1 labeling of an edge from functions f and f \u2032 means that at some point f is called with a value v as the second parameter that is of type out, and then f \u2032 is called with v as the first parameter that is of type in itself. If an edge connects a node with function f and a child node with a value v, meaning that the function has been called with parameter v, it is labeled with the number of the parameter, i.e. a call with 0 as the first parameter to function f, we append 1 as labeling of the edge from node f to node 0.Definition 1. Formally, F is left with the set of all system call function names (the union of all possible API function names specified by the Oracle section 2 of values, and the row of numbers returned)."}, {"heading": "4 Mining malware specifications", "text": "In this section, we show how to calculate the SCDTs that correspond to the behavior of the malware that we use as common specifications of the malware. Given a limited number of programs P1,... we calculate PDSs P1,..., Pq that model these malicious programs. Then, for each PDS Pi, we calculate a set of trees TSi that contains the data flows that are represented as SCDTs for the program Pi. From the calculated set of trees for each program TS1,..., TSq, we calculate the common subtrees that most likely appear in malware that we use as malware specifications. To calculate the tree groups TSi, we proceed as follows: For each program Pi that was modeled as PDS Pi, we calculate the common subtrees that encode the set of achievable configurations by calculating the configurations of achievable configurations from the accessibility algorithm."}, {"heading": "4.1 System call targeted reachability analysis", "text": "To calculate the data flows for a malware push-down system model P = (P, > Pi, >), we first calculate the accessibility of P using the algorithms presented in [12]. From P we build the (MA) automaton A, which recognizes the mail. (< pi, >) To calculate the data flows between the system-relevant control points po, pd, PAPI with the parameter numbers% ar (po) and% ar (pd) = n, we only need to look at the topm + 1 and n + 1 elements of the stack, which capture at the control points po, pd and PAPI with the parameter numbers% ar (po) and% ar (pd) = n."}, {"heading": "4.2 Extracting SCDTs", "text": "We assume that a maximum tree height h = > system configuration is given as input. We write \u03c9 [n] to denote the nth element of any word. < po, \u03c9o > conf (A \u2020 i) do 5 TSi (TSi 2 TSi \u2190 \u2212 \u2205; 3 A \u2020 i \u2190 (post) (< pi, >))); 4 forall the < po, \u03c9o > (A \u2020 i) do 5 TSi (TSi {BuildSCDT (< po, \u03c9o >, h)}; 6 end 7 end 8 return TS; Algorithm 1 iterates over models P1,. Pq (line 1) For each one it initializes the set of resulting trees to the empty set (line 2) and calculates the configurations corresponding to the system calls < pi, > (line 3)."}, {"heading": "4.3 Computing malicious behavior trees", "text": "To select the most malicious trees, we calculate the most common sub-trees in the group of trees extracted from the group of malware used to form our detector. To do this, we need the term support set, the set of trees containing a particular sub-tree, and the term tree support, which gives the ratio of the trees containing the sub-tree to the totality of the trees. In view of a limited number of trees TS T (F, C) and a tree t TS, the support set of a tree t is defined as Tt = {t \u2032 | t \u00b2, t \u00b2 TS}, which gives the ratio of the trees containing the sub-tree to the totality of the trees. Tree support for a tree in group TS is defined as sup (t) = | Tt | TS |. For a fixed threshold k, the group of common trees is defined by T as malware."}, {"heading": "5 Malware detection", "text": "To determine whether a particular program P is malware or not, we re-apply the technique described in Section 4 to calculate the SCDTs for the program P to be analyzed, and then we check whether such trees correspond to malicious behavior, that is, whether such trees contain subtrees that correspond to malicious behavior. To perform this task efficiently, we use tree automats. The advantage of using tree automats is that we can build the minimal automaton that detects the set of malicious signatures in order to maintain a compact and efficient database. In addition, malware detection can be performed efficiently by using automaton membership. However, we need to adapt the tree automats to find malware detection, that is, to define automats that can detect edge-marked trees."}, {"heading": "5.1 Tree automata for edge labeled trees", "text": "Definition 4. A hedge edge called an automatic tree (HELTA) over T (F, C) is a tuple H = (QH, F, C, A, \u0445 H), where QH is a finite set of states, A QH is the set of final states, and \u2206 H is a finite set of circumscriptions defined as f (R). We define a train relationship \u2212 \u2192 H between the basic terms in T (F, QH, C) as follows: Let T (F, QH, C) have a regular word language over C (QH), i.e. the language that encodes all possible children of the tree node f."}, {"heading": "5.2 Inferring tree automata from malicious behavior trees", "text": "In this section we show how to infer a HELTA (t 3 m3) meaning of the tree that includes the derived behavior. (t) Thus, if t is defined as malicious behavior (t = 1), and t is defined as behavior (t = 1), so that t is a tree of the form f (c1), c2 (b))), s.t. a, b (e1) and E (F, c) is an environment, then the tree t must be a tree of the form f (t11),.., c1m1 (t 1 m1), c1 (e1))), c21 (t 2 1),., c 2 m2 (t 2 m2), c2 (b (e2), c 3 (t 3 m3)."}, {"heading": "R1 For all f \u2208 F , f([C(QH)]\u2217)\u2192 qf \u2208 \u2206H", "text": "R2 For all t = f (c1 (t1),.., cn (tn)), so that tC t \"and t\" MalSCDT, f \"([C (QH)], c1\" (qt1) [C (QH)],... [C (QH)], cn (qtn) [C (QH)]), qf \"(c1 (t1),..., cn (tn), HR3 For all end states qt\" A \"and all f\" F, \"f\" ([C (QH)], qut, \"[C (QH)],), qt\" (H1), for f \"F,\" qf \"recognize all terms whose roots f. This is ensured by R1. In the rules [C (QH) that allow to recognize terms t in (1) and cji (t\" i) in (2)."}, {"heading": "5.3 Malware detection", "text": "The detection phase works as follows: With a program P for analysis, we build a PDS model P using the approach described in Section 2, then we extract the behavior group TS contained in P, using the approach in Section 4. Then we use the automaton H to see if one of the trees in TS can match the automaton. If this is the case, program P is classified as malware. If we add the tree in Fig. 6 and the tree in Fig. 2 is the only malicious behavior in MalSCDT, which in turn matches C = {1, 2 1} and F = {0, CopyFile, ExitProcess, GetModuleFileName, GetModuleName}. We define an automaton H, in which the state QH = {q0, qExitProcess, qCopyFile (qCopyFile) [qyFile] (q1, qyFile] (q1, qyF1, F1) (Get1, [) (Get1, Get1, Fleq1] (F1] (F1)."}, {"heading": "6 Experiments", "text": "To evaluate our approach, we implemented a tool prototype that was tested on a dataset of real malware and benign programs; the malware input dataset contains 1176 instances of malware (viruses, backdoors, trojans, worms,...) collected from virus repositories as VX Heavens, and a disjointed dataset of 250 benign files collected from a Windows XP installation with a fresh operating system. We randomly divided the malware dataset into a training and testing group, using the train dataset to infer the malicious trees used to detect the samples from the test group; we were able to detect 983 malware files from the malicious trees derived from 193 malware files, and show that benign programs are benign, i.e. a false positive rate of 0%."}, {"heading": "6.1 Inferring malicious behaviors", "text": "To deduce malicious behavior, we turned each of the 193 malware binaries into a PDS model using the approach described in Section 2. To implement Oracle O, we use the PoMMaDe tool [25], which uses Jakstab [19] and IDA Pro [15]. Jakstab performs static analysis of the binary program, but it does not allow to extract the API functions so that IDA Pro is used to obtain such information, thus obtaining% ar and% \u03bb. In practice, by querying the information available on the MSDN website, we applied algorithm 1 to the PDS models to extract the SCDTs for each of the malware instances. The current results were obtained with an h-value of 2 to avoid approaching the malware, in the SDN website.We apply algorithm 1 to the PDS models to extract the SCDTs."}, {"heading": "6.2 Detecting malware", "text": "Malware detection is reduced to the generation of SCDTs and verified that they are detected by the approach described in Section 4.2. So when a subtree of the extracted tree is detected by the machine that detects the malicious behavior, we decide that the binary sample is malware. We implemented such a procedure in our tool and were able to detect 983 malware samples from 330 different families. In Table 2, we show the bandwidth of the malware families and the number of samples that our tool detects as malware. On average, our tool extracts 64 SCDTs in 2.15 seconds for each file (this value can be greatly improved as runtime efficiency was not a main goal of the prototype design).The discrepancy in the number of trees generated (compared to the training set) is justified by implementing SCDTs."}, {"heading": "7 Related work", "text": "The basic approaches to calculable functions [1], based on Kleene's recursion theorem [4,5,6], or the proper definition with MALog [20] capture the essence of such behaviors, but are too abstract to use in practice or require the full specification of software functionality. Our work is close to the approaches that use model verification and temporal logic as a specification of malicious behavior [24,25]. In such work, specifications must be designed manually while we learn them automatically. Some of the trees we describe are encrypted in such formulas."}, {"heading": "8 Conclusion", "text": "In this paper, we demonstrated how static accessibility analysis techniques can be combined to derive semantic signatures of malware in the form of malicious trees that describe the flow of data between system calls. Our experiments show that the approach can be used to automatically derive malicious behavior specifications and detect multiple malware samples from a priori given smaller malware. We were able to detect 983 malware files from the malicious trees derived from 193 malware files, and apply the detector to 250 benign files that receive a 0% positive error rate. In the future work, we envisage improving binary modeling techniques, e.g. enriching the functional parameter type system, to allow for better approximations. The use of more advanced mining techniques, e.g. structural leap mining, used in [14] can be used to improve the learning model approach to the comparison of a tree type approach with other forms in the direction of expression and complexity."}], "references": [{"title": "An abstract theory of computer viruses", "author": ["L.M. Adleman"], "venue": "In Proceedings of the 8th Annual Int. Cryptology Conference on Advances in Cryptology,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1988}, {"title": "Malware analysis with tree automata inference", "author": ["D. Babic", "D. Reynaud", "D. Song"], "venue": "In CAV,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "Static analysis of binary code to isolate malicious behaviors", "author": ["J. Bergeron", "M. Debbabi", "M.M. Erhioui", "B. Ktari"], "venue": "In WETICE,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1999}, {"title": "Toward an Abstract Computer Virology", "author": ["G. Bonfante", "M. Kaczmarek", "J.-Y. Marion"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2005}, {"title": "On Abstract Computer Virology from a Recursion Theoretic Perspective", "author": ["G. Bonfante", "M. Kaczmarek", "J.-Y. Marion"], "venue": "Journal in Computer Virology,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2006}, {"title": "A Classification of Viruses Through Recursion Theorems", "author": ["G. Bonfante", "M. Kaczmarek", "J.-Y. Marion"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2007}, {"title": "Architecture of a morphological malware detector", "author": ["G. Bonfante", "M. Kaczmarek", "J.-Y. Marion"], "venue": "Journal in Computer Virology,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Reachability analysis of pushdown automata: Application to model-checking", "author": ["A. Bouajjani", "J. Esparza", "O. Maler"], "venue": "In CONCUR,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1997}, {"title": "Static analysis of executables to detect malicious patterns", "author": ["M. Christodorescu", "S. Jha"], "venue": "In Proceedings of the 12th conf. on USENIX Security Symposium,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2003}, {"title": "Mining specifications of malicious behavior", "author": ["M. Christodorescu", "S. Jha", "C. Kruegel"], "venue": "In Proceedings of the 1st India software engineering conference,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Semantics-aware malware detection", "author": ["M. Christodorescu", "S. Jha", "S.A. Seshia", "D.X. Song", "R.E. Bryant"], "venue": "In IEEE Symposium on Security and Privacy,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2005}, {"title": "Efficient algorithms for model checking pushdown systems", "author": ["J. Esparza", "D. Hansel", "P. Rossmanith", "S. Schwoon"], "venue": "In CAV,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2000}, {"title": "Symantec internet security threat report trends", "author": ["M. Fossi", "G. Egan", "K. Haley", "E. Johnson", "T. Mack", "T. Adams", "J. Blackbird", "M. Low", "D. Mazurek", "D. McKinney"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Synthesizing near-optimal malware specifications from suspicious behaviors", "author": ["M. Fredrikson", "S. Jha", "M. Christodorescu", "R. Sailer", "X. Yan"], "venue": "In IEEE S. Security and Privacy,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Using verification technology to specify and detect malware", "author": ["A. Holzer", "J. Kinder", "H. Veith"], "venue": "In EUROCAST,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Detecting malicious code by model checking", "author": ["J. Kinder", "S. Katzenbeisser", "C. Schallhart", "H. Veith"], "venue": "In DIMVA,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2005}, {"title": "Proactive Detection of Computer Worms Using Model Checking", "author": ["J. Kinder", "S. Katzenbeisser", "C. Schallhart", "H. Veith"], "venue": "IEEE Trans. on Dependable and Secure Computing,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2010}, {"title": "Jakstab: A static analysis platform for binaries", "author": ["J. Kinder", "H. Veith"], "venue": "In CAV,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2008}, {"title": "A general definition of malware", "author": ["S. Kramer", "J.C. Bradfield"], "venue": "Journal in computer virology,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2010}, {"title": "Static verification of worm and virus behavior in binary executables using model checking", "author": ["P. Singh", "A. Lakhotia"], "venue": "In Information Assurance Workshop,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}, {"title": "Dynamic program analysis of Microsoft Windows applications", "author": ["A. Skaletsky", "T. Devor", "N. Chachmon", "R.S. Cohn", "K.M. Hazelwood", "V. Vladimirov", "M. Bach"], "venue": "In ISPASS,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Efficient malware detection using model-checking", "author": ["F. Song", "T. Touili"], "venue": "In FM,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Pushdown model checking for malware detection", "author": ["F. Song", "T. Touili"], "venue": "In TACAS,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "LTL model-checking for malware detection", "author": ["F. Song", "T. Touili"], "venue": "In TACAS", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2013}, {"title": "The Art of Computer Virus", "author": ["P. Szor"], "venue": "Research and Defense. Addison-Wesley Pro.,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2005}, {"title": "Mal-id: Automatic malware detection using common segment analysis and meta-features", "author": ["G. Tahan", "L. Rokach", "Y. Shahar"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2012}, {"title": "A quantitative comparison of the subgraph miners MoFa, gSpan, FFSM, and Gaston", "author": ["M. W\u00f6rlein", "T. Meinl", "I. Fischer", "M. Philippsen"], "venue": "Knowledge Discovery in Databases,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2005}, {"title": "gSpan: Graph-based substructure pattern mining", "author": ["X. Yan", "J. Han"], "venue": "In ICDM,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2002}], "referenceMentions": [{"referenceID": 12, "context": "For instance, in 2010 the number of newly unique variants of malware was 286 million [13] and recent numbers confirm the trend [21].", "startOffset": 85, "endOffset": 89}, {"referenceID": 13, "context": "Research confirms the unsuitability of current malware detectors [14,24].", "startOffset": 65, "endOffset": 72}, {"referenceID": 21, "context": "Research confirms the unsuitability of current malware detectors [14,24].", "startOffset": 65, "endOffset": 72}, {"referenceID": 24, "context": "The basic detection technique is signature matching, it consists in the inspection of the binary code and search for patterns in the form of binary sequences [27].", "startOffset": 158, "endOffset": 162}, {"referenceID": 13, "context": "As it is possible to automatically generate an unbounded number of variants, such databases would have to grow arbitrarily, not to mention it takes about two months to manually update them [14].", "startOffset": 189, "endOffset": 193}, {"referenceID": 2, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 8, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 10, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 14, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 15, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 16, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 23, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 21, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 22, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 19, "context": "Such is the outcome of the recent use of model-checking techniques to perform virus detection [3,9,11,16,17,18,26,24,25,22].", "startOffset": 94, "endOffset": 123}, {"referenceID": 24, "context": "The prime example of a malicious behavior is self-replication [27].", "startOffset": 62, "endOffset": 66}, {"referenceID": 1, "context": "Recent work [2,10,14] shows that we can teach computers to learn malicious behavior specifications.", "startOffset": 12, "endOffset": 21}, {"referenceID": 9, "context": "Recent work [2,10,14] shows that we can teach computers to learn malicious behavior specifications.", "startOffset": 12, "endOffset": 21}, {"referenceID": 13, "context": "Recent work [2,10,14] shows that we can teach computers to learn malicious behavior specifications.", "startOffset": 12, "endOffset": 21}, {"referenceID": 7, "context": "From the reachability analysis of each PDS, we obtain a multi-automaton (MA), a finite automaton encoding the possibly infinite reachable configurations (states and stack contents)[8,12].", "startOffset": 180, "endOffset": 186}, {"referenceID": 11, "context": "From the reachability analysis of each PDS, we obtain a multi-automaton (MA), a finite automaton encoding the possibly infinite reachable configurations (states and stack contents)[8,12].", "startOffset": 180, "endOffset": 186}, {"referenceID": 1, "context": "With such tool we were able to infer some signatures not inferred using previous approaches [2,10,14] because our signatures track calls to functions of the Win32 API instead of calls to the Native API.", "startOffset": 92, "endOffset": 101}, {"referenceID": 9, "context": "With such tool we were able to infer some signatures not inferred using previous approaches [2,10,14] because our signatures track calls to functions of the Win32 API instead of calls to the Native API.", "startOffset": 92, "endOffset": 101}, {"referenceID": 13, "context": "With such tool we were able to infer some signatures not inferred using previous approaches [2,10,14] because our signatures track calls to functions of the Win32 API instead of calls to the Native API.", "startOffset": 92, "endOffset": 101}, {"referenceID": 9, "context": "This number of detected malware is larger than the 16 files reported in [10] and in line with the 912 files detected in [14].", "startOffset": 72, "endOffset": 76}, {"referenceID": 13, "context": "This number of detected malware is larger than the 16 files reported in [10] and in line with the 912 files detected in [14].", "startOffset": 120, "endOffset": 124}, {"referenceID": 1, "context": "Our false positive detection rate is better (5% reported in [2]).", "startOffset": 60, "endOffset": 63}, {"referenceID": 7, "context": "[8,12] For a pushdown system P = (P, \u0393,\u2206) and MA A, there exist MAs Apost\u2217 and Apre\u2217 recognizing post\u2217(Conf(A)) and pre\u2217(Conf(A)) respectively.", "startOffset": 0, "endOffset": 6}, {"referenceID": 11, "context": "[8,12] For a pushdown system P = (P, \u0393,\u2206) and MA A, there exist MAs Apost\u2217 and Apre\u2217 recognizing post\u2217(Conf(A)) and pre\u2217(Conf(A)) respectively.", "startOffset": 0, "endOffset": 6}, {"referenceID": 21, "context": "In addition to the approach of [24], let API be the set of all Application Programming Interface function names available in the program.", "startOffset": 31, "endOffset": 35}, {"referenceID": 11, "context": "To compute the sets of trees TSi we proceed as follows: For each program Pi modeled as a PDS Pi we compute the finite automaton encoding the set of reachable configurations from the initial state using the reachability analysis algorithm from [12].", "startOffset": 243, "endOffset": 247}, {"referenceID": 27, "context": "To calculate the common subtrees we use the algorithm [30] computing frequent subgraph, to compute frequent subtrees.", "startOffset": 54, "endOffset": 58}, {"referenceID": 11, "context": "To compute the data flows for a malware pushdown system model P = (P, \u0393,\u2206), we first calculate the reachability of P using the algorithms presented in [12].", "startOffset": 151, "endOffset": 155}, {"referenceID": 27, "context": "To compute frequent subtrees we specialize the frequent subgraph algorithm presented in [30] to the case of trees.", "startOffset": 88, "endOffset": 92}, {"referenceID": 0, "context": "The algorithm receives a set of trees and a support value k \u2208 [0, 1] and outputs all the subtrees with support at least k.", "startOffset": 62, "endOffset": 68}, {"referenceID": 22, "context": "To implement the oracle O, we use the PoMMaDe tool [25] that uses Jakstab [19] and IDA Pro [15].", "startOffset": 51, "endOffset": 55}, {"referenceID": 17, "context": "To implement the oracle O, we use the PoMMaDe tool [25] that uses Jakstab [19] and IDA Pro [15].", "startOffset": 74, "endOffset": 78}, {"referenceID": 27, "context": "We use the gSpan [30] tool for that, it computes frequent subgraph structures using a depth-first tree search over a canonical labeling of graph edges relying on the linear ordering property of the labeling to prune the search space.", "startOffset": 17, "endOffset": 21}, {"referenceID": 26, "context": "The tool has been applied in various domains as active chemical compound structure mining and its performance is competitive among other tools [29].", "startOffset": 143, "endOffset": 147}, {"referenceID": 9, "context": "This value is in line with the values detailed in [10,14] and better than the 5% reported in [2].", "startOffset": 50, "endOffset": 57}, {"referenceID": 13, "context": "This value is in line with the values detailed in [10,14] and better than the 5% reported in [2].", "startOffset": 50, "endOffset": 57}, {"referenceID": 1, "context": "This value is in line with the values detailed in [10,14] and better than the 5% reported in [2].", "startOffset": 93, "endOffset": 96}, {"referenceID": 0, "context": "The foundational approaches via computable functions [1], based in Kleene\u2019s recursion theorem [4,5,6], or the neat definition using MALog [20] capture the essence of such behaviors, but are too abstract to be used in practice or require the full specification of software functionality.", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "The foundational approaches via computable functions [1], based in Kleene\u2019s recursion theorem [4,5,6], or the neat definition using MALog [20] capture the essence of such behaviors, but are too abstract to be used in practice or require the full specification of software functionality.", "startOffset": 94, "endOffset": 101}, {"referenceID": 4, "context": "The foundational approaches via computable functions [1], based in Kleene\u2019s recursion theorem [4,5,6], or the neat definition using MALog [20] capture the essence of such behaviors, but are too abstract to be used in practice or require the full specification of software functionality.", "startOffset": 94, "endOffset": 101}, {"referenceID": 5, "context": "The foundational approaches via computable functions [1], based in Kleene\u2019s recursion theorem [4,5,6], or the neat definition using MALog [20] capture the essence of such behaviors, but are too abstract to be used in practice or require the full specification of software functionality.", "startOffset": 94, "endOffset": 101}, {"referenceID": 18, "context": "The foundational approaches via computable functions [1], based in Kleene\u2019s recursion theorem [4,5,6], or the neat definition using MALog [20] capture the essence of such behaviors, but are too abstract to be used in practice or require the full specification of software functionality.", "startOffset": 138, "endOffset": 142}, {"referenceID": 21, "context": "Our work is close to the approaches using model checking and temporal logic formulas as malicious behavior specification [24,25].", "startOffset": 121, "endOffset": 128}, {"referenceID": 22, "context": "Our work is close to the approaches using model checking and temporal logic formulas as malicious behavior specification [24,25].", "startOffset": 121, "endOffset": 128}, {"referenceID": 9, "context": "Regarding semantic signature inference there are the works [10,14] where the extraction of behaviors is based on dynamic analysis of executables.", "startOffset": 59, "endOffset": 66}, {"referenceID": 13, "context": "Regarding semantic signature inference there are the works [10,14] where the extraction of behaviors is based on dynamic analysis of executables.", "startOffset": 59, "endOffset": 66}, {"referenceID": 1, "context": "Another dynamic analysis based approach is the one of [2] where trees, alike ours, express the same kind of data flows between nodes representing system calls.", "startOffset": 54, "endOffset": 57}, {"referenceID": 20, "context": "slower during execution [23].", "startOffset": 24, "endOffset": 28}, {"referenceID": 1, "context": "Plus, from the dataset made publicly available in [2], we notice the signatures involve only functions from the Native API library.", "startOffset": 50, "endOffset": 53}, {"referenceID": 6, "context": "In [7] the authors propose to learn behaviors of binary files by extracting program control-flow graphs using dynamic analysis.", "startOffset": 3, "endOffset": 6}, {"referenceID": 25, "context": "An alternative to semantic signatures are works based on machine learning approaches as [28], which shows that by mining \u201cn\u2212grams\u201d (a sequence of n bits), it is possible to distinguish malware from benign program.", "startOffset": 88, "endOffset": 92}, {"referenceID": 13, "context": "structural leap mining used in [14], can be used to improve the learning approach.", "startOffset": 31, "endOffset": 35}, {"referenceID": 21, "context": "In another direction, given the relation between modal formulas and tree models a comparison between our approach and the approach in [24] concerning expressiveness and complexity is envisaged.", "startOffset": 134, "endOffset": 138}], "year": 2013, "abstractText": "The number of malicious software (malware) is growing out of control. Syntactic signature based detection cannot cope with such growth and manual construction of malware signature databases needs to be replaced by computer learning based approaches. Currently, a single modern signature capturing the semantics of a malicious behavior can be used to replace an arbitrarily large number of old-fashioned syntactical signatures. However teaching computers to learn such behaviors is a challenge. Existing work relies on dynamic analysis to extract malicious behaviors, but such technique does not guarantee the coverage of all behaviors. To sidestep this limitation we show how to learn malware signatures using static reachability analysis. The idea is to model binary programs using pushdown systems (that can be used to model the stack operations occurring during the binary code execution), use reachability analysis to extract behaviors in the form of trees, and use subtrees that are common among the trees extracted from a training set of malware files as signatures. To detect malware we propose to use a tree automaton to compactly store malicious behavior trees and check if any of the subtrees extracted from the file under analysis is malicious. Experimental data shows that our approach can be used to learn signatures from a training set of malware files and use them to detect a test set of malware that is 5 times the size of the training set.", "creator": "LaTeX with hyperref package"}}}