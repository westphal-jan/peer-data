{"id": "1312.6130", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "A Functional View of Strong Negation in Answer Set Programming", "abstract": "The distinction between strong negation and default negation has been useful in answer set programming. We present an alternative account of strong negation, which lets us view strong negation in terms of the functional stable model semantics by Bartholomew and Lee. More specifically, we show that, under complete interpretations, minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. The same account lets us view Lifschitz's two-valued logic programs as a special case of the functional stable model semantics. In addition, we show how non-Boolean intensional functions can be eliminated in favor of Boolean intensional functions, and furthermore can be represented using strong negation, which provides a way to compute the functional stable model semantics using existing ASP solvers. We also note that similar results hold with the functional stable model semantics by Cabalar.", "histories": [["v1", "Fri, 20 Dec 2013 21:01:32 GMT  (23kb,D)", "http://arxiv.org/abs/1312.6130v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["michael bartholomew", "joohyung lee"], "accepted": false, "id": "1312.6130"}, "pdf": {"name": "1312.6130.pdf", "metadata": {"source": "CRF", "title": "A Functional View of Strong Negation in Answer Set Programming", "authors": ["Michael Bartholomew", "Joohyung Lee"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The distinction between default negation and strong negation is useful in response set programming. In particular, it results in an elegant solution to the framework problem. The fact that block b remains at the same place l by inertia, can be described by the rule Lee (b, l, 1) Barth\u0131on (b, l, t), \u0131on (b, l, t), \u0131on (b, l, t + 1) (1) along with the rule that describes the uniqueness of location values [Lifschitz, 2002], \u0445 \u0131On (b, l1, t, t), \u0131on (b, l, t), l 6 = l1) Here \"is the symbol of strong negation that represents explicit falsehood, while\" \u0131not \"is the symbol of default negation (negation as failure). Rule (1) asserts that without explicit evidence to the contrary, block b remains at the site l. If we receive explicitly contradictory information about the location of b."}, {"heading": "2 Preliminaries", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Review: First-Order Stable Model Semantics and Strong Negation", "text": "This review follows [Ferraris et al., 2011]. A signature is defined as a first-order logic (consisting of function constants and predicate constants). [F]. [S]..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "2.2 Review: The Functional Stable Model Semantics", "text": "Functional stable semantics is defined by the modification of semantics in the preceding section to enable \"intentional\" functions (\"intentional\" functions \") (\" intentional \"functions\") (\"intentional\" functions \") (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" intentional \"functions) (\" exemplary \") (\" exemplary \") (exemplary\") (exemplary \") (exemplary\") (exemplary \") (exemplary) (exemplary) (exemplary) (exemplary) ((exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary) (exemplary (exemplary) (exemplary) (exemplary) (exemplary) (exemplary (exemplary) (exemplary) (exemplary (exemplary) (exemplary) (exemplary) (exemplary (exemplary) (exemplary) (exemplary) (exemplary) (exemplary (exemplary) (exemplary) (exemplary) (exemplary) (\" (exemplary) (exemplary) (\"(exemplary) (exemplary) (exemplary) (\" (\"(exemplary) (\" (\"(\") (\") (\" (\") (\") (\"intentional\") (\"intentional\" functions (\"(\" intentional \") (\" intentional \"intentional\") (\"intentional\" (\"intentional\" intentional \") (\" intentional \"intentional\")"}, {"heading": "2.3 Review: Stable Models of Multi-Valued Propositional Formulas", "text": "The following is a review of the stable model semantics of polyvalent formulas by [Bartholomew and Lee, 2012], which can be considered a special case of functional stable model semantics in the previous section. Syntax of polyvalent formulas is given in [Ferraris et al., 2011]. A polyvalent statement formula is a set of symbols called constants, along with a nonempty finite set of symbols assigned by each constant to c. We call them \"dome\" (c) the domain of c. A Boolean constant is one whose domain is the set. {TRUE, FALSE}. An atom of a signature is an expression of the form c = v (\"the value of c is an interpretative element\") in which c's c's is the formula of c."}, {"heading": "3 Relating Strong Negation to Boolean Functions", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Representing Strong Negation in Multi-Valued Propositional Formulas", "text": "Considering a traditional statement logic program of a signature \u03c3 [Gelfond and Lifschitz, 1991], we identify ourselves with the multi-rated statement signature, the constants of which are the same symbols from \u03c3 and each constant is Boolean. By this we mean the multi-rated statement formula obtained by identifying negative literals of the form \u0445 p by p = FALSE and positive literals of the form p by p = TRUE. We say that a series of literals from \u03c3 is complete if for each atom there is a whole series of A or 1 in X. We identify a complete set of literals from the form \u0445 p = FALSE and positive literals of the form p with the corresponding polyvalent expression.Theorem 1 A complete set of literals from \u03c3 0 is a collection of answers E in the sense of [Gelfond and Lifschitz, 1991]."}, {"heading": "3.2 Relation among Strong Negation, Default Negation, Choice Rules and Boolean Functions", "text": "In certain cases, strong negation can be replaced by default negation, and beyond that, the expression can be rewritten in the sense of selection rules, often leading to a concise representation.The following theorem, which extends the theorem of double negation from [Ferraris et al., 2009] to enable intensive functions, represents a condition under which equivalent transformations in classical logic maintain stable models. Theorem 2 Let F be a proposition, let c be a list of predicate and function constants, and let me be a (coherent) interpretation. Let F \u2032 be the proposition obtained from F \u2032 by replacing a formula \u00ac H with \u00ac H \u2032, so that I | = presupposed (H \u2012 H \u2012). ThenI | = SM [F; c] iff I | = SM [F \u2032; c].We say that an interpretation after a predicate is completed when it meets the predicate (p)."}, {"heading": "3.3 Representing Strong Negation by Boolean Functions in the First-Order Case", "text": "It is not as if it is a \"replacement\" solution, but a \"replacement\" solution for a \"replacement\" solution for a \"replacement\" solution \"for a\" replacement \"solution\" for a \"replacement\" solution \"for a\" replacement \"solution\" for a \"replacement\" solution \"for a\" replacement \"solution\" for a \"replacement\" solution. \"(b) It is a\" replacement \"for a solution.\" (b) It is a \"replacement\" for a solution. \"(b) It is a\" substitute \"for a solution.\" (b) It is a \"substitute\" for a solution. \"(b) It is a\" substitute \"for a solution.\" (b) It is a \"substitute\" for a solution. \"(b) It is a\" substitute \"for a solution.\" (b) It is a \"substitute\" for a solution. \"(b) It is a\" substitute. \"(b) It is a solution.\" (f) It is a replacement for a solution. \""}, {"heading": "4 Representing Non-Boolean Functions Using Strong Negation", "text": "In this section, we will show how to eliminate non-Boolean intensive functions in favor of Boolean intensive functions. In combination with the method in the previous section, this results in a systematic method of rendering non-Boolean intensive functions by means of strong negation."}, {"heading": "4.1 Eliminating non-Boolean Functions in Favor of Boolean Functions", "text": "Let us F (x) = FALSE (S) and F (x) = FALSE (F) = FALSE (F) = FALSE (S) = FALSE (S) = FALSE (S) = FALSE (S) = FALSE (S) = TRUEb (S) = FALSE (S) = TRUEb (S) = FALSE (S) = TRUEb (S) = TRUEb (S) = TRUEb (S) = TRUEb (S) = TRUEb (S) = TRUE (S), where x (S) n-tuple of variables and all variables in x, y and z (S).Theorem 5 For each f-plain formula F (F (F) = FALSE (S) = TRUEb (S) = TRUE (S) = TRUE (S).S (S) = TRUEb (S).S (S), S (S), S (S) S (S), S (S), S (S, S, S, S, S, S, S, S (S), S, S (S), S, S (S, S), S (S, S, S, S (S), S (S)."}, {"heading": "5 Relating to Lifschitz\u2019s Two-Valued Logic Programs", "text": "Lifschitz [2012] presented a high-level definition of a logic program that does not contain an explicit default negation, but can handle non-monotonous thinking in a style similar to Reiter's default logic. In this section, we show how its formalism can be regarded as a special case of multi-value propositional formulas under the stable model semantics in which every function is Boolean."}, {"heading": "5.1 Review: Two-Valued Logic Programs", "text": "A bivalent rule is an expression of formL0 \u2190 L1,..., Ln: F (13), where L0,.., Ln are statement dictionaries formed from \u03c3 and F are a sentence formula of the signature \u03c3.A bivalent program is a set of bivalent rules. An interpretation I is a function of \u03c3 to {TRUE, FALSE}. Interpretation I is a stable model of what I find in relation to an interpretation I is the sentence of rules L0 \u2190 L1,..., Ln corresponds to rules (13), for which I | = F. Interpretation I is a stable model of what, if it is a minimal model. Example 7 a) Example 7 a: a: a: a, \u00ac a: \u00ac a, b \u2190 a: > (14) The execution of this program in relation to {a, b} consists of rules a and b} a: an interpretation of a minimal model."}, {"heading": "5.2 Translation into SM with Boolean Functions", "text": "In view of a bivalent logic formula and a signature \u03c3, we identify ourselves with the polyvalent formulas G, \u0131Tr (G) is obtained from G by replacing all negative literal formulas \u0445 A with A = FALSE and all positive literal formulas A with A = TRUE. With \u0131tv2sm (L0), we designate for each rule (13) the polyvalent formulas defined as the conjunction of formformformformformformulas (F). For each interpretation I of the formulas, we obtain the polyvalent interpretation I \u2032 of I. For each Atom A of the formulas formula, the formulas formulas I \u2032 and the formulas formulas I \u2032 and the formulas formulas formulas of formulas I \u2032 of formulas I \u2032 of I \u2032 \u00ba is the polyvalent formulas LIT1."}, {"heading": "6 Strong Negation and the Cabalar Semantics", "text": "Theorem 5 of [Bartholomew and Lee), 2013] (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC)) (BC) (BC) (BC)) (BC) (BC)) (BC) (BC) (BC)) (BC) (BC) (BC) (BC) (BC)) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC) (BC)"}, {"heading": "7 Conclusion", "text": "In this note, we have shown that symmetrical predicates that use strong negation can alternatively be expressed under complete interpretations in the form of Boolean intensive functions in the language of [Bartholomew and Lee, 2012], but without requiring the full interpretation assumption to rely on the concept of partial interpretations.System CPLUS2ASP [Casolary and Lee, 2011; Babb and Lee, 2013] transforms the action language C + into response programs with asymmetrical predicates. The translation in 4 sub partial interpretations is b (t) 6 = b (t) true if b (t) is not defined. See [Cabalar and Lee, 2011; Bartholomew and Lee, 2013] for more details."}], "references": [{"title": "CPLUS2ASP: Computing action language C+ in answer set programming", "author": ["Babb", "Lee", "2013. Joseph Babb", "Joohyung Lee"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Babb et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Babb et al\\.", "year": 2013}, {"title": "Stable models of formulas with intensional functions", "author": ["Bartholomew", "Lee", "2012. Michael Bartholomew", "Joohyung Lee"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Bartholomew et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bartholomew et al\\.", "year": 2012}, {"title": "On the stable model semantics for intensional functions", "author": ["Bartholomew", "Lee", "2013. Michael Bartholomew", "Joohyung Lee"], "venue": "TPLP,", "citeRegEx": "Bartholomew et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bartholomew et al\\.", "year": 2013}, {"title": "Functional answer set programming", "author": ["Cabalar", "2011. Pedro Cabalar"], "venue": "TPLP, 11(2-3):203\u2013233,", "citeRegEx": "Cabalar and Cabalar.,? \\Q2011\\E", "shortCiteRegEx": "Cabalar and Cabalar.", "year": 2011}, {"title": "Representing the language of the causal calculator in answer set programming", "author": ["Casolary", "Lee", "2011. Michael Casolary", "Joohyung Lee"], "venue": "In ICLP (Technical Communications),", "citeRegEx": "Casolary et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Casolary et al\\.", "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["Ferraris et al", "2009. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz", "Ravi Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "al. et al\\.,? \\Q2009\\E", "shortCiteRegEx": "al. et al\\.", "year": 2009}, {"title": "Stable models and circumscription", "author": ["Ferraris et al", "2011. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["Gelfond", "Lifschitz", "1991. Michael Gelfond", "Vladimir Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1991}, {"title": "Answer set programming and plan generation", "author": ["Lifschitz", "2002. Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Lifschitz and Lifschitz.,? \\Q2002\\E", "shortCiteRegEx": "Lifschitz and Lifschitz.", "year": 2002}, {"title": "Two-valued logic programs", "author": ["Lifschitz", "2012. Vladimir Lifschitz"], "venue": "In ICLP (Technical Communications),", "citeRegEx": "Lifschitz and Lifschitz.,? \\Q2012\\E", "shortCiteRegEx": "Lifschitz and Lifschitz.", "year": 2012}], "referenceMentions": [], "year": 2017, "abstractText": "The distinction between strong negation and default negation has been useful in answer set programming. We present an alternative account of strong negation, which lets us view strong negation in terms of the functional stable model semantics by Bartholomew and Lee. More specifically, we show that, under complete interpretations, minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. The same account lets us view Lifschitz\u2019s two-valued logic programs as a special case of the functional stable model semantics. In addition, we show how non-Boolean intensional functions can be eliminated in favor of Boolean intensional functions, and furthermore can be represented using strong negation, which provides a way to compute the functional stable model semantics using existing ASP solvers. We also note that similar results hold with the functional stable model semantics by Cabalar.", "creator": "LaTeX with hyperref package"}}}