{"id": "1312.6149", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "On the Semantics of Gringo", "abstract": "Input languages of answer set solvers are based on the mathematically simple concept of a stable model. But many useful constructs available in these languages, including local variables, conditional literals, and aggregates, cannot be easily explained in terms of stable models in the sense of the original definition of this concept and its straightforward generalizations. Manuals written by designers of answer set solvers usually explain such constructs using examples and informal comments that appeal to the user's intuition, without references to any precise semantics. We propose to approach the problem of defining the semantics of gringo programs by translating them into the language of infinitary propositional formulas. This semantics allows us to study equivalent transformations of gringo programs using natural deduction in infinitary propositional logic.", "histories": [["v1", "Fri, 20 Dec 2013 21:33:55 GMT  (12kb,D)", "http://arxiv.org/abs/1312.6149v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["amelia harrison", "vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1312.6149"}, "pdf": {"name": "1312.6149.pdf", "metadata": {"source": "CRF", "title": "On the Semantics of Gringo", "authors": ["Amelia Harrison", "Vladimir Lifschitz", "Fangkai Yang"], "emails": ["fkyang}@cs.utexas.edu"], "sections": [{"heading": "1 Introduction", "text": "In this sense, Gringo is the name of the Gringo input language, which is used as a frontend in many areas of programming (ASP). (It is not only the way it is used in the Gringo language, but also the way it is used in the Gringo language.) We are focusing here on version 4, which was released in March 2013. (It differs from version 3, which is described in the user manual of October 4, 2010.2, in several ways, including the approach to the aggregates - it is modified as proposed by the ASP.) The basis of Gringo is the language of logic programs with the negation defined as a failure, with the syntax and semantics. Our goal is to extend this semantics to a larger subset of Gringo."}, {"heading": "2 Syntax", "text": "We begin with a signature \u03c3 in the sense of a prefabricated logic that includes, among other things, (i) digits - object constants representing all integers, (ii) arithmetic functions - binary function constants +, \u2212, \u00b7, (iii) comparisons - binary predicate constants < >, \u2264, \u2265. We identify numbers with the corresponding elements of the set Z of integers. Object, function and predicate symbols not listed in (i) - (iii) is called symbolic. A term above size is arithmetic if it does not contain symbolic object or function constants. A basic term is precalculated if it does not contain arithmetic functions. We assume that in addition to the signature, a set of symbols called aggregate names is specified, and that for each aggregate name, the function designated by a term, each element is defined by Z."}, {"heading": "3 Semantics", "text": "We will define the semantics of gringo by means of a syntactical transformation \u03c4. It converts gringo rules into infinite sentence combinations of atoms of the form p (t), where p is a symbolic predicate constant and t is a tuple of pre-calculated terms. Then, the stable models of a program are defined as stable models in the sense of [13] of the sentence consisting of the translations of all rules of the program. Truszczynski's definition of stable models for infinite sentence formulas follows. Before defining the translation \u03c4 for rules, we will define them for basic literals, conditional literals and overall expressions."}, {"heading": "3.1 Review: Stable Models of Infinitary Formulas", "text": "The propositions F\u03c30, F\u03c31,.. are defined as follows: - F\u03c30 = \u03c3, - F\u03c3i + 1 results from F\u03c3i by adding the expressions H and H for all subsets H of F\u03c3i, and the expressions F \u2192 G for all F, G and F\u03c3i. The elements of \u221e i = 0 F\u03c3i are called (infinite) formulas. Negation and equivalence are abbreviations. Subsets of a signature are also called their interpretations. The satisfaction relationship between an interpretation and a formula is defined in a natural way. The reduction F I of a formula F w.r.t. an interpretation I is defined as follows: - \"I = I = H.\" - For p formations, pI = pI = pI = p; otherwise pI = P. - (H) I =.GI | H. \""}, {"heading": "3.2 Semantics of Well-Formed Ground Literals", "text": "A term t is well-formed if it contains neither symbolic object constants nor symbolic function constants within the framework of arithmetic functions; for example, all arithmetic terms and all precalculated terms are well-formed; c + 2 is not well-formed; the definition of \"well-formed\" for literals, aggregated expressions, etc., is the same; for each well-formed term t, we denote the precalculated term that is derived from t by evaluating all arithmetic functions, and similarly for terms. For example, [f (2 + 2) is f (4).The translation of [t] of a well-formed keyword L is defined as follows: - \u03c4 (p (t)) is p ([t])); - \u03c4 (t1) is t2), where the term is the symbol = or comparison, is > if the relationship between [t1] and [t2] and otherwise exists; - the term is not (4)."}, {"heading": "3.3 Global Variables", "text": "About a variable, we say that it is global - in a conditional literal H: L, if it occurs in H, but not in L; - in an overall expression \u03b1 {t: L} \u2022 s, if it occurs in the term s; - in a rule (3), if it occurs in at least one of the expressions Hi, Bi.For example, the header of the rule (2) is a letter with the global variable N, and its body is an overall expression with the global variable N. Consequently, N is also usually global. A conditional letter, an overall expression, or a rule is closed if it has no global variables. An example of a rule R is a well-formed closed rule that can be extracted from R by replacing precompiled terms for global variables. For example, a total time (6) - \u0131sum {H, C: \u0131enroll (C), Hours (H, C) = 6 is an instance of the rule (2), if there are no clear substances."}, {"heading": "3.4 Semantics of Closed Conditional Literals", "text": "If t is a term, x is a tuple of different variables, and r is a tuple of expressions of the same length as x, then the term obtained from t by substituting r for x is called txr. Similar notation is used for the result of substituting r for x in expressions of other kinds, such as literals and lists of words. The result of applying to a closed conditional literal H: L is the conjunction of formulas \"(Lxr)\" \u2192 \"(Hxr), where x is the list of variables occurring in\" H: L, \"over all tuples\" r \"precomputed terms of the same length as x, so that both Lxr and H x r are well formed. For example:\" available \"(X):\" person \"(X) is the conjunction of the formulas\" person \"(r)\" available, \"\" available \"(r) over all precomputed terms\" r. \""}, {"heading": "3.5 Semantics of Closed Aggregate Expressions", "text": "In this section, the semantics of soil aggregates, as proposed in [1, Section 4.1], are adapted to closed total expressions. E should be a closed total expression, and x should be the list of variables occurring in E. A tuple r of pre-calculated terms of the same length as x is permissible (w.r.t. E) if both txr and L x r are well formed. About a number of permissible tuples, we say that it justifies E if the relationship between \u03b1 ([txr]: r: r] and [s] exists. Consider, for example, the total expression {H, C: \u0131enroll (H, C) Hours (H, C) = 6. (5) In this case, permissible tuples c: permissible pairs of pre-calculated terms, c).The amount {3, \u0131cs101), (3, \u0131cs102)}} (H = 101, c = 101 (c) in total (H)."}, {"heading": "3.6 Semantics of Rules and Programs", "text": "For each rule R stands for the conjunction of formulas VB1 VHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHH1 VHHH1 VHH1 VH1 VH1 VH1 VHH1 VH1 VH1 VH1 VHHH1 VH1 VHH1 VH1 VHHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHH1 VH1 VH1 VH1 VH1 VH1 VHH1 VH1 VHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VH1 VHz V1 VH1 VH1 VH1 VH1 VH1 VH"}, {"heading": "4 Reasoning about Gringo Programs", "text": "In this section we give examples of thinking about gringo programs based on the semantics defined above. These examples use the results of [8], and we assume here that the reader is familiar with this work."}, {"heading": "4.1 Simplifying a Rule from Example 3.7 of User\u2019s Guide", "text": "Consider rule 7\u0131weekdays \u2190 \u0131day (X): (\u0131day (X), \u0131not \u0131weekend (X). (9) Replacing this rule with the fact that \u0131weekdays within a program have no effect on the number of stable models, the result of applying translation manuals to (9) is the formula \u0441 r (\u0131day (r), \u0131day (r), \u0131day (r), (10) 7 This rule is similar to a rule from Example 3.7 of the Gringo 3 User Manual (see footnote 2), where the conjunction extends over all the precalculated terms. The formula la\u0131day (r) \u0131weekend (r) \u2192 \u0131day (r) is intuitionally provable. It follows from the substitution property of the basic system of natural deduction of [8] that (10) in the base system is identical to the weekdays."}, {"heading": "4.2 Simplifying the Sorting Rule", "text": "The basic order (X, Y) < p (X), p (Y), X < Y, not p (Z): (p (Z), X < Z (X), p (Y), X < Y) (11) can be replaced by one of the following two shorter rules within a program without changing the stable models of this program. (Order (X, Y), p (Y), p (Z): (X < Z, Z < Y) (13) Let us prove this claim to rule (12) (X, Y), p (8), p (Y), X < Y, not p (Z): (X < Z < Z < Y < Y) (13)."}, {"heading": "4.3 Eliminating Choice in Favor of a Conditional Literal", "text": "Replacing the rule {p (X)} \u2190 q (X) (16) with p (X) \u2190 q (X) (17) within any program will not affect the set of stable models. Indeed, the result of applying Translation \u03c4 to (16) is that the conjunction extends to all precalculated terms r, and the result of applying it to (17) is that the implication from (18) corresponds to the implication from (19) in the extension corresponds to the intuitionistic logic obtained by adding the axiom scheme \u00ac F, and consequently to the extended system represented in [8, section 7]. By the replacement property of the extended system, it follows that (18) is equivalent to (19) also in the extended system."}, {"heading": "4.4 Eliminating a Trivial Aggregate Expression", "text": "Rule (1) informally states that we can conclude p (Y) once we have established that there is at least one X to which q (X, Y) is applied. To replace this rule with p (Y) \u2190 q (X, Y) (20) within any program, we must calculate the result of the application on rule (1). Instances of (1) are the rupees (t) \u2190 \u0131count {X, t: q (X, t)} \u2265 1 (21) for all precomputed terms. Consider the total expression E in the body of (21). Any precomputed term r is permissible w.r.t. E. A set of precomputed terms justifies the counting ({(r, t): r): for all precomputed terms."}, {"heading": "4.5 Replacing an Aggregate Expression with a Conditional Literal", "text": "Informally speaking, the rule states that the cardinality of the set {X: p (X)} = 0 (23) q can close once we have determined that the cardinality of the set {X: p (X)}} is 0; the rule q (X) (24) states that we can close q once we have determined that p (X) does not apply to X. We will prove that replacing (23) with (24) within a program does not affect the set of stable models. To this end, we will show that the results of the application of (23) and (24) are equivalent in the extended system of [8, Section 7]. First, we must calculate the result of the application to rule (23). Consider the overall expression E in the body of (23)."}, {"heading": "4.6 Eliminating Summation over the Empty Set", "text": "Unofficially, the rule [X: p (X)} = 0 (28) states that we can conclude q once we have determined that the sum of the elements of the set {X: p (X)} is equal to 0. Consider the total expression E in the body of (28). Any precalculated term r is permissible if it is not affected by the fact q. To see this, we first calculate the result of applying the rule (28), so let us consider the total expression E in the body of (28). Any precalculated term r is permissible."}, {"heading": "5 Conclusion", "text": "In this note, we approached the problem of defining the semantics of gringo by reducing gringo programs to infinite propositional formulas. We argued that this approach to semantics could allow us to investigate equivalent transformations of programs by natural deduction into infinite propositional logic. In the absence of precise semantics, it is impossible to put the study of some important questions on a solid footing, such as the correctness of ASP programs, grounding, solvers, and optimization methods, and the relationship between the input languages of different solvers (for example, the equivalence of the semantics of aggregate expressions in gringo to their semantics in the ASP core language and in the language proposed in [5] assuming that aggregates are not used recursively). As a future work, we are interested in addressing some of these tasks on the basis of the semantics proposed in this note."}, {"heading": "Acknowledgements", "text": "Many thanks to Roland Kaminski and Torsten Schaub for helping us understand the input language Gringo. Roland, Michael Gelfond, Yuliya Lierler, Joohyung Lee and anonymous arbitrators have provided valuable comments on drafts of this note."}], "references": [{"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). pp. 119\u2013131", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175, 236\u2013263", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Weight constraints as nested expressions", "author": ["P. Ferraris", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 5, 45\u201374", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2005}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan and Claypool Publishers", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Representing knowledge in A-Prolog", "author": ["M. Gelfond"], "venue": "Lecture Notes in Computer Science 2408, 413\u2013451", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Kowalski, R., Bowen, K. (eds.) Proceedings of International Logic Programming Conference and Symposium. pp. 1070\u20131080. MIT Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1991}, {"title": "On equivalent transformations of infinitary formulas under the stable model semantics (preliminary report)", "author": ["A. Harrison", "V. Lifschitz", "M. Truszczynski"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR)", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Stable models of formulas with generalized quantifiers", "author": ["J. Lee", "Y. Meng"], "venue": "Working Notes of the 14th International Workshop on Non-Monotonic Reasoning (NMR)", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Stable models of formulas with generalized quantifiers (preliminary report)", "author": ["J. Lee", "Y. Meng"], "venue": "Technical Communications of the 28th International Conference on Logic Programming (ICLP). pp. 61\u201371", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Two new definitions of stable models of logic programs with generalized quantifiers", "author": ["J. Lee", "Y. Meng"], "venue": "Working Notes of the 5th Workshop of Answer Set Programming and Other Computing Paradigms (ASPOCP)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Towards a first order equilibrium logic for nonmonotonic reasoning", "author": ["D. Pearce", "A. Valverde"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA). pp. 147\u2013160", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Connecting first-order ASP and the logic FO(ID) through reducts", "author": ["M. Truszczynski"], "venue": "Correct Reasoning: Essays on Logic-Based AI in Honor of Vladimir Lifschitz. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 5, "context": ") The basis of Gringo is the language of logic programs with negation as failure, with the syntax and semantics defined in [6].", "startOffset": 123, "endOffset": 126}, {"referenceID": 6, "context": "4 The subset of Gringo discussed in this note includes also constraints, disjunctive rules, and choice rules, treated along the lines of [7] and [3].", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "4 The subset of Gringo discussed in this note includes also constraints, disjunctive rules, and choice rules, treated along the lines of [7] and [3].", "startOffset": 145, "endOffset": 148}, {"referenceID": 3, "context": "Our proposal is based on the informal and sometimes incomplete description of the language in the User\u2019s Guide, on the discussion of ASP programming constructs in [4], on experiments with gringo, and on the clarifications provided in response to our questions by its designers.", "startOffset": 163, "endOffset": 166}, {"referenceID": 11, "context": "Alternatively, the semantics of Gringo can be approached using quantified equilibrium logic [12] or its syntactic counterpart defined in [2].", "startOffset": 92, "endOffset": 96}, {"referenceID": 1, "context": "Alternatively, the semantics of Gringo can be approached using quantified equilibrium logic [12] or its syntactic counterpart defined in [2].", "startOffset": 137, "endOffset": 140}, {"referenceID": 7, "context": "We may be able to prove, for instance, that two Gringo programs have the same stable models by observing that the corresponding infinitary formulas are equivalent in one of the natural deduction systems discussed in [8].", "startOffset": 216, "endOffset": 219}, {"referenceID": 5, "context": "Like grounding in the original definition of a stable model [6], it is modular, in the sense that it applies to the program rule by rule, and it is applicable even if", "startOffset": 60, "endOffset": 63}, {"referenceID": 8, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 87, "endOffset": 90}, {"referenceID": 9, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 90, "endOffset": 94}, {"referenceID": 10, "context": ") 5 Stable models of formulas with generalized quantifiers are defined by Lee and Meng [9][10][11].", "startOffset": 94, "endOffset": 98}, {"referenceID": 12, "context": "Then the stable models of a program will be defined as stable models, in the sense of [13], of the set consisting of the translations of all rules of the program.", "startOffset": 86, "endOffset": 90}, {"referenceID": 12, "context": "A stable model of a program \u03a0 is a stable model, in the sense of [13], of the set consisting of the formulas \u03c4R for all rules R of \u03a0.", "startOffset": 65, "endOffset": 69}, {"referenceID": 7, "context": "These examples use the results of [8], and we assume here that the reader is familiar with that paper.", "startOffset": 34, "endOffset": 37}, {"referenceID": 7, "context": "By the replacement property of the basic system of natural deduction from [8], it follows that (10) is equivalent to \u0131weekdays in the basic system.", "startOffset": 74, "endOffset": 77}, {"referenceID": 7, "context": "By the main theorem of [8], it follows that replacing (10) with the atom \u0131weekdays within any set of formulas does not affect the set of stable models.", "startOffset": 23, "endOffset": 26}, {"referenceID": 7, "context": "By the main theorem of [8] it is sufficient to show that the result of applying \u03c4 to (11) is equivalent in the basic system to the result of applying \u03c4 to (12).", "startOffset": 23, "endOffset": 26}, {"referenceID": 4, "context": "This includes the correctness of ASP programs, grounders, solvers, and optimization methods, and also the relationship between input languages of different solvers (for instance, the equivalence of the semantics of aggregate expressions in Gringo to their semantics in the ASP Core language and in the language proposed in [5] under the assumption that aggregates are used nonrecursively).", "startOffset": 323, "endOffset": 326}], "year": 2013, "abstractText": "Input languages of answer set solvers are based on the mathematically simple concept of a stable model. But many useful constructs available in these languages, including local variables, conditional literals, and aggregates, cannot be easily explained in terms of stable models in the sense of the original definition of this concept and its straightforward generalizations. Manuals written by designers of answer set solvers usually explain such constructs using examples and informal comments that appeal to the user\u2019s intuition, without references to any precise semantics. We propose to approach the problem of defining the semantics of gringo programs by translating them into the language of infinitary propositional formulas. This semantics allows us to study equivalent transformations of gringo programs using natural deduction in infinitary propositional logic.", "creator": "LaTeX with hyperref package"}}}