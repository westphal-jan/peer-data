{"id": "1312.6156", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "Negation in the Head of CP-logic Rules", "abstract": "CP-logic is a probabilistic extension of the logic FO(ID). Unlike ASP, both of these logics adhere to a Tarskian informal semantics, in which interpretations represent objective states-of-affairs. In other words, these logics lack the epistemic component of ASP, in which interpretations represent the beliefs or knowledge of a rational agent. Consequently, neither CP-logic nor FO(ID) have the need for two kinds of negations: there is only one negation, and its meaning is that of objective falsehood. Nevertheless, the formal semantics of this objective negation is mathematically more similar to ASP's negation-as-failure than to its classical negation. The reason is that both CP-logic and FO(ID) have a constructive semantics in which all atoms start out as false, and may only become true as the result of a rule application. This paper investigates the possibility of adding the well-known ASP feature of allowing negation in the head of rules to CP-logic. Because CP-logic only has one kind of negation, it is of necessity this ''negation-as-failure like'' negation that will be allowed in the head. We investigate the intuitive meaning of such a construct and the benefits that arise from it.", "histories": [["v1", "Fri, 20 Dec 2013 21:41:20 GMT  (22kb,D)", "http://arxiv.org/abs/1312.6156v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["joost vennekens"], "accepted": false, "id": "1312.6156"}, "pdf": {"name": "1312.6156.pdf", "metadata": {"source": "CRF", "title": "Negation in the Head of CP-logic Rules", "authors": ["Joost Vennekens"], "emails": ["joost.vennekens@cs.kuleuven.be"], "sections": [{"heading": "1 Introduction", "text": "In fact, most of them are able to survive on their own, without being able to survive on their own."}, {"heading": "2 Preliminaries: CP-logic", "text": "A theory in the CP logic consists of a series of rules. These rules are called \u00b7 \u00b7 \u00b7 \u00b7 probability laws (or CP laws for short, and they are statements of the form: \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7"}, {"heading": "2.1 Negation in CP-logic", "text": "Consider again the role that the CP law initially causes. (Broken: 0,9) \u2190 Throws (Suzy) does not play a role in the above execution model. First, if the atom throws (Suzy) is still default, this law is as follows: \"Once throws (Suzy) are caused, this law becomes active and is (eventually) executed, making broken likely 0,9. Now, let's assume instead that the first CP law would be active in any state where RefusesThrow (Suzy) has not deviated from its default. (RefusesThrow (Suzy)\" RefusesThrow \"(Suzy)\" s \"RefusesThrow\" (Suzy \"s) has not deviated from its default.\" This law would always be active in the original state. This means that it would be an execution model in which this law breaks the bottle and then refuses to deny Suzy the execution."}, {"heading": "3 Negation in the head", "text": "A CP theory represents a series of causal mechanisms that are activated one by one, and together construct the final state of the domain. Each of these causal mechanisms has the same kind of effect: for some sets of atoms it would cause at most one of these atoms to deviate from their default value f to the deviating value t. If several causal mechanisms affect the same atom, the result is simple: there are no additive effects and the result is simply that the atom is not if and only if at least one mechanism causes it. If subsequent rules \"cause\" an effect that is already t, then these changes are absolutely void. It is to this attitude that we now want to add negation-in-head. We will call such negated literal in-head a negative effect literally literally literal. To be more precise, we allow rules of the form: \"x\" (L1:)"}, {"heading": "4 Encoding interventions", "text": "In fact, it is not as if one sees oneself in a position to behave in the same way as one has done in the past. (...) It is not as if one sees oneself in a position to outdo oneself. (...) It is not as if one is able to outdo oneself. (...) It is not as if one is able to outdo oneself. (...) It is not as if one is able to outdo oneself. (...) It is as if one is able to outdo oneself. (...) It is not as if one sees oneself in a position to outdo oneself. (...) It is not as if one sees oneself in a position. (...) It is not as if one sees oneself in a position. (...) It is not as if one sees oneself. (...)"}, {"heading": "5 Representing defaults", "text": "An interesting test case for logic programs was always the presentation of defaults. (18) The typical example concerns the default \u03b4 = bird (x): flies (x) flies (x) along with the background knowledge: flies (x) penguin (x) flies (x).In an advanced logic program, the two types of denial can be used to elegantly represent the default: flies (x) birds (x) and not flies (x).flies (x).Flies (x) penguin (x).In a normal logic program or deterministic CP theory, defaults are typically represented by an anomaly predictory.Flies (x) birds (x) and not flies (x).In a normal logic program or deterministic CP theory, defaults are typically represented by an anomaly predictory.Flies (x) and not a default caused by CP defaults (x) is a default caused by logic (x)."}, {"heading": "6 Probabilities and defaults", "text": "An interesting consequence of adding negation-in-the-head to the CP logic is that we can automatically combine the coding of defaults with uncertainty, as in the previous section. Let's say, for example, that in general there is a 5% change that does not cause a bird to be able to fly, for example, the result of a birth defect or an accident, which could be presented as follows: (Fly (x): 0.95) \u2190 Bird (x). (20) \u00ac Fly (x) \u2190 Penguin (x). (21) The first rule describes the normal situation for birds, while the second rule still serves to give an exception to the general rule. Note that even for penguins, the causal mechanism underlying the first rule still happens, i.e. the rule is still fired, but it fails due to the results of flying."}, {"heading": "7 Implementation", "text": "To implement the feature of negation in the head, a simple transformation into regular CP logic can be used. This transformation is based on the way Denecker and Ternovska (2007) encode causal effects in their inductive definition modeling of the situation calculation. For a CP theory T in vocabulary \u03a3, make \u03a3 \u00ac consist of all atoms for which a negative effect appears literally \u00ac A in T. For each atom, we introduce two new atoms, CA and C \u00ac A. Intuitively, CA means that there is a cause for A, and C \u00ac A means that there is a cause for \u00ac A. Let there be the following transformation: - Replace all positive effective letters A in the rule heads with CA - Replace all negative effective letters \u00ac A in the rule heads with C \u00ac A - Add this rule: A \u2190 C \u00ac ALet converted theory of nullity (T)."}, {"heading": "8 Conclusion", "text": "This work is part of a long-term research project aimed at developing a Tarskian alternative to ASP: instead of relying on the original epistemic intuitions of ASP, our goal is to have a language in which every expression can be interpreted as an objective statement about the real world. First, the motivation is simplicity: many problems solved with today's ASP systems and the GDT methodology have no inherent epistemic component, so it would be easy if we could understand such programs in terms of what they say about the real world, rather than having to make a detour around the beliefs of an (irrelevant) rational agent. Second, the unity of science: both theoretical and practical research on classical logic have made enormous efforts. Its roots in non-monotonic reasoning have made ASP an antithesis of classical theory, in which the desire for objective knowledge is abandoned in favor of istemic knowledge."}], "references": [{"title": "Probabilistic reasoning with answer sets. Theory and Practice of Logic Programming", "author": ["C. Baral", "M. Gelfond", "N. Rushton"], "venue": null, "citeRegEx": "Baral et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Baral et al\\.", "year": 2008}, {"title": "Inductive situation calculus", "author": ["M. Denecker", "E. Ternovska"], "venue": "Artificial Intelligence,", "citeRegEx": "Denecker and Ternovska.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Ternovska.", "year": 2007}, {"title": "Well-founded semantics and the algebraic theory of non-monotone inductive definitions", "author": ["M. Denecker", "J. Vennekens"], "venue": "In LPNMR,", "citeRegEx": "Denecker and Vennekens.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2007}, {"title": "Answer set programming\u2019s contributions to classical logic. An analysis of ASP methodology", "author": ["M. Denecker", "J. Vennekens", "H. Vlaeminck", "J. Wittocx", "M. Bruynooghe"], "venue": "In MG-65: Symposium on Constructive Mathematics in Computer Science,", "citeRegEx": "Denecker et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Denecker et al\\.", "year": 2010}, {"title": "A tarskian informal semantics for asp", "author": ["M. Denecker", "Y. Lierler", "M. Truszczynski", "J. Vennekens"], "venue": "In Technical Communications of the 28th International Conference on Logic Programming,", "citeRegEx": "Denecker et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Denecker et al\\.", "year": 2012}, {"title": "Strong introspection", "author": ["M. Gelfond"], "venue": "In AAAI, pages 386\u2013391,", "citeRegEx": "Gelfond.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond.", "year": 1991}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz.", "year": 1991}, {"title": "The stable model semantics for logic programming. In ICLP/SLP, pages 1070\u20131080", "author": ["M. Gelfond", "V. Lifschitz"], "venue": null, "citeRegEx": "Gelfond and Lifschitz.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz.", "year": 1988}, {"title": "Structural equations and causation", "author": ["N. Hall"], "venue": "Philosophical Studies,", "citeRegEx": "Hall.,? \\Q2007\\E", "shortCiteRegEx": "Hall.", "year": 2007}, {"title": "Answer set programming and plan generation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Lifschitz.,? \\Q2002\\E", "shortCiteRegEx": "Lifschitz.", "year": 2002}, {"title": "Causality: Models, Reasoning, and Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl.,? \\Q2000\\E", "shortCiteRegEx": "Pearl.", "year": 2000}, {"title": "An alternative approach to the semantics of disjunctive logic programs and deductive databases", "author": ["C. Sakama", "K. Inoue"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Sakama and Inoue.,? \\Q1994\\E", "shortCiteRegEx": "Sakama and Inoue.", "year": 1994}, {"title": "CP-logic: A language of causal probabilistic events and its relation to logic programming", "author": ["J. Vennekens", "M. Denecker", "M. Bruynooghe"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Vennekens et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Vennekens et al\\.", "year": 2009}, {"title": "Embracing events in causal modelling: Interventions and counterfactuals in CP-logic", "author": ["J. Vennekens", "M. Denecker", "M. Bruynooghe"], "venue": "In JELIA,", "citeRegEx": "Vennekens et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Vennekens et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 5, "context": "Historically, the origins of ASP lie in the seminal papers by Gelfond and Lifschitz on the stable semantics for normal (1988) and extended logic programs (1991).", "startOffset": 62, "endOffset": 126}, {"referenceID": 5, "context": "Historically, the origins of ASP lie in the seminal papers by Gelfond and Lifschitz on the stable semantics for normal (1988) and extended logic programs (1991). These papers develop an epistemic view on logic programs, in which an answer set is seen as an exhaustive enumeration of a rational agent\u2019s atomic beliefs.", "startOffset": 62, "endOffset": 161}, {"referenceID": 5, "context": ", Gelfond\u2019s example (1991) of interviewing all students for which we do not know whether they are eligible for a grant\u2014the statement of the graph colouring problems is not concerned with anyone\u2019s knowledge or beliefs, but only with the objective colour of the nodes.", "startOffset": 2, "endOffset": 27}, {"referenceID": 1, "context": "One of its main achievements has been the development of the language of FO(ID) (Denecker and Ternovska, 2007), which extends FO with a construct for representing inductive definitions.", "startOffset": 80, "endOffset": 110}, {"referenceID": 12, "context": "This paper is concerned with one particular such extension, namely, CP-logic (Vennekens et al., 2009), which extends the inductive definition construct of FO(ID) with a means for expressing non-deterministic choice.", "startOffset": 77, "endOffset": 101}, {"referenceID": 2, "context": "Recent summaries of these results were published by Denecker et al. (2010) and Denecker et al.", "startOffset": 52, "endOffset": 75}, {"referenceID": 2, "context": "Recent summaries of these results were published by Denecker et al. (2010) and Denecker et al. (2012). A goal of this research program is to reconstruct ASP as a series of conservative extensions of FO.", "startOffset": 52, "endOffset": 102}, {"referenceID": 10, "context": "to correctly formalise non-deterministic inductive definitions, not the minimal model semantics must be used, but the possible world semantics of Sakama and Inoue (1994). A more important application of CP-logic, however, is to represent probabilistic causal laws.", "startOffset": 146, "endOffset": 170}, {"referenceID": 10, "context": "Such relations have received a great deal of attention in the AI community, especially since the influential work by Pearl (2000) on this topic.", "startOffset": 117, "endOffset": 130}, {"referenceID": 10, "context": "Such relations have received a great deal of attention in the AI community, especially since the influential work by Pearl (2000) on this topic. As shown by Vennekens et al. (2010), CP-logic can actually be seen as a refinement of Pearl\u2019s theory, which allows for a more compact and modular representation of certain phenomena.", "startOffset": 117, "endOffset": 181}, {"referenceID": 0, "context": "CP-logic has certain similarities to P-log, a probabilistic extension of ASP (Baral et al., 2008).", "startOffset": 77, "endOffset": 97}, {"referenceID": 5, "context": "In other words, we will examine how CP-logic can be extended with the familiar ASP feature of negation in the head Gelfond and Lifschitz (1991). Again, the traditional ASP interpretation of a classical negation literal is rooted in the epistemic tradition: whereas not A means that A is not believed to be true, a classical negation literal \u00acA means that A is believed to be false.", "startOffset": 115, "endOffset": 144}, {"referenceID": 12, "context": "It was shown by Vennekens et al. (2009) that, because each applicable rule must eventually be applied, the differences between these execution models are irrelevant, as long as we only care about the final states that may be reached.", "startOffset": 16, "endOffset": 40}, {"referenceID": 12, "context": "An important class of sound theories are those which are stratified, but there also exist useful sound theories outside of this class (see Vennekens et al. (2009) for a discussion).", "startOffset": 139, "endOffset": 163}, {"referenceID": 10, "context": "One of the interesting uses of negation-in-the-head is related to the concept of interventions, introduced by Pearl (2000). Let us briefly recall this notion.", "startOffset": 110, "endOffset": 123}, {"referenceID": 11, "context": "This is an instance of a general method, developed by Vennekens et al. (2010), of performing Pearl-style interventions in CP-logic.", "startOffset": 54, "endOffset": 78}, {"referenceID": 1, "context": "This transformation is based on the way in which Denecker and Ternovska (2007) encode causal ramifications in their inductive definition modelling of the situation calculus.", "startOffset": 49, "endOffset": 79}], "year": 2017, "abstractText": "CP-logic is a probabilistic extension of the logic FO(ID). Unlike ASP, both of these logics adhere to a Tarskian informal semantics, in which interpretations represent objective states-of-affairs. In other words, these logics lack the epistemic component of ASP, in which interpretations represent the beliefs or knowledge of a rational agent. Consequently, neither CP-logic nor FO(ID) have the need for two kinds of negations: there is only one negation, and its meaning is that of objective falsehood. Nevertheless, the formal semantics of this objective negation is mathematically more similar to ASP\u2019s negation-as-failure than to its classical negation. The reason is that both CP-logic and FO(ID) have a constructive semantics in which all atoms start out as false, and may only become true as the result of a rule application. This paper investigates the possibility of adding the well-known ASP feature of allowing negation in the head of rules to CP-logic. Because CP-logic only has one kind of negation, it is of necessity this \u201cnegation-as-failure like\u201d negation that will be allowed in the head. We investigate the intuitive meaning of such a construct and the benefits that arise from it.", "creator": "LaTeX with hyperref package"}}}