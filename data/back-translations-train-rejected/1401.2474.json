{"id": "1401.2474", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jan-2014", "title": "Transformation-based Feature Computation for Algorithm Portfolios", "abstract": "Instance-specific algorithm configuration and algorithm portfolios have been shown to offer significant improvements over single algorithm approaches in a variety of application domains. In the SAT and CSP domains algorithm portfolios have consistently dominated the main competitions in these fields for the past five years. For a portfolio approach to be effective there are two crucial conditions that must be met. First, there needs to be a collection of complementary solvers with which to make a portfolio. Second, there must be a collection of problem features that can accurately identify structural differences between instances. This paper focuses on the latter issue: feature representation, because, unlike SAT, not every problem has well-studied features. We employ the well-known SATzilla feature set, but compute alternative sets on different SAT encodings of CSPs. We show that regardless of what encoding is used to convert the instances, adequate structural information is maintained to differentiate between problem instances, and that this can be exploited to make an effective portfolio-based CSP solver.", "histories": [["v1", "Fri, 10 Jan 2014 22:05:39 GMT  (25kb)", "http://arxiv.org/abs/1401.2474v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["barry hurley", "serdar kadioglu", "yuri malitsky", "barry o'sullivan"], "accepted": false, "id": "1401.2474"}, "pdf": {"name": "1401.2474.pdf", "metadata": {"source": "CRF", "title": "Transformation-based Feature Computation for Algorithm Portfolios", "authors": ["Barry Hurley", "Serdar Kadioglu", "Yuri Malitsky", "Barry O\u2019Sullivan"], "emails": ["b.hurley@4c.ucc.ie,", "y.malitsky@4c.ucc.ie,", "b.osullivan@cs.ucc.ie", "serdark@cs.brown.edu"], "sections": [{"heading": null, "text": "ar Xiv: 140 1.24 74v1 [cs.AI] 10 Yes"}, {"heading": "1 Introduction", "text": "In fact, most of them are only a very small group, able to play by the rules without being able to hide."}, {"heading": "2 Encodings", "text": "There are a number of well-known polynomial time transformations or encodings, ranging from constraint satisfaction problems to sat [16]. In this paper, we focus on three commonly used encodings: direct, order, and support encoding."}, {"heading": "2.1 Direct Encoding", "text": "In the direct encoding [22] for each CSP variable X with domain {1,.., d}, a SAT variable is created for each CSP value, i.e. x1, x2,.., xd. If x1 matches in the resulting SAT formula, then the CSP variable X is assigned the value 1 in the CSP solution. Thus, in order to represent a solution for the CSP variable X, x1, x2,.., xd must be assigned appropriately. We add at least one set and at most one sentence to the SAT formula for each CSP variable X, enumerating the conflicting tuples: (x1, x2,., xd), w, D (X): (\u00ac xv, xw) At least one set and at most one set between CSP variables are represented in the direct encoding by enumerating the conflicting tuples."}, {"heading": "2.2 Support Encoding", "text": "The support encoding [8,3] uses the same mechanism as direct encoding to translate the domain of a csp variable into sat. However, the support encoding differs from how the constraints between the variables are encoded. Since there is a constraint between two variables X and Y. For each value v in the range of X, SY should be a subset of values in the range of Y that are consistent with the assignment of X = v. Either xv is false or one of the consistent assignments of X1 must be true, represented by the clause: \u00ac xv Facilitational Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facilitator Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facilitator Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facility Facili"}, {"heading": "2.3 Order Encoding", "text": "Unlike the direct and supportive encoding of the model X = v as the SAT variable, the order encoding generates SAT variables to represent X \u2264 v. If X is smaller or equal v, X must also be smaller or equal v + 1. To enforce this throughout the domain, we add the clauses: (\u00ac x \u2264 v \u2264 x \u2264 v v + 1) The order encoding is of course suitable for modeling inequality constraints. To specify X \u2264 3, we would simply add the unit insert (x \u2264 3). If we want to model the constraint X = v, we could rewrite it as (X \u2264 v \u2264 X \u2264 v v). X \u2264 v can then be rewritten as \u00ac X \u2264 (v \u2212 1). To determine that X = v is under the order encoding, we would encode (x \u2264 v \u00b2 w \u2212 1) a conflicting tuple between two variables (e.g. < X \u2212 v = w)."}, {"heading": "3 Feature Computation", "text": "In addition to the pure direct, support, and order encodings discussed in the previous section, we will also consider variants of these encodings that do not include the clauses encoding the domains of the variables. We will omit the domains to test whether it is enough to focus only on the constraints that exist in a CSP to differentiate the instances. We will now briefly describe the characteristics used for CSP and SAT.CSP characteristics. We will calculate characteristics for each of the original CSP instances plus for each of the six encodings. We will capture 36 characteristics directly from the CSP instance using Mistral [4]. These include static characteristics such as statistics on the types of constraints used, average and maximum domain size; and dynamic statistics recorded by executing Mistral for 2 seconds: average and standard deviation per weights, number of nodes, number of UBC, number of attributes, and a few other SAT characteristics."}, {"heading": "4 Numerical Results", "text": "This year, it has come to the point that it will only be a matter of time before it is ready, until it is ready."}, {"heading": "5 Conclusion", "text": "In this paper, we show that it is possible to encode one instance from one problem domain to another as a pre-processing step for the calculation of features. In particular, we show that even with the effort of converting CSP instances to Sat, a CSP portfolio trained on well-established satellite features can work just as well as if it had been trained on CSP-specific features. These results show that encoding techniques can retain enough information about the original instance to accurately distinguish different classes of instances. Our results serve as proof of a concept for an automated approach to feature generation for NP-complete problems that do not have a well-studied feature vector. We see this as a step toward problem-free feature calculation for algorithm portfolios and plan to further analyze them and expand their applications in the future."}, {"heading": "Acknowledgements", "text": "The second author was assisted in carrying out the work contained in this document by Paris Kanellaki's Fellowship at Brown University. This document reflects only his views and should not be interpreted either explicitly or implicitly as those of his current employer."}], "references": [{"title": "Mapping Problems with Finite-Domain Variables into Problems with Boolean Variables", "author": ["C. Ans\u00f3tegui", "F. Many\u00e0"], "venue": "The 7th International Conference on Theory and Applications of Satisfiability Testing, SAT 2004", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2004}, {"title": "Arc Consistency in SAT", "author": ["I.P. Gent"], "venue": "Proceedings of the 15th European Conference on Artificial Intelligence, ECAI\u20192002. pp. 121\u2013125", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2002}, {"title": "Mistral,a Constraint Satisfaction Library", "author": ["E. Hebrard"], "venue": "Proceedings of the Third International CSP Solver Competition", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2009}, {"title": "Adaptation in a CBR-Based Solver Portfolio for the Satisfiability Problem", "author": ["B. Hurley", "B. O\u2019Sullivan"], "venue": "Case-Based Reasoning Research and Development - 20th International Conference, ICCBR 2012. pp. 152\u2013166", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2012}, {"title": "Algorithm Selection and Scheduling", "author": ["S. Kadioglu", "Y. Malitsky", "A. Sabharwal", "H. Samulowitz", "M. Sellmann"], "venue": "Proceedings of the 17th International Conference on Principles and Practice of Constraint Programming. pp. 454\u2013469. CP\u201911, Springer-Verlag, Berlin, Heidelberg", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "ISAC - Instance-Specific Algorithm Configuration", "author": ["S. Kadioglu", "Y. Malitsky", "M. Sellmann", "K. Tierney"], "venue": "Coelho, H., Studer, R., Wooldridge, M. (eds.) ECAI. Frontiers in Artificial Intelligence and Applications, vol. 215, pp. 751\u2013756. IOS Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2010}, {"title": "On the Parallel Complexity of Discrete Relaxation in Constraint Satisfaction Networks", "author": ["S. Kasif"], "venue": "Artificial Intelligence 45(3), 275\u2013286", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1990}, {"title": "Feature filtering for instance-specific algorithm configuration", "author": ["C. Kroer", "Y. Malitsky"], "venue": "IEEE 23rd International Conference on Tools with Artificial Intelligence, ICTAI 2011. pp. 849\u2013855", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "The sat4j library, release 2.2 system description", "author": ["D. Le Berre", "A. Parrain"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "CSP2SAT4J: A Simple CSP to SAT Translator", "author": ["D. Le Berre", "I. Lynce"], "venue": "Proceedings of the 2nd International CSP Solver Competition", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2008}, {"title": "Abscon 112, Toward more Robustness", "author": ["C. Lecoutre", "S. Tabary"], "venue": "Proceedings of the Third International CSP Solver Competition", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}, {"title": "Features for SAT (2012), http://www.cs.ubc.ca/labs/beta/Projects/SATzilla/Report_SAT_features.pdf", "author": ["Lin Xu", "H.H. Frank Hutter", "K. Leyton-Brown"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "Non-modelbased algorithm portfolios for sat", "author": ["Y. Malitsky", "A. Sabharwal", "H. Samulowitz", "M. Sellmann"], "venue": "Proceedings of the 14th international conference on Theory and application of satisfiability testing. pp. 369\u2013370", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Using Casebased Reasoning in an Algorithm Portfolio for Constraint Solving", "author": ["E. O\u2019Mahony", "E. Hebrard", "A. Holland", "C. Nugent", "B. O\u2019Sullivan"], "venue": "Proceeding of the 19th Irish Conference on Artificial Intelligence and Cognitive Science", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "CNF Encodings", "author": ["S.D. Prestwich"], "venue": "Handbook of Satisfiability, pp. 75\u201397. IOS Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "A multi-engine solver for quantified boolean formulas", "author": ["L. Pulina", "A. Tacchella"], "venue": "Proceedings of the 13th international conference on Principles and practice of constraint programming. pp. 574\u2013589. CP\u201907, Springer-Verlag, Berlin, Heidelberg", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2007}, {"title": "XML Representation of Constraint Networks: Format XCSP", "author": ["O. Roussel", "C. Lecoutre"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2009}, {"title": "System Description of a SAT-based CSP Solver Sugar", "author": ["N. Tamura", "T. Tanjo", "M. Banbara"], "venue": "Proceedings of the 3rd International CSP Solver Competition. pp. 71\u201375", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "Azucar: A SAT-Based CSP Solver Using Compact Order Encoding \u2014 (Tool Presentation)", "author": ["T. Tanjo", "N. Tamura", "M. Banbara"], "venue": "Proceedings of the 15th International Conference on Theory and Applications of Satisfiability Testing (SAT 2012), LNCS 7317. pp. 456\u2013462. Springer", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2012}, {"title": "A Proof-Producing CSP Solver", "author": ["M. Veksler", "O. Strichman"], "venue": "Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence, AAAI 2010", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2010}, {"title": "SAT v CSP", "author": ["T. Walsh"], "venue": "Principles and Practice of Constraint Programming \u2014 CP 2000, LNCS 1894. vol. 1894, pp. 441\u2013456. Springer-Verlag", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2000}, {"title": "SATzilla: Portfolio-based Algorithm Selection for SAT", "author": ["L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown"], "venue": "Journal of Artificial Intelligence Research pp. 565\u2013606", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 13, "context": "Significant strides have recently been made in the application of portfolio-based algorithms in the fields of constraint satisfaction [15], quantified boolean formulae [17], and most notably in sat [23,6].", "startOffset": 134, "endOffset": 138}, {"referenceID": 15, "context": "Significant strides have recently been made in the application of portfolio-based algorithms in the fields of constraint satisfaction [15], quantified boolean formulae [17], and most notably in sat [23,6].", "startOffset": 168, "endOffset": 172}, {"referenceID": 21, "context": "Significant strides have recently been made in the application of portfolio-based algorithms in the fields of constraint satisfaction [15], quantified boolean formulae [17], and most notably in sat [23,6].", "startOffset": 198, "endOffset": 204}, {"referenceID": 4, "context": "Significant strides have recently been made in the application of portfolio-based algorithms in the fields of constraint satisfaction [15], quantified boolean formulae [17], and most notably in sat [23,6].", "startOffset": 198, "endOffset": 204}, {"referenceID": 21, "context": "These decisions can be made based on regression techniques [23], in which a classifier is trained to predict expected runtime of each solver and choosing the one with best predicted performance.", "startOffset": 59, "endOffset": 63}, {"referenceID": 3, "context": "Alternatively, a ranking algorithm can be trained to directly predict the best solver for each instance [5].", "startOffset": 104, "endOffset": 107}, {"referenceID": 5, "context": "The features can also be used for clustering [7], where the best solver is chosen for each cluster of instances.", "startOffset": 45, "endOffset": 48}, {"referenceID": 7, "context": "Even in the case of constraint satisfaction problems, where a feature set has been proposed, careful filtering can dramatically improve the quality of portfolios [9].", "startOffset": 162, "endOffset": 165}, {"referenceID": 0, "context": "Perhaps the most relevant work is by Ans\u00f3tegui and Many\u00e0 which evaluated the performance of sat solvers on six sat-encodings on graph colouring, random binary csps, pigeon hole, and all interval series problems [1].", "startOffset": 211, "endOffset": 214}, {"referenceID": 17, "context": "Solvers such as sugar [19], azucar [20], and CSP4SAT4J [11] have similarly tackled csp problems by encoding them into sat and then solving them with a predefined sat solver.", "startOffset": 22, "endOffset": 26}, {"referenceID": 18, "context": "Solvers such as sugar [19], azucar [20], and CSP4SAT4J [11] have similarly tackled csp problems by encoding them into sat and then solving them with a predefined sat solver.", "startOffset": 35, "endOffset": 39}, {"referenceID": 9, "context": "Solvers such as sugar [19], azucar [20], and CSP4SAT4J [11] have similarly tackled csp problems by encoding them into sat and then solving them with a predefined sat solver.", "startOffset": 55, "endOffset": 59}, {"referenceID": 14, "context": "There are a number of known polynomial-time transformations, or encodings, from constraint satisfaction problems to sat [16].", "startOffset": 120, "endOffset": 124}, {"referenceID": 20, "context": "In the direct encoding [22] for each csp variable X , with domain {1, .", "startOffset": 23, "endOffset": 27}, {"referenceID": 6, "context": "The support encoding [8,3] uses the same mechanism as the direct encoding to translate a csp variable\u2019s domain into sat.", "startOffset": 21, "endOffset": 26}, {"referenceID": 1, "context": "The support encoding [8,3] uses the same mechanism as the direct encoding to translate a csp variable\u2019s domain into sat.", "startOffset": 21, "endOffset": 26}, {"referenceID": 2, "context": "We record 36 features directly from the csp instance using mistral [4].", "startOffset": 67, "endOffset": 70}, {"referenceID": 11, "context": "We use the 54 features computed using the newest feature computation tool from UBC [13].", "startOffset": 83, "endOffset": 87}, {"referenceID": 16, "context": "We implemented a tool to translate a csp instance specified in XCSP format [18] into sat (cnf).", "startOffset": 75, "endOffset": 79}, {"referenceID": 5, "context": "To train our portfolios we used the ISAC methodology [7] which has been shown to work better than a regression based approaches [14].", "startOffset": 53, "endOffset": 56}, {"referenceID": 12, "context": "To train our portfolios we used the ISAC methodology [7] which has been shown to work better than a regression based approaches [14].", "startOffset": 128, "endOffset": 132}, {"referenceID": 10, "context": "For our csp solver portfolio we used: abscon [12], csp4j [11], sat4j [10], pcs [21], gecode [2], and sugar [19].", "startOffset": 45, "endOffset": 49}, {"referenceID": 9, "context": "For our csp solver portfolio we used: abscon [12], csp4j [11], sat4j [10], pcs [21], gecode [2], and sugar [19].", "startOffset": 57, "endOffset": 61}, {"referenceID": 8, "context": "For our csp solver portfolio we used: abscon [12], csp4j [11], sat4j [10], pcs [21], gecode [2], and sugar [19].", "startOffset": 69, "endOffset": 73}, {"referenceID": 19, "context": "For our csp solver portfolio we used: abscon [12], csp4j [11], sat4j [10], pcs [21], gecode [2], and sugar [19].", "startOffset": 79, "endOffset": 83}, {"referenceID": 17, "context": "For our csp solver portfolio we used: abscon [12], csp4j [11], sat4j [10], pcs [21], gecode [2], and sugar [19].", "startOffset": 107, "endOffset": 111}], "year": 2014, "abstractText": "Instance-specific algorithm configuration and algorithm portfolios have been shown to offer significant improvements over single algorithm approaches in a variety of application domains. In the sat and csp domains algorithm portfolios have consistently dominated the main competitions in these fields for the past five years. For a portfolio approach to be effective there are two crucial conditions that must be met. First, there needs to be a collection of complementary solvers with which to make a portfolio. Second, there must be a collection of problem features that can accurately identify structural differences between instances. This paper focuses on the latter issue: feature representation, because, unlike sat, not every problem has well-studied features. We employ the well-known SATzilla feature set, but compute alternative sets on different sat encodings of csps. We show that regardless of what encoding is used to convert the instances, adequate structural information is maintained to differentiate between problem instances, and that this can be exploited to make an effective portfolio-based csp solver.", "creator": "LaTeX with hyperref package"}}}