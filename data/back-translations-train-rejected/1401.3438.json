{"id": "1401.3438", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "The Ultrametric Constraint and its Application to Phylogenetics", "abstract": "A phylogenetic tree shows the evolutionary relationships among species. Internal nodes of the tree represent speciation events and leaf nodes correspond to species. A goal of phylogenetics is to combine such trees into larger trees, called supertrees, whilst respecting the relationships in the original trees. A rooted tree exhibits an ultrametric property; that is, for any three leaves of the tree it must be that one pair has a deeper most recent common ancestor than the other pairs, or that all three have the same most recent common ancestor. This inspires a constraint programming encoding for rooted trees. We present an efficient constraint that enforces the ultrametric property over a symmetric array of constrained integer variables, with the inevitable property that the lower bounds of any three variables are mutually supportive. We show that this allows an efficient constraint-based solution to the supertree construction problem. We demonstrate that the versatility of constraint programming can be exploited to allow solutions to variants of the supertree construction problem.", "histories": [["v1", "Wed, 15 Jan 2014 04:53:22 GMT  (423kb)", "http://arxiv.org/abs/1401.3438v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["neil c a moore", "patrick prosser"], "accepted": false, "id": "1401.3438"}, "pdf": {"name": "1401.3438.pdf", "metadata": {"source": "CRF", "title": "The Ultrametric Constraint and its Application to Phylogenetics", "authors": ["Neil C.A. Moore", "Patrick Prosser"], "emails": ["ncam@cs.st-andrews.ac.uk", "pat@dcs.gla.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "In fact, it is so that most people are able to understand themselves and themselves. Most people in the world know that they are people who are able to identify themselves. Most people in the world, who are able to identify themselves and understand themselves, are not able to identify themselves. Most people in the world, who are able to identify themselves, are able to identify themselves. Most people in the world, who are able to identify themselves and understand themselves, are not able to identify themselves. Most people in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world in the, in the world, in the world in the, in the world in the, in the world in the, in the world in the, in the world in the, in the world in the, in the, in the world in the, in the, in the world in the, in the, in the world in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the world, in the, in the, in the, in the, in the, in the, in the, in the, in the, in the world, in the, in the, in the, in the, in the, in the, in the, in the world, in the, in the, in the, in the, in the, in the, in the, in the world, in the, in the, in the, in the, in the, in the, in"}, {"heading": "2. Background", "text": "In this section we give the necessary definitions and descriptions of the Constraint Satisfaction Problem (Tsang, 1993), the Constraint Programming and the Supertree Problem."}, {"heading": "2.1 Constraint Programming and the CSP", "text": "The Condition of C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C C"}, {"heading": "2.2 The Supertree Problem", "text": "The construction of supertrees is a problem in phylogenetics, where we combine leaf-labeled species trees, where the leaf labels overlap, into a single tree that respects all tree-related relationships in each input tree (Bininda-Emonds, 2004). Species trees describe part of the evolutionary history of a number of species. Leaf labels correspond to existing species, and internal nodes represent divergence events in evolutionary history, where one species splits into at least two other species. Species trees can also be provided with data on internal nodes that represent the time at which the divergence event took place. We now define the term displays, which makes precise what we mean by \"tree-related relationships\": supertree T2 shows a tree T2 if and only if T2 is equivalent to T4 (i.e. they induce the same hierarchy on the leaflets), where the following steps are achieved."}, {"heading": "3. The Ultrametric Constraint", "text": "The ultrametric constraint was first proposed by Ghent et al. (2003) in the context of supertree construction (Bininda-Emonds, 2004) and implemented using primitive toolkits. We verify this coding and show that in most constraint toolkits it is both spatially and temporally inefficient, which motivates the creation of a specialized ultrametric distributor across three variables that maintains the ultrametric property beyond the boundaries of these variables. It is presented by describing the necessary dissemination methods, and then we expand it to a specialized distributor that maintains the ultrametric property on a symmetric matrix of variables."}, {"heading": "3.1 Previous Work on the Ultrametric Constraint", "text": "It is not only the question of whether there can be a solution at all, but also the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all. (...) It is the question of whether there can be a solution at all."}, {"heading": "3.2 Design of a BC(Z) UM-3 Propagator", "text": "In this section we describe a Um-3 propagator that forces BC (Z), namely UM-3-BCZ."}, {"heading": "3.2.1 Analysis of Lower and Upper Bounds", "text": "In this section, we consider less than the others. Since we consider the lower and upper limits in isolation, it is only possible that the lower and upper limits in isolation exceed an upper limit or vice versa. This is not a problem, because there is no solution, and it is a waste of time if we do not recognize the upper limit in this section, so that the domain cannot become zero, and vice versa. The procedure LBFix in Figure 5 takes as input three variables and reforms all unsupported values in the lower limit of the domain. The intuition for the algorithms is that any need must be included in a binding for the smallest element, hence, if the smallest lower limit is between the lower limits of the domain. The intuition for the algorithm is that each individual must be included in a binding for the smallest element."}, {"heading": "3.2.2 The Propagation Algorithm", "text": "This year, more than ever before in the history of the country in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is not a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country and in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country."}, {"heading": "3.3 Entailment", "text": "Schulte and Carlsson (2006) define the consequences in such a way that all possible constraints on the domains within a constraint are consistent. If we can determine that this has happened, we can no longer execute the multiplier because it can no longer prune values. Definition 5. A multiplier is associated with domains D = {d1,.., dn} when a number of domains belonging to these domains, i.e. each E = {e1,.., en} s.t., i.e. ei di, have reached a fixed point. We now describe a sufficient condition that the constraint UM-3-BCZ must be accompanied, i.e. the constraint UM-3-BCZ will result as soon as two variable singleton domains have two variables: Theorem 2. UM-3-BCZ will result in a multiplication, i.e. the constraint UM-3-BCZ will result as soon as two variable singleton domains have two."}, {"heading": "3.4 Ultrametric Matrix Constraint", "text": "The supertree model presented in section 4 uses the ultrametric constraint, but in this context the desired end product is to confine an entire matrix to be an ultrametric matrix, and not merely to constrain three variables. Definition 6. A symmetric matrix M is an ultrametric matrix if and only if for each set of three different indices i, j and k there is an equality for the minimum of Mij, Mik and Mjk; and Mii = 0 for all i. The ultrametric matrix constraint can be achieved for Matrix M by resolving the constraint UM-3-BCCZ (Mij, Mik, Mjk) for all decisions of different i, j and k, but at the cost of introducing (n 3) constraints of matrix 3 if each model containing this constraint contains a spatial constraint."}, {"heading": "4. Supertree Construction", "text": "We are now reviewing mandatory solutions to the Supertree design problem, reviewing the first constraint programming solution (Ghent et al., 2003) and presenting a new coding that exploits the specialized UM matrix BCZ constraint."}, {"heading": "4.1 Imperative Solutions to the Supertree Problem", "text": "The earliest imperative techniques can be traced back to Bryant and Steel (1995) and Ng and Wormald (1996) (> a), both of which present an OneTree algorithm based on the build algorithm of Aho, Sagiv, Szymanski and Ullman (1981). OneTree is based on the observation that in a tree all three leaf nodes define a unique relationship with their most recent common ancestors (mrca, d), if the former has a greater depth than the latter and similarly mrca (a, b) = mrca, d) if they have the same depth."}, {"heading": "4.2 A Constraint Encoding using Toolkit Constraints", "text": "This second stage, i.e. the OneTree equivalent, was first solved as a constraint program by Ghent et al. (2003). The coding uses an equivalence between ultrametric trees and ultrametric matrices: Definition 7. Let M be a true symmetric n \u00b7 n matrix. An ultrametric tree for M is a root-bound tree T, so that: 1. T n has leaves corresponding to a unique row of M; 2. Each internal node of T has at least 2 children; 3. For two leaves i and j, Mij is the designation of the youngest common ancestor of i and j; and 4. Along a path from the root to a leaf, the designations are strictly limited.Theorem 3. A symmetric matrix M has a symmetric matrix M, if and only if it is an ultrametric tree; and only if it is an ultrametric matrix."}, {"heading": "4.2.1 The Model of Gent et al.", "text": "As input, a forest F is given with n different sheet labels, so that a symmetrical n \u00b7 n matrix M is generated from bounded integer variables with domains {1,.., n \u2212 1} or {0} on the main diagonal. Variable Mij is the depth of the mrca of types i and j. First, constraints are put in place to make the entire matrix ultrametric, ensuring that each resulting tree is ultrametric: Mij > Mik = Mjk-Mik > Mij = Mjk-Mjk > Mij = Mik-Mik = Mjk (2) for each i < j < j < k. The input trees are then shown in triples and fans using one of the resolution algorithms in Figures 12 and 13. For each triple (ij) k, the constraint Mij > Mik = Mjk (3) and for each 3-fan (ijk) Mik = (3)."}, {"heading": "4.2.2 Converting Back to Tree Representation", "text": "The final step is to use an algorithm based on the constructive proof of Gusfield (1997) for the \"direction of theorem 3\" to form a tree from the matrix M generated by a constraint solver. We will not describe this algorithm in detail, but for reasons of intuition it works as follows: \u2022 Choose any leaf s. Let the number of unique entries in row s d be. \u2022 Partition the other leaves in sentences p1,..., pd based on their input in series. \u2022 Solve the problem recursively on each pi by not ignoring all the rows and columns in matrix D in pi. \u2022 Combine it into a total solution by attaching partial problem solutions at the correct depth on the path to s.15, show a recursion of the algorithm with a selection and show that line a fully describes the path to a in the corresponding tree."}, {"heading": "4.2.3 Time Complexity of the Model of Gent et al.", "text": "However, the complexity of tracing O (n2) variables with O (n) size domains is the worst case O (nn 2), which is an upper limit on the time needed to solve the Supertree problem. We have not attempted to derive a lower upper limit on time complexity, as our new model has been proven to have reached a polynomic time limit, as we will show in the following section."}, {"heading": "4.3 A Constraint Encoding Using the New Propagator Design", "text": "This year it has come to the point where you are able to move in a country where most people are able to leave a country where they are able to move, \"he said in an interview with the\" Welt. \""}, {"heading": "4.3.1 Time Complexity of CPBuild", "text": "AC3 (Mackworth, 1977) begins with a queue containing all the constraints, repeating a constraint until none exists, and executing the associated propagator. Any constraints on affected variables may be queued up again. Once the queue empties, all propagators are at a fixed point. We need O (n3) constraints so that the complexity of the worst case O (n3) creates initial Q + O (n) O (n3) at worst new queues, each with a remote value. O (1) propagation time or O (n4) overall, which is the complexity of the worst case O (Ng & Wormald, 1996). Our constraint solution has its worst case when the problem is insoluble, as it is insoluble domains fixed by propagation while an unsolvable point is reached earlier."}, {"heading": "5. Empirical Study", "text": "This year it has come to the point that it will be able to exercise the aforementioned lcihsrcsrteeSi rf\u00fc eid eerwtlrteeSrteeu rf\u00fc eid eerwtlrsrteeoiKe."}, {"heading": "6. Versatility of the Constraint Model", "text": "One of the strengths of constraint programming is its versatility: faced with a constraint model of a core problem, this model can then be expanded to address variants of the original pure problem. We demonstrate this versatility with respect to the ultrametric model by presenting four variants of the supertree problem: (a) incorporating ancient divergence data into the model, (b) nested taxa, (c) determining whether an induced triple or fan is common to all supertrees, and (d) coping with incompatibilities."}, {"heading": "6.1 Ancestral Divergence Dates", "text": "Semple et al. (2004) and Bryant et al. (2004) add temporal information to the input trees. Interior nodes may be marked with integer ranks such that if interior node v2 is a proper descendant of v1 then rank (v1) < rank (v2), resulting in a and b. \"The RankedTree algorithm (Bryant et al., 2004) takes as input of precedence constraints derived from input ranking species trees and predates relationships. The algorithm prints a rank tree that respects these relationships or returns as\" incompatible. \"This is trivial to integrate into the constraint model. If trees are then sorted for each pair of species (i, j) we are variable."}, {"heading": "6.2 Nested Taxa", "text": "A taxon (plural, taxa) is a group of organisms that includes a single common ancestor and his offspring (Dawkins & Wong, 2004), for example, the species \"lion\" and the class \"birds\" taxa. So far, all trees in our species have been labeled with a leaf, but this is restrictive because trees can be labeled with taxa both on leaves and on internal nodes, creating nested taxa. Figure 20 shows tree T1 with an internal node labeled P that has descendants a and b, i.e. the taxa and b-taxa are nested within the P taxon. Problems associated with creating compatible supertrees for this type of data were raised by page (2004) and defined and resolved by Daniel and Semple (2004). A number of input trees and possible solutions to the problem are presented in Figure 20: Note that all labels are preserved in the solution, all ancestors are related."}, {"heading": "6.2.1 Constraint Encoding", "text": "We describe how to implement the input to make the delimitation solution easier, and then describe the input trees that must replace any tree with the same tree that a single subtree has rooted in its place. There must be such a subtree elsewhere in the input forest, or we have a contradiction in M replacing an enclosing taxon P on a leaf with the same tree. This process does not add or remove information, since the relationships between M and everything in the tree and the new relationships between the taxa in the input forest are always implicit."}, {"heading": "6.3 Necessity", "text": "There can be many possible supertrees for a given input forest. A question, then, is what relationships all supertrees have in common? The problem of determining whether a derived induced triple tree (or fan) is necessary in a supertree (i.e., all possible supertrees in common) is introduced by (Daniel, 2003) together with the polynomic time decision procedure.The algorithm Necessity in Figure 22 proceeds as arguments from a forest F of trees, which is assumed to be compatible, and from a rooted triple tree or fan, and determines whether it occurs in any supertree displaying the trees in F. The algorithm is a simple modification of CPBuild, in which the lines 1 to 3 are essentially the same, and from a rooted triple tree or fan, and determines whether it occurs in any supertree displaying the trees in F. The algorithm is a simple modification of CPBuild, in which the lines 1 to 3 are essentially the same as Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik, Mik."}, {"heading": "6.4 Coping with Conflict", "text": "If an alternative approach to satisfying so many of the input triples and fans within a reasonable span of time is possible, we must come into conflict with each other, either directly or indirectly. \"We\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s. \"We\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s. \"We\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s. \"s\" s \"s.\" s \"s\" s. \"s\" s. \"s\" s \"s.\" s \"s.\" s \"s\" s. \"s\" s \"s.\" s \"s\" s. \"s\" s \"s.\" s \"s\" s. \"s\" s \"s\" s. \"s\" s \"s.\" s \"s\" s \"s.\" s \"s\" s \"s.\" s \"s\" s \"s.\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s\" s \"s.\" s \"s\" s \"s\" s \"s\" s. \"s\" s \"s\" s \"s\" s \"s\" s \""}, {"heading": "6.5 Summary", "text": "This has an added advantage in terms of ancestral divergence, as it can result in a more compact enumeration of output trees when labeling internal nodes with ranges rather than specific values. If input trees come into conflict, we suggest two options: use quickXPlain to determine the cause of this conflict, or build a supertree with GreedyBuild. Bryant et al. (2004) state that they essentially have an \"all-or-nothing\" approach to building supertrees when using RankedTree and what is needed is something comparable to MinCutSupertree, i.e. when trees are incompatible, build a supertree that violates the minimum number of triples or fans, and do so in polynomial time (page, 2002; Semple & Steel, 2000)."}, {"heading": "7. Conclusion", "text": "We introduced a new constraint propagator for ultrametric constraint on three integer variables and showed how it can be extended to a symmetrical matrix of limited integer variables. If the boundaries (Z) consistency are set on the symmetrical array, the lower boundaries of the variables support each other, which is sufficient for modelling and solving the supertree construction problem in O (n4) time and O (n2) space, comparable to the complexity of OneTree (Ng & Wormald, 1996), but subject to the Bryant and Steel algorithm (1995). So why apply the CPBuild approach when there are already effective mandatory approaches? The answer lies in the versatility of constraint programming. Instead of developing a new algorithm for a new variant of the supertree problem, we add secondary constraints to a base model, and we have shown that a polymial boundary can be achieved, and a time boundary can often be extended."}, {"heading": "Acknowledgments", "text": "We would like to thank Pierre Flener and Xavier Lorca, Barbara Smith, Ian Gent and Christine Wei Wu, Charles Semple, Mike Steel and Rod Page, Muffy Calder and Joe Sventek, Stanislav Zivny, Chris Unsworth and our three anonymous reviewers / co-authors."}], "references": [{"title": "Inferring a tree from lowest common ancestors with an application to the optimization of relational expressions", "author": ["A. Aho", "Y. Sagiv", "T. Szymanski", "J. Ullman"], "venue": "SIAM J. Comput,", "citeRegEx": "Aho et al\\.,? \\Q1981\\E", "shortCiteRegEx": "Aho et al\\.", "year": 1981}, {"title": "Combining tree partitioning, precedence, and incompatibility", "author": ["N. Beldiceanu", "P. Flener", "X. Lorca"], "venue": "constraints. Constraints,", "citeRegEx": "Beldiceanu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Beldiceanu et al\\.", "year": 2008}, {"title": "Refining the basic constraint propagation algorithm", "author": ["C. Bessi\u00e8re", "R\u00e9gin", "J.-C"], "venue": "In IJCAI,", "citeRegEx": "Bessi\u00e8re et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Bessi\u00e8re et al\\.", "year": 2001}, {"title": "Constraint propagation", "author": ["C. Bessi\u00e8re"], "venue": "Handbook of constraint programming. Elsevier. Chapter 3.", "citeRegEx": "Bessi\u00e8re,? 2006", "shortCiteRegEx": "Bessi\u00e8re", "year": 2006}, {"title": "Phylogenetic Supertrees: Combining information to reveal the tree of life", "author": ["O. Bininda-Emonds"], "venue": "Springer.", "citeRegEx": "Bininda.Emonds,? 2004", "shortCiteRegEx": "Bininda.Emonds", "year": 2004}, {"title": "Extending the limits of supertree methods", "author": ["M. Bordewich", "G. Evans", "C. Semple"], "venue": "Annals of combinatorics,", "citeRegEx": "Bordewich et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Bordewich et al\\.", "year": 2006}, {"title": "Extension Operations on Sets of Leaf-labeled Trees", "author": ["D. Bryant", "M. Steel"], "venue": "Advances in Applied Mathematics,", "citeRegEx": "Bryant and Steel,? \\Q1995\\E", "shortCiteRegEx": "Bryant and Steel", "year": 1995}, {"title": "Supertree methods for ancestral divergence dates and other applications", "author": ["D. Bryant", "C. Semple", "M. Steel"], "venue": "Computational Biology Series Kluwer", "citeRegEx": "Bryant et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Bryant et al\\.", "year": 2004}, {"title": "Adjustment of heads and tails for the jobshop scheduling problem", "author": ["J. Carlier", "E. Pinson"], "venue": "European Journal of Operational Research,", "citeRegEx": "Carlier and Pinson,? \\Q1994\\E", "shortCiteRegEx": "Carlier and Pinson", "year": 1994}, {"title": "Solving small TSPs with constraints", "author": ["Y. Caseau", "F. Laburthe"], "venue": "In Proceedings International Conference on Logic Programming,", "citeRegEx": "Caseau and Laburthe,? \\Q1997\\E", "shortCiteRegEx": "Caseau and Laburthe", "year": 1997}, {"title": "Supertree methods: Some new approaches", "author": ["P. Daniel"], "venue": "Master\u2019s thesis, Department of Mathematics and Statistics, University of Canterbury.", "citeRegEx": "Daniel,? 2003", "shortCiteRegEx": "Daniel", "year": 2003}, {"title": "Supertree algorithms for nested taxa", "author": ["P. Daniel", "C. Semple"], "venue": "Computational Biology Series Kluwer", "citeRegEx": "Daniel and Semple,? \\Q2004\\E", "shortCiteRegEx": "Daniel and Semple", "year": 2004}, {"title": "The Ancestor\u2019s Tale", "author": ["R. Dawkins", "Y. Wong"], "venue": null, "citeRegEx": "Dawkins and Wong,? \\Q2004\\E", "shortCiteRegEx": "Dawkins and Wong", "year": 2004}, {"title": "Some practicable filtering techniques for the constraint satisfaction problem", "author": ["R. Debruyne", "C. Bessi\u00e8re"], "venue": "In Proceedings of IJCAI\u201997,", "citeRegEx": "Debruyne and Bessi\u00e8re,? \\Q1997\\E", "shortCiteRegEx": "Debruyne and Bessi\u00e8re", "year": 1997}, {"title": "The CP(Graph) Computation Domain in Constraint Programming", "author": ["G. Dooms"], "venue": "Ph.D. thesis, Universit\u00e9 catholique de Louvain, Facult\u00e9 des sciences appliqu\u00e9es.", "citeRegEx": "Dooms,? 2006", "shortCiteRegEx": "Dooms", "year": 2006}, {"title": "Supertree construction with constraint programming", "author": ["I. Gent", "P. Prosser", "B. Smith", "W. Wei"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "Gent et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2003}, {"title": "Algorithms on strings, trees, and sequences: computer science and computational biology", "author": ["D. Gusfield"], "venue": "Cambridge University Press, New York, NY, USA.", "citeRegEx": "Gusfield,? 1997", "shortCiteRegEx": "Gusfield", "year": 1997}, {"title": "Molecular evolution of mitochondrial 12S RNA and Cytochrome b sequences in the pantherine lineage of Felidae", "author": ["D. Janczewski", "W. Modi", "J. Stephens", "S. O\u2019Brien"], "venue": "Mol. Biol. Evol.,", "citeRegEx": "Janczewski et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Janczewski et al\\.", "year": 1995}, {"title": "Tractable constraints on ordered domains", "author": ["P.G. Jeavons", "M.C. Cooper"], "venue": "Artif. Intell.,", "citeRegEx": "Jeavons and Cooper,? \\Q1995\\E", "shortCiteRegEx": "Jeavons and Cooper", "year": 1995}, {"title": "QUICKXPLAIN: Preferred Explanations and Relaxations for OverConstrained Problems", "author": ["U. Junker"], "venue": "Proceedings AAAI2004, pp. 167\u2013172.", "citeRegEx": "Junker,? 2004", "shortCiteRegEx": "Junker", "year": 2004}, {"title": "Seabird supertrees: Combining partial estimates of procellariiform phylogeny", "author": ["M. Kennedy", "R. Page"], "venue": "The Auk,", "citeRegEx": "Kennedy and Page,? \\Q2002\\E", "shortCiteRegEx": "Kennedy and Page", "year": 2002}, {"title": "An efficient filtering algorithm for disjunction of constraints", "author": ["O. Lhomme"], "venue": "Principles and Practice of Constraint Programming, pp. 904\u2013908. Springer.", "citeRegEx": "Lhomme,? 2003", "shortCiteRegEx": "Lhomme", "year": 2003}, {"title": "Consistency in networks of relations", "author": ["A. Mackworth"], "venue": "Artificial Intelligence, 8, 99\u2013118.", "citeRegEx": "Mackworth,? 1977", "shortCiteRegEx": "Mackworth", "year": 1977}, {"title": "Reconstruction of rooted trees from subtrees", "author": ["M.P. Ng", "N.C. Wormald"], "venue": "Discrete Appl. Math.,", "citeRegEx": "Ng and Wormald,? \\Q1996\\E", "shortCiteRegEx": "Ng and Wormald", "year": 1996}, {"title": "TREEVIEW: An application to display phylogenetic trees on personal computers", "author": ["R. Page"], "venue": "Computer Applications in the Biosciences, 12, 357\u2013358.", "citeRegEx": "Page,? 1996", "shortCiteRegEx": "Page", "year": 1996}, {"title": "Taxonomy, supertrees, and the tree of life", "author": ["R. Page"], "venue": "Bininda-Emonds, O. (Ed.), Phylogenetic Supertrees: Combining information to reveal the tree of life, pp. 247\u2013265. Computational Biology Series Kluwer.", "citeRegEx": "Page,? 2004", "shortCiteRegEx": "Page", "year": 2004}, {"title": "Modified mincut supertrees", "author": ["R.D.M. Page"], "venue": "InWABI \u201902: Proceedings of the Second International Workshop on Algorithms in Bioinformatics, pp. 537\u2013552 London, UK. Springer-Verlag. 937", "citeRegEx": "Page,? 2002", "shortCiteRegEx": "Page", "year": 2002}, {"title": "Modernizing the Tree of Life", "author": ["E. Pennisi"], "venue": "Science, 300, 1692\u20131697.", "citeRegEx": "Pennisi,? 2003", "shortCiteRegEx": "Pennisi", "year": 2003}, {"title": "Supertree construction with constraint programming: recent progress and new challenges", "author": ["P. Prosser"], "venue": "WCB06 - Workshop on Constraint Based Methods for Bioinformatics, pp. 75\u201382.", "citeRegEx": "Prosser,? 2006", "shortCiteRegEx": "Prosser", "year": 2006}, {"title": "Rooted Tree and Spanning Tree Constraints", "author": ["P. Prosser", "C. Unsworth"], "venue": "In 17th ECAI Workshop on Modelling and Solving Problems with Constraints", "citeRegEx": "Prosser and Unsworth,? \\Q2006\\E", "shortCiteRegEx": "Prosser and Unsworth", "year": 2006}, {"title": "A filtering algorithm for constraints of difference in CSP\u2019s", "author": ["R\u00e9gin", "J.-C."], "venue": "Proceedings AAAI\u201994, pp. 362\u2013367.", "citeRegEx": "R\u00e9gin and J..C.,? 1994", "shortCiteRegEx": "R\u00e9gin and J..C.", "year": 1994}, {"title": "Contradicting conventional wisdom in constraint satisfaction", "author": ["D. Sabin", "E. Freuder"], "venue": "In Proceedings of ECAI-94,", "citeRegEx": "Sabin and Freuder,? \\Q1994\\E", "shortCiteRegEx": "Sabin and Freuder", "year": 1994}, {"title": "Finite domain constraint programming systems", "author": ["C. Schulte", "M. Carlsson"], "venue": "In Handbook of constraint programming. Elsevier. Chapter", "citeRegEx": "Schulte and Carlsson,? \\Q2006\\E", "shortCiteRegEx": "Schulte and Carlsson", "year": 2006}, {"title": "Supertree algorithms for ancestral divergence dates and nested", "author": ["C. Semple", "P. Daniel", "W. Hordijk", "R. Page", "M. Steel"], "venue": "taxa. Bioinformatics,", "citeRegEx": "Semple et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Semple et al\\.", "year": 2004}, {"title": "A supertree method for rooted trees", "author": ["C. Semple", "M. Steel"], "venue": "Discrete Appl. Math.,", "citeRegEx": "Semple and Steel,? \\Q2000\\E", "shortCiteRegEx": "Semple and Steel", "year": 2000}, {"title": "A Tutorial on Constraint Programming", "author": ["B.M. Smith"], "venue": "Technical Report 95.14, University of Leeds.", "citeRegEx": "Smith,? 1995", "shortCiteRegEx": "Smith", "year": 1995}, {"title": "Foundations of Constraint Satisfaction", "author": ["E. Tsang"], "venue": "Academic Press.", "citeRegEx": "Tsang,? 1993", "shortCiteRegEx": "Tsang", "year": 1993}, {"title": "A generic arc-consistency algorithm and its specializations", "author": ["P. van Hentenryck", "Y. Deville", "Teng", "C.-M"], "venue": "Artificial Intelligence,", "citeRegEx": "Hentenryck et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Hentenryck et al\\.", "year": 1992}, {"title": "Design, implementation, and evaluation of the constraint language cc(fd)", "author": ["P. van Hentenryck", "V. Saraswat", "Y. Deville"], "venue": "Journal of Logic Programming,", "citeRegEx": "Hentenryck et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Hentenryck et al\\.", "year": 1998}, {"title": "Quartet-based phylogeny reconstruction with answer set programming", "author": ["G. Wu", "You", "J.-H", "G. Lin"], "venue": "IEEE/ACM Transactions on Computational Biology and Bioinformatics,", "citeRegEx": "Wu et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2007}, {"title": "Making AC-3 an optimal algorithm", "author": ["Z. Yuanlin", "R.H.C. Yap"], "venue": "In IJCAI,", "citeRegEx": "Yuanlin and Yap,? \\Q2001\\E", "shortCiteRegEx": "Yuanlin and Yap", "year": 2001}], "referenceMentions": [{"referenceID": 27, "context": "7 million species identified only about 80,000 have been placed in the ToL so far (Pennisi, 2003).", "startOffset": 82, "endOffset": 97}, {"referenceID": 27, "context": "There are applications for the ToL: to help understand how pathogens become more virulent over time, how new diseases emerge, and to recognise species at risk of extinction (Pennisi, 2003; Mace, Gittleman, & Purvis, 2003).", "startOffset": 173, "endOffset": 221}, {"referenceID": 4, "context": "One approach to building the ToL is divide and conquer: combining smaller trees such as those available from TreeBase (TreeBASE, 2003) into so-called \u201csupertrees\u201d (Bininda-Emonds, 2004) to approach a more complete ToL.", "startOffset": 163, "endOffset": 185}, {"referenceID": 10, "context": "To date, supertree construction has been dominated by imperative techniques (Semple & Steel, 2000; Semple, Daniel, Hordijk, Page, & Steel, 2004; Daniel, 2003; Bordewich, Evans, & Semple, 2006; Ng & Wormald, 1996; Bryant & Steel, 1995; Page, 2002) but recently new declarative approaches have emerged using constraint programming (Gent, Prosser, Smith, & Wei, 2003; Prosser, 2006; Beldiceanu, Flener, & Lorca, 2008) and answer set programming (Wu, You, & Lin, 2007).", "startOffset": 76, "endOffset": 246}, {"referenceID": 26, "context": "To date, supertree construction has been dominated by imperative techniques (Semple & Steel, 2000; Semple, Daniel, Hordijk, Page, & Steel, 2004; Daniel, 2003; Bordewich, Evans, & Semple, 2006; Ng & Wormald, 1996; Bryant & Steel, 1995; Page, 2002) but recently new declarative approaches have emerged using constraint programming (Gent, Prosser, Smith, & Wei, 2003; Prosser, 2006; Beldiceanu, Flener, & Lorca, 2008) and answer set programming (Wu, You, & Lin, 2007).", "startOffset": 76, "endOffset": 246}, {"referenceID": 28, "context": "To date, supertree construction has been dominated by imperative techniques (Semple & Steel, 2000; Semple, Daniel, Hordijk, Page, & Steel, 2004; Daniel, 2003; Bordewich, Evans, & Semple, 2006; Ng & Wormald, 1996; Bryant & Steel, 1995; Page, 2002) but recently new declarative approaches have emerged using constraint programming (Gent, Prosser, Smith, & Wei, 2003; Prosser, 2006; Beldiceanu, Flener, & Lorca, 2008) and answer set programming (Wu, You, & Lin, 2007).", "startOffset": 329, "endOffset": 414}, {"referenceID": 3, "context": "We then propose a specialised ultrametric constraint, in terms of its propagation procedures, that maintains bounds(Z)-consistency (Bessi\u00e8re, 2006) on three variables.", "startOffset": 131, "endOffset": 147}, {"referenceID": 10, "context": "We justify this assertion by proposing a constraint solution finding essential relations in the supertree (Daniel, 2003), addressing ancestral divergence dates (Semple et al.", "startOffset": 106, "endOffset": 120}, {"referenceID": 33, "context": "We justify this assertion by proposing a constraint solution finding essential relations in the supertree (Daniel, 2003), addressing ancestral divergence dates (Semple et al., 2004; Bryant, Semple, & Steel, 2004), modelling nested taxa (Page, 2004; Daniel & Semple, 2004) and coping with conflicting data.", "startOffset": 160, "endOffset": 212}, {"referenceID": 25, "context": ", 2004; Bryant, Semple, & Steel, 2004), modelling nested taxa (Page, 2004; Daniel & Semple, 2004) and coping with conflicting data.", "startOffset": 62, "endOffset": 97}, {"referenceID": 36, "context": "Background In this section we give necessary definitions and descriptions of the Constraint Satisfaction Problem (Tsang, 1993), Constraint Programming, and the Supertree problem.", "startOffset": 113, "endOffset": 126}, {"referenceID": 22, "context": "Propagation maintains a level of consistency, such as arcconsistency (Mackworth, 1977), across the variables, removing values from domains that cannot occur in any solution (i.", "startOffset": 69, "endOffset": 86}, {"referenceID": 3, "context": "We use the definitions of (generalized) arc-consistency ((G)AC) due to Bessi\u00e8re (2006):", "startOffset": 71, "endOffset": 87}, {"referenceID": 22, "context": "Arc-consistency can be established on a CSP using an algorithm such as AC3 (Mackworth, 1977).", "startOffset": 75, "endOffset": 92}, {"referenceID": 3, "context": "The AC3 algorithm has O(e \u00b7 d3) time complexity, where e is the number of constraints and d the size of the largest domain, however other algorithms can achieve a time bound of O(e \u00b7 d2) (Yuanlin & Yap, 2001; Bessi\u00e8re & R\u00e9gin, 2001). We demonstrate arc-consistency with the example of Figure 1 by Smith (1995). We have three constrained integer variables x, y and z, each with an integer domain {1.", "startOffset": 209, "endOffset": 310}, {"referenceID": 8, "context": "For a job shop scheduling problem we might have a model that uses 0/1 variables to decide the relative order of pairs of activities that share a resource, and we might increase propagation by adding Carlier and Pinson\u2019s edge finding constraint (1994). The constraint programming approach is general and practical for modelling and solving problems, and provides a framework for the combination of problem specific algorithms in one solver.", "startOffset": 199, "endOffset": 251}, {"referenceID": 4, "context": "2 The Supertree Problem Supertree construction is a problem in phylogenetics where we are to combine leaf-labelled species trees, where the sets of leaf labels intersect, into a single tree that respects all arboreal relationships in each input tree (Bininda-Emonds, 2004).", "startOffset": 250, "endOffset": 272}, {"referenceID": 10, "context": "Variants on the supertree problem that have previously been published and solved in the specialist bioinformatics literature include finding all solutions1, counting solutions, finding conserved relationships in all supertrees (Daniel, 2003), incorporating nested taxa (Semple et al.", "startOffset": 227, "endOffset": 241}, {"referenceID": 33, "context": "Variants on the supertree problem that have previously been published and solved in the specialist bioinformatics literature include finding all solutions1, counting solutions, finding conserved relationships in all supertrees (Daniel, 2003), incorporating nested taxa (Semple et al., 2004), incorporating ancestral divergence dates (Semple et al.", "startOffset": 269, "endOffset": 290}, {"referenceID": 33, "context": ", 2004), incorporating ancestral divergence dates (Semple et al., 2004) and the possibility of contradictory input data (Semple & Steel, 2000).", "startOffset": 50, "endOffset": 71}, {"referenceID": 4, "context": "(2003) within the context of supertree construction (Bininda-Emonds, 2004), and was implemented using toolkit primitives.", "startOffset": 52, "endOffset": 74}, {"referenceID": 14, "context": "The Ultrametric Constraint The ultrametric constraint was first proposed by Gent et al. (2003) within the context of supertree construction (Bininda-Emonds, 2004), and was implemented using toolkit primitives.", "startOffset": 76, "endOffset": 95}, {"referenceID": 15, "context": "The constraint was proposed by Gent et al. (2003), used again by Prosser (2006) and both times implemented as a literal translation of Equation 1 using toolkit primitives.", "startOffset": 31, "endOffset": 50}, {"referenceID": 15, "context": "The constraint was proposed by Gent et al. (2003), used again by Prosser (2006) and both times implemented as a literal translation of Equation 1 using toolkit primitives.", "startOffset": 31, "endOffset": 80}, {"referenceID": 3, "context": "arc-consistency (Debruyne & Bessi\u00e8re, 1997) or the filtering algorithm of Lhomme (2003). However, the cost of these is greater in the average case than delayed-disjunction, preventing their use in toolkits.", "startOffset": 28, "endOffset": 88}, {"referenceID": 3, "context": "This Lemma will have important implications for the species tree model to be presented in detail in Section 4: in particular, the lower bounds of a bounds(Z)-consistency model form a solution, where bounds(Z)-consistency (Bessi\u00e8re, 2006) is defined as follows", "startOffset": 221, "endOffset": 237}, {"referenceID": 37, "context": "This can be guaranteed if domain reductions only occur at the bounds, as is the case here, or if domains are represented using one of the structures proposed by van Hentenryck et al. (1992).", "startOffset": 165, "endOffset": 190}, {"referenceID": 32, "context": "3 Entailment Schulte and Carlsson (2006) define entailment as when all possible constractions of the domains in a constraint\u2019s scope are consistent.", "startOffset": 13, "endOffset": 41}, {"referenceID": 22, "context": "This propagator mimics part of the AC3 algorithm (Mackworth, 1977) since it (a) receives a propagation event on a variable, (b) identifies which constraints are over that variable, and (c) arranges for the propagation to be carried out.", "startOffset": 49, "endOffset": 66}, {"referenceID": 15, "context": "Supertree Construction We now review imperative solutions to the supertree construction problem, review the first constraint programing solution (Gent et al., 2003), and present a new encoding that exploits the specialised UM-Matrix-BCZ constraint.", "startOffset": 145, "endOffset": 164}, {"referenceID": 6, "context": "1 Imperative Solutions to the Supertree Problem The earliest imperative techniques are due to Bryant and Steel (1995) and Ng and Wormald (1996).", "startOffset": 94, "endOffset": 118}, {"referenceID": 6, "context": "1 Imperative Solutions to the Supertree Problem The earliest imperative techniques are due to Bryant and Steel (1995) and Ng and Wormald (1996). Both present a OneTree algorithm which is based on the Build algorithm of Aho, Sagiv, Szymanski, and Ullman (1981).", "startOffset": 94, "endOffset": 144}, {"referenceID": 6, "context": "1 Imperative Solutions to the Supertree Problem The earliest imperative techniques are due to Bryant and Steel (1995) and Ng and Wormald (1996). Both present a OneTree algorithm which is based on the Build algorithm of Aho, Sagiv, Szymanski, and Ullman (1981). OneTree is based on the observation that in a tree any three leaf nodes define a unique relation with respect to their most recent common ancestor (mrca), such that mrca(a, b) is the interior node furthest from the root that has both leaf nodes a and b as descendants.", "startOffset": 94, "endOffset": 260}, {"referenceID": 23, "context": "Ng and Wormald (1996) give the complexity of OneTree as O(h(n)) where h(n) = n(n+ t+ bn)\u03b1(n+ t+ f), n is the number of labels, t the number of triples, f the number of fans, b is the sum of the squares of the number of leaves in the fans, and \u03b1 is the inverse Ackermann function (and is less than 4 for all conceivable inputs and so behaves like a constant).", "startOffset": 0, "endOffset": 22}, {"referenceID": 6, "context": "This should be contrasted with the O(t \u00b7 n) complexity of Bryant and Steel\u2019s OneTree (1995).", "startOffset": 58, "endOffset": 92}, {"referenceID": 15, "context": ", OneTree equivalent, was first solved as a constraint program by Gent et al. (2003). The encoding takes advantage of an equivalence between ultrametric trees and ultrametric matrices:", "startOffset": 66, "endOffset": 85}, {"referenceID": 16, "context": "A proof is given by Gusfield (1997).", "startOffset": 20, "endOffset": 36}, {"referenceID": 16, "context": "The final step is to use an algorithm based on the constructive proof by Gusfield (1997) of the \u21d0 direction of Theorem 3 to build a tree from the matrix M produced by a constraint solver.", "startOffset": 73, "endOffset": 89}, {"referenceID": 22, "context": "AC3 (Mackworth, 1977) begins with a queue containing all constraints.", "startOffset": 4, "endOffset": 21}, {"referenceID": 19, "context": "Our benchmark is real-life seabird data previously used by Kennedy and Page (2002) and Beldiceanu et al.", "startOffset": 59, "endOffset": 83}, {"referenceID": 1, "context": "Our benchmark is real-life seabird data previously used by Kennedy and Page (2002) and Beldiceanu et al. (2008) and we present statistics on various techniques for producing supertrees, namely OneTree, and the CP solutions of Section 4 (entries Toolkit and CPBuild).", "startOffset": 87, "endOffset": 112}, {"referenceID": 1, "context": "Our benchmark is real-life seabird data previously used by Kennedy and Page (2002) and Beldiceanu et al. (2008) and we present statistics on various techniques for producing supertrees, namely OneTree, and the CP solutions of Section 4 (entries Toolkit and CPBuild). For completeness we reproduce the results of Beldiceanu et al. (2008) over the same data set, and tabulate this as TreeCon.", "startOffset": 87, "endOffset": 337}, {"referenceID": 14, "context": "An alternative constraint model of a tree might use 0/1 variables corresponding to potential edges within an adjacency matrix (Prosser & Unsworth, 2006), or indeed the CP(Graph) computation domain (Dooms, 2006).", "startOffset": 197, "endOffset": 210}, {"referenceID": 1, "context": "Our results also compare well against those of Beldiceanu et al. (2008). There is one case, BE, where CPBuild is an order of magnitude slower than TreeCon; so far we do not have an explanation for this.", "startOffset": 47, "endOffset": 72}, {"referenceID": 24, "context": "Figure 17 shows the supertree, displayed with treeView (Page, 1996), produced from the largest compatible forest {A,B,D,F}.", "startOffset": 55, "endOffset": 67}, {"referenceID": 7, "context": "The RankedTree algorithm (Bryant et al., 2004) takes as input a collection of precedence constraints derived from input ranked species trees and predates relations.", "startOffset": 25, "endOffset": 46}, {"referenceID": 32, "context": "1 Ancestral Divergence Dates Semple et al. (2004) and Bryant et al.", "startOffset": 29, "endOffset": 50}, {"referenceID": 7, "context": "(2004) and Bryant et al. (2004) add temporal information to the input trees.", "startOffset": 11, "endOffset": 32}, {"referenceID": 7, "context": "(2004) and Bryant et al. (2004) add temporal information to the input trees. Interior nodes may be labelled with integer ranks such that if interior node v2 is a proper descendant of v1 then rank(v1) < rank(v2), resulting in a ranked phylogenetic tree. Additionally relative divergence dates may be expressed in the form \u201cdiv(c,d) predates div(a,b)\u201d and this is interpreted as \u201cthe divergence of species c and d predates that of species a and b\u201d. The RankedTree algorithm (Bryant et al., 2004) takes as input a collection of precedence constraints derived from input ranked species trees and predates relations. The algorithm outputs a ranked tree that respects those relations or returns \u201cnot compatible\u201d. This is trivial to incorporate into the constraint model. If trees have been ranked then for each pair of species (i, j) in the leaf set we instantiate the constrained integer variable Mij to the value of mrca(i, j). For a predates relation \u201cdiv(c,d) predates div(a,b)\u201d we post the constraint Mcd < Mab. This is done before step 4 of CPBuild (Figure 16), i.e., ranks and predates relations become side constraints. Similarly time bounds on speciation events are posted as unary constraints, i.e. in a dated phylogenetic tree upper and lower divergence bounds are given on interior nodes, such that l(a, b) and u(a, b) give respectively the lower and upper bounds on the divergence dates of species a and b. In the constraint program the following two side constraints are then posted (again, before step 4): l(a, b) \u2264 Mab and Mab \u2264 u(a, b). A demonstration of ranked trees is given in Figure 18. On the left we have two ranked species trees of cats used recently by Semple et al. (2004) and originally by Janczewski, Modi, Stephens, and O\u2019Brien (1995).", "startOffset": 11, "endOffset": 1694}, {"referenceID": 7, "context": "(2004) and Bryant et al. (2004) add temporal information to the input trees. Interior nodes may be labelled with integer ranks such that if interior node v2 is a proper descendant of v1 then rank(v1) < rank(v2), resulting in a ranked phylogenetic tree. Additionally relative divergence dates may be expressed in the form \u201cdiv(c,d) predates div(a,b)\u201d and this is interpreted as \u201cthe divergence of species c and d predates that of species a and b\u201d. The RankedTree algorithm (Bryant et al., 2004) takes as input a collection of precedence constraints derived from input ranked species trees and predates relations. The algorithm outputs a ranked tree that respects those relations or returns \u201cnot compatible\u201d. This is trivial to incorporate into the constraint model. If trees have been ranked then for each pair of species (i, j) in the leaf set we instantiate the constrained integer variable Mij to the value of mrca(i, j). For a predates relation \u201cdiv(c,d) predates div(a,b)\u201d we post the constraint Mcd < Mab. This is done before step 4 of CPBuild (Figure 16), i.e., ranks and predates relations become side constraints. Similarly time bounds on speciation events are posted as unary constraints, i.e. in a dated phylogenetic tree upper and lower divergence bounds are given on interior nodes, such that l(a, b) and u(a, b) give respectively the lower and upper bounds on the divergence dates of species a and b. In the constraint program the following two side constraints are then posted (again, before step 4): l(a, b) \u2264 Mab and Mab \u2264 u(a, b). A demonstration of ranked trees is given in Figure 18. On the left we have two ranked species trees of cats used recently by Semple et al. (2004) and originally by Janczewski, Modi, Stephens, and O\u2019Brien (1995). The branch lengths of the source trees have been translated into rankings and added to the interior vertices of those trees.", "startOffset": 11, "endOffset": 1759}, {"referenceID": 7, "context": "(2004) and Bryant et al. (2004) add temporal information to the input trees. Interior nodes may be labelled with integer ranks such that if interior node v2 is a proper descendant of v1 then rank(v1) < rank(v2), resulting in a ranked phylogenetic tree. Additionally relative divergence dates may be expressed in the form \u201cdiv(c,d) predates div(a,b)\u201d and this is interpreted as \u201cthe divergence of species c and d predates that of species a and b\u201d. The RankedTree algorithm (Bryant et al., 2004) takes as input a collection of precedence constraints derived from input ranked species trees and predates relations. The algorithm outputs a ranked tree that respects those relations or returns \u201cnot compatible\u201d. This is trivial to incorporate into the constraint model. If trees have been ranked then for each pair of species (i, j) in the leaf set we instantiate the constrained integer variable Mij to the value of mrca(i, j). For a predates relation \u201cdiv(c,d) predates div(a,b)\u201d we post the constraint Mcd < Mab. This is done before step 4 of CPBuild (Figure 16), i.e., ranks and predates relations become side constraints. Similarly time bounds on speciation events are posted as unary constraints, i.e. in a dated phylogenetic tree upper and lower divergence bounds are given on interior nodes, such that l(a, b) and u(a, b) give respectively the lower and upper bounds on the divergence dates of species a and b. In the constraint program the following two side constraints are then posted (again, before step 4): l(a, b) \u2264 Mab and Mab \u2264 u(a, b). A demonstration of ranked trees is given in Figure 18. On the left we have two ranked species trees of cats used recently by Semple et al. (2004) and originally by Janczewski, Modi, Stephens, and O\u2019Brien (1995). The branch lengths of the source trees have been translated into rankings and added to the interior vertices of those trees. On the right we have one of the 17 possible resultant supertrees. In total, 7 of the 17 solutions contain interior nodes with ranges. If interior nodes are labelled with specific values rather than ranges then 30 solutions are produced, some of which are structurally identical. This goes some way to addressing the issue of enumerating all supertrees compactly, raised as a challenge by Semple et al. (2004). In Figure 19 we show the effect of adding a predates constraint to a supertree construction.", "startOffset": 11, "endOffset": 2294}, {"referenceID": 7, "context": "(2004) and Bryant et al. (2004) add temporal information to the input trees. Interior nodes may be labelled with integer ranks such that if interior node v2 is a proper descendant of v1 then rank(v1) < rank(v2), resulting in a ranked phylogenetic tree. Additionally relative divergence dates may be expressed in the form \u201cdiv(c,d) predates div(a,b)\u201d and this is interpreted as \u201cthe divergence of species c and d predates that of species a and b\u201d. The RankedTree algorithm (Bryant et al., 2004) takes as input a collection of precedence constraints derived from input ranked species trees and predates relations. The algorithm outputs a ranked tree that respects those relations or returns \u201cnot compatible\u201d. This is trivial to incorporate into the constraint model. If trees have been ranked then for each pair of species (i, j) in the leaf set we instantiate the constrained integer variable Mij to the value of mrca(i, j). For a predates relation \u201cdiv(c,d) predates div(a,b)\u201d we post the constraint Mcd < Mab. This is done before step 4 of CPBuild (Figure 16), i.e., ranks and predates relations become side constraints. Similarly time bounds on speciation events are posted as unary constraints, i.e. in a dated phylogenetic tree upper and lower divergence bounds are given on interior nodes, such that l(a, b) and u(a, b) give respectively the lower and upper bounds on the divergence dates of species a and b. In the constraint program the following two side constraints are then posted (again, before step 4): l(a, b) \u2264 Mab and Mab \u2264 u(a, b). A demonstration of ranked trees is given in Figure 18. On the left we have two ranked species trees of cats used recently by Semple et al. (2004) and originally by Janczewski, Modi, Stephens, and O\u2019Brien (1995). The branch lengths of the source trees have been translated into rankings and added to the interior vertices of those trees. On the right we have one of the 17 possible resultant supertrees. In total, 7 of the 17 solutions contain interior nodes with ranges. If interior nodes are labelled with specific values rather than ranges then 30 solutions are produced, some of which are structurally identical. This goes some way to addressing the issue of enumerating all supertrees compactly, raised as a challenge by Semple et al. (2004). In Figure 19 we show the effect of adding a predates constraint to a supertree construction. The data has previously been used by Bryant et al. (2004) in their Figures 5 and 6.", "startOffset": 11, "endOffset": 2446}, {"referenceID": 22, "context": "Problems related to creating compatible supertrees for this type of data were raised by Page (2004) and defined and solved by Daniel and Semple (2004).", "startOffset": 88, "endOffset": 100}, {"referenceID": 10, "context": "Problems related to creating compatible supertrees for this type of data were raised by Page (2004) and defined and solved by Daniel and Semple (2004). A set of input trees and possible solution to the problem are shown in Figure 20: notice that all labels are conserved in the solution, all ancestral relationships are conserved and, for any labels li and lj from the same input tree, li is ancestor of lj in the input tree if and only if li is ancestor of lj in the solution tree.", "startOffset": 126, "endOffset": 151}, {"referenceID": 10, "context": "Problems related to creating compatible supertrees for this type of data were raised by Page (2004) and defined and solved by Daniel and Semple (2004). A set of input trees and possible solution to the problem are shown in Figure 20: notice that all labels are conserved in the solution, all ancestral relationships are conserved and, for any labels li and lj from the same input tree, li is ancestor of lj in the input tree if and only if li is ancestor of lj in the solution tree. This is an instance of the problem Higher Taxa Compatibility defined by Daniel and Semple (2004) and Semple et al.", "startOffset": 126, "endOffset": 580}, {"referenceID": 10, "context": "Problems related to creating compatible supertrees for this type of data were raised by Page (2004) and defined and solved by Daniel and Semple (2004). A set of input trees and possible solution to the problem are shown in Figure 20: notice that all labels are conserved in the solution, all ancestral relationships are conserved and, for any labels li and lj from the same input tree, li is ancestor of lj in the input tree if and only if li is ancestor of lj in the solution tree. This is an instance of the problem Higher Taxa Compatibility defined by Daniel and Semple (2004) and Semple et al. (2004), where the result tree must perfectly display all of the input trees.", "startOffset": 126, "endOffset": 605}, {"referenceID": 10, "context": ", common to all possible supertrees) is introduced by (Daniel, 2003) along with the polynomial time decision procedureNecessity.", "startOffset": 54, "endOffset": 68}, {"referenceID": 19, "context": "Junker\u2019s quickXPlain method (Junker, 2004) discovers a minimal subset of constraints that when posted and propagated result in a failure.", "startOffset": 28, "endOffset": 42}, {"referenceID": 19, "context": "Junker (2004) state that this method can be achieved by a worst case of 2k \u00b7 log2(n/k) + 2k propagations 4, where k is the size of the minimal explanation found and n is the number of constraints.", "startOffset": 0, "endOffset": 14}, {"referenceID": 19, "context": "Junker (2004) state that this method can be achieved by a worst case of 2k \u00b7 log2(n/k) + 2k propagations 4, where k is the size of the minimal explanation found and n is the number of constraints. An alternative approach is to satisfy as many of the input triples and fans as is possible within a reasonable amount of time, i.e., polynomial time. Semple and Steel propose such an algorithm, MinCutSupertree (2000), and this has been refined by Page (2002).", "startOffset": 0, "endOffset": 414}, {"referenceID": 19, "context": "Junker (2004) state that this method can be achieved by a worst case of 2k \u00b7 log2(n/k) + 2k propagations 4, where k is the size of the minimal explanation found and n is the number of constraints. An alternative approach is to satisfy as many of the input triples and fans as is possible within a reasonable amount of time, i.e., polynomial time. Semple and Steel propose such an algorithm, MinCutSupertree (2000), and this has been refined by Page (2002). We now propose a similar scheme within the constraint programming framework.", "startOffset": 0, "endOffset": 456}, {"referenceID": 26, "context": "when trees are incompatible build a supertree that violates the minimum number of triples or fans, and do this in polynomial time (Page, 2002; Semple & Steel, 2000).", "startOffset": 130, "endOffset": 164}, {"referenceID": 6, "context": "Bryant et al. (2004) state that they have essentially an \u201call-or-nothing\u201d approach to supertree construction when using RankedTree and what is needed is something akin to MinCutSupertree, i.", "startOffset": 0, "endOffset": 21}, {"referenceID": 5, "context": "This has since been done by Bordewich et al. (2006) and can also be done in our constraint model by incorporating the constraints identified in section 6.", "startOffset": 28, "endOffset": 52}, {"referenceID": 6, "context": "This is sufficient for modelling and solving the supertree construction problem in O(n4) time and O(n2) space, comparable to the complexity of OneTree (Ng & Wormald, 1996) but inferior to that of the algorithm of Bryant and Steel (1995). So, why bother with the CPBuild approach when efficient imperative approaches already exist? The answer lies in the versatility of constraint programming.", "startOffset": 213, "endOffset": 237}], "year": 2008, "abstractText": "A phylogenetic tree shows the evolutionary relationships among species. Internal nodes of the tree represent speciation events and leaf nodes correspond to species. A goal of phylogenetics is to combine such trees into larger trees, called supertrees, whilst respecting the relationships in the original trees. A rooted tree exhibits an ultrametric property; that is, for any three leaves of the tree it must be that one pair has a deeper most recent common ancestor than the other pairs, or that all three have the same most recent common ancestor. This inspires a constraint programming encoding for rooted trees. We present an efficient constraint that enforces the ultrametric property over a symmetric array of constrained integer variables, with the inevitable property that the lower bounds of any three variables are mutually supportive. We show that this allows an efficient constraint-based solution to the supertree construction problem. We demonstrate that the versatility of constraint programming can be exploited to allow solutions to variants of the supertree construction problem.", "creator": null}}}