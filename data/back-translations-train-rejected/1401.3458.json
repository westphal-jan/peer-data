{"id": "1401.3458", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Solving #SAT and Bayesian Inference with Backtracking Search", "abstract": "Inference in Bayes Nets (BAYES) is an important problem with numerous applications in probabilistic reasoning. Counting the number of satisfying assignments of a propositional formula (#SAT) is a closely related problem of fundamental theoretical importance. Both these problems, and others, are members of the class of sum-of-products (SUMPROD) problems. In this paper we show that standard backtracking search when augmented with a simple memoization scheme (caching) can solve any sum-of-products problem with time complexity that is at least as good any other state-of-the-art exact algorithm, and that it can also achieve the best known time-space tradeoff. Furthermore, backtracking's ability to utilize more flexible variable orderings allows us to prove that it can achieve an exponential speedup over other standard algorithms for SUMPROD on some instances.", "histories": [["v1", "Wed, 15 Jan 2014 05:17:49 GMT  (474kb)", "http://arxiv.org/abs/1401.3458v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["fahiem bacchus", "shannon dalmao", "toniann pitassi"], "accepted": false, "id": "1401.3458"}, "pdf": {"name": "1401.3458.pdf", "metadata": {"source": "CRF", "title": "Solving #SAT and Bayesian Inference with Backtracking Search", "authors": ["Fahiem Bacchus", "Shannon Dalmao", "Toniann Pitassi"], "emails": ["FBACCHUS@CS.TORONTO.EDU", "TONI@CS.TORONTO.EDU"], "sections": [{"heading": null, "text": "Counting the number of satisfactory assignments to a sentence formula (# SAT) is a closely related problem of fundamental theoretical importance. Both problems, and others, belong to the class of product summary problems (SUMPROD). In this paper, we show that the standard traceability search, when supplemented with a simple memorization scheme (caching), can solve any product summary problem with time complexity that is at least as good as any other state-of-the-art, accurate algorithm, and that it can also achieve the most well-known time-space compromise. In addition, the ability of traceability to use more flexible variable orders allows it to prove that in some instances it can achieve exponential acceleration over other standard SUMPROD algorithms. The ideas presented here have been used in a number of solvers applied to different types of product summary problems. These systems have taken advantage of the fact that the traceability problem of this problem can be exploited in this way to improve performance."}, {"heading": "1. Introduction", "text": "In fact, it is such that most of them will be able to move into another world, in which they are able to move, in which they are able to move, in which they move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live in which they live, in which they live, in which they live in which they live, in which they live, in which they live in which they live, in which they live, in which they live, in which they live in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they, in which they, in which they, in which they live, in which they, in which they are"}, {"heading": "2. Background", "text": "In this section, we first define the product sum class (SUMPROD) of problems, and then illustrate how BAYES, # SAT, and some other important problems are instances of SUMPROD. As we will show in the rest of the paper, the backtracking search, equipped with different caching schemes, is as follows: 1. The term \"traceability\" over an earlier set of obligations can be used in other contexts, including other SUMPROD algorithms. However, we are referring here to the standard algorithmic paradigm of traceability search, in which a single tree of partial variable assignments is examined in a first manner. This algorithm has an extensive history spanning over a hundred years (Bitner & Reingold, 1975). Well suited to solving SUMPROD. The central computer-based structure evaluated by all SUMPROD algorithms is then explained and the theoretical notion of breadth that is captured by this structure is identified."}, {"heading": "2.1 Sum-of-Products", "text": "Dechter (1999) has shown that BAYES and many other problems are cases of a more general problem called SUMPROD (sum of products). An instance of SUMPROD is defined by the tuple < V, F, Egg V, >, where V is a set of discrete value variables {X1,..., Xn}, F is a set of functions {f1,..., fm}, each fi being defined by a set of variables. Egg V is an additional operator, and is a multiplication operator. The range of functions in F depends on the problem, where both operators are across that range, so that both are commutative, associative, and spread over the entire range. Typical examples include functions extending over the boolean range, where the latter are disjunction operators and are related, or across the realties are operators, the latter being ordinary addition and multiplication. Definition 1 (Total SUltROMPD < < < the problem is in < < the link)."}, {"heading": "2.1.1 BAYES:", "text": "BAYES is the problem of calculating probabilities in a Bayesian network (BN). Developed by Pearl (1988), a Bayesian network is a triple (V, E, P), in which (V, E) a directed acyclic graph is described, in which the nodes V = {X1,.., Xn} represent discrete random variables, edges represent direct correlations between the variables, and with each random variable Xi represent a conditional probability table CPT (or function), fi (Xi, \u03c0 (Xi)) that the conditional distribution of Xi's given assignments of values to their parents (Xi) in (V, E). A Xi Xi represents a common distribution over the random variables V, in which the probability of each assignment (x1,.., xn) to the variables Pr (x1,., xn) = 1 fi (xi, this problem) is assigned."}, {"heading": "2.1.2 MARKOV RANDOM FIELDS", "text": "Markov Random Fields or Markov Networks (MN) (Preston, 1974; Spitzer, 1971) are similar to Bayesian networks in that they also define a common probability distribution via a series of discrete random variables V = {X1,..., Xn} by defining a set of functions fi, so-called potentials, each via a set of variables Ei V. In particular, the probability of an assignment (x1,.., xn) to the variables is given by the normalized product of fi, which is evaluated at the values specified by the assignment: \u0435i fi (Ei [x1,..., xn]). Thus, the difficulty consists in calculating the partition function or calculating a normalization constant: Z = improved X1 \u00b7 \u00b7"}, {"heading": "2.1.3 MOST PROBABLE EXPLANATION", "text": "The most probable explanation (Most Probable Explantation, MPE) is the problem of finding the most probable complete mapping to the variables in a Bayes mesh (or Markov mesh) that matches a fixed mapping to a subset of the variables (the proofs). If the proof, \u03b1, is an instance of the variables in E-V, then MPE is the problem of calculating Max V-Em-i = 1fi | \u03b1 (Ei-E), where fi-\u03b1 is the reduction of the function fi by the instances \u03b1 to the variables in E (which results in a function over the variable Ei-E)."}, {"heading": "2.1.4 SAT", "text": "Let V = {X1, X2,.., Xn} be a collection of n Boolean variables, and let \u03c6 (V) have a k-CNF Boolean formula on these variables with m clauses {c1,..., cm}. An assignment \u03b1 to the Boolean variable V is satisfactory if it makes the formula True (i.e. \u03c6 (\u03b1) = 1). Given a Boolean formula \u03c6 (V) in k-CNF, does SAT ask if it has a satisfactory assignment? By treating each set ci as a function of its variable Ei (i.e., it assigns an assignment to these variables TRUE if this assignment fulfills the sentence and otherwise FALSE), we can see that SAT corresponds to the instance of SUMPROD < V, {c1,.., cm}."}, {"heading": "2.1.5 #SAT", "text": "Given a k-CNF formula \u03c6 (V) on the Boolean variables V = {X1,.., Xn} as described above, # SAT is the problem of determining the number of satisfactory assignments for \u03c6. By looking at each set ci as a function from its variables egg to {0, 1} (i.e., it maps satisfactory assignments to 1 and falsifies assignments to 0), we can see that # SAT corresponds to the example of SUMPROD < V, {c1,.,.., cm}, +, \u00b7 >: \u2211 X1 \u00b7 = 1ci (Ei)."}, {"heading": "2.1.6 OPTIMIZATION WITH DECOMPOSED OBJECTIVE FUNCTIONS", "text": "Let V = {X1,.., Xn} be a collection of finite variables, the optimization task is to find a mapping of values to these variables that maximizes an objective function O (V) (i.e. a function that maps any complete mapping to the variables to a real value).In many problems, O can be broken down into the sum of subobjective functions {f1,...., fm}, where each fi is a function of a subset of variables Ei. This problem can then be considered a SUMPROD instance < V, {f1,..., fm}, max, + > max X1 \u00b7 \u00b7 \u00b7 max Xnm \u2211 i = 1fi (Ei)."}, {"heading": "2.2 The Computational Complexity of SUMPROD", "text": "SUMPROD is a mathematically difficult problem. For example, it is known that # SAT is just as complete for complexity class # P (Valiant, 1979b, 1979a) as BAYES (Roth, 1996). Many special cases that are simple for SAT remain difficult for # SAT, e.g. Valiant showed that the decision version of # SAT is difficult even if the sentence size is k 2, and Roth (1996) showed that in many cases where SAT is simple, the problem is difficult to even come close to solving, e.g. if \u03c6 (V) is monotonous, or Horn or 2-CNF. Despite this intractability at worst, algorithms for SUMPROD, e.g. the variable elimination algorithm presented by Dechter (1999), can be successful in practice. The key structure exploited by this algorithm, and by most algorithms, is that the functions of many SUMPROD problems are relatively local and independent."}, {"heading": "2.3 Complexity Measures and Tree width", "text": "There is a natural hypergraph, H = (V, E), corresponding to any instance < V, F, > of SUMPROD. In the hypergraph, V corresponds to the set V of variables and for each function fi with the domain set Egg, there is a corresponding hyperedge, Egg. The \"width\" of this hypergraph is the critical measure of complexity for essentially all state-of-the-art algorithms for # SAT, BAYES and SUMPROD. There are three different (and well-known) terms of width that we will define in this section. We will also show that these different terms of width are essentially equivalent. These equivalences are known, although we need to specify some basic properties in order to analyze our new algorithms and refer them to standard algorithms. Definition 2 (Branch Width) Let H = (V, E) be a hypergraph."}, {"heading": "2.4 Exact Algorithms for SUMPROD", "text": "Next, we will briefly consider three prominent exact algorithms for BAYES. These algorithms solve the more general problem of SUMPROD. All of these algorithms are actually non-deterministic algorithms that should be considered as procedural families, each of which represents a certain deterministic realization."}, {"heading": "2.4.1 VARIABLE ELIMINATION:", "text": "Variable or bucket elimination (VE) (Dechter, 1999) is a basic algorithm for SUMPROD. Variable elimination begins with the selection of an elimination order, \u03c0 for the variables V = {X1,.., Xn}: X\u03c0 (1),.., X\u03c0 (n). (This is the non-deterministic part of the calculation. In the first phase, all functions that include X\u03c0 (1) are summarized in the defined FX\u03c0 (1), and a new function, F1, is calculated by \"summing\" X\u03c0 (1). The new function summarizes the product of all functions in FX\u03c0 (1) across all X\u03c0 (1)'s values. Specifically, F1 is a function of all variables of the functions in FX\u03c0 (1), the exact resolution of X\u03c0 (1), and their value at each assignment of X\u03c0 (1)."}, {"heading": "2.4.2 RECURSIVE CONDITIONING:", "text": "The recursive preparation of the problem (RC-Space, 2001) is another type of algorithm for defining functions and functions. Lets S = < V, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E"}, {"heading": "2.4.3 AND/OR SEARCH:", "text": "In the more recent work Dechter and Mateescu (2007) we have shown that the notion of such an edge is not able to connect such an edge, but is only able to solve a problem that is the structure of an undirected diagram H, which has the same indentations as H and has an edge that connects two indentations with each other when and only when these two indentations appear together in a hyperedge of H.Definition 6 (Pseudo Tree) In the face of an undirected diagram G with indentations and edges (V, EC) a pseudo tree for G (V, EC) is a directed tree T with indentations and edges (V, ET)."}, {"heading": "2.4.4 OTHER EXACT ALGORITHMS", "text": "This year, it is closer than ever before in the history of the country."}, {"heading": "2.5 Complexity Analysis", "text": "This year, more than ever, it will be able to retaliate."}, {"heading": "3. Using DPLL for #SAT and SUMPROD", "text": "Now we present our methods for extending the backtracking search with different caching schemes, so that SUMPROD can be solved with a time and space guarantee at least as well as the other exact algorithm for SUMPROD. For easier presentation we present DPLL-based algorithms for solving # SAT and derive complexity results for these algorithms. Later we will discuss how the algorithms and complexity results can be applied to other instances of SUMPROD (like BAYES)."}, {"heading": "3.1 DPLL and #DPLL:", "text": "The DPLL is a non-deterministic algorithm for SAT, which is also used to solve various generalizations of SAT (Dubois, 1991; Zhang, 1996; Birnbaum & Lozinskii, 1999; Littman, Majercik, & Pitassi, 2001).DPLL solves SAT by performing a depth search in the space of partial instantiation (i.e., it is a standard backtracking search algorithm).The non-deterministic part of the calculation lies in choosing which variable to query (i.e., instantiate) is next performed during its search.It operates on SAT problems encoded in clause. (CNF) The default DPLL algorithm for solving SAT is given in Algorithm 5."}, {"heading": "3.2 DPLL with Caching:", "text": "Given that the obvious use of DPLL to solve SUMPROD can yield exponentially worse results than the standard algorithms, we are now exploring ways to modify DPLL so that it can solve # SAT (and thus BAYES and SUMPROD) more efficiently. To understand the source of # DPLL's inefficiency, consider the following example. The following diagram shows a sequence of # DPLL set to \u03c6 = {(w-x) (y-z)}. Each node shows the variable to branch and the current formula # DPLL is working on. The left branches correspond to the setting of the branch variable to FALSE, while on the right the variable is set to TRUE. The empty formula is given by {}, while a formula containing the empty sentence is indicated by {()} {DPLL: the empty clause of {()} {DPLL is applied and solves the subproblem {(y)."}, {"heading": "3.2.1 DPLL WITH SIMPLE CACHING (#DPLL-SIMPLECACHE)", "text": "One way to prevent this duplication is to apply memoirs. As shown in Example 6, associated with each node in the DPLL tree, a formula f is such that the subtree rooted in that node tries to calculate the number of satisfactory assignments to f. If we perform a deep search of the tree, we can maintain a buffer that contains all formulas f that have already been solved, and when we reach a new node in the tree, we can avoid traversing its subtree if the value of its corresponding formula is already in the cache. In Example 6, we would keep a buffer if we solve it along the path (w = 0, x = 1), leaving the subtree below (w = 1).Algorithm 7: # DPLL algorithm with simple cache (# DPLL-SimpleCache) # DPLL-SimpleCache."}, {"heading": "3.2.2 DPLL WITH COMPONENT CACHING (#DPLL-CACHE)", "text": "We call the new algorithm # DPLL cache, and its implementation will be in algorithm 8.In the algorithm we can generalize the cache to deal with formulas. First, we say that a (single) formula \u03c6 is known if its value is stored in the cache or if it is an obvious formula (and its value is implicitly stored in the cache). In view of a number of formulas, we say that the sentence is known if either each of these formulas is known, or there are some formal examples whose value is known as zero. In both cases, we say that the value of the cache is equal to the product of the values of the cache. Now, we generalize some of the cache access components. (1) InCache is generalized so that it can accommodate a number of formulas."}, {"heading": "3.3 Using DPLL Algorithms for Other Instances of SUMPROD:", "text": "The DPLL algorithms described in this section can be easily modified to solve other instances of the SUMPROD variable. However, since # SAT solves many instances of the SUMPROD algorithms completely, this problem can easily be applied to BAYES and be empirically successful (Sang et al., 2005b). Moreover, the encoding provided by Sang et al. (2005b) guarantees the same complexity as standard BAYES algorithms. (That is, the CNF encoding does not have a wider width than the original Bayes Net.) This encoding does not associate uniform probabilities to values of the variables. This is not equal to the probability of the x = 0 variables for the probability of the x = 1. This is easy to accommodate in our algorithms: Instead of multiplying the value returned by each variable."}, {"heading": "4. Comparing Algorithms for BAYES and #SAT", "text": "In this section, we will prove that our DPLL-based algorithms are at least as powerful as the standard full algorithms for solving SAT, and that they are stronger than many of them on some levels. This last feature is just as important as our new DPLL-based algorithms, which in some cases can solve problems beyond the reach of many standard full algorithms. (This input can be considered as a sequence of bits.) For VE, which encode non-deterministic bits an elimination order; for RC, which require non-deterministic algorithms, we will look for the non-deterministic bits."}, {"heading": "5. Impact on Practice", "text": "This year, it is more than ever before in the history of the city, in which it has come as far as never before in the history of the city."}, {"heading": "6. Final Remarks", "text": "This year it is more than ever before."}, {"heading": "Appendix A. Proofs", "text": "We can assume that the labels of the leaves of Ttd are in one-to-one correspondence with the margins of H. For an arbitrary node m in Ttd, let label (m) be the set of etices in the label of m, let label of m, Am be the tree root of m, Am be the tree rooted at m, Am root of m, Am be the tree rooted at m, Am wurzel of m, Am verwurzelt at m, etices of the labels at m, Am."}], "references": [{"title": "Satisfiability, Branch-width and Tseitin Tautologies", "author": ["A. Aleknovich", "A. Razborov"], "venue": "In Annual IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "Aleknovich and Razborov,? \\Q2002\\E", "shortCiteRegEx": "Aleknovich and Razborov", "year": 2002}, {"title": "Algorithms and Complexity Results for #SAT and Bayesian Inference", "author": ["F. Bacchus", "S. Dalmao", "T. Pitassi"], "venue": "In Annual IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "Bacchus et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Bacchus et al\\.", "year": 2003}, {"title": "Counting Models using Connected Components", "author": ["R.J. Bayardo", "J.D. Pehoushek"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "Bayardo and Pehoushek,? \\Q2000\\E", "shortCiteRegEx": "Bayardo and Pehoushek", "year": 2000}, {"title": "On the space-time trade-off in solving Constraint Satisfaction Problems", "author": ["R.J. Bayardo", "D.P. Miranker"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Bayardo and Miranker,? \\Q1995\\E", "shortCiteRegEx": "Bayardo and Miranker", "year": 1995}, {"title": "Memoization and DPLL: Formula Caching Proof Systems", "author": ["P. Beame", "R. Impagliazzo", "T. Pitassi", "N. Segerlind"], "venue": "In IEEE Conference on Computational Complexity,", "citeRegEx": "Beame et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2003}, {"title": "The good old Davis Putnam procedure helps counting models", "author": ["E. Birnbaum", "E.L. Lozinskii"], "venue": "J. Artif. Intell. Research (JAIR),", "citeRegEx": "Birnbaum and Lozinskii,? \\Q1999\\E", "shortCiteRegEx": "Birnbaum and Lozinskii", "year": 1999}, {"title": "Backtracking programming techniques", "author": ["J.R. Bitner", "E. Reingold"], "venue": "Communications of the ACM,", "citeRegEx": "Bitner and Reingold,? \\Q1975\\E", "shortCiteRegEx": "Bitner and Reingold", "year": 1975}, {"title": "A tourist guide through Treewidth", "author": ["H.L. Bodlaender"], "venue": "Acta Cybernetica, 11(1\u20132), 1\u201321.", "citeRegEx": "Bodlaender,? 1993", "shortCiteRegEx": "Bodlaender", "year": 1993}, {"title": "Exponential separations between restricted resolution and cutting planes proof systems", "author": ["M. Bonet", "J.L. Esteban", "N. Galesi", "J. Johannsen"], "venue": "In Annual IEEE Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "Bonet et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Bonet et al\\.", "year": 1998}, {"title": "Context-specific independence in Bayesian Networks", "author": ["C. Boutilier", "N. Friedman", "M. Goldszmidt", "D. Koller"], "venue": "In Uncertainty in Artificial Intelligence, Proceedings of Annual Conference (UAI),", "citeRegEx": "Boutilier et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 1996}, {"title": "Encoding CNFs to empower component analysis", "author": ["M. Chavira", "A. Darwiche"], "venue": "In Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Chavira and Darwiche,? \\Q2006\\E", "shortCiteRegEx": "Chavira and Darwiche", "year": 2006}, {"title": "On probabilistic inference by weighted model counting", "author": ["M. Chavira", "A. Darwiche"], "venue": "Artificial Intelligence,", "citeRegEx": "Chavira and Darwiche,? \\Q2008\\E", "shortCiteRegEx": "Chavira and Darwiche", "year": 2008}, {"title": "Compiling relational bayesian networks for exact inference", "author": ["M. Chavira", "A. Darwiche", "M. Jaeger"], "venue": "Int. J. Approx. Reasoning,", "citeRegEx": "Chavira et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Chavira et al\\.", "year": 2006}, {"title": "On PHP, st-connectivity and odd charged graphs", "author": ["P. Clote", "A. Setzer"], "venue": "In Proof Complexity and Feasible Arithmetics,", "citeRegEx": "Clote and Setzer,? \\Q1998\\E", "shortCiteRegEx": "Clote and Setzer", "year": 1998}, {"title": "Introduction to Algorithms. 2nd Edition", "author": ["T.H. Cormen", "C.E. Leiserson", "R.L. Rivest", "C. Stein"], "venue": null, "citeRegEx": "Cormen et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Cormen et al\\.", "year": 2001}, {"title": "Optimal time-space tradeoff in probabilistic inference", "author": ["A. Darwiche", "D. Allen"], "venue": "In European Workshop on Probabilistic Graphical Models. Available at www.cs.ucla.edu/ \u0303darwiche. Darwiche, A", "citeRegEx": "Darwiche and Allen,? \\Q2002\\E", "shortCiteRegEx": "Darwiche and Allen", "year": 2002}, {"title": "A logical approach to factoring belief networks", "author": ["A. Darwiche"], "venue": "Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning, pp. 409\u2013420.", "citeRegEx": "Darwiche,? 2002", "shortCiteRegEx": "Darwiche", "year": 2002}, {"title": "New advances in compiling CNF into decomposable negation normal form", "author": ["A. Darwiche"], "venue": "Proceedings of the European Conference on Artificial Intelligence (ECAI), pp. 328\u2013332.", "citeRegEx": "Darwiche,? 2004", "shortCiteRegEx": "Darwiche", "year": 2004}, {"title": "Using more reasoning to improve #SAT solving", "author": ["J. Davies", "F. Bacchus"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "Davies and Bacchus,? \\Q2007\\E", "shortCiteRegEx": "Davies and Bacchus", "year": 2007}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam", "year": 1960}, {"title": "Bucket elimination: A unifying framework for reasoning", "author": ["R. Dechter"], "venue": "Artificial Intelligence, 113, 41\u201385.", "citeRegEx": "Dechter,? 1999", "shortCiteRegEx": "Dechter", "year": 1999}, {"title": "Mixtures of deterministic-probabilistic networks and their AND/OR search space", "author": ["R. Dechter", "R. Mateescu"], "venue": "In Uncertainty in Artificial Intelligence, Proceedings of Annual Conference (UAI),", "citeRegEx": "Dechter and Mateescu,? \\Q2004\\E", "shortCiteRegEx": "Dechter and Mateescu", "year": 2004}, {"title": "AND/OR search spaces for graphical models", "author": ["R. Dechter", "R. Mateescu"], "venue": "Artificial Intelligence,", "citeRegEx": "Dechter and Mateescu,? \\Q2007\\E", "shortCiteRegEx": "Dechter and Mateescu", "year": 2007}, {"title": "Counting the number of solutions for instances of satisfiability", "author": ["O. Dubois"], "venue": "Theoretical Computer Science, 81, 49\u201364.", "citeRegEx": "Dubois,? 1991", "shortCiteRegEx": "Dubois", "year": 1991}, {"title": "The intractability of resolution", "author": ["A. Haken"], "venue": "Theoretical Computer Science, 39, 297\u2013305.", "citeRegEx": "Haken,? 1985", "shortCiteRegEx": "Haken", "year": 1985}, {"title": "Clause learning can effectively psimulate general propositional resolution", "author": ["P. Hertel", "F. Bacchus", "T. Pitassi", "A. van Gelder"], "venue": "In Proceedings of the AAAI National Conference (AAAI)", "citeRegEx": "Hertel et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hertel et al\\.", "year": 2008}, {"title": "Exponential incomparability of tree-like and ordered resolution", "author": ["J. Johannsen"], "venue": "Unpublished manuscript, available at http://www.tcs.informatik.uni-muenchen. de/ \u0303jjohanns/notes.html. Kask, K., Dechter, R., Larrosa, J., & Dechter, A. (2005). Unifying tree decompositions for reasoning in graphical models. Artificial Intelligence, 166(1-2), 165\u2013193.", "citeRegEx": "Johannsen,? 2001", "shortCiteRegEx": "Johannsen", "year": 2001}, {"title": "Exploiting decomposition in constraint optimization problems", "author": ["M. Kitching", "F. Bacchus"], "venue": "In Proceedings of Principles and Practice of Constraint Programming (CP),", "citeRegEx": "Kitching and Bacchus,? \\Q2008\\E", "shortCiteRegEx": "Kitching and Bacchus", "year": 2008}, {"title": "Local computation with probabilities on graphical structures and their application to expert systems", "author": ["S. Lauritzen", "D. Spiegelhalter"], "venue": "Journal of the Royal Statistical Society Series B,", "citeRegEx": "Lauritzen and Spiegelhalter,? \\Q1988\\E", "shortCiteRegEx": "Lauritzen and Spiegelhalter", "year": 1988}, {"title": "Guiding real-world sat solving with dynamic hypergraph separator decomposition", "author": ["W. Li", "P. van Beek"], "venue": "In Proceedings of the International Conference on Tools with Artificial Intelligence (ICTAI),", "citeRegEx": "Li and Beek,? \\Q2004\\E", "shortCiteRegEx": "Li and Beek", "year": 2004}, {"title": "Performing incremental Bayesian Inference by dynamic model counting", "author": ["W. Li", "P. van Beek", "P. Poupart"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "Li et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Li et al\\.", "year": 2006}, {"title": "Exploiting causal independence using weighted model counting", "author": ["W. Li", "P. van Beek", "P. Poupart"], "venue": "In Proceedings of the AAAI National Conference (AAAI)", "citeRegEx": "Li et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Li et al\\.", "year": 2008}, {"title": "Stochastic boolean satisfiability", "author": ["M.L. Littman", "S.M. Majercik", "T. Pitassi"], "venue": "J. Automated Reasoning,", "citeRegEx": "Littman et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Littman et al\\.", "year": 2001}, {"title": "Maxplan: A new approach to probabilistic planning", "author": ["S.M. Majercik", "M.L. Littman"], "venue": "In Proceedings of the International Conference on Artificial Intelligence Planning and Scheduling (AIPS),", "citeRegEx": "Majercik and Littman,? \\Q1998\\E", "shortCiteRegEx": "Majercik and Littman", "year": 1998}, {"title": "Dynamic orderings for AND/OR branch-and-bound search in graphical models", "author": ["R. Marinescu", "R. Dechter"], "venue": "In Proceedings of the European Conference on Artificial Intelligence (ECAI),", "citeRegEx": "Marinescu and Dechter,? \\Q2006\\E", "shortCiteRegEx": "Marinescu and Dechter", "year": 2006}, {"title": "Best-first AND/OR search for graphical models", "author": ["R. Marinescu", "R. Dechter"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "Marinescu and Dechter,? \\Q2007\\E", "shortCiteRegEx": "Marinescu and Dechter", "year": 2007}, {"title": "AND/OR multi-valued decision diagrams for weighted graphical models", "author": ["R. Mateescu", "R. Dechter"], "venue": "In Uncertainty in Artificial Intelligence, Proceedings of Annual Conference (UAI)", "citeRegEx": "Mateescu and Dechter,? \\Q2007\\E", "shortCiteRegEx": "Mateescu and Dechter", "year": 2007}, {"title": "AND/OR cutset conditioning", "author": ["R. Mateescu", "R. Dechter"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Mateescu and Dechter,? \\Q2005\\E", "shortCiteRegEx": "Mateescu and Dechter", "year": 2005}, {"title": "Chaff: Engineering an efficient sat solver", "author": ["E. Moskewicz", "C. Madigan", "M. Zhao", "L. Zhang", "S. Malik"], "venue": "In Proc. of the Design Automation Conference (DAC)", "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "Principles of Artificial Intelligence", "author": ["N.J. Nilsson"], "venue": "Tioga.", "citeRegEx": "Nilsson,? 1980", "shortCiteRegEx": "Nilsson", "year": 1980}, {"title": "Probabilistic Reasoning in Intelligent Systems (2nd edition)", "author": ["J. Pearl"], "venue": "Morgan Kaufmann, San Mateo, CA.", "citeRegEx": "Pearl,? 1988", "shortCiteRegEx": "Pearl", "year": 1988}, {"title": "Gibbs States on Countable Sets", "author": ["C. Preston"], "venue": "Cambridge University Press.", "citeRegEx": "Preston,? 1974", "shortCiteRegEx": "Preston", "year": 1974}, {"title": "Resolution versus search: Two strategies for SAT", "author": ["I. Rish", "R. Dechter"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Rish and Dechter,? \\Q2000\\E", "shortCiteRegEx": "Rish and Dechter", "year": 2000}, {"title": "Graph minors X. obstructions to tree-decomposition", "author": ["N. Robertson", "P. Seymour"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "Robertson and Seymour,? \\Q1991\\E", "shortCiteRegEx": "Robertson and Seymour", "year": 1991}, {"title": "Graph minors XIII. the disjoint paths problem", "author": ["N. Robertson", "P. Seymour"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "Robertson and Seymour,? \\Q1995\\E", "shortCiteRegEx": "Robertson and Seymour", "year": 1995}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Artificial Intelligence, 82(1\u20132), 273\u2013 302.", "citeRegEx": "Roth,? 1996", "shortCiteRegEx": "Roth", "year": 1996}, {"title": "Combining component caching and clause learning for effective model counting", "author": ["T. Sang", "F. Bacchus", "P. Beame", "H.A. Kautz", "T. Pitassi"], "venue": "In Theory and Applications of Satisfiability Testing (SAT)", "citeRegEx": "Sang et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Sang et al\\.", "year": 2004}, {"title": "Heuristics for fast exact model counting", "author": ["T. Sang", "P. Beame", "H.A. Kautz"], "venue": "In Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Sang et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sang et al\\.", "year": 2005}, {"title": "Performing Bayesian Inference by weighted model counting", "author": ["T. Sang", "P. Beame", "H.A. Kautz"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "Sang et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sang et al\\.", "year": 2005}, {"title": "A dynamic approach for MPE and weighted MAXSAT", "author": ["T. Sang", "P. Beame", "H.A. Kautz"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Sang et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Sang et al\\.", "year": 2007}, {"title": "Affine algebraic decision diagrams (aadds) and their applications to structured probabilistic inference", "author": ["P. Sanner", "D. McAllester"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Sanner and McAllester,? \\Q2005\\E", "shortCiteRegEx": "Sanner and McAllester", "year": 2005}, {"title": "Markov random fields and Gibbs ensembles", "author": ["F.L. Spitzer"], "venue": "American Mathematical Monthly, 78, 142\u201354.", "citeRegEx": "Spitzer,? 1971", "shortCiteRegEx": "Spitzer", "year": 1971}, {"title": "sharpSAT\u2014Counting models with advanced component caching and implicit BCP", "author": ["M. Thurley"], "venue": "Theory and Applications of Satisfiability Testing (SAT), pp. 424\u2013429.", "citeRegEx": "Thurley,? 2006", "shortCiteRegEx": "Thurley", "year": 2006}, {"title": "The complexity of enumeration and reliability problems", "author": ["L.G. Valiant"], "venue": "SIAM Journal of Computing, 9, 410\u2013421.", "citeRegEx": "Valiant,? 1979a", "shortCiteRegEx": "Valiant", "year": 1979}, {"title": "The Complexity of Computing the Permanent", "author": ["L.G. Valiant"], "venue": "Theoretical Computer Science, 8, 189\u2013201.", "citeRegEx": "Valiant,? 1979b", "shortCiteRegEx": "Valiant", "year": 1979}, {"title": "Number of models and satisfiability of sets of clauses", "author": ["W. Zhang"], "venue": "Theoretical Computer Science, 155, 277\u2013288.", "citeRegEx": "Zhang,? 1996", "shortCiteRegEx": "Zhang", "year": 1996}], "referenceMentions": [{"referenceID": 41, "context": "Probabilistic inference in Bayesian Networks (BAYES) is an important and well-studied problem with numerous practical applications in probabilistic reasoning (Pearl, 1988).", "startOffset": 158, "endOffset": 171}, {"referenceID": 46, "context": "In particular, the decision versions of both #SAT and BAYES are #P-complete (Valiant, 1979b, 1979a; Roth, 1996), and there are natural polynomial-time reductions from each problem to the other (Darwiche, 2002; Sang, Beame, & Kautz, 2005b; Chavira, Darwiche, & Jaeger, 2006).", "startOffset": 76, "endOffset": 111}, {"referenceID": 16, "context": "In particular, the decision versions of both #SAT and BAYES are #P-complete (Valiant, 1979b, 1979a; Roth, 1996), and there are natural polynomial-time reductions from each problem to the other (Darwiche, 2002; Sang, Beame, & Kautz, 2005b; Chavira, Darwiche, & Jaeger, 2006).", "startOffset": 193, "endOffset": 273}, {"referenceID": 41, "context": "Developed by Pearl (1988), a Bayesian network is a triple (V, E,P) where (V, E) describes a directed acyclic graph, in which the nodes V = {X1, .", "startOffset": 13, "endOffset": 26}, {"referenceID": 42, "context": "Markov Random Fields or Markov Networks (MN) (Preston, 1974; Spitzer, 1971) are similar to Bayesian Networks in that they also define a joint probability distribution over a set of discrete random variables V = {X1, .", "startOffset": 45, "endOffset": 75}, {"referenceID": 52, "context": "Markov Random Fields or Markov Networks (MN) (Preston, 1974; Spitzer, 1971) are similar to Bayesian Networks in that they also define a joint probability distribution over a set of discrete random variables V = {X1, .", "startOffset": 45, "endOffset": 75}, {"referenceID": 46, "context": "For example, #SAT is known to be complete for the complexity class #P (Valiant, 1979b, 1979a) as is BAYES (Roth, 1996).", "startOffset": 106, "endOffset": 118}, {"referenceID": 45, "context": "For example, #SAT is known to be complete for the complexity class #P (Valiant, 1979b, 1979a) as is BAYES (Roth, 1996). Many special cases that are easy for SAT remain hard for #SAT, e.g., Valiant showed that the decision version of #SAT is #P hard even when the clause size, k, is 2, and Roth (1996) showed that the problem is hard to even approximate in many cases where SAT is easy, e.", "startOffset": 107, "endOffset": 301}, {"referenceID": 21, "context": ", the variable elimination algorithm presented by Dechter (1999), can be successful in practice.", "startOffset": 50, "endOffset": 65}, {"referenceID": 7, "context": ", (Bodlaender, 1993).", "startOffset": 2, "endOffset": 20}, {"referenceID": 7, "context": ", (Bodlaender, 1993). Following Robertson and Seymour (1991) we have defined tree decompositions over hypergraphs, rather than over graphs, and we have made two extra restrictions so as to simplify the proofs of our results.", "startOffset": 3, "endOffset": 61}, {"referenceID": 21, "context": "Variable or bucket elimination (VE) (Dechter, 1999) is a fundamental algorithm for SUMPROD.", "startOffset": 36, "endOffset": 51}, {"referenceID": 16, "context": "Recursive conditioning (RC) (Darwiche, 2001) is another type of algorithm for SUMPROD. Let S = \u3008V,F ,\u2295,\u2297\u3009 be an instance of SUMPROD and H be its underlying hypergraph. RC is a divide and conquer algorithm that instantiates the variables of V so as to break the problem into disjoint components. It then proceeds to solve these components independently. The original spaceefficient version of recursive conditioning, as specified by Darwiche (2001), begins with a branch decomposition T of H of width w and depth d, and an initially empty set of instantiated variables \u03c1.", "startOffset": 29, "endOffset": 448}, {"referenceID": 21, "context": "Rish and Dechter (2000) have previously made a connection between DP and variable elimination.", "startOffset": 9, "endOffset": 24}, {"referenceID": 15, "context": "In fact, Darwiche and Allen (2002) show that there is a smooth tradeoff that can be achieved, with RC-Space and RC-Cache at the two extremes.", "startOffset": 9, "endOffset": 35}, {"referenceID": 40, "context": "In more recent work Dechter and Mateescu (2007) have shown that the notion of AND/OR search spaces (Nilsson, 1980) can be applied to formalize the divide and conquer approach to SUMPROD problems utilized by RC.", "startOffset": 99, "endOffset": 114}, {"referenceID": 21, "context": "In more recent work Dechter and Mateescu (2007) have shown that the notion of AND/OR search spaces (Nilsson, 1980) can be applied to formalize the divide and conquer approach to SUMPROD problems utilized by RC.", "startOffset": 20, "endOffset": 48}, {"referenceID": 21, "context": "Algorithm 4 shows the caching version AND/OR-Cache (called AND/OR graph search by Dechter and Mateescu (2007)).", "startOffset": 82, "endOffset": 110}, {"referenceID": 21, "context": "(Marinescu and Dechter (2006) refer to AND/OR-Cache+ as \u201cAND/OR with partial variable ordering\u201d.", "startOffset": 15, "endOffset": 30}, {"referenceID": 41, "context": "Another algorithm that has now been mostly superseded is cut-set conditioning (Pearl, 1988).", "startOffset": 78, "endOffset": 91}, {"referenceID": 15, "context": "(2005), Darwiche (2001) has shown that RC can compute all marginals on BAYES problems with an extra bottom up traversal of its search tree\u2014at most doubling its run time.", "startOffset": 8, "endOffset": 24}, {"referenceID": 15, "context": "(2005), Darwiche (2001) has shown that RC can compute all marginals on BAYES problems with an extra bottom up traversal of its search tree\u2014at most doubling its run time. The same technique can be applied to AND/OR search algorithms. For the DPLL algorithms we present here, Sang et al. (2005b) have given an even simpler scheme for modifying them so that they can computing all marginals.", "startOffset": 8, "endOffset": 294}, {"referenceID": 2, "context": "Finally, an important early algorithm called DDP was presented by Bayardo and Pehoushek (2000). This was a version of DPLL that utilized dynamic decomposition for solving #SAT.", "startOffset": 66, "endOffset": 95}, {"referenceID": 2, "context": "Finally, an important early algorithm called DDP was presented by Bayardo and Pehoushek (2000). This was a version of DPLL that utilized dynamic decomposition for solving #SAT. In terms of the algorithms discussed above, AND/OR-Space can be viewed as being an version of DDP that utilizes a pseudo tree to guide its variable ordering. In the original presentation of DDP, any variable ordering could be used including dynamic variable orderings. The search continued until the problem was decomposed into independent components (tested for during search) at which point a separate recursion was used to solve each component. Hence, the DDP explored an AND/OR search tree, however this tree need not correspond to any pseudo tree over the original problem. (The DVO and DSO AND/OR search schemes presented by Mateescu and Dechter (2005) are also versions of DDP run with particular variable ordering heuristics).", "startOffset": 66, "endOffset": 836}, {"referenceID": 2, "context": "Finally, an important early algorithm called DDP was presented by Bayardo and Pehoushek (2000). This was a version of DPLL that utilized dynamic decomposition for solving #SAT. In terms of the algorithms discussed above, AND/OR-Space can be viewed as being an version of DDP that utilizes a pseudo tree to guide its variable ordering. In the original presentation of DDP, any variable ordering could be used including dynamic variable orderings. The search continued until the problem was decomposed into independent components (tested for during search) at which point a separate recursion was used to solve each component. Hence, the DDP explored an AND/OR search tree, however this tree need not correspond to any pseudo tree over the original problem. (The DVO and DSO AND/OR search schemes presented by Mateescu and Dechter (2005) are also versions of DDP run with particular variable ordering heuristics). In comparison with the algorithms we present in the next section, Bayardo and Pehoushek (2000) did not provide a complexity analysis of DDP, DDP did not use caching to enhance its performance, and DDP still has less flexibility in its variable ordering.", "startOffset": 66, "endOffset": 1007}, {"referenceID": 3, "context": "Specifically, Dechter and Mateescu show that AND/OR-Space runs in time exponential in the height of its inputed pseudo tree, and Bayardo and Miranker (1995) show that this height is bounded w log n.", "startOffset": 129, "endOffset": 157}, {"referenceID": 3, "context": "Specifically, Dechter and Mateescu show that AND/OR-Space runs in time exponential in the height of its inputed pseudo tree, and Bayardo and Miranker (1995) show that this height is bounded w log n. Lemma 1 then shows that the bound also holds for branch width. Similarly, Dechter and Mateescu (2007) show that AND/OR-Cache runs in time and space bounded by nO(1)2O(w) by exploiting the very close relationship between pseudo trees and elimination orders.", "startOffset": 129, "endOffset": 301}, {"referenceID": 44, "context": "However, Robertson and Seymour (1995) present an algorithm for computing a branch decomposition with branch width that is within a factor of 2 of optimal and that runs in time nO(1)2O(w), where w is the branch width of H.", "startOffset": 9, "endOffset": 38}, {"referenceID": 21, "context": "And finally, from that nearly optimal elimination ordering the bucket-tree construction of Dechter and Mateescu (2007) can be used to construct a nearly optimal pseudo tree, and thus we can obtain a deterministic version of AND/OR-Space that runs in linear space and time 2O(w logn), and a deterministic version of AND/OR-Cache that runs in time and space nO(1)2O(w).", "startOffset": 91, "endOffset": 119}, {"referenceID": 24, "context": "DPLL is a nondeterministic algorithm for SAT, that has also been used to solve various generalizations of SAT, including #SAT (Dubois, 1991; Zhang, 1996; Birnbaum & Lozinskii, 1999; Littman, Majercik, & Pitassi, 2001).", "startOffset": 126, "endOffset": 217}, {"referenceID": 56, "context": "DPLL is a nondeterministic algorithm for SAT, that has also been used to solve various generalizations of SAT, including #SAT (Dubois, 1991; Zhang, 1996; Birnbaum & Lozinskii, 1999; Littman, Majercik, & Pitassi, 2001).", "startOffset": 126, "endOffset": 217}, {"referenceID": 25, "context": "In particular, it is implicit in the results of Haken (1985) that any decision tree for the formulas encoding the (negation of the) propositional pigeonhole principle has exponential size, and thus DPLL and #DPLL must take exponential-time on these examples.", "startOffset": 48, "endOffset": 61}, {"referenceID": 47, "context": "For example, this approach is readily applicable to BAYES and has proved to be empirically successful (Sang et al., 2005b). Furthermore, the encoding provided by Sang et al. (2005b) achieves the same complexity guarantees as standard algorithms for BAYES.", "startOffset": 103, "endOffset": 182}, {"referenceID": 16, "context": "The proof of this theorem is implicit in the results of Darwiche (2001).", "startOffset": 56, "endOffset": 72}, {"referenceID": 2, "context": "DDP is the algorithm presented by Bayardo and Pehoushek (2000).", "startOffset": 34, "endOffset": 63}, {"referenceID": 17, "context": ", (Darwiche, 2004; Chavira & Darwiche, 2006, 2008).", "startOffset": 2, "endOffset": 50}, {"referenceID": 28, "context": "The empirical results of Kitching and Bacchus (2008) show that the added flexibility of #DPLL-Cache can sometimes yield significant performance improvements over AND/OR search even when the extra flexibility of AND/OR-Cache+ is exploited.", "startOffset": 25, "endOffset": 53}, {"referenceID": 3, "context": "More sophisticated caching methods have also been explored for solving SAT by Beame et al. (2003) who showed that some of these methods can considerably increase the power of DPLL.", "startOffset": 78, "endOffset": 98}, {"referenceID": 0, "context": "In other related work, one of the results of Aleknovich and Razborov (2002) showed that SAT could be solved in time nO(1)2O(w).", "startOffset": 45, "endOffset": 76}, {"referenceID": 21, "context": "Marinescu and Dechter (2007) present a method for searching an AND/OR tree in a best-first manner.", "startOffset": 14, "endOffset": 29}, {"referenceID": 28, "context": ", 2004, 2005a) and by the branch and bound system described by Kitching and Bacchus (2008) support our belief that this added flexibility can be important in practice.", "startOffset": 63, "endOffset": 91}, {"referenceID": 1, "context": "Some of the results of this paper were presented in an earlier conference paper (Bacchus et al., 2003).", "startOffset": 80, "endOffset": 102}, {"referenceID": 16, "context": "By the results of Darwiche (2001), there is a branch decomposition of H of depth O(logm) and width O(w).", "startOffset": 18, "endOffset": 34}, {"referenceID": 16, "context": "By the results of Darwiche (2001), there is a branch decomposition of H of depth O(logm) and width O(w). Also by the results of Robertson and Seymour (1995), it is possible to find a branch decomposition, Tbd, such that Tbd has branch width O(w) and depth O(logm), in time nO(1)2O(w).", "startOffset": 18, "endOffset": 157}, {"referenceID": 27, "context": "To prove this theorem we first observe that from a result of Johannsen (Johannsen, 2001), #DPLL-Cache, #DPLL-Space, and #DPLL can all solve the negation of the propositional stringof-pearls principle (Bonet, Esteban, Galesi, & Johannsen, 1998) in time nO(logn), when run with a dynamic variable ordering.", "startOffset": 71, "endOffset": 88}, {"referenceID": 12, "context": "The string-of-pearls principle, introduced in a different form by Clote and Setzer (1998) and explicitly by Bonet et al.", "startOffset": 66, "endOffset": 90}, {"referenceID": 8, "context": "The string-of-pearls principle, introduced in a different form by Clote and Setzer (1998) and explicitly by Bonet et al. (1998) is as follows.", "startOffset": 108, "endOffset": 128}, {"referenceID": 27, "context": "Johannsen (Johannsen, 2001) shows that SPn,n has quasipolynomial size tree resolution proofs.", "startOffset": 10, "endOffset": 27}, {"referenceID": 27, "context": "Lemma 4 (Johannsen, 2001) SPn,n can be solved in time nO(logn) by #DPLL, #DPLL-Space, and #DPLL-Cache.", "startOffset": 8, "endOffset": 25}], "year": 2009, "abstractText": "Inference in Bayes Nets (BAYES) is an important problem with numerous applications in probabilistic reasoning. Counting the number of satisfying assignments of a propositional formula (#SAT) is a closely related problem of fundamental theoretical importance. Both these problems, and others, are members of the class of sum-of-products (SUMPROD) problems. In this paper we show that standard backtracking search when augmented with a simple memoization scheme (caching) can solve any sum-of-products problem with time complexity that is at least as good any other state-of-the-art exact algorithm, and that it can also achieve the best known time-space tradeoff. Furthermore, backtracking\u2019s ability to utilize more flexible variable orderings allows us to prove that it can achieve an exponential speedup over other standard algorithms for SUMPROD on some instances. The ideas presented here have been utilized in a number of solvers that have been applied to various types of sum-of-product problems. These system\u2019s have exploited the fact that backtracking can naturally exploit more of the problem\u2019s structure to achieve improved performance on a range of problem instances. Empirical evidence of this performance gain has appeared in published works describing these solvers, and we provide references to these works.", "creator": "dvips(k) 5.96dev Copyright 2007 Radical Eye Software"}}}