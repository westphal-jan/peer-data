{"id": "1401.3466", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "An Anytime Algorithm for Optimal Coalition Structure Generation", "abstract": "Coalition formation is a fundamental type of interaction that involves the creation of coherent groupings of distinct, autonomous, agents in order to efficiently achieve their individual or collective goals. Forming effective coalitions is a major research challenge in the field of multi-agent systems. Central to this endeavour is the problem of determining which of the many possible coalitions to form in order to achieve some goal. This usually requires calculating a value for every possible coalition, known as the coalition value, which indicates how beneficial that coalition would be if it was formed. Once these values are calculated, the agents usually need to find a combination of coalitions, in which every agent belongs to exactly one coalition, and by which the overall outcome of the system is maximized. However, this coalition structure generation problem is extremely challenging due to the number of possible solutions that need to be examined, which grows exponentially with the number of agents involved. To date, therefore, many algorithms have been proposed to solve this problem using different techniques ranging from dynamic programming, to integer programming, to stochastic search all of which suffer from major limitations relating to execution time, solution quality, and memory requirements.", "histories": [["v1", "Wed, 15 Jan 2014 05:23:56 GMT  (3867kb)", "http://arxiv.org/abs/1401.3466v1", null]], "reviews": [], "SUBJECTS": "cs.MA cs.AI", "authors": ["talal rahwan", "sarvapali dyanand ramchurn", "nicholas robert jennings", "rea giovannucci"], "accepted": false, "id": "1401.3466"}, "pdf": {"name": "1401.3466.pdf", "metadata": {"source": "CRF", "title": "An Anytime Algorithm for Optimal Coalition Structure Generation", "authors": ["Talal Rahwan", "Sarvapali D. Ramchurn", "Nicholas R. Jennings", "Andrea Giovannucci"], "emails": ["TR@ECS.SOTON.AC.UK", "SDR@ECS.SOTON.AC.UK", "NRJ@ECS.SOTON.AC.UK", "AGIOVANNUCCI@IUA.UPF.EDU"], "sections": [{"heading": null, "text": "The formation of a coalition is a basic type of interaction that involves the creation of coherent groupings of different, autonomous, agents in order to efficiently achieve their individual or collective objectives. Building effective coalitions is a major research challenge in the field of multi-agent systems. At the center of these efforts is the problem of determining which of the many possible coalitions needs to be formed to achieve a specific goal. This requires calculating a value for any possible coalition known as coalition value, which indicates how useful this coalition would be if formed, the agents usually need to find a combination of coalitions in which each actor belongs to exactly one coalition, and through which the overall outcome of the system is maximized."}, {"heading": "1. Introduction", "text": "In fact, it is so that most of them are able to survive themselves, and that they are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...)"}, {"heading": "2. Related Work", "text": "Previous algorithms designed for the problem of coalition structure generation can be divided into two main categories: \u2022 Exact algorithms1 - by heuristics, integer programming or dynamic programming. \u2022 Inaccurate algorithms - by means of genetic algorithms or in a certain way limitation of the search area. Next, we will discuss both the advantages and limitations of the algorithms falling into each of these classes. In the entire essay, we describe the number of agents according to n and according to A = {a1, \u00b7 a set of agents. Furthermore, we define a sequence of agents in A as follows: following:"}, {"heading": "2.1 Exact Algorithms for Coalition Structure Generation", "text": "There are very few exact algorithms for generating coalition structures, and those that have been developed can be distinguished by the use of dynamic programming or heuristics. (1) Remember that an exact algorithm always provides an optimal solution when it exists (Evans & Minieka, 1992). In the following, we outline their properties and discuss how they relate to our ultimate goal of developing an efficient, always optimal algorithm for generating coalition structures."}, {"heading": "2.1.1 DYNAMIC PROGRAMMING", "text": "In this context, Yeh (1986) developed a dynamic programming algorithm to solve the complete set partitioning problem. However, a very similar algorithm was later developed by Rothkopf, Pekec and Harstad (1995) to solve the problem of winning in combinatorial auctions. These algorithms can be applied directly to find optimal coalition structures, since the problems they were originally intended to solve are very similar to the CSG problem.2 Note also that both of these algorithms use essentially the same technique and therefore have the same computer-based complexity. During this paper, we do not distinguish between them, and refer to both the Dynamic Programming (DP) and the algorithm, which is the greatest advantage of this algorithm that it runs in O (3n) time."}, {"heading": "2.1.2 ANYTIME ALGORITHMS WITH WORST CASE GUARANTEES", "text": "In fact, it is as if most of us are able to obey the rules that they have imposed on themselves. (...) In fact, it is as if they are able to determine themselves how they have behaved. (...) It is as if they were able to obey the rules. (...) It is as if they were able to change the rules. (...) It is as if they were able to determine themselves. (...) It is as if they were able to determine themselves. (...) It is as if they were able to determine themselves. (...) It is as if they were able to determine themselves. (...) It is as if they were able to determine themselves. (...) It is as if they are able to determine the rules. (...)"}, {"heading": "2.2 Non-Exact Algorithms for Coalition Structure Generation", "text": "In fact, it is such that most of them will be able to move into a different world, in which they are able to live as in a world in which they are able, in which they are able, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live."}, {"heading": "3. Search Space Representation", "text": "In this section, we describe our novel representation of the search space (i.e. the space of possible coalition structures), remembering that the spatial representation used by most existing algorithms is an undirected graph (see Figure 1 for an example) in which the vertices represent coalition structures (Sandholm et al., 1999; Dang & Jennings, 2004), but this representation forces us to examine all possible solutions to ensure that the optimal one has been found. Considering this, we believe that an ideal representation of the search space should allow the calculation of solutions at any time, while setting limits to their quality, and should allow the circumcision of the space to speed up the search. With this objective in mind, we describe exactly such a representation in this section. In particular, it supports an efficient search for the following reasons: First, it divides the space into smaller, independent sub-spaces for which we can identify the upper and lower boundaries, and thus it calculates a predetermined solution. Second, we can better define the sub-spaces for most of these sub-spaces, since we can better match the existing sub-spaces."}, {"heading": "3.1 Partitioning the Search Space", "text": "8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,"}, {"heading": "3.2 Computing Bounds for Sub-spaces", "text": "For each subarea PG it is possible to calculate an upper and a lower limit on the value of the best10 coalition structure that could be found in it. To this end, let Ls be the list of coalitions of size s, and let maxs, mins, and avgs be the maximum, minimum, and average value of coalitions in Ls respectively. Furthermore, given a holistic partitionG, let TG be the Cartesian product of lists Ls. That is, TG = s, G (s) G (s), where G (s) is the multiplicity of in9. Note that the levels in our representation are essentially the same as those that appear in the coalition structure graph, except that the coalition structures within each level are categorized into subspaces. In other words, the coalition structures that belong to the subdivisions in Pi are the same as those that belong to LVi.10. Through this paper, a coalition structure is described as \"best.\""}, {"heading": "4. Solving the Coalition Structure Generation Problem", "text": "Assuming that the value of each coalition C is given by a characteristic function v (C) \u0441R, and that the value of each coalition structure is given by function V (CS) = \u2211 C \u0441CS v (C), our goal is to sift through the set of possible coalition structures, noted as P, in order to find an optimal coalition structure designated as: CS \u043c = arg max CS \u0441P V (CS) (1) given v (C) for all C \u04412A\\ {). Note that in this section the terms \"coalition structure\" and \"solution\" are used interchangeably. Basically, our novel algorithm, always based on integer partition (which we call IP) consists of the following two main steps: 1. Scanning the input to calculate the boundaries (i.e. MAXG and AV GG) so that the boundaries (i.e. MAXG and AV GG) are identical for each subspace."}, {"heading": "4.1 Scanning the Input", "text": "The input to the coalition structure generational problem is the value associated with each coalition, i.e. v (C) is for all coalitions. (1) One way to represent this input is to use a table that contains each coalition along with its value. Another way is to agree on a sequence of coalitions and to use a list that contains only the values of these ordered coalitions (i.e. the first value in the list corresponds to the first value, the second value corresponds to the second coalition, and so on). We use the latter representation because it does not require the coalitions themselves to be maintained in memory. Further, we assume that the input is given as follows: v (Ls), which the second value corresponds to the second coalition, and so on.), where v (Ls) is a list that contains the values of all coalitions of size. Furthermore, we assume that the coalitions are lexicographically ordered in Ls."}, {"heading": "4.2 Selecting and Searching a Sub-Space", "text": "Considering the amount of sub-spaces that remain after scanning the input, we select a sub-space that needs to be searched and find the best coalition structure therein. We then truncate any remaining sub-spaces that have an upper limit lower than the best value found so far. This process of selection, search and truncation is repeated until one of the following closing conditions is reached: \u2022 The best coalition structure found so far matches within the given upper limit \u03b2-spaces. \u2022 All remaining sub-spaces have either been searched or truncated. This can be done in Algorithm 3. Basically, the algorithm works as follows: \u2022 A sub-space PG-spaces is selected to be searched (Step 2).12 Once PG-spaces have been searched (Step 3), it is removed from the group of remaining sub-spaces (Step 4). Then we check whether the CS-space has been modified (Step 5), if the CS-space has been modified (or if the input space has been modified)."}, {"heading": "4.2.1 SELECTING A SUB-SPACE", "text": "This implies that \u03b2 is more than 1 until the following subspaces are searched: {PG: MAXG \u2265 V (CS \u0445)} This can be done by selecting the next subspace to be searched with the following selection rule: Selection rule G = arg max G. \"(MAXG) As a result of this selection strategy, all subspaces with an upper limit lower than V (CS) are not searched and these can represent a significant portion of the search space (see Section 5.3 for more details). Another result is that it will always be advantageous to search a subspace, even if that subspace does not contain a better solution than the one found so far. This is because the above selection strategy ensures that a sub-space is searched for, and this improves the worst case that the sub-space does not contain."}, {"heading": "4.2.2 SEARCHING A SUB-SPACE", "text": "G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G"}, {"heading": "5. Performance Evaluation", "text": "In this section, we evaluate the intellectual property algorithm empirically and compare it with the state of the literature. Since the ability of intellectual property to constrain space depends on the proximity of the upper and lower limits to the actual optimal value, and since this proximity is determined by the distribution of coalition values, it is crucial that intellectual property is tested against different value distributions. Furthermore, we aim to evaluate the ability of our algorithm to generate solutions at all times and to quickly zoom in on very high-quality solutions. In the following, we will first discuss the validity and properties of the various value distributions we use to test the algorithm (Section 5.1), and then compare our algorithm with the fastest available algorithm in literature (i.e. IDP) based on the above distributions (Section 5.2). Finally, we will empirically evaluate the efficiency and effectiveness of our algorithm in generalizing solutions (Section 5.3)."}, {"heading": "5.1 Benchmarking", "text": "The common practice in benchmarking heuristics is to choose some standard examples of the problem and to compare the different algorithms that exist without giving them a prioritized knowledge of the type of input with which they are presented. Standard examples of the coalition structure generational problems were defined and used by Larson and Sandholm (2000), namely: 201. Normal: v (C) \u0445 | N (\u00b5, \u03c32), where \u00b5 = 1 and \u03c3 = 0.1.2. Uniform: v (C). U (a, b), where a = 0 and b = 1.While we use the above distributions to name our algorithm, we also question the validity of these distributions. This is because in our previous work (Rahwan et al., 2007b) we pointed out that the normal and uniform distributions of uniforms generate small numbers of coalibutions. However, we now show that when the coalition values are picked out of the normal form or the size of the coalition (s)."}, {"heading": "5.2 Experiment 1: Optimality", "text": "In this experiment, we compare the performance of the algorithms against different numbers of agents (from 15 to 27). In addition, the time to find the optimal coalition structure is measured in terms of time (in milliseconds) on an Intel 2.6GHz quad core PC with 3 gigabytes of RAM. The algorithms are encoded using JAVA 1.6. Runtime is displayed on a log scale in Figure 8.22. We note how IP-X applies IP to distribution X, where X can be NDCS, normal or uniform (as described above). IP finds the optimal coalition structure significantly faster than IDP for all distributions. At best (uniform for 27 agents), IP 570 times better than IDP (i.e. it takes 0.175% of the time taken by IDP) and at worst (NDCS for 16 agents) it is 1.7 times faster than IDP."}, {"heading": "5.3 Experiment 2: Anytime Quality", "text": "In this experiment, we further evaluate the property of our algorithms at any time, and that is by recording the value of the solutions generated prior to the return of the guaranteed optimum. In particular, we have recorded two indicative measures of the quality of the solutions. Firstly, we have calculated the ratio between the value of the current best solution and the optimal solution (obtained at the end of the run), which is called ropt = V (CS \u2032) V (CS \u0445). This measure shows how effective the algorithm is in the search for good solutions. Secondly, we have fixed the ratio between the value of the current best solution and the upper limit to the optimal value. (i.e.) rbound = V (CS \u2032). This measure shows how effective the algorithm is in the search for good solutions."}, {"heading": "6. Conclusions and Future Work", "text": "In fact, it is such that most of them will be able to move into another world, in which they are able to move, in which they move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they live, in which they live."}, {"heading": "7. Acknowledgments", "text": "The research in this paper was carried out within the framework of the ALADDIN project (Autonomous Learning Agents for Decentralized Data and Information Systems) and is jointly funded by a strategic partnership between BAE Systems and EPSRC (Engineering and Physical Research Council) (EP / C548051 / 1). Andrea Giovannucci was funded by the Juan de la Cierva Program (JCI-2008-03006) and the EU-funded Synthetic Forager Project (ICT-217148-SF). We also thank Professor TuomasSandholm for his comments and the anonymous reviewers for their valuable comments on earlier versions of the paper. We are also very grateful to Dr Viet Dung Dang for his contributions to earlier versions of the paper. Finally, we would like to thank Dr W. T. Luke Teacy for his help with some of the corrections and the anonymous reviewers for their very constructive comments."}, {"heading": "Appendix A. Summary of Notation", "text": "A The number of agents in A. C A coalition. | C | The cardinality of C. v (C) The value of C. CS A coalition structure.V (CS) The value of CS. CS \u043d An optimal coalition structure. UB \u0445 The upper limit of V (CS \u043a). LB \u043c The lower limit of V (CS \u043c). CS \u2032 The best coalition structure found so color. \u03b2 The quality of the best solution found so color. \u03b2 The limit within which a solution is acceptable. LCis The list of possible size combinations is taken from the set {1, 2,., i}. The list of coalitions of size s ordered lexicographicographically.v (Ls) The list contains the values of all coalitions in Ls. maxs The maximum number of coalitions in Ls. maxs. The maximum value of coalitions in Ls. mins The minimum value of coalitions in Ls. avgs The mean value of coalition structures in the possible coalition structure."}, {"heading": "Appendix B. Proof of Theorem 1.", "text": "G-G1, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-2, G-G2, G-G2, G-G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2, G-G2"}, {"heading": "Appendix C. Proof of Theorem 2.", "text": "In general, the number of possible combinations of size s from the set B = A / B equals C | A | | | B | s. On this basis, for each coalition of size g1, g2,.., Gi there are coalitions of size g2 that do not overlap with it. (g1 + g2 +... + gi) Gi + 1 coalitions of size gi + 1 that do not overlap with the union C1, g2,...., Gi each C \u2212 (g1 + g2 +...) Gi + 1 coalitions of size gi + 1 that do not overlap with the union C1, g2."}, {"heading": "Appendix D. Proof of Theorem 3.", "text": "In view of an integral partition G = [g1,.., g | g | g | g] j = [[G] j, it is necessary to prove that all coalition structures in PG are generated by MCP. Without loss of universality, we assume that the parts in G are in increasing order, that is: g1 \u2264 g2 and so on. Furthermore, the way in which these ordered sentences are generated ensures that the coalitions do not overlap in any of the ordered sentences. In other words: MCP produces a subset of TG, which is defined as T-G, which is as follows: 26T-G = C1,..., C-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G G-G-G-G-G-G-G-G-G-G G-G-G-G G-G-G-G-G-G-G-G G G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G-G G G-G-G-G-G-G-G G G-G-G-G-G-G-G-G-G-G G-G-G-G-G-G-G G-G-G-G-G-G-G-G G-G-G-G-G-G-G-G G-G-G-G-G-G-G"}, {"heading": "Appendix E. Proof of Theorem 4.", "text": "Considering the fact that an integer partitionG = [g1] and the way MCP works. 27 Considering an integer partitionG = [g1], on the other hand, if there is a subset of GG that contains all ordered sets that correspond to CS, we will prove that the CSG = = 1, C2,. We define T-GG and T-GSG as being in Appendix D. We also assume that the order holds in (7), if G (gi) = 1 that the difference between GG and GG exists, then there is no difference between the way FCP works. 27 On the other hand, if there is a sufficient difference."}, {"heading": "Appendix F. Proof of Theorem 5", "text": "We will first use theory 5 for the normal distribution case (i.e. the case in which coalitions containing fewer coalitions are more likely to be optimal). To prove this, we will first prove the following problem, which has to do with the properties of the normal distribution."}, {"heading": "Appendix G. Proof of Theorem 6.", "text": "Considering the following points: C'A, v (C), N (| C |, | C |) (16), we must prove that the value of each coalition structure is drawn independently of the same normal distribution. Specifically, we will prove that for two independent random variables x and y, that x-x, x-N (\u00b5x, \u03c3x2) and y-N (\u00b5y, \u03c3y2), we know that the following values are fulfilled for all two independent random variables x and y, the x-N (\u00b5x, \u03c3x2) and y-N (\u03c3x2), since they are independent random variables): (v (C1) + \u03c3y2) (18), then, based on (16) and (18), two arbitrary coalition values, v (C1) and v (C2), and v (C2), the following values are fulfilled (since they are independent random variables): (v (C1) + \u03c3y2) (18), two arbitrary coalition values v (S-S) and v (C2), S-S-S-S-S-S-S, fulfil the following (since they are independent random variables)): (v (C1) + \u03c3y2) and S-S-S-S-S-S, then, based on (S-S-S-S-S-S-S-S-S-S-S-S, and S-S-S-S-S-S-S-S-S-S, S-S-S-S-S-S-S-S-S-S-S-S-S-S, S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S, S-S-S-S-S-S-S-S-S-S-S, S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-S-"}], "references": [], "referenceMentions": [], "year": 2009, "abstractText": "Coalition formation is a fundamental type of interaction that involves the creation of coherent groupings of distinct, autonomous, agents in order to efficiently achieve their individual or collective goals. Forming effective coalitions is a major research challenge in the field of multi-agent systems. Central to this endeavour is the problem of determining which of the many possible coalitions to form in order to achieve some goal. This usually requires calculating a value for every possible coalition, known as the coalition value, which indicates how beneficial that coalition would be if it was formed. Once these values are calculated, the agents usually need to find a combination of coalitions, in which every agent belongs to exactly one coalition, and by which the overall outcome of the system is maximized. However, this coalition structure generation problem is extremely challenging due to the number of possible solutions that need to be examined, which grows exponentially with the number of agents involved. To date, therefore, many algorithms have been proposed to solve this problem using different techniques \u2014 ranging from dynamic programming, to integer programming, to stochastic search \u2014 all of which suffer from major limitations relating to execution time, solution quality, and memory requirements. With this in mind, we develop an anytime algorithm to solve the coalition structure generation problem. Specifically, the algorithm uses a novel representation of the search space, which partitions the space of possible solutions into sub-spaces such that it is possible to compute upper and lower bounds on the values of the best coalition structures in them. These bounds are then used to identify the sub-spaces that have no potential of containing the optimal solution so that they can be pruned. The algorithm, then, searches through the remaining sub-spaces very efficiently using a branch-and-bound technique to avoid examining all the solutions within the searched subspace(s). In this setting, we prove that our algorithm enumerates all coalition structures efficiently by avoiding redundant and invalid solutions automatically. Moreover, in order to effectively test our algorithm we develop a new type of input distribution which allows us to generate more reliable benchmarks compared to the input distributions previously used in the field. Given this new distribution, we show that for 27 agents our algorithm is able to find solutions that are optimal in 0.175% of the time required by the fastest available algorithm in the literature. The algorithm is anytime, and if interrupted before it would have normally terminated, it can still provide a solution that is guaranteed to be within a bound from the optimal one. Moreover, the guarantees we provide on the quality of the solution are significantly better than those provided by the previous state of the art algorithms designed for this purpose. For example, for the worst case distribution given 25 agents, our algorithm is able to find a 90% efficient solution in around 10% of time it takes to find the optimal solution. c<lb>\u00a92009 AI Access Foundation. All rights reserved. RAHWAN, RAMCHURN, GIOVANNUCCI, & JENNINGS", "creator": "TeX"}}}