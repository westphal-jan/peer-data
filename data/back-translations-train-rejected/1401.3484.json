{"id": "1401.3484", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Modularity Aspects of Disjunctive Stable Models", "abstract": "Practically all programming languages allow the programmer to split a program into several modules which brings along several advantages in software development. In this paper, we are interested in the area of answer-set programming where fully declarative and nonmonotonic languages are applied. In this context, obtaining a modular structure for programs is by no means straightforward since the output of an entire program cannot in general be composed from the output of its components. To better understand the effects of disjunctive information on modularity we restrict the scope of analysis to the case of disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion of a DLP-function, where a well-defined input/output interface is provided, and establish a novel module theorem which indicates the compositionality of stable-model semantics for DLP-functions. The module theorem extends the well-known splitting-set theorem and enables the decomposition of DLP-functions given their strongly connected components based on positive dependencies induced by rules. In this setting, it is also possible to split shared disjunctive rules among components using a generalized shifting technique. The concept of modular equivalence is introduced for the mutual comparison of DLP-functions using a generalization of a translation-based verification method.", "histories": [["v1", "Wed, 15 Jan 2014 05:36:41 GMT  (492kb)", "http://arxiv.org/abs/1401.3484v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["tomi janhunen", "emilia oikarinen", "hans tompits", "stefan woltran"], "accepted": false, "id": "1401.3484"}, "pdf": {"name": "1401.3484.pdf", "metadata": {"source": "CRF", "title": "Modularity Aspects of Disjunctive Stable Models", "authors": ["Tomi Janhunen", "Emilia Oikarinen", "Hans Tompits", "Stefan Woltran"], "emails": ["Tomi.Janhunen@tkk.fi", "Emilia.Oikarinen@tkk.fi", "tompits@kr.tuwien.ac.at", "woltran@dbai.tuwien.ac.at"], "sections": [{"heading": "1. Introduction", "text": "This year is the highest in the history of the country."}, {"heading": "2. The Class of DLP-Functions", "text": "The topic of this section is the syntax of DLP functions and the syntactical constraints we have imposed on the composition of DLP functions."}, {"heading": "3. Model Theory and Stable-Model Semantics", "text": "After defining the syntax of DLP functions, we now turn to their semantics."}, {"heading": "4. Characterizations using Classical Logic", "text": "It is well known how the series of stable models of an ordinary disjunctive logic program, i.e. a DLP function in the form < R, \u2205, O, \u2205 >, can be characterized using classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003).In this section, we generalize these concepts to any DLP function. To this end, the main focus is on the role of input atoms and their integration into these concepts. In addition, we extend the tightness properties of programs (Erdem & Lifschitz, 2003) to DLP functions by introducing the concept of I-tightness in Section 4.2."}, {"heading": "4.1 Program Completion and Loop Formulas", "text": "Considering a DLP function, a loop of \"A\" is a non-empty subset of a strongly interconnected component of the positive dependency graph \"A\" (\"A\") (\"A\"). Remember that \"A\" (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"A\") (\"B\" (\"A\") (\"A\") (\"A\") (A) (B) (A) (A) (A) (A) (A) (A) (A) (B) () (A) (A) (A) (A) (A) (A) (A) (A) (B) () (A) (A) (B) () (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (B (A) (A) (A) (A) (A) (A) (A) (A) (A) (B (A) (A) (A) (A) (A) (A) (A) (A) (B (A) (A) (A) (A) (A) (A) (B (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (B (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A () (A) (A) (A) (A () (A) (A) (A) (A) (A () (A) (A) (A) (A) () (A) (A) (A) (A) (A (A) (A) ("}, {"heading": "M \u2208 SM(\u03a0) if and only if M |= Comp(\u03a0) and M |= LF(\u03a0).", "text": "It is not the case that we for each interpretation M (1), M (1), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (2), M (4), M (3), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4), M (4, M (4), M (4), M (4), M (4), M (4, M (4), M (4), M (4), M (4, M (4), M (4), M (4, M (4), M (4, M (4), M (4), M (4, M (4), M (4), M (4), M (4, M (4), M (4), M (4, M (4), M (4, M (4), M (4, 4, M (4), M (4, M (4), M (4, M (4), M (4), M (4, M (4), M (4), M (4, M (4), M (4), M (4), M (4, M (4), M (4, M (4, 4), M (4, M ("}, {"heading": "4.2 Tight DLP-functions", "text": "This is of interest because we can take advantage of the fact that the positive dependency curve DG + (B) can be defined with respect to the input signature. In other words, since the dependency curve DG + (B) has only the atoms of Ato (B), loops are defined as arbitrary, non-empty subsets of the strongly connected components in DG + (B), if the tightness for DLP functions can be defined with respect to the input signature. In the initial phase of Section 4, the loops were defined as arbitrary, non-empty subsets of the strongly connected components in DG + (B). So, if the tightness for DLP functions acyclic is then defined only singleton loops, the conversion is not necessarily true because, for a program that has only singleton loops, DG + (B) can have edges."}, {"heading": "M \u2208 SM(\u03a0) if and only if M |= Comp(\u03a0).", "text": "In particular, this result is compatible with an existing characterization of stable models in the case of Ati (\u0441) = \u2205, i.e., if Ato (\u0441\u0441\u0442\u0430\u0441\u0442\u043e\u0441\u0442\u043e\u0441\u0435\u0441\u0435\u0441\u0442\u0435\u0441\u0435\u0441\u0442\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0442\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0442\u0435\u0441\u0442\u0435\u0441\u0435\u0441\u0442\u0435\u0441\u0442\u0435\u0441\u0442\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0435\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u0441\u0438\u043d\u0438\u043d\u0438\u043d\u0438\u043d\u0438\u043d\u0438\u0439 (2003) is reduced to that of Lee and Lifschitz."}, {"heading": "5. Compositional Semantics", "text": "In the following, our goal is to establish the main result of this work, i.e. to show that the semantics of the Stable Model as given in Definition 3.8 is fully compositional when larger DLP functions as presented in Definition 3.1 are formed as linkages of DLP functions. Specifically, the linkage of SM (B) and SM (B),..., SM (B) is explained in Section 5.1. In analogy to Section 3, we take a fairly rigorous approach and consider such a relationship first for classical models, then for minimal models, and finally cover the case of stable models that make up our module theorem. Finally, in Section 5.2, we will use quantified Boolean formulas from the second level of the polynomic hierarchy and its modular representation in relation to DLP functions to illustrate the module theorem. Finally, Section 5.3 is dedicated to a comparison with the splitting verified by Lifitz and Turner."}, {"heading": "5.1 Module Theorem", "text": "To begin with, we need to define the criteria for combining definitions and models (Definition 5.1) (Definition 5.1) (Definition 5.1) (Definition 5.1) (Definition 5.1) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (Definition 5.2) (5.2) (Definition 5.2) (5.2) (Definition 5.2) (5.2) (Definition 5.2) (5.2) (Definition 5.2) (5.2) (5.2) (5.2) (5.2) (5.2) (6.2) (6.2) (6.2) (6.2) (6.2 (6.2) (6.2) (6.2) (6.2 (6.2) (6.2) (6.2 (6.2) (6.2) (6.2 (6.2) (6.2) (6.2) (6.6.2 (6.2) (6.2 (6.2) (6.2) (6.2 (6.6.2) (6.2) (6.2)."}, {"heading": "5.2 Modular Representation of Quantified Boolean Formulas", "text": "Our next goal is to present the theory developed so far in relation to a broader problem. To this end, we will consider the pair of DLP functions shown in Figure 2. (1) Their purpose is to evaluate quantified Boolean formulas (QBFs) of the form \"X-Y\" n (1) of the form \"X-Y\" n (1). (2) Their purpose is to evaluate quantified Boolean formulas (QBFs), and the parameter \"n\" indicates the number of disjuncts in the matrix, which is a Boolean formula in disjunctive normal form (DNF). (10) Without loss of universality, we can assume that X = 1 (Ai), Y = 1 (Ci), Y = 1 (Ci), and X-Y = [2) of the sets of Boolean variables in the (19)."}, {"heading": "5.3 Splitting Sets", "text": "For comparison, we formulate the splitting set theorem (Lifschitz & Turner, 1994) for a DLP function that essentially forms an \"ordinary\" disjunctive program. Splitting sets are sets of atoms that are closed in the following sense: Definition 5.15 In the case of a DLP function, a set quantity of atoms is a splitting set, if and only if it is for each rule A-B-C-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R-R"}, {"heading": "A \u2229 U 6= \u2205 implies A \u222aB \u222a C \u2286 U .", "text": "According to the definitions 2.1 and 5.15, \u2205 and O are always splitting sets for both sides. < b = >.eu However, one is mostly interested in other non-trivial splitting sets for both sides, but such sets do not have to exist. < b = > R divides the respective group of rules R into two parts. The division of R into bU (R) and tU (R) includes all rules A \u2190 B, XI (R) and tU (R) so that the upper group tU (R), R (R), R (R), R (R), bU (R) and tU (R) become a proper group, i.e. bU (R) 6 = Systems and tU (R) 6 = Systems, if1. U is not trivial and.U has at least one definition rule A (S), B) and C (R)."}, {"heading": "6. Decomposing DLP-Functions", "text": "The objectives of this section contradict the construction of a DLP function as a connection of modules. < p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p and p > p > p > p > p > p > p = p and p = p \u00b2 p = p \u00b2 p = p \u00b2 p = p \u00b2 p and p = p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p p p \u00b2 p = p \u00b2 p p p p \u00b2 p = p p \u00b2 p p p p p = p \u00b2 p p p p = p \u00b2 p p p = p \u00b2 p p p = p \u00b2 p p p p = p \u00b2 p p = p \u00b2 p \u00b2 p p = p \u00b2 p = p \u00b2 p \u00b2 p p = p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p = p \u00b2 p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p p = p \u00b2 p \u00b2 p p p p = p \u00b2 p \u00b2 p = p \u00b2 p p \u00b2 p = p \u00b2 p \u00b2 p p = p \u00b2 p p p \u00b2 p \u00b2 p p p p p p p p p p p = p = p \u00b2 p \u00b2 p \u00b2 p p = p \u00b2 p \u00b2 p p = p \u00b2 p \u00b2 p p p = p \u00b2 p \u00b2 p p p p p p \u00b2 p p p = p p = p \u00b2 p \u00b2 p = p \u00b2 p \u00b2 p p = p \u00b2 p \u00b2 p \u00b2 p \u00b2 p p p p p p p p = p \u00b2 p \u00b2 p p"}, {"heading": "S2 \u2208 SCC", "text": "This is clearly possible for integrity restrictions that relate to hidden atoms that are contained only in a single component. However, in order to avoid mergers of this kind as far as possible, it is worth redistributing integrity restrictions that relate to hidden atoms. This is clearly possible for integrity restrictions that relate to a single component. To formalize the ideas presented hitherto, cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf. cf."}, {"heading": "7. Shifting Disjunctions", "text": "In this section, we will continue to track applications for the module theorem established in Section 5."}, {"heading": "8. Equivalence of DLP-Functions", "text": "The concept of visible equivalence was originally introduced to neglect hidden atoms when comparing logical programs or other interesting theories based on their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logical program modules - leading to the idea of modular equivalence of logical programs. In this section, we generalize the concept of modular equivalence for DLP functions and introduce a translation-based method for verifying the modular equivalence of DLP functions, following analogous approaches of Oikarinen and Janhunen (2004, 2009)."}, {"heading": "8.1 Modular Equivalence", "text": "For this reason, we consider two DLP functions (1 and 2) to be compatible if and only if Ati (1) = Ati (2) and Ato (1) = Ato (2) = Ato (2). Definition 8.1 DLP functions (1 and 2) are considered compatible. Definition 8.1 DLP functions (1 and 2) is such that for all interpretations M (1), M (1), M (2), Atv (1) = f (M), Atv (2).Proof DLP functions being congruent for normal programs (Oikarinen & Janhunen, 2008a)."}, {"heading": "8.2 Verifying Modular Equivalence", "text": "The two logical programs are weak equivalents if they have exactly the same set of stable models. (This motivates us to adjust the modular equivalence of modular equivalence for the verification of modular equivalence.) As observed in previous work (Janhunen & Oikarinen, 2007; Oikarinen & Janhunen, 2008a), the verification of visible / modular equivalence involves a payment problem in general. (A reduction in computational time complexity can be achieved for programs that have sufficiently visible atoms. (Janhunen & Janhunen, 2008a), the verification of visible / modular equivalence involves a counting problem. (A reduction in computational time complexity can be achieved for programs that have sufficiently visible atoms. (Janhunen Oikarinen, 2008a), the equivalence of visible atoms."}, {"heading": "9. Related Work", "text": "Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases. In their approach, query programs are formalized as triples < \u03c0, R >, where \u03c0 is a set of disjunctive rules and R and S are the signatures for the input and output relationships, while auxiliary (hidden) predicates are left implicit. Therefore, the only notable difference in terms of definition 2.1 is that input atoms must not occur in the heads of disjunctive rules. In terms of semantics, the program is reduced in terms of a complete instantiation database. D specifies in terms of instantiation, and, among other things, stable model semantics is applied to definition 3.2."}, {"heading": "10. Conclusion and Discussion", "text": "This year, we have reached the point where we feel we are able to live in a country where most people are able to live in a country where they are able, where they are able to move, and where they are able to move."}], "references": [{"title": "Macros, macro calls and use of ensembles in modular answer set programming", "author": ["C. Baral", "J. Dzifcak", "H. Takahashi"], "venue": "Proceedings of the 22nd International Conference on Logic Programming (ICLP\u201906 ),", "citeRegEx": "Baral et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Baral et al\\.", "year": 2006}, {"title": "Propositional semantics for disjunctive logic programs", "author": ["R. Ben-Eliyahu", "R. Dechter"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Ben.Eliyahu and Dechter,? \\Q1994\\E", "shortCiteRegEx": "Ben.Eliyahu and Dechter", "year": 1994}, {"title": "Modularity in logic programming", "author": ["M. Bugliesi", "E. Lamma", "P. Mello"], "venue": "Journal of Logic Programming,", "citeRegEx": "Bugliesi et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Bugliesi et al\\.", "year": 1994}, {"title": "Negation as failure", "author": ["K.L. Clark"], "venue": "Logic and Data Bases,", "citeRegEx": "Clark,? \\Q1978\\E", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "Reducing disjunctive to non-disjunctive semantics by shift-operations", "author": ["J. Dix", "G. Gottlob", "V.W. Marek"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Dix et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Dix et al\\.", "year": 1996}, {"title": "Conflict-driven disjunctive answer set solving", "author": ["C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. K\u00f6nig", "M. Ostrowski", "T. Schaub"], "venue": "Proceedings of the 11th International Conference on Principles and Knowledge Representation and Reasoning,", "citeRegEx": "Drescher et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Drescher et al\\.", "year": 2008}, {"title": "Uniform equivalence of logic programs under the stable model semantics", "author": ["T. Eiter", "M. Fink"], "venue": "Proceedings of the 19th International Conference on Logic Programming (ICLP\u201903),", "citeRegEx": "Eiter and Fink,? \\Q2003\\E", "shortCiteRegEx": "Eiter and Fink", "year": 2003}, {"title": "Simplifying logic programs under uniform and strong equivalence", "author": ["T. Eiter", "M. Fink", "H. Tompits", "T. Woltran"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Eiter et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2004}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Eiter and Gottlob,? \\Q1995\\E", "shortCiteRegEx": "Eiter and Gottlob", "year": 1995}, {"title": "Modular logic programming and generalized quantifiers", "author": ["T. Eiter", "G. Gottlob", "H. Veith"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201997 ),", "citeRegEx": "Eiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "Combining answer set programming with description logics for the Semantic Web", "author": ["T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits"], "venue": "Artificial Intelligence,", "citeRegEx": "Eiter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2008}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Erdem and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Erdem and Lifschitz", "year": 2003}, {"title": "Magic sets and their application to data integration", "author": ["W. Faber", "G. Greco", "N. Leone"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Faber et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Faber et al\\.", "year": 2007}, {"title": "Fully abstract compositional semantics for logic programs", "author": ["H. Gaifman", "E. Shapiro"], "venue": "In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages,", "citeRegEx": "Gaifman and Shapiro,? \\Q1989\\E", "shortCiteRegEx": "Gaifman and Shapiro", "year": 1989}, {"title": "Engineering an incremental ASP solver", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Gebser et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "Detecting inconsistencies in large biological networks with answer set programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele", "B. Usadel", "P. Veber"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Gebser et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "Building a knowledge base: An example", "author": ["M. Gelfond", "A. Gabaldon"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Gelfond and Gabaldon,? \\Q1999\\E", "shortCiteRegEx": "Gelfond and Gabaldon", "year": 1999}, {"title": "Logic programming and knowledge representation \u2013 the A-Prolog perspective", "author": ["M. Gelfond", "N. Leone"], "venue": "Artificial Intelligence,", "citeRegEx": "Gelfond and Leone,? \\Q2002\\E", "shortCiteRegEx": "Gelfond and Leone", "year": 2002}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the 5th International Conference on Logic Programming", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Disjunctive defaults", "author": ["M. Gelfond", "H. Przymusinska", "V. Lifschitz", "M. Truszczy\u0144ski"], "venue": "Proceedings of the 2nd International Conference on Principles and Knowledge Representation and Reasoning,", "citeRegEx": "Gelfond et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Giunchiglia et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "Some (in)translatability results for normal logic programs and propositional theories", "author": ["T. Janhunen"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Janhunen,? \\Q2006\\E", "shortCiteRegEx": "Janhunen", "year": 2006}, {"title": "Modular equivalence in general", "author": ["T. Janhunen"], "venue": "Proceedings of the 18th European Conference on Artificial Intelligence", "citeRegEx": "Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Janhunen", "year": 2008}, {"title": "Removing redundancy from answer set programs", "author": ["T. Janhunen"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908),", "citeRegEx": "Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Janhunen", "year": 2008}, {"title": "Unfolding partiality and disjunctions in stable model semantics", "author": ["T. Janhunen", "I. Niemel\u00e4", "D. Seipel", "P. Simons", "You", "J.-H"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Janhunen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Janhunen et al\\.", "year": 2006}, {"title": "lpeq and dlpeq \u2013 translators for automated equivalence testing of logic programs", "author": ["T. Janhunen", "E. Oikarinen"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Janhunen and Oikarinen,? \\Q2004\\E", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2004}, {"title": "Automated verification of weak equivalence within the smodels system", "author": ["T. Janhunen", "T. Oikarinen"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Janhunen and Oikarinen,? \\Q2007\\E", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2007}, {"title": "Towards an efficient tableau method for boolean circuit satisfiability checking", "author": ["T. Junttila", "I. Niemel\u00e4"], "venue": "Proceedings of the First International Conference on Computational Logic (CL 2000),", "citeRegEx": "Junttila and Niemel\u00e4,? \\Q2000\\E", "shortCiteRegEx": "Junttila and Niemel\u00e4", "year": 2000}, {"title": "Enhancing disjunctive logic programming systems by SAT checkers", "author": ["C. Koch", "N. Leone", "G. Pfeifer"], "venue": "Artificial Intelligence,", "citeRegEx": "Koch et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Koch et al\\.", "year": 2003}, {"title": "Loop formulas for disjunctive logic programs", "author": ["J. Lee", "V. Lifschitz"], "venue": "Proceedings of the 19th International Conference on Logic Programming (ICLP\u201903 ), Vol. 2916 of LNCS,", "citeRegEx": "Lee and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Lee and Lifschitz", "year": 2003}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Leone et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Computing circumscription", "author": ["V. Lifschitz"], "venue": "Proceedings of the 9th International Joint Conference on Artificial Intelligence", "citeRegEx": "Lifschitz,? \\Q1985\\E", "shortCiteRegEx": "Lifschitz", "year": 1985}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "A modular action description language", "author": ["V. Lifschitz", "W. Ren"], "venue": "In Proceedings of the 21st National Conference on Artificial Intelligence", "citeRegEx": "Lifschitz and Ren,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz and Ren", "year": 2006}, {"title": "Splitting a logic program", "author": ["V. Lifschitz", "H. Turner"], "venue": "Proceedings of the 11th International Conference on Logic Programming", "citeRegEx": "Lifschitz and Turner,? \\Q1994\\E", "shortCiteRegEx": "Lifschitz and Turner", "year": 1994}, {"title": "Representing transition systems by logic programs", "author": ["V. Lifschitz", "H. Turner"], "venue": "Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "Lifschitz and Turner,? \\Q1999\\E", "shortCiteRegEx": "Lifschitz and Turner", "year": 1999}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhao,? \\Q2004\\E", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": null, "citeRegEx": "Marek and Truszczy\u0144ski,? \\Q1999\\E", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Applications of circumscription to formalizing commonsense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence,", "citeRegEx": "McCarthy,? \\Q1986\\E", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Niemel\u00e4,? \\Q1999\\E", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Verifying the equivalence of logic programs in the disjunctive case", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904 ),", "citeRegEx": "Oikarinen and Janhunen,? \\Q2004\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2004}, {"title": "Achieving compositionality of the stable model semantics for smodels programs", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Oikarinen and Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2008}, {"title": "Implementing prioritized circumscription by computing disjunctive stable models", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Artificial Intelligence: Methodology, Systems, and Applications, 13th International Conference (AIMSA\u201908),", "citeRegEx": "Oikarinen and Janhunen,? \\Q2008\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2008}, {"title": "A translation-based approach to the verification of modular equivalence", "author": ["E. Oikarinen", "T. Janhunen"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Oikarinen and Janhunen,? \\Q2009\\E", "shortCiteRegEx": "Oikarinen and Janhunen", "year": 2009}, {"title": "A theory of diagnosis from first principles", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Reiter,? \\Q1987\\E", "shortCiteRegEx": "Reiter", "year": 1987}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "Simons et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Simons et al\\.", "year": 2002}], "referenceMentions": [{"referenceID": 40, "context": "Answer-set programming (ASP) (Marek & Truszczy\u0144ski, 1999; Niemel\u00e4, 1999; Gelfond & Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems are described in terms of rules subject to a nonmonotonic semantics based on stable models (Gelfond & Lifschitz, 1988).", "startOffset": 29, "endOffset": 95}, {"referenceID": 21, "context": "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.", "startOffset": 38, "endOffset": 55}, {"referenceID": 13, "context": "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.", "startOffset": 94, "endOffset": 121}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al.", "startOffset": 75, "endOffset": 98}, {"referenceID": 31, "context": ", 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally.", "startOffset": 62, "endOffset": 82}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced.", "startOffset": 76, "endOffset": 657}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving.", "startOffset": 76, "endOffset": 1043}, {"referenceID": 5, "context": "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemel\u00e4, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving. The idea is to gradually extend a program instance in terms of additional modules, e.g., when solving AI planning problems. Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the module theorem can be directly exploited in correctness proofs. For instance, it is proved by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can be captured with disjunctive stable models using a particular translation.", "startOffset": 76, "endOffset": 1445}, {"referenceID": 15, "context": "The term goes back to Gelfond and Gabaldon (1999) who introduced LP-functions as (partial) definitions of new relations in terms of old, known ones.", "startOffset": 22, "endOffset": 50}, {"referenceID": 13, "context": "However, arbitrary combinations of program modules are not meaningful and, first of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro (1989) from the context of negation/disjunction-free logic programs.", "startOffset": 135, "endOffset": 162}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step.", "startOffset": 63, "endOffset": 76}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs\u2014neither involving default negation nor disjunctions.", "startOffset": 64, "endOffset": 472}, {"referenceID": 3, "context": "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs\u2014neither involving default negation nor disjunctions. As observed by them, too, syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models.2 In the current paper, we strive for analogous results but in the case of programs permitting both default negation and disjunctions. It turns out that strongly connected components of positive dependency graphs provide a key criterion when it comes to confining program composition. The compositionality properties of disjunctive programs under stable-model semantics have also arisen in the context of the so-called splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the module theorem established herein is a proper generalization of its predecessor (Oikarinen & Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation of quantified Boolean formulas (QBFs), which serve as canonical representatives of the classes of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter and Gottlob (1995), it is natural from our perspective to concentrate on the second level of the PH in the case of disjunctive programs.", "startOffset": 64, "endOffset": 1651}, {"referenceID": 13, "context": "The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences of a definite program and hence the intersection of its Herbrand models.", "startOffset": 20, "endOffset": 47}, {"referenceID": 13, "context": "To this end, we extend a definition originally proposed by Gaifman and Shapiro (1989) to the case of disjunctive programs.", "startOffset": 59, "endOffset": 86}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 105}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 122}, {"referenceID": 16, "context": "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).", "startOffset": 77, "endOffset": 158}, {"referenceID": 13, "context": "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs.", "startOffset": 23, "endOffset": 50}, {"referenceID": 13, "context": "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs. Thus, program union as operator for composition without further restrictions is not satisfactory with respect to compositionality. We start by adapting the construction of Gaifman and Shapiro (1989) to the case of disjunctive programs.", "startOffset": 23, "endOffset": 451}, {"referenceID": 13, "context": "The first three of the conditions above are due to Gaifman and Shapiro (1989) and they imply that the sets O1, H1, O2, and H1 are mutually pairwise distinct.", "startOffset": 51, "endOffset": 78}, {"referenceID": 22, "context": "As observed by Oikarinen and Janhunen (2008a), the heads of choice rules possessing multiple atoms can be freely split without affecting their semantics.", "startOffset": 29, "endOffset": 46}, {"referenceID": 22, "context": "Consequently, the length of \u03a0 in symbols, denoted by \u2016\u03a0\u2016, gives an upper bound for |At(\u03a0)| which is important when one considers the computational cost of translating programs (Janhunen, 2006).", "startOffset": 176, "endOffset": 192}, {"referenceID": 15, "context": "In formal terms, a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is designed to provide a mapping from subsets of I to a set of subsets of O \u222a H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored.", "startOffset": 168, "endOffset": 196}, {"referenceID": 15, "context": "In formal terms, a DLP-function \u03a0 = \u3008R, I,O,H\u3009 is designed to provide a mapping from subsets of I to a set of subsets of O \u222a H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the (syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity, that D spans over a fixed (at most denumerable) signature At(D)8 so that At(\u03a0) \u2286 At(D) holds for each DLP-function \u03a0 \u2208 D. Given DLP-functions \u03a01, \u03a02, and \u03a03 that pairwise respect the input/output interfaces of each other, it holds that \u2022 \u03a01 \u2295\u03a02 \u2208 D (closure), \u2022 \u03a01 \u2295\u2205 = \u2205\u2295\u03a01 = \u03a01, for the empty DLP-function \u2205 = \u3008\u2205, \u2205, \u2205, \u2205\u3009 (identity), \u2022 \u03a01 \u2295\u03a02 = \u03a02 \u2295\u03a01 (commutativity), and \u2022 \u03a01 \u2295 (\u03a02 \u2295\u03a03) = (\u03a01 \u2295\u03a02)\u2295\u03a03 (associativity). The theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more restrictive operator for program composition, viz.", "startOffset": 168, "endOffset": 929}, {"referenceID": 1, "context": "Technically speaking, we define the positive dependency graph DG(\u03a0) of a DLP-function \u03a0 = \u3008R, I,O,H\u3009 using only positive dependencies\u2014following the definition by Ben-Eliyahu and Dechter (1994). However, we exclude input atoms from the graph as their definitions are external to \u03a0 anyway.", "startOffset": 162, "endOffset": 193}, {"referenceID": 32, "context": "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.", "startOffset": 127, "endOffset": 160}, {"referenceID": 39, "context": "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.", "startOffset": 127, "endOffset": 160}, {"referenceID": 18, "context": "In order to cover arbitrary DLP-functions, we interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).", "startOffset": 102, "endOffset": 131}, {"referenceID": 3, "context": ", a DLP-function \u03a0 of the form \u3008R, \u2205, O, \u2205\u3009, can be characterized via classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003).", "startOffset": 134, "endOffset": 147}, {"referenceID": 30, "context": ", Ato(\u03a0) \u222a Ath(\u03a0) = At(\u03a0), the completion Comp(\u03a0) reduces to the definition provided by Lee and Lifschitz (2003) and the same holds for the set LF(\u03a0) of loop formulas.", "startOffset": 88, "endOffset": 113}, {"referenceID": 30, "context": "In turn, we know that Mo \u222aMh |= Comp(\u03a0/Mi)\u222aLF(\u03a0/Mi) iff Mo \u222aMh is a stable model of the program \u03a0/Mi by the results of Lee and Lifschitz (2003); recall that \u03a0/Mi is an ordinary disjunctive program without any input atoms.", "startOffset": 119, "endOffset": 144}, {"referenceID": 3, "context": "Since each \u201cordinary\u201d program can be represented as a DLP-function, we thus properly generalize the well-known completion semantics (Clark, 1978).", "startOffset": 132, "endOffset": 145}, {"referenceID": 30, "context": "Then, the notion of Ati(\u03a0)tightness coincides with ordinary tightness, and the definition of the completion Comp(\u03a0) reduces to the one provided by Lee and Lifschitz (2003).", "startOffset": 147, "endOffset": 172}, {"referenceID": 32, "context": "3 to a comparison with the splitting set theorem proven by Lifschitz and Turner (1994).", "startOffset": 59, "endOffset": 87}, {"referenceID": 31, "context": "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques.", "startOffset": 48, "endOffset": 68}, {"referenceID": 31, "context": "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplified encoding provided by Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:", "startOffset": 48, "endOffset": 287}, {"referenceID": 22, "context": "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)\u2014enabling a concise representation of minimal diagnoses in the sense of Reiter (1987).", "startOffset": 30, "endOffset": 47}, {"referenceID": 22, "context": "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)\u2014enabling a concise representation of minimal diagnoses in the sense of Reiter (1987). The resulting disjunctive rules involve head-cycles (see Section 7 for details) which typically pre-empt a polynomial-time translation into a computationally easier normal logic program.", "startOffset": 30, "endOffset": 287}, {"referenceID": 22, "context": "The design of \u03a0sat n and \u03a0 unsat n is based on the explanatory approach from Janhunen et al. (2006), where (19) is equivalently viewed as a formula \u2203X\u00ac\u2203Y \u00ac\u03c6 having the matrix \u00ac\u03c6 in conjunctive normal form (CNF).", "startOffset": 77, "endOffset": 100}, {"referenceID": 22, "context": "Concerning the correctness of the representation given in Figure 2, due to an existing proof by Janhunen et al. (2006), we only present the main steps\u2014fully exploiting the benefits from our modular approach.", "startOffset": 96, "endOffset": 119}, {"referenceID": 32, "context": "According to Lifschitz and Turner (1994), a solution to R with respect to U \u2286 O is a pair \u3008X,Y \u3009 where X \u2286 U , Y \u2286 O\\U , X \u2208 SM(bU (R)), and Y \u2208 SM(tU (R)/X).", "startOffset": 13, "endOffset": 41}, {"referenceID": 22, "context": "As previously demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like \u03a0 = \u3008{a \u2190 \u223cb; b \u2190 \u223ca}, \u2205, {a, b}, \u2205\u3009 only in the trivial way, i.", "startOffset": 44, "endOffset": 61}, {"referenceID": 20, "context": "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.", "startOffset": 62, "endOffset": 102}, {"referenceID": 4, "context": "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.", "startOffset": 62, "endOffset": 102}, {"referenceID": 7, "context": "As shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary equivalence, i.", "startOffset": 12, "endOffset": 32}, {"referenceID": 22, "context": "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006).", "startOffset": 217, "endOffset": 233}, {"referenceID": 22, "context": "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logic program modules\u2014giving rise to the notion of modular equivalence for logic programs.", "startOffset": 218, "endOffset": 266}, {"referenceID": 22, "context": "2 Verifying Modular Equivalence Oikarinen and Janhunen (2004) proposed a translation-based method for the verification of weak equivalence of disjunctive logic programs.", "startOffset": 46, "endOffset": 62}, {"referenceID": 22, "context": "The idea behind the translation-based method of Oikarinen and Janhunen (2004) is that ordinary disjunctive programs R1 and R2 are weakly equivalent iff their translations TR(R1, R2) and TR(R2, R1) have no stable models.", "startOffset": 62, "endOffset": 78}, {"referenceID": 22, "context": "The translation TR(\u03a02) for the minimality check essentially contains the same rules as TR(R1, R2) \\ R1, where TR(R1, R2) is the translation defined by Oikarinen and Janhunen (2004) for sets R1 and R2 of disjunctive rules.", "startOffset": 165, "endOffset": 181}, {"referenceID": 7, "context": "Related Work Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases.", "startOffset": 13, "endOffset": 34}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated.", "startOffset": 50, "endOffset": 71}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey.", "startOffset": 50, "endOffset": 664}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion.", "startOffset": 50, "endOffset": 1149}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations.", "startOffset": 50, "endOffset": 2220}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion.", "startOffset": 50, "endOffset": 2976}, {"referenceID": 7, "context": "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by \u2294. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category\u2014the join \u2294 being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(\u00b7, \u00b7): tclo(x, y) \u2190 rel(x, y); tclo(x, y) \u2190 tclo(x, z), rel(z, y). Here, tclo(\u00b7, \u00b7) acts as the output predicate of the module tclo[rel] whereas rel(\u00b7, \u00b7) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(\u00b7, \u00b7) above. Consider, for instance, the rule loop(x) \u2190 tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(\u00b7, \u00b7). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 \u2264 x, y \u2264 n} and On = {tclo(x, y) | 1 \u2264 x, y \u2264 n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion. The outcome determines the meaning of the modular description via an embedding into ASP (Lifschitz & Turner, 1999). Faber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog programs with negation.", "startOffset": 50, "endOffset": 3220}, {"referenceID": 12, "context": "Hence, the module theorem provided by Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore, observations presented in Section 5.", "startOffset": 38, "endOffset": 58}, {"referenceID": 12, "context": "The module theorem is important as it provides a compositional semantics for disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007).", "startOffset": 217, "endOffset": 237}], "year": 2009, "abstractText": "Practically all programming languages allow the programmer to split a program into several modules which brings along several advantages in software development. In this paper, we are interested in the area of answer-set programming where fully declarative and nonmonotonic languages are applied. In this context, obtaining a modular structure for programs is by no means straightforward since the output of an entire program cannot in general be composed from the output of its components. To better understand the effects of disjunctive information on modularity we restrict the scope of analysis to the case of disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion of a DLP-function, where a well-defined input/output interface is provided, and establish a novel module theorem which indicates the compositionality of stable-model semantics for DLP-functions. The module theorem extends the well-known splitting-set theorem and enables the decomposition of DLP-functions given their strongly connected components based on positive dependencies induced by rules. In this setting, it is also possible to split shared disjunctive rules among components using a generalized shifting technique. The concept of modular equivalence is introduced for the mutual comparison of DLP-functions using a generalization of a translation-based verification method.", "creator": "dvips(k) 5.96 Copyright 2005 Radical Eye Software"}}}