{"id": "1401.3486", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "The Role of Macros in Tractable Planning", "abstract": "This paper presents several new tractability results for planning based on macros. We describe an algorithm that optimally solves planning problems in a class that we call inverted tree reducible, and is provably tractable for several subclasses of this class. By using macros to store partial plans that recur frequently in the solution, the algorithm is polynomial in time and space even for exponentially long plans. We generalize the inverted tree reducible class in several ways and describe modifications of the algorithm to deal with these new classes. Theoretical results are validated in experiments.", "histories": [["v1", "Wed, 15 Jan 2014 05:37:49 GMT  (598kb)", "http://arxiv.org/abs/1401.3486v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["anders jonsson"], "accepted": false, "id": "1401.3486"}, "pdf": {"name": "1401.3486.pdf", "metadata": {"source": "CRF", "title": "The Role of Macros in Tractable Planning", "authors": ["Anders Jonsson"], "emails": ["anders.jonsson@upf.edu"], "sections": [{"heading": "1. Introduction", "text": "This year it is more than ever before."}, {"heading": "2. Notation", "text": "It is about the question to what extent it is about a way, in which it is about the question, to what extent it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, and in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way and in which it is about a way, in which it is about a way and in which it is about a way, in which it is about a way in which it is about a way and in which it is about a way and in which it is about a way and in which it is about a way, in which it is about which it is about a way and in which it is about which it is about a way and in which it is about which it is about a way and in which it is about which it is about a way and in which it is about which it is about which it is about a way and which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is not only about which it is about which it is about which it is not only about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which is about which"}, {"heading": "3. The Class IR", "text": "In fact, it is so that it is a matter of a manner and manner in which it is about the question, to what extent it is about a problem that is about itself in the manner and manner in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it has arisen, in the way in which it is in the manner and manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned, and in the manner in which it is concerned, in the manner in which it is concerned, in the manner in which it is concerned with itself, in the manner in which it is concerned with itself, in the manner in which it is concerned with itself, in the manner in which it is concerned with itself, in the manner and in the manner in which it is concerned with itself, in the manner in which it is concerned with itself, in the manner in the manner in which it is concerned with itself, and in the manner in the manner in which it is concerned with itself, and in the manner in the manner in which it is concerned with itself, in the manner in the manner in which it is concerned with itself and in the manner in the manner in which it is concerned with itself, in the manner in the manner in which it is concerned with itself and in the manner in the manner in the manner in which it is concerned with itself and in the manner in the manner in the manner in which it is concerned with itself and in the manner in the manner in the manner in the manner in which it has arisen and in the manner in the manner in the manner in which it has arisen and in the manner in the manner in the manner in which it has arisen and in the manner in the manner in the manner in which it has arisen"}, {"heading": "3.1 Plan Generation for IR", "text": "In this section, we present a plan creation algorithm for class IR, called MacroPlanner. For each planning problem P-IR, MacroPlanner generates one or more plans, which solve P in the form of macros. The algorithm uses a divide-and-conquer strategy to define and solve several partial problems for each variable v-V of the problem. Subsequently, it stores the solutions for each partial problem as macros and integrates these macros into the action sets of higher partial problems. Algorithm 1 MacroPlanner (P) 1: G \u2190 causal graph of P 2: R \u2190 transitive reduction of G 3: v \u2190 root variable of R 4: M \u2190 GetMacros (v, init, A, R) 5: return M or \"fail\" if M = The main routine of MacroPlanner appears in algorithm 1. MacroPlanner takes a planning problem P-IR as input and constructs the calculation graph of MacroPlanner, not identifying the reduction of Macrotransitions."}, {"heading": "3.1.1 Defining Subproblems", "text": "This section describes the subroutine GetMacros that may be required for each variable v-v project. < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "3.1.2 Solving the Subproblems", "text": "In this section we describe the subroutine solution, which solves the partial problems defined by GetMacros. < Q > Q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q"}, {"heading": "3.2 Examples", "text": "In fact, it is so that it will be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be able to be to be able to be to be to be able to be able to be able to be able to be able to be to be able to be able to be to be to be able to be to be able to be to be to be to be to be able to be to be to be to be able to be to be to be to be able to be to be to be to be to be to be to be able to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be able to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be able to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be to be"}, {"heading": "3.3 Theoretical Properties", "text": "The first two theorems refer to the correctness and optimisation of the MacroPlanner. The reasons of the individual action strands in the individual countries are different in each case. The reasons of the individual MacroPlanner. The reasons of the individual action strands of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual action strands of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The reasons of the individual MacroPlanner. The individual reasons of the individual actions of the individual action strands of the individual action strands."}, {"heading": "3.4 Pruning", "text": "To improve runtime, it is possible to prune some states before they are visited. Specifically, let (p, seq) be a state-sequence pair visited during a call to the solution (v, s, Z, O, G). For each state-sequence pair (t, seq2) previously visited during the same call, so that t (v) = p (v), try to reach p from t using Compose (v, t, p, O, G). Since p is a fully specified state, composing (v, p, O, G) returns to at most one action sequence. Call it seq3. If p is reachable from t and < seq2, seq3 > is at least as short as seq, there is no need to visit p, since any state reachable via p is also reachable via p."}, {"heading": "4.1 Relaxed Causal Graph", "text": "& & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & &"}, {"heading": "4.1.2 Algorithm", "text": "V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-V-"}, {"heading": "4.1.3 Theoretical Properties", "text": "Theorem 4.3. For each planning problem P-RIR, each macro m-M returned by RelaxedPlanner (P) is well defined and solves P algorithm 6 RelaxedMacros (v, init, A, G) Theorem 4.4. For each planning problem P-RIR, RelaxedPlanner returns an optimal plan for P, otherwise \"fail.\" The proofs of theorems 4.3 and 4.4 are simple adjustments of the corresponding proofs for MacroPlanner and appear in Appendix D."}, {"heading": "4.2 Acyclic Causal Graph", "text": "In this section, we introduce a second extension of MacroPlanner, this time to the class of planning problems with acyclic causal diagrams. In other words, variables in the causal diagram can have unlimited dimensions, even when considering the transitive reduction. Cross-border problems present a challenge to the approach of macro compilation, as illustrated in the following example. If we consider a planning problem P with V = {v1, v2, v3 = 1), and A (v2) contains the following actions: a11 = < v1 = 0; v1 = < v3 (v1) = D (v3), 1 (v3), 1 (v2), v2 (v3), v2 (v2), v2, v2 (v2), (v2, v3, v3, v3 (v3), v3 (v3), v3 (v3, v3, v3, v3, v3, v2 (), (v2, v2, v3, v3, v3, v3, v3), (v3, v3, v3 (v2)."}, {"heading": "4.2.1 Definition of the Class AR", "text": "In order to extend MacroPlanner to planning problems with acyclic causal diagrams, we impose an additional constraint on planning problems. For each state variable v \u0394V with an outdegree greater than 1 in the causal diagram, we require v to be reversible. Definition 4.5. A state variable v \u0394V is reversible if and only if the projected initial state init | Vv of s.Definition 4.6 is attainable for each state s for Vv that is attainable from the projected initial state init | Vv. A planning problem P belongs to class AR if the causal diagram of P is acyclic and each variable is reversible."}, {"heading": "4.2.2 Algorithm", "text": "In this section we show how to modify the MacroPlanner algorithm so that it solves the planning problems in AR. < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "4.2.3 Theoretical Properties", "text": "Theorem 4.7. For each planning problem P-AR, if the sequence seq of ReversiblePlanner (P) differs from \"fail,\" seq is well defined for init and (init-post (seq))) fulfils the goal. Theorem 4.8. For each planning problem P-AR with simple measures, if P is solvable, ReversiblePlanner (P) returns a sequence seq to the solution of P, otherwise it returns \"fail.\" Theorem 4.9. For each planning problem P-AR, the complexity of ReversiblePlanner O (Dk-A-A-V-V), where D = maxv-V-D (v) and k = maxv-V-W |. The proofs of theorems 4.7, 4.8 and 4.9 appear in Appendix E. The proofs of theorems 4.7 and 4.8 are similar to those of Macroversible Planners, and show by existing ones that the situation is not variable."}, {"heading": "4.3 The Class AOR", "text": "We can now combine the two results for classes IR and AR. The idea is to use the original algorithm to fully generate macros for each variable v, as long as the outdegree of v in the transitive reduction of the causal graph is less than or equal to 1. If we come across a variable v whose outdegree is greater than 1, we switch to the algorithm for reversible variables from the previous section. In this way, we can handle causal cyclic graphs, even if some variables are not reversible. We call the resulting class AOR.4.3.1 Definition of the class AORDefinition 4.10. A planning problem P belongs to the class AOR, if the causal graph of P is acyclic and each variable of V with output > 1 in the transitive reduction of the causal graph is reversible. The planning problem P belongs to the class AOR, since the causal graph of P is not reversible with output 2."}, {"heading": "4.3.2 Algorithm", "text": "In this section we describe AcyclicPlanner, which combines ideas from MacroPlanner and ReversiblePlanner to solve planning problems in the class AOR. < < < < < < < / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /"}, {"heading": "4.3.3 Theoretical Properties", "text": "For each planning problem P-AOR with unforeseen measures, if there is a plan to solve the problem, < / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /"}, {"heading": "4.4 Examples", "text": "In this section we give examples of planning problems in AR and AOR and describe how ReversiblePlanner and AcyclicPlanner solve them."}, {"heading": "4.4.1 Gripper", "text": "Our first example is the well-known Gripper domain, in which a robot has to transport balls between two rooms. < b = > b = relaxed planning problem Pn is defined by the number n of balls that the robot has to transport. < b = relaxed problem Pn is defined by the number n of balls that the robot has to transport. The set of variables is V = {vl, vh, v1, 2}, and D (vi) = {0, 1, R} for each 1 \u2264 i,. The initial state is init = (vl = 0, vh = 0, v1 = 0) and the target state is target = (v1 = 1, R} for each 1 \u2264 i. The initial state is init = (vl = 0, v1 = 0). The two rooms are denoted 0 and 1. Variable vl represents the position of the robot, i.e. variable vh represents the number of balls currently held by the robot."}, {"heading": "4.4.2 Logistics", "text": "The second example is the logistics domain where a number of packets must be moved to their final location. < p > p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p = p p"}, {"heading": "5. Experimental Results", "text": "To test our algorithm, we conducted experiments in two areas: the Tower of Hanoi and an enhanced version of Gripper. The results of the experiments in the Tower of Hanoi appear in Table 1. We varied the number of discs in steps of 10 and recorded the runtime of MacroPlanner. The table also shows the number of macros generated by our algorithm and how many were used to represent the resulting global plan. For example, 27 of 82 generated macros formed part of the solution for Tower of Hanoi with 10 discs. For the second set of experiments, we modified the version of Gripper from the previous section. Instead of two rooms, the environment consists of a labyrinth with 967 rooms. To transport balls, the robot has to navigate through the labyrinth from the starting point to the target location. The robot can only pick up and drop the balls at the starting and finishing points."}, {"heading": "6. Related Work", "text": "For easier presentation, we group related work into three general categories: complexity outcomes, macro-based planning and factor planning. Each of the following subsections presents related work in one of these categories."}, {"heading": "6.1 Complexity Results", "text": "Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994) that models the degree of dependence between problem variables. However, several researchers have investigated tractable subclasses of planning problems that can be proven to be solved in polynomial time. Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994) that models the degree of dependence between problem variables."}, {"heading": "6.2 Macro-Based Planning", "text": "It is also worth mentioning the relationship with other macro-based algorithms for planning: macros have long been used in planning, starting with the advent of STRIPS representation (Fikes & Nilsson, 1971) Minton (1985) and Korf (1987) developed the idea further, the latter showing that macros can reduce the search space exponentially if carefully selected. (Knoblock, 1994) developed an abstraction technique similar to that of macros, where the problem is dealt with at various levels of abstraction until it is completely solved. Vidal (2004) extracted macros from relaxed plans used to generate heuristics. Methods such as Macro-FF (Botea, Enzenberger, Mu M\u00fcller, & Schaeffer, 2005) automatically generate macros that are experimentally useful for the search that have proved competitive in the Fourth International Planning Competition."}, {"heading": "6.3 Factored Planning", "text": "Another related field of work is factor planning, which attempts to break down a planning problem into one or more subdomains. Typically, a planning problem is incorporated into several subdomains organized into a tree structure. Each variable and action of the problem belongs to one of the subdomains. Amir and Engelhardt (2003) introduced an algorithm called PartPlan, which solves planning problems for which there is already a tree decomposition. The algorithm is exponential in the maximum number of actions and variables of a subdomain. Brafman and Domshlak (2006) introduced an algorithm called LID-GF, which decomposes planning problems based on the causal diagram. LID-GF is polynomic for planning problems with fixed local depth and causal graphs of fixed tree width. The local depth of a variable is defined as the number of times the value of the variable will change due to a tree decomposition, the problem must be solved by a fixed tree type of interest."}, {"heading": "7. Conclusion", "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "Acknowledgments", "text": "This work was partly funded by APIDIS and MEC funding TIN2006-15387-C03-03."}, {"heading": "Appendix A. Proof of Theorem 3.2", "text": "In this appendix, we prove that it is a macro for a parent. (...) In this appendix, we prove that every macro is a macro for a parent. (...) In this appendix, we prove that every macro is a macro for a parent. (...) In this appendix, we prove that every macro is a macro for a parent. (...) In this appendix, we prove that every macro is a macro for a parent. (...) In this appendix, we prove that every macro is a macro for the parent. (...) In this appendix appendix, every macro is a macro for one. (...) In this appendix appendix, every macro is a macro for one. (...) In this appendix appendix appendix, every macro is a macro."}, {"heading": "Appendix B. Proof of Theorem 3.3", "text": "In this appendix, we prove Theorem 3.3, which states that MacroPlanner (P) provides an optimal solution for P-IR if and only if there is one. First, we prove a series of lemmas stating that the macros of Solve provide the shortest solutions to the corresponding subproblems.Definition B.1. For each v-V and each pair of states (s, t) for each v-V-V, let s-Z that there is a sequence of actions in Av = a. A: Vpost (a) Vv} that, when applied in state s, results in state t.Lemma B.2. For each v-V-V, let (p, seq) is a sequence of actions that occur during a call to Solve (v, s, Z, Z, O, G). Then for each w-Pa (v), GetMacros (w, init, A, G) previously solve (p, Z), O-Z, G-Z, W-Z, and W-Z values."}, {"heading": "Appendix C. Proof of Theorems 3.5 and 3.6", "text": "In this section, we will prove theorems 3.5 and 3.6, which establish two subclasses of class IR for which MacroPlanner generates solutions in polynomial time. To prove theorem 3.5, we note that for each variable condition V and each action a with v Vpost (a), it is valid that Vpre (a) = Vv (a) = Vv (v) = Vz (c) for each projected condition Z (z) = d) is the set of projected preconditions that specifies the value d for v. Each state in the domain transition curve that specifies the value d for v must correspond either to the precondition of an action in Adv or to a projected precondition in Zdv. Otherwise, the corresponding node would not be added to the graph by the algorithm. The only exception is the projected precondition init (v)."}, {"heading": "Appendix D. Proof of Theorems 4.3 and 4.4", "text": "In this appendix, we first show that Definition B.1 and Lemma B.2 apply to RelaxedPlanner. The term accessibility in Definition B.1 refers to a set of measures such as Vpost (a) Vv, which excludes actions that change the value of a successor of v.Lemma B.2. If (p, seq) is a state pair visited during a conversation with Solve (v, s, Z, O, G), and w Pa (v) is a parent of v in G, GetMacros (w, init, A, G), which was previously called Solve (w, p | Vw, O, G), where Z \u00b2 and O \u00b2 values of Z \u00b2 and O \u00b2 values of RelaxedMacro.m also apply to RelaxedMacro.s, where the reduction of Vaxal V2 is transferred to the original vaxal line."}, {"heading": "Appendix E. Proofs of Theorems 4.7, 4.8, and 4.9", "text": "In this appendix we prove that the sequence seq (P) -1 (P) -1 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (P) -2 (S) -2) -2 (P) -2 (S) -2 (P) -2)."}], "references": [{"title": "Factored Planning", "author": ["E. Amir", "B. Engelhardt"], "venue": "In Proceedings of the 18th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Amir and Engelhardt,? \\Q2003\\E", "shortCiteRegEx": "Amir and Engelhardt", "year": 2003}, {"title": "Macro-FF: Improving AI Planning with Automatically Learned Macro-Operators", "author": ["A. Botea", "M. Enzenberger", "M. M\u00fcller", "J. Schaeffer"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Botea et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Botea et al\\.", "year": 2005}, {"title": "Fast Planning with Iterative Macros", "author": ["A. Botea", "M. Muller", "J. Schaeffer"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Botea et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Botea et al\\.", "year": 2007}, {"title": "Structure and Complexity in Planning with Unary Operators", "author": ["R. Brafman", "C. Domshlak"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Brafman and Domshlak,? \\Q2003\\E", "shortCiteRegEx": "Brafman and Domshlak", "year": 2003}, {"title": "Factored Planning: How, When, and When Not", "author": ["R. Brafman", "C. Domshlak"], "venue": "In Proceedings of the 21st National Conference on Artificial Intelligence", "citeRegEx": "Brafman and Domshlak,? \\Q2006\\E", "shortCiteRegEx": "Brafman and Domshlak", "year": 2006}, {"title": "The computational complexity of propositional STRIPS planning", "author": ["T. Bylander"], "venue": "Artificial Intelligence,", "citeRegEx": "Bylander,? \\Q1994\\E", "shortCiteRegEx": "Bylander", "year": 1994}, {"title": "Planning for conjunctive goals", "author": ["D. Chapman"], "venue": "Artificial Intelligence,", "citeRegEx": "Chapman,? \\Q1987\\E", "shortCiteRegEx": "Chapman", "year": 1987}, {"title": "Act Local, Think Global: Width Notions for Tractable Planning", "author": ["H. Chen", "O. Gim\u00e9nez"], "venue": "In Proceedings of the 17th International Conference on Automated Planning and Scheduling", "citeRegEx": "Chen and Gim\u00e9nez,? \\Q2007\\E", "shortCiteRegEx": "Chen and Gim\u00e9nez", "year": 2007}, {"title": "Causal Graphs and Structurally Restricted Planning", "author": ["H. Chen", "O. Gim\u00e9nez"], "venue": "In Proceedings of the 18th International Conference on Automated Planning and Scheduling", "citeRegEx": "Chen and Gim\u00e9nez,? \\Q2008\\E", "shortCiteRegEx": "Chen and Gim\u00e9nez", "year": 2008}, {"title": "Multi-Agent Off-line Coordination: Structure and Complexity", "author": ["C. Domshlak", "Y. Dinitz"], "venue": "In Proceedings of the 6th European Conference on Planning,", "citeRegEx": "Domshlak and Dinitz,? \\Q2001\\E", "shortCiteRegEx": "Domshlak and Dinitz", "year": 2001}, {"title": "Complexity, decidability and undecidability results for domain-independent planning", "author": ["K. Erol", "D. Nau", "V. Subrahmanian"], "venue": "Artificial Intelligence,", "citeRegEx": "Erol et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Erol et al\\.", "year": 1995}, {"title": "STRIPS: A new approach to the application of theorem proving to problem solving", "author": ["R. Fikes", "N. Nilsson"], "venue": "Artificial Intelligence,", "citeRegEx": "Fikes and Nilsson,? \\Q1971\\E", "shortCiteRegEx": "Fikes and Nilsson", "year": 1971}, {"title": "The Complexity of Planning Problems with Simple Causal Graphs", "author": ["O. Gim\u00e9nez", "A. Jonsson"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Gim\u00e9nez and Jonsson,? \\Q2008\\E", "shortCiteRegEx": "Gim\u00e9nez and Jonsson", "year": 2008}, {"title": "Planning over Chain Causal Graphs for Variables with Domains of Size 5 Is NP-Hard", "author": ["O. Gim\u00e9nez", "A. Jonsson"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Gim\u00e9nez and Jonsson,? \\Q2009\\E", "shortCiteRegEx": "Gim\u00e9nez and Jonsson", "year": 2009}, {"title": "A New Approach To Tractable Planning", "author": ["P. Haslum"], "venue": "In Proceedings of the 18th International Conference on Automated Planning and Scheduling", "citeRegEx": "Haslum,? \\Q2008\\E", "shortCiteRegEx": "Haslum", "year": 2008}, {"title": "The Fast Downward Planning System", "author": ["M. Helmert"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Helmert,? \\Q2006\\E", "shortCiteRegEx": "Helmert", "year": 2006}, {"title": "The Role of Macros in Tractable Planning Over Causal Graphs", "author": ["A. Jonsson"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Jonsson,? \\Q2007\\E", "shortCiteRegEx": "Jonsson", "year": 2007}, {"title": "State-variable planning under structural restrictions: Algorithms and complexity", "author": ["P. Jonsson", "C. B\u00e4ckstr\u00f6m"], "venue": "Artificial Intelligence,", "citeRegEx": "Jonsson and B\u00e4ckstr\u00f6m,? \\Q1998\\E", "shortCiteRegEx": "Jonsson and B\u00e4ckstr\u00f6m", "year": 1998}, {"title": "Tractable plan existence does not imply tractable plan generation", "author": ["P. Jonsson", "C. B\u00e4ckstr\u00f6m"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Jonsson and B\u00e4ckstr\u00f6m,? \\Q1998\\E", "shortCiteRegEx": "Jonsson and B\u00e4ckstr\u00f6m", "year": 1998}, {"title": "New Islands of Tractability of Cost-Optimal Planning", "author": ["M. Katz", "C. Domshlak"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Katz and Domshlak,? \\Q2008\\E", "shortCiteRegEx": "Katz and Domshlak", "year": 2008}, {"title": "Structural Patterns Heuristics via Fork Decompositions", "author": ["M. Katz", "C. Domshlak"], "venue": "In Proceedings of the 18th International Conference on Automated Planning and Scheduling,", "citeRegEx": "Katz and Domshlak,? \\Q2008\\E", "shortCiteRegEx": "Katz and Domshlak", "year": 2008}, {"title": "Factored Planning Using Decomposition Trees", "author": ["E. Kelareva", "O. Buffet", "J. Huang", "S. Thi\u00e9baux"], "venue": "In Proceedings of the 20th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Kelareva et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kelareva et al\\.", "year": 2007}, {"title": "Automatically generating abstractions for planning", "author": ["C. Knoblock"], "venue": "Artificial Intelligence,", "citeRegEx": "Knoblock,? \\Q1994\\E", "shortCiteRegEx": "Knoblock", "year": 1994}, {"title": "Planning as search: A quantitative approach", "author": ["R. Korf"], "venue": "Artificial Intelligence,", "citeRegEx": "Korf,? \\Q1987\\E", "shortCiteRegEx": "Korf", "year": 1987}, {"title": "Selectively generalizing plans for problem-solving", "author": ["S. Minton"], "venue": "In Proceedings of the 9th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Minton,? \\Q1985\\E", "shortCiteRegEx": "Minton", "year": 1985}, {"title": "Learning Macro-Actions for Arbitrary Planners and Domains", "author": ["M. Newton", "J. Levine", "M. Fox", "D. Long"], "venue": "In Proceedings of the 17th International Conference on Automated Planning and Scheduling,", "citeRegEx": "Newton et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Newton et al\\.", "year": 2007}, {"title": "A Lookahead Strategy for Heuristic Search Planning", "author": ["V. Vidal"], "venue": "In Proceedings of the 14th International Conference on Automated Planning and Scheduling,", "citeRegEx": "Vidal,? \\Q2004\\E", "shortCiteRegEx": "Vidal", "year": 2004}, {"title": "A reactive planner for a model-based executive", "author": ["B. Williams", "P. Nayak"], "venue": "In Proceedings of the 15th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Williams and Nayak,? \\Q1997\\E", "shortCiteRegEx": "Williams and Nayak", "year": 1997}], "referenceMentions": [{"referenceID": 16, "context": "The class IR and the algorithm for solving instances of the class previously appeared in a conference paper (Jonsson, 2007).", "startOffset": 108, "endOffset": 123}, {"referenceID": 15, "context": "In fact, this is the strategy used by Helmert (2006) to compute the causal graph heuristic.", "startOffset": 38, "endOffset": 53}, {"referenceID": 16, "context": "Our second example is a planning domain first suggested by Jonsson and B\u00e4ckstr\u00f6m (1998b). Again, we use Pn to denote the instance containing n variables v1, .", "startOffset": 59, "endOffset": 89}, {"referenceID": 16, "context": "Jonsson and B\u00e4ckstr\u00f6m (1998b) showed that an optimal plan for Pn has length 2 n \u2212 1.", "startOffset": 0, "endOffset": 30}, {"referenceID": 15, "context": "5 are Tower of Hanoi and the domain suggested by Jonsson and B\u00e4ckstr\u00f6m (1998b), both from the previous example section.", "startOffset": 49, "endOffset": 79}, {"referenceID": 9, "context": "6 is a domain proposed by Domshlak and Dinitz (2001). The set of variables is V = {v1, .", "startOffset": 26, "endOffset": 53}, {"referenceID": 9, "context": "Domshlak and Dinitz (2001) showed that the length of an optimal plan solving the planning problem is 2n+1 \u2212 2.", "startOffset": 0, "endOffset": 27}, {"referenceID": 6, "context": "If the STRIPS formalism is used, deciding whether a solution exists is undecidable in the first-order case (Chapman, 1987) and PSPACEcomplete in the propositional case (Bylander, 1994).", "startOffset": 107, "endOffset": 122}, {"referenceID": 5, "context": "If the STRIPS formalism is used, deciding whether a solution exists is undecidable in the first-order case (Chapman, 1987) and PSPACEcomplete in the propositional case (Bylander, 1994).", "startOffset": 168, "endOffset": 184}, {"referenceID": 22, "context": "Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994), which models the degree of independency between the problem variables.", "startOffset": 67, "endOffset": 83}, {"referenceID": 5, "context": "If the STRIPS formalism is used, deciding whether a solution exists is undecidable in the first-order case (Chapman, 1987) and PSPACEcomplete in the propositional case (Bylander, 1994). For PDDL, the representation language used at the International Planning Competition, the fragment including delete lists is EXPSPACE-complete (Erol, Nau, & Subrahmanian, 1995). Recently, several researchers have studied tractable subclasses of planning problems that can be provably solved in polynomial time. Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994), which models the degree of independency between the problem variables. However, Chen and Gim\u00e9nez (2008a) showed that any connected causal graph causes the problem to be hard (unless established assumptions such as P = NP fail), so additional restrictions on the problem are necessary.", "startOffset": 169, "endOffset": 687}, {"referenceID": 5, "context": "If the STRIPS formalism is used, deciding whether a solution exists is undecidable in the first-order case (Chapman, 1987) and PSPACEcomplete in the propositional case (Bylander, 1994). For PDDL, the representation language used at the International Planning Competition, the fragment including delete lists is EXPSPACE-complete (Erol, Nau, & Subrahmanian, 1995). Recently, several researchers have studied tractable subclasses of planning problems that can be provably solved in polynomial time. Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994), which models the degree of independency between the problem variables. However, Chen and Gim\u00e9nez (2008a) showed that any connected causal graph causes the problem to be hard (unless established assumptions such as P = NP fail), so additional restrictions on the problem are necessary. A common restriction is that the variables of the problem are binary. Jonsson and B\u00e4ckstr\u00f6m (1998a) defined the class 3S of planning problems with acyclic causal graphs and binary variables.", "startOffset": 169, "endOffset": 967}, {"referenceID": 5, "context": "If the STRIPS formalism is used, deciding whether a solution exists is undecidable in the first-order case (Chapman, 1987) and PSPACEcomplete in the propositional case (Bylander, 1994). For PDDL, the representation language used at the International Planning Competition, the fragment including delete lists is EXPSPACE-complete (Erol, Nau, & Subrahmanian, 1995). Recently, several researchers have studied tractable subclasses of planning problems that can be provably solved in polynomial time. Most of these subclasses are based on the notion of a causal graph (Knoblock, 1994), which models the degree of independency between the problem variables. However, Chen and Gim\u00e9nez (2008a) showed that any connected causal graph causes the problem to be hard (unless established assumptions such as P = NP fail), so additional restrictions on the problem are necessary. A common restriction is that the variables of the problem are binary. Jonsson and B\u00e4ckstr\u00f6m (1998a) defined the class 3S of planning problems with acyclic causal graphs and binary variables. In addition, variables are either static, symmetrically reversible, or splitting. The authors showed that it is possible to determine in polynomial time whether or not a solution exists, although solution plans may be exponentially long. Gim\u00e9nez and Jonsson (2008) designed a macro-based algorithm that solve planning problems in 3S in polynomial time.", "startOffset": 169, "endOffset": 1323}, {"referenceID": 12, "context": "Gim\u00e9nez and Jonsson (2009) extended this result to multi-valued variables with domains of size at most 5.", "startOffset": 0, "endOffset": 27}, {"referenceID": 12, "context": "Gim\u00e9nez and Jonsson (2009) extended this result to multi-valued variables with domains of size at most 5. Katz and Domshlak (2008b) showed that planning problems whose causal graphs are inverted forks are tractable as long as the root variable has a domain of fixed size.", "startOffset": 0, "endOffset": 132}, {"referenceID": 12, "context": "Other tractability results include the work by Haslum (2008), who defined planning problems in terms of graph grammars, and showed that the resulting class is tractable under certain restrictions of the grammar.", "startOffset": 47, "endOffset": 61}, {"referenceID": 7, "context": "Chen and Gim\u00e9nez (2007) defined the width of planning problems and designed an algorithm for solving planning problems whose complexity is exponential in the width.", "startOffset": 0, "endOffset": 24}, {"referenceID": 27, "context": "The idea of using reversible variables is related to the work by Williams and Nayak (1997), who designed a polynomial-time algorithm for solving planning problems with acyclic causal graphs and reversible actions.", "startOffset": 65, "endOffset": 91}, {"referenceID": 10, "context": "We have already mentioned the work by Gim\u00e9nez and Jonsson (2008) for the class 3S.", "startOffset": 38, "endOffset": 65}, {"referenceID": 7, "context": "Also, Chen and Gim\u00e9nez (2008b) presented a polynomial-time algorithm that generates all macros within Hamming distance k of a state, and defined an associated tractable class of planning problems with constant Hamming width.", "startOffset": 6, "endOffset": 31}, {"referenceID": 23, "context": "Minton (1985) and Korf (1987) developed the idea further, the latter showing that macros can exponentially reduce the search space if chosen", "startOffset": 0, "endOffset": 14}, {"referenceID": 23, "context": "Minton (1985) and Korf (1987) developed the idea further, the latter showing that macros can exponentially reduce the search space if chosen", "startOffset": 18, "endOffset": 30}, {"referenceID": 22, "context": "(Knoblock, 1994) developed an abstraction technique similar to that of macros, where the problem is treated at different levels of abstractions until fully solved.", "startOffset": 0, "endOffset": 16}, {"referenceID": 22, "context": "(Knoblock, 1994) developed an abstraction technique similar to that of macros, where the problem is treated at different levels of abstractions until fully solved. Vidal (2004) extracted macros from relaxed plans used to generate heuristics.", "startOffset": 1, "endOffset": 177}, {"referenceID": 0, "context": "Amir and Engelhardt (2003) introduced an algorithm called PartPlan that solves planning problems for which a tree decomposition already exists.", "startOffset": 0, "endOffset": 27}, {"referenceID": 0, "context": "Amir and Engelhardt (2003) introduced an algorithm called PartPlan that solves planning problems for which a tree decomposition already exists. The algorithm is exponential in the maximum number of actions and variables of a subdomain. Brafman and Domshlak (2006) introduced an algorithm called LID-GF which decomposes planning problems based on the causal graph.", "startOffset": 0, "endOffset": 264}, {"referenceID": 0, "context": "Amir and Engelhardt (2003) introduced an algorithm called PartPlan that solves planning problems for which a tree decomposition already exists. The algorithm is exponential in the maximum number of actions and variables of a subdomain. Brafman and Domshlak (2006) introduced an algorithm called LID-GF which decomposes planning problems based on the causal graph. LID-GF is polynomial for planning problems with fixed local depth and causal graphs of fixed tree-width. The local depth of a variable is defined as the number of times that the value of the variable has to change on a plan solving the problem. Interestingly, Tower of Hanoi, which is solved in polynomial time by MacroPlanner, has exponential local depth and a causal graph with unbounded tree-width. Kelareva, Buffet, Huang, and Thi\u00e9baux (2007) proposed an algorithm for factored planning that automatically chooses the order of solving subproblems.", "startOffset": 0, "endOffset": 811}, {"referenceID": 19, "context": "Katz and Domshlak (2008b) suggested projecting planning problems onto known tractable fragments in order to compute heuristics.", "startOffset": 0, "endOffset": 26}], "year": 2009, "abstractText": "This paper presents several new tractability results for planning based on macros. We describe an algorithm that optimally solves planning problems in a class that we call inverted tree reducible, and is provably tractable for several subclasses of this class. By using macros to store partial plans that recur frequently in the solution, the algorithm is polynomial in time and space even for exponentially long plans. We generalize the inverted tree reducible class in several ways and describe modifications of the algorithm to deal with these new classes. Theoretical results are validated in experiments.", "creator": null}}}