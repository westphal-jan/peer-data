{"id": "1401.3846", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Fast Set Bounds Propagation Using a BDD-SAT Hybrid", "abstract": "Binary Decision Diagram (BDD) based set bounds propagation is a powerful approach to solving set-constraint satisfaction problems. However, prior BDD based techniques in- cur the significant overhead of constructing and manipulating graphs during search. We present a set-constraint solver which combines BDD-based set-bounds propagators with the learning abilities of a modern SAT solver. Together with a number of improvements beyond the basic algorithm, this solver is highly competitive with existing propagation based set constraint solvers.", "histories": [["v1", "Thu, 16 Jan 2014 04:56:56 GMT  (577kb)", "http://arxiv.org/abs/1401.3846v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["graeme gange", "peter james stuckey", "vitaly lagoon"], "accepted": false, "id": "1401.3846"}, "pdf": {"name": "1401.3846.pdf", "metadata": {"source": "CRF", "title": "Fast Set Bounds Propagation Using a BDD-SAT Hybrid", "authors": ["Graeme Gange", "Peter J. Stuckey"], "emails": ["ggange@csse.unimelb.edu.au", "pjs@csse.unimelb.edu.au", "lagoon@cadence.com"], "sections": [{"heading": "1. Introduction", "text": "In fact, it is the case that most people who stand up for the rights of people do not have to abide by the rules which they have imposed on themselves, but by the rules which they have imposed on themselves. (...) It is not so that they abide by the rules. (...) It is not so that they abide by the rules. (...) It is not so that they abide by the rules. (...) It is as if they abide by the rules. (...) It is as if they abide by the rules. (...) It is as if they abide by the rules. (...) It is as if they abide by the rules. (...) It is as if they abide by the rules. (...) It is as if they abide by the rules. (...) (...) () (...) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) () () () () () () () () () () ()) () () () ()) () () () ()) () () () () ()) () () () () () () ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (() () () () () (() () () (() (() (() () ((() () (() () () (() () () () () () (((() () (() (() () () (() ((() (() () () (() (() () ((() () () ((("}, {"heading": "2. Propagation-based Solving", "text": "The domain of a variable v is the set D (v). A domain D1 is the set D (v). A domain D1 is stronger than a domain D2, written D1 D2, if D1 (v) D2 (v) for all V-V. A domain D1 is equal to a domain D2, written D1 = D2, if D1 (v) = V2, written V2, set. A domain D2, written D2 = V2, written V2, if D2, written V2, set V2 (v)."}, {"heading": "2.1 Constraints, Propagators and Propagation", "text": "A constraint is a constraint on the allowable values for a set of variables. We will set primitive set constraints such as (membership) k, (equality) u = v, (subset) u, (union) u = v, w, (intersection) u = v, w, (cardinality) u = v, w, (cardinality), k, (upper cardinality constraint) | v, k, (lexicographic order) u < v, where u, v, w variables are set, k is an integer. We can also construct more complicated constraints that are (possibly existentially quantified) conjunctions of primitive set constraints. We define the solutions of a constraint c to be the set of values, k, k is an integer."}, {"heading": "2.2 Set Bounds Consistency", "text": "A domain D (v) (c) (D) (v) (v) (v) b) (c) (4) (4) (4) (4) (4) (4) (4) is the union of the values of v in all solutions of c in D, and the lower limit of D (v) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) {4) (4) {4) (4) {1) (4) (4) (4) (4) (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4, 4, 4, 4, (4), 4, (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4, (4), (4), (4), (4), (4), (4), (4), (4), (4), (4), (4, (4), (4), (4), (4), (4, (4), (4), (4), (4), (4, (4), (4, (4), (4), (4), (4), (4), (4, (4), (4), (4), (4), (4), (4), (4, (4), (4), (4), (4), (4), (4), (4), (4), (4), (4"}, {"heading": "2.3 Boolean Satisfiability (SAT)", "text": "The Davis-Putnam-Logemann-Loveland (DPLL) algorithm (Davis, Logemann, & Loveland, 1962), on which most modern SAT solvers are based, is also a propagation-based approach to solving SAT problems. It combines two phases - search, in which a value is assigned to an indeterminate variable, and propagation (so-called unit propagation). Modern SAT solvers integrate advanced engineering skills to spread constraints very quickly, to determine that no commodity is part of the search that leads to failure, and to automate the search by tracking how often a variable is part of the failure (activity), and to focus the search on variables with high activity. Modern SAT solvers often restart the search by relying on no goods to prevent repeated searching, and to advance the search for a suitable unit."}, {"heading": "3. Binary Decision Diagrams", "text": "A Boolean variable can take the value 0 (false) or 1 (true). We use the following Boolean operations: 0 (conjunction), 0 (disjunction), 0 (negation), 0 (implication), 1 (bi-implication), and 1 (existential quantification). We name the following Boolean operations: 0 (conjunction), 0 (disjunction), 0 (implication), 1 (implication), 1 (bi-implication), and 2 (existential quantification)."}, {"heading": "3.1 Set Propagation using BDDs", "text": "The key step in building up quantity multiplication using BDDs is to recognize that we can represent a finite quantity domain using a BDD."}, {"heading": "3.1.1 Representing domains", "text": "If v is a fixed variable extending to subsets of {1,.., N}, then we can represent v by means of Boolean variables V (v) = {v1,.., vN} B. This formula can be represented by a BDD. We will arrange the variables v1,..., v2, \u00b7, vN. We can represent an evaluation variable v, D (v) as a range to be replaced by a formula: x1, x2, x3, 4 and 4, 4 and 4, 4 and 4, 4 and 4, 4 and 4 and 4, and 4 and 4, and 4 and 4, and 4 and 4, and 4 and 4, and 4 and 4, and 4 and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4 and 4, and 4, and 4, and 4 and 4, and 4, and 4 and 4, and 4, and 4, and 4, and 4 and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4, and 4 and 4 and 4, and 4, and 4, and 4, and 4 and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4, and 4"}, {"heading": "3.1.2 Representing constraints", "text": "Similarly, we can model any set constraint c as BDD B (c) by using the Boolean variable representation V (v) of its set variable v. By carefully arranging the variables in each BDD, we can make small representations of the formulas; the meaningful order of the Boolean variables is defined as follows. In view of the set variables u \u00b2 v \u00b2 w, which are spread over sets of {1,..., N}, we arrange the Boolean variables as u1, v1, w1, v2, v2, v2, v2, v2, vN, vN, wN,.The plot B (c) simply consists of imbalances, solns (c), R (\u03b8).For primitive set constraints (in the pointed order), this size is linear in N. For further details see the work of Hawkins et al. (2005). The BDD-D representation is shown for \u2264 (D) x = N in Figure 2."}, {"heading": "3.1.3 BDD-based Set Bounds Propagation", "text": "We can, more or less by definition, build a fixed boundary propagator, since we have BDDs to represent domains and constraints.??? = B (c) \u0445 val \"vars (c) D (v\") sb (c) (D) (v) = V (v) J\u03c6KWe simply attach the domains to the constraint in order to obtain \u03c6, then extract the fixed variables from the result and then project the relevant portion for each variable v. The fixed boundary propagation can be improved by removing the fixed variables as quickly as possible. The improved definition is given by Hawkins et al. (2004). Overall, the complexity O (| B (c) |) can be made. The updated fixed boundaries can be used to simplify the BDD representing the propagator. Since fixed variables never continue to interact with propagation, they can be projected from B (c), so we can {c), B (JddT) (J.noD):"}, {"heading": "3.2 Tseitin Transformation", "text": "It is possible to convert any Boolean circuit into a pure SAT representation; the method for this is generally attributed to Tseitin (1968). Figure 3 provides pseudo-code for the translation of a BDD that is rooted on a node and returns a pair (Boolean variable, set of clauses).The clauses force the Boolean variable to assume the truth value of the BDD. Like most BDD algorithms, it relies on marking the visited nodes to ensure that each node is visited at most once. It assumes that the array visit [] is at the bottom and the corresponding Boolean variable is stored in the visit [] the first time a node is visited. A more comprehensive discussion of the Tseitin transformation is presented by Ee'n and So \ufffd rensson (2006).The restriction is enforced by fixing the corresponding Boolean variable in the visit []."}, {"heading": "4. Faster Set-bounds Propagation", "text": "This is not necessary as long as we are willing to refrain from simplifying BDDs, which is possible in certain areas. (N): 0 / 3 D [vi]: 0 / 3 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0 / 4 D [vi]: 0, 1). We do not know if i is in v. Hence D (v) or not."}, {"heading": "4.1 Waking up Less Often", "text": "In practice, the propagandist does not blindly apply each propagandist to the fixed point, but tracks which propagandists still need to be at the fixed point and execute only those that cannot be reached. By specified limits, this is usually handled as follows: The bddprop algorithm collects the set of Boolean variables that affect the BDD. (Whenever V changes, these propagandists can change the result.) If a variable that does not become matter is not fixed, then propagation cannot learn new information. Each propagandist stores a list of Boolean variables that affect the current domain. If a Boolean variable is not fixed, then it does not fix propagation. (Each propagandist stores a list of the Boolean variables that we can edit in the current domain.) When a Boolean variable is fixed xji, we traverse the list of propagandists that x j and the propagandists are waking up to execute."}, {"heading": "4.2 Dead Subgraph Memoization and Shortcutting", "text": "The algorithm presented above always examines all available parts of the graph to determine the number of supported values. However, a number of improvements to MultiDecision Diagrams (MDDs) have been introduced by Cheng and Yap (2008), which reduce the portion of the graph that needs to be traversed to ensure consistency, such as dead subgraph memorisations that avoid traversing subgraphs that cannot provide support for any values, and shortcuts that detect situations where it is only necessary to find a way to T to ensure consistency, which can be easily adapted to a BDD-based set constraint solver."}, {"heading": "4.2.1 Dead Subgraph Memoization", "text": "In fact, most people are able to feel how they are, to behave, and to be able to play by the rules, \"he said in an interview with The New York Times:\" I believe that the world we live in will not be able to understand the world, but will be able to understand it. \""}, {"heading": "4.2.2 Shortcutting", "text": "In fact, the majority of people who are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to move, to fight, to move, to fight, to move, to fight, to move, to fight, to fight, to fight, to move, to fight, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to move, to move, to move, to move, to move, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move"}, {"heading": "5. Hybrid SAT Solver", "text": "Despite very rapid propagation, however, a pure set-bounces-based solver suffers from an inability to analyze the reasons for failure, leading to repeated research into similar dead sub-trees, which limits the solver's performance on many hard problem instances. To address this problem, we construct a hybrid solver that embeds BDD-based set-bounces propagators in an efficient SAT solver. Search and conflict analysis are re-formed in the SAT solver, and the BDD propagators are used to generate conclusions and clauses for the SAT solver during propagation."}, {"heading": "5.1 Efficient Reason Generation", "text": "This year it has come to the point that it has never been able to rock the aforementioned lcihsrcnlrVo until it is able to rock the aforementioned lrVo."}, {"heading": "5.2 Lazy Reason Generation", "text": "The simplest way to use reason generation is a so-called eager generation, where whenever a BDD distributor draws a new conclusion, a minimal reason clause is generated and added to the SAT solver. However, these clauses cannot make a meaningful contribution to the search until a conflict is detected - they cannot spread until the solver goes beyond the specified variable, and no conflict clauses are constructed until there is a conflict. Since there is some extra effort in adding and maintaining a large number of these clauses in the solver, it may be better to delay the construction of these reasons until they are actually needed to explain a conflict. Instead, we can only apply reason generation when the SAT conflict analysis asks for the explanation of a literal set of these clauses by the BDD solver. To do this, we need to determine the state of the distributor that caused the inference."}, {"heading": "5.3 Hybrid Architecture", "text": "The architecture is illustrated in Figure 14. Common SAT motor architecture is shown on the left. BDD propagation is added as shown on the right. Unit propagation causes Boolean letters to be fixed, which may require BDD letters to be woken up. We add any Boolean variable that represents part of a specified variable x to the BDD letter. When the unit propagation reaches a fixed point, the trace of the fixed letters is traversed and each BDD letter is scheduled for execution. If we use filtering, it is only scheduled if the letter is one that depends on the propagation clause. Then, we execute the planned BDD letter with the help of bddp."}, {"heading": "6. Experimental Results", "text": "We have built a hybrid SAT solver that implements the algorithms described above, based on MiniSAT 2.0 (dated 070721) (Ee \u0301 n & So \ufffd rensson, 2003), which has been modified to include the BDD-based propagator. BDDs are constructed using the BuDDy BDD package (http: / / sourceforge.net / projects / buddy /), all BDDs are constructed at the start of execution, then converted into static graphs during propagation. In fact, for many of the minor problems solved in Section 6, most of the solution time for constructing the BDDDD is executed at a lower priority level than the propagator to detect conflicts as early as possible."}, {"heading": "6.1 Social Golfers", "text": "It's not the only question we have to ask ourselves when we go looking. (...) It's not the only question we ask ourselves. (...) It's the first question we ask ourselves. (...) It's the second question we ask ourselves. (...) It's the first question we ask ourselves. (...) The second question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The third question we ask ourselves. (...) The second question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask. (...) The third question we ask."}, {"heading": "6.2 Steiner Systems", "text": "Another common yardstick for fixed delimitation solutions is the calculation of small Steiner systems (t, k, N).A Steiner system S (t, k, N) is a set X of cardinality N and a collection C of subsets of cardinality k (called \"blocks\").We model the Steiner problem similar to Lagoon and Stuckey (2004), extended in the case of more general Steiner systems. We model each block as a fixed variable s1,.. sm, with the constraints: m, i = k).We model the Steiner problem similar to Lagoon and Stuckey (2004) extended in the case of more general Steiner systems. We model each block as a fixed variable s1,.. sm, with the constraints: m, i = k).We model the Steiner problem similar to Lagoon and Stuckey (2004) extended in the case of more general Steiner systems. We model each block as a fixed variable s1,."}, {"heading": "6.3 Fixed-weight Hamming Codes", "text": "The problem of finding maximum hamming codes can also be expressed as a problem with fixed n-codes. A variant of this problem is to find maximum codes where all code words have set exactly w-codes.One formulation for this problem is: m-i = 1 (| si-i = 1). One variation of this problem is to find maximum codes where s-s = (s-s) have set exactly w-codes.One formulation for this problem is: m-i = 1 (| si-i = 1). One variation of this problem is to remove maximum codes where s-s = (s-s). One formulation for this problem is symmetrical difference. This is similar in the structure of the formulation for the steiner systems; but instead of having a fixed number of system codes, we find the maximum code by repeatedly adding new codes model and the corresponding constraints until no solution can be found."}, {"heading": "7. Related Work", "text": "In this context, it should be noted that this is not a purely formal matter, but a purely formal matter, which is a purely formal matter."}, {"heading": "8. Concluding Remarks", "text": "In this paper, we have improved BDD-based techniques for propagation of symmetries by demonstrating an approach that avoids the need for costly BDD constructions and manipulation operations, which, in combination with filtering to reduce the number of redundant constructions of spreaders and dead subgraphs, as well as abbreviations, is at least an order of magnitude faster than previous techniques that construct BDDs during runtime (Hawkins et al., 2005). In addition, when integrated into a modern SAT solver with clauses learning and extended by a method for generating nogoods, the hybrid solver is capable of solving hard problems several orders of magnitude faster than pure bow set solvers. Overall, the hybrid solver is robust and highly competitive with all the other propagation-based set solvers we know of. In many quantity problems, there is a significant number of symmetries, and there is a large pummetry problem solving (see, for example, where there is a large pummetry problem)."}, {"heading": "9. Acknowledgments", "text": "Part of this work has already been published (Gange, Lagoon, & Stuckey, 2008).NICTA is funded by the Australian Government, represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council."}], "references": [{"title": "Constraint Solving over Multi-valued Logics", "author": ["F. Azevedo"], "venue": "Ph.D. thesis, Faculdade de Ci\u00eancias e Tecnologia, Universidade Nova de Lisboa.", "citeRegEx": "Azevedo,? 2002", "shortCiteRegEx": "Azevedo", "year": 2002}, {"title": "Cardinal: A finite sets constraint solver", "author": ["F. Azevedo"], "venue": "Constraints, 12 (1), 93\u2013129.", "citeRegEx": "Azevedo,? 2007", "shortCiteRegEx": "Azevedo", "year": 2007}, {"title": "Graph-based algorithms for Boolean function manipulation", "author": ["R. Bryant"], "venue": "IEEE Trans. Comput., 35 (8), 677\u2013691.", "citeRegEx": "Bryant,? 1986", "shortCiteRegEx": "Bryant", "year": 1986}, {"title": "Maintaining generalized arc consistency on ad hoc r-ary constraints", "author": ["K. Cheng", "R. Yap"], "venue": "In 14th International Conference on Principles and Process of Constraint Programming,", "citeRegEx": "Cheng and Yap,? \\Q2008\\E", "shortCiteRegEx": "Cheng and Yap", "year": 2008}, {"title": "Checking satisfiability of a conjunction of BDDs", "author": ["R. Damiano", "J. Kukula"], "venue": "In Proceedings of Design Automation Conference,", "citeRegEx": "Damiano and Kukula,? \\Q2003\\E", "shortCiteRegEx": "Damiano and Kukula", "year": 2003}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "An extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Proceedings of SAT 2003,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2003\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2003}, {"title": "Translating pseudo-boolean constraints into SAT", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2006\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2006}, {"title": "Fast set bounds propagation using BDDs", "author": ["G. Gange", "V. Lagoon", "P. Stuckey"], "venue": "In 18th European Conference on Artificial Intelligence,", "citeRegEx": "Gange et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gange et al\\.", "year": 2008}, {"title": "Gecode", "author": ["GECODE"], "venue": "www.gecode.org. Accessed Jan 2008.", "citeRegEx": "GECODE,? 2008", "shortCiteRegEx": "GECODE", "year": 2008}, {"title": "Interval propagation to reason about sets: Definition and implementation of a practical language", "author": ["C. Gervet"], "venue": "Constraints, 1 (3), 191\u2013246.", "citeRegEx": "Gervet,? 1997", "shortCiteRegEx": "Gervet", "year": 1997}, {"title": "Length-lex ordering for set CSPs", "author": ["C. Gervet", "P. Van Hentenryck"], "venue": "In Proceedings of the National Conference on Artificial Intelligence,", "citeRegEx": "Gervet and Hentenryck,? \\Q2006\\E", "shortCiteRegEx": "Gervet and Hentenryck", "year": 2006}, {"title": "Set bounds and (split) set domain propagation using ROBDDs", "author": ["P. Hawkins", "V. Lagoon", "P. Stuckey"], "venue": "In 17th Australian Joint Conference on Artificial Intelligence,", "citeRegEx": "Hawkins et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Hawkins et al\\.", "year": 2004}, {"title": "Solving set constraint satisfaction problems using ROBDDs", "author": ["P. Hawkins", "V. Lagoon", "P. Stuckey"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Hawkins et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hawkins et al\\.", "year": 2005}, {"title": "A hybrid BDD and SAT finite domain constraint solver", "author": ["P. Hawkins", "P. Stuckey"], "venue": "In Proceedings of the 8th International Symposium on Practical Aspects of Declarative Languages,", "citeRegEx": "Hawkins and Stuckey,? \\Q2006\\E", "shortCiteRegEx": "Hawkins and Stuckey", "year": 2006}, {"title": "The ECLiPSe constraint logic programming system", "author": ["IC-PARC"], "venue": "[Online, accessed Oct 2008]. http://www.eclipse-clp.org/.", "citeRegEx": "IC.PARC,? 2003", "shortCiteRegEx": "IC.PARC", "year": 2003}, {"title": "ILOG Solver", "author": ["ILOG"], "venue": "[Online, accessed Oct 2008]. http://www.ilog.com/.", "citeRegEx": "ILOG,? 2004", "shortCiteRegEx": "ILOG", "year": 2004}, {"title": "Set domain propagation using ROBDDs", "author": ["V. Lagoon", "P. Stuckey"], "venue": "In Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Lagoon and Stuckey,? \\Q2004\\E", "shortCiteRegEx": "Lagoon and Stuckey", "year": 2004}, {"title": "A Course in Combinatorics (2nd edition)", "author": ["J.H. van Lint", "R.M. Wilson"], "venue": null, "citeRegEx": "Lint and Wilson,? \\Q2001\\E", "shortCiteRegEx": "Lint and Wilson", "year": 2001}, {"title": "Constraint Propagation in Mozart", "author": ["T. M\u00fcller"], "venue": "Doctoral dissertation, Universit\u00e4t des Saarlandes, Naturwissenschaftlich-Technische Fakult\u00e4t I, Fachrichtung Informatik, Saarbr\u00fccken, Germany.", "citeRegEx": "M\u00fcller,? 2001", "shortCiteRegEx": "M\u00fcller", "year": 2001}, {"title": "Propagation = lazy clause generation", "author": ["O. Ohrimenko", "P. Stuckey", "M. Codish"], "venue": "Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Ohrimenko et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ohrimenko et al\\.", "year": 2007}, {"title": "Propagation via lazy clause", "author": ["O. Ohrimenko", "P. Stuckey", "M. Codish"], "venue": "generation. Constraints,", "citeRegEx": "Ohrimenko et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ohrimenko et al\\.", "year": 2009}, {"title": "PECOS: a high level constraint programming language", "author": ["Puget", "J.-F."], "venue": "Proceedings of SPICIS\u201992, Singapore.", "citeRegEx": "Puget and J..F.,? 1992", "shortCiteRegEx": "Puget and J..F.", "year": 1992}, {"title": "Symmetry breaking revisited", "author": ["Puget", "J.-F."], "venue": "Constraints, 10 (1), 23\u201346.", "citeRegEx": "Puget and J..F.,? 2005", "shortCiteRegEx": "Puget and J..F.", "year": 2005}, {"title": "Hybrid set domains to strengthen constraint propagation and reduce symmetries", "author": ["A. Sadler", "C. Gervet"], "venue": "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP04),", "citeRegEx": "Sadler and Gervet,? \\Q2004\\E", "shortCiteRegEx": "Sadler and Gervet", "year": 2004}, {"title": "Sicstus prolog", "author": ["SICS"], "venue": "www.sics.se/sicstus.", "citeRegEx": "SICS,? 2009", "shortCiteRegEx": "SICS", "year": 2009}, {"title": "Efficent reasoning for nogoods in constraint solvers with BDDs", "author": ["S. Subbarayan"], "venue": "Proceedings of Tenth International Symposium on Practical Aspects of Declarative Languages, Vol. 4902 of LNCS, pp. 53\u201357.", "citeRegEx": "Subbarayan,? 2008", "shortCiteRegEx": "Subbarayan", "year": 2008}, {"title": "On the complexity of derivation in propositional calculus", "author": ["G. Tseitin"], "venue": "Studies in Constructive Mathematics and Mathematical Logic, Part 2, 115\u2013125.", "citeRegEx": "Tseitin,? 1968", "shortCiteRegEx": "Tseitin", "year": 1968}, {"title": "Evaluation of length-lex set variables", "author": ["J. Yip", "P. Van Hentenryck"], "venue": "In Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Yip and Hentenryck,? \\Q2009\\E", "shortCiteRegEx": "Yip and Hentenryck", "year": 2009}], "referenceMentions": [{"referenceID": 10, "context": "The most common level of consistency is set bounds consistency (Gervet, 1997) where the solver keeps track for each set of which elements are definitely in or out of the set.", "startOffset": 63, "endOffset": 77}, {"referenceID": 15, "context": "Many solvers use set bounds consistency including ECLiPSe (IC-PARC, 2003), Gecode (GECODE, 2008), and ILOG SOLVER (ILOG, 2004).", "startOffset": 58, "endOffset": 73}, {"referenceID": 9, "context": "Many solvers use set bounds consistency including ECLiPSe (IC-PARC, 2003), Gecode (GECODE, 2008), and ILOG SOLVER (ILOG, 2004).", "startOffset": 82, "endOffset": 96}, {"referenceID": 16, "context": "Many solvers use set bounds consistency including ECLiPSe (IC-PARC, 2003), Gecode (GECODE, 2008), and ILOG SOLVER (ILOG, 2004).", "startOffset": 114, "endOffset": 126}, {"referenceID": 9, "context": "Many solvers use set bounds consistency including ECLiPSe (IC-PARC, 2003), Gecode (GECODE, 2008), and ILOG SOLVER (ILOG, 2004). Set bounds propagation is supported by solvers since stronger notions of propagation such as domain propagation require representing exponentially large domains of possible values. However, Lagoon and Stuckey (2004) demonstrated that it is possible to use reduced ordered binary decision diagrams (BDDs) as a compact representation of both set domains and of set constraints, thus permitting set domain propagation.", "startOffset": 75, "endOffset": 344}, {"referenceID": 6, "context": ", the report by E\u00e9n and S\u00f6rensson (2003) for a good introduction to modern SAT solving.", "startOffset": 16, "endOffset": 41}, {"referenceID": 2, "context": "Reduced Ordered Binary Decision Diagrams (BDDs) (Bryant, 1986) require that the BDD is: reduced, that is it contains no identical nodes (nodes with the same variable label and identical true and false arcs) and has no redundant tests (no node has both true and false arcs leading to the same node); and ordered, if there is an arc from a node labelled v1 to a node labelled v2 then v1 \u227a v2.", "startOffset": 48, "endOffset": 62}, {"referenceID": 12, "context": "For more details see the work of Hawkins et al. (2005). The BDD representation of |x| \u2264 2 is shown in Figure 2(b), for N = 5.", "startOffset": 33, "endOffset": 55}, {"referenceID": 12, "context": "The improved definition is given by Hawkins et al. (2004). Overall the complexity can be made O(|B(c)|).", "startOffset": 36, "endOffset": 58}, {"referenceID": 25, "context": "2 Tseitin Transformation It is possible to convert any Boolean circuit to a pure SAT representation; the method for doing so is generally attributed to Tseitin (1968). Figure 3 gives pseudo code for the translation of a BDD rooted at node, returning a pair of (Boolean variable, set of clauses).", "startOffset": 2, "endOffset": 167}, {"referenceID": 6, "context": "A more comprehensive discussion of the Tseitin transformation is presented by E\u00e9n and S\u00f6rensson (2006). The constraint is enforced by fixing the variable corresponding to the root node to true.", "startOffset": 78, "endOffset": 103}, {"referenceID": 3, "context": "However, a number of improvements for MultiDecision Diagrams (MDDs) were presented by Cheng and Yap (2008) which reduce the portion of the graph which must be traversed in order to enforce consistency.", "startOffset": 86, "endOffset": 107}, {"referenceID": 3, "context": "A method for efficiently maintaining the failure sets was presented by Cheng and Yap (2008), which uses sparse-set data structures to provide efficient lookup, insertion and backtracking.", "startOffset": 71, "endOffset": 92}, {"referenceID": 3, "context": "Note that shortcutting for BDDs is more complex than the approach used by Cheng and Yap (2008) since they do not treat \u201clong arcs\u201d in MDDs.", "startOffset": 74, "endOffset": 95}, {"referenceID": 14, "context": "A method for constructing such minimal clauses was demonstrated by Hawkins and Stuckey (2006), but this method involves constructing new BDDs, eliminating redundant variables until the minimal BDD is constructed, then reading off the variables remaining", "startOffset": 67, "endOffset": 94}, {"referenceID": 26, "context": "The algorithm presented by Subbarayan (2008) provides a method to do this by traversing a static graph, again avoiding the need to construct intermediate BDDs.", "startOffset": 27, "endOffset": 45}, {"referenceID": 26, "context": "Figure 12: Pseudo-code for the reason generation algorithm by Subbarayan (2008). Constructs a minimal set of variables required to cause the inference var = sign.", "startOffset": 62, "endOffset": 80}, {"referenceID": 1, "context": "We also compare with published results of the Cardinal (Azevedo, 2007) and Length-Lex (Yip & Van Hentenryck, 2009) solvers on the same problems.", "startOffset": 55, "endOffset": 70}, {"referenceID": 17, "context": "Again, we use the same model as used by Lagoon and Stuckey (2004), using a w \u00d7 g matrix of set variables vij where 1 \u2264 i \u2264 w and 1 \u2264 j \u2264 g.", "startOffset": 40, "endOffset": 66}, {"referenceID": 14, "context": "We compare against the reported results for the original BDD-SAT hybrid solver of Hawkins and Stuckey (2006) versus a number of variations of our hybrid.", "startOffset": 82, "endOffset": 109}, {"referenceID": 14, "context": "We compare against the reported results for the original BDD-SAT hybrid solver of Hawkins and Stuckey (2006) versus a number of variations of our hybrid. base is the base solver of Figures 4 and 5, while +f indicates with filtering of Section 4.1 added, +s indicates with dead subgraph memoization and shortcutting added (Section 4.2) using the original sparse set code, +i is these optimizations with the improved sparse set code. We also combine filtering with the other optimizations. The table shows time and number of fails for each variant, where the solvers with identical failure behaviour are grouped together. Note that filtering can change the search by reordering the propagations and hence changing the nogoods that are generated, while the other optimizations cannot except that shortcutting can change the results of filtering (and hence change search). While filtering improves on the base line, dead subgraph memoization and shortcutting do not, although we can see the benefit of the improved sparse set operations. Comparing against the solver of Hawkins and Stuckey (2006), which was run on a (\u266f) 2.", "startOffset": 82, "endOffset": 1093}, {"referenceID": 14, "context": "We compare against the reported results for the original BDD-SAT hybrid solver of Hawkins and Stuckey (2006) versus a number of variations of our hybrid. base is the base solver of Figures 4 and 5, while +f indicates with filtering of Section 4.1 added, +s indicates with dead subgraph memoization and shortcutting added (Section 4.2) using the original sparse set code, +i is these optimizations with the improved sparse set code. We also combine filtering with the other optimizations. The table shows time and number of fails for each variant, where the solvers with identical failure behaviour are grouped together. Note that filtering can change the search by reordering the propagations and hence changing the nogoods that are generated, while the other optimizations cannot except that shortcutting can change the results of filtering (and hence change search). While filtering improves on the base line, dead subgraph memoization and shortcutting do not, although we can see the benefit of the improved sparse set operations. Comparing against the solver of Hawkins and Stuckey (2006), which was run on a (\u266f) 2.4GHz Pentium 4, we find that, slightly different number of backtracks and slightly faster machine not withstanding, the solver presented here is roughly an order of magnitude faster. Table 2 shows the results using VSIDS search on easy problems. It compares against the solver of Hawkins and Stuckey (2006) and a Tseitin decomposition.", "startOffset": 82, "endOffset": 1426}, {"referenceID": 14, "context": "The base solver is around 5 times faster per failure than the solver of Hawkins and Stuckey (2006). The Tseitin decomposition is not competitive, even if we discount the results on 7,5,3.", "startOffset": 72, "endOffset": 99}, {"referenceID": 1, "context": "We also compare against the published results of the Cardinal solver (Azevedo, 2007), which uses", "startOffset": 69, "endOffset": 84}, {"referenceID": 17, "context": "We model the Steiner problem similarly to Lagoon and Stuckey (2004) extended for the case of more general Steiner Systems.", "startOffset": 42, "endOffset": 68}, {"referenceID": 0, "context": "For comparison with the results of Azevedo (2007) and Yip and Van Hentenryck (2009), we construct a dual model with additional variables d1, .", "startOffset": 35, "endOffset": 50}, {"referenceID": 0, "context": "For comparison with the results of Azevedo (2007) and Yip and Van Hentenryck (2009), we construct a dual model with additional variables d1, .", "startOffset": 35, "endOffset": 84}, {"referenceID": 0, "context": "In Table 6, we use the model and search strategy used by Azevedo (2007), restricting the number of times a given element can occur in the sets s1, .", "startOffset": 57, "endOffset": 72}, {"referenceID": 12, "context": "Tables 7 to 10 show the results on the 11 hard instances reported by Hawkins et al. (2005). Clearly on these problems the VSIDS hybrid is the most robust.", "startOffset": 69, "endOffset": 91}, {"referenceID": 10, "context": "This general approach was also used by Conjunto (Gervet, 1997), ECLPS (IC-PARC, 2003), ILOG Solver (ILOG, 2004) and Mozart (M\u00fcller, 2001).", "startOffset": 48, "endOffset": 62}, {"referenceID": 15, "context": "This general approach was also used by Conjunto (Gervet, 1997), ECLPS (IC-PARC, 2003), ILOG Solver (ILOG, 2004) and Mozart (M\u00fcller, 2001).", "startOffset": 70, "endOffset": 85}, {"referenceID": 16, "context": "This general approach was also used by Conjunto (Gervet, 1997), ECLPS (IC-PARC, 2003), ILOG Solver (ILOG, 2004) and Mozart (M\u00fcller, 2001).", "startOffset": 99, "endOffset": 111}, {"referenceID": 19, "context": "This general approach was also used by Conjunto (Gervet, 1997), ECLPS (IC-PARC, 2003), ILOG Solver (ILOG, 2004) and Mozart (M\u00fcller, 2001).", "startOffset": 123, "endOffset": 137}, {"referenceID": 25, "context": "The underlying BDD propagation algorithm is similar to propagation of the case constraint of SICStus PRolog (SICS, 2009) and Multi-valued Decision Diagrams (MDDs) (see e.", "startOffset": 108, "endOffset": 120}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables.", "startOffset": 124, "endOffset": 368}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables.", "startOffset": 124, "endOffset": 502}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables. These directly BDD-based algorithms were used to construct the earlier hybrid solver presented by Hawkins and Stuckey (2006), which is conceptually similar to the solver presented in this paper.", "startOffset": 124, "endOffset": 750}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables. These directly BDD-based algorithms were used to construct the earlier hybrid solver presented by Hawkins and Stuckey (2006), which is conceptually similar to the solver presented in this paper. The solver presented here is much more efficient, and includes improvements such as filtering and shortcutting not present in the solver of Hawkins and Stuckey (2006). The solver of Damiano and Kukula (2003) also combines BDD solving and SAT solving, but rather than building BDDs from a high-level problem description and lazily constructing a SAT representation, instead takes a CNF SAT representation and constructs a BDD from a collection of clauses with the primary goal of variable elimination.", "startOffset": 124, "endOffset": 987}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables. These directly BDD-based algorithms were used to construct the earlier hybrid solver presented by Hawkins and Stuckey (2006), which is conceptually similar to the solver presented in this paper. The solver presented here is much more efficient, and includes improvements such as filtering and shortcutting not present in the solver of Hawkins and Stuckey (2006). The solver of Damiano and Kukula (2003) also combines BDD solving and SAT solving, but rather than building BDDs from a high-level problem description and lazily constructing a SAT representation, instead takes a CNF SAT representation and constructs a BDD from a collection of clauses with the primary goal of variable elimination.", "startOffset": 124, "endOffset": 1028}, {"referenceID": 0, "context": "These include solvers which combine set-bounds representation with either cardinality information, such as that proposed by Azevedo (2002, 2007), lexicographic bounds information (Sadler & Gervet, 2004) or both (Gervet & Van Hentenryck, 2006; Yip & Van Hentenryck, 2009). BDD-based approaches to set-constraint solving, such as that presented by Hawkins et al. (2005) differs greatly from these approaches, as it is possible to perform propagation over arbitrary constraints; Lagoon and Stuckey (2004) also demonstrated the feasibility of a BDD-based solver which maintains a complete domain representation of set variables. These directly BDD-based algorithms were used to construct the earlier hybrid solver presented by Hawkins and Stuckey (2006), which is conceptually similar to the solver presented in this paper. The solver presented here is much more efficient, and includes improvements such as filtering and shortcutting not present in the solver of Hawkins and Stuckey (2006). The solver of Damiano and Kukula (2003) also combines BDD solving and SAT solving, but rather than building BDDs from a high-level problem description and lazily constructing a SAT representation, instead takes a CNF SAT representation and constructs a BDD from a collection of clauses with the primary goal of variable elimination. It is essentially equivalent to the base solver. The underlying BDD propagation algorithm is similar to propagation of the case constraint of SICStus PRolog (SICS, 2009) and Multi-valued Decision Diagrams (MDDs) (see e.g., Cheng & Yap, 2008). Indeed we have adapted the dead subgraph memoization and shortcutting devices of Cheng and Yap (2008) to BDD propagation.", "startOffset": 124, "endOffset": 1666}, {"referenceID": 13, "context": "This traversal-based method, when combined with filtering to reduce the number of redundant propagator executions and dead subgraph memoization and shortcutting, is at least an order of magnitude faster than previous techniques which construct BDDs during runtime (Hawkins et al., 2005).", "startOffset": 264, "endOffset": 286}], "year": 2010, "abstractText": "Binary Decision Diagram (BDD) based set bounds propagation is a powerful approach to solving set-constraint satisfaction problems. However, prior BDD based techniques incur the significant overhead of constructing and manipulating graphs during search. We present a set-constraint solver which combines BDD-based set-bounds propagators with the learning abilities of a modern SAT solver. Together with a number of improvements beyond the basic algorithm, this solver is highly competitive with existing propagation based set constraint solvers.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}