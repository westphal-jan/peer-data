{"id": "1401.3868", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Clause-Learning Algorithms with Many Restarts and Bounded-Width Resolution", "abstract": "We offer a new understanding of some aspects of practical SAT-solvers that are based on DPLL with unit-clause propagation, clause-learning, and restarts. We do so by analyzing a concrete algorithm which we claim is faithful to what practical solvers do. In particular, before making any new decision or restart, the solver repeatedly applies the unit-resolution rule until saturation, and leaves no component to the mercy of non-determinism except for some internal randomness. We prove the perhaps surprising fact that, although the solver is not explicitly designed for it, with high probability it ends up behaving as width-k resolution after no more than O(n^2k+2) conflicts and restarts, where n is the number of variables. In other words, width-k resolution can be thought of as O(n^2k+2) restarts of the unit-resolution rule with learning.", "histories": [["v1", "Thu, 16 Jan 2014 05:07:08 GMT  (326kb)", "http://arxiv.org/abs/1401.3868v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["albert atserias", "johannes klaus fichte", "marc thurley"], "accepted": false, "id": "1401.3868"}, "pdf": {"name": "1401.3868.pdf", "metadata": {"source": "CRF", "title": "Clause-Learning Algorithms with Many Restarts and Bounded-Width Resolution", "authors": ["Albert Atserias", "Johannes Klaus Fichte", "Marc Thurley"], "emails": ["atserias@lsi.upc.edu", "fichte@kr.tuwien.ac.at", "marc.thurley@googlemail.com"], "sections": [{"heading": "1. Introduction", "text": "This year it has come to the point that it is a purely reactionary project, in which it is a reactionary project, in which it is a reactionary project."}, {"heading": "1.1 Related Work", "text": "The first attempt to compare the power of SAT solvers with the power of resolution as a system of evidence was made by Beame et al. (2003, 2004). The most important positive result of their work is that claw learning, with a specific learning scheme and without rebooting, can provide exponentially shorter evidence than appropriate refinements of resolution such as tree or regular or positive resolution. Furthermore, they show that modifying a standard solver to allow multiple assignments to the same variable would be able to efficiently simulate a general resolution, provided an ideal decision strategy is applied. Following the work, it emerged that the requirement for multiple assignments to the same variable is a technical problem that can be avoided if the given CNF formula is processed appropriately (Hertel et al., 2008). In our work, we avoid these two maneuvers by introducing the concept of clause absorption to help us solve the standard algorithms directly."}, {"heading": "1.2 Organization", "text": "In Section 2, we introduce the basic notation and define the algorithm we are analyzing. We also discuss the dependence of our results on our choice of learning scheme, restart policy and the decision strategy the algorithm applies. Section 3 begins with some basic facts about the algorithm's workings, continues with the most important definitions of absorption and beneficial rounds, and then analyzes the runtime of the algorithm. Section 4 contains a discussion of the consequences, including the implications for limited tree width formulas."}, {"heading": "2. Clause Learning Algorithms", "text": "In this section we will define the algorithm and discuss our selection of its components, starting with some preliminary definitions.1. Note that a weaker version of 1-Empowerment was originally introduced by Pipatsrisawat and Darwiche (2008)."}, {"heading": "2.1 Preliminaries", "text": "Let's say V = {v1,.., vn} a fixed group of statement variables = previous sentence. A letter is a statement variable x or its negation x. we use the notation x0 for x-a and x1 for x. Note that xa is defined so that the assignment x = a fulfills it. For a {0, 1} formula we also use a set of clauses. The width of a sentence is the number of letters in it. Below are all formulas about the same set of variables V and each sentence contains only letters on variables from V. For two clauses A = {x, '1,."}, {"heading": "2.2 Definition of the Algorithm", "text": "A state is a sequence of assignments (x1 = a1,.., xr = ar) in which all variables are different and some assignments are marked as decisions. We use the notation xi d = ai to indicate that the assignment xi = ai is a decision assignment. In this case, xi is called a decision variable, the rest of the assignments are implicit assignments. We use S and T to designate states. The empty state is the one without assignments. Let's define the decision level of an assignment xi = ai as the number of decision assignments in (x1 = a1,..., xi = ai)."}, {"heading": "2.2.1 Operation", "text": "The algorithm maintains a current state S and a current set of clauses D. There are four operating modes DEFAULT, CONFLICT, UNIT and DECISION. The algorithm starts in DEFAULT mode with the empty state as the current state and the given CNF formula as the current set of clauses: \u2022 DEFAULT. If S sets all variables in D and meets all clauses in D, stop and output SAT along with the current state S. Otherwise, if D | S contains the empty clause, move into CONFLICT mode. Otherwise, if D | S contains a unity clause, move into UNIT mode, move into DECISION mode. Apply the learning scheme to add a new clause C in D. If C is the empty clause, stop and output UNSAT."}, {"heading": "2.2.2 Runs of the Algorithm", "text": "Consider a run of the algorithm started in DEFAULT mode with the empty state and the initial set of clauses D until either a clause is falsified or all variables are set. Such a run is referred to as a complete round started with D, which we represent by the sequence of states S0,..., Sm that the algorithm passes through, where S0 is the empty state and Sm is the state in which either all variables are set or the falsified sentence is found. In general, a round is an initial segment S0,..., Sr of a complete round until a state in which either D | Sr is the empty clause or D | Sr contains no unity clause. If D | Sr contains the empty clause, we say that the round is conclusive. If a round is inconclusive, we do not call it conclusive. The term inconclusive means that no clause can be learned from such a round."}, {"heading": "2.3 Restart Policy, Learning Scheme, and Decision Strategy", "text": "In the following, we will discuss our choice of learning scheme, the restart policy and the decision-making strategy used by the algorithm, focusing in particular on the dependence of our results on this choice."}, {"heading": "2.3.1 Restart Policy", "text": "The only important feature that we need from the reboot policy is that it dictates restarts often enough. Specifically, our analysis will work just as well for the most aggressive of the restart strategies, which dictates a restart after each conflict, as for a less aggressive strategy, which allows for any limited number of conflicts between restarts. The fact that our analysis is insensitive in this respect derives from a monotony property of the performance of the algorithm, which we will prove in Lemma 5. Specifically, it follows from the monotonicity dilemma that if we opt for a policy that allows c > 1 conflicts before a restart, the upper limit on the number of required reboots can only decrease (or remain the same). Only the upper limit on the number of conflicts would appear multiplied by a factor of c, although the truth may be that these also decrease."}, {"heading": "2.3.2 Decision Strategy", "text": "The decision strategy determines which variable is next assigned and what value. Again, the only important feature we need of the decision strategy is that it often enough allows a round of completely random decisions. Here, a completely random decision is defined as follows: If the current state of the algorithm is S, we choose a variable x equally randomly from among the variables of V that do not occur in S. And a value a in {0, 1} also equally randomly and independently of the choice of x. Thus, our analysis actually applies to any decision strategy that allows an unlimited number of rounds of heuristic decisions between completely random ones. Specifically, if we allow c > 1 rounds of non-random decisions between random ones, then the number of required restarts and conflicts would appear to be multiplied by a factor of c. Again, this will be from the second consequence that the definitions of round, conclusive rounds and inconclusive decisions differ slightly from those in the conference version of this paper."}, {"heading": "2.3.3 Learning Scheme", "text": "The learning scheme determines which clause is added to the set of clauses when a conflict occurs. Let S0,.., Sr be a final round that begins with the set of clauses D that falsify a clause of D. Let xi = ai or xi d = ai be the i-th mapping of the round. We comment on each Si by a clause Ai by inverted induction to i [1,.., r]: 1. Let Bi be any clause in D that is determined by Sr.2. For i \u2264 r, for which xi d = ai is a decision, let Ai = Ai + 1.3. For i \u2264 r, for which xi = ai is implied, let Bi be each clause in D so that Bi \u2212 1 is the unit clause {xaii}, and let Ai = Res (Ai + 1, Bi, xi) if this clause is solvable."}, {"heading": "2.3.4 Clause Bookkeeping", "text": "It should be noted that our analysis is decisively based on the assumption that the learned clauses will never be removed from the current set of clauses. However, practical SAT solvers regularly delete some of the learned clauses in order to save memory and avoid the overhead they introduce. Therefore, an interesting question is whether our results can be made to work without this assumption. In this regard, the strong evidence of the complexity of the learned clauses from Nordstro \u00b6 m (2009) shows that not every small-scale refutation of the resolution in a small clauses space can be made to work, that a similar assumption to ours is actually necessary. Another remark worth mentioning here concerns the breadth of the clauses learned. Since our goal is to show that the algorithm can simulate a small-area resolution, it seems obvious to ask whether we can limit the learning scheme to allow clauses of small clauses with only a small-width analysis."}, {"heading": "3. Analysis of the Algorithm", "text": "In this section we analyze the runtime of the algorithm. However, before we can do this, we must present our most important technical concepts of absorption and useful rounds and examine some of their most important properties."}, {"heading": "3.1 Runs of the Algorithm", "text": "Let R and R be a round, and let C be a clause. We say that R. \"summarizes R.\" summarizes R. \"down to decision marks, every assignment in R also appears in R.\" We say that R \"and R\" to C, \"if the constraints of R\" and R \"to variables in C are the same: each variable in C is either not assigned in both, or assigned to the same value in both. We say that R\" s branches in C \"when all decision variables in R are\" variables in C. \"We define them later on for clauses simplifying notation. We prove two more technical lemmas. The goal is to show that inconclusive rounds are robust in the order in which assignments are made. For example, the first clause shows that each inconclusive round is subsumed to respond to their decisions."}, {"heading": "3.2 Absorption", "text": "An essential feature of the definition of a round is that, if it is inconclusive, the rest of the clauses do not contain any single clauses and, in particular, are closed with the spread of single clauses, which means that for an inconclusive round R that started with D, if A is a clause in D and R falsifies all but one of its letters, then R must fulfil the remaining letter, and thus also A. Besides the clauses in D, other clauses may have this property important enough to merit a definition: Definition 3 (absorption). Let D be a set of clauses, let A be a non-empty clause, and let xa be a literal clause in A. We say that D absorbs A to xa when each inconclusive round starts with D, which distorts A, which in turn leads to a. We say that D A absorbs A when D is too inconclusive."}, {"heading": "3.2.1 Properties of Absorption", "text": "In fact, we are able to go in search of a solution that will enable us to find a solution that will enable us to find a solution, that will enable us to find a solution, and that will enable us to find a solution that will enable us to find a solution, that will enable us to find a solution that will enable us to find a solution, and that will enable us to find a solution that will enable us to find a solution. \""}, {"heading": "3.2.2 Absorption and Empowerment", "text": "The next goal is to show that absorption and empowerment are two terms. For assignments \u03b1, \u03b2 we write \u03b1 \u03b2 if each assignment in \u03b1 is also in \u03b2. Let's reproduce the definition of 1-empowerment in the work of Pipatsrisawat and Darwiche (2009), slightly adapted to our notation and terminology. Definition 6 (1-empowerment in Pipatsrisawat & Darwiche, 2009) Let D be a set of clauses, let C be a non-empty clause and let xa be a literal clause in C. Let's be the assignment that sets y = 1 \u2212 b for each literal assignment in C\\ xa}. We say that C is 1-empowerment in relation to D if the following three conditions are met: 1. C is a logical consequence of D; i.e."}, {"heading": "3.3 Beneficial Rounds", "text": "It is a question of whether and how we will be able to find a solution, which we must take care of. (...) It is a question of whether we are able to find a solution. (...) It is a question of whether we are able to find a solution. (...) It is a question of whether we are able to find a solution. (...) It is a question of whether we want a solution. (...) It is a question of whether we want a solution. (...) It is a question of whether we are able to find a solution. (...) It is a question of whether we want a solution. (...) It is a question of whether we want a solution. (...) It is a question of whether we find a solution. (...) It is a question of whether we find a solution. (...) It is a solution. (...) It is a solution. (...) It is a solution. (...) It is a solution. (...) It is a solution. (...) It is a solution. (... It is a solution. (...) It is a solution. (...) It is a solution. (... It is a solution. (...) It is a solution. (... It is a solution. (...) It is a solution. (... It is a solution."}, {"heading": "3.4 Main Technical Lemma", "text": "We will now begin to analyze the number of complete rounds that it takes to resolve two absorbed clauses (4k). We will begin to analyze the number of complete rounds until a complete decision is reached. (A, B) Let's leave the total number of variables in D, and k will be the width of C. For each individual clauses, we will have two resolvable clauses that are included by D and which have a nonempty resolution of C = Res. (A, B) Let's leave n the total number of variables in D, and k will be the width of C. For each individual clauses, we will have R0,. Rt \u2212 1 denote the t consecutive complete rounds of algorithms started with D, and let's leave D0,. (Dt \u2212 1 denote the intermediate sets of clauses.) Then the probability becomes that none of the Ri clauses is advantageous for C and none of the Di-absorbed C."}, {"heading": "3.5 Bounds", "text": "With the tools mentioned above, we are now able to prove the main result of the work: the simulation of Wide-k resolution by the algorithm. First, we will provide proof of the algorithm that applies the Decision learning scheme. Not only is the proof easier and more instructive, but we will also get slightly better boundaries for this particular case. Afterwards, we will see the result for the enforcement of learning schemes in general."}, {"heading": "3.5.1 The Decision Scheme", "text": "The fact that makes the decision easier is that, for this learning scheme, the occurrence of a favored round, the absorption phases in the next round are absorbed. (D) This means that the next set of clauses intercepted by C, and thus also intercepted by C. (D) This means that the next set of clauses absorbed by D and B will be two resolvable clauses absorbed by D and that has a nonempty resolution of C = Res 5. We get the following result as a direct consequence of Lemma 11.Lemma 12. Let D be a set of clauses, and let A and B be two resolvable clauses absorbed by D and that has a nonempty resolution of C = Res (A, B). Let n the total number of variables in D and k be the width of C. Then, for all t, using the decision learning scheme, the probability that C will not be absorbed by the current clauses."}, {"heading": "3.5.2 Asserting Learning Schemes in General", "text": "The analysis is somewhat more complex than that of the decision-making process, since in general a clause from a full round R \"cannot be assumed to be a subset of the decisions in R.\" Therefore, we can only show that the solvent is ultimately absorbed by a small detour. We note that this evidence must overcome similar difficulties as, and that the proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009). We need a clause and D must be a set of clauses. Let WC, D denotate the series of letters in C such that there is an inconclusive round that is beneficial to C. \"Let u,\" C, D denote the number of variables that are not assigned, starting with an inconclusive round that is for C. \"If there is no such round, we define C, D = 0."}, {"heading": "4. Consequences", "text": "The total number of clauses from width k to n variables is limited by 2k (n k), which is at most 2nk for each n and k. So if F has n variables and a resolution that refutes the width k, we can assume that its length is at most 4nk, if we make the following estimate: i = 0 2i (n i) \u2264 1 + 2 k \u2211 i = 1 ni = 1 + 2n \u00b7 (nk \u2212 1 n \u2212 1) \u2264 4nk. We get the following sequence to Theorem 17.corollar18. Let F be a set of clauses about n variables that have a resolution of width k. With a probability of at least 1 / 2, the algorithm starts with F, using an arbitrary learning scheme, the empty clause learns according to a maximum of 16k (k + 1) ln (16kn) nmafiability of width k + 2kollar.An application of Dalollar18 means that we can use the empty clause according to 16k + tsk (2k) for the purpose of CNnnnnn18 at the most (although it is a rigid algorithm)."}, {"heading": "Acknowledgments", "text": "We thank Martin Grohe for pointing out the problem of comparing the performance of SAT solvers with a limited resolution. We also thank Knot Pipatsrisawat and Adnan Darwiche for pointing out the link between 1-empowering and absorption. We also thank Peter Jeavons for comments on the conference version of this paper and the anonymous speakers for very detailed comments. The first author was partially supported by CYCIT TIN2007-68005-C04-03. The second author was partially supported by the European Research Council (ERC), Grant 239962. The third author was partially supported by a postdoctoral fellowship under the German Academic Exchange Service (DAAD). A preliminary version of this paper appeared in the Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing, SAT '09 (Atserias et al., 2009)."}], "references": [{"title": "Satisfiability, branch-width and Tseitin tautologies", "author": ["M. Alekhnovich", "A.A. Razborov"], "venue": "In Proceedings of the 43rd Symposium on Foundations of Computer Science (FOCS", "citeRegEx": "Alekhnovich and Razborov,? \\Q2002\\E", "shortCiteRegEx": "Alekhnovich and Razborov", "year": 2002}, {"title": "Resolution is not automatizable unless W[P] is tractable", "author": ["M. Alekhnovich", "A.A. Razborov"], "venue": "SIAM J. Comput.,", "citeRegEx": "Alekhnovich and Razborov,? \\Q2008\\E", "shortCiteRegEx": "Alekhnovich and Razborov", "year": 2008}, {"title": "Resolution with merging", "author": ["P.B. Andrews"], "venue": "J. ACM,", "citeRegEx": "Andrews,? \\Q1968\\E", "shortCiteRegEx": "Andrews", "year": 1968}, {"title": "A combinatorial characterization of resolution width", "author": ["A. Atserias", "V. Dalmau"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "Atserias and Dalmau,? \\Q2008\\E", "shortCiteRegEx": "Atserias and Dalmau", "year": 2008}, {"title": "Clause-learning algorithms with many restarts and bounded-width resolution", "author": ["A. Atserias", "J.K. Fichte", "M. Thurley"], "venue": "Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Atserias et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Atserias et al\\.", "year": 2009}, {"title": "Using CSP look-back techniques to solve real-world SAT instances", "author": ["R.J. Bayardo", "R.C. Schrag"], "venue": "In Proceedings of the Fourtheenth National Conference on Artificial Intelligence", "citeRegEx": "Bayardo and Schrag,? \\Q1997\\E", "shortCiteRegEx": "Bayardo and Schrag", "year": 1997}, {"title": "Understanding the power of clause learning", "author": ["P. Beame", "H.A. Kautz", "A. Sabharwal"], "venue": "Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Beame et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2003}, {"title": "Towards understanding and harnessing the potential of clause learning", "author": ["P. Beame", "H.A. Kautz", "A. Sabharwal"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Beame et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2004}, {"title": "Lower bounds for width-restricted clause learning on small width formulas", "author": ["E. Ben-Sasson", "J. Johannsen"], "venue": "Proceedings of 13th International Conference on Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Ben.Sasson and Johannsen,? \\Q2010\\E", "shortCiteRegEx": "Ben.Sasson and Johannsen", "year": 2010}, {"title": "Short proofs are narrow - resolution made simple", "author": ["E. Ben-Sasson", "A. Wigderson"], "venue": "In Proceedings of the Thirty-First Annual ACM Symposium on Theory of Computing (STOC", "citeRegEx": "Ben.Sasson and Wigderson,? \\Q1999\\E", "shortCiteRegEx": "Ben.Sasson and Wigderson", "year": 1999}, {"title": "Constraint satisfaction, bounded treewidth, and finite-variable logics", "author": ["V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi"], "venue": "In CP \u201902: Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Dalmau et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Dalmau et al\\.", "year": 2002}, {"title": "Clause learning can effectively p-simulate general propositional resolution", "author": ["P. Hertel", "F. Bacchus", "T. Pitassi", "A.V. Gelder"], "venue": null, "citeRegEx": "Hertel et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hertel et al\\.", "year": 2008}, {"title": "Local consistency and sat-solvers", "author": ["P. Jeavons", "J. Petke"], "venue": "In Proceedings of the 16th International Conference on Principles and Practice of Constraint Programming - CP 2010,", "citeRegEx": "Jeavons and Petke,? \\Q2010\\E", "shortCiteRegEx": "Jeavons and Petke", "year": 2010}, {"title": "Chaff: Engineering an efficient SAT solver", "author": ["M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "In Proceedings of the 38th Design Automation Conference (DAC\u201901)", "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "Solving SAT and SAT Modulo Theories: From an abstract Davis\u2013Putnam\u2013Logemann\u2013Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM,", "citeRegEx": "Nieuwenhuis et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "Narrow proofs may be spacious: Separating space and width in resolution", "author": ["J. Nordstr\u00f6m"], "venue": "SIAM J. Comput.,", "citeRegEx": "Nordstr\u00f6m,? \\Q2009\\E", "shortCiteRegEx": "Nordstr\u00f6m", "year": 2009}, {"title": "A new clause learning scheme for efficient unsatisfiability proofs", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": null, "citeRegEx": "Pipatsrisawat and Darwiche,? \\Q2008\\E", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2008}, {"title": "On the power of clause-learning SAT solvers with restarts", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": "Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming - CP 2009,", "citeRegEx": "Pipatsrisawat and Darwiche,? \\Q2009\\E", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2009}, {"title": "Grasp - a new search algorithm for satisfiability", "author": ["J.P.M. Silva", "K.A. Sakallah"], "venue": "In Proceedings of IEEE/ACM International Conference on Computer-Aided Design,", "citeRegEx": "Silva and Sakallah,? \\Q1996\\E", "shortCiteRegEx": "Silva and Sakallah", "year": 1996}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.W. Moskewicz", "S. Malik"], "venue": "In International Conference on ComputerAided Design (ICCAD\u201901),", "citeRegEx": "Zhang et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 6, "context": "a subsystem of resolution (Beame et al., 2003).", "startOffset": 26, "endOffset": 46}, {"referenceID": 6, "context": "a subsystem of resolution (Beame et al., 2003). In particular, this means that their performance can never beat resolution lower bounds, and at the same time it provides many explicit examples where SAT-solvers require exponential time. Complementing this is the result that an idealized SAT-solver that relies on non-determinism to apply the techniques in the best possible way will be able to perform as good as general resolution (weak forms of this statement were first established in Beame et al., 2003, 2004; Hertel et al., 2008, and in the current form in Pipatsrisawat & Darwiche, 2009). As Beame et al. (2004) put it, the negative proof complexity results uncover examples of inherent intractability even under perfect choice strategies, while the positive proof complexity results give hope of finding a good choice strategy.", "startOffset": 27, "endOffset": 619}, {"referenceID": 9, "context": "Finally, from the partial automatizability results of Ben-Sasson and Wigderson (1999), it follows that SAT-solvers are able to solve formulas having polynomial-size tree-like resolution proofs in quasipolynomial time, and formulas having polynomial-size general resolution proofs in subexponential time.", "startOffset": 54, "endOffset": 86}, {"referenceID": 11, "context": "Following work showed that the requirement for multiple assignments on the same variable is a technical issue that can be avoided if the given CNF formula is pre-processed appropriately (Hertel et al., 2008).", "startOffset": 186, "endOffset": 207}, {"referenceID": 4, "context": "The first attempt to compare the power of SAT-solvers with the power of resolution as a proof system was made by Beame et al. (2003, 2004). The main positive result from their work is that clause learning with a specific learning scheme and without restarts can provide exponentially shorter proofs than proper refinements of resolution such as tree, or regular, or positive resolution. Furthermore, they show that the modification of a standard solver to allow multiple assignments on the same variable would be able to simulate general resolution efficiently, assuming an ideal decision strategy. Following work showed that the requirement for multiple assignments on the same variable is a technical issue that can be avoided if the given CNF formula is pre-processed appropriately (Hertel et al., 2008). In our work we avoid these two maneuvers by introducing the concept of clause-absorption to help us analyze the standard algorithms directly. Interestingly, for clauses that are logical consequences of the input formulas, our concept of clause-absorption turns out to be dual to the concept of 1-empowerment introduced independently by Pipatsrisawat and Darwiche (2009)1.", "startOffset": 113, "endOffset": 1178}, {"referenceID": 0, "context": "To complete this point, it is worth noting that the non-automatizability results of Alekhnovich and Razborov (2008) indicate that we cannot expect an efficient simulation of general resolution and completely avoid non-determinism at the same time.", "startOffset": 84, "endOffset": 116}, {"referenceID": 16, "context": "Note that, originally, a weaker version of 1-empowerment was introduced by Pipatsrisawat and Darwiche (2008).", "startOffset": 75, "endOffset": 109}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause.", "startOffset": 73, "endOffset": 93}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause. If d denotes the maximum decision level of the assignments in Sr, a conflict clause is called an asserting clause if it contains exactly one variable of decision level d. Asserting clauses, originally defined by Zhang et al. (2001), capture the properties of conflict clauses learned by virtually any modern SAT-solver.", "startOffset": 73, "endOffset": 368}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause. If d denotes the maximum decision level of the assignments in Sr, a conflict clause is called an asserting clause if it contains exactly one variable of decision level d. Asserting clauses, originally defined by Zhang et al. (2001), capture the properties of conflict clauses learned by virtually any modern SAT-solver. For brevity, we describe only two concrete learning schemes in detail. For other schemes see the work of Zhang et al. (2001). The Decision learning scheme adds clause A1 to the current set of clauses after each conflict.", "startOffset": 73, "endOffset": 581}, {"referenceID": 15, "context": "In this respect, the strong proof-complexity results of Nordstr\u00f6m (2009) showing that not every small-width resolution refutation can be made to work in small clause-space seems to indicate that an assumption similar to ours is indeed needed.", "startOffset": 56, "endOffset": 73}, {"referenceID": 8, "context": "Moreover, recent results by Ben-Sasson and Johannsen (2010) show that, in general, learning short clauses only is a provably weaker scheme than learning arbitrarily long clauses.", "startOffset": 28, "endOffset": 60}, {"referenceID": 8, "context": "Moreover, recent results by Ben-Sasson and Johannsen (2010) show that, in general, learning short clauses only is a provably weaker scheme than learning arbitrarily long clauses. Thus, while the examples of Ben-Sasson and Johannsen (2010) do not have small-width resolution refutations and therefore do not show that keeping long clauses is actually required in this case, it is conceivable that it might.", "startOffset": 28, "endOffset": 239}, {"referenceID": 16, "context": "In this section we also show that the notion of clause-absorption is tightly connected to the concept of 1-empowerment independently introduced by Pipatsrisawat and Darwiche (2009).", "startOffset": 147, "endOffset": 181}, {"referenceID": 16, "context": "Let us reproduce the definition of 1-empowerment in the work of Pipatsrisawat and Darwiche (2009), slightly adapted to better suit our notation and terminology.", "startOffset": 64, "endOffset": 98}, {"referenceID": 16, "context": "A preliminary version of this definition was given by Pipatsrisawat and Darwiche (2008) where the second of the three conditions was not required.", "startOffset": 54, "endOffset": 88}, {"referenceID": 2, "context": "A similar connection to clause learning was observed by Pipatsrisawat and Darwiche (2008), where it is also pointed out that the condition that some literal from C appears in both A and B is known as merge resolution (Andrews, 1968).", "startOffset": 217, "endOffset": 232}, {"referenceID": 15, "context": "A similar connection to clause learning was observed by Pipatsrisawat and Darwiche (2008), where it is also pointed out that the condition that some literal from C appears in both A and B is known as merge resolution (Andrews, 1968).", "startOffset": 56, "endOffset": 90}, {"referenceID": 16, "context": "We note that this proof has to overcome similar difficulties as, and is inspired by3, the proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009). We need some preparation.", "startOffset": 128, "endOffset": 162}, {"referenceID": 16, "context": "We thank an anonymous reviewer for pointing out that the original proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009) contained an error that was corrected in the version of the paper on their webpage.", "startOffset": 104, "endOffset": 138}, {"referenceID": 4, "context": "A preliminary version of this paper appeared in the Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing, SAT\u201909 (Atserias et al., 2009).", "startOffset": 162, "endOffset": 185}], "year": 2011, "abstractText": "We offer a new understanding of some aspects of practical SAT-solvers that are based on DPLL with unit-clause propagation, clause-learning, and restarts. We do so by analyzing a concrete algorithm which we claim is faithful to what practical solvers do. In particular, before making any new decision or restart, the solver repeatedly applies the unit-resolution rule until saturation, and leaves no component to the mercy of non-determinism except for some internal randomness. We prove the perhaps surprising fact that, although the solver is not explicitly designed for it, with high probability it ends up behaving as width-k resolution after no more than O(n) conflicts and restarts, where n is the number of variables. In other words, width-k resolution can be thought of as O(n) restarts of the unit-resolution rule with learning.", "creator": "TeX"}}}