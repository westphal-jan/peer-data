{"id": "1401.3878", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Computing Small Unsatisfiable Cores in Satisfiability Modulo Theories", "abstract": "The problem of finding small unsatisfiable cores for SAT formulas has recently received a lot of interest, mostly for its applications in formal verification. However, propositional logic is often not expressive enough for representing many interesting verification problems, which can be more naturally addressed in the framework of Satisfiability Modulo Theories, SMT. Surprisingly, the problem of finding unsatisfiable cores in SMT has received very little attention in the literature. In this paper we present a novel approach to this problem, called the Lemma-Lifting approach. The main idea is to combine an SMT solver with an external propositional core extractor. The SMT solver produces the theory lemmas found during the search, dynamically lifting the suitable amount of theory information to the Boolean level. The core extractor is then called on the Boolean abstraction of the original SMT problem and of the theory lemmas. This results in an unsatisfiable core for the original SMT problem, once the remaining theory lemmas are removed. The approach is conceptually interesting, and has several advantages in practice. In fact, it is extremely simple to implement and to update, and it can be interfaced with every propositional core extractor in a plug-and-play manner, so as to benefit for free of all unsat-core reduction techniques which have been or will be made available.", "histories": [["v1", "Thu, 16 Jan 2014 05:11:40 GMT  (1066kb)", "http://arxiv.org/abs/1401.3878v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["alessandro cimatti", "alberto griggio", "roberto sebastiani"], "accepted": false, "id": "1401.3878"}, "pdf": {"name": "1401.3878.pdf", "metadata": {"source": "CRF", "title": "Computing Small Unsatisfiable Cores in Satisfiability Modulo Theories", "authors": ["Alessandro Cimatti", "Alberto Griggio", "Roberto Sebastiani"], "emails": ["cimatti@fbk.eu", "griggio@fbk.eu", "rseba@disi.unitn.it"], "sections": [{"heading": null, "text": "In this paper, we present a novel approach to this problem, the so-called Lemma Lifting Approach. The main idea is to combine an SMT solver with an external Propositional Core Extractor. The SMT solver produces the theoretical elements found in the search and dynamically raises the appropriate amount of theory information to the Boolean level.The Core Extractor is then required to Boolean abstraction of the original SMT problem and the theoretical elements. This results in an unsatisfactory core for the original SMT problem once the remaining theoretical elements are removed. The approach is conceptually interesting and has several advantages in practice. In fact, it is extremely easy to implement and update, and can be linked to any Propositional Core Extractor in plug-and-play manipulator in order to be free of any unsat core reduction techniques that are available for testing or have extensive validity with our SMT algorithms."}, {"heading": "1. Motivations and Goals", "text": "Over the past decade, we have witnessed impressive progress in the efficiency of SAT techniques that have brought large and previously intractable problems to the surface (2006, 2006, 2006, 2006, 2006, 2006, 2006, 2006).As a result, SAT solutions are now a fundamental tool in many industrial strength applications, including most formal verification design flows for hardware systems, for equivalence, ownership verification and ATPG.Specifically, one of the most relevant issues in this context, thanks to its many important applications, is the finding of small, unsatisfactory cores, that is, small, unsatisfactory subsets of unsatisfactory Klausessen settings for which there is 2011 AI Access Foundation. Examples of such applications include the use of SAT instead of BDDs for unlimited symbolic model verification (McMillan, 2002), automatic predictor detection in abstract refinement works in 2003 (McMillan, Wang & Millan)."}, {"heading": "2. SAT and SMT", "text": "A term is a term of first order composed of function symbols and variables. If a term is a predicate, then it is either an atom or its negation. We call a formula quantifier-free if it does not contain quantifiers, and grounding if it does not contain free variables. A clause is a disjunction of letters and atoms. A letter is either an atom or its negation. We call a formula quantifier-free if it does not contain quantifiers. A clause is a disjunction of letters. A formula is said to be a conjunction of normal form (CNF) if it is a conjunction of clauses. For every non-CNF formula, an equality formula, an equality formula CNF formula can be generated in polynomial time (Tseitin, 1983)."}, {"heading": "2.1 Propositional Satisfiability with the DPLL Algorithm", "text": "Most state-of-the-art SAT methods are further developments of the Davis-Putnam-Longeman-Loveland (DPLL) process (Davis & Putnam, 1960; Davis et al., 1962)."}, {"heading": "1. SatValue Lazy SMT Solver (T -formula \u03d5) {", "text": "In the main loop, the number of decision letters in \u00b5 is literally terminated after this process is called the decision level of l.) In the inner loop, the letters in l are iteratively derived from the current assignment and updated accordingly. (This operation is called decision, l is called the number of decision letters in \u00b5 after this process is called the decision level of l.) In the inner loop, the letters in l are derived iteratively. (The iterative application of the letters l from the current assignment and update of \u00b5 is performed accordingly; this step is repeated until either \u00b5 is satisfied with the letters of l or no more letters can be derived. (The return of sat, conflict and unknown). (The iterative application of the letters in the derivation stage is also called Boolean Constraint Propagation, BCP.) In the first case, DPLL is derived literally."}, {"heading": "2.2 Lazy Techniques for SMT", "text": "The idea underlying each lazy SMT (T) is that (a complete sentence of) is based on the truth (a complete sentence of), (a complete sentence of), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (two), (three), (two), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (six), (six, (six), (six), (six), six, (six), (six), (six), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three, (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), three), (three) (three), (three), (three), (three), (three), (three), (three), (three) (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three), (three)"}, {"heading": "3. Extracting Unsatisfiable Cores", "text": "Without any loss of universality, we shall now consider only formulas in the CNF. In view of an unsatisfactory CNF formula, we shall say that an unsatisfactory CNF formula \u043d is an unsatisfactory core of the (possibly empty) CNF formula \u0432. \"Intuitively, this is a subset of the clauses causing the unsatisfactory values of \u0432. An unsatisfactory core \u0432 is minimal if the formula achieved by removing one of the clauses of \u0432 is satisfactory. A minimum undesirable core is a minimum undesirable core with the smallest possible cardinality."}, {"heading": "3.1 Techniques for Unsatisfiable-Core Extraction in SAT", "text": "In recent years, several algorithms have been proposed for calculating small, minimal or minimal unsatisfactory cores of propositional formulas. In the approach of Zhang and Malik (2003) and Goldberg and Novikov (2003), they are calculated as a by-product of a DPLL-based proof-generation process. The calculated Unsat core is simply a collection of all the original clauses used by the DPLL solver to derive the empty clause by resolution. Generally, the returned core is not minimal, but it can be reduced to a fixed point by iterating the algorithm, calculating the core used for each iteration, whereas the algorithm of Gershman et al. (2008) manipulates the resolution proof to reduce the size of the core by using a minimum iteration of the core, using a fixed point iteration such as Zhang and Malik (2003) to further improve the quality of the results. Oh"}, {"heading": "3.2 Techniques for Unsatisfiable-Core Extraction in SMT", "text": "To the best of our knowledge, there is no literature that explicitly addresses the problem of calculating unsatisfactory cores in SMT 2. However, four SMT solvers (i.e. CVC3, Barrett & Tinelli, 2007, MathSAT, Bruttomesso et al., 2008, Yices, Dutertre & de Moura, 2006 and 2. Except for an earlier short version of this paper (Cimatti, Griggio, & Sebastiani, 2007).Z3, de Moura & Bj\u00f8rner, 2008) support the Unsat core generation3. Below, we describe the underlying approaches that generalize UC propositional extraction techniques. We caution that none of these solvers aims to produce minimal or minimal Unsat cores, nor do anything reduce their size."}, {"heading": "3.2.1 Proof-Based UC Extraction.", "text": "Analogous to the approach of Zhang and Malik (2003), the idea is to analyze the evidence of dissatisfaction backwards and return an unsatisfactory core, which is a collection of the assumptions (i.e. clauses of the original problem) used in the evidence to derive contradiction. 3. To show how the described approaches work, consider this small, unsatisfactory SMT formula (T), where T is LA (Z) (Z): (x = 0) evidentiary force (x = 1) evidentiary force (x = 0)."}, {"heading": "In this case, the unsat core is minimal.", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.2.2 Assumption-Based UC Extraction", "text": "The approach adopted by Yices (Dutertre & de Moura, 2006) and Z3 (de Moura & Bj\u00f8rner, 2008) is an adaptation of the method by Lynce and Marques-Silva (2004): for each clause Ci in the problem definition, a new Boolean \"selection variable Si\" (\u00ac (\u00ac 1) is created; then each Ci is replaced by (Si \u2192 Ci); finally, before starting the search, each Si is forced to be true.Example 2 Let's look again at the formula (1) of Example 1. Under the adopted approach, the conflict clause contains only selection variables, and the unsat core returns is the union of the clauses whose selection clauses appear in such a conflict clause. Example 2 Let's look at the formula (1) of Example 1. Under the adopted approach, each of the 9 input clauses is augmented with an additional variable Si that is invoked at the beginning of the search."}, {"heading": "3.2.3 The CAMUS Approach for Extracting All Minimal UC\u2019s.", "text": "A completely different approach, which aims to generate an exponential amount of MCS's during a production phase before the authors make an explanation, is presented by Liffiton and Sakallah (2008) and implemented in the CAMUS (2008) tool. (a) Enumeration of the set M of all Minimal Correction Subsets (MCS's) of the Minimal Correction Subsets (MCS's) of the Minimal Correction Subsets (MCS's). (b) Enumeration of the set U of all Minimal Correction Subsets (MCS's) of the Minimal Correction Subsets (MCS's). This is also performed by a specialized algorithm that can be produced by another algorithm, of M only a Minimal UC with much less effect.It is important to note that both sets M's and U's exponential again."}, {"heading": "4. A Novel Approach to Building Unsatisfiable Cores in SMT", "text": "We present a novel approach, the so-called Lemma Lifting approach, in which the unsatisfactory core is calculated a posteriori after the execution of the SMT solver, only if the formula T-unsatisfactory has been found, using an external (and possibly optimized) propositional Unsat core extractor."}, {"heading": "4.1 The Main Ideas", "text": "In the following, we shall assume that a lazy SMT (T) procedure is conducted over a T-lemmas (T-lemmas). (D-lemmas are T-lemmas are T-lemmas, both theory conflicts and theory conflict clauses (Nieuwenhuis et al., 2006) (see \u00a7 2.2), the T-lemmas are those used by the T-lemmas to calculate the mixed Boolean + theory conflict clause, including the initial theory conflict clause and the theory deduction clauses. (D-lemmas)."}, {"heading": "4.2 Extracting SMT Cores by Lifting Theory Lemmas", "text": "The main idea is that if the theory used in the SMT search is converted into Boolean clauses, the unsaturated core can be extracted by a purely propositional core extractor. Therefore, we call this technique the lazy SMT method presented in Figure 4. T -Unsat Core receives as input a set of clauses that can be extracted from a purely propositional core extractor... \"Cn,\" and it refers to it as a lazy SMT tool (T) instructed to store somewhere the T lemmas achieved by clause 8 T 2P (Fi) by resolving clause T 2P (Di) with clauses in T 2P (T \u2212 1j = 1 Fj)."}, {"heading": "4.3 Discussion", "text": "This year, it's come to the point where it's never been as good as this year, \"he said.\" We've never lost as much time as this year, \"he said."}, {"heading": "5. Empirical Evaluation", "text": "We have implemented the approach within the MathSAT system (Bruttomesso et al., 2008). MathSAT has been extended with an interface for external Boolean unsatisfactory core extractors (UCE) to exchange Boolean formulas and relative cores in the form of files in DIMACS format. (No change was needed for storing T-lemmas, as MathSAT can already permanently learn all of them.) We have tried eight different external UCEs, namely Amuse (Oh et al., 2004), PicoSAT (Biere, 2008), Eureka and al, MiniUnsat (van Maaren & Wieringa, 2008), MUP (SMU, 2005), SMU."}, {"heading": "5.1 Costs and Effectiveness of Unsat-Core Extraction Using PicoSAT", "text": "This year is the highest in the history of the country."}, {"heading": "5.2 Impact on Costs and Effectiveness Using Different Boolean Unsat Core Extractors", "text": "In this second part of our experimental evaluation, we compare the results we have achieved using different UCE's in terms of cost and effectiveness in reducing the size of the core. We show that depending on the UCE used, it is possible to significantly reduce the size of the cores and replace core quality for the efficiency of execution (and vice versa) without any implementation effort. We compare our basic configuration MathSAT + PicoSAT, against six other configurations, each with different propositional UCE. The results are shown in Figures 8-9. The first column shows the absolute reduction in the size carried out by each tool (as in Figure 6). The second column shows core ratios that compare each configuration with PicoSAT (as in Figure 7, with points below 1.00, which means better performance of the current configuration). Finally, we compare the scatter plots in the third column the execution times (picoSAT always on the axis)."}, {"heading": "6. Conclusions", "text": "We have presented a novel approach to the generation of small unsatisfactory cores in SMT, which calculates them a posteriori, using an external propositional Unsat core extractor. The technique is very simple in concept, easy to implement and update, and benefits from all the advances in propositional Unsat core computation free of charge. Our experimental results have shown that by using different core extractors it is possible to significantly reduce the size of the cores and swap core quality for execution speed (and vice versa) without any implementation effort. As a by-product, we have also produced a revealing evaluation of the most important Boolean Unsat core generation tools currently available."}, {"heading": "Acknowledgments", "text": "We would like to thank Mark Liffiton for his help with the CAMUS tool. We also thank the anonymous arbitrators for their helpful suggestions. Griggio is partially supported by the FP7 / 2007-2013 of the European Community under the Marie Curie FP7 - PCOFUND-GA-2008-226070 \"progetto Trentino,\" project adaptation. R. Sebastiani is partially supported by the SRC within the framework of the GRC Custom Research Project 2009-TJ1880 WOLFLING."}], "references": [{"title": "Efficient Generation of Unsatisfiability Proofs and Cores in SAT", "author": ["R. A\u015b\u0131n", "R. Nieuwenhuis", "A. Oliveras", "E. Rod\u0155\u0131guez Carbonell"], "venue": "Proceedings of LPAR\u201908,", "citeRegEx": "A\u015b\u0131n et al\\.,? \\Q2008\\E", "shortCiteRegEx": "A\u015b\u0131n et al\\.", "year": 2008}, {"title": "A SAT Based Approach for Solving Formulas over Boolean and Linear Mathematical Propositions", "author": ["A. lowicz", "R. Sebastiani"], "venue": "In Proc. CADE\u20192002.,", "citeRegEx": "lowicz and Sebastiani,? \\Q2002\\E", "shortCiteRegEx": "lowicz and Sebastiani", "year": 2002}, {"title": "Splitting on Demand in SAT Modulo Theories", "author": ["C. Barrett", "R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "LPAR, Vol. 4246 of LNCS,", "citeRegEx": "Barrett et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2006}, {"title": "Checking Satisfiability of First-Order Formulas by Incremental Translation to SAT", "author": ["C.W. Barrett", "D.L. Dill", "A. Stump"], "venue": "Computer Aided Verification, 14th International Conference,", "citeRegEx": "Barrett et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2002}, {"title": "Satisfiability modulo theories", "author": ["C.W. Barrett", "R. Sebastiani", "S.A. Seshia", "C. Tinelli"], "venue": null, "citeRegEx": "Barrett et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2009}, {"title": "Picosat essentials", "author": ["A. Biere"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation (JSAT),", "citeRegEx": "Biere,? \\Q2008\\E", "shortCiteRegEx": "Biere", "year": 2008}, {"title": "The MathSAT 4 SMT Solver", "author": ["R. Bruttomesso", "A. Cimatti", "A. Franz\u00e9n", "A. Griggio", "R. Sebastiani"], "venue": "CAV, Vol. 5123 of LNCS,", "citeRegEx": "Bruttomesso et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bruttomesso et al\\.", "year": 2008}, {"title": "An abstraction-based decision procedure for bit-vector arithmetic", "author": ["R.E. Bryant", "D. Kroening", "J. Ouaknine", "S.A. Seshia", "O. Strichman", "B. Brady"], "venue": "Int. J. Softw. Tools Technol. Transf.,", "citeRegEx": "Bryant et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bryant et al\\.", "year": 2009}, {"title": "A Simple and Flexible Way of Computing Small Unsatisfiable Cores in SAT Modulo Theories", "author": ["A. Cimatti", "A. Griggio", "R. Sebastiani"], "venue": "SAT, Vol. 4501 of LNCS,", "citeRegEx": "Cimatti et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Cimatti et al\\.", "year": 2007}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam", "year": 1960}, {"title": "A machine program for theoremproving", "author": ["M. Davis", "G. Logemann", "D.W. Loveland"], "venue": "Commun. ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A Scalable Algorithm for Minimal Unsatisfiable Core Extraction", "author": ["N. Dershowitz", "Z. Hanna", "A. Nadel"], "venue": "In Proceedings of SAT\u201906,", "citeRegEx": "Dershowitz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Dershowitz et al\\.", "year": 2006}, {"title": "A Fast Linear-Arithmetic Solver for DPLL(T)", "author": ["B. Dutertre", "L. de Moura"], "venue": "In Proc. CAV\u201906,", "citeRegEx": "Dutertre and Moura,? \\Q2006\\E", "shortCiteRegEx": "Dutertre and Moura", "year": 2006}, {"title": "A Mathematical Introduction to Logic. Academic Pr", "author": ["H. Enderton"], "venue": null, "citeRegEx": "Enderton,? \\Q1972\\E", "shortCiteRegEx": "Enderton", "year": 1972}, {"title": "Theorem Proving Using Lazy Proof Explication", "author": ["C. Flanagan", "R. Joshi", "X. Ou", "J.B. Saxe"], "venue": "CAV, Vol. 2725 of LNCS,", "citeRegEx": "Flanagan et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Flanagan et al\\.", "year": 2003}, {"title": "An approach for extracting a small unsatisfiable core", "author": ["R. Gershman", "M. Koifman", "O. Strichman"], "venue": "Formal Methods in System Design,", "citeRegEx": "Gershman et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gershman et al\\.", "year": 2008}, {"title": "BDD Based Procedures for a Theory of Equality with Uninterpreted Functions", "author": ["A. Goel", "K. Sajid", "H. Zhou", "A. Aziz", "V. Singhal"], "venue": "CAV, Vol. 1427 of LNCS,", "citeRegEx": "Goel et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Goel et al\\.", "year": 1998}, {"title": "Verification of Proofs of Unsatisfiability for CNF Formulas", "author": ["E.I. Goldberg", "Y. Novikov"], "venue": "In Proceedings of 2003 Design, Automation and Test in Europe Conference and Exposition (DATE", "citeRegEx": "Goldberg and Novikov,? \\Q2003\\E", "shortCiteRegEx": "Goldberg and Novikov", "year": 2003}, {"title": "Proof-guided underapproximation-widening for multi-process systems", "author": ["O. Grumberg", "F. Lerda", "O. Strichman", "M. Theobald"], "venue": "SIGPLAN Not.,", "citeRegEx": "Grumberg et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Grumberg et al\\.", "year": 2005}, {"title": "MUP: a minimal unsatisfiability prover", "author": ["J. Huang"], "venue": "In Proceedings of ASP-DAC", "citeRegEx": "Huang,? \\Q2005\\E", "shortCiteRegEx": "Huang", "year": 2005}, {"title": "Algortithms for Computing Minimal Unsatisfiable Subsets of Constraints", "author": ["M. Liffiton", "K. Sakallah"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Liffiton and Sakallah,? \\Q2008\\E", "shortCiteRegEx": "Liffiton and Sakallah", "year": 2008}, {"title": "On Computing Minimum Unsatisfiable Cores", "author": ["I. Lynce", "J.P. Marques-Silva"], "venue": "In SAT 2004 - The Seventh International Conference on Theory and Applications of Satisfiability Testing,", "citeRegEx": "Lynce and Marques.Silva,? \\Q2004\\E", "shortCiteRegEx": "Lynce and Marques.Silva", "year": 2004}, {"title": "GRASP - A new Search Algorithm for Satisfiability", "author": ["J.P. Marques-Silva", "K.A. Sakallah"], "venue": "In Proc. ICCAD\u201996", "citeRegEx": "Marques.Silva and Sakallah,? \\Q1996\\E", "shortCiteRegEx": "Marques.Silva and Sakallah", "year": 1996}, {"title": "Applying SAT Methods in Unbounded Symbolic Model Checking", "author": ["K.L. McMillan"], "venue": "Proceedings of CAV\u201902,", "citeRegEx": "McMillan,? \\Q2002\\E", "shortCiteRegEx": "McMillan", "year": 2002}, {"title": "Automatic abstraction without counterexamples", "author": ["K.L. McMillan", "N. Amla"], "venue": "Proceedings of TACAS\u201903,", "citeRegEx": "McMillan and Amla,? \\Q2003\\E", "shortCiteRegEx": "McMillan and Amla", "year": 2003}, {"title": "A Branch-and-Bound Algorithm for Extracting Smallest Minimal Unsatisfiable Formulas", "author": ["M.N. Mneimneh", "I. Lynce", "Z.S. Andraus", "J.P. Marques-Silva", "K.A. Sakallah"], "venue": "In Proc. SAT\u201905,", "citeRegEx": "Mneimneh et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Mneimneh et al\\.", "year": 2005}, {"title": "Boosting Minimal Unsatisfiable Core Extraction", "author": ["A. Nadel"], "venue": "Proceedings of the 10th International Conference on Formal Methods in Computer-Aided Design", "citeRegEx": "Nadel,? \\Q2010\\E", "shortCiteRegEx": "Nadel", "year": 2010}, {"title": "Solving SAT and SAT Modulo Theories: From an abstract Davis\u2013Putnam\u2013Logemann\u2013Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "J. ACM,", "citeRegEx": "Nieuwenhuis et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "Amuse: A Minimally-Unsatisfiable Subformula Extractor", "author": ["Y. Oh", "M.N. Mneimneh", "Z.S. Andraus", "K.A. Sakallah", "I.L. Markov"], "venue": "In Proceedings of DAC\u201904. ACM/IEEE", "citeRegEx": "Oh et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Oh et al\\.", "year": 2004}, {"title": "The Satisfiability Modulo Theories Library (SMT-LIB). www.SMT-LIB.org", "author": ["S. Ranise", "C. Tinelli"], "venue": null, "citeRegEx": "Ranise and Tinelli,? \\Q2006\\E", "shortCiteRegEx": "Ranise and Tinelli", "year": 2006}, {"title": "Lazy Satisfiability Modulo Theories", "author": ["R. Sebastiani"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation, JSAT,", "citeRegEx": "Sebastiani,? \\Q2007\\E", "shortCiteRegEx": "Sebastiani", "year": 2007}, {"title": "Deciding Separation Formulas with SAT", "author": ["O. Strichman", "S.A. Seshia", "R.E. Bryant"], "venue": "CAV, Vol. 2404 of LNCS,", "citeRegEx": "Strichman et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Strichman et al\\.", "year": 2002}, {"title": "Using unsatisfiable cores to debug multiple design errors", "author": ["A. Suelflow", "G. Fey", "R. Bloem", "R. Drechsler"], "venue": "In Proceedings of GLSVLSI\u201908,", "citeRegEx": "Suelflow et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Suelflow et al\\.", "year": 2008}, {"title": "On the complexity of derivation in propositional calculus. Automation of Reasoning: Classical Papers in Computational Logic 1967-1970Studies in Constructive Mathematics and Mathematical Logic, Part", "author": ["G.S. Tseitin"], "venue": null, "citeRegEx": "Tseitin,? \\Q1983\\E", "shortCiteRegEx": "Tseitin", "year": 1983}, {"title": "Finding Guaranteed MUSes Fast", "author": ["H. van Maaren", "S. Wieringa"], "venue": "In SAT,", "citeRegEx": "Maaren and Wieringa,? \\Q2008\\E", "shortCiteRegEx": "Maaren and Wieringa", "year": 2008}, {"title": "Hybrid CEGAR: combining variable hiding and predicate abstraction", "author": ["C. Wang", "H. Kim", "A. Gupta"], "venue": "In Proceedings of ICCAD\u201907,", "citeRegEx": "Wang et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2007}, {"title": "Extracting Minimum Unsatisfiable Cores with a Greedy Genetic Algorithm", "author": ["J. Zhang", "S. Li", "S. Shen"], "venue": "In Proceedings of ACAI,", "citeRegEx": "Zhang et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2006}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.H. Moskewicz", "S. Malik"], "venue": "In Proceedings of ICCAD", "citeRegEx": "Zhang et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}, {"title": "The quest for efficient boolean satisfiability solvers", "author": ["L. Zhang", "S. Malik"], "venue": "CADE, Vol. 2392 of LNCS,", "citeRegEx": "Zhang and Malik,? \\Q2002\\E", "shortCiteRegEx": "Zhang and Malik", "year": 2002}, {"title": "Extracting Small Unsatisfiable Cores from Unsatisfiable Boolean Formulas", "author": ["L. Zhang", "S. Malik"], "venue": "In Proceedings of 6th International Conference on Theory and Applications of Satisfiability Testing (SAT2003)", "citeRegEx": "Zhang and Malik,? \\Q2003\\E", "shortCiteRegEx": "Zhang and Malik", "year": 2003}], "referenceMentions": [{"referenceID": 23, "context": "Examples of such applications include use of SAT instead of BDDs for unbounded symbolic model checking (McMillan, 2002), automatic predicate discovery in abstraction refinement frameworks (McMillan & Amla, 2003; Wang, Kim, & Gupta, 2007), decision procedures (Bryant, Kroening, Ouaknine, Seshia, Strichman, & Brady, 2009), under-approximation and refinement in the context of bounded model checking of multi-threaded systems (Grumberg, Lerda, Strichman, & Theobald, 2005), debugging of design errors in circuits (Suelflow, Fey, Bloem, & Drechsler, 2008).", "startOffset": 103, "endOffset": 119}, {"referenceID": 19, "context": "For this reason, the problem of finding small unsat cores in SAT has been addressed by many authors in the recent years (Zhang & Malik, 2003; Goldberg & Novikov, 2003; Lynce & Marques-Silva, 2004; Oh, Mneimneh, Andraus, Sakallah, & Markov, 2004; Mneimneh, Lynce, Andraus, Marques-Silva, & Sakallah, 2005; Huang, 2005; Dershowitz, Hanna, & Nadel, 2006; Zhang, Li, & Shen, 2006; Biere, 2008; Gershman, Koifman, & Strichman, 2008; van Maaren & Wieringa, 2008; A\u015b\u0131n, Nieuwenhuis, Oliveras, & Rod\u0155\u0131guez Carbonell, 2008; Nadel, 2010).", "startOffset": 120, "endOffset": 527}, {"referenceID": 5, "context": "For this reason, the problem of finding small unsat cores in SAT has been addressed by many authors in the recent years (Zhang & Malik, 2003; Goldberg & Novikov, 2003; Lynce & Marques-Silva, 2004; Oh, Mneimneh, Andraus, Sakallah, & Markov, 2004; Mneimneh, Lynce, Andraus, Marques-Silva, & Sakallah, 2005; Huang, 2005; Dershowitz, Hanna, & Nadel, 2006; Zhang, Li, & Shen, 2006; Biere, 2008; Gershman, Koifman, & Strichman, 2008; van Maaren & Wieringa, 2008; A\u015b\u0131n, Nieuwenhuis, Oliveras, & Rod\u0155\u0131guez Carbonell, 2008; Nadel, 2010).", "startOffset": 120, "endOffset": 527}, {"referenceID": 26, "context": "For this reason, the problem of finding small unsat cores in SAT has been addressed by many authors in the recent years (Zhang & Malik, 2003; Goldberg & Novikov, 2003; Lynce & Marques-Silva, 2004; Oh, Mneimneh, Andraus, Sakallah, & Markov, 2004; Mneimneh, Lynce, Andraus, Marques-Silva, & Sakallah, 2005; Huang, 2005; Dershowitz, Hanna, & Nadel, 2006; Zhang, Li, & Shen, 2006; Biere, 2008; Gershman, Koifman, & Strichman, 2008; van Maaren & Wieringa, 2008; A\u015b\u0131n, Nieuwenhuis, Oliveras, & Rod\u0155\u0131guez Carbonell, 2008; Nadel, 2010).", "startOffset": 120, "endOffset": 527}, {"referenceID": 33, "context": "For every non-CNF formula \u03c6, an equisatisfiable CNF formula \u03c8 can be generated in polynomial time (Tseitin, 1983).", "startOffset": 98, "endOffset": 113}, {"referenceID": 13, "context": ", by Enderton (1972). We write \u0393 |= \u03c6 to denote that the formula \u03c6 is a logical consequence of the (possibly infinite) set \u0393 of formulas.", "startOffset": 5, "endOffset": 21}, {"referenceID": 10, "context": "Most state-of-the-art SAT procedures are evolutions of the Davis-Putnam-Longeman-Loveland (DPLL) procedure (Davis & Putnam, 1960; Davis et al., 1962).", "startOffset": 107, "endOffset": 149}, {"referenceID": 10, "context": "Most state-of-the-art SAT procedures are evolutions of the Davis-Putnam-Longeman-Loveland (DPLL) procedure (Davis & Putnam, 1960; Davis et al., 1962). A high-level schema of a modern DPLL engine, adapted from the description given by Zhang and Malik (2002),", "startOffset": 130, "endOffset": 257}, {"referenceID": 38, "context": ", to the work of Zhang and Malik (2002).", "startOffset": 17, "endOffset": 40}, {"referenceID": 10, "context": "The propositional abstraction \u03c6p of the input formula \u03c6 is given as input to a SAT solver based on the DPLL algorithm (Davis et al., 1962; Zhang & Malik, 2002), which either decides that \u03c6p is unsatisfiable, and hence \u03c6 is T -unsatisfiable, or returns a satisfying assignment \u03bcp; in the latter case, P2T (\u03bcp) is given as input to T -solver.", "startOffset": 118, "endOffset": 159}, {"referenceID": 27, "context": "An important variant of this schema (Nieuwenhuis et al., 2006) is that of building a \u201cmixed Boolean+theory conflict clause\u201d, starting from \u00ac\u03b7p and applying the backwardtraversal of the implication graph built by DPLL (Zhang et al.", "startOffset": 36, "endOffset": 62}, {"referenceID": 37, "context": ", 2006) is that of building a \u201cmixed Boolean+theory conflict clause\u201d, starting from \u00ac\u03b7p and applying the backwardtraversal of the implication graph built by DPLL (Zhang et al., 2001), until one of the standard conditions (e.", "startOffset": 162, "endOffset": 182}, {"referenceID": 26, "context": "An important variant of this schema (Nieuwenhuis et al., 2006) is that of building a \u201cmixed Boolean+theory conflict clause\u201d, starting from \u00ac\u03b7p and applying the backwardtraversal of the implication graph built by DPLL (Zhang et al., 2001), until one of the standard conditions (e.g., 1st UIP \u2013 Zhang et al., 2001) is achieved. Other important optimizations are early pruning and theory propagation: the T -solver is invoked also on (the refinement of) an intermediate assignment \u03bc: if it is found T unsatisfiable, then the procedure can backtrack, since no extension of \u03bc can be T -satisfiable; if not, and if the T -solver performs a deduction {l1, . . . , ln} |=T l s.t. {l1, . . . , ln} \u2286 \u03bc, then T 2P(l) can be unit-propagated, and the Boolean abstraction of the T -lemma ( \u2228n i=1 \u00acli \u2228 l) can be learned. The on-line lazy SMT (T ) schema is a coarse description of the procedures underlying all the state-of-the-art lazy SMT (T ) tools like, e.g., BarceLogic, CVC3, MathSAT, Yices, Z3. The interested reader is pointed to, e.g., the work of Nieuwenhuis et al. (2006), Barrett and Tinelli (2007), Bruttomesso et al.", "startOffset": 37, "endOffset": 1071}, {"referenceID": 26, "context": "An important variant of this schema (Nieuwenhuis et al., 2006) is that of building a \u201cmixed Boolean+theory conflict clause\u201d, starting from \u00ac\u03b7p and applying the backwardtraversal of the implication graph built by DPLL (Zhang et al., 2001), until one of the standard conditions (e.g., 1st UIP \u2013 Zhang et al., 2001) is achieved. Other important optimizations are early pruning and theory propagation: the T -solver is invoked also on (the refinement of) an intermediate assignment \u03bc: if it is found T unsatisfiable, then the procedure can backtrack, since no extension of \u03bc can be T -satisfiable; if not, and if the T -solver performs a deduction {l1, . . . , ln} |=T l s.t. {l1, . . . , ln} \u2286 \u03bc, then T 2P(l) can be unit-propagated, and the Boolean abstraction of the T -lemma ( \u2228n i=1 \u00acli \u2228 l) can be learned. The on-line lazy SMT (T ) schema is a coarse description of the procedures underlying all the state-of-the-art lazy SMT (T ) tools like, e.g., BarceLogic, CVC3, MathSAT, Yices, Z3. The interested reader is pointed to, e.g., the work of Nieuwenhuis et al. (2006), Barrett and Tinelli (2007), Bruttomesso et al.", "startOffset": 37, "endOffset": 1099}, {"referenceID": 6, "context": "(2006), Barrett and Tinelli (2007), Bruttomesso et al. (2008), Dutertre and de Moura (2006), and de Moura and Bj\u00f8rner (2008), for details and further references, or to the work of Sebastiani (2007) and Barrett, Sebastiani, Seshia, and Tinelli (2009) for a survey.", "startOffset": 36, "endOffset": 62}, {"referenceID": 6, "context": "(2006), Barrett and Tinelli (2007), Bruttomesso et al. (2008), Dutertre and de Moura (2006), and de Moura and Bj\u00f8rner (2008), for details and further references, or to the work of Sebastiani (2007) and Barrett, Sebastiani, Seshia, and Tinelli (2009) for a survey.", "startOffset": 36, "endOffset": 92}, {"referenceID": 6, "context": "(2006), Barrett and Tinelli (2007), Bruttomesso et al. (2008), Dutertre and de Moura (2006), and de Moura and Bj\u00f8rner (2008), for details and further references, or to the work of Sebastiani (2007) and Barrett, Sebastiani, Seshia, and Tinelli (2009) for a survey.", "startOffset": 36, "endOffset": 125}, {"referenceID": 6, "context": "(2006), Barrett and Tinelli (2007), Bruttomesso et al. (2008), Dutertre and de Moura (2006), and de Moura and Bj\u00f8rner (2008), for details and further references, or to the work of Sebastiani (2007) and Barrett, Sebastiani, Seshia, and Tinelli (2009) for a survey.", "startOffset": 36, "endOffset": 198}, {"referenceID": 6, "context": "(2006), Barrett and Tinelli (2007), Bruttomesso et al. (2008), Dutertre and de Moura (2006), and de Moura and Bj\u00f8rner (2008), for details and further references, or to the work of Sebastiani (2007) and Barrett, Sebastiani, Seshia, and Tinelli (2009) for a survey.", "startOffset": 36, "endOffset": 250}, {"referenceID": 29, "context": "In the approach of Zhang and Malik (2003) and Goldberg and Novikov (2003), they are computed as a byproduct of a DPLL-based proof-generation procedure.", "startOffset": 19, "endOffset": 42}, {"referenceID": 15, "context": "In the approach of Zhang and Malik (2003) and Goldberg and Novikov (2003), they are computed as a byproduct of a DPLL-based proof-generation procedure.", "startOffset": 46, "endOffset": 74}, {"referenceID": 14, "context": "The algorithm of Gershman et al. (2008), instead, manipulates the resolution proof so as to shrink the size of the core, using also a fixpoint iteration as Zhang and Malik (2003) to further enhance the quality of the results.", "startOffset": 17, "endOffset": 40}, {"referenceID": 14, "context": "The algorithm of Gershman et al. (2008), instead, manipulates the resolution proof so as to shrink the size of the core, using also a fixpoint iteration as Zhang and Malik (2003) to further enhance the quality of the results.", "startOffset": 17, "endOffset": 179}, {"referenceID": 14, "context": "The algorithm of Gershman et al. (2008), instead, manipulates the resolution proof so as to shrink the size of the core, using also a fixpoint iteration as Zhang and Malik (2003) to further enhance the quality of the results. Oh et al. (2004) present an algorithm to compute minimal unsat cores.", "startOffset": 17, "endOffset": 243}, {"referenceID": 14, "context": "The algorithm of Gershman et al. (2008), instead, manipulates the resolution proof so as to shrink the size of the core, using also a fixpoint iteration as Zhang and Malik (2003) to further enhance the quality of the results. Oh et al. (2004) present an algorithm to compute minimal unsat cores. The technique is based on modifications of a standard DPLL engine, and works by adding some extra variables (selectors) to the original clauses, and then performing a branch-and-bound algorithm on the modified formula. The procedure presented by Huang (2005) extracts minimal cores using BDD manipulation techniques, removing one clause at a time until the remaining core is minimal.", "startOffset": 17, "endOffset": 555}, {"referenceID": 11, "context": "The construction of a minimal core by Dershowitz et al. (2006) also uses resolution proofs, and it works by iteratively removing from the proof one input clause at a time, until it is no longer possible to prove inconsistency.", "startOffset": 38, "endOffset": 63}, {"referenceID": 11, "context": "The construction of a minimal core by Dershowitz et al. (2006) also uses resolution proofs, and it works by iteratively removing from the proof one input clause at a time, until it is no longer possible to prove inconsistency. When a clause is removed, the resolution proof is modified to prevent future use of that clause. As far as the the computation of minimum unsatisfiable cores is concerned, the algorithm of Lynce and Marques-Silva (2004) searches all the unsat cores of the input problem; this is done by introducing selector variables for the original clauses, and by increasing the search space of the DPLL solver to include also such variables; then, (one of) the unsatisfiable subformulas with the smallest number of selectors assigned to true is returned.", "startOffset": 38, "endOffset": 447}, {"referenceID": 11, "context": "The construction of a minimal core by Dershowitz et al. (2006) also uses resolution proofs, and it works by iteratively removing from the proof one input clause at a time, until it is no longer possible to prove inconsistency. When a clause is removed, the resolution proof is modified to prevent future use of that clause. As far as the the computation of minimum unsatisfiable cores is concerned, the algorithm of Lynce and Marques-Silva (2004) searches all the unsat cores of the input problem; this is done by introducing selector variables for the original clauses, and by increasing the search space of the DPLL solver to include also such variables; then, (one of) the unsatisfiable subformulas with the smallest number of selectors assigned to true is returned. The approach described by Mneimneh et al. (2005) instead is based on a branch-and-bound algorithm that exploits the relation between maximal satisfiability and minimum unsatisfiability.", "startOffset": 38, "endOffset": 819}, {"referenceID": 11, "context": "The construction of a minimal core by Dershowitz et al. (2006) also uses resolution proofs, and it works by iteratively removing from the proof one input clause at a time, until it is no longer possible to prove inconsistency. When a clause is removed, the resolution proof is modified to prevent future use of that clause. As far as the the computation of minimum unsatisfiable cores is concerned, the algorithm of Lynce and Marques-Silva (2004) searches all the unsat cores of the input problem; this is done by introducing selector variables for the original clauses, and by increasing the search space of the DPLL solver to include also such variables; then, (one of) the unsatisfiable subformulas with the smallest number of selectors assigned to true is returned. The approach described by Mneimneh et al. (2005) instead is based on a branch-and-bound algorithm that exploits the relation between maximal satisfiability and minimum unsatisfiability. The same relation is used also by the procedure of Zhang et al. (2006), which is instead based on a genetic algorithm.", "startOffset": 38, "endOffset": 1027}, {"referenceID": 20, "context": "Strictly related with this work, Liffiton and Sakallah (2008) presented a general technique for enumerating all minimal unsatisfiable subsets of a given inconsistent set of constraints, which they implemented in the tool CAMUS.", "startOffset": 33, "endOffset": 62}, {"referenceID": 38, "context": "Similarly to the approach of Zhang and Malik (2003), the idea is to analyze the proof of unsatisfiability backwards, and to return an unsatisfiable core that is a collection of the assumptions (i.", "startOffset": 29, "endOffset": 52}, {"referenceID": 21, "context": "2 Assumption-Based UC Extraction The approach used by Yices (Dutertre & de Moura, 2006) and Z3 (de Moura & Bj\u00f8rner, 2008) is an adaptation of the method by Lynce and Marques-Silva (2004): for each clause Ci in the problem, a new Boolean \u201cselector\u201d variable Si is created; then, each Ci is replaced by (Si \u2192 Ci); finally, before starting the search each Si is forced to true.", "startOffset": 156, "endOffset": 187}, {"referenceID": 37, "context": "The final conflict clause generated by conflict analysis (Zhang et al., 2001) is: 4 \u00acS1 \u2228 \u00acS2 \u2228 \u00acS3 \u2228 \u00acS4 \u2228 \u00acS6 \u2228 \u00acS7 \u2228 \u00acS8, (4)", "startOffset": 57, "endOffset": 77}, {"referenceID": 0, "context": "For a deeper comparison between these two approaches (and some variants of them), we refer the reader to the work of A\u015b\u0131n et al. (2008) and Nadel (2010).", "startOffset": 117, "endOffset": 136}, {"referenceID": 0, "context": "For a deeper comparison between these two approaches (and some variants of them), we refer the reader to the work of A\u015b\u0131n et al. (2008) and Nadel (2010).", "startOffset": 117, "endOffset": 153}, {"referenceID": 20, "context": "A completely different approach, aiming at generating all minimal UC\u2019s of some given inconsistent set of propositional clauses \u03a6, is presented by Liffiton and Sakallah (2008) and implemented in the tool CAMUS.", "startOffset": 146, "endOffset": 175}, {"referenceID": 20, "context": "We refer the reader to the work of Liffiton and Sakallah (2008) for a more detailed explanation of this technique and of its features.", "startOffset": 35, "endOffset": 64}, {"referenceID": 20, "context": "\u201d of the article by Liffiton and Sakallah (2008).", "startOffset": 20, "endOffset": 49}, {"referenceID": 20, "context": ") We understand from Liffiton and Sakallah (2008) that, in order to produce uc1 and uc2, CAMUS enumerates first (not necessarily in this order) the following set of MCS\u2019s:", "startOffset": 21, "endOffset": 50}, {"referenceID": 27, "context": ") In case of mixed Boolean+theory-conflict clauses (Nieuwenhuis et al., 2006) (see \u00a7 2.", "startOffset": 51, "endOffset": 77}, {"referenceID": 27, "context": "The validity of fact (ii) is not affected by this optimization, because only the T -lemmas used during conflict analysis are needed for it to hold (Nieuwenhuis et al., 2006).", "startOffset": 147, "endOffset": 173}, {"referenceID": 25, "context": "uses the lazy theory deduction of Nieuwenhuis et al. (2006). Moreover, it works also if T -lemmas contain new atoms (i.", "startOffset": 34, "endOffset": 60}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case.", "startOffset": 56, "endOffset": 79}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case.", "startOffset": 56, "endOffset": 135}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case. As a side observation, we remark that the technique works also for the per-constraintencoding eager SMT approach of Goel, Sajid, Zhou, Aziz, and Singhal (1998), and Strichman, Seshia, and Bryant (2002).", "startOffset": 56, "endOffset": 350}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case. As a side observation, we remark that the technique works also for the per-constraintencoding eager SMT approach of Goel, Sajid, Zhou, Aziz, and Singhal (1998), and Strichman, Seshia, and Bryant (2002). In the eager SMT approach, the input T -formula \u03c6 is translated into an equi-satisfiable Boolean formula, and a SAT solver is used to check its satisfiability.", "startOffset": 56, "endOffset": 392}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case. As a side observation, we remark that the technique works also for the per-constraintencoding eager SMT approach of Goel, Sajid, Zhou, Aziz, and Singhal (1998), and Strichman, Seshia, and Bryant (2002). In the eager SMT approach, the input T -formula \u03c6 is translated into an equi-satisfiable Boolean formula, and a SAT solver is used to check its satisfiability. With per-constraint-encoding of Goel et al. (1998) and Strichman et al.", "startOffset": 56, "endOffset": 604}, {"referenceID": 14, "context": "atoms that do not appear in \u03c6), as in the approaches of Flanagan et al. (2003), and Barrett, Nieuwenhuis, Oliveras, and Tinelli (2006), since both Facts (ii) and (i) hold also in that case. As a side observation, we remark that the technique works also for the per-constraintencoding eager SMT approach of Goel, Sajid, Zhou, Aziz, and Singhal (1998), and Strichman, Seshia, and Bryant (2002). In the eager SMT approach, the input T -formula \u03c6 is translated into an equi-satisfiable Boolean formula, and a SAT solver is used to check its satisfiability. With per-constraint-encoding of Goel et al. (1998) and Strichman et al. (2002), the resulting Boolean formula is the conjunction of the propositional abstraction \u03c6p of \u03c6 and a formula \u03c6T which is the propositional abstraction of the conjunction of some T -valid clauses.", "startOffset": 56, "endOffset": 632}, {"referenceID": 36, "context": "Notably, this involves also Boolean unsat-core techniques which could be very difficult to adapt to the SMT setting (and to implement within an SMT solver), such as the ones based on genetic algorithms (Zhang et al., 2006).", "startOffset": 202, "endOffset": 222}, {"referenceID": 6, "context": "We implemented the approach within the MathSAT (Bruttomesso et al., 2008) system.", "startOffset": 47, "endOffset": 73}, {"referenceID": 28, "context": ") We have tried eight different external UCEs, namely Amuse (Oh et al., 2004), PicoSAT (Biere, 2008), Eureka (Dershowitz et al.", "startOffset": 60, "endOffset": 77}, {"referenceID": 5, "context": ", 2004), PicoSAT (Biere, 2008), Eureka (Dershowitz et al.", "startOffset": 17, "endOffset": 30}, {"referenceID": 11, "context": ", 2004), PicoSAT (Biere, 2008), Eureka (Dershowitz et al., 2006), MiniUnsat (van Maaren & Wieringa, 2008), MUP (Huang, 2005), Trimmer (Gershman et al.", "startOffset": 39, "endOffset": 64}, {"referenceID": 19, "context": ", 2006), MiniUnsat (van Maaren & Wieringa, 2008), MUP (Huang, 2005), Trimmer (Gershman et al.", "startOffset": 54, "endOffset": 67}, {"referenceID": 15, "context": ", 2006), MiniUnsat (van Maaren & Wieringa, 2008), MUP (Huang, 2005), Trimmer (Gershman et al., 2008), ZChaff (Zhang & Malik, 2003), and the tool proposed by Zhang et al.", "startOffset": 77, "endOffset": 100}, {"referenceID": 5, "context": ", 2004), PicoSAT (Biere, 2008), Eureka (Dershowitz et al., 2006), MiniUnsat (van Maaren & Wieringa, 2008), MUP (Huang, 2005), Trimmer (Gershman et al., 2008), ZChaff (Zhang & Malik, 2003), and the tool proposed by Zhang et al. (2006) (called Genetic here).", "startOffset": 18, "endOffset": 234}, {"referenceID": 28, "context": "We evaluated the six configurations which use, respectively, Amuse (Oh et al., 2004), Genetic (Zhang et al.", "startOffset": 67, "endOffset": 84}, {"referenceID": 36, "context": ", 2004), Genetic (Zhang et al., 2006), Eureka (Dershowitz et al.", "startOffset": 17, "endOffset": 37}, {"referenceID": 11, "context": ", 2006), Eureka (Dershowitz et al., 2006), MiniUnsat (van Maaren & Wieringa, 2008), Trimmer (Gershman et al.", "startOffset": 16, "endOffset": 41}, {"referenceID": 15, "context": ", 2006), MiniUnsat (van Maaren & Wieringa, 2008), Trimmer (Gershman et al., 2008), and ZChaff (Zhang & Malik, 2003), against the baseline configuration, using PicoSAT.", "startOffset": 58, "endOffset": 81}, {"referenceID": 19, "context": "We also compared with MUP (Huang, 2005), but we had to stop the experiments because of memory exhaustion", "startOffset": 26, "endOffset": 39}, {"referenceID": 19, "context": "To this extent, we notice that the performances of MUP (Huang, 2005) and Genetic (Zhang et al.", "startOffset": 55, "endOffset": 68}, {"referenceID": 36, "context": "To this extent, we notice that the performances of MUP (Huang, 2005) and Genetic (Zhang et al., 2006) seem rather poor; PicoSAT (Biere, 2008) is definitely the fastest tool, though the least effective in reducing the size of the final core; on the opposite side, Eureka (Dershowitz et al.", "startOffset": 81, "endOffset": 101}, {"referenceID": 5, "context": ", 2006) seem rather poor; PicoSAT (Biere, 2008) is definitely the fastest tool, though the least effective in reducing the size of the final core; on the opposite side, Eureka (Dershowitz et al.", "startOffset": 34, "endOffset": 47}, {"referenceID": 11, "context": ", 2006) seem rather poor; PicoSAT (Biere, 2008) is definitely the fastest tool, though the least effective in reducing the size of the final core; on the opposite side, Eureka (Dershowitz et al., 2006) is the most effective in this task, but pays a fee in terms of CPU time; Trimmer (Gershman et al.", "startOffset": 176, "endOffset": 201}, {"referenceID": 15, "context": ", 2006) is the most effective in this task, but pays a fee in terms of CPU time; Trimmer (Gershman et al., 2008) represents a good compromise between effectiveness and efficiency.", "startOffset": 89, "endOffset": 112}], "year": 2011, "abstractText": "The problem of finding small unsatisfiable cores for SAT formulas has recently received a lot of interest, mostly for its applications in formal verification. However, propositional logic is often not expressive enough for representing many interesting verification problems, which can be more naturally addressed in the framework of Satisfiability Modulo Theories, SMT. Surprisingly, the problem of finding unsatisfiable cores in SMT has received very little attention in the literature. In this paper we present a novel approach to this problem, called the Lemma-Lifting approach. The main idea is to combine an SMT solver with an external propositional core extractor. The SMT solver produces the theory lemmas found during the search, dynamically lifting the suitable amount of theory information to the Boolean level. The core extractor is then called on the Boolean abstraction of the original SMT problem and of the theory lemmas. This results in an unsatisfiable core for the original SMT problem, once the remaining theory lemmas are removed. The approach is conceptually interesting, and has several advantages in practice. In fact, it is extremely simple to implement and to update, and it can be interfaced with every propositional core extractor in a plug-and-play manner, so as to benefit for free of all unsat-core reduction techniques which have been or will be made available. We have evaluated our algorithm with a very extensive empirical test on SMT-LIB benchmarks, which confirms the validity and potential of this approach. 1. Motivations and Goals In the last decade we have witnessed an impressive advance in the efficiency of SAT techniques, which has brought large and previously-intractable problems at the reach of stateof-the-art SAT solvers. As a consequence, SAT solvers are now a fundamental tool in many industrial-strength applications, including most formal verification design flows for hardware systems, for equivalence, property checking, and ATPG. In particular, one of the most relevant problems in this context, thanks to its many important applications, is that of finding small unsatisfiable cores, that is, small unsatisfiable subsets of unsatisfiable sets of clauses. c \u00a92011 AI Access Foundation. All rights reserved. Cimatti, Griggio, & Sebastiani Examples of such applications include use of SAT instead of BDDs for unbounded symbolic model checking (McMillan, 2002), automatic predicate discovery in abstraction refinement frameworks (McMillan & Amla, 2003; Wang, Kim, & Gupta, 2007), decision procedures (Bryant, Kroening, Ouaknine, Seshia, Strichman, & Brady, 2009), under-approximation and refinement in the context of bounded model checking of multi-threaded systems (Grumberg, Lerda, Strichman, & Theobald, 2005), debugging of design errors in circuits (Suelflow, Fey, Bloem, & Drechsler, 2008). For this reason, the problem of finding small unsat cores in SAT has been addressed by many authors in the recent years (Zhang & Malik, 2003; Goldberg & Novikov, 2003; Lynce & Marques-Silva, 2004; Oh, Mneimneh, Andraus, Sakallah, & Markov, 2004; Mneimneh, Lynce, Andraus, Marques-Silva, & Sakallah, 2005; Huang, 2005; Dershowitz, Hanna, & Nadel, 2006; Zhang, Li, & Shen, 2006; Biere, 2008; Gershman, Koifman, & Strichman, 2008; van Maaren & Wieringa, 2008; A\u015b\u0131n, Nieuwenhuis, Oliveras, & Rod\u0155\u0131guez Carbonell, 2008; Nadel, 2010). The formalism of plain propositional logic, however, is often not suitable or expressive enough for representing many other real-world problems, including the verification of RTL designs, of real-time and hybrid control systems, and the analysis of proof obligations in software verification. Such problems are more naturally expressible as satisfiability problems in decidable first-order theories \u2014Satisfiability Modulo Theories, SMT. Efficient SMT solvers have been developed in the last five years, called lazy SMT solvers, which combine a Conflict-Driven Clause Learning (CDCL) SAT solver based on the DPLL algorithm (Davis & Putnam, 1960; Davis, Logemann, & Loveland, 1962; Marques-Silva & Sakallah, 1996; Zhang & Malik, 2002) \u2014 hereafter simply \u201cDPLL\u201d \u2014 with ad-hoc decision procedures for many theories of interest (see, e.g., Nieuwenhuis, Oliveras, & Tinelli, 2006; Barrett & Tinelli, 2007; Bruttomesso, Cimatti, Franz\u00e9n, Griggio, & Sebastiani, 2008; Dutertre & de Moura, 2006; de Moura & Bj\u00f8rner, 2008). Surprisingly, the problem of finding unsatisfiable cores in SMT has received virtually no attention in the literature. Although some SMT tools do compute unsat cores, this is done either as a byproduct of the more general task of producing proofs, or by modifying the embedded DPLL solver so that to apply basic propositional techniques to produce an unsat core. In particular, we are not aware of any work aiming at producing small unsatisfiable cores in SMT. In this paper we present a novel approach addressing this problem, which we call the Lemma-Lifting approach. The main idea is to combine an SMT solver with an external propositional core extractor. The SMT solver stores and returns the theory lemmas it had to prove in order to refute the input formula; the external core extractor is then called on the Boolean abstraction of the original SMT problem and of the theory lemmas. Our algorithm is based on the following two key observations: i) the theory lemmas discovered by the SMT solver during search are valid clauses in the theory T under consideration, and therefore they do not affect the satisfiability of a formula in T ; and ii) the conjunction of the original SMT formula with all the theory lemmas is propositionally unsatisfiable. Therefore, the external (Boolean) core extractor finds an unsatisfiable core for (the Boolean abstraction of) the conjunction of the original formula and the theory lemmas, which can then be refined back into a subset of the original clauses by simply removing from it (the Boolean abstractions of) all theory lemmas. The result is an unsatisfiable core of the original SMT problem.", "creator": "TeX"}}}