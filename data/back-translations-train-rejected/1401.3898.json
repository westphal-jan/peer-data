{"id": "1401.3898", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "First-Order Stable Model Semantics and First-Order Loop Formulas", "abstract": "Lin and Zhaos theorem on loop formulas states that in the propositional case the stable model semantics of a logic program can be completely characterized by propositional loop formulas, but this result does not fully carry over to the first-order case. We investigate the precise relationship between the first-order stable model semantics and first-order loop formulas, and study conditions under which the former can be represented by the latter. In order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary first-order theory. Based on the studied relationship we extend the syntax of a logic program with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable models using first-order reasoners. Such programs can be viewed as a special class of first-order theories under the stable model semantics, which yields more succinct loop formulas than the general language due to their restricted syntax.", "histories": [["v1", "Thu, 16 Jan 2014 05:18:54 GMT  (541kb)", "http://arxiv.org/abs/1401.3898v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["joohyung lee", "yunsong meng"], "accepted": false, "id": "1401.3898"}, "pdf": {"name": "1401.3898.pdf", "metadata": {"source": "CRF", "title": "First-Order Stable Model Semantics and First-Order Loop Formulas", "authors": ["Joohyung Lee", "Yunsong Meng"], "emails": ["joolee@asu.edu", "Yunsong.Meng@asu.edu"], "sections": [{"heading": "1. Introduction", "text": "However, this idea has proved to be broadly applicable by relating stable semantics to propositional logic, and it has led to an efficient method of answering using SAT solvers. Since the original invention of loop formulas for nondisjunctive programs by Lin and Zhao (2004), the theory has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs that contain classical negation (Lee, 2005; Lee, Lifschitz, 2010), arbitrary formulas."}, {"heading": "2. Review of the First-Order Stable Model Semantics", "text": "This review follows an essay by Ferraris et al. (2011), which continues a conference paper by the same authors (Ferraris et al., 2007), distinguishing between intense and non-intensive predictors; a formula is defined as in first-order logic; a signature consists of function constants and predicate constants; functional constants of species 0 are referred to as object constants; we assume that the following set of primitive propositional connectives and quantifiers is defined; we distinguish between atoms and atomic forms as follows: an atom of a predicate constant signature is an abbreviation of F \u2192 a symbol of generosity."}, {"heading": "3. First-Order Loop Formulas and Herbrand Models", "text": "We review the definition given by Chen et al. (2006) of a first order loop formula for a non-disjunctive program and extend it to a disjunctive program and an arbitrary first order proposition."}, {"heading": "3.1 Review of First-Order Loop Formulas Defined by Chen et al. (2006)", "text": "We call a formula negative if every occurrence of every predicate constant in it (4) is in normal form. (4) An equality t1 = t2 is also negative because it does not contain any predicate constant. (4) A nondisjunctive program is a finite set of rules of formal A-shaped B-shaped B-shaped, (4) 4. Remember that a Herbrand interpretation of a signature (which contains at least one constant) is an interpretation of such constants that its universe represents the totality of all the basic concepts of the n-shaped B-shaped, and each soil concept represents itself. A Herbrand interpretation can be identified with the amount of soil atoms to which it is the value true.where A is an atom, B is a series of atoms, and N is a negative formula. The rules can be functional constants of positive arity.5We will say that a non-disjunctive program in normal form, if all rules are a distinction (4)."}, {"heading": "3.2 Extension to Disjunctive Programs", "text": "A disjunctive program is a finite set of rules of the formA \u2190 B, N, (10), where A and B are sets of atoms, and N is a negative formula. Similar to a non-disjunctive program, we say that a disjunctive program is in normal form if all rules q (10) in it contain all atoms in the form p (x), where x is a list of different variables. Let's be a disjunctive program and let the formula Y be a normal form of Y. Faced with a finite set of q of atoms, let's first rename variables in the form p (x), so that no variables occur in formula x. The (first order) external support formula of Y for the formula Y for the normal form of Y (Y) is the disjunctive Y formula for the function that is the function of Y formulas."}, {"heading": "3.3 Extension to Arbitrary Sentences", "text": "In this section we expand the definition of a first order formula to a first order formula whose negation is close to ES. \u2022 We define the formula NESF (Y) as a first order formula and Y as a finite formula. \u2022 We assume that in F no variables occur in Y by renaming variables. \u2022 NES pi (T) (Y) (Y) (pi) (T) (S) is a first order formula and Y is a finite formula. \u2022 NES t1 = t2 (Y) = (Y); \u2022 NES pi (F) (G) = NESF (Y)."}, {"heading": "4. Comparing First-Order Stable Model Semantics and First-Order Loop", "text": "Formulas The theorems in the previous section were limited to Herbrand stable models. This section extends the results to include non-Herbrand stable models and to compare the idea of loop formulas with SM by reformulating the latter in the style of loop formulas."}, {"heading": "4.1 Loop Formulas Relative to an Interpretation", "text": "I remember that I have satisfied all the primary formulas (9), but it is not a stable solution that relates to the individual models of the respective theory. (It is not that we apply the individual models of the respective theory. (It is not that the individual models of the individual models depend on the respective theory. (It is not that) that the individual models of the individual models are disconnected from the respective theory. (It is not that) that the individual models of the individual models depend on the different formulas of the atoms. (It is not that) that the different formulas themselves can occur in the absence of the functional constants of the positive activity. (It is that the interpretation of the universe is the totality of all integrators, and pI contains all integrators. (9) but it is not that the interpretation of the universe is the totality of all integrators. (It is that all integrators that contain all integrators)."}, {"heading": "4.2 A Reformulation of SM", "text": "As before, the answer to the question of whether it is a \"yes\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no.\" The answer to the question \"no\" to a \"no\" to a \"no\" to a \"no\" to a \"no.\" The answer \"no\" to a \"no\" to a \"no\" to a \"no.\" The answer to the question \"no\" to \"no\" to \"no\" to \"no.\" The answer \"no\" to \"no\" to \"no.\" The answer \"no\" to \"no.\" The answer \"no\" to \"no.\" The answer \"no.\" The answer. \"No.\" The answer. \"The answer.\" No. \"The answer. The answer. The answer.\" No. \"The answer. The answer. The answer.\" No. \"The answer. The answer. The answer. The answer. The answer. The answer."}, {"heading": "2. Formula in Theorem 3 (b):", "text": "F & # 246; (u & # 223;) is f & # 252; f & # 252; r (u1, u2, u3) \u2264 (p & # 246;, q, r & # 246; m & # 246; (& # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; (& # 10; & # 10; & # 10; & # 10;)."}, {"heading": "5. Representing First-Order Stable Model Semantics by First-Order", "text": "Loop formulas In the previous section, we pointed out that loop formulas can be used to check the stability of the model when a set within a model is limited. In this section, we present some syntactical equivalents of the loop formulas."}, {"heading": "5.1 Bounded Formulas", "text": "We say that a corrected formula F is limited if each infinite path in the first order dependency curve has only an infinite number of vertices. If F is limited, then clearly each loop of F. Again, the definition is extended to an uncorrected formula by first paraphrasing it as a corrected formula, and it also applies to a program by referring to its FOL representation. One might wonder whether the syntactic notion of freedom guarantees the semantic notion of freedom: that is, if a formula is limited, then it is limited by any interpretation. However, the following example shows us that this is generally not the case. Example 7 Consider the FOL representation F of the following legislative period (a): q (x) q (x) q (x), p (b), (28) and an interpretation I whose universe | I | is the totality of all non-negative integers, aI =.bt. I = qt. and I = (I) q( I)."}, {"heading": "5.1.1 Bounded Formulas and Clark\u2019s Equational Theory", "text": "On the other hand, such a relation is valid if the interpretation fulfills Clark's theory of equations (1978).Clark's theory of equations of a signature is any (32) theory of equations of a signature (32) designated by CET\u03c3 is the union of the universal closures of the following formulas. (., xm) 6 = q (y1,., yn (.), (29) for all function constants f, g, f (31),., xn) = f (y1,., yn (x1 = y1). (xn = yn), (30) for all function constants f of the species. (0, sent = x,. where t is a term containing the variable x.Proposition 6. If a reflected formula F of a signature is limited, then F is a limited signature."}, {"heading": "5.1.2 Bounded Formulas and Normal Form", "text": "The following theory follows from Theorem 2, Proposition 8 and Proposition 9.12. They actually satisfy a stronger condition called the \"finite proposition.\" \"The syntactic notion of limitation (\" finite proposition \") ensures the semantic notion of limitation (\" finite proposition \"). We say that a formula is in normal form when every strictly positive occurrence of an atom is limited by the form p (x), where x is a list of different variables. It is clear that any formula can be converted into a normal form using equality. Proposition 9 If a rectified proposition F is converted into normal form, then for any interpretation I am a model of {LFF (Y) | Y a finite loop of the first order of F} iff I is a model of {LFF (Y) | Y is a model of {LFF (Y).\" The following theorem follows from Theorem 2, Proposition 8 and Proposition 9.12. They actually fulfill a stronger condition. \""}, {"heading": "5.1.3 Decidability of Boundedness and Finite Complete Set of Loops", "text": "In general, the test whether F is limited is not decidable, but it becomes decidable if F does not contain any functional constants of positive nature. The same applies to the test whether F is atom-tight. Sentence 10 If F does not contain any functional constants of positive nature, (c) the test whether F is limited is not decidable. (d) The test whether F is atom-tight is not decidable.The proof for proposition 10 (c) is based on the following fact, and the simple extension of theorem 2 by Chen et al. (2006) to formulas of the first order is decidable. (d) The test whether F is atom-tight is decidable."}, {"heading": "5.2 Semi-Safe Formulas", "text": "In fact, it is a way in which people are able to determine for themselves how they want to behave."}, {"heading": "6. Programs with Explicit Quantifiers", "text": "The question that arises is to what extent it is actually a question, in which it is a question, to what extent it is a question, to what extent it is a question, to what extent it is actually a question, to what extent it is actually a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question or not a question, to what it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is not a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question is a question, whether it is a question, whether it is a question, whether it is, whether it is, whether it is, whether it is, whether it is a question, whether it is, whether it is, whether it is, whether it is, whether it is, whether it is, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is, whether it is, whether it is,"}, {"heading": "7. Extension to Allow Extensional Predicates", "text": "The definition of a stable SM [F] -model in the journal SM [F] (2011), in which we all set to work, is more general than the definition of the SM-model [F]. (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (F). (. (F). (F). (F). (. (F). (. (F). (. (. (F). (F). (. (F). (. (F). (. (F). (. (. (F). (. (. (. (F).). (.). (.). (F. (.). (.). (.). (.). (F. (. (. (.). (.). (.). (.).). (."}, {"heading": "8. Related Work", "text": "The notion of a limited program is related to the notion of an infinitely recursive program, which Bonatti (2004) examined, in which a different definition of a dependency diagram was considered. Atomic dependence on a non-disjunctural basic program, defined by Bonatti, is a guided graph in which there is only a limited number of atoms, and the edges proceed from atoms that have penetrated the body of each rule, including those that have penetrated the negative body. A program is called infinitely recursive when for each atom there are only an infinite number of atoms that can be reached by it. It is clear that any recursive program is comprehensively recursive, but does not hold the confrontation."}, {"heading": "9. Conclusion", "text": "In this paper, first-order loop formulas are placed in the context of first-order reasoning and examined how they relate to the semantics of stable first-order models; the similarities and mismatches found in this paper provide useful insights into first-order reasoning with stable models; in the future, further constraints will be found that make first-order stable model thinking efficiently decideable and predictable, such as the conditions imposed in \"finite\" programs (Bonatti, 2004), in which first-order ontology predicts with extensive predicates are identified; and based on the studied relationship between first-order stable model semantics and first-order loop formulas, further constraints on knowledge can be found."}, {"heading": "Acknowledgments", "text": "We thank Joseph Babb, Michael Bartholomew, Piero Bonatti, Vladimir Lifschitz and Ravi Palla for useful discussions and the anonymous referees for their useful comments. In part, the authors were supported by the National Science Foundation under grant IIS-0916116 and the IARPA SCIL program."}, {"heading": "Appendix A. Proofs", "text": "The proofs for theorem 2 are presented in the order of dependencies. Theorem 3 is the main theorem. The proof for theorem 2 uses theorem 3. The proofs for theorems 4 and 5 follow from theorem 2. The proof for Lemma 1 follows from theorem 13. In the following, unless noted otherwise, F is a corrected first-order theorem, p is the list of different predicate constants p1,..., pn occurring in F, the symbols u, v are lists of different predicate variables of equal length as p, and the symbols q, r are lists of different predicate names of same length as p."}, {"heading": "A.1 Proof of Theorem 3", "text": "Theorem 3 For each corrected theorem F, the following propositions are equivalent: (a) SM [F]; (b) F-shaped (u-shaped), (u-shaped), (u-shaped (u-shaped), (u-shaped), (u-shaped (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped), (u-shaped) and (u-shaped)."}, {"heading": "A.1.1 Proof of Equivalence between (a) and (b) of Theorem 3", "text": "Suffice it to show that u (u < p * F * (u)) v (v \u2264 p * Non-empty (v) and NSESF (v) are equivalent. \u2022 From left to right: Take u so that u < p * F * (u). Let v be the list of Pi (yi) not empty (yi) so that v follows \u2264 p. \u2022 From u < p it follows that pi (x) is not empty (x), followed by i xivi (xi) so that nonempty (v) follows. \u2022 After Lemma 5 NSESF (v) follows u < p and F (u). From right to left: Take v so that v \u2264 p \u00b2 is not empty (v) and NSESF (v) is not empty (v)."}, {"heading": "A.1.2 Proof of Proposition 3", "text": "I have been involved in a number of high-profile cases in recent years, including one in which I have been involved in a number of high-profile cases in which I have been involved, and I have been involved in a number of high-profile cases in which I have been involved, I have been involved in a number of high-profile cases in which I have been involved, I have been involved in a number of high-profile cases in which I have been involved, I have been involved, I have been involved, I have been involved, I have been involved, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases, I have been involved in a number of high-profile cases and I have been involved in a number of high-profile cases."}, {"heading": "A.1.3 Proof of Proposition 4", "text": "Sentence 4 Let q be a list of predicate names that correspond to p, and let Y have a series of atoms in the dependency diagram of F w.r.t. I make such a list. (Then) Take I | = Nonempty (q), (v \u2264 q), (LoopF (v) \u2192 EF (v, q))), iff Y an unlimited group of F w.r.t. I.Proof. From left to right: AssumeI | = Nonempty (q), (q), (v \u2264 q), LoopF (v, q)). (46) Since I | = Nonempty (q), it is clear that Y is not empty. Take a subset Z of Y that is a loop of F w.r.t. I is that a subset of F w.r.t. I."}, {"heading": "A.1.4 Proof of Proposition 5", "text": "Proposition 5 For each negative formula F, the formula NSESF (u) \u2194 Fis is logically validated. Evidence. The proof is directly derived from the following two terms, which can be proved by induction. Lemma 8 For each formula F, NSESF (u) \u2192 Fis is logically validated. Lemma 9 Let F be a formula, and let SF be the amount of Pi (t), which has a strictly positive occurrence in F. FormulaF formulasPi (t) \u0441SF-z \u00ac vi (t) \u2192 NSESF (v) (47) is logically valid, where z is the tupel of variables in t, which are not free in F."}, {"heading": "A.1.5 Proof of Equivalence between (b) and (c) of Theorem 3", "text": "Lemma 10 Let F be a rectified formula, let S + F be the set of all atoms pi (t), which a (t), that a), we (t), we (t), we (t), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n), S (n, S (n), S (n, S, S (n, S, S, S n, S (n, S, S, S n, S (n), S (n), S (n, S, S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n, S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n, S (n), S (n), S (n, S (n), S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n, S (n, S (n), S (n), S (n, S (n), S (n, S (n), S (n), S (n, S (n), S (n), S (n, S (n), S (n, S (n, S, S, S, S, S (n), S (n), S (n), S (n, S (n), S (n, S"}, {"heading": "Proof of Equivalence Between (b) and (c) of Theorem 3", "text": "From (b) to (c): It follows that the formula Ext-LoopF (u) \u2192 Nonempty (u) is logically valid. From (c) to (b): Suppose that there is v (v \u2264 p) Ext-LoopF (v) \u2192 \u00ac NSESF (v)). Let us take any u so that u \u2264 p and Nonempty (u). According to Lemma 12, Nonempty (u) follows that v exists so that v \u2264 u-Ext-LoopF (v). It is clear that v \u2264 p follows from v \u2264 u and u \u2264 p. It follows from the assumption that \u00ac NSESF (v) exists. Then from Lemma 11, \u00ac NSESF (u) follows from v \u2264 u and \u00ac EF (v, u)."}, {"heading": "A.2 Proof of Theorem 2", "text": "It is as if it is an infinite list of names depending on F w.r.t. It is as if it were from left to right: AssumeI (= q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q) p-loopF (q)."}, {"heading": "A.3 Proof of Proposition 6", "text": "Proposition 6: If a rectified formula F of a signature for t1 and t2 of a signature is limited, then F = > dependency is limited. < any interpretation of vocabulary in t1 and t2 to object names such as (t1) I = (t2) I, and (b) to any variable x in t1 or t2, 1965), when applied to t1 and t2, results in a general unifier (mgu) of t1 and t2 to such object names as (a) t1, and (b) to any variable x in t2, 1965) I = (x2) I.Proof. From the assumptions made by Lemma 5.1 from Kunen's work (1987), t1 and t2 are unifiable."}, {"heading": "A.4 Proof of Proposition 7", "text": "Summary 7 For each corrected sentence F of a signature and for each interpretation I of a signature fulfilling the CET\u03c3, I am a model of the {LFF (Y) | Y is a finite loop of first order F} iff I is a model of the {LFF (Y) | Y is a finite loop of F w.r.t. The proof follows directly from the following fact and Lemma 15.Fakt 1 Let F be a rectified sentence of a signature \u03c3, and let me be an interpretation of the \u03c3. (For each loop of first order Y of each substitution summary summary summary summary summary summary summary summary summary summary summary summary summary summary summary summary summary summary summary"}, {"heading": "A.5 Proof of Proposition 8", "text": "Sentence 8 If a corrected formula F is limited in normal form, then F. The proof follows from the following Lemma.Lemma 16 Let F be a corrected set of a signature \u03c3 in normal form, and let me be an interpretation of \u03c3. For each path < p1 (1), p2 (2),..., pk (UK), pk + 1 (UK + 1) > in the first order dependency graph of F w.r.t I there is a path < p1 (u1), p2 (u2),.., pk (UK), pk + 1 (UK + 1) > in the first order dependency graph of F with a substitution method that maps object variables in ui so that they have object names such as (ui\u03b8) I = i for all i, and u1 is a list of object variables. The proof is similar to the proof for Lemma that the variables of the normal form are not fulfilled and that we need the variable + 1 of Tj."}, {"heading": "A.6 Proof of Proposition 9", "text": "Proposition 9 If a corrected sentence F is limited in normal form, then for any interpretation I > Y \u2022 a model of {LFF (Y) | Y is a first order finite loop of F} iff I is a model of {LFF (Y) | Y is a finite loop of F w.r.t. I, there is a finite loop Y of F with a substitution, the variables in Y on object names like this Y \u2032 = {pi (T) | pi (T), then for each finite loop Y \u2032 of F w.r.t. I, there is a finite loop Y of F w.r.t. I, the variables in Y on object names like this Y \u2032 = {pi) | pi (T), I = (T).Proof. Let Y \u2032 have a finite loop of F w.r.t. I, without loss of generality there is a path < p2."}, {"heading": "A.7 Proof of Proposition 11", "text": "We will follow in this section and in the next section, the theorem 2 in the work of Chen et al. (2006), which contains some equivalent conditions for a program to have a finite complete series of loops to a disjunctive program and a theorem. Lemma 18 (Chen et al., 2006, Thm. 2) For any formula F that does not contain functional constants of positivity, the following conditions are equivalent: (a) F has a finite complete series of loops. (b) There is a nonnegative integer N that is limited for each loop L of F to the number of variables in L. (c) For each loop L of F and each atom A1 and A2 in L, the variables that occur in A1 are identical to the variables that occur in A2. (d) For each loop L is ground and F."}, {"heading": "A.8 Proof of Proposition 10", "text": "Sentence 10 For each corrected sentence F (which permits functional constants of positive unity), (a) the test as to whether F is limited cannot be decided; (b) the test as to whether F is atom-tight cannot be decided; if F does not contain functional constants of positive unity, (c) the test as to whether F is limited can be decided; (d) the test as to whether F is atom-tight can be decided."}, {"heading": "A.8.1 Proof of Part (a) and (b)", "text": "We show the proof for Part (a) first. The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), the following program \"M\" considered to simulate deterministic Turing machines M.t (s, L, v, [V | R], C) \u2190 t (s, \"[v\" | L], V, R, C + 1) for all instr. < s, v, \"s,\" s, \"s,\" right > t \"(s,\" L, \"[s,\" C) \u2190 t (s), [v, \"L,\" C + 1) for all instr. < s, \"v,\" s, \"s, s,\" s, \"right > t,\" right > t, \"[V,\" C \").s,\" t \"(s,\" S, \"L,\" V, \"C,\" [s \").s,\" x, \"we,\" [\"v,\" x."}, {"heading": "A.8.2 Proof of Part (c)", "text": "In view of the equivalence between (a) and (d) in term 18, it can be checked whether a formula F which does not contain a functional constant of positive nature has a finite complete set of loops by examining a finite number of loops from a finite dependency graph which is decidable. It follows from sentence 11 that the test whether F is limited is decidable."}, {"heading": "A.8.3 Proof of Part (d)", "text": "If F is an atomic formula, then Groundc (F) is the set consisting of all object constants, and possibly a new object constant if F contains no object constants. F has a non-trivial loop and Groundc (F) has a non-trivial loop. To check whether F is atomic tight, we first check whether F is limited, what is decidable. If F is not limited, then F is not atomic tight. Otherwise, checking whether F is atomic tight is the same as checking whether F is limited, what is decidable. If F is not limited, then F is not atomic tight."}, {"heading": "A.9 Proof of Proposition 13", "text": "Lemma 20 Let F be a formula and Y a set of atoms. If no predicate constant occurs in Y (strictly positive in F, then NESF (Y) is equivalent to F, Proposition 13 Let's be a program with quantifiers, then F is the FOL representation of A, and Y is a finite set of atoms. Assuming the formula QES (Y) is equivalent to NESF (Y): \u00ac NESF (Y) is a disjunctive program in normal form, then QES (Y) is also equivalent to ES (Y)."}, {"heading": "A.10 Proof of Proposition 16", "text": "Proposition 16 Let P be an LW-program and let F is the FOL-representation of the set of rules in P. The following conditions are equivalent: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM [F]; (c) I is a P -interpretation that satisfills F and the loop formulas of Y for all loops Y of F w.r.t. I.Given a program, Norm () is a normal form of S [F]; (c) I is a ground program, which was developed by Lin and Wang (2008).The proof of Proposition 16 stems from the following dilemma. We refer readers to the work of Lin and Wang for the definition of ES (\u00b7, \u00b7, \u00b7) defined as and ground ground ground ground ground ground ground ground ground ground ground ground ground ground ground ground."}], "references": [{"title": "Ordered completion for first-order logic programs on finite structures", "author": ["V. Asuncion", "F. Lin", "Y. Zhang", "Y. Zhou"], "venue": "In AAAI,", "citeRegEx": "Asuncion et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Asuncion et al\\.", "year": 2010}, {"title": "Reasoning with infinite stable models", "author": ["P.A. Bonatti"], "venue": "Artificial Intelligence, 156 (1), 75\u2013111.", "citeRegEx": "Bonatti,? 2004", "shortCiteRegEx": "Bonatti", "year": 2004}, {"title": "First-order loop formulas for normal logic programs", "author": ["Y. Chen", "F. Lin", "Y. Wang", "M. Zhang"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Chen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2006}, {"title": "Loop-separable programs and their firstorder definability", "author": ["Y. Chen", "F. Lin", "Y. Zhang", "Y. Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "Chen et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2011}, {"title": "First-order indefinability of answer set programs on finite structures", "author": ["Y. Chen", "Y. Zhang", "Y. Zhou"], "venue": "In AAAI,", "citeRegEx": "Chen et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2010}, {"title": "Negation as failure", "author": ["K. Clark"], "venue": "Gallaire, H., & Minker, J. (Eds.), Logic and Data Bases, pp. 293\u2013322. Plenum Press, New York.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "A semantical framework for hybrid knowledge bases", "author": ["J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde"], "venue": "Knowl. Inf. Syst.,", "citeRegEx": "Bruijn et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bruijn et al\\.", "year": 2010}, {"title": "A generalization of the Lin-Zhao theorem", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Ferraris et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2006}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Ferraris et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2007}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Ferraris et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Elementary sets for logic programs", "author": ["M. Gebser", "J. Lee", "Y. Lierler"], "venue": "In Proceedings of National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Gebser et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2006}, {"title": "On elementary loops of logic programs", "author": ["M. Gebser", "J. Lee", "Y. Lierler"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Gebser et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "Loops: Relevant or redundant", "author": ["M. Gebser", "T. Schaub"], "venue": "In Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning", "citeRegEx": "Gebser and Schaub,? \\Q2005\\E", "shortCiteRegEx": "Gebser and Schaub", "year": 2005}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Circumscriptive event calculus as answer set programming", "author": ["Kim", "T.-W", "J. Lee", "R. Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Kim et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2009}, {"title": "Negation in logic programming", "author": ["K. Kunen"], "venue": "The Journal of Logic Programming, 4 (4), 289 \u2013 308.", "citeRegEx": "Kunen,? 1987", "shortCiteRegEx": "Kunen", "year": 1987}, {"title": "Nondefinite vs", "author": ["J. Lee"], "venue": "definite causal theories. In Proceedings 7th Int\u2019l Conference on Logic Programming and Nonmonotonic Reasoning, pp. 141\u2013153.", "citeRegEx": "Lee,? 2004", "shortCiteRegEx": "Lee", "year": 2004}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 503\u2013508.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "Representing synonymity in causal logic and in logic programming", "author": ["J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang"], "venue": "In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). http://peace.eas.asu.edu/joolee/papers/syn.pdf", "citeRegEx": "Lee et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2010}, {"title": "Loop formulas for disjunctive logic programs", "author": ["J. Lee", "V. Lifschitz"], "venue": "In Proceedings of International Conference on Logic Programming (ICLP),", "citeRegEx": "Lee and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Lee and Lifschitz", "year": 2003}, {"title": "Safe formulas in the general theory of stable models", "author": ["J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Technical Report. http://peace.eas.asu.edu/joolee/papers/safety.pdf", "citeRegEx": "Lee et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2009}, {"title": "Loop formulas for circumscription", "author": ["J. Lee", "F. Lin"], "venue": "Artificial Intelligence,", "citeRegEx": "Lee and Lin,? \\Q2006\\E", "shortCiteRegEx": "Lee and Lin", "year": 2006}, {"title": "On loop formulas with variables", "author": ["J. Lee", "Y. Meng"], "venue": "In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR),", "citeRegEx": "Lee and Meng,? \\Q2008\\E", "shortCiteRegEx": "Lee and Meng", "year": 2008}, {"title": "Integrating rules and ontologies in the first-order stable model semantics (preliminary report)", "author": ["J. Lee", "R. Palla"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Lee and Palla,? \\Q2011\\E", "shortCiteRegEx": "Lee and Palla", "year": 2011}, {"title": "Circumscription", "author": ["V. Lifschitz"], "venue": "Gabbay, D., Hogger, C., & Robinson, J. (Eds.), Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298\u2013352. Oxford University Press.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "Knowledge representation and classical logic", "author": ["V. Lifschitz", "L. Morgenstern", "D. Plaisted"], "venue": "Handbook of Knowledge Representation,", "citeRegEx": "Lifschitz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2008}, {"title": "A logic of knowledge and justified assumptions", "author": ["F. Lin", "Y. Shoham"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Shoham,? \\Q1992\\E", "shortCiteRegEx": "Lin and Shoham", "year": 1992}, {"title": "Answer set programming with functions", "author": ["F. Lin", "Y. Wang"], "venue": "Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Lin and Wang,? \\Q2008\\E", "shortCiteRegEx": "Lin and Wang", "year": 2008}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhao,? \\Q2004\\E", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhou,? \\Q2011\\E", "shortCiteRegEx": "Lin and Zhou", "year": 2011}, {"title": "Properties and applications of programs with monotone and convex constraints", "author": ["L. Liu", "M. Truszczynski"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Liu and Truszczynski,? \\Q2006\\E", "shortCiteRegEx": "Liu and Truszczynski", "year": 2006}, {"title": "Circumscription\u2014a form of non-monotonic reasoning", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 13, 27\u201339,171\u2013172.", "citeRegEx": "McCarthy,? 1980", "shortCiteRegEx": "McCarthy", "year": 1980}, {"title": "Applications of circumscription to formalizing common sense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 26 (3), 89\u2013116.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "A first order nonmonotonic extension of constructive logic", "author": ["D. Pearce", "A. Valverde"], "venue": "Studia Logica,", "citeRegEx": "Pearce and Valverde,? \\Q2005\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2005}, {"title": "A machine-oriented logic based on the resolution principle", "author": ["J.A. Robinson"], "venue": "J. ACM, 12, 23\u201341.", "citeRegEx": "Robinson,? 1965", "shortCiteRegEx": "Robinson", "year": 1965}, {"title": "Computing answer sets using model generation theorem provers", "author": ["O. Sabuncu", "F.N. Alpaslan"], "venue": null, "citeRegEx": "Sabuncu and Alpaslan,? \\Q2007\\E", "shortCiteRegEx": "Sabuncu and Alpaslan", "year": 2007}, {"title": "Loop formulas for logic programs with arbitrary constraint atoms", "author": ["You", "J.-H", "G. Liu"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "You et al\\.,? \\Q2008\\E", "shortCiteRegEx": "You et al\\.", "year": 2008}, {"title": "On the progression semantics and boundedness of answer set programs", "author": ["Y. Zhang", "Y. Zhou"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Zhang and Zhou,? \\Q2010\\E", "shortCiteRegEx": "Zhang and Zhou", "year": 2010}], "referenceMentions": [{"referenceID": 17, "context": "Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).", "startOffset": 292, "endOffset": 342}, {"referenceID": 16, "context": "The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy\u2019s circumscription (Lee & Lin, 2006).", "startOffset": 105, "endOffset": 116}, {"referenceID": 22, "context": "According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic program that satisfy all its loop formulas. This idea has turned out to be widely applicable in relating the stable model semantics to propositional logic, and has resulted in an efficient method for computing answer sets using SAT solvers. Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).", "startOffset": 110, "endOffset": 519}, {"referenceID": 13, "context": "The stable model semantics that does not involve grounding appeared a year later (Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying the \u201cstable model operator\u201d SM to F . The definition of SM is close to the definition of the circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model semantics, logic programs are viewed as a special class of first-order theories. A similar definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992).", "startOffset": 92, "endOffset": 594}, {"referenceID": 7, "context": "The first-order stable model semantics is also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed, Ferraris et al. (2011) showed that they are essentially equivalent.", "startOffset": 134, "endOffset": 157}, {"referenceID": 2, "context": "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models.", "startOffset": 62, "endOffset": 81}, {"referenceID": 2, "context": "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these results to allow non-Herbrand stable models as well (possibly allowing functions) under a certain semantic condition, and compare the first-order stable model semantics with loop formulas by reformulating the former in terms of the latter. In Section 5, we present a series of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an extension of logic programs that contain explicit quantifiers and shows how query answering for such extended programs can sometimes be reduced to entailment checking in first-order logic via loop formulas. In Section 7, the results are further extended to distinguish between intensional and non-intensional predicates. Related work is described in Section 8, and long proofs are given in Appendix A. This article is an extended version of a conference paper by Lee and Meng (2008).", "startOffset": 62, "endOffset": 1081}, {"referenceID": 8, "context": "(2011) that extends a conference paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and non-intensional predicates.", "startOffset": 59, "endOffset": 82}, {"referenceID": 7, "context": "Review of the First-Order Stable Model Semantics This review follows a journal paper by Ferraris et al. (2011) that extends a conference paper by the same authors (Ferraris et al.", "startOffset": 88, "endOffset": 111}, {"referenceID": 2, "context": "First-Order Loop Formulas and Herbrand Models We review the definition of a first-order loop formula for a nondisjunctive program given by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order sentence.", "startOffset": 139, "endOffset": 158}, {"referenceID": 2, "context": "1 Review of First-Order Loop Formulas Defined by Chen et al. (2006) We call a formula negative if every occurrence of every predicate constant in it belongs to the antecedent of an implication.", "startOffset": 49, "endOffset": 68}, {"referenceID": 7, "context": ") When \u03a0 is a propositional program, LF \u03a0(Y ) is equivalent to a conjunctive loop formula as defined by Ferraris et al. (2006). The definition of a first-order dependency graph and the definition of a first-order loop are as follows.", "startOffset": 104, "endOffset": 127}, {"referenceID": 2, "context": "The original definition by Chen et al. (2006) does not allow function constants of positive arity.", "startOffset": 27, "endOffset": 46}, {"referenceID": 2, "context": "The following is a reformulation of Theorem 1 from the work of Chen et al. (2006).", "startOffset": 63, "endOffset": 82}, {"referenceID": 2, "context": "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution \u03b8 that maps variables in Y1 to terms so that Y1\u03b8 = Y2.", "startOffset": 28, "endOffset": 47}, {"referenceID": 2, "context": "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution \u03b8 that maps variables in Y1 to terms so that Y1\u03b8 = Y2. Proposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program \u03a0 and any loops Y1 and Y2 of \u03a0, if Y1 subsumes Y2, then LF \u03a0(Y1) entails LF \u03a0(Y2). Therefore in condition (c) from Theorem 1, it is sufficient to consider a set \u0393 of loops such that, for every loop L of \u03a0, there is a loop L\u2032 in \u0393 that subsumes L. Chen et al. (2006) called such \u0393 a complete set of loops.", "startOffset": 28, "endOffset": 538}, {"referenceID": 7, "context": "When \u03a0 and Y are propositional, LF \u03a0(Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined by Ferraris et al. (2006).", "startOffset": 127, "endOffset": 150}, {"referenceID": 7, "context": "It is also a generalization of the main theorem by Ferraris et al. (2006) which was restricted to a propositional disjunctive program.", "startOffset": 51, "endOffset": 74}, {"referenceID": 7, "context": "As with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES .", "startOffset": 83, "endOffset": 106}, {"referenceID": 7, "context": "When F and Y are propositional, LFF (Y ) is equivalent to a conjunctive loop formula for a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells us that the definition of a loop formula in this section generalizes the definition of a loop formula for a disjunctive program in the previous section.", "startOffset": 132, "endOffset": 155}, {"referenceID": 7, "context": "Theorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when F is restricted to a propositional formula.", "startOffset": 27, "endOffset": 50}, {"referenceID": 9, "context": "A sentence F is in Clark normal form (Ferraris et al., 2011) if it is a conjunction of formulas of the form", "startOffset": 37, "endOffset": 60}, {"referenceID": 5, "context": "SLF[F ] is similar to Clark\u2019s completion. In the propositional case, the relationship between the loop formulas of singletons and the completion is studied by Lee (2005). Below we describe their relationship in the first-order case.", "startOffset": 22, "endOffset": 170}, {"referenceID": 6, "context": "Corollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011), which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark normal form.", "startOffset": 61, "endOffset": 84}, {"referenceID": 10, "context": "A nonempty set U of atoms that occur in \u03a0 is a loop of \u03a0 iff, for every nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \\ V in the dependency graph of \u03a0 (Gebser et al., 2006).", "startOffset": 188, "endOffset": 209}, {"referenceID": 5, "context": "1 Bounded Formulas and Clark\u2019s Equational Theory On the other hand, such a relationship holds if the interpretation satisfies Clark\u2019s equational theory (1978). Clark\u2019s equational theory of a signature \u03c3, denoted by CET\u03c3, is the union of the universal closures of the following formulas f(x1, .", "startOffset": 23, "endOffset": 159}, {"referenceID": 1, "context": "Consider another example program by Bonatti (2004), where a, .", "startOffset": 36, "endOffset": 51}, {"referenceID": 1, "context": "They actually satisfy a stronger condition called \u201cfinitely recursive\u201d (Bonatti, 2004).", "startOffset": 71, "endOffset": 86}, {"referenceID": 2, "context": "The proof of Proposition 10 (c) is based on the following fact and the straightforward extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that checking if F has a finite complete set of loops is decidable.", "startOffset": 113, "endOffset": 132}, {"referenceID": 16, "context": "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the \u201csmall predicate property\u201d: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F .", "startOffset": 13, "endOffset": 46}, {"referenceID": 16, "context": "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the \u201csmall predicate property\u201d: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . We will show that any semi-safe sentence under the stable model semantics can be turned into a sentence in first-order logic. First, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step, we assign to every formula F a set RV(F ) of its restricted variables as follows: \u2022 For an atomic formula F , \u2013 if F is an equality between two variables, then RV(F ) = \u2205; \u2013 otherwise, RV(F ) is the set of all variables occurring in F ; \u2022 RV(G \u2227H) = RV(G) \u222a RV(H); \u2022 RV(G \u2228H) = RV(G) \u2229 RV(H); \u2022 RV(G\u2192 H) = \u2205; \u2022 RV(QvG) = RV(G) \\ {v} where Q \u2208 {\u2200,\u2203}.", "startOffset": 13, "endOffset": 476}, {"referenceID": 20, "context": "Proposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ).", "startOffset": 15, "endOffset": 33}, {"referenceID": 8, "context": "(2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007) in that it allows us to distinguish between intensional and non-intensional (a.", "startOffset": 93, "endOffset": 116}, {"referenceID": 7, "context": "Extension to Allow Extensional Predicates The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al.", "startOffset": 99, "endOffset": 122}, {"referenceID": 20, "context": "Proposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula SM[F ; p] entails SPPpc(F ).", "startOffset": 15, "endOffset": 33}, {"referenceID": 1, "context": "Related Work The notion of a bounded program is related to the notion of a finitely recursive program studied by Bonatti (2004), where a different definition of a dependency graph was considered.", "startOffset": 113, "endOffset": 128}, {"referenceID": 27, "context": "Lin and Wang (2008) extended answer set semantics with functions by extending the definition of a reduct, and also provided loop formulas for such programs.", "startOffset": 0, "endOffset": 20}, {"referenceID": 25, "context": "Lin and Wang (2008) consider essentially many-sorted languages.", "startOffset": 0, "endOffset": 20}, {"referenceID": 27, "context": "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.", "startOffset": 96, "endOffset": 116}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c).", "startOffset": 136, "endOffset": 156}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics.", "startOffset": 136, "endOffset": 393}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures.", "startOffset": 136, "endOffset": 869}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels.", "startOffset": 136, "endOffset": 1038}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called \u201cloop-separable,\u201d which is more refined than finite complete set of loops under which the finite answer sets of a program can be captured by first-order sentences.", "startOffset": 136, "endOffset": 1207}, {"referenceID": 35, "context": "The use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways.", "startOffset": 98, "endOffset": 126}, {"referenceID": 1, "context": "Future work is to find further restrictions that make first-order stable model reasoning decidable and computable in an efficient manner, like the conditions imposed in \u201cfinitary\u201d programs (Bonatti, 2004).", "startOffset": 189, "endOffset": 204}, {"referenceID": 34, "context": "Lemma 13 For any terms t1 and t2 of signature \u03c3, any interpretation I that satisfies CET\u03c3, and any substitution \u03b8 from object variables in t1 and t2 to object names such that (t1\u03b8) I = (t2\u03b8) I , Robinson\u2019s unification algorithm (Robinson, 1965), when applied to t1 and t2, returns a most general unifier (mgu) \u03b3 of t1 and t2 such that (a) t1\u03b3 = t2\u03b3, and (b) for every variable x in t1 or t2, (x\u03b3\u03b8) I = (x\u03b8)I .", "startOffset": 228, "endOffset": 244}, {"referenceID": 15, "context": "1 from the work of Kunen (1987), t1 and t2 are unifiable, in which case Robinson\u2019s algorithm returns a mgu for t1 and t2 that maps variables occurring in t1 and t2 into terms.", "startOffset": 19, "endOffset": 32}, {"referenceID": 2, "context": "7 Proof of Proposition 11 We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a program to have a finite complete set of loops to a disjunctive program and a sentence.", "startOffset": 135, "endOffset": 154}, {"referenceID": 1, "context": "The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers the following program \u03a0M to simulate deterministic Turing machines M.", "startOffset": 104, "endOffset": 119}, {"referenceID": 27, "context": "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.", "startOffset": 96, "endOffset": 116}, {"referenceID": 27, "context": "Given a program \u03a0, Norm(\u03a0) is a normal form of \u03a0 and Ground(\u03a0) is a ground program obtained from \u03a0 as described by Lin and Wang (2008). The proof of Proposition 16 follows from the following lemma.", "startOffset": 115, "endOffset": 135}], "year": 2011, "abstractText": "Lin and Zhao\u2019s theorem on loop formulas states that in the propositional case the stable model semantics of a logic program can be completely characterized by propositional loop formulas, but this result does not fully carry over to the first-order case. We investigate the precise relationship between the first-order stable model semantics and first-order loop formulas, and study conditions under which the former can be represented by the latter. In order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary first-order theory. Based on the studied relationship we extend the syntax of a logic program with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable models using first-order reasoners. Such programs can be viewed as a special class of firstorder theories under the stable model semantics, which yields more succinct loop formulas than the general language due to their restricted syntax.", "creator": "TeX"}}}