{"id": "1401.3900", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Decidability and Undecidability Results for Propositional Schemata", "abstract": "We define a logic of propositional formula schemata adding to the syntax of propositional logic indexed propositions and iterated connectives ranging over intervals parameterized by arithmetic variables. The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability.", "histories": [["v1", "Thu, 16 Jan 2014 05:20:30 GMT  (349kb)", "http://arxiv.org/abs/1401.3900v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["vincent aravantinos", "ricardo caferra", "nicolas peltier"], "accepted": false, "id": "1401.3900"}, "pdf": {"name": "1401.3900.pdf", "metadata": {"source": "CRF", "title": "Decidability and Undecidability Results for Propositional Schemata", "authors": ["Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier"], "emails": ["Vincent.Aravantinos@imag.fr", "Ricardo.Caferra@imag.fr", "Nicolas.Peltier@imag.fr"], "sections": [{"heading": null, "text": "The satisfaction problem turns out to be undecidable for this new logic, but we are introducing a very general class of schemes, called bound-linear, for which this problem becomes decidable, and this result is achieved by reducing it to a certain class of schemes, called regular, for which we provide a solid and complete final proof process. This scheme calculation (referred to as yardstick) allows us to capture evidence patterns that correspond to a large class of problems specified in the propositional logic. We also show that the satisfaction problem becomes undecidable again for slight extensions of this class, showing that bound linear schemes represent a good compromise between expressivity and decisiveness."}, {"heading": "1. Introduction", "text": "This is critical to a variety of artificial intelligence applications that are used in practice and that have common and well-known terms such as \"good\" computational properties used by the AI community. These schemes are generated by unrestricted repetitions of patterns, which we call \"iterated schemata.\" We motivate our approach with an example commonly used by the AI community: \"Circuit verification properties are often modeled as sequences of propositional problems parameterized by a natural number n, which encodes the size of the data (e.g. the number of bits, number of layers in the circuit, etc.) We simply call these sequences schemas.\""}, {"heading": "2. Schemata of Propositional Formulae", "text": "In this section we will introduce the syntax and semantics of sentence schemes."}, {"heading": "2.1 Syntax", "text": "The set of linear arithmetic expressions (denoted by N) is, as usual, set to the signature 0, s, +, \u2212 and to a fixed and payable infinite series of arithmetic variables V, if they are considered equivalent by the usual properties of the arithmetic symbols (e.g. n + s (0) + n + s (s (0)) and n + s (s (s (0)))). As usual, the s3 (0) is designated as a typical form of the arithmetic variable."}, {"heading": "2.2 Semantics", "text": "The interpretation of schema language is a function that maps every integer variable to an integer, and every possible variable to a truth value T or F. If I am an interpretation and a substitution, we can define the following interpretation as follows: \"I\" and \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"I\" - \"- I\" - \"- I\" - \"- I\" - \"- I\" - \"- I\" - \"- I\" - \"-\" - I \"-\" - \"I\" - \"-\""}, {"heading": "Proof", "text": "The fact that the received scheme corresponds to the original one is a direct consequence of the definition 2.5. We use the term \"p\" to denote the (unique) normal form of \"p.\" If \"p\" is a substitution that assigns each free variable in \"p\" to a natural number, \"p\" is a propositional realization of \"p.\" It is trivial to know whether a scheme is satisfactory: 2.7 The set of satisfactory schemes can be enumerated recursively."}, {"heading": "Proof", "text": "By definition 2,5 is recursive for each interpretation I and each schema II, recursive for each definition II, recursive for each definition II, recursive for each definition II, recursive for each definition II, recursive for each definition II, recursive for each definition I, recursive for each definition I, recursive for each definition I, recursive for each definition I, recursive for each definition II, recursive for each definition II, recursive for each definition II, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition recursive, recursive for each definition"}, {"heading": "Proof", "text": "This is a direct consequence of the definition 2.5 (by a direct induction over the depth of the scheme). We write IC (\u044e) (which stands for \"interval constraints\") for linking arithmetic constraints of the form min\u044b (i) \u2264 i \u2264 max\u044b (i), where i is a variable bound in \u044b. IC (\u044b) can be extended to schemes by treating them as conjunctions. Let's consider them, for example, as conjunctions. Then we can take pa = p0 \u0445 n \u2212 1i = 1 (pi + 1 economiqi). We have: min\u044b (i) = 1 and max\u044b (i) = n \u2212 1. Let's also consider \u03c3 = {n 7 \u2192 4} and p\u03b1 = p3. Then we can take pa = pi + 1 (which actually occurs in \u0456) and \u03c3 \u2032 = {n 7 \u2192 4, i 7 \u2192 2}. We see informally the use of extensions: they enable to some extent to establish a connection between the instance and the index point. \""}, {"heading": "2.3 The Class of Bound-Linear Schemata", "text": "As we will see (e.g. in Theorem 6.2), the satisfaction problem for schematics cannot be decided. To characterize a decideable subclass, we introduce the following definition: Definition 2.9 A schema is boundless iff the following conditions apply: 1.) contains at most one free arithmetic variable n (the so-called parameter of B).2. Every non-arithmetic atom in B is of the form p\u03b1.n + \u03b2.i + \u03b3, where p-P and i is a bound variable, \u03b1, \u03b3-Z and \u03b2 (\u2212 1, 0, 1}.3). If B is an iteration in B (in which B-A-B-B-B-B-B-B-B-B-form exists), then a, b are each of the form.n + \u03b2 and B-B-B-C +.j, where A-B-A-B-B-B-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A."}, {"heading": "2.4 Expressiveness of Bound-Linear Schemata", "text": "To show that the class of the bound-linear schema is not an artificial or too narrow schema, we present in this section some examples of problems that can, of course, be converted into a bound-linear schema. It is easy to check whether the schema Adder (p, c, r, r) is defined in the introduction (formalizes a sequential Adder). Various properties of this schema can be encrypted in the following ways: (Adder) neutral element: (p, c, r) n, (formalizes a sequential Adder). (D) n, (D) n, (D) n, (D) n, (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). (D). D. (D.) D. (D. (D). (D.) D. (D. (D). (D.). (D. (D). (D). (D). (D.). (D.). (D. (D). (D). (D). (D). (D. (D). (D). (D). (D. (D). (D). (D. (D). (D.). (D. (D). (D). (D. (D.). (D.). (D. (D.). (D). (D. (D). (D). (D). (D. (D). (D). (D). (D. (D). (D.).). (D. (D. (D). (D. (D). (D). (D). (D. (D). (D)."}, {"heading": "3. Related Work", "text": "The various forms of schemas have been applied by several authors, either in propositional logic (Baaz & Zach, 1994) or in the former logic, in order to obtain results in the theory of proof, especially with regard to the number of lines of evidence (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991; Parikh (1973) presents an idea of schematic systems applying the concept of unification; Krajicek and Pudlak (1988) introduce the concept of \"proof skeletons,\" very similar to that of schema, Orevkov (1991) studies that list schematic systems in the former order; Hilbert-typical languages are successfully applied, e.g. in solving open questions in equivalent calculus (i.e. the field of formal logic dealing with the concept of equivalence) with the theorem-protter (Wos, Overbeek, 1992)."}, {"heading": "4. Reduction to Regular Schemata", "text": "In this section, we reduce the satisfaction problem for boundary linear schemes (see definition 2.9) to a much simpler class of schemes called regular, which is defined as: Definition 4.1 A scheme is: \u2022 flat if there is no iteration for each iteration that occurs in an iteration (i.e. iterations cannot be nested in one iteration) \u2022 of limited propagation if every atom that occurs in an iteration is in the form of pi + q. Since the number of atoms is finite, there is \u03b2-Z s.t. for each atom that occurs in an iteration, the propagation limits are called \u03b2. \u2022 oriented to [c, d] if all iterations that occur in an iteration are in the form of a regular scheme (i.e. all iterations must have the same propagation limits if they are limited in a line)."}, {"heading": "4.1 Overview of the Transformation Algorithm", "text": "First, we give an informal overview of the algorithms that convert each linear scheme to a regular one (along with examples that illustrate each transformation step).This very high description is designed to help the reader understand the intuitive formula behind the formal definitions and more technical explanations provided in the next paragraph.The first step is the elimination of iterations that occur within an iteration.Consider, for example, the following scheme: It does not depend on whether you can simply replace this formula; the reader can check whether it is binding-linear but not regular. It is easy to transform it into a satellite-equivalent regular scheme. As it does not depend on the counting mode i = 1 qj, you can simply replace this formula with a new propositional variable r and add the equivalence r."}, {"heading": "4.2 Formal Definition of the Algorithm", "text": "We assume that the original scheme meets the following condition: Definition 4.2 A linear scheme is normalized if the coefficient of the parameter n is contained in even one expression found in the formula (either as an index of a symbol in P or as the limit of an iteration). Exclusively normalized schemes are not considered restrictive because one scheme that does not fulfill this property can be replaced by another (see note 4.7). Obviously, the obtained scheme is equivalent to that of Figure 1 and normalized4. The use of normalized schemes is explained later (see note 4.3). The property of normalization is only useful if the algorithm of Figure 1 is well defined."}, {"heading": "4.2.1 Elimination of Nested Iterations", "text": "As explained in Section 4.1, the first step is to remove the iterations that occur within another iteration. (This is only possible if there is no free variable other than i and the parameter n. (This is only possible if there is no free variable other than i and the parameter n.) If the variables in c are free, exactly the role of the other variables is given, and if there is a new variable b = a2 for each iteration. (This is only possible if there is a new variable p). (This is only possible if the free variable in c is free.) If the variable in c is free, it occurs in relation to each iteration.) If the variable in b = a2 is free, then it occurs."}, {"heading": "4.2.2 Transforming every Iteration into Iterations over Intervals of the", "text": "Form [\u03b1, n \u2212 \u03b2] The next step is to make sure that for each iteration \u0432bi = \u03b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2."}, {"heading": "4.2.3 Removing the Parameter from the Indices in the Iterations", "text": "The next phase is to remove the indexed variables of the form p\u03b1.n + \u03b2 + \u03b2 + \u03b2 \u03b2, where \u03b2 Z and either \u03b1 s = 0 or 1 (to obtain variables that are only indexed by expressions of the form i + \u03b2). First, we make sure that alpha is uniform. Although initially the coefficient of each occurrence of n is equal, this property no longer applies at this point, because the variable p (2 + 1).n + c, where c is not n, occurs in an iteration. Then (since the scheme is standardized) this variable must have been introduced by rule perc7 and i has shifted by the definition of alpha. (after definition of alpha 7) This shift is applied to any index that contains i (after definition of alpha 7), i.e."}, {"heading": "4.2.4 Aligning Iterations", "text": "Finally, make sure that all iterations have the same boundaries. At this point, each iteration is of the form \u043fn \u2212 \u03b2i = \u03b1, where \u03b1, \u03b2 \u00b2 Z results. Let \u03b1 \u00b2, \u03b2 \u00b2 have the largest integers \u03b1, \u03b2. If we have \u03b1 = \u03b1 \u00b2 or \u03b2 = \u03b2 \u00b2, then we unfold the iteration once, resulting in N \u2212 \u03b2 \u2212 1i = \u03b1 \u00b2 [n \u2212 \u03b2 / i]. By translating the iteration counter, the lower boundary of the obtained iteration is now identical to \u03b1 \u00b2 and its length has decreased, repeating itself until we get an iteration on the interval [n \u2212 \u03b2 \u2212 1 + \u03b1 \u00b2 \u00b2 [i \u2212 \u03b1 \u00b2, \u03b2 \u00b2]. Rule \u041a10 formalizes this transformation: the lower boundary of the obtained iteration is now identical to \u03b1 \u00b2 and its length has decreased until we get an iteration on the interval."}, {"heading": "4.2.5 Definition of \u03a8(\u03d5)", "text": "The most difficult part of the transformation is the removal of the variables n in the index carried out according to rule \u04219, and more precisely the definition of what results ensure the feasibility of this transformation. \u2212 Definition 4.4 On the basis of this, we refer to the set of schemes of the form: 2\u03b1.n + a = 2\u03b2.n \u2212 b \u00b2 (p\u03b1 + a \u00b2 p \u2212 b) or 2\u03b1.n \u2212 b \u00b2 (p\u03b1 + a \u00b2 p + b \u00b2) or 2\u03b1.n \u00b2 (p\u03b2 + b) or 2\u03b1.n \u2212 n \u00b2 (a = 2\u03b2.n \u00b2) or 2\u03b2.n \u00b2 (p\u0430 \u2212 a \u00b2 p \u03b2 \u2212 b), where each formula is infinite. Therefore, we add another caveat: Definition 4.5 Let it be a scheme containing a unique parameter."}, {"heading": "Proof", "text": "Let us have \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2"}, {"heading": "Proof", "text": "We define an interpretation J (n) as follows: J (n) def = \u0443 and for each pair of integers (\u03b1, \u03b2): J (p\u03b1 + \u03b2) def = iff I (p2\u03b1.\u0445 + \u03b2) =. By definition, the definition results from the replacement of each atom of the form p2\u03b1.n + a (or p2\u03b1.n \u2212 a), where a \"Ni-Z\" (for any bound variable i) occurs by \"p\u03b1 + a\" (or p \u03b1 \u2212 a). By definition, J | = p\u03b1 + \u03b2 iff I | = p2\u03b1.n + \u03b2 \"and J | = p\u03b1\" p\u03b1 \"(for any bound variable i) occurs by\" p\u03b1 + a \"(or p \u03b1 \u2212 a)."}, {"heading": "4.3 Termination and Complexity", "text": "In this section, we examine the complexity of the transformation algorithm and show that it is exponential. For each scheme, we specify the number of symbols present in Figure 1.Theorem 4.9."}, {"heading": "Proof", "text": "First, we note that the rules are always applied sequentially: it is easy to verify that a rule cannot introduce a formula to which a previous rule is applied. Thus, we look at each rule on a sequential scale. First, we look at the atomic atoms occurring in an iteration as a formula to which the rule may possibly be applied, i.e. the atomic conditions of the rules occurring in an iteration are not taken into account that meet this condition but do not contain the iteration counters. Due to the control (i.e. the application conditions of the rules), no atom that meets this condition can be introduced into the formula (in fact, if the atom PC occurs in an iteration, then it must contain the appropriate application state of the rule). Therefore, the number of applications of this rule is limited to one iteration."}, {"heading": "4.4 Soundness and Completeness", "text": "We prove that the rules in \u03c4 preserve the satellite equivalence and that every irreducible formula is regular. We need the following two sentences: Lemma 4.10 Let me be schemas. Let me be an interpretation which states that for each soil substitution \u03c3 we have the parameters of \u03c3 and for each area extension \u03b8 of \u03c3 for \u0432, \u0432 \"the following: J\u03b8KI = J\u0442\" \u0445KI."}, {"heading": "Proof", "text": "The proof comes from induction based on the fact that the proof is trivial. However, if it is a soil substitution of the parameters of Economy = Economy, then of course it is an expansion of itself for Economy and Economy. Consequently, Economy KI = Economy KI = Economy AI. Suppose that Economy KI = Economy and Economy KI = Economy KI = Economy KI (Economy KI = Economy). Suppose that Economy KI = Economy KI is included. Suppose that Economy KI = Economy KI and Economy KI = Economy KI = Economy KI (Economy KI = Economy KI) is included."}, {"heading": "Proof", "text": "We now show that for any interpretation I, Jp, KI = Jp, KI = Jp, KI. If JpKI = F then both p, and p, KI [/ p] are wrong. Otherwise, we have Lemma 4.10 JKI = Jp, KI. Similarly, we have J, p, KI = F then both p, and p, KI = J, p, KI. Consequently, that p, p, KI (/ p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p"}, {"heading": "Proof", "text": "The proof is by inspecting the various rules (see the definition of the rules for notations): \"The proof is a direct application of Lemma 4.11.\" \"The proof is a direct application of Lemma 4.11.\" \"The proof is a direct application of Lemma 4.11.\" \"The proof is a direct application of Lemma 4.11.\" \"The proof is a direct application of formula J.\" \"The proof is a direct application of formula J.\" \"The definition is the same formula J.\" \"The definition is the same formula J.\" \"The definition is the same formula J.\" \"The definition is J.\" \"The definition is J.\" \"The definition is J.\" \"The definition is JP.\" \"The definition is JP.\" The definition is JP. \"The definition is JP.\" Conversely, if I am a model of Lemma 4.10, we assume that I have the definition of JP. \""}, {"heading": "Proof", "text": "Let us first prove that this schema does not contain nested iteration. Let's assume that this schema is the result of a nested iteration process. Let's assume that this schema contains a nested iteration process. Let's assume that this schema contains an iteration process. Let's assume that this schema contains an iteration process. Let's say that this schema contains an iteration process. Let's assume that this schema contains no iteration processes (otherwise we could simply take an iteration process)."}, {"heading": "5. STAB: A Decision Procedure for Regular Schemata", "text": "Now that we have shown how to transform a bound linear scheme into a regular one, we show that the satisfaction problem is decidable for regular schemes by providing a set of block tableaux rules (Smullyan, 1968) that are completely unsatisfactory. These rules are concise and natural, and in comparison to the na\u00efve process described in the proof of Proposition 2.7, they are much more efficient and end more frequently (see the end of Section 5.1). The process is called a rod (stands for schemes tableaux). Note that it applies to any scheme (not just regular ones). We assume (w.l.o.g) that schemes are in negative normal form."}, {"heading": "5.1 Inference Rules", "text": "It is not the first time that such a method is used by another tableau. (It is the second time that such a method is used by another tableau. (It is the second time that such a method is used by another tableau.) It is the first time that such a method is used by another tableau. (It is the second time that such a method is used by another tableau. (It is the second time that such a method is used by another tableau.) It is the second time that we can extend the tableau by adding children to a tableau. (It is the third time that each of them is marked). (It is the third time that it is used by another tableau.) (It is the third time that it is used by another tableau.) (It is the third time that it is used by another tableau.) (It is the third time that it is used by another tableau. (It is the third time that it is used by another tableau.) It is the third time that it is the third time that it is used by another tableau."}, {"heading": "5.2 Discarding Infinite Derivations: the Looping Rule", "text": "/ / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /"}, {"heading": "Proof", "text": "(J) (J) (J) (J) (J) (J) (I) (I) (I) (I) (I) (V) (I) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A (A) (A) (A) (A (A) (A) (A)"}, {"heading": "Proof", "text": "By a simple introduction to the formulas we can prove the decisiveness of s: sentence 5.13 s is decidable."}, {"heading": "Proof", "text": "Since linear arithmetic is decidable, one can check whether a word is pure or not. Then, these pure literals can simply be removed from the formula (since they fulfill the second condition in definition 5.9), one must find a shift so that any remaining formula in \"meets the first or third condition.\" Leave n1,.. the variables in \",\" the second condition. \"Let's check that there is a substitution that maps each variable to an integer formula, so that: \u2022 any condition nand (1), any condition nand (l) refers to\" n, \"which are unique variables that do not occur in\" n. \"One must check whether there is a substitution condition that maps each variable l\u0438 to an integer formula, so that: \u2022 any condition nand\" (l \") refers to the condition zero and\" (l \")."}, {"heading": "Proof", "text": "Let us show that there is a model J < I s.t. J, that is, that there is an interpretation s.t. J (L) = T, if L is a letter that is pure in definition and J (L) def = I (L) is otherwise. Let us show that there is a model J, that is, that it is practical. Let us distinguish three cases, according to the three items in definition 5.9. \u2022 If we distinguish these three cases, then because I | = L) def = I (L) is pure in definition and J (L) def = I (L) is otherwise. Let us show that we have three cases according to the three items in definition 5.9."}, {"heading": "5.3 Examples", "text": "Before proving the solidity, completeness and completion of the trick, we present some examples of tableaux."}, {"heading": "5.3.1 A Simple Example", "text": "(n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (.). (n). (n). ((n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (). (n). (n). (n). (n). (n). (n). (n). (n). (). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (n). (). (n). (). (). (). (n). (n). (). (). (). (). (). (). (). ()."}, {"heading": "5.4 Soundness and Completeness", "text": "A leaf is irreducible if no rule of expansion applies to it. A derivative is a (possibly infinite) sequence of tableaux (T\u03b9) and I s.t. A derivative is either [0] for a particular unclosed leaf or N and s.t. for all [I] and each unclosed and unblocked leaf N in T\u03b9 \u2212 1 by applying one of the expansion rules. A derivative is fair if either an unclosed leaf or an unreducible, unclosed leaf I and each unclosed and unblocked leaf N is present in T\u03b9. A rule is applied to N in T\u03bb (i.e. no leaf can be \"frozen\"). Definition 5.16 (Tableau Semantics) For each node N in a tableau T, T (N) is interpreted as a conjunction of its elements. T is satisfied in an interpretation if a leaf N in T s.t. I | = T (a leaf in a tableau) and a T (T) is valid in a leaf."}, {"heading": "Proof", "text": "If a sheet N in T is irreducible and not closed, then T is satisfactory."}, {"heading": "Proof", "text": "Since N is not closed, it is satisfactory (by definition), so let it be a solution to the question. \u03a6 contains a formula that cannot be taken literally, one of the extension rules applies and deletes what is impossible. Let cT (N) the number of pairs pa, \u00ac pb and \u03a6T (N) s.t. There is an interpretation that I think is correct, s.t. JaKI = JbKI. If cT (N) 0, then the closing rule applies to pa, pb, which is impossible. Consequently, cT (N) = 0 and in particular this implies that \u0441\u043c is propositively satisfactory (i.e., it does not contain a pair of supplementary literals).Thus \u0441T (N) \u043c is satisfactory and by definition T is satisfactory. Theorem 5.19 (Solidity and completeness w.r.Satisfaction if there is no pair of supplementary literals."}, {"heading": "Proof", "text": "The first point (i.e. solidity) is derived from Lemmata 5,17 and 5,18. We now prove that the procedure is complete if it is an arithmetic atom (i.e. an atom of form). <..). \u2022 mI (i.e.) def = 1 if it is an indexed statement or its negation or vice versa. \u2022 mI (i.e. an atom of form. <.) def = mI (i.e.) def = 1 if it is an indexed statement or its negation or vice versa. \u2022 mI (i.e. an atom of form.) def = mI (i.e. 1) + mI (i.e. 2) if it is an indexed statement or its negation or vice versa. \u2022 mI (i.e. if it is an indexed statement or its negation or vice versa. \u2022 mI (i.e. if it is a definition or its negation) < &ltT = mI."}, {"heading": "Proof", "text": "All rules except the iteration rule and the closing rule replace a formula with a simpler one, so it is easy to see that mI (\u03a6T (N)) decreases. Iteration rule replaces an iteration of length \u03b9 either by or by a disjunction / conjunction of an iterated disjunction / conjunction of length \u03b9 \u2212 1 and a smaller formula. Since \u03b9 > \u03b9 \u2212 1, mI (\u03a6T (N)) decreases, the closing rule does not affect mI (\u03a6T (N)), but obviously decreases cT (N).Let me be a model of T0. According to Resolution 5.6, we can assume that I am minimum.r.t The rule introduced in Definition 5.4.By Lemma 5.17 does not affect the rule contained in Definition I."}, {"heading": "5.5 Termination on Regular Schemata", "text": "We consider the following ST strategy for applying the extension rules: \u2022 The provisional extension rules, the loop and closing rules are applied as soon as possible to all sheets, with highest priority. These rules obviously end on each scheme. \u2022 The iteration rules are applied only to iterations of maximum length (i.e. to the natural sub-sequence of arithmetic expressions). \u2022 For example, if we have the scheme introduced in Section 5.2 \u0441 ni = 1 pi-n \u2212 1 j = 1 qj, then the iteration rules apply only to the first iteration step. \u2022 The relationship introduced in Section 5.2 is used to block loop lines.Theorem 5.21 ST ends on each regular scheme."}, {"heading": "Proof", "text": "If you do not agree with the statements contained in this press release, please do not assume any obligation to update or revise any forward-looking statements, whether as a result of new information, future events, future events or otherwise, to update or revise any forward-looking statements, whether as a result of new information, future events or otherwise, whether as a result of new information, future events, future events or otherwise."}, {"heading": "Proof", "text": "Since ST comes to an end, there can be no infinite derivative, so I am necessarily of the form [0] for any \"N.\" By definition, each node in \"T.\" is either blocked or closed or irreducible (the strategy is applied to the point of irreducibility) If \"T.\" contains an unclosed irreducible hand, then the proof (by defining the concept of fairness) is complete. Otherwise, we look at \"T.\" with \"N.\" This means that no extension can possibly affect N, so \"N\" must also occur in the final tableau T (and is denoted by the same set of schemes as in \"T.\" A rule is applied to \"N\" (which would contradict our definition of fairness)."}, {"heading": "Proof", "text": "Theorem 5.21 shows that stitch ends with any regular scheme, so stitch with Theorem 5.19 and Lemma 5.22 can be used to decide the satisfaction problem for regular schemes. A fine analysis of the previous termination proof ensures that we can solve the satisfaction problem for regular schemes in exponential time (when natural numbers are written in irregular notation). As we have seen further (Theorem 4.9) that the translation of boundary linear schemes into regular exponential was, we can conclude that the satisfaction problem for bound linear schemes can be solved in double exponential time."}, {"heading": "5.6 Model Building", "text": "The existence of an unclosed irreducible branch ensures that the root scheme is satisfactory, as shown in Theorem 4.12. The arithmetic constraints in the branch specify the possible values of the parameter. \u2212 n The remaining formulas must be literal, since the rules of extension apply to any complex formula (in particular, there can be no iteration scheme).These dictionaries specify the truth value of the statement variables just as in the usual case of statement logic (the value of the statement variables that do not appear in the branch can be chosen arbitrarily).Since the branch is not closed, it cannot contain a pair of complementary letters \u2212 n. \u2212 n We will illustrate this construction with a simple example of statement logic: pn, \u00ac q2, \u00ac r1 q1 qm q."}, {"heading": "5.7 The System", "text": "The decision-making process has been implemented and the program (called RegStab) is freely available at http: / / regstab.forge.ocamlcore.org /. It is written in OCaml and has been successfully tested on MacOSX (10.5), Win32 (Windows XP SP3) and GNU Linux (Ubuntu 9.04) x86 platforms. Functions can be defined to make the input file more readable (see below Sum (i) and Carry (i). Here is an input file for the add-on example in Section 5.3.2. / / / A + 0 = A let Sum (i): = S _ i < - > (A _ i (+) B _ i (+) C _ i (+) in let Carry (i): = C _ i / let Carry (i) in let Carry (i): = C _ i + 1 < - > (A _ i /\\ i) in A _ i (C) Adi (1)."}, {"heading": "Adder() /\\ NullB() /\\ Conclusion()", "text": "The software simply prints out the status of the scheme (satisfactory or unsatisfactory). Options are offered to get more information about the search space (number of inference rules, depth of deployment, etc.), see the manual for details. An additional tool is offered to expand the scheme to a statement formula in DIMACS format (by setting the value of n). Figure 4 gives some examples of problems that can be solved by RegStib and the corresponding runtimes (see the distribution for input files and additional information). Here is an example of the output that proves that 0 is a neutral element for the carry propagate viper. We have operated the system in verbose mode, in which it provides some useful information about the search: number of application of extension rules, number of closed and looping leaves, depth of deployment and set of lemmata (companion nodes)."}, {"heading": "Conjecture:", "text": "(((((/\\ i = 1.. n ((S _ i < - > ((A _ i (+) B _ i) (+) C _ i)))) / / (C _ i + 1 < - > (((A _ i /\\ B _ i))) / (C _ i /\\ A _ i)))) / / (C _ i /\\ B _ i)))) / (/ (/\\ i = 1.. n ~ B _ i)) / (\\ / i = 1.. n (A _ i (+) S _ i)))) Application of the tableau rules: /\\: 67\\ /: 84 (+): 38 < - >: 32 < - >: 0 Iterated / >: 12 Iterated /: 3 ------- Overall meaningful rules: 221 Total iterated rules: 15 Number of closed hands: 137 Number of snaking hands: 30 < - >: 4Maximum number of folds: 3 (if the table is first surprising)"}, {"heading": "Lemmas:", "text": "[\\ / i = 1.. n (A _ i (+) S _ i); /\\ i = 1.. n ((S _ i < - > (A _ i (+) B _ i) (+) C _ i)) /\\ (C _ i + 1 < - > (((A _ i /\\ B _ i)\\ / (C _ i /\\ A _ i)))))); /\\ i = 1.. n ~ B _ i; ~ C _ 1] [\\ / i = 1.. n (A _ i /\\ B _ i) [\\ / i = 1.. n-1 (A _ i (+) S _ i /\\ i); /\\ i = 1.. n-1 (S _ i /\\ i < - > A _ i) (+) C-i-i (C _ i /\\ i / i); &lti (C _ S-S-i) &lti (C _ i) &lti (C _ i / i) &lti (\\-i / i);"}, {"heading": "6. Undecidability Results", "text": "We provide some indecisiveness results for two natural extensions of the regular scheme class."}, {"heading": "6.1 Homothetic Transformations on the Iteration Counters", "text": "We consider the class of schemes Ch as follows. Definition 6.1 Ch (h stands for \"homothetic\") is the set of schemes that fulfills the following properties: \u2022 \"contains at most one parameter n.\" \u2022 Each iteration in \"p\" is of the form \"n = 1\" or \"n = 1,\" where: - \"contains no iteration.\" - Every atomic formula in \"p\" belongs to \"pi, p2i, pi \u00b1 1, p2i \u00b1 1,\" where \"p\" is a variable. \u2022 The atomic formulas that occur in \"p,\" but not to the extent of an iteration, are in the form \"p0\" or \"pn, where\" p \"is a variable, fairly simple and very close to the class of regular schemes. There is only one parameter n, all iterations have the same boundaries 1 and n, there is no nested iteration, and the indices of the symbol in\" p \"must.\""}, {"heading": "6.1.1 Notations", "text": "Let us first recall some basic definitions and introduce some useful notations. Let A be an alphabet. Let it be a natural number."}, {"heading": "6.1.2 Overview of the Encoding", "text": "The intuition behind the encoding is the following. We show how to encode each instance of the problem into a scheme (= 1) (= 1) so that that instance has a solution. More precisely, we construct the solution of the parameter n \u00b2. In fact, we represent the potential solution of the array (where w = a, b) by a one-dimensional array of length n. Specifically, we do not store the encoding to represent the potential solutions a \u00b2 and b \u00b2; then we will see how to verify that it is indeed solutions. We represent the potential solution (where w = a, b) by a one-dimensional array of length n. More precisely, we do not store the characters themselves, but for each character that contains the index, a word w \u00b2 in which it occurs and its position in that word (as we will see it) is useful to find the next character in w \u00b2."}, {"heading": "6.1.3 The Signature", "text": "The array is encoded by two indexed sentences: car (w, \u03bd, \u03bb) and t (w, \u03bd) (t stands for \"tail\"), where w {a, b}, 1 \u2264 \u03bd \u2264 \u0445, 1 \u2264 \u03bb \u2264 | w\u03bd |. The intuition behind car (w, \u03bd, \u03bb) l is that iff contains the index l in the array corresponding to w \u00b2, contains the pair (\u03bd, \u03bb) (representing the character w\u03bb\u03bd). t (w, \u03bd) l states that the index l of the array corresponding to w \u00b2 contains \u03bd."}, {"heading": "6.1.4 Formal Definition of the Encoding", "text": "As explained in the previous section, we store the characters in an array, in which we first define two symbols in P. < < p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, \"p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, and s, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p, p, p \u00b2, p, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p \u00b2, p"}, {"heading": "6.2 Unbounded Translation", "text": "One may wonder whether the decidability of the class of regular schemes is still valid if unlimited translations are permitted in the indices, i.e. translations of the form i + m, where i denotes the iteration counter and m denotes a parameter (the case m-Z is covered by the regular class). The following definition and the following theorem show that the answer is negative. Definition 6.3 Ct (t stands for \"translation\") is the set of schemes S, which fulfils the following properties. \u2022 S contains no more than two parameters n, m. \u2022 Each iteration in S is of the form i = 1, where: - each atomic formula in the form p\u03b1.i + \u03b2 +.m, where p is a variable, \u03b1, \u04210, 1} and \u03b2 {\u2212 1, 0, 1}, where: - each atomic formula in the form p\u0430.i + \u03b2.m, where p is a variable."}, {"heading": "Proof", "text": "(sketch) We do not elaborate on the proof because it is very similar to the previous one. We use the same encoding as in the proof of theorem 6.2, except that the pairs (\u03bd, \u03bb) in the array indices of the form \u00b5 + m \u00b7 \u03b9 instead of \u00b5.2\u03b9. Formally, the formulas (1), (2), (3) and (6) are replaced by the following: n = 1 [(l = \u00b5) \u21d2 wtl) (l < \u00b5) \u21d2 (\u00ac (l < \u00b5) \u0445 (l < \u00b5) \u0445 (l = \u00b5)) \u21d2 (wtl = wtl + m)) (i.e. wtl applies now if there is a s.t. l = \u00b5 + m\u03b9).n: l = 1 [wtl] l: 1 [wtl] l: 1 (w \u00b2) l: 1 (m \u00b2) l: 1 (w \u00b2) l: 1 (w \u00b2) l: 1 (m \u00b2) m \u00b2)."}, {"heading": "7. Conclusion", "text": "We introduced the first (to the best of our knowledge) logic for arguing with iterated statement schemes. We defined a scheme class called bound-linear, for which the satisfaction problem can be decided. The proof process is constructive and divided into two parts: First, we show how to transform each scheme from bound-linear to a satellite equivalent scheme of a simpler form, called Regular. Then, a proof procedure is defined to determine the satisfaction of regular schemes. This procedure is solid and complete. Satisfaction for each scheme (even if it is non-regular or non-bound-linear) and ends with each regular scheme. Termination is based on a special looping recognition rule. This procedure was developed in the RegStab.The class of bound-linear schemes is meaningful enough to cover the specifications of many important problems in AzeI testing, especially in automated (interactive) logic or weighted circuits."}, {"heading": "Acknowledgments", "text": "This work was partly funded by the ASAP project of the Agence Nationale de la Recherche (ANR-09-BLAN-0407-01) and the authors thank the anonymous arbitrators for their insightful comments, which have helped to improve an earlier version of this paper."}], "references": [{"title": "An Introduction to Inductive Definitions", "author": ["P. Aczel"], "venue": "Barwise, K. J. (Ed.), Handbook of Mathematical Logic, pp. 739\u2013782. North-Holland, Amsterdam.", "citeRegEx": "Aczel,? 1977", "shortCiteRegEx": "Aczel", "year": 1977}, {"title": "A DPLL proof procedure for propositional iterated schemata. In Workshop \u201cStructures and Deduction 2009", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": null, "citeRegEx": "Aravantinos et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2009}, {"title": "A schemata calculus for propositional logic", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "In TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods),", "citeRegEx": "Aravantinos et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2009}, {"title": "A Decidable Class of Nested Iterated Schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "In IJCAR 2010 (International Joint Conference on Automated Reasoning),", "citeRegEx": "Aravantinos et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2010}, {"title": "Note on the generalization of calculations", "author": ["M. Baaz"], "venue": "Theoretical Computer Science, 224, 3\u201311.", "citeRegEx": "Baaz,? 1999", "shortCiteRegEx": "Baaz", "year": 1999}, {"title": "Short proofs of tautologies using the schema of equivalence", "author": ["M. Baaz", "R. Zach"], "venue": "In Computer Science Logic (CSL\u201993),", "citeRegEx": "Baaz and Zach,? \\Q1994\\E", "shortCiteRegEx": "Baaz and Zach", "year": 1994}, {"title": "The challenge of computer mathematics", "author": ["H. Barendregt", "F. Wiedijk"], "venue": "Philosophical Transactions of the Royal Society A,", "citeRegEx": "Barendregt and Wiedijk,? \\Q2005\\E", "shortCiteRegEx": "Barendregt and Wiedijk", "year": 2005}, {"title": "SPIKE, an automatic theorem prover", "author": ["A. Bouhoula", "E. Kounalis", "M. Rusinowitch"], "venue": "In Proceedings of the International Conference on Logic Programming and Automated Reasoning (LPAR\u201992),", "citeRegEx": "Bouhoula et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Bouhoula et al\\.", "year": 1992}, {"title": "A computational logic", "author": ["R.S. Boyer", "J.S. Moore"], "venue": null, "citeRegEx": "Boyer and Moore,? \\Q1979\\E", "shortCiteRegEx": "Boyer and Moore", "year": 1979}, {"title": "Local model checking for infinite state spaces", "author": ["J. Bradfield", "C. Stirling"], "venue": "In Selected papers of the Second Workshop on Concurrency and compositionality,", "citeRegEx": "Bradfield and Stirling,? \\Q1992\\E", "shortCiteRegEx": "Bradfield and Stirling", "year": 1992}, {"title": "Modal Mu-Calculi", "author": ["J. Bradfield", "C. Stirling"], "venue": null, "citeRegEx": "Bradfield and Stirling,? \\Q2007\\E", "shortCiteRegEx": "Bradfield and Stirling", "year": 2007}, {"title": "Cyclic Proofs for First-Order Logic with Inductive Definitions", "author": ["J. Brotherston"], "venue": "Beckert, B. (Ed.), Automated Reasoning with Analytic Tableaux and Related Methods: Proceedings of TABLEAUX 2005, Vol. 3702 of LNAI, pp. 78\u201392. Springer-Verlag.", "citeRegEx": "Brotherston,? 2005", "shortCiteRegEx": "Brotherston", "year": 2005}, {"title": "The automation of proof by mathematical induction", "author": ["A. Bundy"], "venue": "Robinson, J. A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, pp. 845\u2013911. Elsevier and MIT Press.", "citeRegEx": "Bundy,? 2001", "shortCiteRegEx": "Bundy", "year": 2001}, {"title": "The Oyster-Clam system", "author": ["A. Bundy", "F. van Harmelen", "C. Horn", "A. Smaill"], "venue": "In Proceedings of the 10th International Conference on Automated Deduction,", "citeRegEx": "Bundy et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Bundy et al\\.", "year": 1990}, {"title": "On finite representations of infinite sequences of terms", "author": ["H. Chen", "J. Hsiang", "H. Kong"], "venue": "In Conditional and Typed Rewriting Systems, 2nd International Workshop,", "citeRegEx": "Chen et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Chen et al\\.", "year": 1990}, {"title": "Tableau-based model checking in the propositional mu-calculus", "author": ["R. Cleaveland"], "venue": "Acta Inf., 27 (9), 725\u2013747.", "citeRegEx": "Cleaveland,? 1990", "shortCiteRegEx": "Cleaveland", "year": 1990}, {"title": "Inductionless induction", "author": ["H. Comon"], "venue": "Robinson, A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, chap. 14, pp. 913\u2013962. North-Holland.", "citeRegEx": "Comon,? 2001", "shortCiteRegEx": "Comon", "year": 2001}, {"title": "On unification of terms with integer exponents", "author": ["H. Comon"], "venue": "Mathematical System Theory, 28, 67\u201388.", "citeRegEx": "Comon,? 1995", "shortCiteRegEx": "Comon", "year": 1995}, {"title": "Theorem proving in arithmetic without multiplication", "author": ["D. Cooper"], "venue": "Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 7, chap. 5, pp. 91\u201399. Edinburgh University Press.", "citeRegEx": "Cooper,? 1972", "shortCiteRegEx": "Cooper", "year": 1972}, {"title": "A Machine Program for Theorem Proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communication of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "Finite-Model Theory - A Personal Perspective", "author": ["R. Fagin"], "venue": "Theoretical Computer Science, 116, 3\u201331.", "citeRegEx": "Fagin,? 1993", "shortCiteRegEx": "Fagin", "year": 1993}, {"title": "Decidable classes of inductive theorems", "author": ["J. Giesl", "D. Kapur"], "venue": "IJCAR, Vol. 2083 of Lecture Notes in Computer Science,", "citeRegEx": "Giesl and Kapur,? \\Q2001\\E", "shortCiteRegEx": "Giesl and Kapur", "year": 2001}, {"title": "Chapter 6: Tableau Methods for Modal and Temporal Logics", "author": ["R. Gor\u00e9"], "venue": "M D\u2019Agostino, D Gabbay, R H\u00e4hnle, J Posegga (Ed.), Handbook of Tableau Methods, pp. 297\u2013396. Kluwer Academic Publishers. http://arp.anu.edu.au/~ rpg (draft).", "citeRegEx": "Gor\u00e9,? 1999", "shortCiteRegEx": "Gor\u00e9", "year": 1999}, {"title": "Representation and symbolic manipulation of linearly inductive boolean functions", "author": ["A. Gupta", "A.L. Fisher"], "venue": "IEEE Computer Society", "citeRegEx": "Gupta and Fisher,? \\Q1993\\E", "shortCiteRegEx": "Gupta and Fisher", "year": 1993}, {"title": "Unification of Infinite Sets of Terms schematized by Primal Grammars", "author": ["M. Hermann", "R. Galbav\u00fd"], "venue": "Theoretical Computer Science,", "citeRegEx": "Hermann and Galbav\u00fd,? \\Q1997\\E", "shortCiteRegEx": "Hermann and Galbav\u00fd", "year": 1997}, {"title": "Proof analysis with HLK, CERES and ProofTool: Current status and future directions", "author": ["S. Hetzl", "A. Leitsch", "D. Weller", "B. Woltzenlogel Paleo"], "venue": "Workshop on Empirically Successful Automated Reasoning for Mathematics (ESARM),", "citeRegEx": "Hetzl et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hetzl et al\\.", "year": 2008}, {"title": "Relational queries computable in polynomial time (Extended Abstract)", "author": ["N. Immerman"], "venue": "STOC \u201982: Proceedings of the fourteenth annual ACM symposium on Theory of computing, pp. 147\u2013152, New York, NY, USA. ACM.", "citeRegEx": "Immerman,? 1982", "shortCiteRegEx": "Immerman", "year": 1982}, {"title": "The number of proof lines and the size of proofs in first-order logic", "author": ["J. Krajicek", "P. Pudlak"], "venue": "Archive for Mathematical Logic,", "citeRegEx": "Krajicek and Pudlak,? \\Q1988\\E", "shortCiteRegEx": "Krajicek and Pudlak", "year": 1988}, {"title": "Proof schemata in Hilbert-type axiomatic theories", "author": ["V.P. Orevkov"], "venue": "Journal of Mathematical Sciences, 55 (2), 1610\u20131620.", "citeRegEx": "Orevkov,? 1991", "shortCiteRegEx": "Orevkov", "year": 1991}, {"title": "Some results on the length of proofs", "author": ["R.J. Parikh"], "venue": "Transactions of the American Mathematical Society, 177, 29\u201336.", "citeRegEx": "Parikh,? 1973", "shortCiteRegEx": "Parikh", "year": 1973}, {"title": "Finiteness is Mu-ineffable", "author": ["D.M. Park"], "venue": "Theoretical Computer Science, 3, 173\u2013181.", "citeRegEx": "Park,? 1976", "shortCiteRegEx": "Park", "year": 1976}, {"title": "Inductive Definitions in the system Coq - Rules and Properties", "author": ["C. Paulin-Mohring"], "venue": "TLCA \u201993: Proceedings of the International Conference on Typed Lambda Calculi and Applications, pp. 328\u2013345, London, UK. Springer-Verlag.", "citeRegEx": "Paulin.Mohring,? 1993", "shortCiteRegEx": "Paulin.Mohring", "year": 1993}, {"title": "First-Order Logic", "author": ["R.M. Smullyan"], "venue": "Springer.", "citeRegEx": "Smullyan,? 1968", "shortCiteRegEx": "Smullyan", "year": 1968}, {"title": "On the Structure of Inductive Reasoning: Circular and Tree-shaped Proofs in the mu-Calculus", "author": ["C. Sprenger", "M. Dam"], "venue": "In Proc. FOSSACS\u201903,", "citeRegEx": "Sprenger and Dam,? \\Q2003\\E", "shortCiteRegEx": "Sprenger and Dam", "year": 2003}, {"title": "Automated Reasoning: 33 Basic Research Problems", "author": ["L. Wos"], "venue": "Prentice Hall.", "citeRegEx": "Wos,? 1988", "shortCiteRegEx": "Wos", "year": 1988}, {"title": "Automated Reasoning: Introduction and Applications (Second edition)", "author": ["L. Wos", "R. Overbeek", "E. Lush", "J. Boyle"], "venue": null, "citeRegEx": "Wos et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Wos et al\\.", "year": 1992}], "referenceMentions": [{"referenceID": 29, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 28, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 17, "context": "It is worth mentioning that this iteration cannot be denoted by other term schematisation languages (Chen, Hsiang, & Kong, 1990; Comon, 1995) because the inductive context is not constant.", "startOffset": 100, "endOffset": 141}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 305}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 357}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 417}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 506}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of \u2018schema\u2019 is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given.", "startOffset": 94, "endOffset": 1152}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of \u2018schema\u2019 is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given. The authors overview the state of the art (by describing and comparing most powerful existing systems in use) but structuring proofs is not explicitly mentioned (maybe this feature can be included in what they call \u201cmathematical style\u201d or \u201csupport reasoning with gaps\u201d). In our approach to schemata it is clear that they are a way of structuring proofs and can also help to overcome one of the obstacles to the automation of reasoning pointed out by Wos (1988), i.", "startOffset": 94, "endOffset": 1692}, {"referenceID": 16, "context": "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).", "startOffset": 70, "endOffset": 201}, {"referenceID": 12, "context": "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).", "startOffset": 70, "endOffset": 201}, {"referenceID": 16, "context": "In particular, schemata may have several models, thus implicit induction (Comon, 2001) (which explicitly requires that the underlying Herbrand model is unique) cannot be (directly) used.", "startOffset": 73, "endOffset": 86}, {"referenceID": 26, "context": "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.", "startOffset": 77, "endOffset": 93}, {"referenceID": 20, "context": "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.", "startOffset": 126, "endOffset": 164}, {"referenceID": 30, "context": "In contrast with propositional \u03bccalculus, first-order \u03bc-calculus (Park, 1976) clearly embeds iterated schemata (allowing for instance the above fixed-point expression of \u2227n i=1 pi), but no published research seems to be focused on the identification of complete subclasses.", "startOffset": 65, "endOffset": 77}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.", "startOffset": 81, "endOffset": 94}, {"referenceID": 31, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.", "startOffset": 142, "endOffset": 164}, {"referenceID": 22, "context": ", in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).", "startOffset": 69, "endOffset": 81}, {"referenceID": 15, "context": ", in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).", "startOffset": 96, "endOffset": 142}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it.", "startOffset": 82, "endOffset": 338}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.", "startOffset": 82, "endOffset": 1170}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.", "startOffset": 82, "endOffset": 1199}, {"referenceID": 32, "context": "This is done by providing a set of block tableaux rules (Smullyan, 1968) that are complete w.", "startOffset": 56, "endOffset": 72}, {"referenceID": 18, "context": "This can be detected using decision procedures for arithmetic without multiplication (Cooper, 1972).", "startOffset": 85, "endOffset": 99}, {"referenceID": 11, "context": "In existing work on cyclic proofs, N \u2032 is sometimes called a bud node and N is the companion node of N \u2032 (Brotherston, 2005).", "startOffset": 105, "endOffset": 124}], "year": 2011, "abstractText": "We define a logic of propositional formula schemata adding to the syntax of propositional logic indexed propositions (e.g., pi) and iterated connectives \u2228 or \u2227 ranging over intervals parameterized by arithmetic variables (e.g., \u2227n i=1 pi, where n is a parameter). The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability.", "creator": " TeX output 2011.03.21:1228"}}}