{"id": "1401.3905", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "MAPP: a Scalable Multi-Agent Path Planning Algorithm with Tractability and Completeness Guarantees", "abstract": "Multi-agent path planning is a challenging problem with numerous real-life applications. Running a centralized search such as A* in the combined state space of all units is complete and cost-optimal, but scales poorly, as the state space size is exponential in the number of mobile units. Traditional decentralized approaches, such as FAR and WHCA*, are faster and more scalable, being based on problem decomposition. However, such methods are incomplete and provide no guarantees with respect to the running time or the solution quality. They are not necessarily able to tell in a reasonable time whether they would succeed in finding a solution to a given instance. We introduce MAPP, a tractable algorithm for multi-agent path planning on undirected graphs. We present a basic version and several extensions. They have low-polynomial worst-case upper bounds for the running time, the memory requirements, and the length of solutions. Even though all algorithmic versions are incomplete in the general case, each provides formal guarantees on problems it can solve. For each version, we discuss the algorithms completeness with respect to clearly defined subclasses of instances. Experiments were run on realistic game grid maps. MAPP solved 99.86% of all mobile units, which is 18--22% better than the percentage of FAR and WHCA*. MAPP marked 98.82% of all units as provably solvable during the first stage of plan computation. Parts of MAPPs computation can be re-used across instances on the same map. Speed-wise, MAPP is competitive or significantly faster than WHCA*, depending on whether MAPP performs all computations from scratch. When data that MAPP can re-use are preprocessed offline and readily available, MAPP is slower than the very fast FAR algorithm by a factor of 2.18 on average. MAPPs solutions are on average 20% longer than FARs solutions and 7--31% longer than WHCA*s solutions.", "histories": [["v1", "Thu, 16 Jan 2014 05:21:59 GMT  (1705kb)", "http://arxiv.org/abs/1401.3905v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["ko-hsin cindy wang", "adi botea"], "accepted": false, "id": "1401.3905"}, "pdf": {"name": "1401.3905.pdf", "metadata": {"source": "CRF", "title": "MAPP: a Scalable Multi-Agent Path Planning Algorithm with Tractability and Completeness Guarantees", "authors": ["Ko-Hsin Cindy Wang", "Adi Botea"], "emails": ["CINDY.WANG@RSISE.ANU.EDU.AU", "ADI.BOTEA@NICTA.COM.AU"], "sections": [{"heading": null, "text": "A centralized search such as A * in the combined state space of all units is complete and cost-optimal, but scales poorly because the size of the state space is exponential in the number of mobile units. Traditional decentralized approaches such as FAR and WHCA * are faster and more scalable because they are based on problem decomposition. However, such methods are incomplete and offer no guarantees in terms of runtime or solution quality. They are not necessarily able to say in a reasonable time whether they would be able to find a solution for a given instance. We introduce MAPP, a tractable algorithm for planning multi-agents on undirected charts. We present a basic version and several extensions. They have low polynomial limits on runtime, storage requirements and length of solutions. Although all algorithmic versions of the MAPP are generally incomplete, any formal warranty for problems it can solve provides."}, {"heading": "1. Introduction", "text": "It is important to decide whether there is a solution to most problems, including robotics, military operations, disaster rescue, logistics and commercial games. (There is only a limited number of units that can be moved simultaneously within a common space, the problem becomes much more difficult to present even within a fully known two-dimensional environment as a weighted graph where a unit can be occupied by exactly one unit at a time. It is assumed that units have the same size and each unit moves synchronously to an adjacent unoccupied node in a time step, the problem space grows exponentially in the number of mobile units. Existing hardness results have shown that it is a solution when there is a solution to most movements (Ratner, 1986, 1986, 1986, 1986, 1986, 1986)."}, {"heading": "2. Related Work", "text": "In fact, it is the case that most people who have chosen a different path are able to go it. (...) In fact, it is the case that they are able to move in a different direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. (...) In the other direction, it is the case that they are going in the other direction. \"In the other direction.\" In the other direction. \""}, {"heading": "3. Problem Statement", "text": "The goal is to navigate all units from their initial positions to the targets while avoiding all fixed and mobile obstacles. A state contains the positions of all units at a given time. Our work assumes that each unit can occupy exactly one node at a given time and move to an unoccupied adjacent node. Time is discredited and one or more units can move synchronously at each time step. Our work assumes that each unit can occupy exactly one node at a given time and move to an unoccupied adjacent node."}, {"heading": "5.1 Example", "text": "A simple example of how MAPP works is in Figure 3. There are two units, a and b. MAPP uses a total sequence of active units in each progression step (Section 5.3). Here, a has a higher priority than b. The targets of a and b are drawn as stars. In Figure 3 (i), a is blocked as a and b progress towards their targets by b. In (ii), a blank is placed before a by pushing b down (bold); as a side effect, b is pushed out of its path. At the end of the current progression step (iii), a reaches its goal. In the displacement step (iv), since a is already resolved, a's movements are ignored. The displacement dissolves b's movements until b is back on its path and it has a blank in front of it. Now, b's progressive state is restored, and therefore the global state is well positioned in this example."}, {"heading": "5.2 Path Computation", "text": "To ensure that the paths meet the alternative connection condition (definition 1), we modify the standard A * algorithm as follows. When expanding a node x, \"a neighbor x\" is added to the open list only if there is an alternative path between x \"and x, the parent path of x.\" Through this process, we calculate each path \u03c0 (u) and its family of alternative paths at the same time. To give each neighbor x \"a chance to add an open list, the node x\" could be expanded a maximum of three times, once per possible parent path x. Therefore, O (m) node extensions of A * search are needed to find each path where m is the number of locations on the map."}, {"heading": "5.3 Progression", "text": "If the actual sequence does not affect the accuracy or completeness of the method, but it can have an impact on the speed and length of the solution. The sequence of units can be determined within a progression step, but it can move from one progression step to another, for example, there can be a higher priority for units closer to the target. In this way, these units could arrive at their destination more quickly, and once they are solved, they can get out of the way of the remaining units in the problem. To ensure that lower priority units do not harm the ability of higher priority units to progress, we will introduce the notion of a private zone."}, {"heading": "5.4 Repositioning", "text": "Remember that this happens for a unit u when either pos (u) / \u0445 \u03c0 (u) or u is placed on its pre-calculated path, but the next position on the path is not empty. A repositioning step ensures that a well-positioned state is reached (i.e., all active units have met the progressive condition) before starting the next progression step. A simple and mathematically efficient method of repositioning is to undo a block of the most recent steps performed in the previous progression step. To undo means to perform the reverse step. Solved units are not affected. For the remaining active units, we reverse their movements, in reverse global order, until a well-positioned state is achieved. We call this strategy reverse Reverse Repositioning. An example of this is in Section 5.1.Proposition 9. If the reverse positioning strategy is applied in accordance with period 7 of the algorithm, we can do all (if necessary) steps."}, {"heading": "6. Worst-case and Best-case Analysis", "text": "We give an answer to the question of whether this is a problem where the maximum length of the alternative paths has to be measured. In the worst case, however, it is a small constant in many practical situations, since the ends of such a path are so close together. Our analysis discusses both scenarios. Theorem 10: Algorithm 1 has a worst-case runtime of O (n2m, m2 logm) when it is a constant, and O (n2m2) when it comes to discussing the two scenarios."}, {"heading": "7. Extending the Completeness Range", "text": "In order to extend the completeness of MAPP beyond the SLIDABLE class, we evaluated the effects of each of the three SLIDABLE conditions in a preliminary experiment. We eliminated a SLIDABLE condition at one point in time and counted how many units met the remaining two conditions. A larger increase in the number of solvable units suggests that loosening the definition of the present condition could result in a more significant increase in the completeness range. This initial experimental evaluation indicates that Basic MAPP solves 70.57% of the units with all three SLIDABLE conditions (basic case). If the alternative connectivity requirement is turned off, 87.06% of the units can satisfy the remaining two conditions. Disconnecting the target isolation makes 85.05% of the units satisfactory the remaining two conditions. However, if we ignore empty availability, we only result in a slight increase in the basic availability of 757% of units developed."}, {"heading": "7.1 Relaxing the Target Isolation Condition", "text": "If multiple objectives can be planned in such a way that the (possibly empty) relationship between the two countries can no longer be established, then it is possible that they may turn out to be a \"virtual wall\" only if they cannot achieve their objectives if they have a higher priority than u. (u) It is not possible for them to achieve the objective of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the goal of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of the objective of"}, {"heading": "7.2 Relaxing the Alternate Connectivity Condition", "text": "In this section, we present the buffer zone expansion, our solution for relaxing alternative connectivity conditions allows many routes that correspond to many units to cross the same singlewidth tunnel."}, {"heading": "7.3 Combining Target Isolation and Alternate Connectivity Relaxations", "text": "We show that the two extensions of the SLIDABLE class can be combined with each other.Definition 28. An instance belongs to the extended class, TI + AC SLIDABLE, iff for each unit u there is a path \u03c0 (u) that meets the initial empty condition, as specified in Definition 1, and the relaxed alternative connectivity condition from Definition 22. In addition, the (possibly empty) relationship that was introduced as a result of the target isolation relaxation must be cycle-free, just as in Definition 14. We get an advanced algorithm, TI + AC MAPP, by combining TI MAPP (Definition 15) and AC MAPP (Algorithms 3 and 4). Theorem 29. TI + AC MAPP ends the cycles. Proof. As in the evidence for Lemma 24, we can show that the unit with the highest priority u tunnel reaches its destination as follows."}, {"heading": "8. Improving Solution Length", "text": "As mentioned above, in order to avoid realignment, the units for all active units will not only be affected by the latter units. \"We have observed that in practice, the reverse repositioning strategy (defined in Section 5.4) can introduce many unnecessary movements that can increase the solution length, increase runtime, and affect the visual quality of the solution approaches. We have observed that in a standard implementation step, new movements are added to the solution being built, which are made in reverse order, movements of active units (i.e. those that are not yet resolved) made in the previous step of progression, and the process continues until a well-positioned state is reached, which means that all active units have reached their progressive state (i.e., each active unit has a space in the front).After each step, the well-positioned check is performed globally."}, {"heading": "9. Experimental Results", "text": "In this section, we present our empirical evaluation of the MAPP algorithm, starting with the impact of each new property added, and then testing our TI + AC + RC enhanced MAPP against existing, decoupled, incomplete methods. Specifically, our benchmarks are FAR (Wang & Botea, 2008) and an enhanced version of Silvers (2005) WHCA * algorithm by Sturtevant and Buro (2006), called WHCA * (w, a), which applies abstraction to the costly initial A * searches. As far as MAPP is concerned, these algorithms have been tested for fairly large problems, both in terms of map size and number of units. We are not aware of any other programs that are as scaled as FAR and WHCA *. The strengths of these two methods are the ability to quickly find a solution, but their weakness is that they cannot tell."}, {"heading": "9.1 Scalability as Percentage of Solved Units", "text": "We compare FAR, WHCA * (8.1) and four versions of MAPP."}, {"heading": "9.2 Scalability when Attempting to Solve All Units", "text": "As in the previous section, we compare FAR, WHCA * and MAPP. The version of TI + AC MAPP used here tries to solve all units, not only the demonstrably solvable (try-all function), which is achieved by marking all units as active at the beginning. Active units are divided into three categories: i) demonstrably solvable units that have not achieved their goal; ii) other units that have achieved their goal, but they are still active because other units have yet to cross this place. The entire order of the active units must respect the conditions, the units in category i) have a higher priority than units in category ii), which have a higher priority than units in category iii)."}, {"heading": "9.3 Total Travel Distance", "text": "Factors that may affect the length of the plans are the length of the initial \u03c0 paths and the additional movements caused by blank travel and repositioning. In our experiments, the length of the pre-calculated \u03c0 paths has virtually no negative impact on the travel distance. Even if the \u03c0 paths of the MAPP must meet additional constraints, e.g. if it is possible to evade other targets, they are very similar in length to the normal unrestricted shortest paths and on average only 1.4% longer. In this section, we first evaluate the improvement in repositioning by counting (RC) over standard reverse repositioning. Then, we compare the total distance covered by RC MAPP with FAR and WHCA *."}, {"heading": "9.3.1 REDUCING UNDO MOVES", "text": "Figure 9 shows the advantages of repositioning with counting (RC MAPP), the extension described in Section 8. The figure compares the total distance travelled and the number of undone moves from RC + TI + AC MAPP (abbreviated to RC MAPP) to TI + AC MAPP (abbreviated to MAPP) on average. As shown, repositioning with counting is quite effective and eliminates many unnecessary undone movements (which do not contribute to achieving the globally restored state).Averaged over the entire data set, RC MAPP has a 59.7% shorter undo distance than MAPP with the standard reverse repositioning, resulting in an average reduction of 30.4% in the total distance travelled."}, {"heading": "9.3.2 COMPARING TOTAL DISTANCE WITH FAR AND WHCA*(8,1)", "text": "Compared to FAR and WHCA * (8.1), we increase the total travel distance on average by the subset of input examples that can completely solve all the algorithms considered here. Figures 10 and 11 show average results for all maps. For MAPP, we show the length of the pre-calculated hiking trails, the number of reverse movements (repositioning) and the total distance travelled. In accordance with this performance criterion, the map set is roughly divided into three subranges. In the best case, such as map 307, MAPP leads a shorter distance than WHCA * (8.1) without diagonals in terms of total travel distance and is even comparable to FAR. In an average case, the travel distance of MAPP is roughly comparable to the travel distance of WHCA * without diagonals. Maps 603, 411 and 602 belong to this category."}, {"heading": "9.4 Running Time Analysis", "text": "Because in the case of travel distance analysis, for a meaningful run-time comparison, we limit the analysis to the subset of instances completed by all algorithms (FAR, both versions of WHCA *, and TI + AC + RC MAPP with try-all feature enabled), we show both general summary data, in Tables 2 and 3, and diagrams for all 10 maps, in Figures 12 and 13. Our implementation of the MAPP map builds all the required paths from scratch, including the designated paths. However, most paths between instances on the same map can be reused (WHAR paths containing a destination in the current instance may need to be recalculated. This is a small percentage of all paths, as the number of destinations is typically much smaller than the map size. Such evidence strongly supports the adoption of path calculations offline in one step before processing the map to improve the run-time of the MAPP."}, {"heading": "10. Conclusion", "text": "In fact, most of them are only a very small group, able to move around without being able to achieve their objectives."}, {"heading": "Acknowledgments", "text": "NICTA is funded by the Department of Communications, Information Technology and the Arts of the Australian Government and the Australian Research Council through Backing Australia's Ability and the ICT Research Centre of Excellence. Many thanks to Nathan Sturtevant for providing the HOG framework and helping us understand the program. Many thanks also to Philip Kilby, Jussi Rintanen and Nick Hay for their many helpful comments. We thank the anonymous critics for their valuable feedback."}], "references": [{"title": "Numerical potential field techniques for robot path planning", "author": ["J. Barraquand", "B. Langlois", "Latombe", "J.-C"], "venue": "In International Conference on Advanced Robotics (ICAR),", "citeRegEx": "Barraquand et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Barraquand et al\\.", "year": 1991}, {"title": "Graph Abstraction in Real-time Heuristic Search", "author": ["V. Bulitko", "N. Sturtevant", "J. Lu", "T. Yau"], "venue": "Journal of Artificial Intelligence Research (JAIR),", "citeRegEx": "Bulitko et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bulitko et al\\.", "year": 2007}, {"title": "Principles of Robot Motion: Theory, Algorithms, and Implementation", "author": ["H. Choset", "K. Lynch", "S. Hutchinson", "G. Kantor", "W. Burgard", "L. Kavaraki", "S. Thrun"], "venue": null, "citeRegEx": "Choset et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Choset et al\\.", "year": 2005}, {"title": "On Multiple Moving Objects", "author": ["M. Erdmann", "T. Lozano-Perez"], "venue": "In IEEE International Conference on Robotics and Automation (ICRA),", "citeRegEx": "Erdmann and Lozano.Perez,? \\Q1986\\E", "shortCiteRegEx": "Erdmann and Lozano.Perez", "year": 1986}, {"title": "Biased Cost Pathfinding", "author": ["A. Geramifard", "P. Chubak", "V. Bulitko"], "venue": "In Artificial Intelligence and Interactive Digital Entertainment conference (AIIDE),", "citeRegEx": "Geramifard et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Geramifard et al\\.", "year": 2006}, {"title": "A Formal Basis for the Heuristic Determination of Minimum Cost Paths", "author": ["P. Hart", "N. Nilsson", "B. Raphael"], "venue": "IEEE Transactions on Systems Science and Cybernetics,", "citeRegEx": "Hart et al\\.,? \\Q1968\\E", "shortCiteRegEx": "Hart et al\\.", "year": 1968}, {"title": "On the complexity of motion planning for multiple independent objects: PSPACE-hardness of the \u201cwarehouseman\u2019s problem", "author": ["J.E. Hopcroft", "J.T. Schwartz", "M. Sharir"], "venue": "International Journal of Robotics Research (IJRR),", "citeRegEx": "Hopcroft et al\\.,? \\Q1984\\E", "shortCiteRegEx": "Hopcroft et al\\.", "year": 1984}, {"title": "A New Approach to Cooperative Pathfinding", "author": ["R. Jansen", "N. Sturtevant"], "venue": "In International Conference on Autonomous Agents and Multiagent Systems (AAMAS),", "citeRegEx": "Jansen and Sturtevant,? \\Q2008\\E", "shortCiteRegEx": "Jansen and Sturtevant", "year": 2008}, {"title": "Toward Efficient Trajectory Planning: The Path-Velocity Decomposition", "author": ["K. Kant", "S.W. Zucker"], "venue": "International Journal of Robotics Research (IJRR),", "citeRegEx": "Kant and Zucker,? \\Q1986\\E", "shortCiteRegEx": "Kant and Zucker", "year": 1986}, {"title": "Coordinating pebble motion on graphs, the diameter of permutation groups, and applications", "author": ["D. Kornhauser", "G. Miller", "P. Spirakis"], "venue": "In Proceedings of the 25th Annual Symposium on Foundations of Computer Science (FOCS),", "citeRegEx": "Kornhauser et al\\.,? \\Q1984\\E", "shortCiteRegEx": "Kornhauser et al\\.", "year": 1984}, {"title": "Robot Motion Planning", "author": ["Latombe", "J.-C."], "venue": "Kluwer Academic Publishers.", "citeRegEx": "Latombe and J..C.,? 1991", "shortCiteRegEx": "Latombe and J..C.", "year": 1991}, {"title": "Motion planning on a graph", "author": ["C. Papadimitriou", "P. Raghavan", "M. Sudan", "H. Tamaki"], "venue": "In 35th Annual Symposium on Foundations of Computer Science,", "citeRegEx": "Papadimitriou et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Papadimitriou et al\\.", "year": 1994}, {"title": "Coordinated Unit Movement", "author": ["D. Pottinger"], "venue": "http://www.gamasutra.com/view/ feature/3313/coordinated_unit_movement.php.", "citeRegEx": "Pottinger,? 1999", "shortCiteRegEx": "Pottinger", "year": 1999}, {"title": "A* Speed Optimizations", "author": ["S. Rabin"], "venue": "Deloura, M. (Ed.), Game Programming Gems, pp. 272\u2013287. Charles River Media. Ratner, D., & Warmuth, M. (1986). Finding a shortest solution for the N \u00d7N extension of the 15puzzle is intractable. In Proceedings of AAAI National Conference on Artificial Intelligence (AAAI-86), pp. 168\u2013172.", "citeRegEx": "Rabin,? 2000", "shortCiteRegEx": "Rabin", "year": 2000}, {"title": "Exploiting Subgraph Structure in Multi-Robot Path Planning", "author": ["M.R.K. Ryan"], "venue": "Journal of Artificial Intelligence Research (JAIR), 31, 497\u2013542.", "citeRegEx": "Ryan,? 2008", "shortCiteRegEx": "Ryan", "year": 2008}, {"title": "An Overview of Quadtrees, Octrees, and Related Hierarchical Data Structures", "author": ["H. Samet"], "venue": "NATO ASI Series, Vol. F40.", "citeRegEx": "Samet,? 1988", "shortCiteRegEx": "Samet", "year": 1988}, {"title": "Cooperative Pathfinding", "author": ["D. Silver"], "venue": "Artificial Intelligence and Interactive Digital Entertainment conference (AIIDE), pp. 117\u2013122.", "citeRegEx": "Silver,? 2005", "shortCiteRegEx": "Silver", "year": 2005}, {"title": "Cooperative pathfinding", "author": ["D. Silver"], "venue": "AI Programming Wisdom, 3, 99\u2013111.", "citeRegEx": "Silver,? 2006", "shortCiteRegEx": "Silver", "year": 2006}, {"title": "Finding Optimal Solutions to Cooperative Pathfinding Problems", "author": ["T. Standley"], "venue": "Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence (AAAI-10), pp. 173\u2013178.", "citeRegEx": "Standley,? 2010", "shortCiteRegEx": "Standley", "year": 2010}, {"title": "Smart Moves: Intelligent Pathfinding", "author": ["B. Stout"], "venue": "Game Developer Magazine.", "citeRegEx": "Stout,? 1996", "shortCiteRegEx": "Stout", "year": 1996}, {"title": "Improving collaborative pathfinding using map abstraction", "author": ["N.R. Sturtevant", "M. Buro"], "venue": "In Artificial Intelligence and Interactive Digital Entertainment (AIIDE),", "citeRegEx": "Sturtevant and Buro,? \\Q2006\\E", "shortCiteRegEx": "Sturtevant and Buro", "year": 2006}, {"title": "An Application of Pebble Motion on Graphs to Abstract Multi-robot Path Planning", "author": ["P. Surynek"], "venue": "Proceedings of the 21st International Conference on Tools with Artificial Intelligence (ICTAI), pp. 151\u2013158.", "citeRegEx": "Surynek,? 2009a", "shortCiteRegEx": "Surynek", "year": 2009}, {"title": "A novel approach to path planning for multiple robots in bi-connected graphs", "author": ["P. Surynek"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), pp. 3613\u20133619.", "citeRegEx": "Surynek,? 2009b", "shortCiteRegEx": "Surynek", "year": 2009}, {"title": "An Optimization Variant of Multi-Robot Path Planning is Intractable", "author": ["P. Surynek"], "venue": "Proceedings of the 24th AAAI Conference on Artificial Intelligence (AAAI-10), pp. 1261\u2013 1263.", "citeRegEx": "Surynek,? 2010b", "shortCiteRegEx": "Surynek", "year": 2010}, {"title": "Multi-robot Path Planning, pp", "author": ["P. Surynek"], "venue": "267\u2013290. InTech - Open Access Publisher.", "citeRegEx": "Surynek,? 2010c", "shortCiteRegEx": "Surynek", "year": 2010}, {"title": "Edge-disjoint spanning trees and depth-first search", "author": ["R.E. Tarjan"], "venue": "Acta Informatica, 6(2), 171\u2013185.", "citeRegEx": "Tarjan,? 1976", "shortCiteRegEx": "Tarjan", "year": 1976}, {"title": "Building a Near-Optimal Navigation Mesh", "author": ["P. Tozour"], "venue": "Rabin, S. (Ed.), AI Game Programming Wisdom, pp. 171\u2013185. Charles River Media.", "citeRegEx": "Tozour,? 2002", "shortCiteRegEx": "Tozour", "year": 2002}, {"title": "Fast and Memory-Efficient Multi-Agent Pathfinding", "author": ["Wang", "K.-H. C", "A. Botea"], "venue": "In Proceedings of the International Conference on Automated Planning and Scheduling (ICAPS),", "citeRegEx": "Wang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2008}, {"title": "Tractable Multi-Agent Path Planning on Grid Maps", "author": ["Wang", "K.-H. C", "A. Botea"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Wang et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2009}, {"title": "Scalable Multi-Agent Pathfinding on Grid Maps with Tractability and Completeness Guarantees", "author": ["Wang", "K.-H. C", "A. Botea"], "venue": "In Proceedings of the European Conference on Artificial Intelligence (ECAI),", "citeRegEx": "Wang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2010}, {"title": "A mobile robot navigation exploration algorithm", "author": ["A. Zelinsky"], "venue": "IEEE Transactions of Robotics and Automation, 8(6), 707\u2013717.", "citeRegEx": "Zelinsky,? 1992", "shortCiteRegEx": "Zelinsky", "year": 1992}], "referenceMentions": [{"referenceID": 23, "context": "Existing hardness results have shown that it is NP-complete to decide if a solution of at most k moves exists (Ratner & Warmuth, 1986), or to optimize the solution makespan (Surynek, 2010b).", "startOffset": 173, "endOffset": 189}, {"referenceID": 17, "context": "However, existing decentralized methods such as FAR (Wang & Botea, 2008) and WHCA* (Silver, 2006) are incomplete, and provide no formal criteria to distinguish between problem instances that can be successfully solved and other instances.", "startOffset": 83, "endOffset": 97}, {"referenceID": 5, "context": "Finding a shortest path that connects a single pair of start-target points on a known, finite map can be optimally solved with the A* algorithm (Hart et al., 1968).", "startOffset": 144, "endOffset": 163}, {"referenceID": 18, "context": "Moreover, most of the search nodes generated are \u2018unpromising\u2019, taking some units farther from goal (Standley, 2010).", "startOffset": 100, "endOffset": 116}, {"referenceID": 19, "context": "On the other hand, a purely decentralized method, Local Repair A* (LRA*) (Stout, 1996) first plans each unit\u2019s path independently with A*.", "startOffset": 73, "endOffset": 86}, {"referenceID": 2, "context": "Traditionally, multi-agent path planning took a centralised or a decentralised approach (Latombe, 1991; Choset et al., 2005).", "startOffset": 88, "endOffset": 124}, {"referenceID": 4, "context": "Finding a shortest path that connects a single pair of start-target points on a known, finite map can be optimally solved with the A* algorithm (Hart et al., 1968). The extension to path planning for multiple simultaneously moving units, with distinct start and target positions, introduces potential collisions due to the physical constraint that one location can only be occupied by one unit at a time. Units have to interact and share information with other units in their path planning, making the problem more complex. In multi-agent path planning, a centralized A* performs a single global search in the combined state space L1 \u00d7 L2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln for n units, where Li is the set of possible locations of unit i. Centralized A* plans the paths for all units simultaneously, finding a joint plan containing all units\u2019 actions (waits as well as moves). It retains the optimality and completeness guarantees of A*, but has a prohibitively large state space ofO(mn) states, for n units on a graph withm nodes. Moreover, most of the search nodes generated are \u2018unpromising\u2019, taking some units farther from goal (Standley, 2010). This poses a strong limiting factor on problems that a centralized A* can solve in practice. On the other hand, a purely decentralized method, Local Repair A* (LRA*) (Stout, 1996) first plans each unit\u2019s path independently with A*. Then, during execution, LRA* replans by additional independent A* searches every time a collision occurs. In a good case, LRA* can significantly reduce computations toO(mn). However, it can also generate cycles between units, and is unable to prevent bottlenecks. These problems have been discussed by Silver (2005), Bulitko, Sturtevant, Lu, and Yau (2007), Pottinger (1999), and Zelinsky (1992).", "startOffset": 145, "endOffset": 1677}, {"referenceID": 4, "context": "Finding a shortest path that connects a single pair of start-target points on a known, finite map can be optimally solved with the A* algorithm (Hart et al., 1968). The extension to path planning for multiple simultaneously moving units, with distinct start and target positions, introduces potential collisions due to the physical constraint that one location can only be occupied by one unit at a time. Units have to interact and share information with other units in their path planning, making the problem more complex. In multi-agent path planning, a centralized A* performs a single global search in the combined state space L1 \u00d7 L2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln for n units, where Li is the set of possible locations of unit i. Centralized A* plans the paths for all units simultaneously, finding a joint plan containing all units\u2019 actions (waits as well as moves). It retains the optimality and completeness guarantees of A*, but has a prohibitively large state space ofO(mn) states, for n units on a graph withm nodes. Moreover, most of the search nodes generated are \u2018unpromising\u2019, taking some units farther from goal (Standley, 2010). This poses a strong limiting factor on problems that a centralized A* can solve in practice. On the other hand, a purely decentralized method, Local Repair A* (LRA*) (Stout, 1996) first plans each unit\u2019s path independently with A*. Then, during execution, LRA* replans by additional independent A* searches every time a collision occurs. In a good case, LRA* can significantly reduce computations toO(mn). However, it can also generate cycles between units, and is unable to prevent bottlenecks. These problems have been discussed by Silver (2005), Bulitko, Sturtevant, Lu, and Yau (2007), Pottinger (1999), and Zelinsky (1992).", "startOffset": 145, "endOffset": 1718}, {"referenceID": 4, "context": "Finding a shortest path that connects a single pair of start-target points on a known, finite map can be optimally solved with the A* algorithm (Hart et al., 1968). The extension to path planning for multiple simultaneously moving units, with distinct start and target positions, introduces potential collisions due to the physical constraint that one location can only be occupied by one unit at a time. Units have to interact and share information with other units in their path planning, making the problem more complex. In multi-agent path planning, a centralized A* performs a single global search in the combined state space L1 \u00d7 L2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln for n units, where Li is the set of possible locations of unit i. Centralized A* plans the paths for all units simultaneously, finding a joint plan containing all units\u2019 actions (waits as well as moves). It retains the optimality and completeness guarantees of A*, but has a prohibitively large state space ofO(mn) states, for n units on a graph withm nodes. Moreover, most of the search nodes generated are \u2018unpromising\u2019, taking some units farther from goal (Standley, 2010). This poses a strong limiting factor on problems that a centralized A* can solve in practice. On the other hand, a purely decentralized method, Local Repair A* (LRA*) (Stout, 1996) first plans each unit\u2019s path independently with A*. Then, during execution, LRA* replans by additional independent A* searches every time a collision occurs. In a good case, LRA* can significantly reduce computations toO(mn). However, it can also generate cycles between units, and is unable to prevent bottlenecks. These problems have been discussed by Silver (2005), Bulitko, Sturtevant, Lu, and Yau (2007), Pottinger (1999), and Zelinsky (1992).", "startOffset": 145, "endOffset": 1736}, {"referenceID": 4, "context": "Finding a shortest path that connects a single pair of start-target points on a known, finite map can be optimally solved with the A* algorithm (Hart et al., 1968). The extension to path planning for multiple simultaneously moving units, with distinct start and target positions, introduces potential collisions due to the physical constraint that one location can only be occupied by one unit at a time. Units have to interact and share information with other units in their path planning, making the problem more complex. In multi-agent path planning, a centralized A* performs a single global search in the combined state space L1 \u00d7 L2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln for n units, where Li is the set of possible locations of unit i. Centralized A* plans the paths for all units simultaneously, finding a joint plan containing all units\u2019 actions (waits as well as moves). It retains the optimality and completeness guarantees of A*, but has a prohibitively large state space ofO(mn) states, for n units on a graph withm nodes. Moreover, most of the search nodes generated are \u2018unpromising\u2019, taking some units farther from goal (Standley, 2010). This poses a strong limiting factor on problems that a centralized A* can solve in practice. On the other hand, a purely decentralized method, Local Repair A* (LRA*) (Stout, 1996) first plans each unit\u2019s path independently with A*. Then, during execution, LRA* replans by additional independent A* searches every time a collision occurs. In a good case, LRA* can significantly reduce computations toO(mn). However, it can also generate cycles between units, and is unable to prevent bottlenecks. These problems have been discussed by Silver (2005), Bulitko, Sturtevant, Lu, and Yau (2007), Pottinger (1999), and Zelinsky (1992). In such cases, LRA* exhibits a significant increase in running time and may not terminate.", "startOffset": 145, "endOffset": 1757}, {"referenceID": 2, "context": "Traditionally, multi-agent path planning took a centralised or a decentralised approach (Latombe, 1991; Choset et al., 2005). A centralized approach plans globally, sharing information centrally, such as using a potential field (Barraquand, Langlois, & Latombe, 1991). By contrast, a decentralized approach decomposes the problem into a series of smaller subproblems, typically first computing the units\u2019 paths individually, ignoring all other units, then handling the interactions online. Examples in robotics include computing velocity profiles to avoid collisions with other units (Kant & Zucker, 1986), or pre-assigning priorities to process robots one by one (Erdmann & LozanoPerez, 1986). Recent algorithms can also use a combination of the two approaches. For instance, the Biased Cost Pathfinding (BCP) technique (Geramifard, Chubak, & Bulitko, 2006) generalised the notion of centralized planning to a central decision maker that resolves collision points on paths that were pre-computed independently per unit, by replanning colliding units around a highestpriority unit. To avoid excessively long (or even potentially unbounded) conflict resolutions, a limit on planning time is set. BCP returns paths with the fewest collisions within that time. The algorithm was shown to work well in small-scale gridworld scenarios, but it is not complete or optimal in the general case. Standley\u2019s (2010) algorithm, on the other hand, improved the \u201cstandard\u201d centralized search whilst preserving both optimality and completeness.", "startOffset": 104, "endOffset": 1404}, {"referenceID": 16, "context": "Standley\u2019s (2010) experiments showed that the incomplete algorithm HCA* (Silver, 2005) actually solved more instances.", "startOffset": 72, "endOffset": 86}, {"referenceID": 17, "context": "Recent work on grid maps include WHCA* (Silver, 2006), which uses a 3-dimensional temporal-spatial reservation table and performs a series of windowed forward searches on each unit, based on a true distance heuristic obtained from an initial backward A* search from each target.", "startOffset": 39, "endOffset": 53}, {"referenceID": 22, "context": "BIBOX (Surynek, 2009b) solves problems with at least 2 unoccupied vertices on a biconnected graph.", "startOffset": 6, "endOffset": 22}, {"referenceID": 21, "context": "BIBOX was later extended to work with just 1 unoccupied vertex necessary (Surynek, 2009a).", "startOffset": 73, "endOffset": 89}, {"referenceID": 14, "context": "Recognising that it is much cheaper to perform several independent searches than one global search, Standley also decoupled planning for non-interfering subgroups of units after an independence detection (ID). Each group is then solved centrally such that optimality of the overall solution is still guaranteed. The fully developed hybrid algorithm, OD+ID, uses operator decomposition to improve the centralized planning of non-independent subproblems. Nonetheless, the optimality requirement is costly in practice. Planning time is still dominated by the largest subgroup of units. As the number of units increases, they are less likely to be independent as their paths unavoidably overlap, so the subgroups are expected to increase in size too. Standley\u2019s (2010) experiments showed that the incomplete algorithm HCA* (Silver, 2005) actually solved more instances.", "startOffset": 100, "endOffset": 765}, {"referenceID": 7, "context": "Other \u2018flow\u2019 related ideas include Jansen and Sturtevant\u2019s (2008) direction map for sharing information about units\u2019 directions of travel, so later units can follow the movement of earlier ones, with the improved coherence leading to reduced collisions.", "startOffset": 35, "endOffset": 66}, {"referenceID": 7, "context": "Other \u2018flow\u2019 related ideas include Jansen and Sturtevant\u2019s (2008) direction map for sharing information about units\u2019 directions of travel, so later units can follow the movement of earlier ones, with the improved coherence leading to reduced collisions. Methods such as these scale up to instances with the number of units well beyond the capabilities of centralized search. However, as mentioned earlier, these methods have no known formal characterizations of their running time, memory requirements, and the quality of their solutions in the worst case. They lack the ability to answer in a reasonable bounded time whether a given problem would be successfully solved, which is always important in the case of incomplete algorithms. In practice, both traditional approaches to multi-agent pathfinding have serious drawbacks, with the inherent trade-off between scalability, optimality and completeness. Recently, a body of work has begun to bridge the gap between the two, by addressing both completeness and tractability issues hand in hand, in a bounded suboptimal approach. Ryan (2008) introduced a complete method that combines multi-agent path planning with hierarchical planning on search graphs with specific substructures such as stacks, halls, cliques and rings.", "startOffset": 35, "endOffset": 1092}, {"referenceID": 7, "context": "Other \u2018flow\u2019 related ideas include Jansen and Sturtevant\u2019s (2008) direction map for sharing information about units\u2019 directions of travel, so later units can follow the movement of earlier ones, with the improved coherence leading to reduced collisions. Methods such as these scale up to instances with the number of units well beyond the capabilities of centralized search. However, as mentioned earlier, these methods have no known formal characterizations of their running time, memory requirements, and the quality of their solutions in the worst case. They lack the ability to answer in a reasonable bounded time whether a given problem would be successfully solved, which is always important in the case of incomplete algorithms. In practice, both traditional approaches to multi-agent pathfinding have serious drawbacks, with the inherent trade-off between scalability, optimality and completeness. Recently, a body of work has begun to bridge the gap between the two, by addressing both completeness and tractability issues hand in hand, in a bounded suboptimal approach. Ryan (2008) introduced a complete method that combines multi-agent path planning with hierarchical planning on search graphs with specific substructures such as stacks, halls, cliques and rings. For example, a stack is a narrow corridor with only one entrance, which is placed at one end of the stack. Many maps, including the game maps used in our experiments, seem not to allow an efficient decomposition into stacks, halls, cliques and rings. BIBOX (Surynek, 2009b) solves problems with at least 2 unoccupied vertices on a biconnected graph. In the worst case, the number of steps is cubic in the number of nodes. BIBOX was later extended to work with just 1 unoccupied vertex necessary (Surynek, 2009a). Because of the densely populated problems that the algorithm was designed for, Surynek (2010a) has expressed that BIBOX does not target computer game scenarios, where there are normally a lot fewer units than locations on the map.", "startOffset": 35, "endOffset": 1883}, {"referenceID": 24, "context": "inside a warehouse (Surynek, 2010c).", "startOffset": 19, "endOffset": 35}, {"referenceID": 21, "context": "Bibox-\u03b8 (Surynek, 2009a), that requires only 1 unoccupied node, was shown to run significantly faster and have significantly shorter solutions than Kornhauser, Miller, and Spirakis\u2019s (1984) algorithm for their related \u2018pebble coordination game\u2019.", "startOffset": 8, "endOffset": 24}, {"referenceID": 21, "context": "inside a warehouse (Surynek, 2010c). Bibox-\u03b8 (Surynek, 2009a), that requires only 1 unoccupied node, was shown to run significantly faster and have significantly shorter solutions than Kornhauser, Miller, and Spirakis\u2019s (1984) algorithm for their related \u2018pebble coordination game\u2019.", "startOffset": 20, "endOffset": 227}, {"referenceID": 26, "context": "Several methods exist to abstract a problem map into a search graph, including navigation meshes (Tozour, 2002), visibility points (Rabin, 2000), and quadtrees (Samet, 1988).", "startOffset": 97, "endOffset": 111}, {"referenceID": 13, "context": "Several methods exist to abstract a problem map into a search graph, including navigation meshes (Tozour, 2002), visibility points (Rabin, 2000), and quadtrees (Samet, 1988).", "startOffset": 131, "endOffset": 144}, {"referenceID": 15, "context": "Several methods exist to abstract a problem map into a search graph, including navigation meshes (Tozour, 2002), visibility points (Rabin, 2000), and quadtrees (Samet, 1988).", "startOffset": 160, "endOffset": 173}, {"referenceID": 25, "context": "Moreover, note the additional step after path pre-computation for topologically sorting the partial order, \u227a, into a linear priority order <, can be done cheaply in time linear on the number of units (Tarjan, 1976).", "startOffset": 200, "endOffset": 214}, {"referenceID": 16, "context": "Specifically, our benchmarks are FAR (Wang & Botea, 2008), and an extended version of Silver\u2019s (2005) WHCA* algorithm by Sturtevant and Buro (2006), called WHCA*(w,a), which applies abstraction to the expensive initial backward A* searches.", "startOffset": 86, "endOffset": 102}, {"referenceID": 16, "context": "Specifically, our benchmarks are FAR (Wang & Botea, 2008), and an extended version of Silver\u2019s (2005) WHCA* algorithm by Sturtevant and Buro (2006), called WHCA*(w,a), which applies abstraction to the expensive initial backward A* searches.", "startOffset": 86, "endOffset": 148}, {"referenceID": 20, "context": "This seems to be a good parameter setting in the work of Sturtevant and Buro (2006), and our experiments comparing with WHCA*(20,1) show WHCA*(8,1) to work better on this data set.", "startOffset": 57, "endOffset": 84}], "year": 2011, "abstractText": "Multi-agent path planning is a challenging problem with numerous real-life applications. Running a centralized search such as A* in the combined state space of all units is complete and cost-optimal, but scales poorly, as the state space size is exponential in the number of mobile units. Traditional decentralized approaches, such as FAR and WHCA*, are faster and more scalable, being based on problem decomposition. However, such methods are incomplete and provide no guarantees with respect to the running time or the solution quality. They are not necessarily able to tell in a reasonable time whether they would succeed in finding a solution to a given instance. We introduce MAPP, a tractable algorithm for multi-agent path planning on undirected graphs. We present a basic version and several extensions. They have low-polynomial worst-case upper bounds for the running time, the memory requirements, and the length of solutions. Even though all algorithmic versions are incomplete in the general case, each provides formal guarantees on problems it can solve. For each version, we discuss the algorithm\u2019s completeness with respect to clearly defined subclasses of instances. Experiments were run on realistic game grid maps. MAPP solved 99.86% of all mobile units, which is 18\u201322% better than the percentage of FAR and WHCA*. MAPP marked 98.82% of all units as provably solvable during the first stage of plan computation. Parts of MAPP\u2019s computation can be re-used across instances on the same map. Speed-wise, MAPP is competitive or significantly faster than WHCA*, depending on whether MAPP performs all computations from scratch. When data that MAPP can re-use are preprocessed offline and readily available, MAPP is slower than the very fast FAR algorithm by a factor of 2.18 on average. MAPP\u2019s solutions are on average 20% longer than FAR\u2019s solutions and 7\u201331% longer than WHCA*\u2019s solutions.", "creator": "TeX"}}}