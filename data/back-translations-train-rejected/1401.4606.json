{"id": "1401.4606", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jan-2014", "title": "Drake: An Efficient Executive for Temporal Plans with Choice", "abstract": "This work presents Drake, a dynamic executive for temporal plans with choice. Dynamic plan execution strategies allow an autonomous agent to react quickly to unfolding events, improving the robustness of the agent. Prior work developed methods for dynamically dispatching Simple Temporal Networks, and further research enriched the expressiveness of the plans executives could handle, including discrete choices, which are the focus of this work. However, in some approaches to date, these additional choices induce significant storage or latency requirements to make flexible execution possible.", "histories": [["v1", "Sat, 18 Jan 2014 21:10:40 GMT  (641kb)", "http://arxiv.org/abs/1401.4606v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["patrick raymond conrad", "brian williams"], "accepted": false, "id": "1401.4606"}, "pdf": {"name": "1401.4606.pdf", "metadata": {"source": "CRF", "title": "Drake: An Efficient Executive for Temporal Plans with Choice", "authors": ["Patrick R. Conrad", "Brian C. Williams"], "emails": ["prconrad@mit.edu", "williams@mit.edu"], "sections": [{"heading": null, "text": "We use the concepts of labels and environments derived from previous work in Assumptionbased Truth Maintenance Systems (ATMS) to concisely capture the implications of discrete decisions and exploit the structure of the plan to avoid redundant reasoning or storage. Our labeling and maintenance program, known as the Labeled Value Set Maintenance System, is distinguished by its focus on properties that are fundamental to time problems, and, more generally, weighted graph algorithms. Specifically, the maintenance system focuses on maintaining a minimal representation of undominated constraints. We measure Drake's performance on randomly structured problems and find that Drake's size of compiled representation reduces by a factor of more than 500 when faced with major problems, while latency increases relative to previous work in compiled executives with discrete decisions."}, {"heading": "1. Introduction", "text": "It is indeed the case that most people who are able to determine themselves, to determine themselves, what they want and what they want, do not allow themselves to be led astray. (...) It is not the case that they are led astray. (...) It is not the case that they are led astray. (...) It is the case that they are led astray. (...) It is the case that they are led astray. (...) It is the case that they are led astray. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (...) It is the case. (... It is the case. (...) It is the case. (... It is.) It is the case. (... It is the case. (... It is the case.) It is the case. (... It is the case."}, {"heading": "1.1 Overview of the Problem", "text": "Drake's output is a dynamic execution of the plan, in which it determines in real time when the events should be executed, so that at the end of the plan the execution times are consistent with any time constraints implied by at least a full set of decisions, excluding unforeseen disruptions. If external disruptions make any possible execution inconsistent, Drake signals failure once all possible solutions are made inconsistent. Section 3 provides a formal definition of the marked STNs; essentially, it is a collection of events that the executive must follow."}, {"heading": "1.2 Approach: Exploiting Shared Structure through Labeling", "text": "Drake's strategy during the compilation is to start with the described STN structure, since a concise statement is made about the time constraints and the decisions in the plan. Then Drake constructs the described distance graph associated with the described STN, resulting in a single graph structure that represents all possible decisions and constraints. Next, Drake's Compiler calculates the shippable form of the problem, which is also a described distance graph graph. This compilation is carried out in a unified process that is able to use all similarities between decisions to make the representation compact. In contrast, the previous work by Tsamardinos et al. (2001), the input plan breaks down into independent STNs, hence their compilation strategy can exploit no similarities or shared structures between decisions. There are pathological cases where each choice is completely independent, where there are no similarities for wires to be exploited in independent STNs, hence their compilation strategy is unable to exploit any similarities or shared structures between decisions. There are pathological cases where each choice is where there is no similarities for wires, in order to make them more human, because we expect some structure to be incorporated, however, or almost any structure."}, {"heading": "2. Related Work", "text": "Before we develop Drake, we will review some relevant literature in the two main areas from which Drake draws: planning frameworks and truth management."}, {"heading": "2.1 Scheduling Frameworks and Executives", "text": "As explained in the introduction, in order to achieve robustness, we need leaders who make decisions dynamically and with low latency via expressive temporal representations. There are well-known methods of manipulation and reasoning via simple temporal networks that have been used as the basis for most decisions in temporal managers. In addition, we have formulated and developed numerous efforts to include other useful characteristics such as uncertainty, preferences, and discrete decisions. However, we briefly consider some of these efforts. As our work focuses on discrete decisions, we discuss several efforts to build dynamic leaders for these plans in more detail. These leaders typically use one of two approaches: they argue on all plans in parallel, or alternate between plans. However, these approaches are typically either too memory-intensive or may have high latency. Temporal Restrictions Networks (TCNs) formalized by Dechter, Meiri, and Pearl (1991) capture many qualitative and metric temporary representations that are introduced by the community."}, {"heading": "2.2 Background on ATMSs", "text": "Stallman and Sussman (1977) introduced the deeply useful idea of tracking the dependence of deductions in computer-aided diagnostics to focus the search for unified component mapping during transistor switching. The dependencies that exist on solving the equations make it possible to make those decisions that are actually responsible for failure. They generalize this approach of combinatorial search by introducing dependency-oriented backtracking algorithms that ensure that the search goes far enough to ensure that the newly found inconsistencies are actually removed."}, {"heading": "3. Dynamic Execution of STNs and Labeled STNs", "text": "Now we are ready to present the formal representation of the schedules Drake uses. Plans consist of actions that need to be executed at executable times, defining feasible times by limiting the start and end times of the plan activities. Our work is based on Simple Temporal Networks and we start by explaining how STNs restrict the events of a plan and their executable execution. We extend these definitions to discrete decisions, resulting in marked STNs."}, {"heading": "3.1 Simple Temporal Networks", "text": "A simple temporal network is defined as a series of events linked by binary interval constraints, referred to as simple interval constraints (Dechter et al., 1991).Definition 3.1 (Event) An event is a real variable whose value is the execution time of the event. Definition 3.2 (Simple interval constraint) A simple interval constraint < A, B, l, u > between two events A and B requires that l \u2264 B \u2212 A \u2264 u, denotes [l, u].Conventionally u is not negative. The lower limit l can be positive if there is a strict sequence of events, or negative if there is no strict sequence. Positive or negative infinity can be used within the boundaries to represent an unrestricted interval shift."}, {"heading": "3.2 Adding Choice: Labeled STNs", "text": "This chapter defines our central concept of representation, labels STNs, a variant of STNs that include all single variables. < < / p > p > p > p > p > p > p > p > p > p > p > p {p} p {p} p {p} p {p} p {p} p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p.\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"."}, {"heading": "4. Distance Graphs and Temporal Reasoning", "text": "Dechter et al. (1991) showed that STN reasoning can be reformulated as a short-term path problem = A = 1.2 simple distance diagrams. This connection is important because weighted diagrams are easy to manipulate and have a well-developed theory and efficient algorithms, so most practical algorithms for STNs are based on this connection. Drake follows the previous literature by implementing the temporal reasoning as a labeled version of the shortest path problems. This section begins to develop formalism for described values and described distance diagrams, which allow us to present the shortest path problems and algorithms in a compact way. We begin by reviewing the transformation for STNs.Definition 4.1 (Distance diagram associated with a STN) A distance diagram associated with a STN is a pair < V > of shortcuts V and edge weights W. Each event is associated with a vertex in STN events."}, {"heading": "5. Labeled Value Set Maintenance System", "text": "The previous section defines the representation for labeled distance charts and labeled value sets; this section provides tools for manipulating these values. < The primary focus of labeled value sets is to maintain only unlabeled value pairs that make the labeled value sets compact and efficient. < This section introduces three concepts. First, we describe how to extract values from a labeled value set that allows us to find the dominant values implied by an environment. Second, how to handle assignments to decisions that are inconsistent. Third, how to apply functions to labeled value sets that allow us to compute on them. First, we define the query that allows us to extract the precise dominant value guaranteed under a given environment. Definition 5.1 (labeled Value Set Query) The query operator A (e) is defined for labeled value sets and A."}, {"heading": "6. Dispatching Plans with Choice", "text": "Given this foundation in marked STNs, marked value sets, and marked distance diagrams, we turn to the central focus of this article - the dynamic execution of marked STNs. Let's remember that the dispatcher uses a local, greedy algorithm to make decisions about runtime with low latency, and that the accuracy of this approach is guaranteed by the compilation step. We start with the dispatcher because low latency execution is the basic goal of this work, and because, as in previous work, the compiler is designed to produce an output appropriate for this dispatcher. We adapt the STN dispatcher developed by Muscettola et al. (1998) to work with shipped marked distance diagrams. Essentially, Drake's algorithms replace real number limits at execution times, as in the STN dispatcher, with marked value sets. In addition, we adapt Tsamardinos et al (2001) to accept the current approach, to at least one option for the current event."}, {"heading": "6.1 STN Dispatching", "text": "Muscettola et al. (1998) demonstrated that in the face of a dispatchable form of STN, a simple greedy dispatcher can correctly execute the network with updates that are executed only on adjacent events. < B) If the dispatcher has the unexecuted events in each time step, he can select an event to execute if possible, or else wait until the next time step is completed. This process continues until either all events are executed or an error is detected. Determining whether an event is executable is based on two tests. First, the dispatcher tests whether the ordering restrictions of an event have been met, which is called a test for enablement. A simple time restriction implies a strict ordering between two events that the dispatcher must explicitly test to ensure that an event is not planned before an event that it must precede it. Second, the dispatcher efficiently tracks the consequences of the simple time constraints between each event and its neighbor's calculation window."}, {"heading": "6.2 Labeled STN Dispatching", "text": "Since edge weights are labeled as value sets, the execution windows are also referred to as value sets, meaning that the upper and lower limits of execution times for events may vary and vary separately depending on the choices available. For any limitation or authorization restriction, Drake's executive officer must either enforce the restriction or discard the restriction and choose not to select the associated environment, which is the same strategy as Tsamardinos et al. (2001), where the components STNs are sent in parallel, and proposed execution decisions can be accepted if they start with at least one STN.We start by updating the propagation rules to derive execution windows. STN propagations include adding edge weights (or negative weights) at the execution time of an event."}, {"heading": "7. Compiling Labeled Distance Graphs", "text": "We complete the description of Drake with the compiler, which reformats the input labeled STN in a form that the dispatcher does not need to execute correctly; the compiler uses all the markup concepts we have used to efficiently compute a compact, shipable form of input plans; an STN compiler takes a distance diagram as its input and output form; and outputs a different distance diagram that represents a minimal, shipable form of input and execution; (1998) he introduced an initial set of two-step algorithms for STNs; first, he computes the All-Pairs Shortest Path (APSP) graph associated with the STN, which is itself a shipable form."}, {"heading": "7.1 Johnson\u2019s Algorithm and the Structure of the Fast Algorithm", "text": "Many shortest path algorithms on weighted distance curves essentially result in repeated relaxation over the graph. Floyd-Warshall repeatedly grinds over the entire graph, loosens the edges, and computes the entire APSP in a single calculation. \u2192 Johnson's algorithm calculates the APSP one source point at a time, using Dijkstra's SSSP algorithm as an inner loop to perform the relaxations more efficiently. Since Dijkstra's algorithm only works for positively weighted graphs, the graph is re-weighted before Dijkstra's call and then not weighted. Unfortunately, adapting the Dijkstra algorithm to the labeled distance diagrams is inefficient because it both adds and subtracts the labeled value sets, and both are incompatible with a single order."}, {"heading": "7.2 Labeled Bellman-Ford Algorithm", "text": "The value of this diagram is the vertex loop over the edges and then tests for negative cycles to make sure the result is valid. d [v] is the distance of the vertex v from the input source. [v] is the vertex loop, which is the (not necessarily unique) predecessor of v if it is a shortest path from s to v. Relating to Figure 7.2b, d is the annotation next to the vertex. [v] is the vertex loop, which is the (not necessarily unique) predecessor of v if it is a shortest path from s to v. Relating to Figure 7.2b."}, {"heading": "7.3 Traversals of Labeled Predecessor Graphs", "text": "The quick compilation of algorithms for STNs performs transversals of the predecessor graphs produced by the SSSP analysis, and checks each edge along the transversals for dominance. This is used to reduce the graph to a minimum processable shape. In the undescribed case, however, more care is needed to understand which paths are valid under complete environments to take into account the projection of the predecessor graph under a particular complete environment. The result is the shortest path distance and any predecessors that produce a standard unlabeled predecessor graphic.Algorithm 7.2 Labeled Bellman-Ford Algorithm1: Procedure LabeledBellFord (V, E, W, S) for the shortest path distance and any predecessors that produce a standard unlabeled predecessor graphic1."}, {"heading": "7.4 Pruning Dominated Edges with the SSSP", "text": "With the strategy for finding paths through the highlighted predecessor diagrams 7.10 Figure 7.5, we show two simple examples on which we can apply these two distances 7.7. The extension of the clipping algorithm from the quick STN compilation algorithm is 7.7. (This also applies to the preceding diagrams in the preceding diagrams, which are slightly adapted for our notation. In the following, it is assumed that A is considered as the origin diagram for the original diagrams of the SSSP, and B and C are other vertices.Theorem 7.8 A negative edge (A, C) is dominated by a negative edge (A, B) is considered marginally for our notation, if and only if there is a path from B to C in the preceding diagrams for A.Theorem 7.9 is not negative edge (A, C), if there is a vertex B, subordinated by a negative edge (A, C), and if there is only a path from B, if there is one from B, and only one from B, if there is a negative edge (B)."}, {"heading": "7.5 Mutual Dominance and Rigid Components", "text": "In fact, most of them are able to survive on their own."}, {"heading": "8. Results", "text": "Finally, we examine Drake's performance both theoretically and experimentally; our analysis provides some justification for why we expect Drake's performance to be compact, and our experimental results prove that Drake is performing as intended."}, {"heading": "8.1 Theoretical Results", "text": "We give a brief description of the analytical worst-case performance of Drake's algorithms. The direct enumeration of STNs, as in Tsamardinos et al. \"s (2001) work, uses an STN for each consistent STN. If there are n decisions with d options and v vertices, and we assume that the compiled sparse diagrams are of size O (v log v), then the compiledsize is O (ndv log v). In contrast, Drake does not store the component STNs independently, but only stores the different values, so the size O (kv log v) is where k \u2264 nd is. In the worst case, if each individual component STN is completely different, there are no similarities between the choices, hence Drake's compiled representation is the same size, but never worse, up to a constant. There is a strong parallel to the existing theory about tree widths of general constraint satisfaction problems."}, {"heading": "8.2 Experimental Results", "text": "This section presents an experimental validation of Drake's compiling and shipping algorithms on randomly generated, structured problems7. First, we develop a series of randomly structured STNs derived from Stedl's (2004) problem generator. Then, we compile and ship the suites of problems twice, once with Drake and once by explicitly enumerating all STNs components, following techniques developed by Tsamardinos et al. (2001). Finally, we compare the compiled size of the problems, the compilation time and the execution latency. In this section, we use the number of consistent components of STNs as a horizontal axis because it correlates well with the effective difficulty of the problem. For each of the metrics, we deliver the results from the two methods side by side in one plot and show the ratio of performance in another to allow a point-by-point comparison of performance differences between identical problems."}, {"heading": "9. Summary", "text": "This work introduces Drake, a compact, flexible manager for plans with choice. Drake takes input plans with time flexibility and discrete decisions, such as labeled STNs or DTNs, and selects execution times and makes discrete decisions about runtime (Dechter et al., 1991). Decisions improve the meaningfulness of the tasks that executives can perform, and improve the robustness of the resulting executions. Previous execution approaches typically impose significant memory requirements or introduce substantial latency times during execution. Drake's goal in developing Drake is to develop a distributive executive with a lower memory footage.Building on the concept of labels used by ATMS to encode compactly all the consequences of a series of alternative decisions, Drake introduces a new compact coding called distance diagrams to encode discrete decisions efficiently and create an algorithm that we call an algorithm."}, {"heading": "Acknowledgments", "text": "The authors thank Julie Shah and David Wang for many helpful ideas and discussions, and the reviewers for their insightful comments. Patrick Conrad was funded by an NDSEG Fellowship of the Ministry of Defense during this work."}], "references": [{"title": "Robust execution of contingent, temporally flexible plans", "author": ["S. Block", "A. Wehowsky", "B. Williams"], "venue": "In Proceedings of the 21st National Conference on Artificial Intelligence,", "citeRegEx": "Block et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Block et al\\.", "year": 2006}, {"title": "Controllability in temporal conceptual workflow schemata", "author": ["C. Combi", "R. Posenato"], "venue": "Business Process", "citeRegEx": "Combi and Posenato,? \\Q2009\\E", "shortCiteRegEx": "Combi and Posenato", "year": 2009}, {"title": "Towards temporal controllabilities for workflow schemata", "author": ["C. Combi", "R. Posenato"], "venue": "In Proceedings of the 17th International Symposium on Temporal Representation and Reasoning,", "citeRegEx": "Combi and Posenato,? \\Q2010\\E", "shortCiteRegEx": "Combi and Posenato", "year": 2010}, {"title": "Flexible execution of plans with choice and uncertainty", "author": ["P.R. Conrad"], "venue": null, "citeRegEx": "Conrad,? \\Q2010\\E", "shortCiteRegEx": "Conrad", "year": 2010}, {"title": "Flexible execution of plans with choice", "author": ["P.R. Conrad", "J.A. Shah", "B.C. Williams"], "venue": "In Proceedings of the Nineteenth International Conference on Automated Planning and Scheduling", "citeRegEx": "Conrad et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Conrad et al\\.", "year": 2009}, {"title": "Introduction to algorithms (Second edition)", "author": ["T. Cormen", "C. Leiserson", "R. Rivest", "C. Stein"], "venue": null, "citeRegEx": "Cormen et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Cormen et al\\.", "year": 2001}, {"title": "An assumption-based TMS", "author": ["J. de Kleer"], "venue": "Artificial intelligence,", "citeRegEx": "Kleer,? \\Q1986\\E", "shortCiteRegEx": "Kleer", "year": 1986}, {"title": "AND/OR search spaces for graphical models", "author": ["R. Dechter", "R. Mateescu"], "venue": "Artificial Intelligence,", "citeRegEx": "Dechter and Mateescu,? \\Q2007\\E", "shortCiteRegEx": "Dechter and Mateescu", "year": 2007}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "Dechter et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Dechter et al\\.", "year": 1991}, {"title": "A truth maintenance system", "author": ["J. Doyle"], "venue": "Artificial Intelligence,", "citeRegEx": "Doyle,? \\Q1979\\E", "shortCiteRegEx": "Doyle", "year": 1979}, {"title": "Optimal Temporal Planning at Reactive Time Scales via Dynamic Backtracking Branch and Bound", "author": ["R. Effinger"], "venue": null, "citeRegEx": "Effinger,? \\Q2006\\E", "shortCiteRegEx": "Effinger", "year": 2006}, {"title": "An extensible sat-solver", "author": ["N. En", "N. Srensson"], "venue": "Theory and Applications of Satisfiability Testing,", "citeRegEx": "En and Srensson,? \\Q2004\\E", "shortCiteRegEx": "En and Srensson", "year": 2004}, {"title": "Controlling inequality reasoning in a TMS-based analog diagnosis system", "author": ["D. Goldstone"], "venue": "In Proceedings of the Ninth National Conference on Artificial Intelligence,", "citeRegEx": "Goldstone,? \\Q1991\\E", "shortCiteRegEx": "Goldstone", "year": 1991}, {"title": "Strengthening schedules through uncertainty analysis", "author": ["L. Hiatt", "T. Zimmerman", "S. Smith", "R. Simmons"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Hiatt et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hiatt et al\\.", "year": 2009}, {"title": "Fixing the semantics for dynamic controllability and providing a more practical characterization of dynamic execution strategies", "author": ["L. Hunsberger"], "venue": "In Proceedings of the 16th International Symposium on Temporal Representation and Reasoning,", "citeRegEx": "Hunsberger,? \\Q2009\\E", "shortCiteRegEx": "Hunsberger", "year": 2009}, {"title": "A Fast Incremental Algorithm for Managing the Execution of Dynamically Controllable Temporal Networks", "author": ["L. Hunsberger"], "venue": "In Proceedings of the 17th International Symposium on Temporal Representation and Reasoning,", "citeRegEx": "Hunsberger,? \\Q2010\\E", "shortCiteRegEx": "Hunsberger", "year": 2010}, {"title": "Temporal constraint reasoning with preferences", "author": ["L. Khatib", "P. Morris", "R. Morris", "F. Rossi"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Khatib et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Khatib et al\\.", "year": 2001}, {"title": "Executing reactive, model-based programs through graph-based temporal planning", "author": ["P. Kim", "B.C. Williams", "M. Abramson"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Kim et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2001}, {"title": "Contexts and data dependencies: A synthesis", "author": ["D. McDermott"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on,", "citeRegEx": "McDermott,? \\Q1983\\E", "shortCiteRegEx": "McDermott", "year": 1983}, {"title": "A structural characterization of temporal dynamic controllability", "author": ["P. Morris"], "venue": "Principles and Practice of Constraint Programming,", "citeRegEx": "Morris,? \\Q2006\\E", "shortCiteRegEx": "Morris", "year": 2006}, {"title": "Dynamic control of plans with temporal uncertainty", "author": ["P. Morris", "N. Muscettola", "T. Vidal"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Morris et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Morris et al\\.", "year": 2001}, {"title": "Reformulating temporal plans for efficient execution", "author": ["N. Muscettola", "P. Morris", "I. Tsamardinos"], "venue": "In Proceedings of the Principles of Knowledge Representation and Reasoning-International Conference,", "citeRegEx": "Muscettola et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Muscettola et al\\.", "year": 1998}, {"title": "P 3 C: A New Algorithm for the Simple Temporal Problem", "author": ["L. Planken", "M. de Weerdt", "R. van der Krogt"], "venue": "In Proceedings of the Eighteenth International Conference on Automated Planning and Scheduling", "citeRegEx": "Planken et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Planken et al\\.", "year": 2008}, {"title": "Uncertainty in soft temporal constraint problems: a general framework and controllability algorithms for the fuzzy case", "author": ["F. Rossi", "K. Venable", "N. Yorke-Smith"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Rossi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Rossi et al\\.", "year": 2006}, {"title": "A fast incremental algorithm for maintaining dispatchability of partially controllable Plans", "author": ["J. Shah", "J. Stedl", "B. Williams", "P. Robertson"], "venue": "In Proceedings of the Seventeenth International Conference on Automated Planning and Scheduling", "citeRegEx": "Shah et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Shah et al\\.", "year": 2007}, {"title": "Fast Dynamic Scheduling of Disjunctive Temporal Constraint Networks through Incremental Compilation", "author": ["J.A. Shah", "B.C. Williams"], "venue": "In Proceedings of the Nineteenth International Conference on Automated Planning and Scheduling", "citeRegEx": "Shah and Williams,? \\Q2008\\E", "shortCiteRegEx": "Shah and Williams", "year": 2008}, {"title": "Enabling Fast Flexible Planning Through Incremental Temporal Reasoning with Conflict Extraction", "author": ["Shu", "I.-h", "R. Effinger", "B.C. Williams"], "venue": "In Proceedings of the Fifteenth International Conference on Automated Planning and Scheduling", "citeRegEx": "Shu et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Shu et al\\.", "year": 2005}, {"title": "Distributed management of flexible times schedules", "author": ["S. Smith", "A. Gallagher", "T. Zimmerman"], "venue": "In Proceedings of the 6th International Joint Conference on Autonomous Agents and Multiagent Systems,", "citeRegEx": "Smith et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Smith et al\\.", "year": 2007}, {"title": "Forward reasoning and dependency-directed backtracking in a system for computer-aided circuit analysis", "author": ["R. Stallman", "G. Sussman"], "venue": "Artificial Intelligence,", "citeRegEx": "Stallman and Sussman,? \\Q1977\\E", "shortCiteRegEx": "Stallman and Sussman", "year": 1977}, {"title": "Managing temporal uncertainty under limited communication: a formal model of tight and loose team coordination", "author": ["J. Stedl"], "venue": null, "citeRegEx": "Stedl,? \\Q2004\\E", "shortCiteRegEx": "Stedl", "year": 2004}, {"title": "Backtracking algorithms for disjunctions of temporal constraints", "author": ["K. Stergiou", "M. Koubarakis"], "venue": "Artificial Intelligence,", "citeRegEx": "Stergiou and Koubarakis,? \\Q2000\\E", "shortCiteRegEx": "Stergiou and Koubarakis", "year": 2000}, {"title": "A probabilistic approach to robust execution of temporal plans with uncertainty", "author": ["I. Tsamardinos"], "venue": "Methods and Applications of Artificial Intelligence,", "citeRegEx": "Tsamardinos,? \\Q2002\\E", "shortCiteRegEx": "Tsamardinos", "year": 2002}, {"title": "Fast transformation of temporal plans for efficient execution", "author": ["I. Tsamardinos", "N. Muscettola", "P. Morris"], "venue": "In Proceedings of the Fifteenth National Conference on Artificial Intelligence,", "citeRegEx": "Tsamardinos et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Tsamardinos et al\\.", "year": 1998}, {"title": "Flexible dispatch of disjunctive plans", "author": ["I. Tsamardinos", "M. Pollack", "P. Ganchev"], "venue": "In 6th European Conference on Planning,", "citeRegEx": "Tsamardinos et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Tsamardinos et al\\.", "year": 2001}, {"title": "Ctp: A new constraint-based formalism for conditional", "author": ["I. Tsamardinos", "T. Vidal", "M. Pollack"], "venue": "temporal planning. Constraints,", "citeRegEx": "Tsamardinos et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Tsamardinos et al\\.", "year": 2003}, {"title": "Disjunctive temporal planning with uncertainty", "author": ["K. Venable", "N. Yorke-Smith"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence,", "citeRegEx": "Venable and Yorke.Smith,? \\Q2005\\E", "shortCiteRegEx": "Venable and Yorke.Smith", "year": 2005}, {"title": "Conflict-directed A* and its role in model-based embedded systems", "author": ["B. Williams", "R. Ragno"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "Williams and Ragno,? \\Q2007\\E", "shortCiteRegEx": "Williams and Ragno", "year": 2007}, {"title": "Model-based programming of intelligent embedded systems and robotic space explorers", "author": ["B.C. Williams", "M.D. Ingham", "S.H. Chung", "P.H. Elliott"], "venue": "Proceedings of the IEEE: Special Issue on Modeling and Design of Embedded Software,", "citeRegEx": "Williams et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Williams et al\\.", "year": 2003}, {"title": "A new effcient algorithm for solving the simple temporal problem", "author": ["L. Xu", "B. Choueiry"], "venue": "In Proceedings of the 10th International Symposium on Temporal Representation and Reasoning and Fourth International Conference on Temporal Logic,", "citeRegEx": "Xu and Choueiry,? \\Q2003\\E", "shortCiteRegEx": "Xu and Choueiry", "year": 2003}], "referenceMentions": [{"referenceID": 17, "context": "Examples of added features include explicit modeling of uncertainty (Morris, Muscettola, & Vidal, 2001; Rossi, Venable, & Yorke-Smith, 2006; Shah & Williams, 2008), discrete choices (Kim, Williams, & Abramson, 2001; Tsamardinos, Pollack, & Ganchev, 2001; Combi & Posenato, 2009; Shah & Williams, 2008), preferences (Hiatt, Zimmerman, Smith, & Simmons, 2009; Khatib, Morris, Morris, & Rossi, 2001; Kim et al., 2001), discrete observations (Tsamardinos, Vidal, & Pollack, 2003), and combinations thereof.", "startOffset": 315, "endOffset": 414}, {"referenceID": 17, "context": "Examples of added features include explicit modeling of uncertainty (Morris, Muscettola, & Vidal, 2001; Rossi, Venable, & Yorke-Smith, 2006; Shah & Williams, 2008), discrete choices (Kim, Williams, & Abramson, 2001; Tsamardinos, Pollack, & Ganchev, 2001; Combi & Posenato, 2009; Shah & Williams, 2008), preferences (Hiatt, Zimmerman, Smith, & Simmons, 2009; Khatib, Morris, Morris, & Rossi, 2001; Kim et al., 2001), discrete observations (Tsamardinos, Vidal, & Pollack, 2003), and combinations thereof. This work focuses on enriching the executive to simultaneously schedule events and make discrete choices as the execution unfolds. The ability to make discrete choices greatly enriches an executive by offering it the ability to dynamically allocate resources, order activities, and choose between alternate methods (sub-plans) for achieving goals. Although prior works have developed executives for this type of plan, they have trade-offs in performance. For example, Tsamardinos, Pollack, and Ganchev (2001) presented an executive for Disjunctive Temporal Networks (DTN), a variant of STNs that include discrete choices.", "startOffset": 397, "endOffset": 1012}, {"referenceID": 17, "context": "Examples of added features include explicit modeling of uncertainty (Morris, Muscettola, & Vidal, 2001; Rossi, Venable, & Yorke-Smith, 2006; Shah & Williams, 2008), discrete choices (Kim, Williams, & Abramson, 2001; Tsamardinos, Pollack, & Ganchev, 2001; Combi & Posenato, 2009; Shah & Williams, 2008), preferences (Hiatt, Zimmerman, Smith, & Simmons, 2009; Khatib, Morris, Morris, & Rossi, 2001; Kim et al., 2001), discrete observations (Tsamardinos, Vidal, & Pollack, 2003), and combinations thereof. This work focuses on enriching the executive to simultaneously schedule events and make discrete choices as the execution unfolds. The ability to make discrete choices greatly enriches an executive by offering it the ability to dynamically allocate resources, order activities, and choose between alternate methods (sub-plans) for achieving goals. Although prior works have developed executives for this type of plan, they have trade-offs in performance. For example, Tsamardinos, Pollack, and Ganchev (2001) presented an executive for Disjunctive Temporal Networks (DTN), a variant of STNs that include discrete choices. Their executive extends the compilation strategy for STNs by breaking the DTN into its complete exponential set of component STNs and then compiling and dispatching each in parallel. Their strategy offers low latency, but incurs a high storage cost for the dispatchable plan. Another example, Kirk, is an executive for Temporal Plan Networks (TPNs), which extends STNs by including a hierarchical choice between sub-plans, developed by Kim, Williams, and Abramson (2001). Kirk selects a set of choices and performs incremental re-planning whenever a disturbance invalidates that choice, leaving a small memory footprint, but potentially inducing high latency when it selects new choices.", "startOffset": 397, "endOffset": 1596}, {"referenceID": 17, "context": "Examples of added features include explicit modeling of uncertainty (Morris, Muscettola, & Vidal, 2001; Rossi, Venable, & Yorke-Smith, 2006; Shah & Williams, 2008), discrete choices (Kim, Williams, & Abramson, 2001; Tsamardinos, Pollack, & Ganchev, 2001; Combi & Posenato, 2009; Shah & Williams, 2008), preferences (Hiatt, Zimmerman, Smith, & Simmons, 2009; Khatib, Morris, Morris, & Rossi, 2001; Kim et al., 2001), discrete observations (Tsamardinos, Vidal, & Pollack, 2003), and combinations thereof. This work focuses on enriching the executive to simultaneously schedule events and make discrete choices as the execution unfolds. The ability to make discrete choices greatly enriches an executive by offering it the ability to dynamically allocate resources, order activities, and choose between alternate methods (sub-plans) for achieving goals. Although prior works have developed executives for this type of plan, they have trade-offs in performance. For example, Tsamardinos, Pollack, and Ganchev (2001) presented an executive for Disjunctive Temporal Networks (DTN), a variant of STNs that include discrete choices. Their executive extends the compilation strategy for STNs by breaking the DTN into its complete exponential set of component STNs and then compiling and dispatching each in parallel. Their strategy offers low latency, but incurs a high storage cost for the dispatchable plan. Another example, Kirk, is an executive for Temporal Plan Networks (TPNs), which extends STNs by including a hierarchical choice between sub-plans, developed by Kim, Williams, and Abramson (2001). Kirk selects a set of choices and performs incremental re-planning whenever a disturbance invalidates that choice, leaving a small memory footprint, but potentially inducing high latency when it selects new choices. Chaski is an executive presented by Shah and Williams (2007) for temporal plans with resource allocation, whose expressiveness is between that of STNs and DTNs.", "startOffset": 397, "endOffset": 1874}, {"referenceID": 18, "context": "To develop the compact representation, we begin with the idea, taken from truth maintenance, of labeling consequences of inferences with the minimal set of choices that imply the consequence; this minimal set is called an environment (McDermott, 1983; de Kleer, 1986).", "startOffset": 234, "endOffset": 267}, {"referenceID": 29, "context": "Drake achieves low run-time latency through compilation, yet requires less storage than the fully exponential expansion approach taken by Tsamardinos et al. (2001). In order to accomplish this, Drake works on a compact representation of the temporal constraints and discrete choices.", "startOffset": 138, "endOffset": 164}, {"referenceID": 31, "context": "In practical terms, Drake\u2019s compact encoding provides a reduction in the size of the plan used by the dispatcher by over two orders of magnitude for problems with around 2,000 component STNs, as compared to Tsamardinos et al.\u2019s work (2001). This size reduction comes at a modest increase in the run-time latency, making Drake a useful addition to the available executives.", "startOffset": 207, "endOffset": 240}, {"referenceID": 31, "context": "In contrast, the prior work of Tsamardinos et al. (2001), breaks the input plan into independent STNs, hence their compilation strategy cannot exploit any similarities or shared structures between the choices.", "startOffset": 31, "endOffset": 57}, {"referenceID": 31, "context": "The rover example has a single binary choice, hence for this problem Tsamardinos et al.\u2019s (2001) algorithm separates the two possible STNs then compute their associated distance graphs, which are shown in Figure 1.", "startOffset": 69, "endOffset": 97}, {"referenceID": 31, "context": "3: The Tsamardinos et al. (2001) style distance graphs associated with the Labeled-STN in Figure 1.", "startOffset": 7, "endOffset": 33}, {"referenceID": 19, "context": "Muscettola, Morris, and Tsamardinos (1998) proposed framework for low-latency dynamic execution: a preprocessing step called compilation and a run-time component called dispatch.", "startOffset": 12, "endOffset": 43}, {"referenceID": 19, "context": "Muscettola, Morris, and Tsamardinos (1998) proposed framework for low-latency dynamic execution: a preprocessing step called compilation and a run-time component called dispatch. Tsamardinos, Muscettola, and Morris (1998) later provided a faster compilation algorithm.", "startOffset": 12, "endOffset": 222}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty.", "startOffset": 0, "endOffset": 14}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices.", "startOffset": 0, "endOffset": 110}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices. The executive cannot control, but may only observe the values of some discrete choices at designated parts of the plan. Some of their notation is quite similar to that used here for Drake, but there are two important differences. First, a CTP is a strictly harder problem, since Drake is not concerned with uncontrollable choices, meaning that their algorithm does more work than is necessary for the simpler case. Second, their algorithm does not use a compact representation; their algorithm for consistency checking requires enumerating the possible scenarios. An open problem for future research is to adapt their more general algorithms to take advantage of the compactness of the Labeled Distance Graph. Another useful feature added to STNs is preferences. Khatib, Morris, Morris, and Rossi (2001) introduced a formulation including preferences for event execution times within the simple interval bounds allowed by an STN, adding a notion of quality to the existing notion of consistency.", "startOffset": 0, "endOffset": 1002}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices. The executive cannot control, but may only observe the values of some discrete choices at designated parts of the plan. Some of their notation is quite similar to that used here for Drake, but there are two important differences. First, a CTP is a strictly harder problem, since Drake is not concerned with uncontrollable choices, meaning that their algorithm does more work than is necessary for the simpler case. Second, their algorithm does not use a compact representation; their algorithm for consistency checking requires enumerating the possible scenarios. An open problem for future research is to adapt their more general algorithms to take advantage of the compactness of the Labeled Distance Graph. Another useful feature added to STNs is preferences. Khatib, Morris, Morris, and Rossi (2001) introduced a formulation including preferences for event execution times within the simple interval bounds allowed by an STN, adding a notion of quality to the existing notion of consistency. Rossi, Venable, and Yorke-Smith (2006) discuss simultaneous handling of uncertainty and preferences.", "startOffset": 0, "endOffset": 1233}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices. The executive cannot control, but may only observe the values of some discrete choices at designated parts of the plan. Some of their notation is quite similar to that used here for Drake, but there are two important differences. First, a CTP is a strictly harder problem, since Drake is not concerned with uncontrollable choices, meaning that their algorithm does more work than is necessary for the simpler case. Second, their algorithm does not use a compact representation; their algorithm for consistency checking requires enumerating the possible scenarios. An open problem for future research is to adapt their more general algorithms to take advantage of the compactness of the Labeled Distance Graph. Another useful feature added to STNs is preferences. Khatib, Morris, Morris, and Rossi (2001) introduced a formulation including preferences for event execution times within the simple interval bounds allowed by an STN, adding a notion of quality to the existing notion of consistency. Rossi, Venable, and Yorke-Smith (2006) discuss simultaneous handling of uncertainty and preferences. Kim, Williams, and Abramson (2001) present Temporal Plan Networks, a representation that provides simple temporal constraints over durations combined in series, parallel, and with choice, where each choice has specified costs.", "startOffset": 0, "endOffset": 1330}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices. The executive cannot control, but may only observe the values of some discrete choices at designated parts of the plan. Some of their notation is quite similar to that used here for Drake, but there are two important differences. First, a CTP is a strictly harder problem, since Drake is not concerned with uncontrollable choices, meaning that their algorithm does more work than is necessary for the simpler case. Second, their algorithm does not use a compact representation; their algorithm for consistency checking requires enumerating the possible scenarios. An open problem for future research is to adapt their more general algorithms to take advantage of the compactness of the Labeled Distance Graph. Another useful feature added to STNs is preferences. Khatib, Morris, Morris, and Rossi (2001) introduced a formulation including preferences for event execution times within the simple interval bounds allowed by an STN, adding a notion of quality to the existing notion of consistency. Rossi, Venable, and Yorke-Smith (2006) discuss simultaneous handling of uncertainty and preferences. Kim, Williams, and Abramson (2001) present Temporal Plan Networks, a representation that provides simple temporal constraints over durations combined in series, parallel, and with choice, where each choice has specified costs. Effinger (2006) expands this to a simple preference model, in which choices and activities have associated, fixed costs.", "startOffset": 0, "endOffset": 1538}, {"referenceID": 3, "context": "Conrad (2010) presents an extension of Drake to DTNs with uncertainty. Tsamardinos, Vidal, and Pollack (2003) introduced Conditional Temporal Problems (CTP), adding uncontrollable discrete choices. The executive cannot control, but may only observe the values of some discrete choices at designated parts of the plan. Some of their notation is quite similar to that used here for Drake, but there are two important differences. First, a CTP is a strictly harder problem, since Drake is not concerned with uncontrollable choices, meaning that their algorithm does more work than is necessary for the simpler case. Second, their algorithm does not use a compact representation; their algorithm for consistency checking requires enumerating the possible scenarios. An open problem for future research is to adapt their more general algorithms to take advantage of the compactness of the Labeled Distance Graph. Another useful feature added to STNs is preferences. Khatib, Morris, Morris, and Rossi (2001) introduced a formulation including preferences for event execution times within the simple interval bounds allowed by an STN, adding a notion of quality to the existing notion of consistency. Rossi, Venable, and Yorke-Smith (2006) discuss simultaneous handling of uncertainty and preferences. Kim, Williams, and Abramson (2001) present Temporal Plan Networks, a representation that provides simple temporal constraints over durations combined in series, parallel, and with choice, where each choice has specified costs. Effinger (2006) expands this to a simple preference model, in which choices and activities have associated, fixed costs. Kirk is a dynamic executive for TPNs. Kirk performs optimal method selection just before run-time, assigning the discrete choices and then dispatches the resulting component STN. If some disturbance invalidates the STN that Kirk chose, then Kirk selects a new STN consistent with the execution thus far. Further research developed incremental techniques to allow Kirk to re-plan with lower latency (Shu, Effinger, & Williams, 2005; Block, Wehowsky, & Williams, 2006). Shah and Williams (2008) present Chaski, an executive that dynamically dispatches plans with task assignment over heterogeneous, cooperative agents, represented by a TCN,", "startOffset": 0, "endOffset": 2136}, {"referenceID": 30, "context": "by removing some redundant data structures and computations performed by Tsamardinos et al.\u2019s (2001) algorithm.", "startOffset": 73, "endOffset": 101}, {"referenceID": 29, "context": "First, Tsamardinos et al.\u2019s (2003) CTPs, Tsamardinos et al.", "startOffset": 7, "endOffset": 35}, {"referenceID": 29, "context": "First, Tsamardinos et al.\u2019s (2003) CTPs, Tsamardinos et al.\u2019s (2001) DTN dispatcher, and Combi et al.", "startOffset": 7, "endOffset": 69}, {"referenceID": 29, "context": "First, Tsamardinos et al.\u2019s (2003) CTPs, Tsamardinos et al.\u2019s (2001) DTN dispatcher, and Combi et al. (2010) use a compile-time analysis to compute the implied constraints of every possible plan and explicitly reason over them at run-time.", "startOffset": 7, "endOffset": 109}, {"referenceID": 17, "context": "Second, Kim et al. (2001), and Smith et al.", "startOffset": 8, "endOffset": 26}, {"referenceID": 17, "context": "Second, Kim et al. (2001), and Smith et al. (2007) focus on a single, potentially optimal, assignment to the choices, and if that becomes infeasible, they incrementally re-plan and extract a new plan.", "startOffset": 8, "endOffset": 51}, {"referenceID": 8, "context": "Doyle (1979) introduced Truth Maintenance Systems (TMSs) as a domain independent method for supporting dependency-directed backtracking.", "startOffset": 0, "endOffset": 13}, {"referenceID": 8, "context": "Doyle (1979) introduced Truth Maintenance Systems (TMSs) as a domain independent method for supporting dependency-directed backtracking. The TMS represents data, their justifications, and provides the ability to revise beliefs when assumptions change or contradictions arise. For example, consider a problem solver designed to search for a solution to a constraint satisfaction problem. When determining whether a particular solution is consistent, the problem solver will perform a chain of inferences, providing the TMS with the justification for each step. If an inconsistency is found, the problem solver selects a new candidate solution, and the TMS uses the justifications to determine which of the inferences still hold under the new candidate and which must be recomputed to account for new circumstances. The TMS continually determines whether a particular datum, a general term for any fact that arises in problem solving, is in or out, that is, currently believed true, or not currently believed. Later work relaxes the goal of maintaining a single, consistent assignment to all data of in or out, and instead tracks the contexts in which particular facts hold, even if those contexts may be mutually exclusive. McDermott (1983) uses beads to state a context, which is a particular set of choices or assumptions on which the reasoning might rely, and provides data pools that specify all the facts that hold in that context.", "startOffset": 0, "endOffset": 1240}, {"referenceID": 6, "context": "De Kleer (1986) develops the Assumption-based Truth Maintenance System, which uses a similar idea, but changes the terminology to use environments and labels to specify contexts.", "startOffset": 3, "endOffset": 16}, {"referenceID": 6, "context": "De Kleer (1986) develops the Assumption-based Truth Maintenance System, which uses a similar idea, but changes the terminology to use environments and labels to specify contexts. The ATMS maintains a set of minimal inconsistent environments, called conflicts or no-goods. These conflicts help the system to avoid performing inferences for contexts that are already known to be inconsistent, and the minimality of the conflict set makes the procedure tractable. The ATMS is designed to simultaneously find the logical consequences of all possible combinations of assumptions, in contrast to the TMS, which focuses on finding any one set of assumptions that solve the problem of interest. Hence, the ATMS is well suited as the foundation for an executive that is intended to consider all possible choices simultaneously without incurring latency for switching between choices. Finally, there is some development of the idea that when working with inequalities, the ATMS only needs to keep tightest bounds on the inequalities, which we use extensively; this concept was described by Goldstone (1991) as hibernation.", "startOffset": 3, "endOffset": 1097}, {"referenceID": 8, "context": "A simple temporal network is defined as a set of events related by binary interval constraints, called simple interval constraints (Dechter et al., 1991).", "startOffset": 131, "endOffset": 153}, {"referenceID": 8, "context": "Recall that an STN is consistent if and only if its associated distance graph does not have any negative cycles (Dechter et al., 1991).", "startOffset": 112, "endOffset": 134}, {"referenceID": 21, "context": "The all-pairs shortest path (APSP) graph of the distance graph associated with an STN is a dispatchable form because it explicitly contains all possible constraints of the STN (Muscettola et al., 1998).", "startOffset": 176, "endOffset": 201}, {"referenceID": 21, "context": "We adapt the STN dispatcher developed by Muscettola et al. (1998) to work with dispatchable labeled distance graphs.", "startOffset": 41, "endOffset": 66}, {"referenceID": 21, "context": "We adapt the STN dispatcher developed by Muscettola et al. (1998) to work with dispatchable labeled distance graphs. Essentially, Drake\u2019s algorithms substitute real number bounds on execution times, as in the STN dispatcher, with labeled value sets. Additionally, we adapt Tsamardinos et al.\u2019s (2001) approach to reasoning over multiple possible options, that is, allowing the dispatcher to accept a proposed execution time for an event if at least one full assignment to the choices is consistent with that schedule.", "startOffset": 41, "endOffset": 301}, {"referenceID": 31, "context": "Broadly, this is the same strategy as Tsamardinos et al. (2001), where the component STNs are dispatched in parallel, and proposed scheduling decisions may be accepted if they are consistent with at least one STN.", "startOffset": 38, "endOffset": 64}, {"referenceID": 21, "context": "Muscettola et al. (1998) introduced an initial compilation algorithm for STNs that operates in two steps.", "startOffset": 0, "endOffset": 25}, {"referenceID": 3, "context": "As a first prototype of Drake, Conrad, Shah, and Williams (2009) introduced a labeled extension of this algorithm.", "startOffset": 31, "endOffset": 65}, {"referenceID": 19, "context": "To resolve this, Tsamardinos, Muscettola, and Morris (1998) presented a fast compilation algorithm that interleaves the APSP step and the pruning step, and avoids ever storing the entire APSP graph.", "startOffset": 46, "endOffset": 60}, {"referenceID": 5, "context": "1, taken directly (with slightly altered notation) from the work of Cormen et al. (2001). The algorithm loops over the edges and performs relaxations, then tests for negative cycles to ensure the result is valid.", "startOffset": 68, "endOffset": 89}, {"referenceID": 31, "context": "Tsamardinos, et al. (1998) provide two theorems relating dominance of edges to paths in the predecessor graph, adjusted slightly for our notation.", "startOffset": 0, "endOffset": 27}, {"referenceID": 30, "context": "The direct enumeration of STNs, as in Tsamardinos et al.\u2019s (2001) work, uses one STN for each consistent STN.", "startOffset": 38, "endOffset": 66}, {"referenceID": 7, "context": "Dechter and Mateescu (2007) explain that while a general constraint satisfaction problem with n variables of domain size d can in general only be solved in O ( nd ) steps, many problems have more structure.", "startOffset": 0, "endOffset": 28}, {"referenceID": 29, "context": "First, we develop a suite of random structured Labeled STNs, derived from Stedl\u2019s (2004) problem generator.", "startOffset": 74, "endOffset": 89}, {"referenceID": 29, "context": "First, we develop a suite of random structured Labeled STNs, derived from Stedl\u2019s (2004) problem generator. Then we compile and dispatch the suites of problems twice, once with Drake and once by explicitly enumerating all component STNs, following techniques developed by Tsamardinos et al. (2001). Finally, we compare the compiled size of the problems, the compilation time, and the execution latency.", "startOffset": 74, "endOffset": 298}, {"referenceID": 29, "context": "First, we develop a suite of random structured Labeled STNs, derived from Stedl\u2019s (2004) problem generator. Then we compile and dispatch the suites of problems twice, once with Drake and once by explicitly enumerating all component STNs, following techniques developed by Tsamardinos et al. (2001). Finally, we compare the compiled size of the problems, the compilation time, and the execution latency. Throughout this section, our plots use the number of consistent component STNs as the horizontal axis, because it appears to correlate well with the effective difficulty of the problem. For each of the metrics, we provide the results from the two methods side by side in one plot, and show the ratio of performance in another one, to allow point-wise comparison of the difference in performance between identical problems. The problems are constructed from 2-11 binary choices or 2-7 ternary choices. There are 100 problems at each of these sizes; the problems range from 4 consistent component STNs up to about 2000. The number of events ranges from 4 to about 22 as the number of component STNs increase to keep a consistent ratio of constraints to events. This comparison is performed with a Lisp implementation, run on a 2.66 GHz machine with 4 Gb of memory. There are some performance related implementation details we have omitted in prior sections. For example, labeled value sets are stored as ordered lists to reduce insertion and query time. Additionally, we found that memoization of subsumption and union operations dramatically improved performance. The implementation aggressively prunes values with inconsistent environments to avoid any unnecessary reasoning. The STN compiler and dispatcher exercise the same code as Drake to support a fair comparison, and pays a small overhead in execution speed. The first metric of comparison is the size of the dispatchable form of the random problems. We computed this by serializing the graph representations to strings. Since Drake\u2019s compilation algorithm is derived from the fast STN compiler, the maximum memory footprint for both compilation and dispatch is no more than about double these numbers. Since we designed Drake with this metric in mind, we expect the improvement to be clear and significant, and this is what Figure 8.1 shows. In the ratio plot, the value is the multiple of improvement of Drake over STN enumeration. Except for small problems, Drake\u2019s memory performance is superior, and the improvement ranges up to around a 700 times smaller memory footprint for the largest problems. The STN enumeration Tsamardinos et al. (2001) develops uses up to around 2 MB of storage, and although that is insignificant for a modern desktop, it is often significant for embedded hardware, especially if the system must store a library of compiled plans.", "startOffset": 74, "endOffset": 2610}, {"referenceID": 31, "context": "Overall, Drake appears to provide a noticeably lower memory footprint for dispatching problems with discrete choices than the direct enumeration strategy of Tsamardinos et al. (2001), while only suffering from a mild increase in run-time latency.", "startOffset": 157, "endOffset": 183}, {"referenceID": 8, "context": "Drake takes input plans with temporal flexibility and discrete choices, such as Labeled STNs or DTNs, and selects the execution times and makes discrete decisions at run-time (Dechter et al., 1991).", "startOffset": 175, "endOffset": 197}, {"referenceID": 6, "context": "Building upon the concept of labels employed by the ATMS to compactly encode all the consequences of a set of alternative choices, Drake introduces a new compact encoding, called labeled distance graphs, to encode and efficiently reason over discrete choices, and we introduce a corresponding maintenance system (de Kleer, 1986). Our adaptation of the ATMS labeling scheme focuses on only maintaining non-dominated constraints, which allows Drake to exploit the structure of temporal reasoning, cast as a shortest path problem on a distance graph, to provide a compact representation. Furthermore, modifying the existing unlabeled algorithms to account for labels does not change the overall structure of the algorithms. Drake\u2019s compilation algorithm successfully compresses the dispatchable solution by over two orders of magnitude relative to Tsamardinos, Pollack, and Ganchev\u2019s (2001) prior work, often reducing the compilation time, and typically introducing only a modest increase in execution latency.", "startOffset": 316, "endOffset": 888}], "year": 2011, "abstractText": "This work presents Drake, a dynamic executive for temporal plans with choice. Dynamic plan execution strategies allow an autonomous agent to react quickly to unfolding events, improving the robustness of the agent. Prior work developed methods for dynamically dispatching Simple Temporal Networks, and further research enriched the expressiveness of the plans executives could handle, including discrete choices, which are the focus of this work. However, in some approaches to date, these additional choices induce significant storage or latency requirements to make flexible execution possible. Drake is designed to leverage the low latency made possible by a preprocessing step called compilation, while avoiding high memory costs through a compact representation. We leverage the concepts of labels and environments, taken from prior work in Assumptionbased Truth Maintenance Systems (ATMS), to concisely record the implications of the discrete choices, exploiting the structure of the plan to avoid redundant reasoning or storage. Our labeling and maintenance scheme, called the Labeled Value Set Maintenance System, is distinguished by its focus on properties fundamental to temporal problems, and, more generally, weighted graph algorithms. In particular, the maintenance system focuses on maintaining a minimal representation of non-dominated constraints. We benchmark Drake\u2019s performance on random structured problems, and find that Drake reduces the size of the compiled representation by a factor of over 500 for large problems, while incurring only a modest increase in run-time latency, compared to prior work in compiled executives for temporal plans with discrete choices.", "creator": "TeX"}}}