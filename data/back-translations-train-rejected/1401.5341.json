{"id": "1401.5341", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Jan-2014", "title": "Domain Views for Constraint Programming", "abstract": "Views are a standard abstraction in constraint programming: They make it possible to implement a single version of each constraint, while avoiding to create new variables and constraints that would slow down propagation. Traditional constraint-programming systems provide the concept of {\\em variable views} which implement a view of the type $y = f(x)$ by delegating all (domain and constraint) operations on variable $y$ to variable $x$. This paper proposes the alternative concept of {\\em domain views} which only delegate domain operations. Domain views preserve the benefits of variable views but simplify the implementation of value-based propagation. Domain views also support non-injective views compositionally, expanding the scope of views significantly. Experimental results demonstrate the practical benefits of domain views.", "histories": [["v1", "Tue, 21 Jan 2014 15:22:29 GMT  (59kb)", "http://arxiv.org/abs/1401.5341v1", "Workshop: TRICS13: Techniques foR Implementing Constraint programming, September 2013, CP, Uppsala"]], "COMMENTS": "Workshop: TRICS13: Techniques foR Implementing Constraint programming, September 2013, CP, Uppsala", "reviews": [], "SUBJECTS": "cs.AI cs.PL", "authors": ["pascal van hentenryck", "laurent michel"], "accepted": false, "id": "1401.5341"}, "pdf": {"name": "1401.5341.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 140 1.53 41v1 [cs.AI] 21 Jan 20"}, {"heading": "1 Introduction", "text": "This year, it is only a matter of time before an agreement is reached."}, {"heading": "2 Preliminaries", "text": "In fact, it is so that most people are able to determine for themselves what they want and what they want. (...) In fact, it is so that most people are able to determine for themselves. (...) It is so that they are not ready to decide for themselves. (...) It is as if they want it. (...) It is as if they want it. (...) It is as if they do not want it. (...) It is as if they want it. (...) It is as if they want it. (...) It is as if they want it. (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (. (...). (...). (...). (...). (...). (...). (...). (...). (. (. (.). (). (.).). (). (). (). (...). (...). (. (. (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (). (...). (). (). (). ().). (). (). (). ("}, {"heading": "3 Views", "text": "As a first step, the essay focuses on injective views, i.e. views in which the abstractions for constraints of the form y = 1 (injective function) are injective, i.e. views in which the function per se is injective, which is the functionality that many constraint programming solutions offer. Definition 1 (injective function) A function is injective if it is injective. Definition 1 (injective function): D \u2192 V is injective if it is injective. Definition 1 (w) = {v if it is injective. Example 1 (shift view) is injective if it is injective."}, {"heading": "4 Variable Views", "text": "The basic idea of variable views, which are implemented in many systems, is to delegate all domains and constraints necessary for the application of variable views. < / p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p p _ p p p _ p p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _ p _"}, {"heading": "5 Domain Views", "text": "The key idea behind domain views is to delegate only domain operations from variable y to variable x. Y's view maintains its own constraints to observe them, eliminating the need to manipulate first-order functions. To implement domain views, traditional variables (and views) must store what variables they are looking at. If their domains change, they must communicate their views. Figure 6 shows the revised implementation of domain variables to support domain views. Now, the variable retains its views (line 5) and provides a method of adding a view (line 8). The only other change is the method removed in lines 16-18: The domain variable calls method to notify them of the loss of value v so they can plan their own constraints. Figure 7 shows a template for domain views in relation to an injective function."}, {"heading": "6 Non-injective Views", "text": "In fact, it is as if most people are able to recognize themselves and understand what they are doing. (...) It is not as if they are able to identify themselves. (...) It is not as if they are able to identify themselves. (...) It is as if they are able to identify themselves. (...) It is as if they are able to identify themselves. (...) It is as if they are able to identify themselves. (...) It is as if they are able to be in a position. (...) It is as if they are able to hide themselves. (...) It is as if they are able to hide themselves. (...)"}, {"heading": "7 Monotone and Anti-Monotone Views", "text": "We will briefly mention how to use monotonous and anti-monotonous properties to perform additional operations such as updateMin and updateMax. These techniques are well known and are only checked for completeness here. Definition 3 (monotonous / anti-monotonous function) An injective function is monotonous if it is a monotonous function, and if it is a view on x, then the boundary update operations are equivalent to 1 bool updateMin (Z v) {return x. updateMin (1 (v);} 2 bool updateMax (Z v) {return x. updateMax (return x. updateMax. updateMax). updateMax."}, {"heading": "8 Empirical Evaluation", "text": "We describe experimental results to demonstrate the efficiency of Domain Views. Experiments were performed on MacOS X 10.8.3, running only on a Core i7 in 2.6Ghz, with the full implementation of integer and Boolean variables, along with their domain and views (including literal views), comprising approximately 3,200 lines of code similar to the type of code reuse advertised for Gecode [9]. Full implementation of the methodology, which reaches the limit in [9], only supports core limitations and the use of views to obtain more complex versions. For example, the CP Solver in Objective-CP offers a solution that is not based on 0 xi, but not on 0 ai \u00b7 xi b. Note that cost-based propagation for COP, of course, mandates global conventions maintain ai."}, {"heading": "9 Related Work", "text": "It is important to contrast the implementations of the variable and domain view proposed here with a different approach using delta sets and consultants [7,9]. Consultants are a different kind of \"simulation\" of value-based propagation. [4] A consultant is associated with a variable and a constraint and modifies the state of the constraint for his variables immediately after a domain change. Consultants do not go through the propagation queue, but change the state of their constraint directly. This has both an advantage (speed) and an inconvenience, as a consultant can be called up as his constraint spreads, so some care must be taken to maintain a consistent state. Consultants also receive the domain change (referred to as a delta set) that they may query. Consultants can be associated with variable views."}, {"heading": "10 Conclusion", "text": "In this paper, the concept of views has been rethought, an important abstraction provided by constraint programming systems to avoid the spread of constraints while maintaining the efficiency of a dedicated implementation. An alternative to the concept of variable views, which is typically used in constraint programming systems, has been proposed. In contrast to variable views, domain views delegate only domain operations and maintain their own constraints. Domain views simplify the implementation of constraint programming systems with value-based propagation, as they avoid manipulation of first-order functions (or objects that implement similar functionality). Furthermore, they easily allow the implementation of views with non-injective functions. These are particularly useful for conditional constraints, which are also an important feature of constraint programming systems. Experimental results show that domain views are not supported by a significant overhead (if elegant), and that significant advantages are provided by domain views."}], "references": [{"title": "The Lambda Calculus \u2013 Its Syntax and Semantics, volume 103 of Studies in Logic and the Foundations of Mathematics", "author": ["H.P. Barendregt"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1984}, {"title": "Global constraint catalogue", "author": ["N. Beldiceanu", "M. Carlsson", "S. Demassey", "T. Petit"], "venue": "Past, present and future. Constraints,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "An open-ended finite domain constraint solver", "author": ["M. Carlsson", "G. Ottosson", "B. Carlson"], "venue": "editors, PLILP,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1997}, {"title": "Comet v2.1 user manual", "author": ["I. Dynadec"], "venue": "Technical report, Providence,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Constraint processing in cc(fd)", "author": ["P.V. Hentenryck", "V. Saraswat", "Y. Deville"], "venue": "Technical report,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1992}, {"title": "Advisors for incremental propagation", "author": ["M. Lagerkvist", "C. Schulte"], "venue": "In Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Perfect derived propagators", "author": ["C. Schulte", "G. Tack"], "venue": "CP, volume 5202 of Lecture Notes in Computer Science,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "View-based propagator derivation", "author": ["C. Schulte", "G. Tack"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "A Generic Arc Consistency Algorithm and Its Specializations", "author": ["P. Van Hentenryck", "Y. Deville", "C. Teng"], "venue": "Artificial Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1992}, {"title": "The Objective-CP Optimization System", "author": ["P. Van Hentenryck", "L. Michel"], "venue": "In Proceedings of the 19 International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}], "referenceMentions": [{"referenceID": 1, "context": "The global constraint catalog [2] in fact lists about 354 global constraints at the time of writing.", "startOffset": 30, "endOffset": 33}, {"referenceID": 4, "context": "Prolog-style languages offered indexicals [5,3] while C++ libraries like Ilog Solver [6] introduces the concept of variable views.", "startOffset": 42, "endOffset": 47}, {"referenceID": 2, "context": "Prolog-style languages offered indexicals [5,3] while C++ libraries like Ilog Solver [6] introduces the concept of variable views.", "startOffset": 42, "endOffset": 47}, {"referenceID": 6, "context": "Recently, [8,9] demonstrated how variable views can be implemented in terms of C++ templates, providing further improvement in speed and memory usage.", "startOffset": 10, "endOffset": 15}, {"referenceID": 7, "context": "Recently, [8,9] demonstrated how variable views can be implemented in terms of C++ templates, providing further improvement in speed and memory usage.", "startOffset": 10, "endOffset": 15}, {"referenceID": 7, "context": "[9] demonstrates that variable views provide significant software engineering benefits as well as great computational improvements over the basic approach using new variables and constraints.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": ", [10,4]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 3, "context": ", [10,4]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 7, "context": "Domain views can also be implemented using parametric polymorphism and hence are fully compatible with the compilation techniques in [9].", "startOffset": 133, "endOffset": 136}, {"referenceID": 5, "context": "Section 9 discusses related work on advisors [7] and Section 10 concludes the paper.", "startOffset": 45, "endOffset": 48}, {"referenceID": 0, "context": "Function \u03c8 : Z \u2192 Z can be specified (using lambda calculus notation [1]) as \u03bbk.", "startOffset": 68, "endOffset": 71}, {"referenceID": 9, "context": "6Ghz, using the Objective-CP optimization system [11].", "startOffset": 49, "endOffset": 53}, {"referenceID": 7, "context": "The complete implementation of the integer and boolean variables, along with their domain and their views (including literal views) is around 3,200 lines of code, which is similar to the type of code reuse advertised for Gecode [9].", "startOffset": 228, "endOffset": 231}, {"referenceID": 7, "context": "Objective-CP pushes the methodology advocated in [9] to the limit, only supporting core constraints and using views to obtain more complex versions.", "startOffset": 49, "endOffset": 52}, {"referenceID": 7, "context": "Note that the experiments only aim at demonstrating the practicability of domain views: See [9] for the benefits of views.", "startOffset": 92, "endOffset": 95}, {"referenceID": 7, "context": "For bibd, we follow [9] and rewrite the boolean relations a \u2227 b as \u00ac (\u00aca \u2228 \u00acb) to ensure that the system uses negation views.", "startOffset": 20, "endOffset": 23}, {"referenceID": 5, "context": "It is important to contrast the variable and domain view implementations proposed here with another approach using delta-sets and advisors [7,9].", "startOffset": 139, "endOffset": 144}, {"referenceID": 7, "context": "It is important to contrast the variable and domain view implementations proposed here with another approach using delta-sets and advisors [7,9].", "startOffset": 139, "endOffset": 144}, {"referenceID": 7, "context": "Gecode [9] does not compute delta sets exactly but approximates them by intervals instead.", "startOffset": 7, "endOffset": 10}, {"referenceID": 5, "context": "They are second-class citizens by choice in Gecode [7].", "startOffset": 51, "endOffset": 54}], "year": 2014, "abstractText": "Views are a standard abstraction in constraint programming: They make it possible to implement a single version of each constraint, while avoiding to create new variables and constraints that would slow down propagation. Traditional constraint-programming systems provide the concept of variable views which implement a view of the type y = f(x) by delegating all (domain and constraint) operations on variable y to variable x. This paper proposes the alternative concept of domain views which only delegate domain operations. Domain views preserve the benefits of variable views but simplify the implementation of value-based propagation. Domain views also support non-injective views compositionally, expanding the scope of views significantly. Experimental results demonstrate the practical benefits of domain views.", "creator": "LaTeX with hyperref package"}}}