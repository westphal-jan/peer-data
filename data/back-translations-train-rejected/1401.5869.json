{"id": "1401.5869", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jan-2014", "title": "An Enhanced Branch-and-bound Algorithm for the Talent Scheduling Problem", "abstract": "The talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings are disclosed by some additional experiments.", "histories": [["v1", "Thu, 23 Jan 2014 04:09:45 GMT  (42kb)", "http://arxiv.org/abs/1401.5869v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["zizhen zhang", "hu qin", "xiaocong liang", "rew lim"], "accepted": false, "id": "1401.5869"}, "pdf": {"name": "1401.5869.pdf", "metadata": {"source": "CRF", "title": "An Enhanced Branch-and-bound Algorithm for the Talent Scheduling Problem", "authors": ["Zizhen Zhang", "Hu Qin", "Xiaocong Liang", "Andrew Lim"], "emails": ["zhangzizhen@gmail.com", "tigerqin@hust.edu.cn,", "tigerqin1980@gmail.com", "yurilxc@gmail.com", "lim.andrew@cityu.edu.hk"], "sections": [{"heading": null, "text": "ar Xiv: 140 1.58 69v1 [cs.AI] 23 Jan 20The problem of talent planning is a simplified version of the real-life film shooting problem, which aims to determine a recording sequence to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we design an industry and bound algorithm to solve the problem. The industry and bound algorithm is improved by several acceleration techniques, including pre-processing, dominance rules and caching search states. Extensive experiments across two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the effects of different parameter settings are revealed by some additional experiments. Keywords: industry and boundary; talent planning; preprocessing; dynamic programming; dominance rules."}, {"heading": "1. Introduction", "text": "The scenes of a movie are usually not rotated in the same order as they appear in the final version. Searching for an optimal order in which the scenes are rotated motivates the respective author. (The scenes are shown in the respective other version in each case in the same order). (The scenes are shown in each case in the same order in which the scenes are shown in each case in the same order and order. (The scenes are shown in each case in the same order). (The scenes are shown in each case in the same order in the same order). (The scenes are shown in the same order and order of the order). (The scenes are shown in each case in the same order and order of the order of the order). (The scenes are shown in the same order of the order, in the order of the order of the order, in the order of the order of the order of the order, in the order of the order of the order). (The scenes are shown in the order of the order, in the order of the order of the order, in the order of the order of the order of the order, and in the order of the order of the order of the order)."}, {"heading": "2. Mathematical Formulation", "text": "The problem of talent planning is essentially a permutation problem. It is attempted to find a permutation (i.e., a scheme) \u03c0 = (1),., \u03c0 (n), where \u03c0 (k) is the k-th scene in the permutation \u03c0, so that the total cost C (\u03c0) is minimized. The value of C (\u03c0) is calculated as: C (\u03c0) = m \u00b2 (m \u00b2) \u00b7 (li (\u03c0) \u2212 ei (\u03c0) + 1) We set the parameters mi, j = 1 if Mi, j = X and mi, j = 0 otherwise. The total cost of holding is easily derived as: H (zi) = m \u00b2 (ai) \u00b7 i (zi (zi) \u2212 i (zi) \u2212 n = 1 \u2212 n intended for viewing: i = 1mi (sj)), for this problem minimizing the total cost is equivalent to minimizing the total cost."}, {"heading": "3. An Enhanced Branch-and-bound Approach", "text": "Branch-and-bound is a general technique for optimally solving various combinatorial optimization problems. The basic idea of the branch-and-bound algorithm is to systematically and implicitly list all candidate solutions where large subsets of fruitless candidates are discarded through the use of upper and lower limits, as well as dominance rules. In this section, we describe the main components of our proposed branch-and-bound algorithm, including a dual search strategy, a novel lower limit, the pre-processing phase, the state caching strategy, and two dominance rules."}, {"heading": "3.1. Double-ended Search", "text": "Assuming we want an optimal permutation \u03c0 = (1), p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p"}, {"heading": "3.3. Preprocessing", "text": "In solving problem P (~ B, Q, ~ E), we only have to consider the actors in AN. Problem P (~ B, Q, ~ E) can be simplified further than: The example shown in Table 4 illustrates the pre-processing steps. In Table 4 (a), the actor a4 is fixed and the actor a5 is not needed by the scenes in Q = {s1, s2, s3, s4}. Therefore, we can remove the actors a4 and a5 to make AN = {a1, a2, a3}. Now that one (s2) female actor is on = a (s3) female actor is on = {a1, a2, a3}, we merge scenes s2 and s3. After these steps, we can get a new problem as shown in Table 4 (b)."}, {"heading": "3.4. Lower Bound to Future Cost", "text": "In de la Banda et al. (2011), the authors have proposed a lower pattern linked to future costs. They have generated two lower limits, considering (o (B) \u2212 F, Q) and (o (E) \u2212 F, Q) as input information and claiming that the sum of these two lower limits is still a lower limit (referred to by L0) in terms of future costs. The reader is encouraged to refer to de la Banda et al. (2011) for the details of this lower limit. In this subsection, we present a new implementation of lower (B, Q, E) (referred to by L0) in terms of future costs of the scenes in Q. We refer to the maintenance costs of the actor ai during the period of shooting in Q with the order determined by permutation. If lower (B, Q, E) = mineral costs."}, {"heading": "3.5. Caching Search States", "text": "In de la Banda et al. (2011), the problem of talent planning was solved by a double-ended Q = > Q-Q algorithm, in which a DP state is represented by < B, E >. The DP algorithm stores the best value of each state examined, designated by < B, E >.value, which corresponds to the minimum cost of all search paths associated with sets B and E. We first check whether the value of the cost (~ B, ~ E) is smaller than the current < B >.value (Michie, 1968). More specifically, when the search process reaches a tree node P (~ B, ~ E), it first checks whether the value of the cost (~ B, ~ E) is smaller than the current < B >.value. If so, it updates < B >.value by cost (~ B, ~ E >.value). Otherwise, the current node must be dominated by some nodes and therefore must be safely discarded."}, {"heading": "3.6. Dominance Rules", "text": "Domination rules are often used in industry and bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kellego \ufffd z and Toklu, 2012) and dynamic programming algorithms (Dumas et al., 1995; Mingozzi et al., 1997; Rong and Figueira, 2013) to reduce the search space. The purpose of the domination rules is to determine when the partial solution represented by a node in the search tree is dominated by another node; if so, it does not need to be explored further and can be safely circumcised. In our industry-bound algorithm, two dominance rules are applied to reduce the search space."}, {"heading": "3.6.1. Dominance Rule 1", "text": "On a branch-and-ground tree node associated with the problem P (~ B, Q, E), we assume that the scene s1 is the scene to be planned immediately after B, and the scene s2 belongs to Q \u2212 {s1}. If the scene s1 associated with the scene s1, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, s2, sc, sc, s2, sc, sc, s1, s1, 1, 1, 1, sc, s1, 1, 1, 1, 1, 1, sc, sc, sc, s2, s1, 1, 1, 1, 1, 1, sc, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, sc, sc, sc, sc, s2, s2, s2, s2, s2, s2, s2, s2, s2, s1, s1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,"}, {"heading": "3.6.2. Dominance Rule 2", "text": "At a tree node associated with problem P (B, Q, E), we assume that (s1) is the scene to be planned immediately after B and s2 belongs to Q \u2212 {s1}. If a (s1) a (s2) o (B) a (s2) o (B) a (s2) o (B) and c (s1) o (B) o (B) o (A) o (B) and c (s1) o (B) can be ignored, then the branch associated with scene s1 (s1) and c (s1) o (B) can be listed all action patterns that meet conditions a (s1) o (B) o (B) o (B. The right part of Table 9 is the result of a relocation of scene s2 immediately before scene s1 and immediately after B. From Table 9, we can obtain the following four action patterns: (1) the maintenance costs for pattern 9 actors remain unchanged; (2) the maintenance costs for patterns, 1) the costs for actors are reduced, 12) and (4) for each pattern are likely to be reduced."}, {"heading": "3.7. The Enhanced Branch-and-bound Algorithm", "text": "Our advanced branch-and-bound algorithm for the talent planning problem is given by algorithm 3, initializing the value of past costs z at the root node to zero; the pre-processing phase is realized by function preprocess (Q, AN) (see line 8, algorithm 3); the state caching technique is adopted by function check (~ B, Q, ~ E) (see line 9, algorithm 3); the function Dominates (~ B, Q, ~ E, AN, z, s) uses the proposed two dominance rules to verify that the branch to some scenes is dominated by other branches; the function lower (B, {s}, Q \u2212 {s}, E) provides a valid lower limit to the future cost of the problem at a search node; algorithm 3: The advanced branch-and-bound algorithm for the talent planning problem is lower (B, {s}, Q \u2212 {s}, E); if UZ bleed; Q: Q: Q; Q: Q; Q: Q: Q (end)."}, {"heading": "4. Computational Experiments", "text": "All the experiments were carried out on a Linux server clocked with an Intel Xeon E5430 CPU at 2.66 GHz and 8 GB RAM. The algorithm has only two parameters, namely the number (C) of cached states and the caching strategy used. After some preliminary experiments, we set C = 225 and chose the greedy caching strategy when solving the benchmark instances. In this section, we first present our results for the benchmark instances and then compare them with the results of the two best existing approaches. Finally, we demonstrate experimentally the effects of the parameters on the overall performance of the algorithm. All computing times given here are in CPU seconds on this server. All instances and detailed results are available in the online supplement to this paper at: www.computational-logistics.org / orlib / tsp."}, {"heading": "4.1. Results for Benchmark Instances", "text": "In fact, it is as if most people are able to survive themselves by blaming themselves and others. (...) In fact, it is as if most of them are not able to survive themselves. (...) It is as if they are not able to survive themselves. (...) It is as if they are not able to survive themselves. (...) \"It is as if they are not able to survive themselves.\" (...) \"It is as if they are able to survive themselves. (...)\" (...). \"(...) It is as if they are able to survive themselves.\" (...). \"(...) It is as if they are able to survive themselves. (...).\" (...) It is as if they are able to survive themselves. (...). (...) It is. (...). (...) It is. (...). (...) It is. () It is. (...) It is. (...). () It is. (...). It is. () It is. (...). It is. (...). It is. (...). It is. (). (... It is. (...). It is. (...). It is. (). It is. (). It is. (...). It is. It is. (). (... It is. (). It is. (...). It is. (...). It is. (). It. It is. It is. (. (). It is. (). It is. (). It is. (. (). It is. (). It is. (). (). (). It is. It is. (). It is. (). It is. (). It. (). (). (). It is. It is. It is. (). It is. (). (). It is. It is. (). It is. (). (). It is. (). It is. (). (). It is. (). It is. It is. (). It is. (). (). It is. (). It is. (). (). It is. (). It is. ()"}, {"heading": "4.2. Impacts of Parameter Settings", "text": "We take the value of C from {0, 25, 210, 220, 225}, where C = 0 means that cache is not used. Considering the two caching strategies, we have 12 parameter combinations in total. We tested these 12 parameter combinations with a subset of type 2 instances. Specifically, the first 5 instances were selected from each instance, for a total of 1,000 instances. We also have a time limit of 10 minutes on each execution of our algorithm. The results of these optimally resolved instances were recorded for analysis. Figure 2 shows the number of optimally resolved instances under each parameter setting. This figure shows that more caching states lead to optimally resolved instances under both caching strategies."}, {"heading": "5. Conclusions", "text": "This algorithm uses a new lower limit and two new dominance rules to circumvent the search nodes. Furthermore, it stores search states for the purpose of eliminating search nodes. The experimental results clearly show that our algorithm exceeds the current best approach and achieves the optimal solutions for significantly more benchmark instances. We present a mixed integer linear programming model for the talent planning problem in Section 2. One possible future direction of research is to design mathematical programming algorithms for the talent planning problem, such as a branch and cut algorithm and industry-bound coupled with delayed relaxation and subgradient methods."}, {"heading": "Acknowledgments", "text": "This research was partially supported by the Basic Research Fund for the Central Universities of HUST (grant no. 2012QN213) and the National Natural Science Foundation of China (grant no. 71201065 and 71131004)."}], "references": [{"title": "A dynamic programming formulation with diverse", "author": ["R.M. Adelson", "J.M. Norman", "G. Laporte"], "venue": null, "citeRegEx": "Adelson et al\\.,? \\Q1976\\E", "shortCiteRegEx": "Adelson et al\\.", "year": 1976}, {"title": "An efficient branch and bound algorithm for assembly line balancing problems", "author": ["T. Kelleg\u00f6z", "B. Toklu"], "venue": null, "citeRegEx": "Kelleg\u00f6z and Toklu,? \\Q2012\\E", "shortCiteRegEx": "Kelleg\u00f6z and Toklu", "year": 2012}, {"title": "Two branch-and-bound algorithms for the robust parallel machine", "author": ["M. Ranjbar", "M. Davari", "R. Leus"], "venue": "conference on LISP and functional programming", "citeRegEx": "Ranjbar et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Ranjbar et al\\.", "year": 2012}, {"title": "Caching search states in permutation problems", "author": ["B.M. APES group. Smith"], "venue": "Lecture Notes in Computer Science", "citeRegEx": "67.2003 and Smith,? \\Q2005\\E", "shortCiteRegEx": "67.2003 and Smith", "year": 2005}, {"title": "The single vehicle routing problem with toll-by-weight", "author": ["Z. Zhang", "H. Qin", "W. Zhu", "A. Lim"], "venue": null, "citeRegEx": "Zhang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al.", "startOffset": 50, "endOffset": 72}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al.", "startOffset": 50, "endOffset": 96}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage.", "startOffset": 50, "endOffset": 119}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage. They proposed a simple dynamic programming algorithm to solve their problem. Cheng et al. (1993) studied a film scheduling problem in which all scenes 2", "startOffset": 50, "endOffset": 391}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al.", "startOffset": 92, "endOffset": 114}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.", "startOffset": 92, "endOffset": 138}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.", "startOffset": 92, "endOffset": 183}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al.", "startOffset": 92, "endOffset": 375}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al.", "startOffset": 92, "endOffset": 461}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages.", "startOffset": 92, "endOffset": 485}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages. However, it is a simplified version of the movie shoot scheduling problem (MSSP) introduced by Bomsdorf and Derigs (2008). In the MSSP, we need to deal with a couple of practical constraints, such as the precedence relations among scenes, the time windows of each scene, the resource availability, and the working time", "startOffset": 92, "endOffset": 687}, {"referenceID": 4, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}, {"referenceID": 2, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}, {"referenceID": 1, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}], "year": 2014, "abstractText": "The talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings are disclosed by some additional experiments.", "creator": "LaTeX with hyperref package"}}}