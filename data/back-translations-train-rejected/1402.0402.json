{"id": "1402.0402", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Feb-2014", "title": "Customizable Contraction Hierarchies", "abstract": "We consider the problem of efficiently computing shortest paths in weighted graphs given auxiliary data computed in an expensive offline phase. Contraction Hierarchies --- a very successful techniques on road graphs --- are extended in this work to support a three phase workflow by adding a fast weight customization phase and using nested dissection orders. We provide an in-depth experimental analysis on large road and game maps that clearly shows that Customizable Contraction Hierarchies are a very practicable solution even in scenarios where edge weights constantly change. We are able to prove a constant factor approximation bound.", "histories": [["v1", "Mon, 3 Feb 2014 15:38:27 GMT  (306kb,D)", "https://arxiv.org/abs/1402.0402v1", null], ["v2", "Wed, 5 Feb 2014 12:29:17 GMT  (306kb,D)", "http://arxiv.org/abs/1402.0402v2", null], ["v3", "Wed, 12 Feb 2014 09:37:36 GMT  (306kb,D)", "http://arxiv.org/abs/1402.0402v3", null], ["v4", "Fri, 27 Jun 2014 08:18:28 GMT  (304kb,D)", "http://arxiv.org/abs/1402.0402v4", null], ["v5", "Fri, 21 Aug 2015 11:25:25 GMT  (525kb,D)", "http://arxiv.org/abs/1402.0402v5", null]], "reviews": [], "SUBJECTS": "cs.DS cs.AI", "authors": ["julian dibbelt", "ben strasser", "dorothea wagner"], "accepted": false, "id": "1402.0402"}, "pdf": {"name": "1402.0402.pdf", "metadata": {"source": "CRF", "title": "Customizable Contraction Hierarchies\u2217", "authors": ["Julian Dibbelt", "Ben Strasser"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In fact, the fact is that most of them will be able to play by the rules that they have set themselves in order to play by the rules that they have set by the rules and that they have taken care of. In fact, the fact is that they are able to play by the rules that they have set themselves."}, {"heading": "2 Basics", "text": "We refer to the undirected n-vertex graphs caused by G = (V, E), where V is not necessarily empty and cannot necessarily be compensated."}, {"heading": "3 Metric-Dependent Orders", "text": "Most publications on applications and extensions of contraction hierarchies use greedy orders in the spirit of [21], but details of the vertex order calculation and witness search vary. For reproducibility, we describe our precise approach in this section, which extends to the general description of metric-dependent CH pre-processing in Section 2. The only exception is the distance metric in the street diagrams, where we set p = 1500. We found that a higher value of p increases the time per witness search, but leads to sparse cores. We needed a high value for the distance metric, because otherwise our cores become too dense. This effect did not occur for the other weights considered in the experiments."}, {"heading": "4 Metric-Independent Order", "text": "The metric commands shown in the previous section give very good results on the road graphs with the travel time metric. However, the results for distance measurement are not as good and the commands are completely impracticable for calculating contractional hierarchies without looking for witnesses, as our experiments in Section 9 show. Therefore, to support metric independence, we use the nested section orders proposed in [6] or the ND graphs. An order for G is calculated recursively by determining a balanced separator S of the minimum cardinality, which is determined by the vertex sentences A and B. The vertex graphs of S are clearly mapped to the order (n \u2212 S |). The order for G is recursively mapped by determining a balanced separator S of the minimum cardinality, which is mapped by the vertex sentences A and B. The vertex graphs of S are mapped to the order S | n."}, {"heading": "5 Constructing the Contraction Hierarchy", "text": "In this section, we describe how to efficiently contract the hierarchy G-\u03c0 for a given graph G and order G. Weighted contraction hierarchies are usually constructed using a dynamic adjacence array representation of the core diagram. Our experiments show that this approach also works for the unweighted case, but requires more computing and memory resources due to the higher growth of associations. It has been suggested [42] to use hash tables on top of the dynamic graph structure to improve speed, but at the expense of significantly increased memory consumption. In this section, we show that the contraction hierarchy construction can be performed much faster on unweighted and undirected graphs. Note that in our toolchain graph weights and arc directions are considered during the fit phase. Denote by n the number of nodes in G (and G), by the number of nodes in G (and G), by the number of arcs in G, by the number of G \u00b2, by the number of arcs in G, by the number of arcs in G \u00b2 and by the number of m \u00b2."}, {"heading": "5.1 Contracting Vertices", "text": "We restore it by merging adjacent super-corners: Use y to denote a super-corner that is a neighbor of x. We rewire all edges associated with y to be x incidental, and remove y from H. To support efficient merging of corners in H, we store a linked list of neighbors for each vertex. When we merge two corners, we associate these lists with each other. Unfortunately, combining these lists is not enough, since the previous neighbors z of y still have y in their list of neighbors. We therefore maintain a data structure that finds merging of corners: First, all corners are within their own group. When merging x and y, the sentences of x and y are merged. We chose x as representative, because y deleted.1 if z enumerates1Or alternatively, we can choose the Union Find data structure."}, {"heading": "5.2 Enumerating Neighbors", "text": "Suppose we want to enumerate the neighbors of a vertex in H. Note that the neighborhood of x in H is different from the neighborhood in G. The neighborhood of x in H can contain super corners, because super corners are only added together in G. We keep a Boolean marker that indicates which neighbors have already been enumerated. Initially, no marker is set. We iterate over the neighborhood list of x. For each reference, we look for the representative v. If v has already been enumerated or x is, we remove the reference from the list. If v is not enumerated and is not x, we mark it and register it as neighbor. After enumerating, we reset all markers by enumerating the neighbors. However, after executing our algorithm, we are not interested in the neighborhood of x in H, but we want the neighborhood of x in G, i.e., the algorithm should not list any super corners."}, {"heading": "5.3 Performance Analysis", "text": "Since there are no memory allocations, it is clear that the workspace memory consumption is in O (m). Evidence of a runtime in O (m) is less clear, so use d (x) to indicate the degree of x before x is contracted. This allows us to assume that they are free within the main analysis. We then show that the contraction of a vertex is x and the enumeration of its neighbors in O (x) x. Thus, the processing of all vertices has a runtime in O (m). The neighborhood list of x can contain double references, and therefore its length is greater than the number of neighbors of x. Furthermore, we must perform a search for each entry in the list."}, {"heading": "5.4 Adjacency Array", "text": "While the algorithm described is efficient in theory, it causes too many missteps in practice. Therefore, we have implemented a hybrid structure of the linked list and the linked arrangements, which comprises only a small number of references that we extract from a block to remove them from the list. 6 Enumerating each original vertex form a single block, z} is a set of 3 adjacentices. A triangle can be an upper, middle or lower triangle structure. If all references are deleted from a block, we remove it from the list. 6 Enumerating each original vertex {x, z} is a set of 3 adjacvertices. An intermediate or lower triangle with an upper, intermediate or lower intermediate with an arc (x, y), as illustrated in Figure 4."}, {"heading": "7 Customization", "text": "In this section, we will describe the second metric-dependent pre-processing phase, known as customization, that is, we will show how to efficiently extend the weights of the input graph to a corresponding metric with weights for all arcs in G-\u03c0. We will consider three different distances between vertices: We will refer to distI (s, t) as the shortest distance in the input graph G. However, distUD (s, t) is the shortest distance in G-\u03c0 if we consider only upward paths. Finally, we will let distA (s, t) be the shortest distance in G-ig, i. e. if we designate arbitrary, non-necessarily upward and downward paths in G-\u03c0, if we only consider upward paths."}, {"heading": "7.1 Basic Customization", "text": "A central concept of the basic fit algorithms is the lower triangle inequality, which is defined as follows: A metric mC fulfills it if for all the lower triangles x, y, z each arc (x, y) value exists. Our algorithm takes advantage of this by transforming the given metric in a coordinated way that maintains the respecting property and ensures that the lower triangle inequality holds. Thus, the resulting metric is customized and proves that the resulting metric respects and fulfills the inequality. We then prove that this is sufficient for the resulting metric to be customized.Our algorithm iterates across all arcs (x, y)."}, {"heading": "7.3 Perfect Witness Search", "text": "We present two variants of our algorithm: The first variant is to remove all arcs (x, y) whose weight does not correspond to the shortest XY path path mP (x, y) after the basic fit mC (x, y). This variant is simple and always correct, but it does not remove as many arcs as possible if there is a pair of vertices a and b in the input graph, so that there are several shortest down paths. The second variant 2 also eliminates these additional arcs. An arc (x, y) is removed if and only if an upper or middle triangle (x, y, z) exists, so that the shortest path from x via z to y is no longer than the shortest XY path. However, before we can prove the correctness of the second variant, we must introduce a technical solution that is not absolutely necessary to determine the heights of the XII path, which we also need in relation to the height of the XY path."}, {"heading": "7.3.1 Variant for Graphs with Unique Shortest Paths", "text": "We know that before removing any arc of nodes there is an \"arc of nodes.\" We show that no arc of nodes exists and therefore no arc of nodes exists. We must know that before removing any arc of nodes there is an \"arc of nodes.\" We show that no arc of nodes exists. We know that before removing any arc there is an \"arc of nodes.\" We show that no arc of nodes exists. We show that no arc of nodes exists. \"We know that before removing any arc there is an\". \"We show that no arc of nodes exists."}, {"heading": "7.4 Parallelization", "text": "The basic fit can be parallelized by processing the arcs (x, y) that differ from each other in parallel within a level. Between the levels, we have to synchronize all threads using a barrier. As all threads only write to the arc they are currently assigned to, and are read only by arcs that are processed at a strictly lower level, we can therefore guarantee that there will be no read / write conflict. Therefore, no locks or atomic operations are required. Fortunately, the end result is always the same and independent of the execution sequence. Our algorithm works as follows: We iterate the total arcs within a level x and synchronize all threads between levels."}, {"heading": "7.5 Directed Graphs", "text": "Until now, we have focused on fitting undirected graphs. If the input graph G is directed, our tool chain works as follows: Based on the undirected, undirected graph induced by G, we calculate a vertex ordering \u03c0 (section 4), we build the upward contraction hierarchy G \u00b2 (section 5) and optionally execute {{} a triangle preprocessing angle (section 6). However, for the fit, we consider two weights per arc in G \u00b2 \u03c0, one for each direction of travel. One-way streets are modeled by executing the weight according to the forbidden direction of motion in x (section 6). In terms of defining x x x x x x, we define one upward metric m and one downward metric md for each arc (x, y) G in the directed input graph with input weights w (x, y), we set the values mu (x), y, y (w, y), we set (x), mu (x), y (x, mu (x)."}, {"heading": "7.6 Single Instruction Multiple Data", "text": "The weights appended to each arc in the CH can be replaced by a set of intertwined k weights by storing a vector of k elements for each arc. Vectors allow us to adjust all k metrics in one go by amortizing the time of the triangular enumeration, and they allow us to use single command multiple data (SIMD). Also, since we essentially use two metrics to handle directed graphs, we can store both in a two-dimensional vector. This allows us to handle both directions in a single processor statement. Similarly, if we have k directed input weights, we can store them in a two-dimensional vector. The processor must support the component-wise minimum and saturated addition, i.e., a + b = intmax must contain a minimum amount of b in case of overflow."}, {"heading": "7.7 Partial Updates", "text": "In fact, we will be able to move to another world, in which we will move to another world, in which we will move to another world, \"he said.\" We must move to a new world, \"he said.\" We must move to a new world, \"he said.\" We will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will move to a new world, in which we will dive into a new world. \""}, {"heading": "8 Distance Query", "text": "In this section we describe how to calculate distance queries 3, i.e. a shortest path in G-\u03c0 between two vertices s and t with a user-defined metric up and down, and how to extract it into a shortest path edge sequence in G."}, {"heading": "8.1 Basic", "text": "The basic query performs two instances of the Dijkstras algorithm on the path from s to p and from t. If G is undirected, both searches use the same measurement. Otherwise, the search from s to the top uses the metric mu and the search for t to the bottom uses the metric md. In contrast to [21], in both cases they work with 3We refer to the minimum sum of all weights across all st paths as the distance between s and t. The term \"distance query\" does not mean that we only consider shortest paths by geographical distance. On the same search diagram up, we refer to the same path. If the radius of one of the two searches is larger than the shortest path found so far, we stop the search because we know that there can be no shorter path. We switch between processing vertices in the forward search and processing vertices in the reverse search."}, {"heading": "8.2 Stalling", "text": "We implemented a basic version of an optimization called Stable-on-Demand in [21, 33], which takes advantage of the fact that the shortest strictly up sv path in G-\u03c0 can be longer than the shortest sv path in G-\u03c0 \u03c0, which can go up and down arbitrarily, the search for s only finds up sv path, and if we observe that there is an up-down path that is no longer, then we can cut off the upward search. Denote by the vertex, which can be removed from the queue. We iterate over all outgoing arcs (x, y) and test if there is an up-down path that is no longer than an up-up path. If it holds for some arcs that we do not loosen its outgoing arcs. If d (x, y) > m holds properties (y), then pruning is correct, because all the underpaths of the shortest paths are the shortest down."}, {"heading": "8.3 Elimination Tree", "text": "In a second step, we calculate the lowest common ancestors (LCA) x of s and t in the excretory structure. We do this by simultaneously enumerating all ancestors of s and t by increasing the ranking until a common ancestor is found. In a second step, we iterate the lowest common ancestors (LCA) x of s and t in the excretory structure. We do this by simultaneously enumerating all ancestors of s and t by increasing the rank until a common ancestor is found. In a third step, we do the same for all ancestors of t and x in the backward search."}, {"heading": "8.4 Path Unpacking", "text": "All shortest path queries calculate only the shortest up and down paths, which is sufficient to determine the distance of a shortest path in the original graph. However, if you want to calculate the edge sequence that forms the shortest path, then the upward path must be unpacked. [21] The original KH of [21] unpacks an upward path by storing for each arc (x, y) the vertex z of the lower triangle {x, y, z} that caused the weight at m (x, y). This information depends on the metric and we want to avoid storing additional metric information. Therefore, we use a different strategy: label the upward path found by the query. As long as a lower triangle {pi, pi + 1, x} of an arc (pi, pi + 1) with m (x, pi + 1) + m (x, pi + 1) exists in the arc (pi, pi + 1) and the vertex between the point."}, {"heading": "9 Experiments", "text": "In this section we present our careful and extensive experimental evaluations of the algorithms we have introduced and described. [Compiler and Machine We implement our algorithms in C + +, which are based on a single graph based on a single core of an Intel Core i7-2600K CPU, with 64 GiB of DDR3-1600 RAM, 20 MiB of L3 and 256 KiB of L2 cache. The sequence of experiments performed in Table 2 is based on a single core of a Core i7-2600K CPU processor. Instances We evaluate three large instances of practical relevance in detail. In Section 10 we provide summarized experiments on other instances."}, {"heading": "9.3 CH Size", "text": "This is true even if we only want to count the number of sheets: however, we can say with certainty that with this order it is impossible to achieve a speed limit compared to Dijkstra's algorithm compared to Dijkstra's algorithm on the input graph. However, we can actually calculate the CH without a witness search and perform a complete witness search. Figures show that heuristic witness search is almost optimal."}, {"heading": "9.4 Triangle Enumeration", "text": "Figure 12 clearly shows that most of the time is spent enumerating the triangles of the lower levels, which justifies our proposal to pre-calculate the triangles only for the lower levels, as these are the levels where optimisation is most effective. However, there is no harm in pre-calculating more levels when there is enough memory available. We suggest setting the threshold level up to which triangles are pre-calculated based on the size of available empty memory. On modern servers such as our benchmarking calculator, there is enough memory to pre-calculate all levels. Memory consumption is summarised in Table 7. However, please note that pre-calculating all triangles in the game scenario is prohibitive as less available memory should be expected."}, {"heading": "9.5 Customization", "text": "This year, it has reached the point where it will be able to retaliate."}, {"heading": "9.6 Query Performance", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}, {"heading": "9.7 Comparison with Related Work", "text": "We conclude our experimental analysis of the DIMACS road network in Europe with a final comparison of related techniques as shown in Table 15. For Contraction Hierarchies (CH), we report results based on implementations of [21, 13] and ourselves, covering various trade-offs in terms of preprocessing time versus query speed. Specifically, we observe that our own implementation in Section 9.1-9.6) is a slightly slower query in terms of travel time metric, the cost of higher preprocessing time. Recall what we use for a different Vertex priority function and no rotten updates. For Customizable Route Planning (CRP), we report results from [13, 12].Metric-dependent CH queries in terms of preprocessing time-time-time-time-time-time-time. Recall from Section 3 that we do not use an update function and do not use a rotten function."}, {"heading": "10 Further Instances", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}, {"heading": "10.2 Further DIMACS-Instances", "text": "During the shortest route DIMACS challenge [17], several benchmark factors were provided, including the European instance used in our in-depth experiments in previous chapters. In addition to this instance, a number of graphs representing the US road network were also published. In Table 20, we report on experiments for these additional DIMACS road charts. Unlike the DIMACSEurope instance, these US instances come from the US Census Bureau. This is why we are focusing on the European instance in the main part of our assessment: the graphs are generally undirected (not one-way streets) and motorways are sometimes not connected to state borders. DIMACS-Europe instances come from a different data source and do not have these limitations. This is why we are focusing on the European instance in the main part of our assessment. However, since the graphs are undirected, we cannot evaluate the effects of the use of a single unassessed metric."}, {"heading": "10.3 Further Game Instances", "text": "In addition to our main game benchmark instance TheFrozenSea, the benchmark record of [38] contains a large variety of different playing cards. To show that our technique also works on other playing cards, we conducted our experiments on a selection of different diagrams from the set. \"16room 005\" is a synthetic card with many grid-shaped rooms connected by small doors. \"AcrosstheCape\" is another Star Craft card that is sometimes used as a benchmark instance. \"blastedlands\" is from WarCraft 3 and is the largest card in this set in terms of vertices. \"maze512-4-3\" and \"random512-40-8\" are synthetic cards that consist of a random maze with corridors 4 fields wide. \"ost100d\" is the largest card from the Dragon Age Origins card set. \"random512-35-8\" and \"random512-40-8\" are synthetic cards that cover random obstacles each of them. The difference between the number of obstacles is the amount of."}, {"heading": "11 Conclusions", "text": "We have extended Contraction Hierarchies (CH) to a three-phase customization approach and demonstrated in an extensive experimental assessment that our customizable contract hierarchies approach is practicable and efficient not only on real street diagrams, but also on playing cards. We have proposed new algorithms that improve the state of the art for almost all stages of the toolchain: Using our contract graph data structure, a metric-independent CH can be constructed faster than the established approach based on dynamic arrays. We have shown that the customization phase is essentially a triangle enumeration algorithm. We have proposed two variants of customization: the basic variant leads to faster customization runtimes, while perfect customization and witness search CHs with a detectable minimum number of abbreviations within seconds in a metric-independent vertex sequence."}, {"heading": "11.1 Future Work", "text": "In fact, it is not that we have achieved significant improvements in this area: the work of [39] lay the13.com / benchmarks / foundations of a well-implemented KaHIP-based algorithm. [35] we are leading to significant improvements in this area. The work of [39] lay the13.com / benchmarks / foundations of a well-implemented KaHIP-based algorithm. [35] is leading to new and surprisingly simple road section algorithms called Inertial Flow, which is available as a preprint."}], "references": [{"title": "Highway dimension and provably efficient shortest path", "author": ["Ittai Abraham", "Daniel Delling", "Amos Fiat", "Andrew V. Goldberg", "Renato F. Werneck"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2013}, {"title": "Hierarchical hub labelings for shortest paths", "author": ["Ittai Abraham", "Daniel Delling", "Andrew V. Goldberg", "Renato F. Werneck"], "venue": "In Proceedings of the 20th Annual European Symposium on Algorithms (ESA\u201912),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Highway dimension, shortest paths, and provably efficient algorithms", "author": ["Ittai Abraham", "Amos Fiat", "Andrew V. Goldberg", "Renato F. Werneck"], "venue": "In Proceedings of the 21st Annual ACM\u2013SIAM Symposium on Discrete Algorithms", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "Route planning in transportation networks", "author": ["Hannah Bast", "Daniel Delling", "Andrew V. Goldberg", "Matthias M\u00fcller\u2013Hannemann", "Thomas Pajor", "Peter Sanders", "Dorothea Wagner", "Renato F. Werneck"], "venue": "Technical Report abs/1504.05140, ArXiv e-prints,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Preprocessing speed-up techniques is hard", "author": ["Reinhard Bauer", "Tobias Columbus", "Bastian Katz", "Marcus Krug", "Dorothea Wagner"], "venue": "In Proceedings of the 7th Conference on Algorithms and Complexity (CIAC\u201910),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2010}, {"title": "Search-space size in contraction hierarchies", "author": ["Reinhard Bauer", "Tobias Columbus", "Ignaz Rutter", "Dorothea Wagner"], "venue": "In Proceedings of the 40th International Colloquium on Automata, Languages, and Programming (ICALP\u201913),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "The shortcut problem \u2013 complexity and algorithms", "author": ["Reinhard Bauer", "Gianlorenzo D\u2019Angelo", "Daniel Delling", "Andrea Schumm", "Dorothea Wagner"], "venue": "Journal of Graph Algorithms and Applications,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "A tourist guide through treewidth", "author": ["Hans L. Bodlaender"], "venue": "j-acta-cybernet,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1993}, {"title": "Treewidth: Structure and algorithms", "author": ["Hans L. Bodlaender"], "venue": "Proceedings of the 14th International Colloquium on Structural Information and Communication Complexity,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Treewidth computations i. upper bounds", "author": ["Hans L. Bodlaender", "Arie M.C.A. Koster"], "venue": "Information and Computation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Shortest paths in digraphs of small treewidth", "author": ["Soma Chaudhuri", "Christos Zaroliagis"], "venue": "i: Sequential algorithms. Algorithmica,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2000}, {"title": "Customizable route planning", "author": ["Daniel Delling", "Andrew V. Goldberg", "Thomas Pajor", "Renato F. Werneck"], "venue": "In Proceedings of the 10th International Symposium on Experimental Algorithms (SEA\u201911),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Customizable route planning in road networks", "author": ["Daniel Delling", "Andrew V. Goldberg", "Thomas Pajor", "Renato F. Werneck"], "venue": "Transportation Science,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "Graph partitioning with natural cuts", "author": ["Daniel Delling", "Andrew V. Goldberg", "Ilya Razenshteyn", "Renato F. Werneck"], "venue": "In 25th International Parallel and Distributed Processing Symposium", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Exact combinatorial branch-and-bound for graph bisection", "author": ["Daniel Delling", "Andrew V. Goldberg", "Ilya Razenshteyn", "Renato F. Werneck"], "venue": "In Proceedings of the 14th Meeting on Algorithm Engineering and Experiments", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "Faster customization of road networks", "author": ["Daniel Delling", "Renato F. Werneck"], "venue": "In Proceedings of the 12th International Symposium on Experimental Algorithms (SEA\u201913),", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "The Shortest Path Problem: Ninth DIMACS Implementation Challenge, volume", "author": ["Camil Demetrescu", "Andrew V. Goldberg", "David S. Johnson", "editors"], "venue": "DIMACS Book. American Mathematical Society,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "A note on two problems in connexion with graphs", "author": ["Edsger W. Dijkstra"], "venue": "Numerische Mathematik,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1959}, {"title": "Incidence matrices and interval graphs", "author": ["Delbert R. Fulkerson", "O.A. Gross"], "venue": "Pacific Journal of Mathematics,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1965}, {"title": "Contraction hierarchies: Faster and simpler hierarchical routing in road networks", "author": ["Robert Geisberger", "Peter Sanders", "Dominik Schultes", "Daniel Delling"], "venue": "In Proceedings of the 7th Workshop on Experimental Algorithms (WEA\u201908),", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}, {"title": "Exact routing in large road networks using contraction hierarchies", "author": ["Robert Geisberger", "Peter Sanders", "Dominik Schultes", "Christian Vetter"], "venue": "Transportation Science,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "Nested dissection of a regular finite element mesh", "author": ["Alan George"], "venue": "SIAM Journal on Numerical Analysis,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1973}, {"title": "A quotient graph model for symmetric factorization", "author": ["Alan George", "Joseph W. Liu"], "venue": "In Sparse Matrix Proceedings", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1978}, {"title": "The analysis of a nested dissection algorithm", "author": ["John R. Gilbert", "Robert Tarjan"], "venue": "Numerische Mathematik,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1986}, {"title": "Graph bisection with pareto-optimization", "author": ["Michael Hamann", "Ben Strasser"], "venue": "Technical report,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2015}, {"title": "Engineering multilevel overlay graphs for shortest-path queries", "author": ["Martin Holzer", "Frank Schulz", "Dorothea Wagner"], "venue": "ACM Journal of Experimental Algorithmics,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "Tractability of parameterized completion problems on chordal, strongly chordal, and proper interval graphs", "author": ["Haim Kaplan", "Ron Shamir", "Robert Tarjan"], "venue": "SIAM Journal on Computing,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1999}, {"title": "A fast and high quality multilevel scheme for partitioning irregular graphs", "author": ["George Karypis", "Vipin Kumar"], "venue": "SIAM Journal on Scientific Computing,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1999}, {"title": "Generalized nested dissection", "author": ["Richard J. Lipton", "Donald J. Rose", "Robert Tarjan"], "venue": "SIAM Journal on Numerical Analysis,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1979}, {"title": "On optimal preprocessing for contraction hierarchies", "author": ["Nikola Milosavljevi\u0107"], "venue": "In Proceedings of the 5th ACM SIGSPATIAL International Workshop on Computational Transportation Science,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2012}, {"title": "Computing all-pairs shortest paths by leveraging low treewidth", "author": ["L\u00e9on Planken", "Mathijs de Weerdt", "Roman van Krogt"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2012}, {"title": "The complexity of optimal elimination trees", "author": ["Alex Pothen"], "venue": "Technical report, Pennsylvania State University,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1988}, {"title": "Engineering highway hierarchies", "author": ["Peter Sanders", "Dominik Schultes"], "venue": "ACM Journal of Experimental Algorithmics,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2012}, {"title": "Think locally, act globally: Highly balanced graph partitioning", "author": ["Peter Sanders", "Christian Schulz"], "venue": "In Proceedings of the 12th International Symposium on Experimental Algorithms (SEA\u201913),", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2013}, {"title": "On balanced separators in road networks", "author": ["Aaron Schild", "Christian Sommer"], "venue": "In Proceedings of the 14th International Symposium on Experimental Algorithms (SEA\u201915),", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2015}, {"title": "Dijkstra\u2019s algorithm on-line: An empirical case study from public railroad transport", "author": ["Frank Schulz", "Dorothea Wagner", "Karsten Weihe"], "venue": "ACM Journal of Experimental Algorithmics,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2000}, {"title": "Contraction hierarchies on grid graphs", "author": ["Sabine Storandt"], "venue": "In Proceedings of the 36rd Annual German Conference on Advances in Artificial Intelligence, Lecture Notes in Computer Science. Springer,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2013}, {"title": "Benchmarks for grid-based pathfinding", "author": ["Nathan Sturtevant"], "venue": "Transactions on Computational Intelligence and AI in Games,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2012}, {"title": "Finding small node separators", "author": ["Michael Wegner"], "venue": "Bachelor thesis, Karlsruhe Institute of Technology,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2014}, {"title": "Tedi: efficient shortest path query answering on graphs", "author": ["Fang Wei"], "venue": "In Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data (SIGMOD\u201910). ACM Press,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2010}, {"title": "Computing the minimum fill-in is np-complete", "author": ["Mihalis Yannakakis"], "venue": "SIAM Journal on Algebraic and Discrete Methods,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1981}, {"title": "Weak contraction hierarchies work", "author": ["Tim Zeitz"], "venue": "Bachelor thesis, Karlsruhe Institute of Technology,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2013}], "referenceMentions": [{"referenceID": 17, "context": "Unfortunately, road graphs tend to be huge in practice with vertex counts in the tens of millions, rendering Dijkstra\u2019s algorithm [18] impracticable for interactive use: It incurs running times in the order of seconds even for a single path query.", "startOffset": 130, "endOffset": 134}, {"referenceID": 3, "context": "See [4] for an overview.", "startOffset": 4, "endOffset": 7}, {"referenceID": 6, "context": "While variants of the optimal shortcut selection problem have been proven to be NP-hard [7], determining good shortcuts is feasible in practice even on large road graphs.", "startOffset": 88, "endOffset": 91}, {"referenceID": 19, "context": "Among the most successful speedup techniques using this building block are Contraction Hierarchies (CH) by [20, 21].", "startOffset": 107, "endOffset": 115}, {"referenceID": 20, "context": "Among the most successful speedup techniques using this building block are Contraction Hierarchies (CH) by [20, 21].", "startOffset": 107, "endOffset": 115}, {"referenceID": 20, "context": "Even though ordering heuristics exist that work well in practice [21], the problem of computing an optimal ordering is NP-hard in general [5].", "startOffset": 65, "endOffset": 69}, {"referenceID": 4, "context": "Even though ordering heuristics exist that work well in practice [21], the problem of computing an optimal ordering is NP-hard in general [5].", "startOffset": 138, "endOffset": 141}, {"referenceID": 0, "context": "Worst-case bounds have been proven in [1] in terms of a weight-dependent graph measure called highway dimension and [30] have shown that many of these bounds are tight on many graph classes.", "startOffset": 38, "endOffset": 41}, {"referenceID": 29, "context": "Worst-case bounds have been proven in [1] in terms of a weight-dependent graph measure called highway dimension and [30] have shown that many of these bounds are tight on many graph classes.", "startOffset": 116, "endOffset": 120}, {"referenceID": 20, "context": "A central restriction of CHs as proposed by [21] is that their preprocessing is metric-dependent, that is edge weights, also called metric, need to be known.", "startOffset": 44, "endOffset": 48}, {"referenceID": 11, "context": "For this reason, a Customizable Route Planning (CRP) approach was proposed in [12], extending the multi-level-overlay MLD techniques of [36, 26].", "startOffset": 78, "endOffset": 82}, {"referenceID": 35, "context": "For this reason, a Customizable Route Planning (CRP) approach was proposed in [12], extending the multi-level-overlay MLD techniques of [36, 26].", "startOffset": 136, "endOffset": 144}, {"referenceID": 25, "context": "For this reason, a Customizable Route Planning (CRP) approach was proposed in [12], extending the multi-level-overlay MLD techniques of [36, 26].", "startOffset": 136, "endOffset": 144}, {"referenceID": 36, "context": "Game Scenario Most existing CH papers focus solely on road graphs, with [37] being a notable exception, but there are many other applications with differently structured graphs in which fast shortest path computations are important.", "startOffset": 72, "endOffset": 76}, {"referenceID": 21, "context": "Metric-Independent Orders for CHs One of the central building blocks of this paper is the use of metric-independent nested dissection orders (ND-orders) [22] for CH precomputation instead of the metric-dependent order of [21].", "startOffset": 153, "endOffset": 157}, {"referenceID": 20, "context": "Metric-Independent Orders for CHs One of the central building blocks of this paper is the use of metric-independent nested dissection orders (ND-orders) [22] for CH precomputation instead of the metric-dependent order of [21].", "startOffset": 221, "endOffset": 225}, {"referenceID": 5, "context": "This approach was proposed by [6], and a preliminary case study can be found in [42].", "startOffset": 30, "endOffset": 33}, {"referenceID": 41, "context": "This approach was proposed by [6], and a preliminary case study can be found in [42].", "startOffset": 80, "endOffset": 84}, {"referenceID": 15, "context": "A similar idea was followed by [16], where the authors employ partial CHs to engineer subroutines of their customization phase.", "startOffset": 31, "endOffset": 35}, {"referenceID": 30, "context": "Similar ideas have also appeared in [31]: They consider graphs of low treewidth (see below) and leverage this property to compute CH-like structures, without explicitly using the term CH.", "startOffset": 36, "endOffset": 40}, {"referenceID": 39, "context": "Related techniques by [40, 11] work directly on the tree decomposition.", "startOffset": 22, "endOffset": 30}, {"referenceID": 10, "context": "Related techniques by [40, 11] work directly on the tree decomposition.", "startOffset": 22, "endOffset": 30}, {"referenceID": 21, "context": "To the best of our knowledge the idea first appeared in 1973 in [22] and was refined in [29].", "startOffset": 64, "endOffset": 68}, {"referenceID": 28, "context": "To the best of our knowledge the idea first appeared in 1973 in [22] and was refined in [29].", "startOffset": 88, "endOffset": 92}, {"referenceID": 8, "context": "We refer to [9] and [8] for an introduction to the broad field of treewidth and tree decompositions.", "startOffset": 12, "endOffset": 15}, {"referenceID": 7, "context": "We refer to [9] and [8] for an introduction to the broad field of treewidth and tree decompositions.", "startOffset": 20, "endOffset": 23}, {"referenceID": 40, "context": ", minimizing the fill-in, is NP-hard [41] but fixed parameter tractable in the number of extra edges [27].", "startOffset": 37, "endOffset": 41}, {"referenceID": 26, "context": ", minimizing the fill-in, is NP-hard [41] but fixed parameter tractable in the number of extra edges [27].", "startOffset": 101, "endOffset": 105}, {"referenceID": 5, "context": "[6] have shown that the maximum search space size in terms of vertices corresponds to the height of this elimination tree.", "startOffset": 0, "endOffset": 3}, {"referenceID": 31, "context": "Unfortunately, minimizing the elimination tree height is also NP-hard [32].", "startOffset": 70, "endOffset": 74}, {"referenceID": 23, "context": "For planar graphs, it has been shown that the number of additional edges is in O(n log n) [24].", "startOffset": 90, "endOffset": 94}, {"referenceID": 11, "context": "Compared to CRP [12] we achieve a similar preprocessing\u2013query tradeoff, albeit with slightly better query performance at slightly slower customization speed and we need somewhat more space.", "startOffset": 16, "endOffset": 20}, {"referenceID": 20, "context": "Interestingly, for less well-behaved metrics such as travel distance, we achieve query times below the original metric-dependent CH of [21].", "startOffset": 135, "endOffset": 139}, {"referenceID": 20, "context": "Our specialized algorithm has better theoretic worst-case running time and performs significantly better empirically than the dynamic adjacency arrays used in [21].", "startOffset": 159, "endOffset": 163}, {"referenceID": 20, "context": "Section 3 discusses metric-dependent orders as used by [21], highlighting specifics of our implementation.", "startOffset": 55, "endOffset": 59}, {"referenceID": 20, "context": "Given a fixed weight w, one can exploit that in many applications it is sufficient to only preserve all shortest path distances [21].", "startOffset": 128, "endOffset": 132}, {"referenceID": 20, "context": "This check is called witness search [21] and the xy-path is called witness, if it exists.", "startOffset": 36, "endOffset": 40}, {"referenceID": 20, "context": "Note that the witness searches are expensive and therefore the witness search is usually aborted after a certain number of steps [21].", "startOffset": 129, "endOffset": 133}, {"referenceID": 20, "context": "This up-down path can be found by running a bidirectional search from s restricted to SS(s) and from t restricted to SS(t) [21].", "startOffset": 123, "endOffset": 127}, {"referenceID": 18, "context": ", the core graph before the contraction of \u03c0(i), form a clique [19].", "startOffset": 63, "endOffset": 67}, {"referenceID": 5, "context": "As shown in [6], the set of vertices on the path from v to \u03c0(n) is the set of vertices in SS(v).", "startOffset": 12, "endOffset": 15}, {"referenceID": 20, "context": "3 Metric-Dependent Orders Most publications on applications and extensions of Contraction Hierarchies use greedy orders in the spirit of [21], but details of vertex order computation and witness search vary.", "startOffset": 137, "endOffset": 141}, {"referenceID": 1, "context": "Our weighting heuristic is similar to the one of [2].", "startOffset": 49, "endOffset": 52}, {"referenceID": 20, "context": "Hence, for the experiments presented in Section 9, we do not use lazy updates or periodic queue rebuilding as proposed in [21].", "startOffset": 122, "endOffset": 126}, {"referenceID": 5, "context": "To support metric-independence, we therefore use nested dissection orders as suggested in [6] or ND-orders for short.", "startOffset": 90, "endOffset": 93}, {"referenceID": 33, "context": "However, recent years have seen heuristics that solve the problem very well even for continental road graphs [34, 15, 14].", "startOffset": 109, "endOffset": 121}, {"referenceID": 14, "context": "However, recent years have seen heuristics that solve the problem very well even for continental road graphs [34, 15, 14].", "startOffset": 109, "endOffset": 121}, {"referenceID": 13, "context": "However, recent years have seen heuristics that solve the problem very well even for continental road graphs [34, 15, 14].", "startOffset": 109, "endOffset": 121}, {"referenceID": 27, "context": "We experimentally examine the performance of nested dissection orders computed by NDMetis [28] and KaHIP [34] in Section 9.", "startOffset": 90, "endOffset": 94}, {"referenceID": 33, "context": "We experimentally examine the performance of nested dissection orders computed by NDMetis [28] and KaHIP [34] in Section 9.", "startOffset": 105, "endOffset": 109}, {"referenceID": 5, "context": "The proof of this lemma is a straightforward argument using a geometric series as described in [6].", "startOffset": 95, "endOffset": 98}, {"referenceID": 28, "context": "This lemma is a minor adaptation and extension of [29], who only prove that such a clique exists but not that it lies within enough search spaces.", "startOffset": 50, "endOffset": 54}, {"referenceID": 41, "context": "It has been proposed [42] to use hash-tables on top of the dynamic graph structure to improve speed but at the cost of significantly increased memory consumption.", "startOffset": 21, "endOffset": 25}, {"referenceID": 22, "context": "The approach is heavily based upon the method of the quotient graph [23].", "startOffset": 68, "endOffset": 72}, {"referenceID": 15, "context": "Comparison with CRP Triangle preprocessing has similarities with micro and macro code in CRP [16].", "startOffset": 93, "endOffset": 97}, {"referenceID": 15, "context": "Hence, let t be the number of undirected triangles and m be the number of arcs in G\u03c0 ; further let t \u2032 be the number of directed triangles and m\u2032 be the number of arcs used in [16].", "startOffset": 176, "endOffset": 180}, {"referenceID": 2, "context": "Figure 6: The rank sequence of the solid red path is [3, 2, 1].", "startOffset": 53, "endOffset": 62}, {"referenceID": 1, "context": "Figure 6: The rank sequence of the solid red path is [3, 2, 1].", "startOffset": 53, "endOffset": 62}, {"referenceID": 0, "context": "Figure 6: The rank sequence of the solid red path is [3, 2, 1].", "startOffset": 53, "endOffset": 62}, {"referenceID": 2, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 45, "endOffset": 57}, {"referenceID": 2, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 45, "endOffset": 57}, {"referenceID": 1, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 45, "endOffset": 57}, {"referenceID": 0, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 45, "endOffset": 57}, {"referenceID": 3, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 108, "endOffset": 117}, {"referenceID": 1, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 108, "endOffset": 117}, {"referenceID": 0, "context": "The rank sequence of the blue dashed path is [3, 3, 2, 1] and the rank sequence of the green dotted path is [4, 2, 1].", "startOffset": 108, "endOffset": 117}, {"referenceID": 20, "context": "The ideas employed by our algorithm are somewhat similar to those presented in [21], but our situation differs as we know that we do not have to insert or remove arcs.", "startOffset": 79, "endOffset": 83}, {"referenceID": 20, "context": "In either case in contrast to [21] they operate 3We refer to the minimum sum over all weights over all st-paths as the distance between s and t.", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "2 Stalling We implemented a basic version of an optimization presented in [21, 33] called stall-on-demand.", "startOffset": 74, "endOffset": 82}, {"referenceID": 32, "context": "2 Stalling We implemented a basic version of an optimization presented in [21, 33] called stall-on-demand.", "startOffset": 74, "endOffset": 82}, {"referenceID": 20, "context": "The original CH of [21] unpacks an up-down path by storing for every arc (x, y) the vertex z of the lower triangle {x, y, z} that caused the weight at m(x, y).", "startOffset": 19, "endOffset": 23}, {"referenceID": 16, "context": "The sizes of our main test instances are reported in Table 1: The DIMACS-Europe graph was provided by PTV for the DIMACS challenge [17].", "startOffset": 131, "endOffset": 135}, {"referenceID": 37, "context": "The TheFrozenSea graph is based on the largest Star Craft map presented in [38].", "startOffset": 75, "endOffset": 79}, {"referenceID": 20, "context": "We analyze three different vertex orders: 1) The greedy metric-dependent order is an order in the spirit of [21].", "startOffset": 108, "endOffset": 112}, {"referenceID": 20, "context": "Table 3 compares the performance of our specialized Contraction Graph data structure, described in Section 5, to the dynamic adjacency structure, as used in [21] to compute undirected and unweighted CHs.", "startOffset": 157, "endOffset": 161}, {"referenceID": 41, "context": "We do not report numbers for the hash-based approach of [42] as it is fully dominated.", "startOffset": 56, "endOffset": 60}, {"referenceID": 20, "context": "The numbers show that the heuristic witness search employed by [21] is nearly optimal.", "startOffset": 63, "endOffset": 67}, {"referenceID": 9, "context": "See [10] for details.", "startOffset": 4, "endOffset": 8}, {"referenceID": 15, "context": "When amortized, we even achieve 415 ms which is only slightly above the nonamortized 347 ms reported in [16] for CRP.", "startOffset": 104, "endOffset": 108}, {"referenceID": 20, "context": "In [21] a sequential preprocessing time of 451 s was reported.", "startOffset": 3, "endOffset": 7}, {"referenceID": 1, "context": "Furthermore, [2] report a CH preprocessing time of 2 min when parallelized on 12 cores.", "startOffset": 13, "endOffset": 16}, {"referenceID": 1, "context": "While the machine used in [2] is slightly older and slower than our machine and the number of cores differs (12 vs.", "startOffset": 26, "endOffset": 29}, {"referenceID": 20, "context": "For example, in [21] the fastest CH preprocessing time reported for distance metric is 2,853 s.", "startOffset": 16, "endOffset": 20}, {"referenceID": 9, "context": "In each run we change the upward and the downward weight of a single random arc in G to random values in [0, 10].", "startOffset": 105, "endOffset": 112}, {"referenceID": 20, "context": "The \u201cMetDep+w\u201d variant use a metricdependent order and a non-perfect witness search in the spirit of [21].", "startOffset": 101, "endOffset": 105}, {"referenceID": 20, "context": "This is very surprising, especially considering, that the metric-dependent orders that we computed are better than those reported in [21], i.", "startOffset": 133, "endOffset": 137}, {"referenceID": 20, "context": "This contrasts with the CH of [21], whose performances varies significantly depending on the input metric.", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "For Contraction Hierarchies (CH), we report results based on implementations by [21, 13] and ourselves, covering different trade-offs in terms of preprocessing versus query speed.", "startOffset": 80, "endOffset": 88}, {"referenceID": 12, "context": "For Contraction Hierarchies (CH), we report results based on implementations by [21, 13] and ourselves, covering different trade-offs in terms of preprocessing versus query speed.", "startOffset": 80, "endOffset": 88}, {"referenceID": 12, "context": "For Customizable Route Planning (CRP), we report results from [13, 12].", "startOffset": 62, "endOffset": 70}, {"referenceID": 11, "context": "For Customizable Route Planning (CRP), we report results from [13, 12].", "startOffset": 62, "endOffset": 70}, {"referenceID": 20, "context": "Queries Turn- Time [s] Search Space Time [\u03bcs] Algorithm Implementation Machine Metric aware (# Threads) [# Vertices] (# Threads) CH [21] Opt 270 Time \u25e6 1 809 (1) 356 152 (1) CH [21] Opt 270 Dist \u25e6 5 723 (1) 1 582 1 940 (1) CH [21] E5-2670 Time \u25e6 1 075.", "startOffset": 132, "endOffset": 136}, {"referenceID": 20, "context": "Queries Turn- Time [s] Search Space Time [\u03bcs] Algorithm Implementation Machine Metric aware (# Threads) [# Vertices] (# Threads) CH [21] Opt 270 Time \u25e6 1 809 (1) 356 152 (1) CH [21] Opt 270 Dist \u25e6 5 723 (1) 1 582 1 940 (1) CH [21] E5-2670 Time \u25e6 1 075.", "startOffset": 177, "endOffset": 181}, {"referenceID": 20, "context": "Queries Turn- Time [s] Search Space Time [\u03bcs] Algorithm Implementation Machine Metric aware (# Threads) [# Vertices] (# Threads) CH [21] Opt 270 Time \u25e6 1 809 (1) 356 152 (1) CH [21] Opt 270 Dist \u25e6 5 723 (1) 1 582 1 940 (1) CH [21] E5-2670 Time \u25e6 1 075.", "startOffset": 226, "endOffset": 230}, {"referenceID": 20, "context": "88 (1) 353 91 (1) CH [21] E5-2670 Dist \u25e6 3 547.", "startOffset": 21, "endOffset": 25}, {"referenceID": 12, "context": "32 (1) 1422 540 (1) CH [13] X5680 Time \u25e6 109 (12) 280 110 (1) CH [13] X5680 Dist \u25e6 726 (12) 858 870 (1) CRP [13] X5680 Time \u2022 0.", "startOffset": 23, "endOffset": 27}, {"referenceID": 12, "context": "32 (1) 1422 540 (1) CH [13] X5680 Time \u25e6 109 (12) 280 110 (1) CH [13] X5680 Dist \u25e6 726 (12) 858 870 (1) CRP [13] X5680 Time \u2022 0.", "startOffset": 65, "endOffset": 69}, {"referenceID": 12, "context": "32 (1) 1422 540 (1) CH [13] X5680 Time \u25e6 109 (12) 280 110 (1) CH [13] X5680 Dist \u25e6 726 (12) 858 870 (1) CRP [13] X5680 Time \u2022 0.", "startOffset": 108, "endOffset": 112}, {"referenceID": 12, "context": "37 (12) 2 766 1 650 (1) CRP [13] X5680 Dist \u2022 0.", "startOffset": 28, "endOffset": 32}, {"referenceID": 11, "context": "37 (12) 2 942 1 910 (1) CRP [12] i7 920 Time \u25e6 4.", "startOffset": 28, "endOffset": 32}, {"referenceID": 11, "context": "7 (4) 3 828 720 (2) CRP [12] i7 920 Dist \u25e6 4.", "startOffset": 24, "endOffset": 28}, {"referenceID": 12, "context": "We further report average query search space, including stalled vertices for CH (which might not be included in the CH figures taken from [13]).", "startOffset": 138, "endOffset": 142}, {"referenceID": 20, "context": "Since the CH performance in [21] was evaluated on a ten year old machine (AMD Opteron 270), we obtained the source code and re-ran experiments on our hardware (Intel Xeon E5-2670) for better comparability.", "startOffset": 28, "endOffset": 32}, {"referenceID": 12, "context": "Also note that the latest CRP implementation by [13], evaluated on an Intel Xeon X5680, is turn-aware (\u2022), i.", "startOffset": 48, "endOffset": 52}, {"referenceID": 11, "context": ", it uses turn tables (set to zero in the reported experiments); We therefore additionally take results from [12] obtained on an Intel Core-i7 920, which uses a turn-unaware implementation but parallelizes queries.", "startOffset": 109, "endOffset": 113}, {"referenceID": 12, "context": "The CRP implementation of [13] uses SSE to achieve its customization time of 0.", "startOffset": 26, "endOffset": 30}, {"referenceID": 16, "context": "2 Further DIMACS-Instances During the DIMACS challenge on shortest path [17] several benchmark instances were made available.", "startOffset": 72, "endOffset": 76}, {"referenceID": 37, "context": "3 Further Game Instances Besides our main game benchmark instance TheFrozenSea, the benchmark data set of [38] contains a large variety of different game maps.", "startOffset": 106, "endOffset": 110}, {"referenceID": 33, "context": "Hence, our nested dissection implementation based on KaHIP [34] was not optimized for speed but rather to demonstrate that good separators exist.", "startOffset": 59, "endOffset": 63}, {"referenceID": 38, "context": "However, since we performed the experiments reported in this paper, significant improvements have been made in this domain: The works of [39] lay the 13http://www.", "startOffset": 137, "endOffset": 141}], "year": 2015, "abstractText": "We consider the problem of quickly computing shortest paths in weighted graphs. Often, this is achieved in two phases: 1) derive auxiliary data in an expensive preprocessing phase, 2) use this auxiliary data to speedup the query phase. By adding a fast weight-customization phase, we extend Contraction Hierarchies to support a three-phase workflow: The expensive preprocessing is split into a phase exploiting solely the unweighted topology of the graph, as well as a lightweight phase that adapts the auxiliary data to a specific weight. We achieve this by basing our Customizable Contraction Hierarchies on nested dissection orders. We provide an in-depth experimental analysis on large road and game maps that shows that Customizable Contraction Hierarchies are a very practicable solution in scenarios where edge weights often change.", "creator": "LaTeX with hyperref package"}}}