{"id": "1402.0557", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Optimal Rectangle Packing: An Absolute Placement Approach", "abstract": "We consider the problem of finding all enclosing rectangles of minimum area that can contain a given set of rectangles without overlap. Our rectangle packer chooses the x-coordinates of all the rectangles before any of the y-coordinates. We then transform the problem into a perfect-packing problem with no empty space by adding additional rectangles. To determine the y-coordinates, we branch on the different rectangles that can be placed in each empty position. Our packer allows us to extend the known solutions for a consecutive-square benchmark from 27 to 32 squares. We also introduce three new benchmarks, avoiding properties that make a benchmark easy, such as rectangles with shared dimensions. Our third benchmark consists of rectangles of increasingly high precision. To pack them efficiently, we limit the rectangles coordinates and the bounding box dimensions to the set of subset sums of the rectangles dimensions. Overall, our algorithms represent the current state-of-the-art for this problem, outperforming other algorithms by orders of magnitude, depending on the benchmark.", "histories": [["v1", "Tue, 4 Feb 2014 01:33:30 GMT  (431kb)", "http://arxiv.org/abs/1402.0557v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DS", "authors": ["eric huang", "richard e korf"], "accepted": false, "id": "1402.0557"}, "pdf": {"name": "1402.0557.pdf", "metadata": {"source": "CRF", "title": "Optimal Rectangle Packing: An Absolute Placement Approach", "authors": ["Eric Huang", "Richard E. Korf"], "emails": ["ehuang@parc.com", "korf@cs.ucla.edu"], "sections": [{"heading": "1. Introduction", "text": "Considering a number of rectangles, our problem is to find all the enclosing rectangles with minimum area that they contain without overlapping. We refer to an enclosing rectangle as a border box to avoid confusion. The optimization problem is NP-hard, while the problem of deciding whether a set of rectangles can be packaged in a particular border box is NP-complete by reducing the amount of waste packaging (Korf, 2003). The scale for the consecutive square is a simple set of increasingly difficult benchmarks for this problem, where the task is to find the border boxes with minimum area containing a set of squares measuring 1 x 1, 2 x 2 x 2,... up to N x N (Korf, 2003). Figure 1 is an optimal solution for N = 32. We will use this benchmark to explain many of the ideas in this paper, but our techniques are not limited to packing squares."}, {"heading": "1.1 Overview", "text": "The rest of this article is broken down as follows: In Section 2, we first present various benchmarks that specifically define the rectangular packaging cases that we will solve; in Section 3, we review the state-of-the-art rectangular packers and their techniques that form the basis on which we will present our new work; in Section 4, we follow the data collected and compare our work to the state of the art using previous benchmarks; we also compare the difficulty of previous benchmarks with our new ones; in Section 5, we present a benchmark of rectangles with successively higher precision, new solution techniques to deal with it, and follow up with experimental results; then, we compare our methods with the competing search spaces used to package high-precision rectangles, and show that our methods remain competitive. Sections 6 and 7 explain various possibilities for future work by summarizing all our contributions and results."}, {"heading": "2. Benchmarks", "text": "There are several reasons that motivate our benchmarks: First, our benchmarks describe cases with a single parameter N, which allows researchers to easily reproduce the cases; second, our benchmarks define an infinite number of cases where each successive instance is more difficult than the previous one. A solver is superior to another solver if he can solve the same instance faster or a larger instance in the same time span; in contrast, comparing with an instance library requires counting the number of instances completed within a specified period of time; and, in instance libraries, a solver is often superior to a substance, while a competing solver performs well on another subset, making such comparisons inconclusive."}, {"heading": "2.1 Previous Benchmarks", "text": "Several of the previous benchmarks used in the literature are N = 32, which are presented square in Figure 1, a simpler problem than the benchmarks we propose. Part of this is due to the fact that benchmarks, such as solvers, can also be improved with further research to ensure that they cover various properties of rectangles, in addition to providing an easy way to compare performance between different packers and measure progress. The Benchmark in a sequence square (Korf, 2003) is a simple set of increasingly difficult cases where the task is to find all boxes of the minimum area containing a set of squares ranging from 1 \u00d7 1, 2 \u00d7 2,... up to N \u00d7 2. Prior to our work, many of the most recent state-of-the-art packers are used to measure this popular benchmark, including those of Moffitt and Pollack (2006), Korf, Moffitt and Pollack (2010), Pollack (Pollack (2010), Pollack (O'Sullivan) and 2010 (and Sullivan)."}, {"heading": "2.2 Properties of Easy Benchmarks to Avoid", "text": "To motivate our new benchmarks, we will now explain why the previous benchmarks tended to be much simpler in comparison, and why we designed our new benchmarks to describe instances that consist of rectangles with unique dimensions, without duplicates, and without most of the range being occupied by just a few rectangles."}, {"heading": "2.2.1 Rectangles With Equal Dimensions", "text": "In the benchmark for unoriented successive rectangles, all rectangles share one dimension with another. For example, Figure 2a is an optimal solution for N = 12. For optimal solutions, rectangles of the same dimensions tend to line up side by side, form larger rectangles, and leave little empty space. In Figure 2a, the 8 x 9 and 7 x 8 line up next to each other, as do the 5 x 6 with the 4 x 5 and the 3 x 4 with the 2 x 3. In fact, the solutions for this benchmark all have a much smaller percentage of empty space than comparable examples from the benchmark for successive rectangles, where all rectangles have unique dimensions. We also note that double rectangle benchmarks, such as those in Figure 2b, are resolved quickly."}, {"heading": "2.2.2 Rectangles With Small Area and Small Dimensions", "text": "Figure 2b is also an example of perfect packaging because there is no empty space in the solution. Problems with perfect packaging tend to be simple for two reasons: First, if we test bouncing boxes in increasing order of area, we test fewer boxes because we never test a box with more than the required minimum area. Second, instead of deciding for each rectangle where to go in the bouncing box, a more efficient algorithm for each cell of empty space has to decide which rectangle it should occupy. However, once a small area of empty space arises that cannot accommodate any remaining rectangles, the algorithm can trace back. In both the successive square and disoriented rectangle benchmarks, some large rectangles capture much of the total area in an instance, so the packer does not search too deep before consuming the permissible empty space."}, {"heading": "2.3 New Benchmarks", "text": "We propose several new benchmarks that are more difficult when comparing instances with the same number of rectangles. In addition to the benchmarks described above, our experimental results use the following benchmarks for consecutive square and disoriented consecutive rectangles."}, {"heading": "2.3.1 Equal-Perimeter Rectangles", "text": "First, we present the oriented equal perimeter rectangle benchmark, where each instance is a set of rectangles of size 1 \u00b7 N, 2 \u00b7 (N \u2212 1),..., (N \u2212 1) \u00b7 2, N \u00b7 1, and rectangles must not be rotated (see Figure 3). Given N, all rectangles are unique and have a range of 2N + 2. In our experiments, this benchmark is much more difficult than either the consecutive square benchmark or the non-oriented consecutive rectangle benchmark (Korf et al., 2010) for the same number of rectangles. We cornered our state-of-the-art packers (Huang & Korf, 2010) on both old and new benchmarks. N = 22 of our oriented equal perimeter benchmark took us over nine hours to solve these."}, {"heading": "3. Solution Techniques", "text": "In this section, we will describe previous solution strategies as well as the various new techniques we use in our Rectangular Packer. First, we will describe our techniques as applicable to consecutive square benchmarks, oriented equilibrium benchmarks, and disoriented double-circumference benchmarks. Our work on disoriented high-precision rectangular benchmarks is not included here, as the methods differ significantly, and will be moved to Section 5."}, {"heading": "3.1 Previous Work", "text": "Some of the earlier work, which focused on optimal methods for packing a set of rectangles in a particular delimiting field, was motivated by the problem of pallet loading. Dowsland (1987) used depth search on an abstract graph of the search space to optimally solve the problem on problem sets modelled on the real world pallet and box dimensions. Although their problem cases averaged 30 rectangles and up to 50, their benchmarks were much simpler than the ones we are looking at here, as all rectangles are of the same size, and there was a significant amount of empty space in the solutions. Bhattacharya et al. (1998) extended the work with additional lower and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks.In investigating rectangle spacing where rectangles of different dimensions, Onodera et al are used."}, {"heading": "3.2 Our Overall Search Strategy", "text": "Like Korf et al.'s (2010) algorithm, we have a minimal bounding box solver that calls a containment problem solver, and like Simonis and O'Sullivan (2008), we assign x-coordinates before each of the y-coordinates. Although we use some of the ideas of Simonis and O'Sullivan (2008), we do not use a constraint programming approach in which all constraints are assigned to a general-purpose solver such as prolog. Instead, we implemented our program from the ground up in C + +, allowing us more flexibility in choosing which constraints to use at what time, and of course encoding the search space we use for the y coordinates. We implemented a chronological backtracking algorithm with a dynamic variable arrangement. Our algorithm operates in five stages, since it ranges from the root of the search tree to the scrolls: 1. The minimal bounding box algorithm generates an initial set of bounding and 2."}, {"heading": "3.3 Minimum Bounding Box Problem", "text": "One way to solve the minimum delimitation problem is to find the minimum and maximum distances between candidates and potentially optimal delimitation boxes. Boxes of all sizes are created with surfaces within this range and then tested in a non-decreasing order of surfaces until all solutions within the smallest range are found."}, {"heading": "3.3.1 Anytime Algorithm", "text": "In case of a problem with many rectangles, or if an immediate solution is required, Korf (2003) provides an algorithm available at all times for the delimiting box problem, which replaces the problem described above, also called containment problem solver. We first find a greedy solution on a delimiting box whose height corresponds to the highest rectangle, as described in the previous section. We then repeatedly call the containment problem solver in the following way: If the previous attempt for a particular delimiting box led to packaging, or if its area is larger than the area of the best solution seen so far, then we reduce the width by one unit and try to solve the resulting delimiting problem. Instead, if the previous attempt was unfeasible, we increase the delimiting box height by one unit. The algorithm ends when the width of the current delimiting box is smaller than the width of the widest rectangle."}, {"heading": "3.4 Containment Problem", "text": "On the other hand, if we assigned to Simonis and O'Sullivan's (2008) Packer the x-coordinates of all rectangles before any x-coordinate angle, as Clautiaux et al. (2007), as well as the use of cumulative constraint (Aggoun & Beldiceanu, 1993), the improvement of performance by orders of magnitude x x. The cumulative constraint adds the height of all x-coordinates that overlap, a given x-coordinate position if one of these values exceeds the height of the bouncing box. This constraint was checked while researching x-coordinates and also during exploring x-coordinates later. We improved in this way by modelling the y-coordinates differently, deleting positions as variables and values."}, {"heading": "3.5.1 Pruning Infeasible Subtrees", "text": "We present a limitation-based formulation of Korf's (2003) two-dimensional wasted space that was adapted to the one-dimensional case. In the face of a partial solution, Korf's algorithm calculated a lower limit for the amount of wasted space that was then used to trim the empty space against an upper limit. In contrast, we do not calculate numerical limits and instead detect the impracticability with a single constraint. As rectangles are placed in the delimitation field, the remaining empty space is crushed into small irregular areas. Finally, the empty space is divided into sufficiently small chunks so that they cannot accommodate any of the remaining unplaced rectangles at which point we trace. While we assign x-coordinates in a delimitation field of height H, we keep a histogram < v1, v2, vH >, where vi is the number of empty cells (units of empty space) standing in an empty field of height H."}, {"heading": "3.5.2 Pruning With Dominance Conditions", "text": "Korf (2003) introduced a set of dominance conditions to trim positions where large rectangles are too close to the sides of the delimitation box. For example, imagine that we have to package the squares 4 x 4, 3 x 3, 2 x 2 and 1 x 1. In Figure 5a, the placement of the 4 x 4 square leaves a gap of 2 x 4 on the left side of the delimitation box into which the 3 x 3 square cannot fit. So, only the 2 x 2 and 1 x 1 squares can fit within the gap, and in fact both can be placed completely within the gap. Note that in any solution with an arrangement such as Figure 5a, we can always rearrange them as in Figure 5b without disrupting other squares. So there is no need to try to place the 4 x 4 x 4 square at x = 2 as long as we have tried to place it at x = 0. Generally, a square placement is dominated if it can be put together with a gap that we can dynamically fit all of them together without splitting the rectangles."}, {"heading": "3.5.3 Variable Ordering", "text": "This year, it is more than ever before in the history of the city in which we find ourselves."}, {"heading": "3.6 Perfect Packing Transformation", "text": "A perfect packing instance is a rectangle packing problem with the property that the solution has no empty space. Transformation is done by adding a number of 1 x 1 rectangles to the original set of rectangles necessary to increase the total area of the rectangles to that of the delimiter box. Although the new 1 x 1 rectangles increase the problem size, it is hoped that the ease of solving perfect packing instances will offset the difficulty of packing more rectangles. Next, we will describe our search space for perfect packing. As we will show, our methods are based on the perfect packing property of having no empty space."}, {"heading": "3.7 Assigning Y-Coordinates", "text": "An alternative to the question \"Where should this rectangle go?\" is the question \"Which rectangle should go here?\" In the first model, rectangles are variables and empty positions are values, while in the second, empty positions are variables and rectangles are values. We look for Y coordinates in the second model. We use a 2D bitmap to test placed rectangles for overlap, and we trace positions that cannot accommodate remaining rectangles, or as Korf's (2003) rule for cropping wasted space requires."}, {"heading": "3.7.1 Empty Corner Model", "text": "In all perfect packaging solutions, the lower left corner of each rectangle fits into a lower left corner formed by other rectangles, the sides of the border box, or a combination of both. In this model, we have one variable per empty corner. Since each rectangle goes into exactly one empty corner, the number of empty corner variables is equal to the number of rectangles in the perfect packaging instance. In addition, the set of values is only the amount of unplaced rectangles. This search space has the interesting property that variables are created dynamically during the search, because the X and Y coordinates of an empty corner are not known until after the rectangles they are placed. In addition, placing a rectangle in an empty corner indicates both its x and y coordinates. Note that the empty corner model can describe all perfect packaging solutions."}, {"heading": "3.7.2 Duplicate Rectangles", "text": "Due to the additional 1 \u00d7 1 rectangles from the perfect pack transformation, we have added additional redundancy to the problem. An easy way to handle this is this: For a certain empty corner, we will never place a rectangle that is a duplicate of one we have already tried here. This method of handling duplicates also applies to duplicate rectangles in the original problem instance."}, {"heading": "4. Experimental Results", "text": "We have benchmarked our packers in Linux on a 2GHz AMD Opteron 246 with 2GB of RAM, the packer we call KMP10 (Korf et al., 2010) was benchmarked on the same machine, so we cite their published results. We do not include the data for their relative placement packer because it was not competitive. Results for Simonis and O'Sullivan's packer (2008), which we call SS08, are also quoted and come from SICStus Prolog 4.0.2 for Windows on a 3GHz Intel Xeon 5450 with 3.25GB of RAM. Since their machine is faster than our machine, these comparisons are a conservative estimate of our relative performance."}, {"heading": "4.1 Previous Benchmarks", "text": "Since both the consecutive quadratic benchmark and the disoriented consecutive rectangular benchmarks (Korf et al., 2010) have been used in the literature to measure performance, we include data collected on the basis of these two benchmarks."}, {"heading": "4.1.1 Consecutive Squares", "text": "Table 1 compares the CPU runtimes of four packers on the consecutive square benchmark. The first column specifies the instance size, which is both the number of squares and the size of the largest. The remaining columns specify the CPU times required by different algorithms to find all optimal solutions in the format of days, hours, minutes, and seconds. If there are several boxes with minimum range, as described in Table 8 of Appendix 4.4, we report on the total time it takes to find all optimal bounding boxes. We do this for two reasons: first, finding all minimum bounding boxes removes the question of which box should be tested first if more than one have the same range. Second, by offering all the optimal solutions that can use this information to verify the accuracy of your programs."}, {"heading": "4.1.2 Unoriented Consecutive Rectangles", "text": "Table 3 compares the CPU times of our packer on the disoriented consecutive rectangle benchmark with those of Korf et al. (2010). Although the techniques underlying Simonis and O'Sullivan (2008) exceed those of Korf et al. on the consecutive square benchmark, there were no previously published results for this benchmark other than those of Korf et al. (2008). Since this benchmark is simpler than the square benchmark, we do not split the contributions of our individual techniques on this benchmark because these differences were more clearly outlined in the previous section. The primary distinguishing feature of this benchmark is that rectangles are disorientation.The first column indicates the size of the problem instance. The second column indicates the performance of the previous state-of-the-art packer on this benchmark, with Korf et al.'s Code (2010) giving the primary distinguishing feature of this benchmark is that calculation-orientationless type gives the preceding column of the corner.The second column indicates the problem-size of the preceding column of the packet."}, {"heading": "4.2 Oriented Equal-Perimeter and Unoriented Double-Perimeter Rectangles", "text": "It is indeed the case that we are able to set out in search of new paths to follow in order to achieve our objectives."}, {"heading": "4.3 Comparing Easy and Hard Benchmarks", "text": "The following tables compare the difficulty of different benchmarks using our packer (Huang & Korf, 2010) with all possible optimizations."}, {"heading": "4.3.1 Consecutive Squares vs. Equal-Perimeter Rectangles", "text": "In Table 6, the first column indicates the number of rectangles in the instance; the second and third columns, called \"Boxes Tested,\" indicate the number of Bounding Boxes tested to find optimal solutions for the successive square benchmark or oriented equilibrium benchmark; the fourth and fifth columns also indicate the performance of our rectangular packers for both benchmarks; each data point in this table was collected using a Linux 2.93GHz Intel Core 2 Duo E7500 using a process, a thread and a core. Note that for a given instance with the same number of rectangles, the oriented equilibrium benchmark is significantly harder than the benchmark for consecutive squares; this is because the consecutive square benchmark for a given problem size contains many small squares that are typically easy to place - a property that is missing from the equilibrium benchmark."}, {"heading": "4.3.2 Unoriented Consecutive-Rectangles vs. Unoriented Double-Perimeter Rectangles", "text": "Table 7 shows how removing certain properties leads to increasingly difficult benchmarks. Let's start with the disorientated benchmark for consecutive rectangles (Korf et al., 2010), which contains many simple properties. In the \"Doubly Scaled\" column, we package 2 \u00b7 4, 4 \u00b7 6, 6 \u00b7 8,..., (2N) \u00b7 (2N + 2) rectangles that simply scale the disorientated benchmark for consecutive rectangles by a factor of two. This benchmark is more difficult because integers of larger size lead to more x-coordinates, which in turn increases the branching factor of the problem. In the \"Unique Dimensions\" column, we now package rectangles of size 1 \u00d7 2, 3 \u00d7 4, 5 \u00d7 6,..., (2N \u2212 1) \u00d7 (2N) \u00d7 (2N), which differs from the previous benchmark in that all dimensions are unique. In the last column, we distribute rectangles of size 1 \u00d7 2 \u00d7 2N, 2 \u00d7 2N, 2 \u00d7 2N, 2 \u00d7 2N, 3 \u00d7 2N, 2 \u00d7 2N, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 2 \u00d7, 1 \u00d7, 2 \u00d7 (N), 1 \u00d7 (2N)."}, {"heading": "4.4 Bounding Boxes of Minimum Area", "text": "In this section, we list all the optimal delimiter boxes for different benchmarks that our program has found when all optimizations are enabled. Note that we do not duplicate the data for the disoriented, high-precision benchmark and leave it in Table 10, Section 5.5.2, because the discussion there refers to that data. The first column in Tables 8 and 9 refers to the size of the problem instance for their respective benchmarks. The Optimal Solution columns indicate the dimensions of the optimal delimiter boxes for a given instance. The next column specifies the percent of empty space in the optimal solution. The next column specifies the number of delimiter boxes that have been tested to find all the optimal solutions for a given instance."}, {"heading": "5. Absolute Placement on High-Precision Instances", "text": "Meir and Moser (1968) first proposed the problem of finding the smallest square, which can contain an infinite series of rectangles of the sizes 11 \u00b7 1 2, 1 2 \u00b7 1 3, 1 3 \u00b7 1 4,... etc. The rectangles cannot overlap and are disorientation.The unit square has exactly enough area, since the total area of the rectangles is one in the infinite row. On the other hand, no space can be wasted, which indicates that the task is impossible. Inspired by this problem, we propose our latest benchmark and developed several new techniques. We introduce the disorientated high-precision rectangle benchmark, where the task is to find all the drill boxes of the minimum area, which is a finite set of disorientated rectangles of the sizes 11 \u00d7 1 2, 1 2 \u00d7 1 3,... up to 1 N \u00d7 1 N + 1."}, {"heading": "5.1 Previous Work", "text": "The relative placement approach of Moffitt and Pollack (2006) for rectangular packaging and similar types of search spaces used in resource-limited planning (Weglarz, 1999) promises to be immune to the problem of high-precision rectangular instances. However, because there are so many techniques we have described in the previous sections that cannot be extended to a packer working in the relative placement search space, we have decided to stay within the absolute placement framework and try to mitigate the problems caused by high-precision numbers."}, {"heading": "5.2 Overall Strategy", "text": "Considering an instance of our high-precision scale described in rational numbers, we multiply all values by the smallest common multiple of denominators to obtain an instance of integer dimensions, and then apply the techniques of the absolute placement solution, the improvements of which we will then explain in order to find the optimal solutions. Once we have found, we divide all the X and Y coordinates describing the optimal solutions by the initial scaling constant to obtain the optimal solutions to the original problem. Note that we can map any solution to one in which all rectangles are moved as far to the left and down as possible (Chazelle, 1983). For example, the solution in Figure 6a can be transformed into the one in Figure 6b. Since all rectangles are now supported from the bottom and left by other rectangles, the x-coordinate of each rectangle is the sum of a subset of the widths of the other rectangles, and we must then box the width."}, {"heading": "5.3 Minimum Bounding Box Problem", "text": "Since we create the original set of boundary boxes from all the pairwise combinations of widths and heights within certain ranges, the space is truncated by considering only boundary box widths and heights that correspond to the subtotals of the rectangle widths or the subtotals of the rectangle heights. Let's remember from Section 4.4 that for each boundary box width we calculate a lower boundary of the height. We change this further by rounding up the resulting boundary to the next subset of rectangle heights."}, {"heading": "5.3.1 Precomputing Subset Sums", "text": "We calculate the set of all subset sums prior to the search. For oriented rectangles that cannot be rotated, we calculate two sets: one based only on the height of the rectangles representing the Y coordinates of the candidate, and one based only on their width representing the x coordinates of the candidate. This distinction produces fewer subset sums compared to a single set of subset sums generated from both width and height."}, {"heading": "5.3.2 Pruning Combinations of Widths and Heights", "text": "This pruning technique is based on the observation that in certain cases there can only be a single set of rectangles that create a certain width (height) for the bounding box. Consider, for example, a bounding box width that can only be generated by a unique set of rectangles. Let's assume that the height of the same rectangular box also unambiguously determines the subset for a certain bounding box height. We say that this combination of bounding box width and height is incompatible, because this set of rectangles is the only way we can have a bounding box of the given width, and that this set of rectangles must appear in the solution that is arranged horizontally to each other."}, {"heading": "5.3.3 Learning From Infeasible Attempts", "text": "Remember that the algorithm for solving the minimal bounding box problem repeatedly calls the algorithm to solve the containment problem. Bounding boxes are tested in the order of the non-decreasing area until the first boxes with solutions are found. We can learn from the unworkable errors. Consider, for example, packing N rectangles {r1, r2,..., rN}. Note that we use a pre-calculated variable order for the rectangles. Let rd, d < N be the rectangle that corresponds to the deepest in the search tree that our depth search could go for a given bounding box throughout the entire search effort. If the container net solver says that this bounding box is unworkable, then the next bouning box height that we should consider may be the next largest subset that is based on the smaller set {r1, r2,... instead of all rectangles, rd}."}, {"heading": "5.4 Containment Problem", "text": "Similar to our low-precision methods, we first assign X coordinates to the rectangles, then perform a perfect pack transformation, and finally work on the Y coordinates (Huang & Korf, 2010).The main difference between our high-precision methods and our low-precision methods is that we do not consider all possible integers as the domain of the X and Y coordinates, but rather the smaller subsets of the widths and heights of the rectangles. Methods for using x intervals remain unchanged, so here we just describe how we search for individual x coordinates."}, {"heading": "5.4.1 Assigning X-Coordinates", "text": "For oriented rectangles, we select X coordinates from the set of subsets of rectangle widths. Instead of calculating the set in advance, as with the minimal boundary problem, we create it dynamically at each node during the search prior to branching to different x-coordinate value assignments. The set is calculated as follows: 1. Initialize the set with the value 0, as this represents the placement of a rectangle against the left side of the delimiter box.2. For each rectangle r that has already been assigned an x-coordinate at this point in the search, add the sum of its x-coordinate and its width to the set. This represents the placement of a rectangle against the right side of R.3. For each rectangle with its as yet unassigned x-coordinate, add its width to each element in our set and insert the new sums back into the set."}, {"heading": "5.4.2 Perfect Packing Transformation", "text": "The transformation results in a new instance with no space and consists of the original rectangles plus the new 1 \u00d7 1 rectangles as values. In our high-precision benchmark, we ask which of the original unplaced rectangles could fit there, or a 1 \u00d7 1 rectangle that essentially models empty corners as variables and rectangles as values. In our high-precision benchmark, the N = 15 solution requires the creation of over 1.5 billion 1 \u00d7 1 rectangles because we scale the problem by a very large number. Here, our packer simply requires too much memory and time. We avoid this problem by creating fewer and much larger rectangles to accommodate the empty space."}, {"heading": "5.4.3 Assigning Y-Coordinates", "text": "After the perfect pack transformation, we assign y-coordinates by asking which rectangle can be placed in a given empty corner. As before, we impose the condition that the y-coordinate of each rectangle must be a subset of the rectangle heights. Note that the rectangles created by the perfect pack transformation are not included in the subset sum calculations, as they represent empty space."}, {"heading": "5.4.4 Handling Unoriented Instances", "text": "For disoriented instances, we generate a single set of subset sums when calculating the initial box widths and heights, using both widths and heights from all rectangles of the instance, rather than keeping the widths separated from the heights. Likewise, when generating the set of candidate x and y coordinates, we must add a fourth step to the full list in subsection 5.4.1, where we add the height of each rectangle that has not yet been placed to each element in the set of subset sums, as this is the way to rotate the rectangle."}, {"heading": "5.5 Experimental Results", "text": "We present two different data tables, one to improve the problem of minimum boundary boxes measured by the number of boundary boxes tested, and another to the total time of the CPU for solving the entire rectangular packaging problem. We can separate our experiments in this way because our solution scheme decouples the problem of minimum boundary boxes from the containment problem."}, {"heading": "5.5.1 Minimum Bounding Box Problem", "text": "Table 10 shows the optimal solutions for our disoriented, high-precision rectangle benchmark along with the various properties of the corresponding instances; the first two columns indicate the problem size and dimensions of the optimal solutions; the third gives the least common multiple of the first N + 1 integers; the fourth is the number of bits required to represent the area of the minimum delimiter field; note that all but one of the optimal solutions have a width of 12, as the first rectangle is much larger than all the others; at N = 12 and larger, the required precision exceeds that of a 32-bit integer; the fifth to eighth column compares the number of delimiter fields that different packer test to find all the optimal solutions on our disoriented, high-precision rectangle benchmark mark; and for each column that goes from left to right, we add a new technique for the minimum delimiter field problem."}, {"heading": "5.5.2 Containment Problem", "text": "Table 11 compares the performance of different packers with our techniques. Since we have decoupled the minimum interface problem from the containment problem, we use all of our optimizations for the minimum interface problem in this table, comparing only the individual techniques applied to the containment problem. Therefore, the performance data specified is required to solve the overall problem using various containment problem packers. The first column indicates the size of the problem substance from our high-precision rectangular benchmark. As in previous tables, each successive column from left to right improves the previous column by an additional technique. The column named HK10 corresponds to the use of the previous state of the art with our improved minimal interface algorithm. The column named Empty Space improves HK10 by pre-calculating all subset sums prior to the search for the x coordinates, and uses our techniques to consolidate the empty space in the y coordinates. The Empty Space column with the subset name improves all the coordinates by putting the coordinates before the coordinate of the subset name."}, {"heading": "5.5.3 Comparison to Relative Placement", "text": "It is interesting to note that the number of bouncing boxes seems to be increasing exponentially, largely due to the exponential growth in the number of subsets added by each successive rectangle in our high-precision benchmark. The difficulty of our disoriented rectangle benchmark is compounded by the fact that the branching factor for the individual X and Y coordinate values is also increasing in the containment problem. Unlike our absolute placement techniques of Moffitt and Pollack (2006), the different exact positions for the rectangles are not enumerated, and thus they promise to be immune to the problem of high-precision rectangles. They have used a variable for each pair of rectangles to represent the relationships at the top, bottom, left, and right, and their search algorithm then requires at least one of these non-overlapping boundaries to be true."}, {"heading": "5.6 Summary of High-Precision Rectangles", "text": "In this section, we proposed a new benchmark consisting of instances of high-precision rectangles, methods to use subtotals to limit the number of positions that must be taken into account, rules to filter these subtotals for both minimal limitation and containment problems, methods to learn from unworkable subtrees, and ways to reduce the number of rectangles generated during perfect packaging transformation. These techniques do not exploit any particular characteristics of the benchmark, but are most useful for rectangles with high-precision dimensions. With all our methods, we solved six more problems up to N = 15 on our new benchmark compared to using our precision packer on a scaled instance. Our packer is more than two orders of magnitude faster than the previous one, testing 4,500 times less bounding boxes. A cursory comparison between the state of the art using the relative placement search space and our own packer shows that we are working on something faster than the prior state of the art, and that we are working on the orientation of the previous one."}, {"heading": "6. Future Work", "text": "People solve puzzles both by asking where a particular piece should go and by asking which piece should go to an empty region. Our packer uses both models, the first for the x-coordinates and the second for the y-coordinates. It would be interesting to see how applicable this dual formulation is to other packaging, layout and scheduling problems. Currently, we are working on the x-coordinates by asking, \"Where is this going?,\" and we are working on the y-coordinates by asking, \"What is going on at this point?\" Our method has reduced the time spent in the y-coordinates so much that the time spent on the x-coordinates is orders of magnitude greater than the time spent working on the y-coordinates. This suggests that performance could be improved by looking at both models at the same time."}, {"heading": "7. Conclusions", "text": "It is one of the largest nodes in the history of the EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-EWS-E"}, {"heading": "7.1 Comparison to Constraint Programming Methodologies", "text": "There are clearly trade-offs between our two programmers in C + + and a constraint programming approach. While the latter offers fast prototyping and reuse of constraint libraries already implemented by other researchers, it also forces the problem to be expressed in the abstract constraint language. Such an abstract layer turns out to be unnecessary for the algorithms and data structures that are, of course, used to solve our problem of optimal rectangle packaging. As we have described before, we simply add a constant in an integer array when we assign an X coordinate to a rectangle."}, {"heading": "8. Broader Lessons", "text": "Beyond the specific problem of rectangular packaging, there are lessons to be learned from this work. We believe that one of the most important applications of rectangular packaging is planning. As described in the introduction, the rectangular packaging problem is an abstraction of the entire problem, where different amounts of resources are available, and all require that they be stretched out, such as the memory in a computer. The width of the sheet box becomes the total time, the amount of resources available, and each job becomes a rectangle of equal duration."}, {"heading": "Acknowledgments", "text": "We would like to thank Reza Ahmadi, Adnan Darwiche and Adam Meyerson for their advice on this work and Michael Moffitt for providing his Packer. This research was partly funded by the National Science Foundation under grant number IIS0713178. The source code of our optimal rectangular packer is open source and available at http: / / code.google.com / p / rectpack."}], "references": [{"title": "Extending chip in order to solve complex scheduling and placement problems", "author": ["A. Aggoun", "N. Beldiceanu"], "venue": "Mathematical and Computer Modelling,", "citeRegEx": "Aggoun and Beldiceanu,? \\Q1993\\E", "shortCiteRegEx": "Aggoun and Beldiceanu", "year": 1993}, {"title": "Sweep as a generic pruning technique applied to the non-overlapping rectangles constraint", "author": ["N. Beldiceanu", "M. Carlsson"], "venue": "In CP \u201901: Proceedings of the 7th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Beldiceanu and Carlsson,? \\Q2001\\E", "shortCiteRegEx": "Beldiceanu and Carlsson", "year": 2001}, {"title": "New filtering for the cumulative constraint in the context of non-overlapping rectangles", "author": ["N. Beldiceanu", "M. Carlsson", "E. Poder"], "venue": "CPAIOR, Vol. 5015 of Lecture Notes in Computer Science,", "citeRegEx": "Beldiceanu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Beldiceanu et al\\.", "year": 2008}, {"title": "A generic geometrical constraint kernel in space and time for handling polymorphic k-dimensional objects", "author": ["N. Beldiceanu", "M. Carlsson", "E. Poder", "R. Sadek", "C. Truchet"], "venue": "CP, Vol. 4741 of Lecture Notes in Computer Science,", "citeRegEx": "Beldiceanu et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Beldiceanu et al\\.", "year": 2007}, {"title": "An exact depth-first algorithm for the pallet loading problem", "author": ["S. Bhattacharya", "R. Roy"], "venue": "European Journal of Operational Research,", "citeRegEx": "Bhattacharya et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Bhattacharya et al\\.", "year": 1998}, {"title": "Practical slicing and non-slicing block-packing without simulated annealing", "author": ["H.H. Chan", "I.L. Markov"], "venue": "In GLSVLSI \u201904: Proceedings of the 14th ACM Great Lakes symposium on VLSI,", "citeRegEx": "Chan and Markov,? \\Q2004\\E", "shortCiteRegEx": "Chan and Markov", "year": 2004}, {"title": "The bottomn-left bin-packing heuristic: An efficient implementation", "author": ["B. Chazelle"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "Chazelle,? \\Q1983\\E", "shortCiteRegEx": "Chazelle", "year": 1983}, {"title": "A new exact method for the twodimensional orthogonal packing problem", "author": ["F. Clautiaux", "J. Carlier", "A. Moukrim"], "venue": "European Journal of Operational Research,", "citeRegEx": "Clautiaux et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Clautiaux et al\\.", "year": 2007}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "Dechter et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Dechter et al\\.", "year": 1991}, {"title": "An exact algorithm for the pallet loading problem", "author": ["K.A. Dowsland"], "venue": "European Journal of Operational Research,", "citeRegEx": "Dowsland,? \\Q1987\\E", "shortCiteRegEx": "Dowsland", "year": 1987}, {"title": "New improvements in optimal rectangle packing", "author": ["E. Huang", "R.E. Korf"], "venue": null, "citeRegEx": "Huang and Korf,? \\Q2009\\E", "shortCiteRegEx": "Huang and Korf", "year": 2009}, {"title": "Optimal rectangle packing on non-square benchmarks", "author": ["E. Huang", "R.E. Korf"], "venue": "Proceedings of the 24th National Conference on Artificial intelligence,", "citeRegEx": "Huang and Korf,? \\Q2010\\E", "shortCiteRegEx": "Huang and Korf", "year": 2010}, {"title": "Optimal packing of high-precision rectangles", "author": ["E. Huang", "R.E. Korf"], "venue": null, "citeRegEx": "Huang and Korf,? \\Q2011\\E", "shortCiteRegEx": "Huang and Korf", "year": 2011}, {"title": "Optimal rectangle packing: Initial results", "author": ["R.E. Korf"], "venue": null, "citeRegEx": "Korf,? \\Q2003\\E", "shortCiteRegEx": "Korf", "year": 2003}, {"title": "Optimal rectangle packing: New results", "author": ["R.E. Korf"], "venue": null, "citeRegEx": "Korf,? \\Q2004\\E", "shortCiteRegEx": "Korf", "year": 2004}, {"title": "Optimal rectangle packing", "author": ["R.E. Korf", "M.D. Moffitt", "M.E. Pollack"], "venue": "Annals of Operations Research,", "citeRegEx": "Korf et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Korf et al\\.", "year": 2010}, {"title": "Scheduling: the notions of hump, compulsory parts and their use in cumulative problems", "author": ["A. Lahrichi"], "venue": "Comptes Rendus de Academie des Sciences,", "citeRegEx": "Lahrichi,? \\Q1982\\E", "shortCiteRegEx": "Lahrichi", "year": 1982}, {"title": "Exhaustive approaches to 2d rectangular perfect packings", "author": ["N. Lesh", "J. Marks", "A. McMahon", "M. Mitzenmacher"], "venue": "Information Processing Letters,", "citeRegEx": "Lesh et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Lesh et al\\.", "year": 2004}, {"title": "New approximation algorithms for some dynamic storage allocation problems", "author": ["S.C. Li", "H.W. Leong", "S.K. Quek"], "venue": "COCOON, Vol. 3106 of Lecture Notes in Computer Science,", "citeRegEx": "Li et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Li et al\\.", "year": 2004}, {"title": "A geometrical approach to computation of the optimal solution of the rectangle packing problem", "author": ["A.I. Lipovetskii"], "venue": "American Mathematical Society Translations,", "citeRegEx": "Lipovetskii,? \\Q2008\\E", "shortCiteRegEx": "Lipovetskii", "year": 2008}, {"title": "Two-dimensional packing problems: A survey", "author": ["A. Lodi", "S. Martello", "M. Monaci"], "venue": "European Journal of Operational Research,", "citeRegEx": "Lodi et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Lodi et al\\.", "year": 2002}, {"title": "Recent advances on two-dimensional bin packing problems", "author": ["A. Lodi", "S. Martello", "D. Vigo"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "Lodi et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Lodi et al\\.", "year": 2002}, {"title": "Exact solution of the two-dimensional finite bin packing problem", "author": ["S. Martello", "D. Vigo"], "venue": "Management Science,", "citeRegEx": "Martello and Vigo,? \\Q1998\\E", "shortCiteRegEx": "Martello and Vigo", "year": 1998}, {"title": "On packing of squares and cubes", "author": ["A. Meir", "L. Moser"], "venue": "Journal of Combinatorial Theory,", "citeRegEx": "Meir and Moser,? \\Q1968\\E", "shortCiteRegEx": "Meir and Moser", "year": 1968}, {"title": "Cognitive radio: making software radios more personal", "author": ["J. Mitola", "G. Maguire"], "venue": "IEEE Personal Communications Magazine,", "citeRegEx": "Mitola and Maguire,? \\Q1999\\E", "shortCiteRegEx": "Mitola and Maguire", "year": 1999}, {"title": "Optimal rectangle packing: A meta-csp approach", "author": ["M.D. Moffitt", "M.E. Pollack"], "venue": null, "citeRegEx": "Moffitt and Pollack,? \\Q2006\\E", "shortCiteRegEx": "Moffitt and Pollack", "year": 2006}, {"title": "Branch-and-bound placement for building block layout", "author": ["H. Onodera", "Y. Taniguchi", "K. Tamaru"], "venue": "In DAC \u201991: Proceedings of the 28th ACM/IEEE Design Automation Conference,", "citeRegEx": "Onodera et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Onodera et al\\.", "year": 1991}, {"title": "Search strategies for rectangle packing", "author": ["H. Simonis", "B. O\u2019Sullivan"], "venue": "CP, Vol. 5202 of Lecture Notes in Computer Science,", "citeRegEx": "Simonis and O.Sullivan,? \\Q2008\\E", "shortCiteRegEx": "Simonis and O.Sullivan", "year": 2008}, {"title": "Almost square packing", "author": ["H. Simonis", "B. O\u2019Sullivan"], "venue": "CPAIOR, Vol. 6697 of Lecture Notes in Computer Science,", "citeRegEx": "Simonis and O.Sullivan,? \\Q2011\\E", "shortCiteRegEx": "Simonis and O.Sullivan", "year": 2011}, {"title": "Cutting and packing problems: A categorized, application-orientated research bibliography", "author": ["P.E. Sweeney", "E.R. Paternoster"], "venue": "The Journal of the Operational Research Society,", "citeRegEx": "Sweeney and Paternoster,? \\Q1992\\E", "shortCiteRegEx": "Sweeney and Paternoster", "year": 1992}, {"title": "Project scheduling: recent models, algorithms and applications", "author": ["J. Weglarz"], "venue": null, "citeRegEx": "Weglarz,? \\Q1999\\E", "shortCiteRegEx": "Weglarz", "year": 1999}, {"title": "Constraint processing by rina dechter, morgan kaufmann publishers, 2003, hard cover", "author": ["R.H.C. Yap"], "venue": "Isbn 1-55860-890-7,", "citeRegEx": "Yap,? \\Q2004\\E", "shortCiteRegEx": "Yap", "year": 2004}], "referenceMentions": [{"referenceID": 13, "context": "The optimization problem is NP-hard, while the problem of deciding whether a set of rectangles can be packed in a given bounding box is NP-complete, via a reduction from bin-packing (Korf, 2003).", "startOffset": 182, "endOffset": 194}, {"referenceID": 13, "context": ", up to N \u00d7 N (Korf, 2003).", "startOffset": 14, "endOffset": 26}, {"referenceID": 7, "context": "Although Clautiaux et al. (2007) and others have used random instances, the non-random benchmarks used by Korf (2003) and Simonis and O\u2019Sullivan (2008) have better facilitated the comparison of state-of-the-art packers.", "startOffset": 9, "endOffset": 33}, {"referenceID": 7, "context": "Although Clautiaux et al. (2007) and others have used random instances, the non-random benchmarks used by Korf (2003) and Simonis and O\u2019Sullivan (2008) have better facilitated the comparison of state-of-the-art packers.", "startOffset": 9, "endOffset": 118}, {"referenceID": 7, "context": "Although Clautiaux et al. (2007) and others have used random instances, the non-random benchmarks used by Korf (2003) and Simonis and O\u2019Sullivan (2008) have better facilitated the comparison of state-of-the-art packers.", "startOffset": 9, "endOffset": 152}, {"referenceID": 13, "context": "The consecutive-square benchmark (Korf, 2003), is a simple set of increasingly difficult instances, where the task is to find all bounding boxes of minimum area that contain a set of squares of sizes 1\u00d71, 2\u00d72, .", "startOffset": 33, "endOffset": 45}, {"referenceID": 13, "context": "The consecutive-square benchmark (Korf, 2003), is a simple set of increasingly difficult instances, where the task is to find all bounding boxes of minimum area that contain a set of squares of sizes 1\u00d71, 2\u00d72, ..., up to N \u00d7N . Prior to our work, many of the recent stateof-the-art packers used this popular benchmark to measure performance, including that of Moffitt and Pollack (2006), Korf, Moffitt, and Pollack (2010), and Simonis and O\u2019Sullivan (2008).", "startOffset": 34, "endOffset": 387}, {"referenceID": 13, "context": "The consecutive-square benchmark (Korf, 2003), is a simple set of increasingly difficult instances, where the task is to find all bounding boxes of minimum area that contain a set of squares of sizes 1\u00d71, 2\u00d72, ..., up to N \u00d7N . Prior to our work, many of the recent stateof-the-art packers used this popular benchmark to measure performance, including that of Moffitt and Pollack (2006), Korf, Moffitt, and Pollack (2010), and Simonis and O\u2019Sullivan (2008).", "startOffset": 34, "endOffset": 422}, {"referenceID": 13, "context": "The consecutive-square benchmark (Korf, 2003), is a simple set of increasingly difficult instances, where the task is to find all bounding boxes of minimum area that contain a set of squares of sizes 1\u00d71, 2\u00d72, ..., up to N \u00d7N . Prior to our work, many of the recent stateof-the-art packers used this popular benchmark to measure performance, including that of Moffitt and Pollack (2006), Korf, Moffitt, and Pollack (2010), and Simonis and O\u2019Sullivan (2008). To date, the largest instance solved for this problem is N=32, shown in Figure 1, using our packer (Huang & Korf, 2009).", "startOffset": 34, "endOffset": 457}, {"referenceID": 15, "context": "In the unoriented consecutive-rectangle benchmark (Korf et al., 2010), an instance is a set of rectangles of sizes 1 \u00d7 2, 2 \u00d7 3, .", "startOffset": 50, "endOffset": 69}, {"referenceID": 27, "context": "Finding only the first optimal solution is another benchmark Simonis and O\u2019Sullivan (2011) have used in conjunction with problem instances from the unoriented consecutiverectangle benchmark.", "startOffset": 61, "endOffset": 91}, {"referenceID": 27, "context": "For example, Simonis and O\u2019Sullivan (2011) report that to find the first solution to N=26 takes 3:28:20 (3 hours, 28 minutes, and 20 seconds).", "startOffset": 13, "endOffset": 43}, {"referenceID": 15, "context": "In our experiments, this benchmark is much more difficult than either the consecutive-square benchmark or the unoriented consecutive-rectangle benchmark (Korf et al., 2010) for the same number of rectangles.", "startOffset": 153, "endOffset": 172}, {"referenceID": 5, "context": "Dowsland (1987) used depth-first search on an abstract graph representation of the search space to solve the problem optimally on problem sets modeled after real-world pallet and box dimensions.", "startOffset": 0, "endOffset": 16}, {"referenceID": 4, "context": "Bhattacharya et al. (1998) extended the work with additional lower bounds and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks.", "startOffset": 0, "endOffset": 27}, {"referenceID": 4, "context": "Bhattacharya et al. (1998) extended the work with additional lower bounds and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks. In examining rectangle packing instances where rectangles are of different dimensions, Onodera et al. (1991) used depth-first search, in which each branching point in their search space was a commitment to a particular non-overlap constraint between two rectangles.", "startOffset": 0, "endOffset": 288}, {"referenceID": 4, "context": "Bhattacharya et al. (1998) extended the work with additional lower bounds and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks. In examining rectangle packing instances where rectangles are of different dimensions, Onodera et al. (1991) used depth-first search, in which each branching point in their search space was a commitment to a particular non-overlap constraint between two rectangles. Lower bound and graph reduction techniques were applied to prune the search space, allowing them to optimally solve problems with up to six rectangles. Chan and Markov\u2019s BloBB (2004) packer used branch-and-bound in order to find the minimum area bounding box that can contain a set of rectangles.", "startOffset": 0, "endOffset": 628}, {"referenceID": 4, "context": "Bhattacharya et al. (1998) extended the work with additional lower bounds and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks. In examining rectangle packing instances where rectangles are of different dimensions, Onodera et al. (1991) used depth-first search, in which each branching point in their search space was a commitment to a particular non-overlap constraint between two rectangles. Lower bound and graph reduction techniques were applied to prune the search space, allowing them to optimally solve problems with up to six rectangles. Chan and Markov\u2019s BloBB (2004) packer used branch-and-bound in order to find the minimum area bounding box that can contain a set of rectangles. Their solver could handle up to eleven rectangles, and they observed that instances with duplicate rectangles were much easier, causing their packer to cluster such rectangles together in an optimal solution. Lesh et al.\u2019s solver (2004) used depth-first search, placing each rectangle first in the bottommost and left-most position in which it fit (the bottom-left heuristic, see Chazelle, 1983), to determine whether or not a set of rectangles can be packed in a given enclosing rectangle.", "startOffset": 0, "endOffset": 979}, {"referenceID": 4, "context": "Bhattacharya et al. (1998) extended the work with additional lower bounds and pruning techniques based on dominance conditions and demonstrated their work on the same benchmarks. In examining rectangle packing instances where rectangles are of different dimensions, Onodera et al. (1991) used depth-first search, in which each branching point in their search space was a commitment to a particular non-overlap constraint between two rectangles. Lower bound and graph reduction techniques were applied to prune the search space, allowing them to optimally solve problems with up to six rectangles. Chan and Markov\u2019s BloBB (2004) packer used branch-and-bound in order to find the minimum area bounding box that can contain a set of rectangles. Their solver could handle up to eleven rectangles, and they observed that instances with duplicate rectangles were much easier, causing their packer to cluster such rectangles together in an optimal solution. Lesh et al.\u2019s solver (2004) used depth-first search, placing each rectangle first in the bottommost and left-most position in which it fit (the bottom-left heuristic, see Chazelle, 1983), to determine whether or not a set of rectangles can be packed in a given enclosing rectangle. They were able to handle about twenty-nine rectangles in ten minutes on average, but their testbed consisted only of instances whose optimal solutions had no empty space. Clautiaux et al. (2007) presented a branch-and-bound method in which all the x-coordinates for the rectangles were computed prior to any of the y-coordinates.", "startOffset": 0, "endOffset": 1428}, {"referenceID": 18, "context": "1983), using optimized data structures from Martello and Vigo (1998). Beldiceanu and Carlsson (2001) applied the plane sweep algorithm used in computational geometry to detect violations of the non-overlap constraints, and later adapted the technique to a geometric constraint kernel (Beldiceanu, Carlsson, Poder, Sadek, & Truchet, 2007).", "startOffset": 44, "endOffset": 69}, {"referenceID": 1, "context": "Beldiceanu and Carlsson (2001) applied the plane sweep algorithm used in computational geometry to detect violations of the non-overlap constraints, and later adapted the technique to a geometric constraint kernel (Beldiceanu, Carlsson, Poder, Sadek, & Truchet, 2007).", "startOffset": 0, "endOffset": 31}, {"referenceID": 1, "context": "Beldiceanu and Carlsson (2001) applied the plane sweep algorithm used in computational geometry to detect violations of the non-overlap constraints, and later adapted the technique to a geometric constraint kernel (Beldiceanu, Carlsson, Poder, Sadek, & Truchet, 2007). Lipovetskii (2008) proposed a branch-and-bound algorithm that placed rectangles in the lower-left hand positions.", "startOffset": 0, "endOffset": 288}, {"referenceID": 1, "context": "Beldiceanu and Carlsson (2001) applied the plane sweep algorithm used in computational geometry to detect violations of the non-overlap constraints, and later adapted the technique to a geometric constraint kernel (Beldiceanu, Carlsson, Poder, Sadek, & Truchet, 2007). Lipovetskii (2008) proposed a branch-and-bound algorithm that placed rectangles in the lower-left hand positions. The prior state-of-the-art, due to Korf (2003, 2004) and Simonis and O\u2019Sullivan (2008), both divide the rectangle packing problem into the containment problem and the minimal bounding box problem.", "startOffset": 0, "endOffset": 470}, {"referenceID": 13, "context": "Like Korf et al.\u2019s (2010) algorithm, we have a minimum bounding box solver which calls a containment problem solver, and like Simonis and O\u2019Sullivan (2008), we assign x-coordinates prior to any of the y-coordinates.", "startOffset": 5, "endOffset": 26}, {"referenceID": 13, "context": "Like Korf et al.\u2019s (2010) algorithm, we have a minimum bounding box solver which calls a containment problem solver, and like Simonis and O\u2019Sullivan (2008), we assign x-coordinates prior to any of the y-coordinates.", "startOffset": 5, "endOffset": 156}, {"referenceID": 13, "context": "Like Korf et al.\u2019s (2010) algorithm, we have a minimum bounding box solver which calls a containment problem solver, and like Simonis and O\u2019Sullivan (2008), we assign x-coordinates prior to any of the y-coordinates. Although we use some of Simonis and O\u2019Sullivan\u2019s (2008) ideas, we do not take a constraint programming approach in which all constraints are specified to a general-purpose solver like Prolog.", "startOffset": 5, "endOffset": 272}, {"referenceID": 13, "context": "In a problem instance with many rectangles, or when an immediate solution is required, Korf (2003) provides an anytime algorithm for the bounding box problem, replacing the one described above, which also calls the containment problem solver.", "startOffset": 87, "endOffset": 99}, {"referenceID": 7, "context": "By contrast, Simonis and O\u2019Sullivan\u2019s (2008) packer assigned the x-coordinates of all the rectangles before any of the y-coordinates, as suggested by Clautiaux et al. (2007), as well as using the cumulative constraint (Aggoun & Beldiceanu, 1993), improving performance by orders of magnitude.", "startOffset": 150, "endOffset": 174}, {"referenceID": 31, "context": "Simonis and O\u2019Sullivan (2008) furthermore applied the least-commitment principle (Yap, 2004) from constraint processing, by first committing the placement of rectangles to an interval of x-coordinates instead of just a single x-coordinate value.", "startOffset": 81, "endOffset": 92}, {"referenceID": 16, "context": "This compulsory part (Lahrichi, 1982) constrains the cumulative height of the rectangles that may overlap x-coordinates 2 and 3 in the solution.", "startOffset": 21, "endOffset": 37}, {"referenceID": 2, "context": "Finally, the height of the bounding box constrains the cumulative heights of all rectangles for any given x-coordinate, similar to the ideas of Beldiceanu et al. (2008). Larger intervals result in weaker constraint propagation (less pruning) but a smaller branching factor, while smaller intervals result in stronger constraint propagation but a larger branching factor.", "startOffset": 144, "endOffset": 169}, {"referenceID": 2, "context": "Finally, the height of the bounding box constrains the cumulative heights of all rectangles for any given x-coordinate, similar to the ideas of Beldiceanu et al. (2008). Larger intervals result in weaker constraint propagation (less pruning) but a smaller branching factor, while smaller intervals result in stronger constraint propagation but a larger branching factor. The size of the intervals are experimentally determined. For example, a 4 \u00d7 2 rectangle with x-coordinates restricted to the interval [0,2] contributes a height of 2 at x-coordinates 2 and 3 even prior to deciding its exact x-coordinate value. This compulsory part (Lahrichi, 1982) constrains the cumulative height of the rectangles that may overlap x-coordinates 2 and 3 in the solution. If these interval assignments were all infeasible, then searching for individual x-values is futile. However, if we do find a set of interval assignments, then we still have to search for a set of single x-coordinate values. Simonis and O\u2019Sullivan (2008) assigned x-intervals, single x-coordinates, y-intervals, and single y-coordinates, in that order.", "startOffset": 144, "endOffset": 1015}, {"referenceID": 13, "context": "For the x-coordinates, we propose a pruning constraint adapted from Korf\u2019s (2003) wastedspace pruning heuristic, a dynamic variable order to replace Beldiceanu\u2019s (2008) fixed ordering, and a method to optimize the values assigned to our x-interval variables.", "startOffset": 68, "endOffset": 82}, {"referenceID": 13, "context": "For the x-coordinates, we propose a pruning constraint adapted from Korf\u2019s (2003) wastedspace pruning heuristic, a dynamic variable order to replace Beldiceanu\u2019s (2008) fixed ordering, and a method to optimize the values assigned to our x-interval variables.", "startOffset": 68, "endOffset": 169}, {"referenceID": 13, "context": "We present a constraint-based formulation of Korf\u2019s (2003) two-dimensional wasted space pruning algorithm, adapted to the one-dimensional case.", "startOffset": 45, "endOffset": 59}, {"referenceID": 13, "context": "to test for overlap, and we backtrack on positions that cannot accommodate any remaining rectangles, or as required by Korf\u2019s (2003) wasted space pruning rule.", "startOffset": 119, "endOffset": 133}, {"referenceID": 15, "context": "The packer we call KMP10 (Korf et al., 2010) was benchmarked on the same machine, so we quote their published results.", "startOffset": 25, "endOffset": 44}, {"referenceID": 13, "context": "The packer we call KMP10 (Korf et al., 2010) was benchmarked on the same machine, so we quote their published results. We do not include data for their relative placement packer because it was not competitive. Results for Simonis and O\u2019Sullivan\u2019s packer (2008), which we call SS08, are also quoted, obtained from SICStus Prolog 4.", "startOffset": 26, "endOffset": 261}, {"referenceID": 15, "context": "Because both the consecutive-square benchmark and the unoriented consecutive-rectangle benchmarks (Korf et al., 2010) have been used in the literature to measure performance, we include data collected using these two benchmarks.", "startOffset": 98, "endOffset": 117}, {"referenceID": 13, "context": "We have named this packer to be consistent with our previous work (Huang & Korf, 2009). SS08 refers to the previous state-of-the-art packer (Simonis & O\u2019Sullivan, 2008). The largest problem previously solved was N=27 and took SS08 over 11 hours. We solved the same problem in 35 minutes and solved five more open problems up to N=32. KMP10 refers to Korf et al.\u2019s (2010) absolute placement packer.", "startOffset": 75, "endOffset": 371}, {"referenceID": 13, "context": "Table 3 compares the CPU times of our packer on the unoriented consecutive-rectangles benchmark with that of Korf et al. (2010). Although the techniques due to Simonis and O\u2019Sullivan (2008) outperform those of Korf et al.", "startOffset": 109, "endOffset": 128}, {"referenceID": 13, "context": "Table 3 compares the CPU times of our packer on the unoriented consecutive-rectangles benchmark with that of Korf et al. (2010). Although the techniques due to Simonis and O\u2019Sullivan (2008) outperform those of Korf et al.", "startOffset": 109, "endOffset": 190}, {"referenceID": 13, "context": "The second column gives the performance of the previous state-of-the-art packer on this benchmark, using Korf et al.\u2019s code (2010). The third column gives the performance of our packer on this benchmark.", "startOffset": 105, "endOffset": 131}, {"referenceID": 15, "context": "We start with the unoriented consecutive-rectangle benchmark (Korf et al., 2010) which contains many easy properties.", "startOffset": 61, "endOffset": 80}, {"referenceID": 30, "context": "The relative placement approach of Moffitt and Pollack (2006) for rectangle packing, and similar types of search spaces used in resource-constrained scheduling (Weglarz, 1999), promises to be immune to the problem of high-precision rectangle instances.", "startOffset": 160, "endOffset": 175}, {"referenceID": 25, "context": "The relative placement approach of Moffitt and Pollack (2006) for rectangle packing, and similar types of search spaces used in resource-constrained scheduling (Weglarz, 1999), promises to be immune to the problem of high-precision rectangle instances.", "startOffset": 35, "endOffset": 62}, {"referenceID": 6, "context": "Note that we can map every solution to one where all rectangles are slid over to the left and to the bottom as much as possible (Chazelle, 1983).", "startOffset": 128, "endOffset": 144}, {"referenceID": 15, "context": "Their meta-CSP approach was modeled after work by Dechter, Meiri, and Pearl (1991) on solving binary constraint satisfaction problems, and included various pruning techniques such as model reduction, symmetry breaking, and graph-based pruning heuristics (Korf et al., 2010).", "startOffset": 254, "endOffset": 273}, {"referenceID": 22, "context": "In contrast to our absolute placement technique, Moffitt and Pollack\u2019s (2006) relative placement techniques do not enumerate the different exact locations for the rectangles, and therefore promise to be immune to the problem of high-precision rectangles.", "startOffset": 49, "endOffset": 78}, {"referenceID": 22, "context": "In contrast to our absolute placement technique, Moffitt and Pollack\u2019s (2006) relative placement techniques do not enumerate the different exact locations for the rectangles, and therefore promise to be immune to the problem of high-precision rectangles. They used a variable for every pair of rectangles to represent the relations above, below, left, and right. Their search algorithm then required at least one of these non-overlapping constraints to be true for every pair of rectangles. Their meta-CSP approach was modeled after work by Dechter, Meiri, and Pearl (1991) on solving binary constraint satisfaction problems, and included various pruning techniques such as model reduction, symmetry breaking, and graph-based pruning heuristics (Korf et al.", "startOffset": 49, "endOffset": 574}, {"referenceID": 13, "context": "Within the schema of assigning x-coordinates prior to y-coordinates, we introduced a dynamic variable order for the x-coordinates, and a constraint that adapts Korf\u2019s (2003) wasted space pruning heuristic to the one-dimensional case.", "startOffset": 160, "endOffset": 174}, {"referenceID": 13, "context": "This is how we explain the orders of magnitude speedup for processing just the x-coordinate solutions in a 1D array instead of the 2D bitmap by Korf (2003). As we move from 1D arrays, to 2D bitmaps, to abstract representations of variables and values in constraint programming, the patterns of computation and data structures simply become too distant from what the underlying hardware is optimized for.", "startOffset": 144, "endOffset": 156}], "year": 2013, "abstractText": "We consider the problem of finding all enclosing rectangles of minimum area that can contain a given set of rectangles without overlap. Our rectangle packer chooses the xcoordinates of all the rectangles before any of the y-coordinates. We then transform the problem into a perfect-packing problem with no empty space by adding additional rectangles. To determine the y-coordinates, we branch on the different rectangles that can be placed in each empty position. Our packer allows us to extend the known solutions for a consecutive-square benchmark from 27 to 32 squares. We also introduce three new benchmarks, avoiding properties that make a benchmark easy, such as rectangles with shared dimensions. Our third benchmark consists of rectangles of increasingly high precision. To pack them efficiently, we limit the rectangles\u2019 coordinates and the bounding box dimensions to the set of subset sums of the rectangles\u2019 dimensions. Overall, our algorithms represent the current state-of-the-art for this problem, outperforming other algorithms by orders of magnitude, depending on the benchmark.", "creator": "TeX"}}}