{"id": "1402.0568", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Boolean Equi-propagation for Concise and Efficient SAT Encodings of Combinatorial Problems", "abstract": "We present an approach to propagation-based SAT encoding of combinatorial problems, Boolean equi-propagation, where constraints are modeled as Boolean functions which propagate information about equalities between Boolean literals. This information is then applied to simplify the CNF encoding of the constraints. A key factor is that considering only a small fragment of a constraint model at one time enables us to apply stronger, and even complete, reasoning to detect equivalent literals in that fragment. Once detected, equivalences apply to simplify the entire constraint model and facilitate further reasoning on other fragments. Equi-propagation in combination with partial evaluation and constraint simplification provide the foundation for a powerful approach to SAT-based finite domain constraint solving. We introduce a tool called BEE (Ben-Gurion Equi-propagation Encoder) based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of CNF encodings and subsequent speed-ups in SAT solving times.", "histories": [["v1", "Tue, 4 Feb 2014 01:36:36 GMT  (701kb)", "http://arxiv.org/abs/1402.0568v1", "arXiv admin note: text overlap witharXiv:1206.3883"]], "COMMENTS": "arXiv admin note: text overlap witharXiv:1206.3883", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["amit metodi", "michael codish", "peter james stuckey"], "accepted": false, "id": "1402.0568"}, "pdf": {"name": "1402.0568.pdf", "metadata": {"source": "CRF", "title": "Boolean Equi-propagation for Concise and Efficient SAT Encodings of Combinatorial Problems", "authors": ["Amit Metodi", "Michael Codish", "Peter J. Stuckey"], "emails": ["amit.metodi@gmail.com", "mcodish@cs.bgu.ac.il", "pjs@csse.unimelb.edu.au"], "sections": [{"heading": "1. Introduction", "text": "The situation has improved dramatically in recent years, and today's SAT solutions are much faster and capable of managing larger instances than before."}, {"heading": "2. Constraint Based Boolean Modeling", "text": "This section provides the basis for our contribution: a constraint-based modeling language, together with a Boolean interpretation for each constraint in the language. This allows us to consider a constraint model as a combination of Boolean formulas and provides a structure that drives the subsequent coding to CNF. We first introduce a simple and small fragment of a typical modeling language based on finite domain constraints, which serves to illustrate our approach. Later, in Section 6, we show the full language. We then discuss several options for Boolean representation of integers. In this essay, we use a special uneven representation, called order encoding. Our contribution is independent of this choice, although Equi propagation works well with it. Finally, we end the section so that each of the constraints in the language fragment can be considered as a Boolean formula and a constraint model as its conjunction."}, {"heading": "2.1 Constraint Language Fragment", "text": "We will focus on a small fragment of a typical constraint modeling language described in Figure 1, which serves to illustrate the main ideas of the essay. Constraint (1) deals with the declaration of finite domain integer variables in the range [c1... c2]. For the sake of simplicity, we will continue with the assumption that c1 \u2265 0. Constraints (2-3) deal with the difference of integer variables, and constraints (4-5) with sums of integer variables. As syntactic sugar, we also allow the writing of integer constraints. For example, int neq (I, 5), which is the abbreviation for new int (I \u2032, 5, 5), int neq (I, I \u2032)."}, {"heading": "2.2 Modeling Kakuro: an Example", "text": "A kakuro puzzle is a n \u00d7 m board of black and white cells. The black cells contain clues and the white cells must be filled with numbers between 1 and 9 (the bound 9 is often generalized by a larger value r).The clues set constraints on the sums of values in blocks of white cells on the right and / or below the clue.The numbers assigned to the white cells in such a block must be \"all different.\" Figure 2 illustrates a 4 \u00d7 4 kakuro puzzle (left) and its solution (right).To model a kakuro puzzle, we consider it a series of blocks (of white cells) where each block B is a set of integer variables and is associated with a corresponding integer value, Note (B).Each block B is associated with two constraints: The integers in B must add up to Note (B) and all must be different. Figure 3 illustrates the constraints that correspond to the acuro instance in Figure 2."}, {"heading": "2.3 Representing Integers", "text": "Gavanelli (2007) examines several of the possible options (direct, support, and log encodings) and introduces log support encoding (see e.g. Crawford & Baker, 1994; Bailleux & Boufkhad, 2003), which has many nice properties when applied to small finite domains. In sequence encoding, we focus on an integer variable X in the domain. n] is represented by a bit vector X = [x1, xn]. Each bit xi is interpreted as an X value."}, {"heading": "2.4 Bit Blasting", "text": "Considering a constraint model and deciding how to represent finite domain integer variables at the bit level (we chose the order of encoding), \"bit-blasting\" is the process of instantiating integer variables by corresponding bit vectors and interpreting constraints as Boolean formulas. Each integer variable is declared by a constraint of the new form (I, c1, c2), where 0 \u2264 c1 \u2264 c2 is represented as bit vector I = [1,.., 1, Xc1 + 1,., Xc2]. Therefore, we can view a constraint model as consisting only of Boolean variables, and any constraint c corresponds to a Boolean formula called [c], the \"bitray\" version of c. The specific definition of [[\u00b7]] constractions as a contraction of Xy."}, {"heading": "3. Boolean Equi-propagation", "text": "In this section, we present an approach to the propagation-based SAT coding, the Boolean equipropagation, which propagates information about equality between Boolean literals (and constants). We prove that the Boolean equipropagation is stronger than the unit propagation, as it determines at least as many solid literals as the unit propagation. We demonstrate the power of equipropagation in one example and show that it leads to a considerable reduction in the size of the CNF coding."}, {"heading": "3.1 Boolean Equi-propagation", "text": "A letter (e) is a boolean formula that appears in a boolean formula. The boolean constants 1 and 0 represent true and false. We extend the vars function to sets of formulas in the natural way. An assignment, A, is a partial assignment of boolean variables to constants, which are often considered as the following set of letters: {b, b, b, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c,"}, {"heading": "3.1.1 Equi-propagation", "text": "This is a process of inferring equation-related consequences from a Boolean formula and given e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e-e"}, {"heading": "3.1.2 Boolean Unifiers", "text": "It is sometimes convenient to consider an equation E in a general \"solution formula\" (1), which is a (most general) unifier formula for the equations in E. Boolean formula E (2), if these variables can also be bound to letters. (1) Boolean substitution is an ideal mapping: B \u2192 L0,1, where the equations in E. B. (2), includes those elements for which it is not identical. A Boolean substitution is considered a proposition that is considered as such. (B) 6 = \u00ac b for each B. Note is also that this constellation is defined for all B and that its domain, dom (2), includes elements for which it is not identical. (A) Boolean substitution is considered as a proposition. (B 7) We can apply a different substitution."}, {"heading": "3.1.3 The Equi-propagation Process", "text": "The equation propagation processes that are now being presented are a central theme in this essay: Let's apply these equation propagation processes. (1) The equation propagation processes (1) is a central theme in this essay. (1) The equation propagation processes (1), (2), (1), (1), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2), (2, (2), (2), (2, (2), (2), (2), (2, (2), (2), (2,), (2, (2), (2,), (2, (2), (2), (2), (2), (2, (2), (2), (2,), (2,), (2, (2), (2), (), (2), (), (2), (2, (), (2), (), (2,), (, (2)."}, {"heading": "3.2 The Power of Equi-propagation", "text": "To illustrate the effects of the equation propagation, we come back, for example, from Kakuro in Section 2.2 (recall Figure 2). In fact, solving such puzzles via SAT encryption is fairly simple, with and without equation propagation. Therefore, the example should only be considered as an indication of the effects of the equation propagation on the size of the encryption. We compare three different models of the problem, each showing different equation propagation. We consider as a starting point for this discussion the following Boolean representation, which is derived from a limited model in which the explanations that are not explicitly specified are of the form that are new expressions (I, h), which contain the smallest hint of a block containing I or the number 9, if that is smaller."}, {"heading": "3.3 Implementing Equi-propagators", "text": "To realize this, we must derive the Boolean qualities that depend on a given Boolean formula, and we must use them for satisfaction. (1) We consider three techniques: the use of a SAT solver, the use of BDDs, and the use of ad hoc rules applied to the Boolean formula. (1) We consider the formula (1) unsatisfactory, then it is easy to implement a complete equation. (1) In this way, the condition (1) can be verified for all relevant equations. (1) We (and the constants 0.1). (1) A major obstacle with this SAT approach is that we can be verified for all relevant equations. (1)"}, {"heading": "4. Ad-hoc Equi-Propagation", "text": "We consider a rules-based approach to defining equation propagators with cells that affect all cells. < The novelty is that the approach is not based on CNF, as in previous work, but rather driven by the bit-blasted constraints that are to be encoded on CNF. Our presentation focuses on the case in which limited domain numbers are represented in the order of encoding. For an integer X = [x1,. xn] we often write: X \u2265 i to name the equation xi = 1, X < i to name the equation xi = 0, X = i. The equation xi = i to name the equation xi = i to name the equation xi."}, {"heading": "5. Constraint Model Partial Evaluation", "text": "This year, more than ever before in the history of the country in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is not a country, but in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a region, in which it is a country."}, {"heading": "8. Experiments", "text": "All experiments run on an Intel Core 2 Duo E8400 3.0GHz CPU with 4GB of memory under Linux (Ubuntu lucid, kernel 2.6.32-24-generic).BEE is written in Prolog and runs with SWI Prolog v6.0.2 64-bit. Comparisons with Sugar (v1.15.0) are based on the use of identical constraint models, apply the same SAT solver (CryptoMiniSAT v2.5.1) and run on the same machine. Times are reported in seconds."}, {"heading": "8.1 Quasigroup Completion Problems", "text": "A Quasigroup Completion Problem (QCP) proposed by Gomes, Selman and Crato (1997) as a condition satisfaction benchmark is specified as an n \u00b7 n board of integer variables (in the range [1, n]) in which some integer values are assigned to all variables, the task being to assign values to all variables so that no column or row contains the same value twice. The condition model is a conjunction of allDiff constraints. Anso \u0301 tegui, del Val, Dotu \u2033, Ferna \u0301 ndez, and Manya \u0445 (2004) argue the advantage of direct encoding for QCP. We consider 15 distances from the CSP competition.2 Table 3 considers three settings: BEE with its dual encoding for allDiff constraints, BEE with the use of only the order encoding (equivalent to the use of int neq constraints), and Sugar."}, {"heading": "8.2 Word Design for DNA", "text": "This is problem 33 of the CSPLib, which seeks the largest parameter n, so that there is a row S of n pairs of words with eight letters above the alphabet \u03a3 = {A, C, G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {112, G}; (2) Each pair of different words in S differs in at least 4 positions; and (3) For each x, y \u00b2 S: xR (the inversion of x) and yC (the word achieved by replacing each A of T, each C of G, and vice versa) differ in at least 4 positions. Mancini, Micaletto, Patrizi, and Cadoli (2008) offer a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of coding techniques. Their best reported result is a solution with 87 DNA words obtained in 554 seconds, using an OPL (Hentenvan, 1999 model coxileum strategy)."}, {"heading": "8.3 Vertex Magic Total Labeling", "text": "In fact, most of them are able to survive by themselves if they do not play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...) Most of them are not able to play by the rules. (...)"}, {"heading": "8.4 Balanced Incomplete Block Designs", "text": "This is problem 028 of the CSPlib (BIBD), where an instance is defined by a 5-fold number of positive integers. [v, b, r, k, \u03bb] and requires the division of different objects into B blocks, so that each block contains different objects that occur in each block, and each two different objects occur in exactly \u03bb block.6 Personal Communication (Gerold Ja \ufffd ger), March 2012.The naive model for a BIBD instance [v, b, r, k,] presents the following constraints on a v of b Boolean incidence matrix: (1) exactly r ones in each row, (2) exactly k ones in each column, and (3) exactly the same. This model does not contain sufficient information to trigger the propagation process. To take advantage of the BEE simplifications that we can look at and fix as described by Frisch, Jefferson, and Miguel (2004)."}, {"heading": "9. Conclusion", "text": "Most of these approaches determine binary clauses implied by the CNF, which is certainly sufficient to determine Boolean equality. The problem is that determining all the binary clauses implied by the CNF is prohibitive when the SAT model can contain many (hundreds) of thousands of variables. Typically, only some of the implied binary clauses are determined, such as those visible through the propagation of units. Trade-off is regulated by the choice of techniques used based on CNS clauses, taking into account power and cost. See, for example, the work of Ee-n and Beer (2005) and the references contained therein. There are also approaches (Li, 2003) that recognize and use Boolean qualities during runtime that are complementary to our approach."}, {"heading": "Acknowledgments", "text": "We thank Vitaly Lagoon for the many insightful discussions about this research. NICTA is funded by the Australian Government, represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence Program."}], "references": [{"title": "Modeling choices in quasigroup completion: SAT vs. CSP", "author": ["C. Ans\u00f3tegui", "A. del Val", "I. Dot\u00fa", "C. Fern\u00e1ndez", "F. Many\u00e0"], "venue": null, "citeRegEx": "Ans\u00f3tegui et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Ans\u00f3tegui et al\\.", "year": 2004}, {"title": "Cardinality networks: a theoretical and empirical study", "author": ["R. A\u015b\u0131n", "R. Nieuwenhuis", "A. Oliveras", "E. Rod\u0155\u0131guez-Carbonell"], "venue": "Constraints,", "citeRegEx": "A\u015b\u0131n et al\\.,? \\Q2011\\E", "shortCiteRegEx": "A\u015b\u0131n et al\\.", "year": 2011}, {"title": "Factorizing equivalent variable pairs in ROBDDbased implementations of Pos", "author": ["R. Bagnara", "P. Schachte"], "venue": "Algebraic Methodology and Software Technology, 7th International Conference,", "citeRegEx": "Bagnara and Schachte,? \\Q1998\\E", "shortCiteRegEx": "Bagnara and Schachte", "year": 1998}, {"title": "Efficient CNF encoding of Boolean cardinality constraints", "author": ["O. Bailleux", "Y. Boufkhad"], "venue": "CP, Vol. 2833 of LNCS,", "citeRegEx": "Bailleux and Boufkhad,? \\Q2003\\E", "shortCiteRegEx": "Bailleux and Boufkhad", "year": 2003}, {"title": "The Satisfiability Modulo Theories Library (SMT-LIB). www.SMT-LIB.org", "author": ["C. Barrett", "A. Stump", "C. Tinelli"], "venue": null, "citeRegEx": "Barrett et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2010}, {"title": "Sorting networks and their applications", "author": ["K.E. Batcher"], "venue": "AFIPS Spring Joint Computing Conference, Vol. 32 of AFIPS Conference Proceedings, pp. 307\u2013314, Atlantic City, NJ, USA. Thomson Book Company, Washington D.C.", "citeRegEx": "Batcher,? 1968", "shortCiteRegEx": "Batcher", "year": 1968}, {"title": "Circuit complexity and decompositions of global constraints", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "In Proceedings of IJCAI", "citeRegEx": "Bessiere et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bessiere et al\\.", "year": 2009}, {"title": "Compiling problem specifications into SAT", "author": ["M. Cadoli", "A. Schaerf"], "venue": "Artificial Intelligence,", "citeRegEx": "Cadoli and Schaerf,? \\Q2005\\E", "shortCiteRegEx": "Cadoli and Schaerf", "year": 2005}, {"title": "Optimal base encodings for pseudo-Boolean constraints", "author": ["M. Codish", "Y. Fekete", "C. Fuhs", "P. Schneider-Kamp"], "venue": "TACAS, Vol. 6605 of Lecture Notes in Computer Science,", "citeRegEx": "Codish et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Codish et al\\.", "year": 2011}, {"title": "Pairwise cardinality networks", "author": ["M. Codish", "M. Zazon-Ivry"], "venue": "LPAR (Dakar),", "citeRegEx": "Codish and Zazon.Ivry,? \\Q2010\\E", "shortCiteRegEx": "Codish and Zazon.Ivry", "year": 2010}, {"title": "A unified framework for the formal verification of sequential circuits", "author": ["O. Coudert", "J.C. Madre"], "venue": "In ICCAD,", "citeRegEx": "Coudert and Madre,? \\Q1990\\E", "shortCiteRegEx": "Coudert and Madre", "year": 1990}, {"title": "Experimental results on the application of satisfiability algorithms to scheduling problems", "author": ["J.M. Crawford", "A.B. Baker"], "venue": "AAAI, Vol", "citeRegEx": "Crawford and Baker,? \\Q1994\\E", "shortCiteRegEx": "Crawford and Baker", "year": 1994}, {"title": "Effective preprocessing in SAT through variable and clause elimination", "author": ["N. E\u00e9n", "A. Biere"], "venue": "SAT, Vol. 3569 of Lecture Notes in Computer Science,", "citeRegEx": "E\u00e9n and Biere,? \\Q2005\\E", "shortCiteRegEx": "E\u00e9n and Biere", "year": 2005}, {"title": "An extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "SAT, Vol. 2919 of Lecture Notes in Computer Science,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2003\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2003}, {"title": "Translating pseudo-Boolean constraints into SAT", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "JSAT,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2006\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2006}, {"title": "Symmetry breaking as a prelude to implied constraints: A constraint modeling pattern", "author": ["A.M. Frisch", "C. Jefferson", "I. Miguel"], "venue": "In Proc. 16th Euro. Conf. on AI,", "citeRegEx": "Frisch et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Frisch et al\\.", "year": 2004}, {"title": "Demonstration of a word design strategy for DNA computing on surfaces", "author": ["A.G. Frutos", "Q. Liu", "A.J. Thiel", "A.M.W. Sanner", "A.E. Condon", "L.M. Smith", "R.M. Corn"], "venue": "Journal of Nucleic Acids Research,", "citeRegEx": "Frutos et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Frutos et al\\.", "year": 1997}, {"title": "A dynamic survey of graph labeling", "author": ["J.A. Gallian"], "venue": "The Electronic Journal of Combinatorics, 18.", "citeRegEx": "Gallian,? 2011", "shortCiteRegEx": "Gallian", "year": 2011}, {"title": "The log-support encoding of CSP into SAT", "author": ["M. Gavanelli"], "venue": "Bessiere, C. (Ed.), CP, Vol. 4741 of LNCS, pp. 815\u2013822, Providence, RI, USA. Springer.", "citeRegEx": "Gavanelli,? 2007", "shortCiteRegEx": "Gavanelli", "year": 2007}, {"title": "Toward leaner binary-clause reasoning in a satisfiability solver", "author": ["A.V. Gelder"], "venue": "Ann. Math. Artif. Intell., 43 (1), 239\u2013253.", "citeRegEx": "Gelder,? 2005", "shortCiteRegEx": "Gelder", "year": 2005}, {"title": "Minion: A fast scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "ECAI, Vol. 141 of Frontiers in Artificial Intelligence and Applications,", "citeRegEx": "Gent et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2006}, {"title": "A new encoding of alldifferent into SAT. Proceedings of the 3rd International Workshop on Modeling and Reformulating Constraint Satisfaction Problems, http://www-users.cs.york.ac.uk/frisch/Reformulation/04/ proceedings.pdf", "author": ["I.P. Gent", "P. Nightingale"], "venue": null, "citeRegEx": "Gent and Nightingale,? \\Q2004\\E", "shortCiteRegEx": "Gent and Nightingale", "year": 2004}, {"title": "Heavy-tailed distributions in combinatorial search", "author": ["C.P. Gomes", "B. Selman", "N. Crato"], "venue": "Vol. 1330 of LNCS,", "citeRegEx": "Gomes et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 1997}, {"title": "Efficient CNF simplification based on binary implication graphs", "author": ["M. Heule", "M. J\u00e4rvisalo", "A. Biere"], "venue": "SAT, Vol. 6695 of Lecture Notes in Computer Science,", "citeRegEx": "Heule et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Heule et al\\.", "year": 2011}, {"title": "Universal Booleanization of constraint models", "author": ["J. Huang"], "venue": "CP2008, Vol. 5202 of Lecture Notes in Computer Science, pp. 144\u2013158.", "citeRegEx": "Huang,? 2008", "shortCiteRegEx": "Huang", "year": 2008}, {"title": "An effective SAT encoding for magic labeling", "author": ["G. J\u00e4ger"], "venue": "Faigle, U., Schrader, R., & Herrmann, D. (Eds.), CTW, pp. 97\u2013100.", "citeRegEx": "J\u00e4ger,? 2010", "shortCiteRegEx": "J\u00e4ger", "year": 2010}, {"title": "Equivalent literal propagation in the DLL procedure", "author": ["C. Li"], "venue": "Discrete Applied Mathematics, 130 (2), 251\u2013276.", "citeRegEx": "Li,? 2003", "shortCiteRegEx": "Li", "year": 2003}, {"title": "Vertex-magic total labelings of graphs", "author": ["J. MacDougall", "M. Miller", "M. Slamin", "W. Wallis"], "venue": "Utilitas Mathematica,", "citeRegEx": "MacDougall et al\\.,? \\Q2002\\E", "shortCiteRegEx": "MacDougall et al\\.", "year": 2002}, {"title": "Coprocessor 2.0 - a flexible CNF simplifier - (tool presentation)", "author": ["N. Manthey"], "venue": "SAT, Vol. 7317 of Lecture Notes in Computer Science,", "citeRegEx": "Manthey,? \\Q2012\\E", "shortCiteRegEx": "Manthey", "year": 2012}, {"title": "BEE", "author": ["A. Metodi"], "venue": "http://amit.metodi.me/research/bee/.", "citeRegEx": "Metodi,? 2012", "shortCiteRegEx": "Metodi", "year": 2012}, {"title": "Compiling finite domain constraints to SAT with BEE", "author": ["A. Metodi", "M. Codish"], "venue": "TPLP,", "citeRegEx": "Metodi and Codish,? \\Q2012\\E", "shortCiteRegEx": "Metodi and Codish", "year": 2012}, {"title": "Boolean equi-propagation for optimized SAT encoding", "author": ["A. Metodi", "M. Codish", "V. Lagoon", "P.J. Stuckey"], "venue": "CP, Vol. 6876 of LNCS,", "citeRegEx": "Metodi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Metodi et al\\.", "year": 2011}, {"title": "Minizinc: Towards a standard CP modeling language", "author": ["N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "G.J. Duck", "G. Tack"], "venue": "In Bessiere, C. (Ed.), CP2007,", "citeRegEx": "Nethercote et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nethercote et al\\.", "year": 2007}, {"title": "CUDD: Colorado University Decision Diagram package", "author": ["F. Somenzi"], "venue": "(Online, accessed 13 April 2011). http://vlsi.colorado.edu/~fabio/CUDD/. Soos, M. (2010). CryptoMiniSAT, v2.5.1. http://www.msoos.org/cryptominisat2.", "citeRegEx": "Somenzi,? 2009", "shortCiteRegEx": "Somenzi", "year": 2009}, {"title": "Compiling finite linear CSP", "author": ["N. Tamura", "A. Taga", "S. Kitagawa", "M. Banbara"], "venue": "into SAT. Constraints,", "citeRegEx": "Tamura et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Tamura et al\\.", "year": 2009}, {"title": "Efficiency of a good but not linear set union algorithm", "author": ["R. Tarjan"], "venue": "JACM, 22 (2), 215\u2013225.", "citeRegEx": "Tarjan,? 1975", "shortCiteRegEx": "Tarjan", "year": 1975}, {"title": "The OPL Optimization Programming Language", "author": ["P. van Hentenryck"], "venue": null, "citeRegEx": "Hentenryck,? \\Q1999\\E", "shortCiteRegEx": "Hentenryck", "year": 1999}, {"title": "The alldifferent constraint: A survey.. CoRR:http://arxiv.org/ abs/cs.PL/0105015", "author": ["W.J. van Hoeve"], "venue": null, "citeRegEx": "Hoeve,? \\Q2001\\E", "shortCiteRegEx": "Hoeve", "year": 2001}], "referenceMentions": [{"referenceID": 26, "context": "Journal of Artificial Intelligence Research 46 (2013) 303\u2013341 Submitted 09/12; published 03/13", "startOffset": 27, "endOffset": 54}, {"referenceID": 24, "context": "In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010).", "startOffset": 56, "endOffset": 69}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way.", "startOffset": 13, "endOffset": 39}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1163}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1185}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1221}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1241}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work. All of these techniques exhibit a clear trade-off between the amount of simplification obtained and the time it requires. Moreover, the stronger techniques become prohibitive when the SAT model involves hundreds of thousands of variables and millions of clauses. So in CNF simplification tools, time limits on simplification techniques are imposed and/or approximations are used. This paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific problem domain. When SAT solving is applied to encode and solve finite domain constraint problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints provides important structural information that can be applied to drive the process of CNF simplification. To be specific, the constraints in a model induce a partitioning of their CNF encoding to a conjunction of sub-formulae which we call \u201cportions\u201d. The novelty in our approach to CNF simplification is that instead of considering the CNF as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the portions and this information may trigger further simplification in other portions. Because portions are typically much smaller than the entire CNF we can effectively apply stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to how unit propagation is about inferring unit clauses which can then be applied to simplify CNF formulae, equi-propagation is about inferring equational consequences between literals (and Boolean constants). There is a wide body of research on CNF simplification that can be applied to implement equi-propagation which is sometimes called equivalent literal substitution, for example by Gelder (2005). Techniques typically involve binary clause based simplifications using, among others, hyper binary resolution and binary implication graphs.", "startOffset": 13, "endOffset": 3386}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work. All of these techniques exhibit a clear trade-off between the amount of simplification obtained and the time it requires. Moreover, the stronger techniques become prohibitive when the SAT model involves hundreds of thousands of variables and millions of clauses. So in CNF simplification tools, time limits on simplification techniques are imposed and/or approximations are used. This paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific problem domain. When SAT solving is applied to encode and solve finite domain constraint problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints provides important structural information that can be applied to drive the process of CNF simplification. To be specific, the constraints in a model induce a partitioning of their CNF encoding to a conjunction of sub-formulae which we call \u201cportions\u201d. The novelty in our approach to CNF simplification is that instead of considering the CNF as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the portions and this information may trigger further simplification in other portions. Because portions are typically much smaller than the entire CNF we can effectively apply stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to how unit propagation is about inferring unit clauses which can then be applied to simplify CNF formulae, equi-propagation is about inferring equational consequences between literals (and Boolean constants). There is a wide body of research on CNF simplification that can be applied to implement equi-propagation which is sometimes called equivalent literal substitution, for example by Gelder (2005). Techniques typically involve binary clause based simplifications using, among others, hyper binary resolution and binary implication graphs. See for example, the work of Heule et al. (2011) and the references therein.", "startOffset": 13, "endOffset": 3577}, {"referenceID": 29, "context": "The BEE tool is available for download (Metodi, 2012).", "startOffset": 39, "endOffset": 53}, {"referenceID": 26, "context": "At one extreme we apply complete equi-propagation which detects all equivalences implied by a formula. Clearly complete equi-propagation is NP-hard. However, complete equi-propagators are feasible as we apply them only to small portions of the formula. When complete equi-propagation is too slow we consider ad-hoc techniques. All of these forms of equi-propagation have in common that they are not driven by the CNF structure (e.g. binary clauses) but rather by the underlying constraint structure from which a CNF was, or is being, generated. The rest of this paper is structured as follows. Section 2 introduces a modeling language for finite domain constraints which consists of just 5 constraint constructs and is sufficient to illustrate the contribution of the paper. We argue that the constraints in a model induce a natural partition of their CNF encoding to smaller portions and that this partition can be used to drive the simplification of the CNF encoding. Section 3 presents equi-propagation which is the first ingredient for our contribution. Equi-propagation is about learning information that will apply to simplify CNF encodings. Section 4 describes a practical basis for implementing equi-propagation. Section 5 introduces the second ingredient: partial evaluation. Given the information derived using equi-propagation, partial evaluation applies to simplify the constraints and in particular to remove Boolean variables from their CNF encodings. Section 6 describes a tool, called BEE (Metodi & Codish, 2012) (Ben-Gurion Equi-propagation Encoder) that is based on equi-propagation and partial evaluation. We introduce here our full constraint language which is similar to Sugar and to the subset of FlatZinc relevant for finite domain constraint problems. We also spell out the special treatment of the all-different constraint in BEE. Section 7 demonstrates the application of BEE. Section 8 presents an experimental evaluation. and Finally Section 9 presents our conclusion. This paper extends earlier work presented by Metodi, Codish, Lagoon, and Stuckey (2011), which first introduced equi-propagation, and also the BEE tool paper (Metodi & Codish, 2012).", "startOffset": 84, "endOffset": 2085}, {"referenceID": 18, "context": "Gavanelli (2007) surveys several of the possible choices (the", "startOffset": 0, "endOffset": 17}, {"referenceID": 35, "context": "We can compute unifyE in almost linear (amortized) time using a variation of the union-find algorithm (Tarjan, 1975).", "startOffset": 102, "endOffset": 116}, {"referenceID": 13, "context": "E\u00e9n and S\u00f6rensson (2006) propose to add redundant clauses, {\u00act,\u00acf, x} and {t, f,\u00acx}.", "startOffset": 0, "endOffset": 25}, {"referenceID": 9, "context": "In practice, rather than these two steps, we can use the \u201cRestrict\u201d operation of Coudert and Madre (1990) (\u201cbdd simplify\u201d in Somenzi, 2009) to create the new BDD more efficiently.", "startOffset": 81, "endOffset": 106}, {"referenceID": 2, "context": "Alternately we can use the method of Bagnara and Schachte (1998) (extended to extract literal equalities as opposed to just variable equalities) to extract all the fixed literals and equivalent literal consequences of the BDD.", "startOffset": 37, "endOffset": 65}, {"referenceID": 29, "context": "BEE can be downloaded (Metodi, 2012) where one can also find the examples from this paper and others.", "startOffset": 22, "endOffset": 36}, {"referenceID": 32, "context": "It is a constraint modeling language similar to FlatZinc (Nethercote et al., 2007), but with a focus on a subset of the language relevant for finite domain constraint problems.", "startOffset": 57, "endOffset": 82}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010).", "startOffset": 72, "endOffset": 87}, {"referenceID": 24, "context": "BEE (Ben-Gurion Equi-propagation Encoder) is a tool which applies to encode finite domain constraint models to CNF. BEE was first introduced by Metodi and Codish (2012). During the encoding process, BEE performs optimizations based on equi-propagation and partial evaluation to improve the quality of the target CNF.", "startOffset": 61, "endOffset": 169}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010).", "startOffset": 73, "endOffset": 239}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010). Constraints (9-14) are about integer relations and operations.", "startOffset": 73, "endOffset": 275}, {"referenceID": 5, "context": "One approach, supported by BEE, decomposes the constraint as an odd-even merger (from the context of odd-even sorting networks) (Batcher, 1968).", "startOffset": 128, "endOffset": 143}, {"referenceID": 34, "context": "The BEE encodings are similar to those applied in Sugar (Tamura et al., 2009).", "startOffset": 56, "endOffset": 77}, {"referenceID": 21, "context": "This is essentially the same as the encoding proposed by Gent and Nightingale (2004). When declaring an integer variable I, the bit-blast in the order encoding applies the corresponding unification I = [x1, .", "startOffset": 57, "endOffset": 85}, {"referenceID": 17, "context": "See for example the survey by Gallian (2011) with more than 1200 references.", "startOffset": 30, "endOffset": 45}, {"referenceID": 25, "context": "This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists a set S of n eight-letter words over the alphabet \u03a3 = {A,C,G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {C,G}; (2) Each pair of distinct words in S differ in at least 4 positions; and (3) For every x, y \u2208 S: xR (the reverse of x) and yC (the word obtained by replacing each A by T , each C by G, and vice versa) differ in at least 4 positions. Mancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques.", "startOffset": 26, "endOffset": 519}, {"referenceID": 25, "context": "This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists a set S of n eight-letter words over the alphabet \u03a3 = {A,C,G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {C,G}; (2) Each pair of distinct words in S differ in at least 4 positions; and (3) For every x, y \u2208 S: xR (the reverse of x) and yC (the word obtained by replacing each A by T , each C by G, and vice versa) differ in at least 4 positions. Mancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques. Their best reported result is a solution with 87 DNA words, obtained in 554 seconds, using an OPL (van Hentenryck, 1999) model with lexicographic order to break symmetry. Frutos, Liu, Thiel, Sanner, Condon, Smith, and Corn (1997) present a strategy to solve this problem where the four letters are modeled by bit-pairs [t,m].", "startOffset": 26, "endOffset": 876}, {"referenceID": 16, "context": "4 Building on the approach described by Frutos et al. (1997), we pose conditions on sets of \u201ct-parts\u201d and \u201cm-parts\u201d, T and M , so that their Cartesian product S = T \u00d7M will satisfy the requirements of the original problem.", "startOffset": 40, "endOffset": 61}, {"referenceID": 26, "context": "MacDougall, Miller, Slamin, and Wallis (2002) conjecture that the n vertex complete graph, Kn, for n \u2265 5 has a vertex magic total labeling with magic constants for a specific range of values of k, determined by n.", "startOffset": 35, "endOffset": 46}, {"referenceID": 25, "context": "The SAT based approach presented by J\u00e4ger (2010) cannot handle these.", "startOffset": 36, "endOffset": 49}, {"referenceID": 26, "context": "In order to take advantage of the BEE simplifications we added symmetry breaking as described by Frisch, Jefferson, and Miguel (2004) and illustrated in Figure 20: Each row is viewed as sequence of four parts A .", "startOffset": 42, "endOffset": 134}, {"referenceID": 20, "context": "We consider three different models for Minion: [M\u201906] indicates results using the BIBD model described by Gent et al. (2006), SymB uses the same model we use for the SAT approach, SymB+, is an enhanced symmetry breaking model with all of the tricks applied also in the [M\u201906] model.", "startOffset": 106, "endOffset": 125}, {"referenceID": 26, "context": "There are also approaches (Li, 2003) that detect and use Boolean equalities during run-time, which are complementary to our approach.", "startOffset": 26, "endOffset": 36}, {"referenceID": 12, "context": "See for example the work of E\u00e9n and Biere (2005) and the references therein.", "startOffset": 28, "endOffset": 49}, {"referenceID": 13, "context": "Ongoing work aims to extend BEE for binary and additional number representations such as mixed radix bases as considered by E\u00e9n and S\u00f6rensson (2006) and further by Codish, Fekete, Fuhs, and Schneider-Kamp (2011).", "startOffset": 124, "endOffset": 149}, {"referenceID": 13, "context": "Ongoing work aims to extend BEE for binary and additional number representations such as mixed radix bases as considered by E\u00e9n and S\u00f6rensson (2006) and further by Codish, Fekete, Fuhs, and Schneider-Kamp (2011).", "startOffset": 124, "endOffset": 212}], "year": 2013, "abstractText": "We present an approach to propagation-based SAT encoding of combinatorial problems, Boolean equi-propagation, where constraints are modeled as Boolean functions which propagate information about equalities between Boolean literals. This information is then applied to simplify the CNF encoding of the constraints. A key factor is that considering only a small fragment of a constraint model at one time enables us to apply stronger, and even complete, reasoning to detect equivalent literals in that fragment. Once detected, equivalences apply to simplify the entire constraint model and facilitate further reasoning on other fragments. Equi-propagation in combination with partial evaluation and constraint simplification provide the foundation for a powerful approach to SAT-based finite domain constraint solving. We introduce a tool called BEE (Ben-Gurion Equi-propagation Encoder) based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of CNF encodings and subsequent speed-ups in SAT solving times.", "creator": "TeX"}}}