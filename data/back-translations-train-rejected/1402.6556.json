{"id": "1402.6556", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Feb-2014", "title": "Evolutionary solving of the debts' clearing problem", "abstract": "The debts' clearing problem is about clearing all the debts in a group of n entities (persons, companies etc.) using a minimal number of money transaction operations. The problem is known to be NP-hard in the strong sense. As for many intractable problems, techniques from the field of artificial intelligence are useful in finding solutions close to optimum for large inputs. An evolutionary algorithm for solving the debts' clearing problem is proposed.", "histories": [["v1", "Wed, 26 Feb 2014 14:39:57 GMT  (187kb)", "http://arxiv.org/abs/1402.6556v1", "13 pages, 5 figures"]], "COMMENTS": "13 pages, 5 figures", "reviews": [], "SUBJECTS": "cs.NE cs.AI", "authors": ["csaba patcas", "attila bartha"], "accepted": false, "id": "1402.6556"}, "pdf": {"name": "1402.6556.pdf", "metadata": {"source": "CRF", "title": "Evolutionary solving of the debts\u2019 clearing problem", "authors": ["Csaba P\u0103tca\u015f", "Attila Bartha"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 140 2.65 56v1 [cs.NE] 2 6Fe bKeywords: debt clearing, genetic algorithm"}, {"heading": "1 Introduction", "text": "The problem of deleveraging (DC problem) is one that also arises in real life situations. In a group of people who know each other, it is not uncommon to lend a certain amount of money to an acquaintance for a certain period of time, and this process also takes place between different banks or even countries. As money transactions are time and money sensitive processes, it is desirable to settle the debt in a minimal number of money transaction operations. Verhoeff discussed the problem of debt settlement in 2004 ([9]). Pa tcas [6] later rediscovered the problem and proposed it in 2008 at the qualification competition of the Romanian National Computer Science Team. The solution was described in [6] and the problem was presumed to be insolvable, which was already proven in [9]. In [7] the problem is discussed in a dynamic environment and given a new algorithm that in some cases exhibits a superior speed to that described in [6]."}, {"heading": "2 Stating the problem", "text": "The problem is as follows: Consider a number of n units (persons, companies, etc.) and a list of m borrowing between these units. Borrowing can be described by three parameters: the borrower's index, the lender's index, and the money supply that was borrowed. The task is to find a minimum list of money transactions that erases the debts formed between these n units as a result of m borrowing. It is natural to model this problem using graph theory. Consider the following definitions. Definition 1 ([6]) Let G (V, A, W) be a directed, weighted multigraph without loops, | V | = n, | W: A \u2192 Z, where V is the set of vertices, A is the set of arcs and W the weight function. G stands for the transaction done, so we will call it borrowing."}, {"heading": "3 An equivalent problem", "text": "Theorem 4. Select two nodes i and j so that D (i) > 0 and D (j) < 0.2. Add an arc (i, j) weighing min (D (i), \u2212 D (j) to the transaction diagram. 3. Update the D values of i and j to reflect the addition of the arc (by decreasing D (i) and increasing D (j)). 4. Repeat steps (1) - (3) as long as possible. It is clear that at least one D value becomes zero by executing steps (1) - (3). Also, because we have the invariant that the sum of all D values is always zero, we always have D (i) = \u2212 u (j).a (D) at the last iteration."}, {"heading": "4 Evolutionary technique for solving the DC prob-", "text": "lemWe use the reformulation of the problem described in Section 3.Representation A solution of the problem is represented by a permutation of the D values of V, the set of nodes. So a candidate is a vector C = (c1, c2,.., cn), so the idea of permutation representations is intensively used in solutions of the Traveling Salesman ([2, 5, 10]. Fitness assignment To evaluate the fitness of a chromosome, we iterate over the gene of the chromosome in increasing order and maintaining the partial sum, which is si = i, c = 1cj."}, {"heading": "5 How to obtain large instances of the DC prob-", "text": "Due to the strong NP hardness of the problem, it is difficult to generate large test cases for which information about the optimal solution is known. We describe five methods to generate large test cases.Method 1 If the optimal solution is known for some inputs, adding the set of D values with k zeros increases the optimal solution also by k. Method 2 Method 1 can be solved by adding the input with k pairs of the structure (x, \u2212 x).Method 3 If the number of negative (or positive) numbers is two, the problem is equivalent to the subset sum problem and can be solved in pseudopolynomial time by dynamic programming. With this method, we can generate inputs for which the optimal solution is unique, i.e. there is a single subset of positive (negative) numbers equal to the sum of the two negative (positive) numbers (in absolute values)."}, {"heading": "6 Numerical experiments", "text": "A preliminary test phase was carried out with the same 15 test cases that were used when the problem was proposed in 2008 at the qualification competition of the Romanian national team (see [7]). These test cases all have special structures with n \u2264 20, m \u2264 100 and the cost of an arc is a natural number that is not greater than 100. The optimal solution was found for each test case using the algorithm described in [6]. Our genetic algorithm found the optimal solution for all test cases."}, {"heading": "6.1 Combinations of operators", "text": "In the first series of experiments it was determined which combinations of our recombinations and mutations we use best in practice to increase the probability of the mutation. We constructed three test cases (debt100a, debt100b and debt100c) to find the best solution for this test case."}, {"heading": "6.2 Convergence to optimum", "text": "In the second experiment, we investigated the convergence of the solution with the optimal value as the number of generations increased. We concatenated each of the three test cases described above with ourselves ten times, obtaining cases with debt 1000a, debt 1000b, and debt 1000c, respectively. We performed our genetic algorithm with Recomb2 and Mut1 with a mutation probability of 0.75. Population size was set at 80 and the top five individuals were always moved to the next generation. The algorithm was executed once over 50,000 generations, and the suitability of the best chromosome was recorded every 100 generations. Results are Figures 5, 6, and 7. We can observe that in any case the suitability of the best individual increases sharply in the first 5000 generations, then slows down gradually. 50,000 generations were sufficient to find a solution with suitability 244 (97.6% of the optimum) for debt 1000a and a solution with suitability 39 (97.5% of the optimum) for debt 1000b."}, {"heading": "6.3 Efficiency on very difficult test cases", "text": "In the third group of experiments, we used method 2 to generate test cases that are very difficult for our evolutionary algorithm. Starting from n = 100 and in increments of 100, we generated sentences with the structure {1, 2,.., n / 2, \u2212 1, \u2212 2, \u2212 n / 2}. It is easy to see that the optimal solution for these cases is max = n / 2 and it is unique. Only n2! \u00b7 2n / 2 representations from n! yield an optimal solution, which means that the ratio of optimal solutions to all solutions is about 1.0 \u00b7 10 \u2212 3 for n = 10 and about 3.6 \u00b7 10 \u2212 79 for n = 100. In any case, we performed the genetic algorithm 10 times using recomb2 and Mut1 with a mutation probability of 0.75. Population size was set at 80 and the best five individuals were always moved to the next generation. The algorithm was stopped after 5000 generations. In each test case, we corrected the best solution with an average of 10 percent probability and the best solution in 10 percent."}, {"heading": "7 Conclusions", "text": "The only known algorithms for solving the problem were those presented in [6] and [7], which are exact algorithms that always provide the optimal solution, but whose runtime is practicable only for small inputs (n \u2264 20). Using an equivalent problem, we described an evolutionary algorithm for solving the problem and conducted extensive experiments to evaluate its effectiveness. From the experiments, we concluded that our algorithm is much more efficient than a random search in the space of solutions. Our algorithm is able to find the optimal solution for the most difficult test cases with a size of up to n = 100 within minutes. In cases up to n = 1000, our approach remains practicable, as it can achieve solutions in the range of 80% - 98% compared to the optimal solution in about an hour on a PC. In comparison, a random search does not exceed 15% even in the simplest cases of this size."}], "references": [{"title": "Applying adaptive algorithms to epistatic domains", "author": ["L. Davis"], "venue": "Proceedings of the 9th International Joint Conference on Artificial Intelligence,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1985}, {"title": "Alleles, loci, and the traveling salesman problem", "author": ["D. Goldberg", "R. Lingle", "Jr."], "venue": "Proceedings of the 1st International Conference on Genetic Algorithms and their Applications,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1985}, {"title": "Genetic algorithms and population structure - A massively parallel algorithm", "author": ["M. Gorges-Schleuter"], "venue": "Ph.D. thesis, University of Dortmund,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1990}, {"title": "Adaptation in Natural and Artificial Systems", "author": ["John H. Holland"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1975}, {"title": "A study of permutation crossover operators on the traveling salesman problem", "author": ["I. Oliver", "D. Smith", "J. Holland"], "venue": "Proceedings of the Second International Conference on Genetic Algorithms,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1987}, {"title": "On the Debts", "author": ["C. P\u0103tca\u015f"], "venue": "Clearing Problem, Studia Universitatis Babes\u0327- Bolyai Series Informatica,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2009}, {"title": "The debts\u2019 clearing problem: a new approach", "author": ["C. P\u0103tca\u015f"], "venue": "Acta Universitatis Sapientiae, Informatica,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Schedule optimization using genetic algorithms, Handbook of Genetic Algorithms, 332\u2013349", "author": ["G. Syswerda"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1991}, {"title": "Settling Multiple Debts Efficiently: An Invitation to Computing Science, Informatics in Education, volume", "author": ["T. Verhoeff"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Fuquay, Scheduling problems and traveling salesmen: The genetic edge recombination", "author": ["D. Whitley", "D.T. Starkwater"], "venue": "Proceedings of the Third International Conference on Genetic Algorithms,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1989}], "referenceMentions": [{"referenceID": 8, "context": "The problem of settling debts was discussed by Verhoeff in 2004 ([9]).", "startOffset": 65, "endOffset": 68}, {"referenceID": 5, "context": "P\u0103tca\u015f [6] later re-discovered the problem and proposed it in 2008 at the qualification contest of the Romanian national team of informatics.", "startOffset": 7, "endOffset": 10}, {"referenceID": 5, "context": "The solution was described in [6] and the problem conjectured to be intractable, which was earlier proved in [9].", "startOffset": 30, "endOffset": 33}, {"referenceID": 8, "context": "The solution was described in [6] and the problem conjectured to be intractable, which was earlier proved in [9].", "startOffset": 109, "endOffset": 112}, {"referenceID": 6, "context": "In [7] the problem in a dynamic setting is discussed and a new algorithm given, having superior speed on some cases compared to the one described in [6].", "startOffset": 3, "endOffset": 6}, {"referenceID": 5, "context": "In [7] the problem in a dynamic setting is discussed and a new algorithm given, having superior speed on some cases compared to the one described in [6].", "startOffset": 149, "endOffset": 152}, {"referenceID": 5, "context": "Definition 1 ([6]).", "startOffset": 14, "endOffset": 17}, {"referenceID": 5, "context": "Definition 2 ([6]).", "startOffset": 14, "endOffset": 17}, {"referenceID": 5, "context": "Definition 3 ([6]).", "startOffset": 14, "endOffset": 17}, {"referenceID": 1, "context": "The idea of permutation representations is used intensively in solutions of the Traveling Salesman Problem ([2, 5, 10]).", "startOffset": 108, "endOffset": 118}, {"referenceID": 4, "context": "The idea of permutation representations is used intensively in solutions of the Traveling Salesman Problem ([2, 5, 10]).", "startOffset": 108, "endOffset": 118}, {"referenceID": 9, "context": "The idea of permutation representations is used intensively in solutions of the Traveling Salesman Problem ([2, 5, 10]).", "startOffset": 108, "endOffset": 118}, {"referenceID": 0, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 1, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 2, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 4, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 7, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 9, "context": "Recombination Various operators for permutation representations are discussed in [1, 2, 3, 5, 8, 10].", "startOffset": 81, "endOffset": 100}, {"referenceID": 3, "context": "Mut1 The inversion operator described by Holland ([4]) can be used without modification, on the sequence between the i and j elements.", "startOffset": 50, "endOffset": 53}, {"referenceID": 6, "context": "A preliminary testing phase was carried out using the same 15 test cases which were used when the problem was proposed in 2008 at the qualification contest of the Romanian national team (see [7]).", "startOffset": 191, "endOffset": 194}, {"referenceID": 5, "context": "The optimal solution was found for each test case by using the algorithm described in [6].", "startOffset": 86, "endOffset": 89}, {"referenceID": 5, "context": "The only known algorithms to solve the problem were the ones presented in [6] and [7], which are exact algorithms that provide the optimal solution always, but their running time is practical only for small inputs (n \u2264 20).", "startOffset": 74, "endOffset": 77}, {"referenceID": 6, "context": "The only known algorithms to solve the problem were the ones presented in [6] and [7], which are exact algorithms that provide the optimal solution always, but their running time is practical only for small inputs (n \u2264 20).", "startOffset": 82, "endOffset": 85}], "year": 2014, "abstractText": "The debts\u2019 clearing problem is about clearing all the debts in a group of n entities (persons, companies etc.) using a minimal number of money transaction operations. The problem is known to be NP-hard in the strong sense. As for many intractable problems, techniques from the field of artificial intelligence are useful in finding solutions close to optimum for large inputs. An evolutionary algorithm for solving the debts\u2019 clearing problem is proposed.", "creator": "LaTeX with hyperref package"}}}