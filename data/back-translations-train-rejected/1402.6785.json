{"id": "1402.6785", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Feb-2014", "title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking", "abstract": "Formal methods apply algorithms based on mathematical principles to enhance the reliability of systems. It would only be natural to try to progress from verification, model checking or testing a system against its formal specification into constructing it automatically. Classical algorithmic synthesis theory provides interesting algorithms but also alarming high complexity and undecidability results. The use of genetic programming, in combination with model checking and testing, provides a powerful heuristic to synthesize programs. The method is not completely automatic, as it is fine tuned by a user that sets up the specification and parameters. It also does not guarantee to always succeed and converge towards a solution that satisfies all the required properties. However, we applied it successfully on quite nontrivial examples and managed to find solutions to hard programming challenges, as well as to improve and to correct code. We describe here several versions of our method for synthesizing sequential and concurrent systems.", "histories": [["v1", "Thu, 27 Feb 2014 03:45:20 GMT  (162kb)", "http://arxiv.org/abs/1402.6785v1", "In Proceedings INFINITY 2013,arXiv:1402.6610"]], "COMMENTS": "In Proceedings INFINITY 2013,arXiv:1402.6610", "reviews": [], "SUBJECTS": "cs.SE cs.AI cs.NE", "authors": ["gal katz", "doron peled"], "accepted": false, "id": "1402.6785"}, "pdf": {"name": "1402.6785.pdf", "metadata": {"source": "CRF", "title": "Synthesis of Parametric Programs using Genetic Programming and Model Checking", "authors": ["Gal Katz", "Doron Peled"], "emails": [], "sections": [{"heading": null, "text": "L. Clemente and L. Holik (ed.): 15th International Workshop on Verification of Infinite-State Systems (INFINITY '13) EPTCS 140, 2014, pp. 70-84, doi: 10.4204 / EPTCS.140.5Synthesis of Parametric Programs using Genetic Programming and Model CheckingGal Katz Doron Peled Department of Computer Science, Bar Ilan UniversityRamat Gan 52900, IsraelFormal Methods apply algorithms based on mathematical principles to improve the reliability of systems. It would be only natural to try to move from verification, model verification or testing of a system based on its formal specification to its automatic construction. Classical algorithmic synthesis theory provides interesting algorithms, but also alarmingly high complexity and indecisiveness of the results. The use of genetic programming, in combination of model verification and testing, provides a powerful modern-day sequencing solution that does not require multiple converting and synthesis to complete."}, {"heading": "1 Introduction", "text": "This year, it has come to the point that it has never come as far as it has this year."}, {"heading": "2 Genetic Programming Based on Model Checking", "text": "We present in [8, 9, 10, 11, 12] a framework that combines genetic programming and model verification. (This enables the automatic synthesis of code for certain problems. The framework that we propose is presented in Figure 1. \u2022 The formal specification of the problem, as well as the required candidates and constraints on the structure of the desired solutions are provided by the user. \u2022 A verifier that analyzes the generated programs and provides useful information about their correctness. \u2022 This can be a model checker that often provides more information than yes / no (and counter example) or a SAT solution process. The synthesis process goes through the following steps: 1. The user GP engine with the desired architecture and a set of programs that may be generated."}, {"heading": "3 Example: Mutual Exclusion Algorithms", "text": "In this problem, which was first described and solved by Dijkstra [5], two or more processes are repeatedly executed in an infinite loop: Non Critical SectionPre ProtocolCritical SectionPost ProtocolPost ProtocolPost ProtocolThese parts are fixed and, together with the number of processes involved (two) and the number of variables allowed, consist of the architecture provided to our genetic programming tool, along with the time specification. The Non Critical Section Part represents the part of the process on which it does not require access to the common resource. A process can make a non-deterministic choice between staying in that part or merging into the fixed part."}, {"heading": "4 Synthesizing Parametric Programs", "text": "Our experience with genetic programming quickly encounters a difficulty arising from the limited power of model verification: there are few interesting fixed state programs that can also be fully defined with purely temporal logic. Indeed, most programming problems are parametric, for example, the number of processes that are each captured with the same code, and the number of algorithms that relate to a particular property. Consider the mutual exclusion for a parametric number of processes, for example, the number of processes and the values that are to be sorted."}, {"heading": "5 Correcting Erroneous Program", "text": "Our method is not limited to finding a new program that meets the given specifications. In fact, we can start with the code of an existing program instead of a completely random population and try to improve or correct it. To improve the code, our fitness standards may include some architectural assessments; then the initial program may be found worse than some later generated candidates. If the program we start with is flawed, then it would not get a very high fitness value by not meeting some of the amenities. In [11] we approached the ambitious problem of correcting a known protocol for obtaining interaction called \u03b1-core [17]. The algorithm allows the synchronization of multiple parties for multiple processes by not functioning in a system that enables non-deterministic decisions that make it challenging, as processes that may consider a possible interaction decide to be involved in another interaction. The algorithm uses asynchronous messaging processes to select the interactions involved through the interaction."}, {"heading": "6 A Tool for Genetic Programming Based on Model Checking", "text": "Depending on these settings, the tool can be used for several purposes: \u2022 If all parts are set as static, the tool will simply execute the advanced model verification algorithm on the custom program and return its detailed results. \u2022 If you set the init process as static and all or some of the other processes as dynamic, the tool will be asked to synthesize code according to the specified architecture, which can be used to synthesize programs from scratch, to synthesize only some missing parts of a given subprogram, or to try to correct or improve a complete program. \u2022 If you set the init process as dynamic and all other processes as static, it will be used in attempting to falsify a given parametric program by looking for a configuration that violates its specification (see [11]). \u2022 If both the init process and program processes are set as dynamic, the program will be used as a tool more dynamically parameterized for the different synthesis."}, {"heading": "7 Replacing Model Checking by SAT Solving", "text": "In fact, it is the case that most people are able to survive themselves. (...) It is not as if they were able to survive themselves. (...) It is not as if they were able to survive themselves. (...) It is as if they were able to survive themselves. (...) It is as if they were able to survive themselves. (...) \"It is as if they were able to survive themselves. (...)\" \"It is as if they were able to survive themselves. (...)\" (...) \"(...)\" (((()) ((()) ((())) ((()) (()) (()) (()) (()) (()) (()) (()) (()) (()) () ()) (()) (()) ()) (()) () () () ()) () () () () () () () () () () () ()) () () () () ()) () () () () () () () () () () () () () () ()) () () () () () () () () ()) () () () () () () () () () () () ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (() () () (() () () (() () () () (() (() () () (() () () (() ((() () (() () () (() () () () (() (() () () (() () (((() () () () () (() (() () () ((() ((((()))) ((("}, {"heading": "8 Conclusions", "text": "We proposed the use of a methodology and a tool that performs the synthesis of programs based on genetic programming guided by model verification. Code mutations are at the core of genetic programming (crossover is also widely used, but we have not implemented it), our method can be used for \u2022 synthesis of correction-by-design programs, \u2022 detection of errors in protocols with complicated architectures, \u2022 automatic correction of faulty codes in relation to a given specification, and \u2022 improvement of the code, for example, to work more efficiently. We demonstrated our method on the classic problem of mutual exclusion, and were able to find existing solutions and new solutions. In general, the verification of parametric systems is not decisive, and in the few methods that promise termination, fairly strict limitations are required, as is code synthesis, which we correct on the basis of SM and counter-operations."}], "references": [{"title": "Limits for Automatic Verification of Finite-State Concurrent Systems", "author": ["Krzysztof R. Apt", "Dexter Kozen"], "venue": "Inf. Process. Lett", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1986}, {"title": "Genetic Programming \u2013 An Introduction; On the Automatic Evolution of Computer Programs and its Applications (3rd edition)", "author": ["W. Banzhaf", "P. Nordin", "R.E. Keller", "F.D. Francone"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2001}, {"title": "Automatic discovery of mutual exclusion algorithms", "author": ["Yoah Bar-David", "Gadi Taubenfeld"], "venue": "In: PODC,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Solution of a problem in concurrent programming control", "author": ["Edsger W. Dijkstra"], "venue": "Commun. ACM 8(9),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1965}, {"title": "Reasoning about Rings", "author": ["E. Allen Emerson", "Kedar S. Namjoshi"], "venue": "POPL, pp", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1995}, {"title": "Genetic Programming and Model Checking: Synthesizing New Mutual Exclusion Algorithms", "author": ["Gal Katz", "Doron Peled"], "venue": "ATVA, LNCS", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "Model Checking-Based Genetic Programming with an Application to Mutual Exclusion", "author": ["Gal Katz", "Doron Peled"], "venue": "In: TACAS,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "Synthesizing Solutions to the Leader Election Problem using Model Checking and Genetic Programming", "author": ["Gal Katz", "Doron Peled"], "venue": "In: HVC,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Code Mutation in Verification and Automatic Code Correction", "author": ["Gal Katz", "Doron Peled"], "venue": "In: TACAS,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "MCGP: A Software Synthesis Tool Based on Model Checking and Genetic Programming", "author": ["Gal Katz", "Doron Peled"], "venue": "ATVA, pp. 359\u2013364,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Arbitration Without Common Modifiable Variables", "author": ["Joep L.W. Kessels"], "venue": "Acta Inf", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1982}, {"title": "Discriminative Model Checking", "author": ["Peter Niebert", "Doron Peled", "Amir Pnueli"], "venue": "CAV, LNCS 5123,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Software Reliability Methods. Springer, doi:10.1007/978-1-4757-3540-6", "author": ["Doron Peled"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2001}, {"title": "An order-based algorithm for implementing multiparty synchronization", "author": ["Jose Antonio Perez", "Rafael Corchuelo", "Miguel Toro"], "venue": "Concurrency - Practice and Experience", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2004}, {"title": "Economical Solutions to the Critical Section Problem in a Distributed System", "author": ["Peterson", "Fischer"], "venue": "STOC: ACM Symposium on Theory of Computing (STOC),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1977}, {"title": "On the Synthesis of a Reactive Module", "author": ["Amir Pnueli", "Roni Rosner"], "venue": "In: POPL,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1989}, {"title": "Distributed Reactive Systems Are Hard to Synthesize", "author": ["Amir Pnueli", "Roni Rosner"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1990}, {"title": "Deriving a Scalable Algorithm for Mutual Exclusion", "author": ["Yih-Kuen Tsay"], "venue": "In: DISC,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1998}, {"title": "Hacker\u2019s Delight", "author": ["Henry S. Warren"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2002}], "referenceMentions": [{"referenceID": 12, "context": "Formal methods [16] assist software and hardware developers in enhancing the reliability of systems.", "startOffset": 15, "endOffset": 19}, {"referenceID": 15, "context": "However, high complexity [19] and even undecidability [20] appear in some main classical automatic synthesis problems.", "startOffset": 25, "endOffset": 29}, {"referenceID": 16, "context": "However, high complexity [19] and even undecidability [20] appear in some main classical automatic synthesis problems.", "startOffset": 54, "endOffset": 58}, {"referenceID": 2, "context": "This was applied in Taubenfeld [3] to find mutual exclusion algorithms.", "startOffset": 31, "endOffset": 34}, {"referenceID": 5, "context": "We present in [8, 9, 10, 11, 12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.", "startOffset": 14, "endOffset": 32}, {"referenceID": 6, "context": "We present in [8, 9, 10, 11, 12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.", "startOffset": 14, "endOffset": 32}, {"referenceID": 7, "context": "We present in [8, 9, 10, 11, 12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.", "startOffset": 14, "endOffset": 32}, {"referenceID": 8, "context": "We present in [8, 9, 10, 11, 12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.", "startOffset": 14, "endOffset": 32}, {"referenceID": 9, "context": "We present in [8, 9, 10, 11, 12] a framework combining genetic programming and model checking, which allows to automatically synthesize code for given problems.", "startOffset": 14, "endOffset": 32}, {"referenceID": 1, "context": "while (A[2] != 0) A[me] = 1", "startOffset": 8, "endOffset": 11}, {"referenceID": 1, "context": "While traditional GP is heavily based on crossover, it is quite a controversial operation (see [2], for example).", "startOffset": 95, "endOffset": 98}, {"referenceID": 6, "context": "We provided several methods for generating the various fitness levels: \u2022 Using Streett Automata, and a strongly-connected component analysis of the program graph [9].", "startOffset": 162, "endOffset": 165}, {"referenceID": 5, "context": "\u2022 Enhanced model checking logic and algorithm [8, 15].", "startOffset": 46, "endOffset": 53}, {"referenceID": 11, "context": "\u2022 Enhanced model checking logic and algorithm [8, 15].", "startOffset": 46, "endOffset": 53}, {"referenceID": 3, "context": "In this problem, first described and solved by Dijkstra [5], two or more processes are repeatedly running critical and non-critical sections of a program.", "startOffset": 56, "endOffset": 59}, {"referenceID": 3, "context": "1 2 Simple Deadlock Freedom 1,2,3,4,5,6 One bit protocol [4] 2 3 Simple Starvation Freedom 1,2,3,4,5,7,8 Dekker [5] 3 3 Complex Starvation Freedom 1,2,3,4,5,7,8 Peterson [18]", "startOffset": 112, "endOffset": 115}, {"referenceID": 14, "context": "1 2 Simple Deadlock Freedom 1,2,3,4,5,6 One bit protocol [4] 2 3 Simple Starvation Freedom 1,2,3,4,5,7,8 Dekker [5] 3 3 Complex Starvation Freedom 1,2,3,4,5,7,8 Peterson [18]", "startOffset": 170, "endOffset": 174}, {"referenceID": 3, "context": "The famous Dekker\u2019s algorithm [5] uses two bits to announce that they want to enter the critical section, and the third bit is used to set turns between the two processes.", "startOffset": 30, "endOffset": 33}, {"referenceID": 1, "context": "While (A[other] == 1) While (A[other] == 1) While (A[0] != other) While (A[2] == me)", "startOffset": 74, "endOffset": 77}, {"referenceID": 1, "context": "A[me] = 0 A[2] = me A[me] = 0", "startOffset": 11, "endOffset": 14}, {"referenceID": 17, "context": "Inspired by algorithms developed by Tsay [21] and by Kessels [13], our next goal was to start from an existing algorithm, and by adding more constraints and building blocks, try to evolve into more advanced algorithms.", "startOffset": 41, "endOffset": 45}, {"referenceID": 10, "context": "Inspired by algorithms developed by Tsay [21] and by Kessels [13], our next goal was to start from an existing algorithm, and by adding more constraints and building blocks, try to evolve into more advanced algorithms.", "startOffset": 61, "endOffset": 65}, {"referenceID": 1, "context": "Note that the variable turn is in fact A[2] and is renamed here turn to accord with classical presentation of the extra global bit that does not belong to a specific process.", "startOffset": 40, "endOffset": 43}, {"referenceID": 17, "context": "Tsay [21] used a similar refinement, but his algorithm needs an additional if statement, which is not used in our algorithm.", "startOffset": 5, "endOffset": 9}, {"referenceID": 1, "context": "turn = not0(A[other]) While (A[2] != me);", "startOffset": 30, "endOffset": 33}, {"referenceID": 0, "context": "B[me] = not1(B[other]) While (A[other] == 1 and B[0] == not1(B[1]));", "startOffset": 62, "endOffset": 65}, {"referenceID": 0, "context": "Model checking is undecidable for parametric families of programs (say, with n processes, each with the same code, initialized with different parameters) even for a fixed property [1].", "startOffset": 180, "endOffset": 183}, {"referenceID": 4, "context": "In fact, there are several works on particular cases where one can calculate the parameter size that guarantees that if all the smaller instances are correct, then any instance is correct [6].", "startOffset": 188, "endOffset": 191}, {"referenceID": 7, "context": "A solution for the leader election, albeit not the most optimal one, was obtained using our genetic programming methods [10].", "startOffset": 120, "endOffset": 124}, {"referenceID": 8, "context": "In [11] we approached the ambitious problem of correcting a known protocol for obtaining interprocess interaction called \u03b1-core [17].", "startOffset": 3, "endOffset": 7}, {"referenceID": 13, "context": "In [11] we approached the ambitious problem of correcting a known protocol for obtaining interprocess interaction called \u03b1-core [17].", "startOffset": 128, "endOffset": 132}, {"referenceID": 0, "context": "Recall that model checking of parametric programs is undecidable in general [1].", "startOffset": 76, "endOffset": 79}, {"referenceID": 9, "context": "We constructed a tool, MCGP [12], that implements our ideas about model checking based genetic programming.", "startOffset": 28, "endOffset": 32}, {"referenceID": 8, "context": "\u2022 Setting the init process as dynamic and all other processes as static, is used when trying to falsify a given parametric program by searching for a configuration that violates its specification (see [11]).", "startOffset": 201, "endOffset": 205}, {"referenceID": 18, "context": "Our work is inspired by [7], in which a set of short but ingenious and nontrivial programs, selected from the book Hacker\u2019s Delight [22], were successfully synthesized.", "startOffset": 132, "endOffset": 136}, {"referenceID": 18, "context": "As an example for using our basic method, we tried first to synthesize one of the simplest programs from [22], which is required to output 0 in the variable R if and only if its input X equals 2n \u22121 for some non-negative n.", "startOffset": 105, "endOffset": 109}, {"referenceID": 18, "context": "Finally, the more ingenious program (c) was generated, and verified to be a correct solution (identical to the one presented in [22]).", "startOffset": 128, "endOffset": 132}], "year": 2014, "abstractText": "Formal methods apply algorithms based on mathematical principles to enhance the reliability of systems. It would only be natural to try to progress from verification, model checking or testing a system against its formal specification into constructing it automatically. Classical algorithmic synthesis theory provides interesting algorithms but also alarming high complexity and undecidability results. The use of genetic programming, in combination of model checking and testing, provides a powerful heuristic to synthesize programs. The method is not completely automatic, as it is fine tuned by a user that sets up the specification and parameters. It also does not guarantee to always succeed and converge towards a solution that satisfies all the required properties. However, we applied it successfully on quite nontrivial examples and managed to find solutions to hard programming challenges, as well as to improve and to correct code. We describe here several versions of our method for synthesizing sequential and concurrent systems.", "creator": "LaTeX with hyperref package"}}}