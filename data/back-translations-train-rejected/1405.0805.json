{"id": "1405.0805", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-May-2014", "title": "On the Relative Expressiveness of Argumentation Frameworks, Normal Logic Programs and Abstract Dialectical Frameworks", "abstract": "We analyse the expressiveness of the two-valued semantics of abstract argumentation frameworks, normal logic programs and abstract dialectical frameworks. By expressiveness we mean the ability to encode a desired set of two-valued interpretations over a given propositional signature using only atoms from that signature. While the computational complexity of the two-valued model existence problem for all these languages is (almost) the same, we show that the languages form a neat hierarchy with respect to their expressiveness.", "histories": [["v1", "Mon, 5 May 2014 07:39:50 GMT  (30kb,D)", "http://arxiv.org/abs/1405.0805v1", "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"]], "COMMENTS": "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["hannes strass"], "accepted": false, "id": "1405.0805"}, "pdf": {"name": "1405.0805.pdf", "metadata": {"source": "CRF", "title": "On the Relative Expressiveness of Argumentation Frameworks, Normal Logic Programs and Abstract Dialectical Frameworks", "authors": ["Hannes Strass"], "emails": [], "sections": [{"heading": "Introduction", "text": "Most of them are able to survive themselves, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own, most of them are able to survive on their own."}, {"heading": "Background", "text": "We assume that in the face of a finite proposition A of the atoms (statements, arguments), the vocabulary is capable of realization.1 This knowledge, which is interpreted via A, is then a certain amount of L; a (bivalent) semantics for L is an illustration of the two truth values: L \u2192 22A, which assigns sentences of bivalent models to the language elements. (So A is implicit in L.) Strictly speaking, a bivalent interpretation is an illustration from the proposition of the atoms into the two truth values true and false, but for technical ease we represent bivalent interpretations through the propositions containing the atoms that are true.For a language L, we denote the area of semantics \u03c3 by (L). Intuitively, QS (L) is the set of models that language L can express, with any knowledge base on vocabulary A whatsoever. For example, for L = PL, propositional logic and QS = mod, the usual model, we have semantics."}, {"heading": "Logic Programs", "text": "For a vocabulary of A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A like A A like A like A A like A like A A like A A A like A A like A A A like A A A A A A like A A A A like A A A like A like A A A like A A A like A A A A like A A A A A A like A A A like A A A A A A like A A like A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A"}, {"heading": "Argumentation Frameworks", "text": "Dung (1995) introduced argumentation frameworks as pairs F = (A, R), where A is a set and R A \u00b7 A is a relationship. The intended reading of an AF F is that the elements of A are arguments whose internal structure is abstracted away. The only information about the arguments is given by the relationship R, which encodes an attack term: A pair (a, b) \u00b2 R expresses this argument in a certain sense as an attack argument b. The purpose of semantics for argumentation frameworks is to determine argumentation groups (so-called extensions) that are acceptable according to various standards. For a given extension S A, the arguments in S are considered accepted, those attacked by some arguments in S are rejected, and all others are not, their status is undecided. We will only be interested in so-called stable extensions, S sets arguments that do not attack each other and do not attack all arguments in the group. In stable extensions, each argument is either accepted or rejected, so that the semantics is ambiguous."}, {"heading": "Abstract Dialectical Frameworks", "text": "In fact, we will be able to move to another world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world, in which we are able to move to a world in which we are in which we are in which we are in which we are in which we are in which we are in which we are in which we are in which we live."}, {"heading": "Translations between the formalisms", "text": "From AFs to BADFs Brewka and Woltran (2010) it was shown how to translate AFs into ADFs if they are translated into ADFs: For an AF F = (A, R), the ADF in F is translated as D (F) = (A, R, C) with C = (A) a (A) a (B) a (A) a (A) a (A) a (A) a (A) a (A) a (A) a) a (A) a (A) a (A) a (A) a (A) a (A) a) a (A) A (A) A (A) A (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A (A) (A) (A (A) (A (A) (A) (A) (A (A) (A) (A) (A) (A) (A (A (A) (A) (A (A) (A) (A (A) (A (A) (A (A) (A) (A)"}, {"heading": "Relative Expressiveness", "text": "We will now analyze and compare the relative meaningfulness of reasoning frameworks - AFs -, (bipolar) abstract dialectical frameworks - (B) ADFs -, normal logic programs - LPs - and propositional logic - PL. We will first look at the different families of semantics - supported and stable models - in isolation and then combine the two. For the languages L-ADF, LP}, which have both supported and stable semantics, we will look at semantics via a highscript as in Definition 1. For AFs, we will only look at the stable extension semantics, as this is (so far) the only bivalent semantics for AFs. For propositional logic PL, we will look at the usual model semantics. With the syntactic translations we reviewed in the previous section, we currently have the following relationships. For the supported semantics AF \u2264 e BADFsu \u2264 e < Psu DFAF = AF AF-Pilts, and PL-Pilts."}, {"heading": "Supported semantics", "text": "However, it is not yet clear whether there is a model at all in which we have a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model for a model."}, {"heading": "Stable semantics", "text": "In fact, it is a matter of a mere distraction, which is a matter of a mere distraction. (...) It is a matter of a mere distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a distraction. (...) It is a matter of a matter. (...) It is a matter of a matter. (...) It is a matter of a matter. (...) It is a matter of a matter. (...) It is a matter of a matter."}, {"heading": "Supported vs. stable semantics", "text": "Now we put together the supported and stable images. By the proof of Theorem 8 we can read that for the canonical realization of DstX of an antiquity X the supported and stable semantics match, so su (DstX) = st (D st X) = X. With this observation even bipolar ADFs under the supported semantics can realize any arbitrary antiquity, and we have this: Proposition 10. BADFst \u2264 e BADFsuAs we have seen in Proposition 6, there are bipolar ADFs with supported model sets that are not labels. Hence the following result. Conclusion 11. BADFst < e BADFsuThis result allows us to close the last gap and assemble the overall picture in Figure 1 below."}, {"heading": "Discussion", "text": "In fact, most of us are able to play by the rules we have set ourselves in order to fulfil them."}, {"heading": "Appendix", "text": "Lemma 12. X is bipolar feasible if and only if the formula \u03c6X from theorem 3 is satisfactory. Proof \"if\": Let I'P be a model for \u03c6X. For each a'A we define an acceptance condition as follows: for M'A. It remains to be shown that every M'A is a model for DsuX if and only if M'X. \"if\": Let M'X. We must show that M is a model for DsuX. Let us consider every possible A'M. Since I am a model for X, we must show that every M is a model for M and thus by definition M'X."}], "references": [{"title": "Compact argumentation frameworks", "author": ["R. Baumann", "W. Dvo\u0159\u00e1k", "T. Linsbichler", "H. Strass", "S. Woltran"], "venue": "Konieczny, S., and Tompits, H., eds., Proceedings of the Fifteenth International Workshop on Non-Monotonic Reasoning (NMR).", "citeRegEx": "Baumann et al\\.,? 2014", "shortCiteRegEx": "Baumann et al\\.", "year": 2014}, {"title": "Negation by default and unstratifiable logic programs", "author": ["N. Bidoit", "C. Froidevaux"], "venue": "Theoretical Computer Science 78(1):85\u2013112.", "citeRegEx": "Bidoit and Froidevaux,? 1991", "shortCiteRegEx": "Bidoit and Froidevaux", "year": 1991}, {"title": "Abstract Dialectical Frameworks", "author": ["G. Brewka", "S. Woltran"], "venue": "Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning (KR), 102\u2013111.", "citeRegEx": "Brewka and Woltran,? 2010", "shortCiteRegEx": "Brewka and Woltran", "year": 2010}, {"title": "Abstract Dialectical Frameworks Revisited", "author": ["G. Brewka", "S. Ellmauthaler", "H. Strass", "J.P. Wallner", "S. Woltran"], "venue": "Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence (IJCAI), 803\u2013 809. IJCAI/AAAI.", "citeRegEx": "Brewka et al\\.,? 2013", "shortCiteRegEx": "Brewka et al\\.", "year": 2013}, {"title": "Relating the Semantics of Abstract Dialectical Frameworks and Standard AFs", "author": ["G. Brewka", "P.E. Dunne", "S. Woltran"], "venue": "Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence (IJCAI), 780\u2013785. IJCAI/AAAI.", "citeRegEx": "Brewka et al\\.,? 2011", "shortCiteRegEx": "Brewka et al\\.", "year": 2011}, {"title": "Generalizations of Dung frameworks and their role in formal argumentation", "author": ["G. Brewka", "S. Polberg", "S. Woltran"], "venue": "IEEE Intelligent Systems PP(99). Special Issue on Representation and Reasoning. In press.", "citeRegEx": "Brewka et al\\.,? 2013", "shortCiteRegEx": "Brewka et al\\.", "year": 2013}, {"title": "Negation as Failure", "author": ["K.L. Clark"], "venue": "Gallaire, H., and Minker, J., eds., Logic and Data Bases, 293\u2013322. Plenum Press.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "On the revision of argumentation systems: Minimal change of arguments status", "author": ["S. Coste-Marquis", "S. Konieczny", "J.-G. Mailly", "P. Marquis"], "venue": "Proceedings of TAFA.", "citeRegEx": "Coste.Marquis et al\\.,? 2013", "shortCiteRegEx": "Coste.Marquis et al\\.", "year": 2013}, {"title": "A Knowledge Compilation Map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research (JAIR) 17:229\u2013264.", "citeRegEx": "Darwiche and Marquis,? 2002", "shortCiteRegEx": "Darwiche and Marquis", "year": 2002}, {"title": "On the computational complexity of assumption-based argumentation for default reasoning", "author": ["Y. Dimopoulos", "B. Nebel", "F. Toni"], "venue": "Artificial Intelligence 141(1/2):57\u201378.", "citeRegEx": "Dimopoulos et al\\.,? 2002", "shortCiteRegEx": "Dimopoulos et al\\.", "year": 2002}, {"title": "On the Acceptability of Arguments and its Fundamental Role in Nonmonotonic Reasoning, Logic Programming and n-Person Games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence 77:321\u2013358.", "citeRegEx": "Dung,? 1995", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "Characteristics of Multiple Viewpoints in Abstract Argumentation", "author": ["P.E. Dunne", "W. Dvo\u0159\u00e1k", "T. Linsbichler", "S. Woltran"], "venue": "Proceedings of the Fourteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR). To appear.", "citeRegEx": "Dunne et al\\.,? 2014", "shortCiteRegEx": "Dunne et al\\.", "year": 2014}, {"title": "Model-based recasting in answer-set programming", "author": ["T. Eiter", "M. Fink", "J. P\u00fchrer", "H. Tompits", "S. Woltran"], "venue": "Journal of Applied Non-Classical Logics 23(1\u2013 2):75\u2013104.", "citeRegEx": "Eiter et al\\.,? 2013", "shortCiteRegEx": "Eiter et al\\.", "year": 2013}, {"title": "Potassco: The Potsdam Answer Set Solving Collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": "AI Communications 24(2):105\u2013124. Available at http://potassco.sourceforge.net.", "citeRegEx": "Gebser et al\\.,? 2011", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "The Stable Model Semantics for Logic Programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the International Conference on Logic Programming (ICLP), 1070\u20131080. The MIT Press.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "The comparative linguistics of knowledge representation", "author": ["G. Gogic", "H. Kautz", "C. Papadimitriou", "B. Selman"], "venue": "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI), 862\u2013 869. Morgan Kaufmann.", "citeRegEx": "Gogic et al\\.,? 1995", "shortCiteRegEx": "Gogic et al\\.", "year": 1995}, {"title": "Why are there so many loop formulas", "author": ["V. Lifschitz", "A. Razborov"], "venue": "ACM Transactions on Computational Logic 7(2):261\u2013268", "citeRegEx": "Lifschitz and Razborov,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz and Razborov", "year": 2006}, {"title": "ASSAT: Computing Answer Sets of a Logic Program by SAT Solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157(1-2):115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Autoepistemic logic", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "Journal of the ACM 38(3):587\u2013618.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1991", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1991}, {"title": "Inferring acceptable arguments with answer set programming", "author": ["M. Osorio", "C. Zepeda", "J.C. Nieves", "U. Cort\u00e9s"], "venue": "Proceedings of the Sixth Mexican International Conference on Computer Science (ENC), 198\u2013205. IEEE Computer Society.", "citeRegEx": "Osorio et al\\.,? 2005", "shortCiteRegEx": "Osorio et al\\.", "year": 2005}, {"title": "Analyzing the Computational Complexity of Abstract Dialectical Frameworks via Approximation Fixpoint Theory", "author": ["H. Strass", "J.P. Wallner"], "venue": "Proceedings of the Fourteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR). To ap-", "citeRegEx": "Strass and Wallner,? 2014", "shortCiteRegEx": "Strass and Wallner", "year": 2014}, {"title": "Approximating operators and semantics for abstract dialectical frameworks", "author": ["H. Strass"], "venue": "Artificial Intelligence 205:39\u201370.", "citeRegEx": "Strass,? 2013", "shortCiteRegEx": "Strass", "year": 2013}], "referenceMentions": [{"referenceID": 10, "context": "In this paper, we use such an alternative notion and perform an exemplary study of the relative expressiveness of several different knowledge representation languages: argumentation frameworks (AFs) (Dung, 1995), normal logic programs (LPs), abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010) and propositional logic.", "startOffset": 199, "endOffset": 211}, {"referenceID": 2, "context": "In this paper, we use such an alternative notion and perform an exemplary study of the relative expressiveness of several different knowledge representation languages: argumentation frameworks (AFs) (Dung, 1995), normal logic programs (LPs), abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010) and propositional logic.", "startOffset": 281, "endOffset": 307}, {"referenceID": 1, "context": "\u2022 for AFs, deciding stable extension existence is NPcomplete (Dimopoulos, Nebel, and Toni, 2002); \u2022 for LPs, deciding the existence of supported/stable models is NP-complete (Bidoit and Froidevaux, 1991; Marek and Truszczy\u0144ski, 1991);", "startOffset": 174, "endOffset": 233}, {"referenceID": 18, "context": "\u2022 for AFs, deciding stable extension existence is NPcomplete (Dimopoulos, Nebel, and Toni, 2002); \u2022 for LPs, deciding the existence of supported/stable models is NP-complete (Bidoit and Froidevaux, 1991; Marek and Truszczy\u0144ski, 1991);", "startOffset": 174, "endOffset": 233}, {"referenceID": 3, "context": "\u2022 for ADFs, deciding the existence of models is NPcomplete (Brewka et al., 2013), deciding the existence of stable models is \u03a32 -complete for general ADFs (Brewka et al.", "startOffset": 59, "endOffset": 80}, {"referenceID": 3, "context": ", 2013), deciding the existence of stable models is \u03a32 -complete for general ADFs (Brewka et al., 2013) and NP-complete for the subclass of bipolar ADFs (Strass and Wallner, 2014);", "startOffset": 82, "endOffset": 103}, {"referenceID": 20, "context": ", 2013) and NP-complete for the subclass of bipolar ADFs (Strass and Wallner, 2014);", "startOffset": 57, "endOffset": 83}, {"referenceID": 15, "context": "In view of these almost identical complexities, we use an alternative measure of the expressiveness of a knowledge representation language L: \u201cGiven a set of two-valued interpretations, is there a knowledge base in L that has this exact model set?\u201d This notion lends itself straightforwardly to compare different formalisms (Gogic et al., 1995):", "startOffset": 324, "endOffset": 344}, {"referenceID": 7, "context": "For example, in a recent approach to revising argumentation frameworks (Coste-Marquis et al., 2013), the authors avoid this problem by assuming to produce a collection of AFs whose model sets in union produce the desired model set.", "startOffset": 71, "endOffset": 99}, {"referenceID": 10, "context": "The latter was recently studied for argumentation frameworks by Dunne et al. (2014). They allow to extend the vocabulary in order to realise a given model set, as long as the new vocabulary elements are evaluated to false in all models.", "startOffset": 64, "endOffset": 84}, {"referenceID": 10, "context": "The latter was recently studied for argumentation frameworks by Dunne et al. (2014). They allow to extend the vocabulary in order to realise a given model set, as long as the new vocabulary elements are evaluated to false in all models. For several semantics of AFs, Dunne et al. found necessary (and sufficient) conditions for realisability. While their sufficient conditions are not applicable to our setting, they discovered a necessary condition for realisability with stable extension semantics that we will make use of in this paper. There has also been work on translating ADFs into AFs for the ADF model and AF stable extension semantics (Brewka, Dunne, and Woltran, 2011), however this translation introduces additional arguments and is therefore not compact. The gain that is achieved by our results is not only that of increased clarity about fundamental properties of these knowledge representation languages \u2013 What can these formalisms express, actually? \u2013 but has several further applications. As Dunne et al. (2014) remarked, a major application is in constructing knowledge bases with the aim of encoding a certain model set.", "startOffset": 64, "endOffset": 1031}, {"referenceID": 7, "context": "For example, in a recent approach to revising argumentation frameworks (Coste-Marquis et al., 2013), the authors avoid this problem by assuming to produce a collection of AFs whose model sets in union produce the desired model set. While the work of Dunne et al. (2014) showed that this is indeed necessary in the case of AFs and stable extension semantics (that is, there are model sets that a single AF just cannot express), our work shows that for ADFs under the model semantics, a single knowledge base (ADF) is always enough to realise any given model set.", "startOffset": 72, "endOffset": 270}, {"referenceID": 6, "context": "Clark (1978) gave the first declarative semantics for normal logic programs via a translation to classical logic that will be recalled shortly.", "startOffset": 0, "endOffset": 13}, {"referenceID": 6, "context": "Clark (1978) gave the first declarative semantics for normal logic programs via a translation to classical logic that will be recalled shortly. This leads to the supported model semantics for logic programs: A rule a\u2190 B \u2208 P is active in a set M \u2286 A iff B \u2286M and B\u2212 \u2229M = \u2205 imply a \u2208M . M is a supported model for P iff M = {a \u2208 A | a\u2190 B \u2208 P is active in M}. For a logic program P we denote the set of its supported models by su(P ). The intuition behind this semantics is that everything that is true in a model has some kind of support. However, this support might be cyclic self-support. For instance, the logic program {a\u2190 a} has two supported models, \u2205 and {a}, where the latter is undesired in many application domains. As an alternative, Gelfond and Lifschitz (1988) proposed the stable model semantics, a declarative semantics for negation as failure that does not allow selfsupport: M \u2286 A is a stable model for P iff M is the\u2286-least supported model of P , where the definite program P is obtained from P by (1) eliminating each rule whose body contains a literal not a with a \u2208M , and (2) deleting all literals of the form not a from the bodies of the remaining rules.", "startOffset": 0, "endOffset": 772}, {"referenceID": 2, "context": "Brewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A,L,C) is bipolar iff all links in L are supporting or attacking (or both).", "startOffset": 0, "endOffset": 26}, {"referenceID": 3, "context": "The definition of stable models is inspired by logic programming and slightly more complicated (Brewka et al., 2013).", "startOffset": 95, "endOffset": 116}, {"referenceID": 2, "context": "From AFs to BADFs Brewka and Woltran (2010) showed how to translate AFs into ADFs: For an AF F = (A,R), define the ADF associated to F as D(F ) = (A,R,C) with", "startOffset": 18, "endOffset": 44}, {"referenceID": 2, "context": "Brewka and Woltran (2010) proved that this translation is faithful for the AF stable extension and ADF model semantics (Proposition 1).", "startOffset": 0, "endOffset": 26}, {"referenceID": 2, "context": "Brewka and Woltran (2010) proved that this translation is faithful for the AF stable extension and ADF model semantics (Proposition 1). Brewka et al. (2013) later proved the same for the AF stable extension and ADF stable model semantics (Theorem 4).", "startOffset": 0, "endOffset": 157}, {"referenceID": 2, "context": "From ADFs to PL Brewka and Woltran (2010) also showed that ADFs under supported model semantics can be faithfully translated into propositional logic: When acceptance conditions of statements a \u2208 A are represented by propositional formulas \u03c6a, then the supported models of an ADF D over A are given by the classical models of the formula set {a\u2194 \u03c6a | a \u2208 A}.", "startOffset": 16, "endOffset": 42}, {"referenceID": 21, "context": "From ADFs to LPs In recent work we showed that ADFs can be faithfully translated into normal logic programs (Strass, 2013).", "startOffset": 108, "endOffset": 122}, {"referenceID": 21, "context": "14 in (Strass, 2013) that this translation preserves the supported model semantics.", "startOffset": 6, "endOffset": 20}, {"referenceID": 19, "context": "From AFs to LPs The translation chain from AFs to ADFs to LPs is compact, and faithful for AF stable semantics and LP stable semantics (Osorio et al., 2005), and AF stable semantics and LP supported semantics (Strass, 2013).", "startOffset": 135, "endOffset": 156}, {"referenceID": 21, "context": ", 2005), and AF stable semantics and LP supported semantics (Strass, 2013).", "startOffset": 60, "endOffset": 74}, {"referenceID": 6, "context": "From LPs to PL It is well-known that normal logic programs under supported model semantics can be translated to propositional logic (Clark, 1978).", "startOffset": 132, "endOffset": 145}, {"referenceID": 17, "context": "For the stable model semantics, additional formulas have to be added, but the extended translation works all the same (Lin and Zhao, 2004).", "startOffset": 118, "endOffset": 138}, {"referenceID": 2, "context": "From LPs to ADFs The Clark completion of a normal logic program directly yields an equivalent ADF over the same signature (Brewka and Woltran, 2010).", "startOffset": 122, "endOffset": 148}, {"referenceID": 21, "context": "16 in (Strass, 2013).", "startOffset": 6, "endOffset": 20}, {"referenceID": 13, "context": "We have implemented the translation of Theorem 3 and used the solver clasp (Gebser et al., 2011) to verify that \u03c6X1 is unsatisfiable.", "startOffset": 75, "endOffset": 96}, {"referenceID": 11, "context": "Example 2 ((Dunne et al., 2014)).", "startOffset": 11, "endOffset": 31}, {"referenceID": 11, "context": "Example 2 ((Dunne et al., 2014)). Consider the model set X2 = {{x, y} , {x, z} , {y, z}}. Dunne et al. (2014) proved that X2 is not realisable with stable AF semantics.", "startOffset": 12, "endOffset": 110}, {"referenceID": 12, "context": "The construction from the previous example model set comes from logic programming (Eiter et al., 2013) and can be generalised to realise any non-empty model set satisfying the antichain property.", "startOffset": 82, "endOffset": 102}, {"referenceID": 11, "context": "This is nontrivial in general, and for AFs it constitutes a major open problem (Dunne et al., 2014; Baumann et al., 2014).", "startOffset": 79, "endOffset": 121}, {"referenceID": 0, "context": "This is nontrivial in general, and for AFs it constitutes a major open problem (Dunne et al., 2014; Baumann et al., 2014).", "startOffset": 79, "endOffset": 121}, {"referenceID": 21, "context": "This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013).", "startOffset": 188, "endOffset": 223}, {"referenceID": 3, "context": "This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013).", "startOffset": 188, "endOffset": 223}, {"referenceID": 15, "context": "So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995).", "startOffset": 145, "endOffset": 165}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks.", "startOffset": 8, "endOffset": 508}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks. This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013). Third, there are further formalisms in abstract argumentation (Brewka, Polberg, and Woltran, 2013) whose expressiveness is by and large unexplored to the best of our knowledge. Fourth, the requirement that realisations may only use a fixed vocabulary without any additional symbols is quite restrictive. Intuitively, it should be allowed to add a reasonable number of additional atoms, for example a constant number or one that is linear in the original vocabulary. Finally, our study only considered if a language can express a model set, but not to what cost in terms of representation size. So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995). A landmark result in this direction has been obtained by Lifschitz and Razborov (2006), who have shown that logic programs (with respect to two-valued stable models) are exponentially more succinct than propositional logic.", "startOffset": 8, "endOffset": 1640}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks. This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013). Third, there are further formalisms in abstract argumentation (Brewka, Polberg, and Woltran, 2013) whose expressiveness is by and large unexplored to the best of our knowledge. Fourth, the requirement that realisations may only use a fixed vocabulary without any additional symbols is quite restrictive. Intuitively, it should be allowed to add a reasonable number of additional atoms, for example a constant number or one that is linear in the original vocabulary. Finally, our study only considered if a language can express a model set, but not to what cost in terms of representation size. So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995). A landmark result in this direction has been obtained by Lifschitz and Razborov (2006), who have shown that logic programs (with respect to two-valued stable models) are exponentially more succinct than propositional logic. That is, there are logic programs whose respective sets of stable models cannot be expressed by a propositional formula whose size is at most polynomial in the size of the logic program, unless a certain widely believed assumption of complexity theory is false. With the results of the present paper, we have laid the groundwork for a similar analysis of the other knowledge representation languages considered here, perhaps working towards a \u201cmap\u201d of these languages in the sense of Darwiche and Marquis\u2019 knowledge compilation map [2002].", "startOffset": 8, "endOffset": 2316}], "year": 2014, "abstractText": "We analyse the expressiveness of the two-valued semantics of abstract argumentation frameworks, normal logic programsargumentation frameworks, normal logic programs and abstract dialectical frameworks. By expressiveness we mean the ability to encode a desired set of two-valued interpretations over a given propositional signature using only atoms from that signature. While the computational complexity of the two-valued model existence problem for all these languages is (almost) the same, we show that the languages form a neat hierarchy with respect to their expressiveness.", "creator": "LaTeX with hyperref package"}}}