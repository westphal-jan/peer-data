{"id": "1405.3250", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2014", "title": "Understanding the Complexity of Lifted Inference and Asymmetric Weighted Model Counting", "abstract": "In this paper we study lifted inference for the Weighted First-Order Model Counting problem (WFOMC), which counts the assignments that satisfy a given sentence in first-order logic (FOL); it has applications in Statistical Relational Learning (SRL) and Probabilistic Databases (PDB). We present several results. First, we describe a lifted inference algorithm that generalizes prior approaches in SRL and PDB. Second, we provide a novel dichotomy result for a non-trivial fragment of FO CNF sentences, showing that for each sentence the WFOMC problem is either in PTIME or #P-hard in the size of the input domain; we prove that, in the first case our algorithm solves the WFOMC problem in PTIME, and in the second case it fails. Third, we present several properties of the algorithm. Finally, we discuss limitations of lifted inference for symmetric probabilistic databases (where the weights of ground literals depend only on the relation name, and not on the constants of the domain), and prove the impossibility of a dichotomy result for the complexity of probabilistic inference for the entire language FOL.", "histories": [["v1", "Tue, 13 May 2014 18:39:11 GMT  (50kb)", "https://arxiv.org/abs/1405.3250v1", null], ["v2", "Tue, 29 Jul 2014 17:31:31 GMT  (50kb)", "http://arxiv.org/abs/1405.3250v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.LO", "authors": ["eric gribkoff", "guy van den broeck", "dan suciu"], "accepted": false, "id": "1405.3250"}, "pdf": {"name": "1405.3250.pdf", "metadata": {"source": "CRF", "title": "Understanding the Complexity of Lifted Inference and Asymmetric Weighted Model Counting", "authors": ["Eric Gribkoff"], "emails": ["eagribko@cs.uw.edu", "guyvdb@cs.ucla.edu", "suciu@cs.uw.edu"], "sections": [{"heading": null, "text": "ar Xiv: 140 5.32 50v2 [cs.AI] 29 July 2 01In this paper, we examine superseded conclusions for the Weighted First-Order Model Counting Problem (WFOMC), which counts the tasks that fulfill a given sentence in Firstorder Logic (FOL); it has applications in Statistical Relational Learning (SRL) and Probabilistic Databases (PDB). We present several results. First, we describe a superseded inference algorithm that generalizes earlier approaches in SRL and PDB. Second, we provide a novel sealing result for a non-trivial fragment of FO CNF sentences, which shows that the WFOMC problem for each sentence lies in either PTIME or # P-hard in the size of the input domain; we prove that our algorithm solves the WFOMC problem in PTIME in the first case, and in the second case it fails. Third, we present multiple properties for the difficulty (the result of the difficulty)."}, {"heading": "1 INTRODUCTION", "text": "It is based on the model counting or # SAT task (Gomes et al., 2009), where the goal is to count assignments that fulfill a given logical set. WMC generalizes the model counting by assigning a weight to each assignment, and calculates the sum of its weights. WMC has many applications in AI and its importance is increasing. Most noteworthy is that it is based on the status-of-the-art probability calculations in which the algorithms for Bayesian networks (Darwiche, 2002; Sang et al., 2005; Chavira and Darwiche, 2008), relational Bayesian networks (Chavira et al., 2006) and probability programs (Fierens et al., 2011).This paper deals with weighted models of the count (WFOMC), where we summarize the weights of assignments that satisfy a set."}, {"heading": "2 BACKGROUND", "text": "We start with the introduction of the necessary background to relational logic and weighted model counting."}, {"heading": "2.1 RELATIONAL LOGIC", "text": "An atom P (t1,.., tn) consists of the predicate P / n of unity n followed by n arguments, which are either constants or logical variables {x, y,....}. An atom is an atom or its negation. A formula combines atoms with logical connectors and quantifiers. A formula is grounded if it does not contain logical variables. A proposition replaces all occurrences of x with a. Its application to formula F [a / x] is called F. A formula is a proposition if each logical variable x is enclosed by an x or x. A formula is grounded if it does not contain logical variables. A proposition is a universally quantified disjunction of words. A term is an existentially quantified conjunction of words. A CNF is a conjunction of clauses, and a DNF is a disjunction of terms universally quantified."}, {"heading": "2.2 WEIGHTED MODEL COUNTING", "text": "It is not only a question that we must ask ourselves, but also a question that we must ask ourselves in order to find an answer to the question whether there is an answer to the question, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all, whether there is an answer to the question at all."}, {"heading": "3.1 DEFINITIONS", "text": "An implicit sequence of Q is any proposition C s.t. The logical implication Q \u21d2 C holds. C is an implicit prime number, if there is no other implicit C \u2032 s.t. C. \"A connected component of a proposition C is a minimal subset of its atoms, which have no logical variables in common with the rest of the proposition. If any implicit prime C has more than one connected component, then we can write it as follows: C = D1, D2, where each prime number is a clause with different variables. If we apply distribution propositions, we write Q in the form of union CNF: Q = Q1, Q2, and Qm, where each Qi is necessarily a CNF with different variables. We check whether a separate prime implies D1, where both D1 and D2 are a clause of Q. Intuitively, this means that if we apply inclusion / exclusion to the union CNF, the resulting queries are easier."}, {"heading": "3.2 PREPROCESSING", "text": "We begin by transforming Q (and PDB) such that: 1. No constants in Q. 2. If all variables in Q are x1, x2,..., xk, then any ratio atom in Q (positive or negative) is of the form R (xi1, xi2,...) such that i1 < i2 <.... condition (1) can be forced by smashing Q w.r.t. of its variables. Condition (2) can be forced by modifying both the Q (y) query and the database in a process called ranking and described in the appendix. Here, we illustrate the order of precedence using an example. Consider the query: Q = (R (x, y). S (x, y))). (\u00ac R (x, y)."}, {"heading": "3.3 ALGORITHM DESCRIPTION", "text": "LiftR algorithm, given in Figure 1, goes recursively over the structure of the CNF query Q = Q. When it comes to ground atoms, it simply searches for their probabilities in the PDB. Otherwise, it performs the following sequence of steps. First, it tries to express Q as a union CNF. If it succeeds, and if the union can be divided into two sentences that do not share relational symbols, it applies a decomposable disjunction: Pr (Q) = 1 \u2212 (1 \u2212 Pr (Q1) (1 \u2212 Pr (Q2) (1 \u2212 Pr (Q2))). Otherwise, it applies the include / exclusion formula: Pr (Q) = \u2212 1) applies a decomposable disjunction: Pr (Q) = 1 \u2212 (1 \u2212 Pr (Q2) -Pr (1) -Pr (2)."}, {"heading": "4 MAIN COMPLEXITY RESULT", "text": "In this section, we describe our most important technical result of the work: that the algorithm is complete when it is limited to a certain class of CNF queries. We first review an earlier result to put ours into perspective. (Dalvi and Suciu, 2012) define an algorithm for monotonous DNF (called Unions Of Conjunctive Queries) that can be adapted to monotonous CNF queries; this adjustment is equivalent to LiftR, which is limited to monotonous CNF queries. (Dalvi and Suciu, 2012) prove: Theorem 4.1. If algorithm LiftR includes FAILS on a monotonous CNF query Q, then the calculation of Pr (Q) # P-hard. However, the inclusion of negations in our query language significantly increases the difficulty of analyzing query complexities. Our most important technical result of the query (paper extends Theorem 4.1 x) is a class of CNF queries with negation."}, {"heading": "5.1 NEGATIONS CAN LOWER THE COMPLEXITY", "text": "The presence of negations can reduce the complexity of a query, and our algorithm takes advantage of this. To see this, we consider the following negations: (Tweets (x), (Follows (x, y), (Follows (x, y), (Leader), (Leader), (Q), (Tweets (x), (Tweets (x), (Follows (x, y), (Follows), (Follows (x, y), (Leader), (y), (y), (Leader), (y), (Follows), (Tweets (x), (Tweets (x), (Tweets (x), (Tweets), (x), and that each follows the Leader1. Our goal is to calculate the probability Pr (Q), knowing the probability of all atoms in the domain."}, {"heading": "5.2 ASYMMETRIC WEIGHTS CAN INCREASE THE COMPLEXITY", "text": "(Van den Broeck, 2011) has proven that any query with a maximum of two logical variables per set is domain-liftable. Let's remember that this means that in PTIME you can calculate its probability in the size of the domain, in the symmetric case if all tuples in a relationship have the same probability. However, queries with a maximum of two logical variables per set can # P-hard if they are calculated using asymmetric probabilities, as the h1 query above shows."}, {"heading": "5.3 COMPARISON WITH PRIOR LIFTED FO-CIRCUITS", "text": "(Van den Broeck et al., 2011; Van den Broeck, 2013) introduce FO d-DNNF circuits to calculate symmetrical WFOMC problems. A FO d-DNNF is a circuit whose nodes are one of the following: decomposable conjunction (Q1-Q2, in which Q1, Q2 do not share common predicate symbols), deterministic disjunction (Q1-Q2, in which Q1-Q2 values are wrong), inclusion exclusion, decomposable universal quantifier (a type of x, Q (x)), and deterministic automatic existential quantifier. The latter is an operation specific only to structures with symmetrical weights and therefore not applicable to our setting. We prove that our algorithm can perform all formulas that allow an FO d-DNNF circuit (FO d-NF-Q2) as a powerful Qantifier QR-QR."}, {"heading": "5.4 CANCELLATIONS IN INCLUSION/EXCLUSION", "text": "We now consider a more complex query. Let us first name four simple queries: q0 = (R (x0), q1 (x0, y0), q1 = (S1 (x1, y1), q2 = (S2 (x2, y2)), q3 = (S3 (x2, y2)), q3 = (S3 (x3, y3)), q3 (Dalvi and Suciu, 2012), which have proven their conjunction, i.e. the query h3 = q0, q1, q2, q3, in the data complexity # P-hart. Instead of h3 we consider: q5, q5, q5, q5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, q5, 5, 5, 5, 5, q5, 5, 5, q5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, q3, q3, q3, q3, q4, q4, q4 in the data complexity # P-hart."}, {"heading": "6 EXTENSIONS AND LIMITATIONS", "text": "We describe an extension of LiftR to symmetrical WFOMC and also prove that a complete characterization of the complexity of all FOL queries is impossible."}, {"heading": "6.1 SYMMETRIC WFOMC", "text": "It is not, as if it were an unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen, unforeseen,"}, {"heading": "6.2 THE COMPLEXITY OF ARBITRARY FOL QUERIES", "text": "We suspect that, via asymmetric probabilities (asymmetric WFOMC problem), our algorithm is complete, in the sense that if it fails on a query, the query is demonstrably # P-hard. Note that LiftR only applies to one fragment of FOL queries, namely CNF formulas without function symbols, and where all variables are universally quantified. Here, we present an impossibility result that shows that a complete algorithm for general FOL queries cannot exist. We use for this classic result of Trakhtenbrot (Libkin, 2004): Theorem 6.2 (Finite Satisfaction). The problem: \"In the face of an FOL set, testing whether there is a finite model for these elements\" is undecidable. From here, we get: Theorem 6.3. There is no algorithm that checks whether any FOL set can be calculated asymmetrically in the Q."}, {"heading": "7 PROOF OF THEOREM 4.2", "text": "The proof of the theorem 4.2 is based on a reduction of the # P2-CNF problem, which is defined as follows: \"Q = Q = q = q.\" \"Q = Q = 1.\" \"Q = q.\" \"Q = q = 1.\" \"Q = q = 1.\" \"Q.\" (\"Q = q = 1.\"). \"(\" Q = Q = 1. \").\" (\"Q = 1.\"). (\"Q = 1.\"). (\"Q = 1.\"). (\"Q = 1.\"). (\"Q = 1.\"). (\"Q = 1.\"). \"(\" Q = 1. \"). (\" Q = 1. \"(\" Q = 1. \").\" (\"Q =.\" c. \"(\" Q = 1. \"). (\" Q =. \"c.\" (\"). (\" Q =. \"(\" Q = 1. \"). (\" Q = 1. \"(\"). (\"Q = 1.\"). (\"). (\" Q = 1. \"(\"). \"(\" Q = 1. \").\" (\"(\"). (\"Q = 1.\"). \"(Q = 1.\"). \"(\" (\").\" (\"(\" Q = 1. \").\" (Q = 1. \").\" (\"(Q = 1.\"). \"(\"). \"(\" (Q = 1. \").\" (\"(Q = 1.\"). \"(Q = 1.\"). \"(\" (Q = 1. \").\" (Q =. \").\" (\").\" (Q = 1. \"(Q =.\"). \"(\" (\").\" (Q = 1. \"(\"). \"(Q = 1.\"). \"(Q =.\" (Q =. \").\" (\").\" (\"(\"). \"(Q = 1.\" (Q =. \").\" (Q =. \").\" (\"(\"). \"(Q = 1.\"). \"(Q = 1.\" (\").\""}, {"heading": "8 RELATED WORK", "text": "The results of the algorithm and complexity of (Dalvi and Suciu, 2012), which relate to positive queries, served as a starting point for our investigation of asymmetric WFOMC with negation. See (Suciu et al., 2011) for more background information on their work. The assumption of PDBs with their tupel independence represents a natural method for modelling asymmetric WFOMC. Existing approaches for PDBs can express complicated correlations (Jha et al., 2010; Jha and Suciu, 2012), but only take into account queries without negation. In the spirit, they agree with the objectives of our work (Van den Broeck, 2011) and (Jaeger and Van den Broeck, 2012). They introduce a formal definition of elevated inference and describe a powerful knowledge compilation technology for WFOMC. Their completeness results for more unreliable knowledge pilgrimages allow for a multiplicity of knowledge pilgrimages to a multiplicity of higher-level inference and describe a powerful knowledge compilation technology for WFOMC."}, {"heading": "9 CONCLUSION", "text": "Our first contribution is the LiftR algorithm for counting models of arbitrary CNF sets over asymmetric probability structures. Secondly, we demonstrate a novel dichotomy result that fully classifies a subclass of CNF as PTIME or # P-hard. Thirdly, we describe capabilities of LiftR that are not present in previous upscale inference techniques. Our last contribution is an extension of our algorithm to symmetric WFOMC and a discussion of the impossibility of establishing a dichotomy for all first order logical sets."}, {"heading": "Acknowledgements", "text": "This work was partially supported by the ONR grant N00014-12-1-0423, the NSF grants IIS-1115188 and IIS-1118122 and the Flanders Research Foundation (FWO-Vlaanderen)."}, {"heading": "A APPENDIX", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "A.1 RANKING QUERIES", "text": "We show at this point that each query can be evaluated (see Section 3.2) by modifying both the query Q and the database. Each relationship symbol R of the validity k is replaced by multiple symbols, one for each possible order of its attributes. We illustrate this by using the example of a binary relation symbol R (x, y). Given a range of size n and probabilities Pr (R (a, b)), for all tuples in R we remove three new relation symbols, R1 (x, y), R2 (x), R3 (y, x), and define their probabilities as follows: Pr (R1 (b, b)) = {Pr (R (a, b))))) = {Pr (R (a, b)))) = {Pr (R) (b))) = {Pr (R (b, b)))) = (x (x, x, x, x), x (x, x, x, x (x, x, x, x, x, x, x (x, x, x, x, x, x, x (c, c, c, x, x, x, x (x, x, x, x) x (x, x, x) x (x, x, x, x, x, x, x, x, x (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x (x, x, x, x, x, x (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x (x, x, x, x, x, x, x, x, x, x, x (x, x, x, x, x, x, x, x, x, x, x, x, x, x (x, x, x, x, x, x, x, x, x, x, x, x, x (x, x, x, x, x, x, x"}, {"heading": "A.2 PROVING THE MATRIX OF", "text": "SECTION 7 IS INVERTIBLE LetM (m1, m2, n1, n2) the matrix whose entries are: ApuB q vX k wY l zC kl uvwhere the row is (p, q, k, l) and column is (u, v, w, z) and the range are: p, u = 0,.., m1 \u2212 1q, v = 0,.., m2 \u2212 1k, w = 0,.., n1 \u2212 1l, z = 0,.., n2 \u2212 1given a vector X0, X1,.., Xn \u2212 1 be V (X) the determinant of their Vandermonde matrix: V (X) = 0 \u2264 k < k \u2032 < n (Xk \u2212 Xk \u2032) Lemma A.1. If m1 = m2 = 1 thendet (M) = Cn1k2 (n1 \u2212 1) / 400 V nrix (2) n (Xk \u2212 Y \u2032 n of the row 1, l)."}, {"heading": "Lemma A.2.", "text": "\"We must be careful that we do not have two, three, four, five, five, six, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eight, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven, eleven,"}, {"heading": "A.3 PROVING THE FUNCTIONS OF", "text": "In this section, we prove that the functions in the example in Section 7 are locally invertible: X (x, b) = x (1 \u2212 x) (1 \u2212 b) n Y (y, b) = y (1 \u2212 y) (1 \u2212 b) n A (a, b) = abB (a, b) = 1 \u2212 a 1 \u2212 bWe show this by calculating the determinant of the Jacobic matrix of these functions. In general, the concept of algebraic independence replaces the concept of locally invertible. Let J use the Jacobic matrix of the vector-weighted function F (x, y, a \u2212 b) = (X (x, b), Y (y, b), A (a, b), B (a, b). J = 1 b \u2212 b \u2212 a (1 \u2212 b) 0 b (b), b (b, b), b (b) (1 (1 \u2212 y) (1), y (1) (b), 1 \u2212 b)."}, {"heading": "A.4 DEFINITIONS", "text": "Let's make a query with a single left unary and a single right unary symbol U (x), V (y) Q (Q). Let F be its Boolean formula, and name: F [0 / U, 0 / V] F01 = F [0 / U] F10 = F [1 / U] F11 = F [1 / U] F11 = F [1 / U] with some misuse of notation we refer to these functions as F1, F3, F4, and their arithmetization to multilinear polynomials as f1, f2, f4.Call Q splittable if F has a prime number of implied symbols with at least one left unary symbol U and at least one right unary symbol V. If Q is splittable, then the algorithms apply the inclusion / exclusion formula. Call Q decomposable if F = F1 F2) where all left unary symbols are."}, {"heading": "A.5 OUTLINE OF HARDNESS PROOF", "text": "For a forbidden query Q, we prove hardness by reducing # P2CNF = q t. (see section 7 = j Q). For a PP2CNF formula \u03a6: \u03a6 = (i, j) \u0394E (Xi, Yj) Where E [n] \u00b7 [n], we set the probabilities as follows: Pr (U (i)) = u Pr (V) = u Pr (2) = v Pr (i, j). If (i, j) the probability is so high that (i, j).E Pr (i, j). 2 Pr (X2) = x2, Pr (i, j) = y2,. If (i, j) /.EFix is assigned to an assignment: {X1,., Xn, Y1, Y1,."}, {"heading": "A.7 CASE ANALYSIS", "text": "(f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f4). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3).). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3). (f3)."}, {"heading": "A.8 CASE 1", "text": "In this section we prove that the issues which fall in case 1 of the analysis of Corollary A.15 slide, in the second case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case slide, in the third case, in the third case slide, in the third case, in the third case, in the third case slide, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, slide, in the third case, in the third case, in the third case, in the third case, in the third case, in the third case, slide in the third case, slide in the third case, slide in the third case, slide, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the third case, slide in the"}, {"heading": "A.9 CASE 2", "text": "We prove that queries falling in case 2 of the analysis of Corollary A.15 are exactly the queries that meet the conditions of the zigzag construction, for which we prove hardness as described in Section A.11. Our four functions look like this: f1 = p * q * rf2 = p * s * tf3 = q * s * kf4 = r * t * kWhere any additional factors can be added as long as each of these additional factors appears in at least three of the four functions. Only p and k or q and t or r and s can divide variables. Any other pair of factors appears together in one of f1, f2, f3, f4, and must therefore have different variables by multilinearity. Let x have the variables of p, k, let y have the variables of q, t and let z divide the variables of r, s, with x, y, z have all the disjunctions. We have: f1 = p (x) q () y (3) y = 3 y (x) y (4) y (x)."}, {"heading": "A.10 MULTIPLE UNARY SYMBOLS", "text": "We prove that a query with multiple left-aligned or right-aligned symbols can always be rewritten to an equivalent Q = four Q factors, in terms of hardness, query with a single symbol.A.10.1 Rewrite an immediately insecure query. First, we prove that if Q is immediately insecure, it is q factors with only one left and one right non-aligned symbol.Proposition A.16. If Q is immediately insecure and U is any simple symbol, then Q [0 \u2032 U] is not divisible, and Q [1 / U] is not divisible. Proof. Leaving Q [0 / U] \u21d2 T, where T implies implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit implicit."}, {"heading": "A.11 ZIGZAG CONSTRUCTION", "text": "The zigzag construction is a technique used in (Dalvi and Suciu, 2012) to prove the # P hardness of positive queries. The essence of its technique is that if you make a query Q, you can construct a database so that Pr (Q) \u2261 Pr (Q), where Q \"= Q1\" Q2 \"is essentially the joining of several copies of Q, each with unique relational atoms, except for their simple atoms connected in a linear chain of Q1\" Q2. \"This is an essential tool in its reduction from\" Q2 \"for positive queries. The complete construction is quite complex, and we refer to their work for complete details. Here we establish a crucial assumption behind the zigzag construction that prevents it from being applied directly to queries with negation: using a monotonous query by setting tuple probabilities to 0 or 1 to ensure that the construction does not depend on the Pr."}, {"heading": "A.12 ALGEBRAIC VARIETIES", "text": "Let us suppose that there are two factors p (q) that are not included in the outline phase (f3). Let us suppose that there are two factors p (q) that are not included in the outline phase (f3). Let us suppose that there is an opposite polynomial: A (f1k1, f4k4) = 0, f2k2, f3k3, f4k4. Let us assume that there is a value that we interpret as: f1 [a / x], that we have 0, f2 [a / x], f4 [a / x] = 0."}], "references": [{"title": "Exact lifted inference with distinct soft evidence on every object", "author": ["Hung B Bui", "Tuyen N Huynh", "Rodrigo de Salvo Braz"], "venue": "In AAAI,", "citeRegEx": "Bui et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bui et al\\.", "year": 2012}, {"title": "On probabilistic inference by weighted model counting", "author": ["Mark Chavira", "Adnan Darwiche"], "venue": "Artificial Intelligence,", "citeRegEx": "Chavira and Darwiche.,? \\Q2008\\E", "shortCiteRegEx": "Chavira and Darwiche.", "year": 2008}, {"title": "Compiling relational Bayesian networks for exact inference", "author": ["Mark Chavira", "Adnan Darwiche", "Manfred Jaeger"], "venue": "International Journal of Approximate Reasoning,", "citeRegEx": "Chavira et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Chavira et al\\.", "year": 2006}, {"title": "The dichotomy of probabilistic inference for unions of conjunctive queries", "author": ["Nilesh Dalvi", "Dan Suciu"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Dalvi and Suciu.,? \\Q2012\\E", "shortCiteRegEx": "Dalvi and Suciu.", "year": 2012}, {"title": "A logical approach to factoring belief networks", "author": ["Adnan Darwiche"], "venue": "Proceedings of KR,", "citeRegEx": "Darwiche.,? \\Q2002\\E", "shortCiteRegEx": "Darwiche.", "year": 2002}, {"title": "Probabilistic inductive logic programming: theory and applications", "author": ["Luc De Raedt", "Paolo Frasconi", "Kristian Kersting", "Stephen Muggleton", "editors"], "venue": null, "citeRegEx": "Raedt et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Raedt et al\\.", "year": 2008}, {"title": "Inference in probabilistic logic programs using weighted CNF\u2019s", "author": ["Daan Fierens", "Guy Van den Broeck", "Ingo Thon", "Bernd Gutmann", "Luc De Raedt"], "venue": "In Proceedings of UAI,", "citeRegEx": "Fierens et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Fierens et al\\.", "year": 2011}, {"title": "An Introduction to Statistical Relational Learning", "author": ["L. Getoor", "B. Taskar", "editors"], "venue": null, "citeRegEx": "Getoor et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Getoor et al\\.", "year": 2007}, {"title": "Probabilistic theorem proving", "author": ["Vibhav Gogate", "Pedro Domingos"], "venue": "In Proceedings of UAI,", "citeRegEx": "Gogate and Domingos.,? \\Q2011\\E", "shortCiteRegEx": "Gogate and Domingos.", "year": 2011}, {"title": "Liftability of probabilistic inference: Upper and lower bounds", "author": ["Manfred Jaeger", "Guy Van den Broeck"], "venue": "In Proceedings of the 2nd International Workshop on Statistical Relational AI,", "citeRegEx": "Jaeger and Broeck.,? \\Q2012\\E", "shortCiteRegEx": "Jaeger and Broeck.", "year": 2012}, {"title": "Probabilistic databases with markoviews", "author": ["Abhay Jha", "Dan Suciu"], "venue": "Proceedings of the VLDB Endowment,", "citeRegEx": "Jha and Suciu.,? \\Q2012\\E", "shortCiteRegEx": "Jha and Suciu.", "year": 2012}, {"title": "Lifted inference seen from the other side: The tractable features", "author": ["Abhay Jha", "Vibhav Gogate", "Alexandra Meliou", "Dan Suciu"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Jha et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2010}, {"title": "The complexity of the annihilating polynomial", "author": ["Neeraj Kayal"], "venue": "In Computational Complexity,", "citeRegEx": "Kayal.,? \\Q2009\\E", "shortCiteRegEx": "Kayal.", "year": 2009}, {"title": "Lifted probabilistic inference", "author": ["Kristian Kersting"], "venue": "In Proceedings of European Conference on Artificial Intelligence (ECAI),", "citeRegEx": "Kersting.,? \\Q2012\\E", "shortCiteRegEx": "Kersting.", "year": 2012}, {"title": "First-order probabilistic inference", "author": ["David Poole"], "venue": "In IJCAI,", "citeRegEx": "Poole.,? \\Q2003\\E", "shortCiteRegEx": "Poole.", "year": 2003}, {"title": "The complexity of counting cuts and of computing the probability that a graph is connected", "author": ["J Scott Provan", "Michael O Ball"], "venue": "SIAM Journal on Computing,", "citeRegEx": "Provan and Ball.,? \\Q1983\\E", "shortCiteRegEx": "Provan and Ball.", "year": 1983}, {"title": "Equivalences among relational expressions with the union and difference operators", "author": ["Yehoshua Sagiv", "Mihalis Yannakakis"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Sagiv and Yannakakis.,? \\Q1980\\E", "shortCiteRegEx": "Sagiv and Yannakakis.", "year": 1980}, {"title": "Solving Bayesian networks by weighted model counting", "author": ["T. Sang", "P. Beame", "H. Kautz"], "venue": "In Proceedings of AAAI,", "citeRegEx": "Sang et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sang et al\\.", "year": 2005}, {"title": "Enumerative Combinatorics", "author": ["Richard P. Stanley"], "venue": null, "citeRegEx": "Stanley.,? \\Q1997\\E", "shortCiteRegEx": "Stanley.", "year": 1997}, {"title": "Probabilistic databases", "author": ["Dan Suciu", "Dan Olteanu", "Christopher R\u00e9", "Christoph Koch"], "venue": "Synthesis Lectures on Data Management,", "citeRegEx": "Suciu et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Suciu et al\\.", "year": 2011}, {"title": "On the completeness of firstorder knowledge compilation for lifted probabilistic inference", "author": ["Guy Van den Broeck"], "venue": "In NIPS,", "citeRegEx": "Broeck.,? \\Q2011\\E", "shortCiteRegEx": "Broeck.", "year": 2011}, {"title": "Lifted Inference and Learning in Statistical Relational Models", "author": ["Guy Van den Broeck"], "venue": "PhD thesis,", "citeRegEx": "Broeck.,? \\Q2013\\E", "shortCiteRegEx": "Broeck.", "year": 2013}, {"title": "On the complexity and approximation of binary evidence in lifted inference", "author": ["Guy Van den Broeck", "Adnan Darwiche"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Broeck and Darwiche.,? \\Q2013\\E", "shortCiteRegEx": "Broeck and Darwiche.", "year": 2013}, {"title": "Conditioning in first-order knowledge compilation and lifted probabilistic inference", "author": ["Guy Van den Broeck", "Jesse Davis"], "venue": "In Proceedings of AAAI,", "citeRegEx": "Broeck and Davis.,? \\Q2012\\E", "shortCiteRegEx": "Broeck and Davis.", "year": 2012}, {"title": "Lifted probabilistic inference by first-order knowledge compilation", "author": ["Guy Van den Broeck", "Nima Taghipour", "Wannes Meert", "Jesse Davis", "Luc De Raedt"], "venue": "In IJCAI,", "citeRegEx": "Broeck et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Broeck et al\\.", "year": 2011}, {"title": "Skolemization for weighted first-order model counting", "author": ["Guy Van den Broeck", "Wannes Meert", "Adnan Darwiche"], "venue": "In Proceedings of the 14th International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Broeck et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Broeck et al\\.", "year": 2014}, {"title": "On relations between jacobians and minimal polynomials", "author": ["Jie-Tai Yu"], "venue": "Linear algebra and its applications,", "citeRegEx": "Yu.,? \\Q1995\\E", "shortCiteRegEx": "Yu.", "year": 1995}], "referenceMentions": [{"referenceID": 4, "context": "Most notably, it underlies state-of-the-art probabilistic inference algorithms for Bayesian networks (Darwiche, 2002; Sang et al., 2005; Chavira and Darwiche, 2008), relational Bayesian networks (Chavira et al.", "startOffset": 101, "endOffset": 164}, {"referenceID": 17, "context": "Most notably, it underlies state-of-the-art probabilistic inference algorithms for Bayesian networks (Darwiche, 2002; Sang et al., 2005; Chavira and Darwiche, 2008), relational Bayesian networks (Chavira et al.", "startOffset": 101, "endOffset": 164}, {"referenceID": 1, "context": "Most notably, it underlies state-of-the-art probabilistic inference algorithms for Bayesian networks (Darwiche, 2002; Sang et al., 2005; Chavira and Darwiche, 2008), relational Bayesian networks (Chavira et al.", "startOffset": 101, "endOffset": 164}, {"referenceID": 2, "context": ", 2005; Chavira and Darwiche, 2008), relational Bayesian networks (Chavira et al., 2006) and probabilistic programs (Fierens et al.", "startOffset": 66, "endOffset": 88}, {"referenceID": 6, "context": ", 2006) and probabilistic programs (Fierens et al., 2011).", "startOffset": 35, "endOffset": 57}, {"referenceID": 8, "context": "Again, this reasoning task underlies efficient algorithms for probabilistic reasoning, this time for popular representations in statistical relational learning (SRL) (Getoor and Taskar, 2007), such as Markov logic networks (Van den Broeck et al., 2011; Gogate and Domingos, 2011) and probabilistic logic programs (Van den Broeck et al.", "startOffset": 223, "endOffset": 279}, {"referenceID": 19, "context": "Moreover, WFOMC uncovers a deep connection between AI and database research, where query evaluation in probabilistic databases (PDBs) (Suciu et al., 2011) essentially considers the same task.", "startOffset": 134, "endOffset": 154}, {"referenceID": 14, "context": "Early on, the disconnect between compact relational representations of uncertainty, and the intractability of inference at the ground, propositional level was noted, and efforts were made to exploit the relational structure for inference, using so-called lifted inference algorithms (Poole, 2003; Kersting, 2012).", "startOffset": 283, "endOffset": 312}, {"referenceID": 13, "context": "Early on, the disconnect between compact relational representations of uncertainty, and the intractability of inference at the ground, propositional level was noted, and efforts were made to exploit the relational structure for inference, using so-called lifted inference algorithms (Poole, 2003; Kersting, 2012).", "startOffset": 283, "endOffset": 312}, {"referenceID": 3, "context": "However, current asymmetric WFOMC algorithms (Dalvi and Suciu, 2012) suffer from a major limitation of their own, in that they can only count models of sentences in monotone disjunctive normal form (MDNF) (i.", "startOffset": 45, "endOffset": 68}, {"referenceID": 3, "context": "The present work seeks to upgrade a well-known PDB algorithm for asymmetric WFOMC (Dalvi and Suciu, 2012) to the SRL setting, by enabling it to count models of arbitrary sentences in conjunctive normal form (CNF).", "startOffset": 82, "endOffset": 105}, {"referenceID": 3, "context": "In the PDB setting, our algorithm is known to come with a sharp complexity guarantee, called the dichotomy theorem (Dalvi and Suciu, 2012).", "startOffset": 115, "endOffset": 138}, {"referenceID": 16, "context": "(Sagiv and Yannakakis, 1980) Checking whether logical implication Q \u21d2 Q or equivalence Q \u2261 Q holds between two CNF sentences is \u03a0p2complete.", "startOffset": 0, "endOffset": 28}, {"referenceID": 14, "context": "Yet it can still encode many SRL models, including parfactor graphs (Poole, 2003), Markov logic networks (MLNs) (Richardson and Domingos, 2006) and probabilistic logic programs (De Raedt et al.", "startOffset": 68, "endOffset": 81}, {"referenceID": 3, "context": "(Dalvi and Suciu, 2012) define an algorithm for Monotone DNF (called Unions Of Conjunctive Queries), which can be adapted to Monotone CNF; that adaptation is equivalent to Lift restricted to Monotone CNF queries.", "startOffset": 0, "endOffset": 23}, {"referenceID": 3, "context": "(Dalvi and Suciu, 2012) prove: Theorem 4.", "startOffset": 0, "endOffset": 23}, {"referenceID": 3, "context": "The proof is a significant extension of the techniques used by (Dalvi and Suciu, 2012) to prove Theorem 4.", "startOffset": 63, "endOffset": 86}, {"referenceID": 3, "context": "We note that the two clauses are dependent (since both refer to the relation Follow), hence we cannot simply multiply their probabilities; in fact, we will see that if we remove all negations, then the resulting query is #P-hard; the algorithm described by (Dalvi and Suciu, 2012) would immediately get stuck on this query.", "startOffset": 257, "endOffset": 280}, {"referenceID": 3, "context": "If we remove all negations from Q and rename the predicates we get the following query: h1 =(R(x) \u2228 S(x, y)) \u2227 (S(x, y) \u2228 T (y)) (Dalvi and Suciu, 2012) proved that computing the probability of h1 is #P-hard in the size of the PDB.", "startOffset": 129, "endOffset": 152}, {"referenceID": 3, "context": "q0 = (R(x0) \u2228 S1(x0, y0)) q1 = (S1(x1, y1) \u2228 S2(x1, y1)) q2 = (S2(x2, y2) \u2228 S3(x2, y2)) q3 = (S3(x3, y3) \u2228 T (y3)) (Dalvi and Suciu, 2012) proved that their conjunction, i.", "startOffset": 115, "endOffset": 138}, {"referenceID": 18, "context": "Once the equivalent formulas are detected, the resulting expressions can be organized in a lattice, as shown in Figure 2, and the coefficient of each term in the inclusion-exclusion formula is precisely the lattice\u2019s M\u00f6bius function (Stanley, 1997).", "startOffset": 233, "endOffset": 248}, {"referenceID": 15, "context": "(Provan and Ball, 1983) have shown that this problem is #P-hard.", "startOffset": 0, "endOffset": 23}, {"referenceID": 26, "context": "The reduction consists of a combinatorial part (the construction of certain gadgets), and an algebraic part, which makes novel use of the concepts of algebraic independence (Yu, 1995) and annihilating polynomials (Kayal, 2009).", "startOffset": 173, "endOffset": 183}, {"referenceID": 12, "context": "The reduction consists of a combinatorial part (the construction of certain gadgets), and an algebraic part, which makes novel use of the concepts of algebraic independence (Yu, 1995) and annihilating polynomials (Kayal, 2009).", "startOffset": 213, "endOffset": 226}, {"referenceID": 3, "context": "The algorithm and complexity results of (Dalvi and Suciu, 2012), which apply to positive queries, served as the starting point for our investigation of asymmetric WFOMC with negation.", "startOffset": 40, "endOffset": 63}, {"referenceID": 19, "context": "See (Suciu et al., 2011) for more background on their work.", "startOffset": 4, "endOffset": 24}, {"referenceID": 11, "context": "Existing approaches for PDBs can express complicated correlations (Jha et al., 2010; Jha and Suciu, 2012) but only consider queries without negation.", "startOffset": 66, "endOffset": 105}, {"referenceID": 10, "context": "Existing approaches for PDBs can express complicated correlations (Jha et al., 2010; Jha and Suciu, 2012) but only consider queries without negation.", "startOffset": 66, "endOffset": 105}, {"referenceID": 0, "context": "Other investigations of evidence in lifted inference include (Van den Broeck and Davis, 2012), who allow arbitrary hard evidence on unary relations, (Bui et al., 2012), who allow asymmetric soft evidence on a single unary relation, and (Van den Broeck and Darwiche, 2013), who allow evidence of bounded Boolean rank.", "startOffset": 149, "endOffset": 167}], "year": 2014, "abstractText": "In this paper we study lifted inference for the Weighted First-Order Model Counting problem (WFOMC), which counts the assignments that satisfy a given sentence in firstorder logic (FOL); it has applications in Statistical Relational Learning (SRL) and Probabilistic Databases (PDB). We present several results. First, we describe a lifted inference algorithm that generalizes prior approaches in SRL and PDB. Second, we provide a novel dichotomy result for a non-trivial fragment of FO CNF sentences, showing that for each sentence the WFOMC problem is either in PTIME or #P-hard in the size of the input domain; we prove that, in the first case our algorithm solves the WFOMC problem in PTIME, and in the second case it fails. Third, we present several properties of the algorithm. Finally, we discuss limitations of lifted inference for symmetric probabilistic databases (where the weights of ground literals depend only on the relation name, and not on the constants of the domain), and prove the impossibility of a dichotomy result for the complexity of probabilistic inference for the entire language FOL.", "creator": "LaTeX with hyperref package"}}}