{"id": "1405.3792", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-May-2014", "title": "Minimum Model Semantics for Extensional Higher-order Logic Programming with Negation", "abstract": "Extensional higher-order logic programming has been introduced as a generalization of classical logic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming.", "histories": [["v1", "Thu, 15 May 2014 10:37:42 GMT  (52kb)", "http://arxiv.org/abs/1405.3792v1", null]], "reviews": [], "SUBJECTS": "cs.PL cs.AI cs.LO", "authors": ["angelos charalambidis", "zolt\\'an \\'esik", "panos rondogiannis"], "accepted": false, "id": "1405.3792"}, "pdf": {"name": "1405.3792.pdf", "metadata": {"source": "CRF", "title": "Minimum Model Semantics for Extensional Higher-order Logic Programming with Negation\u2217", "authors": ["Angelos Charalambidis", "Zolt\u00e1n \u00c9sik", "Panos Rondogiannis"], "emails": ["a.charalambidis@di.uoa.gr)", "ze@inf.u-szeged.hu)", "prondo@di.uoa.gr)"], "sections": [{"heading": null, "text": "ar Xiv: 140 5,37 92v1 [Logic Programming. An important feature of this paradigm is that it preserves all the known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. On the basis of some recent results from non-monotonous fixed point theory, we show that each higher order logic program with negation has a unique minimum of infinitely valuable model. In this way, we obtain the first purely model-theoretical semantics for negation in higher order extensional logic programming. With our approach, we solve an old paradox introduced by W. Wadge to show the semantic difficulties of higher order logic programming."}, {"heading": "1 Introduction", "text": "The key idea behind this paradigm is that all the predictions defined in a program are obviously fulfilled, and therefore standard advanced set theory can be used to understand and judge their meaning. Consider, for example, the following simple extended higher order programs (G), B (G). This research is supported by the Greek General Secretariat for Research and Technology, the National Development Agency of Hungary, and the European Commission (European Regional Development Fund) under a Greek-Hungarian intergovernmental program."}, {"heading": "2 An Intuitive Overview of the Proposed Semantics", "text": "The starting point for the semantics proposed in this essay is the infinitely valued semantics for ordinary logic programs with negation as introduced in (Rondogiannis andWadge 2005). < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < &lt"}, {"heading": "3 Non-Monotonic Fixed Point Theory", "text": "The main results of the work are obtained using some current results from the non-monotonic fixed point theory (E'sik and Rondogiannis 2014).The main objective of this research area is to obtain new fixed point results with regard to functions that are not necessarily monotonous. In particular, the results obtained in (E'sik and Rondogiannis 2013) are generalized in this section to the necessary material (E'sik and Rondogiannis 2013) when the classical results of the monotonic fixed point theory (namely Kleene's theorem and also the Knaster-Tarski theorem) are generalized.In this section we provide the necessary material (E'sik and Rondogiannis 2014) needed in the next Section.Suppose (L'sik and Rondogiannis 2014)."}, {"heading": "4 The Syntax of the Higher-Order Language H", "text": "In this section, we introduce the language of higher order: H, which extends the classical firstorder logic. \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \u00b7 D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D \"D\" D"}, {"heading": "5 The Semantics of the Higher-Order Language H", "text": "In this section we define the semantics of H. We begin with the semantics of types and continue with the semantics of expressions. The meaning of the Boolean type o is equivalent to a partially ordered set (V, \u2264) of truth values. The number of truth values of V is defined in relation to an ordinal number."}, {"heading": "6 Minimum Herbrand Model Semantics for H", "text": "In this section, we show that each program of H has a unique minimum of Herbrand model, which is the largest lower limit of all Herbrand models of the program, and is also the least defined point of the immediate sequence of the program. We begin with the relevant definitions. Definition 15 Let P is an interpretation that reads as follows: 1. The domain of I is the Herbrand universe of P; 2. for each single constant of P, I (c) and the function symbols of P: 3. for each predicate constant of P: 1. The domain of I is the Herbrand universe of P; 2. for each single constant of P, I (c) = c; 3. for each predicate constant of P: p.] UP; 3 As usual, if P has no constants, we assume that the existence of an arbitrary function symbol f of P and for all t1,."}, {"heading": "7 Resolving a Semantic Paradox of Higher-Order Logic Programming", "text": "The reason for this limitation is semantic and will be explained shortly. However, not all programs that use predicate constants in the heads of clauses are problematic. However, the density of the good profession is the relation {john}, while the density of the good profession is the relation {john}. In (Wadge 1991) W. Wadge argues that allowing rules to have predicate constants in their heads creates tricky semantic problems. Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher order of logical programming (such as in Bezem 2001). We present the example in almost identical formulation."}, {"heading": "8 Future Work", "text": "The results we have obtained generalize the semantics of classical logic programming to the setting of higher order. We believe that the most interesting direction for future work is to investigate implementation techniques for (fragments of) H, based on the semantics presented in this paper. One possible option would be to investigate the implementation of an extension of a higher order of Datalog with Negation. We are currently investigating these possibilities."}, {"heading": "Appendix A Proof of Lemma 2", "text": "Let us assume that L is a basic model. For each x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x"}, {"heading": "Proof", "text": "If \u03b2 < \u03b1 then x | \u03b2 = (x | \u03b2) | \u03b2 = (y | \u03b2) | \u03b2 = (y | \u03b2) | \u03b2 = y | \u03b2. If \u03b2 > \u03b1 then x | \u03b1 = (x | \u03b2) | \u03b1 \u03b1 (y | \u03b2) | \u03b1 = y | \u03b1.Let us suppose that \u03b2 < \u03b1 and x | \u03b2 = y | \u03b2. Then (x | \u03b2) | \u03b1 = x | \u03b2 = (y | \u03b2) | \u03b2 = (y | \u03b2) | \u03b1 and thus x | \u03b2 = \u03b1 y | \u03b2. Note 1 Under the above assumptions, if \u03b2 < \u03b1 and x | \u03b1 \u03b1 \u03b1 y | \u03b1. Then (x | \u03b2) | \u03b1 = x-\u03b1 y | \u03b2 = (y | \u03b2) | \u03b2 and thus x | \u03b2 | \u03b2. Note 1 if \u03b2 < \u03b1 and x \u03b2 = \u03b2 and \u03b2 < \u03b2 < \u03b2 = x \u03b2 and \u03b2 \u03b2 < \u03b2 < \u03b2 = \u03b2, \u03b2 and \u03b2, \u03b2, \u03b2 and \u03b2 = \u03b2."}, {"heading": "Proof", "text": "Let x = \u03b2 X and y = \u03b2 Y. Then x = \u03b2 X = \u03b2 {\u03b2 X} = x | \u03b2 and y = y | \u03b2.Let \u03b2 < \u03b1. Then x \u03b1 y iff x = y. Let \u03b2 > \u03b1. Then x \u03b1 y iff x | \u03b1 \u03b1 y | \u03b1. But x | \u03b1 = \u03b1 {\u03b2 X} = \u03b1 \u03b1 X and similar for Y.Lemma 11 Let A and B be basic models. Let's assume that f: A \u2192 B and F (f] \u03b2 (where \u03b2 < \u0445) is a series of functions in [A m \u2192 B]."}, {"heading": "Proof", "text": "Let us suppose that \u03b1, \u03b2 < \u03b1 and x \u03b1 y in A. Then (\u03b2 F) (x) = \u03b2 {f (x): f F} and (\u03b2 F) (y) = \u03b2 {f (y): f F (y). Then we have this f (x) \u03b1 f (y) for all f F. So, if\u03b1 = \u03b2, then unambiguously (\u03b2 F) (x) \u03b1 (\u03b2 F) (y). Let us suppose that \u03b2 < \u03b1 (\u03b2 F) (y). Then \u03b2 (x): f (y): f F (x) since f (x) = \u03b2 f (y) for all f F. Let us suppose that \u03b2 (\u03b2 F) (x) \u03b1 (\u03b2 F) (y). Let us suppose that \u03b2 (\u03b2 > F) = \u03b2 > \u03b1 (\u03b2 F) (\u03b2 F) (\u03b2 F) (\u03b2 F) (y) of Korollary 1 (x) \u03b2 F (x) \u03b2 (F) (F) (F) (y) (F) (y) (F) (y) (F)) (y) (f), we assume that we have fundamental relations between L and F (f)."}, {"heading": "Proof", "text": "It is proved in (E'sik and Rondogiannis 2014) that the set of functions A \u2192 B is a basic model with the senseless definition of the relations \u2264 and \u03b1, so that for all f, g: A \u2192 B and \u03b1 < B, f \u2264 g iff f (x) \u2264 g (x) for all x-A and f \u03b1 g iff f (x) \u03b1 g (x) for all x-A. It follows that for all F BA and \u03b1 < B and F can also be calculated anew: (F) (x) = x (x): x-A) and (\u03b1 F) (x) = \u03b1-F (x): f-F). By means of Proposition 8 and Lemma 11, if F is a set of functions \u03b1-monotonic for all \u03b1, then F and \u03b2 F are also f-sif (x): f-F}."}, {"heading": "Proof", "text": "Let us prove that [[\u03c0] D is a basic model by induction on the structure of \u03c0. If \u03c0 = o, [[\u03c0]] D = V, is a basic model. Let us suppose that \u03c0 is of the way and not of the kind. Let us suppose that \u03c0 is of the kind and not of the kind. Let us suppose the induction hypothesis is a model for i = 1, 2. D is a model for i = 1. The above results show that C is closed for all basic models, since B is the weighting function. Note 2 Let C designate the category of all basic models and f-monotonous functions. The above results show that C is closed for all basic models, since B is the weighting function. Note 2 Let C designate the category of all basic models and f-monotonous functions."}, {"heading": "Appendix B Proofs of Lemmas 3, 4 and 5", "text": "Lemma 3 Let E: \u03c1 be an expression and let D be a non-empty set. Moreover, let us be a state about D and let me be an interpretation about D. Then, [[E] s (I)."}, {"heading": "Proof", "text": "Let us at the same time follow the following auxiliary statement (I). Let me say [V] (I). The proof is by structural induction on E. We will only consider the non-trivial case.Case (E1) [E2): The main statement follows directly on the induction hypothesis of E1 and E2. There are two cases. Let us suppose that E1: continuus and E2: continuus 1. Then [E1] s (I). [E1] Answer (E2): The main statement follows directly on the induction hypothesis of E1 and E2. There are two cases. Let us suppose that E1: continuus and E2: continuus 1. Then [E1] s (I)."}, {"heading": "Proof", "text": "Lemma 2 shows that for all predicate types \u03c0, [[\u03c0]] UP is a complete grid and a basic model. It follows that IP for all predicate types \u03c0, P\u03c0 \u2192 [\u03c0] UP is also a complete grid and a model, where P\u03c0 is the set of predicate constants of type \u03c0. Then, inversely, IP is P\u03c0 \u2192 [\u03c0] UP, which is also a basic model (proven in (E'sik and Rondogiannis2014)). Lemma 5 (\u03b1-monotonicity of semantics) Let P be a program and let E: \u03c0 be an expression. Let I, J be Herbrand interpretations and let us be a Herbrand state of P. For all \u03b1 < B, if I am '\u03b1 J, then [E] s (I) \u03b1 [E] s (J)."}, {"heading": "Proof", "text": "The proof is by structural induction based on E.dn: Cases V, false, J and J are therefore unambiguous (J), since their meaning does not depend on me. If E is a predicate constant p, then we have [E1] s (I) s (p).Induction step: Suppose that the statement applies to the expressions E1 and E2 and allow it. By induction hypothesis we have [E1] s (I) s (E1) s (I) s (I) s (I) s (I) s (I) s (I) s (I)."}, {"heading": "Appendix C Proof of Theorem 2", "text": "s define d'IP for each X '( x] \u03b1 as follows: If X = \u2205 then d'\u03b1 X = T\u03b1, otherwise \u03b1 X = {\u0432 X's order (x) \u2264 T\u03b1 + 1 otherwise Let P be a program, then I am a herbbrand interpretation of P and X's (I]. For all predicate constants p in P of type \"1\" \u00b7 \u00b7 \u00b7 \u25cf n \"o and di\" [[[i]] UP and for alli = {1,. n} it counts d \"X\" as (d \"X\") (p) d1 \u00b7 \u00b7 dn = d. \""}, {"heading": "Proof", "text": "If we assume that \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7"}, {"heading": "Proof", "text": "Let us assume M \u00b2 = \u03b4 \u03b1 < \u0432 M\u03b1 and that M \u00b2 is not a model of P. \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2. Furthermore, there is a set p \u00b2 E and di \u00b2 [\u03c1i] D such that [[E] (M \u00b2) d1 \u00b7 \u00b7 dn > M \u00b2 (p) d1 \u00b7 \u00b7 dn. We define x\u03b1 = M\u03b1 (p) d1 \u00b7 dn, x \u00b2 = M \u00b2 (p) d1 \u00b7 \u00b7 dn, y\u03b1 = [E] (M\u03b1) d1 \u00b7 dn and y \u00b2 (M \u00b2) d1 \u00b7 dn for all \u03b1 <. It follows from Lemma 15 that M \u00b2 = \u03b1 M\u03b1 and thus x \u00b2 = \u03b1 < and thus x \u00b2 \u00b2 \u00b2 for all \u03b1 <. Moreover, the use of \u03b1-monotonicity is also [E] (M \u00b2) d1 \u00b7 \u00b7 dn for all \u03b1 <."}, {"heading": "Proof", "text": "We use the construction for d M that we described at the beginning of this appendix. More precisely, we define \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 IP. Let us leave Y0 = M and M0 = d 0 Y0. For each \u03b1 > 0, let us leave M\u03b1 = \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 \u03b2 M\u03b1} and Y\u03b1 = \u03b2 \u03b2 \u03b2 M\u03b2; furthermore, M\u03b1 = d \u03b1 Y\u03b1 applies if Y\u03b1 is not empty and M\u03b2 if Y\u03b1 is empty. Then d M = \u03b2 \u03b2 M\u03b1} and Y\u03b1 M\u03b1 are. It is easy to see that M\u03b1 = \u03b1 M\u03b2 and M\u03b2 M apply to all \u03b2 < p. Let us distinguish two cases. Let us first consider the case when Y\u03b1 is not empty for all < then it is a case. Then, M\u03b1 \u03b1 \u03b1 \u03b1 \u03b1 \u03b1 < M\u03b1 & lt."}, {"heading": "Appendix D Proofs of Lemmas 6, 7 and Theorem 3", "text": "6Let P be a program. For each predicate constant p: \u03c0 in P and I: IP, TP (I) (p)."}, {"heading": "Proof", "text": "It follows that [[\u03c0]] UP is a complete grid (Lemma 2).Lemma 7Let P be a program. Then, TP is \u03b1 < K \u03b1-monotonous for all."}, {"heading": "Proof", "text": "Follows directly from Lemma 5 and Proposition 8.Lemma 17Let P be a program. Then, M-IP is a model of P if and only if TP (M) \u2264 IP M."}, {"heading": "Proof", "text": "An interpretation of I-IP is a model of P iff [[[E]] (I) \u2264 \u03c0 I (p) for all clauses p \u2190 \u03c0 E in P iff (p \u2190 E) \u0394P [[[E]] (I) \u2264 IP I (p) iff TP (I) \u2264 IP I.sentence 18Let D be a non-empty quantity, \u03c0 be a predicate type and x, y [\u03c0] D. If x \u2264 \u03c0 y and x = \u03b2 y for all \u03b2 < \u03b1 then x \u03b1 y."}, {"heading": "Proof", "text": "The proof for this is by structural induction based on rope induction: If x = \u03b2 y for all \u03b2 < \u03b1 then either x = y or order (x), order (y) \u2265 \u03b1. If x = y then x \u03b1 y. Let's assume x = 6 = y. If order (x), order (y) > \u03b1 then x = \u03b1 y. If x = F\u03b1 then unambiguously x \u03b1 y. If x = T\u03b1 then T\u03b1 \u2264 y and therefore y = T\u03b1. The case analysis for y is similar. Induction step: Let's assume that the statement applies to \u03c0. Let's assume that f, g [[[x] \u03c0] D and \u03b1 < \u0445. For all x [[x] D and \u03b2 < \u03b1, f (x) \u2264 g (x) and f (x) = \u03b2 g (x). Consequently, f (x) \u03b1 g (x) and \u03b1 g.Proposition 19 Let P be a program and I, J Herbrand interpretations for J (T) and J (x)."}, {"heading": "Proof", "text": "For all predicate constants p and \u03b2 < \u03b1, I (p) \u2264 J (p) and I (p) = \u03b2 J (p) it follows from sentence 18 that I (p) \u03b1 J (p) and therefore I \u03b1 J.Lemma 20 Let P be a program. If M is a P model, then TP (M) M."}, {"heading": "Proof", "text": "From Lemma 17 it follows that if M is a Herbrand model of P, then TP (M) \u2264 IP M. If TP (M) = M then the statement is immediate. Let's say TP (M) < IP M and let \u03b1 denote the least ordinal so that TP (M) = \u03b1 M does not apply. Then TP (M) = \u03b2 M follows for all \u03b2 < \u03b1. Since TP (M) < IP M according to sentence 19 follows that TP (M) \u03b1 M. Since TP (M) = \u03b1 M does not apply, it follows that TP (M) \u03b1 M. Therefore TP (M) M. Theorem 3 (Least Fixed Point Theorem) Let P be a program and let M be the set of all Herbrand models. Then TP has a least fixed point MP. Furthermore, MP = d M."}, {"heading": "Proof", "text": "From Lemma 7 and Theorem 1 it follows that TP has in relation to a least prefixed point, which is also a least fixed point. Let MP be this least fixed point of TP, i.e. TP (MP) = MP. It is clear from Lemma 17 that MP is a model of P, i.e. MP-M. Then it follows M MP. Furthermore, Theorem 2 implies that d M is a model and thus from Lemma 20, d M is a prefixed point of TP in relation to. Since MP is the least prefixed point of P, MP d M and thus MP = d M."}], "references": [{"title": "An improved extensionality criterion for higher-order logic programs", "author": ["M. Bezem"], "venue": "Proceedings of the 15th International Workshop on Computer Science Logic (CSL). SpringerVerlag, London, UK, 203\u2013216.", "citeRegEx": "Bezem,? 2001", "shortCiteRegEx": "Bezem", "year": 2001}, {"title": "Extensional higher-order logic programming", "author": ["A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge"], "venue": "JELIA, T. Janhunen and I. Niemel\u00e4, Eds. Lecture Notes in Computer Science, vol. 6341. Springer, 91\u2013103.", "citeRegEx": "Charalambidis et al\\.,? 2010", "shortCiteRegEx": "Charalambidis et al\\.", "year": 2010}, {"title": "Extensional higher-order logic programming", "author": ["A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge"], "venue": "ACM Transactions on Computational Logic 14, 3, 21:1\u201321:40.", "citeRegEx": "Charalambidis et al\\.,? 2013", "shortCiteRegEx": "Charalambidis et al\\.", "year": 2013}, {"title": "A fixed point theorem for non-monotonic functions", "author": ["Z. \u00c9sik", "P. Rondogiannis"], "venue": "Proceedings of 13th Panhellenic Logic Symposium, Athens, Greece.", "citeRegEx": "\u00c9sik and Rondogiannis,? 2013", "shortCiteRegEx": "\u00c9sik and Rondogiannis", "year": 2013}, {"title": "A fixed point theorem for non-monotonic functions", "author": ["Z. \u00c9sik", "P. Rondogiannis"], "venue": "CoRR abs/1402.0299. Lloyd, J. W. 1987. Foundations of Logic Programming. Springer Verlag. Pearce, D. 1996. A new logical characterisation of stable models and answer sets. In NMELP, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol.", "citeRegEx": "\u00c9sik and Rondogiannis,? 2014", "shortCiteRegEx": "\u00c9sik and Rondogiannis", "year": 2014}, {"title": "Every logic program has a natural stratification and an iterated least fixed point model", "author": ["T.C. Przymusinski"], "venue": "PODS, A. Silberschatz, Ed. ACM Press, 11\u201321.", "citeRegEx": "Przymusinski,? 1989", "shortCiteRegEx": "Przymusinski", "year": 1989}, {"title": "Minimum model semantics for logic programs with negation-as-failure", "author": ["P. Rondogiannis", "W.W. Wadge"], "venue": "ACM Transactions on Computational Logic 6, 2, 441\u2013467.", "citeRegEx": "Rondogiannis and Wadge,? 2005", "shortCiteRegEx": "Rondogiannis and Wadge", "year": 2005}, {"title": "The well-founded semantics for general logic programs", "author": ["A. van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "J. ACM 38,", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}], "referenceMentions": [{"referenceID": 1, "context": "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.", "startOffset": 76, "endOffset": 142}, {"referenceID": 2, "context": "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.", "startOffset": 76, "endOffset": 142}, {"referenceID": 2, "context": "For example, consider the following simple extensional higher-order program (Charalambidis et al. 2013) stating that a band (musical ensemble) is a group that has at least a singer and a guitarist: band(B):-singer(S),B(S),guitarist(G),B(G).", "startOffset": 76, "endOffset": 103}, {"referenceID": 2, "context": "One basic property of all the higher-order predicates that can be defined in the language of (Charalambidis et al. 2013) is that they are monotonic.", "startOffset": 93, "endOffset": 120}, {"referenceID": 2, "context": "In other words, the semantics of (Charalambidis et al. 2013) is not applicable to this extended higher-order language.", "startOffset": 33, "endOffset": 60}, {"referenceID": 5, "context": "The solution we adopt is relatively simple to state (but non-trivial to materialize): it suffices to generalize the well-founded construction (van Gelder et al. 1991; Przymusinski 1989) to higher-order programs.", "startOffset": 142, "endOffset": 185}, {"referenceID": 6, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 157, "endOffset": 186}, {"referenceID": 3, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 276, "endOffset": 332}, {"referenceID": 4, "context": "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 276, "endOffset": 332}, {"referenceID": 6, "context": "In other words, the underlying truth domain of the infinite-valued approach is: F0 < F1 < \u00b7 \u00b7 \u00b7< F\u03c9 < \u00b7 \u00b7 \u00b7< F\u03b1 < \u00b7 \u00b7 \u00b7< 0 < \u00b7 \u00b7 \u00b7< T\u03b1 < \u00b7 \u00b7 \u00b7< T\u03c9 < \u00b7 \u00b7 \u00b7< T1 < T0 As shown in (Rondogiannis and Wadge 2005), every logic program P with negation has a unique minimum infinite-valued model MP.", "startOffset": 176, "endOffset": 205}, {"referenceID": 6, "context": "As shown in (Rondogiannis and Wadge 2005), one can compute the minimum infinitevalued model as the least fixed point of an operator TP.", "startOffset": 12, "endOffset": 41}, {"referenceID": 6, "context": "More specifically, as it is shown in (Rondogiannis and Wadge 2005; \u00c9sik and Rondogiannis 2014), TP is \u03b1-monotonic for all countable ordinals \u03b1, a property that guarantees the existence of the least fixed point.", "startOffset": 37, "endOffset": 94}, {"referenceID": 4, "context": "More specifically, as it is shown in (Rondogiannis and Wadge 2005; \u00c9sik and Rondogiannis 2014), TP is \u03b1-monotonic for all countable ordinals \u03b1, a property that guarantees the existence of the least fixed point.", "startOffset": 37, "endOffset": 94}, {"referenceID": 3, "context": "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 145, "endOffset": 201}, {"referenceID": 4, "context": "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014).", "startOffset": 145, "endOffset": 201}, {"referenceID": 3, "context": "In particular, the results obtained in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene\u2019s theorem and also the Knaster-Tarski theorem).", "startOffset": 39, "endOffset": 95}, {"referenceID": 4, "context": "In particular, the results obtained in (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene\u2019s theorem and also the Knaster-Tarski theorem).", "startOffset": 39, "endOffset": 95}, {"referenceID": 3, "context": "In this section we provide the necessary material from (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) that will be needed in the next sections.", "startOffset": 55, "endOffset": 111}, {"referenceID": 4, "context": "In this section we provide the necessary material from (\u00c9sik and Rondogiannis 2013; \u00c9sik and Rondogiannis 2014) that will be needed in the next sections.", "startOffset": 55, "endOffset": 111}, {"referenceID": 0, "context": "Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher-order logic programming (such as for example in (Bezem 2001)).", "startOffset": 184, "endOffset": 196}, {"referenceID": 2, "context": "Similarly, the higher-order language introduced in (Charalambidis et al. 2013) also disallows this kind of clauses.", "startOffset": 51, "endOffset": 78}], "year": 2014, "abstractText": "Extensional higher-order logic programming has been introduced as a generalization of classical logic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming.", "creator": "LaTeX with hyperref package"}}}