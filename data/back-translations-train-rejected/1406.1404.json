{"id": "1406.1404", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Jun-2014", "title": "On the satisfiability problem for SPARQL patterns", "abstract": "The satisfiability problem for SPARQL patterns is undecidable in general, since the expressive power of SPARQL 1.0 is comparable with that of the relational algebra. The goal of this paper is to delineate the boundary of decidability of satisfiability in terms of the constraints allowed in filter conditions. The classes of constraints considered are bound-constraints, negated bound-constraints, equalities, nonequalities, constant-equalities, and constant-nonequalities. The main result of the paper can be summarized by saying that, as soon as inconsistent filter conditions can be formed, satisfiability is undecidable. The key insight in each case is to find a way to emulate the set difference operation. Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference. When no inconsistent filter conditions can be formed, satisfiability is efficiently decidable by simple checks on bound variables and on the use of literals. The paper also points out that satisfiability for the so-called `well-designed' patterns can be decided by a check on bound variables and a check for inconsistent filter conditions.", "histories": [["v1", "Thu, 5 Jun 2014 14:48:04 GMT  (14kb)", "http://arxiv.org/abs/1406.1404v1", null], ["v2", "Wed, 1 Jun 2016 21:26:44 GMT  (25kb)", "http://arxiv.org/abs/1406.1404v2", "Major revision, erroneous polynomial-time claims corrected, NP-completeness result added, detailed proofs added, experimental section added"]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["xiaowang zhang", "jan van den bussche", "fran\\c{c}ois picalausa"], "accepted": false, "id": "1406.1404"}, "pdf": {"name": "1406.1404.pdf", "metadata": {"source": "CRF", "title": "On the satisfiability problem for SPARQL patterns", "authors": ["Xiaowang Zhang"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 140 6.14 04v1 [cs.DB] The satisfaction problem of SPARQL patterns is generally indecidable, since the meaningfulness of SPARQL 1.0 is comparable to that of relational algebra. The aim of this paper is to define the limit of decidability of satisfaction with respect to the constraints permitted in filter conditions.The constraints considered are binding constraints, negated binding constraints, equities, inequalities, constant-equals and constant-inequalities. The main result of the paper can be summarized in the words that once inconsistent filter conditions can be formed, satisfaction is not decidable.The most important finding in any case is to find a way to imitate the differential operation set. The indecidability can then be determined from a known indecidability result for the decidability of the decidability of the decider, which cannot be determined on the basis of the algebra relations with union and inconsistency of the composition."}, {"heading": "1 Introduction", "text": "It is only a matter of time before it will happen, until it will happen."}, {"heading": "2 SPARQL and fragments", "text": "In this section, we will recall the syntax and semantics of SPARQL patterns, in accordance with the central SPARQL formalization of Arenas, Gutierrez and Pe'rez [PAG09, APG09, AP11]. We will also define the language fragments defined in terms of the permissible filter conditions that will be the subject of this essay."}, {"heading": "2.1 RDF graphs", "text": "Let I, B, and L be infinite sets of IRIs, empty nodes, or literals, separated in pairs. We call the union I-B-L by U, and elements of I-L are called constants. A triple (s, p, o) from (I-B) \u00d7 I-I (I-B-L) is called a triple from an EDF. An EDF diagram is a finite set of EDF triples."}, {"heading": "2.2 Syntax of SPARQL patterns", "text": "The convention in SPARQL is that variables are written starting with a question mark to distinguish them from constants. We will follow this convention in this paper as follows. \u2022 Each triple pattern of (I-L-V) \u00b7 (I-L-V) \u00b7 (I-L-V) is a pattern (called a triple pattern). \u2022 If P1 and P2 are patterns, then they are also the following: - P1 UNION P2; - P1 AND P2; - P1 OPT P2. \u2022 If P is a pattern and C is a constraint (defined next), then P FILTER C is a pattern; we call C the filter condition. Here, a constraint can have one of the following six forms: 1. Bonding condition (? x) 2. Negative bonding condition:? 3. Equity:? 5.? Aby4.? = Equity with conjunction: 1. Equality and not equality with conjunction?"}, {"heading": "2.3 Semantics of SPARQL patterns", "text": "The semantics of patterns are defined in terms of so-called mappings, which are simply total functions \u00b5: S \u2192 U on some finite sets of variables. We denote the domain S of \u00b5 by dom (\u00b5). Now, if a diagram G = and a pattern P is given, we define the semantics from P to G, denoted by JP KG, as a set of mappings, in the following way. \u2022 If P is a triple pattern (x, y, z), then we agree that JP KG: = {x, y, z}. V \u2192 U | (x), \u00b5 (y), \u00b5 (z))."}, {"heading": "2.4 SPARQL fragments", "text": "We can create fragments of SPARQL by specifying which of the six classes of constraints are permissible as filter conditions. We designate the class of boundary constraints by \"bound,\" negated boundary constraints by \"\u00ac bound,\" equations by \"=,\" inequalities by \"6 =,\" constant equations by \"= c,\" and constant inequalities by \"6 = c.\" Then, for each subset F of {bound, \u00ac bound, =, 6 =, c, 6 = c} we can form the fragment SPARQL (F). In the fragment SPARQL (bound, =, 6 = c), for example, filter conditions can only be bound constraints, equities, and constant inequalities."}, {"heading": "3 Satisfiability: decidable fragments", "text": "A pattern P is considered satisfactory if there is a graph G, so that JP KG is in fact not empty. In general, checking satisfaction is a very complicated, indeed undecided problem. But for the two fragments SPARQL (bound, =, 6 = c) and SPARQL (bound, 6 =, 6 = c), it will be found that there are essentially only two possible reasons for dissatisfaction. The first possible reason is that the pattern indicates a letter value in the first position of a triple RDF pattern, whereas triple RDF patterns can only have letters in the third position. Note: When using the letter 42, the triple pattern (42,? x,? y) is unsatisfactory. Note that literals in the middle position of a triple pattern are already prohibited by the definition of a triple pattern, so we only have to worry about the first position."}, {"heading": "3.1 Handling of wrong literals", "text": "Letters in the wrong place in triple patterns can easily be treated as follows: \u2022 If P is a triple pattern (u, v, w) and u is a literal pattern, then \u03bb (P): = \u2205; otherwise \u03bb (P): = {P): = {P}. \u2022 \u03bb (P1 UNION P2): = \u03bb (P1) if it contains a triple pattern (P1) or \u03bb (P2) is empty; \u2022 \u03bb (P1 UNION P2): = {P 1 UNION P \u00b2 2 | P \u00b2 (P1) and P \u00b2 2 (P2) otherwise. \u2022 \u03bb (P1 AND P2): = {P \u2032 1 AND P \u00b2, not P \u00b2 (P1) and P \u00b2, literally P (P2): \u2022 P1 P2 PER: (P1) if it is empty (P2)."}, {"heading": "3.2 Checking bound variables", "text": "To perform border checks on variables, we associate each pattern P with a set of schemes in which a scheme is simply a set of variables, in the following way. \u2022 If P is a triple pattern (u, v, w), then we will make a different use of patterns (P) in Section 5. \u2022 We will define this pattern (P) for general patterns, not only for those that belong to the fragments considered in this section, because we will make a different use of patterns (P) in Section 5. \u2022 S (P1 UNION P2): = P1). \u2022 S (P1), which belong to the fragments considered in this section. \u2022 S (P1 AND P2): {S1) and S2 (P2). \u2022 Lemberg (P1 OPT P2): = P1 and P2)."}, {"heading": "4 Undecidable fragments", "text": "In this section, we show that the two decidable fragments SPARQL (bound, =, 6 = c) and SPARQL (bound, 6 =, 6 = c) are in a sense maximum. Specifically, the three minimum fragments that are not subsumed by either of these two fragments are SPARQL (bound), SPARQL (=, 6 =) and SPARQL (= c). The main result of this section is: Theorem 6. Reliability is indecisive for SPARQL patterns (bound), for SPARQL patterns (=, 6 =) and for SPARQL patterns (= c)."}, {"heading": "4.1 SPARQL(\u00acbound)", "text": "We assume that the approach is based on satisfaction of satisfaction (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) -2 (I) (I) (I) -2 (I) (I) (I) -2 (I) (I) (I) -2 (I) (I) (I) -2 (I) (I) (I) (I (I) -2 (I) (I (I) -2 (I) (I) (I (I) -2) (I (I) (I (I) -2) (I (I) (I (I)) -2 (I (I) (I (I)) (I (I) -2) (I (I (I) (I (I)) (I (I (I) -2) (I (I (I (I) -2) (I (I (I) (I (I (I) (I (I (I) -2) (I (I (I (I (I) -2) (I (I (I (I (I (I) -2) -2) (I (I (I (I) -2) (I (I (I (I (I (I) -2) -2) (I (I (I (I (I (I (I) -2) -2) -2) (I (I (I (I (I (I (I (I (I (I) -2) -2) -2) -2 (I (I (I (I (I (I (I) -2) -2) -2) -2) -2 (I (I (I (I (I (I (I)"}, {"heading": "5 Satisfiability of well-designed patterns", "text": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, whose properties are similar to the conjunctive queries for relational databases [AHV95]. Standard conjunctive queries are always satisfactory, and conjunctive queries extended to include equality and non-equality constraints can only be unsatisfactory if the constraints are inconsistent. Analogous behavior is present in what we call AF patterns: patterns that use only the AND and FILTER operators. We will formalize this in Proposition 9, and then show in Theorem 11 that a well-designed pattern is satisfactory when and only when its reduction to an AF pattern is satisfactory. In other words, in terms of satisfaction, well-designed patterns can be treated as AF patterns."}, {"heading": "5.1 Satisfiability of AF-patterns", "text": "In Section 3.2, we have set a series of schemas \u0430 (P) for each pattern. If this pattern is empty, P is unsatisfactory (Lemma 3). Now, if P is an AF pattern and vice versa (P) is not empty, the satisfaction of P will depend exclusively on the equations, non-equations, constants and constant-non-equals that occur as filter conditions in P. We designate the set of these constraints by C (P). We note: Every set of constraints is consistent if there is an assignment that meets every constraint. If it is a set of (constant) (non) equals, such as C (P), consistency can be efficiently decided [KS08]. We note: An AF pattern P is satisfactory if and only if there is such a constraint (P), is a consistency of P."}, {"heading": "5.2 AF-reduction of well-designed patterns", "text": "A well-designed pattern is defined as a union of non-union patterns. Since a union is satisfactory, if and only if one of its terms is equal, we will focus on union-free patterns, if a union-free pattern P is called a well-designed pattern, if? x also occurs in P outside of formQ, then? x x in C also defines a free pattern P of the form Q1 OPT Q2 in each union-free pattern P, and each? x x x also occurs in P outside formQ, then? x x in each union-free pattern P is defined as follows: \u2022 If P is a triple pattern, then this corresponds to P. \u2022 If P is of the form P1 AND P2, then we are of the form P2. \u2022 If P is of the P1 AND P2, then we are both equal."}, {"heading": "6 Conclusion", "text": "The results of this paper can be summarized by saying that satisfaction with SPARQL patterns is decidable until the constraints permitted in filter conditions can be combined to produce inconsistent constraints; otherwise, the problem is indecidable. In addition, satisfaction with well-designed patterns is also decidable. All of our positive results result in simple bottom-up syntactic checks that can be implemented efficiently. Therefore, we have tried to paint a fairly complete picture of the satisfaction problem for SPARQL. Of course, satisfaction is only the most basic automated thought task. It is now possible to move on to more complex tasks such as equivalence, implication, containment, or odd response to ontologies. Studies along this line for limited fragments of SPARQL are already taking place [LPS13, WEGL12, KGMSH12], and we hope that our work can provide some additional basis for these investigations."}], "references": [{"title": "The expressive power of SPARQL", "author": ["R. Angles", "C. Gutierrez"], "venue": "A. Sheth, S. Staab, et al., editors, Proceedings 7th International Semantic Web Conference, volume 5318 of Lecture Notes in Computer Science, pages 114\u2013129. Springer", "citeRegEx": "AG08", "shortCiteRegEx": null, "year": 2008}, {"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley", "citeRegEx": "AHV95", "shortCiteRegEx": null, "year": 1995}, {"title": "Querying semantic web data with SPARQL", "author": ["M. Arenas", "J. P\u00e9rez"], "venue": "Proceedings 30st ACM Symposium on Principles of Databases, pages 305\u2013316. ACM", "citeRegEx": "AP11", "shortCiteRegEx": null, "year": 2011}, {"title": "On the semantics of SPARQL", "author": ["M. Arenas", "J. P\u00e9rez", "C. Gutierrez"], "venue": "R. De Virgilio, F. Giunchiglia, and L. Tanca, editors, Semantic Web Information Management\u2014A Model-Based Perspective, pages 281\u2013307. Springer", "citeRegEx": "APG09", "shortCiteRegEx": null, "year": 2009}, {"title": "Completeness guarantees for incomplete ontology reasoners: Theory and practice", "author": ["B. Cuenca Grau", "B. Motik", "G. Stoilos", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research, 43:419\u2013476", "citeRegEx": "CGMSH12", "shortCiteRegEx": null, "year": 2012}, {"title": "Optimization of SPARQL by using coreSPARQL", "author": ["J. Groppe", "S. Groppe", "J. Kolbaum"], "venue": "J. Cordeiro and J. Filipe, editors, Proceedings 11th International Conference on Enterprise Information Systems, pages 107\u2013112", "citeRegEx": "GGK09", "shortCiteRegEx": null, "year": 2009}, {"title": "Journal of Artificial Intelligence Research", "author": ["I. Kollia", "B. Glimm. Optimizing SPARQL query answering over OWL ontologies"], "venue": "48:253\u2013303,", "citeRegEx": "KG13", "shortCiteRegEx": null, "year": 2013}, {"title": "Decision Procedures", "author": ["D. Kroening", "O. Strichman"], "venue": "Springer", "citeRegEx": "KS08", "shortCiteRegEx": null, "year": 2008}, {"title": "Static analysis and optimization of semantic web queries", "author": ["A. Letelier", "J. P\u00e9rez", "R. Pichler", "S. Skritek"], "venue": "ACM Transactions on Database Systems, 38(4):article 25", "citeRegEx": "LPPS13", "shortCiteRegEx": null, "year": 2013}, {"title": "Semantics and complexity of SPARQL", "author": ["J. P\u00e9rez", "M. Arenas", "C. Gutierrez"], "venue": "ACM Transactions on Database Systems, 34(3):article 16", "citeRegEx": "PAG09", "shortCiteRegEx": null, "year": 2009}, {"title": "From SPARQL to rules (and back)", "author": ["A. Polleres"], "venue": "C.L. Williamson, M.E. Zurko, et al., editors, Proceedings 16th World Wide Web Conference, pages 787\u2013796. ACM", "citeRegEx": "Pol07", "shortCiteRegEx": null, "year": 2007}, {"title": "W3C Recommendation", "author": ["RDF primer"], "venue": "February", "citeRegEx": "RDF04", "shortCiteRegEx": null, "year": 2004}, {"title": "Ultrawrap: SPARQL execution on relational data", "author": ["J.F. Sequeda", "D.P. Miranker"], "venue": "Web Semantics, 22:19\u201339", "citeRegEx": "SM13", "shortCiteRegEx": null, "year": 2013}, {"title": "W3C Recommendation", "author": ["RDF SPARQL query language for"], "venue": "January", "citeRegEx": "SPA08", "shortCiteRegEx": null, "year": 2008}, {"title": "J", "author": ["T. Tan"], "venue": "Van den Bussche, and X. Zhang. Undecidability of satisfiability in the algebra of finite binary relations with union, composition, and difference. arXiv:1406.0349", "citeRegEx": "TVdBZ14", "shortCiteRegEx": null, "year": 2014}, {"title": "SPARQL query containment under SHI axioms", "author": ["M. Wudage", "J. Euzenat", "P. Genev\u00e8s", "N. Lay\u00e4\u0131da"], "venue": "Proceedings 26th AAAI Conference, pages 10\u201316", "citeRegEx": "WEGL12", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 11, "context": "The Resource Description Framework (RDF) [RDF04] is a popular data model for information in the Web.", "startOffset": 41, "endOffset": 48}, {"referenceID": 13, "context": "0 [SPA08] with important features such as aggregation and regular expressions.", "startOffset": 2, "endOffset": 9}, {"referenceID": 1, "context": "Since SPARQL patterns can emulate relational algebra expressions [AG08, Pol07, AP11], and satisfiability for relational algebra is undecidable [AHV95], the general satisfiability problem for SPARQL is undecidable as well.", "startOffset": 143, "endOffset": 150}, {"referenceID": 14, "context": "Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference [TVdBZ14].", "startOffset": 151, "endOffset": 160}, {"referenceID": 9, "context": "At the end of the paper we look at a well-behaved class of patterns known as the \u2018well-designed\u2019 patterns [PAG09].", "startOffset": 106, "endOffset": 113}, {"referenceID": 3, "context": "This corresponds to the three-valued logic [APG09] one has to use when allowing arbitrary boolean combinations of constraints as filter conditions (something we have omitted for simplicity).", "startOffset": 43, "endOffset": 50}, {"referenceID": 14, "context": "1 SPARQL(\u00acbound) Our approach is to reduce from the satisfiability problem for the algebra of finite binary relations with union, difference, and composition [TVdBZ14].", "startOffset": 158, "endOffset": 167}, {"referenceID": 14, "context": "Theorem 7 ([TVdBZ14]).", "startOffset": 11, "endOffset": 20}, {"referenceID": 2, "context": "Finally, if e is of the form e1 \u2212 e2, we use a known idea [AP11].", "startOffset": 58, "endOffset": 64}, {"referenceID": 9, "context": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, with properties similar to the conjunctive queries for relational databases [AHV95].", "startOffset": 27, "endOffset": 34}, {"referenceID": 1, "context": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, with properties similar to the conjunctive queries for relational databases [AHV95].", "startOffset": 176, "endOffset": 183}, {"referenceID": 7, "context": "When \u03a3 is a set of (constant-) (non)equalities, like C(P ), consistency can be efficiently decided [KS08].", "startOffset": 99, "endOffset": 105}], "year": 2017, "abstractText": "The satisfiability problem for SPARQL patterns is undecidable in general, since the expressive power of SPARQL 1.0 is comparable with that of the relational algebra. The goal of this paper is to delineate the boundary of decidability of satisfiability in terms of the constraints allowed in filter conditions. The classes of constraints considered are bound-constraints, negated bound-constraints, equalities, nonequalities, constant-equalities, and constant-nonequalities. The main result of the paper can be summarized by saying that, as soon as inconsistent filter conditions can be formed, satisfiability is undecidable. The key insight in each case is to find a way to emulate the set difference operation. Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference. When no inconsistent filter conditions can be formed, satisfiability is efficiently decidable by simple checks on bound variables and on the use of literals. The paper also points out that satisfiability for the so-called \u2018well-designed\u2019 patterns can be decided by a check on bound variables and a check for inconsistent filter conditions.", "creator": "LaTeX with hyperref package"}}}