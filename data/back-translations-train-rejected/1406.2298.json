{"id": "1406.2298", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Jun-2014", "title": "Explaining Violation Traces with Finite State Natural Language Generation Models", "abstract": "An essential element of any verification technique is that of identifying and communicating to the user, system behaviour which leads to a deviation from the expected behaviour. Such behaviours are typically made available as long traces of system actions which would benefit from a natural language explanation of the trace and especially in the context of business logic level specifications. In this paper we present a natural language generation model which can be used to explain such traces. A key idea is that the explanation language is a CNL that is, formally speaking, regular language susceptible transformations that can be expressed with finite state machinery. At the same time it admits various forms of abstraction and simplification which contribute to the naturalness of explanations that are communicated to the user.", "histories": [["v1", "Mon, 9 Jun 2014 19:51:10 GMT  (22kb)", "http://arxiv.org/abs/1406.2298v1", null]], "reviews": [], "SUBJECTS": "cs.SE cs.CL", "authors": ["gordon j pace", "michael rosner"], "accepted": false, "id": "1406.2298"}, "pdf": {"name": "1406.2298.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Michael Rosner"], "emails": ["gordon.pace@um.edu.mt", "mike.rosner@um.edu.mt"], "sections": [{"heading": null, "text": "ar Xiv: 140 6.22 98v1 [cs.SE] 9 Jun 2ing and communicating to the user, system behavior which leads to a deviation from the expected behavior. Such behaviors are typically provided as long traces of system actions that would benefit from a natural linguistic explanation of the trace, especially in the context of specifications of corporate logic. In this essay, we present a model for generating natural language that can be used to explain such traces. A key idea is that the explanatory language is a CNL that formally constitutes regular linguistic transformations that can be expressed using finite state machines. At the same time, it allows various forms of abstraction and simplification that contribute to the naturalness of the explanations communicated to the user."}, {"heading": "1 Introduction", "text": "The growth in the size and complexity of computer systems has been accompanied by an increase in importance for the application of verification techniques, attempting to avoid or at least mitigate problems that arise due to errors in system design and implementation. Faced with a specification of how the system should behave (or what the system should not do), techniques ranging from testing to runtime verification are an attempt to answer the question of whether the system is correct or not. A common problem with all these techniques is that a negative response is useless unless accompanied by a trace that leads to a violation of the expected behavior."}, {"heading": "2 The Roles of NLG and CNL", "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "3 Languages", "text": "In the following, we will first introduce the C language and then a sequence of E languages, and gradually add features to get a more natural explanation of the track. As we will examine in more detail in Section 4, we will use more information at each stage to get a more natural text."}, {"heading": "3.1 The C Language", "text": "We assume that the basic specification of the C language is given by the automaton shown in Figure 2. The following track is a sencelgrxlblgwwxlgrwxlgxlblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblblplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplplpl"}, {"heading": "3.2 CNL0", "text": "Sentences of the CNL0 language are very simple declarative sentences of the kind we typically associate with simple predicate argument structures. In the example shown here, each sentence has a subject, a verb, and possibly a direct object. In this essay, the mapping between the C language and CLN0 is given extensively by means of a lexicon that connects the individual transitional names with a sentence with a simple and fixed syntactical structure. The lexicon itself is expressed as a finite state converter, as described in Section 4.1. For more complex systems, such an approach might not be practical, and a solution might then be to use the sentence of more fundamental properties of the underlying machine associated with each transition. CNL0 provides a somewhat naive explanation of traces using the explanation directly tested by the domain expert."}, {"heading": "3.3 CNL1", "text": "Next, we turn to CNL1, which offers some improvements; the main feature of CNL1 is that it is a paragraph sequence in which each paragraph is merely a sequence of CNL0 sentences, as illustrated in Figure 4. This slightly richer structure has two consequences: firstly, that it provides the skeleton on which the numbered steps can be hung; this is a presentation problem that undoubtedly increases naturalness and improves understanding; secondly, that it gives each paragraph a structural identity that could be exploited to attribute certain semantic properties to the associated sequence of actions."}, {"heading": "3.4 CNL2", "text": "The most important innovation in CNL2 (see Figure 5), as opposed to CNL1, is the use of aggregation to reduce each multi-sentence paragraph to a single, more complex sentence, a technique used to eliminate redundancy (see Dalianis and Hovy [DH93]), resulting in texts that are more fluid, acceptable, and generally less prone to misunderstandings by human readers than descriptions in CNL1 style. Linguistic representations resulting from aggregation in CNL2 include: 1. Punctuation other than stuff2. Temporal connections (\"after,\" \"then\" finally \") 3. The use of contrasting conjunctions such as\" but \"4. Collective terms (\" twice \")."}, {"heading": "3.5 CNL3", "text": "Finally, CNL3 (see Figure 6) is much more complex because it contains not only another aggregation, but also a summary. In this example, there are only two sentences. The first sentence not only aggregates the first six sentences, but also omitted some of the information (for example, that the user has read from a file, that the user has unsubscribed, etc.); it also includes the use of certain phrases, the correct interpretation of which, as already mentioned, requires consideration of the context of the occurrence as well as the use of adverbs (\"it tried unsuccessfully\") and the use of more complex tenses (\"should not have been allowed\")."}, {"heading": "4 Finite State Generation", "text": "In this section we will discuss the use of finite CNLs for NLG, which are based on finite state techniques embodied in xfst (Beesley and Karttunen [BK03]) and which are already used in several other areas of language processing such as computer morphology and light analysis. xfst provides a language to describe complex converters together with a compiler and a user interface for operating and testing converters. Our goal is to better understand the trade-offs that exist between generating reasonably natural explanations from traces and using the efficient computing machine described here."}, {"heading": "4.1 Na\u00efve Generation: CNL0", "text": "As in Figure 2, our starting point is a regular input language defined as a follower. {} SIGMA b | l | g | r | w; define C SIGMA *; SIGMA is the alphabet of the original FSA, and the entire generation mechanism accepts input containing arbitrary strings across that alphabet. Strings that yield the empty string, and therefore no output. CNL0 can be reached more or less directly via a dictionary linking the symbols in SIGMA to simple declarative sentences, as follows: 1 Some of the syntactically obscure aspects of this definition are omitted."}, {"heading": "4.2 Adding Structural Information: CNL1", "text": "s look at the following list of subtrace specifications using regular explanations: Correct login session: lg (r + w); Sequence of incorrect login requests: (lb).In CNL1, the main feature is that we use this information for group text. We will find that the following paragraph definitions are provided: Define correct l [r | w] x; Define incorrect [l] b; Define Group1 correctly @ - >...% |, incorrect @ - >% |; The Group1 definition contains a piece of XPst notation that causes a vertical bar to be inserted."}, {"heading": "4.3 Adding Aggregation: CNL2", "text": "We can now move on to CNL2. There are several intermediate stages, which are shown below:"}, {"heading": "A: l.g.r.x.|l.b.|l.g.w.w.x.|l.g.r.w.x.|l.g.x.|l.b.|l.b.|l.b.|l.", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "B: l,g,r,x.|l,b.|l,g,w,w,x.|l,g,r,w,x.|l,g,x.|l,b.|l,b.|l,b.|l.|", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "C: aggregation1", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "D: aggregation2", "text": "A is as in Figure 7. We must now prepare for aggregation by first replacing all paragraph markers with commas, except the final endpoints. As the converter that achieves this uses the paragraph marker to identify the final endpoint, we must first insert this last paragraph marker as shown in Figure B. The next two phases of aggregation can best be explained by the following example: We want to transform \"the user who wants to log in,\" but the user has specified a good password. the user logged out. \"the more natural\" in \"and\" entered a good password and logged out. \"The first phase removes the topic (i.e. the phrase\" the user \") of all sentences, but inserts the same topic again at the beginning of the paragraph. The second inserts\" and \"just before the final verb phrase of each aggregated sentence.\" In this way, we are able to reach the paragraph 2 rule, we can then fully orient the surface structure as in the CN2 example."}, {"heading": "4.4 Adding Abstraction: CNL3", "text": "We find that certain actions can be combined into a simpler explanation by abstracting away (possibly) irrelevant details, making it easier to understand. Consider, for example, the following rules, consisting of (i) a regular expression that corresponds to a collection of subtracts that can be explained more succinctly; and (ii) a natural linguistic explanation that could replace the detailed text that would be obtained from the entire subtraction: (lg (r + w) x) n declares as \"The user has successfully logged in n times.\" (lg (r + w) x) Failed login attempts: (lb) n declares as \"The user has tried unsuccessfully to log in n times.\" Correct login sessions interspersed with occasional wrong strategies: (lg (r + w) x)."}, {"heading": "4.5 Adding Contextuality: CNL4", "text": "To further enrich user explanations, we can expand the approach to CNL3 used in the previous section so that actions can be described using different terms in different contexts. For example, an unsubscribe action when logging in can be described as \"the unsubscribed user,\" while an unsubscribe action while the user is already logged out can be better described as \"the user tried to log out.\" We can use techniques similar to those used in the previous section by using regular expressions to specify contexts in which an action is described in a particular manner. Consider the following, in which each action and each pair of natural language descriptions is accompanied by two regular expressions that must match the part of the track immediately before and after the action in order to use this description2: 2 We will use the notation a to mark a single icon, except for a.Action Pre Post CNL renderingx * users logging out to locate another user."}, {"heading": "5 Discussion and Conclusions", "text": "Although much remains to be done, the results are promising and it is planned that we will adopt such an approach to enable the specification of explanations for natural languages that can be used in the Larva [CPS09] runtime check program. Two problems underlying our task are: (i) the discovery of subsequences that are of interest to the area in question, and (ii) how to turn an interesting subsequence into a natural-sounding explanation. In this paper, we have provided some ad hoc solutions to both problems. While profiling techniques can be used to detect interesting or frequently occurring subsequences, there clearly needs to be a strong human input to determine which of these sequences should be used for abstraction in order to explain traces more effectively. On the other hand, we see that many of the ad hoc solutions used to make explanations sound more natural can be generalized."}], "references": [{"title": "Finite State Morphology. Number v. 1 in Studies in computational linguistics", "author": ["K.R. Beesley", "L. Karttunen"], "venue": "CSLI Publications,", "citeRegEx": "Beesley and Karttunen.,? \\Q2003\\E", "shortCiteRegEx": "Beesley and Karttunen.", "year": 2003}, {"title": "Larva \u2014 safer monitoring of real-time java programs (tool paper)", "author": ["Christian Colombo", "Gordon J. Pace", "Gerardo Schneider"], "venue": "In Seventh IEEE International Conference on Software Engineering and Formal Methods (SEFM),", "citeRegEx": "Colombo et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Colombo et al\\.", "year": 2009}, {"title": "Aggregation in natural language generation", "author": ["Hercules Dalianis", "Eduard H. Hovy"], "venue": "EWNLG, volume 1036 of Lecture Notes in Computer Science,", "citeRegEx": "Dalianis and Hovy.,? \\Q1993\\E", "shortCiteRegEx": "Dalianis and Hovy.", "year": 1993}, {"title": "A survey and classification of controlled natural languages", "author": ["Tobias Kuhn"], "venue": "Computational Linguistics,", "citeRegEx": "Kuhn.,? \\Q2014\\E", "shortCiteRegEx": "Kuhn.", "year": 2014}, {"title": "Owl simplified english: A finite-state language for ontology editing", "author": ["Richard Power"], "venue": "CNL, volume 7427 of Lecture Notes in Computer Science,", "citeRegEx": "Power.,? \\Q2012\\E", "shortCiteRegEx": "Power.", "year": 2012}, {"title": "Building Natural Language Generation Systems", "author": ["Ehud Reiter", "Robert Dale"], "venue": null, "citeRegEx": "Reiter and Dale.,? \\Q2000\\E", "shortCiteRegEx": "Reiter and Dale.", "year": 2000}, {"title": "Pipelines, templates and transformations: Xml for natural language generation", "author": ["G. Wilcock"], "venue": "Proceedings of the First NLP and XML Workshop, NLPXML 2001EWNLG, Lecture Notes in Computer Science,", "citeRegEx": "Wilcock.,? \\Q2001\\E", "shortCiteRegEx": "Wilcock.", "year": 2001}, {"title": "Simplifying and isolating failure-inducing input", "author": ["Andreas Zeller", "Ralf Hildebrandt"], "venue": "IEEE Trans. Softw. Eng.,", "citeRegEx": "Zeller and Hildebrandt.,? \\Q2002\\E", "shortCiteRegEx": "Zeller and Hildebrandt.", "year": 2002}], "referenceMentions": [], "year": 2017, "abstractText": "An essential element of any verification technique is that of identifying and communicating to the user, system behaviour which leads to a deviation from the expected behaviour. Such behaviours are typically made available as long traces of system actions which would benefit from a natural language explanation of the trace and especially in the context of business logic level specifications. In this paper we present a natural language generation model which can be used to explain such traces. A key idea is that the explanation language is a CNL that is, formally speaking, regular language susceptible transformations that can be expressed with finite state machinery. At the same time it admits various forms of abstraction and simplification which contribute to the naturalness of explanations that are communicated to the user.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}