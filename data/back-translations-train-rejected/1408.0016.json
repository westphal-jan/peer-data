{"id": "1408.0016", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jun-2014", "title": "Architecture of a Web-based Predictive Editor for Controlled Natural Language Processing", "abstract": "In this paper, we describe the architecture of a web-based predictive text editor being developed for the controlled natural language PENG$^{ASP)$. This controlled language can be used to write non-monotonic specifications that have the same expressive power as Answer Set Programs. In order to support the writing process of these specifications, the predictive text editor communicates asynchronously with the controlled natural language processor that generates lookahead categories and additional auxiliary information for the author of a specification text. The text editor can display multiple sets of lookahead categories simultaneously for different possible sentence completions, anaphoric expressions, and supports the addition of new content words to the lexicon.", "histories": [["v1", "Fri, 27 Jun 2014 01:00:59 GMT  (301kb,D)", "http://arxiv.org/abs/1408.0016v1", null]], "reviews": [], "SUBJECTS": "cs.CL cs.AI", "authors": ["stephen guy", "rolf schwitter"], "accepted": false, "id": "1408.0016"}, "pdf": {"name": "1408.0016.pdf", "metadata": {"source": "CRF", "title": "Architecture of a Web-based Predictive Editor for Controlled Natural Language Processing", "authors": ["Stephen Guy", "Rolf Schwitter"], "emails": ["Stephen.Guy@mq.edu.au", "Rolf.Schwitter@mq.edu.au"], "sections": [{"heading": null, "text": "Keywords: controlled processing of natural language, predictive editor, web-based authoring tools, programming of response sentences"}, {"heading": "1 Introduction", "text": "Writing a specification in a controlled natural language without any tool support is a difficult task, as the author must learn and remember the limitations of controlled language. Over the past decade, a number of different techniques and tools have been proposed and implemented to minimize learning effort and support the writing process of controlled natural languages.The most promising approach to alleviating these habitability problems is the use of a predictive text editor [13,17] that limits what the author can write and provides predictive feedback that guides the author's writing process. In this essay, we introduce the architecture of a web-based predictive text editor developed for the controlled natural language PENGASP. The text editor uses an event-driven model view controller architecture to meet a number of user input and display requirements, including displaying multiple groups of preview categories for completing different sentence phrases, deleting lexical words, and adding lexicon inserts."}, {"heading": "2.1 Client-Server Architecture", "text": "The PENGASP system is based on a client-server architecture in which the predictive editor runs in a web browser and communicates with the controlled Natural Language Processor via an HTTP server; in our case, the language processor uses an Answer Set Programming (ASP) tool as an argumentation service (fig. 1): The communication between the predictive editor and the HTTP server is carried out asynchronously using AJAX technologies and using JSON1 objects. The predictive editor is implemented in JavaScript2 and JQuery3. Both the HTTP server and the controlled Natural Language Processor are implemented in SWI Prolog4. The prolog server translates JSON objects into JSON terms and vice versa so that these terms can be processed directly by the language processor. The language processor translates the controlled language input step by step via this discourse content program to ASP [6] and ASP sends a response to this program [7 and ASP]."}, {"heading": "2.2 HTTP Server", "text": "SWI-Prolog provides a number of libraries for implementing HTTP server functionality. Our server is based on this technology and can operate as a standalone server on all platforms supported by SWI-Prolog. The following code fragment illustrates how to create an HTTP server, specify a port (8085) and send a request using a handler registry (http handler / 3): server (port): - http _ server (http _ dispatch, [port (port)]).: - http _ handler ('/ peng /', handle, []). handle (Request): -...: - server (8085).1 http: / / json.org / 2 http: / / www.ecmascript.org / 3 http: / / jquery.com / 4 http: / / / www.swi-prolog.org / In our case, we can now connect to the web browser and the JavaScript editor using http: / / localhost 8085 / handcript."}, {"heading": "2.3 Predictive Editor", "text": "The predictive editor is implemented in JavaScript and JQuery, with the Superfish5 plug-in providing the pull-down menu functionality, which allows the editor to run in most browsers, providing a highly portable system in conjunction with the capabilities of a potentially remote language processor encoded in Prolog. Data communication with the server provides menu menu menu functions, such as saving and loading files, as well as data transfer between the language menu processor and the predictive editing system. JSON menu menu menu menu data sent to the HTTP server by the predictive editor includes menu menu menu menu menu item labels for a word, its position in the relevant sentence, and the relevant sentence number. For each word form or completed sentence submitted by the predictive editor, the preview menu categories and word shapes are presented together with the output of the language menu processor."}, {"heading": "3.1 Controlled Natural Language Processor", "text": "The controlled natural language processor of the PENGASP system consists of a diagram parser, a unification-based grammar, a lexicon and a spell proofread.5 http: / / users.tpg.com.au / j _ birch / plugins / superfish / However, the chart parser is initialized for the first time when the author moves the cursor into the predictive editor's text field and resets it at the beginning of each new sentence, generating predictive categories using the grammar and lexicon of the controlled language processor. These predictive categories inform the author of a specification how to begin a sentence and dynamically generate a sentence for each word form that the author enters into the editor's text field and generates predictive categories that the author can use only word forms and the lexicon of the controlled language processor. These predictive categories inform the author of a specification how the author of a sentence begins and dynamically generates word form for each word form that the author gives to the author, the author of the word form that the author entered."}, {"heading": "3.2 Reasoning Service", "text": "Since we are interested in specifying common sense theories in PENGASP, we need a non-monotonous thought service. ASP is a relatively novel, logic-based knowledge representation formalism that has its roots in logical programming with negation, deductive databases, non-monotonous arguments, and the resolution of constraints [1,7]. An ASP program consists of a set of rules of the following form: L0;...; Lk: - Lk + 1,..., Lm, not Lm + 1,..., not Ln.where all Li's are literal (literally is an atom or its negation. A positive atom has the form p (t1,..., tn), where p is a predicate symbol for arthritis n and t1,... tn are object constants or variables. A negative atom has the form -p (t1,..., tn), where the symbol of the head symbol - the implication - the rule is: the expression of the left hand."}, {"heading": "4 Predictive Editor Requirements", "text": "In addition to the general requirements outlined in Section 2.3, the Lookahead Categories specify a set of detailed requirements for user input and system representation to help design the predictive editor architecture. The main requirements are that the system allow for appropriate editing of information already entered, that the Lookahead Categories are displayed for a certain sentence position until there are no more options, and that the Lookahead Categories for the next sentence position are displayed as quickly as possible as soon as the appropriate options are available. These requirements are detailed in the following sections."}, {"heading": "4.1 User and System Requirements", "text": "Requirement E.1.1: The system allows the deletion of characters or words that have already been entered, or a whole or part of a sentence that has not yet been submitted. (This deletion is called reverse processing.) Requirement E.2.1: A new sentence will not be started (via the chart parser that will be reset) until a template or an input event or the beginning of a sentence occurs after the end of a sentence (period or question mark). A new sentence that is started means that the previous sentence has been submitted. Requirement E.3.1: A user may enter a content word that is not contained in the lexicon and force its submission to the language processor as the next content word. Requirement E.3.2: A user may enter a misspelled word that still needs to be completed with the word."}, {"heading": "4.2 Display of Multiple Sentence Completions", "text": "The two most important cases to consider are the presence of subsets within the preview categories for a sentence position and the permitted juxtaposition of punctuation immediately after a word without spaces. In the case of subsets in preview categories, consider the beginning of a sentence and the two above-mentioned display requirements D.1.1 and D.2.1. Initial preview categories can include \"The,\" \"There is,\" \"A,\" \"Thelma,\" \"John\" and \"Johnathan,\" which according to D.1.1 should all be displayed by the system. A user entering the characters \"The\" would then meet requirement D.2.1, displaying the preview categories for the next position. If these categories contained the word \"child,\" the user could type that word and the text entered would be \"The child,\" illustrating the need to display that sentence completion."}, {"heading": "5 Architecture of the Predictive Editor", "text": "The predictive editor is designed to meet the requirements of the PENGASP system, asynchronous client-server communication, different editor input modes, and user input and system display requirements."}, {"heading": "5.1 Model-View-Controller Architecture", "text": "The architecture of the predictive editor is similar to that of a Model View Controller (MVC) system in terms of separation and independence [4,16]. The model includes the currently active sentence, including the sentence entered by the user and transmitted to the HTTP server, all previously entered sentences and all data (including lookahead categories) received by the language processor via the HTTP server. The model also stores all variables relevant to determining the system state. The view includes the event-driven input field, the pull-down menu representation of lookahead categories, and the input of word shapes via mouseover selection. It also displays the overall model of the sentences entered and the ASP model generated by the language processor. The controller synchronizes all functions and monitors in particular the need for a change in the state in the model, e.g. when the user has entered data different from the currently active sentence, and yes, if new data should not be transferred to the server or not."}, {"heading": "5.2 Event-Triggered Implementation", "text": "A key problem with implementing the MVC architecture is the requirement that event-driven data processing and control must be compatible with asynchronous AJAX communication between the predictive editor and the HTTP server and event-driven predictive editor input. If content is transmitted via JSON data to the HTTP server, the predictive editor system must wait until appropriate predictive data is returned from the server. Once this information is received, it can be stored in the model and only then can the controller process this model data to determine whether the model state variables should be changed, and update the display if necessary. To implement this, the controller organizes runtime execution of events in a pipeline and filter architecture, where each element of the pipeline is a data structure containing the relevant primary data for this event, the relevant processing function and an optional linking of events in a pipeline and filter architecture, may be a data structure that determines the relevant primary data for this event, the relevant processing function, and an optional linking of this to the next data structure in the pipeline, for example, while this may not be a data structure in the pipeline."}, {"heading": "5.3 Data Structures", "text": "As with many client-server systems, some model data is stored and processed on the predictive editor page for optimal processing and control. Model data is stored in objects defined by JavaScript functions, declaring appropriate object methods to allow for convenient processing of this data. Model data includes, for example, batch objects (which contain stacks of word shapes up to entire sentences), individual sent and received objects, and a single object of correlated send and receive data. Methods can detect whether a beginning or end of a sentence character is present, or whether a word form matches a preview category, and whether it is also a subset of another preview category (e.g. \"The,\" which is a subset of \"There\"). Ad objects allow different preview categories to be stored and the ability to change the display from \"hidden to\" and vice versa."}, {"heading": "5.4 Predictive Editor Controller", "text": "In view of the requirements for user input and system display discussed in Section 4.1 and the general requirements outlined in Section 2.3, the predictive editor control system is designed to allow multiple predictive categories to be displayed for different sentence completions and to have strict control over when the data entered by the user is ultimately transferred to the server. The currently activated sentence is stored in two forms, namely a tokenization of user input and a summary of the data submitted to the server. By comparing a stack of token sets / words in each sentence, a differential stack is generated that helps the controller determine a change in the model state. Any newly entered valid words or changes to the current word are evaluated for submission or alternatively previously submitted tokens / words can be removed and new tokens sent to their place (e.g. in the case of backward processing). As in relation to Request D.2.1, this category is specified as a preview for a subitem."}, {"heading": "5.5 Adding Content Words to the Lexicon", "text": "Remember the requirement E.3.1 that a user may forcibly submit a word form to language processing that does not match the lexicon. If this happens, language processing may submit a number of spelling suggestions (provided that an incorrect word has been submitted by mistake) or the prediction editor may offer an option to add this new word to the lexicon in this current context. If the user chooses to add a word, the position in the sentence, the lexical category and the new word form are collected and sent to the server, where the new word is added to the lexicon. The new word is then re-analyzed by language processing and a new set of prediction categories is generated and sent to the prediction editor."}, {"heading": "6 Future Research", "text": "The current predictive editor can be extended for multiple users according to the web-based portability of the system. A user login would enable a number of functions, such as a user-group-based lexicon, depending on the nature of the specification system for that group (e.g. medicine, technology, automotive, etc.). Additionally, a person could have their own extended lexicon for any content words to be added to the lexicon. A user could set a level of knowledge for their grammar that would help control the complexity of pull-down menus, since a user with limited knowledge could use a smaller number of less technical word categories such as \"functional words\" instead of individual groups such as \"adjective,\" adverb, \"\" noun, \"etc., to set preferences for further customizable improvements."}, {"heading": "7 Conclusion", "text": "The web-based prediction editor supports the writing process of these specifications and is based on a portable client-server architecture and is implemented predominantly in JavaScript. An event-driven model view controller-based architecture was used for the editor, which allows strict control of system functionality to meet a number of user input and rendering requirements, including the display of multiple categories for different sentence completions. The prediction editor enables new words of content to be added to the lexicon and supports the selection of anaphorical expressions. An extension of a user login would allow customization of preferences and a user-based lexicon."}, {"heading": "1. Brewka, G., Eiter, T., Truszczyn\u0301ski, M.: Answer Set Programming at a Glance. In:", "text": "In: J. van Benthem and A. ter Meulen (eds.), Handbook of Logic and Language, Second Edition, Elsevier, pp. 181-252 (2011) 3. Franconi, E., Guagliardo, P., Trevisan, M., Tessaris S.: Quelo: an ontology-driven query interface. In: Proceedings of the 24th International Workshop on Description Logics (DL 2011), (2011) 4. Freeman, E., Robson, E., Bates, B., Sierra, K.: Head First Design Patterns, O'Reilly, pp. 526-577, (2004) 5. Fuchs, N.E., Kaljurand, K., Kuhn, T.: Attempto Controlled English for Knowledge Representation."}], "references": [{"title": "Answer Set Programming at a Glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Communications of the ACM, Vol. 54, No. 12, December", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "Discourse Representation in Context", "author": ["J. van Eijck", "H. Kamp"], "venue": "J. van Benthem and A. ter Meulen (eds.), Handbook of Logic and Language, Second Edition, Elsevier, pp. 181\u2013252", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Quelo: an ontology-driven query interface", "author": ["E. Franconi", "P. Guagliardo", "M. Trevisan", "Tessaris S."], "venue": "Proceedings of the 24th International Workshop on Description Logics (DL 2011),", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Head First Design Patterns, O\u2019Reilly, pp", "author": ["E. Freeman", "E. Robson", "B. Bates", "K. Sierra"], "venue": "526\u2013577,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2004}, {"title": "Attempto Controlled English for Knowledge Representation", "author": ["N.E. Fuchs", "K. Kaljurand", "T. Kuhn"], "venue": "C. Baroglio, P.A. Bonatti, J. Maluszynski, M. Marchiori, A. Polleres, S. Schaffert, (eds.), Reasoning Web, Fourth International Summer School 2008, LNCS 5224, pp. 104\u2013124", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2008}, {"title": "Potassco: The Potsdam Answer Set Solving Collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": "AI Communications, Vol. 24, No. 2, pp. 105\u2013124,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Vol. 6, No. 3, pp. 1\u2013238", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "From Discourse to Logic", "author": ["H. Kamp", "U. Reyle"], "venue": "Kluwer, Dordrecht", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1993}, {"title": "Writing Support for Controlled Natural Languages", "author": ["T. Kuhn", "R. Schwitter"], "venue": "Proceedings of ALTA, Tasmania, pp. 46\u201354,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "Logic Programs vs", "author": ["Y. Lierler", "V. Lifschitz"], "venue": "First-Order Formulas in Textual Inference. In: Proceedings of the 10th International Conference on Computational Semantics (IWCS 2013), Potsdam, Germany, pp. 340\u2013346,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "What is Answer Set Programming? In: Proceedings of AAAI 2008, pp", "author": ["V. Lifschitz"], "venue": "1594\u20131597,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2008}, {"title": "OWL Simplified English: a finite-state language for ontology editing", "author": ["R. Power"], "venue": "Kuhn, T. and Fuchs, N.E. (eds): Proceedings of CNL 2012, Springer, Heidelberg, pp. 44\u201360,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "ECOLE: A Look-ahead Editor for a Controlled Language", "author": ["R. Schwitter", "A. Ljungberg", "D. Hood"], "venue": "Proceedings of EAMT-CLAW03, Dublin, pp. 141\u2013150,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2003}, {"title": "Controlled Natural Languages for Knowledge Representation", "author": ["R. Schwitter"], "venue": "Proceedings of COLING 2010, Beijing, China, pp. 1113\u20131121,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2010}, {"title": "The Jobs Puzzle: Taking on the Challenge via Controlled Natural Language Processing", "author": ["R. Schwitter"], "venue": "Journal of Theory and Practice of Logic Programming, Vol. 13, Special Issue 4-5, pp. 487\u2013501", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2013}, {"title": "In: Software Engineering, International Edition, Ninth Edition, Pearson, pp", "author": ["I. Sommerville"], "venue": "155\u2013164,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Menubased natural language understanding", "author": ["H.R. Tennant", "K.M. Ross", "R.M. Saenz", "C.W. Thompson", "J.R. Miller"], "venue": "Proceedings of ACL, pp. 151\u2013158,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1983}, {"title": "An Update on PENG Light", "author": ["C. White", "R. Schwitter"], "venue": "L. Pizzato and R. Schwitter (eds.), Proceedings of ALTA 2009, Sydney, Australia, pp. 80\u201388,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 2, "context": "Over the last decade, a number of different techniques and tools [3,5,12,13] have been proposed and implemented to minimise the learning effort and to support the writing process of controlled natural languages.", "startOffset": 65, "endOffset": 76}, {"referenceID": 4, "context": "Over the last decade, a number of different techniques and tools [3,5,12,13] have been proposed and implemented to minimise the learning effort and to support the writing process of controlled natural languages.", "startOffset": 65, "endOffset": 76}, {"referenceID": 11, "context": "Over the last decade, a number of different techniques and tools [3,5,12,13] have been proposed and implemented to minimise the learning effort and to support the writing process of controlled natural languages.", "startOffset": 65, "endOffset": 76}, {"referenceID": 12, "context": "Over the last decade, a number of different techniques and tools [3,5,12,13] have been proposed and implemented to minimise the learning effort and to support the writing process of controlled natural languages.", "startOffset": 65, "endOffset": 76}, {"referenceID": 12, "context": "The most promising approach to alleviate these habitability problems is the use of a predictive text editor [13,17] that constrains what the author can write and provides predictive feedback that guides the writing process of the author.", "startOffset": 108, "endOffset": 115}, {"referenceID": 16, "context": "The most promising approach to alleviate these habitability problems is the use of a predictive text editor [13,17] that constrains what the author can write and provides predictive feedback that guides the writing process of the author.", "startOffset": 108, "endOffset": 115}, {"referenceID": 14, "context": "In this paper, we present the architecture of a web-based predictive text editor being developed for the controlled natural language PENG [15].", "startOffset": 138, "endOffset": 142}, {"referenceID": 10, "context": "Additionally, the text editor displays a paraphrase for each input sentence and displays the evolving Answer Set Program [11].", "startOffset": 121, "endOffset": 125}, {"referenceID": 7, "context": "The language processor incrementally translates the controlled language input via discourse representation structures [8] into an ASP program and sends this ASP program to the ASP tool clingo [6,7] that tries to generate one or more satisfiable answer sets for the program.", "startOffset": 118, "endOffset": 121}, {"referenceID": 5, "context": "The language processor incrementally translates the controlled language input via discourse representation structures [8] into an ASP program and sends this ASP program to the ASP tool clingo [6,7] that tries to generate one or more satisfiable answer sets for the program.", "startOffset": 192, "endOffset": 197}, {"referenceID": 6, "context": "The language processor incrementally translates the controlled language input via discourse representation structures [8] into an ASP program and sends this ASP program to the ASP tool clingo [6,7] that tries to generate one or more satisfiable answer sets for the program.", "startOffset": 192, "endOffset": 197}, {"referenceID": 14, "context": "The controlled natural language PENG [15] that the author uses as input language has been designed as a high-level interface language to ASP programs.", "startOffset": 37, "endOffset": 41}, {"referenceID": 17, "context": "In certain aspects the language PENG is similar to PENG Light [18] and Attempto Controlled English [5], since it uses a version of discourse representation theory (DRT), in the spirit of [2,8], as intermediate representation language.", "startOffset": 62, "endOffset": 66}, {"referenceID": 4, "context": "In certain aspects the language PENG is similar to PENG Light [18] and Attempto Controlled English [5], since it uses a version of discourse representation theory (DRT), in the spirit of [2,8], as intermediate representation language.", "startOffset": 99, "endOffset": 102}, {"referenceID": 1, "context": "In certain aspects the language PENG is similar to PENG Light [18] and Attempto Controlled English [5], since it uses a version of discourse representation theory (DRT), in the spirit of [2,8], as intermediate representation language.", "startOffset": 187, "endOffset": 192}, {"referenceID": 7, "context": "In certain aspects the language PENG is similar to PENG Light [18] and Attempto Controlled English [5], since it uses a version of discourse representation theory (DRT), in the spirit of [2,8], as intermediate representation language.", "startOffset": 187, "endOffset": 192}, {"referenceID": 9, "context": "Beyond that, ASP is still expressive enough to represent function-free FOL formulas of the \u2203\u2217\u2200\u2217 prefix class in form of a logic program [10].", "startOffset": 136, "endOffset": 140}, {"referenceID": 0, "context": "ASP is a relatively novel logic-based knowledge representation formalism that has its roots in logic programming with negation, deductive databases, non-monotonic reasoning and constraint solving [1,7].", "startOffset": 196, "endOffset": 201}, {"referenceID": 6, "context": "ASP is a relatively novel logic-based knowledge representation formalism that has its roots in logic programming with negation, deductive databases, non-monotonic reasoning and constraint solving [1,7].", "startOffset": 196, "endOffset": 201}, {"referenceID": 3, "context": "The architecture of the predictive editor is based approximately on that of a Model-View-Controller (MVC) system [4,16] in terms of separation and independence.", "startOffset": 113, "endOffset": 119}, {"referenceID": 15, "context": "The architecture of the predictive editor is based approximately on that of a Model-View-Controller (MVC) system [4,16] in terms of separation and independence.", "startOffset": 113, "endOffset": 119}], "year": 2014, "abstractText": "In this paper, we describe the architecture of a web-based predictive text editor being developed for the controlled natural language PENG . This controlled language can be used to write non-monotonic specifications that have the same expressive power as Answer Set Programs. In order to support the writing process of these specifications, the predictive text editor communicates asynchronously with the controlled natural language processor that generates lookahead categories and additional auxiliary information for the author of a specification text. The text editor can display multiple sets of lookahead categories simultaneously for different possible sentence completions, anaphoric expressions, and supports the addition of new content words to the lexicon.", "creator": "LaTeX with hyperref package"}}}