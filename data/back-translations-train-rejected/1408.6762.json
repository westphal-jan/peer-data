{"id": "1408.6762", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Aug-2014", "title": "Chatbot for admissions", "abstract": "The communication of potential students with a university department is performed manually and it is a very time consuming procedure. The opportunity to communicate with on a one-to-one basis is highly valued. However with many hundreds of applications each year, one-to-one conversations are not feasible in most cases. The communication will require a member of academic staff to expend several hours to find suitable answers and contact each student. It would be useful to reduce his costs and time.", "histories": [["v1", "Thu, 28 Aug 2014 16:01:10 GMT  (1916kb)", "http://arxiv.org/abs/1408.6762v1", null]], "reviews": [], "SUBJECTS": "cs.CY cs.CL", "authors": ["nikolaos polatidis"], "accepted": false, "id": "1408.6762"}, "pdf": {"name": "1408.6762.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Peter Hancox"], "emails": [], "sections": [{"heading": null, "text": "The communication of potential students with a university department is done manually and is a very time-consuming procedure. The possibility to communicate with a student one-on-one is highly appreciated. With many hundreds of applications per year, face-to-face interviews are not feasible in most cases. Communication takes several hours to find suitable answers and to contact each student. It would be useful to reduce its cost and time. The project aims to reduce the burden on the head of admissions and potential other users by developing a convincing chatbot. An appropriate algorithm needs to be developed to search the data set and find a potential answer. The program then responds to the user and provides a relevant web link if the user is not satisfied with the answer. In addition, a web interface for both the user and an administrator is developed. The achievements of the project can be summarized as follows: To prepare the background of the project, a literature review has been carried out, together with an analysis of access tools and a feedback system with the corresponding requirements of the algorithm has been developed."}, {"heading": "Acknowledgements", "text": "I would like to thank Dr. Peter Hancox for his invaluable help and support during this project and also the computer support team for his excellent help and instructions.Finally, I feel the need to acknowledge the constant support of my parents.Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsChapter 1: Table of contentsDirectories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories Directories"}, {"heading": "2.2.1 ELIZA ................................................................................................................. 12", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.2.2 A.L.I.C.E ............................................................................................................. 12", "text": "2.3 Learning chatbots...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... 152.6.3 Hibernates... 153.3 Hibernates..."}, {"heading": "1.1 Context", "text": "Although the admissions process works as it is, it is very difficult and time-consuming to contact a university employee. However, the problem would be partially solved if the applicant could talk to a compelling chatbot who is able to respond to his concerns with information about admissions, accommodation booking, payment of fees in installments and the pre-courses offered. Chatbot should be able to communicate with a user similar to: ChatBot: Hello, how can I help you? User: What other test is accepted by the department? ChatBot: What is the minimum score of IELTS required for admission to the MSc Computer Science course? ChatBot: The minimum requirement is a total score of 6.0 with no less than 5.5 in any section. User: What other test is accepted by the department? ChatBot: We also accept TOEFL and the Certificate of Proficiency of the University of Cambridge. User: What are the admissions requirements for the 2nd grade computer security program to have in order to complete at least one degree?"}, {"heading": "1.2 Aims and Objectives", "text": "The main objectives of this project are: Database: To develop a database, all relevant information about questions, answers, keywords, protocols and feedback has been stored. Algorithm: To develop and combine a keyword matching algorithm and a string distance comparison algorithm to get the best possible answer. Interface: To develop a web interface that will allow potential students and their families to submit questions in a chatbot and get compelling answers. The web system can be hosted on any computer that supports an operating system to which the Java virtual machine can load. In addition, Hibernate, Spring, Apache Wicket, Lingpipe, the Jazzy notation, the Stanford NLP parser and Google search libraries should be available."}, {"heading": "1.3 Achievements", "text": "The following objectives were achieved: study of a set of algorithms to solve the problem of direct communication with the University and develop an algorithm that combines the use of keyword matching with String Distance. Design and implementation of a usable chat system, which was expanded after user evaluation. Evaluation of the extended system with users. Use of the system by potential students of the University. Completion of a literature review to learn more about the processing of natural language, study of existing tools and define requirements."}, {"heading": "1.4 Methodology", "text": "The waterfall model follows a series of processes that are applied during development. Usually, the individual phases require the capture of the requirements and their analysis. The design of the system is the next step, followed by the encoding of the actual system. Then, evaluation, testing and, if necessary, debugging are the next step. Finally, the system is either accepted and thus maintained or discarded. It is crucial to move on to the next process of the waterfall model once the previous step has been completed."}, {"heading": "1.5 Contributions", "text": "A number of new concepts were incorporated into the system: a keyword matching algorithm was used in combination with a string similarity algorithm to provide a better response, and is described in Sections 4.2.1, 4.2.2 and 4.2.3; the Stanford parser was also used to analyze the structure of the given sentence, as described in Section 4.2.5; and finally, the system was evaluated based on feedback and protocols from potential students using it, as described in Section 6.2."}, {"heading": "1.6 Outline of Dissertation", "text": "This report is divided into several chapters.Chapter two covers background research, which gives an overview of chatbots, chatter bot interactions with humans, matching algorithms and current systems. Chapter three provides an overview and covers the requirements of the system. Chapter four covers the design of the system. It covers database design, an explanation of the algorithms and how they work. It goes on to explain the functionality of the system for users and the administrator. Chapter five covers the implementation of the system. The system is described with further details on the technologies used. Chapter six contains the evaluation and testing of the final system. Chapter seven is the conclusion of the project. It contains a summary, the main achievements, its limitations and future work.Chapter 2Background researchThis chapter contains background research on topics relevant for approval communication. It presents an overview of chatbots and their interaction with people. In addition, the keyword and template matching algorithms are mentioned, followed by examples of applications."}, {"heading": "2.1 Chatbots", "text": "A chatbot is a program used to participate in conversations with people. It uses a suitable interface for input and output, and can provide realistic answers through the use of AI techniques so that the user thinks that communication with another person is taking place. Implementation of such systems varies from the use of keyword matching, string similarity or complex processing techniques of natural language. More sophisticated chatbots could learn from the user's input. Nowadays, chat bots are often used in web applications to provide help or information when asked by users. \"Chatbots are computer programs that interact with users in natural languages [21].\""}, {"heading": "2.2 Existing applications", "text": "Chatbots are used in many organizations instead of people when possible. Systems like this are mostly based on the way ELIZA or ALICE communicate."}, {"heading": "2.2.1 ELIZA", "text": "The first chatbot to be developed was ELIZA [21]. It was developed by Joseph Weizenbaum using a keyword matching technique. The idea was to read the user's input and search for specific keywords when a keyword was found, then the answer was retrieved. If a keyword did not exist, ELIZA would try to get more information from the user in accordance with given rules to keep the conversation going. Consider the following example to understand how it would work. User: How can I get in touch with my mother? Then the chatbot would identify the keyword mother and find a connection between mother and family and it would answer with a question. ELIZA: Tell me more about your familyThe chatbot does not understand what it says. It only produces rule-compliant results and in this case there was a rule connecting mother and family. Then it had to produce an answer that would encourage the user to submit another question, the keyword to find a hope."}, {"heading": "2.2.2 A.L.I.C.E", "text": "An AIML file resembles an XML file designed to store pattern knowledge for chatbots. There are three types of AIML categories, atomic categories, default categories and recursive categories, which are described below. Atomic categories: Is a type of AIML category where there is an exact match. < Category > < Pattern > What is Your Name < / Pattern > < Template > My Name is Nick < / Template > < / Category >"}, {"heading": "In the above example if the user submits \u201cWhat is your name\u201d then the chatbot will reply with \u201cMy name is Nick\u201d.", "text": "Default Categories: Is a type of AIML category where the use of a wildcard like * is used to match all entries? < Category > < Pattern > What is * < Pattern > < Template > < / Category > If ALICE does not find a solution with the first category, it will move on to the second. In this case, if a user enters \"What is a name,\" ALICE will perform a check until the wildcard is found, and if there is a match, it will come with the answer. Recursive Categories: Is a type of AIML category where special tags are used to convince the user to be more specific. < Category > < Pattern > Know what that * is < Pattern > < Template > < Template > < Template > It is My Name < srai > What is < / srai > < Pattern > < If you know what is the pattern > < When the pattern is shortened, < If the pattern is <"}, {"heading": "2.3 Learning chatbots", "text": "The intelligence of the chatbot is based on predefined rules and assuming that the user gives a correct answer. There are two types of learning and both use the same learning rules. The first will understand what the user has said, will store it for the current session and will give this answer when the user asks for it. The second will store the information in its database and will respond with this answer for each user. Certain rules can be set to understand from previous user input whether there is a possibility that a user is telling the truth or not, and decides to store the information for future users. Questions and answers between users can also be stored and compared in the database to detect the possibility that something is true. The following conversation gives an example of the learning process. User: How many lecturers are there in the computer science department? Chatbot: I'm sorry, but I don't know the answer. Maybe you can help me learn users: There are 28 lecturers in the chatbot department? Is this the right one?"}, {"heading": "2.4 Interaction with humans", "text": "Most chatbots are designed to serve specific purposes, and if a person tries to trick the chatbot, it is likely that he will succeed. Besides, people do not believe that a computer program will be able to satisfy their needs, and they do not even try to interact with each other. Even if a person knows that a chatbot has extensive knowledge, he will be more demanding. In the event that we need to convince a person that the conversation is taking place with another person, an extensive database must be used along with certain rules, such as answering multiple questions, the occurrence of words and sentence parts.The Loebner Prize is a chatbot competition with a number of judges who communicate simultaneously with people and chatbots, and is based on a standard turning test. There are a series of rounds in which a human judge communicates with a chatbot and with a person who uses a computer interface.Based on the answers, the judge will decide which is the only one that is more human in a chatbot room."}, {"heading": "I accepted my offer to the university because it was unconditional.", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "I accepted my offer to the university because it was one of the top.", "text": "In the first case, the term refers to the offer, in the second, to the university."}, {"heading": "2.5 Web applications", "text": "The classical architecture is the three-stage architecture described in Figure 2.3. The advantage of this type of model is that the functionality is distributed among three independent systems and that each level can be independently replaced or updated as requirements or technology change."}, {"heading": "2.6 Web application technologies", "text": "A number of technologies and libraries have been studied for the purpose of developing this project and the following have been identified as those that should be used to build the system."}, {"heading": "2.6.1 Java", "text": "Java is an object-oriented programming language that can be used to develop software that can run on a variety of operating systems without modifications. Besides, it is easy to use language, with a large number of APIs, sufficient documentation and it is free."}, {"heading": "2.6.2 PostgreSQL", "text": "PostgreSQL is an open-source relational database management system. It was chosen because it is supported by a variety of operating systems, works efficiently with increasing usage, and has many advanced features. In addition, there are a number of command-line, web, and GUI front-end tools that can manipulate databases."}, {"heading": "2.6.3 Hibernate", "text": "Hibernate is an open source collection of object-relational mapping APIs for the Java language. Hibernate aims to map the problem of mismatch between relational database systems and object. The idea is to have a Java class for each table and manipulate the objects created by the classes that map the tables. Furthermore, it is a wise choice because of its thorough documentation and its light weight."}, {"heading": "2.6.4 Spring", "text": "Spring is a lightweight open source application framework that can be easily used with other frameworks. It has a number of features that make its use indispensable. There is a central configuration file where Java beans can be created, transactions can be processed without having to manage each transaction separately, and security can be managed. Data access objects can be used on the Hibernate, which reduces errors and simplifies the development process. Testing application code written with Spring is easier than other similar technologies."}, {"heading": "2.6.5 Apache Wicket", "text": "Apache Wicket is a Java-based, component-based web application framework that is easy to integrate into Spring and Hibernate. It provides a clear separation between static HTML and dynamic Java parts of the presentation layer. It allows the creation of reusable components. Wicket provides authorization roles that can easily be placed at the top of any page. Errors are also identified during the compilation process."}, {"heading": "2.6.6 Javascript", "text": "Javascript is a script-based, client-side programming language. It can be used to envelop the functionality of HTML pages. It can be used for various purposes, such as setting character constraints on text areas."}, {"heading": "2.6.7 HTML and CSS", "text": "HTML is the standard markup language for web interface development. It must be used in combination with CSS, which is responsible for the layout of the HTML components.The CSS files are based on the CSS files developed by Mike Stenhouse [12]."}, {"heading": "2.6.8 Third party libraries", "text": "For spell checking, the Jazzy Java Spelling API, which requires user interaction with a local dictionary file, was used, as was the Google Search Java API, which requires user interaction with the Google search server, and the lingpipe Java API, which processes natural language to calculate the similarity of strings, while the Stanford parser was used to analyze a sentence and validate it."}, {"heading": "2.7 Other ideas", "text": "A combination of the keyword matching algorithm and the string similarity algorithm should be used. Keyword matching starts by identifying keywords and retrieves the answer that contains the most keywords. If the same number of keywords is found in more than one answer, or there are no keywords, the string similarity algorithm is executed to determine the question that is most similar to the one entered and retrieve the answer."}, {"heading": "2.8 Conclusion", "text": "From the information gathered from the research, the strengths and weaknesses of each were identified and a list of desired characteristics were compiled, which should be present in the system. Finally, it was concluded that the system should include a combination of keyword matching with the string similarity algorithm, a custom Google search option, and spell checking, log and feedback functionality. In addition, an administration section should be created in which the administrator can add, update, and delete system-related information. Chapter 3Analysis and SpecificationThis chapter contains an overview, a system proposal, and a thorough analysis of functional, non-functional requirements and users of the system."}, {"heading": "3.1 Overview", "text": "The role of the system is to provide a chatbot capable of answering questions related to the approval process; a web interface is provided for users to interact with the system and an administration interface; the user should be able to submit a log of whether they are satisfied with an answer and create a link; the user should be able to rate the system; the system's rank should be a five-star ranking system where one is bad and five is good; the user should also be able to submit a rating using the feedback form; and the system administrator should be able to log in with a username and password."}, {"heading": "3.3 Non-Functional Requirements", "text": "1. User interface: a. The system must maintain an easy-to-use user interface across all functionalities and for all users. b. The client interface should be compatible with all common browsers, such as Internet Explorer, Firefox, Google Chrome and Safari. b. Scalability: a. The system should be able to scale based on the number of users using the system. 3. Security: a. The management system should be protected from unauthorized access. b. The database should be protected from attack and unauthorized access. b. The interface should be protected from attack. d. All passwords should be stored as a secure hash of the administrator password. 4. Third-party interactions: a. The system should be able to interact with the Google spelling server that handles the spelling. b. The system should be able to interact with the Google search server used for the custom search."}, {"heading": "3.4 Use case model", "text": "The use case diagram describes the functionality of the system according to the requirements and can be found below."}, {"heading": "3.4.1 Actor documentation", "text": "Chapter 4Design This chapter describes the design of the system. It consists of a database, a combination of two algorithms, the business logic and the web interface. The system includes interfaces for users and an administrator."}, {"heading": "4.1 Database design", "text": "The design of the database aims to keep it as simple and efficient as possible. The user _ roles table contains the user name and the role name, the roles table stores a description of each role and an ID, the chatbotuser table stores the user data, the information table stores the questions, answers and keywords, the fdback table stores the feedback received and the log table stores the logs. The following figure shows the entity relationship diagram designed for the system database."}, {"heading": "4.2 Algorithms", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.2.1 Keyword matching", "text": "The keyword matching algorithm attempts to identify keywords in a sentence. If one or more keywords are found in the user's input text, a response is retrieved. However, if the same number of keywords found is present as the key for more than one response, a stalemate occurs. Again, a stalemate occurs if there are no keywords. Consider the following example to better understand how the keyword matching algorithm works. The table displays a small number of lines of information from the system's database, and the user then asks the question: \"Does a 2.2 in computer science meet the MSc input requirements in computer security?\" The algorithm identifies both keywords on the second line and retrieves the response."}, {"heading": "4.2.2 String similarity", "text": "The string similarity algorithm will try to find similarities between a list of strings and retrieve the answer closest to the question submitted by the user. To better understand how the string similarity algorithm works, the user submits the question: \"Can I pay with a visa?\" The algorithm then compares the user's question with the questions in the system and answers each with a percentage, ignoring the keywords that represent the possibility of similarity between strings. In this case, the second question is closer to the question submitted by the user, and the answer from this information line is retrieved. Jaro Winkler removal was used in the development of the algorithm [17]. The following figure guides the code through the Jaro Winkler string, whereby the higher difference between the two characters and the higher variable of the string used is."}, {"heading": "4.2.3 Combination of algorithms", "text": "In order to get the best possible result, we decided to combine the two algorithms. Therefore, questions with answers and keywords and questions with answers but no keywords were added to the system database. For example, the keyword matching algorithm searches for keywords and the string similarity algorithm searches for all pre-stored questions with or without keywords. To improve these similar questions, questions were added that have the same answer. Basically, if the keyword matching algorithm fails, we try to think what a simple user would think by asking a question. Consider the following example to better understand how the combination works. The user then submits the question: \"Have you received the sent packet?\" Then the keyword matching algorithm is executed first to identify keywords. It identifies one keyword in the first information line, one in the second and none in the third, and so there is a standstill. In this case, the user matching algorithm is most similar to the third one in the answer, although it is the third one stored by the system."}, {"heading": "4.2.4 Spell checker", "text": "The system is supported by the jazzy spell checker [20], which checks the sentence before it is transmitted to the server. In case of an error, the user is informed about it and about possible corrections. If it is error-free, it is transmitted."}, {"heading": "4.2.5 Natural language parser", "text": "The Stanford Natural Language Parser [18] is used to verify that a sentence is valid according to predefined rules. If the sentence is not valid, the user is informed and must make the appropriate changes. In the case of our system, a sentence is required for a noun and a verb to be valid. In the following example, how the Stanford parser will analyze a sentence is shown. The user enters the question: \"How can I apply?\" (.?)) Then the system will check if there is a noun and a verb in the tree. In the case that there is an SBARQ (WHADVP (WRB How), the question is submitted to the system. In the case that there is not both a noun and a verb, the user is informed."}, {"heading": "4.2.6 Google search", "text": "If a user is not satisfied with a system response, they will receive a link from the approval website. The link will be accessed via a customised Google search according to the input."}, {"heading": "4.3 Business logic", "text": "The business logic of the system is clearly separated from both the database and the presentation layer. The following class diagrams describe the business logic of the system. Figure 4.2 describes the implementation diagram and Figure 4.3 describes the implemented interface."}, {"heading": "4.4 Web Interface", "text": "The business logic of the system is clearly separated from both the database and the presentation layer. The following class diagrams describe the web interface of the system.Chapter 5ImplementationThis chapter describes the system implementation.User and administrator interfaces are described together with an implementation description of the individual components."}, {"heading": "5.1 Overview", "text": "The system has a user interface with the following options: engage in a conversation, create an individual link and leave feedback; the administration interface provides options for adding questions, answers and keywords; view, update and delete questions, answers and keywords; view and delete logs; view and delete feedback; the three-level architecture has been selected and described in Section 2.4. This particular architecture allows for the systematic development of a web application where the presentation layer is separated from the application layer and the data layer, ensuring that any change in either level does not affect the other two."}, {"heading": "5.2 Database layer implementation", "text": "The first layer of the three-level architecture is the data layer, which in this case is a database, which can be achieved by using and configuring Hibernate and Spring. First, a set of Java persistent objects and Hibernate mapping files must be created, followed by their configuration in the Spring container, in terms of creating the database, connecting it and the associated Spring data access objects."}, {"heading": "5.2.1 Hibernate mapping", "text": "Each file must be assigned to a Java class. There are five tables in the database, each represented by a persistent Java object and its XML mapping, and the following code represents a persistent Java object and the associated mapping XML file used to create the feedback table."}, {"heading": "5.2.2 Hibernate configuration", "text": "In order to create the database, the spring container must know the mapping files, which is accomplished in the application context.xml in a bean called sessionFactory. The following figure represents the configuration. In the configuration, the database is specified as PostgreSQL and the mapping resources property is used to declare the mapping files.The application context.xml also contains the connection properties of the database.The bean with id dataSource is used to configure the connection. Properties include a driver name, an url, a username, a password and other connection-related details. The figure below represents the connection properties."}, {"heading": "5.2.3 Data access objects", "text": "A data access object consists of an interface and an implementation of that particular interface. Each DAO file is associated with each Hibernate mapping file and its persistent object. An example of the data access to feedback interface and its implementation is described below."}, {"heading": "5.3 Business logic layer implementation", "text": "The business or application logic of a system is considered one of the most important aspects. This section aims to provide a clear understanding of the logic."}, {"heading": "5.3.1 Business analysis", "text": "The business logic of the system consists of two classes: chatbotService, an interface, and chatbotServiceImplementation, the implementation of the interface. Each functional part of the system is implemented with an appropriate method. Each method is called by the presentation layer if necessary. Furthermore, spring safety has been used to ensure that users can only access the methods they are supposed to. The following image represents a part of the interface.The following image provides a partial description of the implementation method for sentence analysis as found in the implementation of the chatbot service.The following image describes the spring safety used in the system. It is described in the chatbot service Security-Bean in the application context.xml. Properties specify which methods only the administrator can access."}, {"heading": "5.4 Presentation layer implementation", "text": "This section is intended to give an overview of how the interface was created and how it interacts with business logic."}, {"heading": "5.4.1 Presentation analysis", "text": "The presentation layer is designed using Apache Wicket and HTML, which aims to create a clear separation between the template and the business logic by using appropriate wicket IDs in the HTML code and giving these components actions in the Java code when the ID is associated with it. Also, when an action needs to be provided, the corresponding method is called from the chatbot service interface. To achieve this, a bean must be declared in the application context, as shown below. The bean is called the wicket application and then the chatbot service is launched, giving us the ability to call the chatbot service interface in the presentation and then call each of the authorized methods."}, {"heading": "5.5 User Interface", "text": "The final system includes a web interface with the following options: chat, login, leave feedback, add information, update information, delete information, view and delete feedback, and view and delete logs."}, {"heading": "5.5.1 Chatbot interface", "text": "The start page of the system, where the user can have a conversation, is displayed at the bottom."}, {"heading": "5.5.2 Leave feedback", "text": "The system's feedback page, where the user can leave a marker and a feedback message, is displayed at the bottom."}, {"heading": "5.5.3 Add information", "text": "The information page of the system where the administrator can add questions, answers and keywords is shown below."}, {"heading": "5.5.4 View information", "text": "The information page of the system where the administrator can view, update and delete questions, answers and keywords is shown below."}, {"heading": "5.5.5 View feedback", "text": "The system feedback page, where the administrator can view and delete feedback messages, is displayed at the bottom."}, {"heading": "5.5.6 View logs", "text": "Chapter 6Testing and Evaluation This chapter is divided into two subchapters: The first part describes testing the system and the test cases; the second part describes how the system was evaluated."}, {"heading": "6.1 Testing", "text": "In a software system, it is crucial that it behaves as expected. To ensure that the system and its components behave as required, a series of tests have been carried out."}, {"heading": "6.1.1 Overview", "text": "Each unit of the system was tested to ensure that the actual operating result was in line with what we expected. In addition, each unit, when integrated with other units during development, was re-tested to verify its operation with other system units."}, {"heading": "6.1.2 Unit and integration testing", "text": "The test strategy was based on the functionality and requirements of the system. The test table below contains a detailed description of the tests performed. Test case id Test description Expected result TC001 Actual result TC001 Ask a question Reply if PASSTC002 create a questionnaire with a spelling error Spell checker identifies the error Spell checker identifies the error PASSTC003 Input of an invalid result set identifies the error Sentence Parser identifies the error Sentence Parser identifies the error Sentence Parser identifies the error Sentence Parser identifies the error PASSTC004 User is satisfied with the answer Nothing happens PASSTC005 User is not satisfied with the answerFemitteFemitteFemitteFemitteSTST00STC00Administrator provided a log of the question and answer PASSTSTC007"}, {"heading": "6.1.3 Performance testing", "text": "Each developed component underwent a performance test to ensure that the system met certain performance requirements. Finally, each unit was developed and tested and then integrated into the rest of the system to perform a performance test. [19] The following figure describes the levels of performance testing [19]. Each component of the system went through each stage of the methodology used. It was found that each unit behaved differently as a unit and when it was integrated with other units in terms of speed. The test environment plays a crucial role in the performance of the system. A different result occurs when the system is in development mode and another when the system is in use. In addition, the technical specifications of the server on which the final system was deployed also play a role."}, {"heading": "6.1.4 Security testing", "text": "Security tests ensure that the system protects its data from unauthorized access and changes, and that it continues to behave as expected. To ensure the security of the system, various security concepts have been used. Authentication has been used to confirm the identity of a person who is either a user or an administrator. Authorization has been used to ensure that users have access to pages they are supposed to have and that the administrator has general control over the system. To achieve this, access control has been used. To ensure that the system is safe from attacks, including SQL injection and XSS, a series of tests have been conducted and will be shown below."}, {"heading": "6.2 Evaluation", "text": "Evaluation is the process by which we collect and analyze information to determine whether the software system developed is effective and efficient."}, {"heading": "6.2.1 Overview", "text": "An essential part of this project was to build a workable system based on real-world requirements and evaluated against potential students, which met all requirements, including new requirements introduced after feedback from potential students. However, due to time constraints, it was not possible to develop an Android part of the project."}, {"heading": "6.2.2 Question categories", "text": "For analysis purposes, the types of questions a user might be able to ask have been categorized into four main categories. Relevant Question: A relevant question refers to a valid question. The answer exists in the database and the algorithm is able to retrieve it.Irrelevant Question: An irrelevant question refers to a question that is not related to the approval process and has not been included in the database.No Answer Question: An answer question refers to a valid question, but the answer currently does not exist in the database.Bad Answer Question: A bad answer would be that the answer exists in the database, but the algorithm would not retrieve it and return with an incorrect or irrelevant answer. Examples for each of these categories are listed below."}, {"heading": "A relevant question that a user asked: \u201cWhat are the entry requirements for the computer security", "text": "MSc? \"The answer was correct:\" To participate in the program, you must have at least a high school diploma (2,1) or an international equivalent in computer science or a closely related discipline and a solid foundation in programming. \""}, {"heading": "An irrelevant question asked: \u201cSize of university grounds in square miles?\u201d", "text": "The answer was irrelevant: \"Yes, with most major players like HP, IBM and Logica. What is the answer to the question: Are there any connections to the industry?\""}, {"heading": "A no response question asked: \u201cWhere is the toilet?\u201d", "text": "The answer was irrelevant: \"The start dates for the program are: 2011 / 12: 26 September 2011, 2012 / 13: 24 September 2012. It is not possible to join the program in January or any other time after the start date.\""}, {"heading": "A poor response question asked: \u201cIs it OK to pay my fees using a visa?\u201d", "text": "The answer was meagre: \"Yes, unless you are from an EU or EEA country. If you need a visa and have accepted your offer, you will shortly receive a CAS statement by e-mail. The answer to the question was in the database, but the answer you got is the answer to the question: Do I need a visa to study in the UK?\""}, {"heading": "6.2.3 User evaluation", "text": "Messages were sent to MSc applicants with: 1. Unconditional offers (not yet accepted) 2. Unconditional offers (not yet accepted) 3. Conditional offers (not yet accepted) 4. Conditional offers (accepted) 5. Applications requiring references and / or transcripts were sent to two groups of MSc applicants: 1. Feasibility study: 108 emails were sent to 74 applicants with surnames from S or T. 2. Main evaluation: 770 emails were sent to applicants with surnames from another letter. 2. Main evaluation: emails were sent to two groups of MSc applicants: 1. Feasibility study: emails were sent to 18 applicants with surnames from S or T. 2. Main evaluation: 770 emails were sent to applicants with surnames from another letter. 2. Main evaluation: emails were sent to 75 applicants with surnames."}, {"heading": "6.2.4 Survey", "text": "In this section, the results from the protocols and feedback from the period in which the system was online are analyzed. There are two groups of results collected by both students and doctoral students; the first, based on the results from an initial period of 7 days and from applicants with surnames beginning with S or T. The final system was hosted for 15 days, the results of which were used to improve the system and upload it a second time to collect feedback from applicants with surnames beginning with any other letter. Feedback was collected on the feedback page of the system, where the user could give a scale of 1-5 and comment if desired, and through e-mails sent by applicants. The tables and pie charts in the initial results and the final sections below show the user's reaction when they felt that the system had failed. They do not represent the performance of the entire system."}, {"heading": "6.2.4.1 Initial results", "text": "On the system feedback page, four messages were received with a total score of 2.75. In addition, four further messages were received by e-mail containing only suggestions about the system. Based on the feedback received and the number of protocols, it was assumed that about 10 people used the system. The following table represents the categories and number of questions not answered by the system for each category. The following pie charts represent the percentage of the number of protocols from the system database during its first use. After initial use and after careful review of the responses, a number of changes were made and a definitive system was introduced. The most important changes after the initial evaluation of the system were: natural language parsing: it was decided that the use of a sentence parser was necessary for the system, the parser analysed the structure of a sentence and found that a noun and a verb existed, thereby avoiding the submission of syntactically incorrect questions to the system."}, {"heading": "6.2.4.2 Final results", "text": "Thirteen messages were reached via the system's feedback page with a total score of 2.53. In addition, a further twenty-two messages were received by e-mail containing only suggestions about the system. Based on the feedback received and the number of logs, it was assumed that about 50 people used the system. The following table shows the categories and number of questions that the system failed to answer for each category.There were three cases for which a relevant response was provided but the user was not satisfactory.These include: User Interface: The user interface should be more interactive and contain more details.2% 39% 39% 20% Database enrichment: After initial use, it was clear that the information in the database was not of satisfactory level and additional data needed to be added."}, {"heading": "7.1 Achievements", "text": "A number of positive points have been identified; a working system has been developed using Java and a number of third-party libraries; the system has been uploaded to the school's web server twice; the first time it was used by a small number of potential students, leaving feedback and some changes; the second time, a larger number of potential students have used the system and taken feedback; an interesting part has been the logs showing how people communicate with a chatbott.The fact that the system uses a spell checker is considered a positive aspect, as the ability to retrieve the wrong answer due to an error is reduced; in addition, a sentence parser has been used to inform the user before submitting whether a sentence is valid or not; a customized Google search function that provides a link relevant to the question if the user is not satisfied with the answer; and a log of the question and answer is kept at this stage; and the user has the option to submit a web feedback dynamic number, another aspect of the question that is more administrative."}, {"heading": "7.2 Limitations", "text": "A limitation of the system's algorithm was established after evaluation and testing. In fact, there is a possibility of not retrieving the correct answer. A small number of the logs concerned this problem. Furthermore, potential students want to know about a different number of things and not everything is covered in the database. One problem is that the system has no memory and if a user asks the same question several times, the answer remains the same. Anaphora resolution does not exist, which would be useful in some situations if a user refers to a previous question. However, Anaphora resolution would require chatbot memory. A limitation of spell checking is that the system will suggest a word for a spelling error; however, the user will have to manually modify it and resubmit the question. Although there may be a number of questions that do not require a verb, the sentence parser will reject any question that does not contain a noun and a verb, and the user will have to restructure the sentence and submit it."}, {"heading": "7.3 Future work", "text": "A number of different algorithms should be implemented, tested and evaluated to give high priority. Furthermore, algorithms could be used in combination with the best solution, which can also be a combination of two or more algorithms. There are also another number of factors that need to be taken into account, such as speed and compatibility. Also, such a solution is used to find a possible answer."}, {"heading": "7.4 Conclusions", "text": "The main objectives of the project were to develop an algorithm for identifying answers to questions submitted by the user; to develop a database, all relevant data was stored and a web interface was developed; the web interface developed consisted of two parts, one for simple users and one for the administrator.Subsequently, the following objectives were fulfilled.A background research was carried out, which provided an overview of the conversation process and all relevant chat bots available; a database was developed, in which information about questions, answers, keywords, logs and feedback messages were stored.Twice a usable system was designed, developed and made available on the webserver.An evaluation was made on the basis of data collected from potential students at the university; and even after the first deployment, additional requirements were introduced and implemented."}, {"heading": "Appendix A Project proposal", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1. Introduction", "text": "This document includes an introduction to the project including the context, a description of the objectives and a solid plan for completion."}, {"heading": "2. Context", "text": "Experience has shown that applicants are more likely to choose a faculty where they believe they will be treated like a valued person. An opportunity to communicate with a university employee on a one-to-one basis is highly appreciated, but with many hundreds of applications per year, one-to-one interviews are not feasible in most instances. Although the admissions process works properly, it is very difficult and time-consuming to contact a university employee. However, the problem would be partially solved if the applicant could talk to a compelling chatbot that is able to respond to his concerns with information about admissions, accommodation booking, payment of fees in installments and the preliminary courses offered. At the end of development, the chatbot application will be able to communicate with a user similar to: Chat Bot: Hello, how can I help you? User: What is the minimum score of IELTS required for admittance to the Overall Computer Chat Science? The minimum score of 0 is not accepted by anyone else?"}, {"heading": "3. Aims and Objectives", "text": "The aim of this project is to contribute to solving the problem of direct communication between the applicants and the University. The main objectives of the project are the following: Information resource: To develop an information resource, all relevant information about the questions and the answers has been stored. Algorithm: To develop an algorithm that will be able to identify meaningful keywords in users \"input and provide an appropriate answer.Interface: To develop a web interface that aims to give potential students and their families the opportunity to submit questions in a chatbot and receive convincing answers. The web system can be hosted on any computer that supports an operating system on which the Java Virtual Machine will be able to load."}, {"heading": "Appendix B How to run the system", "text": "This is due to the fact that the persons concerned are persons who are able to acquire their identity. & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10;"}, {"heading": "Appendix C Example Conversation", "text": "The following illustrations show what a sample conversation would look like if a user decides to have a conversation with the chatbot."}, {"heading": "Appendix D Feedback", "text": "It is as it is that it is a reactionary party that will be able to hide."}], "references": [{"title": "The Essence of Artificial Intelligence", "author": ["Cawsey", "Alison"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1998}, {"title": "Artificial Intelligence: A guide to intelligent systems, 2nd ed", "author": ["Negnevitsky", "Michael"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2005}, {"title": "Enjoying Web Development with Wicket", "author": ["Tong Ka Iok", "Kent"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "Software testing fundamentals", "author": ["Marnie L Hutcheson"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "University Centre for Machine Translation Chatterbots, Tinymuds, and the Turing Test Entering the Loebner Prize Competition", "author": ["Michael L. Mauldin", "Carnegie Mellon"], "venue": "Available at: http://www.aaai.org/Papers/AAAI/1994/AAAI94-003.pdf [Accessed on", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Chatbots: Are they really useful? Penn state University", "author": ["Bayan Abu Shawar", "Eric Atwell"], "venue": "Available at: http://citeseerx.ist.psu.edu/viewdoc/download doi=10.1.1.106.1099&rep=rep1&type=pdf [Accessed on", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2011}], "referenceMentions": [{"referenceID": 5, "context": "\u201cChatbots are computer programs that interact with users using natural languages[21].", "startOffset": 80, "endOffset": 84}, {"referenceID": 5, "context": "1 ELIZA The first chatbot developed was ELIZA [21].", "startOffset": 46, "endOffset": 50}, {"referenceID": 5, "context": "E ALICE was implemented by Richard Wallace in 1995[21].", "startOffset": 50, "endOffset": 54}], "year": 2014, "abstractText": null, "creator": "Microsoft\u00ae Word 2013"}}}