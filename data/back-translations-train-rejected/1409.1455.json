{"id": "1409.1455", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Sep-2014", "title": "Unsynthesizable Cores - Minimal Explanations for Unsynthesizable High-Level Robot Behaviors", "abstract": "With the increasing ubiquity of multi-capable, general-purpose robots arises the need for enabling non-expert users to command these robots to perform complex high-level tasks. To this end, high-level robot control has seen the application of formal methods to automatically synthesize correct-by-construction controllers from user-defined specifications; synthesis fails if and only if there exists no controller that achieves the specified behavior. Recent work has also addressed the challenge of providing easy-to-understand feedback to users when a specification fails to yield a corresponding controller. Existing techniques provide feedback on portions of the specification that cause the failure, but do so at a coarse granularity. This work presents techniques for refining this feedback, extracting minimal explanations of unsynthesizability.", "histories": [["v1", "Thu, 4 Sep 2014 14:50:54 GMT  (457kb,D)", "http://arxiv.org/abs/1409.1455v1", null]], "reviews": [], "SUBJECTS": "cs.RO cs.AI", "authors": ["vasumathi raman", "hadas kress-gazit"], "accepted": false, "id": "1409.1455"}, "pdf": {"name": "1409.1455.pdf", "metadata": {"source": "CRF", "title": "Unsynthesizable Cores \u2013 Minimal Explanations for Unsynthesizable High-Level Robot Behaviors", "authors": ["Vasumathi Raman", "Hadas Kress-Gazit"], "emails": ["vasu@caltech.edu)."], "sections": [{"heading": null, "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "II. PRELIMINARIES", "text": "The robot responds to eventsar Xiv: 140 9.14 55v1 [cs.RO] 4 Sep 201 42 in the environment captured by its sensors in a manner consistent with the task by selecting from a series of actions, including moving between adjacent locations. Tasks can include endlessly repetitive behaviors such as patrolling a number of locations. Examples of such high-level tasks are search and rescue missions and the DARPA Urban Challenge."}, {"heading": "A. Controller Synthesis", "text": "It is a hybrid domain that encompasses both discrete and continuous components. (...) The discrete abstraction of the high-level robot task consists of a series of Proposition X, the veracity of which is controlled by the environment and read by the robot's sensors, and a series of action and location proposals Y, which are controlled by the robot. (...) The value of each Proposition AP is the abstracted state of a low-level black box component. (...) The discrete abstraction used in this work is the truth. (...) The formal language used for high-level specifications in this work is the truth (...) [16], a modal logic that includes temporary operators to specify the veracity values of atomic positions over time."}, {"heading": "B. Environment Counterstrategy", "text": "In the case of non-synthesizable specifications, the counter-strategy synthesis algorithm q = q introduced in [21] provides an automatic method of constructing an environmental strategy that provides sequences of environmental actions that prevent the robot from achieving the specified behavior; the counter-strategy takes the form of a finite state machine: Definition 1 An environmental counter-strategy for the LTL formula is a set of input states. \u2022 X is a set of input states (sensor propositions). \u2022 Y is a set of input states (position and action specifications). \u2022 E: Q \u2192 2X is a deterministic input function that provides the input states that are true in the next time step."}, {"heading": "III. PROBLEM STATEMENT", "text": "A specification that does not result in implementing automation is referred to as an unsynthesizable system if an unsynthesizable specification is either unsatisfactory, in which case the robot cannot succeed, what happens in the environment (for example, if the task requires a separate working environment), or unrealizable, in which case there is at least one environment that can prevent the desired behavior (for example, if the environment has a different networked working environment, such as by closing a door). Further examples showing the two cases can in any case, the robot can fail in two ways: either it ends in a state from which there is no movement, the specified safety requirements are met, or the robot is able to change its state infinitely, but one of the targets in gs is unattainable without being violated."}, {"heading": "IV. RELATED WORK", "text": "This year, it is at an all-time high in the history of the European Union."}, {"heading": "V. UNSATISFIABLE CORES VIA SAT", "text": "This section describes how to further analyze unsatisfactory components of the robot specifications in order to narrow down the cause of dissatisfaction for both dead ends and livestock by means of Boolean satisfaction tests. Extending these techniques to environmental assumptions is straightforward. Boolean satisfaction problem, or SAT, is the problem of determining whether there is a truth correlation to a set of suggestions that meet a given Boolean formula. A Boolean formula in subjunctive normal form (CNF) is one that has been rewritten as a combination of clauses, each of which is a disjunction of words, one letter being a Boolean sentence or its negation. In a Boolean formula in CNF, an unsatisfactory core is defined as a subset of CNF clauses whose connection is still unsatisfactory; a minimally unsatisfactory core is one that is such that the removal of a clause leads to a satisfactory formula."}, {"heading": "A. Unsatisfiable Cores for Deadlock", "text": "Considering the depth d and a LTL security formula, which is based on the propositions p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p"}, {"heading": "B. Unsatisfiable Cores for Livelock", "text": "In the case of living beings, a similar rolling procedure can be used to determine the core set of clauses that prevent the fulfillment of a goal. A meaningful formula is generated by rolling robotic safety out of the initial state for a given number of time steps, with an additional clause dgoal representing the unfulfilled life expectancy condition that must be held for this depth in the final time step. Consider the living specification 3.Specification 3 Core finding example - unsatisfactory life expectancy 1) Start in the kitchen (is): kitchen 2) Avoid hallway w (is, is, ts): hallway w vestibule w 3): Always activate your camera (ts): \u00a9 kamera 4) Patrol r3 (gs): r3Enroll the robot safety to the depth d, with the additional clause dgoal = \u03c0 d r3 for life expectancy at depth d, results in: df, insufficient time to meet the target."}, {"heading": "C. Unroll Depth", "text": "This year, it is such that it is able to retaliate until it is able to retaliate."}, {"heading": "VI. UNREALIZABLE CORES VIA SAT", "text": "As described in Section V-D, extending the SAT-based core finding techniques described in Section V to unrealizable specifications requires investigating the exact input sequences in the environment that cause the failure. Taking into account all possible input sequences in the environment, it is not practical; fortunately, the counter strategy sometimes provides us with the very input sequences that cause unsynthesizability. It allows the following characterizations of standstill and liveliness: \u2022 Deadlock In the object strategy, there is a state in which there is truth assignment to inputs for which the no7 truth assignment to outputs satisfies the robot transition relationship. Formally, q q q s.t. (q) is the assignment of life (Bock) = / 0 \u2022 Livelock There are a number of states C in the object strategy, so the robot is not caught in any C transition relationship."}, {"heading": "A. Unrealizable Cores for Deadlock", "text": "The safety conditions stipulate that the robot should not pass through its camera (4) when it recognizes a person (2). In addition, the robot must remain in place when it perceives a person (3), because then there is no way that the robot can fulfill both (2) and (3). Specification 5 Core Finding Example - Deadlock 1) Robot starts in r5 with the camera (2): If you perceive a person (2), do not do r5 (2)."}, {"heading": "B. Unrealizable Cores for Livelock", "text": "Consider specification 1 again. If the environmental action is always to specify a person, then the safety requirement in 2 = qq = qq = q4 forces the robot never to activate Q5 because it is explicitly forbidden to do so if it recognizes a person. This is vital because the robot can still move between start and finish. The environmental zone strategy is as follows: \u2022 Q = {q1, q2, q3, q4, q4, Q0, Q0, Q1, Q2, Y = {2, \u03c0r2, \u03c0r3, \u03c0r8, \u03c0r8, \u03c0r8, \u03c0r8, \u03c0r8, \u03c0r8, \u03c0r3, q4, q4, qr3, qr3, qr3, qr3, qr3, qr3, qr3, qr3, qr3, qr3,... The environmental zone strategy is not possible."}, {"heading": "VII. UNSYNTHESIZABLE CORES VIA ITERATED SYNTHESIS", "text": "The real cause of failure, which cannot be realized in the real ratio of the user, is in both cases the real ratio, which is described in Section VI, not to realize. \"\" The real ratio, \"according to the author,\" \"is the real ratio,\" \"the real ratio of the user is to realize.\" \"The real ratio,\" \"according to the author,\" \"is the author,\" \"\" is it, \"\" \"is it,\" \"\" is it, \"\" \"is it,\" \"\" \"is it,\" \"\" \"\" the author, \"\" \"\" \"\" \",\" \"\" \"\" \"\" \",\" \"\" \"\" \",\" \"\" \"\", \"\" \"\" \",\" \"\" \",\" \"\", \"\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"\", \"\", \"\", \"\", \"\" \",\" \"\", \"\" \",\" \"\" \",\" \"\" \",\", \"\" \"\" \",\" \",\" \"\" \"\" \"\", \"\" \"\" \",\" \"\" \",\" \"\" \"\" \",\" \"\" \"\", \"\" \"\" \",\" \"\" \",\" \"\", \"\" \"\" \",\" \"\" \",\" \"\" \"\" \",\" \"\" \",\" \",\" \"\" \"\", \"\", \"\" \"\" \"\" \",\", \",\" \"\" \"\" \"\" \",\", \"\" \",\" \",\" \"\", \"\" \"\", \"\" \"\" \",\", \"\", \"\", \",\" \"\" \"\", \"\" \"\", \",\" \"\" \"\" \",\" \"\", \",\" \"\" \""}, {"heading": "A. Computational Tradeoffs", "text": "There is a mathematical trade-off when performing a synthesizing approach (i.e. feasibility) once for each conjunction in the safety formula, instead of once for the entire specification. Algorithm 3 checks synthesiability once in each iteration of the loop in lines 3-7. Using the efficient algorithm in [20], each feasibility check takes time O (mn\u03a3) 3), where \u03a3 is the size of the state space, i.e. \u03a3 = 2 | X-Y |, and m, n are the number of environmental or system life conditions. Therefore, the complexity of the algorithm is 3 O (nts) (mn\u0440) 3), where \u03a3 the complexity of the approach described in Section VI requires only one call of the environment and system life conditions (m)."}, {"heading": "VIII. EXAMPLES", "text": "In this section, examples of cores identified for non-synthesizable specifications are presented, and the examples previously presented in [7] demonstrate the improvement of the proposed approach compared to the analysis presented in this paper. These examples were carried out using the open source LTLMoP toolbox [17], within which all the technical results presented in this paper were implemented."}, {"heading": "A. Deadlock", "text": "Consider the specification in Fig. 5, where the robot works in the work area shown in Fig. 4. The robot starts on the porch. Safety conditions govern what it should do if it recognizes a \"person\" (stay with him and call for help) or a \"dangerous element\" (pick up the dangerous element and carry it to the porch).The robot should not visit the porch unless it carries a dangerous element. The robot's objectives are to patrol all rooms in the workspace. The environment can lead to a blockage by setting the person sensor to true and the danger sensor to wrong when the robot is in the porch. Note that detecting a dangerous element causes the robot to activate the \"pick-up action,\" which in turn results in the phrase \"supporting element.\" Similarly, detecting a person 11 causes the robot to turn on the radio."}, {"heading": "B. Livelock", "text": "Consider the specification in Fig. 6, also in the same working area: The robot starts on deck and has the goal of visiting the porch. However, depending on whether it perceives a person or a fire, it must stay away from the kitchen or living room. Fig. 6 (a) shows the sentences highlighted by the algorithm in [7] that contain all safety conditions (red) in addition to the target (green), including irrelevant phrases such as that the robot must always turn on the camera. Fig. 6 (b) shows the core returned by algorithm 3 - only those safeguards that directly contribute to keeping the robot away from the porch."}, {"heading": "IX. CONCLUSIONS", "text": "This paper provides techniques for analyzing high-level robot specifications that are not synthesizable, with the aim of providing a minimum explanation of why the robot specification is inconsistent or how the environment may prevent the robot from meeting the desired warranties. The causes of failure outlined in this paper are in the form of non-synthesizable subsets of the original specification or cores. A number of SAT-based techniques are presented to identify unsatisfactory and unrealizable cores in the event of standstill and most cases of life support; an iterated feasibility test is used to identify cores in cases where the SAT-based analysis fails. Examples show that the additional analysis highlights improvements in reducing the number of sentences in the original specification and ignores irrelevant subformulas. Future work includes the automatic determination of depth to achieve a meaningful life-based approach in the case of automated life support for SAT, and the automatic subformulas for SAT."}], "references": [{"title": "A fully automated framework for control of linear systems from temporal logic specifications", "author": ["M. Kloetzer", "C. Belta"], "venue": "IEEE Transactions on Automatic Control, vol. 53, no. 1, pp. 287\u2013297, 2008.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2008}, {"title": "Sampling-Based motion planning with deterministic \u03bc-calculus specifications", "author": ["S. Karaman", "E. Frazzoli"], "venue": "IEEE Conference on Decision and Control (CDC), 2009.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "Sampling- Based motion planning with temporal goals", "author": ["A. Bhatia", "L.E. Kavraki", "M.Y. Vardi"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2010, pp. 2689\u20132696.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Controlling wild bodies using linear temporal logic", "author": ["L. Bobadilla", "O. Sanchez", "J. Czarnowski", "K. Gossman", "S. LaValle"], "venue": "Robotics: Science and Systems (RSS), Los Angeles, CA, USA, June 2011.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Temporal-Logic-Based reactive mission and motion planning", "author": ["H. Kress-Gazit", "G.E. Fainekos", "G.J. Pappas"], "venue": "IEEE Transactions on Robotics, vol. 25, no. 6, pp. 1370\u20131381, 2009.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Receding horizon control for temporal logic specifications", "author": ["T. Wongpiromsarn", "U. Topcu", "R.M. Murray"], "venue": "Hybrid Systems: Computation and Control (HSCC), 2010, pp. 101\u2013110.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2010}, {"title": "Automated feedback for unachievable High-Level robot behaviors", "author": ["V. Raman", "H. Kress-Gazit"], "venue": "IEEE  International Conference on Robotics and Automation (ICRA), 2012, pp. 5156\u20135162.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Explaining impossible High-Level robot behaviors", "author": ["V. Raman", "H. Kress-Gazit"], "venue": "IEEE Transactions on Robotics, vol. PP, no. 99, pp. 1 \u201311, 2012.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Revising temporal logic specifications for motion planning", "author": ["G.E. Fainekos"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2011, pp. 40\u201345.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "Mining assumptions for synthesis", "author": ["W. Li", "L. Dworkin", "S.A. Seshia"], "venue": "ACM-IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE), 2011, pp. 43\u201350.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2011}, {"title": "On the revision problem of specification automata", "author": ["K. Kim", "G.E. Fainekos", "S. Sankaranarayanan"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2012, pp. 5171\u20135176.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Approximate solutions for the minimal revision problem of specification automata", "author": ["K. Kim", "G.E. Fainekos"], "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2012, pp. 265\u2013271.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "Analyzing unsynthesizable specifications for high-level robot behavior using LTLMoP", "author": ["V. Raman", "H. Kress-Gazit"], "venue": "Computer Aided Verification (CAV), 2011, pp. 663\u2013668.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}, {"title": "Sorry Dave, i\u2019m afraid i can\u2019t do that: Explaining unachievable robot tasks using natural language", "author": ["V. Raman", "C. Lignos", "C. Finucane", "K.C.T. Lee", "M.P. Marcus", "H. Kress-Gazit"], "venue": "Robotics: Science and Systems, 2013.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2013}, {"title": "Towards minimal explanations of unsynthesizability for high-level robot behaviors", "author": ["V. Raman", "H. Kress-Gazit"], "venue": "IROS, 2013, pp. 757\u2013762.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2013}, {"title": "The temporal logic of programs", "author": ["A. Pnueli"], "venue": "Foundations of Computer Science (FOCS), 1977, pp. 46\u201357.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1977}, {"title": "LTLMoP: Experimenting with language, temporal logic and robot control", "author": ["C. Finucane", "G. Jing", "H. Kress-Gazit"], "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2010, pp. 1988 \u2013 1993.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2010}, {"title": "Translating structured english to robot controllers", "author": ["H. Kress-Gazit", "G.E. Fainekos", "G.J. Pappas"], "venue": "Advanced Robotics, vol. 22, no. 12, pp. 1343\u20131359, 2008.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Synthesis of Reactive(1) Designs", "author": ["N. Piterman", "A. Pnueli", "Y. Sa\u2019ar"], "venue": "Verification, Model Checking, and Abstract Interpretation (VMCAI). Springer, 2006, pp. 364\u2013380.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "Debugging formal specifications using simple counterstrategies", "author": ["R. K\u00f6nighofer", "G. Hofferek", "R. Bloem"], "venue": "Formal Methods in Computer-Aided Design (FMCAD), 2009, pp. 152\u2013159.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2009}, {"title": "Towards a notion of unsatisfiable cores for LTL", "author": ["V. Schuppan"], "venue": "Fundamentals of Software Engineering (FSEN), 2009, pp. 129\u2013145.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "Explaining counterexamples using causality", "author": ["I. Beer", "S. Ben-David", "H. Chockler", "A. Orni", "R.J. Trefler"], "venue": "Formal Methods in System Design, vol. 40, no. 1, pp.  13 20\u201340, 2012.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2012}, {"title": "Verification of proofs of unsatisfiability for CNF formulas", "author": ["E. Goldberg", "Y. Novikov"], "venue": "Design, Automation and Test in Europe Conference and Exhibition (DATE), 2003, pp. 886\u2013891.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "A simple and flexible way of computing small unsatisfiable cores in SAT modulo theories", "author": ["A. Cimatti", "A. Griggio", "R. Sebastiani"], "venue": "International Conference on Theory and Applications of Satisfiability Testing (SAT). Berlin, Heidelberg: Springer-Verlag, 2007, pp. 334\u2013339. [Online]. Available: http://dl.acm.org/citation. cfm?id=1768142.1768174", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2007}, {"title": "Debugging overconstrained declarative models using unsatisfiable cores", "author": ["I. Shlyakhter", "R. Seater", "D. Jackson", "M. Sridharan", "M. Taghdiri"], "venue": "IEEE International Conference on Automated Software Engineering (ASE), 2003, pp. 94\u2013105.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2003}, {"title": "Boolean abstraction for temporal logic satisfiability", "author": ["A. Cimatti", "M. Roveri", "V. Schuppan", "S. Tonetta"], "venue": "Computer Aided Verification (CAV), 2007, pp. 532\u2013546.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2007}, {"title": "Diagnostic information for realizability", "author": ["A. Cimatti", "M. Roveri", "V. Schuppan", "A. Tchaltsev"], "venue": "Verification, Model Checking, and Abstract Interpretation (VMCAI), 2008, pp. 52\u201367.", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2008}, {"title": "Debugging unrealizable specifications with Model-Based diagnosis", "author": ["R. K\u00f6nighofer", "G. Hofferek", "R. Bloem"], "venue": "International Conference on Hardware and Software: Verification and Testing (HVC). Berlin, Heidelberg: Springer-Verlag, 2011, pp. 29\u201345. [Online]. Available: http://dl.acm.org/citation.cfm?id=1987082.1987090", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "Environment assumptions for synthesis", "author": ["K. Chatterjee", "T.A. Henzinger", "B. Jobstmann"], "venue": "International Conference on Concurrency Theory (CONCUR). Berlin, Heidelberg: Springer- Verlag, 2008, pp. 147\u2013161. [Online]. Available: http://dx.doi.org/10.1007/978-3-540-85361-9 14", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2008}, {"title": "PicoSAT essentials", "author": ["A. Biere"], "venue": "Journal on Satisfiability (JSAT), vol. 4, no. 2-4, pp. 75\u201397, 2008.", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 1, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 2, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 3, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 4, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 5, "context": ", [1\u20136]).", "startOffset": 2, "endOffset": 7}, {"referenceID": 4, "context": "There are several approaches in which correct-by-construction controllers are automatically synthesized from a description of the desired behavior and assumptions on the environment in which the robot operates [5, 6].", "startOffset": 210, "endOffset": 216}, {"referenceID": 5, "context": "There are several approaches in which correct-by-construction controllers are automatically synthesized from a description of the desired behavior and assumptions on the environment in which the robot operates [5, 6].", "startOffset": 210, "endOffset": 216}, {"referenceID": 6, "context": "This has motivated recent algorithms for explaining unsynthesizability of specifications [7, 8], revising specifications [9], and adding", "startOffset": 89, "endOffset": 95}, {"referenceID": 7, "context": "This has motivated recent algorithms for explaining unsynthesizability of specifications [7, 8], revising specifications [9], and adding", "startOffset": 89, "endOffset": 95}, {"referenceID": 8, "context": "This has motivated recent algorithms for explaining unsynthesizability of specifications [7, 8], revising specifications [9], and adding", "startOffset": 121, "endOffset": 124}, {"referenceID": 9, "context": "environment assumptions that would make the specification synthesizable [10].", "startOffset": 72, "endOffset": 76}, {"referenceID": 8, "context": "Feedback about the cause of unsynthesizability can be provided to the user in the form of a modified specification [9, 11, 12], a highlighted fragment of the original specification [13], or by allowing the user to interact with a simulated adversarial environment that prevents the robot from achieving the specified behavior [8].", "startOffset": 115, "endOffset": 126}, {"referenceID": 10, "context": "Feedback about the cause of unsynthesizability can be provided to the user in the form of a modified specification [9, 11, 12], a highlighted fragment of the original specification [13], or by allowing the user to interact with a simulated adversarial environment that prevents the robot from achieving the specified behavior [8].", "startOffset": 115, "endOffset": 126}, {"referenceID": 11, "context": "Feedback about the cause of unsynthesizability can be provided to the user in the form of a modified specification [9, 11, 12], a highlighted fragment of the original specification [13], or by allowing the user to interact with a simulated adversarial environment that prevents the robot from achieving the specified behavior [8].", "startOffset": 115, "endOffset": 126}, {"referenceID": 12, "context": "Feedback about the cause of unsynthesizability can be provided to the user in the form of a modified specification [9, 11, 12], a highlighted fragment of the original specification [13], or by allowing the user to interact with a simulated adversarial environment that prevents the robot from achieving the specified behavior [8].", "startOffset": 181, "endOffset": 185}, {"referenceID": 7, "context": "Feedback about the cause of unsynthesizability can be provided to the user in the form of a modified specification [9, 11, 12], a highlighted fragment of the original specification [13], or by allowing the user to interact with a simulated adversarial environment that prevents the robot from achieving the specified behavior [8].", "startOffset": 326, "endOffset": 329}, {"referenceID": 13, "context": "This paper subsumes the results presented in [14, 15], and extends the core-finding capabilities to previously unaddressed cases, as described in Section VII.", "startOffset": 45, "endOffset": 53}, {"referenceID": 14, "context": "This paper subsumes the results presented in [14, 15], and extends the core-finding capabilities to previously unaddressed cases, as described in Section VII.", "startOffset": 45, "endOffset": 53}, {"referenceID": 4, "context": "More details on the discrete abstraction used in this work can be found in [5].", "startOffset": 75, "endOffset": 78}, {"referenceID": 15, "context": "The formal language used for high-level specifications in this work is Linear Temporal Logic (LTL) [16], a modal logic that includes temporal operators, allowing formulas to specify the truth values of atomic propositions over time.", "startOffset": 99, "endOffset": 103}, {"referenceID": 16, "context": "To allow users who may be unfamiliar with LTL to define specifications, some tools like LTLMoP [17] include a parser that automatically translates English sentences belonging to a defined grammar [18] into LTL formulas, as well as some natural language capabilities, as described in [14].", "startOffset": 95, "endOffset": 99}, {"referenceID": 17, "context": "To allow users who may be unfamiliar with LTL to define specifications, some tools like LTLMoP [17] include a parser that automatically translates English sentences belonging to a defined grammar [18] into LTL formulas, as well as some natural language capabilities, as described in [14].", "startOffset": 196, "endOffset": 200}, {"referenceID": 13, "context": "To allow users who may be unfamiliar with LTL to define specifications, some tools like LTLMoP [17] include a parser that automatically translates English sentences belonging to a defined grammar [18] into LTL formulas, as well as some natural language capabilities, as described in [14].", "startOffset": 283, "endOffset": 287}, {"referenceID": 18, "context": "This fragment of LTL is called Generalized Reactivity (1) or GR(1) [20].", "startOffset": 67, "endOffset": 71}, {"referenceID": 18, "context": "The reader is referred to [20] and [5] for details of the synthesis procedure, and to [5, 17] for a description of how the extracted discrete automaton is transformed into low-level robot control.", "startOffset": 26, "endOffset": 30}, {"referenceID": 4, "context": "The reader is referred to [20] and [5] for details of the synthesis procedure, and to [5, 17] for a description of how the extracted discrete automaton is transformed into low-level robot control.", "startOffset": 35, "endOffset": 38}, {"referenceID": 4, "context": "The reader is referred to [20] and [5] for details of the synthesis procedure, and to [5, 17] for a description of how the extracted discrete automaton is transformed into low-level robot control.", "startOffset": 86, "endOffset": 93}, {"referenceID": 16, "context": "The reader is referred to [20] and [5] for details of the synthesis procedure, and to [5, 17] for a description of how the extracted discrete automaton is transformed into low-level robot control.", "startOffset": 86, "endOffset": 93}, {"referenceID": 19, "context": "In the case of unsynthesizable specifications, the counterstrategy synthesis algorithm introduced in [21] gives an automatic method of constructing a strategy for the environment, which provides sequences of environment actions that prevent the robot from achieving the specified behavior.", "startOffset": 101, "endOffset": 105}, {"referenceID": 19, "context": "marked with some robot goal [21].", "startOffset": 28, "endOffset": 32}, {"referenceID": 7, "context": "More examples illustrating the two cases can be found in [8].", "startOffset": 57, "endOffset": 60}, {"referenceID": 7, "context": ", initial conditions, safeties and goals) [8].", "startOffset": 42, "endOffset": 45}, {"referenceID": 7, "context": "The specification analysis algorithm presented in [8] will narrow down the cause of unsynthesizability to the goal in (4), but will also highlight the entirety of \u03c6 t s , declaring that the environment can prevent the goal because of some subset of the safeties (without identifying the exact subset).", "startOffset": 50, "endOffset": 53}, {"referenceID": 8, "context": "robot system [9, 11, 12] .", "startOffset": 13, "endOffset": 24}, {"referenceID": 10, "context": "robot system [9, 11, 12] .", "startOffset": 13, "endOffset": 24}, {"referenceID": 11, "context": "robot system [9, 11, 12] .", "startOffset": 13, "endOffset": 24}, {"referenceID": 8, "context": "The work in [9] addressed the problem of revising unsatisfiable LTL specifications.", "startOffset": 12, "endOffset": 15}, {"referenceID": 10, "context": "In [11, 12], the authors present exact and approximate algorithms for finding minimal revisions of specification automata, by removing the minimum number of constraints from the unsatisfiable specification.", "startOffset": 3, "endOffset": 11}, {"referenceID": 11, "context": "In [11, 12], the authors present exact and approximate algorithms for finding minimal revisions of specification automata, by removing the minimum number of constraints from the unsatisfiable specification.", "startOffset": 3, "endOffset": 11}, {"referenceID": 20, "context": "For unsatisfiable LTL formulas, the authors of [22] suggest a number of notions of unsatisfiable cores, tied to the corresponding method of extraction.", "startOffset": 47, "endOffset": 51}, {"referenceID": 21, "context": "The authors of [23] employ a formal definition of causality to explain counterexamples provided by model-checkers on unsatisfiable LTL formulas; the advantage of this method is the flexibility of defining an appropriate causal model.", "startOffset": 15, "endOffset": 19}, {"referenceID": 22, "context": ", [24, 25]) literature.", "startOffset": 2, "endOffset": 10}, {"referenceID": 23, "context": ", [24, 25]) literature.", "startOffset": 2, "endOffset": 10}, {"referenceID": 24, "context": "A similar technique was used in [26] for debugging declarative specifications.", "startOffset": 32, "endOffset": 36}, {"referenceID": 24, "context": "The approach in [26] only generalizes to specification languages that are reducible to SAT, a set which does not include LTL; this paper presents a similar approach, using SAT solvers to identify unsatisfiable cores for LTL.", "startOffset": 16, "endOffset": 20}, {"referenceID": 25, "context": "The authors of [27] also attempted to generalize the idea of unsatisfiable cores to the case of temporal logic using SAT-based bounded model checkers.", "startOffset": 15, "endOffset": 19}, {"referenceID": 26, "context": "In the context of unrealizability, the authors of [28] propose definitions for helpful assumptions and guarantees, and com-", "startOffset": 50, "endOffset": 54}, {"referenceID": 27, "context": "The authors in [29] use model-based diagnosis to remove not only guarantees but also irrelevant output signals from the specification.", "startOffset": 15, "endOffset": 19}, {"referenceID": 27, "context": "In [29], this is accomplished using techniques similar to those in [28], which in turn require many realizability checks.", "startOffset": 3, "endOffset": 7}, {"referenceID": 26, "context": "In [29], this is accomplished using techniques similar to those in [28], which in turn require many realizability checks.", "startOffset": 67, "endOffset": 71}, {"referenceID": 9, "context": "To identify and eliminate the source of unrealizability, some works like [10, 30] provide a minimal set of additional environment assumptions that, if added, would make the specification realizable; this is accomplished in [30] using efficient analysis of turn-based probabilistic games, and in [10] by mining the environment counterstrategy.", "startOffset": 73, "endOffset": 81}, {"referenceID": 28, "context": "To identify and eliminate the source of unrealizability, some works like [10, 30] provide a minimal set of additional environment assumptions that, if added, would make the specification realizable; this is accomplished in [30] using efficient analysis of turn-based probabilistic games, and in [10] by mining the environment counterstrategy.", "startOffset": 73, "endOffset": 81}, {"referenceID": 28, "context": "To identify and eliminate the source of unrealizability, some works like [10, 30] provide a minimal set of additional environment assumptions that, if added, would make the specification realizable; this is accomplished in [30] using efficient analysis of turn-based probabilistic games, and in [10] by mining the environment counterstrategy.", "startOffset": 223, "endOffset": 227}, {"referenceID": 9, "context": "To identify and eliminate the source of unrealizability, some works like [10, 30] provide a minimal set of additional environment assumptions that, if added, would make the specification realizable; this is accomplished in [30] using efficient analysis of turn-based probabilistic games, and in [10] by mining the environment counterstrategy.", "startOffset": 295, "endOffset": 299}, {"referenceID": 6, "context": "In the case of deadlock, which can be identified as in [7, 8], a series of Boolean formulas {\u03c8f romInit} is produced by incrementally unrolling the robot safety formula \u03c6 t s , and the satisfiability of \u03c8f romInit is checked at each depth.", "startOffset": 55, "endOffset": 61}, {"referenceID": 7, "context": "In the case of deadlock, which can be identified as in [7, 8], a series of Boolean formulas {\u03c8f romInit} is produced by incrementally unrolling the robot safety formula \u03c6 t s , and the satisfiability of \u03c8f romInit is checked at each depth.", "startOffset": 55, "endOffset": 61}, {"referenceID": 29, "context": "To perform this check, the formula \u03c8f romInit is first converted into CNF, so that it can be provided as input to an off-the-shelf SAT-solver; this work uses PicoSAT [31].", "startOffset": 166, "endOffset": 170}, {"referenceID": 6, "context": "Examples of this tool in action are given in [7, 8].", "startOffset": 45, "endOffset": 51}, {"referenceID": 7, "context": "Examples of this tool in action are given in [7, 8].", "startOffset": 45, "endOffset": 51}, {"referenceID": 13, "context": "Consider Specification 4, which first appeared in [14].", "startOffset": 50, "endOffset": 54}, {"referenceID": 19, "context": "Following [21], we call such a trace a countertrace.", "startOffset": 10, "endOffset": 14}, {"referenceID": 19, "context": "Computing countertraces is expensive [21], but it is possible to identify whether a given counterstrategy is a countertrace by checking that all paths from an initial state follow the same sequence of environment inputs.", "startOffset": 37, "endOffset": 41}, {"referenceID": 7, "context": "Suppose the algorithm in [8] identified goal Bk as the goal responsible for livelock.", "startOffset": 25, "endOffset": 28}, {"referenceID": 7, "context": "In the case of livelock, the initial specification analysis presented in [8] provides a specific liveness condition Bk that causes the unsynthesizability (i.", "startOffset": 73, "endOffset": 76}, {"referenceID": 18, "context": "Using the efficient algorithm in [20], each realizability check takes time O((mn\u03a3)3), where \u03a3 is the size of the state space, i.", "startOffset": 33, "endOffset": 37}, {"referenceID": 6, "context": "The examples presented previously appeared in [7], and this section demonstrates the improvement of the proposed approach over the analysis presented in that work.", "startOffset": 46, "endOffset": 49}, {"referenceID": 16, "context": "These examples were run using the opensource LTLMoP toolbox [17], within which all the technical outcomes presented in this paper have been implemented.", "startOffset": 60, "endOffset": 64}, {"referenceID": 6, "context": "(a) Sentences highlighted using approach in [7] (b) Sentences highlighted using proposed approach", "startOffset": 44, "endOffset": 47}, {"referenceID": 6, "context": "(a) Sentences highlighted using approach in [7] (b) Sentences highlighted using proposed approach", "startOffset": 44, "endOffset": 47}, {"referenceID": 6, "context": "5(a) depicts the sentences highlighted by the algorithm in [7].", "startOffset": 59, "endOffset": 62}, {"referenceID": 6, "context": "6(a) depicts the sentences highlighted by the algorithm in [7], which includes all safety conditions (red) in addition to the goal (green).", "startOffset": 59, "endOffset": 62}], "year": 2014, "abstractText": "With the increasing ubiquity of multi-capable, general-purpose robots arises the need for enabling non-expert users to command these robots to perform complex high-level tasks. To this end, high-level robot control has seen the application of formal methods to automatically synthesize correct-byconstruction controllers from user-defined specifications; synthesis fails if and only if there exists no controller that achieves the specified behavior. Recent work has also addressed the challenge of providing easy-to-understand feedback to users when a specification fails to yield a corresponding controller. Existing techniques provide feedback on portions of the specification that cause the failure, but do so at a coarse granularity. This work presents techniques for refining this feedback, extracting minimal explanations of unsynthesizability.", "creator": "LaTeX with hyperref package"}}}