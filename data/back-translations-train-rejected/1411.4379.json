{"id": "1411.4379", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Nov-2014", "title": "FGPGA: An Efficient Genetic Approach for Producing Feasible Graph Partitions", "abstract": "Graph partitioning, a well studied problem of parallel computing has many applications in diversified fields such as distributed computing, social network analysis, data mining and many other domains. In this paper, we introduce FGPGA, an efficient genetic approach for producing feasible graph partitions. Our method takes into account the heterogeneity and capacity constraints of the partitions to ensure balanced partitioning. Such approach has various applications in mobile cloud computing that include feasible deployment of software applications on the more resourceful infrastructure in the cloud instead of mobile hand set. Our proposed approach is light weight and hence suitable for use in cloud architecture. We ensure feasibility of the partitions generated by not allowing over-sized partitions to be generated during the initialization and search. Our proposed method tested on standard benchmark datasets significantly outperforms the state-of-the-art methods in terms of quality of partitions and feasibility of the solutions.", "histories": [["v1", "Mon, 17 Nov 2014 06:51:50 GMT  (170kb,D)", "http://arxiv.org/abs/1411.4379v1", "Accepted in the 1st International Conference on Networking Systems and Security 2015 (NSysS 2015)"]], "COMMENTS": "Accepted in the 1st International Conference on Networking Systems and Security 2015 (NSysS 2015)", "reviews": [], "SUBJECTS": "cs.NE cs.AI cs.DC", "authors": ["md lisul islam", "novia nurain", "swakkhar shatabda", "m sohel rahman"], "accepted": false, "id": "1411.4379"}, "pdf": {"name": "1411.4379.pdf", "metadata": {"source": "CRF", "title": "FGPGA: An Efficient Genetic Approach for Producing Feasible Graph Partitions", "authors": ["Md. Lisul Islam", "Novia Nurain", "Swakkhar Shatabda", "M Sohel Rahman"], "emails": ["swakkhar}@cse.uiu.ac.bd,", "msrahman@cse.buet.ac.bd"], "sections": [{"heading": "1 Introduction", "text": "Such loading poses challenges for both cloud users and cloud components, while various practical and theoretical applications are needed. Applications include Parallel / Distributed Computing (Load Balancing of Computations), Scientific Computing Approaches (Clique Recognition), Pattern Recognition, and Relationship Network Analysis. However, the goal of graph partitioning is to divide the recesses of a graph into specific sizes so that only a few edges pass between sets (i.e.). The graph partitioning problem has become more important due to its gaming applications in mobile cloud computing components, such as moving parts of a piece of software from the mobile hand to a more inventive server (Fig. 1)."}, {"heading": "2 Preliminaries", "text": "In this section, we provide a formal definition of the problem of graph partitioning discussed in this paper and a brief description of genetic algorithms."}, {"heading": "2.1 Problem Model", "text": "We adopted the problem model described in [8]. However, in [8] the authors used only homogeneous machines and assumed that the machine graph is complete and all edges of the machine graph have the same weight. In our problem we get two graphs: the application graph GA and the machine graph GM. The application graph GA = (V, E) is an undirected weighted graph where the vertices of the diagram correspond to distributed software units of use in the system and the edges to the communication costs between software units. The vertices of this diagram are also weighted. Each vertice vi is associated with a weight chart ri. The weight of one vertice corresponds to the amount of resources required for this device deployment. Examples of such a resource is CPU performance. The adaptation matrix W for this graph GA contains the weights for the edges, For each Wij \u00b2 W represents the communication effort between the software component and the software component."}, {"heading": "2.2 Genetic Algorithms", "text": "Genetic algorithms are population-based search methods that are similar to the natural phenomena of biological evolution. Genetic algorithms are often used for various search optimization problems in different fraternities. Genetic algorithms maintain a set of solutions known as populations. Generally, they begin with a pool of initial random solutions called initial populations. Each individual in the population is encoded by a set of characteristics that can be called a chromosome or genotype and modified to achieve population diversification, followed by an iterative process in which each of these iterations is called a generation. In each generation, the population is then allowed to evolve using various operators that also mimic the natural process of biological evolution such as mutation, recombination or crossover and survival of the fittest. In each generation, the fitness of each individual is evaluated. Generally, the fitness of the optimization function is considered the value of the fitness that is resolved."}, {"heading": "3 Related work", "text": "The term graph partitioning refers to the partitioning of the vertices of a graph into a certain number of disjoint sets of approximately the same size, so that a sectional metric is minimized. Graph partitioning is a NP-complete problem [11] and that there are no approximation algorithms with a constant ratio factor for general graphs [11]. Due to this theoretical limitation, numerous heuristic algorithms for graph partitioning have been developed in recent decades that generate high-quality partitions in very little time. Motivated by the problem of partitioning electronic circuits on disks, a heuristic method is produced [9]. This method is known as the Kernighan-Lin (KL) algorithm. Subsequently, the Kerniggling-Lin algorithm improved in terms of runtime by fiduccia and affected hierarchies."}, {"heading": "4 FGPGA: Our Proposed Method", "text": "Our proposed FGPGA algorithm is formally presented in Algorithm 5. The first generation population in our algorithm contains only viable individuals who are randomly initialized. Our algorithm ends with convergence and convergence is achieved when no significant improvement in the quality of the world's best solutions has been observed for a certain period of time of generation. For each generation, our algorithm selects individuals who participate in the recombination (also known as cross-over) through tournament selection in order to produce offspring to be included in the next generation. In addition, a probable mutation is performed on each of the newly bred individuals. Individuals with the best fitness value are always passed on to the next generation to ensure elitism. In order to maintain diversification among individuals in the search space and to recover from stagnation during the evolutionary process, we periodically conduct twin withdrawals and random restart procedures. The rest of this section is dedicated to summarizing all the parameters necessary for the description of the PGA 1."}, {"heading": "4.1 Encoding", "text": "In our method, we have encoded each individual in a population by V-number of genes. In this case, V is the number of components in a software application. Each of these genes in an individual is randomly initialized based on a uniform distribution of the range [1, M], where M is the total number of heterogeneous machines in machine graphs. Thus, an individual X can be represented as the ordered list of the V-number of genes, with each gene Xi representing the assignment of a software component to a machine.X = {X1, X2, X3,..., XV} Here Xi represents the machine to which component was assigned."}, {"heading": "4.2 Initialization", "text": "Each individual in the population represents an assignment of application software components to a physically heterogeneous machine that has certain capacity limitations. Thus, when a machine is assigned a component or group of components whose aggregate capacity needs exceed the capacity of the respective machine, we can invalidate that group of assignments or declare that person to be an unworkable solution to the graph distribution problem. Thus, during population initialization, we searched for solutions or individuals only in the workable search space, creating a population that consisted only of workable individuals. For each gene in a person's genotype, we repeatedly searched for a machine with enough capacity to house the ith component of the application software. A sketch of the pseudo-code for the initialization process is given below: Algorithm 1: Initialization (Individual X) 1 M = Total number of machines in infrastructure 2 for each gene X (in genotype X) the machine is randomly selected (we find a machine X)."}, {"heading": "4.3 Greedy Mutation", "text": "In our proposed algorithm, we have adopted and implemented a greedy mutation strategy, in which we optimally select the new value of a particular gene of an individual. We randomly change a particular gene by trying r different values for that gene and finally retain the value of those r different values that make the individual fittest, while still keeping it within the feasible range of the search area. An example of greedy mutation is shown in Figure 2. Here, r is set to the number of machines in the infrastructure. Since greedy mutation is mathematically cumbersome, we make the choice between the random mutation and greedy mutation with a probability, GreedyMutationRate (= 0.8). If no feasible individual is found by mutating the currently selected gene, we then try another gene in the chromosome to mutate. The algorithm for greedy mutation is given in Algorithm 2. Algorithm 2: Greedy mutation (individual X) 1 set of random values is specified by X = 5 machines (X = 5) where Gi = 5 (p) is specified for each Gen (X = 5)."}, {"heading": "4.4 Cross-over", "text": "Crossover operator helps genetic evolution to exploit the fitter solutions of previous generations and creates new individuals by allowing fitter individuals to multiply among themselves. To select individuals who act as parents and participate in the recombination to produce offspring, we chose tournament selection with tournament size of 5. Then, genes from both parents are recombined with one-point crossover to create a new gene set for each of the newly formed offspring. Figure 3 shows an example of cross-over process. We have tried different crossover points until we have viable offspring. If no viable offspring are found using the current parents, we then test different parents by tournament selection to generate viable offspring. The algorithm is outlined in Algorithm 3.Algorithm: Crossover (single person X1, single person X2) 1 Xnew1 and X2 are two new offspring by tournament selection to generate viable offspring."}, {"heading": "4.5 Fitness Evaluation", "text": "We have ensured the feasibility of initialization, mutation and crossover, so the search process will always take place within the feasible search space. We have evaluated the suitability of an individual X on the basis of Equation 1."}, {"heading": "4.6 Twin Removal", "text": "The similarity between individuals X1 and X2, similarity (X1, X2) is defined below as: number i so that X1 (i) is not equal to X2 (i) size of the genotype. We declare X1 and X2 twins if they exhibit more than 95% similarity in their genotype and randomly reinitialize one of them to a workable solution. We have performed the procedure of twin removal after 100 generations of evolution.Algorithm 4: twin removal 1 similarity threshold = 0.95 2 for each pair of individuals (Xi, Xj) in the population do 3 if similarity (Xi, Xj)."}, {"heading": "4.7 Random Restart", "text": "If the algorithm does not improve the fitness of the best individual within a significant number of generations, we reinitialize 50% of the population with random values within the feasible search space. We evaluated the improvement over the immediate past 50 generations. If the improvement over the past 50 generations is less than or equal to a threshold, t = 0.001, we initiate the random restart procedure. Algorithm 5: FGPGA () 1 nonDiverseSteps = 0 2 nonImprovingSteps = 0 3 GreedyMutationRate = 0.8 4 Intialize of the population, P random 5, while the termination criterion is met, do 6 Pnew = {globalBest} 7 for each Individual X, P do 8 < X1, X2 > = eventamentSelection (P) 9 Xnew = crossOver (X1, X2) 10, if Fitness (Xnew1) Non-proving1) X then add 11 Xnewing1 to Pnew 12 otherwise add 13 newtwingFitness (Ptwing15) then (PtwingSelection)"}, {"heading": "5 Experimental Results", "text": "We implemented FGPGA in Java programming language using JDK 1.6 and conducted our experiments on an Intel (R) Core (TM) 2 Quad CPU @ 2.40 GHz with 4GB RAM under Windows 7 operating system."}, {"heading": "5.1 Dataset Generation", "text": "To evaluate the performance of our algorithm, we create test graphs using a method similar to that described in [8]. However, the authors in [8] assumed that the infrastructure is homogeneous, and as a result they considered that communication between machines in the cloud infrastructure is uniform, and that the machine graph is a complete graph. Such cases are unrealistic because they do not take into account the heterogeneity of the infrastructure. We modify the graph generation technique to generate test cases that generate graphs with different node sizes and machine graphs with heterogeneous communication connections between them. We first determined the capacity required for the machine graph and multiplied it by 1.5 to ensure a workable infrastructure {\u00b7 5} were then randomly generated by a selected machine with capacity."}, {"heading": "5.2 Algorithm Comparison", "text": "We compared our method with the simulated annealing method proposed in [8]. However, in [8] a number of algorithms were proposed and applied to solve the problem of diagram distribution. Among all the simulated annealing algorithms, they produced higher quality solutions for most of the chart instances they used. We implemented the simulated annealing method described in their work and compared it with the FGPGA. In their simulated annealing [8], they enable unfeasible movements or assignments of vertices to partitions that are already oversized and allow capacity limitations to be violated. In their paper [8], they mention that due to the decrease in unfeasible movements in later eras, the rate of performing unfeasible movements also decreases and thus produces valid solutions when the algorithm ends. However, there is no guarantee that feasible solutions will be produced once an unfeasible step is taken."}, {"heading": "5.3 Results", "text": "We report on the best and average graph interface size for the best partitions found by two algorithms that simulate annealing and FGPGA in Table 2. Each algorithm was run 10 times for each of the graph interface sizes, and the average is shown in the table. Each line corresponds to the results for a particular graph instance. Values in bold fonts show the better quality partitions with a lower graph interface size. Table 2 clearly shows that FGPGA is able to produce better quality partitions in all cases. To show the importance of improving FGPGA over simulated annealing, we plot the best and average graph interface size of the best partitions found by both algorithms for each of the graph instances in Figure 4 and Figure 5. We could see the difference in the quality of the partitions generated by both algorithms. Note that both algorithms generate partitions with relatively high costs for the number of nodes with larger instances."}, {"heading": "5.4 Convergence", "text": "The strength of our genetic approach is that it converges quickly compared to the simulated annealing algorithm. Searching progress for two algorithms is shown in Figure 6. The curves in Figure 6 show the earlier convergence of the best partition in each iteration of simulated annealing algorithms over time and for each generation of genetic algorithms until they converge and end. Figure 6 shows the earlier convergence of FGPGA. FGPGA converts quickly and ends, while simulated annealing does not improve the quality of the partition even when the temperature is higher. This graph shows the behavior of the graph instance 1 algorithms with the number of vertices 100. Other graph cases show similar behavior."}, {"heading": "5.5 Effect of Greedy Mutation", "text": "To show the effect of the greedy mutation operator, we are preparing a different version of the FGPGA algorithm by turning off the greedy mutation. In this version of the FGPGA, the greedy mutation operator is replaced by a traditional random mutation operator, which selects the first valid mutation possible for each randomly selected gene value. The logarithm of the graph section size is shown for each of the versions in Figure 7. Figure 7 clearly shows the early convergence of the greedy mutation operator."}, {"heading": "6 Conclusion", "text": "The recent evolution of mobile cloud computing is leading to a new domain of challenges such as optimal use of software applications on the more inventive infrastructure in the cloud rather than mobile handsets. Such problems can easily be modeled as a graph-based partitioning problem, where a weighted graph of software components had to be partitioned into a number of parts that represent the available infrastructures (i.e. machines) in the cloud. Therefore, in this paper we have introduced FGPGA, an efficient genetic approach to creating workable graph partitions. Our method takes into account the heterogeneity and capacity limitations of the partitions, which resemble real-world scenarios of mobile cloud computing. Feasibility of the generated partitions is ensured by discarding oversized partitions during the search. Experimental results demonstrate the superiority of our proposed method over standardized benchmark data sets in terms of the quality of the partitions and the feasibility of the cloud architecture, and therefore our algorithm is important to investigate the use of our algorithm for the architecture in the future."}], "references": [{"title": "The Case for VM-Based Cloudlets in Mobile Computing", "author": ["M. Satyanarayanan", "P. Bahl", "R. Caceres", "N. Davies"], "venue": "IEEE Pervasive Computing,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Cloudlets: bringing the cloud to the mobile user", "author": ["T. Verbelen", "P. Simoens", "F. De. Turck", "B. Dhoedt"], "venue": "In Proceedings of the 3 ACM workshop on Mobile Cloud Computing and Services,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Partitioning sparse matrices with eigenvectors of graphs", "author": ["A. Pothen", "H.D. Simon", "K.-P. Liou"], "venue": "SIAM J. Matrix Anal. Appl.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1990}, {"title": "A Linear-Time Heuristic for Improving Network Partitions", "author": ["C.M. Fiduccia", "R.M. Mattheyses"], "venue": "In 19 Conference on Design Automation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1982}, {"title": "Genetic algorithm and graph partitioning", "author": ["T.N. Bui", "B.R. Moon"], "venue": "IEEE Trans. Comput.,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1996}, {"title": "Spectral techniques for graph bisection in genetic algorithms", "author": ["J.G. Martin"], "venue": "IEEE In Proceedings GECCO\u201906,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2006}, {"title": "Graph partitioning algorithms for optimizing software deployment in mobile cloud computing", "author": ["T. Verbelen", "T. Stevens", "F. De. Turck", "B. Dhoedt"], "venue": "Future Gener. Comput. Syst.,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "An effcient heuristic procedure for partitioning graphs", "author": ["B.W. Kernighan", "S. Lin"], "venue": "The Bell System Technical Journal,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1970}, {"title": "Parallel multilevel k-way partitioning scheme for irregular graphs", "author": ["G. Karypis", "V. Kumar"], "venue": "In Supercomputing,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1996}, {"title": "Finding good approximate vertex and edge partitions is NP-hard", "author": ["T.N. Bui", "C. Jones"], "venue": "Inf. Process. Lett.,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1992}, {"title": "A linear-time heuristic for improving network partitions", "author": ["C. Fiduccia", "R. Mattheyses"], "venue": "In Design Automation,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1982}, {"title": "Pmrsb: Parallel multilevel recursive spectral bisection", "author": ["S. Barnard"], "venue": "In Supercomputing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1995}, {"title": "An effective multi-level algorithm based on simulated annealing for bisecting graph", "author": ["L. Sun", "M. Leng"], "venue": "Lecture notes in Computer Science", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2007}, {"title": "A new multi-level algorithm based on particle swarm optimization for bisecting graph", "author": ["L. Sun", "M. Leng"], "venue": "Lecture notes in Computer Science", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "A effective multi-level algorithm based on ant colony optimization for bisecting graph", "author": ["L. Sun", "M. Leng"], "venue": "Lecture notes in Computer Science", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Partitioning spase matrices with eigenvectors of graphs", "author": ["A. Pothen", "H.D. Simon", "K.P. Liou"], "venue": "SIAM Journal on Matrix analysis and applications", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1990}, {"title": "JOSTLE: Parallel Multilevel Graph-Partitioning Software : An Overview", "author": ["C. Walshaw", "M. Cross"], "venue": "In F. Magoules, editor, Mesh Partitioning Techniques and Domain Decomposition Techniques,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "Graph partitioning for high performance scientific simulations", "author": ["K. Schloegel", "G. Karypis", "V. Kumar"], "venue": "In J. Dongarra et al., editor, CRPC Par. Comp. Handbook", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2000}, {"title": "Mckeown, A PROBE-based heuristic for graph partitioning", "author": ["P. Chardaire", "M. Barake", "G.P"], "venue": "IEEE Transaction on Computers,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "An efficient approach for large scale graph partitioning", "author": ["R. Loureiro", "A. Amaral"], "venue": "Journal of Combinatorial Optimization,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2007}], "referenceMentions": [{"referenceID": 0, "context": "A special case of such deployment optimization occurs in cloudlet [1,2], where multiple mobile devices access nearby static resourceful computers linked to a distant cloud through high speed wired connections.", "startOffset": 66, "endOffset": 71}, {"referenceID": 1, "context": "A special case of such deployment optimization occurs in cloudlet [1,2], where multiple mobile devices access nearby static resourceful computers linked to a distant cloud through high speed wired connections.", "startOffset": 66, "endOffset": 71}, {"referenceID": 2, "context": "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.", "startOffset": 46, "endOffset": 49}, {"referenceID": 3, "context": "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.", "startOffset": 65, "endOffset": 68}, {"referenceID": 4, "context": "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.", "startOffset": 83, "endOffset": 89}, {"referenceID": 5, "context": "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.", "startOffset": 83, "endOffset": 89}, {"referenceID": 7, "context": "Others existing approaches of graph partitioning such as Kernighan-Lin algorithm [9] fails to scale to large scale graph data.", "startOffset": 81, "endOffset": 84}, {"referenceID": 6, "context": "The authors of [8] have introduced a graph partitioning algorithm based on simulated annealing [14] for software deployment in the cloud.", "startOffset": 15, "endOffset": 18}, {"referenceID": 12, "context": "The authors of [8] have introduced a graph partitioning algorithm based on simulated annealing [14] for software deployment in the cloud.", "startOffset": 95, "endOffset": 99}, {"referenceID": 6, "context": "1 Problem Model We adopted the problem model described in [8].", "startOffset": 58, "endOffset": 61}, {"referenceID": 6, "context": "However, the authors in [8] used only homogeneous machines and assumed the machine graph to be complete and all edges in the machine graph to have same weight.", "startOffset": 24, "endOffset": 27}, {"referenceID": 9, "context": "Graph partitioning is a NP-complete [11] problem and that there is no approximation algorithm with a constant ratio factor for general graphs [11].", "startOffset": 36, "endOffset": 40}, {"referenceID": 9, "context": "Graph partitioning is a NP-complete [11] problem and that there is no approximation algorithm with a constant ratio factor for general graphs [11].", "startOffset": 142, "endOffset": 146}, {"referenceID": 7, "context": "Motivated by the problem of partitioning electronic circuits onto boards a heuristic method is produced in [9].", "startOffset": 107, "endOffset": 110}, {"referenceID": 10, "context": "The Kernighan-Lin algorithm subsequently improved in terms of running time by Fiduccia and Mattheyses [12].", "startOffset": 102, "endOffset": 106}, {"referenceID": 5, "context": "The spectral bisection method is another popular method, which is based on the spectrum of the graphs Laplacian matrix [7, 13].", "startOffset": 119, "endOffset": 126}, {"referenceID": 11, "context": "The spectral bisection method is another popular method, which is based on the spectrum of the graphs Laplacian matrix [7, 13].", "startOffset": 119, "endOffset": 126}, {"referenceID": 12, "context": "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].", "startOffset": 133, "endOffset": 137}, {"referenceID": 13, "context": "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].", "startOffset": 167, "endOffset": 171}, {"referenceID": 14, "context": "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].", "startOffset": 200, "endOffset": 204}, {"referenceID": 8, "context": "One recent approach that has greatly accelerated the partitioning of large graphs is the use of multilevel techniques [10].", "startOffset": 118, "endOffset": 122}, {"referenceID": 15, "context": "This graph is then partitioned using a spectral method [17] and this partition is propagated back through the hierarchy of graphs.", "startOffset": 55, "endOffset": 59}, {"referenceID": 16, "context": "Well-known software packages based on this approach include Jostle [18], Metis [19], and Scotch [20].", "startOffset": 67, "endOffset": 71}, {"referenceID": 17, "context": "Well-known software packages based on this approach include Jostle [18], Metis [19], and Scotch [20].", "startOffset": 79, "endOffset": 83}, {"referenceID": 18, "context": "use a PROBE (Population Reinforced Optimization Based Exploration) heuristic [21].", "startOffset": 77, "endOffset": 81}, {"referenceID": 19, "context": "Besides, Loureiro and Amaral introduce a greedy graph growing heuristic deploying a local refinement algorithm [22].", "startOffset": 111, "endOffset": 115}, {"referenceID": 6, "context": "Hence, the authors of [8], proposed a graph partitioning algorithm based on simulated annealing for mobile cloud computing.", "startOffset": 22, "endOffset": 25}, {"referenceID": 6, "context": "To evaluate the performance of our algorithm we generate test graphs following method similar to described in [8].", "startOffset": 110, "endOffset": 113}, {"referenceID": 6, "context": "However, the authors in [8] assumed the infrastructure to be homogeneous.", "startOffset": 24, "endOffset": 27}, {"referenceID": 6, "context": "2 Algorithm Comparison We compared our method with the simulated annealing method proposed in [8].", "startOffset": 94, "endOffset": 97}, {"referenceID": 6, "context": "In [8], a number of algorithms was proposed and applied to solve the graph partitioning problem.", "startOffset": 3, "endOffset": 6}, {"referenceID": 6, "context": "In their simulated annealing [8], they allow infeasible moves or assignments fo vertices to partitions that are already over-sized and allow the capacity constraint to be violated.", "startOffset": 29, "endOffset": 32}, {"referenceID": 6, "context": "In their paper, they [8] mention that due to the decrease in temperature in later epochs the rate of taking infeasible moves will decrease also and thus produce valid solution when the algorithm terminates.", "startOffset": 21, "endOffset": 24}, {"referenceID": 6, "context": "Detail of the rest of the algorithm can be found in [8].", "startOffset": 52, "endOffset": 55}, {"referenceID": 6, "context": "Since simulated annealing take long to converge, we allowed it to finish the epochs as described in [8].", "startOffset": 100, "endOffset": 103}], "year": 2014, "abstractText": "Graph partitioning, a well studied problem of parallel computing has many applications in diversified fields such as distributed computing, social network analysis, data mining and many other domains. In this paper, we introduce FGPGA, an efficient genetic approach for producing feasible graph partitions. Our method takes into account the heterogeneity and capacity constraints of the partitions to ensure balanced partitioning. Such approach has various applications in mobile cloud computing that include feasible deployment of software applications on the more resourceful infrastructure in the cloud instead of mobile hand set. Our proposed approach is light weight and hence suitable for use in cloud architecture. We ensure feasibility of the partitions generated by not allowing over-sized partitions to be generated during the initialization and search. Our proposed method tested on standard benchmark datasets significantly outperforms the state-of-the-art methods in terms of quality of partitions and feasibility of the solutions.", "creator": "LaTeX with hyperref package"}}}