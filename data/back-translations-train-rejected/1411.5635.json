{"id": "1411.5635", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Nov-2014", "title": "Justifying Answer Sets using Argumentation", "abstract": "An answer set is a plain set of literals which has no further structure that would explain why certain literals are part of it and why others are not. We show how argumentation theory can help to explain why a literal is or is not contained in a given answer set by defining two justification methods, both of which make use of the correspondence between answer sets of a logic program and stable extensions of the Assumption-Based Argumentation (ABA) framework constructed from the same logic program. Attack Trees justify a literal in argumentation-theoretic terms, i.e. using arguments and attacks between them, whereas ABA-Based Answer Set Justifications express the same justification structure in logic programming terms, that is using literals and their relationships. Interestingly, an ABA-Based Answer Set Justification corresponds to an admissible fragment of the answer set in question, and an Attack Tree corresponds to an admissible fragment of the stable extension corresponding to this answer set.", "histories": [["v1", "Thu, 20 Nov 2014 18:37:12 GMT  (1002kb,D)", "https://arxiv.org/abs/1411.5635v1", null], ["v2", "Tue, 2 Dec 2014 14:52:20 GMT  (1002kb,D)", "http://arxiv.org/abs/1411.5635v2", "This article has been accepted for publication in Theory and Practice of Logic Programming"]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["claudia schulz", "francesca toni"], "accepted": false, "id": "1411.5635"}, "pdf": {"name": "1411.5635.pdf", "metadata": {"source": "CRF", "title": "Justifying Answer Sets using Argumentation", "authors": ["CLAUDIA SCHULZ", "FRANCESCA TONI", "Claudia Schulz"], "emails": ["f.toni}@imperial.ac.uk)"], "sections": [{"heading": null, "text": "Key concepts: response programming, assumption-based reasoning, stable extension, explanation"}, {"heading": "1 Introduction", "text": "In fact, most of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to move, to move, to move, to move, to move, to move, to fight, to fight, etc. etc."}, {"heading": "2 Background and Preliminaries", "text": "This section describes all the background information necessary to understand the definitions of ABAS justifications, as well as some key findings on concepts in ASP and ABA that have not or only partially been considered in the literature."}, {"heading": "2.1 Answer Set Programming", "text": "It is a question of whether it is a question of a way in which people perceive themselves and the world as a whole. (...) It is a question of whether people in the world as a whole and as a whole perceive the world as a whole. (...) It is a question of whether the world as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as a whole, as, as a whole, as, as, as, as, as, as, as, as, as,"}, {"heading": "Proof", "text": "We prove both points: \u2022 If S is an answer to P, then S = AS (PS). This means that there is a clause l \u00b2 S, not lm \u00b2 l1,..., not lm + n \u00b2 P, so that l1,.., lm \u00b2 S and lm + 1,..., lm + n \u00b2 S,..., not lm + n \u00b2 P, so that l1,..., lm \u00b2 S and lm + 1,... l \u00b2 S, so (1) l \u00b2 S or (2) there is a clause l \u00b2 l \u00b2 S, not lm \u00b2 S,....., not lm \u00b2 S, not lm \u00b2 P. \"Answer the other way around, if P \u00b2 S is\" MP \"l, then (1) l \u00b2 S or (2) there is a clause l \u00b2 S,."}, {"heading": "2.2 An intuitive example of ASP", "text": "Let Dr. Smith be an ophthalmologist (an ophthalmologist) and let one of his patients be Peter, who is diagnosed by Dr. Smith as myopic. On the basis of this diagnosis, Dr. Smith must decide on the most appropriate treatment for Peter, taking into account the additional information he has about his patient, namely that Peter is afraid to touch his own eyes, that he is a student, and that he enjoys exercising. On the basis of this information and his expertise, Dr. Smith decides that the most appropriate treatment for Peter's myopia is laser surgery. Dr. Smith is now examining whether this decision is consistent with the recommendation of his decision support system, which is implemented in ASPS. Example 1The following logic program Pdoctor represents the decision support system used by Dr. Smith. It encodes some general global knowledge as well as the expertise of an ophthalmologist on the possible treatments for myopia."}, {"heading": "2.3 ABA frameworks", "text": "Much of the literature on argumentation in Artificial Intelligence focuses on two types of argumentation frameworks, all of which are empty. Abstract Argumentation (Dung 1995b) assumes that a series of abstract entities (the arguments) are given together with an attack relationship between them. In contrast, structured argumentation frameworks such as (Prakken 2010; Garc \u0301 a and Simari 2004; Governatori et al. 2004) provide mechanisms for constructing arguments from given knowledge, mainly in the form of rules and for identifying the attack relationship between arguments based on arguments. We will here refer to the structured argumentation framework of (Bondarenko et al. 1997; Dung et al. 2009) as argumentation based on arguments (ABA).An ABA framework (Dung et al. 2009) is a tuple < L, R, A, Cement >, where \u2022 R are a deductive system with the form of L and the return rules of R."}, {"heading": "Proof", "text": "This follows directly from the definition of argumentations.The attack relationship between arguments defined here is a slight deviation from the term in (Dung et al. 2009), since it considers arguments with assumptions and factual prerequisites. Definition 3 (Attacks) An argument (AP1, FP1) \"\u03b11 attacks an argument (AP2, FP2)\" \u03b12 under the premise \u03b13, if and only if \u03b13, AP2 and \u03b13 = \u03b11. Equally, we say that (AP2, FP2) \"\u03b12 of (AP1, FP1)\" \u03b11 is an attacker of (AP2, FP2) \"\u03b12. A series of arguments X attacks an argument B if and only if and only if there is an argument X attacking.\" A series of arguments X1 attacks a series of arguments X2 if and only if and only if X1 attacks an argument X2, AP2 attacks AP2 directly, AP2 attacks AP2 and AP2 only if and AP2 attacks AP2, AP2 directly and AP2 only if APX\u03b1."}, {"heading": "2.4 ABA semantics", "text": "For our purposes, we focus on the allowable and stable extension semantics introduced in (dung 1995b) for abstract reasoning and in (Bondarenko et al. 1997) for ABA. \u2022 X defends an argument A if and only if X is a valid extension of A. \u2022 X is a valid extension of < L, A, R, A, A, A, and only if X does not attack and X defends all arguments in X. \u2022 X is a valid extension of A. \u2022 X is a valid extension of < L, R, A, A, and only if X defends all arguments in X. \u2022 X is a valid extension of < L, A, X is a valid extension of A. \u2022 X is a valid extension of < L, R, A, A, and only if X proclaims all arguments in X. \u2022 X is a valid extension of < L, A, proclaimed."}, {"heading": "Proof", "text": "Similar to the proof for theorem 3.10 in (Bondarenko et al. 1997): According to the definition of stable extension, X is a stable extension if and only if X = {A in < L, R, A, \u00af > | X does not attack A. Then X = {(AP1, FP1) '\u03b11 | @ (AP2, FP2)' \u03b12 \u0445 X attacking (AP1, FP1) '\u03b11} according to definition 2 and 3 and X = {(AP1, FP1)' \u03b11 | @ (AP2, FP2) '\u03b12 \u0445 X s.t. \u03b2 (AP1, \u03b2 = \u03b12} according to definition 3. This can be divided into X = {(AP1, FP1)' \u03b11."}, {"heading": "Proof", "text": "Note that fact arguments are always part of a stable extension, since they cannot be attacked, so we focus only on assumption arguments. \u2022 From left to right: If (AP, FP) \"Alpha X then by Lemma 3\" Alpha AP \"(AP1, FP1)\" Alpha X. \"Consequently, ({\u03b2}\" Alpha X \"is not attacked by X, i.e. by defining a stable extension ({\u03b2}, \u2205)\" Alpha X. \u2022 From right to left: If Alpha AP \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha\" Alpha \"Alpha."}, {"heading": "Proof", "text": "\u2022 From left to right: If (AP, FP) \"\u03b1 / \u0445 X\" then (AP, FP) \"\u03b1 is attacked by X on any \u03b2-AP. Consequently, ({\u03b2}, \u2205)\" \u03b2 is attacked by X, i.e. ({\u03b2}, \u2205) \"\u03b2 / \u0445 X. \u2022 From right to left: If \u03b2 AP is attacked in such a way that (\u03b2)\" \u03b2 / \u0445 X then (\u03b2}, \u2205) \"\u03b2 is attacked by X, meaning that it is something (AP1, FP1)\" \u03b2-X. Thus (AP, FP) \"\u03b1 is attacked from X to \u03b2, so (AP, FP)\" \u03b1 / \u0445 X."}, {"heading": "3 Translating a logic program into an ABA framework", "text": "To use ABA to justify literals in relation to a response set of a consistent logic program, the logic program must first be expressed as an ABA framework."}, {"heading": "3.1 The translation", "text": "We use the approach of (Bondarenko et al. 1997) to translate a logic program into an ABA framework = \"not,\" \"not,\" \"not,\" where the clauses of a logic program represent the set of ABA rules and NAF literals as assumptions in ABA.Definition 4 (translated ABA framework). Let P be a logic program. ABAP = < LP, AP, AP, \"is the translated ABA framework of P in which: \u2022 RP = P = NAFP \u2022 for any non-l = AP: not l = LP = arguments NAFPNote that the clauses of a logic program {ABA framework of P} {ABA can be used directly as rules, since we do not apply the same notation for both. Also note that translated ABA frameworks are always flat, since NAF literals do not occur in the head of clauses of a logic program.\" 2 The following example does not serve as a litmus program for P1, not serve as an example for P1."}, {"heading": "3.2 Correspondence between Answer Sets and Stable Extensions", "text": "In this section, we describe the relationship between the response sentences of a logic program and stable extensions of the translated ABA framework. Conversely, Theorem 2 expresses that a stable extension consists of all arguments supported by NAF literals that are satisfied with the \"appropriate\" response sentence. Note that part of this correspondence was given without formal proof in (Bondarenko et al. 1997). Theorem 1 Let P be a logic program and let ABAP = < LP, RP, AP, E >. Let X be a set of arguments in ABAP and let T = {k | (AP, FP)'k \u00b2 be the totality of all conclusions of arguments in X. X is a stable extension of ABAP if and only if T is a response with NAF words from P."}, {"heading": "Proof", "text": "\u2022 X is a stable extension of ABAP \u2022 iff X = (AP1, FP1) 'k is an argument in ABAP | AP1' X '(AP2, FP2)' l 'X' (from Lemma 3) \u2022 iff X = [(AP1, FP1) 'k | AP1' k | AP1 'X, RP' X 'MP k' (from AP2, FP2) 'l' X '(from Lemma 2) \u2022 iff X =' k '(from AP1 X, P' n 'MP k') 'k | AP1' X, P 'MP k' (from AP2, FP2) 'l' l 'l' X '(from Lemma 2) \u2022 iff X =' k '(from AP1 X, P' n 'MP k') is a stable extension of P = {not l 'P' (from AP2, FP2) 'l' l 'l' X} '(from definition 4) \u2022 iX =' k '(AP1' k ', AP1' p ')."}, {"heading": "Proof", "text": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}, {"heading": "Proof", "text": "This year, it is as if it were a purely reactionary project."}, {"heading": "4 Attack Trees", "text": "Our first justification approach explains why arguments are contained in a stable extension or not by constructing an attack tree of that argument in relation to stable extension. This attack tree is later used to construct a justification in relation to literals: due to the similarity between response sentences and stable extensions, a justification of a literal k in relation to a collection of responses can be derived from an attack tree of an argument with conclusion k constructed in relation to the corresponding stable extension. In this section, we define the term attack trees and show their relationship to abstract dispute trees for ABA, characterizing the explanations they provide as permissible fragments of the stable extension as well as the response group when constructing an attack tree in relation to a corresponding stable extension."}, {"heading": "4.1 Constructing Attack Trees", "text": "This year, it is more than ever before in the history of the city."}, {"heading": "Proof", "text": "This is directly derived from definition 5 and notation 5. Intuitively, an attack tree of an argument in relation to a series of arguments explains why the argument is contained in the set or not by either showing that the argument is defended by the set, i.e. that the set attacks all the attackers of the argument, or that the argument is attacked by the sets and cannot defend itself against it. The first case explains why the argument is part of the set, while the second justifies that the argument is not part of the set."}, {"heading": "4.2 Attack Trees with respect to Stable Extensions", "text": "To justify it, we construct attack trees based on stable extensions and not on arbitrary arguments. This allows us later to extract a justification of a letter relating to a response from an attack tree constructed with respect to the corresponding stable extension. In this section, we will show some properties of attack trees related to a stable extension that apply to both positive and negative attack trees. One of these features is that we can conclude whether or not an argument constructed by a node in an attack tree related to a stable extension is included in this stable extension: all arguments labeled \"+\" in the attack tree are included in the stable extension, while all arguments labeled \"\u2212\" are not included in the stable extension.Lemma 7 Let P be a logical program and let E be a stable extension of ABAP."}, {"heading": "Proof", "text": "1. A + i is either the root node, then by definition Ai-E, or it is the only subnode of any A-N, which means that by definition Ai-E. 2. A-i is either the root node, then by definition Ai-E or A-i a subnode of A + N, and Ai attacks AN. From Part 1 we know that AN-E, that is, Ai / E, because E does not attack itself. Another interesting feature of an attack tree constructed with respect to a stable extension is that all nodes carrying arguments labeled \"\u2212\" have exactly one child node and none. Moreover, all leaf nodes contain arguments labeled \"+.\" Lemma 8 Let P be a logical program and let E be a stable extension of ABAP."}, {"heading": "Proof", "text": "The reason for this is that the second part of Lemma 8 is trivially satisfied. Lemma 8 underlines that an attack knot always has a knot and therefore cannot be a leaf knot. Note: infinite branches of attack knot have no leaf knot containing the leaf knot argument. In this case, the second part of Lemma 8 is trivially satisfied. Lemma 8 underlines how an attack knot justifies a leaf knot and therefore cannot be a leaf knot. Note: infinite branches of attack knot have no leaf knot satisfying the leaf knot argument of the second part of Lemma 8 trivially. Lemma 8 underlines how an attack knot justifies an argument A in relation to a stable expansion. If argument A is part of the stable expansion, the attack knot tree indicates that the reason is that A is defended by the stable expansion."}, {"heading": "Proof", "text": "This is directly derived from Definition 5 and Notation 5. This observation will be useful when comparing Attack Trees with abstract dispute trees in the following section. Example 7 shows how an Attack Tree can be used to explain why an Attack Tree is included in an answer or not included in relation to an argument for this dictionary. Example 7Consider Dr. Smith, his patient Peter, and the Decision Support System introduced in Section 2.2. To explain to Dr. Smith why LaserSurgery is not a proposed treatment of the Decision Support System, an Attack Tree for an argument with completion of LaserSurgery can be constructed in relation to the corresponding stable extension of the Sdoctor response set. Figure 4 shows such an Attack Tree expressing that Peter should not have laser surgery, since the decision to use laser surgery is based on the assumption that the patient is not tightly tied to money; there is evidence that Peter is tight to money, as he is known as a student, and there is no evidence that the Attack against his parents is not possible."}, {"heading": "4.3 Relationship between Attack Trees and Abstract Dispute Tress", "text": "To further characterize attack trees, we prove that attack trees constructed with respect to stable extensions are special cases of abstract dispute trees (Dung et al. 2006). With the help of this correspondence, we show that attack trees provide explanations for an argument relating to a permissible fragment of the stable extension. This result is then expanded and proves that an attack tree of an argument with conclusion k in relation to the corresponding stable extension provides justification in relation to a permissible fragment of the response set. We first define a translation of the nodes, the arguments labeled \"+\" and \"\u2212\" in attack trees to the status of supporters and opponents of dispute trees in abstract dispute trees. Definition 6 (Translated Abstract Dispute Tree) Let P be a logical program, X a set of arguments in ABAP, and attTreeX (A) an attack tree relating to ABAP."}, {"heading": "Proof", "text": "This follows directly from the definition of abstract taps and 8th note lem that the inversion of the 10.1 lem does not hold, i.e. it is not the case that each abstract taps tree for an argument A corresponds to an attack tree attTreeE (A). Example 8 shows lem 10 as well as that its inversion does not hold. Example 8 Let P2 be the following logic program: a) not a, not b \u00b2 not a, not c \u00b2 not bSix arguments can in the translated ABA framework ABAP2: A1: (not a \u00b2) \"not a \u00b2\" (not a \u00b2), \"not b \u00b2,\" not b \u00b2, \"not b \u00b2,\" not b \u00b2, \"not b \u00b2,\" not b \u00b2, \"\" not b \u00b2, \"\" not b \u00b2, \"not c \u00b2,\" \"not c \u00b2,\" \"not c \u00b2."}, {"heading": "Proof", "text": "According to Lemma 7, for each A + i in attTree + E (A), Ai \u0433E and for each A \u2212 j in attTree + E (A), Aj / \u0435E. By defining a stable extension, all arguments B in ABAP will be either B, E or B / ECE. Thus, Ai 6 = Aj for all i, j and therefore, according to definition 6, no argument is both a proponent and a counternode in TE (A), which fulfills the prerequisite for admissibility. According to Lemma 10, TE (A) is an abstract dispute contract. Since a positive attack tree corresponds to an admissible abstract dispute tree in relation to a stable extension, the set of all arguments designated in the attack tree with '+' constitutes a permissible extension, in particular one that is a subset of this stable dispute tree.Theorem 4 Let P be a logical program, E a stable extension of ABAP and a positive dispute tree + E (ABAP) in some arguments of A + ECG '."}, {"heading": "Proof", "text": "in attTree + E (A). Then Args is the set of arguments represented by proponent nodes in the translated abstract tree TE (A) of attTree + E (A). According to Lemma 11, TE (A) is a permissible abstract tree of contention. According to Theorem 3.2 (i) in (Dung et al. 2007), Args is a permissible extension, and according to Lemma 7, Args' E. This result characterizes Attack Trees as a way to justify an argument by means of a permissible fragment of the stable extension. In other words, the Attack Tree does not use a complete stable extension to declare that an argument lies in the stable extension, but only a permissible subset sufficient to show that it defends the argument in question."}, {"heading": "Proof", "text": "This year it has come to the point where it has been able to put itself at the top of the group."}, {"heading": "Proof", "text": "In Lemma 9, the subtree of attTree \u2212 E (A) with the root node Ai is a positive attack tree of Ai. In Lemma 11, it is a permissible abstract attack tree. Trivially, the subtree of TE (A) with the root node Ai agrees with the translated abstract attack tree of Ai. Knowing that the argument that proceeds from the root of a negative attack tree in relation to a stable extension is attacked by a permissible abstract attack tree, we show that this attack tree justifies the root by showing that it is attacked by a permissible extension of ABAP, in particular by a permissible extension that is a subset of the stable extension. Theorem 6 Let P be a logical program, E a stable extension of ABAP, and attTree \u2212 E (A) a negative attack tree of any argument A in ABAP."}, {"heading": "Proof", "text": "Let Args designate the set of arguments with the designation \"+\" in attTree \u2212 E (A). Then Args is the set of arguments represented by the proponent nodes in the translated abstract tree TE (A) of attTree \u2212 E (A). According to Lemma 12, the subtree of TE (A) is with root node Ai, where A + i is the only child of root A \u2212 in attTree \u2212 E (A) is a permissible abstract tree of contention. According to Theorem 3.2 (i) in (Dung et al. 2007), Args is a permissible extension. According to Lemma 7, Args E. It follows that a negative attack tree justifies an argument for a literal dispute, the one in question does not relate to an admissible fragment of the answer group \"Attack\" on the literal. \"Theorem 7, Args E."}, {"heading": "Proof", "text": "In fact, the fact is that most of them are able to hold their own, and that they are able to hold their own."}, {"heading": "5 Basic ABA-Based Answer Set Justifications", "text": "In this section, we define the basic concepts for constructing justifications of a literal k in relation to letters and their relationships, based on attack trees of arguments with conclusion k. The idea is to extract the assumptions and factual presuppositions of each argument in the attack tree to express a support relationship between each of the presupposition literal and the letter that forms the conclusion of an argument. In addition, the attacks between arguments in Attack Tree are translated into attack relationships between the letters that form the conclusions of these arguments. We first introduce terminology based on the structure of an attack tree. Notation 6 Let us be an attack tree and let N be a node in the annotation. arg (N) denotes the argument of the node n. If arg (N) A is: (AP, FP) \"k, then the name (N) = A, conk = (k), AP = (F), (N) is the label of either (P) or (P)."}, {"heading": "5.1 Basic Justifications", "text": "In fact, it is not that one sees oneself in a position to attach oneself to one's nose, but that one sees oneself in a position to attach oneself to one's nose. (...) It is not that one is able to attach oneself to one's nose. (...) It is not that one is able to attach oneself to one's nose. (...) It is that one is able to attach oneself to one's nose. (...) It is not that one can attach oneself to one's nose. (...) It is that one must attach oneself to one's nose. \"(...)"}, {"heading": "5.2 BABAS Justifications", "text": "We define the Basic ABA-based Answer Set (BABAS). (BABAS) Justification is only justified if its BABAS justification is constructed in relation to one of the underlying arguments of BABAS. (BABAS) Justification is only constructed in relation to one of the underlying arguments of BABAS. (BABAS) Justification is only constructed in relation to one of the underlying arguments of BABAS. (BABAS) Justification is only constructed in relation to one of the underlying arguments of BABAS. (BABAS) Justification is not constructed in relation to one of the underlying justifications of BABAS justification. (BABAS) Justification is not constructed in relation to one of the underlying justifications of BABAS justification. (BABAS) Justification is not constructed in relation to one of the underlying arguments of BABAS justification."}, {"heading": "5.3 Shortcomings of BABAS Justifications", "text": "A BABAS justification is a flat structure that loses some information compared to the underlying attack trees. Attack trees label argument in relation to a stable extension that expresses whether an argument is part of the stable extension or not. However, a BABAS justification does not provide information about whether arguments are included in the response or not. These additional arguments are not captured by BABAS, even if they are not captured by the underlying attack trees.Example 14 Consider the negative BABAS justification justB \u2212 S2 (a) from Example 12, presented as a graph in Figure 10. justB \u2212 S2 (a) does not express whether the \"attacking\" literal justification is part of S2, neither in the notation nor in the comparison presented."}, {"heading": "6 Labelled ABA-Based Answer Set Justifications", "text": "In contrast to Basic Justifications, Labelled ABA-Based Answer Set (LABAS) highlight Justifications (described ABA-based justifications) that address the shortcomings of BABAS justifications by marking the relationships and literals in the justification as either \"+\" or \"\u2212,\" depending on the names of the arguments in the underlying attack trees. In addition, literals may have an ace or fact tag indicating that they are used as assumptions or facts. Non-assumption and Non-fact Literals are marked with the name of their argument to distinguish between different arguments with the same conclusion that occur in an Attack Tree. We refer to the structure of nodes in an Attack Tree, as introduced in Note 6. Similar to BABAS Justifications, LABAS justifications are defined in terms of Labelled Justifications that are a flat version of Attack Trees. As opposed to a Literal, Basic Justifications are only characterized by a justification extracted from an attack tree."}, {"heading": "6.1 Labelled Justifications", "text": "(D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n n (D) n n n (D) n n (D) n n (D) n n) n (D) n n (D) n n n (D) n n n (D) n n (D) n n n (D) n n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n (D) n n (D) n (D) n n (D) n n (D) n n n (D) n n n (D) n n n n (D) n n n n n (D) n (D) n n n n (D) n (D) n (D) n (D) n n (D) n) n) n n (D) n) n (D) n (D) n) n n (D) n n (D) n (D) n (D) n) n n (D) n (D) n) n (D) n) n (D) n n n n (D) n (D) n) n n n (D) n) n) n (D n (D) n n (D) n n n (D) n (D) n) n n n n (D) n n n (D) n (D) n) n n n n (D) n) n n (D) n n n (D) n n n n (D) n (D) n (D) n (D) n n n n) n) n) n (D) n) n n) n (D) n n (D) n) n (D) n n) n) n) n (D) n n) n (D) n n) n) n"}, {"heading": "6.2 LABAS Justifications", "text": "In this section, we define the Labeled ABA-based answer Set (LABAS) = q = q = q = q in relation to an answer set based on the labeled reasoning of an argument for that sense of the word \u2212 \u2212 p \u2212 p \u2212 p \u2212 p (A) in relation to an answer set whose LABAS justification is constructed by one of the corresponding arguments of k. Vice versa, if there is no answer, its LABAS justification is constructed by all arguments with conclusion. The only difference in construction is that the literal justification is justified before justification. Definition 10 (Labeled ABA-based answer Set Justification) Let P is a logical program and S is a response to P. Let the labeling of labeled before it is added to justification."}, {"heading": "Proof", "text": "According to definitions 9 and 10 and notation 7, NAF + is the union of all assumptions supporting arguments labeled \"+\" in the attack tree attTree + E (A) used to construct justL + S (k1), where E is the corresponding stable extension of S and E is a corresponding argument of k1. NAF + = Asms as in Theorem 7. This result expresses that LABAS justifications declare that a letter is contained in a response set, because that letter is supported and defended by the response set. LABAS justifications, however, do not simply provide the entire set of responses as an explanation, but instead use a permissible fragment of it. A similar result can be formulated for negative LABAS justifications: Theorem 9Let P be a Logical Programme and let justL \u2212 S (k1) be a Negative LABAS Justification of a kasm."}, {"heading": "Proof", "text": "Analogous to the proof of theorem 8. This means that the LABAS justification of a word that is not part of a response set explains all the ways in which this dictionary is \"attacked\" by a permissible fragment of the response set. In summary, LABAS justifications use the same information for an explanation as attack trees, namely a permissible fragment of a response set, but express this information in the form of words and the support and \"attack relationships\" between them, and not in the form of arguments and attacks. Therefore, LABAS justifications are more appropriate explanations when logical programming concepts are desired.In the following, we will use the term ABAS justification as an abbreviation for both BABAS and LABAS justifications."}, {"heading": "7 Discussion and Related Work", "text": "So far, not much attention has been paid to the problem of justifying response sentences, although the need for justifications has been expressed (Brain and De Vos 2008). According to (Pontelli et al. 2009), a justification should \"only provide the information relevant to the subject to be explained,\" making it easier to understand. We insert this into ABAS justifications by not using the entire derivative of a dictionary, but only the underlying facts and NAF justifications necessary to question the dictionary. The two approaches to justifying why a dictionary is part of a response book or not part of a response book that has most to do with ABAS justifications are argument-based answer set justifications and off-line justifications (Schulz et al. 2013) are a \"precursor\" of ABAS justifications using the argumentation framework ASPIC + (Prakelli 2010) rather than an off-line justification (PontBA 2009)."}, {"heading": "7.1 Off-line Justifications", "text": "In other words, the justified letters l have the relevant letters of an applicable clause in the logic program as their child nodes, and the justifications of these body letters as subgraphs. Example 19: Consider the following logic program, which consists (Pontelli et al. 2009), which has two answers to S1, and S2 = {a, f}, and the justifications of these body letters as subgraphics-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter."}, {"heading": "7.2 Argumentation-Based Answer Set Justification", "text": "In this context, it is important to emphasize that the ASPIC + reasoning framework (Practices 2010) is used instead of ABA. Similar to ABAS Justifications, Argumentation-Based Answer Set Justifications Literale justifies a response set using ASPIC + reasoning frameworks. To translate a logic program into an ASPIC + framework, only a fraction of the ASPIC + features are required. Deficit rules, problems and preference orders are redundant, meaning that the ASPIC + framework is too complex for the purpose of justification and a lighter framework such as ABA + features. The method of constructing justification in Argumentation-Based Answer Set Justification is somewhat different from the justification framework. Instead of ABAS - justification and justification frameworks, assumptions are not appropriate."}, {"heading": "7.3 Other related explanation approaches", "text": "In addition to the two explanatory approaches discussed in the previous sections (Erdem and Oztok 2013), all steps are considered an interpretation to explain biomedical questions expressed in ASP. Similar to ABAS justifications, they construct trees for the explanation, but unlike our justifications, these trees carry rules in the nodes rather than letters. Another difference is that their explanatory trees include every step in the derivation of a literal argument (similar to the approach of (Pontelli et al. 2009) and do not abstract away from intermediate derivative steps between the letter in question and the underlying facts and NAF letters. (Brain and Vos 2005) they try to answer a similar question as we answer them with ABAS justifications, i.e. why a set of words is not or is not a subset of an answer. Their explanations are presented in text form, but they indicate that it may be possible to use a tree representation."}, {"heading": "8 Conclusion and Future Work", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before in the history of the city."}, {"heading": "Acknowledgements", "text": "We would like to thank the anonymous reviewers and David Pearce for their constructive feedback, as well as Abdallah Arioua for pointing out some related work."}], "references": [{"title": "Explaining program execution in deductive systems", "author": ["T. Arora", "R. Ramakrishnan", "W. Roth", "P. Seshadri", "D. Srivastava"], "venue": "Deductive and Object-Oriented Databases, S. Ceri, K. Tanaka, and S. Tsur, Eds. Lecture Notes in Computer Science, vol. 760. Springer Berlin Heidelberg, 101\u2013119.", "citeRegEx": "Arora et al\\.,? 1993", "shortCiteRegEx": "Arora et al\\.", "year": 1993}, {"title": "A knowledge based approach for representing and reasoning about signaling networks", "author": ["C. Baral", "K. Chancellor", "N. Tran", "N. Tran", "A.M. Joy", "M.E. Berens"], "venue": "ISMB/ECCB (Supplement of Bioinformatics). 15\u201322.", "citeRegEx": "Baral et al\\.,? 2004", "shortCiteRegEx": "Baral et al\\.", "year": 2004}, {"title": "Argument-based explanation of logic programs", "author": ["T. Bench-Capon", "D. Lowes", "A. McEnery"], "venue": "Knowledge-Based Systems 4, 3, 177 \u2013 183.", "citeRegEx": "Bench.Capon et al\\.,? 1991", "shortCiteRegEx": "Bench.Capon et al\\.", "year": 1991}, {"title": "Automatic music composition using answer set programming", "author": ["G. Boenn", "M. Brain", "M.D. Vos", "J. Fitch"], "venue": "Theory and Practice of Logic Programming 11, 2-3, 397\u2013427.", "citeRegEx": "Boenn et al\\.,? 2011", "shortCiteRegEx": "Boenn et al\\.", "year": 2011}, {"title": "An abstract, argumentation-theoretic approach to default reasoning", "author": ["A. Bondarenko", "P. Dung", "R. Kowalski", "F. Toni"], "venue": "Artificial Intelligence 93, 1-2, 63 \u2013 101.", "citeRegEx": "Bondarenko et al\\.,? 1997", "shortCiteRegEx": "Bondarenko et al\\.", "year": 1997}, {"title": "Answer set programming - a domain in need of explanation: A position paper", "author": ["M. Brain", "M. De Vos"], "venue": "Explanation-aware Computing, Papers from the 2008 ECAI Workshop. ExaCt. 37\u201348.", "citeRegEx": "Brain and Vos,? 2008", "shortCiteRegEx": "Brain and Vos", "year": 2008}, {"title": "Debugging logic programs under the answer set semantics", "author": ["M. Brain", "M.D. Vos"], "venue": "Proceedings of the 3rd International Workshop on Answer Set Programming (ASP\u201905). CEUR Workshop Proceedings (2005).", "citeRegEx": "Brain and Vos,? 2005", "shortCiteRegEx": "Brain and Vos", "year": 2005}, {"title": "Computing ideal sceptical argumentation", "author": ["P. Dung", "P. Mancarella", "F. Toni"], "venue": "Artificial Intelligence 171, 10-15, 642 \u2013 674.", "citeRegEx": "Dung et al\\.,? 2007", "shortCiteRegEx": "Dung et al\\.", "year": 2007}, {"title": "An argumentation-theoretic foundation for logic programming", "author": ["P.M. Dung"], "venue": "The Journal of Logic Programming 22, 2, 151 \u2013 177.", "citeRegEx": "Dung,? 1995a", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence 77, 2, 321\u2013357.", "citeRegEx": "Dung,? 1995b", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "Dialectic proof procedures for assumption-based, admissible argumentation", "author": ["P.M. Dung", "R.A. Kowalski", "F. Toni"], "venue": "Artificial Intelligence 170, 2, 114\u2013159.", "citeRegEx": "Dung et al\\.,? 2006", "shortCiteRegEx": "Dung et al\\.", "year": 2006}, {"title": "Assumption-based argumentation", "author": ["P.M. Dung", "R.A. Kowalski", "F. Toni"], "venue": "Argumentation in Artificial Intelligence, G. Simari and I. Rahwan, Eds. Springer US, 199\u2013218.", "citeRegEx": "Dung et al\\.,? 2009", "shortCiteRegEx": "Dung et al\\.", "year": 2009}, {"title": "Well-founded reasoning with classical negation", "author": ["P.M. Dung", "P. Ruamviboonsuk"], "venue": "LPNMR. 120\u2013132.", "citeRegEx": "Dung and Ruamviboonsuk,? 1991", "shortCiteRegEx": "Dung and Ruamviboonsuk", "year": 1991}, {"title": "A deductive system for non-monotonic reasoning", "author": ["T. Eiter", "N. Leone", "C. Mateis", "G. Pfeifer", "F. Scarcello"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning. LPNMR\u201997. 364\u2013375.", "citeRegEx": "Eiter et al\\.,? 1997", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "Generating explanations for biomedical queries", "author": ["E. Erdem", "U. Oztok"], "venue": "Theory and Practice of Logic Programming FirstView, 1\u201344.", "citeRegEx": "Erdem and Oztok,? 2013", "shortCiteRegEx": "Erdem and Oztok", "year": 2013}, {"title": "Abduction compared with negation by failure", "author": ["K. Eshghi", "R.A. Kowalski"], "venue": "ICLP. 234\u2013254.", "citeRegEx": "Eshghi and Kowalski,? 1989", "shortCiteRegEx": "Eshghi and Kowalski", "year": 1989}, {"title": "Aspide: Integrated development environment for answer set programming", "author": ["O. Febbraro", "K. Reale", "F. Ricca"], "venue": "Logic Programming and Nonmonotonic Reasoning, J. P. Delgrande and W. Faber, Eds. Lecture Notes in Computer Science, vol. 6645. Springer Berlin Heidelberg, 317\u2013330.", "citeRegEx": "Febbraro et al\\.,? 2011", "shortCiteRegEx": "Febbraro et al\\.", "year": 2011}, {"title": "Explanations and proof trees", "author": ["G. Ferrand", "W. Lesaint", "A. Tessier"], "venue": "Computing and Informatics 25, 2-3.", "citeRegEx": "Ferrand et al\\.,? 2012", "shortCiteRegEx": "Ferrand et al\\.", "year": 2012}, {"title": "Formalizing dialectical explanation support for argument-based reasoning in knowledge-based systems", "author": ["A.J. Gar\u0107\u0131a", "C.I.C. nevar", "N.D. Rotstein", "G.R. Simari"], "venue": "Expert Systems with Applications 40,", "citeRegEx": "Gar\u0107\u0131a et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Gar\u0107\u0131a et al\\.", "year": 2013}, {"title": "Defeasible logic programming: An argumentative approach", "author": ["A.J. Gar\u0107\u0131a", "G.R. Simari"], "venue": "Theory and Practice of Logic Programming 4, 2, 95\u2013138.", "citeRegEx": "Gar\u0107\u0131a and Simari,? 2004", "shortCiteRegEx": "Gar\u0107\u0131a and Simari", "year": 2004}, {"title": "Potassco: The Potsdam answer set solving collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": "AI Communications 24, 2, 105\u2013124.", "citeRegEx": "Gebser et al\\.,? 2011", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "Answer Sets", "author": ["M. Gelfond"], "venue": "Elsevier, Chapter 7.", "citeRegEx": "Gelfond,? 2008", "shortCiteRegEx": "Gelfond", "year": 2008}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Argumentation semantics for defeasible logic", "author": ["G. Governatori", "M.J. Maher", "G. Antoniou", "D. Billington"], "venue": "Journal of Logic and Computation 14, 675\u2013702.", "citeRegEx": "Governatori et al\\.,? 2004", "shortCiteRegEx": "Governatori et al\\.", "year": 2004}, {"title": "A review of explanation methods for heuristic expert systems", "author": ["C. Lacave", "F.J. Diez"], "venue": "Knowledge Engineering Review 19, 2 (June), 133\u2013146.", "citeRegEx": "Lacave and Diez,? 2004", "shortCiteRegEx": "Lacave and Diez", "year": 2004}, {"title": "Explanation and argumentation capabilities: Towards the creation of more persuasive agents", "author": ["B. Moulin", "H. Irandoust", "M. Blanger", "G. Desbordes"], "venue": "Artificial Intelligence Review 17, 3, 169\u2013222.", "citeRegEx": "Moulin et al\\.,? 2002", "shortCiteRegEx": "Moulin et al\\.", "year": 2002}, {"title": "Smodels: A system for answer set programming", "author": ["I. Niemel\u00e4", "P. Simons", "T. Syrj\u00e4nen"], "venue": "CoRR cs.AI/0003033.", "citeRegEx": "Niemel\u00e4 et al\\.,? 2000", "shortCiteRegEx": "Niemel\u00e4 et al\\.", "year": 2000}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. Pontelli", "T.C. Son", "O. Elkhatib"], "venue": "Theory and Practice of Logic Programming 9, 1, 1\u201356.", "citeRegEx": "Pontelli et al\\.,? 2009", "shortCiteRegEx": "Pontelli et al\\.", "year": 2009}, {"title": "An abstract framework for argumentation with structured arguments", "author": ["H. Prakken"], "venue": "Argument and Computation 1, 2, 93\u2013124.", "citeRegEx": "Prakken,? 2010", "shortCiteRegEx": "Prakken", "year": 2010}, {"title": "Proleg: An implementation of the presupposed ultimate fact theory of japanese civil code by prolog technology", "author": ["K. Satoh", "K. Asai", "T. Kogawa", "M. Kubota", "M. Nakamura", "Y. Nishigai", "K. Shirakawa", "C. Takano"], "venue": "JSAI-isAI Workshops. 153\u2013164.", "citeRegEx": "Satoh et al\\.,? 2010", "shortCiteRegEx": "Satoh et al\\.", "year": 2010}, {"title": "Argumentation-based answer set justification", "author": ["C. Schulz", "M. Sergot", "F. Toni"], "venue": "Working notes of the 11th International Symposium on Logical Formalizations of Commonsense Reasoning. Commonsense\u201913.", "citeRegEx": "Schulz et al\\.,? 2013", "shortCiteRegEx": "Schulz et al\\.", "year": 2013}, {"title": "Logic programming for multiagent planning with negotiation", "author": ["T.C. Son", "E. Pontelli", "C. Sakama"], "venue": "Proceedings of the 25th International Conference on Logic Programming. Springer-Verlag, 99\u2013114.", "citeRegEx": "Son et al\\.,? 2009", "shortCiteRegEx": "Son et al\\.", "year": 2009}, {"title": "On the relationship of defeasible argumentation and answer set programming", "author": ["M. Thimm", "G. Kern-Isberner"], "venue": "Computational Models of Argument: Proceedings of COMMA 2008, Toulouse, France, May 28-30, 2008. 393\u2013404.", "citeRegEx": "Thimm and Kern.Isberner,? 2008", "shortCiteRegEx": "Thimm and Kern.Isberner", "year": 2008}, {"title": "Argumentation and answer set programming", "author": ["F. Toni", "M. Sergot"], "venue": "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, M. Balduccini and T. Son, Eds. Lecture Notes in Computer Science, vol. 6565. Springer Berlin Heidelberg, 164\u2013180.", "citeRegEx": "Toni and Sergot,? 2011", "shortCiteRegEx": "Toni and Sergot", "year": 2011}], "referenceMentions": [{"referenceID": 21, "context": "Answer Set Programming (ASP) is one of the most widely used non-monotonic reasoning paradigms, allowing to efficiently compute solutions to problems involving defaults and exceptions (Gelfond 2008).", "startOffset": 183, "endOffset": 197}, {"referenceID": 22, "context": "The solutions to the problem are then given by the declarative answer set semantics (Gelfond and Lifschitz 1991) for the logic program.", "startOffset": 84, "endOffset": 112}, {"referenceID": 1, "context": "ASP is applied in a variety of different areas, ranging from bioinformatics (Baral et al. 2004) over music composition (Boenn et al.", "startOffset": 76, "endOffset": 95}, {"referenceID": 3, "context": "2004) over music composition (Boenn et al. 2011) to multi-agent systems (Son et al.", "startOffset": 29, "endOffset": 48}, {"referenceID": 31, "context": "2011) to multi-agent systems (Son et al. 2009).", "startOffset": 29, "endOffset": 46}, {"referenceID": 20, "context": "Answer set solvers like clingo (Gebser et al. 2011), smodels (Niemel\u00e4 et al.", "startOffset": 31, "endOffset": 51}, {"referenceID": 26, "context": "2011), smodels (Niemel\u00e4 et al. 2000), and DLV (Eiter et al.", "startOffset": 15, "endOffset": 36}, {"referenceID": 13, "context": "2000), and DLV (Eiter et al. 1997) provide efficient tools for the computation of answer sets.", "startOffset": 15, "endOffset": 34}, {"referenceID": 4, "context": "Here, we use Assumption-Based Argumentation (ABA) (Bondarenko et al. 1997; Dung et al. 2009), a structured argumentation framework which constructs arguments from rules and assumptions, and attacks from the notion of contrary of assumptions.", "startOffset": 50, "endOffset": 92}, {"referenceID": 11, "context": "Here, we use Assumption-Based Argumentation (ABA) (Bondarenko et al. 1997; Dung et al. 2009), a structured argumentation framework which constructs arguments from rules and assumptions, and attacks from the notion of contrary of assumptions.", "startOffset": 50, "endOffset": 92}, {"referenceID": 4, "context": "ABA is particularly suitable for our purpose as it was inspired by logic programming, default logic and other non-monotonic reasoning approaches (Bondarenko et al. 1997) which are closely related to ASP.", "startOffset": 145, "endOffset": 169}, {"referenceID": 4, "context": "One of the semantics for ABA frameworks is the stable extension semantics (Bondarenko et al. 1997; Dung 1995b), which has its roots in the stable model semantics for logic programs.", "startOffset": 74, "endOffset": 110}, {"referenceID": 9, "context": "One of the semantics for ABA frameworks is the stable extension semantics (Bondarenko et al. 1997; Dung 1995b), which has its roots in the stable model semantics for logic programs.", "startOffset": 74, "endOffset": 110}, {"referenceID": 24, "context": "On the one hand, they contribute to the field of answer set justification research, which has been identified as an important but not yet sufficiently studied research area (Lacave and Diez 2004; Brain and De Vos 2008).", "startOffset": 173, "endOffset": 218}, {"referenceID": 0, "context": "The reason to use ABA for explanations instead of constructing justifications from the logic program straight away in terms of simple derivations or proof trees (Arora et al. 1993; Ferrand et al. 2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al.", "startOffset": 161, "endOffset": 201}, {"referenceID": 17, "context": "The reason to use ABA for explanations instead of constructing justifications from the logic program straight away in terms of simple derivations or proof trees (Arora et al. 1993; Ferrand et al. 2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al.", "startOffset": 161, "endOffset": 201}, {"referenceID": 2, "context": "2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al. 1991; Moulin et al. 2002).", "startOffset": 213, "endOffset": 258}, {"referenceID": 25, "context": "2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al. 1991; Moulin et al. 2002).", "startOffset": 213, "endOffset": 258}, {"referenceID": 33, "context": "Even though ASP has been applied to argumentation theory in the sense that an argumentation framework can be equivalently expressed in ASP (Toni and Sergot 2011; Thimm and Kern-Isberner 2008), the converse has not been discussed in the literature.", "startOffset": 139, "endOffset": 191}, {"referenceID": 32, "context": "Even though ASP has been applied to argumentation theory in the sense that an argumentation framework can be equivalently expressed in ASP (Toni and Sergot 2011; Thimm and Kern-Isberner 2008), the converse has not been discussed in the literature.", "startOffset": 139, "endOffset": 191}, {"referenceID": 2, "context": "\u2022 early work on manually constructing arguments and attacks from a logic program according to Toulmin\u2019s argument scheme, which then serves as an explanation of the logic program (Bench-Capon et al. 1991); and \u2022 Argumentation-Based Answer Set Justification (Schulz et al.", "startOffset": 178, "endOffset": 203}, {"referenceID": 30, "context": "1991); and \u2022 Argumentation-Based Answer Set Justification (Schulz et al. 2013) which can be considered as a predecessor of ABAS Justifications.", "startOffset": 58, "endOffset": 78}, {"referenceID": 28, "context": "Similarly to ABAS Justifications, Argumentation-Based Answer Set Justifications are constructed from arguments and attacks between them, but using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.", "startOffset": 182, "endOffset": 196}, {"referenceID": 10, "context": "In Section 4 we introduce Attack Trees drawn from a translated ABA framework as a first justification method, show their relationship with abstract dispute trees for ABA (Dung et al. 2006), and characterize the explanation they provide as an admissible fragment of the answer set in question.", "startOffset": 170, "endOffset": 188}, {"referenceID": 22, "context": "In the following, we recall the concept of answer sets as introduced in (Gelfond and Lifschitz 1991).", "startOffset": 72, "endOffset": 100}, {"referenceID": 15, "context": "When used on such P \u222a \u2206S , `MP treats NAF literals purely syntactically as in (Eshghi and Kowalski 1989) and treats facts l\u2190 as l\u2190 true where P \u222a \u2206S `MP true for any logic program P and any set of NAF literals \u2206S .", "startOffset": 78, "endOffset": 104}, {"referenceID": 9, "context": "Abstract Argumentation (Dung 1995b) assumes that a set of abstract entities (the arguments) are given along with an attack relation between them.", "startOffset": 23, "endOffset": 35}, {"referenceID": 28, "context": "In contrast, structured argumentation frameworks such as (Prakken 2010; Gar\u0107\u0131a and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.", "startOffset": 57, "endOffset": 120}, {"referenceID": 19, "context": "In contrast, structured argumentation frameworks such as (Prakken 2010; Gar\u0107\u0131a and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.", "startOffset": 57, "endOffset": 120}, {"referenceID": 23, "context": "In contrast, structured argumentation frameworks such as (Prakken 2010; Gar\u0107\u0131a and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.", "startOffset": 57, "endOffset": 120}, {"referenceID": 4, "context": "framework of (Bondarenko et al. 1997; Dung et al. 2009) called Assumption-Based Argumentation (ABA).", "startOffset": 13, "endOffset": 55}, {"referenceID": 11, "context": "framework of (Bondarenko et al. 1997; Dung et al. 2009) called Assumption-Based Argumentation (ABA).", "startOffset": 13, "endOffset": 55}, {"referenceID": 11, "context": "An ABA framework (Dung et al. 2009) is a tuple \u3008L,R,A,  \u0304\u3009, where", "startOffset": 17, "endOffset": 35}, {"referenceID": 11, "context": "Definition 2 generates the notion of argument in (Dung et al. 2009): If (AP,FP ) ` \u03b1 is an argument according to Definition 2, then AP ` \u03b1 is an argument in (Dung et al.", "startOffset": 49, "endOffset": 67}, {"referenceID": 11, "context": "2009): If (AP,FP ) ` \u03b1 is an argument according to Definition 2, then AP ` \u03b1 is an argument in (Dung et al. 2009).", "startOffset": 95, "endOffset": 113}, {"referenceID": 11, "context": "Conversely, if AP ` \u03b1 is an argument in (Dung et al. 2009), then there exists some FP \u2286 {\u03b2 | \u03b2 \u2190 \u2208 R} such that (AP,FP ) ` \u03b1 is an argument according to Definition 2.", "startOffset": 40, "endOffset": 58}, {"referenceID": 11, "context": "The attack relation between arguments defined here is a slight variation of the notion in (Dung et al. 2009), as it considers arguments with both assumption- and fact-premises.", "startOffset": 90, "endOffset": 108}, {"referenceID": 11, "context": "Since arguments as introduced here and in (Dung et al. 2009) correspond, the attack relation in Definition 3 directly correspond to attacks in (Dung et al.", "startOffset": 42, "endOffset": 60}, {"referenceID": 11, "context": "2009) correspond, the attack relation in Definition 3 directly correspond to attacks in (Dung et al. 2009): If an argument (AP1, FP1) ` \u03b11 attacks an argument (AP2, FP2) ` \u03b12 according to Definition 3, then AP1 ` \u03b11 attacks AP2 ` \u03b12 as defined in (Dung et al.", "startOffset": 88, "endOffset": 106}, {"referenceID": 11, "context": "2009): If an argument (AP1, FP1) ` \u03b11 attacks an argument (AP2, FP2) ` \u03b12 according to Definition 3, then AP1 ` \u03b11 attacks AP2 ` \u03b12 as defined in (Dung et al. 2009).", "startOffset": 146, "endOffset": 164}, {"referenceID": 11, "context": "Conversely, if AP1 ` \u03b11 attacks AP2 ` \u03b12 as defined in (Dung et al. 2009), then there exist FP1, FP2 \u2286 {\u03b2 | \u03b2 \u2190 \u2208 R} such that (AP1, FP1) ` \u03b11 attacks (AP2, FP2) ` \u03b12 according to Definition 3.", "startOffset": 55, "endOffset": 73}, {"referenceID": 9, "context": "For our purposes we focus on the admissible and on the stable extension semantics introduced in (Dung 1995b) for Abstract Argumentation and in (Bondarenko et al.", "startOffset": 96, "endOffset": 108}, {"referenceID": 4, "context": "For our purposes we focus on the admissible and on the stable extension semantics introduced in (Dung 1995b) for Abstract Argumentation and in (Bondarenko et al. 1997) for ABA.", "startOffset": 143, "endOffset": 167}, {"referenceID": 10, "context": "An abstract dispute tree (Dung et al. 2006) for an ABA argument A is a (possibly infinite) tree such that:", "startOffset": 25, "endOffset": 43}, {"referenceID": 11, "context": "An abstract dispute tree is admissible (Dung et al. 2009) if and only if no argument labels both a proponent and an opponent node.", "startOffset": 39, "endOffset": 57}, {"referenceID": 7, "context": "It has been shown that the set of all arguments labelling proponent nodes in an admissible dispute tree is an admissible extension (Dung et al. 2007).", "startOffset": 131, "endOffset": 149}, {"referenceID": 4, "context": "10 in (Bondarenko et al. 1997): By the definition of stable extension, X is a stable extension if and only if X = {A in \u3008L,R,A,  \u0304\u3009 | X does not attack A}.", "startOffset": 6, "endOffset": 30}, {"referenceID": 4, "context": "We use the approach of (Bondarenko et al. 1997) for translating a logic program into an ABA framework, where the clauses of a logic program form the set of ABA rules and NAF literals are used as assumptions in ABA.", "startOffset": 23, "endOffset": 47}, {"referenceID": 4, "context": "Note that part of this correspondence has been stated without a formal proof in (Bondarenko et al. 1997).", "startOffset": 80, "endOffset": 104}, {"referenceID": 10, "context": "In order to further characterize Attack Trees, we prove that Attack Trees constructed with respect to stable extensions are special cases of abstract dispute trees (Dung et al. 2006).", "startOffset": 164, "endOffset": 182}, {"referenceID": 7, "context": "2(i) in (Dung et al. 2007), Args is an admissible extension, and by Lemma 7, Args \u2286 E .", "startOffset": 8, "endOffset": 26}, {"referenceID": 12, "context": "P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991);", "startOffset": 56, "endOffset": 85}, {"referenceID": 7, "context": "2(ii) in (Dung et al. 2007), Asms is an admissible set of assumptions.", "startOffset": 9, "endOffset": 27}, {"referenceID": 4, "context": "5 in (Bondarenko et al. 1997), P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).", "startOffset": 5, "endOffset": 29}, {"referenceID": 12, "context": "1997), P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).", "startOffset": 63, "endOffset": 92}, {"referenceID": 8, "context": "5 refers to (Dung 1995a) where admissible scenarios are defined for logic programs without classical negation.", "startOffset": 12, "endOffset": 24}, {"referenceID": 7, "context": "2(i) in (Dung et al. 2007), Args is an admissible extension.", "startOffset": 8, "endOffset": 26}, {"referenceID": 12, "context": "P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); 2.", "startOffset": 56, "endOffset": 85}, {"referenceID": 7, "context": "2(ii) in (Dung et al. 2007), Asms is an admissible set of assumptions.", "startOffset": 9, "endOffset": 27}, {"referenceID": 4, "context": "5 in (Bondarenko et al. 1997), P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).", "startOffset": 5, "endOffset": 29}, {"referenceID": 12, "context": "1997), P \u222a Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).", "startOffset": 63, "endOffset": 92}, {"referenceID": 12, "context": "Then \u2022 P \u222a NAF is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); \u2022 NAF \u2286 SNAF .", "startOffset": 62, "endOffset": 91}, {"referenceID": 12, "context": "\u2022 P \u222a NAF ij is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); \u2022 NAF ij \u2286 SNAF .", "startOffset": 60, "endOffset": 89}, {"referenceID": 27, "context": "According to (Pontelli et al. 2009), a justification should \u201cprovide only the information that are relevant to the item being explained\u201d, making it easier understandable.", "startOffset": 13, "endOffset": 35}, {"referenceID": 30, "context": "Argumentation-Based Answer Set Justifications (Schulz et al. 2013) are a \u201cpredecessor\u201d of ABAS Justifications using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.", "startOffset": 46, "endOffset": 66}, {"referenceID": 28, "context": "2013) are a \u201cpredecessor\u201d of ABAS Justifications using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.", "startOffset": 90, "endOffset": 104}, {"referenceID": 27, "context": "Off-line justifications (Pontelli et al. 2009) explain why a literal is or is not part of an answer set by making use of the well-founded model semantics for logic programs.", "startOffset": 24, "endOffset": 46}, {"referenceID": 27, "context": "Example 19 Consider the following logic program Pabc (taken from (Pontelli et al. 2009)), which has two answer sets S1 = {b, e, f} and S2 = {a, e, f}: a\u2190 f, not b b\u2190 e, not a f \u2190 e d\u2190 c, e c\u2190 d, f e\u2190", "startOffset": 65, "endOffset": 87}, {"referenceID": 30, "context": "Argumentation-Based Answer Set Justification (Schulz et al. 2013) is the first work that applies argumentation theory to answer set programming, and in particular for the justification of answer sets.", "startOffset": 45, "endOffset": 65}, {"referenceID": 28, "context": "There, the ASPIC+ argumentation framework (Prakken 2010) is used instead of ABA.", "startOffset": 42, "endOffset": 56}, {"referenceID": 14, "context": "In addition to the two explanations approaches for answer sets discussed in the previous sections, (Erdem and Oztok 2013) introduce a formalism for explaining biomedical queries expressed in ASP.", "startOffset": 99, "endOffset": 121}, {"referenceID": 27, "context": "comprise every step in the derivation of a literal (similar to the approach of (Pontelli et al. 2009) explained in Section 7.", "startOffset": 79, "endOffset": 101}, {"referenceID": 6, "context": "(Brain and Vos 2005) try to answer a similar question as the one we address with ABAS Justifications, i.", "startOffset": 0, "endOffset": 20}, {"referenceID": 14, "context": "Just like (Erdem and Oztok 2013), all intermediate steps in a derivation are considered in the explanation, thus differing from ABAS Justifications.", "startOffset": 10, "endOffset": 32}, {"referenceID": 16, "context": "ASPIDE (Febbraro et al. 2011) is an Integrated Development Environment for ASP which, among other features, displays the dependency graph of a logic program, i.", "startOffset": 7, "endOffset": 29}, {"referenceID": 0, "context": "The problem of constructing explanations has been addressed for logic programs without NAF in (Arora et al. 1993) and (Ferrand et al.", "startOffset": 94, "endOffset": 113}, {"referenceID": 17, "context": "1993) and (Ferrand et al. 2012).", "startOffset": 10, "endOffset": 31}, {"referenceID": 14, "context": "Thus, this approach is closer to (Erdem and Oztok 2013) and (Brain and Vos 2005) than to ABAS Justifications as it provides all intermediate derivation steps.", "startOffset": 33, "endOffset": 55}, {"referenceID": 6, "context": "Thus, this approach is closer to (Erdem and Oztok 2013) and (Brain and Vos 2005) than to ABAS Justifications as it provides all intermediate derivation steps.", "startOffset": 60, "endOffset": 80}, {"referenceID": 17, "context": "Similar to this, (Ferrand et al. 2012) show how to use proof trees as explanations for least fixpoint operators, such as the semantics of constraint logic programs, where proof trees are derivations.", "startOffset": 17, "endOffset": 38}, {"referenceID": 24, "context": "Explanations have also received attention in other areas in the field of knowledge representation and reasoning, and it has been emphasized that any expert system should provide explanations for its solutions (see (Lacave and Diez 2004) for an overview of explanations in heuristic expert systems).", "startOffset": 214, "endOffset": 236}, {"referenceID": 25, "context": "Furthermore, it has been pointed out that even though argumentation and other knowledge-based systems have been studied mostly separately in the past, argumentation could serve as a useful tool for the explanation of other knowledge-based systems (Moulin et al. 2002).", "startOffset": 247, "endOffset": 267}, {"referenceID": 2, "context": "In fact, (Bench-Capon et al. 1991) provide an early account of explanations for logic programs in terms of arguments, where Toulmin\u2019s argument scheme is applied.", "startOffset": 9, "endOffset": 34}, {"referenceID": 18, "context": "Related to argumentation as an explanation method, (Gar\u0107\u0131a et al. 2013) introduce explanations in argumentative terms for argumentation-based reasoning methods, such as Defeasible Logic Programming (Gar\u0107\u0131a and Simari 2004), explaining why an argument with a certain conclusion is or is not deemed to be \u201cwinning\u201d.", "startOffset": 51, "endOffset": 71}, {"referenceID": 19, "context": "2013) introduce explanations in argumentative terms for argumentation-based reasoning methods, such as Defeasible Logic Programming (Gar\u0107\u0131a and Simari 2004), explaining why an argument with a certain conclusion is or is not deemed to be \u201cwinning\u201d.", "startOffset": 132, "endOffset": 156}, {"referenceID": 29, "context": "A potential legal rule base for the application of ABAS Justifications is the encoding of the Japanese Civil Code as used in (Satoh et al. 2010).", "startOffset": 125, "endOffset": 144}], "year": 2014, "abstractText": "An answer set is a plain set of literals which has no further structure that would explain why certain literals are part of it and why others are not. We show how argumentation theory can help to explain why a literal is or is not contained in a given answer set by defining two justification methods, both of which make use of the correspondence between answer sets of a logic program and stable extensions of the Assumption-Based Argumentation (ABA) framework constructed from the same logic program. Attack Trees justify a literal in argumentation-theoretic terms, i.e. using arguments and attacks between them, whereas ABA-Based Answer Set Justifications express the same justification structure in logic programming terms, that is using literals and their relationships. Interestingly, an ABA-Based Answer Set Justification corresponds to an admissible fragment of the answer set in question, and an Attack Tree corresponds to an admissible fragment of the stable extension corresponding to this answer set.", "creator": "LaTeX with hyperref package"}}}