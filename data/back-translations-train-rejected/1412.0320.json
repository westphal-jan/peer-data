{"id": "1412.0320", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Dec-2014", "title": "Canonical Logic Programs are Succinctly Incomparable with Propositional Formulas", "abstract": "\\emph{Canonical (logic) programs} (CP) refer to normal logic programs augmented with connective $not\\ not$. In this paper we address the question of whether CP are \\emph{succinctly incomparable} with \\emph{propositional formulas} (PF). Our main result shows that the PARITY problem, which can be polynomially represented in PF but \\emph{only} has exponential representations in CP. In other words, PARITY \\emph{separates} PF from CP. Simply speaking, this means that exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). Furthermore, since it has been shown by Lifschitz and Razborov that there is also a problem that separates CP from PF (assuming $\\mathsf{P}\\nsubseteq \\mathsf{NC^1/poly}$), it follows that CP and PF are indeed succinctly incomparable. From the view of the theory of computation, the above result may also be considered as the separation of two \\emph{models of computation}, i.e., we identify a language in $\\mathsf{NC^1/poly}$ which is not in the set of languages computable by polynomial size CP programs.", "histories": [["v1", "Mon, 1 Dec 2014 01:10:30 GMT  (97kb)", "https://arxiv.org/abs/1412.0320v1", "This is an extended version of a conference paper with the same name in KR2014"], ["v2", "Sat, 24 Jan 2015 11:47:04 GMT  (97kb)", "http://arxiv.org/abs/1412.0320v2", "This is an extended version of a conference paper with the same name in KR2014"]], "COMMENTS": "This is an extended version of a conference paper with the same name in KR2014", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["yuping shen", "xishun zhao"], "accepted": false, "id": "1412.0320"}, "pdf": {"name": "1412.0320.pdf", "metadata": {"source": "CRF", "title": "Canonical Logic Programs are Succinctly Incomparable with Propositional Formulas", "authors": ["Yuping Shen", "Xishun Zhao"], "emails": ["hsszxs}@mail.sysu.edu.cn"], "sections": [{"heading": null, "text": "ar Xiv: 141 2.03 20v2 [cs.L"}, {"heading": "1 Introduction", "text": "The study of logic programs in the semantics of the worst case, i.e., the introduction of programming programs (ASP) [15, 26, 5], has been an active area in artificial intelligence for the last decades. As a competing approach to SAT [4], ASP has been successfully applied in many areas, such as planning, commonsense reasoning, scheduling, etc. \"Extended version of a paper with the same name in KR2014.\" The relationship between logic programs and propositional formulas (PF) is gaining a lot of attention in the literature. A well-known theorem, shown by Lin & Zhao [29], provides a method for translating a normal (logical) program (LP) into a (logical) equivalent set of formulas in PF without the introduction of additional variables. However, translation has been observed to lead to an exponential number of so-called formulas."}, {"heading": "2 Background", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Canonical Programs", "text": "The following notations are taken from [25, 22]. A rule element e is replaced by an undefined element: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is defined: the element I is defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is defined: the element I is defined: the element I is defined: the element I is defined: the element I is defined: the element I is defined: the element I is not defined: the element I is not defined: the element I is not defined: the element I is defined: the element I is not defined: the element I is defined: the element I is not defined: the element I is defined: the element I is not defined: the element I is defined: the element I is not defined: the element I is defined: the element I is defined: the element I is defined: the element is defined: the element is not defined: the element I is defined: the element I is defined: the element is not defined: the element is defined: the element I is defined: the element is defined: the element is defined: the element I is defined: the element is defined: the element is not defined."}, {"heading": "2.2 Problem Representation and Succinctness", "text": "A string is a finite sequence of bits from {0, 1}. A string w with the length n (i.e. w = 0, 1} n) can be written as w1w2... wn, in which each bit is w = 0, 1}. Note that a string w = 0, 1} n defines a subset of variables {x1,.., xn}, e.g. 1010 stands for {x1, x3 \u2032. A problem L can be represented in a class of programs C (i.e. L = C) if there is a sequence of programs {n} (n = 1, 2,..). A problem L is a set of strings. Definition 2.1 (problem representation). A problem L can be represented in a class of programs C (i.e. L = C = C) if there is a sequence of programs."}, {"heading": "2.3 The PARITY Problem", "text": "The PARITY problem is defined as: PARITY = {binary strings with an odd number of 1}. We can simply call a string in PARITY an odd string, and PARITYn denotes the set of odd strings of length n. Note that PARITYn contains 2n \u2212 1 strings. It is not difficult to see that PARITYn for n = 1, 2 strings for n {x1} and PARITYn for 2 strings {x1} (i.e., {x1}), and Ans (2 strings of length n.) {x1}, {x1}, {x2}, {x2}, {x2}, {x2}, {x2}, etc. The strings of length n."}, {"heading": "3.1 Boolean Circuits", "text": "A (Boolean) circuit is a directed, cycle-free graph in which each node is either a gate marked with one of the two circuits, or a Boolean variable. The in-degree (or out-degree) of a node is called its fan-in (or fan-out). A node marked with a variable always has fan-in 0 and is called an input. Output of the circuit is a gate called a fan-out. The value of a circuit Cn under the inputs x1,. xn, denoted by Cn (x1,.., xn), is the value of the output obtained from an iterative calculation by the inputs and the intermediate gates Cn in the usual way."}, {"heading": "3.2 Completion and Related Theorems", "text": "It is therefore not the rule (or conjunction) of the rules in Bi with a connecting, not a connecting, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another, not replaced by another set of rules in Bi with another, not replaced by another set of rules. It is the (or conjunction) of the rules in Bi with another, not replaced by another set of rules. Then Comp (or) is a constant depth not limited by a polynomically limited set of rules. All propositional formulas are circuits of fan-out-1, so Comp (or Comp) is definitely a circuit whose size is polynomically limited."}, {"heading": "4.1 Simplifying Full Coverage Rules", "text": "A rule H (B) is a complete coverage rule when B (B) fully covers (B).Lemma 4.1. Let's (n) be a PARITYn program. Suppose there is a rule x (B) in each set of variables, I (n) not x (B) iff I = Cn (B) contains a unique uniform string. Note, however, that the x (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) n (n) Cn (n) n (n) n (n) n (n) n (n) n (n). Thus, it is sufficient to show Cn (n) n (n)."}, {"heading": "4.3 Proof of Proposition 4.2", "text": "For technical reasons we divide the rewrite procedure into two steps, in the first step a standard PARITY program is converted into a so-called almost pure program and in the second step the program is converted into a pure program, i.e., a PARITY program that has no loops. Before we do this, we have to do some lemmas.Lemma 4.3. Let's be a standard PARITYn program."}, {"heading": "4.4 The Main Results", "text": "s be a PARITYn program. Then there is a PARITYn program. PARITY does not have a polynomial p (n). Proof. Suppose there is a sequence of programs in CP that represent PARITY, and | n | is limited by a polynomial p (n). With sentence 4.5 there is a sequence of fully equivalent PARITY programs in which the polynomial p (n) is also limited."}, {"heading": "5 Discussion and Some More Results", "text": "Interestingly, our main result may seem counterintuitive at first glance: the P-complete problem PATH has poly-CNP representations, whereas this does not apply to a \"simple\" problem PARITY. In fact, there is no contradiction. As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, which does not mean that all problems in this class are in C. In general, exploring conciseness [17, 7, 19, 13] means giving us a deeper understanding of KR formalisms, because it reveals its (in) ability to concisely represent various problems, provided that the coded models are the same. In terms of the theory of compilation, conciseness essentially concerns the computational power of various formalisms (i.e. models of compilation), which is especially interesting when formalisms are equally expressive and share the same argument configuration."}, {"heading": "5.1 Logic Programs with Cardinality Constraints (CC)", "text": "Simply put, CC covers normal programs (LP) with so-called cardinality constraints and selection rules (32). A selection rule {x} \u2190 (8) has two response sets {x} and \u2205, i.e., the same as x \u2190 and not x. In addition, a selection rule {x1,.., xn} \u2190 generates 2n response sets, i.e. all subsets of {x1,.., xn}. A cardinality constraint is an expression of the formula \u2264 B \u2264 u (9) in which B is a finite set of rule elements of the form x or not x, and integer l (or u) is the lower (or upper) limit of B. In this paper, we assume that the size of l (and u) is polynomically limited by n.IX. Intuitively, a number of variables that I fulfill (9) when the number of satisfied rule elements in B meets the related limits. E.g. {x1}, {x1}, {x1}, \u2264, {x3}."}, {"heading": "5.2 Definite Causal Theories (DT)", "text": "(D) D \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o\" o \"o"}, {"heading": "5.3 Two-Valued Logic Programs (TV)", "text": "A (bivalent) program [27] on signature {x1,..., xn} is a finite set of (bivalent) rules of the form: H \u2190 B: G (14), in which B: {H} is a finite set of words and G is a formula. The reduced number of variables I is the set of rulesH \u2190 B (15) from.n s.t. I satisfy G. A set of words J is closed according to rule (15) if H: J whenever B'J. We say that I am the unique model of the minimum conclusion J under each rule of.n. The following program \u043f2 in TVx \u2190: x, \u00ac x: \u00ac x (16) has two models {x} and a procedure equivalent to (12). The following observations were shown in [27]."}, {"heading": "6 Conclusions", "text": "The main result of the paper is that the PARITY problem separates PF from CP, i.e. PARITY does not have polynomial-sized CP programs, but polynomial-sized PF formulas. Together with the separation result of Lifschitz and Razborov, i.e. there is a problem separating CP from PF (provided P * NC1 / poly), we come to the conclusion that the two known KR formalisms are concisely incomparable. In other words, if we look at CP and PF as two different calculation models, the above result merely states that they are incomparable in terms of computing power. We also give a non-trivial concisely picture of a family of logical program classes that exhibits the same expressiveness and argumentation complexity as PF. In future work, we plan to examine some missing correlations in Figure 2, for example, we assume that there is a problem separating LCDP, CT, and CP briefly, and CP."}, {"heading": "Acknowledgement", "text": "Many thanks to Shiguang Feng, Yan Zhang, Jiankun He, Guangrui Dang and Xiaolong Liang for their helpful discussions. In part, the research was supported by NSFC Grant 61272059, MOE Grant 11JJD720020, NSSFC Grant 13 & ZD186, 14CZX058 and the Fundamental Research Funds for the Central Universities Grant 1409025."}], "references": [{"title": "Towards a theory of declarative knowledge", "author": ["K.R. Apt", "H.A. Blair", "A. Walker"], "venue": "Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1988}, {"title": "Computational Complexity: A Modern Approach", "author": ["Sanjeev Arora", "Boaz Barak"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications", "author": ["Armin Biere", "Marijn Heule", "Hans van Maaren", "Toby Walsh", "editors"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Answer set programming at a glance", "author": ["Gerhard Brewka", "Thomas Eiter", "Miroslaw Truszczynski"], "venue": "Communications of the ACM,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Negation as failure", "author": ["Keith L. Clark"], "venue": "Logic and Data Bases,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1978}, {"title": "Expressive power and succinctness of propositional languages for preference representation", "author": ["Sylvie Coste-Marquis", "J\u00e9r\u00f4me Lang", "Paolo Liberatore", "Pierre Marquis"], "venue": "In Proceedings of the Ninth International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2004}, {"title": "Complexity and expressive power of logic programming", "author": ["Evgeny Dantsin", "Thomas Eiter", "Georg Gottlob", "Andrei Voronkov"], "venue": "ACM Computing Surveys,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "Almost definite causal theories", "author": ["Semra Do\u011fanda\u011f", "Paolo Ferraris", "Vladimir Lifschitz"], "venue": "Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Tight logic programs", "author": ["Esra Erdem", "Vladimir Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Consistency of clark\u2019s completion and existence of stable models", "author": ["Fran\u00e7ois Fages"], "venue": "Journal of Methods of Logic in Computer Science,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1994}, {"title": "Weight constraints as nested expressions", "author": ["Paolo Ferraris", "Vladimir Lifschitz"], "venue": "Theory Pract. Log. Program.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2005}, {"title": "On the succinctness of some modal logics", "author": ["Tim French", "Wiebe van der Hoek", "Petar Iliev", "Barteld P. Kooi"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Parity, circuits, and the polynomial-time hierarchy", "author": ["Merrick L. Furst", "James B. Saxe", "Michael Sipser"], "venue": "Mathematical Systems Theory,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1984}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1988}, {"title": "Nonmonotonic causal theories", "author": ["Enrico Giunchiglia", "Joohyung Lee", "Vladimir Lifschitz", "Norman McCain", "Hudson Turner", "Joohyung Lee Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2004}, {"title": "The comparative linguistics of knowledge representation", "author": ["Goran Gogic", "Henry A. Kautz", "Christos H. Papadimitriou", "Bart Selman"], "venue": "In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1995}, {"title": "Limits to parallel computation: P-completeness theory", "author": ["Raymond Greenlaw", "H. James Hoover", "Walter L. Ruzzo"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1995}, {"title": "The succinctness of first-order logic on linear orders", "author": ["Martin Grohe", "Nicole Schweikardt"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2005}, {"title": "Almost optimal lower bounds for small depth circuits", "author": ["Johan Hastad"], "venue": "In Proceedings of the eighteenth annual ACM symposium on Theory of computing,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1986}, {"title": "Boolean Function Complexity - Advances and Frontiers, volume 27 of Algorithms and combinatorics", "author": ["Stasys Jukna"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["Joohyung Lee"], "venue": "In Proceedings of the 19th international joint conference on Artificial intelligence,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2005}, {"title": "Loop formulas for disjunctive logic programs", "author": ["Joohyung Lee", "Vladimir Lifschitz"], "venue": "Logic Programming,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2003}, {"title": "Action language BC: Preliminary report", "author": ["Joohyung Lee", "Vladimir Lifschitz", "Fangkai Yang"], "venue": "In Proceedings of the 23rd International Joint Conference on Artificial Intelligence,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2013}, {"title": "Nested expressions in logic programs", "author": ["Vladimir Lifschitz"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1999}, {"title": "What is answer set programming", "author": ["Vladimir Lifschitz"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "Two-valued logic programs", "author": ["Vladimir Lifschitz"], "venue": "Technical Communications of the 28th International Conference on Logic Programming,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2012}, {"title": "Why are there so many loop formulas", "author": ["Vladimir Lifschitz", "Alexander Razborov"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["Fangzhen Lin", "Yuting Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2004}, {"title": "Causality in Commonsense Reasoning about Actions", "author": ["Norman McCain"], "venue": "PhD thesis, University of Texas at Austin,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1997}, {"title": "Models of computation", "author": ["John E Savage"], "venue": "Exploring the Power of Computing. Addison-Wesley,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1998}, {"title": "Extending and implementing the stable model semantics", "author": ["Patrik Simons", "Ilkka Niemel\u00e4", "Timo Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2002}, {"title": "On the equivalence between answer sets and models of completion for nested logic programs", "author": ["Jia-Huai You", "Li-Yan Yuan", "Mingyi Zhang"], "venue": "In Proceedings of the 18th international joint conference on Artificial intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2003}], "referenceMentions": [{"referenceID": 13, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 24, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 3, "context": ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.", "startOffset": 31, "endOffset": 42}, {"referenceID": 2, "context": "As a competing approach to SAT [4], ASP has been successfully applied in many fields like Planning, Commonsense Reasoning, Scheduling, etc.", "startOffset": 31, "endOffset": 34}, {"referenceID": 27, "context": "A well-known theorem shown by Lin & Zhao [29] gives a method for translating a normal (logic) program (LP) to a (logically) equivalent set of formulas in PF, without introducing additional variables.", "startOffset": 41, "endOffset": 45}, {"referenceID": 26, "context": "In 2006, Lifschitz and Razborov proved that such exponential blowup is generally inevitable, more precisely, they showed that (a variant of) the P-complete problem PATH has polynomial size representations in LP, however, it cannot be polynomially represented in PF (assuming P * NC/poly) [28].", "startOffset": 288, "endOffset": 292}, {"referenceID": 26, "context": "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.", "startOffset": 12, "endOffset": 16}, {"referenceID": 23, "context": "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.", "startOffset": 99, "endOffset": 103}, {"referenceID": 15, "context": "Therefore, NLP is stronger than PF in terms of the succinctness criterion (or the \u201ccomparative linguistics\u201d approach) proposed in [17]:", "startOffset": 130, "endOffset": 134}, {"referenceID": 24, "context": "So the following footnote in [26] seems convincing at first glance:", "startOffset": 29, "endOffset": 33}, {"referenceID": 20, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 23, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 22, "context": "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a \u201cminimal\u201d form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.", "startOffset": 70, "endOffset": 82}, {"referenceID": 1, "context": ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ \u2208 AC, i.", "startOffset": 43, "endOffset": 50}, {"referenceID": 19, "context": ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ \u2208 AC, i.", "startOffset": 43, "endOffset": 50}, {"referenceID": 12, "context": ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].", "startOffset": 104, "endOffset": 112}, {"referenceID": 18, "context": ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].", "startOffset": 104, "endOffset": 112}, {"referenceID": 9, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 8, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 31, "context": "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), \u03a0\u2032 is equivalent to its completion Comp(\u03a0\u2032), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |\u03a0\u2032|.", "startOffset": 44, "endOffset": 56}, {"referenceID": 29, "context": "From the view of the theory of computation, the above result may also be considered as the separation of two models of computation [31], i.", "startOffset": 131, "endOffset": 135}, {"referenceID": 30, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 85, "endOffset": 89}, {"referenceID": 28, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 158, "endOffset": 166}, {"referenceID": 14, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 158, "endOffset": 166}, {"referenceID": 25, "context": ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.", "startOffset": 221, "endOffset": 225}, {"referenceID": 23, "context": "The following notations are adopted from [25, 22].", "startOffset": 41, "endOffset": 49}, {"referenceID": 20, "context": "The following notations are adopted from [25, 22].", "startOffset": 41, "endOffset": 49}, {"referenceID": 23, "context": "According to [25], not not not x can be replaced by not x.", "startOffset": 13, "endOffset": 17}, {"referenceID": 15, "context": "The following concept is adopted from [17, 13].", "startOffset": 38, "endOffset": 46}, {"referenceID": 11, "context": "The following concept is adopted from [17, 13].", "startOffset": 38, "endOffset": 46}, {"referenceID": 26, "context": "However, this is impossible since it contradicts the anti-chain property of \u03a0n [28]: if strings I, I \u2032 \u2208 Ans(\u03a0n) and I \u2286 I \u2032 then I = I \u2032.", "startOffset": 79, "endOffset": 83}, {"referenceID": 1, "context": ", PARITY\u2208 NC/poly (or Poly-PF) [3, 21].", "startOffset": 31, "endOffset": 38}, {"referenceID": 19, "context": ", PARITY\u2208 NC/poly (or Poly-PF) [3, 21].", "startOffset": 31, "endOffset": 38}, {"referenceID": 1, "context": "For more details about circuits, please see [3].", "startOffset": 44, "endOffset": 47}, {"referenceID": 4, "context": "The completion Comp(\u03a0) [6, 10] of a canonical program \u03a0, consists of a set (or conjunction) of formulas4:", "startOffset": 23, "endOffset": 30}, {"referenceID": 8, "context": "The completion Comp(\u03a0) [6, 10] of a canonical program \u03a0, consists of a set (or conjunction) of formulas4:", "startOffset": 23, "endOffset": 30}, {"referenceID": 27, "context": "It is shown in [29, 23] that the so-called loop formulas LF (\u03a0) nicely eliminate inappropriate models of Comp(\u03a0), s.", "startOffset": 15, "endOffset": 23}, {"referenceID": 21, "context": "It is shown in [29, 23] that the so-called loop formulas LF (\u03a0) nicely eliminate inappropriate models of Comp(\u03a0), s.", "startOffset": 15, "endOffset": 23}, {"referenceID": 0, "context": "The (positive) dependency graph [2] of a canonical program \u03a0 is a pair (N,E) in which the set of nodes N = var(\u03a0), and E contains a directed edge (x, x\u2032) iff there is a rule H \u2190 B in \u03a0 s.", "startOffset": 32, "endOffset": 35}, {"referenceID": 27, "context": "1 (Lin-Zhao Theorem[29, 23]).", "startOffset": 19, "endOffset": 27}, {"referenceID": 21, "context": "1 (Lin-Zhao Theorem[29, 23]).", "startOffset": 19, "endOffset": 27}, {"referenceID": 9, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 8, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 31, "context": "1 (or the (generalized) Fages theorem [11, 10, 33]), if \u03a0 has no loops, then LF (\u03a0) is a tautology \u22a4 and \u03a0 is equivalent to Comp(\u03a0) (i.", "startOffset": 38, "endOffset": 50}, {"referenceID": 0, "context": "Let \u03a0 be a basic program and I be a set of variables, define the Knaster-Tarski operator [2] as T\u03a0(I) = {H : H \u2190 B \u2208 \u03a0 and I |= B}.", "startOffset": 89, "endOffset": 92}, {"referenceID": 13, "context": "It is pointed out in [15, 33] that I \u2208 Ans(\u03a0) iff I = T\u221e \u03a0 (\u2205) for a canonical program \u03a0.", "startOffset": 21, "endOffset": 29}, {"referenceID": 31, "context": "It is pointed out in [15, 33] that I \u2208 Ans(\u03a0) iff I = T\u221e \u03a0 (\u2205) for a canonical program \u03a0.", "startOffset": 21, "endOffset": 29}, {"referenceID": 6, "context": "As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, does not imply that all problems in that class can be represented in C.", "startOffset": 12, "endOffset": 18}, {"referenceID": 15, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 5, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 17, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 11, "context": "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.", "startOffset": 49, "endOffset": 64}, {"referenceID": 30, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 96, "endOffset": 100}, {"referenceID": 14, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 143, "endOffset": 147}, {"referenceID": 25, "context": ", logic programs with cardinality constraints and choice rules (CC, without classic negation \u00ac) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.", "startOffset": 177, "endOffset": 181}, {"referenceID": 30, "context": "Simply speaking, CC extends normal programs (LP) with so-called cardinality constraints and choice rules [32].", "startOffset": 105, "endOffset": 109}, {"referenceID": 10, "context": "An equivalent translation from CC to NLP was presented in [12], however, the translation may involve exponential size blowup, since every cardinality constraint is simply converted to a formula via a brute force enumeration.", "startOffset": 58, "endOffset": 62}, {"referenceID": 29, "context": ", see Chapter 2 of [31].", "startOffset": 19, "endOffset": 23}, {"referenceID": 28, "context": "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].", "startOffset": 138, "endOffset": 146}, {"referenceID": 14, "context": "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].", "startOffset": 138, "endOffset": 146}, {"referenceID": 26, "context": "Since PATH is P-complete [28], therefore if PATH has polynomial representations in Poly-DT, then P \u2286 NC/poly, which is believed impossible.", "startOffset": 25, "endOffset": 29}, {"referenceID": 28, "context": "SDT is originally named as Objective Programs in [30].", "startOffset": 49, "endOffset": 53}, {"referenceID": 14, "context": ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].", "startOffset": 72, "endOffset": 79}, {"referenceID": 7, "context": ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].", "startOffset": 72, "endOffset": 79}, {"referenceID": 16, "context": "Recall that Poly-DT represents problems in NC/Poly, and TC is a problem in NC/poly [18], a class widely believed strictly contains NC/poly.", "startOffset": 83, "endOffset": 87}, {"referenceID": 25, "context": "3 Two-Valued Logic Programs (TV) A (two-valued) program [27] \u03a0n on signature {x1, .", "startOffset": 56, "endOffset": 60}, {"referenceID": 25, "context": "The following observations were pointed out in [27].", "startOffset": 47, "endOffset": 51}], "year": 2015, "abstractText": "Canonical (logic) programs (CP) refer to normal logic programs augmented with connective not not. In this paper we address the question of whether CP are succinctly incomparable with propositional formulas (PF). Our main result shows that the PARITY problem, which can be polynomially represented in PF but only has exponential representations in CP. In other words, PARITY separates PF from CP. Simply speaking, this means that exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). Furthermore, since it has been shown by Lifschitz and Razborov that there is also a problem that separates CP from PF (assuming P * NC/poly), it follows that CP and PF are indeed succinctly incomparable. From the view of the theory of computation, the above result may also be considered as the separation of two models of computation, i.e., we identify a language in NC/poly which is not in the set of languages computable by polynomial size CP programs.", "creator": "LaTeX with hyperref package"}}}