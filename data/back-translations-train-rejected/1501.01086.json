{"id": "1501.01086", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jan-2015", "title": "A Novel Design of a Parallel Machine Learnt Generational Garbage Collector", "abstract": "The Generational Garbage collection involves organizing the heap into different divisions of memory space in-order to filter long-lived objects from short-lived objects through moving the surviving object of each generation Garbage Collection cycle to another memory space updating its age and reclaiming space from the dead ones. The problem in this method is that the longer an object is alive during its initial generations the longer the garbage collector will have to deal with it by checking for its reachability from the root and promoting it to other space divisions where as the ultimate goal of the Garbage Collector is to reclaim memory from unreachable objects at a minimal time possible. This paper is a proposal of a method where the lifetime of every object getting into the heap will be predicted and will be placed in heap accordingly for the garbage collector to deal more with reclaiming space from dead objects and less in promoting the live ones to the higher level.", "histories": [["v1", "Tue, 6 Jan 2015 06:04:45 GMT  (229kb)", "http://arxiv.org/abs/1501.01086v1", null]], "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["vasanthakumar soundararajan"], "accepted": false, "id": "1501.01086"}, "pdf": {"name": "1501.01086.pdf", "metadata": {"source": "CRF", "title": "A Novel Design of a Parallel Machine Learnt Generational Garbage Collector", "authors": ["Vasanthakumar .S"], "emails": ["thisisvasanths@gmail.com"], "sections": [{"heading": null, "text": "DOI: 10.5121 / cseij.2014.4602 11The Generational Garbage Collection involves organizing the pile into different areas of storage space to filter long-lived objects from short-lived objects by moving the surviving object of the GC cycle of each generation to a different storage space, updating its age and reclaiming space from the dead. The problem with this method is that the longer an object lives during its first generations, the longer the garbage collector will have to deal with it, checking its accessibility from the root and moving it to other space divisions, where the ultimate goal of the GC is to recover stores of unreachable objects in the shortest possible time.This paper is a proposal for a method in which the lifespan of each object entering the pile is predicted and accordingly placed in the pile for the garbage collector to deal more with the recovery of space from dead objects and less with the promotion of living objects at the higher level."}, {"heading": "1. INTRODUCTION", "text": "The current generation of garbage collectors works in a way that filters the long-lived objects in the cluster from the short-lived objects, since 80-98% of the newly assigned objects will be dead within a few million instructions, or before they fulfill their first GC cycle. Generation GC achieves this by dividing the cluster into different regions of storage spaces called generations. All newly created objects are assigned with space in the generational space distribution intended for the new objects, which is comparatively small for the generational space distribution for the old objects, in order to have a young generation GC that is faster and more frequent. As the GC cycles occur when the space is filled in this young generation, the surviving objects from this GC are transformed into another spatial distribution intended for the surviving objects. This space acts as a buffer space in which the objects are aged by clearing the living objects between the subdivisions and the ends."}, {"heading": "2. ASSUMPTIONS", "text": "Many different languages use automatic garbage collection as an integral part of them. In this essay, we consider a Java application running in a Sun JDK to be our theme. All of our terminologies and implementation details must be consistent with the JVM Generation Garbage Collection and the JVM Heap for the rest of the essay. We will use a sample Java application called java2demo.jar as our theme to discuss the feasibility of predicting, as the control flows for this application are very limited. Suppose there is a JVM whose garbage collector code has been modified to inject a data retrieval module that can log the details of creating objects, allocating space, creating an object, and reclaiming."}, {"heading": "3. SOLUTION PROPOSAL", "text": "There are three important phases in the solution proposed by this essay: predicting the lifespan of objects in clusters, structuring data to keep dead objects first, and recovering space parallel to the promotion of objects."}, {"heading": "3.1 Prediction", "text": "Computer programs are highly structured instruction sets, so a fully functioning software application would have few finite different execution streams. In the case of object-oriented programming, these control flows determine which objects are instantiated and which object circumference is left. These characteristics of software applications written in object-oriented programming languages make the pattern of object creation predictable in a given execution sequence. In this proposed method, the important module happens to be the prediction module. This is a module that runs parallel to the application threads and gathers the details of object creation for a few initial test runs by injecting a record code into theinjector codes intended purely for testing, and thus the performance of the application is affected by the data acquisition that is created, advertised and laminated for each object. Once we have the test set in hand, the machine learning module will run the pre-set for each object and the expected duration of the object."}, {"heading": "3.2 Structuring Reachability Data", "text": "The traditional approach, in which the garbage collector in JVM distinguishes the dead objects from the life that is led on the basis of their accessibility, forms the root. Thus, the GC crosses the root for each object until it either hits the object or reaches a point where it is not possible to cross it again. According to this proposed model, the root holds only two children. One child serves as the root for all objects that very much like to die before they reach their first GC cycle, and the other child serves as the root for all objects that very much like to live longer, or at least long enough, to survive their first GC encounter."}, {"heading": "3.3 Parallel Reclamation and Promotion", "text": "Since we now have two partial roots under the main root, only one will be of interest to the GC, where objects will most likely be recaptured from their space. So, there will be a GC cycle running parallel to another thread, which we will call an Object Promoter (OP). Each child will go through the OP from its root, where all objects are expected to be alive. Here, the OP will review the expected life span of each object and promote it according to the respective generational space. If the OP encounters a dead object (which often occurs during the first test runs to obtain the data set), the OP will act like a GC and regain its space."}, {"heading": "4. DATA COLLECTION AND ANALYSIS", "text": "To check how feasible the predictive phase of this model can be implemented, we can use the java2demo.jar application as our subject and collect data during its runtime in terms of its objects lifetime and analyze it. With the jmap tool, which is an integral part of Sun JDK, we can retrieve the histogram of the cluster at any point during the runtime of the application. Further use of the JvisualVM tool, which is also an integral part of JDk with its visualGC plugin, allows us to graphically display the GC cycles and the objects promotion. The jmap \"s -histo\" s and -histo: Live options can be used to get the list of class names, number of instances for each class name and their size in bytes for all objects and only the live objects respectively. With the jVisualVM, we can learn when the GC cycle is taking place."}, {"heading": "5. BAYESIAN NETWORK", "text": "The Bayes Theorem is a theorem of probability theory that can be seen as a way of understanding how the probability of a theory being true is influenced by a given piece of evidence. It has been used in a variety of contexts, from marine biology to the development of \"Bayesian\" spam blockers for email systems. The Bayesian network will be the right approach for this scenario, since our prediction here is based on the conditional probability (i.e.) that event B will occur since event A has occurred [5]. Here event B refers to the survival of an object for a certain period of time, since a number of objects of another class already exist or the number of GC cycles spent or the same object has survived Eden space, etc."}, {"heading": "5.1 Features and Probability", "text": "Bayes' theorem expresses the conditional probability or \"posterior probability\" of an event A to B. Bayes' theorem applies to all common interpretations of probability. [6] Bayes' theorem provides an expression for the conditional probability from A to B, where the properties on which the probability must be calculated depend on the characteristic data that can be retrieved from the pile during the runtime of the application. [7] Bayes' theorem provides an expression for the conditional probability from A to B. Let us assume that there are \"n\" different characteristics that can be recorded or calculated during or after the runtime of the application from the data that our injected code can retrieve during the first few tests. The characteristics that are specified include characteristics, the characteristics such as the class probability of the object, the depth of the hierarchy."}, {"heading": "5.2 Threshold and Decision making", "text": "Since the Bayesian network gives us the probability that an object will survive a certain generation space or reach a certain generation space, the output will have a value between 0 and 1, including. Now, we must find a threshold that is the determining factor beyond which the object will survive or move into a space below which the object will not survive. This value can be a tunable factor that can be determined based on the performance of the algorithm over the application of improved results, but we must take into account the fact that an incorrect prediction of an object that will not survive a generation space can be tolerated, since the GC will anyway promote the object to the next generation of the buffer space, but an incorrect prediction of an object that will survive a generation space cannot be tolerated, since an \"imminent\" object will be promoted, which will incur further computing costs. Thus, the threshold for this scenario must be generally high, for example, a threshold of 0.8 will be better than the threshold of 0.55."}, {"heading": "6. PRECISION AND RECALL TRADE OFF", "text": "This prediction method proposed for the scenario has two cases of false predictions; the second case is a false positive, that is, the algorithm predicts that the object in question will survive the space, but because of which we would promote a dead object. Considering both cases, we can clearly decide that a false negative is a tolerable scenario in which the false positive cannot be tolerated. Therefore, we have to set the prediction module so that there is absolutely no false positive that could accommodate a few false negatives. One such prediction system is the system of the high-precision classifier. This is a compromise between the precision and the retrieval of the classifier, where we opt for higher precision, which will lead to less memory. To set up a classification system with higher precision, we have to assign a higher value to the threshold."}, {"heading": "7. DATA STRUCTURING", "text": "This method of collecting garbage with predicted lifespan of objects will require a slightly different implementation of the data structure used to detect the dead objects from living ones. Traditional generation GC will do this by checking the accessibility of an object from the root. But, in this case, we will maintain a root node that has two child nodes, each of which will act as the root of a map. A child will act as the root of objects that are most likely to die in this current GC cycle, while the other child will act as the root of the objects that will most likely survive the current GC cycle, and the child that holds the objects that are dying will act as the root for the operation. In this way, the GC will use a root where a very small group of objects that are reachable in the GC cycle are reachable, and those that are predicted in the GC cycle and survive in return (false)."}, {"heading": "8. PARALLELIZATION OF PROCESSES", "text": "This garbage collection method has been designed to be suitable for implementation on multi-processor machines. For each application for which we want to use this predictive GC, we need a series of initial tests to obtain the dataset on which the number is based, based on the complexity of the application. Once the dataset has been captured and processed, apart from the greatly reduced GC pause times, any other action of this proposed GC method can be parallelized and performed without disrupting the operation of the application threads. The OP can run parallel to the GC because they do not share the same root and can transport the objects to the expected generation rooms, where they are most likely to be recovered from their rooms. The OP can also predict the life of objects parallel to the application threads."}, {"heading": "9. CONCLUSION", "text": "I have proposed a description of a Parallelized Machine Learned Generational Garbage Collector that uses the Bayesian network to predict and manage the objects in the cluster appropriately to reduce the time the GC spends dealing with living objects. If implemented, this proposed model will most likely result in a reduction in the workload of the GC at each generation stage, since it will not deal with living objects if the prediction is 100% accurate. Pause times will be greatly reduced in applications that contain a large amount of living objects in their Eden and Survivor rooms. Since the Generational Garbage Collection is used in conjunction with many programming languages used worldwide for application engineering, such a model can improve the performance of the GCs, which in turn reflects an increase in performance over the application. This model is based on the assumption that the application as a subject does not have many different control flows that affect the creation pattern of the objects."}], "references": [{"title": "Infant mortality and generational garbage collection in SIGPLAN Notices", "author": ["Henry G. Baker"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "Controlling garbage collection and heap growth to reduce the execution time of java applications in Proceedings of the OOPSLA\u201901", "author": ["Tim Brecht", "Eshrat Arjomandi", "Chang Li", "Hang Pham"], "venue": "Conference on Object Oriented Programming Systems Languages and Applications,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2001}, {"title": "Garbage collection in an uncooperative environment in Software\u2014Practice and Experience", "author": ["Hans-Juergen Boehm", "Mark Weiser"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1988}, {"title": "A novel design of a generational garbage collector", "author": ["W.U. Zaman", "S.A. Ahmad", "A. Abbas", "A. Qadeer"], "venue": "in Students Conference,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2002}, {"title": "A real-time garbage collector based on the lifetime of objects", "author": ["H. Lieberman", "C. Hewitt"], "venue": "Communications of the ACM 26, pp 419-429, June 1983.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1983}, {"title": "Learning Bayesian Network Classifier Based on Dependency Analysis and Hypothesis Testing in Intelligent Human-Machine Systems and Cybernetics (IHMSC)", "author": ["Sun Wenjing"], "venue": "Xidian Univ.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}], "referenceMentions": [{"referenceID": 0, "context": "This scenario of entities being created, aged and reclaimed when dead, caries the computational advantages of a quintessential subject for the heuristic prediction over the lifetime of entities in a particular domain [1, 39].", "startOffset": 217, "endOffset": 224}], "year": 2014, "abstractText": "The Generational Garbage collection involves organizing the heap into different divisions of memory space in-order to filter long-lived objects from short-lived objects through moving the surviving object of each generation\u2019s GC cycle to another memory space, updating its age and reclaiming space from the dead ones. The problem in this method is that, the longer an object is alive during its initial generations, the longer the garbage collector will have to deal with it by checking for its reachability from the root and promoting it to other space divisions, where as the ultimate goal of the GC is to reclaim memory from unreachable objects at a minimal time possible. This paper is a proposal of a method where the lifetime of every object getting into the heap will be predicted and will be placed in heap accordingly for the garbage collector to deal more with reclaiming space from dead object and less in promoting the live ones to the higher level.", "creator": "PScript5.dll Version 5.2.2"}}}