{"id": "1501.01178", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jan-2015", "title": "Constraint-based sequence mining using constraint programming", "abstract": "The goal of sequence mining is to find sequences of symbols that are included in (i.e. that are subsequences of) a large number of input sequences. Many constraints have been proposed in the literature for this type of problem, but a general framework for handling these constraints is missing. We investigate the use of constraint programming as general framework for this task. We first identify four categories of constraints that are applicable to sequence mining. We then propose two constraint programming formulation: the first formulation introduces a new global constraint called exists embedding that hides the complexity of the inclusion relation. However, this approach does not support one category of constraints. To support such constraints, we develop a second for- mulation that is more general but incurs more overhead. Both formulations can be related to the projected database technique used in specialised algorithms, and can use projected frequency to speed up the search. Experiments demonstrate the flexibility towards constraint-based settings and compare the approach to existing methods. Finally, we discuss the benefits and limitations of a CP-based approach for constrained mining.", "histories": [["v1", "Tue, 6 Jan 2015 13:47:24 GMT  (59kb,D)", "https://arxiv.org/abs/1501.01178v1", null], ["v2", "Thu, 8 Jan 2015 13:50:53 GMT  (63kb,D)", "http://arxiv.org/abs/1501.01178v2", null], ["v3", "Wed, 25 Feb 2015 16:31:27 GMT  (66kb,D)", "http://arxiv.org/abs/1501.01178v3", "In Integration of AI and OR Techniques in Constraint Programming (CPAIOR), 2015"]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["benjamin negrevergne", "tias guns"], "accepted": false, "id": "1501.01178"}, "pdf": {"name": "1501.01178.pdf", "metadata": {"source": "CRF", "title": "Constraint-based sequence mining using constraint programming", "authors": ["Benjamin Negrevergne", "Tias Guns"], "emails": ["firstname.lastname@cs.kuleuven.be"], "sections": [{"heading": null, "text": "Keywords: Sequential Pattern Mining, Sequence Mining, Episode Mining, Constraint Pattern Mining, Constraint Programming, Declarative Programming"}, {"heading": "1 Introduction", "text": "In fact, it is the case that it will be able to fix and correct the mentioned bugs without being able to fix the mentioned bugs."}, {"heading": "2 Sequence mining", "text": "Sequence Mining [1] can be considered a variation of the known item set mining problem proposed in [2]. Itemset Mining provides a set of transactions in which each transaction represents a set of items, and the goal is to find patterns (i.e. item sets) that are present in a large number of transactions. In sequence mining, the problem is similar, except that both transactions and patterns are ordered (i.e. they are sequences instead of item sets) and symbols can be repeated. < b, a, c, b > and < a, c, c, b > are two sequences, and the sequence < a, b > is a possible pattern that is contained in both. This problem is known in the literature by several names, such as embedded subsequence mining, sequential pattern mining, flexible motif mining or serial episode mining depending on the application."}, {"heading": "2.1 Frequent sequence mining: problem statement", "text": "A key term for any pattern mining is the pattern relationship. In sequence mining, a pattern is included in a transaction if there is an embedding of that order in the transaction; where an embedding is an embedding of each symbol in the pattern associated with the same symbol in the transaction so that the transaction is so frequent that the order of transactions is respected. Definition 1 (embedding in an order). Let S = < s1,.,. s1) is an embedding of S \u00b2 and S \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 if and only if: S \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2 s \u00b2."}, {"heading": "2.2 Constraints", "text": "The constraints typically capture background knowledge and are provided by the user. We identify four categories of constraints on the transaction: 1) constraints on the pattern, 2) constraints on the cover, 3) constraints on the inclusion relationship, and 4) preferences on the solution set.Constraints on the pattern These constraints impose constraints on the pattern structure, 2) constraints on the size or constraints of the regular expression. Size restrictions: A size restriction is simple | S | \u03b1, where the constraints on the pattern are set. < \u2264} and \u03b1 is a threshold supplied by the user. It is used to discard small patterns."}, {"heading": "3 Sequence Mining in Constraint Programming", "text": "There is a solution for a CSP is an assignment of each variable to a value from its domain that defines all constraints so that all constraints are met. A COP additionally consists of a set of possible values that it can take, and a set of constraints that express the quality of the variables in V. There is no restriction on what can constitute a constraint of each variable to a value from its domain, so that all constraints are met. A COP additionally consists of an optimization criterion f (V) that expresses the quality of the solution. Examples include logical constraints such as X-Y or X-Y, and mathematical constraints such as Z + Y, and so on. Each constraint has a corresponding propagator that meets the constraints during the search."}, {"heading": "4.2 Constraints", "text": "This formulation supports a variety of constraints, namely pattern (type 1), coverage (type 2) and solution (type 4). For example, type 1 restriction limits the size of the pattern to be greater than a user-defined threshold \u03b1. This restriction can be formalized as the following: coverage (S, D1) | coverage (S, D2) | coverage (S, D2) | coverage (D = D1, D2) and coverage (P = {i, Ti, D2). Another example is the discriminatory restriction mentioned in Section 2.2: In view of two data sets D1 and D2, the ratio between coverage in the two data sets may be greater than a user-defined threshold: coverage (S, D1) | coverage (S, D2) | coverage (D = D1, D2) and coverage (P = {i, Ti, D2).coverage (S) may have a gap."}, {"heading": "5 Decomposition with explicit embedding variables", "text": "In the previous model, we used a global constraint to assign the Ci variables to their appropriate value, i.e.: Ci \u2194 e s.t. S ve Ti. The global constraint efficiently checks the existence of an embedding, but does not disclose the value of this embedding, so it is impossible to express constraints against embedding, such as the maximum gap constraint. To counter this constraint, we extend the previous model by a series of embedding variables Ei1,..., Ei | Ti |, which represent an embedding e = (e1,..., e | Ti |) of the sequence S in transaction Ti. If there is no possible match for a character Si in Ti, the corresponding Eij variable is assigned a no-match value."}, {"heading": "5.1 Variables and constraints", "text": "For each transaction Ti of length Ti | Ti | we perform integer variables Ei1,..., Ei | Ti |. Each variable Eij is an index in Ti, and an assignment to Eij maps the variable Sj to a position in Ti; see figure 2, the value of the index is materialized by the red arrows. This constraint ensures that the variables Ei represent either an embedding e, that S ve Ti or otherwise at least one eij has the nominal value. Therefore, each variable Eij is assigned the value x only if the character in Ti is equal."}, {"heading": "5.2 Search strategies for checking the existence of embeddings", "text": "CP's standard enumerative search would search for all satisfying assignments to the Sj, Ci and Eij variables. As for each sequence of size m, the number of embeddings in a transaction of size n can be O (nm), such such search would not be well. Instead, we just need to look for whether there is an embedding for each transaction. We do this after the S variables have been assigned. We call the search via the S variables the normal search, and the search via the Eij variables the sub-search. Note that you can perform the sub-search for each transaction i independently of the other transactions, that the transactions other than the egg have no influence on each other, only on Ci. Hence, you do not need to trace back via different sub-sub-sub-sub-sub-sub transactions."}, {"heading": "5.3 Projected frequency", "text": "Each eij variable represents the positions in Ti that Sj can still take. This is more general than the predicted transaction, since it also applies if the previous symbol in the sequence Sj \u2212 1 has not yet been assigned. Therefore, we can also use the eij variables to demand that each symbol of Sj must be frequent in the (generalized) projected database, as follows."}, {"heading": "5.4 Constraints", "text": "All constraints in Section 4.2 are also supported in this model. Additionally, constraints relating to inclusion relationships are also supported; for example, max gap and max margin. Let's remember from Section 2.2 that for embedding e = (e1,..., ek) we can restrict the max gap constraint as follows (note that x is smaller than the no-match value | Ti | + 1): \"i-Span.\" n, \"j-2.\" | Ti |, x-1. | Ti |: \"Eij = x-Egg (j \u2212 1). + 1 (12) Max span has been formalized as max span (e)."}, {"heading": "6 Experiments", "text": "The question as to the manner in which the individual models are presented in the manner and manner in which they are presented in the manner and manner in which they are presented in the manner and manner in which they are presented in the manner and manner in which they are used, as they are used in the manner and manner in which they are presented in the manner and manner in the manner in which they are presented in the manner and manner in the manner in which they are presented in the manner and manner in which they are used in the manner and manner in which they are presented in the manner and manner in the manner in which they are presented in the manner and in the manner in which they are presented in the manner and in the manner in which they are presented in the manner and in the manner in which they are presented in the manner and in the manner in which they are presented in the manner and in the manner in which they are presented in the manner and in the manner in which they are presented in the manner in the manner and in the manner in which they are presented in the manner and in the manner in the manner in which they are presented in the manner and in the manner in the manner in which they are presented in the manner and in the manner in the manner in which they are presented in the manner and in the manner in the manner in which they are presented in the manner and in the manner in the manner in the manner in which they are presented in the manner and in the manner in the manner in the manner in which they are presented in the manner and in the manner in the manner in the manner in which they are presented in the manner in the manner in the manner in the manner in the manner in which they are presented in the manner and in the manner in the manner in the manner in the manner in the manner in which they are presented and in the manner in the manner in the manner in the manner in which they are presented in the manner in the manner in the manner in the manner in the manner in which they are presented and in the manner in the manner and in the manner in the manner in which they are presented and in the manner in the manner in the manner in the manner in the manner in which they are presented and in the manner in the manner in the manner in the manner in which they are presented and in the manner in the manner in the manner in which they are presented and in the manner in the manner in the manner in which they are presented and in the manner in the manner in the manner in the"}, {"heading": "7 Related work", "text": "The idea of mining sequence pattern in sequences comes from previous work by Agrawal et al. [1] shortly after their well-known work on frequent mining sequences [2]. The problem introduced in [1] was to find frequent sequences of individual pieces; that is, sequences of sets contained in a database of sequences of sets. Mining sequences of individual symbols were later introduced by [9]; the two problems are closely related and one can be adapted to the other [16]. Mining sequence sequence sequence was driven by the application of market correlation analyses for customer data that spread over several days. Other applications include biomedical sequences in which a large number of DNA sequences and protein sequence datasets are available (e.g. [18], or natural language processing in which sentences can be presented as sequences of words (e.g. [15]) Multiple specialized sequence sequences have sequence sequence problems with sequence sequence sequence-restricted sequence sequence sequence-sequence sequence sequence-restricted sequence-sequence sequence-sequence-sequence-sequence-sequence-sequence-sequence-sequence-sequence"}, {"heading": "8 Conclusion and discussion", "text": "The difficulty in comparison to single sets and sequences with explicit wildcards is that the number of embeds can be enormous, while we know that one embed is sufficient. We proposed two models for the sequence-mining problem: one in which the existing embed relationship is captured in a global compulsion; the advantage is that the complexity of dealing with existential verification is hidden within the compulsion; the disadvantage is that the modification of the embed relationship requires a modification of the global constraints; it is therefore not generally directed towards such constraints; we were able to apply the same projected frequency technique as well-studied algorithms such as PrefixSpan [6] by modifying the global constraints of existence - embed constraints and applying a special search strategy."}, {"heading": "Acknowledgments", "text": "The authors thank Siegfried Nijssen, Anton Dries and Re'mi Coletta for the discussions on the topic and the reviewers for their valuable comments. This work was funded by the European Commission as part of the FP7-284715 \"Inductive Constraint Programming\" project and a postdoctoral fellowship from the Research Foundation Flander.Annex"}, {"heading": "A Branching with projected frequency", "text": "We only want to branch out over the symbols that still occur frequently in the projected sequences. If we take into account the current, partially assigned sequence, some transactions remain empty and others have only a subset of their original symbols left. For each propagator Ci \u2194 e s.t. ve Ti we keep the (monotonously decreasing) set of symbols for this transaction in a variable Xi. The propagator in algorithm 1 only needs one line addition, i.e. after line 12 we add the following: We multiply by removing from Xi all symbols that are not in < Ti [pose].. Ti [Xi |] > except for that, we remove all symbols from Xi that do not appear after the current prefix. First, the branch calculates the local frequency of each symbol over all Xi, and only branches over the frequent ones."}, {"heading": "B Decomposition with explicit embedding variables, modeling details", "text": "The decomposition consists of two limitations: the position restriction and the semi-embedding restriction. (...) The decomposition consists of two limitations: the position restriction and the semi-embedding restriction. (...) The decomposition consists of two limitations. (...) The decomposition consists of two limitations: the position restriction (...) and the semi-embedding restriction (...). (...) The decomposition... (...) \"[...) is. (...) The decomposition...\" (...) is. (...). (...) The decomposition is. (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...).). (...). (...). (...). (...). (...). (...). (...).). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...).). (...). (...). (...). (). (). (). (...). (). (). (). (). (). (). (). ().). (). ().). (). (). (). (). (). (). (). ().). (). ()."}, {"heading": "C Sub-search for the existence of a valid Ei", "text": "For each i transaction, we can independently search for a valid allocation of the egg variables. Once a valid one is found, the sub-search can stop and propagate the corresponding allocation to the Ci and egg variables of the master problem. The following pseudo-code describes how we implement this scheme as a branch in a copy solver (the implementation for a trailing solver is similar): Algorithm 3 Sub-Search Branches (C, E) 1: Substate \u2190 Copy of the current search state 2: do for all Ci 3: remove all other branches (e.g. add variable / value orders) 4: Add substate to add the variable / value orders that Ci = true before Ci = false 5: Add substate, as the next variable / value orders to search over all Eij variables in lexico graphical order, with the smallest order resolved first."}, {"heading": "D Projected frequency for explicit embedding variables", "text": "We introduced the following constraint specification:... n, x, Sj = x \u2192 | [i: Ci-Ti [Eij] = x] | \u2265 \u03b8 (19) A naive formulation of this expression would require the reification of an element constraint B-Ti [Eij] = x. Instead, we will create element constraints Ti [Eij] = Aij, where aijis is an auxiliary integer variable, resulting in the following more efficient reformulation:... n, j-Ti [Eij] = Aij (20)."}], "references": [{"title": "Mining sequential patterns", "author": ["R. Agrawal", "R. Srikant"], "venue": "Data Engineering, 1995. Proceedings of the Eleventh International Conference on. pp. 3\u201314. IEEE", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Fast algorithms for mining association rules in large database", "author": ["R. Agrawal", "R Srikant"], "venue": "Proc. 20th Int. Conf. Very Large Data Bases, VLDB. vol. 1215, pp. 487\u2013499", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1994}, {"title": "A sat-based approach for discovering frequent, closed and maximal patterns in a sequence", "author": ["E. Coquery", "S. Jabbour", "L. Sais", "Y. Salhi"], "venue": "European Conference on Artificial Intelligence (ECAI). p. 258\u2013263", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Predicting tryptic cleavage from proteomics data using decision tree ensembles", "author": ["T. Fannes", "E. Vandermarliere", "L. Schietgat", "S. Degroeve", "L. Martens", "J. Ramon"], "venue": "Journal of Proteome Research 12(5),", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Itemset mining: A constraint programming perspective", "author": ["T. Guns", "S. Nijssen", "L. De Raedt"], "venue": "Artificial Intelligence 175(12-13), 1951\u20131983", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Prefixspan: mining sequential patterns efficiently by prefix-projected pattern growth", "author": ["J. Han", "J. Pei", "B. Mortazavi-Asl", "H. Pinto", "Q. Chen", "U. Dayal", "M. Hsu"], "venue": "ICDE\u20192001, April pp. 215\u201324", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2001}, {"title": "Boolean satisfiability for sequence mining", "author": ["S. Jabbour", "L. Sais", "Y. Salhi"], "venue": "22nd International Conference on Information and Knowledge Management(CIKM\u201913). pp. 649\u2013658. ACM Press, San Francisco, CA, USA", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Mining relevant sequence patterns with cp-based framework", "author": ["A. Kemmar", "W. Ugarte", "S. Loudni", "T. Charnois", "Y. Lebbah", "P. Boizumault", "B. Cremilleux"], "venue": "Tools with Artificial Intelligence (ICTAI), 2013 IEEE 25th International Conference on. IEEE", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2014}, {"title": "Discovery of frequent episodes in event sequences", "author": ["H. Mannila", "H. Toivonen", "A. Inkeri Verkamo"], "venue": "Data Mining and Knowledge Discovery 1(3), 259\u2013289", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1997}, {"title": "A constraint programming approach for mining sequential patterns in a sequence database", "author": ["J.P. M\u00e9tivier", "S. Loudni", "T. Charnois"], "venue": "ECML/PKDD 2013 Workshop on Languages for Data Mining and Machine Learning", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "Dominance programming for itemset mining", "author": ["B. Negrevergne", "A. Dries", "T. Guns", "S. Nijssen"], "venue": "International Conference on Data Mining (ICDM)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Correlated itemset mining in ROC space: A constraint programming approach", "author": ["S. Nijssen", "T. Guns", "L. De Raedt"], "venue": "Flach, P., Zaki, M. (eds.) Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Paris, France, 28 June - 1 July 2009. pp. 647\u2013656. ACM Press", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}, {"title": "Efficient serial episode mining with minimal occurrences", "author": ["H. Ohtani", "T. Kida", "T. Uno", "H. Arimura", "H. Arimura"], "venue": "ICUIMC. pp. 457\u2013464", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Mining (soft-) skypatterns using dynamic CSP", "author": ["W.U. Rojas", "P. Boizumault", "S. Loudni", "B. Cr\u00e9milleux", "A. Lepailleur"], "venue": "Integration of AI and OR Techniques in Constraint Programming - 11th International Conference, CPAIOR 2014, Cork, Ireland, May 19-23, 2014. Proceedings. pp. 71\u201387", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2014}, {"title": "The long and the short of it: summarising event sequences with serial episodes", "author": ["N. Tatti", "J. Vreeken"], "venue": "KDD. pp. 462\u2013470", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Bide: Efficient mining of frequent closed sequences", "author": ["J. Wang", "J. Han"], "venue": "Data Engineering, 2004. Proceedings. 20th International Conference on. pp. 79\u201390. IEEE", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "Clospan: Mining closed sequential patterns in large datasets", "author": ["X. Yan", "J. Han", "R. Afshar"], "venue": "Proceedings of SIAM International Conference on Data Mining. pp. 166\u2013177", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}, {"title": "An efficient, versatile and scalable pattern growth approach to mine frequent patterns in unaligned protein sequences", "author": ["K. Ye", "W.A. Kosters", "A.P. IJzerman"], "venue": "Bioinformatics 23(6), 687\u2013693", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "Sequence mining in categorical domains: incorporating constraints", "author": ["M.J. Zaki"], "venue": "Proceedings of the ninth international conference on Information and knowledge management. pp. 422\u2013429. ACM", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2000}, {"title": "Spade: An efficient algorithm for mining frequent sequences", "author": ["M.J. Zaki"], "venue": "Machine Learning 42(1), 31\u201360", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2001}], "referenceMentions": [{"referenceID": 18, "context": "An important step in the development of more general approaches was the cSpade algorithm [19] which supports a variety constraints.", "startOffset": 89, "endOffset": 93}, {"referenceID": 5, "context": "[6,17,16,13]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 16, "context": "[6,17,16,13]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 15, "context": "[6,17,16,13]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 12, "context": "[6,17,16,13]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 4, "context": "For itemset mining, the simplest form of pattern mining, it has been shown that constraint programming (CP) can be used as a generic framework for constraint-based mining [5] and beyond [14,11].", "startOffset": 171, "endOffset": 174}, {"referenceID": 13, "context": "For itemset mining, the simplest form of pattern mining, it has been shown that constraint programming (CP) can be used as a generic framework for constraint-based mining [5] and beyond [14,11].", "startOffset": 186, "endOffset": 193}, {"referenceID": 10, "context": "For itemset mining, the simplest form of pattern mining, it has been shown that constraint programming (CP) can be used as a generic framework for constraint-based mining [5] and beyond [14,11].", "startOffset": 186, "endOffset": 193}, {"referenceID": 2, "context": "Recent works have also investigated the usage of CP-based approaches for mining sequences with explicit wildcards [3,7,8].", "startOffset": 114, "endOffset": 121}, {"referenceID": 6, "context": "Recent works have also investigated the usage of CP-based approaches for mining sequences with explicit wildcards [3,7,8].", "startOffset": 114, "endOffset": 121}, {"referenceID": 7, "context": "Recent works have also investigated the usage of CP-based approaches for mining sequences with explicit wildcards [3,7,8].", "startOffset": 114, "endOffset": 121}, {"referenceID": 7, "context": "But in case only few embeddings are possible, as in sequences with explicit wildcards, this can be done with a disjunctive constraint over all possible embeddings [8].", "startOffset": 163, "endOffset": 166}, {"referenceID": 5, "context": "\u2013 We introduce an exists-embedding global constraint for sequences, and show the relation to projected databases and projected frequency used in the sequence mining literature to speedup the mining process [6,20].", "startOffset": 206, "endOffset": 212}, {"referenceID": 19, "context": "\u2013 We introduce an exists-embedding global constraint for sequences, and show the relation to projected databases and projected frequency used in the sequence mining literature to speedup the mining process [6,20].", "startOffset": 206, "endOffset": 212}, {"referenceID": 0, "context": "Sequence mining [1] can be seen as a variation of the well-known itemset mining problem proposed in [2].", "startOffset": 16, "endOffset": 19}, {"referenceID": 1, "context": "Sequence mining [1] can be seen as a variation of the well-known itemset mining problem proposed in [2].", "startOffset": 100, "endOffset": 103}, {"referenceID": 5, "context": "Regular expression constraints: Let R be a regular expression over the vocabulary V and LR be the language of sequences recognised by R, then for any sequence pattern S over V , the match-regular constraint requires that S \u2208 LR [6].", "startOffset": 228, "endOffset": 231}, {"referenceID": 11, "context": "Other examples include more statistical measures such as information gain and entropy [12].", "startOffset": 86, "endOffset": 90}, {"referenceID": 18, "context": "The max-gap and max-span constraints [19] impose a restriction on the embedding, and hence on the inclusion relation.", "startOffset": 37, "endOffset": 41}, {"referenceID": 10, "context": "In [11] it was shown that condensed representations like closed, maximal and free patterns can be expressed as pairwise preference relations.", "startOffset": 3, "endOffset": 7}, {"referenceID": 13, "context": "Skypatterns [14] and multi-objective optimisation can also be seen as preference over patterns.", "startOffset": 12, "endOffset": 16}, {"referenceID": 7, "context": "Hence, one can not model this as a disjunctive constraint over all possible embeddings (as is done for sequences with explicit wildcards [8]).", "startOffset": 137, "endOffset": 140}, {"referenceID": 5, "context": "If one would project the prefix away, only the symbols in the transaction from pose on would remain; this is known as prefix projection [6].", "startOffset": 136, "endOffset": 139}, {"referenceID": 5, "context": "This is known to speed up specialised mining algorithms considerably [6,16].", "startOffset": 69, "endOffset": 75}, {"referenceID": 15, "context": "This is known to speed up specialised mining algorithms considerably [6,16].", "startOffset": 69, "endOffset": 75}, {"referenceID": 10, "context": "preference relations have been proposed in [11] to formalise well-known pattern mining settings such as maximal or closed patterns.", "startOffset": 43, "endOffset": 47}, {"referenceID": 10, "context": "Such preference relations can be enforced dynamically during search for any CP formulation [11].", "startOffset": 91, "endOffset": 95}, {"referenceID": 18, "context": "We compare our global and decomposed models (Section 4 and Section 5) to the state-of-the-art algorithms cSpade[19] and PrefixSpan [6].", "startOffset": 111, "endOffset": 115}, {"referenceID": 5, "context": "We compare our global and decomposed models (Section 4 and Section 5) to the state-of-the-art algorithms cSpade[19] and PrefixSpan [6].", "startOffset": 131, "endOffset": 134}, {"referenceID": 9, "context": "We also compare our models to the CP-based approach proposed by [10].", "startOffset": 64, "endOffset": 68}, {"referenceID": 3, "context": "is a proteomics dataset from the application described in [4]; each transaction is a sequence of peptides that is known to cleave in presence of a Trypsin enzyme.", "startOffset": 58, "endOffset": 61}, {"referenceID": 0, "context": "[1] shortly after their well-known work on frequent itemset mining [2].", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[1] shortly after their well-known work on frequent itemset mining [2].", "startOffset": 67, "endOffset": 70}, {"referenceID": 0, "context": "The problem introduced in [1] consisted of finding frequent sequences of itemsets; that is: sequences of sets included in a database of sequences of sets.", "startOffset": 26, "endOffset": 29}, {"referenceID": 8, "context": "Mining sequences of individual symbols was introduced later by [9]; the two problems are closely related and one can adapt one to the other [16].", "startOffset": 63, "endOffset": 66}, {"referenceID": 15, "context": "Mining sequences of individual symbols was introduced later by [9]; the two problems are closely related and one can adapt one to the other [16].", "startOffset": 140, "endOffset": 144}, {"referenceID": 17, "context": "[18]), or natural language processing where sentences can be represented as sequences of words (e.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "The cSpade algorithm [19] for example is an extension of the Spade sequence mining algorithm [20] that supports constraints of type 1, 2 and 3.", "startOffset": 21, "endOffset": 25}, {"referenceID": 19, "context": "The cSpade algorithm [19] for example is an extension of the Spade sequence mining algorithm [20] that supports constraints of type 1, 2 and 3.", "startOffset": 93, "endOffset": 97}, {"referenceID": 5, "context": "PrefixSpan [6] mentions regular expression constraints too.", "startOffset": 11, "endOffset": 14}, {"referenceID": 12, "context": "The LCMseq algorithm [13] also supports a range of constraints, but does not consider all embeddings during search.", "startOffset": 21, "endOffset": 25}, {"referenceID": 16, "context": "CloSpan [17] and Bide [16] are both extentions of Pre-", "startOffset": 8, "endOffset": 12}, {"referenceID": 15, "context": "CloSpan [17] and Bide [16] are both extentions of Pre-", "startOffset": 22, "endOffset": 26}, {"referenceID": 10, "context": "We could do the same in our CP approach by adding constraints after each solution found, following [11,8].", "startOffset": 99, "endOffset": 105}, {"referenceID": 7, "context": "We could do the same in our CP approach by adding constraints after each solution found, following [11,8].", "startOffset": 99, "endOffset": 105}, {"referenceID": 2, "context": "In [3] the setting of sequence patterns with explicit wildcards in a single sequence is studied: such a pattern has a linear number of embeddings.", "startOffset": 3, "endOffset": 6}, {"referenceID": 6, "context": "This is extended in [7] to sequences of itemsets (with explicit wildcards over a single sequence).", "startOffset": 20, "endOffset": 23}, {"referenceID": 7, "context": "[8] also studies patterns with explicit wildcards, but in a database of sequences.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "Finally, [10] considers standard sequences in a database, just like this paper; they also support constraints of type 3.", "startOffset": 9, "endOffset": 13}, {"referenceID": 5, "context": "We were able to use the same projected frequency technique as well-studied algorithms such as PrefixSpan [6], by altering the global exists-embedding constraint and using a specialised search strategy.", "startOffset": 105, "endOffset": 108}], "year": 2015, "abstractText": "The goal of constraint-based sequence mining is to find sequences of symbols that are included in a large number of input sequences and that satisfy some constraints specified by the user. Many constraints have been proposed in the literature, but a general framework is still missing. We investigate the use of constraint programming as general framework for this task. We first identify four categories of constraints that are applicable to sequence mining. We then propose two constraint programming formulations. The first formulation introduces a new global constraint called exists-embedding. This formulation is the most efficient but does not support one type of constraint. To support such constraints, we develop a second formulation that is more general but incurs more overhead. Both formulations can use the projected database technique used in specialised algorithms. Experiments demonstrate the flexibility towards constraint-based settings and compare the approach to existing methods.", "creator": "LaTeX with hyperref package"}}}