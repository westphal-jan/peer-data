{"id": "1501.05222", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Jan-2015", "title": "Plug-and-play dual-tree algorithm runtime analysis", "abstract": "Numerous machine learning algorithms contain pairwise statistical problems at their core---that is, tasks that require computations over all pairs of input points if implemented naively. Often, tree structures are used to solve these problems efficiently. Dual-tree algorithms can efficiently solve or approximate many of these problems. Using cover trees, rigorous worst-case runtime guarantees have been proven for some of these algorithms. In this paper, we present a problem-independent runtime guarantee for any dual-tree algorithm using the cover tree, separating out the problem-dependent and the problem-independent elements. This allows us to just plug in bounds for the problem-dependent elements to get runtime guarantees for dual-tree algorithms for any pairwise statistical problem without re-deriving the entire proof. We demonstrate this plug-and-play procedure for nearest-neighbor search and approximate kernel density estimation to get improved runtime guarantees. Under mild assumptions, we also present the first linear runtime guarantee for dual-tree based range search.", "histories": [["v1", "Wed, 21 Jan 2015 16:39:43 GMT  (44kb)", "http://arxiv.org/abs/1501.05222v1", "Submitted to JMLR"]], "COMMENTS": "Submitted to JMLR", "reviews": [], "SUBJECTS": "cs.DS cs.LG", "authors": ["ryan r curtin", "dongryeol lee", "william b march", "parikshit ram"], "accepted": false, "id": "1501.05222"}, "pdf": {"name": "1501.05222.pdf", "metadata": {"source": "CRF", "title": "Plug-and-play dual-tree algorithm runtime analysis", "authors": ["Ryan R. Curtin", "Dongryeol Lee"], "emails": ["ryan@ratml.org", "drselee@gmail.com", "march@ices.utexas.edu", "p.ram@gatech.edu"], "sections": [{"heading": null, "text": "ar Xiv: 150 1.05 222v 1Keywords: dual tree algorithms, branch and boundary search, search for nearest neighbour, nuclear density estimate, range search"}, {"heading": "1. Dual-tree algorithms", "text": "It is not only a matter of time, but also of the time in which we have to deal with the question of the future of humanity. (...) It is also a question of time in which we have to concern ourselves with the future of humanity. (...) It is a question of time in which we have to concern ourselves with the future of humanity. (...) It is a question of time in which we have to concern ourselves with the future of humanity. (...) It is a question of time in which we have to concern ourselves with the future of humanity. (...) It is a question of time in which we have to concern ourselves with the future of the world. \"(...) It is a question of time in which we have to concern ourselves with the future of the world and with the future of the world and with the world.\" (...) It is a question of time in which we have to concern ourselves with the future and the future of the world and with the future. (...)"}, {"heading": "2. Preliminaries", "text": "For the sake of simplicity, the algorithms considered in this paper are presented in a tree-independent context, as in Curtin et al. (2013b), but the only tree species we will consider is the deck tree (Beygelzimer et al., 2006), and the only type of crossing we will consider is the deck tree pruning, which we will describe later. As we will make heavy use of trees, we will have to create a notation (taken from Curtin et al., 2013b). The notation we will use is defined in Table 1."}, {"heading": "2.1 The cover tree", "text": "The deck tree is a leveled hierarchical data structure originally proposed for the task of the closest neighbor search (by Beygelzimer et al. (2006). Each node Ni in the deck tree is associated with a single dot pi. An adequate description is therefore given in their work (we have slightly adapted the notation): A deck tree T on a record S is a leveled tree where each level is a \"cover\" for the level below it. Each level is indexed by an integer scale si, which decreases as the tree descends. Each node in the tree is associated with a dot in S. Each dot in S can be associated with several nodes in the tree; however, we require that each dot in each level appear once. Let Csi associate the set of dots in S with the nodes at level si si. The deck tree obeys the following inventors for all si: \u2022 (nesting)."}, {"heading": "2.2 Expansion constant", "text": "The explicit representation of a deck tree has a number of useful theoretical properties based on the expansion constant (Karger and Ruhl, 2002); we are redefining its definition. (It is) the expansion constant of S in relation to the smallest C in relation to the smallest C in relation to a metric D: BS (p, 2). (It is) the expansion constant of S in relation to the smallest C in relation to the smallest C: BS (p, 2). (It is) the expansion constant of S in relation to the smallest C: BS (p, 2). (It is) the expansion constant of S in a sense an idea of instrine dimensionality, and previous work has shown that there are many scenarios in which c is independent of the number of points in the dataset (Karger and Ruhl, 2002). (It is) an idea of instrine dimensionality, c and previous work has shown that there are many scenarios independent of those in the number of dataset."}, {"heading": "3. Tree imbalance", "text": "It is known that the imbalance in the trees leads to a degradation in performance; for example, that a kd-tree node with each descending tree in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the way in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the manner in which he is in the way in which he is in the way in which he is in the way in which he is in the way in which he is in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he in the way in the way in which he is in the way in the way in which he is in the way in the way in which he in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in the way in which he is in the way in which he is in the way in which he is in the way in the way in the way in which he is in the way in which he is in the way in which he is in the way in the way in which he is in the way in which he is in the way in the way in the way in the way in which he is in the way in which he is in the way in which he is in the way in the way in the way in the way in which he is in the way in which he is in the way in the way in"}, {"heading": "4. General runtime bound", "text": "Perhaps more interesting than the scales of a dual tree structure is the way in which the trees are actually used in dual tree algorithms. (Although the cover trees were originally intended for the closest tree search), it is possible that they can be adapted to a variety of problems. (Although the cover trees were originally intended for the closest tree search (March et al., 2010), the approximate closest tree algorithm search (Ram et al., 2009b), other existing dual tree algorithms can be easily adapted for use with cover trees. (Within the framework of tree-independent dual tree algorithms, all that is needed to describe a dual tree algorithm). (Other existing dual tree algorithms can be easily adapted for use with cover trees). (Within the framework of tree-independent dual tree algorithms, all that is necessary to describe a point-base case)."}, {"heading": "5. Nearest neighbor search", "text": "The default problem of the closest neighbor search can be easily described: faced with a query set Sq and a reference set Sq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query pq, faced with each query pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pr, faced with each reference point pr, faced with each reference point pr, faced with each query pr, faced with each algorithm pr, faced with each query pq, faced with each query pq, faced with each query pr, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq, faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq faced with each query point pq, faced with each query point pq faced with each query point pq faced with each query point pq, faced with each query point pq faced with a query point pq faced with each query point pq faced with a query, faced with each query point pq, faced with each query point pq"}, {"heading": "6. Approximate kernel density estimation", "text": "It is not only the question of whether it is a problem, but also the question of whether it is a problem that should be looked at on the basis of the characteristics of the kernel. It is also the question of whether it is a problem that should be looked at on the basis of assumptions. It is the question of whether it is a problem that should be looked at on the basis of assumptions. It is the question of whether it is a problem that should be looked at on the basis of assumptions. It is the question of whether it should be a problem. It is the question of whether it should be a problem. It is the question of whether it should be a problem. It is the question of whether it should be a problem."}, {"heading": "6.1 Absolute value approximation", "text": "The fp list provides an initial kernel density for each query point, and the fn list is initialized to 0 if the difference is between the maximum kernel value K (dmin) and the minimum kernel value K (Nq, Nr) and the minimum kernel value K (dmax, Nr)."}, {"heading": "6.2 Relative Value Approximation", "text": "This is the same strategy as Ram et al. (2009a). First, we need to establish a score () function for the relative value approximation (max.). The difference between equations 27 and 28 is the division by the term \"f\" (pq). But we can quickly approach the value \"f\" (pq). (f) Then we need to establish a score () function for the relative value approximation (pq). (4) This is clearly true: Every point in Sr must contribute more than K (maxpr). (pq, pr))."}, {"heading": "7. Range search and range count", "text": "In the area of search, the task is to find the reference points that are sufficiently large for each point of the search, then we will focus on the area of search. The scope problem is practically identical, but only the size of the area in which the number of search terms is located is desirable. Our proof for both of these algorithms is similar, but we will focus on the area of search. A BaseCase () and Score () function are given in algorithms 7 and 8, respectively (a proof of correctness can be found in Curtin et al., 2013b. The sentences N [pq] are used at the beginning of the transversal. To limit the duration of the dual tree search, we need better terms for understanding the difficulty of the problem."}, {"heading": "8. Conclusion", "text": "We have presented a unified framework for limiting the runtimes of dual-tree algorithms that use cover trees and the standard Dual-Tree Traversal (algorithm 1). In order to create an understandable limit, we have introduced the concept of cover tree imbalance; one possible interesting direction for future work is to minimize this amount empirically and theoretically through modified tree tree tree tree algorithms; this should provide both narrower runtime limits and accelerated empirical results. Our main result, Theorem 1, allows plug-and-play runtime limitation of these algorithms. We have shown that Theorem 1 is useful for limiting the runtime of the search for the closest neighbor (Theorem 2), estimating approximate core density (Theorem 3), the exact range number, and the exact range search (Theorem 5)."}], "references": [{"title": "Variational dual-tree framework for largescale transition matrix approximation", "author": ["S. Amizadeh", "B. Thiesson", "M. Hauskrecht"], "venue": "In Proceedings of the Twenty-Eighth Annual Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Amizadeh et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Amizadeh et al\\.", "year": 2012}, {"title": "Cover trees for nearest neighbor", "author": ["A. Beygelzimer", "S.M. Kakade", "J. Langford"], "venue": "In Proceedings of the 23rd International Conference on Machine Learning (ICML", "citeRegEx": "Beygelzimer et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Beygelzimer et al\\.", "year": 2006}, {"title": "Review of \u2018Phylogenetics: The Theory and Practice of Phylogenetic Systematics\u2019, by E.O", "author": ["D.H. Colless"], "venue": "Wiley. Systematic Zoology,", "citeRegEx": "Colless.,? \\Q1982\\E", "shortCiteRegEx": "Colless.", "year": 1982}, {"title": "Dual-tree fast exact max-kernel search", "author": ["R.R. Curtin", "P. Ram"], "venue": "Statistical Analysis and Data Mining,", "citeRegEx": "Curtin and Ram.,? \\Q2014\\E", "shortCiteRegEx": "Curtin and Ram.", "year": 2014}, {"title": "MLPACK: A scalable C++ machine learning library", "author": ["R.R. Curtin", "J.R. Cline", "N.P. Slagle", "W.B. March", "P. Ram", "N.A. Mehta", "A.G. Gray"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Curtin et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Curtin et al\\.", "year": 2013}, {"title": "Treeindependent dual-tree algorithms", "author": ["R.R. Curtin", "W.B. March", "P. Ram", "D.V. Anderson", "A.G. Gray", "C.L. Isbell Jr."], "venue": "In Proceedings of The 30th International Conference on Machine Learning (ICML", "citeRegEx": "Curtin et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Curtin et al\\.", "year": 2013}, {"title": "Fast exact max-kernel search", "author": ["R.R. Curtin", "P. Ram", "A.G. Gray"], "venue": "In Proceedings of the 13th SIAM International Conference on Data Mining (SDM", "citeRegEx": "Curtin et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Curtin et al\\.", "year": 2013}, {"title": "Quad trees a data structure for retrieval on composite keys", "author": ["R.A. Finkel", "J.L. Bentley"], "venue": "Acta Informatica,", "citeRegEx": "Finkel and Bentley.,? \\Q1974\\E", "shortCiteRegEx": "Finkel and Bentley.", "year": 1974}, {"title": "N-body problems in statistical learning", "author": ["A.G. Gray", "A.W. Moore"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Gray and Moore.,? \\Q2000\\E", "shortCiteRegEx": "Gray and Moore.", "year": 2000}, {"title": "Nonparametric density estimation: Toward computational tractability", "author": ["A.G. Gray", "A.W. Moore"], "venue": "In Proceedings of the 3rd SIAM International Conference on Data Mining (SDM", "citeRegEx": "Gray and Moore.,? \\Q2003\\E", "shortCiteRegEx": "Gray and Moore.", "year": 2003}, {"title": "Finding nearest neighbors in growth-restricted metrics", "author": ["D.R. Karger", "M. Ruhl"], "venue": "In Proceedings of the Thirty-Fourth Annual ACM Symposium on Theory of Computing (STOC", "citeRegEx": "Karger and Ruhl.,? \\Q2002\\E", "shortCiteRegEx": "Karger and Ruhl.", "year": 2002}, {"title": "Fast particle smoothing: if I had a million particles", "author": ["M. Klaas", "M. Briers", "N. De Freitas", "A. Doucet", "S. Maskell", "D. Lang"], "venue": "In Proceedings of the 23rd International Conference on Machine Learning (ICML", "citeRegEx": "Klaas et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Klaas et al\\.", "year": 2006}, {"title": "Navigating nets: simple algorithms for proximity search", "author": ["R. Krauthgamer", "J.R. Lee"], "venue": "In Proceedings of the Fifteenth Annual ACM-SIAM Symposium on Discrete Algorithms", "citeRegEx": "Krauthgamer and Lee.,? \\Q2004\\E", "shortCiteRegEx": "Krauthgamer and Lee.", "year": 2004}, {"title": "Faster Gaussian summation: Theory and Experiment", "author": ["D. Lee", "A.G. Gray"], "venue": "In Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Lee and Gray.,? \\Q2006\\E", "shortCiteRegEx": "Lee and Gray.", "year": 2006}, {"title": "Fast high-dimensional kernel summations using the monte carlo multipole method", "author": ["D. Lee", "A.G. Gray"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Lee and Gray.,? \\Q2008\\E", "shortCiteRegEx": "Lee and Gray.", "year": 2008}, {"title": "Multi-tree algorithms for computational statistics and physics", "author": ["W.B. March"], "venue": "PhD thesis, Georgia Institute of Technology,", "citeRegEx": "March.,? \\Q2013\\E", "shortCiteRegEx": "March.", "year": 2013}, {"title": "Fast Euclidean minimum spanning tree: algorithm, analysis, and applications", "author": ["W.B. March", "P. Ram", "A.G. Gray"], "venue": "In Proceedings of the 16th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD", "citeRegEx": "March et al\\.,? \\Q2010\\E", "shortCiteRegEx": "March et al\\.", "year": 2010}, {"title": "Fast algorithms for comprehensive n-point correlation estimates", "author": ["W.B. March", "A.J. Connolly", "A.G. Gray"], "venue": "In Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD", "citeRegEx": "March et al\\.,? \\Q2012\\E", "shortCiteRegEx": "March et al\\.", "year": 2012}, {"title": "The Anchors hierarchy: Using the triangle inequality to survive high dimensional data", "author": ["A.W. Moore"], "venue": "In Proceedings of the Sixteenth Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Moore.,? \\Q2000\\E", "shortCiteRegEx": "Moore.", "year": 2000}, {"title": "Fast Gaussian process posteriors with product trees", "author": ["D.A. Moore", "S.J. Russell"], "venue": "In Proceedings of the Thirtieth Conference on Uncertainty in Artificial Intelligence (UAI14),", "citeRegEx": "Moore and Russell.,? \\Q2014\\E", "shortCiteRegEx": "Moore and Russell.", "year": 2014}, {"title": "Linear-time algorithms for pairwise statistical problems", "author": ["P. Ram", "D. Lee", "W.B. March", "A.G. Gray"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Ram et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ram et al\\.", "year": 2009}, {"title": "Rank-approximate nearest neighbor search: Retaining meaning and speed in high dimensions", "author": ["P. Ram", "D. Lee", "H. Ouyang", "A.G. Gray"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Ram et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ram et al\\.", "year": 2009}, {"title": "Accelerating t-sne using tree-based algorithms", "author": ["L. Van Der Maaten"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Maaten.,? \\Q2014\\E", "shortCiteRegEx": "Maaten.", "year": 2014}, {"title": "Fast mean shift with accurate and stable convergence", "author": ["P. Wang", "D. Lee", "A.G. Gray", "J.M. Rehg"], "venue": "In Proceedings of the Eleventh International Conference on Artificial Intelligence and Statistics (AISTATS", "citeRegEx": "Wang et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2007}], "referenceMentions": [{"referenceID": 7, "context": "The reference set is typically indexed with spatial data structures to accelerate this type of computation (Finkel and Bentley, 1974; Beygelzimer et al., 2006); these result in O(logN) runtime per query under favorable conditions.", "startOffset": 107, "endOffset": 159}, {"referenceID": 1, "context": "The reference set is typically indexed with spatial data structures to accelerate this type of computation (Finkel and Bentley, 1974; Beygelzimer et al., 2006); these result in O(logN) runtime per query under favorable conditions.", "startOffset": 107, "endOffset": 159}, {"referenceID": 9, "context": "There exist numerous dual-tree algorithms for problems as diverse as kernel density estimation (Gray and Moore, 2003), mean shift (Wang et al.", "startOffset": 95, "endOffset": 117}, {"referenceID": 23, "context": "There exist numerous dual-tree algorithms for problems as diverse as kernel density estimation (Gray and Moore, 2003), mean shift (Wang et al., 2007), minimum spanning tree calculation (March et al.", "startOffset": 130, "endOffset": 149}, {"referenceID": 16, "context": ", 2007), minimum spanning tree calculation (March et al., 2010), n-point correlation function estimation (March et al.", "startOffset": 43, "endOffset": 63}, {"referenceID": 17, "context": ", 2010), n-point correlation function estimation (March et al., 2012), max-kernel search (Curtin et al.", "startOffset": 49, "endOffset": 69}, {"referenceID": 11, "context": ", 2013c), particle smoothing (Klaas et al., 2006), variational inference (Amizadeh et al.", "startOffset": 29, "endOffset": 49}, {"referenceID": 0, "context": ", 2006), variational inference (Amizadeh et al., 2012), range search (Gray and Moore, 2001), and embedding techniques Van Der Maaten (2014), to name a few.", "startOffset": 31, "endOffset": 54}, {"referenceID": 1, "context": "Some of these algorithms are derived using the cover tree (Beygelzimer et al., 2006), a data structure with compelling theoretical qualities.", "startOffset": 58, "endOffset": 84}, {"referenceID": 16, "context": ", 2009a); minimum spanning tree calculation scales as O(N logN) (March et al., 2010).", "startOffset": 64, "endOffset": 84}, {"referenceID": 3, "context": "Other problems have similar worst-case guarantees (Curtin and Ram, 2014; March, 2013).", "startOffset": 50, "endOffset": 85}, {"referenceID": 15, "context": "Other problems have similar worst-case guarantees (Curtin and Ram, 2014; March, 2013).", "startOffset": 50, "endOffset": 85}, {"referenceID": 0, "context": "The reference set is typically indexed with spatial data structures to accelerate this type of computation (Finkel and Bentley, 1974; Beygelzimer et al., 2006); these result in O(logN) runtime per query under favorable conditions. Building upon this intuition, Gray and Moore (2001) generalized the fast multipole method from computational physics to obtain dual-tree algorithms.", "startOffset": 134, "endOffset": 283}, {"referenceID": 0, "context": "The reference set is typically indexed with spatial data structures to accelerate this type of computation (Finkel and Bentley, 1974; Beygelzimer et al., 2006); these result in O(logN) runtime per query under favorable conditions. Building upon this intuition, Gray and Moore (2001) generalized the fast multipole method from computational physics to obtain dual-tree algorithms. These are extremely useful when there are large query sets, not just a few query points. Instead of building a tree on the reference set and searching with each query point separately, Gray and Moore suggest also building a query tree and traversing both the query and reference trees simultaneously (a dual-tree traversal, from which the class of algorithms takes its name). Dual-tree algorithms can be easily understood through the recent framework of Curtin et al. (2013b): two trees (a query tree and a reference tree) are traversed by a pruning dual-tree traversal.", "startOffset": 134, "endOffset": 856}, {"referenceID": 0, "context": ", 2006), variational inference (Amizadeh et al., 2012), range search (Gray and Moore, 2001), and embedding techniques Van Der Maaten (2014), to name a few.", "startOffset": 32, "endOffset": 140}, {"referenceID": 0, "context": ", 2006), variational inference (Amizadeh et al., 2012), range search (Gray and Moore, 2001), and embedding techniques Van Der Maaten (2014), to name a few. Some of these algorithms are derived using the cover tree (Beygelzimer et al., 2006), a data structure with compelling theoretical qualities. When cover trees are used, Dual-tree all-nearest-neighbor search and approximate kernel density estimation have O(N) runtime guarantees for O(N) queries (Ram et al., 2009a); minimum spanning tree calculation scales as O(N logN) (March et al., 2010). Other problems have similar worst-case guarantees (Curtin and Ram, 2014; March, 2013). In this work we combine the generalization of Curtin et al. (2013b) with the theoretical results of Beygelzimer et al.", "startOffset": 32, "endOffset": 703}, {"referenceID": 0, "context": ", 2006), variational inference (Amizadeh et al., 2012), range search (Gray and Moore, 2001), and embedding techniques Van Der Maaten (2014), to name a few. Some of these algorithms are derived using the cover tree (Beygelzimer et al., 2006), a data structure with compelling theoretical qualities. When cover trees are used, Dual-tree all-nearest-neighbor search and approximate kernel density estimation have O(N) runtime guarantees for O(N) queries (Ram et al., 2009a); minimum spanning tree calculation scales as O(N logN) (March et al., 2010). Other problems have similar worst-case guarantees (Curtin and Ram, 2014; March, 2013). In this work we combine the generalization of Curtin et al. (2013b) with the theoretical results of Beygelzimer et al. (2006) and others in order to develop a worst-case runtime bound for any dual-tree algorithm when the cover tree is used.", "startOffset": 32, "endOffset": 761}, {"referenceID": 4, "context": "See Curtin et al. (2013b) for details.", "startOffset": 4, "endOffset": 26}, {"referenceID": 1, "context": "(2013b), but the only type of tree we will consider is the cover tree (Beygelzimer et al., 2006), and the only type of traversal we will consider is the cover tree pruning dual-tree traversal, which we will describe later.", "startOffset": 70, "endOffset": 96}, {"referenceID": 3, "context": "For simplicity, the algorithms considered in this paper will be presented in a tree-independent context, as in Curtin et al. (2013b), but the only type of tree we will consider is the cover tree (Beygelzimer et al.", "startOffset": 111, "endOffset": 133}, {"referenceID": 1, "context": "The cover tree is a leveled hierarchical data structure originally proposed for the task of nearest neighbor search by Beygelzimer et al. (2006). Each node Ni in the cover tree is associated with a single point pi.", "startOffset": 119, "endOffset": 145}, {"referenceID": 1, "context": "Beygelzimer et al. (2006) find this representation (which they call the implicit representation) easier for description of their algorithms and some of their proofs.", "startOffset": 0, "endOffset": 26}, {"referenceID": 10, "context": "The explicit representation of a cover tree has a number of useful theoretical properties based on the expansion constant (Karger and Ruhl, 2002); we restate its definition below.", "startOffset": 122, "endOffset": 145}, {"referenceID": 10, "context": "It is, in some sense, a notion of instrinic dimensionality, and previous work has shown that there are many scenarios where c is independent of the number of points in the dataset (Karger and Ruhl, 2002; Beygelzimer et al., 2006; Krauthgamer and Lee, 2004; Ram et al., 2009a).", "startOffset": 180, "endOffset": 275}, {"referenceID": 1, "context": "It is, in some sense, a notion of instrinic dimensionality, and previous work has shown that there are many scenarios where c is independent of the number of points in the dataset (Karger and Ruhl, 2002; Beygelzimer et al., 2006; Krauthgamer and Lee, 2004; Ram et al., 2009a).", "startOffset": 180, "endOffset": 275}, {"referenceID": 12, "context": "It is, in some sense, a notion of instrinic dimensionality, and previous work has shown that there are many scenarios where c is independent of the number of points in the dataset (Karger and Ruhl, 2002; Beygelzimer et al., 2006; Krauthgamer and Lee, 2004; Ram et al., 2009a).", "startOffset": 180, "endOffset": 275}, {"referenceID": 1, "context": "Closed-form solutions for cf for more complex distributions are less easy to derive; however, empirical speedup results from Beygelzimer et al. (2006) suggest the existence of datasets where c is not strongly dependent on d.", "startOffset": 125, "endOffset": 151}, {"referenceID": 1, "context": "A batch construction algorithm is given by Beygelzimer et al. (2006), called Construct.", "startOffset": 43, "endOffset": 69}, {"referenceID": 1, "context": "1, Beygelzimer et al. (2006)).", "startOffset": 3, "endOffset": 29}, {"referenceID": 1, "context": "1, Beygelzimer et al. (2006)). \u2022 Depth bound: the maximum depth of any node isO(c2 logN) (Lemma 4.3, Beygelzimer et al. (2006)).", "startOffset": 3, "endOffset": 127}, {"referenceID": 1, "context": "\u2022 Space bound: a cover tree has O(N) nodes (Theorem 1, Beygelzimer et al. (2006)).", "startOffset": 55, "endOffset": 81}, {"referenceID": 1, "context": "Lastly, we introduce a convenience lemma of our own which is a generalization of the packing arguments used by Beygelzimer et al. (2006). This is a more flexible version of their argument.", "startOffset": 111, "endOffset": 137}, {"referenceID": 1, "context": "1 in Beygelzimer et al. (2006). Consider two cases: first, let d(p, pi) > \u03c1\u03b4 for any pi \u2208 S.", "startOffset": 5, "endOffset": 31}, {"referenceID": 2, "context": "Numerous measures of tree imbalance have already been established; one example is that proposed by Colless (1982), and another is Sackin\u2019s index (Sackin, 1972), but we aim to capture a different measure of imbalance that utilizes the leveled structure of the cover tree.", "startOffset": 99, "endOffset": 114}, {"referenceID": 1, "context": ", 2013a) and the reference implementation (Beygelzimer et al., 2006), the tree imbalance is near-linear with the number of points.", "startOffset": 42, "endOffset": 68}, {"referenceID": 16, "context": ", 2006), they can be adapted to a wide variety of problems: minimum spanning tree calculation (March et al., 2010), approximate nearest neighbor search (Ram et al.", "startOffset": 94, "endOffset": 114}, {"referenceID": 19, "context": ", 2009b), Gaussian processes posterior calculation (Moore and Russell, 2014), and max-kernel search (Curtin and Ram, 2014) are some examples.", "startOffset": 51, "endOffset": 76}, {"referenceID": 3, "context": ", 2009b), Gaussian processes posterior calculation (Moore and Russell, 2014), and max-kernel search (Curtin and Ram, 2014) are some examples.", "startOffset": 100, "endOffset": 122}, {"referenceID": 1, "context": "Although cover trees were originally intended for nearest neighbor search (See Algorithm Find-All-Nearest, Beygelzimer et al., 2006), they can be adapted to a wide variety of problems: minimum spanning tree calculation (March et al., 2010), approximate nearest neighbor search (Ram et al., 2009b), Gaussian processes posterior calculation (Moore and Russell, 2014), and max-kernel search (Curtin and Ram, 2014) are some examples. Further, through the tree-independent dual-tree algorithm abstraction of Curtin et al. (2013b), other existing dual-tree algorithms can easily be adapted for use with cover trees.", "startOffset": 107, "endOffset": 525}, {"referenceID": 1, "context": "Although cover trees were originally intended for nearest neighbor search (See Algorithm Find-All-Nearest, Beygelzimer et al., 2006), they can be adapted to a wide variety of problems: minimum spanning tree calculation (March et al., 2010), approximate nearest neighbor search (Ram et al., 2009b), Gaussian processes posterior calculation (Moore and Russell, 2014), and max-kernel search (Curtin and Ram, 2014) are some examples. Further, through the tree-independent dual-tree algorithm abstraction of Curtin et al. (2013b), other existing dual-tree algorithms can easily be adapted for use with cover trees. In the framework of tree-independent dual-tree algorithms, all that is necessary to describe a dual-tree algorithm is a point-to-point base case function (BaseCase()) and a node-to-node pruning rule (Score()). These functions, which are often very straightforward, are then paired with a type of tree and a pruning dual-tree traversal to produce a working algorithm. In later sections, we will consider specific examples. When using cover trees, the typical pruning dual-tree traversal is an adapted form of the original nearest neighbor search algorithm (see Find-All-Nearest, Beygelzimer et al., 2006); this traversal is implemented in both the cover tree reference implementation and in the more flexible mlpack library (Curtin et al., 2013a). The problem-independent traversal is given in Algorithm 1 and was originally presented by Curtin and Ram (2014). Initially, it is called with the root of the query tree and a reference set R containing only the root of the reference tree.", "startOffset": 107, "endOffset": 1469}, {"referenceID": 18, "context": "\u03c7 \u223c \u03c8 \u223c O(1); often, cached sufficient statistics (Moore, 2000) can enable O(1) runtime implementations of BaseCase() and Score().", "startOffset": 50, "endOffset": 63}, {"referenceID": 17, "context": "\u03c7 \u223c \u03c8 \u223c O(1); often, cached sufficient statistics (Moore, 2000) can enable O(1) runtime implementations of BaseCase() and Score(). These results hold for any dual-tree algorithm regardless of the problem. Hence, the runtime of any dual-tree algorithm would be at least O(N) using our bound, which matches the intuition that answering O(N) queries would take at least O(N) time. For a particular problem and data, if cr, |R \u2217|, \u03c7, \u03c8 are bounded by constants independent of N and \u03b8 is no more than linear in N (for large enough N), then the dual-tree algorithm for that problem has a runtime linear in N . Our theoretical result separates out the problem-dependent and the problem-independent elements of the runtime bound, which allows us to simply plug in the problem-dependent bounds in order to get runtime bounds for any dual-tree algorithm without requiring an analysis from scratch. Our results are similar to that of Ram et al. (2009a), but those results depend on a quantity called the constant of bichromaticity, denoted \u03ba, which has unclear relation to cover tree imbalance.", "startOffset": 51, "endOffset": 942}, {"referenceID": 3, "context": "The more recent results of Curtin and Ram (2014) are more related to these results, but they depend on the inverse constant of bichromaticity \u03bd which suffers from the same problem as \u03ba.", "startOffset": 27, "endOffset": 49}, {"referenceID": 3, "context": "The more recent results of Curtin and Ram (2014) are more related to these results, but they depend on the inverse constant of bichromaticity \u03bd which suffers from the same problem as \u03ba. Although the dependence on \u03bd is linear (that is, O(\u03bdN)), bounding \u03bd is difficult and it is not true that \u03bd = 1 in the monochromatic case. \u03bd corresponds to the maximum number of reference recursions between a single query recursion, and \u03ba corresponds to the maximum number of query recursions between a single reference recursion. The respective proofs that use these constants then apply them as a worst-case measure for the whole algorithm: when using \u03ba, Ram et al. (2009a) assume that every reference recursion may be followed by \u03ba query recursions; similarly, Curtin and Ram (2014) assume that every query recursion may be followed by \u03bd reference recursions.", "startOffset": 27, "endOffset": 661}, {"referenceID": 3, "context": "The more recent results of Curtin and Ram (2014) are more related to these results, but they depend on the inverse constant of bichromaticity \u03bd which suffers from the same problem as \u03ba. Although the dependence on \u03bd is linear (that is, O(\u03bdN)), bounding \u03bd is difficult and it is not true that \u03bd = 1 in the monochromatic case. \u03bd corresponds to the maximum number of reference recursions between a single query recursion, and \u03ba corresponds to the maximum number of query recursions between a single reference recursion. The respective proofs that use these constants then apply them as a worst-case measure for the whole algorithm: when using \u03ba, Ram et al. (2009a) assume that every reference recursion may be followed by \u03ba query recursions; similarly, Curtin and Ram (2014) assume that every query recursion may be followed by \u03bd reference recursions.", "startOffset": 27, "endOffset": 771}, {"referenceID": 1, "context": "The task is well-studied and well-known, and there exist numerous approaches for both exact and approximate nearest neighbor search, including the cover tree nearest neighbor search algorithm due to Beygelzimer et al. (2006). We will consider that algorithm, but in a tree-independent sense as given by Curtin et al.", "startOffset": 199, "endOffset": 225}, {"referenceID": 1, "context": "The task is well-studied and well-known, and there exist numerous approaches for both exact and approximate nearest neighbor search, including the cover tree nearest neighbor search algorithm due to Beygelzimer et al. (2006). We will consider that algorithm, but in a tree-independent sense as given by Curtin et al. (2013b); this", "startOffset": 199, "endOffset": 325}, {"referenceID": 1, "context": "The standard bound function B(Nq) used for cover trees is adapted from (Beygelzimer et al., 2006):", "startOffset": 71, "endOffset": 97}, {"referenceID": 20, "context": "Thus, we will bound |R\u2217| using techniques related to those used by Ram et al. (2009a). The bounding of |R\u2217| is split into two sections: first, we show that when the scale smax r is small enough, R\u2217 is empty.", "startOffset": 67, "endOffset": 86}, {"referenceID": 20, "context": "This is the same strategy as performed by Ram et al. (2009a). First, we must establish a Score() function for relative value approximation.", "startOffset": 42, "endOffset": 61}, {"referenceID": 8, "context": "For an example of a better relative-value approximate kernel density estimation dual-tree algorithm, see the work of Gray and Moore (2003).", "startOffset": 117, "endOffset": 139}], "year": 2015, "abstractText": "Numerous machine learning algorithms contain pairwise statistical problems at their core\u2014 that is, tasks that require computations over all pairs of input points if implemented naively. Often, tree structures are used to solve these problems efficiently. Dual-tree algorithms can efficiently solve or approximate many of these problems. Using cover trees, rigorous worstcase runtime guarantees have been proven for some of these algorithms. In this paper, we present a problem-independent runtime guarantee for any dual-tree algorithm using the cover tree, separating out the problem-dependent and the problem-independent elements. This allows us to just plug in bounds for the problem-dependent elements to get runtime guarantees for dual-tree algorithms for any pairwise statistical problem without re-deriving the entire proof. We demonstrate this plug-and-play procedure for nearest-neighbor search and approximate kernel density estimation to get improved runtime guarantees. Under mild assumptions, we also present the first linear runtime guarantee for dual-tree based range search.", "creator": "LaTeX with hyperref package"}}}