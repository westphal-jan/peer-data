{"id": "1502.02414", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2015", "title": "Tractability and Decompositions of Global Cost Functions", "abstract": "Enforcing local consistencies in cost function networks is performed by applying so-called Equivalent Preserving Transformations (EPTs) to the cost functions. As EPTs transform the cost functions, they may break the property that was making local consistency enforcement tractable on a global cost function. A global cost function is called tractable projection-safe when applying an EPT to it is tractable and does not break the tractability property. In this paper, we prove that depending on the size r of the smallest scopes used for performing EPTs, the tractability of global cost functions can be preserved (r = 0) or destroyed (r &gt; 1). When r = 1, the answer is indefinite. We show that on a large family of cost functions, EPTs can be computed via dynamic programming-based algorithms, leading to tractable projection-safety. We also show that when a global cost function can be decomposed into a Berge acyclic network of bounded arity cost functions, soft local consistencies such as soft Directed or Virtual Arc Consistency can directly emulate dynamic programming. These different approaches to decomposable cost functions are then embedded in a solver for extensive experiments that confirm the feasibility and efficiency of our proposal.", "histories": [["v1", "Mon, 9 Feb 2015 10:09:35 GMT  (410kb)", "http://arxiv.org/abs/1502.02414v1", "32 pages for the main paper, extra Appendix with examples of DAG-decomposed global cost functions"], ["v2", "Wed, 29 Jun 2016 16:24:11 GMT  (431kb)", "http://arxiv.org/abs/1502.02414v2", "45 pages for the main paper, extra Appendix with examples of DAG-decomposed global cost functions"], ["v3", "Thu, 30 Jun 2016 11:21:20 GMT  (515kb)", "http://arxiv.org/abs/1502.02414v3", "45 pages for the main paper, extra Appendix with examples of DAG-decomposed global cost functions"]], "COMMENTS": "32 pages for the main paper, extra Appendix with examples of DAG-decomposed global cost functions", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["david allouche", "christian bessiere", "patrice boizumault", "simon de givry", "patricia gutierrez", "jimmy h m lee", "kam lun leung", "samir loudni", "jean-philippe m\\'etivier", "thomas schiex", "yi wu"], "accepted": false, "id": "1502.02414"}, "pdf": {"name": "1502.02414.pdf", "metadata": {"source": "CRF", "title": "Tractability and Decompositions of Global Cost Functions", "authors": ["David Allouche", "Christian Bessiere", "Patrice Boizumault", "Simon de Givry", "Patricia Gutierrez", "Jimmy H.M. Lee", "Kam Lun Leung", "Samir Loudni", "Jean-Philippe M\u00e9tivier", "Thomas Schiex", "Yi Wu"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 150 2.02 414v 1 [cs.A I] 9 FThe enforcement of local consistency in cost function networks is done by applying so-called Equivalent Preserving Transformations (EPTs) to cost functions. Since EPTs transform cost functions, they can break the property that made the enforcement of local consistency traceable to a global cost function. A global cost function is called tractable projection-safe when an EPT is applied to it, is tractable and does not break the tractability property. In this Paper1, we show that depending on the size r of the smallest scopes used to perform EPTs, the tractability of global cost functions can be obtained (r = 0) or destroyed (r > 1). If r = 1 the answer is indefinite, we show that on a large family of cost functions EPTs can build a dynamic programming consistency which can lead to tractability."}, {"heading": "1. Introduction", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}, {"heading": "2. Background", "text": "The cost structure (0,..) is a tuple defined as: \u2022 [0,..] is the interval of integers from 0 to 2. [0,.] is the interval of integers from 0 to 2. [0,.] is the interval of integers from 0 to 2. [0,.] is the interval of integers from 0 to 2. [0,.] is the interval of integers from 0 to 2. [2,.] is the interval of integers from 0 to 2. [3] where either a positive integer or a positive integer is defined. [3,.] We also define the subtraction of operators for all a and b, where one. \""}, {"heading": "3. Tractable Projection-Safety", "text": "In this section we show that the order of local consistency is directly related to the tractability of the global cost function minimization.Definition of the global cost function W GCF (S, A1,.., Ak) is in P: IsBetterThan (W GCF), m) is in P: IsBetterThan (W GCF (S, A1,., Ak)."}, {"heading": "4. Polynomial DAG-Decomposability", "text": "In addition, we present the cost functions based on a DAG19 definition, which provides an additional class of tractable cost functions based on dynamic programming algorithms. (D) As mentioned by Dasgupta et al. 2007, every dynamic programming has an underlying DAG structure. (D) A direct chart (u, v) E-points from u to v, where u is the parent of v, and v is the child of v, is the root of a DAG with zero degrees. \u2022 A sheet of a DAG is a vertex with zero degrees. \u2022 An internal vertex of a DAG is neither a root nor a leaf; we introduce the function of a DAG19."}, {"heading": "5. An Example of Polynomially DAG-Decomposable Global Cost Function", "text": "In the following, we show that W Grammarvar polynomial DAG-decomposable based on Theorems 6 and 7. Other examples of polynomial DAG-decomposable global cost functions can be found in [38]. [29] For convenience, we assume that the scope of each global cost function is S = {x1,.} Other examples of polynomial DAG-decomposable global cost functions are defined in the softened version of the hard global constraint Grammar [29] based on a context-free language."}, {"heading": "6. Decomposing Global Cost Functions into CFNs", "text": "It is not possible that a global cost framework for a global network of costs (S, A1, A1, Ak) requires a global cost allocation of a global cost function..., Ak) is a polynomial transformation involving a CFN (S, A1, Ak) = (S, F, AK) = (S), where S (E, AE) = (E) = (S, AE) = (S), WT (S) = (S), WT (S) = (S), WCF = (S), WCF = (S), WCF = (S), WCF = (S), WCF = (S)."}, {"heading": "7. Local Consistency and Network-decompositions", "text": "It is true that in recent years there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there has been an exacerbation of imbalances. (...) It is true that there is an exacerbation of imbalances. (...) It is true that there is an exacerbation of imbalances. (...) It is true that there is an exacerbation of imbalances. (...) It is true that there is an exacerbation of imbalances. (...) It is true that there is an exacerbation of imbalances."}, {"heading": "8. Comparison with tractable DAG-decomposability", "text": "In this section, we show that we have the tree of I-rooted in the Abxi-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E-E"}, {"heading": "9. Experiments", "text": "In this section, we put theory into practice by comparing the cost functions described in the previous sections in toulbar2 v0.9.73 to demonstrate the practicality of our algorithmic framework in solving excessively constrained and optimized problems. For each cost function, we implement a weak EDGAC * using a strong DAG structure and corresponding dynamic programming algorithm (called the DAG-based approach in the sequence). In the experiments, we used standard options for toulbar2 to perform a depth-based industry and industry search. The default variable ordering strategy is based on the Weighted Degree heuristics [13] with the last conflict [37], while the default order of values from the selection for each variable defines its fully supported value."}, {"heading": "11 30 382.5 6.46 30 187.7 1.01 293 30 21,712.0 22.13", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "12 30 838.1 21.02 30 324.1 2.48 344 28 105,093.0 122.10", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "13 30 1,960.8 57.53 30 1,022.3 8.76 396 7 94,810.4 115.07", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "14 21 1,729.7 70.23 30 2,401.1 26.91 451 2 12,341.5 16.89", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "15 14 1,823.8 69.14 26 3,936.1 49.34 507 2 85,177.0 120.55", "text": "9.2. The nonogram problem The problem (probably 012 in CSPLIB) [28] is a typical board puzzle on a board of size p x p.Each row and column has a specific sequence of shaded blocks. For example, arow implies (2, 3) that it contains two sequences of shaded blocks, one with length 2 and another with length 3. The problem is to figure out which blocks need to be shaded in such a way that each row and column contains the specific sequences of shaded blocks. We model the problem with n = p2 variables, in which xij specifies whether the block at the ith row and the jth column needs to be shaded. In the experiments, we create random instances from a series of sequences for each row and column, some of which are excessively limited. We model and mitigate the constraints for each row and column based on the network 38 column based on the network AG, based on the model W (see below for the most detailed use of modules)."}, {"heading": "36 30 14.4 0.15 30 14.5 0.01 96 30 4.4 0.00", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "49 30 49.0 0.74 30 56.2 0.06 133 30 20.9 0.00", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "64 30 196.9 6.09 30 482.4 0.85 176 30 87.7 0.02", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "81 30 396.9 22.00 30 625.3 1.95 225 30 386.1 0.07", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "100 15 727.4 57.97 29 11,328.0 41.82 280 30 4,421.3 0.88", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "121 10 740.4 90.91 19 12,278.3 49.96 341 29 17,056.5 3.50", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "144 2 546.5 101.83 5 15,718.4 117.05 408 24 132,105.0 30.24", "text": "9.3. Well-shaped parentheses For a set of 2p straight length intervals within [1,..., 2p], the problem with well-shaped parentheses is to find a chain of parentheses with a length of 2p so that substrings are well-shaped parentheses in each of the intervals. We model this problem using a set of n = 2p variables. Size 6 domains consist of three different types of parentheses: () [] {}. We set a W grammarvar cost function for each interval to represent the requirement for well-shaped parentheses. We create 2p \u2212 1 even length intervals by selecting their endpoints randomly in [1,.. \u2212 2p] and adding an interval covering the entire range to ensure that all variables are limited. We also assign irregular costs (between 0 and 10) to each variable. We compare two models."}, {"heading": "10 30 7.6 1.72 250 30 54,117.4 17.31", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "12 30 10.5 5.60 392 5 334,507.0 130.23", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "14 30 25.9 24.45 580 1 408,251.0 259.71", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "16 24 46.1 47.27 841 0 N/A N/A", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "18 22 44.1 49.96 1,146 0 N/A N/A", "text": "The results are shown in Table 3. The network-based approach is clearly inefficient. It has n \u2032 = 1146 additional variables on average for p = 9. The number of backtracks is exploding rapidly, and the DAG-based approach clearly dominates here. As a second experiment with well-shaped brackets, we create new instances using only a global grammar constraint and a series of p \u2212 p \u2212 1 binary cost functions. If a pair of brackets (((), [] or {}) is placed at these specific positions, it generates randomly generated costs (between 0 and 10). A single W \u2212 Grammarvar cost function is placed on all n \u2212 2p variables that cause a violation, ensuring that the entire string has well-shaped brackets. As in the experiments in Table 3, the two models are characterized by the way the W \u2212 Grammarvar cost function is decomposed."}, {"heading": "10 30 148.8 1.08 65 30 116.6 0.18", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "12 30 509.8 7.76 90 30 926.7 0.66", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "14 30 1,574.3 46.20 119 30 8,358.2 3.46", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "16 20 3,909.7 200.92 152 30 59,019.5 22.28", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "18 0 N/A N/A 189 28 419,900.0 169.93", "text": "problem defined in [19, 59]. The goal is to minimize \u2211 n i = 1 oixi so that \u2211 ni = 1 ai, jxi = bj for each j [1, m] and xi are boolean variables in {0, 1} (o, a and b are positive integer coefficients). We compared the mountain acyclic decomposition in toulbar2 (version 0,9,5) with a direct application of the Integer Linear Programming Solver cplex (version 12,2.0.0). We generated random instances with random integer coefficients in [0, 99] for o and a and bj = 1 2 \u0445 n i = 1 ai, J. We used a sample of 50 problems with m = 4, n = 30 leading to max bj = 918. The mean number of nodes developed in cplex is 50% higher than in toulbar2. However, cplex was on average 6 times faster than ltou2 in these problems."}, {"heading": "10. Conclusion", "text": "Our contributions are quadruple. First, we define the tractability of a global cost function and study its behavior with respect to projections / extensions with different cost functions. We show that tractable r-projection security is always possible for projections / extensions to / from the zero cost function, while it is always impossible for projections / extensions to / from r-cost functions. If r = 1, we show that a tractable cost function may or may not be tractable 1-projection safe. Second, we define polynomically decomposable cost functions and show that they are tractable 1-projection-safe. We also give polytime dynamic programming to compose the minimum of this class of global cost functions."}, {"heading": "1 Introduction", "text": "This manuscript should be read together with the essay by Allouche, Bessiere, Boizumault, de Givry, Guttierez, Lee, Leung, Loudni, Metivier, Schiex and Wu (2015), which contains the necessary definitions, notations and theorems."}, {"heading": "2 Polynomial DAG-Decomposable Global Cost Functions", "text": "Below we show that W Amongvar, W Regularvar, W Max, and W Min. (W Min.). (W)..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "By Theorem 6 and 7 by Allouche et al. (2015), the decomposition is safely DAG-decomposition. Moreover, the leaves are unary cost functions. The DAG-decomposition is polynomial and, by Theorem 9 by Allouche et al. (2015), the result follows.", "text": "Example 4: According to Example 3, the order A is defined as follows: A = [\u03b10, \u03b11, \u03b12, \u03b13, \u03b14, \u03b15, \u03b16] = [0, f (x1, 1), f (x2, 2), f (x3, 2), f (x1, 3), f (3, 3), f (x2, 4) = [0, 3, 6, 6, 9, 12] The DAG composition for W Max can be defined as: W Max (S, c) () = min H42 (2) G 6 1 ([x1]) G 6 3 (x3], H33 ([3]) G 5 1 ([x1]) G 5 (3, 2 2 (2], H31 ([1]) G 4 (2) 4 () G = 3 (3), G 5 (3) = 1 (((3)."}, {"heading": "W Max(S,c)(\u2113) can be computed using Table 1, which gives the cost 9.", "text": "W Max (S, c) () = min 0 0 0, 0 0 0 0, 0 0 0 0"}, {"heading": "3 Conclusion", "text": "In this manuscript, we have shown that W Amongvar, W Regularvar, W Max, and W Min are polynomial DAG-degradable. We also specify the appropriate polytime dynamic programming algorithms to calculate the minimum of this class of global cost functions."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Enforcing local consistencies in cost function networks is performed by applying so-called Equivalent Preserving Transformations (EPTs) to the cost functions. As EPTs transform the cost functions, they may break the property that was making local consistency enforcement tractable on a global cost function. A global cost function is called tractable projection-safe when applying an EPT to it is tractable and does not break the tractability property. In this paper, we prove that depending on the size r of the smallest scopes used for performing EPTs, the tractability of global cost functions can be preserved (r = 0) or destroyed (r > 1). When r = 1, the answer is indefinite. We show that on a large family of cost functions, EPTs can be computed via dynamic programming-based algorithms, leading to tractable projection-safety. We also show that when a global cost function can be decomposed into a Berge acyclic network of bounded arity cost functions, soft local consistencies such as soft Directed or Virtual Arc Consistency can directly emulate dynamic programming. These different approaches to decomposable cost functions are then embedded in a solver for extensive experiments that confirm the feasibility and efficiency of our proposal.", "creator": "LaTeX with hyperref package"}}}