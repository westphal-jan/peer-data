{"id": "1502.05450", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Feb-2015", "title": "The (Final) countdown", "abstract": "The Countdown game is one of the oldest TV show running in the world. It started broadcasting in 1972 on the french television and in 1982 on British channel 4, and it has been running since in both countries. The game, while extremely popular, never received any serious scientific attention, probably because it seems too simple at first sight. We present in this article an in-depth analysis of the numbers round of the countdown game. This includes a complexity analysis of the game, an analysis of existing algorithms, the presentation of a new algorithm that increases resolution speed by a factor of 20. It also includes some leads on how to turn the game into a more difficult one, both for a human player and for a computer, and even to transform it into a probably undecidable problem.", "histories": [["v1", "Thu, 19 Feb 2015 00:41:56 GMT  (2199kb,D)", "http://arxiv.org/abs/1502.05450v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["jean-marc alliot"], "accepted": false, "id": "1502.05450"}, "pdf": {"name": "1502.05450.pdf", "metadata": {"source": "CRF", "title": "(The Final) Countdown Preprint", "authors": ["Jean-Marc Alliot"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The Countdown game (Wikipedia [2015]) is one of the oldest television shows in the world. It began on French television in 1972 as \"des ciffres et des lettres,\" literally \"numbers and letters\" with a numerical round called \"Le compte est bon,\" literally \"the count is good.\" It was broadcast on British Channel 4 as a \"countdown\" in 1982 and has been running in both countries ever since. The numerical round of the game is extremely simple: 6 numbers are drawn from a set of 24, which contains all numbers from 1 to 10 (small numbers) twice plus 25, 50, 75 and 100 (large numbers). With these six numbers, participants must then find a number that is randomly drawn between 101 and 9991, or, if it is impossible, the one that comes closest to the number drawn. Only the four standard operations (+ \u2212 \u00d7 /) can be used."}, {"heading": "30 + 1 = 31 {1,4,7,31}", "text": "4 x 7 = 28 {1,28,31}"}, {"heading": "28 + 1 = 29 {29,31}", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "29 * 31 = 899 {899}", "text": "The simplest answer is usually defined as the answer with the least number of operations, and if two solutions have the same number of operations, one possible refinement is to keep the one with the smallest highest number. The game, although extremely popular, never received serious scientific attention. There was a very early article in the French journal \"l'Ordinateur Individuel\" in the late 1970s, written by Jean-Christophe Buisson (Buisson [1980]), which described a simple algorithm. The only article written on this subject in English was published twice (Defays [1990, 1995a]) by Daniel Defays, who also published a book in French (Defays [1995b]), which uses the game as a central example for the introduction of artificial intelligence methods. But the ultimate goal of the defys was not to develop a precise solver for the game, but a solver that imitates human thinking."}, {"heading": "2 Elementary algorithms", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Decomposition in sub-problems", "text": "The first published algorithm (Buisson [1980]) used a simple decomposition mechanism. Consider the following example: numbers 3, 50, 7, 4, 75, 8, number to find 822. The algorithm would start from the solution (822) and apply a reverse concatenation approach in the prologue procedure. However, not all operations were tried; in odd steps only addition and subtraction were used, while in even steps only divisions were used. Thus, in the first step, the algorithm would generate thirteen numbers: 822, 822 \u00b1 3, 822 \u00b1 50,... and then try to divide all by the remaining 5 (or 6 if no number was added or subtracted) numbers. If a division succeeded, the algorithm would then apply recursively to the new result with the remaining numbers."}, {"heading": "75 - 75 = 0 {8}", "text": "The complexity of this algorithm is very low. If we have n numbers, we first generate 2n + 1 numbers and try to divide them by n \u2212 1 numbers, so we have to do (n \u2212 3) trial divisions, and so on. On the one hand, if all divisions are successful, we have an amaxial complexity of n \u2212 3 numbers, so (n \u2212 2) trial divisions, and so on. On the other hand, if all divisions are successful, we have an amaxial complexity of: n / 2 - i = 1 (4i \u2212 1)."}, {"heading": "822 + 50 = 872 {3,7,4,75,8}", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "872 / 4 = 218 {3,7,75,8}", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "218 + 7 = 225 {3,75,8}", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "225 / 3 = 75 {75,8}", "text": "75 - 75 = 0 {8} The maximum complexity of the algorithm is (6 \u00b7 4) \u00b7 (5 \u00b7 4) \u00b7 \u00b7 \u00b7 (1 \u00b7 4) = 6! 46 If we consider the general case with n numbers, the complexity is n! 4n. For n = 6, the maximum number of operations is 491520. Considering that the actual number of operations in each step is closer to 3 than to 4, we have a minimum complexity of n! 3n, and for n = 6 the minimum number of operations is 87480. Let us also remember that even if a division is not possible, it must be tested before it is discarded, so that this minimum complexity is a subordinate limit that can never be reached."}, {"heading": "2.2 The depth first algorithm", "text": "If we look at the complete set of n numbers, we simply select two of them (C2n = n (n \u2212 1) 2 possibilities) and combine them with one of the four possible operations. The sequence of the two selected numbers is irrelevant, since the order for the addition and multiplication (a + b = b + a and a \u00b7 b \u00b7 a) does not matter, and we can only use one sequence for the other two operations (if a > b, we can only calculate one \u2212 b and a / b, and if a < b \u2212 a and b / a) does not matter; b \u2212 a and b / a). Then we put the result of the calculation back into the sentence, so that a new set of n \u2212 1 numbers is created. We simply repeat the algorithm, until no number remains in the pool \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 and then return to the previous point of choice, whether it is a number or an operation. This is a simple depth search algorithm that creates the whole algorithm, because it searches for \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7."}, {"heading": "2.3 The breadth first algorithm", "text": "It is also a recursive algorithm (7) {7 (7), but it works on the partitions of the set of numbers. The first presentation of this algorithm seems to be pin [1998]. \u2022 First, we create all records generated by only one element. \u2022 First, we create all records generated by only one element. {4} {4 (4) {4) {4) {4) {4) {4 (3) {4) {4) {4) {4) {4 (3) {4) {4) {4) {4) {4 (3) {3}, p) = {3), g (50). Next, we create the records of all numbers that can only be calculated with two numbers. Here, for example, are all numbers generated by {3, 50} the elements of g (3)."}, {"heading": "3 Implementation and refinements", "text": "To compare the algorithms, the programs were all written in Ocaml (INRIA [2004]). The implementation was not parallel and the programs were executed on a 980X. For3The N (p) are probably related to Bell numbers, but they are not the same large instances, an implementation of the best algorithm (depth first with hash tables) was written in C and assembly language. MPI (Board [1997]) was used to solve problems in parallel, and the program was used on a 640 AMD-HE6262 core cluster with 512 cores. Using the same algorithm, the C program on a single core is twice as fast as the Ocaml program. The 980X in this section is a 6-core Intel processor that runs at 3.33Ghz (a clock cycle of 0.3ns) with a 32-Cb-L1 cache by core, a 256kb-L2 cache by core and 12b-cache by core."}, {"heading": "3.1 The depth first algorithm", "text": "Implementing the na\u00efve version of the depth-first algorithm is a simple process. First, the algorithm scans the entire space with the pool of initial numbers and marks all achieved numbers as solvable. Then, if the number to be found is marked as solvable, it is solvable. If it was not found, we save the list of operations that led to it (the list to be saved is only the branch currently being searched for). If the number has already been found, we save the new solution if and only if the list of operations for this solution is smaller than the already saved one. As the algorithm is a depth-first algorithm, we have no guarantee that the first solution found is the shortest."}, {"heading": "3.2 The depth first algorithm with hash tables", "text": "In fact, it is so that it will be able to eren.n the aforementioned lcihsrc\u00fceS."}, {"heading": "3.3 The breadth first algorithm", "text": "The implementation of the first element is not much more complicated than the implementation of the first element = 25. We first need to create a data structure that contains the information necessary to form the numbers generated by a subset of the original pool. For example, we need to know how to build the numbers generated by the first, second, and fourth numbers of the pool. To do this efficiently, we create an array in which the ith element contains the list of pairs that must be combined to form the numbers generated by the binary decomposition of i. This might sound complicated, but is easy to understand with a few examples: \u2022 For i = 16 we have an array that is i = 16 = 100002, so this element will only refer to the fifth element in the initial pool of numbers. \u2022 The element at i = 5 = 1012 points to the list of elements that we combine."}, {"heading": "4 Scaling things up", "text": "Since its beginning in 1972, the number round of the countdown game has never evolved, while its sister game, the letters round, has seriously changed, ranging from 7 letters in 1972 up to 10 letters today. In 1972, computers were able to solve the number pairs around; nowadays, therefore, it is solvable in less than a millisecond. Therefore, it is like in many games in which computers have become much better than people, the interest in the game fades. \u2212 In addition, the game itself is not very difficult on average for people. \u2212 There are thus two ways to change the difficulty of the game: Is it possible to change the game, to turn it into a difficult thing for a computer, and is it possible to turn it into a game, which is more difficult for the player, without changing it too much? There are two ways to change the difficulty of the game: Is it possible to change the game, the target number based on the values in the number, to choose it in a difficult thing for a computer, and is it possible to turn it into a game, the more difficult thing, the more difficult for the player, the harder to change it into a game, the more difficult for the player, without it is too much? There are two ways to change the difficulty of the game. The first is to change the difficulty of the game, the number based on the values in the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the number, the"}, {"heading": "4.1 Solving for n = 6", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1.1 Standard game", "text": "For n = 6 we have 13243 possible sets. In the standard numbers around the countdown game, we look for numbers in the range 101-999, so there are are5The number of possible instances is not an indicator of the difficulty of the game, but we need these numbers in the next sections. 899 \u00b7 13243 = 11905457 possible problems. In Table 2 we have the distance to the next numbers: 10858746 games are solvable (91.2%), 743896 problems (6.25%) have a solution at a distance of 1 (the next number).1226 instances out of 13243 (9.2%) solve all target numbers in the range 101-999. An instance (1, 2, 3, 3}) solves none of the problems at a distance of 1 (the next number)."}, {"heading": "4.1.2 Selecting problems", "text": "Since all cases are solved, we have a complete database; for a given set of numbers and a given target number, we know whether it can be solved and how many operations are needed to solve it, or how close the next number to be found is if it cannot be solved. With this database, it is extremely easy to select only interesting problems. There can be many different selection criteria: solvable problems requiring more than 4 (or 5...) operations, or insoluble problems with the next number at a minimum given distance, or insoluble problems with the next number requiring more than 4 operations, etc. This would turn the round of numbers into something worth looking at again."}, {"heading": "4.1.3 Using a larger set to pick numbers", "text": "Another way to make the game more difficult would be to use all available numbers between 1 and 100 when selecting the numbers. Constructing the complete database is much more computationally intensive. In the standard game, we have 13243 sets, when selecting the k numbers between 1 and n (including repetitions), we have Ckn + k \u2212 1 = C6100 + 6 \u2212 1 = 1609344100 '1.6 109 possible sets and 1446800345900' 1.4 1012 problems. Constructing the database took 12 hours on the cluster described in Section 3.Table 4 gives the distance to the solution, just as Table 2 does for the standard game. Percentages are similar to the standard problem. In Figure 7, we have the same results as in Figure 5. Percentages are higher, which means that on average the problem is easier to solve if numbers are randomly selected between 1 and 100. There are 73096123 (4.5%) sets that solve all the problems while the primes are solved by a set."}, {"heading": "4.2 Solving for n = 7", "text": "With the equations 1, 2, 3 and 4 we find that the maximum and minimum number of operations for the depth first algorithm is dmax (7) = 232243200 and dmin (7) = 41334300. For the width first algorithm we have bmax (7) = 49951531 and bmin (7) = 9379195. So we have dmax (7) dmax (6) = 84, dmin (7) dmin (6) = 63, bmax (7) bmax (6) = 43, bmin (7) bmin (6) = 32. In Table 5 we have the results of the experiment with the five algorithms with n = 7. We see that with the depth first algorithm, the time for solving instances with 7 numbers 62 (740 / 12) times greater than with n = 6. This is completely compatible with the minimum complexity of this algorithm, which has a ratio of 63. With the width first algorithm predicts that times the data are larger with 10 d.h."}, {"heading": "4.3 Solving for n = 8", "text": "Here we have bmin (8) = 363099899, dmin (8) = 3472081200 and dmin (8) dmin (7) = 84 and bmin (8) bmin (7) = 39. In Table 6 we have the results of the experiment with the five algorithms with n = 8. However, we see that the time for solving instances with 8 numbers is 83 (61 / 0.740) times greater than with n = 7. This is exactly what was expected (a ratio of 39). We note that the width-first algorithm predicts a ratio of 84, the time for solving instances with 8 numbers is 40 (4.4 / 0.109) times greater than with n = 7. This is exactly what was expected (a ratio of 39)."}, {"heading": "4.4 Solving for n = 9", "text": "We have dmin (9) dmin (8) = 108 and bmin (9) bmin (8) = 48. Thus, the default depth-first algorithm should take more than 6000s to solve a single instance, and the depth-first algorithm with arrays should take about 40Gb of memory, which the computer used for these tests.In Table 7, we have the results of the experiments with three algorithms with n = 9. As expected, the depth-first algorithm was not able to solve even a single instance in less than an hour. The first algorithm with arrays in width generated an \"out of memory\" error. The results are shown in Figure 11. We need to expand the range to about 200000 (the most difficult number is 190667 with a success rate of 66%)."}, {"heading": "4.5 Solving for n = 10", "text": "For n = 10 we are finally entering uncharted territory. The average time to solve a problem seems to be about 1 to 3 minutes, so it seems impossible to use an exhaustive algorithm. Finally, we are back in the land of heuristics. Results are shown in Figure 12. Full results were calculated on the cluster described in Section 3 in 20 hours. Some pools such as {5, 6, 7, 8, 9, 10, 25, 50, 75, 100} took more than an hour. We had to expand the range above 1000000 to achieve similar results in terms of success rate (up to 1000000 is the most difficult number 986189 with a success rate of 67%)."}, {"heading": "5 A slightly modified problem", "text": "The problem is easy to solve because it is a limited one: at each step the set of available numbers is reduced by one unit, and therefore any computer program can also solve it with a very large set of numbers. Another solution to turn the game into a more interesting one would be to add a simple operation: the possibility to replace every available number with its square. Let's take an example: How to find 999 using {1,2,3,4,5,6}. This is an insoluble problem without the square operation, but it is no longer the case: The remaining operations 3 x 6 = 18 {1,2,4,5,18} 18 x 18 = 324 {1,2,4,5,324} 4 + 5 = 9 {1,2,9,324}"}, {"heading": "324 + 9 = 333 {1,2,333}", "text": "1 + 2 = 3 {3,333}"}, {"heading": "333 x 3 = 999 {999}", "text": "This change changes the character of the game, since it is no longer a \"finite\" game, at least in theory. Thus, we can perform long and complex calculations in order to find results. Consider an example: How to find 862 using the sentence {1,10,10,25,75,100}. The shortest calculation requires 14 steps (whereas in the standard game we can never have more than 5 steps) and uses very large numbers: {1,10,10,25,25,75,100} 10 - 1 = 9 {9,10,25,75,100} 100 x 100 = 10000 {9,10,25,75,10000} 9 x 9 = 81 {81,20000,25,75,10000} 10 x 10 = 10 = 100 {81,200000,25,75,10000} 100 x 100 = 101,10000,25,75,10000} {10000} 10000 + 10000 = 20000 {81,20000000,25,25,25,25,25,25,25,25,25,25,25,25,75} 75 {81,20000000,25,000,000 = 1056000 = 1056000 = 56000 = 56325 = 56325 = 56375 = 56000 = 1056000 = 1056000"}, {"heading": "943 - 81 = 862", "text": "The program needs to be slightly modified to include the possibility of increasing a number to its square at any time, and it also needs to be limited: we need to set an upper limit A, beyond which we no longer have square numbers. Without this limit, the algorithm could not stand still. Moreover, the maximum value of A, which can be tested with 64-bit arithmetic, is 45000.The possibility of squaring numbers increases the complexity of the program considerably. Since we are only interested in finding out whether a given set can solve all numbers in the range 101-999, we stop as soon as all these numbers have been found, and do not search any further for the shortest solution available. With this optimization, and using all the other optimizations shown above, the computing time is not really a problem, at least not for values from A to 50000.We see in Table 8 results for different values of A. At A = 1, the results are the results of the standard algorithm, because squaring 1 yields: 1046711 instances of 1957 (the numbers of 147 and 113 are not resolved quickly)."}, {"heading": "1 1 10 10 25 100: 858", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 10 10 25 75: 863", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 10 10 50 100: 433 453 547 683 773 853", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 10 10 50 75: 793 853 978", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 10 10 75 100: 433 453 457 478 547", "text": "618 653 682 708 718 778 793 822 853 892"}, {"heading": "1 12017 1046711 8.79%", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 10757 758822 6.37%", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3 9059 503409 4.22%", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4 6275 196070 1.65%", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5 5004 128631 1.08%", "text": "907 958 978"}, {"heading": "1 1 10 25 75 100: 853 863", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 10 50 75 100: 793 813 853 978", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 5 5 25 100: 813 953", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 7 7 50 100: 830", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 8 8 9 9: 662", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 9 10 10 100: 478 573 587 598", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 1 9 9 10 100: 867", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1 9 9 10 10 100: 867 947 957 958 967", "text": "When searching for results in the range of 1001-9999 instead of 101-999, the percentage of solvable problems remains extremely high (at least 99.9705%: only 35200 cases of 119173757 seem to be insoluble). However, problems are usually much more difficult for humans as they require the use of much larger numbers. Another interesting suggestion to revive the current countdown game would be to continue using 6 numbers from the same pool, but now to look for numbers in the range of 1001-9999 and allow the use of the square operation. Theoretically, the main question is: Are there some cases that can never be solved, regardless of the value of A? This question is complex and requires further research: on the one hand, we can hope that by searching with sufficiently large values of A we would solve all cases of the problem."}, {"heading": "6 A subsidiary problem: reducing the number of solutions", "text": "When searching for a certain number, there are often many different ways to find the result. However, most of these solutions are \"identical\" from a human point of view. Unfortunately, there is no clear boundary between \"identical\" and \"different\" solutions. There are some elementary rules that can be used to reduce the number of solutions, but it is highly unlikely that the filtered solutions would satisfy all fans of the game. We use postfix notation (A + B is written (+ AB)), since any calculation can be written as a tree and filtering solutions is therefore nothing more than tree reduction. Here are the rules that were used to reduce the tree: \u2022 if a number appears in the initial set, it must not be built."}, {"heading": "7 Conclusion", "text": "Since the game for n = 6 has been fully solved, using both the standard set of numbers and the extended set of all numbers from 1 to 100, it is easy to select numbers and aim in such a way that the problem is challenging for a human being, either by selecting problems that require a minimum number of operations, or unsolvable problems with the best number that can be found some distance from the target, or by using sentences with only prime numbers or large and \"unfriendly\" numbers. Another solution would be to use more than 6 numbers and use a target in a range above 1000, but it is probably not necessary. The final solution is to change the game a bit by adding the square process. We have proven that with only 6 numbers it is possible to find the exact solution to 99.9705% of problems with the target in the order of 1001-9999. However, this is much more difficult for a human being because the use of the target is higher, and the square problem is an insolvable problem."}], "references": [{"title": "Une r\u00e9solution exhaustive du \u201dcompte est bon", "author": ["Jean-Marc Alliot"], "venue": "Communication au groupe des utilisateurs francais de l\u2019Amiga,", "citeRegEx": "Alliot.,? \\Q1986\\E", "shortCiteRegEx": "Alliot.", "year": 1986}, {"title": "A moi compte, deux mots", "author": ["Jean-Christophe Buisson"], "venue": "L\u2019ordinateur individuel,", "citeRegEx": "Buisson.,? \\Q1980\\E", "shortCiteRegEx": "Buisson.", "year": 1980}, {"title": "Numbo: A study in cognition and recognition. The Journal for the Integrated Study of Artificial Intelligence, Cognitive Science and Applied Epistemology", "author": ["Daniel Defays"], "venue": null, "citeRegEx": "Defays.,? \\Q1990\\E", "shortCiteRegEx": "Defays.", "year": 1990}, {"title": "Numbo: A study in cognition and recognition", "author": ["Daniel Defays"], "venue": "BasicBooks,", "citeRegEx": "Defays.,? \\Q1995\\E", "shortCiteRegEx": "Defays.", "year": 1995}, {"title": "L\u2019esprit en friche: les foisonnements de l\u2019Intelligence Artificielle", "author": ["Daniel Defays"], "venue": "Pierre Mardaga,", "citeRegEx": "Defays.,? \\Q1995\\E", "shortCiteRegEx": "Defays.", "year": 1995}, {"title": "Le compte est bon, March 2010. URL http://patquoi.free.fr/lcpdb", "author": ["Patrice Fouquet"], "venue": null, "citeRegEx": "Fouquet.,? \\Q2010\\E", "shortCiteRegEx": "Fouquet.", "year": 2010}, {"title": "Performance analysis guide for intel core i7 processor and intel xeon 5500 processors", "author": ["David Levinthal"], "venue": "Intel report, INTEL Corporation,", "citeRegEx": "Levinthal.,? \\Q2009\\E", "shortCiteRegEx": "Levinthal.", "year": 2009}, {"title": "Le compte est bon", "author": ["Jacky Mochel"], "venue": "URL http://j.mochel.free.fr/comptebon. php", "citeRegEx": "Mochel.,? \\Q2003\\E", "shortCiteRegEx": "Mochel.", "year": 2003}, {"title": "Le compte est bon", "author": ["Jean-Eric Pin"], "venue": "Sujets de projets 9798 de tronc commun informatique de l\u2019Ecole Polytechnique de Paris, June", "citeRegEx": "Pin.,? \\Q1998\\E", "shortCiteRegEx": "Pin.", "year": 1998}, {"title": "Number games solver faq", "author": ["Williams Tunstall-Pedoe"], "venue": "URL http://www.crosswordtools. com/numbers-game/faq.php#stats", "citeRegEx": "Tunstall.Pedoe.,? \\Q2013\\E", "shortCiteRegEx": "Tunstall.Pedoe.", "year": 2013}, {"title": "Countdown is 70: Three cheers for the nation\u2019s favourite comfort blanket", "author": ["G. Virtue"], "venue": "The Guardian, January", "citeRegEx": "Virtue.,? \\Q2014\\E", "shortCiteRegEx": "Virtue.", "year": 2014}, {"title": "A new hashing method with application for game playing", "author": ["Albert L. Zobrist"], "venue": "Technical report 88,", "citeRegEx": "Zobrist.,? \\Q1970\\E", "shortCiteRegEx": "Zobrist.", "year": 1970}], "referenceMentions": [{"referenceID": 1, "context": "There was a very early article in the french magazine \u201cl\u2019Ordinateur Individuel\u201d in the late seventies, written by Jean-Christophe Buisson (Buisson [1980]), which described a simple algorithm.", "startOffset": 130, "endOffset": 154}, {"referenceID": 1, "context": "There was a very early article in the french magazine \u201cl\u2019Ordinateur Individuel\u201d in the late seventies, written by Jean-Christophe Buisson (Buisson [1980]), which described a simple algorithm. The only article written on the subject in English was published twice (Defays [1990, 1995a]) by Daniel Defays. Defays also published in 1995 a book in french (Defays [1995b]) which used the game as a central example for introducing artificial intelligence methods.", "startOffset": 130, "endOffset": 367}, {"referenceID": 1, "context": "The first published algorithm (Buisson [1980]) used a simple decomposition mechanism.", "startOffset": 31, "endOffset": 46}, {"referenceID": 0, "context": "The first recorded implementation of this algorithm (Alliot [1986]) was developed for an Amiga 1000 (a MC68000 based microcomputer with a 7MHz clock).", "startOffset": 53, "endOffset": 67}, {"referenceID": 8, "context": "The first presentation of this algorithm seems to be Pin [1998].", "startOffset": 53, "endOffset": 64}, {"referenceID": 7, "context": "It is sometimes mistakenly presented as being 2 (Mochel [2003]), but it is a very crude estimation.", "startOffset": 49, "endOffset": 63}, {"referenceID": 6, "context": "Memory timings (Levinthal [2009]) for the Core i7 family and Xeon 5500 family are roughly of 4 clock cycles for L1 cache and 10 cycles for L2 cache.", "startOffset": 16, "endOffset": 33}, {"referenceID": 11, "context": "The idea is to use for this problem an (old) (Zobrist [1970]) improvement which has been often used in many classical board games: hash tables.", "startOffset": 46, "endOffset": 61}, {"referenceID": 5, "context": "There are other programs available on the net which claim to solve also the complete set of instances such as Fouquet [2010], but in 60 days (!).", "startOffset": 110, "endOffset": 125}, {"referenceID": 10, "context": "4They should change the random number thingy so it doesn\u2019t come up with a really easy target number, meaning the contestants sit there like stiffs for nearly 30 seconds Virtue [2014]. 2 4 6 8 10 5 10 15 20", "startOffset": 169, "endOffset": 183}, {"referenceID": 9, "context": "However, the importance of large numbers must not be overestimated, as Tunstall-Pedoe [2013] does.", "startOffset": 71, "endOffset": 93}, {"referenceID": 9, "context": "However, the importance of large numbers must not be overestimated, as Tunstall-Pedoe [2013] does. The 4-tuple (25,50,75,100) has a success rate of 88%, much less than (5,7,9,100) which has a success rate of 99.86% and contains only one large number (the worst 4-tuple is (1,1,2,2) with a success rate of 37%). There is another site (Lemoine and Viennot [2012]) in french which advertises the kitsune program and gives some stats.", "startOffset": 71, "endOffset": 361}], "year": 2015, "abstractText": "The Countdown game is one of the oldest TV show running in the world. It started broadcasting in 1972 on the french television and in 1982 on British channel 4, and it has been running since in both countries. The game, while extremely popular, never received any serious scientific attention, probably because it seems too simple at first sight. We present in this article an in-depth analysis of the numbers round of the countdown game. This includes a complexity analysis of the game, an analysis of existing algorithms, the presentation of a new algorithm that increases resolution speed by a factor of 20. It also includes some leads on how to turn the game into a more difficult one, both for a human player and for a computer, and even to transform it into a probably undecidable problem.", "creator": "LaTeX with hyperref package"}}}