{"id": "1503.01707", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Mar-2015", "title": "Mapping-equivalence and oid-equivalence of single-function object-creating conjunctive queries", "abstract": "Conjunctive database queries have been extended with a mechanism for object creation to capture important applications such as data exchange, data integration, and ontology-based data access. Object creation generates new object identifiers in the result, that do not belong to the set of constants in the source database. The new object identifiers can be also seen as Skolem terms. Hence, object-creating conjunctive queries can also be regarded as restricted second-order tuple-generating dependencies (SO tgds), considered in the data exchange literature.", "histories": [["v1", "Thu, 5 Mar 2015 17:47:04 GMT  (27kb)", "https://arxiv.org/abs/1503.01707v1", null], ["v2", "Tue, 12 Jan 2016 14:59:40 GMT  (31kb)", "http://arxiv.org/abs/1503.01707v2", "This revised version has been accepted on 11 January 2016 for publication in The VLDB Journal"]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["angela bonifati", "werner nutt", "riccardo torlone", "jan van den bussche"], "accepted": false, "id": "1503.01707"}, "pdf": {"name": "1503.01707.pdf", "metadata": {"source": "CRF", "title": "Mapping-equivalence and oid-equivalence of single-function object-creating conjunctive queries", "authors": ["Angela Bonifati", "Werner Nutt", "Riccardo Torlone", "Jan Van den Bussche"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 150 3.01 707v 2 [cs.D B] 1In this paper, we focus on the class of single-function object-generating subjunctive queries, or sifo-CQs for short. The single-function symbol can only be used once in the head of the query. We give a new characterization for the Oid equivalence of sifo-CQs, which is simpler than that of Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen's equivalence terms for subjunctive queries with multiplicities. We also solve the logical related problem for sifo-CQs and show that this problem also belongs to NP. Results from Pichler et al. have shown that the logical equivalence for more general classes of SO-tgds is either indecidable or decisable with as yet unknown complexity upper limits."}, {"heading": "1 Introduction", "text": "In this paper, we are interested in subjunctive questions that are extended with an object creation facility. Object creation, also referred to as an oid generation or value invention, has been repeatedly proposed and examined as a feature of query languages in several contexts: high expressiveness [4, 5, 11]; object orientation [3, 22, 24]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18]. In a logic-based approach, object building is typically achieved through the use of scolem functions."}, {"heading": "2 Applications of sifo CQs", "text": "In this section we discuss other applications of sifo CQs, which can be important components of many advanced QQ database systems, ranging from information integration and schema mapping engines along with their benchmarks, to several semantic web tools. We believe this shows that the results in this article on primary Qema and logical implications of sifo CQs are of course relevant and contribute to our understanding of how solutions can be optimized for these applications. CLA (global-as-view) schema mappings [20, 27, 33] refer a query about the source schema and the logical implication of sifo CQs to an atomic element of the global schema, represented by a head atom H of a CQ. Specifically, a CLA mapping can be written as follows: T (x) attributes, which we use a relation symbol T as an atomic head predicate."}, {"heading": "3 Preliminaries", "text": "In this section, we present our formalism for dealing with subjunctive questions and introduce the concept of the object-creating subjunctive query, which was taken from the language ILOG [22]."}, {"heading": "3.1 Databases and conjunctive queries", "text": "From the outset, we start from a stock of kinship names, with each kinship name R having an associated unity ar (R) Q. We also start from an infinite domain of atomic data elements called constants. A fact is of the form R (\u2192 a1,.., ak), where a1,.., ak are constants and R is a k-like kinship name. We call R the predicate of facts.A database schema S is a finite set of kinship names. An instance of S is a finite set of facts with predicates from S. The set of all constants appearing in an instance is called an active domain name I and is called Adom (I). We proceed from an infinite occurrence of variables, separated from domain names. An atom is of the form R (x1,.., xk), where x1, xk), where variables are mk, and k, where a relative name is abk, an imk."}, {"heading": "3.2 Object-creating conjunctive queries", "text": "Suppose a finite vocabulary of function symbols of different equities is defined. As with relationship names Q = Q Q, the uniformity of a function symbol Q is defined by ar (f). Data terms are syntactical expressions built from constants that use function symbols. Formally, data terms are defined inductively as follows: 1. Each constant is a data term; 2. If f is a k-like function symbol and d1,.. then dk is an expression f (d1,.., dk) also a data term. 3An extended fact is defined just like a fact, except that it can contain data terms and not just constants. Formally, an extended fact of the form R (d1,., dk), where dk is data terms and R a k is a k-like relationship term. The active domain of an extended fact e = R (d1,) is an extended formula."}, {"heading": "3.3 The single-function case", "text": "In this paper, we focus on single function oCQs (sifo-CQs), which have exactly one occurrence of a function symbol in the head. Without loss of generality, we always place the function term at the last place of the head. Definition 3.3. A sifo-CQ over a database schema S is an oCQ over S of the formT (x, f (z)) \u2190 B, where \u2022 T is the header predicate; \u2022 f is a function symbol; \u2022 B is the body; \u2022 x-Q is a swab (not necessarily different) of var (B), the so-called Distinguished Variables; \u2022 z-Z is a tuple (not necessarily different) of var (B), the so-called creation variables; some generation variables can be distinguished; \u2022 the elements of var (B), which are not distinguished, are the indistinguishable variables of 3.2 examples of C1 and 3.4 examples of both."}, {"heading": "3.4 Comparison with ILOG", "text": "Object-generating CQs can be regarded as the subjunctive query segment of non-recursive ILOG [22]; our syntax discloses the skolem functions normally obscured in the standard ILOG syntax, and our semantics correspond to what Hull and Yoshikawa call \"exposed semantics.\" Nevertheless, in the following section we will consider the Oid equivalence of sifo CQs, which corresponds to what is called \"obscure equivalence\" [23]."}, {"heading": "4 Characterization of oid-equivalence for sifo CQs", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1 Oid-equivalence of oCQs", "text": "The result Q (I) of an oCQ Q applied to an instance I is an extended instance J e.ma. The data expressions in adom (Q (I)), which are not constants, play the role of the generated oids (also called invented values). Intuitively, then, it is clear that the actual shape of the generated oids does not matter (Example 4.1. Recall the query Q from Example 3.1: Family (c, x, y) Mother (c, x), Father (y).As mentioned in the introduction, we could have used the following query Q (Example 4.1) as well: Family (c, x, y, x))), Mother (c, x), Father (y).Applying the above facts to the mother and father facts from Table 1. Results in the instance shown in Table 3. Intuitively, this instance has exactly the same samerrelevant properties as the family instance from Table 1: beth and ben."}, {"heading": "4.2 Homomorphisms and containment of conjunctive queries", "text": "The characterizations we will give for the equivalence of CQs depend on the classical concepts of homomorphism and the containment between conjunctive queries. Let us briefly remember these concepts [13, 2]. A variable figure is a figure of h from a finite set of variables X to another finite set of variables Y. If A is an atom with variables in X, then we can apply h (B) to any variable occurrence in A to obtain an atom with variables in Y, which we designate with h (A). If B is a set of atoms with var (B) X, then of course we define h (B): = {h (A) | A \u00b2 B \u00b2 of atoms, so that a variable figure h: var (B) \u2192 var (B) and var (B) is conjunctive H."}, {"heading": "4.3 A normal form for oid-equivalence problems", "text": "In this section we will consider two arbitrary sifo CQs Q, Q \"with the same head predicate: Q = T (x, f (z)) \u2190 BQ\" = T (x, f (z)) \"B.\" Then x \"and x\" have the same length. Note that x \"and z\" as well as x \"and z\" can have variables in common. Our goal is to show that the Oid equivalence between arbitrary sifo CQs Q and Q \"can be reduced to the case where the heads are common."}, {"heading": "T (x\u0304, f(z\u0304)) and T (x\u0304\u2032, f \u2032(z\u0304\u2032))", "text": "We have identical arguments, which are called where x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x"}, {"heading": "4.4 Characterization of oid-equivalence", "text": "After the results of the previous subsection, we will now list two sifo CQs as follows: Q = Q (Q = Q = Q) Q (Q = Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q)) and Q (Q = Q = Q) Q (Q = Q) Q (Q = Q) Q (Q = Q)). We will show that Q and Q (Q = Q) are equal if there are homo equivalents and only then there are homo equivalents between B and B \u00b2 in both directions, which we keep x-x-x-x equal and the variables in z. To make this formal, we associate a classic CQ-Q without a function symbol definition."}, {"heading": "4.5 Computational complexity", "text": "The results of this section imply the following: Corollary 4.20. Verification of the Oid equivalence of Sifo CQs is NP-complete. Proof. Suppose that Sifo CQs Q and Q are given with the same header predicate: Q = T (x, f (z))), BQ = T (x), f (z))))), B. \"Let X, X,\" Z \"and Z\" denote the sets of variables that occur in x, x, \"z,\" z \"and z.\" To test the Oid equivalence, we begin with the removal of duplicates in z \"and z, as justified by Lemma 4.9. Note: x\" and x \"have the same length k,\" because of the fixity of T, \"z\" and z. \"So we can write x, x\" and x. \""}, {"heading": "5 Logical entailment of sifo CQs interpreted as", "text": "In fact, it is that we see ourselves in a position to be in, and that we are able to establish ourselves in the world, \"he said in an interview with the\" Welt. \""}, {"heading": "5.1 Nested dependencies", "text": "We have introduced sifo CQs as a limited class of simple SO-tgds. Actually, sifo CQs can also be considered as a limited form of so-called nested tgds [8]. Let's consider a sifo CQ of the general form T (x, f (z))) \u2190 B. Let's be the order of all variables of B, except the generation variables (the variables of z). Also, let w be a fresh variable that does not occur in B, and let H be the atom T (x, w). We can now associate Q with the following implicit statement, which is denoted by ntgd (Q): Therefore, the schema mappings that arise from sifo CQs are now a formula of the first order, but it is clear that ntgd (Q) is logically equivalent to sotgd (Q)."}, {"heading": "5.2 Logical entailment", "text": "Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q Q"}, {"heading": "5.3 Join dependencies and tableau queries", "text": "In our characterization of sifo CQ's logical conclusion, we use a number of concepts from classical relationship database theory [2], which we briefly recall here. Let's remember that a relationship schema is a finite series of elements called attributes. It is common practice to denote the union of two relationship schema X and Y by juxtaposition, whereby XY is written for X and Y. A tuple over a relationship schema U is a function of U to dom. A relationship over U is a finite set of tuples over U. Let t have a tupel over U and let X U. Restricting t to X is denoted by t [X.] The projection schema over X (r) is equal to U. Let's now turn to tableau queries, which are an alternative formalization of conjunctive queries, so that the result of a quantification is a series of tuples rather than a set of facts.Let your database be a series of B and a series of B."}, {"heading": "5.4 Decidability of sifo CQ logical entailment", "text": "We consider two sifo CQs Q and Q with the same header predicate: Q = Q = Q (\u03b2, f (z)) (BQ = T (x), f (z))), B (Remark 5.9. We assume that Q and Q have their function symbol in the same position in the head (considered here as the last position), which is justified because otherwise Q (I) and Q (I) are not empty. (Such an instance could be constructed by replacing the fragmented union of B and B (and the substitution of constants for variables).) Let us leave the constants with an oc assignment for Q (I) in relation to I. By proposition 5.4, we have them (I) and replace the constants for variables."}, {"heading": "5.5 From oid-equivalence to logical entailment", "text": "Let Q and Q sifo be CQs of general forms (1) and (2) from Section 4.4. From our main propositions 4.19 and 5.10 we can say the following: Theorem 5.12. If Q and Q are equivalent, then Q logically includes Q. \"Proof. According to Theorem 4.19, there is a permutation \u03c0 of Z \u2212 X, so that Q\" and Q \"are equivalent. Therefore, there is a homomorphism h: Q.\" Clearly h: B. \"B.\" We check that h meets the conditions of Theorem 5.10, showing that Q \"logically brings Q\".1 Since h maps the head of Q \"on the head of Q,\" we have h \"(x\") = x \"and h\" (z \") = z.\" Since x \"z,\" we have h. \""}, {"heading": "6 Discussion", "text": "The results in this paper provide an understanding of the concepts of Oid equivalence and the logical consequences for QQS. Sifo CQs, however, form a very simple subclass of oCQs. Moreover, the oCQs themselves are rather limited, for example, they consist of a single rule and the rule can have only one atom in mind. So there are at least three natural instructions for further research on oCQs, it would be natural to also examine an idea of the Oid Containment class. Actually, there are at least two reasonable ways to define such an idea. The situation is similar to that in research on CQs with counting or bag semantics. Most of the known results are for equivalence only with the extension to a typical open problem."}, {"heading": "Acknowledgment", "text": "We thank the anonymous referees for their careful comments, which have helped to improve the presentation of the essay."}], "references": [{"title": "Data on the Web: From relations to semistructured data and XML", "author": ["S. Abiteboul", "P. Buneman", "D. Suciu"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Object identity as a query language primitive", "author": ["S. Abiteboul", "P. Kanellakis"], "venue": "J. ACM 45(5),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1998}, {"title": "Procedural languages for database queries and updates", "author": ["S. Abiteboul", "V. Vianu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1990}, {"title": "Datalog extensions for database queries and updates", "author": ["S. Abiteboul", "V. Vianu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1991}, {"title": "STBenchmark: Towards a benchmark for mapping systems", "author": ["B. Alexe", "W.C. Tan", "Y. Velegrakis"], "venue": "PVLDB 1(1),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "The language of plain SOtgds: Composition, inversion and structural properties", "author": ["M. Arenas", "J. P\u00e9rez", "J. Reutter", "C. Riveros"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "Value invention in data exchange", "author": ["P. Arocena", "B. Glavic", "R. Miller"], "venue": "Proceedings 2013 SIGMOD Conference,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Gain control over your integration evaluations", "author": ["P.C. Arocena", "R. Ciucanu", "B. Glavic", "R.J. Miller"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "The expressive power of complex values in object-based data models", "author": ["J. Van den Bussche", "J. Paredaens"], "venue": "Information and Computation", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1995}, {"title": "On the completeness of object-creating database transformation languages", "author": ["J. Van den Bussche", "D. Van Gucht", "M. Andries", "M. Gyssens"], "venue": "J. ACM 44(2),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1997}, {"title": "Structural characterizations of schema-mapping languages", "author": ["B. ten Cate", "P. Kolaitis"], "venue": "Commun. ACM 53(1),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Optimal implementation of conjunctive queries in relational data bases", "author": ["A. Chandra", "P. Merlin"], "venue": "Proceedings 9th ACM Symposium on the Theory of Computing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1977}, {"title": "Equivalence of queries that are sensitive to multiplicities", "author": ["S. Cohen"], "venue": "The VLDB Journal", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Containment of aggregate queries", "author": ["S. Cohen", "W. Nutt", "Y. Sagiv"], "venue": "Database Theory\u2014ICDT", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2003}, {"title": "Clio: Schema mapping creation and data exchange", "author": ["R. Fagin", "L. Haas", "R.M.M. Hern\u00e1ndez", "L. Popa", "Y. Velegrakis"], "venue": "Conceptual Modeling: Foundations and Applications, Lecture Notes in Computer Science,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Towards a theory of schemamapping optimization", "author": ["R. Fagin", "P. Kolaitis", "A. Nash", "L. Popa"], "venue": "Proceedings 27th ACM Symposium on Principles of Database Systems, pp", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Composing schema mappings: Secondorder dependencies to the rescue", "author": ["R. Fagin", "P. Kolaitis", "L. Popa"], "venue": "ACM Trans. Database Syst. 30(4),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2005}, {"title": "On the undecidability of the equivalence of second-order tuple generating dependencies", "author": ["I. Feinerer", "R. Pichler", "E. Sallinger", "V. Savenkov"], "venue": "Information Systems", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Navigational plans for data integration", "author": ["M. Friedman", "A.Y. Levy", "T.D. Millstein"], "venue": "In: AAAI/IAAI, pp", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1999}, {"title": "The TSIMMIS approach to mediation: data models and languages", "author": ["H. Garcia-Molina", "Y. Papakonstantinou", "D. Quass", "A. Rajaraman", "Y. Sagiv", "J. Ullman", "V. Vassalos", "J. Widom"], "venue": "Journal of Intelligent Information Systems", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1997}, {"title": "ILOG: Declarative creation and manipulation of object identifiers", "author": ["R. Hull", "M. Yoshikawa"], "venue": "Proceedings of the 16th International Conference on Very Large Data Bases,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1990}, {"title": "On the equivalence of database restructurings involving object identifiers", "author": ["R. Hull", "M. Yoshikawa"], "venue": "Proceedings of the Tenth ACM Symposium on Principles of Database Systems,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1991}, {"title": "A logic for programming with complex objects", "author": ["M. Kifer", "J. Wu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1993}, {"title": "Determining view dependencies using tableaux", "author": ["A. Klug", "R. Price"], "venue": "ACM Trans. Database Syst", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1982}, {"title": "Nested dependencies: Structure and reasoning", "author": ["P. Kolaitis", "R. Pichler", "E. Sallinger", "V. Savenkov"], "venue": "Proceedings 33rd ACM Symposium on Principles of Database Systems", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2014}, {"title": "Data integration: A theoretical perspective", "author": ["M. Lenzerini"], "venue": "Proceedings 21st ACM Symposium on Principles of Database Systems, pp", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2002}, {"title": "Querying heterogeneous information sources using source descriptions", "author": ["A.Y. Levy", "A. Rajaraman", "J.J. Ordille"], "venue": "Proceedings 22nd International Conference on Very Large Data Bases,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1996}, {"title": "A logic for objects", "author": ["D. Maier"], "venue": "Workshop on Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1986}, {"title": "Object exchange across heterogeneous information sources", "author": ["Y. Papakonstantinou", "H. Garcia-Molina", "J. Widom"], "venue": "ICDE, pp", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1995}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. Data Semantics", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2008}, {"title": "On directly mapping relational databases to RDF and OWL", "author": ["J.F. Sequeda", "M. Arenas", "D.P. Miranker"], "venue": "In: International Conference on World Wide Web (WWW), pp", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2012}, {"title": "Information integration using logical views", "author": ["J.D. Ullman"], "venue": "Theor. Comput. Sci. 239(2),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2000}], "referenceMentions": [{"referenceID": 2, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 3, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 9, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 1, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 8, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 20, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 22, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 27, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 19, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 38, "endOffset": 42}, {"referenceID": 0, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 73, "endOffset": 76}, {"referenceID": 6, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 14, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 16, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 20, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 22, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 27, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 1, "context": "Oid-equivalence has its origins in the theory of object-creating queries introduced by Abiteboul and Kanellakis [3]; it is the natural generalization of query equivalence in the presence of object creation.", "startOffset": 112, "endOffset": 115}, {"referenceID": 21, "context": "Hull and Yoshikawa [23] studied oid-equivalence (they called it \u2018obscured equivalence\u2019) for nonrecursive ILOG programs; the decidability of this problem is a long-standing open question.", "startOffset": 19, "endOffset": 23}, {"referenceID": 12, "context": "We give a new result relating oid-equivalence to equivalence of classical conjunctive queries under \u2018combined\u2019 bag-set semantics [14], which models the evaluation of CQs when query results and relations may contain duplicates of tuples.", "startOffset": 129, "endOffset": 133}, {"referenceID": 6, "context": "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a", "startOffset": 80, "endOffset": 87}, {"referenceID": 16, "context": "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a", "startOffset": 80, "endOffset": 87}, {"referenceID": 15, "context": "For standard CQs without object creation, two queries are equivalent if and only if they are logically equivalent as schema mappings [17].", "startOffset": 133, "endOffset": 137}, {"referenceID": 6, "context": "Sifo CQs viewed as schema mappings belong to the class of so-called \u2018nested dependencies\u2019 [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).", "startOffset": 90, "endOffset": 93}, {"referenceID": 16, "context": "Sifo CQs viewed as schema mappings belong to the class of so-called \u2018nested dependencies\u2019 [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).", "startOffset": 199, "endOffset": 203}, {"referenceID": 17, "context": "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 55, "endOffset": 59}, {"referenceID": 24, "context": "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 144, "endOffset": 148}, {"referenceID": 20, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 112, "endOffset": 116}, {"referenceID": 16, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 161, "endOffset": 165}, {"referenceID": 6, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 208, "endOffset": 211}, {"referenceID": 18, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 25, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 31, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 28, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 89, "endOffset": 97}, {"referenceID": 31, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 89, "endOffset": 97}, {"referenceID": 26, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 122, "endOffset": 126}, {"referenceID": 4, "context": "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].", "startOffset": 238, "endOffset": 241}, {"referenceID": 7, "context": "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].", "startOffset": 253, "endOffset": 256}, {"referenceID": 7, "context": "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.", "startOffset": 52, "endOffset": 55}, {"referenceID": 4, "context": "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.", "startOffset": 85, "endOffset": 88}, {"referenceID": 29, "context": "As such, sifo CQs can be seen as examples of mapping assertions from source schemas to a global ontology in OBDA [31].", "startOffset": 113, "endOffset": 117}, {"referenceID": 30, "context": "A related application is the direct translation of a relational schema into OWL, which uses as an important building block the creation of IRIs [32].", "startOffset": 144, "endOffset": 148}, {"referenceID": 20, "context": "In this section we introduce our formalism for dealing with conjunctive queries and introduce the notion of object-creating conjunctive query, adapted from the language ILOG [22].", "startOffset": 174, "endOffset": 178}, {"referenceID": 11, "context": "We can now recall the classical notion of conjunctive query (CQ) [2, 13].", "startOffset": 65, "endOffset": 72}, {"referenceID": 20, "context": "Object-creating CQs can be considered to be the conjunctive-query fragment of nonrecursive ILOG [22]; our syntax exposes the Skolem functions, which are normally obscured in the standard ILOG syntax, and our semantics corresponds to what is called the \u2018exposed semantics\u2019 by Hull and Yoshikawa.", "startOffset": 96, "endOffset": 100}, {"referenceID": 21, "context": "Nevertheless, in the following section, we will consider oid-equivalence of sifo CQs, which does correspond to what has been called \u2018obscured equivalence\u2019 [23].", "startOffset": 155, "endOffset": 159}, {"referenceID": 11, "context": "Let us briefly recall these notions now [13, 2].", "startOffset": 40, "endOffset": 47}, {"referenceID": 12, "context": "For our proof, we rely on work by Cohen [14] who studied queries with multiset variables that are evaluated under so-called combined semantics, a semantics that combines set and multiset semantics.", "startOffset": 40, "endOffset": 44}, {"referenceID": 12, "context": "Equivalence of MV queries can be characterized using the notion of multiset-homomorphism [14].", "startOffset": 89, "endOffset": 93}, {"referenceID": 12, "context": "15 ([14], Thm 5.", "startOffset": 4, "endOffset": 8}, {"referenceID": 5, "context": "More specifically, it is a plain SO-tgd [7].", "startOffset": 40, "endOffset": 43}, {"referenceID": 25, "context": "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.", "startOffset": 33, "endOffset": 41}, {"referenceID": 10, "context": "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.", "startOffset": 33, "endOffset": 41}, {"referenceID": 16, "context": "[18] call the chase of I with sotgd(Q).", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "But actually, sifo CQs can also be considered as a restricted form of so-called nested tgds [8].", "startOffset": 92, "endOffset": 95}, {"referenceID": 24, "context": "The answer is affirmative; we have seen in the previous subsection that sifo CQ mappings belong to the class of nested dependencies, and logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 220, "endOffset": 224}, {"referenceID": 23, "context": "The logical implication of JDs by tableau queries is well understood and can be solved by the chase procedure with NP complexity [25, 2].", "startOffset": 129, "endOffset": 136}, {"referenceID": 13, "context": "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].", "startOffset": 83, "endOffset": 91}, {"referenceID": 12, "context": "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].", "startOffset": 83, "endOffset": 91}, {"referenceID": 20, "context": "Sifo CQs and ILOG In the introduction we mentioned that sifo CQs, and oCQs in general, are a fragment of ILOG without recursion [22].", "startOffset": 128, "endOffset": 132}, {"referenceID": 21, "context": "Sifo CQs belong to the subclass of the class of recursion-free ILOG programs \u201cwith isolated oid creation\u201d [23].", "startOffset": 106, "endOffset": 110}, {"referenceID": 21, "context": "Various interesting examples showing the intricacies of this problem have already been given by Hull and Yoshikawa [23].", "startOffset": 115, "endOffset": 119}, {"referenceID": 24, "context": "[26] in work done independently from the present paper.", "startOffset": 0, "endOffset": 4}], "year": 2016, "abstractText": "Conjunctive database queries have been extended with a mechanism for object creation to capture important applications such as data exchange, data integration, and ontology-based data access. Object creation generates new object identifiers in the result, that do not belong to the set of constants in the source database. The new object identifiers can be also seen as Skolem terms. Hence, object-creating conjunctive queries can also be regarded as restricted second-order tuple-generating dependencies (SO tgds), considered in the data exchange literature. In this paper, we focus on the class of single-function object-creating conjunctive queries, or sifo CQs for short. The single function symbol can be used only once in the head of the query. We give a new characterization for oid-equivalence of sifo CQs that is simpler than the one given by Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen\u2019s equivalence notions for conjunctive queries with multiplicities. We also solve the logical entailment problem for sifo CQs, showing that also this problem belongs to NP. Results by Pichler et al. have shown that logical equivalence for more general classes of SO tgds is either undecidable or decidable with as yet unknown complexity upper bounds.", "creator": "LaTeX with hyperref package"}}}