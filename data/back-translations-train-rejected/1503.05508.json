{"id": "1503.05508", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Mar-2015", "title": "Exploration of the scalability of LocFaults approach for error localization with While-loops programs", "abstract": "A model checker can produce a trace of counterexample, for an erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scala-bility capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each found MCD. We present the times of our approach on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraint-based and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, and further the information provided by LocFaults is more expressive for the user.", "histories": [["v1", "Wed, 18 Mar 2015 17:45:20 GMT  (42kb)", "http://arxiv.org/abs/1503.05508v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.SE", "authors": ["mohammed bekkouche"], "accepted": false, "id": "1503.05508"}, "pdf": {"name": "1503.05508.pdf", "metadata": {"source": "CRF", "title": "Exploration of the scalability of LocFaults approach for error localization with While-loops programs", "authors": ["Mohammed Bekkouche"], "emails": ["bekkouch@i3s.unice.fr"], "sections": [{"heading": null, "text": "ar Xiv: 150 3.05 508v 1 [cs.A I] 1 8M ar2 01"}, {"heading": "Categories and Subject Descriptors", "text": "D.3.3 [Language constructs and functions]: Restrictions; D.2.5 [Testing and debugging]: Debugging aids, diagnostics, troubleshooting and troubleshooting"}, {"heading": "General Terms", "text": "verification, algorithms, experiments"}, {"heading": "Keywords", "text": "Error Localization, Localization Errors, BugAssist, Off-by-One Errors, Minimum Correction Deviations, Minimum Correction Subsets"}, {"heading": "1. INTRODUCTION", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "2. DEFINITIONS", "text": "In this section we present the definition of an IIS / MUS and MCS."}, {"heading": "CSP.", "text": "A CSP (Constraint Satisfaction Problem) P is defined as a triple < X, D, C >, where: * X is a set of n variables x1, x2,..., xn. * D is the tuple < Dx1, Dx2,..., Dxn >. The set Dxi contains the values of the variables xi. * C = {c1, c2,..., cn} is the set of constraints. A solution for P is an instantiation of variables I and D that meets all constraints in C. P when there are no solutions. A subset of constraints C in C is also called unworkable for the same reason, except that it is limited to the constraints in C. We call it: \u2022 Sol (< X, C, D >) as unworkable."}, {"heading": "IS.", "text": "An IS (Inconsistent Sentence) is an unworkable subset of constraints within the unworkable C. C is an IS iff: * C \"C. * Sol (< X, C,\" D >) = \u2205."}, {"heading": "IIS or MUS.", "text": "An IIS (Irreducible Inconsistente Set) or MUS (Minimal Unsatisfiable Subset) is an unworkable subset of constraints on C, and all of its strict subsets are workable. C is an IIS iff: * C \"is an IS. * Therefore C.\" Sol (< X, C, \"D >) 6 = \u2205 (each of its parts contributes to the unworkability), C\" is considered irreducible."}, {"heading": "MCS.", "text": "C \u2032 is an MCS (Minimal Correction Set) iff: * C \u2032 s = Minus C. * Sol (< X, C \u2032, D >) 6 = \u2205. * C \"s\" like Sol (< X, C \"\u2032, D >) 6 = \u2205.3. THE PROBLEM \u2264 K-MCD Given a flawed program in CFG2 G = (C, A, E): C is the set of conditional nodes; A is the set of assignment blocks; E is the set of slurs, and a counterexample. A MCD (Minimal Correction Deviation Deviation) is a set of D'C like the propagation of the counterexample of G from the root, while denying any condition 3 in D, allows the deviation to be fulfilled. The output is called minimal (or irreducible) in the sense that no element can be removed from D without losing this condition."}, {"heading": "4. ERROR LOCALIZATION IN LOOPS", "text": "As part of Bounded Model Checking (BMC) for programs, unfolding can be applied to the entire program, or it can be applied to loops separately [9]. Our LocFaults [4] error localization algorithm is placed in the second approach; that is, we use a bound b to unfold loops by replacing them with conditional statements represented in Figures 7 and 8 respectively. While loop is unfolded as 3 times each, is the number of iterations needed for the loop to calculate the minimum value in an array of integers. LocFaults takes as input the CFG of the erroneous program."}, {"heading": "5. ALGORITHM", "text": "Our goal is to find MCDs of size smaller than a bound k; in other words, we are trying to provide a solution to the problem raised above (\u2264 k-MCD). To do this, our algorithm (called LocFaults) examines the CFG in depth and generates paths where at most k conditions deviate from the behavior of the counterexample. To improve efficiency, our heuristic solution progresses step by step, deviating successively from the k conditions and searching the MCSs for the appropriate paths. However, if in step k LocFaults deviates from a ci condition and corrects the program, it does not explore in step k \u2032 > k paths that contain a deviation from the ci condition. To do this, we add the cardinality of the minimum deviation found (k) as information about the CI node. We will illustrate with an example of our approach, as shown in Figure 9. Each circle in the chart."}, {"heading": "6. PRACTICAL EXPERIENCE", "text": "To evaluate the scalability of our programs, we have created two equivalent versions for each program: one version in a Java version and one version in a Java version. We compared their performance with that of BugAssist4 on two systems. * The first benchmark is illustrative, it contains a number of programs without loops; * The second benchmark includes 19, 48 and 91 variations for each of the programs BubbleSort, Sum and SquareRoot. These programs contain loops to examine the scalability of our approach compared to BugAssist. To increase the complexity of a program, we increase the number of iterations in the execution of each tool; we use the same limit of the deployment loops for LocFaults and BugAssist.To generate the CFG and the counter example, we use the tool CPBPV [8] (Restriction Programming Frame for Bounded Program Verification). Locaults and bugAssist work respectively on Java and BugAssist."}, {"heading": "6.1 Benchmark without loops", "text": "This part is intended to illustrate the improvement of LocFaults to reduce the number of subsets of suspicious instructions provided to the user: at a certain step of the algorithm, the node in the CFG of the program that allows the detection of an MCD is marked by the cardinality of the latter; in the next steps, the algorithm will scan an adjacency list of this node. Our result8 show that LocFaults misses errors only for TritypeKO6. While BugAssist errors for AbsMinusKO2, AbsMinusKO3, AbsMinusV2KO2, TritypeKO, TriMultPerimetreKO and one of two errors in TritypeKO5. Times 9 of our tool are better compared with BugAssist for programs with numerical calculation."}, {"heading": "6.2 Benchmarks with loops", "text": "These benchmarks are used to measure the scalability of LocFaults compared to BugAssist for programs with loops, depending on the increase in unfolding b. We took three programs with loops: BubbleSort, Sum and SquareRoot. We have caused the off-by-one errors in each of them. The benchmark for each program is by increasing the number of unfolding b. b is equal to the number of iterations through the loop in the worst case. We also vary the number of deviating conditions for LocFaults from 0 to 3. We used the MIP solver from CPLEX for BubbleSort. For Sum and SquareRoot we work the two solvers of CPLEX (CP and MIP) together during the localization process. In fact, during the capture of constraints we use a variable to keep the information about the type of construction of CSP. If LocFaults find a faulty solution."}, {"heading": "Sort", "text": "This year, it has come to the point where it will be able to establish itself at the top."}, {"heading": "7. CONCLUSION", "text": "The LocFaults method detects suspicious subsets by analyzing the paths of the CFG to find the MCDs and MCSs of each MCD; it uses Constraint Solver. The BugAssit method calculates the merging of MCSs of the program by transforming the entire program into a Boolean formula; it uses Max-SAT Solver. Both methods work by starting from a counter-example. In this paper, we presented an investigation of the scalability of LocFaults, especially when treating loops with the off-by-one bug. The initial results show that LocFaults is more effective than BugAssist programs with loops. The times of BugAssist increase rapidly with the number of unfoldings. As part of our future work, we plan to validate our results on programs with more complex loops. We plan to compare the performance of LocFaults with existing statistical methods. In order to improve our tool, we are developing an interactive point that we have expanded upon the suspicions that provides an interactive point."}, {"heading": "8. ACKNOWLEDGMENTS", "text": "Thanks to Bertrand Neveu for his careful reading and helpful comments on this work, thanks to Michel Rueher and He'le ne Collavizza for their interesting remarks, thanks to You Li for his remarks on English mistakes."}, {"heading": "9. REFERENCES", "text": "[1] R. Abreu, P. Zoeteweij, and A. J. Gemund H. Onthe accuracy of spectrum-based fault localization. In Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007, pp. 89-98. IEEE, 2007. [2] M. Barnett and K. M. Leino. Weakest-precondition of unstructured programs. In ACM SIGSOFT Software Engineering Notes, Volume 31, pp. 82-87. ACM, 2005. [3] M. Bekkouche. Bug stories. In http: / / www.i3s.unice.fr / ~ bekkouch _ stories.html, 2015. [4] M. Bekkouche, H. Collavizza, and M. Rueher."}], "references": [{"title": "On the accuracy of spectrum-based fault localization", "author": ["R. Abreu", "P. Zoeteweij", "A.J. Van Gemund"], "venue": "Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007, pages 89\u201398. IEEE,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "Weakest-precondition of unstructured programs", "author": ["M. Barnett", "K.R.M. Leino"], "venue": "ACM SIGSOFT Software Engineering Notes, volume 31, pages 82\u201387. ACM,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2005}, {"title": "Bug stories", "author": ["M. Bekkouche"], "venue": "http: //www.i3s.unice.fr/~bekkouch/Bug_stories.html,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Une approche csp pour l\u2019aide \u00e0 la localisation d\u2019erreurs", "author": ["M. Bekkouche", "H. Collavizza", "M. Rueher"], "venue": "arXiv preprint arXiv:1404.6567,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Locfaults: A new flow-driven and constraint-based error localization approach", "author": ["M. Bekkouche", "H. Collavizza", "M. Rueher"], "venue": "SAC\u201915, SVT track,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2015}, {"title": "Pinpoint: Problem determination in large, dynamic internet services", "author": ["M.Y. Chen", "E. Kiciman", "E. Fratkin", "A. Fox", "E. Brewer"], "venue": "Dependable Systems and Networks, 2002. DSN 2002. Proceedings. International Conference on, pages 595\u2013604. IEEE,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2002}, {"title": "A tool for checking ansi-c programs", "author": ["E. Clarke", "D. Kroening", "F. Lerda"], "venue": "Tools and Algorithms for the Construction and Analysis of Systems, pages 168\u2013176. Springer,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2004}, {"title": "Cpbpv: a constraint-programming framework for bounded program verification", "author": ["H. Collavizza", "M. Rueher", "P. Van Hentenryck"], "venue": "Constraints, 15(2):238\u2013264,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "A survey of automated techniques for formal software verification", "author": ["V. D\u2019silva", "D. Kroening", "G. Weissenbacher"], "venue": "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "Empirical evaluation of the tarantula automatic fault-localization technique", "author": ["J.A. Jones", "M.J. Harrold"], "venue": "Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering, pages 273\u2013282. ACM,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2005}, {"title": "Visualization of test information to assist fault localization", "author": ["J.A. Jones", "M.J. Harrold", "J. Stasko"], "venue": "Proceedings of the 24th international conference on Software engineering, pages 467\u2013477. ACM,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Bug-assist: assisting fault localization in ansi-c programs", "author": ["M. Jose", "R. Majumdar"], "venue": "Computer Aided Verification, pages 504\u2013509. Springer,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2011}, {"title": "Cause clue clauses: error localization using maximum satisfiability", "author": ["M. Jose", "R. Majumdar"], "venue": "ACM SIGPLAN Notices, 46(6):437\u2013446,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}, {"title": "Algorithms for computing minimal unsatisfiable subsets of constraints", "author": ["M.H. Liffiton", "K.A. Sakallah"], "venue": "Journal of Automated Reasoning, 40(1):1\u201333,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "The msuncore maxsat solver", "author": ["J. Marques-Silva"], "venue": "SAT, page 151,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "A survey of software fault localization", "author": ["W.E. Wong", "V. Debroy"], "venue": "Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45, 9,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 2, "context": "This link [3] cites recent stories of software bugs.", "startOffset": 10, "endOffset": 13}, {"referenceID": 15, "context": "It consists of identifying the exact locations of suspicious instructions [18] to help the user to understand why the program failed, which facilitates him in the task of error correction.", "startOffset": 74, "endOffset": 78}, {"referenceID": 4, "context": "To solve this problem, we have proposed an approach [5] (named LocFaults) based on constraints that explores the paths of CFG (Control Flow Graph) of the program from the counterexample, to calculate the minimal subsets to restore the program\u2019s compliance with its postcondition.", "startOffset": 52, "endOffset": 55}, {"referenceID": 8, "context": "Ensuring that our method is highly scalable to meet the enormous complexity of software systems is an important criterion for its quality [9].", "startOffset": 138, "endOffset": 141}, {"referenceID": 10, "context": ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].", "startOffset": 12, "endOffset": 16}, {"referenceID": 9, "context": ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].", "startOffset": 17, "endOffset": 21}, {"referenceID": 0, "context": ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].", "startOffset": 30, "endOffset": 33}, {"referenceID": 0, "context": ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].", "startOffset": 41, "endOffset": 44}, {"referenceID": 5, "context": ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].", "startOffset": 55, "endOffset": 58}, {"referenceID": 12, "context": "BugAssist [13] [12] is a BMC method of error localization using a Max-SAT solver to calculate the merger of MCSs of the", "startOffset": 10, "endOffset": 14}, {"referenceID": 11, "context": "BugAssist [13] [12] is a BMC method of error localization using a Max-SAT solver to calculate the merger of MCSs of the", "startOffset": 15, "endOffset": 19}, {"referenceID": 1, "context": "We use Dynamic Single Assignment (DSA) form [2] transformation that ensures that each variable is assigned only once on each path of the CFG.", "startOffset": 44, "endOffset": 47}, {"referenceID": 8, "context": "ERROR LOCALIZATION IN LOOPS As part of Bounded Model Checking (BMC) for programs, unfolding can be applied to the entire program or it can be applied to loops separately [9].", "startOffset": 170, "endOffset": 173}, {"referenceID": 3, "context": "Our algorithm LocFaults [4] [5] for error localization is placed in the second approach; that is to say, we use a bound b to unfold loops by replacing them with conditional statements nested of depth b.", "startOffset": 24, "endOffset": 27}, {"referenceID": 4, "context": "Our algorithm LocFaults [4] [5] for error localization is placed in the second approach; that is to say, we use a bound b to unfold loops by replacing them with conditional statements nested of depth b.", "startOffset": 28, "endOffset": 31}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1", "startOffset": 35, "endOffset": 38}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1", "startOffset": 49, "endOffset": 52}, {"referenceID": 2, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 23, "endOffset": 26}, {"referenceID": 0, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 167, "endOffset": 170}, {"referenceID": 1, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 184, "endOffset": 187}, {"referenceID": 2, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 202, "endOffset": 205}, {"referenceID": 0, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 241, "endOffset": 244}, {"referenceID": 1, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 255, "endOffset": 258}, {"referenceID": 2, "context": "{min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 278, "endOffset": 281}, {"referenceID": 0, "context": "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).", "startOffset": 16, "endOffset": 19}, {"referenceID": 1, "context": "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).", "startOffset": 28, "endOffset": 31}, {"referenceID": 2, "context": "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).", "startOffset": 40, "endOffset": 43}, {"referenceID": 0, "context": "This information could CE:{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 46, "endOffset": 49}, {"referenceID": 1, "context": "This information could CE:{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 61, "endOffset": 64}, {"referenceID": 2, "context": "This information could CE:{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 76, "endOffset": 79}, {"referenceID": 7, "context": "To generate the CFG and the counterexample, we use the tool CPBPV [8] (Constraint-Programming Framework for Bounded Program Verification).", "startOffset": 66, "endOffset": 69}, {"referenceID": 13, "context": "We adapted and implemented the algorithm of Liffiton and Sakallah [15], see alg.", "startOffset": 66, "endOffset": 70}, {"referenceID": 6, "context": "BugAssist uses the tool CBMC [7] to generate the faulty trace and input data.", "startOffset": 29, "endOffset": 32}, {"referenceID": 14, "context": "For Max-SAT solver, we used MSUnCore2 [16].", "startOffset": 38, "endOffset": 42}], "year": 2015, "abstractText": "A model checker can produce a trace of counterexample, for an erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each found MCD. We present the times of our approach on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraint-based and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, and further the information provided by LocFaults is more expressive for the user.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}