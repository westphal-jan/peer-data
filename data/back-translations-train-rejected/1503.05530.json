{"id": "1503.05530", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Mar-2015", "title": "Exploration of the scalability of LocFaults", "abstract": "A model checker can produce a trace of counterexample, for an erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each found MCD. We present the times of our approach on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraint-based and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, and further the information provided by LocFaults is more expressive for the user.", "histories": [["v1", "Wed, 18 Mar 2015 18:40:55 GMT  (25kb)", "http://arxiv.org/abs/1503.05530v1", "in French"]], "COMMENTS": "in French", "reviews": [], "SUBJECTS": "cs.AI cs.SE", "authors": ["mohammed bekkouche"], "accepted": false, "id": "1503.05530"}, "pdf": {"name": "1503.05530.pdf", "metadata": {"source": "CRF", "title": "Exploration de la scalabilite\u0301 de LocFaults", "authors": ["Mohammed Bekkouche"], "emails": ["Mohammed.Bekkouche@unice.fr"], "sections": [{"heading": null, "text": "A model that is based on a counter-example for an erroneous program that is often long and difficult to understand. In general, the part about the loops is the largest among the statements in this trace. This makes the position of errors in the loops a critical one to analyze errors in the overall program. In this paper, we explore the scalability of locFaults, our error localization method that has found the paths of the CFG (Control Flow Graph) from a counter-example for calculating the MCDs (Minimal Correction Deviations) and MCSs (Minimal Correction Subsets) from each MCD. We present the times of our approximation to programs with unfolded times from 0 to n. Our preliminary results show that the times of our approximation, constraint-based and flow drives, are better compared with BugAssist, which are based on SAT and are transformed."}], "references": [{"title": "A survey of automated techniques for formal software verification.", "author": ["D\u2019silva", "Vijay", "Daniel Kroening", "Georg Weissenbacher"], "venue": "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 27.7", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Une approche CSP pour l\u2019aide \u00e0 la localisation d\u2019erreurs.", "author": ["Bekkouche", "Mohammed", "H\u00e9l\u00e8ne Collavizza", "Michel Rueher"], "venue": "arXiv preprint arXiv", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "LocFaults : A new flow-driven and constraint-based error localization approach*.", "author": ["Bekkouche", "Mohammed", "H\u00e9l\u00e8ne Collavizza", "Michel Rueher"], "venue": "ACM. SAC\u201915, SVT track,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Weakestprecondition of unstructured programs.", "author": ["Barnett", "Mike", "K. Rustan M. Leino"], "venue": "ACM SIG- SOFT Software Engineering Notes", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2005}, {"title": "A survey of software fault localization.", "author": ["Wong", "W. Eric", "Vidroha Debroy"], "venue": "Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45-09", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2009}, {"title": "Cause clue clauses : error localization using maximum satisfiability.", "author": ["Jose", "Manu", "Rupak Majumdar"], "venue": "ACM SIGPLAN Notices", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Bug-Assist : assisting fault localization in ANSI-C programs.", "author": ["Jose", "Manu", "Rupak Majumdar"], "venue": "Computer Aided Verification", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "CPBPV : a constraint-programming framework for bounded program verification.\u201dConstraints", "author": ["Collavizza", "H\u00e9l\u00e8ne", "Michel Rueher", "Pascal Van Hentenryck"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Algorithms for computing minimal unsatisfiable subsets of constraints.", "author": ["Liffiton", "Mark H", "Karem A. Sakallah"], "venue": "Journal of Automated Reasoning", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "A tool for checking ANSI-C programs.\u201d Tools and Algorithms for the Construction and Analysis of Systems", "author": ["Clarke", "Edmund", "Daniel Kroening", "Flavio Lerda"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2004}, {"title": "The msuncore maxsat solver.", "author": ["Marques-Silva", "Joao"], "venue": "SAT 2009 competitive events booklet : preliminary version", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}], "referenceMentions": [{"referenceID": 4, "context": "Elle consiste \u00e0 identifier l\u2019emplacement exact des instructions suspectes [6] afin d\u2019aider l\u2019utilisateur \u00e0 comprendre pourquoi le programme a \u00e9chou\u00e9, ce qui lui facilite la t\u00e2che de la correction des erreurs.", "startOffset": 74, "endOffset": 77}, {"referenceID": 2, "context": "Pour r\u00e9soudre ce probl\u00e8me, nous avons propos\u00e9 une approche [4] (nomm\u00e9e LocFaults) \u00e0 base de contraintes qui explore les chemins du CFG(Control Flow Graph) du programme \u00e0 partir du contre-exemple, pour calculer les sous-ensembles minimaux permettant de restaurer la conformit\u00e9 du programme vis-\u00e0-vis de sa postcondition.", "startOffset": 59, "endOffset": 62}, {"referenceID": 0, "context": "Assurer que notre m\u00e9thode soit hautement scalable pour faire face \u00e0 l\u2019\u00e9norme complexit\u00e9 des syst\u00e8mes logiciels est un crit\u00e8re important pour sa qualit\u00e9 [1].", "startOffset": 152, "endOffset": 155}, {"referenceID": 5, "context": "BugAssist [9] [10] est une m\u00e9thode de localisation d\u2019erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Bool\u00e9enne du programme en entier avec le contre-exemple.", "startOffset": 10, "endOffset": 13}, {"referenceID": 6, "context": "BugAssist [9] [10] est une m\u00e9thode de localisation d\u2019erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Bool\u00e9enne du programme en entier avec le contre-exemple.", "startOffset": 14, "endOffset": 18}, {"referenceID": 3, "context": "Nous utilisons la transformation en forme DSA [5] qui assure que chaque variable est affect\u00e9e une seule fois sur chaque chemin du CFG.", "startOffset": 46, "endOffset": 49}, {"referenceID": 0, "context": "Dans le cadre du Bounded Model Checking (BMC) pour les programmes, le d\u00e9pliage peut \u00eatre appliqu\u00e9 au programme en entier comme il peut \u00eatre appliqu\u00e9 aux boucles s\u00e9par\u00e9ment [1].", "startOffset": 172, "endOffset": 175}, {"referenceID": 1, "context": "Notre approche de localisation d\u2019erreurs, LocFaults [3] [4], se place dans la deuxi\u00e8me d\u00e9marche ; c\u2019est-\u00e0-dire, nous utilisons une borne b pour d\u00e9plier les boucles en les rempla\u00e7ant par des imbrications de conditionnelles de profondeur b.", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "Notre approche de localisation d\u2019erreurs, LocFaults [3] [4], se place dans la deuxi\u00e8me d\u00e9marche ; c\u2019est-\u00e0-dire, nous utilisons une borne b pour d\u00e9plier les boucles en les rempla\u00e7ant par des imbrications de conditionnelles de profondeur b.", "startOffset": 56, "endOffset": 59}, {"referenceID": 0, "context": "\u00c0 partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustr\u00e9 sur la figure 8 le chemin fautif initial (voir le chemin color\u00e9 en rouge), ainsi que la d\u00e9viation pour laquelle la postcondition est satisfaisable (la d\u00e9viation ainsi que le chemin au-dessus de la condition d\u00e9vi\u00e9e sont illustr\u00e9s en vert).", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "\u00c0 partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustr\u00e9 sur la figure 8 le chemin fautif initial (voir le chemin color\u00e9 en rouge), ainsi que la d\u00e9viation pour laquelle la postcondition est satisfaisable (la d\u00e9viation ainsi que le chemin au-dessus de la condition d\u00e9vi\u00e9e sont illustr\u00e9s en vert).", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 35, "endOffset": 38}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 80, "endOffset": 83}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 224, "endOffset": 227}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 259, "endOffset": 262}, {"referenceID": 0, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 298, "endOffset": 301}, {"referenceID": 1, "context": "PATH MCSs {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {min2 = tab0[i1]} \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] \u2265 min3) \u2227 (tab[1] \u2265 min3) \u2227(tab[2] \u2265 min3) \u2227 (tab[3] \u2265 min3)]} {CE : [tab0[0] = 3 \u2227 tab0[1] = 2 \u2227 tab0[2] = 1 {i0 = 1}, \u2227tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[\u00ac(i2 \u2264 tab0.", "startOffset": 335, "endOffset": 338}, {"referenceID": 0, "context": "CE :{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 24, "endOffset": 27}, {"referenceID": 1, "context": "CE :{tab0[0] == 3 \u2227 tab0[1] == 2 \u2227 tab0[2] == 1 \u2227 tab0[3] == 0}", "startOffset": 54, "endOffset": 57}, {"referenceID": 7, "context": "Pour g\u00e9n\u00e9rer le CFG et le contre-exemple, nous utilisons l\u2019outil CPBPV [11] (Constraint-Programming Framework for Bounded Program Verification).", "startOffset": 71, "endOffset": 75}, {"referenceID": 8, "context": "com/software/commerce/optimization/cplex-cpavons adapt\u00e9 et impl\u00e9ment\u00e9 l\u2019algorithme de Liffiton et Sakallah [12], voir alg.", "startOffset": 107, "endOffset": 111}, {"referenceID": 9, "context": "BugAssist utilise l\u2019outil CBMC [13] pour g\u00e9n\u00e9rer la trace erron\u00e9e et les donn\u00e9es d\u2019entr\u00e9e.", "startOffset": 31, "endOffset": 35}, {"referenceID": 10, "context": "Pour le solveur Max-SAT, nous avons utilis\u00e9 MSUnCore2 [14].", "startOffset": 54, "endOffset": 58}, {"referenceID": 0, "context": "[1] D\u2019silva, Vijay, Daniel Kroening, and Georg Weissenbacher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[3] Bekkouche, Mohammed, H\u00e9l\u00e8ne Collavizza, and Michel Rueher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[4] Bekkouche, Mohammed, H\u00e9l\u00e8ne Collavizza, and Michel Rueher.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[5] Barnett, Mike, and K.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[6] Wong, W.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[9] Jose, Manu, and Rupak Majumdar.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[10] Jose, Manu, and Rupak Majumdar.", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "[11] Collavizza, H\u00e9l\u00e8ne, Michel Rueher, and Pascal Van Hentenryck.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[12] Liffiton, Mark H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[13] Clarke, Edmund, Daniel Kroening, and Flavio Lerda.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[14] Marques-Silva, Joao.", "startOffset": 0, "endOffset": 4}], "year": 2015, "abstractText": "A model checker can produce a trace of counterexample, for a erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each MCD found. We present the times of our approach on programs with While-loops unfolded b times, and a number of diverted conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraintbased and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, although the information provided by LocFaults is more expressive for the user.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}