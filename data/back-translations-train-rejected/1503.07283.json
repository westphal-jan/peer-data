{"id": "1503.07283", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Mar-2015", "title": "Morphological Analyzer and Generator for Russian and Ukrainian Languages", "abstract": "pymorphy2 is a morphological analyzer and generator for Russian and Ukrainian languages. It uses large efficiently encoded lexi- cons built from OpenCorpora and LanguageTool data. A set of linguistically motivated rules is developed to enable morphological analysis and generation of out-of-vocabulary words observed in real-world documents. For Russian pymorphy2 provides state-of-the-arts morphological analysis quality. The analyzer is implemented in Python programming language with optional C++ extensions. Emphasis is put on ease of use, documentation and extensibility. The package is distributed under a permissive open-source license, encouraging its use in both academic and commercial setting.", "histories": [["v1", "Wed, 25 Mar 2015 05:28:50 GMT  (52kb)", "http://arxiv.org/abs/1503.07283v1", "AIST 2015 (this http URL); 12 pages"]], "COMMENTS": "AIST 2015 (this http URL); 12 pages", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["mikhail korobov"], "accepted": false, "id": "1503.07283"}, "pdf": {"name": "1503.07283.pdf", "metadata": {"source": "CRF", "title": "Morphological Analyzer and Generator for Russian and Ukrainian Languages", "authors": ["Mikhail Korobov"], "emails": ["kmike84@gmail.com"], "sections": [{"heading": null, "text": "ar Xiv: 150 3.07 283v 1 [cs.C L] 25 Mar 2Keywords: morphological analyzer, Russian, Ukrainian, morphological generator, open source, OpenCorpora, LanguageTool, pymorphy2, pymorphy"}, {"heading": "1 Introduction", "text": "Morphological analysis is an analysis of the internal structure of words. For languages with rich morphology, such as Russian or Ukrainian, it is possible to determine from morphological analysis whether a word can be a noun or a verb, or whether it can be singular or plural. Morphological analysis is an important step in the natural language processing pipelines for such languages. Morphological generation is a process of building a word based on its grammatical representation; this includes lemmatization, diffraction and locating word lexemens. pymorphy2 is a morphological analyzer and generator for the Russian and Ukrainian languages that is widely used in industry and science. It has been developed since 2012; Ukrainian support is a recent addition. The development of its predecessor, pymorphy1, began in 2009. The package is available under a permissive license (MIT)."}, {"heading": "2 Software Architecture", "text": "Pymorphy2 is implemented as a cross-platform Python3 library, with a command-line program and optional C + + extensions for faster analysis; both Python 2.x and Python 3.x are supported; an extensive test suite (600 + unit tests) ensures code quality; test coverage is maintained above 90%; there is online documentation4 vocabulary available; if optional C + + + extension is used (or if Pymorphy2 is run with Python interpreter), the evaluation speed is usually tens of thousands of words per second; in some specific cases, vocabulary can exceed 100,000 words per second in a single thread; without the extension, the evaluation speed is in thousands of words per second; memory usage is about 15MB, or about 30MB if we take the Python interpreter into account; users are provided with a simple API for working with their words, analytics and tags."}, {"heading": "3 Analysis of Vocabulary Words", "text": "Pymorphy2 is based on large dictionaries for the analysis of common words. For Russian, it uses the dictionary OpenCorpora [3], which is optimized for morphological analysis and generational tasks. End-users do not have to compile the dictionaries themselves; pymorphy2 is developed by Andriy Rysin, Dmitry Chaplinsky, Mariana Romanyshyn and other contributors. Any dictionary in OpenCorpora XML format can be used by Pymorphy2. In Ukrainian, there is such an experimental dictionary (2, 2,5, 106 word forms), which is developed by Andriy Rysin, Dmitry Chaplinsky, Mariana Romanyshyn and other contributors."}, {"heading": "3.1 Morphological Analysis and Generation", "text": "This year it has come to the point that it is a purely reactionary, reactionary, reactionary and reactionary project, in which it is a reactionary, reactionary and reactionary project."}, {"heading": "3.2 Working with \"\u0451\" and \"\u0491\" Characters Efficiently", "text": "The use of letters is optional in Russian; in real texts it is often replaced by letters. There are rules for replacing letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters with letters from the real world. However, this is suboptimal because it rejects useful information, makes the text less correct (in Ukrainian \"\u0433\" can be considered a misspelling of letters with letters with letters with letters with letters with letters from the real world) and increases ambiguity: There are words whose analysis of letters with letters with letters with letters with letters from the real world should depend on the text (in Ukrainian \"\u0433\" instead of \"\u0439\" can be considered a misspelling)."}, {"heading": "4 Analysis of Out-of-Vocabulary Words", "text": "It is not practical to try to include all words in a lexicon - there is a long tail of rarely used words, new words appear; there are morphological derivatives, loanwords, it is difficult to include all names, places and special terms in the dictionary. Empirically, Zipf's law seems to apply to natural languages [14]; one of the consequences is that even doubling the size of a lexicon could only slightly increase the reach [6]. For languages without rich morphology, it may be practical to assume that a word, if it is not in a dictionary, can be from any class of the open word classes, and then to refute the results in later processing steps, e.g. with a contextual POS tagger or a syntactic parser. For Slavic languages that do so in later phases, it is a challenge due to large tag sets - for example, OpenCorpora [3] words have more than 4,500 different tags based on morphology, for example, by releasing the number of possible word analyzers based on certain rules."}, {"heading": "4.1 Common Prefixes Removal", "text": "There are a number of invariant prefixes that can be appended to words of open classes (nouns, verbs, adjectives, adverbs, participle, rounding) without affecting the grammatical properties of the word. Examples of such prefixes in Russian: \"\u043d\u0435,\" \"\u043f\u0441\u0435\u0432\u0435\u0432\u0435\u0432\u0435\u0432\u043e,\" \"\u0430\u0432\u0438\u0430\"; pymorphy2 provides language-specific lists of these prefixes. If a word begins with one of these prefixes, pymorphy2 removes the prefix, analyzes the memory and inserts the prefix again. A similar rule is described in [8]."}, {"heading": "4.2 Words Ending with Other Dictionary Words", "text": "If everything that follows applies to pymorphy2, it is assumed that the whole word can be analyzed in the same way as the \"suffix\" word: - a word that is analyzed has another word from a dictionary as a suffix; - the length of that \"suffix\" word is greater than 3; - the length of the word without a \"suffix\" is not greater than 5; - the \"suffix\" word belongs to an open class (noun, verb, adjective, participle, gerund) To search for suffixes, Pymorphy2 tries to consider the first letter as a prefix, then two first letters as a prefix, and so on, and searches for memory in a dictionary. This rule is the same as described in [10]. A similar rule is described in [8], although its induction for specific prefixes is different."}, {"heading": "4.3 Endings Matching", "text": "In many languages, including Russian and Ukrainian, words with common endings often have the same grammatical form.To take advantage of this, pymorphy2 first collects the information from the dictionary: for each word, all endings of length 1 to 5 are extracted, and all possible analyses for these endings are stored. Then, this extension \u2192 {Analyses} mapping is discarded: - only the most common analyses for each POS tag are also discarded; - analyses from unproductive paradigms (currently, these are paradigms produced less than 3 encyclopedias in a dictionary) are discarded; - rare endings (currently, those that occur once) are also discarded; - the resulting mapping is encoded on DAFSA for quick research. Storage scheme is the following: < Extension > SEP < Analyses Info >, where the analyses consist of three 2-byte numbers: (frequency, paradigmatid, index) is one."}, {"heading": "4.4 Words with a Hyphen", "text": "Unlike some other morphological analyzers, pymorphy2 chooses to use hyphenated words. [7] It is argued that the parts of compound words should in most cases be treated as separate words when joined by a hyphen. In both cases, the decisions are not motivated by linguistic considerations; it is the technical difficulty that prevents the analysis and processing of such words as individual entities. Currently, pymorphy2 treats adverbs with a hyphen, particles separated by a hyphen, and compound words with a hyphen. It is the technical difficulty to analyze and process words like individual entities."}, {"heading": "4.5 Other Tokens", "text": "The first letter is an abbreviation for the first or last name of a person. In most cases, a first letter is a single uppercase letter (language-specific). pymorphy2 analyzes such characters as fixed singular nouns, with variants for all possible gender and case combinations. For person names (names), two different lexems are formed for male and female names. For patronymic names (patrons), a single lexeme is returned. Unlike all other analysis rules, the recognition of initials is uppercase and lowercase. This is a way to reduce ambiguity. The following tags are not assigned lexical tokens: PNCT for punctuation, LATN for tokens written in Latin alphabet, NUMB, intg for integer numbers, NUMB, real for floating numbers, ROMN for Roman numbers. When analyzing the text, it is customary to classify tokens during the token."}, {"heading": "4.6 Morphological Generation of Out of Vocabulary Words", "text": "To achieve this, pymorphy2 keeps track of the analytical units (rules and their parameters) used to parse the word, requires each analytical unit to provide a method for obtaining a lexeme, and calls this method for the last analytical unit. To calculate the lexem analyzer, it can view the analysis result and ask previous analytical units for the lexem. For example, Common Prefixes Removal Analyzer removes the prefix from a word, then receives a lexem from the previous analyzer, and then adds the prefix to each word form in a lexem to form a resulting lexem."}, {"heading": "5 Probability Estimation", "text": "The problem of selecting the correct analysis from a list of possible options is called disambiguation. (& tag) & tag > per day, it is necessary to consider the word context; the morphological analyzer takes individual words as input so that it does not rust.In addition, these probabilities can be used in later stages of text analysis, for example by a disambiguator.To estimate P (analysis | word) conditional probability for Russian words pymorphy2, a word pymorphy2 is used partially disambiguated OpenCorpora corpus [3] and assumes that P (analysis | word) = pseudoformability (tag | word) is used as pseudoformation."}, {"heading": "6 Evaluation", "text": "In fact, it is as if it were acting in a way, as it did in the past years in the USA, in Europe, in Europe, in the world, in Europe, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in the world, in, in, in, in, in the world, in, in the world, in, in, in, in the world, in, in the world, in, in the world, in, in, in, in, in, in the world, in, in the world, in, in, in the world, in, in, in the world, in the world, in the world, in, in, in the world, in, in the world, in the world, in the, in the world, in the world, in, in, in the world, in, in the world, in, in, in the world, in the world, in the world, in"}, {"heading": "7 Conclusion and Future Plans", "text": "There are volunteers working on Russian and Ukrainian dictionaries and corpora, related tools and pymorphy2 itself. Development of pymorphy2 is far from complete. There are word classes for which Pymorphy2 analysis can be improved, some of them: personal names, first and last names, smallest first names, places, uppercase letters and other abbreviations, some classes of separated words, ordinal numbers (including digits written in digital notation such as \"22-\u0439\"). According to [1] similar problems are common for Russian morphological analysis, smallest first names, places, uppercase letters and other abbreviations."}], "references": [{"title": "NLP Evaluation: Russian Morphological Parsers", "author": ["I. Astaf \u2019eva", "A. Bonch-Osmolovskaya", "A. Garejshina", "Ju. Grishina", "V. D\u2019jachkov", "M. Ionov", "A. Koroleva", "M. Kudrinsky", "A. Lityagina", "E. Luchina", "E. Sidorova", "S. Toldova", "O. Lyashevskaya", "S. Savchuk", "S. Koval\u2019"], "venue": "Kibrik A. (ed.). Computational Linguistics and Intellectual Technologies. Papers from the Annual International Conference \u201cDialogue\u201d. Volume 1.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2010}, {"title": "Probabilistic Tokenization Model in the OpenCorpora Project [Veroyatnastnaya model\u2019 tokenizacii v proekte Otkritiy Korpus]. In: New Information Technology in Automated Systems: proceedings of the 15th seminar [Noviye informacionnie tehnologii v avtomatizirovannih sistemah: materiali pyatnadcatogo nauchno-prakticheskogo seminara", "author": ["V.V. Bocharov", "D.V. Granovsky", "A.V. Surikov"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Crowdsourcing morphological annotation", "author": ["V.V. Bocharov", "S.V. Alexeeva", "D.V. Granovsky", "E.V. Protopopova", "M.E. Stepanova", "A.V. Surikov"], "venue": "Selegey V. (ed.) Computational Linguistics and Intellectual Technologies. Papers from the Annual International Conference \u201cDialogue\u201d. Volume 1.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "I.:An Automatic Morphological Classifier of Noun Phrases in Russian", "author": ["I.A. Bolshakov", "E. Bolshakova"], "venue": "Kibrik A. (ed.) Computational Linguistics and Intellectual Technologies. Papers from the Annual International Conference \u201cDialogue\u201d Volume", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "Incremental Construction of Minimal Acyclic Finite-State Automata", "author": ["J. Daciuk", "B.W. Watson", "S. Mihov", "R.E. Watson"], "venue": "Computational Linguistics 26(1)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Treatment of Unknown Words. In: proceedings of Workshop on Implementing Automata WIA\u201999", "author": ["J. Daciuk"], "venue": "Potsdam, Germany,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1999}, {"title": "Current Morphological Analysis and Synthesis Challanges in the STARLING system [Aktualniye zadachi morfologicheskogo analiza i sinteza v integrirovannoy informacionnoy srede STARLING", "author": ["S.A. Krylov", "S.A. Starostin"], "venue": "Proceedings of the International Conference \u201cDialog 2003\u201d", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2003}, {"title": "Automatic Rule Induction for Unknown Word Guessing", "author": ["A. Mikheev"], "venue": "Computational Linguistics, Vol. 23(3)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1997}, {"title": "A fast morphological algorithm with unknown word guessing induced by a dictionary for a web search engine", "author": ["I. Segalovich"], "venue": "In Proc. of MLMTA-2003 Las Vegas", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2003}, {"title": "Morphological Modules on the web-site www.aot.ru [Morphologicheskie Moduli na saite www.aot.ru", "author": ["A. Sokirko"], "venue": "Computational Linguistics and Intelligent Technologies: Proceedings of the International Conference \u201cDialog 2004\u201d", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2004}, {"title": "Fast String Matching with Space-efficient Word Graphs", "author": ["S. Yata", "K. Morita", "M. Fuketa", "J. Aoe"], "venue": "Innovations in Information Technology (Innovations \u201908) Al Ain, United Arab Emirates", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2008}, {"title": "Grammaticeskij slovar\u2019 russkogo jazyka", "author": ["A.A. Zaliznjak"], "venue": "Moscow, Russia", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1977}, {"title": "Improvised-temporary-compounds as a new expressive mean in Russian", "author": ["N.N. Zanegina"], "venue": "Kibrik A. (ed.) Computational Linguistics and Intellectual Technologies. Papers from the Annual International Conference \u201cDialogue\u201d Volume 1.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Selected Studies of the Principle of Relative Frequency in Language", "author": ["G.K. Zipf"], "venue": "Cambridge, MA.: Harvard University Press", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1932}], "referenceMentions": [{"referenceID": 2, "context": "For Russian it uses OpenCorpora [3] dictionary (\u223c 5 \u2217 10 word forms, \u223c 0.", "startOffset": 32, "endOffset": 35}, {"referenceID": 4, "context": "To create a compact representation and enable fast access pymorphy2 encodes lexeme information: all words are stored in a DAFSA [5] using the dawgdic C++ library [11] via Python wrapper; information about word tags and lexemes is", "startOffset": 128, "endOffset": 131}, {"referenceID": 10, "context": "To create a compact representation and enable fast access pymorphy2 encodes lexeme information: all words are stored in a DAFSA [5] using the dawgdic C++ library [11] via Python wrapper; information about word tags and lexemes is", "startOffset": 162, "endOffset": 166}, {"referenceID": 9, "context": "ru [10], but it is not quite the same.", "startOffset": 3, "endOffset": 7}, {"referenceID": 8, "context": "Other storage schemes were tried, including two tries scheme similar to described in [9] (but using double-array tries), and succinct (MARISA) tries.", "startOffset": 85, "endOffset": 88}, {"referenceID": 4, "context": "To do the task efficiently, pymorphy2 exploits DAFSA [5] dictionary structure: the result is built by traversing the word character graph and trying to follow \"\u0451\" transitions in addition to \"\u0435\" transitions (for Russian) and \"\u0491\" transitions in addition to \"\u0433\" transitions (for Ukrainian).", "startOffset": 53, "endOffset": 56}, {"referenceID": 13, "context": "Empirically, Zipf\u2019s Law seems to hold for natural languages [14]; one", "startOffset": 60, "endOffset": 64}, {"referenceID": 5, "context": "of the consequences is that even doubling the size of a lexicon could increase the coverage only slightly [6].", "startOffset": 106, "endOffset": 109}, {"referenceID": 2, "context": "For Slavic languages doing this on later stages is challenging because of large tagsets - for example, OpenCorpora [3] words have more than 4500 different tags.", "startOffset": 115, "endOffset": 118}, {"referenceID": 7, "context": "Some of the rules are described in literature [8,9,10,6,4]; the resulting combination is novel.", "startOffset": 46, "endOffset": 58}, {"referenceID": 8, "context": "Some of the rules are described in literature [8,9,10,6,4]; the resulting combination is novel.", "startOffset": 46, "endOffset": 58}, {"referenceID": 9, "context": "Some of the rules are described in literature [8,9,10,6,4]; the resulting combination is novel.", "startOffset": 46, "endOffset": 58}, {"referenceID": 5, "context": "Some of the rules are described in literature [8,9,10,6,4]; the resulting combination is novel.", "startOffset": 46, "endOffset": 58}, {"referenceID": 3, "context": "Some of the rules are described in literature [8,9,10,6,4]; the resulting combination is novel.", "startOffset": 46, "endOffset": 58}, {"referenceID": 7, "context": "A similar rule is described in [8].", "startOffset": 31, "endOffset": 34}, {"referenceID": 9, "context": "This rule is the same as described in [10].", "startOffset": 38, "endOffset": 42}, {"referenceID": 7, "context": "A similar rule is described in [8], though its induction for concrete prefixes is different.", "startOffset": 31, "endOffset": 34}, {"referenceID": 9, "context": "This rule is based on [10]; similar approaches are also used in [4] and [9].", "startOffset": 22, "endOffset": 26}, {"referenceID": 3, "context": "This rule is based on [10]; similar approaches are also used in [4] and [9].", "startOffset": 64, "endOffset": 67}, {"referenceID": 8, "context": "This rule is based on [10]; similar approaches are also used in [4] and [9].", "startOffset": 72, "endOffset": 75}, {"referenceID": 7, "context": "[8] uses similar rules, but derives them differently.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "In [7] it is argued that in most cases the parts of compound words should be handled as separate words if they are joined using a hyphen.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "A similar decision is made in OpenCorpora tokenization module [2]; it considers words like \"\u0416\u0430\u043d\u041f\u043e\u043b\u044c\" as three tokens which should be analyzed separately and joined back at later processing stages.", "startOffset": 62, "endOffset": 65}, {"referenceID": 3, "context": "A similar method was used in [4].", "startOffset": 29, "endOffset": 32}, {"referenceID": 12, "context": "Words with multiple hyphens are likely represent different phenomena in Russian and Ukrainian languages; they could be interjections or phrases [13].", "startOffset": 144, "endOffset": 148}, {"referenceID": 2, "context": "To estimate P (analysis|word) conditional probability for Russian words pymorphy2 uses partially disambiguated OpenCorpora corpus [3] and assumes that P (analysis|word) = P (tag|word).", "startOffset": 130, "endOffset": 133}, {"referenceID": 8, "context": "0 [9].", "startOffset": 2, "endOffset": 5}, {"referenceID": 0, "context": "The most sophisticated Russian morphological parser evaluation so far is [1]; it happened in 2010.", "startOffset": 73, "endOffset": 76}, {"referenceID": 9, "context": "pymorphy used some pymorphy2 rules (not all) and a different dictionary (extracted from [10] instead of [3]).", "startOffset": 88, "endOffset": 92}, {"referenceID": 2, "context": "pymorphy used some pymorphy2 rules (not all) and a different dictionary (extracted from [10] instead of [3]).", "startOffset": 104, "endOffset": 107}, {"referenceID": 0, "context": "According to [1], similar issues are common for Russian morphological analyzers.", "startOffset": 13, "endOffset": 16}], "year": 2015, "abstractText": "pymorphy2 is a morphological analyzer and generator for Russian and Ukrainian languages. It uses large efficiently encoded lexicons built from OpenCorpora and LanguageTool data. A set of linguistically motivated rules is developed to enable morphological analysis and generation of out-of-vocabulary words observed in real-world documents. For Russian pymorphy2 provides state-of-the-arts morphological analysis quality. The analyzer is implemented in Python programming language with optional C++ extensions. Emphasis is put on ease of use, documentation and extensibility. The package is distributed under a permissive open-source license, encouraging its use in both academic and commercial setting.", "creator": "LaTeX with hyperref package"}}}