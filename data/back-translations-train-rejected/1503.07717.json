{"id": "1503.07717", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Mar-2015", "title": "ASPeRiX, a First Order Forward Chaining Approach for Answer Set Computing", "abstract": "The natural way to use Answer Set Programming (ASP) to represent knowledge in Artificial Intelligence or to solve a combinatorial problem is to elaborate a first order logic program with default negation. In a preliminary step this program with variables is translated in an equivalent propositional one by a first tool: the grounder. Then, the propositional program is given to a second tool: the solver. This last one computes (if they exist) one or many answer sets (stable models) of the program, each answer set encoding one solution of the initial problem. Until today, almost all ASP systems apply this two steps computation. In this article, the project ASPeRiX is presented as a first order forward chaining approach for Answer Set Computing. This project was amongst the first to introduce an approach of answer set computing that escapes the preliminary phase of rule instantiation by integrating it in the search process. The methodology applies a forward chaining of first order rules that are grounded on the fly by means of previously produced atoms. Theoretical foundations of the approach are presented, the main algorithms of the ASP solver ASPeRiX are detailed and some experiments and comparisons with existing systems are provided.", "histories": [["v1", "Thu, 26 Mar 2015 12:57:22 GMT  (238kb,D)", "http://arxiv.org/abs/1503.07717v1", "49 pages. To appear in Theory and Practice of Logic Programming (TPLP)"], ["v2", "Wed, 16 Nov 2016 15:08:22 GMT  (275kb,D)", "http://arxiv.org/abs/1503.07717v2", "50 pages. To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "49 pages. To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["claire lef\\`evre", "christopher b\\'eatrix", "igor st\\'ephan", "laurent garcia"], "accepted": false, "id": "1503.07717"}, "pdf": {"name": "1503.07717.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Claire Lef\u00e8vre", "Christopher B\u00e9atrix", "Igor St\u00e9phan", "Laurent Garcia"], "emails": ["claire@info.univ-angers.fr", "beatrix@info.univ-angers.fr", "stephan@info.univ-angers.fr", "garcia@info.univ-angers.fr"], "sections": [{"heading": null, "text": "This article introduces the ASPeRiX project as a first-order approach to Answer Set Computing. This project was one of the first to introduce a response set computing approach that escapes the preliminary phase of rule instantiation by integrating it into the search process.The methodology applies a first-order forward concatenation of rules based on already produced atoms, the theoretical foundations of the approach are presented, the main algorithms of the ASP solver ASPeRiX are detailed, and some experiments and comparisons with existing systems.KEYWORDS: Answer Set Programming, Solver Implementation, Grounding on the Fly, First Order, Forward Chaining are provided."}, {"heading": "1 Introduction", "text": "It is a very convenient paradigm to represent knowledge in artificial intelligence (AI) and to encode combinatorial problems (Baral 2003; Niemela 1999). It has its roots in nonmonotonous thinking and logical programming and has led to a lot of work since some efficient solutions are available. In a few words, if someone wants to support this work, this is supported by ANR (National Research Agency), the project ASPIQ under the reference ANR-12-0003.ar Xiv: 150 3.07 717v 1 [cs.L O] 2to use ASP to solve a problem, he has to write a logical program in a purely declarative manner."}, {"heading": "2 Theoretical Background", "text": "In this section we will give the main background of the ASP framework that is useful for understanding this article. Set V denotes the infinitely countable set of variables, Set FS denotes the set of function symbols, Set CS denotes the set of constant symbols, and Set PS denotes the set of predicate symbols. It is assumed that the set of terms defined by induction is defined as follows: \u2022 if the set CS is not empty then. Function ar denotes the set of constants from FS to N that is associated with any function or predicate symbol. Set T denotes the set of terms defined by induction: \u2022 if V then the set CS is not empty \u2022 if the activity function is denoted from FS to N. \u2022 if f FS is denoted by ar (f) = n > 0 and t1,."}, {"heading": "3.3 Functions \u03b3", "text": "It is the function which in the first phase of the search for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for the question for the question for an answer to the question for the answer to the question for the question for the answer to the question for the answer to the question for the question for the question for an answer to the question for the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for an answer to the question for the answer to the question for an answer to the question for the answer to the question for the question for an answer to the question for the answer to the question for the answer to the question for the question for the question for the question for the answer for the answer for the answer to the question for the answer for the question for the answer for the answer for the question for the answer to the question for the answer to the question for the answer for the answer for the question for the answer for the question for the answer for the answer for the question for the answer for the answer for the answer for the answer"}, {"heading": "9 until \u03b8 6= NULL or R = \u2205;", "text": "The answer is searched for the selection point for the rule (a (1) n (1), not b (1), not b (2), not b (2), not b (2), not b (2), not b (2). (selection point CP1) (selection point CP1): the atoms (1) and b (2) are included in the sentence OUT to force the rule (left branch after selection point CP1). During the propagation step, many calls to the function Pro are made. During the first call, the sentence R consists of all rules that contain the predicate symbol of the atoms b (1) and b (2) in their negative body."}, {"heading": "9 until \u03b8 6= NULL or R = \u2205;", "text": "10 if \u03b8 6 = Nctul then / * An applicable instantiation rule is found * / 11 subst (r) \u2190 subst (r) \u0432 {\u03b8}; 12 return \u03b8 (r); 13 else 14 return Naccil; 15 else 16 return NULL; of this set and a (1) \u2190 n (1), not b (1), not b (2).) is returned to the calling function solve (option CP1) and a selection point n (2), not b (2), not b (3), not b (3), not b (X), not b (X), not b (1), not b), not b), not b (2), not b (2), not b (3), not b (3).) is returned to the calling function solve (option CP2)."}, {"heading": "9 until \u03b8 6= NULL or C = \u2205;", "text": "10 if \u03b8 6 = NULL then / * A true instantiated constraint is found * / 11 returns true; 12 otherwise 13 returns false; 14 otherwise 15 returns false;"}, {"heading": "3.4 Rule Instantiation", "text": "This section describes the process of instantiating a rule, which is a rotten process that is only mentioned when needed. As we only consider safe rules, the instantiation of a rule is actually the instantiation of its positive body. In a forward-looking approach, the only rule used in the ASPeRiX solution that leads to an unblocked rule or rule is therefore mainly guided by the instantiated atoms already present in the IN and MBT sets. The algorithms used in the ASPeRiX solution and described below are inspired by the earlier work of DLV grounder (Faber et al. 2012), which is based on the semi-naive evaluation technology of (Ullman 1989), with the aim of finding a substitution for all the letters of a rule that already exist in IN, MBT or OUT thanks to the atoms."}, {"heading": "6 else", "text": "The first question, which arises in the second question, is the question of the nature and manner of the question, such as the second question, the second question, the second question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question, the third question,"}, {"heading": "4 Experimental results", "text": "In fact, most of them are able to survive by themselves if they do not play by the rules. (...) Most of them are able to survive by themselves. (...) Most of them are not able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...) Most of them are able to survive by themselves. (...)"}, {"heading": "5 Conclusion", "text": "This year it has come to the point that it will be able to remention and recite the aforementioned hreeisrcnlrVo until they are able to recite themselves, \"he said."}, {"heading": "Appendix A Hanoi example", "text": "The following ASP program is the Hanoi example with 4 moves.% ------ Defaults Number of moves (10000). Biggest disk (4).% ------ Default state (towers (l (4, l (3, l (2, l (2, l (1, nil))))), nil, nil (nil).% ------ Goal entry destination (towers (nil, nil (4, l (3, l (2, l (1, nil))))).% ------ All dice involved -- Disc (1.. 4).% ------ Legal stack ------ legalStack (nil). legalStack (T, nil (2, nil)): - Disc (T). legalStack (T). legalStack (l (T, l (T1, S)))): - legalStack (1, legalStack)."}, {"heading": "Appendix B Proofs", "text": "B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B. B."}], "references": [{"title": "Function Symbols in ASP: Overview and Perspectives", "author": ["M. Alviano", "F. Calimeri", "W. Faber", "G. Ianni", "N. Leone"], "venue": "Nonmonotonic Reasoning, Essays Celebrating its 30th Anniversary, G. Brewka, V. Marek, and M. Truszczynski, Eds. Studies in Logic, vol. 31. College Publications, 1\u201324.", "citeRegEx": "Alviano et al\\.,? 2011", "shortCiteRegEx": "Alviano et al\\.", "year": 2011}, {"title": "WASP: A native ASP solver based on constraint learning", "author": ["M. Alviano", "C. Dodaro", "W. Faber", "N. Leone", "F. Ricca"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913), P. Cabalar and T. C. Son, Eds. LNCS, vol. 8148. Springer, 55\u201367.", "citeRegEx": "Alviano et al\\.,? 2013", "shortCiteRegEx": "Alviano et al\\.", "year": 2013}, {"title": "Disjunctive asp with functions: Decidable queries and effective computation", "author": ["M. Alviano", "W. Faber", "N. Leone"], "venue": "Theory and Practice of Logic Programming 10, 4-6, 497\u2013512.", "citeRegEx": "Alviano et al\\.,? 2010", "shortCiteRegEx": "Alviano et al\\.", "year": 2010}, {"title": "Representing constraint satisfaction problems in answer set programming", "author": ["M. Balduccini"], "venue": "Proceedings of the Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP\u201909). 16\u201330.", "citeRegEx": "Balduccini,? 2009", "shortCiteRegEx": "Balduccini", "year": 2009}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press.", "citeRegEx": "Baral,? 2003", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Towards an integration of answer set and constraint solving", "author": ["S. Baselice", "P. Bonatti", "M. Gelfond"], "venue": "Proceedings of the 21st International Conference on Logic Programming (ICLP\u201905). LNCS, vol. 3668. Springer, 52\u201366.", "citeRegEx": "Baselice et al\\.,? 2005", "shortCiteRegEx": "Baselice et al\\.", "year": 2005}, {"title": "A decidable subclass of finitary programs", "author": ["S. Baselice", "P.A. Bonatti"], "venue": "Theory and Practice of Logic Programming 10, 4-6, 481\u2013496.", "citeRegEx": "Baselice and Bonatti,? 2010", "shortCiteRegEx": "Baselice and Bonatti", "year": 2010}, {"title": "Enhancing disjunctive datalog by constraints", "author": ["F. Buccafurri", "N. Leone", "P. Rullo"], "venue": "IEEE Transactions on Knowledge and Data Engineering 12, 5, 845\u2013860.", "citeRegEx": "Buccafurri et al\\.,? 2000", "shortCiteRegEx": "Buccafurri et al\\.", "year": 2000}, {"title": "Computable functions in", "author": ["F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone"], "venue": null, "citeRegEx": "Calimeri et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2008}, {"title": "Finitely recursive programs: Decidability and bottom-up computation", "author": ["F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone"], "venue": "AI Communications 24, 4 (Dec.), 311\u2013334.", "citeRegEx": "Calimeri et al\\.,? 2011", "shortCiteRegEx": "Calimeri et al\\.", "year": 2011}, {"title": "The third open answer set programming competition", "author": ["F. Calimeri", "G. Ianni", "F. Ricca"], "venue": "Theory and Practice of Logic Programming 14, 1, 117\u2013135.", "citeRegEx": "Calimeri et al\\.,? 2014", "shortCiteRegEx": "Calimeri et al\\.", "year": 2014}, {"title": "Experimenting with parallelism for the instantiation of ASP programs", "author": ["F. Calimeri", "S. Perri", "F. Ricca"], "venue": "Journal of Algorithms 63, 1-3, 34\u201354.", "citeRegEx": "Calimeri et al\\.,? 2008", "shortCiteRegEx": "Calimeri et al\\.", "year": 2008}, {"title": "Gasp: Answer set programming with lazy grounding", "author": ["A. Dal Pal\u00f9", "A. Dovier", "E. Pontelli", "G. Rossi"], "venue": "Fundamenta Informaticae 96, 3 (Aug.), 297\u2013322.", "citeRegEx": "Pal\u00f9 et al\\.,? 2009", "shortCiteRegEx": "Pal\u00f9 et al\\.", "year": 2009}, {"title": "OMiGA: An open minded grounding on-the-fly answer set solver", "author": ["M. Dao-Tran", "T. Eiter", "M. Fink", "G. Weidinger", "A. Weinzierl"], "venue": "Proceedings of the 13th European Conference on Logics in Artificial Intelligence (JELIA\u201912). LNAI, vol. 7519. Springer, 480\u2013483.", "citeRegEx": "Dao.Tran et al\\.,? 2012", "shortCiteRegEx": "Dao.Tran et al\\.", "year": 2012}, {"title": "Computing non-ground representations of stable models", "author": ["T. Eiter", "J.J. Lu", "V.S. Subrahmanian"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201997), J. Dix, U. Furbach, and A. Nerode, Eds. LNCS, vol. 1265. Springer, 198\u2013217.", "citeRegEx": "Eiter et al\\.,? 1997", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "The intelligent grounder of DLV", "author": ["W. Faber", "N. Leone", "S. Perri"], "venue": "Correct Reasoning - Essays on Logic-Based AI in Honour of Vladimir Lifschitz, E. Erdem, J. Lee, Y. Lierler, and D. Pearce, Eds. LNCS, vol. 7265. Springer, 247\u2013264.", "citeRegEx": "Faber et al\\.,? 2012", "shortCiteRegEx": "Faber et al\\.", "year": 2012}, {"title": "Pushing goal derivation in dlp computations", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Proceedings of the 5th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201999), M. Gelfond, N. Leone, and G. Pfeifer, Eds. LNCS, vol. 1730. Springer, 177\u2013191.", "citeRegEx": "Faber et al\\.,? 1999", "shortCiteRegEx": "Faber et al\\.", "year": 1999}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907). 372\u2013379.", "citeRegEx": "Ferraris et al\\.,? 2007", "shortCiteRegEx": "Ferraris et al\\.", "year": 2007}, {"title": "Engineering an incremental ASP solver", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908), M. Garcia de la Banda and E. Pontelli, Eds. LNCS, vol. 5366. Springer, 190\u2013205.", "citeRegEx": "Gebser et al\\.,? 2008", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "Advances in gringo Series 3", "author": ["M. Gebser", "R. Kaminski", "A. K\u00f6nig", "T. Schaub"], "venue": "Proceedings of 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201911), J. P. Delgrande and W. Faber, Eds. LNCS, vol. 6645. Springer, 345\u2013351.", "citeRegEx": "Gebser et al\\.,? 2011", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Artificial Intelligence 187, 52\u201389.", "citeRegEx": "Gebser et al\\.,? 2012", "shortCiteRegEx": "Gebser et al\\.", "year": 2012}, {"title": "GrinGo : A New Grounder for Answer Set Programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907). LNCS, vol. 4483. Springer, 266\u2013271.", "citeRegEx": "Gebser et al\\.,? 2007", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the Fifth International Conference and Symposium on Logic Programming (ICLP\u201988), R. A. Kowalski and K. Bowen, Eds. The MIT Press, Cambridge, Massachusetts, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 3/4, 365\u2013386.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning 36, 4, 345\u2013377.", "citeRegEx": "Giunchiglia et al\\.,? 2006", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "A non-ground realization of the stable and well-founded semantics", "author": ["G. Gottlob", "S. Marcus", "A. Nerode", "G. Salzer", "V.S. Subrahmanian"], "venue": "Theoretical Computer Science 166, 1-2, 221\u2013262.", "citeRegEx": "Gottlob et al\\.,? 1996", "shortCiteRegEx": "Gottlob et al\\.", "year": 1996}, {"title": "Logic programming with function symbols: Checking termination of bottom-up evaluation through program adornments", "author": ["S. Greco", "C. Molinaro", "I. Trubitsyna"], "venue": "Theory and Practice of Logic Programming 13, 4-5, 737\u2013752.", "citeRegEx": "Greco et al\\.,? 2013", "shortCiteRegEx": "Greco et al\\.", "year": 2013}, {"title": "Graphs and colorings for answer set programming", "author": ["K. Konczak", "T. Linke", "T. Schaub"], "venue": "Theory and Practice of Logic Programming 6, 61\u2013106.", "citeRegEx": "Konczak et al\\.,? 2006", "shortCiteRegEx": "Konczak et al\\.", "year": 2006}, {"title": "A first order forward chaining approach for answer set computing", "author": ["C. Lef\u00e8vre", "P. Nicolas"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201909). LNCS, vol. 5753. Springer, 196\u2013208.", "citeRegEx": "Lef\u00e8vre and Nicolas,? 2009a", "shortCiteRegEx": "Lef\u00e8vre and Nicolas", "year": 2009}, {"title": "The first version of a new ASP solver : ASPeRiX", "author": ["C. Lef\u00e8vre", "P. Nicolas"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201909). LNCS, vol. 5753. Springer, 522\u2013527.", "citeRegEx": "Lef\u00e8vre and Nicolas,? 2009b", "shortCiteRegEx": "Lef\u00e8vre and Nicolas", "year": 2009}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7, 3, 499\u2013562.", "citeRegEx": "Leone et al\\.,? 2006", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "One more decidable class of finitely ground programs", "author": ["Y. Lierler", "V. Lifschitz"], "venue": "Proceedings of the 25th International Conference on Logic Programming (ICLP\u201909). LNCS, vol. 5649. Springer, 489\u2013493.", "citeRegEx": "Lierler and Lifschitz,? 2009", "shortCiteRegEx": "Lierler and Lifschitz", "year": 2009}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157, 1-2, 115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907). 441\u2013446.", "citeRegEx": "Lin and Zhou,? 2007", "shortCiteRegEx": "Lin and Zhou", "year": 2007}, {"title": "Logic programs with abstract constraint atoms: The role of computations", "author": ["L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczynski"], "venue": "Artificial Intelligence 174, 3-4, 295\u2013315.", "citeRegEx": "Liu et al\\.,? 2010", "shortCiteRegEx": "Liu et al\\.", "year": 2010}, {"title": "Pbmodels - software to compute stable models by pseudoboolean solvers", "author": ["L. Liu", "M. Truszczynski"], "venue": "Proceedings of the 8th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201905), C. Baral, G. Greco, N. Leone, and G. Terracina, Eds. LNCS, vol. 3662. Springer, 410\u2013415.", "citeRegEx": "Liu and Truszczynski,? 2005", "shortCiteRegEx": "Liu and Truszczynski", "year": 2005}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 3-4, 241\u2013273.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "ASP modulo CSP: the clingcon system", "author": ["M. Ostrowski", "T. Schaub"], "venue": "Theory and Practice of Logic Programming 12, 4-5, 485\u2013503.", "citeRegEx": "Ostrowski and Schaub,? 2012", "shortCiteRegEx": "Ostrowski and Schaub", "year": 2012}, {"title": "Enhancing dlv instantiator by backjumping techniques", "author": ["S. Perri", "F. Scarcello", "G. Catalano", "N. Leone"], "venue": "Annals of Mathematics and Artificial Intelligence 51, 2-4, 195\u2013228.", "citeRegEx": "Perri et al\\.,? 2007", "shortCiteRegEx": "Perri et al\\.", "year": 2007}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence 138, 1-2, 181\u2013234.", "citeRegEx": "Simons et al\\.,? 2002", "shortCiteRegEx": "Simons et al\\.", "year": 2002}, {"title": "Implementation of local grounding for logic programs for stable model semantics", "author": ["T. Syrj\u00e4nen"], "venue": "Tech. rep., Helsinki University of Technology.", "citeRegEx": "Syrj\u00e4nen,? 1998", "shortCiteRegEx": "Syrj\u00e4nen", "year": 1998}, {"title": "Connecting first-order ASP and the logic FO(ID) through reducts", "author": ["M. Truszczynski"], "venue": "Correct Reasoning - Essays on Logic-Based AI in Honour of Vladimir Lifschitz. LNCS, vol. 7265. Springer, 543\u2013559.", "citeRegEx": "Truszczynski,? 2012", "shortCiteRegEx": "Truszczynski", "year": 2012}, {"title": "Principles of Database and Knowledge-Base Systems, Volume II", "author": ["J.D. Ullman"], "venue": "Computer Science Press.", "citeRegEx": "Ullman,? 1989", "shortCiteRegEx": "Ullman", "year": 1989}, {"title": "Learning non-ground rules for answer-set solving. In 2nd Workshop on Grounding and Transformations for Theories With Variables (GTTV\u201913). Appendix A Hanoi example The following ASP program is the Hanoi example with 4 discs", "author": ["A. Weinzierl"], "venue": null, "citeRegEx": "Weinzierl,? \\Q2013\\E", "shortCiteRegEx": "Weinzierl", "year": 2013}], "referenceMentions": [{"referenceID": 4, "context": "Answer Set Programming (ASP) is a very convenient paradigm to represent knowledge in Artificial Intelligence (AI) and to encode combinatorial problems (Baral 2003; Niemel\u00e4 1999).", "startOffset": 151, "endOffset": 177}, {"referenceID": 36, "context": "Answer Set Programming (ASP) is a very convenient paradigm to represent knowledge in Artificial Intelligence (AI) and to encode combinatorial problems (Baral 2003; Niemel\u00e4 1999).", "startOffset": 151, "endOffset": 177}, {"referenceID": 22, "context": "It has its roots in nonmonotonic reasoning and logic programming and has led to a lot of works since the seminal paper (Gelfond and Lifschitz 1988).", "startOffset": 119, "endOffset": 147}, {"referenceID": 22, "context": "to use ASP to solve a problem, he has to write a logic program in term of rules in a purely declarative manner in such a way that the answer sets (initially called stable models in (Gelfond and Lifschitz 1988)) of the program represent the solutions of his original problem.", "startOffset": 181, "endOffset": 209}, {"referenceID": 40, "context": "For the grounder box we can cite Lparse (Syrj\u00e4nen 1998) and Gringo (Gebser et al.", "startOffset": 40, "endOffset": 55}, {"referenceID": 19, "context": "For the grounder box we can cite Lparse (Syrj\u00e4nen 1998) and Gringo (Gebser et al. 2011), and for the solver box Smodels (Simons et al.", "startOffset": 67, "endOffset": 87}, {"referenceID": 39, "context": "2011), and for the solver box Smodels (Simons et al. 2002) and Clasp (Gebser et al.", "startOffset": 38, "endOffset": 58}, {"referenceID": 20, "context": "2002) and Clasp (Gebser et al. 2012).", "startOffset": 16, "endOffset": 36}, {"referenceID": 32, "context": "A particular family of solvers are Assat (Lin and Zhao 2004), Cmodels (Giunchiglia et al.", "startOffset": 41, "endOffset": 60}, {"referenceID": 24, "context": "A particular family of solvers are Assat (Lin and Zhao 2004), Cmodels (Giunchiglia et al. 2006) and Pbmodels (Liu and Truszczynski 2005), since they transform the answer set computation problem into a (pseudo) boolean model computation problem and use a (pseudo) SAT solver as an internal black box.", "startOffset": 70, "endOffset": 95}, {"referenceID": 35, "context": "2006) and Pbmodels (Liu and Truszczynski 2005), since they transform the answer set computation problem into a (pseudo) boolean model computation problem and use a (pseudo) SAT solver as an internal black box.", "startOffset": 19, "endOffset": 46}, {"referenceID": 30, "context": "In the system DLV (Leone et al. 2006), symbolized in Fig.", "startOffset": 18, "endOffset": 37}, {"referenceID": 8, "context": "1 by the dash-line rectangle, the grounder ((Calimeri et al. 2008) describes a parallel version) is incorporated as an internal function.", "startOffset": 44, "endOffset": 66}, {"referenceID": 1, "context": "In the same way, WASP (Alviano et al. 2013) uses the DLV grounder (Faber et al.", "startOffset": 22, "endOffset": 43}, {"referenceID": 15, "context": "2013) uses the DLV grounder (Faber et al. 2012).", "startOffset": 28, "endOffset": 47}, {"referenceID": 36, "context": "Let P2 be the program, as given in (Niemel\u00e4 1999), encoding a 3coloring problem on a N vertices graph organized as a bicycle wheel (see below).", "startOffset": 35, "endOffset": 49}, {"referenceID": 36, "context": "Let P3 be the program, inspired from one given in (Niemel\u00e4 1999), encoding the Hamiltonian cycle problem in a N vertices complete oriented graph.", "startOffset": 50, "endOffset": 64}, {"referenceID": 5, "context": "Some aim at solving the grounding bottleneck by combining ASP to constraint programming: (Baselice et al. 2005) proposes to reduce the memory requirements for a very specific class of programs, i.", "startOffset": 89, "endOffset": 111}, {"referenceID": 3, "context": "multi-sorted logic programs with cardinality constraints, (Balduccini 2009) proposes an algorithm to make cooperate an ASP solver and a Constraint Logic Programming solver in such a way that ASP is viewed as a specification language for constraint satisfaction problems and (Ostrowski and Schaub 2012) describes the Clingcon system which is a tight cooperation between the ASP solver Clasp and the Constraint Programming solver GeCode.", "startOffset": 58, "endOffset": 75}, {"referenceID": 37, "context": "multi-sorted logic programs with cardinality constraints, (Balduccini 2009) proposes an algorithm to make cooperate an ASP solver and a Constraint Logic Programming solver in such a way that ASP is viewed as a specification language for constraint satisfaction problems and (Ostrowski and Schaub 2012) describes the Clingcon system which is a tight cooperation between the ASP solver Clasp and the Constraint Programming solver GeCode.", "startOffset": 274, "endOffset": 301}, {"referenceID": 28, "context": "2009) and ASPeRiX (Lef\u00e8vre and Nicolas 2009a; Lef\u00e8vre and Nicolas 2009b)) developed at the same time, and more recently OMiGA (Dao-Tran et al.", "startOffset": 18, "endOffset": 72}, {"referenceID": 29, "context": "2009) and ASPeRiX (Lef\u00e8vre and Nicolas 2009a; Lef\u00e8vre and Nicolas 2009b)) developed at the same time, and more recently OMiGA (Dao-Tran et al.", "startOffset": 18, "endOffset": 72}, {"referenceID": 13, "context": "2009) and ASPeRiX (Lef\u00e8vre and Nicolas 2009a; Lef\u00e8vre and Nicolas 2009b)) developed at the same time, and more recently OMiGA (Dao-Tran et al. 2012).", "startOffset": 126, "endOffset": 148}, {"referenceID": 34, "context": "They are all based on the notion of computation given in (Liu et al. 2010).", "startOffset": 57, "endOffset": 74}, {"referenceID": 42, "context": "Instantiation and propagation are inspired by previous work realized on the DLV grounder which is based on the semi-naive evaluation technique of (Ullman 1989).", "startOffset": 146, "endOffset": 159}, {"referenceID": 25, "context": "Last, concerning a direct handling of first order programs, let us note that there exists some works (Gottlob et al. 1996; Eiter et al. 1997; Ferraris et al. 2007; Lin and Zhou 2007; Truszczynski 2012) dealing with first order nonmonotonic logic programs.", "startOffset": 101, "endOffset": 201}, {"referenceID": 14, "context": "Last, concerning a direct handling of first order programs, let us note that there exists some works (Gottlob et al. 1996; Eiter et al. 1997; Ferraris et al. 2007; Lin and Zhou 2007; Truszczynski 2012) dealing with first order nonmonotonic logic programs.", "startOffset": 101, "endOffset": 201}, {"referenceID": 17, "context": "Last, concerning a direct handling of first order programs, let us note that there exists some works (Gottlob et al. 1996; Eiter et al. 1997; Ferraris et al. 2007; Lin and Zhou 2007; Truszczynski 2012) dealing with first order nonmonotonic logic programs.", "startOffset": 101, "endOffset": 201}, {"referenceID": 33, "context": "Last, concerning a direct handling of first order programs, let us note that there exists some works (Gottlob et al. 1996; Eiter et al. 1997; Ferraris et al. 2007; Lin and Zhou 2007; Truszczynski 2012) dealing with first order nonmonotonic logic programs.", "startOffset": 101, "endOffset": 201}, {"referenceID": 41, "context": "Last, concerning a direct handling of first order programs, let us note that there exists some works (Gottlob et al. 1996; Eiter et al. 1997; Ferraris et al. 2007; Lin and Zhou 2007; Truszczynski 2012) dealing with first order nonmonotonic logic programs.", "startOffset": 101, "endOffset": 201}, {"referenceID": 28, "context": "The present paper is an extended version of (Lef\u00e8vre and Nicolas 2009a; Lef\u00e8vre and Nicolas 2009b).", "startOffset": 44, "endOffset": 98}, {"referenceID": 29, "context": "The present paper is an extended version of (Lef\u00e8vre and Nicolas 2009a; Lef\u00e8vre and Nicolas 2009b).", "startOffset": 44, "endOffset": 98}, {"referenceID": 34, "context": "\u2022 theoretical foundations of the approach, \u201cmbt ASPeRiX computation\u201d, with complete proofs; these computations are based on those of (Liu et al. 2010) and include use of constraints and must-be-true propagation in order to guide the search;", "startOffset": 133, "endOffset": 150}, {"referenceID": 22, "context": "(Gelfond and Lifschitz 1988) Let P be a normal logic program and X an atom set.", "startOffset": 0, "endOffset": 28}, {"referenceID": 27, "context": "(Konczak et al. 2006) Let P be a normal logic program and X be an atom set.", "startOffset": 0, "endOffset": 21}, {"referenceID": 27, "context": "(Konczak et al. 2006) Let P be a normal logic program and X be an atom set.", "startOffset": 0, "endOffset": 21}, {"referenceID": 23, "context": "This is possible in ASP by means of an extended logic program (Gelfond and Lifschitz 1991) in which rules are built with classical literals (i.", "startOffset": 62, "endOffset": 90}, {"referenceID": 34, "context": "This concept is itself based on an abstract notion of computation for ground programs proposed in (Liu et al. 2010).", "startOffset": 98, "endOffset": 115}, {"referenceID": 16, "context": "2 The term \u201cmust be true\u201d is first used in (Faber et al. 1999).", "startOffset": 43, "endOffset": 62}, {"referenceID": 15, "context": "The algorithm used in the ASPeRiX solver and described below is inspired by the previous work realized on the DLV grounder (Faber et al. 2012; Perri et al. 2007) which is based on the semi-naive evaluation technique of (Ullman 1989).", "startOffset": 123, "endOffset": 161}, {"referenceID": 38, "context": "The algorithm used in the ASPeRiX solver and described below is inspired by the previous work realized on the DLV grounder (Faber et al. 2012; Perri et al. 2007) which is based on the semi-naive evaluation technique of (Ullman 1989).", "startOffset": 123, "endOffset": 161}, {"referenceID": 42, "context": "2007) which is based on the semi-naive evaluation technique of (Ullman 1989).", "startOffset": 63, "endOffset": 76}, {"referenceID": 22, "context": "The core language of ASPeRiX is that of normal logic programs (Gelfond and Lifschitz 1988) with function symbols and true (or strong) negation without inconsistent answer set.", "startOffset": 62, "endOffset": 90}, {"referenceID": 8, "context": "ASPeRiX also provides dedicated treatment of lists with built-in predicates, as in DLV-complex (Calimeri et al. 2008), an extension of DLV with lists and sets.", "startOffset": 95, "endOffset": 117}, {"referenceID": 7, "context": "On the other side, ASPeRiX does not provide aggregate atoms and optimization statements (Buccafurri et al. 2000) which are accepted by the main current systems.", "startOffset": 88, "endOffset": 112}, {"referenceID": 0, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 2, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 9, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 31, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 6, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 26, "context": "A lot of work has been made for identifying program classes for which reasoning is decidable (Alviano et al. 2011; Alviano et al. 2010; Calimeri et al. 2011; Lierler and Lifschitz 2009; Baselice and Bonatti 2010; Greco et al. 2013).", "startOffset": 93, "endOffset": 231}, {"referenceID": 40, "context": "ASP grounders Lparse (Syrj\u00e4nen 1998) and versions up to 3.", "startOffset": 21, "endOffset": 36}, {"referenceID": 21, "context": "0 of Gringo (Gebser et al. 2007) accept programs respecting some syntactic domain restrictions and are able to deal with some restricted versions of functions.", "startOffset": 12, "endOffset": 32}, {"referenceID": 15, "context": "DLV grounder (Faber et al. 2012) and Gringo (since version 3.", "startOffset": 13, "endOffset": 32}, {"referenceID": 19, "context": "0) (Gebser et al. 2011) only require programs to be safe and can deal with all programs having a finite instantiation.", "startOffset": 3, "endOffset": 23}, {"referenceID": 43, "context": "Current version (Weinzierl 2013) uses must-be-true propagation and tries to introduce methods for conflict-driven learning of non-ground rules:", "startOffset": 16, "endOffset": 32}, {"referenceID": 19, "context": "10) (Gebser et al. 2011; Gebser et al. 2012), DLV Dec 16 2012 (Leone et al.", "startOffset": 4, "endOffset": 44}, {"referenceID": 20, "context": "10) (Gebser et al. 2011; Gebser et al. 2012), DLV Dec 16 2012 (Leone et al.", "startOffset": 4, "endOffset": 44}, {"referenceID": 30, "context": "2012), DLV Dec 16 2012 (Leone et al. 2006), GASP (june 2009) (Dal Pal\u00f9 et al.", "startOffset": 23, "endOffset": 42}, {"referenceID": 13, "context": "2009) and OMiGA Dec 3 2012 (Dao-Tran et al. 2012).", "startOffset": 27, "endOffset": 49}, {"referenceID": 13, "context": "Cutedge problem cutedge program is proposed in (Dao-Tran et al. 2012): given a random graph with 100 vertices and N edges, each answer set is obtained by deleting an edge and compute some transitive closure on the remaining edges.", "startOffset": 47, "endOffset": 69}, {"referenceID": 18, "context": "4 iClingo (Gebser et al. 2008) was created to address this specific problem.", "startOffset": 10, "endOffset": 30}, {"referenceID": 10, "context": "On the other hand, we plan to fully respect the core language ASP (Calimeri et al. 2014) by introducing, among others, minimization / maximization and aggregates and extend it by introducing existentially quantified variables in multi-head rules to encode fragments of Description Logics which are logical formalisms for ontologies and the Semantic Web.", "startOffset": 66, "endOffset": 88}], "year": 2017, "abstractText": "The natural way to use Answer Set Programming (ASP) to represent knowledge in Artificial Intelligence or to solve a combinatorial problem is to elaborate a first order logic program with default negation. In a preliminary step this program with variables is translated in an equivalent propositional one by a first tool: the grounder. Then, the propositional program is given to a second tool: the solver. This last one computes (if they exist) one or many answer sets (stable models) of the program, each answer set encoding one solution of the initial problem. Until today, almost all ASP systems apply this two steps computation. In this article, the project ASPeRiX is presented as a first order forward chaining approach for Answer Set Computing. This project was amongst the first to introduce an approach of answer set computing that escapes the preliminary phase of rule instantiation by integrating it in the search process. The methodology applies a forward chaining of first order rules that are grounded on the fly by means of previously produced atoms. Theoretical foundations of the approach are presented, the main algorithms of the ASP solver ASPeRiX are detailed and some experiments and comparisons with existing systems are provided.", "creator": "LaTeX with hyperref package"}}}