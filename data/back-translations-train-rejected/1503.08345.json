{"id": "1503.08345", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Mar-2015", "title": "Implementing an intelligent version of the classical sliding-puzzle game for unix terminals using Golang's concurrency primitives", "abstract": "A smarter version of the sliding-puzzle game is developed using the Go programming language. The game runs in computer system's terminals. Mainly, it was developed for UNIX-type systems but because of cross-platform compatibility of the programming language used, it works very well in nearly all the operating systems.", "histories": [["v1", "Sat, 28 Mar 2015 20:35:02 GMT  (76kb)", "http://arxiv.org/abs/1503.08345v1", "8 pages"], ["v2", "Sat, 22 Aug 2015 17:07:32 GMT  (15kb)", "http://arxiv.org/abs/1503.08345v2", "8 pages"]], "COMMENTS": "8 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["pravendra singh"], "accepted": false, "id": "1503.08345"}, "pdf": {"name": "1503.08345.pdf", "metadata": {"source": "CRF", "title": "Implementing an intelligent version of the classical sliding-puzzle game for unix terminals using Golang's concurrency primitives", "authors": ["Pravendra Singh"], "emails": ["hackpravj@gmail.com"], "sections": [{"heading": null, "text": "A smarter version of the sliding puzzle game is being developed using the Go programming language, which runs on computer system terminals. It is mainly designed for UNIX-like systems, but because of the cross-platform compatibility of the programming language used, it works very well in almost all operating systems. It uses Go primitives to simplify most important parts of the game. Real-time notification features are also being developed using the built-in parallel support. Keywords: Artificial intelligence, parallel programming, programming languages, Golang, game development"}, {"heading": "1. Introduction", "text": "Sliding puzzles [1] have long had their own reputation in the world of artificial intelligence and graph theory. The oldest type of sliding puzzles is known as fifteen puzzles [1]. It is believed that they were invented in 1874 by Noyes Palmer Chapman [2], a postmaster in the state of New York. The game consists of a 4x4 board with 16 tiles. Numbers are drawn on each tile, with the exception of a tile that is either empty or sometimes has digits' 0 '. The task of the game is to rearrange all tiles in a certain way, moving the empty tile only at once. This type of puzzle also has many variations. The 3x3 board puzzle, which is quite popular among them, is also known as the 8-puzzle game. In this type, the board consists of 9 tiles. In this paper we will consider the 8-type gameboard.On the other hand, Go is originally developed by Google as a new operating language [3]."}, {"heading": "2. Solvability", "text": "Here, the standard 8 puzzle board is taken into account, where the task of the game is to place the tiles so that the last tile is empty and all other tiles have numbers in increasing order (from 1 to 8). In total, 362880 (9!) board configurations are possible, but only half of them are actually solvable according to our limitations [23]. Thus, the game generates random configurations of the board and uses a built-in package called \"Scanner\" [5] to check the board for solvability. If the board is not really solvable, then it generates a new game board [23]. For its implementation, the package scanner uses the discussion from the paper \"Notes on the 15 puzzle\" [6]. A simplified version of this can be found in the \"Analysis of Sixteen Puzzles\" [7]. Package scanner \"implements an algorithm to verify the solvability of any configuration."}, {"heading": "3. Puzzle Solution", "text": "The game comes with an integrated package called \"Solver\" [5], which supports some of its functions. Thus, for example, the game displays the optimal number of moves using the solver to solve any board configuration in real time. All moves of the player are tracked with the solver and evaluated accordingly. \"Solver\" package is implemented using Golang's native data structures and interfaces, and uses an A-star algorithm [9] to traverse the game's state space."}, {"heading": "3.1 Heuristic Function", "text": "The heuristic function used in the implementation is \"Misplaced Tiles\" [8], which is a permissible function [11], h (n) \u2264 h * (n). Then it will never overestimate the actual driving distance and the solution will always be optimal.func heuristicScore (b Board) int {var score intfor i: = 0; i < 3; i + + {for j: = 0; j < 3; j + + {if b.Rows [i].Tiles [j].Value! = ((((3 * i + j + 1)% 9) {score + +}}}"}, {"heading": "3.2 Open List Data Structure", "text": "In the implementation, the game uses a custom data structure to achieve the open list required to execute the A-star algorithm. Open List maintains a collection of game state nodes that can be traversed at any time. Type OpenList struct {nodeTable map [board.Board] Node table map [board.Board] boolqueue * Priority Queue}"}, {"heading": "3.2.1 nodeTable", "text": "Golang provides an integrated map type [10] that implements a hash table.A map is a disordered group of elements of one type, the so-called element type, indexed by a series of unique keys of another type, the so-called key type. The value of an uninitialized map is zero. [10] nodeTable assigns a board configuration to a node in the state space of the game. No node appears twice when we move from the start state to the destination state, so there is no ambiguity. It helps us traverse the path once the search is completed."}, {"heading": "3.2.2 table", "text": "table is also a map that maps board configurations to a Boolean value. It is used to check if a board configuration exists in the open list or not. By default, it returns false if the board is absent."}, {"heading": "3.2.3 queue", "text": "The queue represents a data structure with priority [12], strictly speaking a queue with minimum priority. It is used to select a child node of a node that has the lowest travel costs. As a priority for the nodes, values of travel costs are used. It is created with the package \"Container / Heap\" [13] from Golang."}, {"heading": "3.3 Close List Data Structure", "text": "Similar to Open List, the solver also uses a Close List data structure, which is used to mark nodes as already traversed. Type CloseList struct {table map [board.Board] bool}"}, {"heading": "3.3.1 table", "text": "table is similar to the table used in Open List. It maps a board configuration to a Boolean value that indicates whether a board is in a closed list or not."}, {"heading": "4. Path Traversing", "text": "The search algorithm ends when the node to be entered in the narrow list is the target node. As it traverses all nodes in the state space of the game, it tracks all nodes and their respective child nodes. To do this, it guides a map from the child board configuration to the parent board configuration, generating a many-to-one mapping, since a board configuration as a child can have 2 to 4 new board configurations. / / Mapping from child to parent board configurations Relation card [Board.Board] Board.To collect the exact steps from start to destination state, it forms a linked list structure of board configurations, with the destination status at the end of the list and the board having to move next from the current board configuration, using the package \"Container / list\" [14] [Paths.Paths.Paths.Path.State] (back to the path.state], see the path)."}, {"heading": "5. Scoring Function", "text": "The game has its own scoring function. The \"score\" [15] package helps to implement this. At each state node (s), the score for the game can be calculated by the function score (n).score (n) = ACS (n) / Total MovesACS (n) = Accumulated Correct Score for the node n | 0; if the node n is start state, where ACS (n) = | ACS (parent (n)) + 1; if the last move was correct | ACS (parent (n) - 1; if the last move was wrong, the maximum possible score of 1 is only achieved in the game if all moves of the player were correct throughout the goal state."}, {"heading": "6. Game Interface", "text": "The graphical user interface for the game consists of letters for drawing boxes [16] as used in early text-based video hardware emulators, also known as semigraphics [17]. It uses the Golang port [18] of the Termbox library to write text-based user interfaces. The user interfaces are colored in normal 8-colors with foreground and background attributes for special formatting."}, {"heading": "7. Real Time Notification", "text": "In this case, it is an asynchronous or reactionary game, in which it is a reactionary distraction."}, {"heading": "8. Acknowledgements", "text": "The author is grateful to his Artificial Intelligence course leader, Mr. Partha Pratim Roy. Rob Pike, Ken Thompson, Robert Griesemer and many Golang contributors have helped to make the language so stunning. nsf (https: / / github.com / nsf) for developing the termbox-go library."}, {"heading": "9. References", "text": "[1] Sliding puzzle - http: / / en.wikipedia.org / wiki / Sliding _ puzzle [2] The 15 Puzzle, by Jerry Slocum & Dic Sonneveld, 2006. ISBN 1-890980-15-3 [3] Release History The Go Programming Language - https: / / golang.org / doc / devel / release.html [4] The Go Programming Language - https: / / golang.org / [5] Package \"solver\" - http: / / github.com / pravj / blob / master / solver.go [6] Notes on the \"15\" Puzzle - Wm."}], "references": [{"title": "The Mathematical Puzzles of Sam Loyd", "author": ["M. Gardner"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1959}], "referenceMentions": [{"referenceID": 0, "context": "A total of 362880(9!) board configurations are possible but only half of them are actually solvable according to our constraints[23].", "startOffset": 128, "endOffset": 132}], "year": 2015, "abstractText": "A smarter version of the sliding-puzzle game is developed using the Go programming language. The game runs in computer system's terminals. Mainly, it was developed for UNIX-type systems but because of cross-platform compatibility of the programming language used, it works very well in nearly all the operating systems. The game uses Go's concurrency primitives to simplify most of the hefty parts of the game. Real time notification functionality is also developed using language's built-in concurrency support.", "creator": null}}}