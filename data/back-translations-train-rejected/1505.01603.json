{"id": "1505.01603", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-May-2015", "title": "Best-First and Depth-First Minimax Search in Practice", "abstract": "Most practitioners use a variant of the Alpha-Beta algorithm, a simple depth-first pro- cedure, for searching minimax trees. SSS*, with its best-first search strategy, reportedly offers the potential for more efficient search. However, the complex formulation of the al- gorithm and its alleged excessive memory requirements preclude its use in practice. For two decades, the search efficiency of \"smart\" best-first SSS* has cast doubt on the effectiveness of \"dumb\" depth-first Alpha-Beta. This paper presents a simple framework for calling Alpha-Beta that allows us to create a variety of algorithms, including SSS* and DUAL*. In effect, we formulate a best-first algorithm using depth-first search. Expressed in this framework SSS* is just a special case of Alpha-Beta, solving all of the perceived drawbacks of the algorithm. In practice, Alpha-Beta variants typically evaluate less nodes than SSS*. A new instance of this framework, MTD(f), out-performs SSS* and NegaScout, the Alpha-Beta variant of choice by practitioners.", "histories": [["v1", "Thu, 7 May 2015 06:54:26 GMT  (357kb)", "http://arxiv.org/abs/1505.01603v1", "Computer Science in the Netherlands 1995. arXiv admin note: text overlap witharXiv:1404.1515"]], "COMMENTS": "Computer Science in the Netherlands 1995. arXiv admin note: text overlap witharXiv:1404.1515", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["aske plaat", "jonathan schaeffer", "wim pijls", "arie de bruin"], "accepted": false, "id": "1505.01603"}, "pdf": {"name": "1505.01603.pdf", "metadata": {"source": "CRF", "title": "Best-First and Depth-First Minimax Search in Practice", "authors": ["Aske Plaat", "Wim Pijls", "Arie de Bruin"], "emails": ["plaat@theory.lcs.mit.edu", "jonathan@cs.ualberta.ca", "whlmp@cs.few.eur.nl", "arie@cs.few.eur.nl"], "sections": [{"heading": null, "text": "This paper presents a simple framework for invoking alpha-beta that allows us to develop a variety of algorithms, including SSS * and DUAL *. In fact, we are formulating a best-first algorithm using depth search. Expressed in this framework, SSS * is just a special case of alpha-beta that resolves all perceived disadvantages of the algorithm. In practice, alpha-beta variants typically evaluate fewer nodes than SSS *. A new instance of this framework, MTD *, surpasses SSS * and NegaScout, the alpha-beta variant of choice by practitioners."}, {"heading": "1 Introduction", "text": "The game is one of the classic problems of artificial intelligence. Finding the best move in a zero-sum game is known exclusively as Minimax Search. Studying Minimax search algorithms has yielded ideas that have proven useful in many search areas. For example, this research extends to single-agent search, such as iterative deepening (IDA *) [11], real-time search (RTA *) [12] and bidirectional search [14]. Although the two-agent search has many other applications, the best game we will use in this paper is. Over the past thirty years, most practitioners have used depth search algorithms based on Alpha Beta [10] for their game programs. There is an exponential gap in the size of trees that we have built at best and at worst built Alpha Beta Beta Beta Beta."}, {"heading": "2 Null-Window Search and Memory", "text": "It is well known that searching for such a tree has great potential for creating efficient search algorithms based solely on searching for zero windows, such as C * [6, 34] and Alpha Bounding [30].Knuth and Moore have shown that the return value of an alpha beta search with window can be one of three things [10]: < g < g < g < g < g < g >."}, {"heading": "3 A Framework for Best-First Search", "text": "The concept of zero-window alpha-beta search was introduced by Pearl with its proof-procedure test [20]. Since we use memory to store interim search information, we have called our framework Memory-Enhanced Test (MT). As a proof-procedure, we use a standard zero-window alpha-beta method for use with transposition tables. The code is shown in Figure 1. So far, we have discussed the following two mechanisms that can be used in building efficient algorithms: (1) zero-window search cuts off more nodes than large search windows, and (2) transposition tables can be used to glue together multiple alpha-beta passes. We can use these blocks to construct a number of different algorithms. One way is to construct drivers that repeatedly invoke alpha-beta at the root of the game tree. Three of these drivers are shown in Figures 2 and 3. The manner in which the zero-window is selected (and the manner in which is referred to)."}, {"heading": "3.1 SSS*", "text": "The driver on the left in Figure 2 constructs an algorithm that starts with an upper limit of +. From the post-condition of alpha-beta, we see that this call will be low, resulting in an upper limit. By feeding this upper limit back into an alpha-beta call with zero windows, we get a sequence of failures in memory. If g =, we will end up with a failure in memory with g = 0, meaning that the maximum value of that has been found. This driver expands the same leaf nodes in the same order as Stockman's SSS * [33]. (Full proof for this assertion can be found in [22] and a sketch of the evidence in [25]. In this sense, we have constructed an equivalent formulation of SSS * by constructing an initial algorithm that uses the depth and memory extension of the SSS formulas. The reformulation is called AB-SSS *. Many researchers have used algorithms that alpha are practical to first alpha *."}, {"heading": "3.2 DUAL*", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at", "text": "The only difference from AB-SSS * is the initialization of the boundary to and a change in the designation Alpha-Beta. This reformulation focuses attention on just one point: The boundary begins at the lower end of the scale, which implies that the only fundamental difference between SSS * and DUAL * is that upper boundaries are replaced by lower boundaries (which implies that the Max Solution Tree, which is refined by AB-SSS *, has become a minimal solution tree in AB-DUAL *). All other differences seem insignificant, as nothing else needs to be changed."}, {"heading": "3.3 Other Options for the choice of Start Value", "text": "AB-SSS * starts the order of alpha-beta searches at +, the upper end of the scale. ABDUAL * starts at the lower end of the scale. An intuitively appealing option is to choose a different starting value that is closer to the expected result. An option is to halve the interval between the upper and lower limit to reduce the number of alpha-beta calls for this purpose, as it is expected to be a close approximation of the value for the current depth. Another idea is to use a heuristic guess as the starting value. In an iterative deepening frame, of course, it is to use the score from the previous iteration for this purpose, as it will be an approximation of the value for the current depth. We have called this driver MTD (B) and its pseudo-code is shown in Figure 3. The first call acts to decide which way the search will go."}, {"heading": "4 Performance", "text": "In order to evaluate the performance of the proposed algorithms in practice, a series of experiments were conducted in which we present data for comparison of Alpha-Beta, NegaScout, AB-SSS *, AB-DUAL * and MTD (\u0192)."}, {"heading": "4.1 Experiment Design", "text": "In fact, it is the case that most people who are able are able to determine for themselves what they want and what they do not want."}, {"heading": "4.2 Results", "text": "Figure 4 shows the performance of Phoenix based on the number of blade evaluations (NBP or number of lower positions) as an indicator. Figure 5 shows the performance of the algorithms based on the number of nodes in the search tree (inner and leaf structure, including the nodes that caused transposition interruptions) as an indicator. The diagrams show the cumulative number of nodes across all previous iterations for a certain depth (which is realistic since iterative indentation is used) relative to aspiration NegaScout. Note the different vertical scales."}, {"heading": "4.2.1 Aspiration NegaScout and MTD(\u0192)", "text": "The results show that Aspiration NegaScout is better than Alpha-Beta. This result is in line with [31], which has shown that Aspiration NegaScout represents a small improvement over Alpha-Beta, as conversion tables and iterative indentation were used. MTD (\u0107) is a best-first algorithm, which consists exclusively of zero-window searches. In each run, the previous one is used to guide the search for selecting the best node. The majority of searches in NegaScout is also performed with a zero window. An important difference is the value with which this zero-window search is performed. NegaScout derives it from the tree itself, while MTD (\u0435) relies for the first assumption on information from outside the tree. (In our experiments, the Minimax value from a previous iterative ineration Iteration is used for this purpose.) The best results come from NegaScout (TD) NegaScans, the current algorithm, although the choice of algorithm is the algorithm of choice of Messence, scan, scan, scan, scan, scan, scan, scan, scan, scan, scan, scan."}, {"heading": "4.2.2 SSS* and DUAL*", "text": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of hands augmented by SSS * and Alpha-Beta is relatively small. As game programs use many search enhancements, the benefit of a best-first search is greatly reduced. We conclude that AB-SSS * in practice represents a small improvement over Alpha-Beta only for Leaf Nodes (depending on the branching factor). Claims that SSS * and DUAL * rate significantly fewer leaf nodes than Alpha-Beta are based on simplistic assumptions that have little to do with the practice used."}, {"heading": "4.3 Execution time", "text": "Comparing the results for the same machines, we found that MTD (\u0192) is consistently the fastest algorithm. The run shown is a typical example of a run on a Sun SPARC. We experienced different times in operation on different machines. It may well be that the cache size plays an important role and that the tuning of the program can have considerable effects. In our experiments, we found that Phoenix MTD (\u0107) was about 9-13% faster than aspiration NegaScout in execution time. With other programs and other machines, these results will obviously differ, partly depending on the quality of the score of the previous iteration and the test positions used. Since the algorithms tested also work quite closely together, the relative differences are quite sensitive to variations in the input parameters. When generalizing these results, these numbers should be better taken into account than when using these real verifications as a reference point for other situations."}, {"heading": "4.4 Artificial versus Real Trees", "text": "Our experiments have been carried out with practical programs that extend the basic Minimax algorithms with techniques such as iterative deepening and conversion tables. As a result, SSS * does not significantly exceed Alpha-Beta in practice. It is commonly used by Alpha-Beta variants such as NegaScout. Simulations are usually performed when it is too difficult or too expensive to construct the right experimental environment.When searching for game trees, the arguments for simulations are weak. There is no need to run simulations when high-quality game programs are available to obtain actual data.In addition, simulation parameters may be wrong, leading to large errors in the results that lead to misleading conclusions."}, {"heading": "5 Conclusions", "text": "The Zero Window Search, reinforced by Storage, can be used to construct the best initial Minimax algorithms. A conventional transmission table can be used for Storage. Zero Window Calls generate a sequence of boundaries to the Minimax value. Storage contains the part of the search tree that defines these boundaries to be refined in subsequent Passs.A frame was presented for algorithms that generate sequences of boundaries in different ways. Interestingly, certain instances of this frame extend the same leaf nodes in the same order as SSS * and DUAL *. These algorithms, called AB-SSS * and AB-DUAL *, solve the perceived problems of SSS * and DUAL *. They are much simpler and more practical, consisting of a single loop of Alpha Beta calls. We used tournament game programs for our tests."}, {"heading": "Acknowledgements", "text": "This work benefited from discussions with Mark Brockington, Yngvi Bjornsson and Andreas Junghanns. The support of Jaap van den Herik and the financial support of the Dutch Organisation for Scientific Research (NWO), the Tinbergen Institute, the Natural Sciences and Engineering Research Council of Canada (NSERC grant OGP-5183) and the Central Research Fund of the University of Alberta are appreciated."}], "references": [{"title": "The Design and Analysis of Algorithms for Asynchronous Multiprocessors", "author": ["G\u00e9rard M. Baudet"], "venue": "PhD thesis,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1978}, {"title": "Asynchronous Parallel Game-Tree Search", "author": ["Mark Brockington"], "venue": "PhD thesis,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1994}, {"title": "Algorithms for the parallel search of game trees", "author": ["Murray Campbell"], "venue": "Master\u2019s thesis,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1981}, {"title": "A comparison of minimax tree search algorithms", "author": ["Murray S. Campbell", "T. Anthony Marsland"], "venue": "Artificial Intelligence,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1983}, {"title": "A special-purpose machine for an improved search algorithm for deep chess combinations", "author": ["K. Coplan"], "venue": "Advances in Computer Chess", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1981}, {"title": "Solution trees as a basis for game-tree search", "author": ["Arie de Bruin", "Wim Pijls", "Aske Plaat"], "venue": "ICCA Journal,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "Analysis of Speedup in Distributed Algorithms", "author": ["John P. Fishburn"], "venue": "PhD thesis,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1981}, {"title": "Minimax search algorithms with and without aspiration windows", "author": ["Hermann Kaindl", "Reza Shams", "Helmut Horacek"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1991}, {"title": "An analysis of alpha-beta pruning", "author": ["Donald E. Knuth", "Ronald W. Moore"], "venue": "Artificial Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1975}, {"title": "Iterative deepening: An optimal admissible tree search", "author": ["Richard E. Korf"], "venue": "Artificial Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1985}, {"title": "Real-time heuristic search", "author": ["Richard E. Korf"], "venue": "Artificial Intelligence,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1990}, {"title": "A general branch and bound formulation for and/or graph and game tree search", "author": ["Vipin Kumar", "Laveen N. Kanal"], "venue": "In Search in Artificial Intelligence. Springer Verlag,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1988}, {"title": "BS*: An admissible bidirectional staged heuristic search algorithm", "author": ["J.B.H. Kwa"], "venue": "Artificial Intelligence,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1989}, {"title": "A review of game-tree pruning", "author": ["T. Anthony Marsland"], "venue": "ICCA Journal,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1986}, {"title": "Parallel search of strongly ordered game trees", "author": ["T. Anthony Marsland", "Murray S. Campbell"], "venue": "Computing Surveys,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1982}, {"title": "Low overhead alternatives to SSS", "author": ["T. Anthony Marsland", "Alexander Reinefeld", "Jonathan Schaeffer"], "venue": "Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1987}, {"title": "An empirical comparison of pruning strategies in game trees", "author": ["Agata Muszycka", "Rajjan Shinghal"], "venue": "IEEE Transactions on Systems, Man and Cybernetics,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1985}, {"title": "Asymptotical properties of minimax trees and game searching procedures", "author": ["Judea Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1980}, {"title": "The solution for the branching factor of the alpha-beta pruning algorithm and its optimality", "author": ["Judea Pearl"], "venue": "Communications of the ACM,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1982}, {"title": "Heuristics \u2013 Intelligent Search Strategies for Computer Problem Solving", "author": ["Judea Pearl"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1984}, {"title": "Solution trees as a unifying concept for game tree algorithms", "author": ["Wim Pijls", "Arie de Bruin", "Aske Plaat"], "venue": "Technical Report EUR-CS-95-01, Erasmus University, Department of Computer Science, P.O. Box 1738,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1995}, {"title": "A new paradigm for minimax search", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "Technical Report TR-CS-94-18,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1994}, {"title": "Best-first fixed-depth game-tree search in practice", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-95),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1995}, {"title": "A minimax algorithm better than Alpha-Beta? no and yes", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "Technical Report 95-15,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "Spielbaum Suchverfahren", "author": ["Alexander Reinefeld"], "venue": "Informatik-Fachberichte 200. Springer Verlag,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1989}, {"title": "Time-efficient state space search", "author": ["Alexander Reinefeld", "Peter Ridinger"], "venue": "Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1994}, {"title": "Information acquisition in minimal window search", "author": ["Alexander Reinefeld", "Jonathan Schaeffer", "T. Anthony Marsland"], "venue": "In Proceeding of the International Joint Conference on Artificial Intelligence (IJCAI-85),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1985}, {"title": "A minimax algorithm better than alpha-beta", "author": ["Igor Roizen", "Judea Pearl"], "venue": "Yes and no. Artificial Intelligence,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1983}, {"title": "Experiments in Search and Knowledge", "author": ["Jonathan Schaeffer"], "venue": "PhD thesis, Department of Computing Science, University of Waterloo, Canada,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1986}, {"title": "The history heuristic and alpha-beta search enhancements in practice", "author": ["Jonathan Schaeffer"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1989}, {"title": "A world championship caliber checkers program", "author": ["Jonathan Schaeffer", "Joseph Culberson", "Norman Treloar", "Brent Knight", "Paul Lu", "Duane Szafron"], "venue": "Artificial Intelligence,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1992}, {"title": "A minimax algorithm better than alpha-beta", "author": ["George C. Stockman"], "venue": "Artificial Intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1979}, {"title": "The NegaC* search", "author": ["Jean-Christophe Weill"], "venue": "ICCA Journal,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1992}], "referenceMentions": [{"referenceID": 9, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 94, "endOffset": 98}, {"referenceID": 10, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 124, "endOffset": 128}, {"referenceID": 12, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 154, "endOffset": 158}, {"referenceID": 8, "context": "Over the last thirty years, most practitioners used depth-first search algorithms based on Alpha-Beta [10] for their game-playing programs.", "startOffset": 102, "endOffset": 106}, {"referenceID": 29, "context": "This led to numerous enhancements to the basic algorithm, including iterative deepening, transposition tables, the history heuristic and narrow search windows (see for example [31] for an assessment).", "startOffset": 176, "endOffset": 180}, {"referenceID": 2, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 7, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 14, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 24, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 31, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 6, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 26, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 24, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 14, "context": "It is well-known that the narrower the search window, the more nodes can be cutoff [16].", "startOffset": 83, "endOffset": 87}, {"referenceID": 3, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 4, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 6, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 17, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 28, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 6, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 18, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 24, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 4, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 98, "endOffset": 105}, {"referenceID": 32, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 98, "endOffset": 105}, {"referenceID": 28, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 125, "endOffset": 129}, {"referenceID": 8, "context": "Knuth and Moore have shown that the return value g of an Alpha-Beta search with window , can be one of three things [10]:", "startOffset": 116, "endOffset": 120}, {"referenceID": 8, "context": "Knuth and Moore have shown that the essential part of the search tree that proves the minimax value is the minimal tree [10].", "startOffset": 120, "endOffset": 124}, {"referenceID": 5, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 11, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 23, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 31, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 19, "context": "For NegaScout it appears that the gains of the tighter bounds out-weigh the costs of re-expansions, compared to a single wide-window Alpha-Beta call [21].", "startOffset": 149, "endOffset": 153}, {"referenceID": 7, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 16, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 27, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 29, "context": "For game-playing programs an obvious choice is to use a transposition table for storage [31].", "startOffset": 88, "endOffset": 92}, {"referenceID": 14, "context": "Today, transposition tables are often used in combination with iterative deepening [16].", "startOffset": 83, "endOffset": 87}, {"referenceID": 13, "context": "The main benefit of this combination is to improve the quality of move ordering [15].", "startOffset": 80, "endOffset": 84}, {"referenceID": 5, "context": "Some background explaining in greater detail why the transposition table is a suitable structure for storing search or solution trees, and why it gives correct results in algorithms doing repetitive null-window searches, can be found in [7, 25].", "startOffset": 237, "endOffset": 244}, {"referenceID": 23, "context": "Some background explaining in greater detail why the transposition table is a suitable structure for storing search or solution trees, and why it gives correct results in algorithms doing repetitive null-window searches, can be found in [7, 25].", "startOffset": 237, "endOffset": 244}, {"referenceID": 23, "context": "We have shown in [25] that although the search information that must be stored is indeed of exponential size, it is much less than what is often assumed.", "startOffset": 17, "endOffset": 21}, {"referenceID": 18, "context": "The concept of null-window Alpha-Beta search was introduced by Pearl with his proof-procedure Test [20].", "startOffset": 99, "endOffset": 103}, {"referenceID": 31, "context": "This driver expands the same leaf nodes in the same order as Stockman\u2019s SSS* [33].", "startOffset": 77, "endOffset": 81}, {"referenceID": 20, "context": "(A full proof of this claim can be found in [22] and an outline of the proof in [25].", "startOffset": 44, "endOffset": 48}, {"referenceID": 23, "context": "(A full proof of this claim can be found in [22] and an outline of the proof in [25].", "startOffset": 80, "endOffset": 84}, {"referenceID": 7, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 15, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 16, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 24, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 27, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 31, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 23, "context": "This enables us to easily test the performance of SSS* These tests confirm that SSS* does not need too much memory [25].", "startOffset": 115, "endOffset": 119}, {"referenceID": 14, "context": "SSS*\u2019s slow OPEN list operations are traded in for hash table lookups that are as fast as for Alpha-Beta [16], and the experiments show that AB-SSS* does not need too much memory.", "startOffset": 105, "endOffset": 109}, {"referenceID": 15, "context": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at instead of + [17, 26].", "startOffset": 199, "endOffset": 207}, {"referenceID": 24, "context": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at instead of + [17, 26].", "startOffset": 199, "endOffset": 207}, {"referenceID": 4, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 21, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 32, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 28, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 178, "endOffset": 182}, {"referenceID": 1, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 201, "endOffset": 204}, {"referenceID": 30, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 229, "endOffset": 233}, {"referenceID": 23, "context": "This paper presents results for chess; the results for the other games (which are similar and confirm the chess results) can be found in [25].", "startOffset": 137, "endOffset": 141}, {"referenceID": 23, "context": "All three algorithms use a standard transposition table with a maximum of 221 entries; tests showing that the solution trees could comfortably fit in tables of this size, without any risk of noise due to collisions [25].", "startOffset": 215, "endOffset": 219}, {"referenceID": 29, "context": "Phoenix uses dynamic ordering based on the history heuristic [31].", "startOffset": 61, "endOffset": 65}, {"referenceID": 3, "context": "Many papers in the literature use Alpha-Beta as the base-line for comparing the performance of other algorithms (for example, [5, 15]).", "startOffset": 126, "endOffset": 133}, {"referenceID": 13, "context": "Many papers in the literature use Alpha-Beta as the base-line for comparing the performance of other algorithms (for example, [5, 15]).", "startOffset": 126, "endOffset": 133}, {"referenceID": 0, "context": "By choosing NegaScout enhanced with aspiration searching [2] (Aspiration NegaScout) as our performance metric, and giving it a transposition table big enough to contain all re-search information, we are emphasizing that it is possible to do better than the \u201cbest\u201d methods currently practiced and that, contrary to published simulation results, some methods\u2014notably SSS*\u2014will turn out to be inferior.", "startOffset": 57, "endOffset": 60}, {"referenceID": 29, "context": "This result is consistent with [31] which showed Aspiration NegaScout to be a small improvement over Alpha-Beta", "startOffset": 31, "endOffset": 35}, {"referenceID": 23, "context": "A deeper analysis of MTD(\u0192) can be found in [25].", "startOffset": 44, "endOffset": 48}, {"referenceID": 2, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 7, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 15, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 16, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 24, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 25, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 27, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 31, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 2, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 7, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 15, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 16, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 24, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 25, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 27, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 31, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 7, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 15, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 27, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 23, "context": "The results for checkers and Othello, games with a narrow and medium branching factor, confirm these results [25].", "startOffset": 109, "endOffset": 113}, {"referenceID": 22, "context": "Some of these results were originally published in [24].", "startOffset": 51, "endOffset": 55}], "year": 1998, "abstractText": "Most practitioners use a variant of the Alpha-Beta algorithm, a simple depth-first procedure, for searching minimax trees. SSS*, with its best-first search strategy, reportedly offers the potential for more efficient search. However, the complex formulation of the algorithm and its alleged excessive memory requirements preclude its use in practice. For two decades, the search efficiency of \u201csmart\u201d best-first SSS* has cast doubt on the effectiveness of \u201cdumb\u201d depth-first Alpha-Beta. This paper presents a simple framework for calling Alpha-Beta that allows us to create a variety of algorithms, including SSS* and DUAL*. In effect, we formulate a best-first algorithm using depth-first search. Expressed in this framework SSS* is just a special case of Alpha-Beta, solving all of the perceived drawbacks of the algorithm. In practice, Alpha-Beta variants typically evaluate less nodes than SSS*. A new instance of this framework, MTD(\u0192), out-performs SSS* and NegaScout, the Alpha-Beta variant of choice by practitioners.", "creator": null}}}