{"id": "1505.02552", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-May-2015", "title": "Relations between MDDs and Tuples and Dynamic Modifications of MDDs based constraints", "abstract": "We study the relations between Multi-valued Decision Diagrams (MDD) and tuples (i.e. elements of the Cartesian Product of variables). First, we improve the existing methods for transforming a set of tuples, Global Cut Seeds, sequences of tuples into MDDs. Then, we present some in-place algorithms for adding and deleting tuples from an MDD. Next, we consider an MDD constraint which is modified during the search by deleting some tuples. We give an algorithm which adapts MDD-4R to these dynamic and persistent modifications. Some experiments show that MDD constraints are competitive with Table constraints.", "histories": [["v1", "Mon, 11 May 2015 10:32:59 GMT  (405kb,D)", "http://arxiv.org/abs/1505.02552v1", "15 pages, 16 figures"]], "COMMENTS": "15 pages, 16 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["guillaume perez", "jean-charles r\\'egin"], "accepted": false, "id": "1505.02552"}, "pdf": {"name": "1505.02552.pdf", "metadata": {"source": "CRF", "title": "Relations between MDDs and Tuples and Dynamic Modifications of MDDs based constraints", "authors": ["Guillaume Perez", "Jean-Charles R\u00e9gin"], "emails": ["guillaume.perez06@gmail.com,", "jcregin@gmail.com"], "sections": [{"heading": "1 Introduction", "text": "This year it is more than ever before in the history of the city."}, {"heading": "2 Background", "text": "An MDD, as used in CP [1,13,14,3,11], is a rooted directional acyclic graph (DAG) that is used to represent multiple layers of nodes so that each variable is represented on a particular layer of the graph. Each node on a given integer d (see Figure 1.). Given the r input variables, the DAG representation is designed to represent each variable on a particular layer of the graph. Each node on a venom layer has at most d outgoing slurs in the next layer. Each arc is labeled by its corresponding layers of nodes, and the last layer is represented by the true nodes."}, {"heading": "3 Transformations", "text": "Cheng and Yap have proposed an algorithm for creating an MDD from a table. It uses an internal data structure similar to a trie that requires d entries per node to be able to add new tuples to the MDD. Then, they merge the leaves of the triad and apply the reduction operator. Spatial complexity is actually not a problem with their algorithm, as their reduction algorithm also requires direct access to the children of a node, i.e. d entries per node. However, a new reduction algorithm was recently proposed by Perez and R\u00e9gin [18]. Its spatial and time complexity is linear, so we can improve the transformation of tuples in MDD if we are able to add tuples to an MDD in linear time. In this section, we propose such algorithms."}, {"heading": "3.1 From Trie to MDD", "text": "A Trie is a data structure used by Ghent et al. to compress tuple sets. [12] Each path from the root to a leaf represents a allowed tuple. A Trie, which represents a set of T tuples, has | T | leaves. Each variable corresponds to one layer of the Trie. A node has a maximum of d children, where d is the size of the domain of the corresponding variable of the node. An example of Trie is in Figure 2. It corresponds to the same tuple set as the MDD of Figure 1. A Trie can be transformed into an MDD by merging all the leaves into the terminal node tt and applying the reduction operation [7]."}, {"heading": "3.2 From Table to MDD", "text": "A table is a data structure in which each row represents a tuple and in which each column corresponds to a value of a tuple. Cheng and Yap build and MDD from a table by defining a tuple. Tuples are added to the tuple one after the other by first creating a common node: the root of the tree and by creating paths starting from the root. The rooted sub-paths, which are common to several tuples, are merged to be represented only once. Afterwards, all leaves are fused and the MDD is reduced. The disadvantage of this approach is the addition of a tupel. To determine in linear time where to include it in the existing MDD, the algorithm requires d entries per node1,1 Note that if we accept to increase the complexity of time, we can avoid this spatial complexity."}, {"heading": "3.3 From GCS and Tuple Sequence to MDD.", "text": "Dre rf\u00fc ide eeisrVnlrtee\u00fcgn rf\u00fc ide rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc"}, {"heading": "4 Addition and Deletions of tuples from an MDD", "text": "Some work has been done to perform operations on BDDs. For example, Bryant defines some algorithms for applying different operators [6,5]. However, the described algorithms do not exist (i.e. a resulting BDD is created) and it is not easy to generalize some algorithms developed for BDDs to MDDs, mainly because some Boolean rules no longer apply when we have d values in the domain and because the complexity of some algorithms when handling d values is multiplied by O (d). Some algorithms have also been suggested for applying operators to MDDs [2,18]. However, there are no fixed algorithms. In this section we define fixed algorithms for adding / deleting tuples from an MDD. Such algorithms are necessary in order to be able to define a dynamic algorithm for MDD constraints in order to compete with dynamic tables."}, {"heading": "4.1 Deletion of tuples from an MDD", "text": "The idea of this operation is to build a specific path whose isolation is marked by the values of the tuple, but which must be deleted. [The isolation for each intermediate layer (neither the first nor the last). [The isolation for the first nor the last layer). [The isolation for the last layer of the last layer 4. We call an incremental reduction of the operator on the MDDWe detailing these steps: 1. The isolation for the first layer 2. The isolation for each intermediate layer (neither the first nor the last). [The isolation for the last layer 4. We call an incremental reduction of the operator on the MDDWe detail these steps. Leave the tuple that needs to be deleted. [i] the value for the variable x [i].Step 1. We identify a1 = (r, n1) the arc of the first layer."}, {"heading": "4.2 Addition of tuples to an MDD", "text": "Adding the tuples to the MDD would mean that at some point we will not be able to identify the isolation. (That is, we also use the idea of isolation.) We have to use this idea to avoid adding many things. (That is, we have to control exactly what we add to the MDDD. (In this case, the isolation for the last layer is 4) We call an incremental reduction of the tupel, which we have to perform in four steps: 1. The isolation for the first layer 2 (neither the first nor the last). (The isolation for the last layer 4) We call an incremental reduction of the operator on the MDDD We first consider the addition of a tupel. (The first two steps are very similar to the deletion.) Except that at one point there will be no further paths in the MDD."}, {"heading": "4.3 Incremental Reduction", "text": "Using a generic algorithm is costly because it traverses all nodes of the MDD and merges the corresponding nodes. Assuming that we add / delete tuples from a reduced MDD, we can save some calculations for the reduction applied after the operation. In fact, it is easy to show that only isolated nodes and nodes that have an isolated node as neighbors need to be looked at anew to verify their equivalence. Furthermore, it is easy to identify isolated nodes because they belong to the L list of algorithms, and the advantage of this approach is that the reduction step does not increase the complexity of addition or deletion."}, {"heading": "5 Persistent modifications during the search", "text": "Consider C an MDD (L, 1, root (mdd1), y1), y2), DELETEARC (L, y2), i), i), c), c), c), c), c), c), c), c), c), c), c), c \", c\", c \", c\", c \", c\", c \", c\", c \", c\", c \", c\", c \", c\", c, c \"c, c\" c, c, c, c, c, c, c \"c, c\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c,\" c, \"c\" c, \"c,\" c \"c,\" c, c \"c, c, c\" c, c \"c, c, c\" c, c, c \"c, c\" c, c, c \"c, c\" c, c \"c, c, c\" c, c \"c, c, c\" c, c, c \"c, c, c\" c, c, c \"c, c, c, c, c\" c, c, c, c, c \"c, c, c, c\" c, c, c, c, c, c, c \"c, c, c, c, c, c, c\" c, c, c, c, c, c, c \"c, c\" c, c, c, c, c, c, c \"c, c, c, c, c, c, c\" c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, \"c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c,\" c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c"}, {"heading": "6 Experiments", "text": "The aim of these experiments is not to show that MDD-4R is a competitive algorithm compared to GAC-4R or other efficient algorithms for table constraints, even if we retrieve some results. This study has already been done in [17]. We aim to show that an MDD approach competes with a table approach even if it uses compressed tuples. Machines MacBook Pro, Intel Core I7, 2.3GHz, 8GB of memory. We build random instances for a global picture of the two approaches. GAC-4R vs MDD-4R We remember the advantage of MDD-4R over GAC-4R when there are a large number of tups."}, {"heading": "7 Conclusion", "text": "We have given an algorithm for converting tuple sets, GCS, and tuple sequences into an MDD. Then we have described efficient on-site algorithms for adding or deleting tuples from an MDD. Finally, we have considered the dynamic modification of an MDD constraint and proposed a dynamic algorithm to maintain arc consistency while searching for a solution. We have also shown some experiments, which prove that an MDD approach competes with a spreadsheet approach to represent constraint extension constraints."}], "references": [{"title": "A constraint store based on multivalued decision diagrams", "author": ["Henrik Reif Andersen", "Tarik Hadzic", "John N. Hooker", "Peter Tiedemann"], "venue": "In CP,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "Mdd propagation for sequence constraints", "author": ["D. Bergman", "A. Cire", "W-J. van Hoeve"], "venue": "Jour- nal of Artificial Intelligence Research,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Manipulating mdd relaxations for combinatorial optimization", "author": ["David Bergman", "Willem Jan van Hoeve", "John N. Hooker"], "venue": "In CPAIOR,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Arc-consistency in dynamic constraint satisfaction problems", "author": ["C. Bessi\u00e8re"], "venue": "Proceedings AAAI,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1991}, {"title": "Symbolic boolean manipulation with ordered binary decision diagrams", "author": ["R.E. Bryant"], "venue": "ACM Computing Surveys,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1992}, {"title": "Graph-based algorithms for boolean function manipulation", "author": ["Randal E. Bryant"], "venue": "IEEE Trans- actions on Computers,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1986}, {"title": "An mdd-based generalized arc consistency algorithm for positive and negative table constraints and some global", "author": ["K. Cheng", "R. Yap"], "venue": "constraints. Constraints,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Maintaining generalized arc consistency on ad hoc r-ary constraints", "author": ["Kenil C.K. Cheng", "Roland H.C. Yap"], "venue": "In CP,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "Global cut framework for removing symmetries", "author": ["F. Focacci", "M. Milano"], "venue": "In Proc. CP\u201901,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2001}, {"title": "Mdd propagators with explanation", "author": ["G. Gange", "P. Stuckey", "Radoslaw Szymanek"], "venue": "Con- straints,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Data structures for generalised arc con- sistency for extensional constraints", "author": ["I. Gent", "C. Jefferson", "I. Miguel", "P. Nightingale"], "venue": "In Proc", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Approximate com- pilation of constraints into multivalued decision diagrams", "author": ["Tarik Hadzic", "John N. Hooker", "Barry O\u2019Sullivan", "Peter Tiedemann"], "venue": "In CP,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "A systematic approach to mdd- based constraint programming", "author": ["Samid Hoda", "Willem Jan van Hoeve", "John N. Hooker"], "venue": "In CP,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Practical reformulations with table constraints", "author": ["Olivier Lhomme"], "venue": "In ECAI, pages 911\u2013912,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "Good old discrete relaxation", "author": ["R. Mohr", "G. Masini"], "venue": "In Proceedings of ECAI-88,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1988}, {"title": "Improving GAC-4 for table and MDD constraints", "author": ["G. Perez", "J-C. R\u00e9gin"], "venue": "In Principles and Practice of Constraint Programming - 20th International Conference,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2014}, {"title": "Efficient operations on mdds for building constraint programming models", "author": ["G. Perez", "J-C. R\u00e9gin"], "venue": "In International Joint Conference on Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Improving the expressiveness of table constraints", "author": ["J-C. R\u00e9gin"], "venue": "In CP\u201911, proceedings work- shop ModRef\u201911,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2011}], "referenceMentions": [{"referenceID": 7, "context": "Cheng and Yap have proposed to compress the tuple set of the constraint by using Multi-valued Decision Diagrams (MDD) and designed mddc one of the first filtering algorithm establishing arc consistency for them [8,7].", "startOffset": 211, "endOffset": 216}, {"referenceID": 6, "context": "Cheng and Yap have proposed to compress the tuple set of the constraint by using Multi-valued Decision Diagrams (MDD) and designed mddc one of the first filtering algorithm establishing arc consistency for them [8,7].", "startOffset": 211, "endOffset": 216}, {"referenceID": 15, "context": "Recently, Perez and R\u00e9gin have presented MDD-4R a new algorithm which improves mddc [17].", "startOffset": 84, "endOffset": 88}, {"referenceID": 16, "context": "They have also introduced an efficient algorithm for reducing a MDD and some powerful algorithms for combining MDDs [18].", "startOffset": 116, "endOffset": 120}, {"referenceID": 13, "context": "They can be specified either directly, by input from the user, or indirectly by synthesizing other constraints or subproblems [15,14].", "startOffset": 126, "endOffset": 133}, {"referenceID": 12, "context": "They can be specified either directly, by input from the user, or indirectly by synthesizing other constraints or subproblems [15,14].", "startOffset": 126, "endOffset": 133}, {"referenceID": 8, "context": "They have been reinforced in order to deal either from tuples or from sequences of tuples [10,12,19].", "startOffset": 90, "endOffset": 100}, {"referenceID": 10, "context": "They have been reinforced in order to deal either from tuples or from sequences of tuples [10,12,19].", "startOffset": 90, "endOffset": 100}, {"referenceID": 17, "context": "They have been reinforced in order to deal either from tuples or from sequences of tuples [10,12,19].", "startOffset": 90, "endOffset": 100}, {"referenceID": 5, "context": "It is a multiple-valued extension of BDDs [6].", "startOffset": 42, "endOffset": 45}, {"referenceID": 0, "context": "An MDD, as used in CP [1,13,14,3,11], is a rooted directed acyclic graph (DAG) used to represent some multi-valued function f : {0.", "startOffset": 22, "endOffset": 36}, {"referenceID": 11, "context": "An MDD, as used in CP [1,13,14,3,11], is a rooted directed acyclic graph (DAG) used to represent some multi-valued function f : {0.", "startOffset": 22, "endOffset": 36}, {"referenceID": 12, "context": "An MDD, as used in CP [1,13,14,3,11], is a rooted directed acyclic graph (DAG) used to represent some multi-valued function f : {0.", "startOffset": 22, "endOffset": 36}, {"referenceID": 2, "context": "An MDD, as used in CP [1,13,14,3,11], is a rooted directed acyclic graph (DAG) used to represent some multi-valued function f : {0.", "startOffset": 22, "endOffset": 36}, {"referenceID": 9, "context": "An MDD, as used in CP [1,13,14,3,11], is a rooted directed acyclic graph (DAG) used to represent some multi-valued function f : {0.", "startOffset": 22, "endOffset": 36}, {"referenceID": 16, "context": "However, a new reduction algorithm has been recently proposed by Perez and R\u00e9gin [18].", "startOffset": 81, "endOffset": 85}, {"referenceID": 10, "context": "for compressing tuple sets [12].", "startOffset": 27, "endOffset": 31}, {"referenceID": 6, "context": "A trie can be transformed into an MDD by merging all the leaves into the terminal node tt and by applying the reduction operation [7].", "startOffset": 130, "endOffset": 133}, {"referenceID": 8, "context": "A GCS (Global Cut Seed), is a compact representation of a tuple set [10].", "startOffset": 68, "endOffset": 72}, {"referenceID": 17, "context": "In order to remedy to this problem, tuple sequences have been introduced [19].", "startOffset": 73, "endOffset": 77}, {"referenceID": 17, "context": "Nevertheless, it may create an exponential number of tuple sequences [19].", "startOffset": 69, "endOffset": 73}, {"referenceID": 5, "context": "For instance, Bryant define some algorithms for applying different operators [6,5].", "startOffset": 77, "endOffset": 82}, {"referenceID": 4, "context": "For instance, Bryant define some algorithms for applying different operators [6,5].", "startOffset": 77, "endOffset": 82}, {"referenceID": 1, "context": "Some algorithms have also been proposed for applying operators on MDDs [2,18].", "startOffset": 71, "endOffset": 77}, {"referenceID": 16, "context": "Some algorithms have also been proposed for applying operators on MDDs [2,18].", "startOffset": 71, "endOffset": 77}, {"referenceID": 0, "context": "First we identify a1 = (r, n1, \u03c4 [1]) the arc of the first layer labeled by \u03c4 [1] the first value of the tuple.", "startOffset": 33, "endOffset": 36}, {"referenceID": 0, "context": "First we identify a1 = (r, n1, \u03c4 [1]) the arc of the first layer labeled by \u03c4 [1] the first value of the tuple.", "startOffset": 78, "endOffset": 81}, {"referenceID": 0, "context": "We create the node ne1, the arc (r, ne1, \u03c4 [1]) and we delete the arc a1.", "startOffset": 43, "endOffset": 46}, {"referenceID": 3, "context": "It is not a fully dynamic arc consistency algorithm like DnAC-4 [4] or DnAC-6 [9] because we will not consider the addition of tuples in the MDD.", "startOffset": 64, "endOffset": 67}, {"referenceID": 14, "context": "This is a adaptation of GAC-4 [16] to MDD which improves the incrementality of GAC-4 [17].", "startOffset": 30, "endOffset": 34}, {"referenceID": 15, "context": "This is a adaptation of GAC-4 [16] to MDD which improves the incrementality of GAC-4 [17].", "startOffset": 85, "endOffset": 89}, {"referenceID": 15, "context": "This study has already been done in [17].", "startOffset": 36, "endOffset": 40}], "year": 2015, "abstractText": "We study the relations between Multi-valued Decision Diagrams (MDD) and tuples (i.e. elements of the Cartesian Product of variables). First, we improve the existing methods for transforming a set of tuples, Global Cut Seeds, sequences of tuples into MDDs. Then, we present some in-place algorithms for adding and deleting tuples from an MDD. Next, we consider an MDD constraint which is modified during the search by deleting some tuples. We give an algorithm which adapts MDD-4R to these dynamic and persistent modifications. Some experiments show that MDD constraints are competitive with Table constraints.", "creator": "LaTeX with hyperref package"}}}