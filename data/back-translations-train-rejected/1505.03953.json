{"id": "1505.03953", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-May-2015", "title": "A Theory of Formal Synthesis via Inductive Learning", "abstract": "Formal synthesis is the process of generating a program satisfying a high-level specification. In recent times, effective formal synthesis methods have been proposed based on the use of inductive learning. We refer to this class of methods that learn programs from examples as formal inductive synthesis. In this paper, we present a theoretical framework for formal inductive synthesis. We discuss how formal inductive synthesis differs from traditional machine learning. We then describe oracle-guided inductive synthesis (OGIS), a class of synthesizers that operate by iteratively querying an oracle. An instance of OGIS that has had much practical impact is counterexample-guided inductive synthesis (CEGIS). We present a theoretical characterization of CEGIS for learning any program that computes a recursive language. In particular, we analyze the relative power of CEGIS variants where the types of counterexamples generated by the oracle varies. We also consider the impact of bounded versus unbounded memory available to the learning algorithm. In the special case where the universe of candidate programs is finite, we relate the speed of convergence to the notion of teaching dimension studied in machine learning theory. Altogether, the results of the paper take a first step towards a theoretical foundation for the emerging field of formal inductive synthesis.", "histories": [["v1", "Fri, 15 May 2015 03:47:18 GMT  (1273kb,D)", "https://arxiv.org/abs/1505.03953v1", null], ["v2", "Thu, 25 Jun 2015 14:13:04 GMT  (81kb,D)", "http://arxiv.org/abs/1505.03953v2", null], ["v3", "Sun, 8 Nov 2015 01:21:36 GMT  (126kb,D)", "http://arxiv.org/abs/1505.03953v3", null], ["v4", "Sat, 21 May 2016 07:41:54 GMT  (765kb,D)", "http://arxiv.org/abs/1505.03953v4", null]], "reviews": [], "SUBJECTS": "cs.AI cs.FL", "authors": ["susmit jha", "sanjit a seshia"], "accepted": false, "id": "1505.03953"}, "pdf": {"name": "1505.03953.pdf", "metadata": {"source": "CRF", "title": "A Theory of Formal Synthesis via Inductive Learning", "authors": ["Susmit Jha", "Sanjit A. Seshia"], "emails": ["jhask@utrc.utc.com", "sseshia@eecs.berkeley.edu"], "sections": [{"heading": null, "text": "Submitted to: c \u00a9 S. Jha & S. A. SeshiaThis work is licensed under the Creative Commons Attribution License."}, {"heading": "A Theory of Formal Synthesis via Inductive Learning", "text": "Susmit Jha United Technologies Research Center, Berkeleyjhask @ utrc.utc.com. Sanjit A. Seshia EECS, UC Berkeleysseshia @ eecs.berkeley.eduFormal synthesis is the process of generating a program that meets a high-level formal specification. Recently, effective formal synthesis methods based on the use of inductive learning have been proposed. We refer to this class of methods that programs learn from examples as formal inductive synthesis. In this paper, we present a theoretical framework for formal inductive synthesis. We discuss how formal inductive synthesis differs from traditional machine learning. We then describe oracle-assisted inductive synthesis (OGIS), a framework that covers a family of synthesizers that operate by iterative query of an oracle. An instance of OGIS that has had much practical effect is called oracle analytical synthesis (CEGIS)."}, {"heading": "1 Introduction", "text": "This year, the time has come for them to be able to live in a country in which they are able, in which they are able to move, and in which they are able to move in order to develop."}, {"heading": "2.3 Counterexample-Guided Inductive Synthesis (CEGIS)", "text": "This year it is more than ever before."}, {"heading": "3 Background and Related Work", "text": "In this section, we compare the contributions of this paper with the most closely related papers and also provide some relevant background information."}, {"heading": "3.1 Formal Synthesis", "text": "In the last decade, there has been an explosion of work in program synthesis (e.g. [54, 55, 30, 56, 37, 58]. Furthermore, it has been recognized that many of the trickiest steps of formal verification involve the synthesis of artifacts such as inductive invariants, ranks, assumptions, etc. [51, 23] Most of these efforts have focused on solving specific synthesis problems. Most of these efforts have two essential unifying features: (i) syntactical constraints on the space of programs / artifacts to be synthesized in the form of templates, sketches, component libraries, etc., and (ii) the use of inductive synthesis using examples. The most recent work on syntax-based synthesis (SyGuS) [1] is an attempt to capture these disparate efforts in a common theoretical formalism."}, {"heading": "3.2 Machine Learning Theory", "text": "Another related area is the field of machine learning, in particular theoretical literature. In Section 1, we outlined some of the main differences between the areas of formal inductive synthesis and machine learning. Here, we focus on the sub-area of query-based learning that comes closest to the OGIS framework. Readers are referred to Angluin's excellent essays on the subject for more background information [4, 5]. A big difference between the query-based learning literature and our work lies in the treatment of oracles, in particular how much control one has over the oracle that answers questions. In query-based learning, the oracles are treated as black boxes that have to answer certain types of queries and only provide a valid answer to a query. Furthermore, it is typical in the query-based learning literature that the oracle is specified a priori as part of the formulation of the problem. In contrast, designing a synthesis process involves the development of a learning concept based on the most important of the learning concepts that relate to the constellation."}, {"heading": "3.3 Learning of Formal Languages", "text": "The problem of learning a formal language from examples is classical. We cover some relevant background materials here. Gold [19] looked at the problem of learning formal languages from examples. Similar techniques have been studied elsewhere in the literature, but the examples are provided to the learner as an infinite stream. It is assumed that the learner has an unlimited memory and can store all examples. This model is unrealistic in a practical environment, but offers a useful theoretical understanding of inductive learning of formal languages. Gold defined a language class that is identifiable at the boundary if there is a learning method that identifies the grammar of the target language with a stream of input strings. Languages that were learned with only positive examples were designated as positive and negative examples."}, {"heading": "3.4 Learning vs. Teaching", "text": "We also examine the complexity of synthesizing programs from a finite class of programs. This part of our work refers to previous work on the complexity of teaching the exact learning of concepts by Goldman and Kearns. [20] Informal, the didactic dimension of a concept class is the minimum number of instances a teacher must disclose in order to uniquely identify a target concept from the class. [20, 21] Shinohara et al. [53] also introduced a notion of teaching ability in which a concept class can be taught using examples if there is a polynomic size sample under which all consistent learners will accurately identify the target concept. [50] Also consider a model of learning with an auxiliary teacher's algorithm that requires each teacher to use a specific algorithm to correct the target concept."}, {"heading": "4 Theoretical Analysis of CEGIS: Preliminaries", "text": "Our presentation of formal inductive synthesis and OGIS has not yet used any particular representation of a concept class or specification. In this section, we will begin with the theoretical formalization of the Contrasting Inductive Synthesis Technique (CEGIS), for which such a choice is necessary. We will precisely define the formal inductive synthesis problem for concepts that correspond to recursive languages. We will limit our attention to the case where the specification is partial and represents a trace property - i.e. the specification is defined by a single formal language. This assumption, which is typical of formal verification and synthesis, also simplifies notation and evidence. Most of our results cover the case of more general specifications; we will make appropriate additional comments on the general case where appropriate. For simplification, the main definitions and frequently used notation are summarized in Table 1."}, {"heading": "4.1 Basic Notation", "text": "We use N to call the set of natural numbers. We use N to call the set of natural numbers."}, {"heading": "4.2 CEGIS Definitions", "text": "We now specialize in the definitions of Sec. 2 in the case of CEGIS. An indexed language family (also referred to as a language class) L defines the concept of class C for synthesis. Domain E for synthesis is the set of natural numbers N and the examples are i. We remember that we can limit our attention to the specific case where the specification of the language is captured by a single target language, i.e. Lc covers all permitted speech behaviors."}, {"heading": "5 Theoretical Analysis of CEGIS: Results", "text": "In this section we will present the theoretical results if the class of languages (programs) is infinite. We will consider two axes of variation. First, we will consider the case in which the technique of inductive learning has a finite memory, in Section 5.1, and then the case in which it has a finite memory, in Section 5.2. In both cases, we will consider the four types of counterexamples mentioned in Section 1 and Section 4, namely arbitrary counter-examples, minimal counter-examples, constantly limited counter-examples and positively limited counter-examples. For the sake of simplicity, however, our evidence focuses on the case of sub-specifications that are trace characteristics, the common case in formal verification and synthesis. Thus, it includes subsets of a target specification language Lc. However, many of the results given here extend to the case of general specifications. Most of our theorems show differences between language classes for CEGIS variants - i.e. theorems that show that there is a specification of a class that does not match, e.g., some of the CEIS variant for some cases)."}, {"heading": "5.1 Finite Memory Inductive Synthesis", "text": "We study the four language classes cegis, mincegis, cbcegis and pbcegis, which are identified by the synthesis motors Tcegis, Tmincegis, Tcbcegis and Tpbcegis and establish relationships between them. We show that cbcegis, mincegis = cegis, pbcegis are 6 cegis and pbcegis are 6 cegis."}, {"heading": "5.1.1 Minimal vs. Arbitrary Counterexamples", "text": "It is about the question to what extent it is worth sticking to the rules that applied in the past. (...) It is about the question to what extent it is about the future in the present. (...) It is about the question to what extent it is about the future. (...) It is about the future. (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"It is about the future.\" (...) \"(...)\" It is about the future. \"(...)\" It is about the future. \"(...)\" It is about the future. \"(...)\" It is about the future. \"(...\" It is about the future. \"(...)\" It is about the future. \"(...\" It is about the future. \"It is about the future.\" (...)"}, {"heading": "5.1.2 Bounded vs. Arbitrary Counterexamples", "text": "Next, we explore cbcegis and compare its relative synthesizing power to cegis."}, {"heading": "5.1.3 Different Flavors of Bounded Counterexamples", "text": "Theorem 5.6 The power of synthesis techniques with limited counterexamples is therefore neither less nor more than the techniques with positively limited counterexamples, i.e., cbcegis 6 pbcegis and pbcegis 6 cbcegis. Proof We consider two languages taken into account in previous proofs and show that the languages corresponding to one of them can only be identified by pbcegis, while the languages corresponding to the other can only be identified by cbcegis. Consider the language family 1 (Lnotcb), which is formed by a fixed constant through a lower boundary of the elements, i.e., Lnotcb = {Li | i > B and Li = {n | N} n > i}}}, where B is a fixed integer constant. In Theorem 5.2, we have shown that a synthesis machine Tcbcfifiis cannot identify all languages in Lnotcb."}, {"heading": "5.2 Infinite Memory Inductive Synthesis", "text": "This year, it has reached the point where it will be able to put itself at the top of the list."}, {"heading": "6.1 NP-hardness", "text": "We measure the efficiency of an OGIS synthesis engine using the concept of sample complexity mentioned in paragraph 2. < p > The number of queries (and answers) necessary to correctly identify a language. To analyze the sample complexity, we need to resolve the nature of queries about the oracle. We focus on queries for which the oracle provides an example or counter-example in the answer. We show that searching for a minimum set of examples provided by the oracle so that the synthesis machine matches the correct language is NP-hard.Theorem 6.1 Solving the formal inductive synthesis problem < C, E, \u03a6, O > for a limited set of examples for C and finite E with the minimum number of queries is NP-hard for each oracle interface O that includes correctness, qr (and possibly Proqwit prove bleed) by reducing the hardness of the NP."}, {"heading": "6.2 Relation to Teaching Dimension", "text": "Goldman et al. [20, 21] proposed teaching dimension as a measure for exploring the computational complexity of learning is only a teaching model in which a helpful teacher selects the examples of the concept and makes them available to the learner. [20, 21] In the learning model proposed by Goldman et al. [20, 21], the basic goal of the teacher is to help the learner identify the target concept by offering an example sequence from E. C that formally defines the teaching dimension of a concept class.Definition 6.1 (adapted from [20]) An example sequence of marked examples from E, where the labels are given by some underlying specifications."}, {"heading": "7 Conclusion", "text": "We presented a theoretical framework and analysis of formal inductive synthesis by formalizing the concept of oracle-assisted inductive synthesis (OGIS). We showed how OGIS generalizes examples of concept learning in machine learning as well as synthesis techniques developed using formal methods. We focused on counter-example inductive synthesis (CEGIS), an OGIS implementation that uses the verification machine as an oracle. We presented various variations of cegis that are motivated by practice, and demonstrated that their synthesis power can be different, especially when the learning machine can store only a limited number of examples. There are several directions for future work. We will discuss some open problems among them that would further improve the theoretical understanding of formal inductive synthesis."}], "references": [{"title": "Syntax-Guided Synthe-  28  Formal Inductive Synthesis sis", "author": ["Rajeev Alur", "Rastislav Bodik", "Garvit Juniwal", "Milo M.K. Martin", "Mukund Raghothaman", "Sanjit A. Seshia", "Rishabh Singh", "Armando Solar-Lezama", "Emina Torlak", "Abhishek Udupa"], "venue": "Proceedings of the IEEE International Conference on Formal Methods in Computer-Aided Design (FMCAD)", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2013}, {"title": "Inductive Inference of Formal Languages from Positive Data", "author": ["Dana Angluin"], "venue": "Information and Control", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1980}, {"title": "Learning regular sets from queries and counterexamples", "author": ["Dana Angluin"], "venue": "Information and computation", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1987}, {"title": "Queries and concept learning", "author": ["Dana Angluin"], "venue": "Machine Learning", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1988}, {"title": "Available at http://www.sciencedirect.com/ science/article/pii/S030439750300608X", "author": ["Dana Angluin"], "venue": "Queries revisited. Theoretical Computer Science", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Inductive Inference: Theory and Methods", "author": ["Dana Angluin", "Carl H. Smith"], "venue": "ACM Computing Surveys", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1983}, {"title": "Context-Bounded Analysis For Concurrent Programs With Dynamic Creation of Threads", "author": ["Mohamed Faouzi Atig", "Ahmed Bouajjani", "Shaz Qadeer"], "venue": "Logical Methods in Computer Science", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Satisfiability Modulo Theories", "author": ["Clark Barrett", "Roberto Sebastiani", "Sanjit A. Seshia", "Cesare Tinelli"], "venue": "editors: Handbook of Satisfiability,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2009}, {"title": "Bounded Model Checking", "author": ["Armin Biere"], "venue": "Handbook of Satisfiability,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Toward a mathematical theory of inductive inference", "author": ["L. Blum", "M. Blum"], "venue": "Information and Control", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1975}, {"title": "Learnability and the Vapnik-Chervonenkis Dimension", "author": ["Anselm Blumer", "A. Ehrenfeucht", "David Haussler", "Manfred K. Warmuth"], "venue": "J. ACM 36(4),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1989}, {"title": "Graph-based algorithms for Boolean function manipulation", "author": ["Randal E. Bryant"], "venue": "IEEE Transactions on Computers", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1986}, {"title": "Automated Design Debugging With Maximum Satisfiability", "author": ["Yibin Chen", "Sean Safarpour", "Joo Marques-Silva", "Andreas G. Veneris"], "venue": "IEEE Trans. on CAD of Integrated Circuits and Systems", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Design and Synthesis of Synchronization Skeletons Using Branching-Time", "author": ["Edmund M. Clarke", "E. Allen Emerson"], "venue": "Temporal Logic. In: Logic of Programs,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1981}, {"title": "Special issue on learning techniques for compositional reasoning", "author": ["Dimitra Giannakopoulou", "Corina S. Pasareanu", "eds"], "venue": "Formal Methods in System Design", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "On the Complexity of Teaching", "author": ["Sally A. Goldman", "Michael J. Kearns"], "venue": "Journal of Computer and System Sciences", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1992}, {"title": "Learning Binary Relations and Total Orders", "author": ["Sally A. Goldman", "Ronald L. Rivest", "Robert E. Schapire"], "venue": "SIAM J. Comput", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1993}, {"title": "Synthesizing software verifiers from proof rules", "author": ["Sergey Grebenshchikov", "Nuno P Lopes", "Corneliu Popeea", "Andrey Rybalchenko"], "venue": "ACM SIGPLAN Notices, 47,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2012}, {"title": "Geometrical Concept Learning and Convex Polytopes", "author": ["Tibor Heged\u0171s"], "venue": "Proceedings of the Seventh Annual Conference on Computational Learning Theory, COLT \u201994,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1994}, {"title": "An Efficient Membership-Query Algorithm for Learning {DNF} with Respect to the Uniform Distribution", "author": ["C Jeffrey"], "venue": "Journal of Computer and System Sciences", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1997}, {"title": "Systems that learn: an introduction to learning theory", "author": ["Sanjay Jain"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1999}, {"title": "Iterative learning from positive data and negative counterexamples", "author": ["Sanjay Jain", "Efim Kinber"], "venue": "Information and Computation", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2007}, {"title": "Combining Postulates of Naturalness in Inductive Inference", "author": ["Klaus P. Jantke", "Hans-Rainer"], "venue": "Beick", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1981}, {"title": "Oracle-guided Component-based Program Synthesis", "author": ["Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "ICSE \u201910,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2010}, {"title": "Synthesizing Switching Logic for Safety and Dwell-Time Requirements", "author": ["Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "Proceedings of the International Conference on Cyber-Physical Systems (ICCPS),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "Are There Good Mistakes? A Theoretical Analysis of CEGIS", "author": ["Susmit Jha", "Sanjit A. Seshia"], "venue": "Workshop on Synthesis (SYNT)", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2014}, {"title": "Synthesis of Optimal Switching Logic for Hybrid Systems", "author": ["Susmit Jha", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "Proceedings of the International Conference on Embedded Software (EMSOFT),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2011}, {"title": "Towards Automated System Synthesis Using SCIDUCTION", "author": ["Susmit Kumar Jha"], "venue": "Ph.D. thesis, EECS Department,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2011}, {"title": "Mining Requirements from Closed-Loop Control Models", "author": ["Xiaoqing Jin", "Alexandre Donz\u00e9", "Jyotirmoy Deshmukh", "Sanjit A. Seshia"], "venue": "Proceedings of the International Conference on Hybrid Systems: Computation and Control (HSCC)", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2013}, {"title": "Computer-Aided Reasoning: An Approach", "author": ["Matt Kaufmann", "Panagiotis Manolios", "J. Strother Moore"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2000}, {"title": "Software synthesis procedures", "author": ["Viktor Kuncak", "Mika\u00ebl Mayer", "Ruzica Piskac", "Philippe Suter"], "venue": "Commun. ACM", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2012}, {"title": "Algorithmic Learning of Recursive Languages. Mensch-und-Buch-Verlag", "author": ["S. Lange"], "venue": null, "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2000}, {"title": "Learning Indexed Families of Recursive Languages from Positive Data: A Survey", "author": ["Steffen Lange", "Thomas Zeugmann", "Sandra Zilles"], "venue": "Theor. Comput. Sci", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2008}, {"title": "Formal language identification: Query learning vs gold-style learning", "author": ["Steffen Lange", "Sandra Zilles"], "venue": "Information Processing Letters,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2004}, {"title": "Boolean Satisfiability: From Theoretical Hardness to Practical Success", "author": ["Sharad Malik", "Lintao Zhang"], "venue": "Communications of the ACM (CACM)", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2009}, {"title": "A Deductive Approach to Program Synthesis", "author": ["Zohar Manna", "Richard Waldinger"], "venue": "ACM Trans. Program. Lang. Syst", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 1980}, {"title": "Machine Learning, first edition", "author": ["Thomas M. Mitchell"], "venue": null, "citeRegEx": "43", "shortCiteRegEx": "43", "year": 1997}, {"title": "MaxSAT-Based MCS Enumeration", "author": ["Antonio Morgado", "Mark Liffiton", "Joao Marques-Silva"], "venue": null, "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2013}, {"title": "PVS: A Prototype Verification System", "author": ["S. Owre", "J.M. Rushby", "N. Shankar"], "venue": "In Deepak Kapur, editor: 11th International Conference on Automated Deduction (CADE), Lecture Notes in Artificial Intelligence", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 1992}, {"title": "On the Synthesis of a Reactive Module", "author": ["Amir Pnueli", "Roni Rosner"], "venue": "ACM Symposium on Principles of Programming Languages (POPL),", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1989}, {"title": "Specification and Verification of Concurrent Systems in CESAR", "author": ["Jean-Pierre Queille", "Joseph Sifakis"], "venue": "In: Symposium on Programming,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 1982}, {"title": "Induction of Decision Trees", "author": ["J.R. Quinlan"], "venue": "Mach. Learn", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1986}, {"title": "Theory of Recursive Functions and Effective Computability", "author": ["Hartley Rogers", "Jr."], "venue": null, "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1987}, {"title": "Best-case results for nearest-neighbor learning", "author": ["S. Salzberg", "A.L. Delcher", "D. Heath", "S. Kasif"], "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on 17(6),", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1995}, {"title": "Sciduction: Combining Induction, Deduction, and Structure for Verification and Synthesis", "author": ["Sanjit A. Seshia"], "venue": "Proceedings of the Design Automation Conference (DAC),", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2012}, {"title": "Algorithmic Program Debugging", "author": ["Ehud Y Shapiro"], "venue": null, "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1982}, {"title": "Teachability in Computational Learning", "author": ["Ayumi Shinohara", "Satoru Miyano"], "venue": "In: ALT,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 1990}, {"title": "Programming by sketching for bit-streaming programs", "author": ["Armando Solar-Lezama", "Rodric Rabbah", "Rastislav Bod\u0131\u0301k", "Kemal Ebcioglu"], "venue": null, "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2005}, {"title": "Combinatorial sketching for finite programs", "author": ["Armando Solar-Lezama", "Liviu Tancau", "Rastislav Bodk", "Sanjit A. Seshia", "Vijay A. Saraswat"], "venue": "In: ASPLOS,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2006}, {"title": "A Methodology for LISP Program Construction from Examples", "author": ["Phillip D. Summers"], "venue": "J. ACM 24(1)", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 1977}, {"title": "TRANSIT: Specifying Protocols with Concolic Snippets", "author": ["Abhishek Udupa", "Arun Raghavan", "Jyotirmoy V. Deshmukh", "Sela Mador-Haim", "Milo M.K. Martin", "Rajeev Alur"], "venue": "Proceedings of the 34th ACM SIGPLAN conference on Programming Language Design and Implementation,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2013}, {"title": "A Theory of the Learnable", "author": ["G. Leslie"], "venue": "Valiant", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 1984}, {"title": "On the Uniform Convergence of Relative Frequencies of Events to Their Probabilities", "author": ["V.N. Vapnik", "A. Ya"], "venue": "Chervonenkis", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 1971}, {"title": "Applied Linear Regression, third edition", "author": ["Sanford Weisberg"], "venue": "Wiley, Hoboken NJ. Available at http: //www.stat.umn.edu/alr", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2005}, {"title": "Limit Detection of Recursive Functions by Specific Strategies", "author": ["Rolf Wiehagen"], "venue": "Electronic Information Processing and Cybernetics", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 1976}, {"title": "A Thesis in Inductive Inference", "author": ["Rolf Wiehagen"], "venue": "editors: Nonmonotonic and Inductive Logic, Lecture Notes in Computer Science 543,", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 1990}, {"title": "The Formal Semantics of Programming Languages: An Introduction", "author": ["Glynn Winskel"], "venue": null, "citeRegEx": "64", "shortCiteRegEx": "64", "year": 1993}], "referenceMentions": [{"referenceID": 13, "context": "Formal verification techniques such as model checking [15, 47, 16] and theorem proving (see, e.", "startOffset": 54, "endOffset": 66}, {"referenceID": 40, "context": "Formal verification techniques such as model checking [15, 47, 16] and theorem proving (see, e.", "startOffset": 54, "endOffset": 66}, {"referenceID": 38, "context": "[45, 36, 22]) are used routinely in the computer-aided design of integrated circuits and have been widely applied to find bugs in software, analyze models of embedded systems, and find security vulnerabilities in programs and protocols.", "startOffset": 0, "endOffset": 12}, {"referenceID": 29, "context": "[45, 36, 22]) are used routinely in the computer-aided design of integrated circuits and have been widely applied to find bugs in software, analyze models of embedded systems, and find security vulnerabilities in programs and protocols.", "startOffset": 0, "endOffset": 12}, {"referenceID": 34, "context": "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].", "startOffset": 120, "endOffset": 124}, {"referenceID": 11, "context": "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].", "startOffset": 158, "endOffset": 162}, {"referenceID": 7, "context": "At the heart of many of these advances are computational reasoning engines such as Boolean satisfiability (SAT) solvers [41], Binary Decision Diagrams (BDDs) [13], and satisfiability modulo theories (SMT) solvers [8].", "startOffset": 213, "endOffset": 216}, {"referenceID": 35, "context": "Starting with the seminal work of Manna and Waldinger on deductive program synthesis [42] and Pnueli and Rosner on reactive synthesis from temporal logic [46], there have been several advances that have made formal synthesis practical in specific application domains such as robotics, online education, and end-user programming.", "startOffset": 85, "endOffset": 89}, {"referenceID": 39, "context": "Starting with the seminal work of Manna and Waldinger on deductive program synthesis [42] and Pnueli and Rosner on reactive synthesis from temporal logic [46], there have been several advances that have made formal synthesis practical in specific application domains such as robotics, online education, and end-user programming.", "startOffset": 154, "endOffset": 158}, {"referenceID": 35, "context": ", [42]), a program is synthesized by constructively proving a theorem, employing logical inference and constraint solving.", "startOffset": 2, "endOffset": 6}, {"referenceID": 49, "context": "On the other hand, inductive synthesis [19, 57, 52] seeks to find a program matching a set of input-output examples.", "startOffset": 39, "endOffset": 51}, {"referenceID": 45, "context": "On the other hand, inductive synthesis [19, 57, 52] seeks to find a program matching a set of input-output examples.", "startOffset": 39, "endOffset": 51}, {"referenceID": 5, "context": "At a high level, it is thus an instance of learning from examples, also termed as inductive inference or machine learning [6, 43].", "startOffset": 122, "endOffset": 129}, {"referenceID": 36, "context": "At a high level, it is thus an instance of learning from examples, also termed as inductive inference or machine learning [6, 43].", "startOffset": 122, "endOffset": 129}, {"referenceID": 44, "context": "Many current approaches to synthesis blend induction and deduction in the sense that even as they generalize from examples, deductive procedures are used in the process of generalization (see [51, 34] for a detailed exposition).", "startOffset": 192, "endOffset": 200}, {"referenceID": 27, "context": "Many current approaches to synthesis blend induction and deduction in the sense that even as they generalize from examples, deductive procedures are used in the process of generalization (see [51, 34] for a detailed exposition).", "startOffset": 192, "endOffset": 200}, {"referenceID": 48, "context": "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].", "startOffset": 170, "endOffset": 181}, {"referenceID": 44, "context": "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].", "startOffset": 170, "endOffset": 181}, {"referenceID": 0, "context": "It has been recognized that this syntax guidance, also termed as a structure hypothesis, can be crucial in helping the synthesizer converge quickly to the target concept [55, 51, 1].", "startOffset": 170, "endOffset": 181}, {"referenceID": 53, "context": "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].", "startOffset": 156, "endOffset": 160}, {"referenceID": 18, "context": "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].", "startOffset": 179, "endOffset": 183}, {"referenceID": 19, "context": "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].", "startOffset": 275, "endOffset": 279}, {"referenceID": 41, "context": "Concept Classes: In traditional machine learning, the classes of concepts to be synthesized tend to be specialized, such as linear functions or half-spaces [61], convex polytopes [25], neural networks of specific forms [9], Boolean formulas in fixed, bounded syntactic forms [26], and decision trees [48].", "startOffset": 300, "endOffset": 304}, {"referenceID": 36, "context": "Learning Algorithms: In traditional machine learning, just as concept classes tend to be specialized, so also are the learning algorithms for those classes [43].", "startOffset": 156, "endOffset": 160}, {"referenceID": 48, "context": "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].", "startOffset": 150, "endOffset": 162}, {"referenceID": 23, "context": "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].", "startOffset": 150, "endOffset": 162}, {"referenceID": 24, "context": "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].", "startOffset": 227, "endOffset": 235}, {"referenceID": 26, "context": "For instance, the class of programs from which the synthesizer must generate the correct one may be finite, as in the synthesis of bitvector programs [55, 30, 24], or infinite, as in the synthesis of guards for hybrid automata [31, 33].", "startOffset": 227, "endOffset": 235}, {"referenceID": 48, "context": "Our work has a particular focus on counterexample-guided inductive synthesis (CEGIS) [55], a particularly popular and effective instantiation of the OGIS framework.", "startOffset": 85, "endOffset": 89}, {"referenceID": 15, "context": "In this case, we draw a connection between the number of counterexamples needed by a CEGIS procedure and the notion of teaching dimension [20] previously introduced in the machine learning literature.", "startOffset": 138, "endOffset": 142}, {"referenceID": 15, "context": "We also show that the teaching dimension [20] of the concept class is a lower bound on the number of counterexamples needed for a CEGIS technique to terminate (on an arbitrary program from that class).", "startOffset": 41, "endOffset": 45}, {"referenceID": 25, "context": "A preliminary version of this paper appeared in the SYNT 2014 workshop [32].", "startOffset": 71, "endOffset": 75}, {"referenceID": 3, "context": "Following standard terminology in the machine learning theory community [4], we define a concept c as a set of examples drawn from a domain of examples E.", "startOffset": 72, "endOffset": 75}, {"referenceID": 28, "context": "Such a query allows us to accurately model the working of counterexample-guided synthesis techniques such as [35] where the verification problem is undecidable but, if a counterexample is reported, it is a true counterexample.", "startOffset": 109, "endOffset": 113}, {"referenceID": 23, "context": "The distinguishing input query has been found useful in scenarios where it is computationally hard to check correctness using the specification \u03a6, such as in malware deobfuscation [30].", "startOffset": 180, "endOffset": 184}, {"referenceID": 4, "context": "learning theory community, there have been thorough studies of query-based learning; see Angluin\u2019s review paper [5] for details.", "startOffset": 112, "endOffset": 115}, {"referenceID": 2, "context": "1 Query-based learning of automata [3]: Angluin\u2019s classic work on learning deterministic finite automata (DFAs) from membership and equivalence queries [3] is an instance of OGIS with O = {qmem,qeq}.", "startOffset": 35, "endOffset": 38}, {"referenceID": 2, "context": "1 Query-based learning of automata [3]: Angluin\u2019s classic work on learning deterministic finite automata (DFAs) from membership and equivalence queries [3] is an instance of OGIS with O = {qmem,qeq}.", "startOffset": 152, "endOffset": 155}, {"referenceID": 14, "context": "Several variants of L\u2217 have found use in the formal verification literature; see [18] for more information.", "startOffset": 81, "endOffset": 85}, {"referenceID": 48, "context": "2 Counterexample-guided inductive synthesis (CEGIS) [55]: CEGIS was originally proposed as an algorithmic method for program synthesis where the specification is given as a reference program and the concept class is defined using a partial program, also referred to as a \u201csketch\u201d [55].", "startOffset": 52, "endOffset": 56}, {"referenceID": 48, "context": "2 Counterexample-guided inductive synthesis (CEGIS) [55]: CEGIS was originally proposed as an algorithmic method for program synthesis where the specification is given as a reference program and the concept class is defined using a partial program, also referred to as a \u201csketch\u201d [55].", "startOffset": 280, "endOffset": 284}, {"referenceID": 28, "context": ", [35]) and other ways of providing syntax guidance; see [1] for a more detailed treatment.", "startOffset": 2, "endOffset": 6}, {"referenceID": 0, "context": ", [35]) and other ways of providing syntax guidance; see [1] for a more detailed treatment.", "startOffset": 57, "endOffset": 60}, {"referenceID": 48, "context": "4 of [55] and Fig.", "startOffset": 5, "endOffset": 9}, {"referenceID": 28, "context": "3 of [35]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 28, "context": ", see [35]).", "startOffset": 6, "endOffset": 10}, {"referenceID": 23, "context": "3 Oracle-guided program synthesis using distinguishing inputs [30]: Our third example is an approach to program synthesis that uses distinguishing inputs when a complete specification is either unavailable or it is expensive to verify a candidate program against its specification [30].", "startOffset": 62, "endOffset": 66}, {"referenceID": 23, "context": "3 Oracle-guided program synthesis using distinguishing inputs [30]: Our third example is an approach to program synthesis that uses distinguishing inputs when a complete specification is either unavailable or it is expensive to verify a candidate program against its specification [30].", "startOffset": 281, "endOffset": 285}, {"referenceID": 37, "context": "Significant effort has been made on improving validation engines to produce counterexamples which aid debugging by localizing the error [44, 14].", "startOffset": 136, "endOffset": 144}, {"referenceID": 12, "context": "Significant effort has been made on improving validation engines to produce counterexamples which aid debugging by localizing the error [44, 14].", "startOffset": 136, "endOffset": 144}, {"referenceID": 8, "context": "This is motivated by the use of bounds in formal verification such as bounded model checking [10] and bug-finding in concurrent programs [7] using bounds on context switches.", "startOffset": 93, "endOffset": 97}, {"referenceID": 6, "context": "This is motivated by the use of bounds in formal verification such as bounded model checking [10] and bug-finding in concurrent programs [7] using bounds on context switches.", "startOffset": 137, "endOffset": 140}, {"referenceID": 54, "context": "This notion of finite memory is similar to that used classically for language learning from examples [62].", "startOffset": 101, "endOffset": 105}, {"referenceID": 10, "context": "We show that the complexity of these techniques is related to well-studied notions in learning theory such as the Vapnik-Chervonenkis dimension [12] and the teaching dimension [20].", "startOffset": 144, "endOffset": 148}, {"referenceID": 15, "context": "We show that the complexity of these techniques is related to well-studied notions in learning theory such as the Vapnik-Chervonenkis dimension [12] and the teaching dimension [20].", "startOffset": 176, "endOffset": 180}, {"referenceID": 47, "context": "[54, 55, 30, 56, 37, 58].", "startOffset": 0, "endOffset": 24}, {"referenceID": 48, "context": "[54, 55, 30, 56, 37, 58].", "startOffset": 0, "endOffset": 24}, {"referenceID": 23, "context": "[54, 55, 30, 56, 37, 58].", "startOffset": 0, "endOffset": 24}, {"referenceID": 30, "context": "[54, 55, 30, 56, 37, 58].", "startOffset": 0, "endOffset": 24}, {"referenceID": 50, "context": "[54, 55, 30, 56, 37, 58].", "startOffset": 0, "endOffset": 24}, {"referenceID": 44, "context": "[51, 23].", "startOffset": 0, "endOffset": 8}, {"referenceID": 17, "context": "[51, 23].", "startOffset": 0, "endOffset": 8}, {"referenceID": 0, "context": "The recent work on syntax-guided synthesis (SyGuS) [1] is an attempt to capture these disparate efforts in a common theoretical formalism.", "startOffset": 51, "endOffset": 54}, {"referenceID": 3, "context": "The reader is referred to Angluin\u2019s excellent papers on the topic for more background [4, 5].", "startOffset": 86, "endOffset": 92}, {"referenceID": 4, "context": "The reader is referred to Angluin\u2019s excellent papers on the topic for more background [4, 5].", "startOffset": 86, "endOffset": 92}, {"referenceID": 22, "context": "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].", "startOffset": 61, "endOffset": 76}, {"referenceID": 55, "context": "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].", "startOffset": 61, "endOffset": 76}, {"referenceID": 9, "context": "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].", "startOffset": 61, "endOffset": 76}, {"referenceID": 1, "context": "Similar techniques have been studied elsewhere in literature [29, 63, 11, 2].", "startOffset": 61, "endOffset": 76}, {"referenceID": 32, "context": "[39].", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "A detailed survey is presented in [27] and [38].", "startOffset": 34, "endOffset": 38}, {"referenceID": 31, "context": "A detailed survey is presented in [27] and [38].", "startOffset": 43, "endOffset": 47}, {"referenceID": 33, "context": "Lange and Zilles [40] relate Angluin-style query-based learning with Gold-style learning.", "startOffset": 17, "endOffset": 21}, {"referenceID": 15, "context": "This part of our work is related to previous work on the complexity of teaching in exact learning of concepts by Goldman and Kearns [20].", "startOffset": 132, "endOffset": 136}, {"referenceID": 15, "context": "Exact bounds on teaching dimensions for specific concept classes such as orthogonal rectangles, monotonic decision trees, monomials, binary relations and total orders have been previously presented in literature [20, 21].", "startOffset": 212, "endOffset": 220}, {"referenceID": 16, "context": "Exact bounds on teaching dimensions for specific concept classes such as orthogonal rectangles, monotonic decision trees, monomials, binary relations and total orders have been previously presented in literature [20, 21].", "startOffset": 212, "endOffset": 220}, {"referenceID": 46, "context": "[53] also introduced a notion of teachability in which a concept class is teachable by examples if there exists a polynomial size sample under which all consistent learners will exactly identify the target concept.", "startOffset": 0, "endOffset": 4}, {"referenceID": 43, "context": "[50] also consider a model of learning with a helpful teacher.", "startOffset": 0, "endOffset": 4}, {"referenceID": 42, "context": "Languages and Programs: We also use standard definitions from computability theory which relate languages and programs [49].", "startOffset": 119, "endOffset": 123}, {"referenceID": 48, "context": "Intuitively, a function TEMPLATE defines an encoding of the space of candidate programs similar to encodings proposed in the literature such as those on program sketching [55] and component interconnection encoding [30].", "startOffset": 171, "endOffset": 175}, {"referenceID": 23, "context": "Intuitively, a function TEMPLATE defines an encoding of the space of candidate programs similar to encodings proposed in the literature such as those on program sketching [55] and component interconnection encoding [30].", "startOffset": 215, "endOffset": 219}, {"referenceID": 28, "context": "[35]) where more behaviors can be sampled over time.", "startOffset": 0, "endOffset": 4}, {"referenceID": 48, "context": "1CEGIS techniques in literature [55, 35] initiate search for correct program using positive examples and use specification to obtain positive examples corresponding to counterexamples.", "startOffset": 32, "endOffset": 40}, {"referenceID": 28, "context": "1CEGIS techniques in literature [55, 35] initiate search for correct program using positive examples and use specification to obtain positive examples corresponding to counterexamples.", "startOffset": 32, "endOffset": 40}, {"referenceID": 8, "context": "Bounded model-checking [10] returns a counterexample trace for an incorrect design if it can find a counterexample of length less than the specified constant bound.", "startOffset": 23, "endOffset": 27}, {"referenceID": 6, "context": "Verification of concurrent programs by bounding the number of context switches [7] is another example of the bounded verification technique.", "startOffset": 79, "endOffset": 82}, {"referenceID": 21, "context": "As we recover the positive examples, we run a Gold style algorithm for identifying finite languages [28] to converge to the correct language.", "startOffset": 100, "endOffset": 104}, {"referenceID": 48, "context": "The counterexample guided inductive synthesis approach [55] for bitvector sketches and oracle guided inductive synthesis using distinguishing inputs [30] for programs composed of a finite library of components are examples of OGIS synthesis techniques applied to finite language classes.", "startOffset": 55, "endOffset": 59}, {"referenceID": 23, "context": "The counterexample guided inductive synthesis approach [55] for bitvector sketches and oracle guided inductive synthesis using distinguishing inputs [30] for programs composed of a finite library of components are examples of OGIS synthesis techniques applied to finite language classes.", "startOffset": 149, "endOffset": 153}, {"referenceID": 15, "context": "We analyze the complexity of synthesis for finite language classes and discuss its relation to the notion of teaching dimension from the concept learning literature [20].", "startOffset": 165, "endOffset": 169}, {"referenceID": 23, "context": "This connection between synthesis of languages from finite classes and teaching of concepts was first discussed in [30].", "startOffset": 115, "endOffset": 119}, {"referenceID": 15, "context": "[20, 21] proposed teaching dimension as a measure to study computational complexity of learning.", "startOffset": 0, "endOffset": 8}, {"referenceID": 16, "context": "[20, 21] proposed teaching dimension as a measure to study computational complexity of learning.", "startOffset": 0, "endOffset": 8}, {"referenceID": 15, "context": "[20, 21], the basic goal of the teacher is to help the learner identify the target concept c\u2217 \u2208 C by providing an example sequence from E.", "startOffset": 0, "endOffset": 8}, {"referenceID": 16, "context": "[20, 21], the basic goal of the teacher is to help the learner identify the target concept c\u2217 \u2208 C by providing an example sequence from E.", "startOffset": 0, "endOffset": 8}, {"referenceID": 15, "context": "1 (adapted from [20]) An example sequence is a sequence of labeled examples from E, where the labels are given by some underlying specification.", "startOffset": 16, "endOffset": 20}, {"referenceID": 52, "context": "One of these results relates the teaching dimension to a second metric for measuring complexity of learning, namely the Vapnik-Chervonenkis (VC) dimension [60].", "startOffset": 155, "endOffset": 159}, {"referenceID": 52, "context": "2 [60] Let E be the domain of examples and c be a concept from the class C .", "startOffset": 2, "endOffset": 6}, {"referenceID": 10, "context": "[12] have shown that the VC dimension of a concept class characterizes the number of examples required for learning any concept in the class under the distribution-free or probably approximately correct (PAC) model of Valiant [59].", "startOffset": 0, "endOffset": 4}, {"referenceID": 51, "context": "[12] have shown that the VC dimension of a concept class characterizes the number of examples required for learning any concept in the class under the distribution-free or probably approximately correct (PAC) model of Valiant [59].", "startOffset": 226, "endOffset": 230}, {"referenceID": 15, "context": "Vapnik-Chervonenkis dimension are discussed at length by Goldman and Kearns [20].", "startOffset": 76, "endOffset": 80}, {"referenceID": 15, "context": "The following theorems from [20] provides lower and upper bound on the teaching dimension of a finite concept class in terms of the size of the concept class and its VC-dimension.", "startOffset": 28, "endOffset": 32}, {"referenceID": 15, "context": "3 [20] The teaching dimension T D(C ) of any concept class C satisfies the following upper and lower bounds: VC(C )/ log(|C |)\u2264 T D(C )\u2264 |C |\u22121", "startOffset": 2, "endOffset": 6}, {"referenceID": 15, "context": "Moreover, Goldman and Kearns [20] exhibit a concept class for which the upper bound is tight.", "startOffset": 29, "endOffset": 33}, {"referenceID": 56, "context": "But teaching dimension of formal concept classes such as programs in the while [64] language with only linear arithmetic over integers is not known.", "startOffset": 79, "endOffset": 83}], "year": 2016, "abstractText": "Formal synthesis is the process of generating a program satisfying a high-level formal specification. In recent times, effective formal synthesis methods have been proposed based on the use of inductive learning. We refer to this class of methods that learn programs from examples as formal inductive synthesis. In this paper, we present a theoretical framework for formal inductive synthesis. We discuss how formal inductive synthesis differs from traditional machine learning. We then describe oracle-guided inductive synthesis (OGIS), a framework that captures a family of synthesizers that operate by iteratively querying an oracle. An instance of OGIS that has had much practical impact is counterexample-guided inductive synthesis (CEGIS). We present a theoretical characterization of CEGIS for learning any program that computes a recursive language. In particular, we analyze the relative power of CEGIS variants where the types of counterexamples generated by the oracle varies. We also consider the impact of bounded versus unbounded memory available to the learning algorithm. In the special case where the universe of candidate programs is finite, we relate the speed of convergence to the notion of teaching dimension studied in machine learning theory. Altogether, the results of the paper take a first step towards a theoretical foundation for the emerging field of formal inductive synthesis.", "creator": "LaTeX with hyperref package"}}}