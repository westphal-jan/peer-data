{"id": "1505.05365", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2015", "title": "Towards Ideal Semantics for Analyzing Stream Reasoning", "abstract": "The rise of smart applications has drawn interest to logical reasoning over data streams. Recently, different query languages and stream processing/reasoning engines were proposed in different communities. However, due to a lack of theoretical foundations, the expressivity and semantics of these diverse approaches are given only informally. Towards clear specifications and means for analytic study, a formal framework is needed to define their semantics in precise terms. To this end, we present a first step towards an ideal semantics that allows for exact descriptions and comparisons of stream reasoning systems.", "histories": [["v1", "Wed, 20 May 2015 13:27:23 GMT  (109kb,D)", "http://arxiv.org/abs/1505.05365v1", "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 17-22, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL2014,1"]], "COMMENTS": "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 17-22, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL2014,1", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["harald beck", "minh dao-tran", "thomas eiter", "michael fink"], "accepted": false, "id": "1505.05365"}, "pdf": {"name": "1505.05365.pdf", "metadata": {"source": "CRF", "title": "Towards Ideal Semantics for Analyzing Stream Reasoning", "authors": ["Harald Beck", "Michael Fink"], "emails": ["beck@kr.tuwien.ac.at", "dao@kr.tuwien.ac.at", "eiter@kr.tuwien.ac.at", "fink@kr.tuwien.ac.at"], "sections": [{"heading": "1 Introduction", "text": "This year it is more than ever before."}, {"heading": "2 Streams", "text": "In this section, we introduce a logic-oriented view of streams and define formally generalized versions of prominent window functions."}, {"heading": "2.1 Streaming Data", "text": "A current is usually considered as a sequence, set or bag of tuples with a time stamp. Here, we consider currents as functions from a discrete time domain to groups of logical atoms and do not assume a fixed scheme for tuples. We build on mutually disjunct groups of predicates P, constants C, variables V and time variables U. The set of terms is given by C \u00b2 V and the set A of atoms is defined as {p (t1,., tn). If i, j \u00b2 P, t1,., tn \u00b2 T}. The set G of soil atoms contains all atoms p (t1,.., tn) A like {t1,."}, {"heading": "2.2 Windows", "text": "An essential aspect of the argument in the stream is the limitation of the viewed data to so-called windows, i.e., current partial streams in order to limit the amount of data and forget obsolete information.Definition 2 (Window function) A window function boards from a stream S = (T) and a time t to a window S. \"The usual time-based window of size\" [3] contains only the tuples of the last \"units of time. We give a generalized definition in which the window can also include the tuples of the future u-points of time. Based on the query time t and a step size d, we deduce a pivot point of size t\" from which an interval [t, \"tu] is selected by looking backwards (resp.).\" (resp.) units of time from t, \"i.e., t\" +. \""}, {"heading": "3 Reasoning over Streams", "text": "We will now use the above definitions of flows and windows to formalize a semantics for the argumentation of flows."}, {"heading": "3.1 Stream Semantics", "text": "Similar to modal logic, we will use operators 2 and 3 to test whether a tuple (atom) or formula holds all the time, or at some point in a window. In addition, we will use an exact operator @ to refer to specific points in time. To get a window of the current, we will use window operators within the meaning of definition 6 (formulas Fk) The defined Fk of the formulas (for k modalities) is defined by the grammar: = an exact operator @ to refer to specific points in time."}, {"heading": "4 Discussion and Related Work", "text": "In this section, we will discuss the relationship of this ongoing work with existing approaches from different communities. Modal logic is similarly fixed on operators. (The formalism presented deals with operators 3 and 2 as in modal logic. [6] The definition of Entailment also uses a structure similar to Kripke for multimodal logic. [7] Instead of static access relationships, we use window functions that take into account not only the worlds (i.e. the points in time), but also the interpretation function. To the best of our knowledge, window operators have not been taken into account in either modal logic or temporal logic. CQL expands SQL to deal with input streams, CQL queries are evaluated using three sets of operators. (i) Stream-to-relation operators apply window functions to the input stream to assign execution times to pockets valid tuples (w.r.t. the window) without time sensing."}, {"heading": "5 Conclusion", "text": "We have presented a first step towards a theoretical basis for the (idealistic) semantics of formalisms for the argumentation of flows. Analytical tools for the characterization, investigation and comparison of logical aspects of flow machines are missing. To close this gap, we provide a framework for the argumentation of flow data with a fine-grained control of how the truth of tuples is related to their temporal occurrence. For example, different types of window applications can be captured on data streams. We discussed the relationship of the proposed formalism to existing approaches, namely CQL, SECRET, reactive ASP, StreamLog and ETALIS. The next steps include extensions of the framework for the formal capture of fragments of existing approaches. In the direction of more advanced argumentation features such as recursion and non-monotonicity, we strive for rule-based semantics based on the presented core. Furthermore, considering time intervals as an analysis could be an interesting research question for a longer period of time."}], "references": [{"title": "Stream reasoning and complex event processing in ETALIS", "author": ["Darko Anicic", "Sebastian Rudolph", "Paul Fodor", "Nenad Stojanovic"], "venue": "Semantic Web Journal,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2012}, {"title": "Stream: The stanford stream data manager", "author": ["Arvind Arasu", "Brian Babcock", "Shivnath Babu", "Mayur Datar", "Keith Ito", "Itaru Nishizawa", "Justin Rosenstein", "Jennifer Widom"], "venue": "in SIGMOD Conference,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2003}, {"title": "The CQL continuous query language: semantic foundations and query execution", "author": ["Arvind Arasu", "Shivnath Babu", "Jennifer Widom"], "venue": "VLDB J.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "Continuous queries over data streams", "author": ["Shivnath Babu", "Jennifer Widom"], "venue": "SIGMOD Record,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "C-SPARQL: a continuous query language for rdf data streams", "author": ["Davide Francesco Barbieri", "Daniele Braga", "Stefano Ceri", "Emanuele Della Valle", "Michael Grossniklaus"], "venue": "Int. J. Semantic Computing,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2010}, {"title": "Towards reactive multi-context systems", "author": ["Gerhard Brewka"], "venue": "in LPNMR, pp", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "Modeling the execution semantics of stream processing engines with secret", "author": ["Nihal Dindar", "Nesime Tatbul", "Ren\u00e9e J. Miller", "Laura M. Haas", "Irina Botan"], "venue": "VLDB J.,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Answer set programming for stream reasoning", "author": ["Thang M. Do", "Seng Wai Loke", "Fei Liu"], "venue": "in AI, pp", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "dlvhex: A prover for semantic-web reasoning under the answer-set semantics", "author": ["Thomas Eiter", "Giovambattista Ianni", "Roman Schindlauer", "Hans Tompits"], "venue": "in Web Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "Stream reasoning with answer set programming", "author": ["Martin Gebser", "Torsten Grote", "Roland Kaminski", "Philipp Obermeier", "Orkunt Sabuncu", "Torsten Schaub"], "venue": "in KR,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Reactive answer set programming", "author": ["Martin Gebser", "Torsten Grote", "Roland Kaminski", "Torsten Schaub"], "venue": "in LPNMR, pp", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Engineering an incremental asp solver", "author": ["Martin Gebser", "Roland Kaminski", "Benjamin Kaufmann", "Max Ostrowski", "Torsten Schaub", "Sven Thiele"], "venue": "in ICLP,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Linked stream data processing engines: Facts and figures", "author": ["Danh Le Phuoc", "Minh Dao-Tran", "Minh-Duc Pham", "Peter Boncz", "Thomas Eiter", "Michael Fink"], "venue": "ISWC - ET,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "It\u2019s a streaming world! reasoning upon rapidly changing information", "author": ["Emanuele Della Valle", "Stefano Ceri", "Frank van Harmelen", "Dieter Fensel"], "venue": "IEEE Intelligent Systems,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Logical foundations of continuous query languages for data streams", "author": ["Carlo Zaniolo"], "venue": "in Datalog,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}], "referenceMentions": [{"referenceID": 3, "context": "In the setting of stream processing [4] studied by the database community, input tuples dynamically arrive at the processing systems in form of possibly infinite streams.", "startOffset": 36, "endOffset": 39}, {"referenceID": 2, "context": "The Continuous Query Language (CQL) [3] is a well-known stream processing language.", "startOffset": 36, "endOffset": 39}, {"referenceID": 13, "context": ", has raised interest in the topic of stream reasoning [16], i.", "startOffset": 55, "endOffset": 59}, {"referenceID": 4, "context": "Engines such as CQELS [14] and C-SPARQL [5] also follow the snapshot semantics approach of CQL.", "startOffset": 40, "endOffset": 43}, {"referenceID": 7, "context": "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].", "startOffset": 190, "endOffset": 197}, {"referenceID": 9, "context": "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].", "startOffset": 190, "endOffset": 197}, {"referenceID": 14, "context": "(ii) In Knowledge Representation and Reasoning (KRR), first attempts towards expressive stream reasoning have been carried out by considering continuous data in Answer Set Programming (ASP) [9, 11] or extending Datalog to sequential logic programs [17].", "startOffset": 248, "endOffset": 252}, {"referenceID": 7, "context": "The plain approach of [9] periodically calls the dlvhex solver [10] but is not capable of incremental reasoning and thus fails under heavy load of data.", "startOffset": 22, "endOffset": 25}, {"referenceID": 8, "context": "The plain approach of [9] periodically calls the dlvhex solver [10] but is not capable of incremental reasoning and thus fails under heavy load of data.", "startOffset": 63, "endOffset": 67}, {"referenceID": 14, "context": "StreamLog [17] is an extension of Datalog towards stream reasoning.", "startOffset": 10, "endOffset": 14}, {"referenceID": 9, "context": "Time-decaying logic programs [11] attempt to implement time-based windows in reactive ASP [13] but the relation to other stream processing/reasoning approaches has not yet been explored.", "startOffset": 29, "endOffset": 33}, {"referenceID": 11, "context": "Time-decaying logic programs [11] attempt to implement time-based windows in reactive ASP [13] but the relation to other stream processing/reasoning approaches has not yet been explored.", "startOffset": 90, "endOffset": 94}, {"referenceID": 6, "context": "Moreover, as observed in [8], conceptually identical queries may produce different results in different engines.", "startOffset": 25, "endOffset": 28}, {"referenceID": 12, "context": "Investigations of specific languages, as well as comparisons between different approaches, are confined to experimental analysis [15], or informal examination on specific examples.", "startOffset": 129, "endOffset": 133}, {"referenceID": 11, "context": "Example 2 (cont\u2019d) The input for the scenario in Example 1 can be modeled as a stream S = (T, \u03c5) where T = [0, 13] and", "startOffset": 107, "endOffset": 114}, {"referenceID": 2, "context": "The usual time-based window of size ` [3] contains only the tuples of the last ` time units.", "startOffset": 38, "endOffset": 41}, {"referenceID": 2, "context": "The CQL [3] syntax for w d is [Range l Slide d] and w ` corresponds to [Range l].", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "w(S, 5) = ([0, 5], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w(S, 11) = ([6, 11], {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}).", "startOffset": 11, "endOffset": 17}, {"referenceID": 9, "context": "w(S, 5) = ([0, 5], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w(S, 11) = ([6, 11], {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}).", "startOffset": 68, "endOffset": 75}, {"referenceID": 0, "context": "For t1 = 5, we have t1 = b 53c \u00b7 3 = 3, thus T \u2032 1 = [max{0, 3\u2212 2},min{3 + 1, 13}] = [1, 4].", "startOffset": 85, "endOffset": 91}, {"referenceID": 3, "context": "For t1 = 5, we have t1 = b 53c \u00b7 3 = 3, thus T \u2032 1 = [max{0, 3\u2212 2},min{3 + 1, 13}] = [1, 4].", "startOffset": 85, "endOffset": 91}, {"referenceID": 5, "context": "For t2 = 11, we get t2 = 9 and T \u2032 2 = [7, 10].", "startOffset": 39, "endOffset": 46}, {"referenceID": 8, "context": "For t2 = 11, we get t2 = 9 and T \u2032 2 = [7, 10].", "startOffset": 39, "endOffset": 46}, {"referenceID": 0, "context": "w 3 (S, 5) = ([1, 4], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7\u2192 {tr(d, p2))}}).", "startOffset": 14, "endOffset": 20}, {"referenceID": 3, "context": "w 3 (S, 5) = ([1, 4], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7\u2192 {tr(d, p2))}}).", "startOffset": 14, "endOffset": 20}, {"referenceID": 5, "context": "w 3 (S, 5) = ([1, 4], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7\u2192 {tr(d, p2))}}).", "startOffset": 74, "endOffset": 81}, {"referenceID": 8, "context": "w 3 (S, 5) = ([1, 4], {2 7\u2192 {tr(a, p1), bus(c, p1)}}), and w 3 (S, 11) = ([7, 10], {8 7\u2192 {tr(d, p2))}}).", "startOffset": 74, "endOffset": 81}, {"referenceID": 1, "context": "The application w(S, 11) can lead to two possible windows (T \u2032, \u03c5\u2032 1) and (T \u2032, \u03c5\u2032 2), where T \u2032 = [2, 11], and", "startOffset": 99, "endOffset": 106}, {"referenceID": 9, "context": "The application w(S, 11) can lead to two possible windows (T \u2032, \u03c5\u2032 1) and (T \u2032, \u03c5\u2032 2), where T \u2032 = [2, 11], and", "startOffset": 99, "endOffset": 106}, {"referenceID": 1, "context": "S1 = ([2, 13], {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}), and S2 = ([2, 13], {2 7\u2192 {bus(c, p1)}, 11 7\u2192 {bus(e, p2)}}),", "startOffset": 6, "endOffset": 13}, {"referenceID": 11, "context": "S1 = ([2, 13], {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}), and S2 = ([2, 13], {2 7\u2192 {bus(c, p1)}, 11 7\u2192 {bus(e, p2)}}),", "startOffset": 6, "endOffset": 13}, {"referenceID": 1, "context": "S1 = ([2, 13], {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}), and S2 = ([2, 13], {2 7\u2192 {bus(c, p1)}, 11 7\u2192 {bus(e, p2)}}),", "startOffset": 64, "endOffset": 71}, {"referenceID": 11, "context": "S1 = ([2, 13], {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}), and S2 = ([2, 13], {2 7\u2192 {bus(c, p1)}, 11 7\u2192 {bus(e, p2)}}),", "startOffset": 64, "endOffset": 71}, {"referenceID": 1, "context": "w(S1, 13) = ([2, 13], {2 7\u2192{tr(a, p1)}, 8 7\u2192{tr(d, p2)}}), and w(S2, 13) = ([13, 13], \u2205).", "startOffset": 13, "endOffset": 20}, {"referenceID": 11, "context": "w(S1, 13) = ([2, 13], {2 7\u2192{tr(a, p1)}, 8 7\u2192{tr(d, p2)}}), and w(S2, 13) = ([13, 13], \u2205).", "startOffset": 13, "endOffset": 20}, {"referenceID": 11, "context": "w(S1, 13) = ([2, 13], {2 7\u2192{tr(a, p1)}, 8 7\u2192{tr(d, p2)}}), and w(S2, 13) = ([13, 13], \u2205).", "startOffset": 76, "endOffset": 84}, {"referenceID": 11, "context": "w(S1, 13) = ([2, 13], {2 7\u2192{tr(a, p1)}, 8 7\u2192{tr(d, p2)}}), and w(S2, 13) = ([13, 13], \u2205).", "startOffset": 76, "endOffset": 84}, {"referenceID": 1, "context": "Consequently, we get w idx (S, 13) = ([2, 13], \u03c5 \u2032), where \u03c5\u2032 is", "startOffset": 38, "endOffset": 45}, {"referenceID": 11, "context": "Consequently, we get w idx (S, 13) = ([2, 13], \u03c5 \u2032), where \u03c5\u2032 is", "startOffset": 38, "endOffset": 45}, {"referenceID": 9, "context": "First, the window operator 1 selects the substream S\u2032 = (TS\u2032 , \u03c5\u2032), where TS\u2032 = [6, 11] and \u03c5\u2032 = \u03c5|T \u2032 = {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}.", "startOffset": 80, "endOffset": 87}, {"referenceID": 1, "context": "The query q = 13(tr(a, p1) \u2227 bus(c, p1))[t] is ground iff t \u2208 N and ?q = yes iff t \u2208 [2, 7].", "startOffset": 85, "endOffset": 91}, {"referenceID": 5, "context": "The query q = 13(tr(a, p1) \u2227 bus(c, p1))[t] is ground iff t \u2208 N and ?q = yes iff t \u2208 [2, 7].", "startOffset": 85, "endOffset": 91}, {"referenceID": 1, "context": "M,SM , t 1(3tr(a, p1) \u22273bus(c, p1)) for all t \u2208 [2, 7] M,SM , t 1(3tr(d, p2) \u22273bus(e, p2)) for all t \u2208 [11, 13]", "startOffset": 48, "endOffset": 54}, {"referenceID": 5, "context": "M,SM , t 1(3tr(a, p1) \u22273bus(c, p1)) for all t \u2208 [2, 7] M,SM , t 1(3tr(d, p2) \u22273bus(e, p2)) for all t \u2208 [11, 13]", "startOffset": 48, "endOffset": 54}, {"referenceID": 9, "context": "M,SM , t 1(3tr(a, p1) \u22273bus(c, p1)) for all t \u2208 [2, 7] M,SM , t 1(3tr(d, p2) \u22273bus(e, p2)) for all t \u2208 [11, 13]", "startOffset": 103, "endOffset": 111}, {"referenceID": 11, "context": "M,SM , t 1(3tr(a, p1) \u22273bus(c, p1)) for all t \u2208 [2, 7] M,SM , t 1(3tr(d, p2) \u22273bus(e, p2)) for all t \u2208 [11, 13]", "startOffset": 103, "endOffset": 111}, {"referenceID": 1, "context": "?q1 = {({X 7\u2192a, Y 7\u2192c, P 7\u2192p1}, {u 7\u2192 t}) | t \u2208 [2, 7]}\u222a {({X 7\u2192d, Y 7\u2192e, P 7\u2192p2}, {u 7\u2192 t}) | t \u2208 [11, 13]}", "startOffset": 48, "endOffset": 54}, {"referenceID": 5, "context": "?q1 = {({X 7\u2192a, Y 7\u2192c, P 7\u2192p1}, {u 7\u2192 t}) | t \u2208 [2, 7]}\u222a {({X 7\u2192d, Y 7\u2192e, P 7\u2192p2}, {u 7\u2192 t}) | t \u2208 [11, 13]}", "startOffset": 48, "endOffset": 54}, {"referenceID": 9, "context": "?q1 = {({X 7\u2192a, Y 7\u2192c, P 7\u2192p1}, {u 7\u2192 t}) | t \u2208 [2, 7]}\u222a {({X 7\u2192d, Y 7\u2192e, P 7\u2192p2}, {u 7\u2192 t}) | t \u2208 [11, 13]}", "startOffset": 99, "endOffset": 107}, {"referenceID": 11, "context": "?q1 = {({X 7\u2192a, Y 7\u2192c, P 7\u2192p1}, {u 7\u2192 t}) | t \u2208 [2, 7]}\u222a {({X 7\u2192d, Y 7\u2192e, P 7\u2192p2}, {u 7\u2192 t}) | t \u2208 [11, 13]}", "startOffset": 99, "endOffset": 107}, {"referenceID": 11, "context": "For each of the queries @U\u03b1[13] and \u03b1[U ], the time assignments for U in the answers will map to time points when a tram and a bus arrived simultaneously at the same stop.", "startOffset": 27, "endOffset": 31}, {"referenceID": 11, "context": "q3 = 12(tr(X,P )\u2192 23bus(Y, P ))[13].", "startOffset": 31, "endOffset": 35}, {"referenceID": 1, "context": "Applying \u0174(1) on the stream S = (T, \u03c5) in the previous examples yields S\u2032 = (T \u2032, \u03c5\u2032), where T \u2032 = [2, 13] and \u03c5\u2032 = {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}.", "startOffset": 99, "endOffset": 106}, {"referenceID": 11, "context": "Applying \u0174(1) on the stream S = (T, \u03c5) in the previous examples yields S\u2032 = (T \u2032, \u03c5\u2032), where T \u2032 = [2, 13] and \u03c5\u2032 = {2 7\u2192 {tr(a, p1)}, 8 7\u2192 {tr(d, p2)}}.", "startOffset": 99, "endOffset": 106}, {"referenceID": 1, "context": "T \u2032\u2032 2 = [2, 5], \u03c5 \u2032\u2032 2 = {2 7\u2192 {tr(a, p1), bus(c, p1)}}, and T \u2032\u2032 8 = [8, 11], \u03c5 \u2032\u2032 8 = {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}.", "startOffset": 9, "endOffset": 15}, {"referenceID": 4, "context": "T \u2032\u2032 2 = [2, 5], \u03c5 \u2032\u2032 2 = {2 7\u2192 {tr(a, p1), bus(c, p1)}}, and T \u2032\u2032 8 = [8, 11], \u03c5 \u2032\u2032 8 = {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}.", "startOffset": 9, "endOffset": 15}, {"referenceID": 6, "context": "T \u2032\u2032 2 = [2, 5], \u03c5 \u2032\u2032 2 = {2 7\u2192 {tr(a, p1), bus(c, p1)}}, and T \u2032\u2032 8 = [8, 11], \u03c5 \u2032\u2032 8 = {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}.", "startOffset": 71, "endOffset": 78}, {"referenceID": 9, "context": "T \u2032\u2032 2 = [2, 5], \u03c5 \u2032\u2032 2 = {2 7\u2192 {tr(a, p1), bus(c, p1)}}, and T \u2032\u2032 8 = [8, 11], \u03c5 \u2032\u2032 8 = {8 7\u2192 {tr(d, p2)}, 11 7\u2192 {bus(e, p2)}}.", "startOffset": 71, "endOffset": 78}, {"referenceID": 1, "context": "With according rewriting, CQL eingines like STREAM [2] could be used to realize the proposed semantics.", "startOffset": 51, "endOffset": 54}, {"referenceID": 6, "context": "In [8] a model called SECRET is proposed to analyze the execution behavior of different stream processing engines (SPEs) from a practical point of view.", "startOffset": 3, "endOffset": 6}, {"referenceID": 9, "context": "The most recent work related to expressive stream reasoning with rules [11] is based on Reactive ASP [12].", "startOffset": 71, "endOffset": 75}, {"referenceID": 10, "context": "The most recent work related to expressive stream reasoning with rules [11] is based on Reactive ASP [12].", "startOffset": 101, "endOffset": 105}, {"referenceID": 14, "context": "Another logic-based approach towards stream reasoning is StreamLog [17].", "startOffset": 67, "endOffset": 71}, {"referenceID": 0, "context": "The ETALIS system [1] aims at adding expressiveness to Complex Event Processing (CEP).", "startOffset": 18, "endOffset": 21}, {"referenceID": 5, "context": "In a longer perspective, along the same lines with [7], we aim at a formalism for stream reasoning in distributed settings across heterogeneous nodes having potentially different logical capabilities.", "startOffset": 51, "endOffset": 54}], "year": 2015, "abstractText": "The rise of smart applications has drawn interest to logical reasoning over data streams. Recently, different query languages and stream processing/reasoning engines were proposed in different communities. However, due to a lack of theoretical foundations, the expressivity and semantics of these diverse approaches are given only informally. Towards clear specifications and means for analytic study, a formal framework is needed to define their semantics in precise terms. To this end, we present a first step towards an ideal semantics that allows for exact descriptions and comparisons of stream reasoning systems.", "creator": "LaTeX with hyperref package"}}}