{"id": "1505.07263", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-May-2015", "title": "Qsmodels: ASP Planning in Interactive Gaming Environment", "abstract": "Qsmodels is a novel application of Answer Set Programming to interactive gaming environment. We describe a software architecture by which the behavior of a bot acting inside the Quake 3 Arena can be controlled by a planner. The planner is written as an Answer Set Program and is interpreted by the Smodels solver.", "histories": [["v1", "Wed, 27 May 2015 10:58:03 GMT  (196kb)", "http://arxiv.org/abs/1505.07263v1", "Proceedings of Logics in Artificial Intelligence, 9th European Conference, {JELIA} 2004, pp. 689-692. Lisbon, Portugal, September 27-30, 2004"]], "COMMENTS": "Proceedings of Logics in Artificial Intelligence, 9th European Conference, {JELIA} 2004, pp. 689-692. Lisbon, Portugal, September 27-30, 2004", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["luca padovani", "alessandro provetti"], "accepted": false, "id": "1505.07263"}, "pdf": {"name": "1505.07263.pdf", "metadata": {"source": "CRF", "title": "Qsmodels: ASP Planning in Interactive Gaming Environment\u22c6", "authors": ["Luca Padovani", "Alessandro Provetti"], "emails": ["luca@mag.dsi.unimi.it.", "ale@unime.it"], "sections": [{"heading": null, "text": "ar Xiv: 150 5.07 263v 1 [cs.A I] 2 7M ayThis article describes the Qmodels project, which is the result of a graduate project [3] currently in the development stage. The goal of this project is twofold: First, we want to demonstrate the feasibility of using Answer Set Programming [1] (ASP) in an interactive environment.The chosen environment is id Software's Quake 3 Arena (Q3A) game; most of the source codes have recently been released to the public. Q3A is a first-person shooter: The goal of the player is to kill enemies with weapons and upgrades within the playing field (usually a labyrinth).The human-like enemies found within Q3A are called BOTs. As in most computer games, Q3A bots behave the rules of a finite state machine (FSM), which is defined by expert game programs to experiment with, the second goal is to create a high-level architecture and the agent."}, {"heading": "Select Goal\u2013Plan\u2013Execute.", "text": "The Qmodels architecture consists of two layers: a high level, responsible for medium- and long-term planning, and a (low) level, responsible for the execution of plans and emergency responses. The high level was developed mainly in ASP on the Smodels platform. That is, Smodels calculates the response sets of a logic program that characterizes all successful plans of a certain length, following the more or less standard encryption found in [1]. The calculated response set is passed on to the low level that checks it, extracts relevant syntactical information and executes the necessary measures. The high level layer of our project implements a Q3A agent that begins with knowledge of the playing field, which resembles an interpersonal player, trying to beat his opponents by confronting them only in a better state for the attack. To achieve this result, we have added a very simple learning system to the planner that tracks the opponent's behavior in order to better guess future movements."}, {"heading": "Methodology", "text": "Our implementation required a lot of work and experimentation to link the existing software components, Q3A and Smodels. Developing the agent required extensive knowledge of the internal Q3A functions, most of which are undocumented. Smodels, on the other hand, was used as an external process triggered by system calls. We plan to move to an API interface soon. The two levels of Q3A work are executed simultaneously: While the lower level takes over planning, the lower level is responsible for executing the plan and reacting in emergency situations. Events are considered unpredictable when they occur, which makes the status of the domain incompatible with the assumptions made during the planning phase. It should be noted that the lower level inherits some powerful functionality from Q3A, such as combat and shooting actions, which are considered atomic from the upper level. To make our agents act realistically in their range, we set the frequency to ten times per second."}, {"heading": "Execution Cycle", "text": "The execution cycle of our application is illustrated in Figure 2. The first step is scanning where we access Q3A memory and look for information, such as the agent state (position, health level..) and the availability of bonuses (health and ammunition tokens). Then, we check if an emergency occurs, e.g. the agent is under attack, or he / she faces the enemy, or he / she stands behind the enemy, etc. If one of these situations holds, we execute the preventive rules to find those that apply to the current emergency and condition. If no preventive rule applies, the execution cycle is resumed. After scanning, if no emergency is detected, we check if a plan is currently available; if not, we ask for a new one. Thus, we first translate the Q3A memory states in flow, which are added as facts to the planner himself. Finally, we hand over the interface to the external modeling program, which is responsible for the logic component."}, {"heading": "The use of pre-emption rules", "text": "In this sense, the introduction of the so-called preemption rules was probably the most important step in the realization of credible Q3A bots. Preemptive rules allow the description of a high-level response system, in which we determine the reaction behavior of the agent and let smokers calculate the actual reaction rules associated with the current plan. For each emergency situation considered and each timeframe of the prepared plan, we get an appropriate response rule. If an emergency occurs, our modification to Q3A searches through the rules for the corresponding rule (time and event) and executes the action within the regulatory body. As a result, preemption rules dictate behavior that is somewhat similar to that of an FSM. In our case, however, the response is integrated into the planner and evaluated by the same inference engine. Therefore, we couple a time-consuming planning system for longer-term responses to a more efficient response system."}, {"heading": "Application Experience", "text": "Our test platform consists of a series of standard Q3A game levels in which our agent engages in a duel with a human player. We require that the game server (in our case, an Intel P4 2.0 GHz) runs on a separate computer than the human player's, due to the high computing power required by smokers. Depending on the length of the plan, the planning extraction phase can take up to 6 / 7 seconds. This delay is almost transparent to the human opponent, as our agent tries to hide during the planning process. If the agent then encounters the enemy, the preventive rules, together with the low-threshold AI, will make him act quickly and generally avoid confrontation. In Qsmodel's plans, the final action is always an attack, as the overarching goal is to kill the enemy. However, the last action is rarely executed, as in emergencies the prevention rules take control of the bot and cancel the remaining part of the plan."}], "references": [{"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "Representing Actions: Laws, Observations and Hypotheses", "author": ["C. Baral M. Gelfond", "A. Provetti"], "venue": "Journal of Logic Programming,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1997}, {"title": "Answer Set Programming in Interactive Gaming Environment. Graduation project in Informatics (in Italian). University of Milan", "author": ["L. Padovani"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2004}], "referenceMentions": [{"referenceID": 2, "context": "This article describes the Qsmodels project, which grew out of a graduation project [3] is currently under development.", "startOffset": 84, "endOffset": 87}, {"referenceID": 0, "context": "First, we want to demonstrate the viability of using Answer Set Programming [1] (ASP) in an interactive environment.", "startOffset": 76, "endOffset": 79}, {"referenceID": 1, "context": "The second objective is to implement and experiment with the high-level agent architecture described by Baral, Gelfond and Provetti [2].", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": ", smodels computes the answer sets of a logic program which characterizes all successful plans of a given length, following the more or less standard encoding found in [1].", "startOffset": 168, "endOffset": 171}], "year": 2015, "abstractText": "Qsmodels is a novel application of Answer Set Programming to interactive gaming environment. We describe a software architecture by which the behavior of a bot acting inside the Quake 3 Arena can be controlled by a planner. The planner is written as an Answer Set Program and is interpreted by the Smodels solver. This article describes the Qsmodels project, which grew out of a graduation project [3] is currently under development. The aim of this project is twofold. First, we want to demonstrate the viability of using Answer Set Programming [1] (ASP) in an interactive environment. The chosen environment is the Quake 3 Arena (Q3A) game from id Software; recently most of the source codes have been released to the public. Q3A is a first person shooter : the player\u2019s goal is to kill enemies using weapons and upgrades found inside the game field (normally a labyrinth). The human-like enemies found within Q3A are called BOTs. Like in the most computer games, Q3A bots behave according to the rules of a finite-state automaton (FSM) defined by expert game programmers. The second objective is to implement and experiment with the high-level agent architecture described by Baral, Gelfond and Provetti [2]. Such schema consists in the following loop: Observe\u2013 Select Goal\u2013Plan\u2013Execute. The Qsmodels architecture consists of two layers: a high level, responsible for midand longterm planning, and a (low level) in charge of plan execution and emergency state reactions. The high level has been developed mainly in ASP on the Smodels platform. I.e., smodels computes the answer sets of a logic program which characterizes all successful plans of a given length, following the more or less standard encoding found in [1]. The computed answer set is passed to the low-level layer that inspects it, extracts relevant syntactic informations and executes the required actions. The high-level layer of our project realizes a Q3A agent which, starting with the knowledge about the game field similar to that of an intermediate-level human player, tries to beat his opponents by facing them only when in a better condition for the attack. To achieve this result, we have added to the planner a very simple learning system which keeps track of opponent\u2019s behavior in order to better guess future moves. Even though we are still in the experimental phase, we submit that our architecture has several advantages over the traditional schema for the AI part of games. Namely, our solution is \u22c6 Work supported by the Information Society Technologies programme of the European Commission, Future and Emerging Technologies under the IST-2001-37004 WASP project.", "creator": "LaTeX with hyperref package"}}}