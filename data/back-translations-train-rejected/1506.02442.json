{"id": "1506.02442", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2015", "title": "NP-hardness of sortedness constraints", "abstract": "In Constraint Programming, global constraints allow to model and solve many combinatorial problems. Among these constraints, several sortedness constraints have been defined, for which propagation algorithms are available, but for which the tractability is not settled. We show that the sort(U,V) constraint (Older et. al, 1995) is intractable for integer variables whose domains are not limited to intervals. As a consequence, the similar result holds for the sort(U,V, P) constraint (Zhou, 1996). Moreover, the intractability holds even under the stability condition present in the recently introduced keysorting(U,V,Keys,P) constraint (Carlsson et al., 2014), and requiring that the order of the variables with the same value in the list U be preserved in the list V. Therefore, keysorting(U,V,Keys,P) is intractable as well.", "histories": [["v1", "Mon, 8 Jun 2015 11:24:06 GMT  (38kb,D)", "http://arxiv.org/abs/1506.02442v1", "15 pages, 4 figures"]], "COMMENTS": "15 pages, 4 figures", "reviews": [], "SUBJECTS": "cs.CC cs.AI cs.DM", "authors": ["irena rusu"], "accepted": false, "id": "1506.02442"}, "pdf": {"name": "1506.02442.pdf", "metadata": {"source": "CRF", "title": "NP-hardness of sortedness constraints", "authors": ["Irena Rusu"], "emails": [], "sections": [{"heading": null, "text": "We show that the sort constraint (U, V, P) is insoluble for integer variables whose domains are not limited to intervals (assuming P 6 = NP). Consequently, the similar result also applies to the sort constraint (U, V, P) (Zhou, 1996). Furthermore, even under the stability condition that exists in the recently introduced key sort constraint (U, V, Keys, P) (Carlsson et al., 2014), the insoluble constraint requires that the order of variables with the same value in the U list be maintained in list V. Thus, the key order (U, V, Keys, P) is insoluble. Keywords: sort constraints; NP hardness; graph matching."}, {"heading": "1 Introduction", "text": "In fact, the majority of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to fight, to move, to move, to fight, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move,"}, {"heading": "2 Constraints and consistency", "text": "In this paper, we deal with constraints on integer domains. Given a variable w, we refer to Dom (w) as its domain, which is considered a finite series of integers. If Dom (w) is defined as an interval (with integer l, r such that l \u2264 r) or a union of intervals is defined, we understand that there are only integers in the (union of) intervals, i.e. if Dom (wi) is defined as a set of variables with associated domains Dom (wi), and R is a t relationship over Z (equivalent, a subset of Zt). The constraint C = (W, w2, R) is a set of variables with associated domains Dom (wi), and R is a t relationship over Z (equivalent, a subset of Zt)."}, {"heading": "3 Links between sortedness, graph matching and 3SAT", "text": "Consider two sets of variables U = {ui \u2264 i \u2264 n} and V = {vi | 1 \u2264 i \u2264 n}, with finite integer domains dome (ui) and dome (vi), for all i, 1 \u2264 i \u2264 n. Following, we define the sectional diagram (U, V) of U and V as a two-part graph with a vertex value of U (ui, vj). We also use the notation M = (v), V) is an injective function. (U, V) is an injective function. (V)"}, {"heading": "4 The proposed construction is a polynomial transformation", "text": "In this section, we show that there is a truth matching that gives H with at least one true and one wrong letter in each clause, if and only if there is some kind of matching. To this end, we must first prove that: Claim 2 Let Gij represent an arbitrary entity. Then, no kind of matching M can contain the edges (U, V) and (bij) the edges (bij) and (bij) the edges (bij) and (bij) the edges (bij) and (bij) the edges (bij) at the same time. We have Aij (Bij) the edges (bij) and (bij) the edges (bij) and (bij) the edges (bij). Da (aij) the advance (bij) and (bij) in order to V if a kind of matching contains both edges (bij)."}, {"heading": "5 Hardness of sortedness constraints", "text": "The construction in the previous section allows us to derive the NP completeness of SortSupport in general, but also in a particular case of it, as follows. (Claim 5 SortSupport is NP-complete. Obviously, SortSupport NP-complete to show that it is NP-complete, Claim 4.With a slight modification of the domains we define for the variables, we also have this: Claim 6 SortSupport is NP-complete, even if the domains Dom (ui), 1 \u2264 i \u2264 i \u2264 n, pairwise disjoint.Proof. To have the pair disjunct domains, the idea is: (a), the intervals of Dom (u) are used with multiple domains Dom (u), so all other intervals will shift to the right to avoid unwanted overlaps; (b), to cut them into a sufficiently large number of subsections."}, {"heading": "6 Conclusion", "text": "In this paper, we have shown that the three sorting constraints defined so far are insoluble, even in the specific case where the variables to be sorted have pairs of separate domains, and even if we do not seek domain consistency, but only the enforcement of boundary (D) consistency. The traceability of the lower levels of boundary consistency, i.e. boundaries (Z) and boundaries (R) consistency, is shown for sorting (U, V) [5, 7] but is still open for sorting (U, V, P) and key sorting (U, V, Keys, P)."}], "references": [{"title": "The complexity of global constraints", "author": ["Christian Bessiere", "Emmanuel Hebrard", "Brahim Hnich", "Toby Walsh"], "venue": "In AAAI,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Sicstus prolog user?s manual", "author": ["Mats et al. Carlsson"], "venue": "(release 4.3.1),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Finite domain bounds consistency revisited", "author": ["Chiu Wo Choi", "Warwick Harvey", "Jimmy Ho-Man Lee", "Peter J Stuckey"], "venue": "In AI 2006: Advances in Artificial Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "Computers and intractability: A Guide to the Theory of NP-Completeness", "author": ["Michael R Garey", "David S Johnson"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1979}, {"title": "Narrowing a 2n-block of sortings in o (n logn)", "author": ["Noelle Bleuzen Guernalec", "Alain Colmerauer"], "venue": "In Principles and Practice of Constraint Programming-CP97,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1997}, {"title": "On representatives of subsets", "author": ["Philip Hall"], "venue": "J. London Math. Soc,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1935}, {"title": "Faster algorithms for bound-consistency of the sortedness and the alldifferent constraint", "author": ["Kurt Mehlhorn", "Sven Thiel"], "venue": "In Principles and Practice of Constraint Programming\u2013CP", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "Minizinc: Towards a standard cp modelling language", "author": ["Nicholas Nethercote", "Peter J Stuckey", "Ralph Becket", "Sebastian Brand", "Gregory J Duck", "Guido Tack"], "venue": "In Principles and Practice of Constraint Programming\u2013CP", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2007}, {"title": "Getting to the real problem: Experience with bnr prolog in or", "author": ["WJ Older", "GM Swinkels", "MH Van Emden"], "venue": "Proceedings of the Third International Conference on the Practical Applications of Prolog (PAP?95). Alinmead Software Ltd, page 28", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1995}, {"title": "Maximum weight edge-constrained matchings", "author": ["Irena Rusu"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "When do bounds and domain propagation lead to the same search space", "author": ["Christian Schulte", "Peter J Stuckey"], "venue": "ACM Transactions on Programming Languages and Systems (TOPLAS),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2005}, {"title": "Modeling and programming with Gecode", "author": ["Christian Schulte", "Guido Tack", "Mikael Z. Lagerkvist"], "venue": "http://www.gecode.org/doc-latest/MPG.pdf,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "Choco documentation", "author": ["CHOCO Team"], "venue": "http://choco.emn.fr", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2010}, {"title": "Efficient algorithms for constraint propagation and for processing tree descriptions", "author": ["Sven Thiel"], "venue": "PhD thesis, Universita\u0308tsbibliothek,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2004}, {"title": "The alldifferent constraint: A survey", "author": ["Willem-Jan van Hoeve"], "venue": "arXiv preprint cs/0105015,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2001}, {"title": "A constraint program for solving the job-shop problem", "author": ["Jianyang Zhou"], "venue": "In Principles and Practice of Constraint Programming?CP96,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1996}], "referenceMentions": [{"referenceID": 0, "context": "Dealing with global constraints in general, that is, without fixing a constraint (or a set of constraints), is intractable [1].", "startOffset": 123, "endOffset": 126}, {"referenceID": 14, "context": "However, each constraint has its own complexity, which may range from tractability at all levels of consistency, as for the alldifferent constraint [15], to intractability at relatively low levels of consistency, as for linear equations [11].", "startOffset": 148, "endOffset": 152}, {"referenceID": 10, "context": "However, each constraint has its own complexity, which may range from tractability at all levels of consistency, as for the alldifferent constraint [15], to intractability at relatively low levels of consistency, as for linear equations [11].", "startOffset": 237, "endOffset": 241}, {"referenceID": 8, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 162, "endOffset": 165}, {"referenceID": 15, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 182, "endOffset": 186}, {"referenceID": 1, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 217, "endOffset": 220}, {"referenceID": 1, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 103, "endOffset": 106}, {"referenceID": 11, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 115, "endOffset": 119}, {"referenceID": 12, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 130, "endOffset": 134}, {"referenceID": 7, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 193, "endOffset": 196}, {"referenceID": 6, "context": "In Section 3, we transform, using ideas from [7], the search for a support of sort(U, V ) into a graph matching problem that we call SortSupport, and we show how to associate with each instance of the NP-complete problem Not-All-Equal 3SAT an instance of SortSupport.", "startOffset": 45, "endOffset": 48}, {"referenceID": 3, "context": "The next section is devoted to the proof that our construction is a polynomial transformation [4], implying the NP-completeness of SortSupport.", "startOffset": 94, "endOffset": 97}, {"referenceID": 2, "context": "In order to solve a CSP, constraints are successively used to prune the search space, with the help of propagation algorithms that often seek to enforce various consistency properties, defined below (following [3]).", "startOffset": 210, "endOffset": 213}, {"referenceID": 8, "context": "We now define the sortedness constraints: \u2022 the sort(U, V ) constraint, defined in [9], has variable set U\u222aV , where U = {u1, u2, .", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "Propagation algorithms achieving bounds(Z)-consistency have been proposed in [5] and [7].", "startOffset": 77, "endOffset": 80}, {"referenceID": 6, "context": "Propagation algorithms achieving bounds(Z)-consistency have been proposed in [5] and [7].", "startOffset": 85, "endOffset": 88}, {"referenceID": 15, "context": "\u2022 the sort(U, V, P ) constraint, defined in [16], generalizes the sort(U, V ) constraint by adding a set P of n variables with domains included in {1, 2, .", "startOffset": 44, "endOffset": 48}, {"referenceID": 13, "context": "The propagation algorithms for the sort(U, V ) constraint are able to reduce the domains of the variables in U \u222aV similarly, but achieve bound(Z)-consistency only on the V -domains, and not on the U and P -domains [14].", "startOffset": 214, "endOffset": 218}, {"referenceID": 1, "context": "\u2022 the keysorting(U, V,Keys, P ) constraint (where Keys is a positive integer), defined in [2], allows to add two features with respect to sort(U, V, P ) : (a) each variable is a h-tuple (h \u2265 1 and integer, common to all variables), whose first Keys elements form the sorting key of the variable, using lexicographic ordering; and (b) the sorting has to be stable, i.", "startOffset": 90, "endOffset": 93}, {"referenceID": 6, "context": "Following [7], we define the intersection graph \u0393(U, V ) of U and V as the bipartite graph with vertex set U \u222a V and edge set {(ui, vj) |Dom(ui) \u2229 Dom(vj) 6= \u2205}.", "startOffset": 10, "endOffset": 13}, {"referenceID": 9, "context": "We adapt the graph construction in [10], and therefore use the same notations.", "startOffset": 35, "endOffset": 39}, {"referenceID": 3, "context": "The reduction is from the NP-complete problem Not-All-Equal 3SAT [4], the variant of 3SAT in which each clause is required to have at least one true and at least one false literal.", "startOffset": 65, "endOffset": 68}, {"referenceID": 5, "context": "By Hall\u2019s theorem [6], this graph has a perfect matching M \u2032, that we add to M .", "startOffset": 18, "endOffset": 21}, {"referenceID": 4, "context": "bounds(Z) and bounds(R) consistency, is shown for sort(U, V ) [5, 7], but is still open for sort(U, V, P ) and keysorting(U, V,Keys, P ).", "startOffset": 62, "endOffset": 68}, {"referenceID": 6, "context": "bounds(Z) and bounds(R) consistency, is shown for sort(U, V ) [5, 7], but is still open for sort(U, V, P ) and keysorting(U, V,Keys, P ).", "startOffset": 62, "endOffset": 68}], "year": 2015, "abstractText": "In Constraint Programming, global constraints allow to model and solve many combinatorial problems. Among these constraints, several sortedness constraints have been defined, for which propagation algorithms are available, but for which the tractability is not settled. We show that the sort(U, V ) constraint (Older et. al, 1995) is intractable (assuming P 6=NP) for integer variables whose domains are not limited to intervals. As a consequence, the similar result holds for the sort(U, V, P ) constraint (Zhou, 1996). Moreover, the intractability holds even under the stability condition present in the recently introduced keysorting(U, V,Keys, P ) constraint (Carlsson et al., 2014), and requiring that the order of the variables with the same value in the list U be preserved in the list V . Therefore, keysorting(U, V,Keys, P ) is intractable as well.", "creator": "LaTeX with hyperref package"}}}