{"id": "1506.04299", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Jun-2015", "title": "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates", "abstract": "Causality has been recently introduced in databases, to model, characterize and possibly compute causes for query results (answers). Connections between query causality and consistency-based diagnosis and database repairs (wrt. integrity constrain violations) have been established in the literature. In this work we establish connections between query causality and abductive diagnosis and the view-update problem. The unveiled relationships allow us to obtain new complexity results for query causality -the main focus of our work- and also for the two other areas.", "histories": [["v1", "Sat, 13 Jun 2015 17:33:47 GMT  (22kb)", "https://arxiv.org/abs/1506.04299v1", "To appear in Proc. UAI Causal Inference Workshop, 2015"], ["v2", "Tue, 7 Jul 2015 18:55:13 GMT  (74kb)", "http://arxiv.org/abs/1506.04299v2", "To appear in Proc. UAI Causal Inference Workshop, 2015. This version considerably improves the presentation over that previously uploaded"], ["v3", "Mon, 13 Jul 2015 09:15:22 GMT  (74kb)", "http://arxiv.org/abs/1506.04299v3", "To appear in Proc. UAI Causal Inference Workshop, 2015. This version makes more precise the statements of results already presented in the previous version"], ["v4", "Tue, 18 Aug 2015 23:05:44 GMT  (76kb)", "http://arxiv.org/abs/1506.04299v4", "To appear in Proc. UAI Causal Inference Workshop, 2015. The structure of the paper has been changed, and the statements of some results have been improved"], ["v5", "Sun, 20 Sep 2015 03:41:29 GMT  (76kb)", "http://arxiv.org/abs/1506.04299v5", "To appear in Proc. UAI Causal Inference Workshop, 2015. One example was fixed"]], "COMMENTS": "To appear in Proc. UAI Causal Inference Workshop, 2015", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["babak salimi", "leopoldo bertossi"], "accepted": false, "id": "1506.04299"}, "pdf": {"name": "1506.04299.pdf", "metadata": {"source": "CRF", "title": "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates", "authors": ["Babak Salimi"], "emails": ["bsalimi@scs.carleton.ca", "bertossi@scs.carleton.ca"], "sections": [{"heading": null, "text": "In fact, it is so that most of them are able to understand themselves and understand what they are doing. (...) In fact, it is so that they are able to understand themselves. (...) In fact, it is so that they are able to understand themselves. (...) It is so that they are able to understand themselves. (...) It is not so that they are able to understand themselves. (...) It is as if they were able to change the world. (...) It is as if they were able to change the world. (...) It is as if they were able to change the world. (...) It is as if they are able to change the world. (...) It is as if they were able to change the world. (...). (...) It is so. (...). (...) It is. (...) It is. (...). (...) It is. (...) It is. (...). (...) It is. (...) It is. (...). (...) It is. (...) It is. (...). (... It is. (...) It is. (...) It is. (...). (it is. (...) It is. (...). (it is. (...) It is. (it is. (...). (it is. (...). (it is. (...). (it is. (...). (it is. (it.). (it is.). (it is. (it. (it.). (it is.). (it. (it is.). (it is. (it.). (is. (it. (it. (it is.). (it.). (is. (is. (it is.). (it. (it. (it is.). (is. (it is. (is.). (it is. (it is. (it.). (it. (it is. (is.). (it is. (it is.). (it. (it is. (it is. (it. (it.). (it is. (it. It is. (it is.). (it is.). (it is. (it. (it is."}, {"heading": "1 PRELIMINARIES AND CAUSALITY DECISION PROBLEMS", "text": "We consider the relational database schemes of the form S = (U, P), where U = Q = Q is the possibly infinite database domain and P is a finite series of database predicators4 of the fixed arrangements. A database instance D, which is compatible with S, can be considered a finite series of earth formulas (aka in databases). (Cn) A subjunctive formula (CQ) is a formula Q (x) of the form P (c1,..., cn), where P has the arrangements n, and the constants c1,. (Cn) A subjunctive formula (CQ) is a formula Q (x) of the firststorder (FO) language L (S), the query (s \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 Pm) with S of the form y query (P1)."}, {"heading": "1.1 CAUSALITY AND RESPONSIBILITY", "text": "In the rest of this work, unless otherwise stated, we will assume that a database instance D is divided into two actual sets, D = Dn = Dx, where Dn and Dx are the sets of endogenous and exogenous tuples, respectively Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q ="}, {"heading": "1.2 VIEW-CONDITIONED CAUSALITY", "text": "A form of conditional causality has been informally introduced in (Meliou et al., 2010b) to characterize the causes of an answer to a question conditioned by the other answers to the question. < c) The notion has been specified in (Meliou et al., 2011), in a more general, non-relational environment, which includes, in particular, the case of multiple queries. (They use the concept of intentional causality, and we adapt a monotonous response Q with Q (D) = {a-flow / min-cut problem in a network.4it in the following case of a single query, possibly with multiple answers. Consider an instance D = Dn-Dx, and a monotonous answer Q with Q (D) = {a-flow / min-cut problem in a network.4it below."}, {"heading": "2 CAUSALITY AND ABDUCTION", "text": "In a general logical sense, an abductive explanation of an observation is a formula that, together with the logical background theory, entails observation (Psillos, 1996; Denecker & Kakas, 2002). Under the abductive approach of diagnosis (Console et al., 1991; Eiter & Gottlob, 1995; Poole, 1992, 1994), it is customary for the system specification to describe causal information fairly explicitly, especially in action theories in which the effects of actions are directly represented by horn formulas. By limiting the explanatory formulas to predicates that describe primitive causes (actions), an explanatory formula that entails observation is also a cause for observation (Denecker & Kakas, 2002)."}, {"heading": "2.1 BACKGROUND ON DATALOG ABDUCTIVE DIAGNOSIS", "text": "A Datalog Abduction Problem (Eiter et al., 1997) is of the form AP = < E, Hyp, Obs >, where: (a) E is a set of Datalog rules, (b) E is a set of soil atoms (the expanded database) whose predicates do not appear in the minds of the regulated, (c) Hyp, the hypothesis is a finite set of soil atoms, the abductible atoms in this case, 8, and (d) Obs, is a finite combination of soil atoms. Since it is common, we will start with the assumption that the abduction problems proceed from the autopsy points."}, {"heading": "2.2 QUERY CAUSALITY FROM ABDUCTIVE DIAGNOSIS", "text": "In this section, we first show that, for the class of datalog theories (system specifications), inductive conclusions are needed for actual causality for monotonous questions. # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "3 VIEW-UPDATES AND QUERY CAUSALITY", "text": "There is a strong correlation between the causality of the query and the view update problem in the form of delete propagation, first proposed in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al., 2002)). We begin with the formalization of some specific arithmetic problems related to the general delete propagation problem."}, {"heading": "3.1 DELETE-PROPAGATION PROBLEMS", "text": "Faced with a monotonous Q query, we can imagine that it is a virtual view Q (D). (This is a common case of the problem of database updates by views (Abiteboul et al., 1995). In this paper, we consider some variations of this problem, both in its functional and decision version. (7Definition 3.1.) For example D, and a monotonous Q query: (a) For such a Q (D) query, the minimal source side effect problem is about calculating a minimal source side effect D, so that there is a source side effect Q (D). (b) The minimal source side effect decision problem is (the decision on membership of): MSSEPs (Q) = {(D, D), a source investigation D, a source differentiation Q (D), D \u00b2 problem, Q \u00b2 -Q \u00b2 -D effect is a source differentiation."}, {"heading": "3.2 VIEW DELETIONS VS. CAUSES", "text": "It is, of course, to be expected that the deletion of an approach can be achieved from the point of view of an approach in order to find a solution. (D) It is, of course, to be expected that the deletion of an approach can be achieved from the point of view of an approach. (D) It is, of course, to be expected that the deletion of an approach can be achieved from the point of view of an approach. (D) It is natural that the deletion of an approach can be achieved from the point of view of an approach. (D) It is natural that the deletion of an approach can be achieved from the point of view of an approach. (D) It is to be expected, of course, that the deletion of an approach can be achieved from the point of view of an approach. (D) It is to be expected that the deletion of an approach can be achieved from the point of view of an approach. (D)"}, {"heading": "4 CONCLUSIONS", "text": "Some connections between the last two have already been made before. Specifically, the problem of view updating has been addressed from the perspective of abductive reasoning (Kakas & Mancarella, 1990; Console et al., 1995).The idea is to \"hijack\" the presence of tuples in the base tables that explain the presence of these tuples in the visual expansion that one wants to get rid of, for example. Combined with the results reported in (Salimi & Bertossi, 2015), we can see that there are deeper and multiple connections between the areas of query causality, inductive and consistency-based diagnoses, view updating and database repairs. Results for one of these areas can be applied profitably to the others.11Links between consistency-based and abductive diagnosis. We point out that database repairs are explicitly related to the problem of updating the data."}], "references": [{"title": "Coherent Integration of Databases by Abductive Logic Programming", "author": ["O. Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "Arieli et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Arieli et al\\.", "year": 2004}, {"title": "Achieving Data Privacy through Secrecy Views and Null-Based Virtual Updates", "author": ["L. Bertossi", "L. Li"], "venue": "IEEE Transaction on Knowledge and Data Engineering,", "citeRegEx": "Bertossi and Li,? \\Q2013\\E", "shortCiteRegEx": "Bertossi and Li", "year": 2013}, {"title": "Database Repairing and Consistent Query Answering", "author": ["L. Bertossi"], "venue": "Morgan & Claypool, Synthesis Lectures on Data Management,", "citeRegEx": "Bertossi,? \\Q2011\\E", "shortCiteRegEx": "Bertossi", "year": 2011}, {"title": "Unifying Causality, Diagnosis, Repairs and View-Updates in Databases", "author": ["L. Bertossi", "B. Salimi"], "venue": "First International PODS-Workshop on Big Uncertain Data (BUDA", "citeRegEx": "Bertossi and Salimi,? \\Q2014\\E", "shortCiteRegEx": "Bertossi and Salimi", "year": 2014}, {"title": "Answer Set Programming at a Glance", "author": ["G. Brewka", "Eiter", "Th", "M. Truszczynski"], "venue": "Communications of the ACM,", "citeRegEx": "Brewka et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Brewka et al\\.", "year": 2011}, {"title": "On Propagation of Deletions and Annotations Through Views", "author": ["P. Buneman", "S. Khanna", "W.C. Tan"], "venue": "Proc. PODS,", "citeRegEx": "Buneman et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Buneman et al\\.", "year": 2002}, {"title": "Responsibility and Blame: A Structural-Model Approach", "author": ["H. Chockler", "J.Y. Halpern"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "Chockler and Halpern,? \\Q2004\\E", "shortCiteRegEx": "Chockler and Halpern", "year": 2004}, {"title": "A Spectrum of Logical Definitions of Model-Based Diagnosis", "author": ["L. Console", "P. Torasso"], "venue": "Comput. Intell.,", "citeRegEx": "Console et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Console et al\\.", "year": 1991}, {"title": "On the Relationship between Abduction and Deduction", "author": ["L. Console", "D. Theseider-Dupre", "P. Torasso"], "venue": "J. Log. Comput.,", "citeRegEx": "Console et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Console et al\\.", "year": 1991}, {"title": "The Role of Abduction in Database View Updating", "author": ["L. Console", "Sapino M. L", "D. Theseider-Dupre"], "venue": "J. Intell. Inf. Syst.,", "citeRegEx": "Console et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Console et al\\.", "year": 1995}, {"title": "Abduction in Logic Programming", "author": ["M. Denecker", "Kakas A. C"], "venue": "In Computational Logic: Logic Programming and Beyond,", "citeRegEx": "Denecker and C.,? \\Q2002\\E", "shortCiteRegEx": "Denecker and C.", "year": 2002}, {"title": "The Complexity of Logic-Based Abduction", "author": ["T. Eiter", "G. Gottlob"], "venue": "J. ACM ,", "citeRegEx": "Eiter and Gottlob,? \\Q1995\\E", "shortCiteRegEx": "Eiter and Gottlob", "year": 1995}, {"title": "Abduction from Logic Programs: Semantics and Complexity", "author": ["T. Eiter", "G. Gottlob", "N. Leone"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Eiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "Hypothesis Classification, Abductive Diagnosis and Therapy", "author": ["G. Friedrich", "Gottlob. G", "W. Nejdl"], "venue": "Proc. Internat. Workshop on Expert Systems in Engineering,", "citeRegEx": "Friedrich et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Friedrich et al\\.", "year": 1990}, {"title": "Bounded Treewidth as a Key to Tractability of Knowledge Representation And Reasoning", "author": ["G. Gottlob", "R. Pichler", "F. Wei"], "venue": "Artificial Intelligence,", "citeRegEx": "Gottlob et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Gottlob et al\\.", "year": 2010}, {"title": "Tractable Database Design and Datalog Abduction through Bounded Treewidth", "author": ["G. Gottlob", "R. Pichler", "F. Wei"], "venue": "Inf. Syst.,", "citeRegEx": "Gottlob et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Gottlob et al\\.", "year": 2010}, {"title": "Causes and Explanations: A StructuralModel Approach: Part 1", "author": ["J. Halpern", "J. Pearl"], "venue": "Proc. UAI,", "citeRegEx": "Halpern and Pearl,? \\Q2001\\E", "shortCiteRegEx": "Halpern and Pearl", "year": 2001}, {"title": "Causes and Explanations: A StructuralModel Approach: Part 1", "author": ["Y.J. Halpern", "J. Pearl"], "venue": "British J. Philosophy of Science,", "citeRegEx": "Halpern and Pearl,? \\Q2005\\E", "shortCiteRegEx": "Halpern and Pearl", "year": 2005}, {"title": "A Modification of Halpern-Pearl Definition of Causality", "author": ["J. Halpern"], "venue": "To appear in Proc. IJCAI,", "citeRegEx": "Halpern,? \\Q2015\\E", "shortCiteRegEx": "Halpern", "year": 2015}, {"title": "Appropriate Causal Models and Stability of Causation", "author": ["J. Halpern"], "venue": "Proc. KR,", "citeRegEx": "Halpern,? \\Q2014\\E", "shortCiteRegEx": "Halpern", "year": 2014}, {"title": "Database Updates through Abduction", "author": ["Kakas A. C", "P. Mancarella"], "venue": "Proc. VLDB,", "citeRegEx": "C. and Mancarella,? \\Q1990\\E", "shortCiteRegEx": "C. and Mancarella", "year": 1990}, {"title": "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies", "author": ["B. Kimelfeld"], "venue": "Proc. PODS,", "citeRegEx": "Kimelfeld,? \\Q2012\\E", "shortCiteRegEx": "Kimelfeld", "year": 2012}, {"title": "Maximizing Conjunctive Views in Deletion Propagation", "author": ["B. Kimelfeld", "J. Vondrak", "R. Williams"], "venue": "ACM TODS,", "citeRegEx": "Kimelfeld et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Kimelfeld et al\\.", "year": 2012}, {"title": "The Complexity of Causality and Responsibility for Query Answers and Non-Answers", "author": ["A. Meliou", "Gatterbauer", "K.F.W. Moore", "D. Suciu"], "venue": "Proc. VLDB,", "citeRegEx": "Meliou et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Meliou et al\\.", "year": 2010}, {"title": "Causality in Databases", "author": ["A. Meliou", "Gatterbauer. W", "J.Y. Halpern", "C. Koch", "Moore K. F", "D. Suciu"], "venue": "IEEE Data Eng. Bull,", "citeRegEx": "Meliou et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Meliou et al\\.", "year": 2010}, {"title": "Tracing Data Errors with View-Conditioned Causality", "author": ["A. Meliou", "Gatterbauer", "S. Nath", "D. Suciu"], "venue": "Proc. SIGMOD,", "citeRegEx": "Meliou et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Meliou et al\\.", "year": 2011}, {"title": "Ampliative Reasoning: Induction or Abduction", "author": ["A. Psillos"], "venue": "Proc. ECAI\u201996 Workshop on Abductive and Inductive Reasoning,", "citeRegEx": "Psillos.,? \\Q1996\\E", "shortCiteRegEx": "Psillos.", "year": 1996}, {"title": "Logic Programming, Abduction and Probability", "author": ["D. Poole"], "venue": "Proc. FGCS,", "citeRegEx": "Poole,? \\Q1992\\E", "shortCiteRegEx": "Poole", "year": 1992}, {"title": "Representing Diagnosis Knowledge", "author": ["D. Poole"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Poole,? \\Q1994\\E", "shortCiteRegEx": "Poole", "year": 1994}, {"title": "A Theory of Diagnosis from First Principles", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Reiter,? \\Q1987\\E", "shortCiteRegEx": "Reiter", "year": 1987}, {"title": "Causality in Databases: The Diagnosis and Repair Connections", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. 15th International Workshop on Non-Monotonic Reasoning (NMR", "citeRegEx": "Salimi and Bertossi,? \\Q2014\\E", "shortCiteRegEx": "Salimi and Bertossi", "year": 2014}, {"title": "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. ICDT,", "citeRegEx": "Salimi and Bertossi,? \\Q2015\\E", "shortCiteRegEx": "Salimi and Bertossi", "year": 2015}, {"title": "Model-based Problem Solving", "author": ["P. Struss"], "venue": "In Handbook of Knowledge Representation, chap. 10. Elsevier,", "citeRegEx": "Struss,? \\Q2008\\E", "shortCiteRegEx": "Struss", "year": 2008}], "referenceMentions": [{"referenceID": 18, "context": ", 2010a,b, 2011), can be traced back to (Halpern & Pearl, 2001, 2005), which provides a model-based account of causation on the basis of counterfactual dependence.2 Causal responsibility was introduced in Chockler & Halpern (2004), to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.", "startOffset": 41, "endOffset": 231}, {"referenceID": 29, "context": "Since this and causality are related to explanations, a first connection between causality and consistency-based diagnosis (Reiter, 1987), a form of model-based diagnosis, was established in (Salimi & Bertossi, 2014, 2015): Causality and the responsibility problem can be formulated as consistency-based diagnosis problems, which allowed to extend the results in (Meliou et al.", "startOffset": 123, "endOffset": 137}, {"referenceID": 7, "context": "However, no precise connection has been established so far between causality and abductive diagnosis (Console et al., 1991; Eiter & Gottlob, 1995), another form of model-based diagnosis.", "startOffset": 101, "endOffset": 146}, {"referenceID": 2, "context": "In (Salimi & Bertossi, 2015) connections were established between query causality, database repairs (Bertossi, 2011), and consistency-based diagnosis.", "startOffset": 100, "endOffset": 116}, {"referenceID": 12, "context": "As opposed to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly performed under a logic programming (LP) approach (in the general sense of LP) to knowledge representation (Denecker & Kakas, 2002; Eiter et al., 1997; Gottlob et al., 2010b).", "startOffset": 233, "endOffset": 300}, {"referenceID": 9, "context": "Abductive reasoning/diagnosis has been applied to the view update problem in databases (Kakas & Mancarella, 1990; Console et al., 1995), which is about characterizing and computing updates of physical database relations that give an account of (or have as result) the intended updates on views.", "startOffset": 87, "endOffset": 135}, {"referenceID": 5, "context": "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.", "startOffset": 31, "endOffset": 94}, {"referenceID": 21, "context": "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.", "startOffset": 31, "endOffset": 94}, {"referenceID": 22, "context": "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.", "startOffset": 31, "endOffset": 94}, {"referenceID": 5, "context": "It is also possible to consider minimizing the side-effect on the view, which also requires that other tuples in the (virtual) view contents are not affected (deleted) (Buneman et al., 2002).", "startOffset": 168, "endOffset": 190}, {"referenceID": 25, "context": "The notion was made precise in (Meliou et al., 2011), in a more general, non-relational setting that in particular includes the case of several queries.", "startOffset": 31, "endOffset": 52}, {"referenceID": 26, "context": "However, it has been argued that causes and abductive explanations are not necessarily the same (Psillos, 1996; Denecker & Kakas, 2002).", "startOffset": 96, "endOffset": 135}, {"referenceID": 7, "context": "Under the abductive approach to diagnosis (Console et al., 1991; Eiter & Gottlob, 1995; Poole, 1992, 1994), it is common that the system specification rather explicitly describes causality information, specially in action theories where the effects of actions are directly represented by Horn formulas.", "startOffset": 42, "endOffset": 106}, {"referenceID": 27, "context": "In this case, and is some sense, causality information is imposed by the system specifier (Poole, 1992).", "startOffset": 90, "endOffset": 103}, {"referenceID": 12, "context": "A Datalog abduction problem (Eiter et al., 1997) is of the form AP = \u3008\u03a0, E,Hyp,Obs\u3009, where: (a) \u03a0 is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), whose predicates do not appear in heads of rules in \u03a0, (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case,8 and (d) Obs , the observation, is a finite conjunction of ground atoms.", "startOffset": 28, "endOffset": 48}, {"referenceID": 32, "context": "In (Salimi & Bertossi, 2015) we established such a connection between another form of model-based diagnosis (Struss, 2008), namely consistency-based diagnosis (Reiter, 1987).", "startOffset": 108, "endOffset": 122}, {"referenceID": 29, "context": "In (Salimi & Bertossi, 2015) we established such a connection between another form of model-based diagnosis (Struss, 2008), namely consistency-based diagnosis (Reiter, 1987).", "startOffset": 159, "endOffset": 173}, {"referenceID": 7, "context": "For relationships and comparisons between consistency-based and abductive diagnosis see (Console et al., 1991).", "startOffset": 88, "endOffset": 110}, {"referenceID": 13, "context": "The following result is obtained by showing that the NPcomplete combined complexity of the relevance problem for Propositional Datalog Abduction (PDA) (established in (Friedrich et al., 1990)), coincides with the data complexity of the relevance problem for (non-propositional) Datalog Abduction.", "startOffset": 167, "endOffset": 191}, {"referenceID": 12, "context": "For this, techniques developed in (Eiter et al., 1997) can be used.", "startOffset": 34, "endOffset": 54}, {"referenceID": 21, "context": "There is a close relationship between query causality and the view-update problem in the form of deletepropagation, which was first suggested in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al.", "startOffset": 145, "endOffset": 186}, {"referenceID": 22, "context": "There is a close relationship between query causality and the view-update problem in the form of deletepropagation, which was first suggested in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al.", "startOffset": 145, "endOffset": 186}, {"referenceID": 5, "context": ", 2012) (see also (Buneman et al., 2002)).", "startOffset": 18, "endOffset": 40}, {"referenceID": 5, "context": "(Buneman et al., 2002) For an instance D, and a monotone query Q:", "startOffset": 0, "endOffset": 22}, {"referenceID": 5, "context": "Actually, the following result is obtained from the NP-completeness of view sideeffect-free problem (Buneman et al., 2002) and Proposition 3.", "startOffset": 100, "endOffset": 122}, {"referenceID": 5, "context": "2, a new tractability result for the minimum source-side-effect problem, which has been shown to be NP-hard for general CQs in (Buneman et al., 2002).", "startOffset": 127, "endOffset": 149}, {"referenceID": 5, "context": "In (Buneman et al., 2002) it has been shown that the minimum source-side-effect decision problem is tractable for the class of project-join queries with chain joins.", "startOffset": 3, "endOffset": 25}, {"referenceID": 5, "context": "Actually, the tractability results for these classes of queries are both obtained via a reduction to maximum flow problem (Meliou et al., 2010a; Buneman et al., 2002).", "startOffset": 122, "endOffset": 166}, {"referenceID": 5, "context": "9 extends that in (Buneman et al., 2002), from linear queries to weakly-linear queries.", "startOffset": 18, "endOffset": 40}, {"referenceID": 9, "context": "More precisely, the view-update problem has been treated from the point of view of abductive reasoning (Kakas & Mancarella, 1990; Console et al., 1995).", "startOffset": 103, "endOffset": 151}, {"referenceID": 4, "context": "Actually, answer set programs (ASPs) (Brewka et al., 2011) for database repairs (Bertossi, 2011) implicity repair the database by updating conjunctive combinations of intentional, annotated predicates.", "startOffset": 37, "endOffset": 58}, {"referenceID": 2, "context": ", 2011) for database repairs (Bertossi, 2011) implicity repair the database by updating conjunctive combinations of intentional, annotated predicates.", "startOffset": 29, "endOffset": 45}, {"referenceID": 2, "context": "Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs (Bertossi, 2011) is made (Bertossi & Li, 2013).", "startOffset": 112, "endOffset": 128}, {"referenceID": 0, "context": "Finally, we should note that abduction has also been explicitly applied to database repairs (Arieli et al., 2004).", "startOffset": 92, "endOffset": 113}], "year": 2015, "abstractText": "Causality has been recently introduced in databases, to model, characterize and possibly compute causes for query results (answers). Connections between query causality and consistency-based diagnosis and database repairs (wrt. integrity constrain violations) have been established in the literature. In this work we establish connections between query causality and abductive diagnosis and the view-update problem. The unveiled relationships allow us to obtain new complexity results for query causality -the main focus of our workand also for the two other areas. Causality is an important notion that appears at the foundations of many scientific disciplines, in the practice of technology, and also in our everyday life. Causality is unavoidable to understand and manage uncertainty in data, information, knowledge, and theories. In data management in particular, there is a need to represent, characterize and compute the causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables). In this work we concentrate on causality as defined forand applied to relational databases. Most of the work on causality has been developed in the context of knowledge representation, and little has been said about causality in data management. Furthermore, in a world of big uncertain data, the necessity to understand the data beyond simple query answering, introducing explanations in different forms, has become particularly relevant. The notion of causality-based explanation for a query result was introduced in (Meliou et al., 2010a), on the basis of the deeper concept of actual causation.1 Intuitively, a In contrast with general causal claims, such as \u201csmoking tuple (of constants) t is an actual cause for an answer \u0101 to a conjunctive query Q from a relational database instance D if there is a \u201ccontingent\u201d subset of tuples \u0393, accompanying t, such that, after removing \u0393 from D, removing t from D r \u0393 causes \u0101 to switch from being an answer to being a non-answer (i.e. not being an answer). Usually, actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples. A cause t may have different associated contingency sets \u0393. Intuitively, the smaller they are the strongest is t as a cause (it need less company to undermine the query answer). So, some causes may be stronger than others. This idea is formally captured through the notion of causal responsibility, and introduced in (Meliou et al., 2010a). It reflects the relative degree of actual causality. In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities (Meliou et al., 2010b,a). Furthermore, view-conditioned causality was proposed in (Meliou et al., 2010b, 2011) as a restricted form of query causality, to determine causes for a set of unexpected query results, but conditioned to the correctness of prior knowledge about some other set of results. Actual causation, as used in (Meliou et al., 2010a,b, 2011), can be traced back to (Halpern & Pearl, 2001, 2005), which provides a model-based account of causation on the basis of counterfactual dependence.2 Causal responsibility was introduced in Chockler & Halpern (2004), to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome. Model-based diagnosis (Struss, 2008, sec. 10.3), an area of causes cancer\u201d, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., \u201cJoe\u2019s smoking is a cause for his cancer\u201d. As discussed in (Salimi & Bertossi, 2015), some objections to the Halpern-Pearl model of causality and the corresponding changes (Halpern, 2014, 2015) do not affect results in the context of databases. knowledge representation, addresses the problem of, given the specification of a system in some logical formalism and a usually unexpected observation about the system, obtaining explanations for the observation, in the form of a diagnosis for the unintended behavior. Since this and causality are related to explanations, a first connection between causality and consistency-based diagnosis (Reiter, 1987), a form of model-based diagnosis, was established in (Salimi & Bertossi, 2014, 2015): Causality and the responsibility problem can be formulated as consistency-based diagnosis problems, which allowed to extend the results in (Meliou et al., 2010a). However, no precise connection has been established so far between causality and abductive diagnosis (Console et al., 1991; Eiter & Gottlob, 1995), another form of model-based diagnosis. The definition of causality for query answers applies to monotone queries (Meliou et al., 2010a,b). However, all complexity and algorithmic results in (Meliou et al., 2010a; Salimi & Bertossi, 2015) have been restricted to first-order (FO) monotone queries. Other important classes of monotone queries, such as Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), possibly with recursion, require further investigation. In (Salimi & Bertossi, 2015) connections were established between query causality, database repairs (Bertossi, 2011), and consistency-based diagnosis. In particular, complexity results for several causality problems were obtained from the repair connection. In the line of this kind of research, in this work we unveil natural connections between actual causation and abductive diagnosis, and also the viewupdate problem in databases (more on this latter connection later in the section). As opposed to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly performed under a logic programming (LP) approach (in the general sense of LP) to knowledge representation (Denecker & Kakas, 2002; Eiter et al., 1997; Gottlob et al., 2010b). Since Datalog can be seen as a form of LP, we manage to extend and formulate the notion of query-answer causality to Datalog queries via the abductive diagnosis connection, in this way extending causality to a new class of queries, e.g. recursive queries, and obtaining complexity results on causality for them. Abductive reasoning/diagnosis has been applied to the view update problem in databases (Kakas & Mancarella, 1990; Console et al., 1995), which is about characterizing and computing updates of physical database relations that give an account of (or have as result) the intended updates on views. The idea is that abductive diagnosis provides (abduces) the reasons for the desired view updates, and they are given as changes on base tables. In this work we also explore fruitful connections of causality with this view-update problem (Abiteboul et al., 1995), i.e. about updating a database through views. An important aspect of the problem is that one wants the base, source database, i.e. the base relations, to change in a minimally way while still producing the view updates. Put in different terms, it is an update propagation problem, from views to base relations. This classical and important problem in databases. The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views. If the views are defined by monotone queries, only database deletions can give an account of view deletions. So, in this case, a minimal set (in some sense) of deletions from the base relations is expected to be performed. This is \u201cminimal source-sideeffect\u201d case. It is also possible to consider minimizing the side-effect on the view, which also requires that other tuples in the (virtual) view contents are not affected (deleted) (Buneman et al., 2002). In this work we provide a precise connection between different variants of the delete-propagation problem and query causality. In particular, we show that the minimal source-side-effect problem is related to the mostresponsible cause problem, which was formulated and investigated in (Salimi & Bertossi, 2015); and also that the \u201cminimal view side-effect problem\u201d is related to viewconditioned causality we already mentioned above. The established connections between abductive diagnoses, query causality and delete-propagation problems allow us to adopt (and possibly adapt) established results for some of them for application to the others. In this way we obtain some new complexity results. More precisely, our main results are as follows:3 1. We establish precise connections between causality for Datalog queries and abductive diagnosis. More precisely, we establish mutual characterizations of each in terms of the other, and computational reductions, between actual causes for Datalog queries and abductive diagnosis from Datalog specifications. We profit from these connections to obtain new algorithmic and complexity results for each of the two problems separately. (a) We characterize and obtain causes in terms ofand from abductive diagnoses. (b) We show that deciding tuple causality for Datalog queries, possibly recursive, is NP-complete in data. (c) We identify a class of Datalog queries for which The possible connections between the areas and problems in this paper were suggested in (Bertossi & Salimi, 2014), but no precise results were formulated there. 2 deciding causality is tractable in combined complexity. 2. We establish and profit from precise connections between delete-propagation and causality. More precisely, we show that: (a) Most-responsible causes and view-conditioned causes can be obtained from solutions to different variants of the delete-propagation problem and vice-versa. (b) Computing the size of the solution to a minimum source-side-effect problem is hard for FP. (c) Deciding weather an answer has a viewconditioned cause is NP-complete. (d) We can identify some new classes of queries for which computing minimum source-side-effect delete-propagation is tractable. 1 PRELIMINARIES AND CAUSALITY DECISION PROBLEMS We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain and P is a finite set of database predicates4 of fixed arities. A database instance D compatible with S can be seen as a finite set of ground atomic formulas (in databases aka. atoms or tuples), of the form P (c1, ..., cn), where P \u2208 P has arity n, and the constants c1, . . . , cn \u2208 U . A conjunctive query (CQ) is a formula Q(x\u0304) of the firstorder (FO) language L(S) associated to S of the form \u2203\u0233(P1(s\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Pm(s\u0304m)), where the Pi(s\u0304i) are atomic formulas, i.e. Pi \u2208 P , and the s\u0304i are sequences of terms, i.e. variables or constants of U . The x\u0304 in Q(x\u0304) shows all the free variables in the formula, i.e. those not appearing in \u0233. A sequence c\u0304 of constants is an answer to query Q(x\u0304) if D |= Q[c\u0304], i.e. the query becomes true in D when the variables are replaced by the corresponding constants in c\u0304. We denote the set of all answers to an open conjunctive query Q(x\u0304) with Q(D). A conjunctive query is boolean (a BCQ), if x\u0304 is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q and D 6|= Q, respectively. When Q is a BCQ, or contains no free variables, Q(D) = {yes} if Q is true, and Q(D) = \u2205, otherwise. A query Q is monotone if for every two instances D1 \u2286 D2, Q(D1) \u2286 Q(D2), i.e. the set of answers grows monotonically with the instance. For example, CQs and unions of CQ (UCQs) are monotone queries. Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), although not FO, are also monotone (cf. Section 1.1 for more details). As opposed to built-in predicates (e.g. 6=) that we assume do not appear, unless explicitly stated otherwise. 1.1 CAUSALITY AND RESPONSIBILITY In the rest of this work, unless otherwise stated, we will assume that a database instance D is split in two disjoint sets, D = D \u222a D, where D and D denote the sets of endogenous and exogenous tuples, respectively; and Q is a monotone query. Definition 1.1. A tuple \u03c4 \u2208 D is a counterfactual cause for an answer \u0101 to Q in D if D |= Q(\u0101) and D r {\u03c4} 6|= Q(\u0101). A tuple \u03c4 \u2208 D is an actual cause for \u0101 if there exists \u0393 \u2286 D, called a contingency set, such that \u03c4 is a counterfactual cause for \u0101 in D r \u0393. Causes(D,Q(\u0101)) denotes the set of actual causes for \u0101. This set is non-empty on the assumption that Q(\u0101) is true in D. When the query Q is boolean, Causes(D,Q) contains the causes for the answer yes in D. The definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of a Datalog, the query Q(x\u0304) is a whole program \u03a0 that accesses an underlying extensional database E that is not part of the query. Program \u03a0 contains a rule that defines a top answer-collecting predicate Ans(x\u0304). Now, \u0101 is an answer to query \u03a0 on E when \u03a0 \u222a E |= Ans(\u0101). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. A Datalog query is boolean if the top answer-predicate is propositional, say ans . In the case of Datalog, we sometimes use the notation Causes(E,\u03a0(\u0101)) or Causes(E,\u03a0), depending on whether \u03a0 has a Ans(x\u0304) or ans as answer predicate, resp. Given a \u03c4 \u2208 Causes(D,Q(\u0101)), we collect all subsetminimal contingency sets associated with \u03c4 : Cont(D,Q(\u0101), \u03c4 ) := {\u039b \u2286 Dn | D r \u039b |= Q(\u0101), D r (\u039b \u222a {\u03c4}) 6|= Q(\u0101), and \u2200\u039b $ \u039b, D r (\u039b \u222a {\u03c4}) |= Q(\u0101)}. The responsibility of actual cause \u03c4 for answer \u0101, denoted \u03c1 Q(\u0101) (\u03c4), is 1 (|\u0393|+1) , where |\u0393| is the size of the smallest contingency set for \u03c4 . Responsibility can be extend to all tuples in D by setting their value to 0, and they are not actual causes for Q. Example 1.1. Consider a database D with relations Author(Name,Journal) and Journal(JName,Topic,#Paper), and contents as below: Author Name JName Joe TKDE John TKDE Tom TKDE John TODS Journal JName Topic #Paper TKDE XML 30 TKDE CUBE 31 TODS XML 32 Consider the conjunctive query: Q(Name, Topic) :\u2203Journal JName #Paper(Author(Name,JName) \u2227 Journal(JName,Topic,#Paper), (1) which has the following answers: Q(D) Name Topic Joe XML Joe CUBE Tom XML Tom CUBE John XML John CUBE 3 Assume \u3008John, XML\u3009 is an unexpected answer to Q, and we want to compute its causes assuming that all tuples are endogenous. It turns out that Author(John, TODS) is an actual cause, with contingency sets \u03931 = {Author(John, TKDE)} and \u03932={Journal(TKDE, XML, 32)}, because Author(John, TODS) is a counterfactual cause for answer \u3008 John, XML\u3009 in both of D r \u03931 and D r \u03932. Therefore, the responsibility of Author(John, TODS) is 12 . Likewise, Journal(TKDE, XML, 32), Author(John, TKDE), Journal(TODS,XML, 32) are actual causes for \u3008John, XML\u3009 with responsibility 12 . Now, under the assumption that the tuples in Journal are the endogenous tuples, the only actual causes for answer \u3008John, XML\u3009 are Author(John, TKDE) and Author(John, TODS). A Datalog query Q(x\u0304) is a whole program \u03a0 consisting of positive rules that accesses an underlying extensional database E that is not part of the query. Program \u03a0 contains a rule that defines a top answer-collecting predicate Ans(x\u0304), by means of a rule of the form Ans(x\u0304) \u2190 P1(s\u03041), . . . , Pm(s\u0304m). Now, \u0101 is an answer to query \u03a0 on E when \u03a0 \u222a E |= Ans(\u0101). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. So, the extension Ans(D) of Ans in the minimal model of the program contains the answers to the query. A Datalog query is boolean if the top answer-predicate is propositional, say ans , i.e. defined by a rule of the form ans \u2190 P1(s\u03041), . . . , Pm(s\u0304m). In this case, the query is true if \u03a0\u222aD |= ans , equivalently, if ans belongs to the minimal model of \u03a0 \u222aE (Ceri et al., 1989; Abiteboul et al., 1995). CQs can be expressed as Datalog queries, e.g. (1) becomes: AnsQ(Name, Topic) \u2190\u2212 Author(Name,JName), Journal(JName,Topic,#Paper). The definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of Datalog, we sometimes use the notation Causes(E,\u03a0(\u0101)) or Causes(E,\u03a0), depending on whether \u03a0 has a Ans(x\u0304) or ans as answer predicate, resp. In (Meliou et al., 2010a), causality for non-query answers is defined on basis of sets of potentially missing tuples that account for the missing answer. Computing actual causes and their responsibilities for non-answers becomes a rather simple variation of causes for answers. In this work we focus on causality for query answers. The complexity of the computational and decision problems that arise in query causality have been investigated in (Meliou et al., 2010a; Salimi & Bertossi, 2015). Here we present some problems and results that we use throughout this paper. The first is the causality problem, about deciding whether a tuple is an actual cause for a query answer. Definition 1.2. For a boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of): CDP(Q) := {(D, \u03c4) | \u03c4 \u2208 D, and \u03c4 \u2208", "creator": "LaTeX with hyperref package"}}}