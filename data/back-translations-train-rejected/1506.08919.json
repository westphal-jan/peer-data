{"id": "1506.08919", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2015", "title": "Characterization of Logic Program Revision as an Extension of Propositional Revision", "abstract": "We address the problem of belief revision of logic programs, i.e., how to incorporate to a logic program P a new logic program Q. Based on the structure of SE interpretations, Delgrande et al. adapted the well-known AGM framework to logic program (LP) revision. They identified the rational behavior of LP revision and introduced some specific operators. In this paper, a constructive characterization of all rational LP revision operators is given in terms of orderings over propositional interpretations with some further conditions specific to SE interpretations. It provides an intuitive, complete procedure for the construction of all rational LP revision operators and makes easier the comprehension of their semantic and computational properties. We give a particular consideration to logic programs of very general form, i.e., the generalized logic programs (GLPs). We show that every rational GLP revision operator is derived from a propositional revision operator satisfying the original AGM postulates. Interestingly, the further conditions specific to GLP revision are independent from the propositional revision operator on which a GLP revision operator is based. Taking advantage of our characterization result, we embed the GLP revision operators into structures of Boolean lattices, that allow us to bring to light some potential weaknesses in the adapted AGM postulates. To illustrate our claim, we introduce and characterize axiomatically two specific classes of (rational) GLP revision operators which arguably have a drastic behavior. We additionally consider two more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) and the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators.", "histories": [["v1", "Tue, 30 Jun 2015 02:09:02 GMT  (83kb)", "http://arxiv.org/abs/1506.08919v1", "42 pages, 5 figures, to appear in Theory and Practice of Logic Programming (accepted in June 2015)"]], "COMMENTS": "42 pages, 5 figures, to appear in Theory and Practice of Logic Programming (accepted in June 2015)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["nicolas schwind", "katsumi inoue"], "accepted": false, "id": "1506.08919"}, "pdf": {"name": "1506.08919.pdf", "metadata": {"source": "CRF", "title": "Characterization of Logic Program Revision as an Extension of Propositional Revision\u2217", "authors": ["Nicolas Schwind", "Katsumi Inoue"], "emails": ["schwind@nii.ac.jp", "inoue@nii.ac.jp"], "sections": [{"heading": null, "text": "ar Xiv: 150 6. \u0445 This is a revised and complete version (including Proofs of Proposals) of (Schwind and Inoue 2013).and the normal logic programs (NLPs) and adapts our characterization result to DLP and NLP revision operators."}, {"heading": "1 Introduction", "text": "In fact, most of them are able to determine for themselves how they have behaved."}, {"heading": "2 Belief revision in propositional logic", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Formal preliminaries", "text": "We consider a propositional language L defined by a finite set of propositional variables (also called atoms) A and the usual connectives. To avoid heavy expressions, an interpretation I is also considered a subset of atoms of A that are true in I. For example, if A = {p, q}, then the interpretation of A is such that I (p) = 1 and I (q) = 0 is also represented as the set {p}. For convenience, quantities are dropped within interpretations (except in the case where the interpretation is the empty set), e.g. the interpretation {p, q} is simply referred to as the set of all interpretations. An interpretation I is a model of a formula called L if the empty set is) when the interpretation {p, q} is simply referred to as pq."}, {"heading": "2.2 Propositional revision operators", "text": "We begin with the introduction of a revision operator as a simple function that takes into account two formulas (the original formula and the new one) and returns the revised formula: Definition 1 (Propositional revision operator, equivalence between operators) A (Propositional) revision operator is a mapping that associates two formulas to each other, with a new formula named after a new formula named after a new formula. Two revision operators are called equivalent if they apply equally to all formulas. (Propositional) Revision operator is a mapping that associates two formulas to each other. The AGM framework (Alchourro) describes the standard principles for revision of belief (e.g. consistency maintenance and minimality of change) that capture changes occurring in a static domain. Katsuno and Mendelzon (1991) equally reformulate the AGM postulates as follows: Definition 2 (Revision operator)."}, {"heading": "3 Belief revision in Logic Programming", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Preliminaries on Logic Programming", "text": "We define the syntax and semantics of generalized logic programs. We use the same notations as in (S) q = q q = q q (S). A generalized logic program (GLP) is a finite series of rules of Forma1;.; ak; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; p; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P; P"}, {"heading": "3.2 Logic program revision operators", "text": "We now consider a revision in the context of logic programs. (D) Q = Q = Q = Q Q Q = Q Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q ="}, {"heading": "4 Characterization of GLP revision operators", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1 Characterization result", "text": "That is, we show that any GLP revision operator (i.e., any LP revision operator meeting the postulates (RA1-RA6) can be characterized with respect to all classical interpretations in such a way that P, Q, and all interpretations P, Y, and all the following conditions apply to all GLP interpretations: (1) If Y and Y are a faithful mapping associated with each GLP P P a complete preorder, (2) If Y and Y are associated with a complete preorder, (2) If Y and Y are associated with a complete preorder, (2) If Y and Y are associated with a complete preorder, (2) If Y and Y < (3) If we have a closed relationship, then Y and Y."}, {"heading": "4.2 Comparison with other existing works", "text": "As we mentioned briefly in the introduction, Delgrande et al. (2013a) have proposed a constructive characterization of faith revision operators for logic programs that fulfill the entire set of postulates (RA1 - RA6). They have considered different forms of logic programs, i.e., they have only a generalized, disjunctive, positive, and horn, so that we will now compare our characterization with the characterization given in (Delgrande et al.) if each GLP overall has a preposition for the case of GLP 16 (GLP-compliant) faithful assignment (Delgrande et al.). A GLP-compliant faithful assignment is an assignment that associates each GLP constellation with a complete preorder."}, {"heading": "5 GLP revision operators embedded into Boolean lattices", "text": "We can find that the GLP revision operators, if we form a specific GLP revision operator, which is a specific KM revision operator, a partition of the class of all GLP revision operators, a potential revision operator. We define the binary relationship between the GLP revision operators, if the GLP revision operators, which have a clear answer to the GLP operators, define it as follows: for all GLP revision operators, f1, f1, f2, f2, f2, f2, and only for each interpretation Y operators, we have f2 (Y).You can see that for each revision operator, the GLP operators, the GLP revision operators, the GLP revision operators, the GLP revision operators, the GLP revision operators, the GLP revision operators, the GLP revision operators, the GLP operators, the GLP operators, the Latef2, and only for each interpretation Y and for each interpretation."}, {"heading": "6 The case of disjunctive and normal logic programs", "text": "In this section we will take a look at more restrictive forms of programs, i.e., the disjunctive logic programs and the normal logic programs. A disjunctive logic program (DLP) is a normal logic program (NLP), in which the rules of forma1 apply;..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "7 Conclusion", "text": "In this paper, we followed some previous work on the revision of logic programs, where the approach adopted is based on a monotonous characterization of logic programs with SE interpretations. We paid particular attention to the revision of generalized logic programs (GLPs) and characterized the class of rational GLP revision operators in terms of the total order of classical interpretations with some additional specific conditions for the interpretation of SE. The constructive characterization we provided facilitates understanding of the semantic properties of GLP revision operators by providing a clear, complete picture of them. Interestingly, we showed that a GLP revision operator can be considered an extension of a rational propositional revision operator. Each propositional revision operator corresponds to a specific subclass of GLP revision operators, and a GLP revision operator can be independent."}, {"heading": "Appendix: Proofs of Propositions", "text": "Sentence 1 There is a 1: 1 correspondence between the KM audit operators and the entirety of all faithful orders."}, {"heading": "Proof", "text": "Let us assume that there are two formulas, so that there are two formulas, so that either \"1\" or \"2\" or \"2,\" that is \"6\" or \"2,\" let us assume that there are two formulas, namely \"1\" or \"2,\" which means that there are two formulas, namely \"1\" or \"2.\" < < < < < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > < < < < < < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > < < < < < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > < > > > > > > > > > > > > > > > < > > > > > > > > > > > > > > > > > > > > > > > > > > > > < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > < > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > >"}, {"heading": "Proof", "text": "(RA5 - RA6) Let P, Q, R be three GLPs. If (P-DQ) + R is not consistent, then (RA5) is trivially fulfilled, so let us assume that (P-D Q) + R is consistent. Since (P-D Q) + R is consistent, we must show that (P-D Q) + R is consistent, that P + Q (Q-R) + R is consistent, then P + Q + R is consistent, so by definition we get P-D (Q + R) = P + Q + R. Therefore, (P-D Q) + R is consistent when (P-R) is consistent and P-R interpretation when (P-D) is not consistent."}, {"heading": "Proof", "text": "(Only if part) In this proof we have for each well defined set of SE interpretations S, lp (S) all GLP P so that SE (P) = S. To mitigate notations if S is of the form (Y), (Y), Y (2))) for some interpretations E, we write lp (E) instead of lp (S). (For example, lp (Y), (Y), (Y (2), Y (2)))))) simply from lp (Y (Y), Y (Y) (Y), Y (Y) (Y), Y (Y), P (2). (P) The proof uses in several cases the following remarks: Remark 2 If it is an LP that meets the postulates (RA5) and (RA6), then for all GLPs P P P P P, Q) + R that are consistent."}, {"heading": "Proof", "text": "We must show that Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q))) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P) P (P) P (P) P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P (P) P) P (S (S) P (P) P) P (P) P (P) P (P) P) P (P) P (P) P) P (P) P) P (S (S (S) P) P) P (S (P) P) P) P (S (S (P) P) P) P S (P) P) P (P) P) P (P) P (P) P) P (P) P (P) P) P (P) P (P) P (P) P) P S (S (S (S (P) P) P) P) P (S (P) P) P (P) P) P (P) P (P S (S (S (P) P) P) P S (P) P (S (S (S (P) P) P S (P) P) P) P (S (S (P) P) P) P (S (S (P) P"}, {"heading": "Proof", "text": "(If part) Obvious by Definition 15. (Only if part) Let us first of all assume that there are two propositional formulas, namely those that look as if there are two propositional formulas, so that these two propositional formulas, so that these two propositional formulas, so that these two propositional formulas, so that these propositional formulas, so that these two propositional formulas, so that these two propositional formulas, so that these two propositional formulas formulas, so that these two propositional formulas formulas formulas, so that these two propositional formulas formulas formulas formulas formulas, formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formulas formations formulas formulas formulas formulas formulas formulas formations formations formulas formulas formulas formulas formations formations formulas formulas formulas formulas formulas formations formations formulas formations formations formulas formulas formulas formations formations formations formations formulas formulas formulas formations formations formations formations formulas formations formations formulas formations formations formulas formations formations formations formations formations formations formations formations formations formations form"}, {"heading": "Proof", "text": "In this evidence, we assume for each well-defined group of SE interpretations that Y (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) = S. Let (P) P (P) GLPpart and P) GLP (Y) faith. We must show that (S) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) and P (P) faith are fulfilled if and only if for all GLP P P P, Q) we min (SE (Q), P) P (X), X (X), Y (X), Y) faith (X), Y (X), Y (X), Y)."}, {"heading": "Proof", "text": "Let us be a KM revision operator and for each interpretation Y we have f2 (Y) f1 (Y) f1 (Y) f1 (Y) Q + Q (Q). Let P, Q be two GLPs in such a way that P + Q is inconsistent (the case where P + Q is consistent). We must show that Y-AS (P-2 Q) is consistent. We have (Y, Y) such an interpretation SE (P-1 Q) and for each X (X, Y) / SE (P-2) such an interpretation Y."}, {"heading": "Proof", "text": "Let us first show that for all GLPs P, Q so that P + Q is inconsistent, we have AS (P + Q). Let P, Q so that P are two GLPs so that P + Q is inconsistent. Let Y so, AS (P) AS (P) AS (P) AS (P) AS (P) S so that Y + Q (Q) is uneven. Let Y so, AS (P) S so, AS (Y) S so, AS (Y) so, AS (Y) S so, AS (X, Y) S so, AS (S). But f (Y) f (P) = 2Y (Y) so, S so."}, {"heading": "Proof", "text": "First, let us show that for all GLPs P, Q is inconsistent P + Q, that for each interpretation we have Y, f (Y) = {Y}. Let P, Q be inconsistent P + Q. For each interpretation Y and each X (Y, X) f (Y) f (Y), that is, from definition 15 for each interpretation Y, we have Y (P) AS (P) B Q), if and only if (Y) SE (P) (P) is no interpretation Y (P), if and only if Y | = definition f (Y) f (P) f exists."}, {"heading": "Proof", "text": "So let's assume that I | = Celsius Celsius Celsius. Then, to determine whether I | = Celsius Celsius Celsius can be tested in polynomial time (the answer is \"yes\" in the former case, \"no\" in the latter). So let's assume that I | = Celsius Celsius Celsius Celsius Celsius Celsius Celsius. We prove coNP hardness by showing a polynomial reduction of the dissatisfaction problem. Let's consider a meaningful formula \u03b1 over a set of statement variables A, and combine it in polynomial time: \u2022 the formulas \u03c6 (new, new) so that we get a uniform vision, so that we find a uniform solution to the dissatisfaction problem. Let's consider a meaningful formula \u03b1 over a set of statement variables A, and associate it with it in polynomial time: \u2022 the formulas \u03c6 (new, new) so uniform we are (new, new) so uniform we are (new, new)."}, {"heading": "Proof", "text": "We show that any skeptical GLP-based revision operator, i.e., that SE (P + S Q) is a complete set of SE interpretations. This is trivial if P + Q is consistent, because in this case P + Q = P + Q and expansion preserves the completeness of SE models, i.e., assume that P + Q is inconsistent. Let X, Y, Z s.t. Y'Z, (X, Y), (Z), SE (P, f Q), and let us show that (X, Z), (P) a full LP-based revision operator, i.e. a propositional LP-based LP-revision operator, we know that (X, Y), (Z, Z), P-revision operator, i.e. a DLP-based LP-revision operator, i.e. a propositional LP-based LP-operator, we know that P, i.e. a propositional LP-based P, i.e. a propositional LP-based P, we know that P-based P, i.e. a propositional LP-based LP, i.e. a propositional LP-based P, we know that P-based LP, i.e. a propositional LP-based LP-based LP, i.e."}, {"heading": "Proof", "text": "Let us first check the representation of DLP revisions (X, Z) which we (X, Z, Z, Z, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S,"}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourr\u00f3n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "Journal of Symbolic Logic 50, 2, 510\u2013530.", "citeRegEx": "Alchourr\u00f3n et al\\.,? 1985", "shortCiteRegEx": "Alchourr\u00f3n et al\\.", "year": 1985}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["J.J. Alferes", "J.A. Leite", "L.M. Pereira", "H. Przymusinska", "T.C. Przymusinski"], "venue": "Journal of Logic Programming 45, 1-3, 43\u201370.", "citeRegEx": "Alferes et al\\.,? 2000", "shortCiteRegEx": "Alferes et al\\.", "year": 2000}, {"title": "Propositional theories are strongly equivalent to logic programs", "author": ["P. Cabalar", "P. Ferraris"], "venue": "Theory and Practice of Logic Programming 7, 6.", "citeRegEx": "Cabalar and Ferraris,? 2007", "shortCiteRegEx": "Cabalar and Ferraris", "year": 2007}, {"title": "Investigations into a theory of knowledge base revision: preliminary report", "author": ["M. Dalal"], "venue": "Proceedings of the 7th National Conference on Artificial Intelligence (AAAI\u201988). 475\u2013479.", "citeRegEx": "Dalal,? 1988", "shortCiteRegEx": "Dalal", "year": 1988}, {"title": "AGM-style belief revision of logic programs under answer set semantics", "author": ["J.P. Delgrande", "P. Peppas", "S. Woltran"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913). 264\u2013 276.", "citeRegEx": "Delgrande et al\\.,? 2013a", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "A preference-based framework for updating logic programs", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907). 71\u201383.", "citeRegEx": "Delgrande et al\\.,? 2007", "shortCiteRegEx": "Delgrande et al\\.", "year": 2007}, {"title": "Belief revision of logic programs under answer set semantics", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201908). 411\u2013 421.", "citeRegEx": "Delgrande et al\\.,? 2008", "shortCiteRegEx": "Delgrande et al\\.", "year": 2008}, {"title": "Merging logic programs under answer set semantics", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 25th International Conference on Logic Programming (ICLP\u201909). 160\u2013174.", "citeRegEx": "Delgrande et al\\.,? 2009", "shortCiteRegEx": "Delgrande et al\\.", "year": 2009}, {"title": "A modeltheoretic approach to belief change in answer set programming", "author": ["J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "ACM Transactions on Computational Logic 14, 2, 1\u201346.", "citeRegEx": "Delgrande et al\\.,? 2013b", "shortCiteRegEx": "Delgrande et al\\.", "year": 2013}, {"title": "On properties of update sequences based on causal rejection", "author": ["T. Eiter", "M. Fink", "G. Sabbatini", "H. Tompits"], "venue": "Theory and Practice of Logic Programming 2, 6, 711\u2013767.", "citeRegEx": "Eiter et al\\.,? 2002", "shortCiteRegEx": "Eiter et al\\.", "year": 2002}, {"title": "On solution correspondences in answer set programming", "author": ["T. Eiter", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905). 97\u2013102.", "citeRegEx": "Eiter et al\\.,? 2005", "shortCiteRegEx": "Eiter et al\\.", "year": 2005}, {"title": "Negation as failure in the head", "author": ["K. Inoue", "C. Sakama"], "venue": "Journal of Logic Programming 35, 1, 39\u201378.", "citeRegEx": "Inoue and Sakama,? 1998", "shortCiteRegEx": "Inoue and Sakama", "year": 1998}, {"title": "A unified view of propositional knowledge base updates", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Proceedings of the 11th International Joint Conference on Artificial Intelligence (IJCAI\u201989). 1413\u20131419.", "citeRegEx": "Katsuno and Mendelzon,? 1989", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1989}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR\u201991). 387\u2013394.", "citeRegEx": "Katsuno and Mendelzon,? 1991", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1991}, {"title": "Propositional knowledge base revision and minimal change", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Artificial Intelligence 52, 3, 263\u2013294.", "citeRegEx": "Katsuno and Mendelzon,? 1992", "shortCiteRegEx": "Katsuno and Mendelzon", "year": 1992}, {"title": "Merging information under constraints: a logical framework", "author": ["S. Konieczny", "R. Pino P\u00e9rez"], "venue": "Journal of Logic and Computation 12, 5, 773\u2013808.", "citeRegEx": "Konieczny and P\u00e9rez,? 2002", "shortCiteRegEx": "Konieczny and P\u00e9rez", "year": 2002}, {"title": "Belief revision and update: Complexity of model checking", "author": ["P. Liberatore", "M. Schaerf"], "venue": "Journal of Computer and System Sciences 62, 1, 43\u201372.", "citeRegEx": "Liberatore and Schaerf,? 2001", "shortCiteRegEx": "Liberatore and Schaerf", "year": 2001}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic 2, 4, 526\u2013541.", "citeRegEx": "Lifschitz et al\\.,? 2001", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "Computational complexity", "author": ["C.M. Papadimitriou"], "venue": "Addison-Wesley, Reading, Massachusetts.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "An abductive framework for computing knowledge base updates", "author": ["C. Sakama", "K. Inoue"], "venue": "Theory and Practice of Logic Programming 3, 6, 671\u2013713.", "citeRegEx": "Sakama and Inoue,? 2003", "shortCiteRegEx": "Sakama and Inoue", "year": 2003}, {"title": "Nonmonotonic reasoning by minimal belief revision", "author": ["K. Satoh"], "venue": "Proceedings of FGCS\u201988. 455\u2013462.", "citeRegEx": "Satoh,? 1988", "shortCiteRegEx": "Satoh", "year": 1988}, {"title": "Characterization theorems for revision of logic programs", "author": ["N. Schwind", "K. Inoue"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913). 485\u2013498.", "citeRegEx": "Schwind and Inoue,? 2013", "shortCiteRegEx": "Schwind and Inoue", "year": 2013}, {"title": "On semantic update operators for answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 19th European Conference on Artificial Intelligence (ECAI\u201910). 957\u2013962.", "citeRegEx": "Slota and Leite,? 2010", "shortCiteRegEx": "Slota and Leite", "year": 2010}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201912). 156\u2013168.", "citeRegEx": "Slota and Leite,? 2012", "shortCiteRegEx": "Slota and Leite", "year": 2012}, {"title": "The rise and fall of semantic rule updates based on SE-models", "author": ["M. Slota", "J. Leite"], "venue": "CoRR abs/1306.3884.", "citeRegEx": "Slota and Leite,? 2013", "shortCiteRegEx": "Slota and Leite", "year": 2013}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["H. Turner"], "venue": "Theory and Practice of Logic Programming 3, 4-5, 609\u2013622.", "citeRegEx": "Turner,? 2003", "shortCiteRegEx": "Turner", "year": 2003}, {"title": "Logic program-based updates", "author": ["Y. Zhang"], "venue": "ACM Transactions on Computational Logic 7, 3, 421\u2013472.", "citeRegEx": "Zhang,? 2006", "shortCiteRegEx": "Zhang", "year": 2006}, {"title": "Towards generalized rule-based updates", "author": ["Y. Zhang", "N.Y. Foo"], "venue": "Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI\u201997). 82\u201388.", "citeRegEx": "Zhang and Foo,? 1997", "shortCiteRegEx": "Zhang and Foo", "year": 1997}], "referenceMentions": [{"referenceID": 4, "context": "Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision.", "startOffset": 46, "endOffset": 121}, {"referenceID": 21, "context": "\u2217 This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013).", "startOffset": 75, "endOffset": 99}, {"referenceID": 13, "context": ", revision and update (Katsuno and Mendelzon 1991), and characterized axiomatically each one of these change operations by a set of socalled KM postulates.", "startOffset": 22, "endOffset": 50}, {"referenceID": 27, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 1, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 9, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 19, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 26, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 5, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.", "startOffset": 98, "endOffset": 216}, {"referenceID": 9, "context": "Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002).", "startOffset": 113, "endOffset": 132}, {"referenceID": 17, "context": "Initially, SE models were used to characterize the strong equivalence between logic programs (Lifschitz et al. 2001): precisely, two LPs have the same set of SE models if and only if they are strongly equivalent, that is to say, they admit the same answer sets, and will still do even after adding any arbitrary set of rules to them.", "startOffset": 93, "endOffset": 116}, {"referenceID": 4, "context": "Katsuno and Mendelzon (1992) adapted these principles to the case of propositional logic, distinguished two kind of change operations, i.", "startOffset": 0, "endOffset": 29}, {"referenceID": 1, "context": "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence. Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002). However, the notion of SE models introduced by Turner (2003) provided a monotonic semantical characterization of LPs, which is more expressive than the answer set semantics.", "startOffset": 119, "endOffset": 502}, {"referenceID": 11, "context": "In this paper, we give a particular consideration to the revision of generalized logic programs (GLPs) (Inoue and Sakama 1998) which are of very general form.", "startOffset": 103, "endOffset": 126}, {"referenceID": 14, "context": "Interestingly, the first one, called here LP faithful assignment, is similar to the structure of faithful assignment defined in (Katsuno and Mendelzon 1992) and used to characterize the (rational) KM revision operators in the propositional setting; the second one, called here well-defined assignment, can be defined independently from the first one.", "startOffset": 128, "endOffset": 156}, {"referenceID": 4, "context": "We formally compare our characterization result with another recent one proposed in (Delgrande et al. 2013a); the benefit of our approach is that our construction is one-to-one, as opposite to Delgrande et al.", "startOffset": 84, "endOffset": 108}, {"referenceID": 21, "context": "This version of the paper is a revised and extended version of a published LPNMR\u201913 paper (Schwind and Inoue 2013).", "startOffset": 90, "endOffset": 114}, {"referenceID": 4, "context": "The main extensions include a comparison of our main characterization result with the one proposed in (Delgrande et al. 2013a), some complexity results, characterization results for DLP and NLP revision operators and the proofs of propositions.", "startOffset": 102, "endOffset": 126}, {"referenceID": 0, "context": "The AGM framework (Alchourr\u00f3n et al. 1985) describes the standard principles for belief revision (e.", "startOffset": 18, "endOffset": 42}, {"referenceID": 0, "context": "The AGM framework (Alchourr\u00f3n et al. 1985) describes the standard principles for belief revision (e.g., consistency preservation and minimality of change), which capture changes occuring in a static domain. Katsuno and Mendelzon (1991) equivalently rephrased the AGM postulates as follows:", "startOffset": 19, "endOffset": 236}, {"referenceID": 13, "context": "Indeed, each KM revision operator is associated with some faithful assignment (Katsuno and Mendelzon 1991).", "startOffset": 78, "endOffset": 106}, {"referenceID": 3, "context": "KM revision operators include the class of distance-based revision operators (see, for instance, (Dalal 1988)), i.", "startOffset": 97, "endOffset": 109}, {"referenceID": 0, "context": "This operator was first introduced in (Alchourr\u00f3n et al. 1985) under the name of full meet revision function.", "startOffset": 38, "endOffset": 62}, {"referenceID": 0, "context": ", all AGM postulates in (Alchourr\u00f3n et al. 1985)), it is often considered as unreasonable because it throws away all the old beliefs if the new formula is inconsistent with them.", "startOffset": 24, "endOffset": 48}, {"referenceID": 3, "context": "Likewise, the revision operator based on Hamming distance dH is equivalent to the well-known Dalal revision operator (Dalal 1988).", "startOffset": 117, "endOffset": 129}, {"referenceID": 3, "context": "In fact, in (Dalal 1988) the Dalal revision is also defined in a modelwise fashion, i.", "startOffset": 12, "endOffset": 24}, {"referenceID": 6, "context": "We use the same notations as in (Delgrande et al. 2008).", "startOffset": 32, "endOffset": 55}, {"referenceID": 25, "context": "SE interpretations are semantic structures characterizing strong equivalence between logic programs (Turner 2003), they provide a monotonic semantic foundation of logic programs under answer set semantics.", "startOffset": 100, "endOffset": 113}, {"referenceID": 10, "context": "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 96, "endOffset": 142}, {"referenceID": 2, "context": "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 96, "endOffset": 142}, {"referenceID": 6, "context": "Definition 7 (Expansion operator (Delgrande et al. 2008)) Given two programs P ,Q, the expansion of P by Q, denoted P+Q is any program R such that SE(R) = SE(P) \u2229 SE(Q).", "startOffset": 33, "endOffset": 56}, {"referenceID": 8, "context": "We refer the reader to (Delgrande et al. 2013b), Section 3.", "startOffset": 23, "endOffset": 47}, {"referenceID": 6, "context": "Definition 9 (GLP revision operator (Delgrande et al. 2008)) A GLP revision operator \u22c6 is an LP revision operator that satisfies the following postulates, for all GLPs P ,P1,P2,Q,Q1,Q2,R:", "startOffset": 36, "endOffset": 59}, {"referenceID": 20, "context": "(2008) proposed a revision operator inspired from Satoh\u2019s propositional revision operator (Satoh 1988).", "startOffset": 90, "endOffset": 102}, {"referenceID": 12, "context": "Though it seems to have a good behavior on some instances, this operator does not satisfy (RA6), so that it does not fully respect the principle of minimality of change (see (Katsuno and Mendelzon 1989), Section 3.", "startOffset": 174, "endOffset": 202}, {"referenceID": 8, "context": "However, the whole set of postulates is consistent, as they later introduce the so-called cardinality-based revision operator (Delgrande et al. 2013b) that reduces to the Dalal revision scheme over propositional models and that satisfies all the postulates (RA1 - RA6).", "startOffset": 126, "endOffset": 150}, {"referenceID": 8, "context": "The following definition is a concise, equivalent reformulation of the original one introduced in (Delgrande et al. 2013b), Definition 3.", "startOffset": 98, "endOffset": 122}, {"referenceID": 3, "context": "Delgrande et al. (2008) proposed a revision operator inspired from Satoh\u2019s propositional revision operator (Satoh 1988).", "startOffset": 0, "endOffset": 24}, {"referenceID": 8, "context": "Theorem 2 (Delgrande et al. 2013b) \u22c6c is a GLP revision operator.", "startOffset": 10, "endOffset": 34}, {"referenceID": 4, "context": ", generalized, disjunctive, normal, positive, and Horn, so we shall now compare our characterization with the one given in (Delgrande et al. 2013a) for the case of GLPs:", "startOffset": 123, "endOffset": 147}, {"referenceID": 4, "context": "As we already briefly mentionned in the introduction, Delgrande et al. (2013a) also recently proposed a constructive characterization of belief revision operators for logic programs that satisfy the whole set of postulates (RA1 - RA6).", "startOffset": 54, "endOffset": 79}, {"referenceID": 4, "context": "Definition 16 (GLP compliant faithful assignment (Delgrande et al. 2013a)) A GLP compliant faithful assignment is a mapping which associates every GLP P with a total preorder \u2264P over SE interpretations such that for all GLPs P ,Q and all SE interpretations (X ,Y ), (X ,Y ), the following conditions hold:", "startOffset": 49, "endOffset": 73}, {"referenceID": 4, "context": "The following theorem is expressed as a combination of Theorems 4 and 5 from (Delgrande et al. 2013a) applied to GLPs:", "startOffset": 77, "endOffset": 101}, {"referenceID": 4, "context": "Theorem 3 (Delgrande et al. 2013a) An LP revision operator \u22c6 is a GLP revision operator (i.", "startOffset": 10, "endOffset": 34}, {"referenceID": 4, "context": "2 In (Delgrande et al. 2013a), an additional postulate is considered in the characterization theorems, namely (Acyc).", "startOffset": 5, "endOffset": 29}, {"referenceID": 4, "context": "(Delgrande et al. 2013a), Theorem 2).", "startOffset": 0, "endOffset": 24}, {"referenceID": 18, "context": "We assume that the reader is familiar with the basic concepts of computational complexity, in particular with the classes P, NP and coNP (see (Papadimitriou 1994) for more details).", "startOffset": 142, "endOffset": 162}, {"referenceID": 16, "context": "We focus here on the the model-checking problem (Liberatore and Schaerf 2001) for LP revision operators.", "startOffset": 48, "endOffset": 77}, {"referenceID": 10, "context": "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 171, "endOffset": 217}, {"referenceID": 2, "context": "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).", "startOffset": 171, "endOffset": 217}, {"referenceID": 24, "context": ", dynamic support and fact update (see (Slota and Leite 2013) for more details).", "startOffset": 39, "endOffset": 61}, {"referenceID": 22, "context": "As to the case of update of logic programs Slota and Leite (2013) argued that semantic rule updates based on SE models seem to be inappropriate.", "startOffset": 43, "endOffset": 66}, {"referenceID": 23, "context": "In (Slota and Leite 2012) the same authors successfully reconciliate semantic-based and syntax-based approaches to updating logic programs: they considered different characterizations of logic programs in terms of RE models (standing for robust equivalence models) that proved to be a more suitable semantic fundation for rule updates than SE models.", "startOffset": 3, "endOffset": 25}], "year": 2015, "abstractText": "We address the problem of belief revision of logic programs, i.e., how to incorporate to a logic program P a new logic program Q. Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision. They identified the rational behavior of LP revision and introduced some specific operators. In this paper, a constructive characterization of all rational LP revision operators is given in terms of orderings over propositional interpretations with some further conditions specific to SE interpretations. It provides an intuitive, complete procedure for the construction of all rational LP revision operators and makes easier the comprehension of their semantic and computational properties. We give a particular consideration to logic programs of very general form, i.e., the generalized logic programs (GLPs). We show that every rational GLP revision operator is derived from a propositional revision operator satisfying the original AGM postulates. Interestingly, the further conditions specific to GLP revision are independent from the propositional revision operator on which a GLP revision operator is based. Taking advantage of our characterization result, we embed the GLP revision operators into structures of Boolean lattices, that allow us to bring to light some potential weaknesses in the adapted AGM postulates. To illustrate our claim, we introduce and characterize axiomatically two specific classes of (rational) GLP revision operators which arguably have a drastic behavior. We additionally consider two more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) \u2217 This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013). 2 N. Schwind and K. Inoue and the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators.", "creator": "LaTeX with hyperref package"}}}