{"id": "1508.03856", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Aug-2015", "title": "Two-stage Cascaded Classifier for Purchase Prediction", "abstract": "In this paper we describe our machine learning solution for the RecSys Challenge, 2015. We have proposed a time efficient two-stage cascaded classifier for the prediction of buy sessions and purchased items within such sessions. Based on the model, several interesting features found, and formation of our own test bed, we have achieved a reasonable score. Usage of Random Forests helps us to cope with the effect of the multiplicity of good models depending on varying subsets of features in the purchased items prediction and, in its turn, boosting is used as a suitable technique to overcome severe class imbalance of the buy-session prediction.", "histories": [["v1", "Sun, 16 Aug 2015 19:27:35 GMT  (28kb)", "http://arxiv.org/abs/1508.03856v1", null]], "reviews": [], "SUBJECTS": "cs.IR cs.LG", "authors": ["sheikh muhammad sarwar", "mahamudul hasan", "dmitry i ignatov"], "accepted": false, "id": "1508.03856"}, "pdf": {"name": "1508.03856.pdf", "metadata": {"source": "CRF", "title": "Two-stage Cascaded Classifier for Purchase Prediction", "authors": ["Sheikh Muhammad Sarwar", "Dmitry I. Ignatov"], "emails": ["smsarwar@du.ac.bd", "munna09bd@gmail.com", "dignatov@hse.ru", "permissions@acm.org."], "sections": [{"heading": null, "text": "ar Xiv: 150 8.03 856v 1 [cs.I R] 16 Aug 201 5Categories and Subject Descriptions H.3.3 [Information Storage and Retrieval]: Information Filtering; 1.2.6 [Artificial Intelligence]: LearningKeywords Supervised learning, class imbalance, e-commerce"}, {"heading": "1. INTRODUCTION", "text": "For us, the most difficult part of the competition is the classic problem of machine learning, the class imbalance [?]. The task of the challenge is to predict \"purchase sessions\" from a large number of sessions. Each session contains the click data of several anonymous users. However, only 5% of the training data consists of purchase sessions, which is actually half a million out of 9.3 million sessions. So, if we look at two classes (buy and not buy), a serious class imbalance problem occurs. Apart from predicting the purchase sessions, the combat organizers also want to know which items would be purchased from a purchase session. To answer these two questions, we have developed two models of machine learning, in which one model is able to select the purchase sessions and the other finds the related items. To find purchase sessions and solve the class imbalance problem, we use permission to distribute digital or paper copies of all or part of this work for the benefit of the personal or classroom use, and not to grant permission to copy or copy copies of all or part of this work to the ACit for the benefit of the user."}, {"heading": "2. PROBLEM STATEMENT", "text": "RecSys Challenge 2015 provides a record that contains the clickstream data of multiple users of an e-commerce site over a six-month period. There are two types of sessions Sb (the sessions that end with the purchase) and Snb (the sessions that do not end with the purchase) as follows: Sb = [s] S: Bs 6 = [s] and Snb = S\\ Sb. The test data also includes a series of sessions St and St [s] S: Given the sessions St, our task is to find all sessions Stb'St that have at least one buying event. In addition, if a session contains s, we must predict a buying event, the amount of sessions Bs that were purchased. The final solution should include sessions Sl and the amount of sessions Sl."}, {"heading": "2.1 Observation about the Scoring Function", "text": "According to the description of the challenge, the purchase event occurs only in 5% of sessions, and therefore we can assume that the penalty for predicting false sessions is only 0.05. On the other hand, it is possible to achieve a value of 1.05 for predicting a correct session, and consequently the strategy should be to identify most sessions as purchase sessions. However, there is a limitation on the size of the solution file (< 25MB), and therefore an appropriate level of precision should be achieved in selecting the resulting sittings.2.2 Data DescriptionThe task contains three data files: click file, purchase file, and test file. The click file contains all click sessions (Sc) and some information about the elements clicked in these sittings.2.2 Data Description The purchase file contains a series of sessions (Sb) in which at least one item was purchased. The click file contains a set of {Item file} in the form of the file type {Item file in the category \"Item file\""}, {"heading": "3. DATA PREPROCESSING", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Resolving Missing Category Information", "text": "First, we extract several properties of items and assign category numbers to items with unknown category 0 (almost half of the session data belongs to this category). In fact, the data was collected over a six-month period - from April to September, where most category information appeared after mid-June. We assume that the e-commerce site could not provide category data for this period. However, since an item occurred repeatedly in different sessions, it is possible to restore the category for most items based on the data from June to September. When resolving the category, we try to restore regular category only, i.e. we do not use a specific category. However, our analysis showed that an item belongs to several categories. Nevertheless, we want to find a specific category for a particular item. Therefore, we resolve the article categories according to the following rule: If an item belongs to several categories, the actual category is the most common category in the click data. After resolving the categories, we add the original category attribute to each click data."}, {"heading": "3.2 Performing Temporal Ordering", "text": "First, we sort both the click file and the purchase file with sessionId, which has a specific advantage that we will discuss later. Then, for each of the sessions associated with the files, we sort the session data by timestamp. In this way, we find the chronological order of the user's clicks on the elements in a session. In addition, the duration of a click can be easily determined by simply subtracting the time of that click from the time of the next click. Now, when we add up the duration of the clicks in which the element appears for each individual element in a session, we define the duration of the element in that session. After we sort by timestamp, we append itemDuration (the time in which an element in a session is checked) to each click data."}, {"heading": "3.3 Extraction of Item Properties", "text": "The features are listed in Table 2. Initially, we tried to solve the problem only with the click-to-buy ratio, achieving a score of 29000. In this process, we determined the click-to-buy ratio of all items in a session, and when the average was above the 5.5 threshold, we identified that session as a buy. Afterwards, we selected half of the items by sorting by the click-to-buy ratio. With this simple approach, we understood that we needed to build features that use this valuable statistic to develop our machine learning solution."}, {"heading": "3.4 Development of an Alternative Testbed", "text": "We have developed a complete framework in Java for performing the task, which includes the development of our own test bed. Developing our own independent test bed is critical, as there are only three chances that the task will be submitted within 24 hours. To do this, we place each purchase session from all sessions in our click data Sc into a file clickBuy (click sessions ended in purchase) and all non-purchase sessions are placed in the file onlyClick (click sessions did not end in purchase). We sort all click sessions in advance by sessionId and finally divide them (within O (Sc | log | Sc |)). After the columns, we randomly include half of the sessions in the file clickBuy to create our local test kit and solution file; the remaining half of the data from the file clickBuy remains for training our model and its evaluation in our own test. Finally, we add a quarter of the sessions from the single click data in the new test file to our own file, and add the remaining half of the new test data from our own file to our own file, whereby 234Buy will be able to use the remaining half of the school data in our own file."}, {"heading": "4. PROPOSED SOLUTION", "text": "The task is intuitively divided into two sub-tasks: predicting the outcome of a session and a session to predict the set of elements that should be purchased in that session. So we construct two classifiers to address these two sub-tasks. However, first, we thought of building a single classifier that would extract traits from the elements of the training data, and given the elements of a session in test data, it should classify the element as Buy or Not Buy. Unfortunately, we have to deal with large trait data in this process. If we look at Table 3, it becomes clear that developing only an item-based classifier would require creating a model for 1049817 elements labeled as Buy and 25565682 as Not Buy. To create this amount of data, building a complex classifier would require an enormous amount of computing time. Therefore, we first predict the sessions that would end with Buy, and then look for the future purchased elements: So we have to develop these classifications in two."}, {"heading": "4.1 Item Classifier", "text": "An important observation with respect to the classifier is that we only need to train the classifier on the basis of the click data of the purchase sessions in the training data. A click data of a purchase session includes a number of items that were purchased (Bs) and a number of items that were not purchased (Aces). Now, for each item, we extract i-Bs from both session-based and item-based characteristics. We then label this item as a purchase and each product i-Bs as a non-purchase. By looking only at the purchase sessions, we obtain 1049817 purchased items and 1264870 unpurchased items. As a result, the class imbalance is less stressed and the classifier needs to be trained with a total of only 215053 data, resulting in a short training period. As we have received our own test bed (see Section 3.4), we have our local solution file that we can use to verify the performance of our method."}, {"heading": "4.2 Session Classifier", "text": "We have 509696 sessions and 8740001 do not buy onesin the training data. Instead of looking at the function of the items, we look at the characteristics of the sessions. There are important observations for building the session classic: 1) To address the problems we have in selecting the sessions with AdaBoost.M1 algorithm, there is an imbalance in the class that leads to most sessions that are not purchased. To address the problems, we need to select the sessions with AdaBoost.M1 algorithm. AdaboostM1 comes as a replacement for the imbalance in the class."}, {"heading": "5. CONCLUSIONS", "text": "The use of a cascade of two different classifiers is beneficial when experiencing a severe imbalance between buy and non-buy sessions and a variety of good feature subsets. Furthermore, learning and classification phases for this subtask decomposition are relatively short. We have no doubt that further adjustment of the model would definitely allow for a better score."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "In this paper we describe our machine learning solution for the RecSys Challenge 2015. We have proposed a timeefficient two-stage cascaded classifier for the prediction of buy sessions and purchased items within such sessions. Based on the model, several interesting features found, and formation of our own test bed, we have achieved a reasonable score. Usage of Random Forests helps us to cope with the effect of the multiplicity of good models depending on varying subsets of features in the purchased items prediction and, in its turn, boosting is used as a suitable technique to overcome severe class imbalance of the buy-session prediction.", "creator": "LaTeX with hyperref package"}}}