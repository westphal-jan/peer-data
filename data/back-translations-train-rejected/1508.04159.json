{"id": "1508.04159", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Aug-2015", "title": "Reasoning in complex environments with the SelectScript declarative language", "abstract": "SelectScript is an extendable, adaptable, and declarative domain-specific language aimed at information retrieval from simulation environments and robotic world models in an SQL-like manner. In this work we have extended the language in two directions. First, we have implemented hierarchical queries; second, we improve efficiency enabling manual design space exploration on different \"search\" strategies. As depicted in the teaser above, we demonstrate the applicability of such extensions in two application problems; the basic language concepts are explained by solving the classical problem of the Towers of Hanoi and then a common path planning problem in a complex 3D environment is implemented.", "histories": [["v1", "Mon, 17 Aug 2015 21:26:39 GMT  (3475kb,D)", "http://arxiv.org/abs/1508.04159v1", "14 pages, 7 figures"], ["v2", "Sun, 4 Oct 2015 15:53:29 GMT  (1408kb,D)", "http://arxiv.org/abs/1508.04159v2", "15 pages, 7 figures, 6th International Workshop on Domain-Specific Languages and models for ROBotic systems (DSLRob-15)"]], "COMMENTS": "14 pages, 7 figures", "reviews": [], "SUBJECTS": "cs.PL cs.AI cs.DB cs.RO", "authors": ["andr\\'e dietrich", "sebastian zug", "luigi nardi", "j\\\"org kaiser"], "accepted": false, "id": "1508.04159"}, "pdf": {"name": "1508.04159.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "In this work, we have expanded the language in two directions: first, we have implemented hierarchical queries; second, we improve efficiency and allow manual exploration of the design space through various \"search strategies.\" As shown in the teaser above, we demonstrate the applicability of such extensions to two application problems; the basic language concepts are explained by solving the classic problem of the Towers of Hanoi and then a common route planning problem is implemented in a complex 3D environment."}, {"heading": "1. Introduction", "text": "In fact, most people are able to move to another world in which they are able to live, in which they want to live."}, {"heading": "2. Related Work", "text": "In fact, most of them are able to play by the rules that they have imposed on themselves, and they are able to play by the rules that they have imposed on themselves."}, {"heading": "3. Language Basics", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "4. DSL Extension", "text": "This year it is more than ever before in the history of the city."}, {"heading": "5. Appications", "text": "The following two sections are used to demonstrate the applicability of our approach to problem solving. Therefore, we choose the two examples already shown in the first figure. This figure shows that both are problems that cannot be solved by applying a concept, but are complex problems that occur in a complex environment."}, {"heading": "6. Summary & Outlook", "text": "We have introduced SelectScript, a new declarative embedded language (DSL), and demonstrated that it can run as an intermediate layer on various discrete simulation environments and world models that hide the discrepancies between different APIs. Furthermore, we have shown that accessing information with an SQL-like syntax is more \"natural\" and elegant than extracting the same information in the old way, i. e. The focus of this work is on expanding DSL to hide the complexity of applying strategies and methods."}, {"heading": "Acknowledgments", "text": "We acknowledge the funding provided by the EPSRC grant PAMELA EP / K008730 / 1."}], "references": [{"title": "Selectscript: A query language for robotic world models and simulations", "author": ["A. Dietrich", "S. Zug", "J. Kaiser"], "venue": "Proceedings of the IEEE International Conference on Robotics and Automation (ICRA). Seattle, Washington, 2015.  14  ANDR\u00c9 DIETRICH, SEBASTIAN ZUG, LUIGI NARDI, AND J\u00d6RG KAISER", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2015}, {"title": "Automated construction of robotic manipulation programs", "author": ["R. Diankov"], "venue": "Ph.D. dissertation, Carnegie Mellon University, Robotics Institute, 8 2010.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2010}, {"title": "YAO: A Software for Variational Data Assimilation Using Numerical Models.", "author": ["L. Nardi", "C. Sorror", "F. Badran", "S. Thiria"], "venue": "Computational Science and Its Applications - ICCSA 2009,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Firedrake: automating the finite element method by composing abstractions", "author": ["F. Rathgeber", "D.A. Ham", "L. Mitchell", "M. Lange", "F. Luporini", "A.T. McRae", "G.-T. Bercea", "G.R. Markall", "P.H. Kelly"], "venue": "Submitted to ACM TOMS, 2015.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Faust: an efficient functional approach to dsp programming", "author": ["Y. Orlarey", "D. Fober", "S. Letz"], "venue": "New Computational Paradigms for Computer Music, vol. 290, 2009.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines", "author": ["J. Ragan-Kelley", "C. Barnes", "A. Adams", "S. Paris", "F. Durand", "S. Amarasinghe"], "venue": "ACM SIGPLAN Notices, vol. 48, no. 6, pp. 519\u2013530, 2013.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "YAO: a generator of parallel code for variational data assimilation applications", "author": ["L. Nardi", "F. Badran", "P. Fortin", "S. Thiria"], "venue": "IEEE 14th International Conference on High Performance Computing and Communications, HPCC-2012, june 2012, pp. 224 \u2013232.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Pyop2: A high-level framework for performance-portable simulations on unstructured meshes", "author": ["F. Rathgeber", "G.R. Markall", "L. Mitchell", "N. Loriant", "D.A. Ham", "C. Bertolli", "P.H. Kelly"], "venue": "High Performance Computing, Networking Storage and Analysis, SC Companion:. Los Alamitos, CA, USA: IEEE Computer Society, 2012, pp. 1116\u20131123. [Online]. Available: http://dx.doi.org/10.1109/SC.Companion.2012.134", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "A practical automatic polyhedral parallelizer and locality optimizer", "author": ["U. Bondhugula", "A. Hartono", "J. Ramanujam", "P. Sadayappan"], "venue": "PLDI. USA: ACM SIGPLAN, 2008, pp. 101\u2013113.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "Towards a domain specific language for a scene graph based robotic world model", "author": ["S. Blumenthal", "H. Bruyninckx"], "venue": "arXiv preprint arXiv:1408.0200, 2014.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Towards a robot perception specification language", "author": ["N. Hochgeschwender", "S. Schneider", "H. Voos", "G.K. Kraetzschmar"], "venue": "arXiv preprint arXiv:1408.2933, 2014.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "MeshSQL: the query language for simulation mesh data", "author": ["B.S. Lee", "R. Musick"], "venue": "Information Sciences, vol. 159, no. 3, pp. 177\u2013202, 2004.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Introducing Microsoft R  \u00a9 LINQ", "author": ["P. Pialorsi", "M. Russo"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2007}, {"title": "Efficient object querying for java", "author": ["D. Willis", "D.J. Pearce", "J. Noble"], "venue": "ECOOP 2006\u2013 Object-Oriented Programming. Springer, 2006, pp. 28\u201349.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2006}, {"title": "The Open Dynamics Engine", "author": ["R. Smith"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Recursive query facilities in relational databases: a survey", "author": ["P. Przymus", "A. Boniewicz", "M. Burza\u0144ska", "K. Stencel"], "venue": "Database Theory and Application, Bio-Science and Bio- Technology. Springer, 2010, pp. 89\u201399.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2010}, {"title": "SQL: 1999, formerly known as SQL3", "author": ["A. Eisenberg", "J. Melton"], "venue": "ACM Sigmod record, vol. 28, no. 1, pp. 131\u2013138, 1999.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1999}, {"title": "Distributed management and representation of data and context in robotic applications", "author": ["A. Dietrich", "S. Zug", "S. Mohammad", "J. Kaiser"], "venue": "Proceedings of the IEEE/RSI International Conference on Intelligent Robobts and Systems (IROS), Chicago, Illinois, 2014, accepted.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "Ros meets cassandra: Data management in smart environments with nosql", "author": ["A. Dietrich", "S. Mohammad", "S. Zug", "J. Kaiser"], "venue": "Proc. of the 11th International Baltic Conference (Baltic DB&IS 2014), Tallinn, Estonia, 2014, pp. 43\u201354. (Andr\u00e9 Dietrich, Sebastian Zug, and J\u00f6rg Kaiser) Department of Distributed Systems, Otto-von-Guericke-Universit\u00e4t Magdeburg, Magdeburg, Germany E-mail address: {dietrich, zug, kaiser}@ivs.cs.uni-magdeburg.de (Luigi Nardi) Department of Computing, Imperial College, London, United Kingdom E-mail address: l.nardi@imperial.ac.uk", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2014}], "referenceMentions": [{"referenceID": 0, "context": "We have developed SelectScript [1] as a consequence to the growing complexity of (robotic) world models and discrete simulation environments that we are confronted with in our everyday scientific life.", "startOffset": 31, "endOffset": 34}, {"referenceID": 0, "context": "This work is an extension of a previous work from the same authors, an interested reader can find SelectScript explained in [1].", "startOffset": 124, "endOffset": 127}, {"referenceID": 1, "context": "In that work an example of the OPEN robotics automation virtual environment (OpenRAVE) [2] is provided.", "startOffset": 87, "endOffset": 90}, {"referenceID": 2, "context": "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].", "startOffset": 238, "endOffset": 250}, {"referenceID": 3, "context": "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].", "startOffset": 238, "endOffset": 250}, {"referenceID": 4, "context": "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].", "startOffset": 238, "endOffset": 250}, {"referenceID": 5, "context": "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].", "startOffset": 238, "endOffset": 250}, {"referenceID": 2, "context": "As an example, in [3] the user is able to represent his variational data assimilation application under a specifically designed formalism.", "startOffset": 18, "endOffset": 21}, {"referenceID": 3, "context": "A similar approach on unstructured meshes is introduced by [4] where a high-level specification is provided using a syntax close to the mathematics, i.", "startOffset": 59, "endOffset": 62}, {"referenceID": 6, "context": "These languages are often called performance DSLs [7, 8, 9].", "startOffset": 50, "endOffset": 59}, {"referenceID": 7, "context": "These languages are often called performance DSLs [7, 8, 9].", "startOffset": 50, "endOffset": 59}, {"referenceID": 8, "context": "These languages are often called performance DSLs [7, 8, 9].", "startOffset": 50, "endOffset": 59}, {"referenceID": 7, "context": "As an example [8] implements an access-execute model where the user specifies a stencil computation for unstructured meshes; the DSL decides how to execute the computation taking into account manual and automatic performance optimisation techniques.", "startOffset": 14, "endOffset": 17}, {"referenceID": 5, "context": "Effective manual design space exploration is also proposed by [6] where the authors provide a mechanism for manually exploring different schedule choices.", "startOffset": 62, "endOffset": 65}, {"referenceID": 9, "context": "A compelling example that shares some commonalities with our work is RSG-DSL [10], which is a DSL focusing on robot scene graphs (RSGs) world model representations.", "startOffset": 77, "endOffset": 81}, {"referenceID": 10, "context": "Another example is the robot perception specification language (RPSL) [11] which focuses on task knowledge and the variety of sensors a robot has to deal with when implementing a robot perception architecture (RPA).", "startOffset": 70, "endOffset": 74}, {"referenceID": 11, "context": "MeshSQL [12] defines queries for mesh-based physics simulations.", "startOffset": 8, "endOffset": 12}, {"referenceID": 12, "context": "For example the language integrated query (LINQ) [13] extends some of the .", "startOffset": 49, "endOffset": 53}, {"referenceID": 13, "context": "This is similar to other approaches in the Java world, Java query language (JQL) [14], SQL for Java Objects (JoSQL) [15], etc.", "startOffset": 81, "endOffset": 85}, {"referenceID": 14, "context": "We will use the interpreter for the open dynamics engine (ODE) [16] on the \u201cchaotic\u201d simulation of Fig.", "startOffset": 63, "endOffset": 67}, {"referenceID": 0, "context": "In [1] it was further demonstrated for OpenRAVE, that it is possible to request a result AS OccupancyGrid for external planners, AS Prolog to support reasoning tasks, or even AS SensorMap that depicts the current sensor coverage of an area.", "startOffset": 3, "endOffset": 6}, {"referenceID": 15, "context": "CONNECT BY construct that was originally introduced by Oracle [17].", "startOffset": 62, "endOffset": 66}, {"referenceID": 16, "context": "The SQL standard [18] defines a syntax that involves the keywords WITH RECURSIVE and requires to associate query expressions with a name, which allows to reuse them.", "startOffset": 17, "endOffset": 21}, {"referenceID": 2, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 10, "endOffset": 19}, {"referenceID": 1, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 10, "endOffset": 19}, {"referenceID": 0, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 10, "endOffset": 19}, {"referenceID": 2, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 241, "endOffset": 250}, {"referenceID": 1, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 241, "endOffset": 250}, {"referenceID": 0, "context": "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.", "startOffset": 241, "endOffset": 250}, {"referenceID": 0, "context": "5 elif not towers[step [1]] or towers[step [1]][-1]> towers[step [0]][ -1]:", "startOffset": 23, "endOffset": 26}, {"referenceID": 0, "context": "5 elif not towers[step [1]] or towers[step [1]][-1]> towers[step [0]][ -1]:", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "7 towers[step [1]].", "startOffset": 14, "endOffset": 17}, {"referenceID": 0, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 11, "endOffset": 16}, {"referenceID": 1, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 18, "endOffset": 23}, {"referenceID": 0, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 25, "endOffset": 30}, {"referenceID": 0, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 32, "endOffset": 37}, {"referenceID": 1, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 32, "endOffset": 37}, {"referenceID": 1, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 39, "endOffset": 44}, {"referenceID": 1, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 46, "endOffset": 52}, {"referenceID": 0, "context": "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.", "startOffset": 46, "endOffset": 52}, {"referenceID": 2, "context": "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.", "startOffset": 103, "endOffset": 110}, {"referenceID": 1, "context": "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.", "startOffset": 103, "endOffset": 110}, {"referenceID": 0, "context": "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.", "startOffset": 103, "endOffset": 110}, {"referenceID": 2, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 8, "endOffset": 17}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 8, "endOffset": 17}, {"referenceID": 0, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 8, "endOffset": 17}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 55, "endOffset": 61}, {"referenceID": 0, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 63, "endOffset": 69}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 71, "endOffset": 77}, {"referenceID": 0, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 71, "endOffset": 77}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 79, "endOffset": 85}, {"referenceID": 0, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 87, "endOffset": 93}, {"referenceID": 0, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 95, "endOffset": 101}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 95, "endOffset": 101}, {"referenceID": 1, "context": "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]", "startOffset": 103, "endOffset": 109}, {"referenceID": 2, "context": "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 39, "endOffset": 46}, {"referenceID": 1, "context": "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 39, "endOffset": 46}, {"referenceID": 0, "context": "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 39, "endOffset": 46}, {"referenceID": 2, "context": "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);", "startOffset": 24, "endOffset": 31}, {"referenceID": 1, "context": "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);", "startOffset": 24, "endOffset": 31}, {"referenceID": 0, "context": "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);", "startOffset": 24, "endOffset": 31}, {"referenceID": 2, "context": "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 47, "endOffset": 54}, {"referenceID": 1, "context": "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 47, "endOffset": 54}, {"referenceID": 0, "context": "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)", "startOffset": 47, "endOffset": 54}, {"referenceID": 2, "context": "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE", "startOffset": 22, "endOffset": 29}, {"referenceID": 1, "context": "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE", "startOffset": 22, "endOffset": 29}, {"referenceID": 0, "context": "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE", "startOffset": 22, "endOffset": 29}, {"referenceID": 3, "context": "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)", "startOffset": 46, "endOffset": 55}, {"referenceID": 2, "context": "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)", "startOffset": 46, "endOffset": 55}, {"referenceID": 1, "context": "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)", "startOffset": 46, "endOffset": 55}, {"referenceID": 0, "context": "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)", "startOffset": 46, "endOffset": 55}, {"referenceID": 3, "context": "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15", "startOffset": 24, "endOffset": 33}, {"referenceID": 2, "context": "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15", "startOffset": 24, "endOffset": 33}, {"referenceID": 1, "context": "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15", "startOffset": 24, "endOffset": 33}, {"referenceID": 0, "context": "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15", "startOffset": 24, "endOffset": 33}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 18, "endOffset": 24}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 32, "endOffset": 38}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 47, "endOffset": 53}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 62, "endOffset": 69}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 70, "endOffset": 76}, {"referenceID": 0, "context": "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];", "startOffset": 70, "endOffset": 76}, {"referenceID": 17, "context": "In [19] and [20] we had described a methodology that overlays smart and distributed environments with some kind of distributed scene graph (by using cloud based techniques).", "startOffset": 3, "endOffset": 7}, {"referenceID": 18, "context": "In [19] and [20] we had described a methodology that overlays smart and distributed environments with some kind of distributed scene graph (by using cloud based techniques).", "startOffset": 12, "endOffset": 16}], "year": 2017, "abstractText": "SelectScript is an extendable, adaptable, and declarative domainspecific language aimed at information retrieval from simulation environments and robotic world models in an SQL-like manner. In this work we have extended the language in two directions. First, we have implemented hierarchical queries; second, we improve efficiency enabling manual design space exploration on different \u201csearch\u201d strategies. As depicted in the teaser above, we demonstrate the applicability of such extensions in two application problems; the basic language concepts are explained by solving the classical problem of the Towers of Hanoi and then a common path planning problem in a complex 3D environment is implemented.", "creator": "LaTeX with hyperref package"}}}