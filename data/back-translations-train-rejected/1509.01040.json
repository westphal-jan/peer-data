{"id": "1509.01040", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Sep-2015", "title": "Building a Truly Distributed Constraint Solver with JADE", "abstract": "Real life problems such as scheduling meeting between people at different locations can be modelled as distributed Constraint Satisfaction Problems (CSPs). Suitable and satisfactory solutions can then be found using constraint satisfaction algorithms which can be exhaustive (backtracking) or otherwise (local search). However, most research in this area tested their algorithms by simulation on a single PC with a single program entry point. The main contribution of our work is the design and implementation of a truly distributed constraint solver based on a local search algorithm using Java Agent DEvelopment framework (JADE) to enable communication between agents on different machines. Particularly, we discuss design and implementation issues related to truly distributed constraint solver which might not be critical when simulated on a single machine. Evaluation results indicate that our truly distributed constraint solver works well within the observed limitations when tested with various distributed CSPs. Our application can also incorporate any constraint solving algorithm with little modifications.", "histories": [["v1", "Thu, 3 Sep 2015 11:41:45 GMT  (565kb)", "http://arxiv.org/abs/1509.01040v1", "7 pages"]], "COMMENTS": "7 pages", "reviews": [], "SUBJECTS": "cs.AI cs.DC", "authors": ["ibrahim adeyanju"], "accepted": false, "id": "1509.01040"}, "pdf": {"name": "1509.01040.pdf", "metadata": {"source": "META", "title": "Building a Truly Distributed Constraint Solver with JADE", "authors": ["Ibrahim Adeyanju"], "emails": [], "sections": [{"heading": null, "text": "People in different places can be modeled as distributed constraint satisfaction problems (CSPs). Appropriate and satisfactory solutions can then be found using constraint satisfaction algorithms, which can be exhaustive (backtracking) or otherwise (local search). However, most research in this area tested their algorithms by simulation on a single PC with a single entry point into the program. The most important contribution of our work is the design and implementation of a truly distributed constraint solver based on a local search algorithm using Java Agent Development Framework (JADE) to enable communication between agents on different machines. In particular, we discuss design and implementation problems associated with a truly distributed constraint solver, which may not be critical when simulated on a single machine. Evaluation results show that our truly distributed constraint solver works well within the observed constraints when tested with different distributed CSPs module algorithms."}, {"heading": "1. INTRODUCTION", "text": "Such real-world activities can be modeled as Constraint Satisfaction Problems (CSPs) and algorithms designed to provide appropriate solutions. A CSP consists of a finite set of decision variables, each with a set of alternatives that it can adopt, and a set of constraints [1]. CSPs are solved when all constraints between decision variables are met by decisions from their domain. A distributed CSP is one in which variables and constraints are distributed to multiple actors in collaboration [2]. In such a scenario, group objectives are clearly defined, but individual objectives lead to additional complexity in implementing solution approaches. This paper discusses the design and implementation of a truly distributed section solver using a local search algorithm on multiple machines. In real-life, applications of distributed constraints are used to solve problems such as distributed resource allocation [3] that arise in problems such as distributed or sensorily captured networks, distributed disaster response networks, and other emergency planning [4]."}, {"heading": "2. RELATED WORK", "text": "Two broad categories of techniques for solving Constraint Satisfaction Problems (CSP), centralized or distributed, are Exhaustive Search and Local Search. Exhaustive Search, also known as Systematic Backtracking, involves a carefully selected partial solution, which is gradually scanned through all possible combinations of different values of variables until a complete solution is found that meets all the limitations. Exhaustive search algorithms are guaranteed to find one or more solutions if they exist or could determine if there is no solution at all. Current backtracking algorithms include back-jumping schemes [5,6], Asynchronous Weak Commitment Search [7], and Asynchronous Forward Checking [8]. Local Search involves a partial solution by randomly assigning values to variables involved in a CSP. Improvement of the random solution is then sought by successive iterations [remote], allowing different points in the search space until a valid solution is found or a valid solution is found."}, {"heading": "3. CONSTRAINT SOLVER", "text": "Our application of the distributed constraint solver is based on a local search algorithm called Distributed Penalty-driven Local search (DisPeL) [15] as the underlying constraint solver. DisPeL is a local search algorithm for solving distributed CSPs, where each agent controls only one variable by finding the first solution that meets all constraints at the same time. Collaborative agents alternate in a fixed order to improve random initialization. Gradual improvements are found iteratively instead of the best possible improvement as with traditional algorithms in mountaineering, resulting in a reduction in communication costs, as all improvements are accepted and the information used in decision-making is always coherent [15]. DisPePeL's core strategy consists of applying two types of penalties (temporary and incremental) to solving deadlocks (local optima) by modifying the underlying cost landscape, even if there is no solution to resolve them immediately, even if the penalties are too high."}, {"heading": "4. JADE FRAMEWORK", "text": "Distributed constraint solvers are multi-agent systems as they attempt to find suitable solutions for CSPs whose agents are spread across multiple locations. Agent-oriented applications combine artificial intelligence with distributed system techniques by modelling components as agents. Each agent is autonomous, proactive and has the ability to communicate with other agents to achieve personal and collaborative goals [26]. Such applications have a peer-to-peer architecture model in which each agent is able to send or receive communications from each other agent within the application. Open source middleware that provides a domain-independent infrastructure can facilitate communication in multi-agent systems, allowing application developers to focus on producing business logic. Java Agent DEvelopment Framework (JADE) is a fully distributed middleware system with a flexible infrastructure that enables easy expansion [6]. The logic framework of fully implementing the core software itself facilitates the development of full-cycle-oriented applications by means of other agents."}, {"heading": "4.1 JADE Architecture", "text": "A JADE platform consists of a runtime environment (also referred to as a container) that can be distributed over the network and provides all the services required for hosting and executing agents. A special container, which is referred to as the main container, must always be active on a platform and all other normal containers register with it as soon as they start and must therefore know the host address and port of the main container. A diagram that shows the typical architecture of the JADE platform is shown in Figure 1. Starting another main container elsewhere in the network represents a different platform for which new normal containers may be able to register. The main container manages the container table (CT), which is the register of object references and transport addresses of all container nodes in the platform; manages the global agent table GADT), which is the register of all agents present in the platform, including their current status and their location; and hosts the Agent-Agent Agent-Agent-Agent-Agent-Agent, which is the Agent Management Facilitator page, as well as the Agent Facilitator page."}, {"heading": "4.2 Message Transport Service", "text": "JADE includes a Message Transport Service (MTS) that manages all message exchanges within and between platforms. All standard Message Transport Protocols (MTPs) defined by FIPA are implemented by this service to promote interoperability between different non-JADE platforms. Each MTP contains the definition of a transport protocol and a standard encoding of the message envelope. HTTP-based MTP is always started by default with the initialization of a main container, while no MTP is enabled on normal containers. This creates a server socket on the main container host and listens for incoming connections via HTTP at the specified URL. When an incoming connection is established and a valid message is received via that connection, the MTP directs the message to its final destination, which is generally one of the agents within the distributed platform [26]."}, {"heading": "4.3 Agent Tasks - Behaviour scheduling", "text": "An agent in JADE performs its tasks within program elements known as \"behaviors.\" A behavior represents a task that an agent can perform. An agent can execute multiple behaviors simultaneously, even though the planning of behavior in an agent is not preventive, but cooperative. This means that if a behavior is intended to execute, its action () method is called and runs until it returns. Therefore, it is the programmer who defines when an agent switches from executing one behavior to executing the next. If no behavior is available to execute, the agent thread goes to sleep to consume no CPU time and wakes up as soon as a behavior to execute is available again [27]."}, {"heading": "4.4 Agent Communication", "text": "The communication paradigm used in JADE is asynchronous message delivery. [26] Each agent has a message queue in which the JADE runtime is posted by other agents; whenever a message is posted to the message queue, the receiving agent is notified. However, the programmer determines if and when the agent actually picks up the message from the queue to process it. This process is illustrated in Figure 2. The message format in JADE complies with the specifications of the FIPA-ACL message structure and includes fields such as sender, recipient list, communication file (QUESTION, INFORM, PROPOSE, etc.), content, content language, and ontology."}, {"heading": "5. DESIGN & IMPLEMENTATION", "text": "The design of our truly distributed constraint solver application is discussed in two sections on the user interface (Section 5.1) and the underlying distributed constraint solver (Section 5.2).The user interface is the part of the application that interacts with the user by allowing the user to enter values and view the final result of the computation.The underlying distributed constraint solver deals with the structure of the algorithm and how it was integrated into the JADE platform that was used to allow real distribution of agents to different machines in solving constraint satisfaction problems."}, {"heading": "5.1 Graphical User Interface (GUI)", "text": "The user interface would allow a user to enter some values for an agent involved in the DisCSP before he is active and begins communicating with other agents to resolve the problem, and the results are shown in a dialog box, and the graphical user interface for the distributed constraint solver is shown in Figure 3. This user interface can only be used once by a single agent involved in solving a DisCSP problem, and the application must be restarted to resolve any other DisCSP agent. If one of the input fields contains an invalid value and the information about the dialog gives an indication of the possible cause of the error, the \"Start Agent\" button will be used to activate another agent."}, {"heading": "5.2 Constraint solving technique", "text": "The Distributed Constraint Solver (DCS) underlying our GUI discussed in Section 5.1 is based on the Distributed Penaltydriven Local Search (DisPeL) [15] algorithm. At this point we will discuss the implementation of a DisPeL DCS with JADE to ensure a true distribution of agents on different machines. It should be stressed that all versions of DisPeL were previously simulated by the upstream author on individual machines and that our implementation of a true DCS is novel. Real distribution of DisCSPs leads to other important research problems. The problems we encountered implementing a DisPeL DCS on multiple machines are in the next subsections."}, {"heading": "5.2.1 Ownership of the DisCSP", "text": "When the DisPeL algorithm was simulated to solve DisCSP on a single machine, all constraint expressions were either randomly generated [15] or entered via the same GUI [29]. It was relatively easy to identify constraint expressions for each variable. However, in order to run DisPeL on multiple machines, we need to address the problem of who initializes DisCSP and sorts all constraint expressions. Ideally, any agent involved in solving a DisCSP should only know from other agents that it has limitations, but the algorithm solves the problem due to the fact that the entire DisCSP is known from the outset before initiating the process towards a suitable solution, and that the DisCSP is static (unchanged) throughout until a solution is found or the maximum iterations allowed are reached. Some important features of the DisPeL algorithm, such as ordering all variable names of the agent as the UAgent, ensure that this address agent or the distributed agent is close to the target simultaneously."}, {"heading": "5.2.2 Constraints and global constants validation", "text": "Closely related to the problem of DisCSP ownership is also the validation of constraint expressions and global constants such as the maximum number of iterations. This is not a problem if the constraint solver is implemented on a single machine with a single interface to take over all inputs. For example, if Agent A and B have constraints \"A > B\" between them, it must be ensured that the same equivalent expression (\"A > B\" on Agent A's interface and \"B < A\" on Agent B) is entered on their interfaces to avoid conflicts. Global constants such as the \"maximum number of iterations\" should also be identical for all agents used in the original algorithm. To solve this problem, we validate equivalent expressions across limited agents by passing the constraint operators with other messages communicated between agents. Conflicting constraints such as the \"maximum number of Iterations\" in the CSP process are then ignored."}, {"heading": "5.2.3 Termination Detection", "text": "The process of resolving constraints must stop when all agents receive solutions to their constraints. Such detection is relatively easy if all agents are implemented on a single machine and have a single application entry, as each agent can be checked to see if they have received a solution before the application is terminated. Termination detection is more complex when agents are on different machines with multiple application entries. We address this problem as suggested by the original author of our constraint algorithm [15] by using the same method as the Distributed Breakout Algorithm [13]."}, {"heading": "5.2.4 Unreliable network communication", "text": "Since the agents involved in the DisCSP may be on different computers connected via a computer network (preferably local network), the problems of communication delays, network congestion, packet corruption and timeouts are also crucial. There would be no reason to consider this problem if all agents are on the same machine. We have used the means proposed by the author of our Constraint Solver [15], where agents are allowed to resume their activity if messages are not received after a reasonable time. Agents in such a situation assume that the values of their neighbors remain unchanged."}, {"heading": "6. EVALUATION", "text": "We tested our truly distributed constraint solver application extensively with sample DisCSPs. Test cases were designed based on the functional requirements of our application. To this end, seven DisCSPs with up to four agents were formulated; the formulated DisCSPs are shown in Table 1. The diameter of the agent network was taken as the most remote parameter for termination detection, which can be achieved by drawing the agent tree for a DisCSP and counting the number of agents from top to bottom of the agent tree, as shown in Figure 4. We note from Table 1 that all the tested DisCSPs returned correct results, with the only unresolved showing the interim results when maximum iteration was reached. Sometimes, when a definitive solution is achieved due to the asynchronous nature of the JADE, there is a screenshot of a GUI test of an agent during the evaluation for Agent 7 shown in Figure 5."}, {"heading": "7. CONCLUSION", "text": "This work dealt with our work on the development of a truly distributed constraint solver based on a local search algorithm (DisPeL) on different computers. The class libraries of the JADE framework were used to implement a multi-agent system that enables true distribution of CSPs. We intend to expand our application so that each agent can have multiple variables in addition to actual distribution on multiple computers. The type of constraint expressions handled by our software will also be expanded to allow comparisons, boolean and arithmetic operations between more than two variables. Variables other than integrators such as double, string and other objects such as dates that would be more useful in real applications will also be considered in future versions of our application. Finally, we would distribute the agents in our constraint solver over a wide network that is not a local network."}, {"heading": "8. ACKNOWLEDGEMENTS", "text": "The author is grateful to Dr Hatem Ahriz from RobertGordon University, Aberdeen, for his very useful feedback."}, {"heading": "9. REFERENCES", "text": "[1] Dechter R. Constraint Processing for constraint processing. San Francisco, CA: Morgan Kaufmann P. 2003. [2] Makoto Y, Edmund H D, Toru I, Kazuhiro K. The Distributed Constraint Satisfaction Problem: Formalization and Algorithms. IEEE TKDE. 1998; 10 (5): 673-685. [3] Pragnesh J M, Hyuckchul J, Milind T, Wei-Min S, Shriniwas K. Dynamic Distributed Resource Allocation: A Distributed Constraint Satisfaction Approach. In Proceedings of CP."}], "references": [{"title": "The Distributed Constraint Satisfaction Problem: Formalization and Algorithms", "author": ["Y Makoto", "D Edmund H", "I Toru", "K. Kazuhiro"], "venue": "IEEE TKDE", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1998}, {"title": "Dynamic Distributed Resource Allocation: A Distributed Constraint Satisfaction Approach", "author": ["M Pragnesh J", "J Hyuckchul", "T Milind", "S Wei-Min", "K. Shriniwas"], "venue": "In Proceedings of CP\u201f01. Springer,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "A distributed constraintbased scheduler", "author": ["E Lamma", "P Mello", "M. Milano"], "venue": "Artificial Intelligence in Engineering", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1997}, {"title": "Enhancement schemes for constraint processing: Backjumping, learning, cutset decomposition", "author": ["R Dechter"], "venue": "Artificial Intelligence", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1990}, {"title": "Conflict-Directed Backjumping Revisited. JAIR", "author": ["X Chen", "P. van Beek"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "Asynchronous Weak-commitment Search for Solving Distributed Constraint Satisfaction Problems", "author": ["Makoto Yokoo"], "venue": "In Proceedings of CP\u201f95", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1995}, {"title": "Asynchronous Forward-checking for DisCSPs", "author": ["A Meisels", "R. Zivan"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2007}, {"title": "Query optimization by simulated annealing", "author": ["E Ioannidis Y", "E. Wong"], "venue": "In Proceedings of the international conference on Management of data. ACM,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1987}, {"title": "On simulated annealing in EDA", "author": ["F. Wong D"], "venue": "In Proceedings of the International Symposium on Physical Design. ACM,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "The breakout method for escaping from local minima", "author": ["P. Morris"], "venue": "Proceedings of the National Conference on Artificial Intelligence", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1993}, {"title": "The distributed breakout algorithms", "author": ["K Hirayama", "M. Yokoo"], "venue": "Artificial Intelligence", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}, {"title": "Distributed breakout revisited", "author": ["W Zhang", "L. Wittenburg"], "venue": "In Proceedings of the national conference on Artificial intelligence", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2002}, {"title": "Implementing remote procedure calls", "author": ["D Birrell A", "J. Nelson B"], "venue": "ACM Transaction on Computer Systems", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1984}, {"title": "On remote procedure call", "author": ["P. Gomes-Soares"], "venue": "In Proceedings of the conference of the Centre for Advanced Studies on Collaborative research. IBM Press", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1992}, {"title": "Net Remoting", "author": ["Don W. Browning"], "venue": "Manning Publications Co., Greenwich, CT,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "Advanced .Net Remoting", "author": ["Ingo Rammer"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2002}, {"title": "Efficient Java RMI for parallel programming", "author": ["J Maassen", "R Van-Nieuwpoort", "R Veldema", "H Bal", "T Kielmann", "C Jacobs", "R. Hofman"], "venue": "ACM Transaction on Programming Languages and Systems", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Remote Procedure Calls and Java RMI", "author": ["J. Waldo"], "venue": "IEEE Concurrency", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1998}, {"title": "Adding parametric polymorphism to the common object request broker architecture (CORBA)", "author": ["L. Bethea W"], "venue": "In Addendum to the proceedings of OOPSLA '00. ACM,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2000}, {"title": "Programming with object groups in CORBA", "author": ["P. Felber", "R. Guerraoui"], "venue": "IEEE Concurrency", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2000}, {"title": "KSACI: A Handheld Device Infrastructure for Agents Communication", "author": ["L Albuquerque R", "F Hubner J", "G de Paula", "S Sichman J", "G. Ramalho"], "venue": "In Proceedings of the International Workshop on Intelligent Agents. Springer,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2001}, {"title": "Agent Communication Languages: The Current Landscape", "author": ["Y Labrou", "T Finin", "Y. Peng"], "venue": "IEEE Intelligent Systems", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1999}, {"title": "Developing multiagent systems with JADE", "author": ["F Bellifemine", "G Caire", "D. Greenwood"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2007}, {"title": "JADE - A FIPA compliant Agent Framework", "author": ["F Bellifemine", "G Rimassa", "A. Poggi"], "venue": "In Proceedings of the International Conference and Exhibition on the Practical Application of Intelligent Agents and Multi-Agents. London,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1999}, {"title": "JADE Tutorial- Jade Programming for Beginners", "author": ["G. Caire"], "venue": "Torino, Italy: Telecom Italia Laboratory (TILAB);", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2003}, {"title": "SIDCOT: A Smart Interface for Constraint Programming. [Unpublished BSc", "author": ["D. Lee"], "venue": "Thesis]. Aberdeen: Robert Gordon University;", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}], "referenceMentions": [{"referenceID": 0, "context": "A distributed CSP is one in which variables and constraints are distributed among multiple agents in collaboration [2].", "startOffset": 115, "endOffset": 118}, {"referenceID": 1, "context": "Real life applications of distributed constraint solvers include dynamic distributed resource allocation [3] which arises in problems such as distributed sensor networks, disaster rescue and hospital scheduling.", "startOffset": 105, "endOffset": 108}, {"referenceID": 2, "context": "Another application is building schedulers such as Distributed Meeting Scheduler and Railway Traffic regulation[4].", "startOffset": 111, "endOffset": 114}, {"referenceID": 3, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 61, "endOffset": 66}, {"referenceID": 4, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 61, "endOffset": 66}, {"referenceID": 5, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 104, "endOffset": 107}, {"referenceID": 6, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 142, "endOffset": 145}, {"referenceID": 7, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 20, "endOffset": 26}, {"referenceID": 8, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 20, "endOffset": 26}, {"referenceID": 9, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 47, "endOffset": 51}, {"referenceID": 10, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 102, "endOffset": 109}, {"referenceID": 11, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 102, "endOffset": 109}, {"referenceID": 12, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 164, "endOffset": 168}, {"referenceID": 13, "context": "These include Remote Procedure Calls (RPC) [16,17], .", "startOffset": 43, "endOffset": 50}, {"referenceID": 14, "context": "These include Remote Procedure Calls (RPC) [16,17], .", "startOffset": 43, "endOffset": 50}, {"referenceID": 15, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 13, "endOffset": 20}, {"referenceID": 16, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 13, "endOffset": 20}, {"referenceID": 17, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 53, "endOffset": 60}, {"referenceID": 18, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 53, "endOffset": 60}, {"referenceID": 19, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 112, "endOffset": 119}, {"referenceID": 20, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 112, "endOffset": 119}, {"referenceID": 21, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 173, "endOffset": 180}, {"referenceID": 22, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 173, "endOffset": 180}, {"referenceID": 23, "context": "In our work, we used Java Agent DEvelopment Framework (JADE) [26,27], an open source platform for peer-to-peer agent applications.", "startOffset": 61, "endOffset": 68}, {"referenceID": 24, "context": "In our work, we used Java Agent DEvelopment Framework (JADE) [26,27], an open source platform for peer-to-peer agent applications.", "startOffset": 61, "endOffset": 68}, {"referenceID": 12, "context": "CONSTRAINT SOLVER Our distributed constraint solver application is built using a local search algorithm called Distributed Penalty-driven Local search (DisPeL) [15] as its underlying constraint solver.", "startOffset": 160, "endOffset": 164}, {"referenceID": 12, "context": "This causes a reduction in communication costs since all improvements are accepted and the information used in making decisions is always coherent [15].", "startOffset": 147, "endOffset": 151}, {"referenceID": 12, "context": "Hence, each agent will communicate in a synchronised manner with all other agents that are co-constrained with it exchanging value assignments and requests to impose penalties [15].", "startOffset": 176, "endOffset": 180}, {"referenceID": 23, "context": "Each agent is autonomous, proactive, and has the ability to communicate with other agents to achieve personal and communal goals [26].", "startOffset": 129, "endOffset": 133}, {"referenceID": 4, "context": "Java Agent DEvelopment framework (JADE) is a completely distributed middleware system with a flexible infrastructure that allows easy extension [6].", "startOffset": 144, "endOffset": 147}, {"referenceID": 23, "context": "JADE is a software platform written in Java that provides basic middleware-layer functionalities which are independent of the specific application and which simplify the realization of distributed applications that exploit the software agent abstraction [26].", "startOffset": 254, "endOffset": 258}, {"referenceID": 24, "context": "Relationship between Containers and platforms on the JADE architecture [27]", "startOffset": 71, "endOffset": 75}, {"referenceID": 23, "context": "Agents in JADE are identified by a globally unique name called an Agent Identifier (AID) consisting basically of the agent\u201fs local name and its addresses (usually inherited from the platform) [26].", "startOffset": 192, "endOffset": 196}, {"referenceID": 4, "context": "A2 & A3 in Figure 1), different containers in the same platform (A1 & A2) or different platforms (A4 & A5) provided they know each other\u201fs agent identifier [6].", "startOffset": 156, "endOffset": 159}, {"referenceID": 23, "context": "Whenever an incoming connection is established and a valid message is received over that connection, the MTP routes the message to its final destination which, in general, is one of the agents located within the distributed platform [26].", "startOffset": 233, "endOffset": 237}, {"referenceID": 24, "context": "When there are no behaviours available for execution the agent\u201fs thread goes to sleep in order not to consume CPU time and is woken up as soon as there is a behaviour again available for execution [27].", "startOffset": 197, "endOffset": 201}, {"referenceID": 23, "context": "4 Agent Communication The communication paradigm adopted in JADE is the asynchronous message passing [26].", "startOffset": 101, "endOffset": 105}, {"referenceID": 12, "context": "1 is based on the Distributed Penaltydriven Local search (DisPeL) [15] algorithm.", "startOffset": 66, "endOffset": 70}, {"referenceID": 12, "context": "1 Ownership of the DisCSP When DisPeL algorithm was simulated to solve DisCSPs on a single machine; all the constraint expressions were either randomly generated [15] or entered through the same GUI [29].", "startOffset": 162, "endOffset": 166}, {"referenceID": 12, "context": "We address this problem as suggested by original author of our constraint algorithm [15] by using the same method as Distributed Breakout Algorithm [13].", "startOffset": 84, "endOffset": 88}, {"referenceID": 10, "context": "We address this problem as suggested by original author of our constraint algorithm [15] by using the same method as Distributed Breakout Algorithm [13].", "startOffset": 148, "endOffset": 152}, {"referenceID": 12, "context": "We used the remedy suggested by the author of our constraint solver [15] where agents are allowed to resume activity if messages have not been received after a reasonable amount of time.", "startOffset": 68, "endOffset": 72}], "year": 2012, "abstractText": "Real life problems such as scheduling meeting between people at different locations can be modelled as distributed Constraint Satisfaction Problems (CSPs). Suitable and satisfactory solutions can then be found using constraint satisfaction algorithms which can be exhaustive (backtracking) or otherwise (local search). However, most research in this area tested their algorithms by simulation on a single PC with a single program entry point. The main contribution of our work is the design and implementation of a truly distributed constraint solver based on a local search algorithm using Java Agent DEvelopment framework (JADE) to enable communication between agents on different machines. Particularly, we discuss design and implementation issues related to truly distributed constraint solver which might not be critical when simulated on a single machine. Evaluation results indicate that our truly distributed constraint solver works well within the observed limitations when tested with various distributed CSPs. Our application can also incorporate any constraint solving algorithm with little modifications. General Terms Algorithms, Agent-Oriented systems", "creator": "Microsoft\u00ae Office Word 2007"}}}