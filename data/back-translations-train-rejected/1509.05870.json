{"id": "1509.05870", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Sep-2015", "title": "Exploiting Reduction Rules and Data Structures: Local Search for Minimum Vertex Cover in Massive Graphs", "abstract": "The Minimum Vertex Cover (MinVC) problem is a well-known NP-hard problem. Recently there has been great interest in solving this problem on real-world massive graphs. For such graphs, local search is a promising approach to finding optimal or near-optimal solutions. In this paper we propose a local search algorithm that exploits reduction rules and data structures to solve the MinVC problem in such graphs. Experimental results on a wide range of real-word massive graphs show that our algorithm finds better covers than state-of-the-art local search algorithms for MinVC. Also we present interesting results about the complexities of some well-known heuristics.", "histories": [["v1", "Sat, 19 Sep 2015 10:48:31 GMT  (96kb,D)", "http://arxiv.org/abs/1509.05870v1", "7 pages, 3 figures, 2 tables, 6 algorithms, submitted to AAAI-16"]], "COMMENTS": "7 pages, 3 figures, 2 tables, 6 algorithms, submitted to AAAI-16", "reviews": [], "SUBJECTS": "cs.DS cs.AI", "authors": ["yi fan", "chengqian li", "zongjie ma", "ljiljana brankovic", "vladimir estivill-castro", "abdul sattar"], "accepted": false, "id": "1509.05870"}, "pdf": {"name": "1509.05870.pdf", "metadata": {"source": "CRF", "title": "Exploiting Reduction Rules and Data Structures: Local Search for Minimum Vertex Cover in Massive Graphs", "authors": [], "emails": [], "sections": [{"heading": "Introduction", "text": "The fact is that we are able to live in a country where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish, where people are able to flourish."}, {"heading": "Preliminaries", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "Basic Notations", "text": "If e = {u, v} is an edge of G, we say that u and v are neighbors. N (v) we define as {u \u0394V | {u, v}. The degree of a vertex v, which is denoted by d (v), is defined as | N (v) |. We use davg (G) and dmax (G) to denote the average degree or maximum degree of the graph G, where G is suppressed if taken out of context. An edge e = {u, v} is covered by a vertex S if one of its endpoints is in S, i.e. u \u30fb S or v \u0441S (or both). Otherwise, it is revealed by S."}, {"heading": "Local Search for MinVC", "text": "Most local search algorithms solve the MinitV-C problem by iteratively solving their decision version, which provides a positive integer k, in search of a k-sized vertex coverage. A general framework is algorithm 1. We refer to the current candidate solution as C, which is a series of vertices selected for coverage. Algorithm 1. A local search framework for MinitV 1. (C, optInfo) \u2190 InitV 2. The construction phase does not end with 3, when C covers all edges, then 4 C 2. (5) Removing a vertice from C; 6 Replacing a vertice pair for MinitV 1. Algorithm 2. consists of two stages: the construction phase 1. (line 1) and the local search phase 3. (line 2 to 6).Initially, an initial vertice coverage is constructed using the InitV-C method."}, {"heading": "The Construction Stage", "text": "Previous InitV-C procedures construct a starting point from an empty set C mainly as follows: 1. Max gain: Select a vertex v with the maximum gain and add v to C, thereby breaking ties at random. Repeat this process until C becomes a lid. (Papadimitrious and Steiglitz 1982) 2. Min gain: Select a vertex v with the minimum positive gain and add all V neighbors to C, thereby breaking ties at random. Repeat this process until C becomes a lid. Redundant vertex (vertex whose loss is 0) in C are then removed. (Ugurlu 2012; Kettani, Ramdani and Tadili 2013) 3. Random: Choose an uncovered edge, add the end point with a higher degree in C. Repeat this process until C is removed to a lid redundancy point in 2015."}, {"heading": "Reduction Rules for MinVC", "text": "Our solver will include the following reduction rules in the InitV-C procedure to handle vertices of lower degrees. Grade 1 rule: If G contains a vertex u s.t. N (u) = {v}, then there is a minimum vertex lid of G. The two following rules are from (Chen, Kanj and Jia 2001). Grade 2 with triangle rule: If G contains a vertex v s.t. N (v) = {n1, n2} and {n1, n2}.E, then there is a minimum vertex lid of G containing both n1 and n2. Grade 2 with square rule: If G contains two vertices u and v s.t. N (u) = N (v) = {n1, n2} and {n1, n2}.E, then there is a minimum vertex lid of G that includes both n1 and n2.Since we develop a local search, we will include a local search for both neighbors (we will then include a local search v = 2)."}, {"heading": "Incorporating Reduction Rules", "text": "We include reduction rules to: (1) construct smaller initial apex caps; (2) help confirm optimality."}, {"heading": "Constructing A Vertex Cover with Reductions", "text": "It is as if we have a cover with only one decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decrease of decre"}, {"heading": "A Local Search MinVC Solver", "text": "Algorithm 3: LinCom (G, cutoff) Input: A graph G = (V, E), the cutoff time output: A vertex of G1 (C, optInfo) \u2190 InitV C (); 2 if optInfo = optimum-guaranteed, then return C with elapsed time < Cutoff do 3 if C covers all edges then 4 C \u043a C; 5 Remove a vertex u s.t. fixed [u] = false with minimal loss of C, bonds break randomly; 6 Remove a vertex u \u0441C s.t. fixed [u] = false with minimal loss, bonds break randomly; 7 e \u2190 a random uncovered edge; 8 add the endpoint of e with greater gain, bonds to the benefit of the older;"}, {"heading": "9 return C\u2217;", "text": "Our solver LinCom is sketched in algorithm 3. First, a vertex is constructed. If the returned hull is guaranteed to be optimal, the algorithm will return immediately. Then, at each step, the algorithm first selects a vertex u \u0441C s.t. u is not an inferred vertex (i.e. fixed [u] = false) with minimal loss and breaks connections randomly. Then, the algorithm selects a randomly revealed edge e, selects one of the e endpoints with the greater gain and adds it, thereby loosening the bonds in favor of the older ones."}, {"heading": "Data Structures", "text": "To reduce complexity, we used an efficient data structure called alternative partitions (see Figure 1)."}, {"heading": "Alternative Partitions", "text": "We use loss-k (or gain-k) partition to denote the partition containing vertices in C (or outside of C) whose loss (or gain) is k (Figure 1). All loss-k partitions are denoted as dark areas, and all gain-k partitions are denoted as light areas. Since the dark and light areas are alternatively distributed, we call them alternative partitions. Obviously, we have Proposition 1 1 1 1 1 1 0 \u2264 gain (v) \u2264 d (v) \u2264 | V | where v 6% C. 2. 0 \u2264 loss (v) \u2264 d (v) \u2264 | V \u00b2 C. Then we use Algorithm 4 to find these vertices in C with the minimal losses. Algorithm 4: randomMinLossVertex Input: A sequence of alternative partitions Output: A random vertex v \u00b2 C with minimal losses 1 k \u00b2 0; 2 while the loss-k partition is empty, k + 1 random vertex in the loss position."}, {"heading": "Implementations", "text": "Given a graph G = (V, E) and a candidate solution C, we implement the alternative partitions to an array in which each position contains a vertex (see Figure 1). We also maintain two additional arrays of pointers, each pointing to the beginning of a particular partition. Let's imagine the array as a book of vertices, and the pointer arrays as indexes of the book. Initializing the partitions Initially, when C is empty, there are no dark regions in our data structure, so initializing the partitions is equivalent to sorting the vertices into a monotonous, not decreasing, order based on their gain. Note that the gain of each vertex is equal to its degree, so we must now sort vertices by degree. With Proposition 1, this fulfills the assumption of counting the order running in linear time (Cormen et al. 2009)."}, {"heading": "Complexity Analysis", "text": "In this section, we assess the complexity of the bestseller selection and the vertex that covers construction euristics."}, {"heading": "Complexity of The Best-picking Heuristic", "text": "Along with the addition / removal of a vertex v, we must move this vertex and all its neighbors to other partitions. Therefore, maintaining the partitions according to Proposition 5 O (1) requires time plus a time span proportional to d (v). Thus, if a vertex is added / removed, the complexity of maintaining the partitions according to Proposition 5 O (dmax) is in each step O (dmax). After Propositions 2 and 6, we have Proposition 7 The best picking heuristics in Algorithm 3 can be performed in O (dmax) complexity. In the local search phase according to Proposition 1, we have theorem 8 assumed that each vertex can be added or removed with equal probability, then the average complexity of the best picking heuristics in algorithm 3 O (davg). It is nice because (Cai 2015) has been determined that the best picking heuristics of O (C) is complexity."}, {"heading": "Complexity of The Max-gain/Min-gain Heuristics", "text": "(Cai 2015) formally proved that the maximum gain heuristic had a worst-case complexity of O (V | 2). In addition, both (UgurluAlgorithm 5: minGainConstructVC input: A graph G = (V, E) output: A cover C and if-optimal- garantied1 C \u2190 | | UE | E |; initialize the partitions; 2 while | UE | 0 do 3 k 1; 4 while the gain-k partition is empty do k \u2190 k + 1 min g v \u2190 a random vertex in the gain-k partition; 5 foreach v (min g v) N (min g v) do 6 if v-C then continue placeVertextVert IntoC (v); UE | UE | \u2212 gain gain gain gain gain (v).7 foreach n-N (v) do 8 if n-C then lossMinusMinus (n) elsegainMinusMinus (n) 9 return (C, optimum-not guaranteed), we."}, {"heading": "Experimental Evaluation", "text": "In this section we conduct extensive experiments to compare LinCom with the modern MinVC algorithm FastVC for local search using massive graphs. To show the individual effects, we also present the performance of our InitV-C method (referred to as InitVC in the tables)."}, {"heading": "Benchmarks", "text": "We downloaded all 139 instances 2 that were originally online, 3 and then converted to DIMACS chart format, but we excluded three extremely large instances because they have no memory for all algorithms here. So we tested all solvers on the remaining 136 instances, some of which were recently used in testing parallel algorithms for maximum clique- and coloring problems (Rossi and Ahmed 2014; Rossi et al. 2014).2http: / / lcs.ios.ac.cn / c aisw / Resource / realworld% 20graphs.tar.gz 3http: / / www.graphrepository.com. / networks.php"}, {"heading": "Experiment Setup", "text": "The experiments were conducted on a cluster equipped with a number of Intel (R) Xeon (R) CPUs X5650 @ 2.67 GHz with 8 GB RAM. All algorithms are executed on each instance with a time limit of 1000 seconds, with seeds ranging from 1 to 100. For each algorithm in each instance, we specify the minimum size (\"Cmin\") and the average size (\"Cavg\") of the vertex covers found by the algorithm. To make the comparisons clearer, we also report the difference (\", 000\") between the minimum size of the vertex cover found by FastVC and the minimum size found by LinCom. A positive case means that LinCom finds a smaller vertex cover, while a negative case means that FastVC finds a smaller vertex cover. The numbers of FastVC's vertex cover or LinCom's minimum size of the vertex cover found between these pages and the LinCom's (1) can relate to those of 106."}, {"heading": "Experimental Results", "text": "We show the most important experimental results in Tables 1 and 2. For reasons of space, we do not report the results in charts with less than 1000 corners. Furthermore, we do not report the results in charts where LinCom and FastVC represent exactly the same minimum size and average size. It is clear from the results in Tables 1 and 2 that LinCom achieves the best known solutions in most cases and makes significant progress. In fact, out of all 136 instances tested, LinCom is more robust with 264http: / / lcs.ios.ac.cn / caisw / Code / FastVC.zipless corners on average. This improvement is large as it is rare that a better solution is found (Cai 2015).2) LinCom is more robust. In fact, LinCom is more robust from 12 classes, LinCom surpasses FastVC over 7 classes, while FastVC over 1 class (e.g. facebook networks)."}, {"heading": "Conclusions and Future Work", "text": "In this paper, we have developed a local search algorithm for MinVC called LinCom, based on reduction rules and data structures, which help to generate a better quality initial euristics, while the data structures reduce the complexity of heuristics. The most important contributions are two folds: (1) we have reduced the complexity of two vertexes, covering construction euristics and best-picking heuristics based on the score-based alternative partitions at the theoretical level; (2) we apply these results and some reduction rules to develop a local search solver that surpasses the current state of the art."}], "references": [{"title": "Emergence of scaling in random networks. Science 286(5439):509\u2013512", "author": ["Barabasi", "Albert 1999] Barabasi", "A.-L", "R. Albert"], "venue": null, "citeRegEx": "Barabasi et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Barabasi et al\\.", "year": 1999}, {"title": "Numvc: An efficient local search algorithm for minimum vertex cover", "author": ["Cai"], "venue": "J. Artif. Intell. Res", "citeRegEx": "Cai,? \\Q2013\\E", "shortCiteRegEx": "Cai", "year": 2013}, {"title": "Vertex cover: Further observations and further improvements", "author": ["Kanj Chen", "J. Jia 2001] Chen", "I.A. Kanj", "W. Jia"], "venue": "J. Algorithms", "citeRegEx": "Chen et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2001}, {"title": "Introduction to Algorithms (3", "author": ["Cormen"], "venue": null, "citeRegEx": "Cormen,? \\Q2009\\E", "shortCiteRegEx": "Cormen", "year": 2009}, {"title": "On the hardness of approximating label-cover", "author": ["Dinur", "I. Safra 2004] Dinur", "S. Safra"], "venue": null, "citeRegEx": "Dinur et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Dinur et al\\.", "year": 2004}, {"title": "Structural and algorithmic aspects of massive social networks", "author": ["Eubank"], "venue": "In Proceedings of the Fifteenth Annual ACM-SIAM Symposium on Discrete Algorithms,", "citeRegEx": "Eubank,? \\Q2004\\E", "shortCiteRegEx": "Eubank", "year": 2004}, {"title": "Cliques, Coloring, and Satisfiability: Second DIMACS Implementation Challenge", "author": ["Johnson", "D.J. Trick 1996] Johnson", "M.A. Trick", "eds"], "venue": "Workshop, October", "citeRegEx": "Johnson et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Johnson et al\\.", "year": 1996}, {"title": "Reducibility among combinatorial problems", "author": ["R.M. Karp"], "venue": "In Proceedings of a symposium on the Complexity of Computer Computations, held March 20-22,", "citeRegEx": "Karp,? \\Q1972\\E", "shortCiteRegEx": "Karp", "year": 1972}, {"title": "Article: A heuristic approach for the vertex cover problem", "author": ["Ramdani Kettani", "O. Tadili 2013] Kettani", "F. Ramdani", "B. Tadili"], "venue": "International Journal of Computer Applications 82(4):9\u201311", "citeRegEx": "Kettani et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Kettani et al\\.", "year": 2013}, {"title": "Combinatorial Optimaization: Algorithms and Complexity", "author": ["Papadimitrious", "K. Steiglitz"], "venue": null, "citeRegEx": "Papadimitrious et al\\.,? \\Q1982\\E", "shortCiteRegEx": "Papadimitrious et al\\.", "year": 1982}, {"title": "A stochastic local search approach to vertex cover", "author": ["Helmert Richter", "S. Gretton 2007] Richter", "M. Helmert", "C. Gretton"], "venue": "In KI 2007: Advances in Artificial Intelligence, 30th Annual German Conference on AI,", "citeRegEx": "Richter et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Richter et al\\.", "year": 2007}, {"title": "The network data repository with interactive graph analytics and visualization", "author": ["Rossi", "R.A. Ahmed 2015] Rossi", "N.K. Ahmed"], "venue": "In Proceedings of the TwentyNinth AAAI Conference on Artificial Intelligence", "citeRegEx": "Rossi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Rossi et al\\.", "year": 2015}, {"title": "Fast maximum clique algorithms for large graphs", "author": ["Rossi"], "venue": "In 23rd International World Wide Web Conference,", "citeRegEx": "Rossi,? \\Q2014\\E", "shortCiteRegEx": "Rossi", "year": 2014}], "referenceMentions": [{"referenceID": 7, "context": "The Minimum Vertex Cover (MinVC) problem is a wellknown NP-hard problem (Karp 1972) with many real-world applications (Johnson and Trick 1996).", "startOffset": 72, "endOffset": 83}], "year": 2015, "abstractText": "The Minimum Vertex Cover (MinVC) problem is a well-known NP-hard problem. Recently there has been great interest in solving this problem on real-world massive graphs. For such graphs, local search is a promising approach to finding optimal or near-optimal solutions. In this paper we propose a local search algorithm that exploits reduction rules and data structures to solve the MinVC problem in such graphs. Experimental results on a wide range of real-word massive graphs show that our algorithm finds better covers than state-of-theart local search algorithms for MinVC. Also we present interesting results about the complexities of some wellknown heuristics.", "creator": "LaTeX with hyperref package"}}}