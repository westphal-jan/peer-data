{"id": "1509.07513", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Sep-2015", "title": "Description of the Odin Event Extraction Framework and Rule Language", "abstract": "This document describes the Odin framework, which is a domain-independent platform for developing rule-based event extraction models. Odin aims to be powerful (the rule language allows the modeling of complex syntactic structures) and robust (to recover from syntactic parsing errors, syntactic patterns can be freely mixed with surface, token-based patterns), while remaining simple (some domain grammars can be up and running in minutes), and fast (Odin processes over 100 sentences/second in a real-world domain with over 200 rules). Here we include a thorough definition of the Odin rule language, together with a description of the Odin API in the Scala language, which allows one to apply these rules to arbitrary texts.", "histories": [["v1", "Thu, 24 Sep 2015 20:10:27 GMT  (203kb,D)", "http://arxiv.org/abs/1509.07513v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["marco a valenzuela-esc\\'arcega", "gus hahn-powell", "mihai surdeanu"], "accepted": false, "id": "1509.07513"}, "pdf": {"name": "1509.07513.pdf", "metadata": {"source": "META", "title": "Description of the Odin Event Extraction Framework and Rule Language", "authors": ["Marco A. Valenzuela-Esc\u00e1rcega", "Gus Hahn-Powell", "Mihai Surdeanu"], "emails": ["marcov@email.arizona.edu", "hahnpowell@email.arizona.edu", "msurdeanu@email.arizona.edu"], "sections": [{"heading": null, "text": "ar Xiv: 150 9.07 513v 1 [cs.C L] 24 SeContents"}, {"heading": "1 Changes 3", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 Introduction 3", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3 A Walkthrough Example 4", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4 Rules 6", "text": "The number of people in the city has fallen to its lowest level since records began in 2000."}, {"heading": "5 Mentions, or the Output of Rules 21", "text": "5.1 Text mention......................................................................................................................................................................"}, {"heading": "6 Advanced: Customizing Rule Output with Actions 23", "text": "7 Merge: the Odin API 241 Changes 1.0: First release."}, {"heading": "2 Introduction", "text": "In fact, it is so that most of them are able to survive themselves without them being able to survive themselves, and that they are able to survive themselves, \"he said in an interview with the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" New York Times, \"the\" the \"New York Times,\" the \"the\" New York Times, \"the\" the \"New York Times,\" the \"the\" the \"New York,\" the \"the\" the \"the\" New York, \"the\" the \"the\" New York Times, \"the\" the \"the\" New York, \"the\" the \"the\" New York Times, \"the\" the \"the\" New York, \"the\" the \"the\" the \"New York Times,\" the \"the\" the \"the\" the \"the\" New York, \"the\" the \"the\" the \"the\" the \"the\" New York, the \"the\" the \"the\" the \"the\""}, {"heading": "3 A Walkthrough Example", "text": "In fact, most of them will be able to move to another world in which they are able, in which they are able to move, and in which they are able to move."}, {"heading": "4 Rules", "text": "As the previous example has shown, the basic building block of an Odin grammar is a rule. Rules define either surface patterns that are flat patterns over word strings, such as ner in the example (formally defined in Section 4.3), or patterns about the underlying syntactical structure of a sentence described by means of relational dependencies, such as Phospho, Ubiq, or Negreg (defined in Section 4.4). All Odin rules are written in YAML Ben-Kiki et al. [2005]. However, it is not necessary to be a YAML expert to use Odin, as we only use a small and simple YAML subset to write rules. A brief explanation of the required YAML features is given in Section 4.1."}, {"heading": "4.1 A Gentle Introduction to YAML", "text": "Odin rules are written with a small subset of YAML Ben-Kiki et al. [2005]. Specifically, we only use lists, associative arrays, and strings, which are briefly summarized below. For more details (although you should not need them), please refer to the YAML manual Ben-Kiki et al. [2005]."}, {"heading": "4.1.1 YAML Lists", "text": "YAML supports two different types of list specification: The recommended one for Odin requires each list element to appear on its own line, and it is characterized by preceding the actual element with a dash and a space. Elements of the same list must have the same indentation degree. As an example, a list of fruits in YAML notation is provided in Example 3.1 - apple 2 - banana 3 - orange 4 - watermelonExample 3: example YAML list."}, {"heading": "4.1.2 YAML Associative Arrays", "text": "YAML supports two different syntaxes for associative arrays. The recommended one for Odin is the one where each key-value pair appears in its own line, and all key-value pairs have the same indentation level. Each key must be followed by a colon. An example of an associative YAML array can be found in Example 4.1 first _ name: Homer 2 last _ name: Simpson 3 address: 742 Evergreen Terrace 4 town: Springfield dExample 4: Example YAML associative array"}, {"heading": "4.1.3 YAML Strings", "text": "There is one exception: the pattern field of the rule (as described in sections 4.3 and 4.4). Patterns can be complex, and it is a good idea to split them into multiple lines. YAML supports multi-line strings using the vertical bar character (e.g. |) to partition a key-value pair. If used, the string starts on the next line and is delimited by its indentation. An example of a multi-line string of YAML shows in Example 5.1 Var1: single-line string 2 Var2: | 3 this is a multi-line string 4 that is still part of the same string 5 because of its indentation 6 Var3: another single-line string Example 5: An example of a multi-line string of YAML associative array with a multi-line string value As shown, YAML strings do not need to be quoted occasionally."}, {"heading": "4.2 Rules", "text": "Odin rules are simply presented as YAML associative arrays, using the fields shown in Table 1. Uniquely, the most important part of a rule is the pattern field. In Section 4.3, we describe how to implement surface or \"token patterns,\" which are useful for simple sequences or when syntax is untrustworthy. In Section 4.4, we introduce the bread and butter of Odin: syntactic or \"dependency patterns.\" Note that both pattern types use some of the same constructs: string matchers (i.e. objects that can match a string) and token constraints (i.e. objects that impose complex conditions on individual tokens to match)."}, {"heading": "4.3 Token Patterns", "text": "A common task in information extraction is to extract structured information from text. Structured information can relate to various things, from item enumerations to complex event mentions. One way to extract this type of mentions from text is to use surface patterns that allow us to associate sequences of token sequences that normally signal the presence of the information we are interested in. Surface patterns are available in Odin through the use of \"token patterns.\" Odin's token patterns can correspond to continuous and discontinuous token sequences by applying linguistic constraints to each token pattern (Section 4.3.1), imposing structure (Section 4.3.5), generalizing through the use of operators (Section 4.3.6) and relying on context (Section 4.3.7). In this section, we will describe each of these features that make token patterns efficient and easy to use for various information extraction tasks."}, {"heading": "4.3.1 Token Constraints", "text": "Remember that in the simplest case, a character (or word) in Odin can be mapped simply by specifying a string. For example, to match the phosphorylation trigger in Example 1, all we had to do was write phosphorylation (quotation marks are optional), but, of course, Odin can do much more if he can match individual words. At this point, token constraints come in handy. A token constraint is a Boolean expression surrounded by square brackets that can be used to impose more complex conditions when mapping a token. Each token field has several fields that can be mapped: A token field is mapped by writing the field name, followed by the equals sign and a string matcher. (e.g. word = dog corresponds to the word \"dog,\" tag = / VP V / corresponds to each token field with a portion of the speech that begins with \"V,\" entity = \"B-person\" corresponds to each token character followed by a token sign and a string matchword corresponds to each word that corresponds to a part of the speech that begins with \"V.\""}, {"heading": "4.3.2 String Matchers", "text": "A string matcher is an object that matches a string. Matching strings is the most common operation in Odin and is used in both token and dependency patterns. This is because all token fields (described in Table 2) have string values that match string matchers. Additionally, dependency patterns (described in Section 4.4) match incoming and outgoing dependencies by matching the name of the dependency using the same string matchers. Strings can match accurately or with regular expressions. Both options are described next."}, {"heading": "4.3.3 Exact String Matchers", "text": "An exact string matcher is called a string literal, a string separated by quotation marks. The escape character is the backslash (e.g.\\). If the string is a valid Java identifier, the quotation marks can be omitted. For example, word = dog corresponds to the word \"dog.\""}, {"heading": "4.3.4 Regex String Matchers", "text": "A regex string matcher is characterized by a slash delimited regular Java expression.11 A slash can be escaped with a backslash. This is the only regular expression escape performed by Odin, everything else is handled by the Java regular expression engine."}, {"heading": "4.3.5 Named Arguments", "text": "Token patterns support two types of named arguments: those created \"on-the-fly\" from any sequence of tokens or those that refer to existing mentions; capturing a sequence of tokens and assigning a label for later use can be done with (? < identifier > pattern) notation, where identifier is the name of the argument and pattern is the token pattern whose result should be captured and associated with the argument name; capturing multiple sequences or mentions with the same name is supported, as are nested mentions (i.e. arguments defined within other arguments); Bonnie and Clyde rob bank1 argument (? < robber > bonnie) and (? robber > clyde) robbed [] (? < location > bank) Example 6: An example of a token pattern pattern with a repeated argument called @."}, {"heading": "4.3.6 Token Pattern Operations", "text": "Most basic token operations are concatenation and alternation; concatenation of two patterns is achieved by writing one pattern after another; alternation is achieved by separating the two patterns by the alternation operator (e.g. |), which is analogous to a Boolean OR.. 1 Brackets can be used to group such expressions. As usual, brackets take precedence over the alternation operator. Table 3 shows some simple examples of operators and brackets usage.11See http: / / docs.oracle.com / 8 / docs / api / regex / Pattern.htmlOdin also supports several types of quantifiers (see Table 4 for details). The?, * and + postfix quantifiers are used to quantify a pattern zero or once, zero or more times, and one or more times."}, {"heading": "4.3.7 Zero-width Assertions", "text": "Zero-width assurances allow you to check whether a pattern exists or not without including it in the matching result. Odin supports the following zero-width assurances:"}, {"heading": "4.3.8 Output", "text": "The output of any Odin rule is referred to as \"Mention,\" and these are actual cases of a Mention Scale class or one of its subclasses (see Section 5). Generally, the result of the successful application of a Mention Pattern is usually a TextBound Mention (see Section 5). However, if the Mention Pattern contains Named Mentions, then the result is a Mention Relationship, which is essentially a collection of Named Mentions or \"Arguments\" (but without a predicate or \"Trigger,\" which is typical of Event Mentions!). In other words, Mentions of Relationships are not dependent on a particular predicate. If one of the Named Mention Patterns has the name \"trigger\" (case sensitive), then Odin assumes that this pattern defines an event, and the result is an Event Mention (an instance of the Mention Mention Class), 10, and generates a simple relationship between one person and two examples."}, {"heading": "4.4 Dependency Patterns", "text": "While token patterns are quite powerful, they are, course, not too robust to syntactic variation (which is only). Writing patterns over syntactic structure produces generalizations with wider coverage that do not sacrifice precision. Consider the sentences in Figure 3: While it takes several token-pattern rules to accurately capture the syntactic variation shown in Figure 3, all of these variations can be covered by a single rule that uses a dependency pattern (see Example 11).1 - name: dancers _ 1 2 label: | 5 trigger = dance] 6 dancer: Entity = nsubj 7 partner: Entity = dobj ltant: Example _ withExample. A dependency rule that expects two arguments: (1) a nominal subject and (2) the headword completions of a \"with prepositional phrases from the lemmatized trigger, dance, dance, dance, dance; (2) precentized."}, {"heading": "4.4.1 Named Arguments for Dependency Patterns", "text": "It is clear that naming event arguments is important (e.g. you may want to track who the agent is and who the patient is in a robbery event), and we have probably already observed that Odin has a simple syntax for this: A path to an argument begins with name: label = path, where label is the label of an existing mention, and the path must lead to a token that is part of a mention with the specified label. Argument names are required and unique, i.e. you cannot have two different patterns with the same name, but the same pattern can correspond to several mentions! For example, if an argument with the name \"theme\" is assigned to three different units, then three event labels are created, each of which coincides with an entity as a theme. If the specified path to the theme is not mentioned, then no event labels are created. Sometimes, you have to make an argument optional or allow more than one argument with the same name."}, {"heading": "4.4.2 Quantifiers for Dependency Patterns", "text": "In addition to the above-mentioned quantifiers for event arguments, Odin supports quantifiers within the actual dependency patterns. They are used in Table 9.The?, * and + postfix quantifiers are used to match a pattern zero or once, zero or multiple times and one or more times. There is no idea of greedy / rotten dependency patterns. Remote repetitions can be specified by appending {m, n} to a pattern and mean that the pattern changes at least m times and at most n. If m is omitted (e.g. {, n}), the pattern must repeat from zero to n times. If n is omitted (e.g. {m,}), the pattern must repeat at least m times. There is no idea of greedy / rotten dependency patterns. For an exact number of repetitions, the suffix {n} is required."}, {"heading": "4.4.3 Zero-width Assertions", "text": "The lookaround syntax is (? = pattern) for positive claims and (?! pattern) for negative claims. Example 17 shows an example of a positive lookaround in action.Dennis crashed his car.1 - name: np 2 label: noun 3 priority: 1 4 type: Tokens 5 unit: tag 6 pattern: | 7 / N / 89 - name: accident-1 10 label: accident 11 priority: 2 12 pattern: | 13 trigger = [lemma = crash] 14 agent: Nomen = nsubj [tag = NNP] # We are only interested in proper names 15 # Only match if this is mom's car 16 vehicle: Noun = dobj (? = poss [lemma = mom]) [lemma = car] Example 17: Sometimes it comes down to ownership. Maybe we want to know if Dennis should be grounded if he crashes a car."}, {"heading": "4.4.4 Output", "text": "Oscar lives in a recycle bin 1 - name: dep _ event _ mention _ out 2 label: LivesIn 3 priority: 2 4 pattern: | 5 trigger = [lemma = live] 6 resident: Person = nsubj 7 location: Location prep _ inExample 18: An example of a dependency pattern rule that causes an event to be mentioned by specifying a trigger. Dr. Frankenstein spends a lot of time in Graveyard.1 - name: sometitle-1 2 label: Title 3 priority: 1 4 type: token 5 pattern: | 6 [word = / (? i) \u0432mr? s | dr | prof /] 7 8 - name: dep _ relation _ mention _ out label: PersonWithTitle10 priority: 2 11 pattern: | 12 person: title reference = an argument, but the first argument to be given is a dependency sample, which is not an example of 19."}, {"heading": "4.5 Building a Grammar", "text": "Of course, the next step is to merge them into a full grammar, which can be very simple: you only have to save them minimally in a single file, which is then loaded into an Odin engine (see Section 7). If efficiency is important to you, you can improve your grammar by assigning rules to priorities. Rules that correspond to entities, for example, should be executed beforehand (i.e. they have a lower priority) than rules that correspond to events in which these entities serve as arguments. (But even that is not necessary: Odin takes care of the pipeline rules internally.) But some domain grammars are more complicated than a simple sequence of rules. You may have event names that are so complex that you would prefer to store them in a taxonomy. Some event types have almost exactly the same syntactic representations as others, so you want to reuse some rules. Odin supports all of these topics. We will describe them in the next step."}, {"heading": "4.5.1 Master File", "text": "The master file is the starting point of a grammar, or the file is passed to the Odin runtime machine. As already mentioned, this file can simply be a set of rules for simple grammars. For more complicated scenarios, this file must contain a required rule section and two optional sections: taxonomy and variables. Let's describe these sections next."}, {"heading": "4.5.2 Taxonomy", "text": "Taxonomy is a forest (i.e. a collection of trees) of labels, which, if specified, is used by Odin as a hierarchy for mentioning names. An example of taxonomy is in Example 20.1 # a tree hierarchy can be used to define taxonomy 2 - organism: 3 - prokaryotic: 4 - archae bacteria 5 - eu bacteria 6 - eukaryotic: 7 - unicellular: 8 - protista 9 - multicellular: 10 - autotropic: 11 - plantae 12 - heterotropic: 13 - fungi 14 - animals 15 # we want to include robots in our taxonomy 16 #, but they are not organisms, what can we do? 17 # fortunately, several trees are supported 18 - robot example 20: Example taxonomy When a taxonomy is provided, all terms used by the rules must be declared taxonomic."}, {"heading": "4.5.3 Variables and Templates", "text": "It is very common for similar events to share the same syntactic structure. For example, in the biomedical domain, all biochemical reactions (there are between 10 and 20 of them) share the same structure. For example, \"A phosphorylates B\" is similar to \"A ubiquitinates B,\" except for the predicate: \"phosphorylates\" vs. \"ubiquitinates.\" In such situations, we want to reuse these syntactic structures between events (so we do not write the same rules 10-20 times). Odin supports this by using variables and rule templates where rule templates are simple rules that use variables."}, {"heading": "5 Mentions, or the Output of Rules", "text": "As indicated in this document, each rule generates a reference object if it successfully matches any text. These objects are not magical: we simply use them to store everything that contains the rule and match the corresponding text. Table 10 summarizes the fields of the reference object. Sometimes, actual code is best suited to explaining things. We strongly encourage the reader to take a look at the code that implements mention12. Note that some of the information stored in mentions, such as the token interval of mentions, relates to data structures generated by our preprocessing code, such as sentence and document."}, {"heading": "5.1 TextBoundMention", "text": "The simplest is TextBoundMention. A TextBoundMention is created when the output of a rule is a flat structure, i.e. a contiguous sequence of tokens in a sentence. Formally, a TextBoundMention has a token interval, but its argument card is empty. These mentions are usually used to represent entities or event triggers."}, {"heading": "5.2 RelationMention", "text": "A RelationMention encodes n-ary relationships between its arguments. All arguments are named (based on the argument names given in the matching rule) and are stored in the argumentation card. Importantly, multiple arguments can have the same name! This is extremely useful when one usually has to include enumerations of several valid arguments with the same role (for example, a food argument can include several foods consumed during a dinner)."}, {"heading": "5.3 EventMention", "text": "An EventMention is similar to a RelationMention, with only one additional feature: it has a TextBoundMention that represents the trigger of the event. In other words, the argument map contains an additional argument called trigger that stores the predicate of the event. Note: An event must have exactly one trigger. 12https: / / github.com / clulab / processors / blob / master / src / main / scala / edu / edu / arizona / sista / odin / Mention.scala13https: / / github.com / clulab / processors / blob / master / src / main / scala / edu / arizona / sista / processors / Document.scala"}, {"heading": "6 Advanced: Customizing Rule Output with Actions", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "7 Putting it Together: the Odin API", "text": "In recent years, it has become clear that the majority of people who work for the rights of women and men are not women, but men and women who work for the rights of men and women. (...) In recent years, it has become clear that women and men who work for the rights of women and men are acting in the most diverse positions and positions in the most diverse areas of working life and the world of work. (...) In recent years, it has become clear that women and men who work for the rights of women and the rights of women are acting in the most diverse positions. (...) In recent years, it has become clear that women and men and women are acting in the most diverse areas of the world of work and in the most diverse areas that are at stake. (...) In the areas that are at stake and that are at stake. \"(...) In recent years, it has become clear that women and men in the most diverse areas of the world of work are about the rights of men and women. (...)"}], "references": [{"title": "The common pattern specification language", "author": ["Douglas E Appelt", "Boyan Onyshkevych"], "venue": "In Proc. of the TIPSTER Workshop,", "citeRegEx": "Appelt and Onyshkevych.,? \\Q1998\\E", "shortCiteRegEx": "Appelt and Onyshkevych.", "year": 1998}, {"title": "Fastus: A finite-state processor for information extraction from real-world text", "author": ["Douglas E. Appelt", "Jerry R. Hobbs", "John Bear", "David Israel", "Mabry Tyson"], "venue": "In Proceedings of the International Conferences on Artificial Intelligence (IJCAI),", "citeRegEx": "Appelt et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Appelt et al\\.", "year": 1993}, {"title": "Yaml ain\u2019t markup language (yaml) version 1.1. yaml", "author": ["Oren Ben-Kiki", "Clark Evans", "Brian Ingerson"], "venue": "org, Tech. Rep,", "citeRegEx": "Ben.Kiki et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Ben.Kiki et al\\.", "year": 2005}, {"title": "TokensRegex: Defining cascaded regular expressions over tokens", "author": ["Angel X. Chang", "Christopher D. Manning"], "venue": "Technical Report CSTR 2014-02,", "citeRegEx": "Chang and Manning.,? \\Q2014\\E", "shortCiteRegEx": "Chang and Manning.", "year": 2014}, {"title": "Rule-based information extraction is dead! long live rule-based information extraction systems", "author": ["Laura Chiticariu", "Yunyao Li", "Frederick R Reiss"], "venue": "In Proc. of EMNLP,", "citeRegEx": "Chiticariu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Chiticariu et al\\.", "year": 2013}, {"title": "Developing Language Processing Components with GATE (Version", "author": ["Hamish Cunningham", "Diana Maynard", "Kalina Bontcheva", "Valentin Tablan", "Niraj Aswani", "Ian Roberts", "Genevieve Gorrell", "Adam Funk", "Angus Roberts", "Danica Damljanovic", "Thomas Heitz", "Mark A. Greenwood", "Horacio Saggion", "Johann Petrak", "Yaoyong Li", "Wim Peters"], "venue": null, "citeRegEx": "Cunningham et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Cunningham et al\\.", "year": 2011}, {"title": "The Stanford typed dependencies representation", "author": ["Marie-Catherine de Marneffe", "Christopher D. Manning"], "venue": "In Proc. of COLING Workshop on Cross-framework and Cross-domain Parser Evaluation,", "citeRegEx": "Marneffe and Manning.,? \\Q2008\\E", "shortCiteRegEx": "Marneffe and Manning.", "year": 2008}, {"title": "Opendmap: an open source, ontology-driven concept analysis engine, with applications to capturing knowledge regarding protein transport, protein interactions and cell-type-specific gene expression", "author": ["Lawrence Hunter", "Zhiyong Lu", "James Firby", "William A Baumgartner", "Helen L Johnson", "Philip V Ogren", "K Bretonnel Cohen"], "venue": "BMC bioinformatics,", "citeRegEx": "Hunter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hunter et al\\.", "year": 2008}, {"title": "Tregex and Tsurgeon: tools for querying and manipulating tree data structures", "author": ["Roger Levy", "Galen Andrew"], "venue": "In Proc. of LREC,", "citeRegEx": "Levy and Andrew.,? \\Q2006\\E", "shortCiteRegEx": "Levy and Andrew.", "year": 2006}, {"title": "The Stanford CoreNLP natural language processing toolkit", "author": ["C.D. Manning", "M. Surdeanu", "J. Bauer", "J. Finkel", "S.J. Bethard", "D. McClosky"], "venue": "In Proc. of ACL,", "citeRegEx": "Manning et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Manning et al\\.", "year": 2014}, {"title": "Text chunking using transformation-based learning", "author": ["Lance A Ramshaw", "Mitchell P Marcus"], "venue": "arXiv preprint cmp-lg/9505040,", "citeRegEx": "Ramshaw and Marcus.,? \\Q1995\\E", "shortCiteRegEx": "Ramshaw and Marcus.", "year": 1995}], "referenceMentions": [{"referenceID": 4, "context": "Rule-based information extraction (IE) has long enjoyed wide adoption throughout industry, though it has remained largely ignored in academia, in favor of machine learning (ML) methods [Chiticariu et al., 2013].", "startOffset": 185, "endOffset": 210}, {"referenceID": 9, "context": "The design of Odin followed the simplicity principles promoted by other natural language processing toolkits, such as Stanford\u2019s CoreNLP, which aim to \u201cavoid over-design\u201d, \u201cdo one thing well\u201d, and have a user \u201cup and running in ten minutes or less\u201d [Manning et al., 2014].", "startOffset": 249, "endOffset": 271}, {"referenceID": 1, "context": "Conceptually, Odin follows the same strategy introduced by FASTUS more than 20 years ago Appelt et al. [1993]: it applies a cascade of grammars, where each grammar builds on the output produced by the previous one.", "startOffset": 89, "endOffset": 110}, {"referenceID": 10, "context": "10The IOB or BIO notation is a common representation, first proposed in Ramshaw and Marcus [1995], used to capture sequences of words that form named entity mentions.", "startOffset": 72, "endOffset": 98}, {"referenceID": 2, "context": "All Odin rules are written in YAML Ben-Kiki et al. [2005]. However, it is not necessary to be a YAML expert to use Odin, as we only use a small and simple YAML subset to write rules.", "startOffset": 35, "endOffset": 58}, {"referenceID": 2, "context": "1 A Gentle Introduction to YAML Odin rules are written using a small YAML Ben-Kiki et al. [2005] subset.", "startOffset": 74, "endOffset": 97}, {"referenceID": 2, "context": "1 A Gentle Introduction to YAML Odin rules are written using a small YAML Ben-Kiki et al. [2005] subset. In particular, we only use lists, associative arrays, and strings, which are briefly summarized below. For more details (although you should not need them), please read the YAML manual Ben-Kiki et al. [2005].", "startOffset": 74, "endOffset": 313}, {"referenceID": 6, "context": "Again, we currently use Stanford dependencies de Marneffe and Manning [2008] in Odin, but Odin is independent of the representation used.", "startOffset": 49, "endOffset": 77}], "year": 2015, "abstractText": "This document describes the Odin framework, which is a domain-independent platform for developing rule-based event extraction models. Odin aims to be powerful (the rule language allows the modeling of complex syntactic structures) and robust (to recover from syntactic parsing errors, syntactic patterns can be freely mixed with surface, token-based patterns), while remaining simple (some domain grammars can be up and running in minutes), and fast (Odin processes over 100 sentences/second in a real-world domain with over 200 rules). Here we include a thorough definition of the Odin rule language, together with a description of the Odin API in the Scala language, which allows one to apply these rules to arbitrary texts. 1 ar X iv :1 50 9. 07 51 3v 1 [ cs .C L ] 2 4 Se p 20 15", "creator": "LaTeX with hyperref package"}}}