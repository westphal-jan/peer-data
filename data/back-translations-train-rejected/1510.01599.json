{"id": "1510.01599", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Oct-2015", "title": "Disjunctive Answer Set Solvers via Templates", "abstract": "Answer set programming is a declarative programming paradigm oriented towards difficult combinatorial search problems. A fundamental task in answer set programming is to compute stable models, i.e., solutions of logic programs. Answer set solvers are the programs that perform this task. The problem of deciding whether a disjunctive program has a stable model is $\\Sigma^P_2$-complete. The high complexity of reasoning within disjunctive logic programming is responsible for few solvers capable of dealing with such programs, namely DLV, GnT, Cmodels, CLASP and WASP. In this paper we show that transition systems introduced by Nieuwenhuis, Oliveras, and Tinelli to model and analyze satisfiability solvers can be adapted for disjunctive answer set solvers. Transition systems give a unifying perspective and bring clarity in the description and comparison of solvers. They can be effectively used for analyzing, comparing and proving correctness of search algorithms as well as inspiring new ideas in the design of disjunctive answer set solvers. In this light, we introduce a general template, which accounts for major techniques implemented in disjunctive solvers. We then illustrate how this general template captures solvers DLV, GnT and Cmodels. We also show how this framework provides a convenient tool for designing new solving algorithms by means of combinations of techniques employed in different solvers.", "histories": [["v1", "Tue, 6 Oct 2015 14:42:38 GMT  (68kb)", "http://arxiv.org/abs/1510.01599v1", "To appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["remi brochenin", "yuliya lierler", "marco maratea"], "accepted": false, "id": "1510.01599"}, "pdf": {"name": "1510.01599.pdf", "metadata": {"source": "CRF", "title": "Disjunctive Answer Set Solvers via Templates", "authors": ["REMI BROCHENIN"], "emails": ["remi.brochenin@unige.it)", "ylierler@unomaha.edu)", "marco@dibris.unige.it)"], "sections": [{"heading": null, "text": "ar Xiv: 151 0.01 599v 1KEYWORDS: Answer Set Programming, Abstract Solvers"}, {"heading": "1 Introduction", "text": "In fact, it is such that most of them will be able to move into another world, in which they are able to integrate themselves, in which they are able to live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they are able to move, in which they are able to integrate themselves, and in which they are able to live in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they"}, {"heading": "2 Preliminaries", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Formulas, Logic Programs, and Program\u2019s Completion", "text": "In fact, most of them are able to determine for themselves what they want and what they want to do."}, {"heading": "3 A Two-Layer Abstract Solver", "text": "The question of whether it is a pure problem arises not only in the United States, but also in other countries. (...) The question is whether it is a pure problem or not. (...) The question is to what extent it is a pure problem. (...) The question is whether it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (...) The question is to what extent it is a pure problem. (... The question is to what extent it is.) The question is to what extent it is a pure problem. (... The question is to what extent it is a pure problem."}, {"heading": "4 Graph Templates", "text": "In Brochenin et al. (2014), transitional systems were used to capture multiple disjunctive solvers, namely cmodels, gnt, and dlv, which implement traceability, and the transitional systems highlighted the similarities that these solvers have in common. For example, all solvers are based on a two-tiered approach in the spirit of the dp-assat-proc algorithm. In this thesis, we take an additional step toward a unifying framework for capturing two-tiered methods. We introduce a graph template that we then use to include disjunctive solvers cmodels, gnt, and dlv."}, {"heading": "4.1 A Single Layer Graph Template", "text": "In fact, most of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move and to move."}, {"heading": "4.2 A Two-Layer Graph Template", "text": "It is about the question of the extent to which it is a question of the way in which people are able to survive themselves. (...) It is about the question to what extent people are able to survive themselves. (...) It is about the question to what extent people are able to survive themselves. (...) It is about the question to what extent people are able to survive themselves. (...) It is about the question to what extent they are able to survive themselves. (...) It is about the question to what extent they are able to survive themselves. (...) It is about the question to what extent they are able to survive themselves."}, {"heading": "5 Applications of the Template", "text": "In this section, we will show how the approach underlying the disjunctive solution can be captured by the two-layer template. Unlike solver cmodels, which uses the dpll method for generating and testing, the system uses gnt the Smodels approach for the respective tasks. Recall that the Smodels approach finds stable models for non-disjunctive logical programs, while the dpll approach finds classic models."}, {"heading": "6 Proofs", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "6.1 Proof of Theorem 2", "text": "We begin by giving several lemmas that will be crucial in constructing arguments for Theorem 2. Remember that up = {UnitPropagate}.Lemma 1 The set-up is cla-complette.In other words, for any program and any complete and consistent set M of literals about atoms, the set M is a clan model of \"iff UnitPropagate\" (, M) = \u2205."}, {"heading": "Proof", "text": "From left to right: Let's assume M is a Kla model of. \"Our proof is by contradiction. Let's assume that UnitPropagate 6 = \u2205. Let's assume any literal l from this group. Then, the literal l is such that it doesn't belong to M. Besides, there's a rule in\" that corresponds to a sentence C, so that all the literals of \"C\" occur in \"M.\" Since M is a Kla model of \"I,\" let's conclude that l \"M.\" We deduce a contradiction. Right to left: Let the literals of \"C\" and l occur in \"M\" (in fact, \"M\" is a complete set of words about atoms. \"Let's assume that M is\" not a Kla model of \"I.\" Then there's a rule in \"that corresponds to a sentence of\" C, \"so that all the literals of\" I \"and L\" occur in M (in fact, \"M\" is a complete set of words about atoms \"), because\" M \"does not fulfill any rule in\" M. \""}, {"heading": "Proof", "text": "Assume that there is a rule A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A A-A-A-A-A A A A A-A-A A-A A A-A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A"}, {"heading": "Proof", "text": "By the contradiction. Let's assume M is a stable M-Model. Then M is also a classic M-Model. Through the first sentence M is such that there is no empty subset of M +, so that there is an unfounded amount of M w.r.t. Since M-U is 6 = \u2205, it follows that M-U is not an unfounded amount of M-U. It follows that for some rules a-A-B-B-B-B-B-B-B-B-B-B is so valid that a-M-B-U all the following conditions apply 1. M-B-A-A, 2. M-U-B-A-A-A-A-A-A-A-A and 3. (M-U) -A-B-B. Since M-B-B-B-B-B-B-B-B-B-B-B-B-B-B-B-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A, the following conditions apply 1. M-B-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-fact, and 3. (M-U-U-B-B-B-B-B-B-B-B-B-B-B-B-B-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-fact, that A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-fact, A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-A-"}, {"heading": "Proof of Theorem 2", "text": "We must show that all the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters, the letters of the letters, the letters of the letters, the letters of the letters, the letters of the letters, the letters and the letters of the letters, the letters and the letters of the letters of the letters of the letters, the letters and the letters of the letters of the letters of the letters and the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters of the letters, the letters of the letters and the letters of the letters of the letters of the letters and the letters of the letters of the letters."}, {"heading": "6.2 Proofs of Theorems 3, 4, Propositions 2, 4, 5, 6", "text": "We begin with the proof for theorem 4. We skip the proof for theorem 3 because it is based on the same evidentiary techniques as the proof for theorem 4. The proof for theorem 4 is based on auxiliary lemmas as well as proofs for the following propositions 4, 5, 6. We close this section with the proof for theorem 2. Lemma 4. Let g be a generative function and t be a witness function. Let Pg and Pt be propositions of p-conditions.Then the diagram STT Pg, g Pt, t (BA) is finite and acyclic for each of them."}, {"heading": "Proof", "text": "Consider the states of the graph STT Pg, g Pt, t (). Since the string L of the states of the form (L, R) s or the type Ok (L) is composed of a series of atoms limited by the size of L. Moreover, L does not allow repetitions. Therefore, there is a finite number of possible strings L in the states (L, R). Since t (L) has a finite number of atoms and there is a finite number of possible L, the amount of atoms over which R is built is finite. Consequently, there is a finite number of possible R. We come to the conclusion that there is a finite number of possible states (L, L)."}, {"heading": "Proof of Proposition 5", "text": "First, we show that l1. \u00b7 \u00b7 \u00b7.lk1 is consistent. Contradictory. Suppose that l1. \u00b7 \u00b7 \u00b7.lk1 is inconsistent. Since conclusion L is not applicable, l1. \u00b7 \u00b7 \u00b7.lk1 contains at least one literal decision. Since BacktrackL is not applicable, l1. \u00b7 \u00b7 \u00b7.lk1 does not contain a literal decision. We deduce an inconsistency from it. Since DecideL is not applicable and l1. \u00b7 \u00b7.lk1 is consistent, l1. \u00b7 \u00b7.lk1 assigns all atoms of the atoms (g)."}, {"heading": "Proof of Proposition 6", "text": "Statements (a \u2212 c) We prove these statements by induction about the length of a path in the graph STT Pg, g Pt, t (\u0441) from the initial state. Since the statements in the initial state of the graph are trivial, we only have to prove that all transition rules of the"}, {"heading": "STT", "text": "Similarly, it is easy to identify the ownership structure that preserves it. (c) It applies to all transitions (1). (c) It applies to all transitions (1). (c) It applies to all transitions (1). (c) It applies to all transitions (1). (c) It applies to all transitions (1). (c) It applies to all transitions (1). (c) It applies to all transitions (1). (2) It applies to all transitions (1). (2) It applies to all transitions rules (1). (1) It applies to all transitions rules (1). (2) It applies to all. (2) It does not apply. (2) It applies to all transitions rules (1). (2) It applies to all transitions rules (1)."}, {"heading": "Proof", "text": "We prove statements (a) and (b) by induction about the length of a path in the diagram"}, {"heading": "STT", "text": "\u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7"}, {"heading": "Proof", "text": "We assume that there is a final state of form (L, R). (L, R) We derive a contradiction. (L, R) We derive a contradiction. (L) We derive a contradiction. (L) We do not apply a final state. (L) We are a final state that is attainable from the initial situation. (L) We differ from the initial situation. (L, R) We have a final state that is attainable from the initial situation. (L) We differ from the initial situation. (L) This transition only leads to a transition phase. (L) This transition can only lead to a transition phase. (L) Let us call such a state. (L, R) s is a final state that is attainable from the initial situation."}, {"heading": "Proof of Proposition 4", "text": "First, we illustrate that any set of M letters that is a w1 model of g (\u0442, M), so that t (\u0442, M) does not have a w2 model, so that M | atoms (\u0442) is a stable model of B. In fact, M | atoms (\u0442) is a stable model of B. By defining w1-approximizing and w2-securing functions W.R.T. w, M | atoms (\u0442) is a stable model of B. Second, we consider any stable model L. By defining w1-approximizing and w2-securing functions W.R.T. w, it follows that it is M \u2032 that M \u2032 | atoms (\u0442) = L and M \u00b2 is a w1 model of g (\u0442, M \u00b2), so that t (\u0442, M \u00b2) does not have a w2 model."}, {"heading": "Proof of Theorem 4", "text": "Let w1 denote a type so that Pg is w1-enforcing and the function g w1-approximating. Let w2 denote a type so that Pt is w2-enforcing and function t w2-ensuring. Let us now proceed to prove the four conditions of the definition of \"verification\" one by one. 1. By Lemma 4, the graph STT Pg, g Pt, t () is acyclic and finite. 2. By Lemma 6 point 1, each end state is either Fail State or Ok (L). 3. By Lemma 6 point 1, each end state of STT Pg, g Pt, t (B) is attainable from the initial state and except Fail State is Ok (L), where L is a w1 model of g (E), so that t (E, L) does not have a w2 model."}, {"heading": "Proof of Proposition 2", "text": "Similarly, according to Lemma 2, up is clan assertion.1. According to Lemma 4, DP 2g, t (\u044b) is finite and acyclic. 2. According to Lemma 6 point 1, each end state is either fail state or Ok (L). 3. According to Lemma 6 point 1, each end state of STT Pg, g Pt, t (\u0442) is reachable from the initial state and outside of fail state is Ok (L), where L is a clan model of g (\u0442, L), so that t (\u0442, L) has no clan model. 4. According to Lemma 6 point 2, failure state is reachable from the initial state iff g (\u0430) has no clan model L, so t (\u0442, L) has no clan model."}, {"heading": "6.3 Proof of Theorem 5", "text": "First, we prove an auxiliary problem that will help us deal with the CNF conversion of DNF formulas. For a DNF formula F, we define CNF (F) as the conversion of F to CNF using simple equivalent transformations: the distribution of the disjunction over the conjunction. Lemma 7Let F be a DNF formula. Let l be a letter of F. Let M be a set of words. The following two statements are equivalent: 1. There is a subjunctive clause D of F, so that for each subjunctive clause D \u2032 F that differs from D \u2032 contradicts by M, 2. There is a sentence C of CNF (F), so that l \u00b8 C and M contradict C\\ {l}."}, {"heading": "Proof", "text": "Formula F has the form that formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula F = 1, formula F = 1, formula F = 1, formula F = 1, formula F = 1, formula F = 1, formula F = 2, formula F = 1, formula F = 1, formula F = 1, formula F = 1, formula F = 2, formula F = 1, formula F = 1, formula F = 1, formula 1. Formula F = 1, formula 1. Formula F = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = I. Formula I = 1, formula I. Formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1, formula I = 1"}, {"heading": "Proof of Theorem 5", "text": "There remains a case in which it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question, to what is a question, to what extent it is a question, to what is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question to what it is a question, to what extent it is a question, to what extent it is a question, to what is a question to what is a question, to what extent it is a question to what is a question, to what extent it is a question to what extent it is a question, to what extent it is a question, to what is a question, to what extent it is a question to what extent it is a question, to what extent it is a question to what extent, to what is a question to what extent it is a question, to what is a question, to what is a question to what is a question, to what extent it is a question, to what extent it is a question, to what extent it is a question to what extent, to what is a question, to what is"}, {"heading": "7 Conclusions, Future and Related Work", "text": "In this paper, we continue this direction of work by presenting a two-tiered framework suitable for capturing disjunctive approaches. We argue that this framework allows for easier analysis and comparison of these systems. We first introduce a general template that includes the techniques implemented in such solvers, and then define specific approaches by using this template. Formal results on the accuracy of abstract representations are given. We believe that this work is a springboard toward clear, comprehensive design features of current disjunctive approaches by defining appropriate techniques using this template. Formal results on the accuracy of abstract representations are given."}], "references": [{"title": "WASP: A native ASP solver based on constraint learning", "author": ["M. Alviano", "C. Dodaro", "W. Faber", "N. Leone", "F. Ricca"], "venue": "Proceedings of the 12th International Conference of Logic Programming and Nonmonotonic Reasoning (LPNMR 2013), P. Cabalar and T. C. Son, Eds. Lecture Notes in Computer Science, vol. 8148. Springer, 54\u201366.", "citeRegEx": "Alviano et al\\.,? 2013", "shortCiteRegEx": "Alviano et al\\.", "year": 2013}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press.", "citeRegEx": "Baral,? 2003", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Abstract disjunctive answer set solvers", "author": ["R. Brochenin", "Y. Lierler", "M. Maratea"], "venue": "Proceedings of the 21st European Conference on Artificial Intelligence (ECAI 2014). Frontiers in Artificial Intelligence and Applications, vol. 263. IOS Press, 165\u2013170.", "citeRegEx": "Brochenin et al\\.,? 2014", "shortCiteRegEx": "Brochenin et al\\.", "year": 2014}, {"title": "Inferring phylogenetic trees using answer set programming", "author": ["D.R. Brooks", "E. Erdem", "S.T. Erdo\u011fan", "J.W. Minett", "D. Ringe"], "venue": "Journal of Automated Reasoning 39, 471\u2013511.", "citeRegEx": "Brooks et al\\.,? 2007", "shortCiteRegEx": "Brooks et al\\.", "year": 2007}, {"title": "A machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7), 394\u2013397.", "citeRegEx": "Davis et al\\.,? 1962", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "Complexity results for disjunctive logic programming and application to nonmonotonic logics", "author": ["T. Eiter", "G. Gottlob"], "venue": "Proceedings of the 1993 International Logic Programming Symposium (ILPS), D. Miller, Ed. 266\u2013278.", "citeRegEx": "Eiter and Gottlob,? 1993", "shortCiteRegEx": "Eiter and Gottlob", "year": 1993}, {"title": "Disjunctive Datalog", "author": ["T. Eiter", "G. Gottlob", "H. Mannila"], "venue": "ACM Transactions on Database Systems 22, 3 (Sept.), 364\u2013418.", "citeRegEx": "Eiter et al\\.,? 1997", "shortCiteRegEx": "Eiter et al\\.", "year": 1997}, {"title": "Enhancing efficiency and expressiveness in answer set programming systems", "author": ["W. Faber"], "venue": "Ph.D. thesis, Ph.D. dissertation, Vienna University of Technology.", "citeRegEx": "Faber,? 2002", "shortCiteRegEx": "Faber", "year": 2002}, {"title": "Advanced conflict-driven disjunctive answer set solving", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI 2013), F. Rossi, Ed. IJCAI/AAAI.", "citeRegEx": "Gebser et al\\.,? 2013", "shortCiteRegEx": "Gebser et al\\.", "year": 2013}, {"title": "Tableau calculi for answer set programming", "author": ["M. Gebser", "T. Schaub"], "venue": "Proceedings of the 22nd International Conference on Logic Programming (ICLP 2006), S. Etalle and M. Truszczynski, Eds. Lecture Notes in Computer Science, vol. 4079. Springer, 11\u201325.", "citeRegEx": "Gebser and Schaub,? 2006", "shortCiteRegEx": "Gebser and Schaub", "year": 2006}, {"title": "Tableau calculi for logic programs under answer set semantics", "author": ["M. Gebser", "T. Schaub"], "venue": "ACM Transaction on Computational Logic 14, 2, 15.", "citeRegEx": "Gebser and Schaub,? 2013", "shortCiteRegEx": "Gebser and Schaub", "year": 2013}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. Kowalski and K. Bowen, Eds. MIT Press, 1070\u2013 1080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "On the relation among answer set solvers", "author": ["E. Giunchiglia", "N. Leone", "M. Maratea"], "venue": "Annals of Mathematics and Artificial Intelligence 53, 1-4, 169\u2013204.", "citeRegEx": "Giunchiglia et al\\.,? 2008", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2008}, {"title": "On the relation between answer set and SAT procedures (or, between smodels and cmodels)", "author": ["E. Giunchiglia", "M. Maratea"], "venue": "Proceedings of the 21st International Conference on Logic Programming (ICLP 2005), M. Gabbrielli and G. Gupta, Eds. Lecture Notes in Computer Science, vol. 3668. Springer, 37\u201351.", "citeRegEx": "Giunchiglia and Maratea,? 2005", "shortCiteRegEx": "Giunchiglia and Maratea", "year": 2005}, {"title": "Unfolding partiality and disjunctions in stable model semantics", "author": ["T. Janhunen", "I. Niemel\u00e4", "D. Seipel", "P. Simons", "You", "J.-H."], "venue": "ACM Transactions on Computunational Logic 7, 1, 1\u201337.", "citeRegEx": "Janhunen et al\\.,? 2006", "shortCiteRegEx": "Janhunen et al\\.", "year": 2006}, {"title": "Enhancing disjunctive logic programming systems by sat checkers", "author": ["C. Koch", "N. Leone", "G. Pfeifer"], "venue": "Artificial Intelligence 151, 1-2, 177\u2013212.", "citeRegEx": "Koch et al\\.,? 2003", "shortCiteRegEx": "Koch et al\\.", "year": 2003}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "W. Faber", "G. Pfeifer", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7, 3, 499\u2013562.", "citeRegEx": "Leone et al\\.,? 2006", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation", "author": ["N. Leone", "P. Rullo", "F. Scarcello"], "venue": "Information and Computation 135(2), 69\u2013 112.", "citeRegEx": "Leone et al\\.,? 1997", "shortCiteRegEx": "Leone et al\\.", "year": 1997}, {"title": "Cmodels: SAT-based disjunctive answer set solver", "author": ["Y. Lierler"], "venue": "Proceedings of the 8th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2005), C. Baral, G. Greco, N. Leone, and G. Terracina, Eds. Lecture Notes in Computer Science, vol. 3662. Springer, 447\u2013452.", "citeRegEx": "Lierler,? 2005", "shortCiteRegEx": "Lierler", "year": 2005}, {"title": "Abstract answer set solvers", "author": ["Y. Lierler"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP 2008), M. G. de la Banda and E. Pontelli, Eds. Lecture Notes in Computer Science, vol. 5366. Springer, 377\u2013391.", "citeRegEx": "Lierler,? 2008", "shortCiteRegEx": "Lierler", "year": 2008}, {"title": "SAT-based answer set programming", "author": ["Y. Lierler"], "venue": "Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "Lierler,? 2010", "shortCiteRegEx": "Lierler", "year": 2010}, {"title": "Abstract answer set solvers with backjumping and learning", "author": ["Y. Lierler"], "venue": "Theory and Practice of Logic Programming 11, 135\u2013169.", "citeRegEx": "Lierler,? 2011", "shortCiteRegEx": "Lierler", "year": 2011}, {"title": "Transition systems for model generators - a unifying approach", "author": ["Y. Lierler", "M. Truszczynski"], "venue": "Theory and Practice of Logic Programming 11, 4-5, 629\u2013646.", "citeRegEx": "Lierler and Truszczynski,? 2011", "shortCiteRegEx": "Lierler and Truszczynski", "year": 2011}, {"title": "Answer Set Planning", "author": ["V. Lifschitz"], "venue": "Proceedings of the 16th International Conference on Logic Programming (ICLP 1999), D. D. Schreye, Ed. The MIT Press, Las Cruces, New Mexico, USA, 23\u201337.", "citeRegEx": "Lifschitz,? 1999", "shortCiteRegEx": "Lifschitz", "year": 1999}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013398.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1999", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM 53(6), 937\u2013977.", "citeRegEx": "Nieuwenhuis et al\\.,? 2006", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "Enhancing DLV instantiator by backjumping techniques", "author": ["S. Perri", "F. Scarcello", "G. Catalano", "N. Leone"], "venue": "Annals of Mathematics and Artificial Intelligence 51, 2-4, 195\u2013228.", "citeRegEx": "Perri et al\\.,? 2007", "shortCiteRegEx": "Perri et al\\.", "year": 2007}, {"title": "Team-building with answer set programming in the gioia-tauro seaport", "author": ["F. Ricca", "G. Grasso", "M. Alviano", "M. Manna", "V. Lio", "S. Iiritano", "N. Leone"], "venue": "Theory and Practice of Logic Programming 12, 3, 361\u2013381.", "citeRegEx": "Ricca et al\\.,? 2012", "shortCiteRegEx": "Ricca et al\\.", "year": 2012}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence 138, 181\u2013234.", "citeRegEx": "Simons et al\\.,? 2002", "shortCiteRegEx": "Simons et al\\.", "year": 2002}, {"title": "Developing a Declarative Rule Language for Applications in Product Configuration", "author": ["T. Soininen", "I. Niemel\u00e4"], "venue": "Proceedings of the 1st International Workshop on Practical Aspects of Declarative Languages (PADL 1999), G. Gupta, Ed. Lecture Notes in Computer Science, vol. 1551. Springer, 305\u2013319.", "citeRegEx": "Soininen and Niemel\u00e4,? 1999", "shortCiteRegEx": "Soininen and Niemel\u00e4", "year": 1999}, {"title": "Omega-restricted logic programs", "author": ["T. Syrj\u00e4nen"], "venue": "Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001), T. Eiter, W. Faber, and M. Truszczynski, Eds. Lecture Notes in Computer Science, vol. 2173. Springer, 267\u2013279.", "citeRegEx": "Syrj\u00e4nen,? 2001", "shortCiteRegEx": "Syrj\u00e4nen", "year": 2001}], "referenceMentions": [{"referenceID": 25, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 26, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 1, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 6, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 11, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 12, "context": "Answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Baral 2003; Eiter et al. 1997; Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) is a declarative programming paradigm oriented towards difficult combinatorial search problems.", "startOffset": 23, "endOffset": 153}, {"referenceID": 3, "context": "ASP has been applied to solve problems in various areas of science and technology including graph-theoretic problems arising in zoology and linguistics (Brooks et al. 2007), team building problems in container terminal (Ricca et al.", "startOffset": 152, "endOffset": 172}, {"referenceID": 29, "context": "2007), team building problems in container terminal (Ricca et al. 2012), and product configuration tasks (Soininen and Niemel\u00e4 1999).", "startOffset": 52, "endOffset": 71}, {"referenceID": 31, "context": "2012), and product configuration tasks (Soininen and Niemel\u00e4 1999).", "startOffset": 39, "endOffset": 66}, {"referenceID": 12, "context": "Gelfond and Lifschitz introduced logic programs with disjunctive rules (Gelfond and Lifschitz 1991).", "startOffset": 71, "endOffset": 99}, {"referenceID": 5, "context": "The problem of deciding whether a disjunctive program has a stable model is \u03a32 -complete (Eiter and Gottlob 1993).", "startOffset": 89, "endOffset": 113}, {"referenceID": 17, "context": "Only five answer set systems can solve disjunctive programs: dlv (Leone et al. 2006), gnt (Janhunen et al.", "startOffset": 65, "endOffset": 84}, {"referenceID": 15, "context": "2006), gnt (Janhunen et al. 2006), cmodels (Lierler 2005), clasp (Gebser et al.", "startOffset": 11, "endOffset": 33}, {"referenceID": 19, "context": "2006), cmodels (Lierler 2005), clasp (Gebser et al.", "startOffset": 15, "endOffset": 29}, {"referenceID": 8, "context": "2006), cmodels (Lierler 2005), clasp (Gebser et al. 2013) andwasp (Alviano et al.", "startOffset": 37, "endOffset": 57}, {"referenceID": 0, "context": "2013) andwasp (Alviano et al. 2013).", "startOffset": 14, "endOffset": 35}, {"referenceID": 14, "context": "These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 74, "endOffset": 129}, {"referenceID": 13, "context": "These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 74, "endOffset": 129}, {"referenceID": 9, "context": "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 26, "endOffset": 74}, {"referenceID": 10, "context": "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 26, "endOffset": 74}, {"referenceID": 20, "context": "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 122, "endOffset": 181}, {"referenceID": 22, "context": "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 122, "endOffset": 181}, {"referenceID": 23, "context": "2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011).", "startOffset": 122, "endOffset": 181}, {"referenceID": 4, "context": "(2006), where authors propose to use transition systems to describe the Davis-Putnam-Logemann-Loveland (dpll) procedure (Davis et al. 1962).", "startOffset": 120, "endOffset": 139}, {"referenceID": 22, "context": "This approach has been adapted (Lierler 2011; Lierler and Truszczynski 2011) to describing answer set solvers for non-disjunctive programs including smodels, cmodels, and clasp.", "startOffset": 31, "endOffset": 76}, {"referenceID": 23, "context": "This approach has been adapted (Lierler 2011; Lierler and Truszczynski 2011) to describing answer set solvers for non-disjunctive programs including smodels, cmodels, and clasp.", "startOffset": 31, "endOffset": 76}, {"referenceID": 0, "context": "2013) andwasp (Alviano et al. 2013). Several formal approaches have been used to describe and compare search procedures implemented in answer set solvers. These approaches range from a pseudocode representation of the procedures (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008), to tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013), to abstract frameworks via transition systems (Lierler 2008; Lierler 2011; Lierler and Truszczynski 2011). The latter method originates from the work by Nieuwenhuis et al. (2006), where authors propose to use transition systems to describe the Davis-Putnam-Logemann-Loveland (dpll) procedure (Davis et al.", "startOffset": 15, "endOffset": 534}, {"referenceID": 2, "context": "The current paper builds on the content presented by Brochenin et al. (2014). It enhances the earlier work by introducing notions of a graph template, \u201cpropagator conditions\u201d, and \u201capproximating pairs\u201c that allow to more uniformly account for major techniques implemented in disjunctive answer set solvers.", "startOffset": 53, "endOffset": 77}, {"referenceID": 32, "context": "Software systems called grounders (Syrj\u00e4nen 2001; Perri et al. 2007) are used to take a logic program with variables as its input and produce a propositional program as its output so that the resulting propositional program has the same answer sets as the input program.", "startOffset": 34, "endOffset": 68}, {"referenceID": 28, "context": "Software systems called grounders (Syrj\u00e4nen 2001; Perri et al. 2007) are used to take a logic program with variables as its input and produce a propositional program as its output so that the resulting propositional program has the same answer sets as the input program.", "startOffset": 34, "endOffset": 68}, {"referenceID": 18, "context": "For a program \u03a0 and a consistent set L of literals over atoms(\u03a0 ), a set X of atoms over atoms(\u03a0 ) is said to be unfounded (Leone et al. 1997) on L with respect to the program \u03a0 when for each atom a \u2208 X and each rule A \u2190 B \u2208 \u03a0 such that a \u2208 A, either of the following conditions hold", "startOffset": 123, "endOffset": 142}, {"referenceID": 17, "context": "6 from Leone et al. (1997) that relates the notions of unfounded set and stable model.", "startOffset": 7, "endOffset": 27}, {"referenceID": 4, "context": "The Davis\u2013Putnam\u2013Logemann\u2013Loveland (dpll) algorithm from Davis et al. (1962) is a well-known method that exhaustively explores sets of literals to generate classical models of a propositional formula.", "startOffset": 57, "endOffset": 77}, {"referenceID": 4, "context": "The Davis\u2013Putnam\u2013Logemann\u2013Loveland (dpll) algorithm from Davis et al. (1962) is a well-known method that exhaustively explores sets of literals to generate classical models of a propositional formula. Most satisfiability and non-disjunctive answer set solvers are based on variations of the dpll procedure that is a classical backtrack search-based algorithm. We now review the abstract transition system for dpll proposed by Nieuwenhuis et al. (2006), which is an alternative to common pseudo-code descriptions of backtrack search-based algorithms.", "startOffset": 57, "endOffset": 452}, {"referenceID": 27, "context": "13 in Nieuwenhuis et al. (2006).", "startOffset": 6, "endOffset": 32}, {"referenceID": 19, "context": "Lierler (2011) illustrated that extending DP\u03a0 by a transition rule", "startOffset": 0, "endOffset": 15}, {"referenceID": 23, "context": "Many answer set solvers for such programs can be seen as extensions of this procedure (Lierler and Truszczynski 2011).", "startOffset": 86, "endOffset": 117}, {"referenceID": 5, "context": "The problem of deciding whether a disjunctive program has a stable model is \u03a32 complete (Eiter and Gottlob 1993).", "startOffset": 88, "endOffset": 112}, {"referenceID": 19, "context": "We now relate the graph DP 2 g,t(\u03a0 ) to the procedure dp-assat-proc from Lierler (2005). This procedure forms the basis of the answer set solver cmodels.", "startOffset": 73, "endOffset": 88}, {"referenceID": 21, "context": "To be complete in our presentation, we now review the details of g and t functions (Lierler 2010).", "startOffset": 83, "endOffset": 97}, {"referenceID": 2, "context": "In Brochenin et al. (2014), transition systems exemplified by the graph DP 2 \u03a0 were used to capture several disjunctive solvers, namely, cmodels, gnt and dlv implementing backtracking.", "startOffset": 3, "endOffset": 27}, {"referenceID": 22, "context": "For instance, for a non-disjunctive program \u03a0 , the graph DPTsm,\u03a0 coincides with the graph sm\u03a0 (Lierler 2011) that captures computation of answer set solver smodels (Simons et al.", "startOffset": 95, "endOffset": 109}, {"referenceID": 30, "context": "For instance, for a non-disjunctive program \u03a0 , the graph DPTsm,\u03a0 coincides with the graph sm\u03a0 (Lierler 2011) that captures computation of answer set solver smodels (Simons et al. 2002).", "startOffset": 165, "endOffset": 185}, {"referenceID": 22, "context": "The graph DPTsd,\u03a0 coincides with the graph atleast\u03a0 (Lierler 2011) that provides a procedure for deciding whether a non-disjunctive program has supported models.", "startOffset": 52, "endOffset": 66}, {"referenceID": 15, "context": "Janhunen et al. (2006) define the generating function g and the witness function t used in gnt.", "startOffset": 0, "endOffset": 23}, {"referenceID": 15, "context": "The graph SM \u03a0 captures the gnt procedure by Janhunen et al. (2006) in a similar way as the graph DP 2 \u03a0 captures the cmodels procedure of dp-assat-proc in Section 3.", "startOffset": 45, "endOffset": 68}, {"referenceID": 15, "context": "The graph SM \u03a0 captures the gnt procedure by Janhunen et al. (2006) in a similar way as the graph DP 2 \u03a0 captures the cmodels procedure of dp-assat-proc in Section 3.2. Figure 7 presents an example of a path in a graph SM {a\u2190c;b\u2190c;c\u2190a,b;a\u2228b\u2190}. From the formal results by Janhunen et al. (2006) it immediately follows that g is sta-approximating with respect to cla and t is sta-ensuring with respect to cla.", "startOffset": 45, "endOffset": 294}, {"referenceID": 2, "context": "6 Corollary 1 corresponds to Theorem 5 in (Brochenin et al. 2014).", "startOffset": 42, "endOffset": 65}, {"referenceID": 7, "context": "t(\u03a0 ,M) = {(B \u2229M) \u2228 \u2228 A\u2032 \u2228 | A \u2190 B \u2208 \u03a0 + , B \u2286 M,A = A \u2229M}\u222a {(M|atoms(\u03a0 )) } (9) Following the results from Faber (2002) and Koch et al.", "startOffset": 108, "endOffset": 121}, {"referenceID": 7, "context": "t(\u03a0 ,M) = {(B \u2229M) \u2228 \u2228 A\u2032 \u2228 | A \u2190 B \u2208 \u03a0 + , B \u2286 M,A = A \u2229M}\u222a {(M|atoms(\u03a0 )) } (9) Following the results from Faber (2002) and Koch et al. (2003), the generating function g is sup-approximating with respect to cla while the witness function t is cla-ensuring with respect to cla.", "startOffset": 108, "endOffset": 144}, {"referenceID": 2, "context": "7 Corollary 2 corresponds to Theorem 6 in (Brochenin et al. 2014).", "startOffset": 42, "endOffset": 65}, {"referenceID": 7, "context": "This corollary is an alternative proof of correctness for the dlv algorithm previously stated by Faber (2002) and Koch et al.", "startOffset": 97, "endOffset": 110}, {"referenceID": 7, "context": "This corollary is an alternative proof of correctness for the dlv algorithm previously stated by Faber (2002) and Koch et al. (2003) in terms of pseudo-code.", "startOffset": 97, "endOffset": 133}, {"referenceID": 19, "context": "We now generalize Lemma 4 from Lierler (2008) to the case of disjunctive programs.", "startOffset": 31, "endOffset": 46}, {"referenceID": 23, "context": "Transition systems for describing dpll-based solving procedures have been introduced by Nieuwenhuis et al. (2006). Lierler (2008) introduced and compared the transition systems for the answer set solvers smodels and cmodels for nondisjunctive programs.", "startOffset": 88, "endOffset": 114}, {"referenceID": 19, "context": "Lierler (2008) introduced and compared the transition systems for the answer set solvers smodels and cmodels for nondisjunctive programs.", "startOffset": 0, "endOffset": 15}, {"referenceID": 23, "context": "Nieuwenhuis et al. (2006) considered another extension of the graphs by introducing transition rules that capture backjumping and learning techniques common in design of modern solvers, that later allowed Lierler (2011) to design, e.", "startOffset": 0, "endOffset": 26}, {"referenceID": 19, "context": "(2006) considered another extension of the graphs by introducing transition rules that capture backjumping and learning techniques common in design of modern solvers, that later allowed Lierler (2011) to design, e.", "startOffset": 186, "endOffset": 201}, {"referenceID": 14, "context": "Other methods include pseudo-code presentation of algorithms (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).", "startOffset": 61, "endOffset": 116}, {"referenceID": 13, "context": "Other methods include pseudo-code presentation of algorithms (Giunchiglia and Maratea 2005; Giunchiglia et al. 2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).", "startOffset": 61, "endOffset": 116}, {"referenceID": 9, "context": "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).", "startOffset": 26, "endOffset": 74}, {"referenceID": 10, "context": "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013).", "startOffset": 26, "endOffset": 74}, {"referenceID": 9, "context": "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013). Giunchiglia et al. (2008) presented pseudo-code descriptions of cmodels without backjumping and learning, smodels and dlv without backjumping restricted to non-disjunctive programs.", "startOffset": 27, "endOffset": 102}, {"referenceID": 9, "context": "2008) and tableau calculi (Gebser and Schaub 2006; Gebser and Schaub 2013). Giunchiglia et al. (2008) presented pseudo-code descriptions of cmodels without backjumping and learning, smodels and dlv without backjumping restricted to non-disjunctive programs. They study relationships to the solving algorithms by analyzing the correspondence about the search spaces they explore, focusing on tight programs: in particular, they note a tight relation between solvers cmodels and dlv. Gebser and Schaub (2013) considered formal proof systems based on tableau methods for characterizing the operations and the strategies of ASP procedures for disjunctive programs.", "startOffset": 27, "endOffset": 507}], "year": 2015, "abstractText": "Answer set programming is a declarative programming paradigm oriented towards difficult combinatorial search problems. A fundamental task in answer set programming is to compute stable models, i.e., solutions of logic programs. Answer set solvers are the programs that perform this task. The problem of deciding whether a disjunctive program has a stable model is \u03a32 -complete. The high complexity of reasoning within disjunctive logic programming is responsible for few solvers capable of dealing with such programs, namely dlv, gnt, cmodels, clasp and wasp. In this paper we show that transition systems introduced by Nieuwenhuis, Oliveras, and Tinelli to model and analyze satisfiability solvers can be adapted for disjunctive answer set solvers. Transition systems give a unifying perspective and bring clarity in the description and comparison of solvers. They can be effectively used for analyzing, comparing and proving correctness of search algorithms as well as inspiring new ideas in the design of disjunctive answer set solvers. In this light, we introduce a general template, which accounts for major techniques implemented in disjunctive solvers. We then illustrate how this general template captures solvers dlv, gnt, and cmodels. We also show how this framework provides a convenient tool for designing new solving algorithms by means of combinations of techniques employed in different solvers. To appear in Theory and Practice of Logic Programming (TPLP).", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}