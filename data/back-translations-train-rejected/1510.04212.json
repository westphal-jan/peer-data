{"id": "1510.04212", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Oct-2015", "title": "Inheritance in Object-Oriented Knowledge Representation", "abstract": "This paper contains the consideration of inheritance mechanism in such knowledge representation models as object-oriented programming, frames and object-oriented dynamic networks. In addition, inheritance within representation of vague and imprecise knowledge are also discussed. New types of inheritance, general classification of all known inheritance types and approach, which allows avoiding in many cases problems with exceptions, redundancy and ambiguity within object-oriented dynamic networks and their fuzzy extension, are introduced in the paper. The proposed approach bases on conception of homogeneous and inhomogeneous or heterogeneous class of objects, which allow building of inheritance hierarchy more flexibly and efficiently.", "histories": [["v1", "Wed, 14 Oct 2015 17:34:11 GMT  (10kb)", "http://arxiv.org/abs/1510.04212v1", "in Information and Software Technologies, Communications in Computer and Information Science, Springer, 2015"]], "COMMENTS": "in Information and Software Technologies, Communications in Computer and Information Science, Springer, 2015", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["dmytro terletskyi"], "accepted": false, "id": "1510.04212"}, "pdf": {"name": "1510.04212.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Dmytro Terletskyi", "Taras Shevchenko"], "emails": ["dmytro.terletskyi@gmail.com,"], "sections": [{"heading": null, "text": "ar Xiv: 151 0.04 212v 1 [cs.A I] 1 4O ctKeywords: single inheritance, multiple inheritance, strong inheritance, weak inheritance, full inheritance, partial inheritance"}, {"heading": "1 Introduction", "text": "Nowadays, the design and development of knowledge-based systems for solving problems in various areas is an important task in the field of artificial intelligence. Currently, there are many different knowledge representation models (KRMs), the most famous of which are logical models, production models, semantic networks, frames, scripts, conceptual graphs, ontologies, etc. All of these KRMs have their own specifications and allow the representation of some types of knowledge. However, the particular programming paradigm should be chosen for the implementation of a particular KRM. Because today, the most famous and most widely used programming paradigm is object-oriented programming (OOP). It gives us the opportunity to efficiently implement many existing KRMs, especially those that are object-oriented, e.g. frames, scripts. We should bear in mind that the knowledge in forms of each KRM must somehow be represented in the database."}, {"heading": "2 Inheritance in Object-Oriented Programming", "text": "Nowadays, there are two main approaches in modern OOP that are implemented within class-based and prototype-based programming languages. [3] The main idea of the first approach is to identify common properties of a certain set of objects and their description within such a structure as a class. Objects exist only at runtime as a result of the instantiation of a class. In the second approach, the objects are the results of a cloning operation that is applied to prototypes where prototypes define stereotypical objects. Therefore, all future considerations regarding OOP are carried out within class-based programming approaches. In the paradigm of OOP, class-based programming approaches are currently used more frequently than prototype-based ones, and most modern OOP languages support precisely class-based styles. Therefore, all future considerations regarding OOP are carried out within class-based programming approaches. In the paradigm of OOP, class defines some kind of concept, and objects are instances of the same. Each class consists of fields and methods in which the structure of the object is defined and the behavior of the object is determined."}, {"heading": "2.1 Single Inheritance", "text": "Class-based approach provides the ability to define the class based on the existing definition of another class. In this case, a class can inherit specifics from another class. Furthermore, it can expand or specialize the inherited specifics by adding its own characteristics. This process is referred to as a single inheritance [3]. With this mechanism, we can build inheritance hierarchies where more general concepts occupy a higher position in the hierarchy than less general ones. Class that inherits another class is referred to as a subclass of that class, and the class that was inherited from another class is referred to as a superclass. Individual inheritance can be graphically represented as a tree. According to [3], there are at least three different interpretations of inheritance. We consider inheritance in the context of modeling classification hierarchies in the chosen domain of application. Such an interpretation is more common in OOP and is applied in object-oriented knowledge representation."}, {"heading": "2.2 Multiple Inheritance", "text": "For this purpose, there is another form of inheritance called multiple inheritance [3], which allows the class to inherit specifics of many other classes. Multiple inheritance hierarchy can be graphically represented as an acyclic graph or simply as a direct inheritance graph. Multiple inheritance has almost the same advantages as a single one. Furthermore, it offers the possibility of creating more complex classes and objects via inheritance. Multiple inheritance, however, also has some disadvantages. The use of multiple inheritance sometimes causes two types of semantic conflicts within the subclasses. In the first case, the class can simultaneously inherit a few copies of the same method or different values of the corresponding properties from different superclasses. In the second case, the subclass can inherit such an inheritance."}, {"heading": "3 Object-Oriented Knowledge Representation", "text": "The basic idea of the object-oriented knowledge representation approach is the representation of knowledge about a domain in relation to objects, classes, and relationships between them. OOP offers all the possibilities for such representation, but in many books describing models of knowledge representation, OOP is not mentioned. Nevertheless, we look at models that are ideologically close to OOP, such as frames and object-oriented dynamic networks (OODN). We briefly look at these KRMs and the implementation of inheritance mechanisms in them."}, {"heading": "3.1 Frames", "text": "Frame is a data structure for the representation of knowledge about stereotypical situations [7]. Frame consists of a series of slots in which each slot has its own filler. Name of a frame, relationships to other frames, attributes of the frame, procedural attachments can be fillers for the slots of the frame. However, each slot can be merged with its value into a system of relationships. Generally, there are two types of frames: individual or instance frames for the representation of individual objects and general or class frames for the representation of classes [9]. Different frames can be merged into a system of relationships. There are three main types of relationships between frames: generalization, aggregation and association. Generalization represents relationship between subclass and superclass or object and class if subclass is a kind of superclass."}, {"heading": "3.2 Problem of Exceptions", "text": "The first known problem of inheritance is the problem of exceptions. There are some classic examples illustrating it. They are known as examples of flying penguins or ostriches and of three-legged or white elephants [1]. In general, the problem can be formulated as a situation where the superclass contains properties that do not apply to all its subclasses.After the formulation of this problem, some approaches to its solution have been suggested. For example, in frame-based systems subclasses can override the values of the inherited slots of their superclass [9]. However, this approach is not efficient because overwriting slots leads to the situation when the subclass goes beyond its superclass. Thereafter, this class cannot be considered a subclass of its superclass because all subclasses must inherit all the properties of their superclass. The main idea of another known approach is the use of non-is-a linkage to modelling exceptions [1], [13].The logical solution to this problem of other subclasses is that they do not differ in any way from any other known approach."}, {"heading": "3.3 Problem of Redundancy", "text": "Another problem related to inheritance is the problem of redundancy. It occurs within the inheritance tree when the class inherits specifications from more than one related superclass [1]. In this situation, there is a vertical inheritance chain in which the top level contains most general classes and each of the lower levels contains less general classes than its superclass. At the bottom level, there is the most specific class in the hierarchy. The main feature of this class is that it inherits all properties from its predecessors. Sometimes, such inheritance is redundant because the class can inherit unnecessary properties or methods and all objects in this class have the same specifications. There are some approaches that avoid inheritance of redundant properties. One of them is the choice of the closest value. However, it is not an efficient way as the result of such a selection depends on a suitable algorithm. Different systems have different algorithms that can produce different results in the same situation [1] [13]."}, {"heading": "3.4 Problem of Ambiguity", "text": "Another type of problem related to inheritance is the problem of ambiguity. However, there are a few classic examples that illustrate this problem: they are known as examples of Quaker or Nixon, and elephant being a circus performer, etc. [1]. This problem occurs when the class inherits specifics from more than one unrelated superclass of the same level, and these superclasses contain characteristics and methods with the same names. In all these cases, there is ambiguity because it is unknown which particular property should be chosen, and different variants can only have one similar name, but no type or value. Sometimes, they can have the same type and different values, or they can have the same type and the same value. In all these cases, there is ambiguity because it is unknown which particular property should be chosen, and different variants can have completely different semantic contexts. Methods, similar to properties of properties, can only have the same names and very different semantic contexts."}, {"heading": "3.5 Object-Oriented Dynamic Networks", "text": "In fact, most of them are able to assert themselves, they are able to assert themselves, and they are able to assert themselves, and they are able to assert themselves."}, {"heading": "4 Object-Oriented Representation of Fuzzy Knowledge", "text": "At present, there are a variety of KRMs that offer the possibility of presenting knowledge in different ways, most of which were mentioned in the introductory part. However, a lot of human knowledge is vague and inaccurate [2], [6] and cannot be efficiently represented by using existing KRMs. Therefore, most of them have been extended to the case of blurred knowledge, through the use of blurred set theory [14]. At present, however, the classical paradigm of OOP does not provide an opportunity to represent blurred objects and classes. Therefore, a few attempts have been made to do so within object-oriented approaches to representing blurred knowledge [2], [6], [8] and blurred relations between knowledge and property-oriented classes are blurred."}, {"heading": "4.1 Fuzzy Frames", "text": "One of the most interesting extensions of classic KRMs in the case of fuzzy knowledge are fuzzy frames [4], [5]. There are two main differences between frames and fuzzy frames. First, within fuzzy frames slots can contain fuzzy sets as values. Second, the inheritance through a slot can be partial. Such an extension of frames allows the description of objects and classes that have partial properties, i.e. properties that are inherent to a certain extent. It means that such properties are not strictly true or false for the object or class. This type of inheritance is referred to as weaker inheritance. Suggested type of inheritance can in some cases solve problems with exceptions if the subclass inherits all properties of its superclass, but some of them are inherited with a measure smaller than 1. It means that these properties are less expressed within the subclass than in its ancestors. However, such an approach does not solve problems with redundancy and ambiguity because it only allows flexible relationships between classes."}, {"heading": "4.2 Fuzzy Object-Oriented Dynamic Networks", "text": "Similar to OOP and frames, object-oriented dynamic networks are not efficient for representing blurred objects and classes. Therefore, the definition of blurred object-oriented dynamic networks can be formulated as follows: - Definition 5 Blurred object-oriented dynamic network is an object-oriented dynamic networkFOODN = (O, C, R, E, M), subject to at least one of the following conditions: - Ak,..., Am. O = {A1,..., An}, where 1 \u2264 k \u2264 m \u2264 n and Ak,..., Am are blurred objects; - Tp,.,., Tq,. C = {T1,.., Tw}, where 1 \u2264 m \u2264 and Tp, i.e. blurred objects are."}, {"heading": "5 Types of Inheritance", "text": "As we can see from previous sections, there are two types of inheritance - single and multiple. Such types of inheritance classification allows consideration of the inheritance process related to different types of inheritance sources. However, there is another classification that divides inheritance into strong and weak parts. It allows consideration of inheritance from a different point of view, namely how the inherited traits are expressed within the subclass. Nevertheless, there are other classifications. The common characteristic for single and multiple inheritance is that the subclass inherits all the traits and methods of inheritance. We assume that it is the source of most problems. In our opinion, if the class does not inherit all the traits of the inheritance source, it would not cause the problems of redundancy and ambiguity. Moreover, such a type of inheritance allows the structure of inheritance in a flexible way, without redundancy and ambiguity."}, {"heading": "5.1 Single Inheritance", "text": "Suppose we have inherited the following order of inheritance: A3 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2192 A2 \u2212 \u2212 \u2212 \u2192 A1 (nucleus (T), pr1 (T), pr1 (pr1 (T)), whereas Nucleus (T) = (p1 (A1), p2 (A1), f1 (A1), f1 (A1), f1 (A1), f1 (A1), f1 (A1), f1 (A1), f2 (A1), pr1 (T). The structures of classes A1, A2 and A3 in heterogeneous class T can be expressed as follows: A1 = nucleus (T), prprprpr1 (T), A2 (T) (1) (1) (T)."}, {"heading": "5.2 Multiple Inheritance", "text": "Suppose we inherited the following order of inheritance: A3 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2192 A1 and A3 \u2212 \u2212 \u2212 \u2212 \u2212 \u2192 A2 = T = (pr1 (T), pr2 (T), pr1 (pr1 (T), pr2 (T))), where A1 (T) = (p1 (A1), p2 (A1), pr2 (T) = (p1 (A2), f1 (A2), pr1 (A2)), pr1 (pr1 (T), pr2 (T)) = (p1 (A3), f1 (A3). The structures of classes A1, A2 and A3 in the heterogeneous class T can be expressed as follows: Aprprprpr1 (T), A1 (T) (A2) (A3)."}, {"heading": "5.3 Special Cases", "text": "Suppose we have the situation when class A2 partially inherits class A1, for example property p1 (A1) and method f1 (A1).A2 inherits (p1, f1) \u2212 \u2212 \u2212 \u2212 \u2212 A1 = T = (Core (T), pr1 (T), pr1 (T), pr1 (A1), f1 (A2 (A1), f2 (A1), pr1 (T), pr1 (T), f1 (T), pr1 (T) (A1), f1 (T), f1 (A2 (A1), f2 (A1), A \u2212 A \u2212 T = (p1), p2 (A1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1), the Aprose (1, the Aprose (1), the Aprose (1), the Aprose (1, the Aprose (1), the Aprose (1, the Aprose (1), the Aprose (1, the Aprose (1), the Aprose (the Aprose (1), the Aprose (the Aprose (T), the Aprose (the Aprose (the Aprose (T), the Aprose (the Aprose (the Aprose), the Aprose (the Aprose (the Aprose), the Aprose (the Aprose (the Aprose), the Aprose (the Apr1), the Aprose (the Aprose (the Aprose (the Apr1), the Aprose (the Aprose (the Aprose (the Apr1), the Aprose (the Aprose (the Apr1),"}, {"heading": "6 Conclusions", "text": "This paper provides an analysis of the inheritance process and its peculiarities in the context of knowledge representation within OOP, Frames, and OODN. Furthermore, different types of inheritance problems such as problems with exceptions, redundancy, ambiguity, and some approaches to solving them from different perspectives were considered. Furthermore, the different types of inheritance problems were considered, new types of inheritance problems were proposed that allow the establishment of inheritance hierarchy more flexibly and efficiently, and a general classification of all known types of inheritance was introduced, covering eight different types of inheritance, and the application of an approach that enables problems with exceptions, redundancy, and ambiguity within OODN and FOODN to be avoided in many cases was demonstrated using examples."}, {"heading": "1. Al-Asady, R.: Inheritance Theory: An Artificial Intelligence Approach. Ablex Publishing Corporation, Norwood, New Jersey (1995)", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2. Berzal, F., Marin, N., Pons, O., Vila, M.A.: Managing Fuzziness on Conventional Object-Oriented Platforms. International Journal of Intelligent Systems. 22, 781\u2013", "text": "803 (2007) 3. Craig, I.D.: Object-Oriented Programming Languages: Interpretation. Springer, London (2007) 4. Graham, I., Jones, P.L.: A Theory of Fuzzy Frames: Part-1. Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 109-132 (1987) 5. Graham, I., Jones, P.L.: A Theory of Fuzzy Frames: Part-2. Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 120-135 (1987) 6. Leung, K.S., Wong, M.H.: Fuzzy Concepts in an Object Oriented Expert System Shell. International Journal of Intelligent Systems. 7, 171-192 (1992) 7. Minsky, M.: A Framework for Representing Knowledge."}], "references": [{"title": "Inheritance Theory: An Artificial Intelligence Approach", "author": ["R. Al-Asady"], "venue": "Ablex Publishing Corporation, Norwood, New Jersey", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Managing Fuzziness on Conventional Object-Oriented Platforms", "author": ["F. Berzal", "N. Marin", "O. Pons", "M.A. Vila"], "venue": "International Journal of Intelligent Systems. 22, 781\u2013 803", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Object-Oriented Programming Languages: Interpretation", "author": ["I.D. Craig"], "venue": "Springer, London", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2007}, {"title": "A Theory of Fuzzy Frames: Part-1", "author": ["I. Graham", "P.L. Jones"], "venue": "Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 109\u2013132", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1987}, {"title": "A Theory of Fuzzy Frames: Part-2", "author": ["I. Graham", "P.L. Jones"], "venue": "Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 120\u2013135", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1987}, {"title": "Fuzzy Concepts in an Object Oriented Expert System Shell", "author": ["K.S. Leung", "M.H. Wong"], "venue": "International Journal of Intelligent Systems. 7, 171\u2013192", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1992}, {"title": "A Framework for Representing Knowledge", "author": ["M. Minsky"], "venue": "Technical Report No. 306, AI Laboratory, Massachusetts Institute of Technology", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1974}, {"title": "Intelligent Systems Modeling with Reusable Fuzzy Objects", "author": ["T.D. Ndousse"], "venue": "International Journal of Intelligent Systems. 12, 137\u2013152", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1997}, {"title": "Artificial Intelligence: A Guide to Intelligent Systems: Second Edition", "author": ["M. Negnevitsky"], "venue": "Addison-Wesley, Herlow, Essex", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2004}, {"title": "Mathematical Foundations for Designing and Development of Intelligent Systems of Information Analysis", "author": ["D.A. Terletskyi", "O.I. Provotar"], "venue": "Scientific Journal \u201cProblems in Programming\u201d. 15, 233\u2013241", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Object-Oriented Dynamic Networks", "author": ["D.O. Terletskyi", "O.I. Provotar"], "venue": "Setlak, G., Markov, K. (eds.) Computational Models for Business and Engineering Domains. IBS ISC, vol. 30, pp. 123\u2013136. ITHEA", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Fuzzy Object-Oriented Dynamic Networks", "author": ["D.A. Terletskyi", "A.I. Provotar"], "venue": "I. International Scientific Journal \u201cCybernetics and System Analysis\u201d. 51, 34\u201340", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "The Mathematics of Inheritance Systems", "author": ["D.S. Touretzky"], "venue": "Morgan Kaufmann Publishers, Los Altos, California", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1986}, {"title": "Fuzzy Sets", "author": ["L.A. Zadeh"], "venue": "Information and control. 8, 338\u2013353", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1965}], "referenceMentions": [{"referenceID": 0, "context": "Firstly, inheritance mechanism leads three main kinds of problems, such as problem of exceptions, problem of redundancy and problem of ambiguity [1], [13].", "startOffset": 145, "endOffset": 148}, {"referenceID": 12, "context": "Firstly, inheritance mechanism leads three main kinds of problems, such as problem of exceptions, problem of redundancy and problem of ambiguity [1], [13].", "startOffset": 150, "endOffset": 154}, {"referenceID": 1, "context": "Secondly, a lot of human knowledge have vague and imprecise nature [2], [6] and OOP does not support representation of such knowledge.", "startOffset": 67, "endOffset": 70}, {"referenceID": 5, "context": "Secondly, a lot of human knowledge have vague and imprecise nature [2], [6] and OOP does not support representation of such knowledge.", "startOffset": 72, "endOffset": 75}, {"referenceID": 9, "context": "Thirdly, OOP provides an opportunity to create and to operate only with homogeneous classes [10], that is why we need to create new class for every new type of objects, even when some of them are similar.", "startOffset": 92, "endOffset": 96}, {"referenceID": 2, "context": "Nowadays there are two main approaches in modern OOP, which are implemented within class-based and prototype-based programming languages [3].", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "This process is called single inheritance [3].", "startOffset": 42, "endOffset": 45}, {"referenceID": 2, "context": "According to [3] there are at least three different interpretations of inheritance.", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "For this purpose there is another form of inheritance, which is called an multiple inheritance [3].", "startOffset": 95, "endOffset": 98}, {"referenceID": 6, "context": "Frame is a data-structure for representation of knowledge about stereotypical situations [7].", "startOffset": 89, "endOffset": 92}, {"referenceID": 8, "context": "Generally, there are two types of frames: individual or instance-frames for representation of single objects, and generic or class-frames for representation of classes [9].", "startOffset": 168, "endOffset": 171}, {"referenceID": 6, "context": "Different frames can be merged into one system via relationships [7].", "startOffset": 65, "endOffset": 68}, {"referenceID": 8, "context": "Similarly to OOP, frames use the inheritance mechanism for building framessystems, which also have hierarchical structure [9].", "startOffset": 122, "endOffset": 125}, {"referenceID": 8, "context": "However, single and multiple inheritance cause the same problems in frames as in OOP [9], [13].", "startOffset": 85, "endOffset": 88}, {"referenceID": 12, "context": "However, single and multiple inheritance cause the same problems in frames as in OOP [9], [13].", "startOffset": 90, "endOffset": 94}, {"referenceID": 0, "context": "They are known as examples about flying penguins or ostriches and about three-legged or white elephant [1], [13].", "startOffset": 103, "endOffset": 106}, {"referenceID": 12, "context": "They are known as examples about flying penguins or ostriches and about three-legged or white elephant [1], [13].", "startOffset": 108, "endOffset": 112}, {"referenceID": 8, "context": "For example, in frame-based systems, subclasses can override the values of inherited slots from their superclass [9].", "startOffset": 113, "endOffset": 116}, {"referenceID": 0, "context": "The main idea of another known approach is the usage of not-is-a links for modelling of exceptions [1], [13].", "startOffset": 99, "endOffset": 102}, {"referenceID": 12, "context": "The main idea of another known approach is the usage of not-is-a links for modelling of exceptions [1], [13].", "startOffset": 104, "endOffset": 108}, {"referenceID": 0, "context": "However it causes appearing of the contradictory classes, formation of inconsistent knowledge base and as result contradictory reasoning [1].", "startOffset": 137, "endOffset": 140}, {"referenceID": 0, "context": "It appears within the inheritance tree, when the class inherits specifics from more than one related superclass [1], [13].", "startOffset": 112, "endOffset": 115}, {"referenceID": 12, "context": "It appears within the inheritance tree, when the class inherits specifics from more than one related superclass [1], [13].", "startOffset": 117, "endOffset": 121}, {"referenceID": 0, "context": "Various systems have different algorithms, which can return different results in the same situation [1], [13].", "startOffset": 100, "endOffset": 103}, {"referenceID": 12, "context": "Various systems have different algorithms, which can return different results in the same situation [1], [13].", "startOffset": 105, "endOffset": 109}, {"referenceID": 0, "context": "[1], [13].", "startOffset": 0, "endOffset": 3}, {"referenceID": 12, "context": "[1], [13].", "startOffset": 5, "endOffset": 9}, {"referenceID": 0, "context": "There are a few approaches for solving this problem [1], [13].", "startOffset": 52, "endOffset": 55}, {"referenceID": 12, "context": "There are a few approaches for solving this problem [1], [13].", "startOffset": 57, "endOffset": 61}, {"referenceID": 0, "context": "In this situation results will be different in various systems [1].", "startOffset": 63, "endOffset": 66}, {"referenceID": 10, "context": "Another kind of object-oriented knowledge representation model is object-oriented dynamic networks, which was proposed in [11].", "startOffset": 122, "endOffset": 126}, {"referenceID": 2, "context": "Within OOP, class is something like abstract description of some quantity of objects of the same nature [3].", "startOffset": 104, "endOffset": 107}, {"referenceID": 9, "context": "However, there is another type of classes, which are inhomogeneous or heterogeneous [10].", "startOffset": 84, "endOffset": 88}, {"referenceID": 1, "context": "However, a lot of human knowledge is vague and imprecise [2], [6] and cannot be represented in efficient way, using existing KRMs.", "startOffset": 57, "endOffset": 60}, {"referenceID": 5, "context": "However, a lot of human knowledge is vague and imprecise [2], [6] and cannot be represented in efficient way, using existing KRMs.", "startOffset": 62, "endOffset": 65}, {"referenceID": 13, "context": "That is why most of them were extended to the case of fuzzy knowledge, through the use of fuzzy sets theory [14].", "startOffset": 108, "endOffset": 112}, {"referenceID": 1, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 118, "endOffset": 121}, {"referenceID": 5, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 123, "endOffset": 126}, {"referenceID": 7, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 128, "endOffset": 131}, {"referenceID": 3, "context": "One of the most interesting extensions of classical KRMs to the case of fuzzy knowledge are fuzzy frames [4], [5].", "startOffset": 105, "endOffset": 108}, {"referenceID": 4, "context": "One of the most interesting extensions of classical KRMs to the case of fuzzy knowledge are fuzzy frames [4], [5].", "startOffset": 110, "endOffset": 113}, {"referenceID": 11, "context": "That is why concepts of fuzzy object, class of fuzzy objects which are basic for OODN were extended to the case of fuzzy knowledge [12].", "startOffset": 131, "endOffset": 135}], "year": 2015, "abstractText": "This paper contains the consideration of inheritance mechanism in such knowledge representation models as object-oriented programming, frames and object-oriented dynamic networks. In addition, inheritance within representation of vague and imprecise knowledge are also discussed. New types of inheritance, general classification of all known inheritance types and approach, which allows avoiding in many cases problems with exceptions, redundancy and ambiguity within objectoriented dynamic networks and their fuzzy extension, are introduced in the paper. The proposed approach bases on conception of homogeneous and inhomogeneous or heterogeneous class of objects, which allow building of inheritance hierarchy more flexibly and efficiently.", "creator": "LaTeX with hyperref package"}}}