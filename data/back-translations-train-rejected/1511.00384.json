{"id": "1511.00384", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Nov-2015", "title": "Z Specification for the W3C Editor's Draft Core SHACL Semantics", "abstract": "This article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology.", "histories": [["v1", "Mon, 2 Nov 2015 05:31:42 GMT  (35kb)", "http://arxiv.org/abs/1511.00384v1", "57 pages, Invited Expert contribution to the W3C RDF Data Shapes Working Group"]], "COMMENTS": "57 pages, Invited Expert contribution to the W3C RDF Data Shapes Working Group", "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["arthur ryman"], "accepted": false, "id": "1511.00384"}, "pdf": {"name": "1511.00384.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["arthur.ryman@gmail.com"], "sections": [{"heading": null, "text": "ar Xiv: 151 1.00 384v 1 [cs.D B] 2This article provides a formalization of the W3C Draft Core SHACL semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the design and found that the recursive definitions in the design are well founded. Further formal validation of the design requires the use of an executable specification technology."}, {"heading": "1 Introduction", "text": "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF diagrams. A semantics for core SHACL has been proposed [2], hereinafter referred to as the semantics draft. The proposed semantics include an abstract syntax, inference rules, and a definition of typing that allows certain types of recursion. The semantics draft uses a precise mathematical language, but is informal in the sense that it is not written in a formal specification language and therefore cannot benefit from tools such as type checkers. This document provides a formal translation of the semantics draft into Z notation [6]. The LATEX source for this article has been type-checked using the Fuzz type checker [7] and is available in the GitHub repository [4]."}, {"heading": "1.1 Organization of this Article", "text": "The rest of this article is structured as follows. \u2022 Section 2 formalizes some basic concepts of RDF. \u2022 Section 3 translates the abstract syntax of SHACL into Z notation. \u2022 Section 4 formalizes the evaluation semantics of SHACL. \u2022 Section 5 formalizes the declarative semantics of form expression schemes. \u2022 Section 6 summarizes the quality problems found in the draft. \u2022 Section 7 concludes with some comments on the benefits of the formalization exercise and possible next steps."}, {"heading": "2 Basic RDF Concepts", "text": "This section formalizes some basic RDF concepts. We use some formal definitions given in [5] to modify the identifiers to match those used in the semantics draft.2.1 TERMLet TERM be the set of all RDF terms. [TERM] 2.2 Iri, Blank and LitThe set of all RDF terms is divided into IRIs, empty nodes and literal terms. (Graph) Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph Graph. We treat IRI as a synonym for Iri. < Iri, Blank, Lit > Partition TERM2.3 IRIThe semantics draft introduces the term Iri. (The semantics draft introduces the term Iri)."}, {"heading": "3 Abstract Syntax", "text": "This section contains a translation of the abstract syntax from SHACL to Z. The draft semantics defines the empty syntax using an informal Extended Backus-Naur Form (EBNF). The approach used here is to interpret any term or expression that appears in the abstract syntax, so that there is direct correspondence between the abstract syntax and Z. For example, the term schema is interpreted as a set of schemes. We give a Z definition for each abstract syntax term that appears on the left side of the EBNF definition term."}, {"heading": "Rule ::= ShapeLabel ShapeDefinition ExtensionCondition*", "text": "A rule consists of a shape name, a shape definition and a sequence of zero or more extension conditions.Rule = = ShapeLabel \u00b7 ShapeDefinition \u00b7 seqExtensionConditionIt is convenient to introduce functions that select the components of a rule.ShapeLabel = = = (\u03bb r: rule \u2022 fst (r)) shapeDef = = (\u03bb r: rule \u2022 snd (r)) extConds = = (\u03bb r: rule \u2022 trd (r)) 3.4 ShapeLabel"}, {"heading": "ShapeLabel ::= an identifier", "text": "A ShapeLabel is an identifier drawn from a given set. [ShapeLabel] 3.5 ShapeDefinition"}, {"heading": "ShapeDefinition ::= ClosedShape | OpenShape", "text": "A shape definition is either a closed shape or an open form.ShapeDefinition:: = close ShapeExpr | open OPTIONAL [InclPropSet] \u00b7 ShapeExprNote that abstract syntax terms that are alternately defined are naturally represented as free types in Z notation. \u2022 close is the constructor for closed form.ShapeExpr: ShapeDefinition \"ShapeExpr: ShapeExfinition\" ShapeExpr: ShapeExpr \u2022 shapeExpr: ShapeExpr \u2022 shapeExpr (close (x) = x-Expr: OPTIONAL [InclPropSet]; x: ShapeExpr \u2022 shapeExpr (open (o, x) = x3.6 ClosedShape"}, {"heading": "ClosedShape ::= \u2019close\u2019 ShapeExpr", "text": "The set of closed shapes is the area of the constructor for the tight shape definition. ClosedShape = = ran close3.7 OpenShape"}, {"heading": "OpenShape ::= \u2019open\u2019 InclPropSet? ShapeExpr", "text": "The set of open shapes is the area of the constructor for defining open shapes. OpenShape = = ran open3.8 InclPropSet"}, {"heading": "InclPropSet ::= PropertiesSet", "text": "An included property group is a property group. InclPropSet = = PropertiesSetNote that there seems to be little motivation to introduce the term InclPropSet, as it is identical to PropertiesSet.3.9 PropertiesSet."}, {"heading": "PropertiesSet ::= set of IRI", "text": "A property set is a set of IRIs.PropertiesSet = = IRI3.10 ShapeExprShapeExpr:: = EmptyShape | TripleConstraint Cardinality | InverseTripleConstraint Cardinality | NegatedTripleConstraint | NegatedInverseTripleConstraint | SomeOfShape | OneOfShape | GroupShape | RepetitionShapeExpr | group seq1 ShapeExpr | Repetition ShapeExpr \u00d7 Cardinality \u2022 Emptyshape \u2022 triple DirectedTripleConstraint \u00d7 Cardinality | someOf seq1 ShapeExpr | oneOf seq1 ShapeExpr | group seq1 ShapeExpr \u00d7 Cardinality \u2022 Emptyshape \u2022 emptyshape is the empty form expression."}, {"heading": "EmptyShape ::= \u2019emptyshape\u2019", "text": "The set of empty form expressions is the singleton sentence containing the empty form.EmptyShape = = {emptyshape} 3.12 DirectedPredicateA directed predicate is an IRI with a direction that its use in a triple.DirectedPredicate::: = nop IRI | inv IRIThe semantics draft uses the notation ^ p for inv (p).Let predDF (dp) constract the predDF (dp) constracate of a directed DirectDP: DirectedDP: DirectedDP \u2022 predDP (nop)): predDP (inv (p).Let preddDF (dp) constract of a directPredicate dp.PredDP: DirectedPredicate \"p\" p:.DP DP \"p: predDP (nop),\" predDP DDP (dDP conconstract): dpredDP (dDP).DP (dp): ddpredDP (dDP), \"dddddprep: dDP (p),\" ddcstract: dddDP C \"ddstract: ddp.DP (dconstract),\" (Directconstract: DP: DP), \"dconstrap: C (Directconstrap),\" dddconstract: (dDP), \"ddconstract: C (Directconstract: DP),\" ddddDP (dconstrap), \"dconstract: ddddddDP: (dDP)."}, {"heading": "TripleConstraint ::= IRI ValueConstr | IRI ShapeConstr", "text": "A triple constraint sets conditions for triples whose subject is a certain focus node and whose predicate is a certain IRI.TripleConstraint: DirectedTripleConstraintTripleConstraint = {p: IRI; C: Constraint \u2022 (nop (p), C)} 3.15 InverseTripleConstraint"}, {"heading": "InverseTripleConstraint ::= \u2019^\u2019 IRI ShapeConstr", "text": "ShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeShapeSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSheSh"}, {"heading": "Cardinality ::= \u2019[\u2019 MinCardinality \u2019;\u2019 MaxCardinality \u2019]\u2019", "text": "Cardinality defines a range for the number of elements within a proposition. Cardinality = = MinCardinality \u00b7 MaxCardinality \u2022 A cardinality consists of a minimum cardinality and a maximum cardinality.3.18 MinCardinality"}, {"heading": "MinCardinality ::= a natural number", "text": "Minimum Cardinality is the minimum number of elements required to be in a group. MinCardinality = = 3,19 MaxCardinality"}, {"heading": "MaxCardinality ::= a natural number | \u2019unbound\u2019", "text": "MaxCardinality:: = maxCard | unbound \u2022 maxCard is the constructor for finite maximum cardinalities. A finite maximum cardinality is a natural number. Note that a maximum cardinality of 0 means that the set must be empty. \u2022 unbound indicates that the maximum number of elements in a set is unlimited.3.20 inBoundsA natural number k is considered within the limits of a cardinality if k lies between the minimum and maximum limits of cardinality."}, {"heading": "3.21 Notation", "text": "The semantic draft uses the notation given in Table 1 for some formal expressions. \u2022 If cardinality [1; 1] is a value or a formal constraint, it can be omitted. \u2022 The negated formal expressions are semantically equivalent to the corresponding non-negated formal expressions with cardinality [0; 0].3.22 none. \u2022 A cardinality of none = [0; 0] is used to indicate a negated triple or inverse triple constraint. \u2022 A cardinality of one = [1; 1] is the default cardinality of a triple or inverse triple constraint, if no cardinality is explicitly stated in notations a: C and ^ a: C.3.23 Negative triple constraint."}, {"heading": "NegatedTripleConstraint ::= \u2019!\u2019 TripleConstraint", "text": "A negated form expression with triple constraint is a form expression with triple constraint that has a cardinality of non.Negated form expression with triple constraint = = {tc: TripleConstraint \u2022 triple (tc, none)} 3.24 Negated form expression with triple constraint = = {tc: TripleConstraint \u2022 triple (tc, none)} 3.24 Negated form expression with triple constraint"}, {"heading": "NegatedInverseTripleConstraint ::= \u2019!\u2019 InverseTripleConstraint", "text": "A negated inverse triple constraint form expression is an inverse triple constraint form expression that has a cardinality of none.NegatedInverseTripleConstraint = = {itc: InverseTripleConstraint \u2022 triple (itc, none)} 3.25 ValueConstr"}, {"heading": "ValueConstr ::= ValueSet | LiteralDatatype XSFacet? | NodeKind", "text": "A value constraint imposes conditions on the object nodes of triples for normal predicates and on the subject nodes of triples for inverse predications.ValueConstr = = ran valueSet, ran datatype, ran kind3.26 ValueSet"}, {"heading": "ValueSet ::= set of literals and IRI", "text": "The amount of specified value constraints is the range of the ValueSet constructor. ValueSet = = ran valueSet3.27 LiteralDatatype"}, {"heading": "LiteralDatatype ::= an RDF literal datatype", "text": "A literal data type is an IRI that identifies a set of literal RDF terms. We assume that this subset of IRIs is given. Literal data type: IRI We also assume that we get an interpretation of each literal data type as a set of letters."}, {"heading": "NodeKind ::= \u2019iri\u2019 | \u2019blank\u2019 | \u2019literal\u2019 | \u2019nonliteral\u2019", "text": "NodeKind:: = iri | blank | literal | nonliteral \u2022 iri denotes the set of IRIs. \u2022 blank denotes the set of empty nodes. \u2022 literal denotes the set of literals. \u2022 nonliteral denotes the addition of the set of literals, i.e. the union of IRIs and empty nodes. Each node corresponds to a set of RDF terms. TermsOfKind: NodeKind \"TERMtermsOfKind (iri) = IRItermsOfKind (blank) = BlanktermsOfKind (literal) = LittermsOfKind (nonliteral) = TERM\\ Lit3.29 XSFacet"}, {"heading": "XSFacet ::= an XSD restriction", "text": "An XML Schema facet restricts literals. We assume that this is a given set. [XSFacet] We also assume that we are given an interpretation of facets as sets of words.LiteralsOfFacet: LiteralDatatype \u00d7 XSFacet \"Lit instead of d: LiteralDatatype; f: XSFacet \u2022 LiteralsOfFacet (d, f) LiteralsOfDatatype (d) \u2022 The literals that correspond to a facet of a datatype are a subset of the literals that correspond to datatype.3.30 ShapeConstr"}, {"heading": "ShapeConstr ::= (\u2019!\u2019)? DisjShapeConstr | ConjShapeConstraint", "text": "A form constraint requires a node to fulfill logical combinations of one or more other shapes identified by their shape designates.ShapeConstr = = ran or ced ran and reasrannor as well as rannand3.31 DisjShapeConstr"}, {"heading": "DisjShapeConstr ::= ShapeLabel (\u2019or\u2019 ShapeLabel)*", "text": "The set of all disjunctive form constraints is the range of or constructor.DisjShapeConstr = = ran or3.32 ConjShapeConstraint"}, {"heading": "ConjShapeConstraint ::= ShapeLabel (\u2019and\u2019 ShapeLabel)*", "text": "The set of all conjunctive form constraints is the area of and the constructor. ConjShapeConstraint = = ran and3.33 SomeOfShape"}, {"heading": "SomeOfShape ::= ShapeExpr (\u2019|\u2019 ShapeExpr)*", "text": "The set of some form expressions is the range of one of. SomeOfShape = = ran an Of3.34 OneOfShape"}, {"heading": "OneOfShape ::= ShapeExpr (\u2019@\u2019 ShapeExpr)*", "text": "The set of one-of-shape expressions is the range of oneOf. OneOfShape = = ran oneOf3.35 GroupShape"}, {"heading": "GroupShape ::= ShapeExpr (\u2019,\u2019 ShapeExpr)*", "text": "The set of groupform expressions is the area of the group.GroupShape = = ran group3.36 RepeatShape"}, {"heading": "RepetitionShape ::= ShapeExpr Cardinality", "text": "The amount of repetitive form expressions is the repetition.RepetitionShape = = ran repetition3.37 ExtensionCondition"}, {"heading": "ExtensionCondition ::= ExtLangName ExtDefinition", "text": "An extension condition is the definition of a constraint written in an extension languageExtensionCondition = = ExtLangName \u00b7 ExtDefinition3.38 ExtLangName."}, {"heading": "ExtLangName ::= an identifier", "text": "An Extension Language Name is an identifier for an Extension Language, e.g. JavaScript. We assume that this is a given set. [ExtLangName] 3.39 ExtDefinition"}, {"heading": "ExtDefinition ::= a string", "text": "S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S) S (S (S) S (S) S (S) S (S (S) S (S) S (S (S (S) S (S (S) S (S (S (S) S (S (S) S (S (S) S (S (S (S) S (S (S) S (S (S) S (S (S) S (S (S) S (S (S) S (S) S (S (S) S (S (S) S (S (S) S (S (S) S (S (S (S) S (S) S (S (S) S (S (S) S (S (S) S (S (S) S) S) S (S) S (S) S (S) S (S) S (S (S) S) S (S (S) S) S (S (S) S (S) S (S) S (S (S (S) S (S) S) S (S ("}, {"heading": "4 Evaluation", "text": "Indeed, it has been shown that it is a very complex and complex project, in which it is a project that relates to the needs of people who are able to integrate themselves."}, {"heading": "4.10.1 DAG", "text": "A directed, acyclic graph is a directed graph, in which no node can be reached by itself. (X) The semantic draft introduces the notation Sri for a reduced schema, in which S is a schema, r is a rule-of-a-node in an evidence tree, and i corresponds to a premise of r. The reduced schema is constructed by replacing a form with a form in which the corresponding component is eliminated. This replacement process is described here. The complete definition of Sri follows the definition of proofs, and i corresponds to a premise of r. The reduced schema is constructed by replacing a shape with a shape in which the corresponding one-in-shape component is eliminated. (D) The complete definition of Sri follows the definition of proofs.) A schema S, an explicit designation T is defined in S, and a shape designation Expr in S is defined, and a shape expression: Shape r:: T."}, {"heading": "5 Declarative semantics of shape expression schemas", "text": "This year, it is closer than ever before to an agreement between the two countries."}, {"heading": "5.4 Proof Trees", "text": "In fact, it is a way in which she has lived in the United States in recent years: a country in which most people are able to move, and in which most of them are able to live, live, live and live, in which they live, live, live and live."}, {"heading": "5.5 Reduced Schema for rule-one-of", "text": "To get to the point, the tree in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the canopy in the tree in the canopy and in the canopy in the tree in the canopy in the tree in the canopy in the tree in the canopy in the canopy."}, {"heading": "5.6 Witness Mappings", "text": "n: \"It is a question of whether it is worth building a tree,\" he says: \"It is a question of whether it is a tree at all.\" (\"It is a question of whether it is a tree at all.\") (\"It is a question of whether it is a tree at all.\") \"It is a question of whether it is a tree.\" (\"It is about a tree.\") \"It is about a tree.\" (\"It is about a tree.\") \"It is about a tree.\" (\"It is about a tree.\") \"(\" It is about a tree. \")\" It is about a tree. \"(\" It is about a tree. \")\" It is about a tree. \"(\" It is about a tree. \")\""}, {"heading": "6 Issues", "text": "Some areas of the draft semantics have multiple interpretations or appear to be wrong and therefore require further clarification. 6.1 Depp subgraph (T, S) When defining Depp subgraph (T, S), the form T determines that it is achievable on its own? 6.2 Negshapes (S) When defining Negshapes (S), the third sphere states: There is a form designation T1 and a form designation p:: C or an inverse form triple constraints ^ p:: C in expr (T1, S) and T appears in C. This statement looks wrong because it omits the mention of negation. If there is no negation involved, why should T be in Negshapes (S)? Does this definition only select directed triple constraints that have cardinality [1,1] because that is the default? If not, then the totality of all designations referenced in any form (refs) that appear wrong."}, {"heading": "6.3 Triple matches constraint", "text": "The following definition introduces the notion of satisfying a form constraint by a series of triples. This satisfaction is used to verify whether the neighborhood of a node locally meets the constraints defined by a form expression, without taking into account whether the constraints set by the triple constraints and the triple inverse constraints required forms fulfills sin.6.5 This statement implies that here only form constraints should be ignored. However, the definition also ignores the constraints set by a form expression. This looks incorrect.6.4 Rule-triple constraint Add the condition that all outgoing triple constraints be differentiated.6.5 Rule-invers-triple constraint schema Add the condition that all incoming triple constraints schema be differentiated.6.6 Rule-triple constraint schema Add the condition that i and j be a rule repetition.6.8 Reduced schema schema schema that all invers-triple constraint schema schema be differentiated by a form constraint schema schema schema schema schema."}, {"heading": "7 Conclusion", "text": "The practice of formalizing the semantics draft led to a considerable increase in the size of the document, which resulted in the identification of a number of quality problems. This exercise also showed that the recursive definitions of the semantics draft are well founded. However, it is not clear whether these definitions lead to results that are consistent with our intuition or that they can be efficiently calculated. One way to further validate the semantics draft is to translate it into an executable formal specification system such as Coq [1] and test it on a number of examples, including both typical documents and cornerstones."}], "references": [{"title": "RDF Data Shapes", "author": ["A. Le Hors"], "venue": "Working Group. wiki page, World Wide Web Consortium,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "agryman/z-core-shacl-semantics. source code repository, GitHub", "author": ["A. Ryman"], "venue": "https://github.com/agryman/z-core-shacl-semantics", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Recursion in RDF Data Shape Languages. Article", "author": ["A. Ryman"], "venue": "World Wide Web Consortium,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "The Z Notation: a reference manual", "author": ["M. Spivey"], "venue": "https://spivey.oriel.ox.ac.uk/mike/zrm/index.html", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "The fuzz type-checker for Z. web", "author": ["M. Spivey"], "venue": "page, Oxford University,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF graphs.", "startOffset": 38, "endOffset": 41}, {"referenceID": 3, "context": "This document provides a formal translation of the semantics draft into Z Notation [6].", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.", "startOffset": 83, "endOffset": 86}, {"referenceID": 1, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.", "startOffset": 129, "endOffset": 132}, {"referenceID": 2, "context": "We reuse some formal definitions given in [5], modifying the identifiers to match those used in the semantics draft.", "startOffset": 42, "endOffset": 45}], "year": 2015, "abstractText": "This article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}