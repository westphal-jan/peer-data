{"id": "1511.00916", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Nov-2015", "title": "Lowering the learning curve for declarative programming: a Python API for the IDP system", "abstract": "Programmers may be hesitant to use declarative systems, because of the associated learning curve. In this paper, we present an API that integrates the IDP Knowledge Base system into the Python programming language. IDP is a state-of-the-art logical system, which uses SAT, SMT, Logic Programming and Answer Set Programming technology. Python is currently one of the most widely used (teaching) languages for programming. The first goal of our API is to allow a Python programmer to use the declarative power of IDP, without needing to learn any new syntax or semantics. The second goal is allow IDP to be added to/removed from an existing code base with minimal changes.", "histories": [["v1", "Tue, 3 Nov 2015 14:21:23 GMT  (17kb)", "http://arxiv.org/abs/1511.00916v1", "International Workshop on User-Oriented Logic Programming (IULP 2015), co-located with the 31st International Conference on Logic Programming (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz, pages 83-98, August 2015"]], "COMMENTS": "International Workshop on User-Oriented Logic Programming (IULP 2015), co-located with the 31st International Conference on Logic Programming (ICLP 2015), Proceedings of the International Workshop on User-Oriented Logic Programming (IULP 2015), Editors: Stefan Ellmauthaler and Claudia Schulz, pages 83-98, August 2015", "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["joost vennekens"], "accepted": false, "id": "1511.00916"}, "pdf": {"name": "1511.00916.pdf", "metadata": {"source": "CRF", "title": "Lowering the learning curve for declarative programming: a Python API for the IDP system", "authors": ["Joost Vennekens"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 151 1,00 916v 1 [cs.P L] 3N ov"}, {"heading": "1 Introduction", "text": "While declarative systems are inherently more difficult to learn than, say, an object-oriented programming language, they are often perceived as such because many programmers are unfamiliar with their syntax, semantics, or paradigm. This, in turn, leads to a problem where programmers do not learn this technology because there are not enough programmers to make the technology readily available. In this paper, we propose to address both problems using an API that allows a declarative knowledge base (KB) to be used within a known imperative host language. Our first goal is to integrate the functionality of KB into the host language as seamlessly as possible."}, {"heading": "2 KB system", "text": "As the underlying KB system, we will use IDP (Imperative Declarative Programming) 2 [2], which combines techniques from SAT Solving, Logic Programming and Answer Set Programming (ASP). It has performed well in previous ASP competitions, e.g. the close second place after Clasp in the System Track of 20113. IDP has a number of features that fit well with our goals of achieving both close integration with the host language and a low learning curve. IDP uses a language that represents a conservative extension of classical first-order logic (FO). Since most computer science students are familiar with FO, this means that the learning curve for a large part of IDP's input language consists solely of learning a certain ASCII syntax for FO. One of the ways in which IDP FO expands is by inductive tasks [3]. Since such definitions are not generally expressed in FO, this is a true extension of the language for FO."}, {"heading": "2.1 FO: syntax and semantics", "text": "We briefly remember the standard syntax and semantics of FO. A vocabulary \u03a3 consists of a series of function symbols, each with an associated arty n and a series of predicate symbols, also with an arty n. A function with an arty n is referred to as a constant. A term is either a constant, a variable or an expression f (t1). A formula is either an atom or an expression, a mode of expression, a mode of expression, an expression P (t1,. tn), with P an n-like predicate and the ti-terms. A formula is either an atom or an expression, a mode of expression, a mode of expression, an expression Color x: an expression P (t1,. tn), a structure, with P an n-like predicate and the ti-terms again terms. A formula is either an atom or an expression, a mode of expression, a mode of expression Color x: an expression, an expression P (t1,. tn), a structure, with P an n-like predicate and the ti-terms again terms."}, {"heading": "3 Interfacing with the KB System", "text": "In this section, we present our API for using the IDP KB system within Python."}, {"heading": "3.1 Vocabularies and structures", "text": "All interactions with the IDP system are carried out by objects of the IDP class. Each such object represents a knowledge base consisting of a triple (V, S, T) vocabulary. \"The following methods add symbols to the vocabulary of the KB:\" The way in which it is used is not only the way in which it is used, but also the way in which it is used. \"The way in which it is used is the way in which it is used.\" The way in which it is used is also the way in which it is used. \"The way in which it is used is also the way in which it is used.\" The way in which it is used is the way in which it is used. \""}, {"heading": "3.2 Formulas and definitions", "text": "In accordance with our goal of achieving a low learning curve, formulas are written in Python syntax. An overview is shown in Figure. Python language has the default Boolean operators and, or, or, or, or, and, or, or, not. In addition, it also has the functions all and any that can be applied to lists of Boolean values to return the conjunction / separation of these values. The latter two functions, together with Python's vocabulary syntax, can be used as universal / existential quantification. The surface understanding syntax also has an optional if part that can be used to represent the common pattern of a universally quantified implication."}, {"heading": "3.3 Functional interfacing", "text": "In line with our goal of making the API easy to use, the programmer does not then have to explicitly call the IDP system, which avoids the need to learn new functions or terminology, and reduces the possibility of errors. Instead, calling the IDP system happens \"automagically\" in the following circumstances: - Symbols that have been declared but for which no interpretation has been provided are automatically assigned to a valid interpretation (in accordance with FO semantics) when their content is checked. In other words, IDP is used as an oracle to fill the interpretation of all declared symbols for which the user does not provide one, in such a way that the interpretations of all symbols together represent an FO model of constraints, i.e., a model expansion task is performed to allow the x constraints, one is chosen arbitrarily. - The KB object has an explicitly satisfactory attribute."}, {"heading": "3.4 Inductive definitions", "text": "An important feature of the IDP system is its ability to handle inductive definitions. It uses a rule-based syntax to represent such definitions, in which, for example, the transitive closure of a graph G can be defined as: \"X,\" \"Y,\" \"X,\" \"Z,\" \"D,\" \"D,\" \"D,\" \"D,\" \"D,\" \"\" D, \"\" D, \"\" D, \"\" D, \"\" D, \"\" D, \"\" D, \"D,\" \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D, \"D,\" D"}, {"heading": "4 Experiments", "text": "In this section, two examples of our API are presented, with a particular emphasis on proving that integration with the surrounding Python code can occur naturally."}, {"heading": "4.1 Sudoku", "text": "(...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (..., (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (...), (..., (...), (...), (...), (..., (...), (...), (..., (...), (..., (...), (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (...), (...), (..., (...), (..., (...), (..., (...), (...), (..., (...), (..., (...), (..., (...), (..., (...), (..., (..., (...), (..., (...), (...), (...), (, (...), (...), (..."}, {"heading": "4.2 Working with graphs", "text": "The following class GraphKB extends the generic IDP knowledge base class with some specific functions for working with undirected graphs (Nox). When constructing such a graph list, the nodes of the graph can be initialized using a given formula and the edges using an adjacent list. (The predicate Edge is defined as the symmetrical closing of the adjacent list.) This class also offers a convenience method to define the transitive closing of relationships via this graph. (IDP) GraphKB (IDP): def) n t (s) l (s) e l f, node = [0], a d. \""}, {"heading": "5 Implementation", "text": "The implementation of our API and the examples are available for download.10 The connection to the IDP system is currently decoupled: If the 9 https: / / networkx.github.io / 10 https: / / bitbucket.org / joostv / pyidp / adminAPI detects that the IDP system needs to be called, it creates a text file with the corresponding vocabulary, structure and theory, then calls the IDP system as an external process and analyzes its output. The results of this call are cached so that the IDP system is not called again until the KB changes."}, {"heading": "6 Related work", "text": "There is already a long history of work trying to bridge the gap between imperative and declarative programming [1]. We briefly compare our approach to some recent work in this area. [8] presents an approach where a constraint solver is not added to a single host language, but can be used in the development of a domain-specific language in Racket. As with us, the motivation behind this work is to spread the power of declarative systems more widely. However, their approach differs in that they rely on an intermediary - the domain-specific language designer - to hide the complexity of the declarative system, while our approach focuses on creating an interface that is natural enough to offer KB functionality directly. In [4] a constraint solver is integrated into the scale language, as in our case, its approach uses the syntax of the host language to align itself with the declarative system."}, {"heading": "7 Conclusions and future work", "text": "The goal of our API is to fill such gaps declaratively with as little effort as possible. However, as we have seen, our API could provide a workable solution that is produced in as few lines of code as possible, while our use of standard Python expressions for constraints and definitions leads to a low learning curve. In addition, these two features make it easier to remove the KB when a more efficient solution is needed to insert the KB into an existing code base, while our use of standard Python expressions for constraints and definitions leads to a reduction in the number of programs that were generated first."}], "references": [{"title": "Programming in alma-0, or imperative and declarative programming reconciled", "author": ["Krzysztof R. Apt", "Andrea Schaerf"], "venue": "In FroCos,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1998}, {"title": "Predicate logic as a modeling language: Modeling and solving some machine learning and data mining problems with IDP3", "author": ["M. Bruynooghe", "H. Blockeel", "B. Bogaerts", "B. De Cat", "S. De Pooter", "J. Jansen", "A. Labarre", "J. Ramon", "M. Denecker", "S. Verwer"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "A logic of nonmonotone inductive definitions", "author": ["Marc Denecker", "Eugenia Ternovska"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Constraints as control", "author": ["A. K\u00f6ksal", "V. Kuncak", "P. Suter"], "venue": "In POPL\u201912,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "Unifying execution of imperative and declarative code", "author": ["A. Milicevic", "D. Rayside", "K. Yessenov", "D. Jackson"], "venue": "In Proc. 33rd Int\u2019l Conference on Software Engineering (ICSE),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "A framework for representing and solving NP search problems", "author": ["David G. Mitchell", "Eugenia Ternovska"], "venue": "In AAAI,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "A semantic account for modularity in multi-language modelling of search problems", "author": ["Shahab Tasharrofi", "Eugenia Ternovska"], "venue": "In Proc. FroCos,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Growing solver aided languages with rosetta", "author": ["E. Torlak", "R. Bodik"], "venue": "In Proc. ACM international symposium on New ideas, new paradigms, and reflections on programming & software,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "Journal of the ACM,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1991}, {"title": "A lightweight specification language for bounded program verification", "author": ["K. Yessenov"], "venue": "Master\u2019s thesis,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}], "referenceMentions": [{"referenceID": 1, "context": "As an underlying KB system, we will use IDP (Imperative Declarative Programming) [2], which combines techniques from SAT solving, Logic Programming and Answer Set Programming (ASP).", "startOffset": 81, "endOffset": 84}, {"referenceID": 2, "context": "One of the ways in which IDP extends FO is by adding inductive definitions [3].", "startOffset": 75, "endOffset": 78}, {"referenceID": 5, "context": "As pointed out in [6], modal expansion for FO captures the complexity class NP, thereby", "startOffset": 18, "endOffset": 21}, {"referenceID": 6, "context": "Moreover, [7] have further demonstrated that model expansion is a key task when using declarative methods to build modular software systems.", "startOffset": 10, "endOffset": 13}, {"referenceID": 8, "context": "Such an inductive definition is interpreted under the well-founded semantics [9], which in the case of a positive definition (such as the one above) boils down to a least-fixpoint construction.", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "There is already a long history of work attempting to close the gap between imperative and declarative programming [1].", "startOffset": 115, "endOffset": 118}, {"referenceID": 7, "context": "In [8], an approach is presented in which a constraint solver is not added to a single host language, but can be used in the development of a domain-specific language in Racket.", "startOffset": 3, "endOffset": 6}, {"referenceID": 3, "context": "In [4], a constraint solver is integrated into the Scala language.", "startOffset": 3, "endOffset": 6}, {"referenceID": 4, "context": "In [5], a reasoner for FO extended with transitive closure is integrated into Java.", "startOffset": 3, "endOffset": 6}, {"referenceID": 9, "context": "First, the declarative knowledge is not written in expressions in the host language, but in a separate language (the Alloy-like JFSL [10]).", "startOffset": 133, "endOffset": 137}, {"referenceID": 4, "context": "When it comes to computational performance, [5] reports good results, which our implementation is not able to match.", "startOffset": 44, "endOffset": 47}], "year": 2015, "abstractText": "Programmers may be hesitant to use declarative systems, because of the associated learning curve. In this paper, we present an API that integrates the IDP Knowledge Base system into the Python programming language. IDP is a state-of-the-art logical system, which uses SAT, SMT, Logic Programming and Answer Set Programming technology. Python is currently one of the most widely used (teaching) languages for programming. The first goal of our API is to allow a Python programmer to use the declarative power of IDP, without needing to learn any new syntax or semantics. The second goal is allow IDP to be added to/removed from an existing code base with minimal changes.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}