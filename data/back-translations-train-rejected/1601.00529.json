{"id": "1601.00529", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Jan-2016", "title": "Programming in logic without logic programming", "abstract": "In previous work, we proposed a logic-based framework in which computation is the execution of actions in an attempt to make reactive rules of the form if antecedent then consequent true in a canonical model of a logic program determined by an initial state, sequence of events, and the resulting sequence of subsequent states. In this model-theoretic semantics, reactive rules are the driving force, and logic programs play only a supporting role.", "histories": [["v1", "Mon, 4 Jan 2016 15:09:38 GMT  (523kb)", "http://arxiv.org/abs/1601.00529v1", null], ["v2", "Tue, 5 Jan 2016 15:06:29 GMT  (523kb)", "http://arxiv.org/abs/1601.00529v2", "Under consideration in Theory and Practice of Logic Programming (TPLP)"]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["robert kowalski", "fariba sadri"], "accepted": false, "id": "1601.00529"}, "pdf": {"name": "1601.00529.pdf", "metadata": {"source": "CRF", "title": "Programming in Logic Without Logic Programming", "authors": ["Robert Kowalski", "Fariba Sadri"], "emails": ["rak@doc.ic.ac.uk}", "fs@doc.ic.ac.uk}"], "sections": [{"heading": null, "text": "In fact, most people who are able to survive themselves are able to survive themselves, \"he said.\" I don't think they're able to survive me, \"he said.\" I don't think they're able to survive themselves. I don't think they're able to survive themselves. \"He added,\" I don't think they're able to survive themselves. \"He added,\" I don't think they're able to survive themselves. \"He added,\" I don't think they're able to survive themselves. \"He added,\" I don't think they're able to survive themselves. \""}, {"heading": "2 KELPS", "text": "In this example, the result of two alternative concepts that are made by a reliable customer, then the product must be shipped."}, {"heading": "2.1 Vocabulary", "text": "This year, it has reached the stage where it will be able to take the lead in order to achieve the objectives I have mentioned."}, {"heading": "2.2 KELPS Framework", "text": "This year, it is time for us to be able to find a solution that enables us to find a solution that enables us to find a solution and that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution that enables us to find a solution. \""}, {"heading": "3 The KELPS Model-theoretic Semantics", "text": "In the model theoretical semantics of KELPS, the truth values of the rules R and the prerequisites Cpre are defined according to the standard, non-modal semantics of the classical first order logic. This is in contrast to the semantics of modal logic, in which states are represented by possible worlds, associated with access relationships. In the operational semantics of KELPS, states are updated by adding and solving fluctuations. Fluids not affected by the update are left untouched. If < R, Aux, C > is a KELPS framework, S is a series of unstamped flows representing a single state, and ev is a series of unstamped events, then the associated successor state is unaffected."}, {"heading": "3.1 Herbrand interpretations", "text": "The semantics of the Herbrand interpretations is a simplified version of the standard semantics of the first-order logical definition. Faced with a first-order sorted language, the Herbrand Universe U is the set of all well-sorted basic concepts (i.e., variable-free) that can be constructed from the non-empty set of constants and functional symbols of the vocabulary. The Herbrand Base is the set of all well-sorted basic atoms that can be constructed from the predicate symbols and the basic concepts of the vocabulary. A Herbrand Interpretation is a subset of the Herbrand Base. A Herbrand Model M of a sentence S is a Herbrand Interpretation in such a way that every sentence in S. A difference from the standard definition of truth is the basic case: If I am an interpretation of its brand, then a basic atom A is true in I if and only if A is true. The other difference is the definition of truth in S if each sentence is true."}, {"heading": "3.2 The temporal structure of KELPS interpretations", "text": "The timestamping of fluctuations and events and the limitations of the syntax of KELPS provide Herbrand interpretations of KELPS programs with a rich structure of sub-interpretations. This structure is captured by the following theorem, which is a direct consequence of the definition of truth.Theorem 1. Given a KELPS framework < R, Aux, C >, initial state S0 and a sequence of events ev0... evi: 1. If s is a conjunction of time constraints whose time parameters are allground, then s is valid in Aux S * ev *, if and only if s is in Aux.2. If s is a conjunction of FOL conditions and time constraints whose time parameters are all ground, then: a. If all time stamps in s are the same time i, then s is valid in Aux S * ev *, then s is valid in Aux S *, if and only if s in Aux Si *.b."}, {"heading": "3.3 Sequencing", "text": "The temporal constraints of a complex impose a partial order on the timestamps of the FOL conditions in the complex. Although these timestamps are partially ordered, the complex is used to detect or generate linearly ordered sequences of states that meet the FOL conditions of the complex. It is useful to have a notation in the meta-language that distinguishes between the different sequences represented by the same complex. This notation is not part of the KELPS object language, but useful for defining reactive interpretations and the operative semantics of KELPS. Intuitively, sequencing the form earlier < later means that the FOL conditions in earlier sequences can be evaluated (detected or generated) before the FOL conditions in later.Definition. Let earlier and earlier later be complex. 4 Then, earlier equation of the form < later (or earlier < < if < earlier < < if < earlier in < < later in < < earlier in <) form < < earlier in < earlier in < earlier in < later in < later in <) form <"}, {"heading": "3.4 Reactive interpretations", "text": "Figure 1 and Figure 2 illustrate different types of models of a KELPS program. The following definition characterizes reactive interpretations and models. Frankly speaking, an action occurs in a reactive interpretation if and only if it occurs as a mere action atom in one of the alternative consequences of an instance of a reactive rule, and all previous FOL conditions in the history and alternative consequence of the instance of the rule are already applicable in the interpretation prior to the time of the act. Definition. Given a limited KELPS framework < R, Aux, C >, initial state S0 and setting of ev * time-stamped events, let Cpre in I = Aux S * ev * be true and let ev * = ext * actions * be a division of ev * into external events ext * and actions and actions *. Then I will be reactive if and only if for each action action I have a ruler R < & ante[ other previous action that supports such an earlier action] is an earlier action."}, {"heading": "4 The KELPS Operational Semantics", "text": "Operational semantics uses the internal structure of the KELPS interpretationsAux S * ev * to generate them by maintaining a partial interpretationAux S0 *... Si * evi * a step at a time when it only maintains the unstamped current rules Si and the events to be observed in the future. To recognize the complex sequences of states and events in the past, the OS must maintain a current set of rules that must be monitored in the future."}, {"heading": "5 Relationships between the Model-theoretic and the Operational Semantics", "text": "The proof of correctness for the OS of LPS (Kowalski and Sadri 2010, 2011, 2014), also applies to KELPS, and the details of the proof are given in the appendix: Theorem 2: \"It is as if a KELPS framework < R, Aux, C >, initial state S0 and sequence ext1,... exti,... of sets of external events, assuming that the OS adds the sequences of sets acts1,... of actions and S1, Si,... of states. Then R Cpre is true in I = Aux S * ev *, when, for each target tree added to a target state, i \u2265 0, the target clause is added in any target tree in which we add a target tree, j, j, j, j, j, j, the following theorem characterizes the interpretations generated by the OS. It is a detailed proof of the correctness of active interpretations."}, {"heading": "6 Related Work", "text": "The development of KELPS / LPS has been influenced by work in many different areas of data processing, including programming, databases and artificial intelligence. To facilitate the task of comparing KELPS / LPS with related work, we primarily focus on comparing KELPS / LPS with other approaches that attempt to give rule-based systems logical semantics. In our previous work (Kowalski and Sadri 2009, 2010, 2011, 2012, 2014, 2015) we included extensive comparisons between LPS and many of these systems. In this paper, we incorporate previous comparisons with KELPS and other related work."}, {"heading": "6.1 LPS", "text": "First, we need to clarify the relationship between KELPS and LPS. Consider, for example, a reactive rule in LPS that expresses the goal of a robot to respond with a sentence to each sentence said by an agent called \"turing\": sentence (structuring, T1, T2) sentence (robot, T3, T4) T2 < T2 + 3 secHere the predicate set represents a composite event or action with its start and end times. In LPS, the predicate can be defined by a logic program that can be used both to detect and generate sentences. The logic program may contain clauses such as: sentence (agent, T1, T3) np (agent, T2, T3) adj (agent, T + 1), among other clauses defining the predicates np and vp."}, {"heading": "6.2 Abductive Logic Programming (ALP) and the Event Calculus", "text": "LPS (and thus KELPS) arose in our earlier work on ALP (Fung and Kowalski 1997; Kakas et al 1998) and ALP agents (Kowalski and Sadri 1999, 2009; Kowalski 2011). ALP expands logical programming by allowing certain predicates (abductible or open predicates) to solve a problem. These assumptions are constrained by integrity constraints. In ALP agents, the deductible predicates represent actions, and integrity constraints include reactive rules. The main difference is that KELPS / LPS employs destructive updates for state transitions, while ALP agents use the event calculation (Kowalski and Sergot 1986). Although event calculation is seen as a solution to the framework problem (Shanahan 1997), we believe that it cannot compete with practical applications that represent destructive changes in the state."}, {"heading": "6.3 MetateM", "text": "To our knowledge, MetateM (Barringer et al 1996) is the only other framework that is not based on ALP and describes state transitions by reactive rules in logical form and treats calculation as model generation. Programs in MetateM consist of sentences in modal time logic of form: \"past and present formula\" implies \"present or future formula\" calculation consists in generating a model in which all these sentences are true. MetateM does not formally distinguish between events and fluents and has no explicit causal theory, but frame axioms and other logic programs are written as needed in the form of reactive rules. Like KELPS, MetateM lacks MetateM's logic programs. The main differences are that in KELPS time is explicitly represented, models are classical rather than modal, and models are constructed using destructive updates."}, {"heading": "6.4 Constraint Handling Rules (CHR)", "text": "Similar to LPS, there are two types of rules: equivalencies and rules of propagation. Equivalencies can be used like ordinary logical programs, but can also be used for simplification. Rules of propagation are logical implications that are used to reason forward, like reactive rules in KELPS. CHR (Abdennadher and Sch\u00fctz 1998) extends CHR to include disjunctions in the consequences of rules of propagation, more like reactive rules in KELPS. The operative semantics of rules of propagation in CHR are similar to KELPS, and the operative semantics of rules of propagation and equivalencies are similar to the consequences of rules of propagation, more like reactive rules in KELPS. CHR has a classical logic of semantics in which the propagation of tensism is interpreted as theorem-testing, similar to the explicit semantics of rules of propagation and equivalencies of rules of propagation and equivalencies of LPS."}, {"heading": "6.5 Production systems (PS)", "text": "Production systems are computer languages in which programs are sentences of form, when conditions are actions. State transitions are carried out by evaluating the conditions in the current state and executing the corresponding actions, performing \"conflict resolution\" to choose between contradictory actions. The chosen actions destructively update the current state. It was an attempt to understand the logic of production systems and their relationship to logical programs that led to the development of LPS (which explains the PS in LPS). Several other authors have also tried to provide production rules with logical semantics, mostly by mapping them into logical programs. Rashid (1994) especially transforms production rules into logical programs and uses the fixed-point semantics of logic programming to perform forward concatenation. Baral and Lobo (1995), on the other hand, translate production rules into situational calculation as a logic program with stable model semantics."}, {"heading": "6.6 Integrity Constraints", "text": "The model theoretical semantics of KELPS, which is fundamental to the investigation of completeness in this paper, is based on the model theoretical semantics of integrity constraints in deductive databases and ALP. But from a historical perspective (Kowalski 2014), model theoretical semantics is only one of two main alternatives. The other alternative is the theoretical view, which refers to integrity constraints (and queries) theorems that are a logical consequence of the database, which is called theory. In the parallel world of logical programming, there is a shift away from the theoretical view of computing to a model-generation view. Our own work on the semantics of KELPS / LPS has followed this shift from the theoretical testing to the model generation."}, {"heading": "6.7 Transaction Logic", "text": "Transaction Logic (TR) (Bonner and Kifer 1993) is a logic-based formalism for defining transactions that resemble complex plans in KELPS / LPS and similarly update states of a logic program or database. Transactions in TR have a logical, model-theoretical semantics that, like the possible world semantics of modal logic, are based on contexts of possible worlds (or states). But, unlike modal logic, the truth value of a transaction is defined along a state curve, starting with the state at the beginning of the transaction and ending with the state at the end of the transaction. As in KELPS / LPS, state transitions are performed by means of destructive updates. Although there is no direct analogy of the reactive rules of KELPS / LPS, they can be simulated by transactions. Rezk and Kifer (2012) use such a simulation to transform a logic-based sequence into a production system that KELPS shares a view of the TR with actual conditions."}, {"heading": "6.8 Active Databases", "text": "The majority of these approaches depict reactive rules in the form of Eventcondition-Action (ECA) rules in logical programs. Thus, both Zaniolo (1993) and Lausen et al. (1998) use frame axioms similar to those in Theorem 5 and reduce ECA rules to logical programs such as Action (T + 1) Condition (T + 1) Event (T + 1). Fernandes et al. (1997) give separate logical formalizations of events, conditions, and actions, but do not combine them into reactive rules that are logical implications.Like production systems and unlike KELPS / LPS, active databases are limited to rules whose ancestors query the current state and whose consequences update the current state."}, {"heading": "6.9 Agent Languages", "text": "This year, it has come to the point that it has never come as far as it has this year."}, {"heading": "6.10 Reactive Systems Programming Languages", "text": "In fact, most people who are able to survive themselves are able to survive themselves, \"he told the Deutsche Presse-Agentur in an interview with\" Frankfurter Allgemeine Sonntagszeitung \"(Friday).\" I don't think we will be able to change the world, \"he said.\" But I don't think we will be able to change the world. \"He added,\" I don't think we will be able to change the world. \"He added,\" I don't think we will be able to change the world. \""}, {"heading": "7 Conclusions and Future Work", "text": "This work contributes to the analysis of the relationship between the operational and model semantics of KELPS. In the future, it would be useful to extend the results to LPS. It would also be interesting to extend the operating system to capture more of the non-reactive interpretations that fit the model theory semantics. On the practical side, it would be useful to extend reactive rules to allow for more complex event conditions. This extension would not affect the model theory semantics and can be implemented, for example, by storing a window of past events. It is also important to examine the treatment of parallelism in more detail, especially in the context of multi-agent systems, in which the external events of a single agent include actions generated by other agents.There are a number of implementations of LPS."}, {"heading": "Acknowledgements", "text": "We thank the anonymous referees for their careful reading of our earlier submission and for their many helpful comments."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "In previous work, we proposed a logic-based framework in which computation is the execution of actions in an attempt to make reactive rules of the form if antecedent then consequent true in a canonical model of a logic program determined by an initial state, sequence of events, and the resulting sequence of subsequent states. In this model-theoretic semantics, reactive rules are the driving force, and logic programs play only a supporting role. In the canonical model, states, actions and other events are represented with timestamps. But in the operational semantics, for the sake of efficiency, timestamps are omitted and only the current state is maintained. State transitions are performed reactively by executing actions to make the consequents of rules true whenever the antecedents become true. This operational semantics is sound, but incomplete. It cannot make reactive rules true by preventing their antecedents from becoming true, or by proactively making their consequents true before their antecedents become true. In this paper, we characterize the notion of reactive model, and prove that the operational semantics can generate all and only such models. In order to focus on the main issues, we omit the logic programming component of the framework.", "creator": "Microsoft\u00ae Word 2010"}}}