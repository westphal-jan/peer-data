{"id": "1601.02865", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Jan-2016", "title": "Essence' Description", "abstract": "A description of the Essence' language as used by the tool Savile Row.", "histories": [["v1", "Tue, 12 Jan 2016 14:05:35 GMT  (55kb,D)", "http://arxiv.org/abs/1601.02865v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["peter nightingale", "andrea rendl"], "accepted": false, "id": "1601.02865"}, "pdf": {"name": "1601.02865.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Andrea Rendl"], "emails": [], "sections": [{"heading": null, "text": "ESSENCE \u2032 Description 1.6.4Peter Nightingale and Andrea Rendl"}, {"heading": "1 Introduction", "text": "The purpose of this document is to describe the ESSENCE \u2032 language and to be a reference for users of ESSENCE \u2032. ESSENCE \u2032 is a limited modeling language, hence it is mainly designed for the description of NP-hardy decision problems. < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "2 The ESSENCE\u2032 Expression Language", "text": "In ESSENCE \u2032, expressions are constructed from variables and literals that use operators (such as +). We start by describing the types that can take expressions, then we describe the simplest expressions and build them from there."}, {"heading": "2.1 Types and Domains", "text": "Types and domains play a similar role; they specify a set of values that an expression or variable can assume. Types denote non-empty sets that contain all elements that have a similar structure, while domains may denote empty sets drawn from a single type. Thus, each domain is associated with an underlying type. For example, integer is the type that underlies the domain, the integers between 1 and 10. The type contains all integers, and the domain is a finite subset.ESSENCE is a strongly typed language; each expression has a type, and the types of all expressions can be derived and checked for correctness. Moreover, ESSENCE is a finite domain language; each decision variable is associated with a finite domain of values. The atomic types of ESSENCE \u2032 are int (integer) and bool (boolean)."}, {"heading": "2.2 Domain Expressions", "text": "ESSENCE \u2032 contains a small expression language for Boolean and integer domains. This language consists of three binary infix operators: Intersect, Union and -. All three are left associative and the precedents are given in Appendix A. The language also allows clamped subexpressions with (and).For example, the first and second lines below are exactly equivalent. If you let dom domain-int (1.. 5, 3.. 8) become dom-domain-int (1.. 5) Union-int (3.. 8)."}, {"heading": "2.3 Literals", "text": "Each of the three types (integer, boolean and matrix) has a corresponding literal syntax in ESSENCE \u2032. Any value can be written as a literal. Sentences and real numbers are not (yet) part of the language. Integers and Boolean literals are simple: 1 2 3 -5 true falseThere are two forms of matrix literals. The simpler form is a comma separated list of expressions surrounded by square brackets. For example, the following is a matrix literal containing four integer literals. [1, 3, 2, 4] ESSENCE \u2032 Description 1.6.44 Matrix literals can contain any valid expression in ESSENCE \u2032. For example, a matrix literal may contain other matrix literals to form a matrix with two or more dimensions."}, {"heading": "2.4 Variables", "text": "Variables are identified by a string. Variable names must begin with a letter a-z or A-Z and may contain one of the following characters after the first letter: a-z A-Z 0-9. A variable may be an integer, a boolean, or a matrix. Scoping variables depends on how they are declared and is covered in the following sections. Just like a type, variables have a category. The category is decision, quantifier, or parameter. Decision variables are CSP variables, and the other categories are described below. Expressions that contain decision variables are referred to as decision variables, and expressions that do not contain decision variables as non-decision variables. This distinction is important because expressions must not contain decision variables in certain contexts."}, {"heading": "2.5 Expression Types", "text": "Expressions can be of any of the three basic types (integer, boolean, or matrix). Integer expressions span an an entire domain, e.g. x + 3 (where x is an integer variable) is an integer expression ranging from lb (x) + 3 to ub (x) + 3. Boolean expressions extend across the Boolean domain, for example, the integer comparison x = 3 can be either true or false."}, {"heading": "2.6 Type Conversion", "text": "Boolean expressions or literals are automatically converted to integers when used in a context that expects an integer. Like conventional false expressions, they are converted to 0 and true is converted to 1. For example, the following valid ESSENCE \u2032 Boolean expressions are 1 + 2-3 + true- (x < y) = 5 false < trueInteger expressions are not automatically converted to Boolean. Matrix expressions cannot be converted to another type (or vice versa). ESSENCE \u2032 Description 1.6.45"}, {"heading": "2.7 Matrix Indexing and Slicing", "text": "Suppose we had a three-dimensional matrix M with the following domain: matrix indexed by [int (1.. 3), int (1.. 3), bool] of int (1.. 5) M would be indexed as follows: M [x, y, z], where x and y can be integer or Boolean expressions and z must be boolean. Since the matrix has the base domain int (1.. 5), M [x, y, z] will be an integer expression. Matrix indexing is a subfunction: If one of the indices is outside the boundaries, then the expression is undefined. ESSENCE \u2032 has the relational semantics, which in short means that the Boolean expression containing the undefined expression is wrong. For example, M [1,1, false] = M [1,1, false] = matrix [2,4, true] is always wrong because the 4 is out of bounds. The relational semantics are always described in section 4 of the matrix."}, {"heading": "2.8 Integer and Boolean Expressions", "text": "ESSENCE \u2032 has a number of binary infix and simple operators and functions to build integer and Boolean expressions, for example: \u2022 Integer operators: + - * * * * /% | min max \u2022 Boolean operators:\\ / /\\ - > < - >! \u2022 Quantified sum: sum \u2022 Logical quantifiers: forAll exists \u2022 Numerical comparison operators: =! = > < > = < = \u2022 Matrix comparison operators: < = lex < lex > = lex > lex \u2022 Set operator: in \u2022 Global constraints: allDiff gcc \u2022 Table constraints: TablesThese are described in the following subsections. ESSENCE \u2032 Description 1.6.46"}, {"heading": "2.8.1 Integer Operators", "text": "ESSENCE \u2032 has the following binary integer operators: + - * /% * *. +, - and * are the default integer operators. The operators / and% are integer division and modulo functions. a / b is defined as ba / bc (i.e., it is always rounded), which does not apply to some programming languages, e.g. C99, which rounded towards 0. The modulo operator a% b is defined as a \u2212 bba / bc, which is complementary to /.3 / 2 = 1 (-3) / 2 = -2 3 (-2) = -2 (-3) / (-2) = 13% 2 = 1 (-3)% 2 = 1."}, {"heading": "3 % (-2) = -1", "text": "(-3)% (-2) = -1 * * is the power function: x * * y is defined as xy. There are two simple functions: the absolute value (where | x | is the absolute value of x) and the negation (simple -)."}, {"heading": "2.8.2 Boolean Operators", "text": "ESSENCE \u2032 has the /\\ (and) and\\ / (or) operators defined on Boolean expressions; there are also - > (implied), < - > (if and only if) and! (negation) operators, which take all Boolean expressions and generate a new Boolean expression; they can be nested at will; the comma in ESSENCE \u2032 is also a binary Boolean operator, with the same meaning as /\\. However, it has a different precedence and is used very differently. /\\ is normally used within a constraint and is used to separate constraints (or separate groups of constraints constructed with a forAll); for example, forAll i: int (1.. n). x [i] = y [i] = i] /\\ x [i] = within a /\\ x [i] [i] = y [i + 1], exists i: int (1.. n)."}, {"heading": "2.8.3 Integer and Boolean Functions", "text": "ESSENCE \u2032 has named functions min (X, Y) and max (X, Y), both of which have two integer expressions X and Y. min and max can also be applied to one-dimensional matrices to obtain the minimum or maximum of all elements in the matrix (see Section 2.10). Factorial (x) returns the factor number of values from 0 to 20 if the result matches a 64-bit signed integer. It is undefined for other values of x and the expression x must not contain decision variables. popcount (x) returns the bit number of the 64-bit dual complementary representation of x, and x must not contain decision variables. toInt (x) takes a Boolean expression x and converts to an integer of 0 or 1. This function is only included for compatibility with ESSENCE: it is not needed in ESSENCE because Booleans are automatically converted to integers."}, {"heading": "2.8.4 Numerical Comparison Operators", "text": "ESSENCE \u2032 returns the following integer comparisons with their obvious meanings: =! = > < > = < = These operators each take two integer expressions and generate a Boolean expression. ESSENCE \u2032 Description 1.6.47"}, {"heading": "2.8.5 Matrix Comparison Operators", "text": "ESSENCE \u2032 offers a way to compare one-dimensional matrices: These operators compare two matrices based on the dictionary order (lex for short).There are four operators: A < lex B ensures that A comes before B in lex order, and A < = lex B, which ensures that A < lex B or A = B > = lex and > lex are identical, but with inverted arguments. For all four operators, A and B may have different lengths and be indexed differently, but they must be one-dimension.Multidimensional matrices can be flattened to one dimension using the flat surface function described in Section 2.10."}, {"heading": "2.8.6 Set Operator", "text": "The operator in indicates that an integer expression takes on a value in a set expression, and the set expression must not contain decision variables; the set can be a domain expression (Section 2.2) or the toSet function, which converts a matrix into a set, as in the following examples. x + y in (int (1,3,5) intersect int (3.. 10)) x + y in toSet ([i | i: int (1.. n), i% 2 = 0])"}, {"heading": "2.8.7 The Quantified Sum Operator", "text": "The sum operator corresponds to the mathematical concept and has the following syntax: sum i: D. Where i is a quantification variable, D is a domain, and E is the expression within the sum. More than one quantification variable can be generated by adding a comma-separated list i, j, k. For example, if we want to take the sum of all numbers in the range of 1 to 10, we write i: int (1.. n). i, which corresponds to the number ni = 1 i. n, cannot be a decision variable. Quantified sum has several similarities to forSpace and exists quantification quators (as described in Section 2.8.8 below): it introduces new local variables (so-called quantification variables) that can be used within E, and the quantification variables all have the same domain D. However, the sum has an important difference: a sum is an integer expression. A quantified sum can be negated within any other integer, including another quantified sum int (j) (10)."}, {"heading": "2.8.8 Universal and Existential Quantification", "text": "Universal and existential quantification are powerful means of writing down a series of constraints in a compact manner. Quantifications have the same syntax as the sum, but with forAll and exist as keywords: forAll i: D. E exists i: D. For example, the universal quantification for All i: int (1.. 3). x [i] = corresponds to the conjunction: x [1] = 1 /\\ x [2] = 2 /\\ x [3] = 3ESSENCE \u2032 Description 1.6.48 An example of existential quantification isexists i: int (1.. 3). x [i] = iand it corresponds to the following disjunction: x [1] = 1\\ / x [2] = 2\\ / x [3] = 3Quantifications can range over several quantified variables and can be arbitrarily nested, as shown in the current Sudoku example."}, {"heading": "2.8.9 Quantification over Matrix Domains", "text": "All three quantifiers are defined on matrix domains as well as on integer and Boolean domains, for example, to quantify over all permutations of the size n: forAll perm: matrix indexed by [int (1.. n)] of int (1.. n). allDiff (perm) - > expThe variable perm represents a matrix drawn from the matrix domain, and the allDiff constraint is evaluated to true if Perm is a permutation of 1.... n. Therefore, the expression exp is for all permutations of 1.... n.If n is a constant, the above example could be written as a set of n nested quantifiers. However, if n is a parameter of the problem class, it is very difficult to write the above example using other (non-matrix-related) quantifiers."}, {"heading": "2.8.10 Global Constraints", "text": "ESSENCE \u2032 provides a small set of global constraints such as allDiff (which is fulfilled when a vector of variables takes on different values).Global constraints are all Boolean expressions in ESSENCE \u2032. Typically, it is worthwhile using them in models, because the solver often performs better with a global constraint than with a set of simpler constraints. For example, the following two lines are semantically equivalent (assuming x is a matrix that is replaced by 1.. n).forint All i, j: int (1.. n). i < j - > x [i]! = x [j] allDiff (x) Both lines ensure that the variables in x take on different values. However, in most situations the allDiff will perform better.2 Table 1 summarizes the global constraints available in ESSENCE (1..)."}, {"heading": "2.8.11 Table Constraints", "text": "A table constraint defines the satisfactory tuples of the constraint with the help of a matrix, which allows a table constraint to theoretically implement any relationship, even though it is practically limited to relationships in which the amount of satisfactory tuples is small enough to store in memory and efficiently search for them. (The first argument specifies the variables to the extent of the constraint, and the second argument is a two-dimensional matrix of satisfactory tuples. For example, the constraint a + b = c on Boolean variables is to write as a table as the following. ([a, b, c], [0,0,0], [0,1,1], [1,0,1]]]]) The first argument of the table is a one-dimensional matrix expression. It can contain both decision variables and constants; the second argument is a two-dimensional matrix expression that contains no decision variables; the second argument can be specified as a literal or identifier."}, {"heading": "2.9 Matrix Comprehensions", "text": "This is an example of how matrices can also be constructed using matrix terms, providing a very flexible way to create matrices of variables or values. A one-dimensional matrix concept creates a one-dimensional matrix, but they can be linked together to create multi-dimensional matrices. There are two syntactical forms of the matrix concept: [exp] i: domain1, j: domain2, cond2] [exp: domain2, cond2]."}, {"heading": "2.9.1 Matrix Comprehensions over Matrix Domains", "text": "Similar to quantifiers, matrix understanding variables can have a matrix domain. Thus, the following understanding forms a two-dimensional matrix in which the lines are all permutations of 1.. n. [Perm: matrix indexed by [int (1.. n)] of int (1.. n), allDiff (perm)]"}, {"heading": "2.10 Functions on Matrices", "text": "Table 2 lists the matrix functions available in ESSENCE. The functions sum, product, and or were originally intended to be used with matrix terms, but can be used with any matrix. The quantifiers sum, forAll and exists can be replaced by sum and or contain matrix terms. Consider, for example, the forAll expression below (from the Sudoku model), which can be replaced with the second line below. In fact, matrix functions combined with matrix terms are strictly more powerful than quantifiers. (..) ESSENCE \u2032 Description 1.6.412 and (allDiff (M [line,..] line: int (1.. 9) Indeed, matrix functions combined with matrix terms are strictly more powerful than quantifiers that do not have corresponding quantifiers. Quantifiers are easier to keep in the language because they are easier to read."}, {"heading": "3 Model Structure", "text": "In fact, it is the case that most of them are able to abide by the rules that they have imposed on themselves. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...) Most of them are not able to abide by the rules. (...)"}, {"heading": "3.2.1 Constant Domains", "text": "Constant domains are similarly given with the keywords be domain.letting c = 10 n: int (1..) let INDEX domain be int (1.. c * n) In this example, INDEX is defined as an integer domain whose upper limit is set by one parameter n and another constant c.Constant domains are handy if a domain is reused several times. In the sudoku running example, we could use a rental for the domain (1.. 9): ESSENCE description 1.6.415 languages ESSENCE '1.0 let domain be domain (1.. 9) given clues: matrix indexed by [range, range] of int (0.. 9) find M: matrix indexed by [range, range] of such thatforint variables: all variables: range. forAll col: range. (forAll col: range, range). (clues [, row] col."}, {"heading": "3.5 Objective", "text": "The goal of a problem is either to maximize or minimize an integer or Boolean expression. For example, minimizing xstates causes the value assigned to variable x to be minimized. Only one target is allowed, and it is finally given to find and leave statements."}, {"heading": "3.6 Solver Control", "text": "In addition to instructing the solver to minimize or maximize an expression, ESSENCE \u2032 also supports some rudimentary options for controlling which variables the solver will branch and which sequence of variables will be heuristically used. heuristically, the statement is passed only when Minion is used as the solver. These instructions are experimental and may be removed from the language in future versions. Heuristic instructions follow static, sdf, conflicts, or srf, and these options are passed to Minion. The following example tells the solver to branch to w and x, with the smallest domain being used heuristically first. Heuristic instructions follow static, sdf, conflicts, or srf, and these options are passed to Minion."}, {"heading": "3.7 Constraints", "text": "After defining constants and declaring decision variables and parameters, constraints with keywords are specified so that the constraints in ESSENCE \u2032 are Boolean expressions as described in Section 2.8. Typically, the constraints are written as a list of Boolean expressions separated by the operator."}, {"heading": "4 Undefinedness in ESSENCE\u2032", "text": "Since the current version of ESSENCE \u2032 is a closed language, there is an endless series of subfunctions in the language. For example, x / y is a subfunction because it is not defined when y = 0. In its current version ESSENCE \u2032 implements relational semantics as defined by Frisch and Stuckey. Relational semantics has the advantage that it can be implemented efficiently. Relational semantics can be summarized as follows: \u2022 Principles and Practice of Constraint Programming - CP 2009, pages 367-382."}, {"heading": "A Operator Precedence in ESSENCE\u2032", "text": "As expected, operators with higher priority are used first. Left-associative operators are evaluated first, e.g. 2 / 3 / 4 = (2 / 3) / 4. The only operator with right associativity is * *. This allows double exposures to have their conventional meaning: 2 * * 3 * * 4 = 2 * * (3 * * 4) Unary operators usually have a higher priority than binary operators. There is one exception to this rule: that * * has a higher priority than simple minus. This allows -2 * 2 * * * 3 to have its conventional meaning of - (2 * * (2 * 3) = -256, as opposed to (-2) * * (2 * * (3) = 256."}, {"heading": "B Reserved Words", "text": "The following words are keywords and must not be used as identifiers: forall, forAll, exists, sum, such, that, let, given, where, find, language, int, bool, union, intersect, in, false, true"}], "references": [{"title": "ESSENCE: A constraint language for specifying combinatorial problems", "author": ["Alan M. Frisch", "Warwick Harvey", "Chris Jefferson", "Bernadette Mart\u2019inez Hern\u00e1ndez", "Ian Miguel"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Automatically improving constraint models in Savile Row through associative-commutative common subexpression elimination", "author": ["Peter Nightingale", "\u00d6zg\u00fcr Akg\u00fcn", "Ian P Gent", "Christopher Jefferson", "Ian Miguel"], "venue": "In 20th International Conference on Principles and Practice of Constraint Programming (CP", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Automatically improving SAT encoding of constraint problems through common subexpression elimination in Savile Row", "author": ["Peter Nightingale", "Patrick Spracklen", "Ian Miguel"], "venue": "In Proceedings of the 21st International Conference on Principles and Practice of Constraint Programming (CP", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2015}, {"title": "The OPL Optimization Programming Language", "author": ["Pascal Van Hentenryck"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}], "referenceMentions": [{"referenceID": 0, "context": "ESSENCE\u2032 began as a subset of ESSENCE [1] and has been extended from there.", "startOffset": 38, "endOffset": 41}, {"referenceID": 3, "context": "It is similar to the earlier Optimization Programming Language (OPL) [4].", "startOffset": 69, "endOffset": 72}, {"referenceID": 1, "context": "ESSENCE\u2032 is implemented by the tool SAVILE ROW [2, 3].", "startOffset": 47, "endOffset": 53}, {"referenceID": 2, "context": "ESSENCE\u2032 is implemented by the tool SAVILE ROW [2, 3].", "startOffset": 47, "endOffset": 53}, {"referenceID": 0, "context": "In this case the clues (for example M[1,1]=5) are included in the model.", "startOffset": 37, "endOffset": 42}, {"referenceID": 0, "context": "In this case the clues (for example M[1,1]=5) are included in the model.", "startOffset": 37, "endOffset": 42}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 1, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 21, "endOffset": 26}, {"referenceID": 0, "context": "[ 1, 3, 2, 4 ]", "startOffset": 0, "endOffset": 14}, {"referenceID": 2, "context": "[ 1, 3, 2, 4 ]", "startOffset": 0, "endOffset": 14}, {"referenceID": 1, "context": "[ 1, 3, 2, 4 ]", "startOffset": 0, "endOffset": 14}, {"referenceID": 3, "context": "[ 1, 3, 2, 4 ]", "startOffset": 0, "endOffset": 14}, {"referenceID": 0, "context": "x[1] = 1 /\\ x[2] = 2 /\\ x[3] = 3", "startOffset": 1, "endOffset": 4}, {"referenceID": 1, "context": "x[1] = 1 /\\ x[2] = 2 /\\ x[3] = 3", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "x[1] = 1 /\\ x[2] = 2 /\\ x[3] = 3", "startOffset": 25, "endOffset": 28}, {"referenceID": 0, "context": "x[1] = 1 \\/ x[2] = 2 \\/ x[3] = 3 Quantifications can range over several quantified variables and can be arbitrarily nested, as demonstrated with the sum quantifier.", "startOffset": 1, "endOffset": 4}, {"referenceID": 1, "context": "x[1] = 1 \\/ x[2] = 2 \\/ x[3] = 3 Quantifications can range over several quantified variables and can be arbitrarily nested, as demonstrated with the sum quantifier.", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "x[1] = 1 \\/ x[2] = 2 \\/ x[3] = 3 Quantifications can range over several quantified variables and can be arbitrarily nested, as demonstrated with the sum quantifier.", "startOffset": 25, "endOffset": 28}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 1, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 21, "endOffset": 26}, {"referenceID": 0, "context": "table( [a,b,c], [[0,0,0], [0,1,1], [1,0,1]] ) The first argument of table is a one-dimensional matrix expression.", "startOffset": 26, "endOffset": 33}, {"referenceID": 0, "context": "table( [a,b,c], [[0,0,0], [0,1,1], [1,0,1]] ) The first argument of table is a one-dimensional matrix expression.", "startOffset": 26, "endOffset": 33}, {"referenceID": 0, "context": "table( [a,b,c], [[0,0,0], [0,1,1], [1,0,1]] ) The first argument of table is a one-dimensional matrix expression.", "startOffset": 35, "endOffset": 42}, {"referenceID": 0, "context": "table( [a,b,c], [[0,0,0], [0,1,1], [1,0,1]] ) The first argument of table is a one-dimensional matrix expression.", "startOffset": 35, "endOffset": 42}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 1, "endOffset": 6}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 1, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 11, "endOffset": 16}, {"referenceID": 0, "context": "M[1,1]=5, M[1,2]=3, M[1,5]=7, .", "startOffset": 21, "endOffset": 26}, {"referenceID": 0, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 12, "endOffset": 17}, {"referenceID": 1, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 12, "endOffset": 17}, {"referenceID": 2, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 19, "endOffset": 24}, {"referenceID": 3, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 19, "endOffset": 24}, {"referenceID": 0, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 50, "endOffset": 67}, {"referenceID": 1, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 50, "endOffset": 67}, {"referenceID": 2, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 50, "endOffset": 67}, {"referenceID": 3, "context": "flatten([ [ [1,2], [3,4] ], [ [5,6], [7,8] ] ]) = [1,2,3,4,5,6,7,8]", "startOffset": 50, "endOffset": 67}, {"referenceID": 1, "context": "letting cmatrix = [ [2,8,5,1], [3,7,9,4] ] letting cmatrix2 : matrix indexed by [ int(1.", "startOffset": 20, "endOffset": 29}, {"referenceID": 0, "context": "letting cmatrix = [ [2,8,5,1], [3,7,9,4] ] letting cmatrix2 : matrix indexed by [ int(1.", "startOffset": 20, "endOffset": 29}, {"referenceID": 2, "context": "letting cmatrix = [ [2,8,5,1], [3,7,9,4] ] letting cmatrix2 : matrix indexed by [ int(1.", "startOffset": 31, "endOffset": 40}, {"referenceID": 3, "context": "letting cmatrix = [ [2,8,5,1], [3,7,9,4] ] letting cmatrix2 : matrix indexed by [ int(1.", "startOffset": 31, "endOffset": 40}, {"referenceID": 1, "context": "10) = [ [2,8,5,1], [3,7,9,4] ] Finally new matrices may be constructed using a slice or comprehension, as in the example below where the letting is used for the table of a table constraint.", "startOffset": 8, "endOffset": 17}, {"referenceID": 0, "context": "10) = [ [2,8,5,1], [3,7,9,4] ] Finally new matrices may be constructed using a slice or comprehension, as in the example below where the letting is used for the table of a table constraint.", "startOffset": 8, "endOffset": 17}, {"referenceID": 2, "context": "10) = [ [2,8,5,1], [3,7,9,4] ] Finally new matrices may be constructed using a slice or comprehension, as in the example below where the letting is used for the table of a table constraint.", "startOffset": 19, "endOffset": 28}, {"referenceID": 3, "context": "10) = [ [2,8,5,1], [3,7,9,4] ] Finally new matrices may be constructed using a slice or comprehension, as in the example below where the letting is used for the table of a table constraint.", "startOffset": 19, "endOffset": 28}, {"referenceID": 0, "context": "DOM is bool) then M[0] becomes false, and the model has a solution when M[1]=false.", "startOffset": 73, "endOffset": 76}, {"referenceID": 0, "context": "1)) then the constraint M[0] = M[1] becomes false and the model has no solutions.", "startOffset": 32, "endOffset": 35}, {"referenceID": 0, "context": "find M : matrix indexed by [int(1)] of DOM such that M[0] = M[1] In the SAVILE ROW implementation of ESSENCE\u2032, all partial functions are removed in a two-step process, before any other transformations are applied.", "startOffset": 61, "endOffset": 64}], "year": 2016, "abstractText": null, "creator": "LaTeX with hyperref package"}}}