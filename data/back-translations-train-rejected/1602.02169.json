{"id": "1602.02169", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Feb-2016", "title": "Probabilistic Extension to the Concurrent Constraint Factor Oracle Model for Music Improvisation", "abstract": "We can program a Real-Time (RT) music improvisation system in C++ without a formal semantic or we can model it with process calculi such as the Non-deterministic Timed Concurrent Constraint (ntcc) calculus. \"A Concurrent Constraints Factor Oracle (FO) model for Music Improvisation\" (Ccfomi) is an improvisation model specified on ntcc. Since Ccfomi improvises non-deterministically, there is no control on choices and therefore little control over the sequence variation during the improvisation. To avoid this, we extended Ccfomi using the Probabilistic Non-deterministic Timed Concurrent Constraint calculus. Our extension to Ccfomi does not change the time and space complexity of building the FO, thus making our extension compatible with RT. However, there was not a ntcc interpreter capable of RT to execute Ccfomi. We developed Ntccrt --a RT capable interpreter for ntcc-- and we executed Ccfomi on Ntccrt. In the future, we plan to extend Ntccrt to execute our extension to Ccfomi.", "histories": [["v1", "Fri, 5 Feb 2016 21:26:53 GMT  (4254kb)", "http://arxiv.org/abs/1602.02169v1", "70 pages"]], "COMMENTS": "70 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["mauricio toro"], "accepted": false, "id": "1602.02169"}, "pdf": {"name": "1602.02169.pdf", "metadata": {"source": "CRF", "title": "Probabilistic Extension to the Concurrent Constraint Factor Oracle Model for Music Improvisation", "authors": ["Mauricio Toro"], "emails": [], "sections": [{"heading": null, "text": "Keywords: Factor Oracle, Concurrent Constraints Programming, ccp, Machine Learning, Machine Improvisation, Ccfomi, Gecode, ntcc, pntcc, Real Time."}, {"heading": "1 Introduction", "text": "There are two different approaches to developing multimedia interaction systems (e.g. machine improvisation). One might think that to implement real-time capable systems, these systems should be written directly in C + + for efficiency reasons. In contrast, it can be argued that multimedia interaction systems - which are inherently compliant - should not be written directly in C or C + + because there is no formalism to think about contemporaneity in C + +. We argue that these systems should be modeled using a process calculation using formal semantics and verification procedures, and these models should be executed on a real-time capable interpreter. This will be our definition for real-time in the rest of this document.Garavel explains in [13] that models based on process calculations are not widely used because there are many calculations and many variants for each cold, and it is difficult to select the most appropriate concepts of worktime, and that it is difficult to explicitly express existing time demands."}, {"heading": "1.1 Motivation", "text": "We defend the approach of calculations, Rueda et al. [38], [40] explain that it is possible to prove the properties of the Ntcc models before they are executed and the models run on an Ntcc interpreter. We define soft multimedia interaction in real time, which means that the system reacts quickly enough to interact with human actors without them noticing it. One can contradict Rueda et al. and argue that while there are several interpreters for Ntcc interpreters, such as Lman [22] and Rueda's interpreter model of music [40], that there is no generic interpreter to run Ntcc models in real time. We agree with Rueda et al. on the way these systems are developed, but we argue that there are currently no Ntcc interpreters that are improvisational. We argue in agreement with Rueda et al."}, {"heading": "1.2 Music improvisation", "text": "\"Musical improvisation is the spontaneous creative process of making music during performance. To use a linguistic analogy: improvisation is like speaking or talking as opposed to reciting a written text. Among jazz musicians, there is a saying: improvisation is accelerated composition, and vice versa, composition is slowed improvisation.\" [23] Improvisation exists in almost all areas of music. However, improvisation is most often associated with melodic improvisation, as found in jazz. However, spontaneous real-time variations in the performance of tempo and dynamics within a classical performance can also be considered improvisation [23] The reader may see an example of musical improvisation in [35], where the musician Alberto Riascos improvised in the Colombian musical genre Guabina1 and explained to us how he did so."}, {"heading": "1.3 Machine improvisation", "text": "In this process, music is represented either by explicit coding of rules or by the use of machine learning methods. To improvise in real time, it is necessary to perform two phases simultaneously: Stylistic Learning and Stylistic1 Guabina must be able to interact in real time with human players [40]. Rueda et al. define stylistic learning as the process of applying such methods to musical sequences in order to integrate them into a model, and stylistic simulation as the process of producing musical sequences."}, {"heading": "1.5 Our solution", "text": "This idea is based on the probabilistic Ccfomi model developed by P\u00e9rez and Rueda. [29] This model selects the improvised sequences probabilistically, based on a probability distribution. Unfortunately, there is no information on how this probability distribution can be constructed, nor how it can change over time according to the user and computer interaction. Our model is the first pntcc model, as far as we know, in which the probability distributions change from a unit of time to an anothery. For example, it is considered that our system can play the pitches at a given moment (i.e., the precision of the notes is not altered)."}, {"heading": "1.6 Contributions", "text": "Our first attempt to provide an interface for Gecol to Common Lisp was to extend Gecol to work with Gecol 2. With Gecol 2, we wrote several prototypes for the Ntcc interpreter. Examples, sources and binaries can be found at http: / / common-lisp.net / project /.Ntccrt. A real-time interpreter for Ntcc. Using Ntccrt, we ran Ccfomi. Examples, sources and binaries can be found at http: / ntccrt.sourceforge.net. An article about Ntccrt is due to be published this year. Gelisp. A new graphical constraint solving library for OpenMusic. We plan to use it in the future for closer integration between Ntccrt and OpenMusic. Examples, sources and binaries can be found at http: / / gelisp.sourceforge.net. An article about Gelisp is due to be published this year."}, {"heading": "1.7 Organization", "text": "Chapter 2 focuses on the modelling of CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"}, {"heading": "2 Background", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Concurrent Constraint Programming (CCP)", "text": "In fact, it is such that we are able to assert ourselves in a position to assert that we are able to assert ourselves in a position to assert ourselves in the world, and that we are able to assert ourselves in the world, that we are able to assert ourselves in the world, in which we are located, in which we live, in the world, in which we live, in which we live, in which we live, in which we live, in which we, in which we, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we, in which we, in which we, in which we, in which we, in which we, in which we, in which we, in which we, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in the, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in which, in"}, {"heading": "2.2 Non-deterministic Timed Concurrent", "text": "This year, it has come to the point that it has never come as far as it has this year."}, {"heading": "2.3 Generic Constraint Development Environment (Gecode)", "text": "Gecode is based on Restrictions as Propagation Means (CPA) according to [39]. A CPA system offers multiple propagation possibilities to turn a (non-primitive) factor into primitive constraints that provide the same information. (Readers may notice that there is a similarity between CPA and ntcc. Both are based on simultaneous occupations working over a limited business. (Chapter 6) We explain how to code ntcc agents as propagators. Geccode works on different operating systems and is currently used as the constraint library for Alice [36], and soon it will be maintained for a long time."}, {"heading": "2.5 Concurrent Constraint Factor Oracle Model for Music Improvisation", "text": "Subsequently, we will present a brief explanation of the model from [40]. Ccfomi has three types of variables representing the partially built FO automaton: Variables are the set of labels of all currently existing factor combinations starting from k. Variables are the suffix associations from each state i, and variables indicate the state reached by k by following a factor link that is labeled. For example, in Figure 5, the FO is represented by,,,,. Although not explicitly specified in Ccfomi, the variables can and are modeled as infinite rational trees [34], which allows us to add elements to them, each unit of time. Infinite rational trees have infinite size. However, they contain only a finite number of different subtrees. For this reason, they are subjects of multiple axiomatizations to construct a system based on them."}, {"heading": "2.6 Probabilistic Non-deterministic Timed", "text": "Concurrent Constraint (pntcc) \"One possible criticism of CCP is that it is too general to represent certain complex systems. However, even if counting with partial information is extremely valuable, we find that proper consideration of certain phenomena remains difficult, which greatly impairs both modelling and verification.\" [29] Particularly difficult is the case of uncertain behavior. In fact, the uncertainty underlying simultaneous interactions in areas such as computer music goes far beyond what can only be modelled with partial information. \"[29] The first attempt to extend ntcc to work with probabilities was the stochastic, non-deterministic time dependency restriction (sntcc [25]). Sntc gives an operator the ability to decide whether or not to execute a process with a certain probability. With sntcc, Ccfomi models the action of choosing between a suffix association or a factor association with a probability."}, {"heading": "3 Probabilistic Choice of Musical Sequences", "text": "When we model an improvisation, we want to select a particular music sequence based on the history of user and computer interaction. For example, if we traverse the factor oracle (FO) in the simulation phase, we want to choose some information between the factor connections and the suffix link that follows a particular state. To achieve this, we propose to assign integers to the links in the FO. Finally, with these integers we can calculate probabilities based on a probability distribution. We remember the introduction that our main goal is to assign Ccfomi to the modelling choice of the musical sequences. At the beginning of this theory work, we developed a probability model that changes the complexity in the time for building the FO to square (see Appendix 9.2.1). The idea behind this was to modify the probabilities of all factor connections that originate from the state i when we modify a factor connection that leaves this state. This idea was rejected because it is not compatible with real time."}, {"heading": "3.1 Stylistic learning phase", "text": "During the learning phase, we store an integer for each factor link that starts with i, marked by > \u03c3. We also store an integer for each state i of the automaton. The initial value for is (Fig. 6), where \u03b3 is a system parameter that represents the importance of a new sequence in relation to the sequences already learned. If a factor link from i is marked as the first factor link from i, we assign it and the constant c. In addition, we want c to be a large integer, which allows us to be more precise in thinking about this approach. The reader will notice that this approach gives a certain meaning to a new factor link that starts with i, without changing the value of all other quantities that start with i. Furthermore, we preserve the sum of all values in the variable for each state i. This system exhibits a very important property: For each state i. The sum of all probabilities associated with the factor link is linked to the factor link that goes out of the state i."}, {"heading": "3.2 Stylistic simulation phase", "text": "In the simulation phase, we use all the information calculated in the learning phase to select the grades as a matter of probability. Factor linkages chosen in this phase reduce the meaning proportional to \u03b2. In addition, the probability of choosing secondary factor linkages is proportional to \u03b3. We consider primary factor linkages going from i to i + 1, and all others as secondary. On the other hand, the suffix linkages are rewarded by the context, computed linkages in the learning phase.If there were no suffix linkages, we would choose a factor linkage that leaves the state i with a probability distribution (and considers all others as secondary).Later, we will explain how we can expand this concept to work with the suffix linkages rewarded by their context. The concept of reducing the probability of a factor linkage if it remains unchanged."}, {"heading": "3.3 Summary", "text": "In this chapter, we explained how to model music improvisation using probabilities, extending the concept of non-deterministic choice described in Ccfomi. Intuition reduces the probability of choosing a factor link each time it becomes ischosen, and rewards a suffix link based on context. In addition, we explained how the parameters \u03b1, \u03b2, and \u03b3 allow us to parameterise the calculation of probabilities. This procedure is so simple that the probabilities can be calculated in constant time when the FO is constructed, maintaining the linear complexity in time and space of the online construction algorithm of the FO. Furthermore, the use of probabilities allows us to generate different sequences without repeating the same sequence several times in a row as Ccfomi."}, {"heading": "3.4 Related work", "text": "For Omax, Assayag and Blonch have recently proposed a new method of traversing the oracle on the basis of heuristics [5], arguing that traversing the oracle produces more \"interesting\" sequences only with the suffix associations and not with the factor associations. There is an extension of Ccfomi with pntcc. Using pntcc enables the selection of sequences in the simulation phase based on a probability distribution. Although Perez and Rueda have modelled the probable selection of sequences using the FO, they do not provide a description of how these probabilities can be calculated during the learning phase."}, {"heading": "4 Changing Musical Attributes of the Notes", "text": "In fact, interactive systems based on the style of the learned corpus are usually based on the recombination of sequences in time and space. Although the recombination creates new sequences based on the user style, it does not create new notes. In fact, it does not even change a single property of a note (e.g. Ccfomi) based on the recombination of sequences in time. Although the recombination creates new sequences based on the user style, it does not create new notes."}, {"heading": "4.1 Stylistic learning phase", "text": "The intensity in music represents two different things at the same time. If we analyze the intensity of a single note in a sequence, we think about that intensity as a musical accent that means the meaning of certain notes or defines rhythms. On the other hand, we think about the average intensity of a note string as the dynamics of that sequence of notes. Accents can be written explicitly in the score with a symbol under the note, and the dynamics for relative volume can be explicitly stored in the score as piano (p), forte (f), fortissimo (ff), etc. To capture these two concepts, in the learning phase we store the intensity in a tuple < pitch, duration, intensity >. In addition, we store the current dynamics for the last notes played by the user and the computer. To calculate the current dynamics, we propose the Calculate-Current-Dynamics algorithm."}, {"heading": "4.2 Stylistic simulation phase", "text": "If we play the intensities with the same value as they were learned, we might have a problem of coherence between the current dynamics of the user and the current dynamics of the sequences we produce. To give an example of this problem, we look at the Happy Birthday fragment shown in Figure 7. The current dynamics for this fragment is 98. Let us now assume the current dynamics of the computer is 30. This is a problem because the user expects the computer to improvise in the same dynamics as it does according to the interviews with Riascos and Collazo. The solution we propose multiplies by a factor the intensity of each note generated by the computer. In the previous example, the next note generated by the computer would be multiplied by a factor of 30 / 98."}, {"heading": "4.3 Summary", "text": "We explained how to change the intensity of the notes generated during improvisation. It is a matter of maintaining the current dynamics of the notes generated by the computer, which is similar to the current dynamics of the notes generated by the user. This corresponds to the formalisation of an improvisation technique used by two musicians interviewed for this theory thesis. This type of variation of intensity is something new to machine improvisation systems of our knowledge. We believe that such an approach, which allows simple variations to be made, retains the style learned by the user and is compatible with real-time, should be the subject of future research."}, {"heading": "4.4 Related work", "text": "To solve this problem of creating new notes and changing the attributes of notes during improvisation, we do not use a new system when we have called innovation rate, which indicates the amount of new material that is desired [6]. Furthermore, Omax calculates a rhythmic quality function to compare the density (the number of events for the total duration) between the current state and the place where a connection exists. Using this rhythmic quality function, improvisation cannot \"jump\" abruptly between different rhythmic patterns. Therefore, the Omax improvisation is rhythmically coherent in itself. However, the generation of new rhythms related to the user's style is still an open problem. The anticipatory model developed by Cont et al presents some results where the sequences produced in improvisation have different pitches compared to the original sequence. To achieve this, improvise on a pitch interval FO every user plays."}, {"heading": "5.1 Modeling the stylistic learning phase", "text": "The learning phase is represented by the functions Ext _ Oracle _ On-line and Ext _ Add _ Letter. To calculate the context, we use the function Length _ Repeated _ Suffix, which is used by Lefevre et al. The function Ext _ Add _ Letter is used by Lefevre et al. The function Length _ Repeated _ Suffix computes the context. It finds the length of a repeated suffix of P [1.. i + 1] in linear time and space Complexity.The Ext _ Add _ Letter function is responsible for the addition of new pitches to the FO. It also generates a tuple < pitch, duration, intensity >; updates values of and; and calculates the current dynamics of the user, and the context for the state i + 1. This function receives an FO with i states, a pitch, the system parameters and the intensity of execution."}, {"heading": "5.2 Modeling the style simulation phase", "text": "This model is an extension of the model shown in [29]. In our model, the IMPROV process selects a link according to the probability distribution. In addition, it updates the values for sum and, sets the results up and updates the dynamics of the computer stream. To ask whether a restriction A, B or A, B can be derived from memory, we use reification. For example, the process, if a = b, c = d do P, can be codified as a process when g do P and the restrictions,.IMPROV (k, \u03c4, \u03b2) | when do (when do (tell () | tell () | tell () | tell () | tell () | tell () | tell () | tell () | tell () | tell () | | | do next (IMPROV (k + 1, \u03b2) +) +) | | | | if next (when do (tell (when do (tell () () () (p) | | tell () | | tell () p () | tell () | tell () p () | tell () | tell () () p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, (), p (), p, p, p, (), (), (), ()."}, {"heading": "5.3 Synchronizing the improvisation phases", "text": "This means that the process has played the note i and the process can add a new symbol to the FO. The other condition is that the first suffix term of the FO is equal to -1 and that this suffix term cannot be followed in the simulation phase. Furthermore, the SYNC process also \"waits\" for the current dynamic to take on a value greater than 0."}, {"heading": "5.4 Summary", "text": "Although synchronization and probability selection are declaratively modeled, adapting the time units is not an easy task, since the value of a cell can only be changed in the following time unit. If we change the value of a cell in the context of an if process, we must be aware that the value will not be changed until two time units later."}, {"heading": "5.5 Related work", "text": "Although this is a remarkable model, we believe that ntcc can provide a simpler way to synchronize processes and to think about the accuracy of implementation, because it is obviously easier to synchronize them declaratively. Restrictions provide a much more powerful way to express declaratively complex synchronization patterns. As the ntcc model has a logical counterpart [24], it is possible to prove the characteristics of the model, for example, the fact that it always (or never or sometimes) chooses the longest context, or that repetitions of a particular partial sequence are avoided. Probabilistic Ccofmi [29] fixes the problems with synchronization and expands the idea of probabilistic choice in the improvisation phase, giving it a clear and concise manner."}, {"heading": "6 Implementation", "text": "It is. (It is.) It is. (It is.) It is. (It is.) It is. (It is.) It is. (It is.) It is. (It is.) It is. (It is.) It is. (It is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it is.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it.) It is. (it is. (it.) It is. (it.) It is. (it. (it.) It. (it is. (it.) It. (it. (it.) It. (it. (it.) It. (it. (it.) It. (it.) It. (it. (it.) It. (it. (it.) It. (it. (it.) It. (it.) It. (it. (it.) is. (it. (it.) It. It. (it. (it.) It. (it. (it.) is. (it. (it.) It. It. (it. (it.) It. (it. (it. (it.) It. It. It. (it.) It. (it. (it.) It. (it. (it.) It. (it.) It. It. (it. (it. (it.) It.) It. It. (it. It. It. (it. It. It. It.) It. (it is. It. It. It. It. (it. It. It. It. It. It. It. It. It is. It. It is. It. (it. It is.) is. It. It. It is. It is. It is. (it. It is. It. It is. It. It is. It."}, {"heading": "6.1.1 Developing mode", "text": "To write an Ntcc model in Ntccrt, the user can write it directly in C + +, use a parser that uses Common Lisp macros as input, or define a graphical \"patch\" in OpenMusic. With one of these representations, it is possible to create a standalone program or an external object (Fig. 11). To create an interface for OpenMusic, we first developed a Lisp parser that uses Common Lisp macros to write an Ntcc model in Lisp syntax and translate it into C + + code. Lisp macros extend Lisp syntax to give special meaning to characters that are reserved for this purpose. By executing these macros, an Ntcc program is automatically compiled. After success with Lisp macros, we have developed OpenMusic methods to represent Ntcc processes. Openmusic methods are a graphical representation of the Common Lisp System graphical object (CLP)."}, {"heading": "6.1.2 Execution mode", "text": "To execute an Ntccrt program, we can proceed in two different ways: We can create a standalone program that can interact with the Midishare library [12], or we can create an external object for either Pd or Max. One advantage of compiling an Ntcc model as an external object is that we use control signals and the message delivery provided by Pd and Max to synchronize any graphical object with the Ntccrt external.31 To handle MIDI streams (e.g. MIDI files, MIDI instruments, or MIDI streams from other programs), we use the predefined functions in Pd or Max to process MIDI. Then, we connect the output of these functions to the Ntccrt binary plugin. In this section, we also provide an interface for Midishare that is useful when executing standalone programs (Fig. 12).6.2 Implementing Ntccrt is the first interpreter in Ntccrt."}, {"heading": "6.2.1 Data structures", "text": "rteeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"}, {"heading": "6.2.2 Execution model", "text": "To run a simulation, users write an ntcc mdel to Ntccrt, unless the specified method is compiled, and then call the compiled program with the number of units to simulate and the parameters (if any) of the most important ntcc definition. For each unit of time i, the interpreter performs the following steps: First, it creates a new memory and new variables in memory, then it processes the input (e.g. MIDI data coming from PD or Max), and when it simulates the first unit of time i, it invokes the most important ntcc definition with the arguments specified by the user, then it moves the processes into the queue, unless it shifts the persistent assignment processes to the persistent assignment queue Metrt, and executes all remaining processes in the process queue, then it computes a fixed point."}, {"heading": "6.4 Summary", "text": "rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr lrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr"}, {"heading": "6.5 Related work", "text": "Lman was developed as a framework for programming RCX Lego Robots. It consists of three parts: an abstract machine, a compiler, and a visual language. We borrowed the idea from this interpreter to have multiple queues to store ntcc processes instead of using threads. Unfortunately, Lman only supports finite domain restrictions. NtccSim was used to simulate biological models [16]. It was developed in MozartOz [37]. It is able to work with finite domains (FD) and a constraint system to think about real numbers. We suspect (it is not proven) that using Mozart-Oz to write a ntcc interpreter is not as efficient as using Gecode based on the results obtained in the Gecode benchmarks, and a constraint system in which Gecode works better than Mozart-Oz in the constraint solution."}, {"heading": "7 Tests and Results", "text": "Since the creation of Lman, performance and correctness of the previous implementations of Ntccrt, we have tried to develop a generic implementation that could be used by an Ntccrt interpreter. Lman has been a great success in the history of Ntcc interaction systems. Although it goes beyond the scope of this research to assess whether these interpreters are faster than Ntccrt or whether they are able to interact in real time with a human player, we suspect that they are not suitable for real interaction to simulate hundreds of units of time in complex models such as Ccfomi, based on the results presented by their authorities. In this chapter, we will evaluate the performance of our Ntcc interpreter prototypes and also evaluate the behavior of Ntccrt. To achieve these goals, we conducted various tests on Ntccrt and on our previous implementations of Ntccrt."}, {"heading": "7.4 Summary", "text": "Ntccrt, our Ntcc interpreter based on encoding Ntcc processes as a gecode distributor, outperforms our thread and event-driven implementations of Ntcc. Because we learn and produce sequences with a response time of less than 30 milliseconds, we have a system that is fast enough to interact with a musician, according to the Continuator authors."}, {"heading": "7.5 Related work", "text": "The developers of Lman used a specification to play a MIDI pitch with a fixed duration per unit of time. [21] The tests were performed with a Pentium III 930 MHz, 256 MB Ram, Linux Debian Woody (3.0) and the Lego robot RCX 2.0 with BrickOS 2.6.1. They created a simulation with 100 units of time. This simple process takes an average of 281.25 ms to run each unit of time with Lman, unfortunately it is not suitable for real-time interaction in music, even if we would run it on modern computers. On the other hand, Rueda's interpreter Ccfomi executed on an Apple PowerBook G4 at 1.67 GHz using Digitols MCL version of Common Lisp, taking an average of 25 milliseconds per unit of time and scheduling about 20 simultaneous processes."}, {"heading": "8 Conclusions", "text": "In this chapter we present a summary of the thesis, some concluding remarks and suggest some future working ideas."}, {"heading": "8.1 Summary", "text": "Although this idea is very simple, the probabilities are calculated in constant time and space when the FO is built. We have succeeded in obtaining the linear complexity in time and space of the online construction algorithm of the FO. \u2022 Calculating the probability of being in a particular scale makes the model more suitable for certain music genres, but it requires the calculation of several constants that vary according to the genre of tonal music in which the user improvises. Therefore, it is discarded. \u2022 We explained how we can change the intensity of notes generated in improvisation, but it requires calculating several constants that vary according to the genre of tonal music in which the user improvises. We believe that this type of approach, in which simple variations can be made without changing the style learned by the user by billions."}, {"heading": "8.2 Concluding remarks", "text": "We show how to control a probable extension of Ccfomi using the factor Oracle. This extension has three main features. First, it preserves the linear time and space complexity of the online factor Oracle algorithm. The factor Oracle was chosen as the data structure to capture the user style in Ccfomi because of its linear complexity. Our extension would not be worth it if we had changed the complexity of the factor Oracle online construction algorithm to add probability information to the model, making it incompatible with real time. Second, we use pntcc (a probable extension of ntcc) for our model. The advantage of pntcc is that we do not have to model all processes in a new calculus, instead we use pntcc, where we use all agents defined in ntcc (except the * agents not used in this work) and a new agent for the selection of probabilities."}, {"heading": "8.3 Future work", "text": "For the future, we propose to expand our research in the following directions:"}, {"heading": "8.4 Extending our model", "text": "We propose to include new elements in the music sequences, for example taking into account the timbre of the music, pitch / amplitude variations (e.g. vibrato, bending over and accaccaccatura) and resonance effects (e.g. delay, reverb and choir)."}, {"heading": "8.5 Improvisation set-ups", "text": "It is a question of the extent to which it is a question of the way in which people are able to comply with the rules that they have applied in practice. (...) It is a question of the extent to which they have to comply with the rules. (...) It is a question of the extent to which they have to comply with the rules. (...) It is a question of the extent to which they have to comply with the rules. (...) It is a question of the extent to which they have to comply with the rules. (...) It is a question of the extent to which they have to comply with the rules. \"(...) It is a question of the extent to which they have to comply with the rules. (...) It is a question of the extent to which they have to comply with the rules.\" (...) It is a question of the extent to which they have to comply with the rules."}, {"heading": "Acknowledgements", "text": "Removed for double-blind verification."}, {"heading": "9 Appendix", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "9.1 Algorithms", "text": "In the following, we present four algorithms: the online algorithm Factor Oracle (FO), the FO algorithm that calculates the context, our first approach to extending the FO algorithm to include probabilistic choices, and an example of the current dynamic algorithm."}, {"heading": "9.1.1 Factor Oracle on-line algorithm", "text": "This is the online algorithm shown in [1] for building an FO. ADD LETTER (, \u03c3) Create a new state m + 1 Create a new transition from m to m + 1 labeled \u03c3 k, while k > \u2212 1 and there is no transition from k to \u03c3 do Create a new transition from k to m + 1 to \u03c3 k if K = = \u2212 1 then s 0 otherwise s where the transition from k to \u03c3 (m + 1) to Oracle () sORACLE-ON-LINE () leads Create Oracle (\u03b5) with a single state \u2212 1 for i 0 to m do Oracle () ADD-BRIEF (Oracle (),) Theorem 1 The complexity of Oracle-On-line is O (m) in time and space [1]."}, {"heading": "9.1.2 Factor Oracle on-line algorithm that calculates the context", "text": "The FO algorithm, which calculates the context while maintaining the linear complexity of time and space, comes from [19]. The algorithm for adding a new symbol to the FONewAddLetter (oracle (p [1.. i], \u03c3) 01 Creates a new state i + 1 02 \u03b4 (i, \u03c3) i + 1 03 j 04 i 05 while j > \u2212 1 and \u03b4 (j, \u03c3) is undefined do 06 \u03b4j, \u03c3 i + 1 07 j 08 j 09 if j = \u2212 1 then 10 s 0 11 else s \u03b4 (j, \u03c3) 12 s 13 lrs [i + 1] LengthReppeatedSuffix (14 return Oracle (p [1.. i], \u03c3) Find the length of the repeated suffix of p [i.. i + 1] LengthReppeatedSuffix () 01 if s = 0 then 02 return 0 03 return LengthCommon Suffix () + 1 Find the common suffix of p [i] then.. i.."}, {"heading": "9.1.3 Example of the current dynamics algorithm", "text": "This is an example of the execution of the current dynamic algorithm (Fig. 19) shown in Chapter 4 for the sequence D = [28,28,38,25,40,30].0.9 (a) 530.9 (b) 0.9 (c) 0.9 (d)."}, {"heading": "9.2 Our previous approaches for the model", "text": "In the following, we present our previous approaches to modelling probabilistic selection and modification of note attributes during improvisation; the probabilistic choice has been discarded because it is not compatible with real-time; on the other hand, the change in pitch and duration during improvisation has been discarded because it is not suitable for all music genres (e.g. music genres that are not based on note scales) and requires extensive training."}, {"heading": "9.2.1 Extension for probabilistic choice", "text": "The idea behind this extension is to change all values for the exit from state i when adding a new transition from state i. Furthermore, when choosing a transition during the improvisation phase, it is necessary to change the value for all transitions from state i. This poses a major problem, changing the value for all transitions from state i changes the complexity of the FO's online algorithm over time from linear to square. Therefore, this extension has been discarded.55"}, {"heading": "9.2.2 Adding a new transition to the FO", "text": "Let us take \u03b3 values in the range [0.. 1]. \u03b3 is a constant that regulates the priority for the new transitions added to the FO. Figure 20 shows the process of adding a new transition to FO.0.60.2."}, {"heading": "9.2.3 Choosing a transition during improvisation", "text": "Take \u03b2 values in the range [0.. 1] and be a constant that regulates the change of probabilities in the choice of a transition. The process of changing the probabilities in the choice of a transition is shown in Figure 21.0.657."}, {"heading": "9.2.4 Pitch variation", "text": "Based on this assumption, we create new pitches that belong to this scale. This has two problems. Firstly, it is necessary to calculate the scale on which the user is playing. Secondly, it is necessary to arrange the tones of the scale in order to give some notes of the scale a higher priority over others."}, {"heading": "9.2.5 Probability of being on a certain music scale", "text": "To know on which scale the improvisations learned by the user are located, we count the notes played by the user that are included in the scale. We look at five types of scales used in Western music [17]: Major, Minor, Pentatonic, Harmonic Major and Harmonic Minor. For each of these, there are 12 scales, the C, C #, D, D #, E, F, F #, G, G #, A, A #, B. Therefore, we look at 60 different scales. The goal is to find out on which of these 60 scales the user is playing. For example, the fragment of Happy Birthday (fig. 7) was analyzed in the 60 possible scales. We found that several scales have the same result as shown in Table 5. How can we distinguish between C major, C major harmonic and A minor? We have tried to multiply each degree of the scale by a factor."}, {"heading": "9.2.6 Duration variation", "text": "To preserve the learned style, we will replace a note with a sequence of notes that have already been played by the user and whose total duration corresponds to the duration of \u0394. For example, in the Happy Birthday fragment (B, 1000,60) we can replace a sequence that has already been played, such as [(G, 500,90), (C, 500,100)] [(G, 375,80), (G, 125,60), (A, 500,100)] [(A, 500,100), (G, 500,90)]. In this case, maintaining the original duration requires a library. 9.3 Our previous prototypes for the Ntcc interpreter Prior to the development of Ntccrt, we developed some combinations of programming languages (C + + and Common Lisp) and currency models, threads and event-driven programming. 9.3 The first problem we faced in designing the interpreter was the use of Common Gon Lisp, since it was developed on Lisp for OpenGon Music."}, {"heading": "9.3.1 Threaded interpreters in Lisp and C++", "text": "Using Gecol 2, we developed a prototype for the ntcc interpreter in Lispworks 5.0.1 Professional using Lispworks processes (based on pthreads) on Mac OS X. Similarly, we created another interpreter using C + +, Gecode, and Pthreads (for simultaneous control).59 In both thread prototypes, the tell agents are modeled as threads that add a restriction to memory, whose access is controlled by a lock. On the other hand, the processes wait until the memory is free, and ask if their state can be derived from memory. If they can derive its condition, they perform their continuation, otherwise they ask on (Fig. 22). The conditions for this when processes are represented by Boolean variables associated with exhausted propagators wait and ask if their state can be derived from memory. Fortunately, Gecode provides propagators for most of the restrictions used in propagators."}, {"heading": "9.3.2 Event-driven interpreter in Lisp", "text": "After discarding the threading model, we found a concurrency model that enabled us to perform better. However, we opted for event-driven programming for the implementation of the next prototype. This model is good for an ntcc interpreter, since we do not use synchronous I / O operations and all synchronization is done by the ask processes (when, and unless) using constraint entailment.The reader can make a comparison between the event-driven prototype and the thread prototype in Chapter 7.This prototype works in a very simple manner. There is an event queue for the ntcc processes, which are represented by events, and there is a dispatcher that handles the events. The When-events handler checks whether the boolean variable b, which represents its waiting state, is assigned. If it is not assigned, it adds the same event to the queue, otherwise it checks the value of the nnnn."}, {"heading": "9.4.1 The dining philosophers", "text": "Consider the problem of the food philosophers proposed by Edsger Dijkstra. It consists of n philosophers sitting on a round table and n chopsticks that are between each of them. Each philosopher thinks until he gets hungry. As soon as he gets hungry, he has to take control of the chopsticks to his immediate left and right to eat. When he has finished eating, he begins to think again. The aforementioned food philosopher problem has a few limitations. Philosophers cannot talk between them and demand that they eat both chopsticks. Moreover, a solution to this problem must not allow blockages, which could happen if all philosophers take one chopstick and wait forever for the other chopstick to be released. Moreover, it must not allow hunger, which could happen if one or more philosophers are unable to eat."}, {"heading": "9.4.2 Formal definition", "text": "Philosophers (i, n) when do next (tell () + tell ()) | when do when do next (tell () | tell () | tell () + (tell () | tell () | unless next (tell () | tell () | tell () | when do next ((tell () | tell ())) + (tell () | tell () | tell () | tell () | tell (i% 2 = 0 do tell (F = (i \u2212 1)% n) | tell (S = (i + 1)% n) | when i% 2 = 1 do tell (F = (i + 1)% n) | tell (S = (i \u2212 1)% n) | tell (i, n) | tell (i \u2212 1) the next philosopher (i \u2212 1) does not choose one of the philosophers waiting to control him when he is not controlled by a process."}, {"heading": "9.4.3 Implementation", "text": "Figure 24 shows a Pd program in which the philosophers are represented as pony (a graphical object design to send a message when the user clicks on it or when he receives a message from another object) and the parallel control is performed by an Ntccrt external. When the philosophers start eating, the Ntccrt external sends a message to the bang that changes color. Chopsticks are displayed as comments for simplicity."}, {"heading": "9.4.4 Signal processing", "text": "Ntcc has been used in the past as an audio processing framework [42]. In this paper, Valencia and Rueda represent how this modelling formalism gives a compact and precise definition of audio stream systems. They argued that it is possible to model an audio system and prove temporal properties using the temporal logic associated with ntcc. They suggested that any unit of time can be associated with processing the current sample of a sequential stream. Unfortunately, this is not possible in practice, as it takes 44,000 units of time per second to process a 44Khz audio stream. Furthermore, it raises problems finding a limitation system suitable for processing signals."}, {"heading": "9.4.5 Formal definition", "text": "IdleObject (j) when do next BusyObject (j) | unless next IdleObject (j) | when do tell BusyObject (j) when do IdleObject (j) | unless next BusyObject (j) A process i working on object j is represented by the following IdleProcess (i, j) A process is waiting when it can deduct (based on information from the store) that.IdleProcess (i, j) when do WaitProcess (i, j) | unless next IdleProcess (i, j) A process is waiting when the information for launch it can deduct from the store. If it can control the object, it goes into the busy status.WaitingProcess (i, j) when do BussyProcess (i, j) | unless next WaitingProcess (i, j) A process is busy until it can deduce (based on the process) that the process ecut works on the process associated object (BusyObject) (i)."}, {"heading": "9.4.6 Implementation", "text": "We present the graphical description of the processes IdleProcess, BusyProcess and WaitingProcess (see Fig. 25).650.1367Figure 25: Writing a synchronization Ntccrt externally in OpenMusic"}, {"heading": "9.4.7 Finding paths in a graph concurrently", "text": "In the following, we describe an application in which we use Ntccrt to find paths in a graph at the same time. The idea is to have an Ntccrt process for each edge. Each sends \"signals\" to its successors and \"signals\" back to its predecessors. If an animal receives a backward \"signal\" and a forward \"signal,\" it tells the memory that there is a path and adds it to the set j (a finite set variable containing the successors of the vertex i). After the propagation is over, we iterate the resulting sets to find different paths. So, for example, we can build a path in the graph that gets the lower limit of each variable."}, {"heading": "9.4.8 Formal definition", "text": "represents an edge in a diagram. when do (tell () | tell () | when do tell () | when do tell () The main process finds a path between the vertices a and b in a diagram represented by edges (a series of pairs (i, j) representing the edges of the diagram).The main process calls each (i, j) edge and simultaneously sends \"signals\" to processes with the shape and back \"signals\" to processes with the shape. Note that sending and receiving these \"signals\" is greatly simplified by using tell, ask and the ntcc storage.Main (edges, a, b) () | tell | tell"}, {"heading": "9.4.9 Example", "text": "To find a path between vertices Q 1 and 5, Q is a dynamic system. Q is a complex system. Q begins by sending \"signals\" to all processes with the form and back \"signals\" to all processes with the form. Once a return \"signal\" and a forward \"signal\" is received, it tells the memory that there is a way (i.e., say (). In addition, the reader may notice that there is no path between vertices 1 and 5 in Figure 27. In this example, reverse \"signals\" to processes are not received by any process. Therefore, neither receives a forward-looking signal back and a forward-looking signal. After calculating a fixed point, we can ask the constraint system for the value of the variable. As the variable is not limited, we can conclude that there is no path. 9,5 Operative semantics from cc and cc can be defined during the operational semantics."}, {"heading": "9.6 Tests with Ccfomi: In detail", "text": "Detailed information on the tests can be found at http: / / ntccrt.sourceforge.net /"}, {"heading": "9.7 Tests with the model to find paths in a graph:", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "In detail", "text": "Detailed information on the tests can be found at http: / / ntccrt.sourceforge.net /"}], "references": [{"title": "Factor oracle: A new structure for pattern matching", "author": ["Cyril Allauzen", "Maxime Crochemore", "Mathieu Raffinot"], "venue": "In Conference on Current Trends in Theory and Practice of Informatics,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1999}, {"title": "Concurrent constraint models for interactive scores", "author": ["Antoine Allomber", "G\u00e9rard Assayag", "M. Desainte-Catherine", "Camilo Rueda"], "venue": "In Proc. of the 3rd Sound and Music Computing Conference (SMC),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Modeling temporal constrains for a system of interactive score", "author": ["Antoine Allombert", "Myriam Desainte-Catherine", "Mauricio Toro"], "venue": "Constraint Programming in Music,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "An overview of FORCES: an INRIA project on declarative formalisms for emergent systems", "author": ["Jes\u00fas Aranda", "G\u00e9rard Assayag", "Carlos Olarte", "Jorge A. P\u00e9rez", "Camilo Rueda", "Mauricio Toro", "Frank D. Valencia"], "venue": "Logic Programming, 25th International Conference,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Navegating the oracle: A heuristic approach", "author": ["G\u00e9rard Assayag", "Georges Bloch"], "venue": "In International Computer Music Conference", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "Improvisation planning and jam session design using concepts of sequence variation and flow experience", "author": ["G\u00e8rard Assayag", "Shlomo Dubnov"], "venue": "In Sound and Music Computing", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "Interview about music improvisation (videorecording)", "author": ["Juan Manuel Collazos"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Multiple viewpoint systems for music prediction", "author": ["Darrell Conklin", "Ian H. Witten"], "venue": "Journal of New Music Research,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1995}, {"title": "Antescofo: Anticipatory synchronization and control of interactive parameters in computer music", "author": ["Arshia Cont"], "venue": "In Proceedings of International Computer Music Conference (ICMC). Belfast,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2008}, {"title": "A framework for anticipatory machine improvisation and style imitation", "author": ["Arshia Cont", "Shlomo Dubnov", "G\u00e9rard Assayag"], "venue": "In Anticipatory Behavior in Adaptive Learning Systems (ABiALS),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}, {"title": "Anticipatory model of musical style imitation using collaborative and competitive reinforcement learning", "author": ["Arshia Cont", "Shlomo Dubnov", "G.Assayag"], "venue": "Anticipatory Behavior in Adaptive Learning Systems,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Midishare: une architecture logicielle pour la musique, pages 175\u2013194", "author": ["S. Letz D. Fober", "Y. Orlarey"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2004}, {"title": "Reflections on the future of concurrency theory in general and process calculi in particular", "author": ["Hubert Garavel"], "venue": "Electron. Notes Theor. Comput. Sci.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "Using factor oracles for machine improvisation", "author": ["G.Assayag", "Sholomo Dubnov"], "venue": "Soft Comput.,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2004}, {"title": "Interfacing pure data with faust", "author": ["Albert Graef"], "venue": "In LAC, editor, 5th International Linux Audio Conference (LAC2007),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "Timed concurrent constraint programming for analyzing biological systems", "author": ["Julian Guti\u00e9rrez", "Jorge A. P\u00e9rez", "Camilo Rueda", "Frank D. Valencia"], "venue": "Electron. Notes Theor. Comput. Sci.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Introducci\u00f3n a la m\u00fasica", "author": ["Ott\u00f3 K\u00e1rolyi"], "venue": "Alianza Editorial Madrid,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1981}, {"title": "Modeling and Verification of Real-Time Systems: Formalisms and Software Tools, chapter Verification of Real-Time Probabilistic Systems, pages 249\u2013288", "author": ["M. Kwiatkowska", "G. Norman", "D. Parker", "J. Sproston"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "Computing repeated factors with a factor oracle", "author": ["A. Lefebvre", "T. Lecroq"], "venue": "Proceedings of the 11th Australasian Workshop On Combinatorial Algorithms,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2000}, {"title": "A declarative framework for security: Secure concurrent constraint programming", "author": ["Hugo A. L\u00f3pez", "Catuscia Palamidessi", "Jorge Andr\u00e9s P\u00e9rez", "Camilo Rueda", "Frank D. Valencia"], "venue": "In ICLP,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "Lman ntcc: Abstract machine for concurrent programming of lego robots. (in spanish)", "author": ["M.P. Mu\u00f1oz", "A.R. Hurtado"], "venue": "B.Sc. Thesis,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2004}, {"title": "Programming robot devices with a timed concurrent constraint programming", "author": ["Pilar Mu\u00f1oz", "Andr\u00e9s Hurtado"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2004}, {"title": "Temporal concurrent constraint programming: Denotation, logic and applications", "author": ["M. Nielsen", "C. Palamidessi", "F. Valencia"], "venue": "Nordic Journal of Computing,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2002}, {"title": "A stochastic non-deterministic temporal concurrent constraint calculus", "author": ["C. Olarte", "C. Rueda"], "venue": "sccc, 0:30\u201336,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2005}, {"title": "Concurrent Constraints Models of Music Interaction", "author": ["Carlos Olarte", "Camilo Rueda", "Gerardo Sarria", "Mauricio Toro", "Frank Valencia"], "venue": "Constraint Programming in Music,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2011}, {"title": "Syntactical and semantical aspects of faust", "author": ["Y. Orlarey", "D. Fober", "S. Letz"], "venue": "Soft Comput.,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2004}, {"title": "Playing with virtual musicians: the continuator in practice", "author": ["Fran\u00e7ois Pachet"], "venue": "IEEE Multimedia,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2002}, {"title": "Non-determinism and probabilities in timed concurrent constraint programming", "author": ["Jorge P\u00e9rez", "Camilo Rueda"], "venue": "Logic Programming, 24th Internatinoal Conference,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "Process Ordering in a Process Calculus for Spatially-Explicit Ecological Models", "author": ["Anna Philippou", "Mauricio Toro"], "venue": "In Proceedings of MOKMASD\u201913,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2013}, {"title": "Simulation and Verification for a Process Calculus for Spatially-Explicit Ecological Models", "author": ["Anna Philippou", "Mauricio Toro", "Margarita Antonaki"], "venue": "Scientific Annals of Computer Science,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2013}, {"title": "Pure data", "author": ["M. Puckette"], "venue": "In Proceedings of the International Computer Music Conference. San Francisco", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1996}, {"title": "Real-time audio analysis tools for Pd and MSP", "author": ["M. Puckette", "T. Apel", "D. Zicarelli"], "venue": "In Proceedings of the International Computer Music Conference.,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1998}, {"title": "Incremental algorithms for constraint solving and entailment over rational trees", "author": ["Viswanath Ramachandran", "Pascal Van Hentenryck"], "venue": "In Proceedings of the 13th Conference on Foundations of Software Technology and Theoretical Computer Science,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1993}, {"title": "Interview about music improvisation (videorecording)", "author": ["Alberto Riascos"], "venue": null, "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2007}, {"title": "Status report: Hot pickles, and how to serve them", "author": ["Andreas Rossberg", "Guido Tack", "Leif Kornstaedt"], "venue": "ACM SIGPLAN Workshop on ML,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "Multiparadigm Programming in Mozart/Oz", "author": ["Peter Van Roy", "editor"], "venue": "Second International Conference,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2004}, {"title": "On validity in modelization of musical problems by ccp", "author": ["C. Rueda", "F. Valencia"], "venue": "Soft Comput.,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2004}, {"title": "Research report 1", "author": ["Camilo Rueda"], "venue": "Technical Report 2006-1,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2006}, {"title": "A concurrent constraints factor oracle model for music improvisation", "author": ["Camilo Rueda", "G\u00e9rard Assayag", "Shlomo Dubnov"], "venue": "In XXXII Conferencia Latinoamericana de Informtica CLEI", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2006}, {"title": "Using stochastic ntcc to model biological systems", "author": ["Camilo Rueda", "Carlos Olarte"], "venue": "In CLEI 2005 (31st Latinoamerican Conference on Informatics),", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2005}, {"title": "A temporal concurrent constraint calculus as an audio processing framework", "author": ["Camilo Rueda", "Frank Valencia"], "venue": "In SMC", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2005}, {"title": "Formalizing timed musical processes with a temporal concurrent constraint programming calculus", "author": ["Camilo Rueda", "Frank D. Valencia"], "venue": "In Proc. of Musical Constraints Workshop CP2001,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2002}, {"title": "Concurrent Constraint Programming", "author": ["Vijay A. Saraswat"], "venue": null, "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1992}, {"title": "Formal Models of Timed Musical Processes", "author": ["Gerardo Sarria"], "venue": "PhD thesis, Universidad del Valle, Colombia,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2008}, {"title": "Programming deep concurrent constraint combinators", "author": ["Christian Schulte"], "venue": null, "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2000}, {"title": "Nondeterministic lisp as a substrate for constraint logic programming", "author": ["Jeffrey Mark Siskind", "David Allen McAllester"], "venue": "In Proceedings of the 11th National Conference on Artificial Intelligence,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 1993}, {"title": "Exploring the possibilities and limitations of concurrent programming for multimedia interaction and graphical representations to solve musical csp\u2019s", "author": ["Mauricio Toro"], "venue": "Technical Report 2008-3,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2008}, {"title": "Probabilistic Extension to the Factor Oracle Model for Music Improvisation", "author": ["Mauricio Toro"], "venue": "Master\u2019s thesis, Pontificia Universidad Javeriana Cali, Colombia,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2009}, {"title": "Towards a correct and efficient implementation of simulation and verification tools for probabilistic ntcc", "author": ["Mauricio Toro"], "venue": null, "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2009}, {"title": "Structured interactive musical scores", "author": ["Mauricio Toro"], "venue": "Technical Communications of the 26th International Conference on Logic Programming,", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2010}, {"title": "Structured Interactive Scores: From a simple structural description of a multimedia scenario to a real-time capable implementation with formal semantics", "author": ["Mauricio Toro"], "venue": "PhD thesis, Univeriste\u0301 de Bordeaux", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 2012}, {"title": "Structured interactive music", "author": ["Mauricio Toro"], "venue": "scores. CoRR,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2015}, {"title": "Ntccrt: A concurrent constraint framework for real-time interaction", "author": ["Mauricio Toro", "Carlos Ag\u00f3n", "G\u00e9rard Assayag", "Camilo Rueda"], "venue": "In Proc. of ICMC \u201909,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2009}, {"title": "Concurrent constraint conditional branching interactive scores", "author": ["Mauricio Toro", "Myriam Desainte-Catherine"], "venue": "In Proc. of SMC \u201910,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2010}, {"title": "A model for interactive scores with temporal constraints and conditional branching", "author": ["Mauricio Toro", "Myriam Desainte-Catherine", "P. Baltazar"], "venue": "In Proc. of Journe\u0301es d\u2019Informatique Musical (JIM)", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2010}, {"title": "An extension of interactive scores for multimedia scenarios with temporal relations for micro and macro controls", "author": ["Mauricio Toro", "Myriam Desainte-Catherine", "Julien Castet"], "venue": "In Proc. of Sound and Music Computing (SMC) \u201912,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2012}, {"title": "Formal semantics for interactive music scores: a framework to design, specify properties and execute interactive scenarios", "author": ["Mauricio Toro", "Myriam Desainte-Catherine", "Camilo Rueda"], "venue": "Journal of Mathematics and Music,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2014}, {"title": "Mean-field semantics for a Process Calculus for Spatially-Explicit Ecological Models", "author": ["Mauricio Toro", "Anna Philippou", "Sair Arboleda", "Carlos V\u00e9lez", "Mar\u00eda Puerta"], "venue": "Technical report, Department of Informatics and Systems, Universidad Eafit,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2015}, {"title": "Synchronous parallel composition in a process calculus for ecological models", "author": ["Mauricio Toro", "Anna Philippou", "Christina Kassara", "Spyros Sfenthourakis"], "venue": "Proceedings of the 11th International Colloquium on Theoretical Aspects of Computing", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 2014}, {"title": "Decidability of infinite-state timed ccp processes and first-order ltl", "author": ["Frank D. Valencia"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2005}], "referenceMentions": [{"referenceID": 12, "context": "Garavel explains in [13] that models based on process calculi are not widespread because there are many calculi and many variants for each calculus, being difficult to choose the most appropriate.", "startOffset": 20, "endOffset": 24}, {"referenceID": 36, "context": "[38],[40] explain that using the semantics and logic underlying the Non-deterministic Timed Concurrent Constraint (ntcc) [24] calculus, it is possible to prove properties of the ntcc models before executing them and execute the models on a ntcc interpreter.", "startOffset": 0, "endOffset": 4}, {"referenceID": 38, "context": "[38],[40] explain that using the semantics and logic underlying the Non-deterministic Timed Concurrent Constraint (ntcc) [24] calculus, it is possible to prove properties of the ntcc models before executing them and execute the models on a ntcc interpreter.", "startOffset": 5, "endOffset": 9}, {"referenceID": 22, "context": "[38],[40] explain that using the semantics and logic underlying the Non-deterministic Timed Concurrent Constraint (ntcc) [24] calculus, it is possible to prove properties of the ntcc models before executing them and execute the models on a ntcc interpreter.", "startOffset": 121, "endOffset": 125}, {"referenceID": 21, "context": ", arguing that although there are several interpreters for ntcc such as Lman [22] and Rueda\u2019s Interpreter [40], there is not a generic interpreter to run ntcc models in real-time.", "startOffset": 77, "endOffset": 81}, {"referenceID": 38, "context": ", arguing that although there are several interpreters for ntcc such as Lman [22] and Rueda\u2019s Interpreter [40], there is not a generic interpreter to run ntcc models in real-time.", "startOffset": 106, "endOffset": 110}, {"referenceID": 38, "context": "\u2019s argument, that models based on ntcc such as \u201cA Concurrent Constraints Factor Oracle model for Music Improvisation\u201d (Ccfomi) [40] are a good alternative to model multimedia interaction because synchronization is presented declaratively by means of variable sharing among concurrent agents reasoning about information contained in a global store.", "startOffset": 127, "endOffset": 131}, {"referenceID": 2, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 56, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 52, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 24, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 50, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 47, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 49, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 51, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 3, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 55, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 48, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 53, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 54, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 46, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 78, "endOffset": 132}, {"referenceID": 28, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 156, "endOffset": 172}, {"referenceID": 58, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 156, "endOffset": 172}, {"referenceID": 29, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 156, "endOffset": 172}, {"referenceID": 57, "context": "Process calculi has been applied to the modeling of interactive music systems [3, 58, 54, 26, 52, 49, 51, 53, 4, 57, 50, 55, 56, 48] and ecological systems [30, 60, 31, 59].", "startOffset": 156, "endOffset": 172}, {"referenceID": 33, "context": "However, spontaneous real-time variation in performance of tempo and dynamics within a classical performance may also be considered as improvisation [23] The reader may see an example of music improvisation in [35], where musician Alberto Riascos improvised in the Colombian music genre Guabina and explained us how he did it.", "startOffset": 210, "endOffset": 214}, {"referenceID": 38, "context": "In addition, to perform both phases concurrently, the system must be able to interact in real-time with human players [40].", "startOffset": 118, "endOffset": 122}, {"referenceID": 38, "context": "define Stylistic learning as the process of applying such methods to musical sequences in order to capture important musical features and organize these features into a model, and the Stylistic simulation as the process producing musical sequences stylistically consistent with the learned style [40].", "startOffset": 296, "endOffset": 300}, {"referenceID": 38, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 105, "endOffset": 109}, {"referenceID": 27, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 111, "endOffset": 115}, {"referenceID": 43, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 117, "endOffset": 121}, {"referenceID": 40, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 153, "endOffset": 157}, {"referenceID": 1, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 182, "endOffset": 185}, {"referenceID": 43, "context": "This formalism and its extensions have been used to model systems such as: musical improvisation systems [40], [29], [45], an audio processing framework [42], and interactive scores [2], [45].", "startOffset": 187, "endOffset": 191}, {"referenceID": 39, "context": "in other fields such as modeling molecular biology [41], analyzing biological systems [16], and security protocols [20] because these fields also include the study of complex interactions where we want to observe certain properties showing up and to model the answer of the system to them.", "startOffset": 51, "endOffset": 55}, {"referenceID": 15, "context": "in other fields such as modeling molecular biology [41], analyzing biological systems [16], and security protocols [20] because these fields also include the study of complex interactions where we want to observe certain properties showing up and to model the answer of the system to them.", "startOffset": 86, "endOffset": 90}, {"referenceID": 19, "context": "in other fields such as modeling molecular biology [41], analyzing biological systems [16], and security protocols [20] because these fields also include the study of complex interactions where we want to observe certain properties showing up and to model the answer of the system to them.", "startOffset": 115, "endOffset": 119}, {"referenceID": 27, "context": "To avoid a repetitive improvisation, we extend Ccfomi with the Probabilistic Nondeterministic Timed Concurrent Constraint (pntcc) calculus [29] to decrease the", "startOffset": 139, "endOffset": 143}, {"referenceID": 27, "context": "This idea is based on the Probabilistic Ccfomi model [29] developed by P\u00e9rez and Rueda.", "startOffset": 53, "endOffset": 57}, {"referenceID": 33, "context": "This idea is based on interviews with musicians Riascos [35] and Juan Manuel Collazos [7], where they", "startOffset": 56, "endOffset": 60}, {"referenceID": 6, "context": "This idea is based on interviews with musicians Riascos [35] and Juan Manuel Collazos [7], where they", "startOffset": 86, "endOffset": 89}, {"referenceID": 37, "context": "The original version of Gelisp was developed by Rueda for Common Lisp [39].", "startOffset": 70, "endOffset": 74}, {"referenceID": 46, "context": "A report including all the implementation details of Ntccrt, the graphical interface for Gelisp, Gecol 2, applications of Ntccrt, and our previous attempts to develop a real-time ntcc interpreter [48].", "startOffset": 196, "endOffset": 200}, {"referenceID": 42, "context": "Concurrent Constraint Programming (CCP [44]) is a model for concurrent systems.", "startOffset": 39, "endOffset": 43}, {"referenceID": 38, "context": "If the constraint cannot be deduced, this process blocks until there is enough information to deduce the constraint\u201d [40].", "startOffset": 117, "endOffset": 121}, {"referenceID": 42, "context": "relates tokens to tokens and Var is an infinite set of variables\u201d [44].", "startOffset": 66, "endOffset": 70}, {"referenceID": 41, "context": "Valencia and Rueda argue in [43] that the CCP model posses difficulties for modeling reactive systems where information on a given variable changes depending on the interactions of a system with its environment.", "startOffset": 28, "endOffset": 32}, {"referenceID": 22, "context": "found at [24].", "startOffset": 9, "endOffset": 13}, {"referenceID": 37, "context": "Gecode is based on Constraints as Propagation agents (CPA) according to [39].", "startOffset": 72, "endOffset": 76}, {"referenceID": 34, "context": "Gecode works on different operating systems and is currently being used as the constraint library for Alice[36] and soon it will be used in Mozart-Oz, therefore it will be maintained for a long time.", "startOffset": 107, "endOffset": 111}, {"referenceID": 0, "context": "The Factor Oracle (FO)[1] is a finite automaton that can be built in linear time and space, in an incremental fashion.", "startOffset": 22, "endOffset": 25}, {"referenceID": 0, "context": "The FO is built on-line and their authors proved that its algorithm has a linear complexity in time and space[1].", "startOffset": 109, "endOffset": 112}, {"referenceID": 0, "context": "Further formal definitions and the proof of FO complexity can be found in [1].", "startOffset": 74, "endOffset": 77}, {"referenceID": 13, "context": "1 Since the FO has a linear complexity in time and space, it was found in [14] that it is appropriate for machine improvisation.", "startOffset": 74, "endOffset": 78}, {"referenceID": 13, "context": "Therefore a tuple with pitch (the frecuency of the note), duration (the amount of time that the note is played), and intensity (the volume on which is the note is played) can be related to each arrow according to [14].", "startOffset": 213, "endOffset": 217}, {"referenceID": 38, "context": "Concurrent Constraint Factor Oracle Model for Music Improvisation (Ccfomi) is defined in [40].", "startOffset": 89, "endOffset": 93}, {"referenceID": 38, "context": "Following, we present a briefly explanation of the model taken from [40].", "startOffset": 68, "endOffset": 72}, {"referenceID": 32, "context": "Although it is not stated explicitly in Ccfomi, the variables and are modeled as infinite rational trees [34] with unary branching, allowing us to add elements to them, each time-unit.", "startOffset": 105, "endOffset": 109}, {"referenceID": 38, "context": "\u201cProcess adds (if needed) factor links labeled to state i from all states k reached from i\u22121 by suffix links, then computes , the suffix link from i\u201d [40].", "startOffset": 150, "endOffset": 154}, {"referenceID": 38, "context": "The PLAYER process non-deterministically chooses between playing a note now or postponing the decision to the next time-unit\u201d [40].", "startOffset": 126, "endOffset": 130}, {"referenceID": 38, "context": "The process starts from state k and stochastically, chooses according to probability q, whether to output the symbol or to follow a backward link \u201d[40].", "startOffset": 147, "endOffset": 151}, {"referenceID": 27, "context": "\u201d [29].", "startOffset": 2, "endOffset": 6}, {"referenceID": 23, "context": "The first attempt to extend ntcc to work with probabilities was the Stochastic Non-deterministic Timed Concurrent Constraint (sntcc [25]) calculus.", "startOffset": 132, "endOffset": 136}, {"referenceID": 27, "context": "\u201d [29].", "startOffset": 2, "endOffset": 6}, {"referenceID": 18, "context": "Further information about the context can be found at [19].", "startOffset": 54, "endOffset": 58}, {"referenceID": 18, "context": "To calculate the context, Lefebvre and Lecroq modified the FO construction algorithm, conserving its linear complexity in time and space [19].", "startOffset": 137, "endOffset": 141}, {"referenceID": 10, "context": "This approach has been successfully used by Cont, Assayag and Dubnov on their anticipatory improvisation model [11].", "startOffset": 111, "endOffset": 115}, {"referenceID": 5, "context": "For instance, in Omax [6] \u2013a model for music improvisation processing in real-time audio and video\u2013 this is called recombination and it is parametrized by a recombination factor.", "startOffset": 22, "endOffset": 25}, {"referenceID": 4, "context": "For Omax, Assayag and Blonch recently proposed a new way to traverse the oracle based on heuristics [5].", "startOffset": 100, "endOffset": 103}, {"referenceID": 7, "context": "According to Conklin [8], music-generation systems aim to create music based on some predefined rules and a corpus (i.", "startOffset": 21, "endOffset": 24}, {"referenceID": 13, "context": "Unfortunately, they use algorithms with high complexity in time and space, making them inappropriate for music interaction according to [14].", "startOffset": 136, "endOffset": 140}, {"referenceID": 33, "context": "The idea behind this intensity variation was originally proposed by musicians Riascos [35] and Collazos [7].", "startOffset": 86, "endOffset": 90}, {"referenceID": 6, "context": "The idea behind this intensity variation was originally proposed by musicians Riascos [35] and Collazos [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 5, "context": "To solve this problem of creating new notes and changing the attributes of the notes during the improvisation, the Omax model has a parameter called innovation rate, indicating the amount of new material desired [6].", "startOffset": 212, "endOffset": 215}, {"referenceID": 9, "context": "The anticipatory model developed by Cont et al [10] presents some results where the sequences produced in the improvisation have different pitches, compared to the original sequence.", "startOffset": 47, "endOffset": 51}, {"referenceID": 27, "context": "This model is an extension of the model presented in [29].", "startOffset": 53, "endOffset": 57}, {"referenceID": 22, "context": "Since the ntcc model has a logical counterpart [24], it is possible to prove properties of the", "startOffset": 47, "endOffset": 51}, {"referenceID": 27, "context": "Probabilistic Ccofmi [29] fixes the problems with synchronization and extends the notion of probabilistic choice in the improvisation phase, giving it a clear and concise semantic.", "startOffset": 21, "endOffset": 25}, {"referenceID": 21, "context": "Lman [22] by Hurtado and Mu\u00f1oz in 2003, NtccSim (http://avispa.", "startOffset": 5, "endOffset": 9}, {"referenceID": 30, "context": "In addition, we describe how we made an interface to OpenMusic and how we can generate binary plugins for data-flow programming languages: Pure Data (Pd) [32] or Max/Msp [33] where MIDI, audio, or video inputs/outputs can interact with a Ntccrt binary.", "startOffset": 154, "endOffset": 158}, {"referenceID": 31, "context": "In addition, we describe how we made an interface to OpenMusic and how we can generate binary plugins for data-flow programming languages: Pure Data (Pd) [32] or Max/Msp [33] where MIDI, audio, or video inputs/outputs can interact with a Ntccrt binary.", "startOffset": 170, "endOffset": 174}, {"referenceID": 46, "context": "A detailed description of Ntccrt, the generation of binary plugins, Pure Data, Max/Msp, and the previous Ntccrt prototypes can be found in a previous publication [48].", "startOffset": 162, "endOffset": 166}, {"referenceID": 11, "context": "We can create a stand-alone program that can interact with the Midishare library [12], or we can create an external object for either Pd or Max.", "startOffset": 81, "endOffset": 85}, {"referenceID": 44, "context": "The When propagator is based on the idea of the Parallel conditional combinator proposed by Schulte [46].", "startOffset": 100, "endOffset": 104}, {"referenceID": 59, "context": "Valencia proposed in [61] to develop model checking tools for ntcc.", "startOffset": 21, "endOffset": 25}, {"referenceID": 27, "context": "In addition, P\u00e9rez and Rueda proposed in [29] exploring the automatic generation of models for probabilistic model checker such as Prism [18].", "startOffset": 41, "endOffset": 45}, {"referenceID": 17, "context": "In addition, P\u00e9rez and Rueda proposed in [29] exploring the automatic generation of models for probabilistic model checker such as Prism [18].", "startOffset": 137, "endOffset": 141}, {"referenceID": 15, "context": "NtccSim was used to simulate biological models [16].", "startOffset": 47, "endOffset": 51}, {"referenceID": 35, "context": "It was developed in MozartOz [37].", "startOffset": 29, "endOffset": 33}, {"referenceID": 45, "context": "One drawback of this interpreter is the use of Screamer [47] to represent the constraint systems.", "startOffset": 56, "endOffset": 60}, {"referenceID": 8, "context": "5, as studied in [9].", "startOffset": 17, "endOffset": 20}, {"referenceID": 26, "context": "Pachet argues in [28] that an improvisation system able to learn and produce sequences in less than 30ms is appropriate for real-time interaction.", "startOffset": 17, "endOffset": 21}, {"referenceID": 20, "context": "Lman\u2019s developers ran a specification to play a MIDI pitch with a fixed duration each time-unit [21].", "startOffset": 96, "endOffset": 100}, {"referenceID": 5, "context": "Several concurrent improvisation situation set-ups have been proposed [6], [10], but none of them have been implemented for real-time music improvisation.", "startOffset": 70, "endOffset": 73}, {"referenceID": 9, "context": "Several concurrent improvisation situation set-ups have been proposed [6], [10], but none of them have been implemented for real-time music improvisation.", "startOffset": 75, "endOffset": 79}, {"referenceID": 38, "context": "in [40] propose the following set-ups: n performers and n oracles learning and performing; one performer, one oracle learning, and several improvisation processes running concurrently in the same oracle; one performer and several oracles learning from different viewpoints of the same performance.", "startOffset": 3, "endOffset": 7}, {"referenceID": 43, "context": "[45] calculus.", "startOffset": 0, "endOffset": 4}, {"referenceID": 43, "context": "Sarria proposed in [45] developing an interpreter for rtcc.", "startOffset": 19, "endOffset": 23}], "year": 2016, "abstractText": "We can program a Real-Time (RT) music improvisation system in C++ without a formal semantic or we can model it with process calculi such as the Non-deterministic Timed Concurrent Constraint (ntcc) calculus. \u201cA Concurrent Constraints Factor Oracle (FO) model for Music Improvisation\u201d (Ccfomi) is an improvisation model specified on ntcc. Since Ccfomi improvises non-deterministically, there is no control on choices and therefore little control over the sequence variation during the improvisation. To avoid this, we extended Ccfomi using the Probabilistic Non-deterministic Timed Concurrent Constraint calculus. Our extension to Ccfomi does not change the time and space complexity of building the FO, thus making our extension compatible with RT. However, there was not a ntcc interpreter capable of RT to execute Ccfomi. We developed Ntccrt \u2013a RT capable interpreter for ntcc\u2013 and we executed Ccfomi on Ntccrt. In the future, we plan to extend Ntccrt to execute our extension to Ccfomi.", "creator": "Writer"}}}