{"id": "1602.04498", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2016", "title": "Extending Consequence-Based Reasoning to SRIQ", "abstract": "Consequence-based calculi are a family of reasoning algorithms for description logics (DLs), and they combine hypertableau and resolution in a way that often achieves excellent performance in practice. Up to now, however, they were proposed for either Horn DLs (which do not support disjunction), or for DLs without counting quantifiers. In this paper we present a novel consequence-based calculus for SRIQ---a rich DL that supports both features. This extension is non-trivial since the intermediate consequences that need to be derived during reasoning cannot be captured using DLs themselves. The results of our preliminary performance evaluation suggest the feasibility of our approach in practice.", "histories": [["v1", "Sun, 14 Feb 2016 19:56:18 GMT  (102kb,D)", "https://arxiv.org/abs/1602.04498v1", null], ["v2", "Mon, 22 Feb 2016 16:04:55 GMT  (103kb,D)", "http://arxiv.org/abs/1602.04498v2", null], ["v3", "Tue, 23 Feb 2016 21:17:27 GMT  (103kb,D)", "http://arxiv.org/abs/1602.04498v3", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["andrew bate", "boris motik", "bernardo cuenca grau", "franti\\v{s}ek siman\\v{c}\\'ik", "ian horrocks"], "accepted": false, "id": "1602.04498"}, "pdf": {"name": "1602.04498.pdf", "metadata": {"source": "META", "title": "Extending Consequence-Based Reasoning to SRIQ", "authors": ["Andrew Bate", "Boris Motik", "Bernardo Cuenca Grau", "Franti\u0161ek Siman\u010d\u0131\u0301k", "Ian Horrocks"], "emails": ["firstname.lastname@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "1 Introduction Description Logic (DLs) (Baader et al. 2003) are a family of knowledge representation formalisms with numerous applications in practice. DL-based application models model a domain of interest using an ontology in which key terms in the domain are described with concepts (i.e., unary predicates), and the relationships between concepts are described using roles (i.e., binary predicates). Subsumption is the problem of determining whether each instance of a concept C is also an instance of a konzeptD in all models of an ontology, and it is a fundamental argument problem in applications of DLs. Expressive DLs, this problem is of high worst-case complexity ranging from EXPTIME to N2EXPTIME. Despite this discouraging complexity, highly optimized argumentators such as FaCT + (Tsarkov and Horrocks) 2006, Pellet (Sirlet 2007)."}, {"heading": "3.1 Why Consequence-Based Calculi?", "text": "Consider the EL ontology O1 in Figure 1; one can easily verify that O | = Bi (x) \u2192 Ci (x) for 0 \u2264 i \u2264 n. To prove O | = B0 (x) \u2192 C0 (x) using the (hyper) tableau calculation, we start with B0 (a) and apply (1) - (4) in predictive concatenation. Since O (1) contains for j (1, 2), this constructs a treelike depth model n and a fanout of two, where nodes are labeled at the depth i of Bi and Ci. The predictive concatenation ensures that the reasoning is goal-oriented; however, all nodes labeled with Bi are and they have the same properties, revealing a weakness of the (hyper) tableau calculation: the constructed models can be large (exponentially in our example) and highly redundant; besides that we can prevent them from being universally (by) causing problems in practice."}, {"heading": "3.2 Basic Notions", "text": "In fact, most of them are able to play by the rules that they have given themselves, and they are able to play by the rules that they have set themselves."}, {"heading": "4.1 Definitions", "text": "Definition 1. Definition 1. Definition 1. Definition 1. Definition 2. Definition 2. Definition 3. Definition 3. Definition 3. Definition 3. Definition 3. Definition 3. Definition 3. Definition 4. Definition 4. Definition 4. Definition 4. Definition 4. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5. Definition 5."}, {"heading": "4.2 An Outline of the Completeness Proof", "text": "\"To prove that we can establish an equality between equality and equality, we must demonstrate the principles of equality in one step.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We.\" - \"We. -\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" We. \"-\" - \"We.\" - \"-\" We. \"-\" - \"We.\" - \"-\" - \"We.\" - \"-\" - \"We.\" - \"-\" - \"We.\" - \"-\" - \"-\" We. \"-\" - \"-\" - \"-\" We. \"-\" - \"-\" - \"-\" - \"We.\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" We. \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\" - \"-\""}, {"heading": "C.1 Constructing a Model Fragment", "text": "In this section, we will show how to use a term t to generate a part of the model of O, which is the neighborhood of t. In the rest of the appendix C.1, we specify the following parameters for the process of model fragment generation: \u2022 t is an F-term, \u2022 v is a context in D, \u2022 t is a compound of atoms, and \u2022 t is a separation of atoms. Let Nt be the set of earth clauses obtained from Sv as follows: Nt = [t]."}, {"heading": "C.1.1 Grounding the Context Order", "text": "To construct Rt, we need an order on terms in the neighbourhood of v. For this purpose > a total, strict order of simplification on the basic concepts constructed using the F-neighbourhood of t and predicate symbols in P, which fulfils the following conditions for all context concepts s1 and s2 so that s1\u03c3t and s2\u03c3t are both basic concepts, and where the predecessor of t exists, O1 v s2 implies s1\u03c3t > s2\u03c3t and s1\u03c3t > s2\u03c3t and s2\u03c3t are the precursor of t. O1 v s2\u03c3t > s2\u03c3t and s2\u03c3t are the precursor of t, if it exists. O1 v s1\u03c3t > s1\u03c3n and s1\u03c3n > s2\u03c3n and s2\u03c3n > s2\u03c3n 6 Prospective Prospective Prospective Prospective Prospective Prospective Prospective Prospective Prospective Prospective Prospective Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect Prospect)"}, {"heading": "C.1.2 Constructing the Rewrite System Rt", "text": "We order all clauses in Nt = \u21d2 Rit with 1,.., Cn. Since the body of each Ci is a subset of what Li > t can contain, literally Li in his head, which would contradict condition L1; therefore, we can assume that each Ci is in the form Ci = \u0445i \u2192 ichLi, where Li > t, literally Li in the form Li = li. / ri with. / ich. i < ich. n is. For the rest of Annex C.1, we reserve Ci, ich. i, \u0441i, Li, li and ri because we refer to the (parts) of the clauses in this condition. Finally, we assume that we have such a clause in Annex C.1 for all 1 \u2264 i < ich. n."}, {"heading": "C.1.3 The Properties of the Model Fragment Rt", "text": "To show that Rt = > # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "C.2.1 Unfolding the Context Structure", "text": "We construct R by a partial induction over the terms in T. We define several partial functions: function X places a term t in a context Xt. (functions V; functions V; functions V; functions V; functions V; functions V; functions V; functions V; functions V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms V; terms N; terms N N; terms V; terms V; terms V; terms V; terms N N N; terms V; terms V; terms V; terms V; terms V; terms V; terms N N; terms V; terms V; terms V; terms V; terms N terms V; terms V; terms V; terms N terms V; terms V; V terms V terms; V terms; V terms; V terms V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; and V terms; V terms; V terms; V terms; V terms; V terms; V terms; V terms; terms; V terms; V terms; V terms; V terms; terms; V terms; V terms; V terms; V terms; V terms; terms; V terms; terms; V terms; V terms; terms; V terms; terms; terms; V terms; terms; V terms; terms; V terms; terms; terms; V terms; terms; terms; V terms V terms; terms; terms; terms; V terms; terms V terms; terms; terms; terms V; terms; terms; terms V; terms; terms; terms V terms; terms V; terms; terms; terms V; terms; terms; terms V; terms; terms; terms V; terms; terms; terms V; terms; terms; terms V; terms; terms; terms; terms; terms"}, {"heading": "C.2.2 Termination, Confluence, and Compatibility", "text": "Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-Z-"}, {"heading": "C.2.3 The Completeness Claim", "text": "For each DL clause, we have an R clause in which each soil term is replaced by its normal form. Since R clause is a congruence, we have R clause in which there is an arbitrary replacement if and only if R clause exists, if and only if R clause exists. Next, we assume that R clause is replaced by its normal form. Since R clause is a congruence, we have R clause in which we have R clause if and only if R clause exists. We assume that R clause is not replaced by its normal form. Since R clause is a congruence, we have R clause if and only if and only if R clause exists. The definition of DL clauses, Ai clause is of the form B x clause, S clause."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Consequence-based calculi are a family of reasoning algorithms for description logics (DLs), and they combine hypertableau and resolution in a way that often achieves excellent performance in practice. Up to now, however, they were proposed for either Horn DLs (which do not support disjunction), or for DLs without counting quantifiers. In this paper we present a novel consequence-based calculus for SRIQ\u2014 a rich DL that supports both features. This extension is nontrivial since the intermediate consequences that need to be derived during reasoning cannot be captured using DLs themselves. The results of our preliminary performance evaluation suggest the feasibility of our approach in practice.", "creator": "TeX"}}}