{"id": "1602.06797", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Feb-2016", "title": "Semi-supervised Clustering for Short Text via Deep Representation Learning", "abstract": "In this work, we propose a semi-supervised method for short text clustering, where we represent texts as distributed vectors with neural networks, and use a small amount of labeled data to specify our intention for clustering. We design a novel objective to combine the representation learning process and the k-means clustering process together, and optimize the objective with both labeled data and unlabeled data iteratively until convergence through three steps: (1) assign each short text to its nearest centroid based on its representation from the current neural networks; (2) re-estimate the cluster centroids based on cluster assignments from step (1); (3) update neural networks according to the objective by keeping centroids and cluster assignments fixed. Experimental results on four datasets show that our method works significantly better than several other text clustering methods.", "histories": [["v1", "Mon, 22 Feb 2016 14:55:26 GMT  (689kb,D)", "http://arxiv.org/abs/1602.06797v1", null], ["v2", "Fri, 14 Jul 2017 19:52:33 GMT  (689kb,D)", "http://arxiv.org/abs/1602.06797v2", "In Proceedings of CoNLL 2016"]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["zhiguo wang", "haitao mi", "abraham ittycheriah"], "accepted": false, "id": "1602.06797"}, "pdf": {"name": "1602.06797.pdf", "metadata": {"source": "CRF", "title": "Semi-supervised Clustering for Short Text via Deep Representation Learning", "authors": ["Zhiguo Wang"], "emails": ["abei}@us.ibm.com"], "sections": [{"heading": null, "text": "Their task is to group similar texts into a cluster so that the texts in other clusters are more similar than the texts in other clusters. Normally, a text is called a sack-of-words or term-frequency-inverse document frequency (TFIDF) vector (TFIDF) vector (TFIDF) vector (TFIDF) vector (TFIDF) vector (TFIDF) algorithm (MacQueen, 1967), a set of texts is divided into homogeneous groups. However, when it comes to short texts, the characteristics of short texts and clustering tasks pose several problems for the conventional, unverified clustering algorithms. First, the number of unique words in each short text is small; as a result, lexical thrift usually leads to poor cluster quality (Dhillon and Guan, 2003). Second, for a specific short-text clustering task we have prior knowledge of, or some intensive classes."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "In this work, we propose a semi-supervised method for short text clustering, where we represent texts as distributed vectors with neural networks, and use a small amount of labeled data to specify our intention for clustering. We design a novel objective to combine the representation learning process and the kmeans clustering process together, and optimize the objective with both labeled data and unlabeled data iteratively until convergence through three steps: (1) assign each short text to its nearest centroid based on its representation from the current neural networks; (2) reestimate the cluster centroids based on cluster assignments from step (1); (3) update neural networks according to the objective by keeping centroids and cluster assignments fixed. Experimental results on four datasets show that our method works significantly better than several other text clustering methods. 1 Introduction Text clustering is a fundamental problem in text mining and information retrieval. Its task is to group similar texts together such that texts within a cluster are more similar to texts in other clusters. Usually, a text is represented as a bag-of-words or term frequency-inverse document frequency (TFIDF) vector, and then the k-means algorithm (MacQueen, 1967) is performed to partition a set of texts into homogeneous groups. However, when dealing with short texts, the characteristics of short text and clustering task raise several issues for the conventional unsupervised clustering algorithms. First, the number of uniqe words (a) What\u2019s the color of apples? (b) When will this apple be ripe? (c) Do you like apples? (d) What\u2019s the color of oranges? (e) When will this orange be ripe? (f) Do you like oranges? Table 1: Examples for short text clustering. in each short text is small, as a result, the lexcical sparsity issue usually leads to poor clustering quality (Dhillon and Guan, 2003). Second, for a specific short text clustering task, we have prior knowledge or paticular intenstions before clustering, while fully unsupervised approaches may learn some classes the other way around. Take the sentences in Table 1 for example, those sentences can be clustered into different partitions based on different intentions: apple {a, b, c} and orange {d, e, f} with a fruit type intension, or what-question {a, d}, when-question {b, e}, and yes/no-question cluster {c, f} with a question type intension. To address the lexical sparity issue, one direction is to enrich text representations by extracting features and relations from Wikipedia (Banerjee et al., 2007) or an ontology (Fodeh et al., 2011). But this approach requires the annotated knowlege, which is also language dependent. So the other direction, which directly encode texts into distributed vectors with neural networks (Hinton and Salakhutdinov, 2006; Xu et al., 2015), becomes more interesing. To tackle the second problem, semi-supervised approaches (e.g. (Bilenko et al., 2004; Davidson and Basu, 2007; Bair, 2013)) have gained significant popularity in the past decades. Our question is can ar X iv :1 60 2. 06 79 7v 1 [ cs .C L ] 2 2 Fe b 20 16 we have a unified model to integrate netural networks into the semi-supervied framework? In this paper, we propose a unified framework for the short text clustering task. We employ a deep neural network model to represent short sentences, and integrate it into a semi-supervised algorithm. Concretely, we extend the objective in the classical unsupervised k-means algorithm by adding a penalty term from labeled data. Thus, the new objective covers three key groups of parameters: centroids of clusters, the cluster assignment for each text, and the parameters within deep neural networks. In the training procedure, we start from random initialization of centroids and neural networks, and then optimize the objective iteratively through three steps until converge: (1) assign each short text to its nearest centroid based on its representation from the current neural networks; (2) re-estimate cluster centroids based on cluster assignments from step (1); (3) update neural networks according to the objective by keeping centroids and cluster assignments fixed. Experimental results on four different datasets show that our method achieves significant improvements over several other text clustering methods. In following parts, we first describe our neural network models for text representaion (Section 2). Then we introduce our semi-supervised clustering method and the learning algorithm (Section 3). Finally, we evaluate our method on four different datasets (Section 4). 2 Representation Learning for Short Texts We represent each word with a dense vector w, so that a short text s is first represented as a matrix S = [w1, ..., w|s|], which is a concatenation of all vectors of w in s, |s| is the length of s. Then we design two different types of neural networks to ingest the word vector sequence S: the convolutional neural networks (CNN) and the long short-term memory (LSTM). More formally, we define the presentation function as x = f(s), where x is the represent vector ...\t\r  ... ...\t\r  ... convolution operation max-pooling operation fully connected layer Figure 1: CNN for text representation learning. of the text s. We test two encoding functions (CNN and LSTM) in our experiments. Inspired from Kim (2014), our CNN model views the sequence of word vectors as a matrix, and applies two sequential operations: convolution and maxpooling. Then, a fully connected layer is employed to convert the final representation vector into a fixed size. Figure 1 gives the diagram of the CNN model. In the convolution operation, we define a list of filters {wo}, where the shape of each filter is d \u00d7 h, d is the dimension of word vectors and h is the window size. Each filter is applied to a patch (a window size h of vectors) of S, and generates a feature. We apply this filter to all possible patches in S, and produce a series of features. The number of features depends on the shape of the filter wo and the length of the input short text. To deal with variable feature size, we perform a max-pooling operation over all the features to select the maximum value. Therefore, after the two operations, each filter generates only one feature. We define several filters by varying the window size and the initial values. Thus, a vector of features is captured after the max-pooling operation, and the feature dimension is equal to the number of filters. Figure 2 gives the diagram of our LSTM model. We implement the standard LSTM block described in Graves (2012). Each word vector is fed into the LSTM LSTM LSTM ...... w1 w2 wn Mean Figure 2: LSTM for text representation learning. LSTM model sequentially, and the mean of the hidden states over the entire sentence is taken as the final representation vector. 3 Semi-supervised Clustering for Short Texts 3.1 Revisiting K-means Clustering Given a set of texts {s1, s2, ..., sN}, we represent them as a set of data points {x1, x2, ..., xN}, where xi can be a bag-of-words or TF-IDF vector in traditional approaches, or a dense vector in Section 2. The task of text clustering is to partition the data set into some numberK of clusters, such that the sum of the squared distance of each data point to its closest cluster centroid is minimized. For each data point xn, we define a set of binary variables rnk \u2208 {0, 1}, where k \u2208 {1, ...,K} describing which of the K clusters xn is assigned to. So that if xn is assigned to cluster k, then rnk = 1, and rnj = 0 for j 6= k. Let\u2019s define \u03bck as the centroid of the k-th cluster. We can then formulate the objective function as Junsup = N \u2211 n=1 K \u2211 k=1 rnk\u2016xn \u2212 \u03bck\u2016 (1) Our goal is the find the values of {rnk} and {\u03bck} so as to minimize Junsup. The k-means algorithm optimizes Junsup through the gradient descent approach, and results in an iterative procedure (Bishop, 2006). Each iteration involves two steps: E-step and M-step. In the Estep, the algorithm minimizes Junsup with respect to {rnk} by keeping {\u03bck} fixed. Junsup is a linear function for {rnk}, so we can optimize for each data point separately by simply assigning the n-th data point to the closest cluster centroid. In the M-step, the algorithm minimizes Junsup with respect to {\u03bck} by keeping {rnk} fixed. Junsup is a quadratic function of {\u03bck}, and it can be minimized by setting its derivative with respect to {\u03bck} to zero. \u2202Junsup \u2202\u03bck = 2 N \u2211 n=1 rnk(xn \u2212 \u03bck) = 0 (2) Then, we can easily solve {\u03bck} as \u03bck = \u2211N n=1 rnkxn \u2211N n=1 rnk (3) In other words, \u03bck is equal to the mean of all the data points assigned to cluster k. 3.2 Semi-supervised K-means with Neural Networks The classical k-means algorithm only uses unlabeled data, and solves the clustering problem under the unsupervised learning framework. As already mentioned, the clustering results may not be consistent to our intention. In order to acquire useful clustering results, some supervised information should be introduced into the learning procedure. To this end, we employ a small amount of labeled data to guide the clustering process. Following Section 2, we represent each text s as a dense vector x via neural networks f(s). Instead of training the text representation model separately, we integrate the training process into the k-means algorithm, so that both the labeled data and the unlabeled data can be used for representation learning and text clustering. Let us denote the labeled data set as {(s1, y1), (s2, y2), ..., (sL, yL)}, and the unlabeled data set as {sL+1, sL+2, ..., sN}, where yi is the given label for si. We then define the objective function as: Jsemi = \u03b1<lb>N<lb>\u2211<lb>n=1<lb>K<lb>\u2211<lb>k=1<lb>rnk\u2016f(sn)\u2212 \u03bck\u2016<lb>+ (1\u2212 \u03b1)<lb>L<lb>\u2211<lb>n=1<lb>{\u2016f(sn)\u2212<lb>\u03bcgn\u2016+<lb>\u2211<lb>j<lb>6=gn<lb>[l +<lb>\u2016f(sn)\u2212<lb>\u03bcgn\u2016 \u2212 \u2016f(sn)\u2212 \u03bcj\u2016]+}<lb>(4) 1. Initialize<lb>{\u03bck} and f(\u00b7).<lb>2. assign cluster: Assign each text to its nearest cluster centroid.<lb>3. estimate centroid: Estimate the cluster centroids based on the cluster assignments from step 2.<lb>4. update parameter: Update parameters in neural networks.<lb>5. Repeat step 2 to 4 until convergence.<lb>Table 2: Pseudocode for semi-supervised clustering<lb>The objective function contains two terms. The first<lb>term is adapted from the unsupervised k-means al-<lb>gorithm in Eq. (1), and the second term is defined<lb>to encourage labeled data being clustered in correla-<lb>tion with the given labels. \u03b1 \u2208 [0, 1] is used to tune<lb>the importance of unlabeled data. The second term<lb>contains two parts. The first part penalizes large dis-<lb>tance between each labeled instance and its correct<lb>cluster centroid, where gn = G(yn) is the cluster<lb>ID mapped from the given label yn, and the map-<lb>ping function G(\u00b7) is implemented with the Hun-<lb>garian algorithm (Munkres, 1957). The second part<lb>is denoted as a hinge loss with a margin l, where<lb>[x]+ = max(x, 0). This part incurs some loss if the<lb>distance to the correct centroid is not shorter (by the<lb>margin l) than distances to any of incorrect cluster<lb>centroids.<lb>There are three groups of parameters in Jsemi: the<lb>cluster assignment of each text<lb>{rnk}, the cluster<lb>centroids<lb>{\u03bck}, and the parameters within the neural<lb>network model f(\u00b7). Our goal is the find the values<lb>of<lb>{rnk}, {\u03bck} and parameters in f(\u00b7), so as to min-<lb>imize Jsemi. Inspired from the k-means algorithm,<lb>we design an algorithm to successively minimize<lb>Jsemi with respect to<lb>{rnk}, {\u03bck}, and parameters in<lb>f(\u00b7). Table 2 gives the corresponding pseudocode.<lb>First, we initialize the cluster centroids<lb>{\u03bck} with<lb>the k-means++ strategy (Arthur and Vassilvitskii,<lb>2007), and randomly initialize all the parameters in<lb>the neural network model. Then, the algorithm iter-<lb>atively goes through three steps (assign cluster, es-<lb>timate centroid, and update parameter) until Jsemi<lb>converges.<lb>The assign cluster step minimizes Jsemi with re-<lb>spect to<lb>{rnk} by keeping f(\u00b7) and<lb>{\u03bck} fixed. Its<lb>goal is to assign a cluster ID for each data point. We<lb>can see that the second term in Eq. (4) has no rela-<lb>tion with<lb>{rnk}. Thus, we only need to minimize the<lb>first term by assigning each text to its nearest clus-<lb>ter centroid, which is identical to the E-step in the<lb>k-means algorithm. In this step, we also calculate<lb>the mappings between the given labels<lb>{yi} and the<lb>cluster IDs (with the Hungarian algorithm) based on<lb>cluster assignments of all labeled data.<lb>The estimate centroid step minimizes Jsemi with<lb>respect to<lb>{\u03bck} by keeping<lb>{rnk} and f(\u00b7) fixed,<lb>which corresponds to the M-step in the k-means al-<lb>gorithm. It aims to estimate the cluster centroids<lb>{\u03bck} based on the cluster assignments<lb>{rnk} from<lb>the assign cluster step. The second term in Eq.<lb>(4) makes each labeled instance involved in the es-<lb>timating process of cluster centroids. By solving<lb>\u2202Jsemi/\u2202\u03bck = 0, we get<lb>\u03bck =<lb>\u2211N<lb>n=1 \u03b1rnkf(sn) + \u2211L<lb>n=1wnkf(sn)<lb>\u2211N<lb>n=1 \u03b1rnk + \u2211L<lb>n=1wnk<lb>(5)<lb>wnk = (1\u2212 \u03b1)(I<lb>\u2032<lb>nk +<lb>\u2211<lb>j<lb>6=gn<lb>I<lb>\u2032\u2032<lb>nkj \u2212<lb>\u2211<lb>j<lb>6=gn<lb>I<lb>\u2032\u2032\u2032<lb>nkj)<lb>I<lb>\u2032<lb>nk = \u03b4(k, gn)<lb>I<lb>\u2032\u2032<lb>nkj = \u03b4(k, j) \u00b7 \u03b4<lb>\u2032<lb>nj<lb>I<lb>\u2032\u2032\u2032<lb>nkj = (1\u2212 \u03b4(k, j)) \u00b7 \u03b4<lb>\u2032<lb>nj<lb>\u03b4<lb>\u2032<lb>nj = \u03b4(l +<lb>\u2016f(sn)\u2212<lb>\u03bcgn\u2016 \u2212 \u2016f(sn)\u2212 \u03bcj\u2016 > 0)<lb>(6)<lb>where \u03b4(x1, x2)=1 if x1 is equal to x2, otherwise<lb>\u03b4(x1, x2)=0, and \u03b4(x)=1 if x is true, otherwise<lb>\u03b4(x)=0. The first term in the numerator of Eq. (5)<lb>is the contributions from all data points, and \u03b1rnk is<lb>the weight of sn for \u03bck. The second term is acquired<lb>from labeled data, and wnk is the weight of a labeled<lb>instance sn for \u03bck.<lb>The update parameter step minimizes Jsemi with<lb>respect to f(\u00b7) by keeping<lb>{rnk} and<lb>{\u03bck} fixed,<lb>which has no counterpart in the k-means algorithm.<lb>The main goal is to update parameters for the text<lb>representation model. We take Jsemi as the loss<lb>function, and train neural networks with the Adam<lb>algorithm (Kingma and Ba, 2014). dataset<lb>class# total# labeled#<lb>question type 6 5,953 595<lb>ag news<lb>4 4,000 400<lb>dbpedia<lb>14 14,000 1,400<lb>yahoo answer 10 10,000 1,000<lb>Table 3: Statistics for the short text datasets<lb>4 Experiment<lb>4.1 Experimental Setting<lb>We evaluate our method on four short text datasets.<lb>(1) question type is the TREC question dataset (Li<lb>and Roth, 2002), where all the questions are clas-<lb>sified into 6 categories: abbreviation, description,<lb>entity, human, location and numeric. (2) ag news<lb>dataset contains short texts extracted from the AG\u2019s<lb>news corpus, where all the texts are classified into<lb>4 categories: World, Sports, Business, and Sci/Tech<lb>(Zhang and LeCun, 2015). (3) dbpedia is the DBpe-<lb>dia ontology dataset, which is constructed by pick-<lb>ing 14 non-overlapping classes from DBpedia 2014<lb>(Lehmann et al., 2014). (4) yahoo answer is the<lb>10 topics classification dataset extracted from Ya-<lb>hoo! Answers Comprehensive Questions and An-<lb>swers version 1.0 dataset by Zhang and LeCun<lb>(2015). We use all the 5,952 questions for the ques-<lb>tion type dataset. But the other three datasets con-<lb>tain too many instances (e.g. 1,400,000 instances in<lb>yahoo answer). Running clustering experiments on<lb>such a large dataset is quite inefficient. Following<lb>the same solution in (Xu et al., 2015), we randomly<lb>choose 1,000 samples for each classes individually<lb>for the other three datasets. Within each dataset, we<lb>randomly sample 10% of the instances as labeled<lb>data, and evaluate the performance on the remain-<lb>ing 90% instances. Table 3 summarizes the statistics<lb>of these datasets.<lb>In all experiments, we set the size of word vector<lb>dimension as d=300 1, and pre-train the word vec-<lb>tors with the word2vec toolkit (Mikolov et al., 2013)<lb>on the English Gigaword (LDC2011T07). The num-<lb>ber of clusters is set to be the same number of labels<lb>in the dataset. The clustering performance is eval-<lb>We tuned different dimensions for word vectors. When the<lb>size is small (50 or 100), performance drops significantly. When<lb>the size is larger (300, 500 or 1000), the curve flattens out. To<lb>make our model more efficient, we fixed it as 300.<lb>num_dim", "creator": "LaTeX with hyperref package"}}}