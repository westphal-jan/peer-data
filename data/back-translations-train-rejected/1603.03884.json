{"id": "1603.03884", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Mar-2016", "title": "Grounding Recursive Aggregates: Preliminary Report", "abstract": "Problem solving in Answer Set Programming consists of two steps, a first grounding phase, systematically replacing all variables by terms, and a second solving phase computing the stable models of the obtained ground program. An intricate part of both phases is the treatment of aggregates, which are popular language constructs that allow for expressing properties over sets. In this paper, we elaborate upon the treatment of aggregates during grounding in Gringo series 4. Consequently, our approach is applicable to grounding based on semi-naive database evaluation techniques. In particular, we provide a series of algorithms detailing the treatment of recursive aggregates and illustrate this by a running example.", "histories": [["v1", "Sat, 12 Mar 2016 10:22:13 GMT  (61kb)", "http://arxiv.org/abs/1603.03884v1", "21 pages, 7 figures, preliminary version appeared at GTTV'15"]], "COMMENTS": "21 pages, 7 figures, preliminary version appeared at GTTV'15", "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["martin gebser", "roland kaminski", "torsten schaub"], "accepted": false, "id": "1603.03884"}, "pdf": {"name": "1603.03884.pdf", "metadata": {"source": "CRF", "title": "Grounding Recursive Aggregates: Preliminary Report", "authors": ["Martin Gebser", "Roland Kaminski", "Torsten Schaub"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 160 3.03 884v 1 [cs.A I] 1 2M ar2 016"}, {"heading": "1 Introduction", "text": "In this process, a basic rule is produced only if its positive bodies belong to the present ones. In this case, the atom is incorporated into the present structures."}, {"heading": "2 Formal Preliminaries", "text": "This section is reminiscent of the formal preparatory work on the syntax and semantics of Gringo's input language, which was developed in [6]."}, {"heading": "2.1 Syntax", "text": "We consider digits, (symbolic) constants, variables and aggregate terms that go beyond the scope of this paper. 5 We use anonymous variables, i.e. interpretation of digits and aggregates that go beyond the scope of this paper. 5 We consider digits and aggregate terms to be unique variables, i.e. the interpretation of digits and aggregate terms is not included here because it is specifically dealt with in Gringo; a description goes beyond the scope of this paper. 5 We use anonymous variables, i.e."}, {"heading": "2.2 Semantics", "text": "The semantics of programs are based on a translation into (infinite) sentence formulas along with their stable models. (7) Basic simple literals are represented by proposition atoms as a sequence. (a) = a for (basic) symbolic variables. (t1) A variable is global - in a simple letter if it occurs in the letter - in an aggregated letter if it occurs in the letter - in an aggregated letter - in an aggregated letter - in an aggregated letter if it occurs in the letter - in a rule - if it occurs globally in the head or body letter.7 Gringo and its semantic foundations occur in [6] principles of formulas."}, {"heading": "2.3 Safety and Rule Dependency Graph", "text": "A global variable is safe in an integer if it is bound by a positive symbolic letter in the corresponding integer. A rule is safe if all its variables are safe. A program is safe if all its rules are safe. In the following, we will consider only safe programs. The rule dependency graph G = (V, E) of a (normal) logic program P is a directed graph, so that V = P and E = {(r1, r2) as well as V \u00b7 V \u00b7 V | l \u00b7 solid \u00b1 (r2), head (r1) l}.8 The positive rule dependency graph G + is similarly defined, but takes into account edges caused only by positive letters (l \u00b2 solid + (r2)."}, {"heading": "3 Basic Grounding Algorithms", "text": "This section; contains some basic algorithms on which the semi-naive grounding valuation is based; < < < < < < < < < < < < < < < < < < < < >; < < < < < < < < < < < < < < < < < < < < >; < < < < < >; < < < < < >; < < < < < >; < < < < < < < < < < < < < >; < < < < < < < >; < < < < < < > > >; < < < < < < > > > > > >; < < < < < < > > > > > >; < < < < < < < < < < < < > > > > > >; < < < < < < < < < < < > > > > > > >; < < < < < > > > > > > > > > > > >; < < < < < < < < < < < < < < < > > > > > > > > > > > > > > > > > > > >"}, {"heading": "3.1 Analyzing Logic Programs", "text": "The Analyze function in Algorithm 1 takes a logic program P, classifies occurrences of recursive symbolic atoms (Ar) and groups rules into components suitable for successive grounding; the classification of atoms can be used to apply simplifications in the following algorithms (cf. Algorithm 3); the outer loop (lines 5-10) iterates over its components in the topological order; 10 Each component is then further refined in terms of its positive dependency curve (lines 6-7); the outer loop (lines 5-10) iterates over its components in the topological order; 10 Each component is then further refined in terms of its positive dependence curve (lines 6-7); and the set of recursive symbolic atoms is determined in line 9. These are all body literals whose atom is unified with the head of a rule in the current or a subsequent component."}, {"heading": "3.2 Preparing Components for Grounding", "text": "The function Prepare sets the rules in a component C for grounding its recursive atoms Ar. To this end, it adds the predicate name of the atoms in the positive rule fields of a given component to each of the subscripts n, o or a. 11 These subscripts 11 The alphabet in section 2 does not allow predicate names with subscripts. During grounding, we temporarily extend this alphabet by such predicate names. (1) Function Prepare (C, Ar) 2 L 3 for each r in C 4 D 5 let S = body + (r) 1 Ar 6 for each p (x) in S do7 L, L, head (r) 2 L, 3 for each r in C 4 D 5 Let S = body + (r) 5 x) qa (y)."}, {"heading": "9 if S = \u2205 then", "text": "In contrast to the recursive atom (x), the recursive body receives only one subscription. In the first line of line 7, the predicate names of the recursive atoms are repeated in the component at hand. Each such rule r is extended to a series of rules (loop in lines 6-8); the recursive atoms in their body (line 5); in the first line of line 7, the predicate names of the recursive atoms are already considered recursive (sentence D), the subscripts o, and the predicate name of the recursive atom (x) receive only the subscripts."}, {"heading": "3.3 Grounding Rules", "text": "The rule algorithm is based on two auxiliary functions. First, the rule algorithm provides a safe body order of a rule body. (12) A safe body order of a body. (12) The duration of the instantiation algorithms is sensitive to the selected body order. (12) The duration of the instantiation algorithms is sensitive to the selected body order. (X) In the context of ASP, however, heuristics for ordering body words have been investigated in [11]. (X), (X), (X) and (X) is a safe body order, while (X) the duration of the instantiation algorithms is not applicable to the selected body order."}, {"heading": "3.4 Grounding Logic Programs", "text": "The above functions are summarized in algorithm 4 for grounding whole (normal) logical programs. - The function Ground takes a division of a program into real rules P and atoms Af, which proceed from facts, and returns (after completion) to a set of basic rules Pg. The latter is executed only once if the component is free of recursive positive body words, and otherwise, until no new (head) atoms arise. This is achieved by manipulating the following sets of atoms. - Aa the set of all relevant atoms up to the current grounding stage, - To the set of atoms new in the previous grounding stage, - Ao\\ To the set of atoms not new."}, {"heading": "9 return P \u222aQ", "text": "Algorithm 5: Rewrite Logic ProgramsThis iteration does not produce new atoms and terminates the instantiation of component 7,1. The other components are analogously grounded, but due to their lack of recursive positive body literals within a single iteration. This is forced by the second-stop criterion in line 11 of algorithm 4."}, {"heading": "4 Grounding Recursive Aggregates", "text": "After laying the foundations for grounding normal logic programs, we now proceed to the treatment of recursive aggregates. The idea is to translate aggregate atoms into normal logic programs, approximately one rule per aggregate element, and then reuse the basic grounding machinery as much as possible. In addition, an aggregated specific propagation takes place. In the end, the resulting aggregate instances are reassembled from the corresponding rules."}, {"heading": "4.1 Rewriting Logic Programs with Aggregates", "text": "The function Rewrite in Algorithm 5 takes as input a logic program (possibly with recursive aggregates) and writes it to a normal logic program with additional predicates that capture aggregates and aggregate elements. 14Each aggregate event is replaced by an atom of the form aggr i (x) in line 7, where i is a unique identification with the aggregate event and x are the global variables that occur in the aggregate. The idea is that each atom is circumscribed by aggr i (x), corresponding to a soil aggregate that is replaced by the atom in the termination. aggregates represent elements such as tj, auxiliary rules, the atoms of the form accu i (x, t) are added in line 8, where x is the global variables as above and t is the tuple that is aggregated (or the special constant neutral)."}, {"heading": "4.2 Analyzing and Preparing Logic Programs with Aggregates", "text": "Figure 6 shows the result of the function analysis with preare for each component of the rewritten corporate controls in Table 5. Component 1,1 and component2,1 rules are based on facts only and therefore lead both to a single component. Component 3,1 contains the remaining rules. The aggregate of corporate control coding is recursive in this component in view of atomic controls (X, Z) in its second aggregate element. Note that not all aggregate components are involved in this recursion, since direct shares via the rule of component 2,1.1 function propagates (I, r, Aa, Af) 2 A, 3 foreach i, g foreach i, g where i-I and accu i (g, t) Aa do 4 let Tf = {t | accu i (g, tuple (t) function propagates (I, Aa, Af) 2 A-3 foreach i, g foreach i, g where i-accu i, g-i and accu i-Ge (g, Gate-Ge) Ge-Ge (Ge-Ge) Ge-Ge (Ge-Gate-Ge-Ge) Ge (Ge-Ge-Ge-Ge-Ge) (Ge-Ge-Ge-Ge-Ge-Ge-Ge) (Ge-Ge-Ge) (Ge-Ge-Ge-Ge-Ge-Ge-Ge) (Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge) (Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge (Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge) (Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-Ge-G"}, {"heading": "4.3 Propagating Aggregates", "text": "The Propagate function checks the partial grounding of an aggregated instance for its grounded aggregated elements. To this end, it checks atoms by predicate Accu i during grounding. The loop in lines 3-10 iterates over the given aggregated indices I and tuples of global variables stored in atoms by predicate Accui. If there are enough tuples captured by such atoms to satisfy the corresponding aggregates, propagate adds atoms by predicate Aggr i to A \u2206 for further instantiation. While line 4 collects tuples that are necessarily accumulated by the aggregated function, line 5 collects tuples whose conditions may be able to hold. Also note that the relevance check of tuples that do not alter the result of an aggregated function."}, {"heading": "4.4 Assembling Aggregates", "text": "After rewriting aggregated atoms into normal program rules, Assemble reconstructs their grounded equivalents according to algorithm 7 from the rewritten grinding program, i.e. all occurrences of atoms of the form aggr i (g) are replaced by their corresponding aggregates, whereby the aggregated elements are reconstructed from rules with head atoms accu i (g, tuple (t) in line 3, with one element consisting of the term tuple t together with the condition expressed by the rule.16 The actual exchange takes place in line 4, followed by the deletion of outdated rules in line 5. Finally, the reconstructed grinding program is returned in line 6."}, {"heading": "4.5 Grounding Logic Programs with Aggregates", "text": "The first change is in line 3, where the function of the logical program P can be converted into a normal logical program before an invocation occurs. GroundRule in algorithms 3, Af) 2 (Pg, Aa) 2 (Pi) 2 (Pi) 3 (Rewrite) in analysis (P) 4 (P) 4 (Let I = {i) aggr i in a control header in C} 5 Ir = (r) 5 Ir."}, {"heading": "5 Discussion", "text": "Our framework, implemented in the Gringo series 4, represents the first approach that covers full-fledged aggregates under Ferraris \"semantics [13,6]. While semi-na\u00efve evaluation techniques are based on the field of database systems [3,4], their introduction to grounding in ASP was driven by the dlv system [14], which establishes basic semi-na\u00efve grounding algorithms (cf. [1]) similar to those in Section 3. Given this proximity, our grounding methods for dealing with recursive aggregates within the dlv system, hitherto limited to stratified aggregates, have been adopted. Other grounding approaches will be limited to non-na\u00efve approaches in gidl [16], lparse [16] and earlier versions of the Gringo aggregates [17,18,2]. The latter also support recursive (convex) aggregates, but are limited by the need for these approaches to be limited to non-na\u00efve approaches."}], "references": [{"title": "Advances in gringo series 3", "author": ["M. Gebser", "R. Kaminski", "A. K\u00f6nig", "T. Schaub"], "venue": "In Delgrande, J., Faber, W., eds.: Proceedings of the Eleventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201911). Springer-Verlag", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Principles of Database and Knowledge-Base Systems", "author": ["J. Ullman"], "venue": "Computer Science Press", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1988}, {"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1995}, {"title": "The magic of duplicates and aggregates", "author": ["I. Mumick", "H. Pirahesh", "R. Ramakrishnan"], "venue": "In McLeod, D., Sacks-Davis, R., Schek, H., eds.: Proceedings of the Sixteenth International Conference on Very Large Data Bases (VLDB\u201990). Morgan Kaufmann Publishers", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1990}, {"title": "Abstract Gringo", "author": ["M. Gebser", "A. Harrison", "R. Kaminski", "V. Lifschitz", "T. Schaub"], "venue": "Theory and Practice of Logic Programming 15(4-5)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2015}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25(3-4)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1999}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "In Apt, K., Marek, V., Truszczy\u0144ski, M., Warren, D., eds.: The Logic Programming Paradigm: A 25-Year Perspective. Springer-Verlag", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1999}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Morgan and Claypool Publishers", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Unfounded sets and well-founded semantics of answer set programs with aggregates", "author": ["M. Alviano", "F. Calimeri", "W. Faber", "N. Leone", "S. Perri"], "venue": "Journal of Artificial Intelligence Research 42", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2011}, {"title": "Logic programs with propositional connectives and aggregates", "author": ["P. Ferraris"], "venue": "ACM Transactions on Computational Logic 12(4)", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7(3)", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2006}, {"title": "Grounding FO and FO(ID) with bounds", "author": ["J. Wittocx", "M. Mari\u00ebn", "M. Denecker"], "venue": "Journal of Artificial Intelligence Research 38", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2010}, {"title": "Gringo: A new grounder for answer set programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "In Baral, C., Brewka, G., Schlipf, J., eds.: Proceedings of the Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907). Springer-Verlag", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2007}, {"title": "On the input language of ASP grounder gringo", "author": ["M. Gebser", "R. Kaminski", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "In Erdem, E., Lin, F., Schaub, T., eds.: Proceedings of the Tenth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201909). Springer-Verlag", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}, {"title": "Correct Reasoning: Essays on Logic-Based AI in Honour of Vladimir Lifschitz", "author": ["E. Erdem", "J. Lee", "Y. Lierler", "D. Pearce", "eds."], "venue": "Springer-Verlag", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "Proceedings of the Sixth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201901)", "author": ["T. Eiter", "W. Faber", "M. Truszczy\u0144ski", "eds."], "venue": "Springer-Verlag", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2001}], "referenceMentions": [{"referenceID": 0, "context": "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.", "startOffset": 112, "endOffset": 117}, {"referenceID": 2, "context": "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.", "startOffset": 112, "endOffset": 117}, {"referenceID": 3, "context": "An example of such an aggregate is shown in Table 1, giving an encoding of the Company Controls Problem [5]: A company X controls a company Y , if X directly or indirectly controls more than 50% of the shares of Y .", "startOffset": 104, "endOffset": 107}, {"referenceID": 4, "context": "Section 2 starts with recalling the formal preliminaries from [6].", "startOffset": 62, "endOffset": 65}, {"referenceID": 4, "context": "This section recalls the formal preliminaries regarding the syntax and semantics of gringo\u2019s input language, developed in [6].", "startOffset": 122, "endOffset": 125}, {"referenceID": 4, "context": "\u2013 in a simple literal, if it occurs in the literal \u2013 in an aggregate literal, if it occurs in the guard \u2013 in a rule, if it is global in the head or a body literal 7 gringo as well as its semantic underpinnings in [6] also allow for double negated literals of form \u223c\u223ca.", "startOffset": 213, "endOffset": 216}, {"referenceID": 5, "context": "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].", "startOffset": 140, "endOffset": 148}, {"referenceID": 6, "context": "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].", "startOffset": 140, "endOffset": 148}, {"referenceID": 7, "context": "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].", "startOffset": 140, "endOffset": 148}, {"referenceID": 8, "context": "In general, this is guaranteed for programs with stratified negation and monotone aggregates only [12].", "startOffset": 98, "endOffset": 102}, {"referenceID": 9, "context": "Our framework, which is implemented in gringo series 4, constitutes the first approach capturing full-fledged aggregates under Ferraris\u2019 semantics [13,6].", "startOffset": 147, "endOffset": 153}, {"referenceID": 4, "context": "Our framework, which is implemented in gringo series 4, constitutes the first approach capturing full-fledged aggregates under Ferraris\u2019 semantics [13,6].", "startOffset": 147, "endOffset": 153}, {"referenceID": 1, "context": "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.", "startOffset": 83, "endOffset": 88}, {"referenceID": 2, "context": "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.", "startOffset": 83, "endOffset": 88}, {"referenceID": 10, "context": "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.", "startOffset": 161, "endOffset": 165}, {"referenceID": 11, "context": "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].", "startOffset": 47, "endOffset": 51}, {"referenceID": 12, "context": "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].", "startOffset": 97, "endOffset": 106}, {"referenceID": 13, "context": "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].", "startOffset": 97, "endOffset": 106}, {"referenceID": 0, "context": "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].", "startOffset": 97, "endOffset": 106}, {"referenceID": 12, "context": "The latter two also support recursive (convex) aggregates but are limited by the necessity to bind non-global variables by domain predicates, given that programs have to be \u03c9- [16] or \u03bb-restricted [17], respectively.", "startOffset": 197, "endOffset": 201}], "year": 2016, "abstractText": "Problem solving in Answer Set Programming consists of two steps, a first grounding phase, systematically replacing all variables by terms, and a second solving phase computing the stable models of the obtained ground program. An intricate part of both phases is the treatment of aggregates, which are popular language constructs that allow for expressing properties over sets. In this paper, we elaborate upon the treatment of aggregates during grounding in gringo series 4. Consequently, our approach is applicable to grounding based on semi-naive database evaluation techniques. In particular, we provide a series of algorithms detailing the treatment of recursive aggregates and illustrate this by a running example.", "creator": "LaTeX with hyperref package"}}}