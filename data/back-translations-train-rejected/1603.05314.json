{"id": "1603.05314", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Mar-2016", "title": "Hardware Acceleration for Boolean Satisfiability Solver by Applying Belief Propagation Algorithm", "abstract": "Boolean satisfiability (SAT) has an extensive application domain in computer science, especially in electronic design automation applications. Circuit synthesis, optimization, and verification problems can be solved by transforming original problems to SAT problems. However, the SAT problem is known as NP-complete, which means there is no efficient method to solve it. Therefore, an efficient SAT solver to enhance the performance is always desired. We propose a hardware acceleration method for SAT problems. By surveying the properties of SAT problems and the decoding of low-density parity-check (LDPC) codes, a special class of error-correcting codes, we discover that both of them are constraint satisfaction problems. The belief propagation algorithm has been successfully applied to the decoding of LDPC, and the corresponding decoder hardware designs are extensively studied. Therefore, we proposed a belief propagation based algorithm to solve SAT problems. With this algorithm, the SAT solver can be accelerated by hardware. A software simulator is implemented to verify the proposed algorithm and the performance improvement is estimated. Our experiment results show that time complexity does not increase with the size of SAT problems and the proposed method can achieve at least 30x speedup compared to MiniSat.", "histories": [["v1", "Wed, 16 Mar 2016 23:57:27 GMT  (1508kb)", "http://arxiv.org/abs/1603.05314v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["te-hsuan chen", "ju-yi lu"], "accepted": false, "id": "1603.05314"}, "pdf": {"name": "1603.05314.pdf", "metadata": {"source": "CRF", "title": "Hardware Acceleration for Boolean Satisfiability Solver by Applying Belief Propagation Algorithm", "authors": ["Te-Hsuan Chen", "Ju-Yi Lu"], "emails": ["juyi}@umich.edu"], "sections": [{"heading": null, "text": "In computer science, especially in applications for the automation of electronic designs, problems of circuit synthesis, optimization and verification can be solved by converting original problems to SAT problems. However, the SAT problem is known as NP-complete problem, which means that there is no efficient method of solving SAT problems. Therefore, the design of an efficient SAT solver to increase performance is always desirable. In this paper, we have proposed a hardware acceleration method for Boolean SAT problems. By studying the properties of SAT problems and decrypting low-density parity check codes (LDPC), a special class of error correction codes (ECCs), we find that both are constraint satisfaction problems (CSPs). The faith propagation algorithm (BPA) has been successfully applied to the decoding of LDPC codes, and therefore we have proposed a decoding hardware to address the decoding problems."}, {"heading": "1. INTRODUCTION", "text": "This year, it is closer than ever before in the history of the country."}, {"heading": "1.1 Contribution", "text": "Our main contribution in this paper is (1) the application of the algorithm for decoding LDPC codes to CNF-based SAT problems, (2) the evaluation of the proposed modified BPA by a simulator written in C / C + +, (3) the evaluation of the time required by the proposed SAT solver and the comparison with MiniSat [5]."}, {"heading": "1.2 Organization", "text": "The work is structured as follows: Section 2 gives a brief overview of the LDPC codes and the faith propagation algorithm. Section 3 proposes a SAT solution algorithm based on the faith propagation algorithm. Section 4 provides the experimental results. Section 5 discusses the related work and Section 6 concludes."}, {"heading": "2. LOW-DENSITY PARITY CHECK CODE", "text": "This year, it is so far that it is only a matter of time before it is ready, until it is ready."}, {"heading": "3. BELIEF PROPAGATION FOR SAT", "text": "In this section we will discuss the proposed Faith Propagation Algorithm for SAT Problems (BPA-SAT) for SAT Problems. In 3.1 we will discuss the adopted modification of Faith Propagation to be applied to the SAT Solver. In 3.2 we will give an overview of the proposed BPA-SAT and some detailed implementations."}, {"heading": "3.1 Adaption on BPA-SAT", "text": "In addition, the initialization of the probability is less important than the conventional BPA, since there is no prior information about the literal assignment. 1. Initialization: In the SAT problem, the initial values of the literals are all set to 0.5 in order not to show a bias of the assignment without prior information. 2. Pass information from the clauses to the literals: Since the operators in the CNF clauses are OR, which is 1 = 1 + 2 + 3, this represents 1,1 (1) the probability that 1 is the vector of 1 = 0, and the probability of 2, 3. Therefore, the modified equation is: 1,1 (0) = (1 = 1 =,) (1), (), (), (), (), (), (, (,), (, (,), (, (,), (, (,), (, (,), (, (,), (, (,), (, (,), (, (,), (), (, (,), (), (, (), (), (), (, (), (), (, (,), (), (), (), (, (), (), (), (, (,), (), (, (,), (), (), (), (), (), (), (, (), (), (), (, (, (,), (), (), (), (), (), (), (), (), (, (), (, (), (), (), (), (, (), (), (), (, (), (, (), (), (), (), (), (), (), (, (, (, (), (), (), (, (), (), (), (), (), (), (), (), (), (), (, (, (), (, (), (), (), (), (), (, (, (), (), (), (),"}, {"heading": "3.2 BPA-SAT overview", "text": "Figure 4 is the flowchart of the entire BPA-SAT. There are two loops in BPA-SAT, the inner loop is the core algorithm of BPA-SAT, which calculates iteratively, (1), (1) and (1) The outer loop is the break-and-restart mechanism to prevent BPA-SAT from going on forever, and randomly assigns a different starting point (baseline value set)."}, {"heading": "4. EXPERIMENTAL RESULT", "text": "In this section, we present an evaluation of the completeness and acceleration of our belief in SAT issues. 3SAT benchmarks in SATLIB [12] are run on our BPA for SAT simulator. For acceleration, we compare the estimated execution time of BPA for SAT running on FPGA Xilinx 2 XC2V6000-5 with the real execution time of a MiniSat solver running on two 6-core Intel (R) Xeon (R) CPU E5645 @ 2.40GHz processors."}, {"heading": "4.1 Completeness", "text": "In this subsection, we examine the completeness of the BPA-SAT. In our experiment, all cases in the benchmark are satisfactory, completeness is defined as a fraction of the testbench instance that can be solved by the BPA-SAT. Figure 5 examines the completeness of the BPA for SAT. All benchmark rates are satisfactory. Benchmark uf20-91 shows the literal number 20 and paragraph 91. It shows that BPA for SAT has a worse solving ability when the problem size increases. After the adoption of the random restart mechanism, there is only an average improvement of 5%. Therefore, the question of how completeness can be improved will be the main problem in future work. Furthermore, the ECC decoder, where BPA works well, has the verbatim clauses ratio greater than 1, while the verbal clauses ratio of the SAT problem is generally less than 0.25. This fundamental difference is considered the decisive factor for the proposed incompleteness of the BPA-SAT."}, {"heading": "4.2 Execution iteration & Speedup Evaluation", "text": "In fact, most of them will be able to establish themselves in the EU."}, {"heading": "5. RELATED WORK", "text": "The application-specific architecture is the mainstream in hardware acceleration of the SAT problem to avoid the time-consuming FPGA synthesis time. [10] [11] Both implemented the Boolean constraint propagation calculation in parallel. For storage on the Word clause instance, the former stored the data with embedded DRAM, while the latter relied on the block RAM (BRAM) of the modern FPGA. Both relied on input / output queue to allow parallel value assignment; the intensive BCP calculation was done in parallel by partitioning clauses divided into several subsets; the synchronization scheme also provides for the detection of serial conflicts. In this type of architecture, the problem size can be very large. As the size of BRAM is the only limitation of this hardware implementation, the capacity can be extended to 64K variable and 176K clauses."}, {"heading": "6. CONCLUSION", "text": "In this paper, a belief propagation algorithm for CNF-based SAT problems (BPA-SAT) was presented. BPA-SAT is based on the belief propagation algorithm (BPA), which is used in decoding a class of error correction codes, low-density parity check (LDPC) codes. As BPA can be implemented with hardware, the BPA-SAT solver can be accelerated by hardware. Furthermore, the experimental results show that the time complexity of the BPA-SAT does not increase with the size of the SAT problems. Therefore, the speed solver does not deteriorate dramatically when the size of the CNF increases. The main problem, the complexity of this algorithm, is also investigated. The complexity decreases significantly with the size of the CNF. Experimental results and our assessment show that for the constants that the PA-SAT can be solved times higher than the state of the BAT-SAT technology compared to a 44SAT-SAT."}, {"heading": "7. REFERENCES", "text": "[1] Wagner, I., Bertacco V., Post-Silicon and RuntimeVerification for Modern Processors, Springer (December 3, 2010) [2] Cook, S. A., \"The Complexity of Theorem-Proving Procedures,\" Proceedings of the Third Year ACM Symposium on Therentice, pp.151-158, 1971 [3] Russell, S., and Norvig, P., Artificial Intelligence: A Modern Approach, Prentice Hall; 3 issue (December 11, 2009) [4] Gallager, R. G., Low Density Parity Check Codes. Cambridge, MA: MIT Press, 1963. [5] Een, N., S\u00f6rensson N., An extensible sat-solver. In SAT, pp.502-518, 2003 [6] MacKay, D. J. C., and Neal, Boal, R. M., \"Near Shannon Limit Performance of Low Density Parity Check Codes,\"."}, {"heading": "249, 2001", "text": "[12] SATLIB - The Satisfiability Library. Available http: / / www.cs.ubc.ca / ~ hoos / SATLIB / index-ubc.html [13] Chen, X., Kang, J., Lin, S., and Akella, V., \"Memory System Optimization for FPGA-based Implementation of Quasi-Cyclic LDPC Codes Decoders,\" Circuits and Systems I: Regular Papers, IEEE Transactions on, vol.58, no.1, pp.98111, Jan. 2011"}], "references": [{"title": "Post-Silicon and Runtime Verification for Modern Processors", "author": ["I. Wagner", "Bertacco V"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "The Complexity of Theorem-Proving Procedures", "author": ["S.A. Cook"], "venue": "Proceedings of the third annual ACM symposium on Theory of computing, pp.151-158, 1971", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1971}, {"title": "Artificial Intelligence: A Modern Approach, Prentice Hall; 3 edition", "author": ["S. Russell", "P. Norvig"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Low Density Parity Check Codes", "author": ["R.G. Gallager"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1963}, {"title": "An extensible sat-solver", "author": ["N. Een", "S\u00f6rensson N"], "venue": "In SAT,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Near Shannon Limit Performance of Low Density Parity Check Codes", "author": ["D.J.C. MacKay", "R.M. Neal"], "venue": "Electronics Letters, 1996", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1996}, {"title": "Reconfigurable hardware SAT solvers: a survey of systems", "author": ["I. Skliarova", "A de Brito Ferrari"], "venue": "Computers, IEEE Transactions on , vol.53, no.11, pp. 1449- 1461, Nov. 2004", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2004}, {"title": "Error Correction Coding: Mathematical Methods and Algorithms", "author": ["T.K. Moon"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "Error Control Coding", "author": ["S. Lin", "J. Costello D"], "venue": "Fundamentals and Applications,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "A Practical Reconfigurable Hardware Accelerator for Boolean Satisfiability solvers", "author": ["J.D. Davis", "Z. Tan", "F. Yu", "L. Zhang"], "venue": "Design Automation Conference, 2008. DAC 2008. 45th ACM/IEEE , vol., no., pp.780-785, 8-13 June 2008", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2008}, {"title": "Accelerating Boolean satisfiability through application specific processing", "author": ["Y. Zhao", "S. Malik", "M. Moskewicz", "C. Madigan"], "venue": "System Synthesis, 2001. Proceedings. The 14th International Symposium on , vol., no., pp. 244- 249, 2001", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2001}, {"title": "Memory System Optimization for FPGA-Based Implementation of Quasi- Cyclic LDPC Codes Decoders", "author": ["X. Chen", "J. Kang", "S. Lin", "V. Akella"], "venue": "Circuits and Systems I: Regular Papers, IEEE Transactions on , vol.58, no.1, pp.98- 111, Jan. 2011", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 0, "context": "INTRODUCTION Boolean satisfiability (SAT) is a class of problems that establishes if there exist an assignment to variables of a Boolean formula that evaluates it to true [1].", "startOffset": 171, "endOffset": 174}, {"referenceID": 1, "context": "The SAT problem is the first known NP-complete decision problem [2], which means that there is no efficient algorithm to solve SAT problems.", "startOffset": 64, "endOffset": 67}, {"referenceID": 6, "context": "The approaches to solve the SAT problem have divided into software solvers, which solving the problem using computer simulation, and hardware solver, to implement Verilog code running on FPGA or virtual machine [7][10][11].", "startOffset": 211, "endOffset": 214}, {"referenceID": 9, "context": "The approaches to solve the SAT problem have divided into software solvers, which solving the problem using computer simulation, and hardware solver, to implement Verilog code running on FPGA or virtual machine [7][10][11].", "startOffset": 214, "endOffset": 218}, {"referenceID": 10, "context": "The approaches to solve the SAT problem have divided into software solvers, which solving the problem using computer simulation, and hardware solver, to implement Verilog code running on FPGA or virtual machine [7][10][11].", "startOffset": 218, "endOffset": 222}, {"referenceID": 2, "context": "A constraint satisfaction problem (CSP) consists of three components, X, D, and C [3]:", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "The decoding of a special class of ECC, low-density parity-check (LDPC) codes [4], is a constraint satisfaction problem.", "startOffset": 78, "endOffset": 81}, {"referenceID": 7, "context": "In the decoding of LDPC codes, the procedure can be illustrated by a bipartite graph which contains two types of nodes: variable nodes and parity-check nodes, and use iterative belief propagation decoding method to find solutions [8][9].", "startOffset": 230, "endOffset": 233}, {"referenceID": 8, "context": "In the decoding of LDPC codes, the procedure can be illustrated by a bipartite graph which contains two types of nodes: variable nodes and parity-check nodes, and use iterative belief propagation decoding method to find solutions [8][9].", "startOffset": 233, "endOffset": 236}, {"referenceID": 4, "context": "1 Contribution Our main contribution in this paper is (1) applying the algorithm of decoding LDPC codes, to CNF-based SAT problems, (2) evaluating the proposed modified BPA by a simulator written in C/C++, (3) estimating the time that is need by the proposed SAT solver and comparing it with MiniSat [5].", "startOffset": 300, "endOffset": 303}, {"referenceID": 3, "context": "LOW-DENSITY PARITY CHECK CODE Originally proposed in 1962 by Robert Gallager [4] and rediscovered by David MacKay in 1996 [6], LDPC codes with iterative decoding algorithms have performance closely approaching Shannon channel capacity.", "startOffset": 77, "endOffset": 80}, {"referenceID": 5, "context": "LOW-DENSITY PARITY CHECK CODE Originally proposed in 1962 by Robert Gallager [4] and rediscovered by David MacKay in 1996 [6], LDPC codes with iterative decoding algorithms have performance closely approaching Shannon channel capacity.", "startOffset": 122, "endOffset": 125}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 0, "context": "For example, let the parity-check matrix H be a 3\u00d74 matrix H = [ 1 1 1 0 1 1 0 1 0 1 1 1 ]", "startOffset": 63, "endOffset": 90}, {"referenceID": 11, "context": "Based the experimental result of [13], the desired FPGA computation ability, second per iteration (SPI) can be calculated in equation below:", "startOffset": 33, "endOffset": 37}, {"referenceID": 11, "context": "In [13], the Codeword length is the bandwidth the FPGA can execute in parallel in a single iteration.", "startOffset": 3, "endOffset": 7}, {"referenceID": 9, "context": "[10][11] both implemented Boolean Constraint Propagation computation in parallel.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[10][11] both implemented Boolean Constraint Propagation computation in parallel.", "startOffset": 4, "endOffset": 8}, {"referenceID": 6, "context": "[7] implemented the application-specific architecture by storing the whole literal-clause matrix into the FPGA block.", "startOffset": 0, "endOffset": 3}], "year": 2016, "abstractText": "Boolean satisfiability (SAT) has an extensive application domain in computer science, especially in electronic design automation applications. Circuit synthesis, optimization, and verification problems can be solved by transforming original problems to SAT problems. However, the SAT problem is known as an NP-complete problem, which means there is no efficient method to solve SAT problems. Therefore, the design of an efficient SAT solver to enhance the performance is always desired. In this paper, we proposed a hardware acceleration method for Boolean SAT problems. By surveying the properties of SAT problems and the decoding of low-density parity-check (LDPC) codes, a special class of error-correcting codes (ECCs), we discover that both of them are constraint satisfaction problems (CSPs). The belief propagation algorithm (BPA) has been successfully applied to the decoding of LDPC, and the corresponding decoder hardware designs are extensively studied. Therefore, we proposed a belief propagation based algorithm to solve SAT problems. With this algorithm, the SAT solver can be accelerated by hardware. A software simulator is implemented to verify the proposed algorithm and the performance improvement is estimated. Our experiment results show that time complexity does not increase with the size of SAT problems and the proposed method can achieve at least 30\u00d7 speedup compared to MiniSat.", "creator": "Microsoft\u00ae Word 2013"}}}