{"id": "1604.03243", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Apr-2016", "title": "Separating Sets of Strings by Finding Matching Patterns is Almost Always Hard", "abstract": "We study the complexity of the problem of searching for a set of patterns that separate two given sets of strings. This problem has applications in a wide variety of areas, most notably in data mining, computational biology, and in understanding the complexity of genetic algorithms. We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]-hard when parameterized by the size of the pattern set, and APX-hard). We then perform a detailed parameterized analysis of the problem, separating tractable and intractable variants. In particular we show that parameterizing by the size of pattern set and the number of strings, and the size of the alphabet and the number of strings give FPT results, amongst others.", "histories": [["v1", "Tue, 12 Apr 2016 04:37:35 GMT  (16kb)", "http://arxiv.org/abs/1604.03243v1", null], ["v2", "Tue, 1 Nov 2016 03:31:41 GMT  (42kb,D)", "http://arxiv.org/abs/1604.03243v2", null], ["v3", "Mon, 19 Dec 2016 00:50:32 GMT  (42kb,D)", "http://arxiv.org/abs/1604.03243v3", null]], "reviews": [], "SUBJECTS": "cs.CC cs.AI cs.DS", "authors": ["giuseppe lancia", "luke mathieson", "pablo moscato"], "accepted": false, "id": "1604.03243"}, "pdf": {"name": "1604.03243.pdf", "metadata": {"source": "CRF", "title": "Finding Patterns is Almost Always Hard", "authors": ["Guiseppe Lancia", "Luke Mathieson", "Pablo Moscato"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 160 4.03 243v 1 [cs.C CWe explore the complexity of the problem of finding a set of patterns that separate two predetermined sets of strings. This problem is applied in a variety of areas, especially in data mining, computer biology, and understanding the complexity of genetic algorithms. We show that the basic problem of finding a small number of patterns that match a set of strings but do not match any string in a second row is difficult (NP-complete, W [2] difficult when parameterized by the size of the sample set, and APX-hard), then we perform a detailed parameterized analysis of the problem, separating tractable and insoluble variants from each other. Specifically, we show that parameterization is provided by the size of the sample set and the number of strings, as well as the size of the alphabet and the number of string FPT results, among other things."}, {"heading": "1. Introduction", "text": "Finding patterns in a data collection is one of the fundamental problems in the fields of data mining, data science, artificial intelligence, bioinformatics and many other fields of theoretical and applied informatics. Accordingly, there is a large number of formulations of this problem. In this paper, we develop a special formulation that stems from two central motives: the preprint submitted to Elsevier on 13 April 2016. Multi-parent recombination in genetic and evolutionary algorithms and 2. the construction of explanatory patterns in single-core polymorphisms related to diseases. However, these motivations should not be interpreted as limiting the applicability of the problem we have developed and studied."}, {"heading": "1.1. Separating Healthy Patterns from Diseased", "text": "Identification of explanatory genes, discovery of biomarkers, metabolic network analysis and protein interaction serve as the key (but not the only) motivation for identifying differential disease markers and thus pathways to treatment. Consider the following problem as a motivating archetypal example: We have two groups of individuals, healthy and sick, and for each example we get a string that encodes the single nucleotide polymorphisms (SNPs) in the two copies of each genome. An SNP has several alleles, of which an individual has two. Thus, the individual can be homozygous in each of the alleles or heterocygous with any selection of allele pairs. It is easy to see that if we can identify patterns of SNPs that separate the healthy from the diseased individuals, we have a source of genetic information that can help explain and treat the problem."}, {"heading": "1.2. Patterns in Multiparent Recombination", "text": "The central mechanism for optimization in genetic algorithms (GAs) is the recombination of parental solutions to a new child solution that ideally maintains the positive aspects of the parents. However, the mechanism derives from an analogy to sexual reproduction in biological evolution and therefore typically combines two existing solutions to produce the offspring. However, in the optimization environment there is no conceptual reason for this limitation. Since recombination can be considered as a local step in the search space from one individual solution to another, mediated by a third individual solution, a natural generalization of this solution is to employ multiple parents in the hope of further refining the components of the solution that enhance quality and at the same time produce new solutions that effectively cover the search space. The central theoretical formalization for describing this process is that of the diagram 1. An individual solution in a (simple) GA is described by an array that we can present as a character chain, a given alphabet."}, {"heading": "1.3. Computational Complexity Considerations", "text": "Of course, we can easily generalize this idea to consider multiple parent recombinations (i.e. more than two parents) and indeed multiple parent recombinations. A single scheme, which is a chain of n * symbols, would be sufficient as a trivial solution and the natural solution where for each position, if all parents agree on the same symbol, the scheme of that symbol has and otherwise offers a simple solution. In these cases, however, it is relatively easy to see that the generated schemes can easily be under-specified, leading to a loss of useful information, making the recombination ineffective. One solution to this problem is to ask for a small set of schemes that are compatible with the parents but incompatible with a set of forbidden parameters - similar to the list of forbidden parameters in the taboo search. We formalize this problem and examine its complexity."}, {"heading": "1.4. Related Work", "text": "The identification of patterns describing a set of strings forms a well-studied family of patterns with a wide range of applications. Although, to the best of our ability, the precise problems we have examined here have not yet been taken into account, a number of interesting related problems are being investigated in the literature. In contrast to the work here, these variables can function as substrings of any length, but these can at best form a basis for further research by the interested reader. Keans and Pitt [12] provide a family of polynomial age algorithms for learning the language generated by a single such pattern with a certain number of k of pattern variables. Angluin [1] investigates the inverse problem of generating a pattern, with the central result being a poylnomial era algorithm for the case in which the pattern contains a single pattern variable."}, {"heading": "2. Preliminaries and Definitions", "text": "We provide the relevant definitions for the complexity analysis, which proceeds as follows: In the reductions, we use the question of whether these problems are known, but we will not define them, although we can apply the following key formulas: \"It is a complete problem if the input is a planar diagram [10]. \u2022 Set Cover is W [2] -complete if it is parameterized by the size of the specified coverage. \u2022 k Feature Set is W [2] -complete if it is parameterized by the size of the features [7]. The graphics taken as input for these problems are simple, undirected, and unweighted."}, {"heading": "3. Hard Cases of the Pattern Identification Problem", "text": "This narrows down to the origin situation of the complex relationships of the problem. (G, k) It is an instance (G, k) in which there is an instance of dominance. (G, k) It is an instance of dominance. (G, k) It is an instance of dominance. (G, k) It is an instance of dominance. (G) It is an instance of dominance. (G) It is an instance in which there is an instance. (G) (G) It is an instance of dominance. (G) It is an instance in which there is an instance. (G) (G) It is an instance in which there is an instance. (G) It is an instance in which there is an instance. (G) It is an instance in which there is an instance. (G) It is an instance in which there is an instance. (G) There is an instance in which there is an instance. (G) There is an instance in which there is an instance. (G)"}, {"heading": "3.1. Containment", "text": "It is not clear that the problem lies in W [P] or even XP. Since the non-parameterized version of the problem is NP-complete, it is at least contained in paragraph NP. For PI with small patterns, we have shown the containment in W [2]. In contrast, for PI with large patterns, we can show the containment in W [5]. Theorem 3.19. For PI with large patterns, however, we have shown the containment in W [5], if the containment is by k + r.Proof. We reduce the problem to MC (1), which is complete for W [5]. We use the same first-order structure as for the proof of corolars 3.5 and give a suitable first-order formula c: s1,."}, {"heading": "4. Tractable Cases of Pattern Identification Problem", "text": "It is therefore possible that the number of symbols in the total number of all strings and the size of the alphabet. As G and B are too small, for most d (G) there may be positions in which any pair of strings in G (B) occupies different positions, i.e. any other position must be the base symbol in all strings. Therefore, the positions in which each string cannot be used identically in generalization patterns, we can ignore. This gives limited sentences in G (G) and B (B) the size of G (G)."}, {"heading": "5. Discussion", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.1. Ties to Other Problems", "text": "As expected, the problem of pattern identification has links to other problems that (can) model the general search for patterns that separate two sets of data, and these links also illustrate some features of the computational complexity of the problem."}, {"heading": "5.1.1. Set Covering", "text": "If the length n of the strings is small, pattern identification can easily be reduced to set covers. In the face of an instance (\u03a3, G, B, k) of pattern identification, we can create the set P of all patterns that are compatible with a string in G. We know that | P | \u2264 | G | \u00b7 2n. From P, we remove any pattern that is compatible with a string in B. Let P be the set obtained in this way. This leads to the following theorem: Theorem 5.1. Pattern identification: W [2], if n \u2264 f (k) \u00b7 log | I | I, where | I | is the total size of the instance and f (k) is a total set parameterized by k."}, {"heading": "5.1.2. Feature Set", "text": "The k feature set problem bears a strong resemblance to the pattern identification problem, with the exception of the k feature set case, which requires a set of features separating the \"good\" examples from the \"bad\" ones, and not a set of patterns. In fact, in the face of a workable solution to one problem, we can construct a workable (but not necessarily optimal) solution to the other. In the face of a set of indices composed of columns forming a feature set, we can construct a set of patterns separating G and B as follows: for each g-G, pg should be the pattern, with pg [i] = g [i] = if i-I and pg [i] = \u0439 otherwise. We note that this results in a set of small patterns (i.e. s = k), but the number of patterns can be as large as | G |. Conversely, the number of patterns P can play a role in most non-symbols in each pattern."}, {"heading": "6. Conclusion and Future Directions", "text": "The central question, of course, is the precise classification of pattern identification. Although PI with small patterns W [2] is -complete, the general problem is only W [2] -hard, and the containment of PI with large patterns simply provides a loose upper limit, although it suggests that the problem is harder than PI with small patterns. The problem also intuitively has some similarities to p-hypergraph (non) -dominating set, which is W [3] -complete [5]. p-ColoredHypergraph (non) -dominating set, however, is W * [3] -complete [5] and appears \"harder\" than pattern identification, so we suspect: Guess 6.1. Musterification is W [3] -complete if parameters by k. There are also some interesting parameters for which complexity remains open."}, {"heading": "7. Acknowledgements", "text": "PM acknowledges funding for his research through the Australian Research Council (ARC, http: / / www.arc.gov.au /), which funds Future Fellowship FT120100060 and Discovery Project DP140104183."}, {"heading": "8. References", "text": "It is not the first time that the EU Commission has taken such a step."}], "references": [{"title": "Finding patterns common to a set of strings", "author": ["Dana Angluin"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1980}, {"title": "Every Planar Map is Four- Colorable, volume 98 of Contemporary Mathematics", "author": ["Kenneth Appel", "Wolfgang Haken"], "venue": "American Mathematical Society, Providence, RI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1989}, {"title": "Using patterns to form homogeneous teams", "author": ["Robert Bredereck", "Thomas K\u00f6hler", "Andr\u00e9 Nichterlein", "Rolf Niedermeier", "Geevarghese Philip"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2015}, {"title": "An analysis of the Whierarchy", "author": ["Yijia Chen", "J\u00f6rg Flum", "Martin Grohe"], "venue": "The Journal of Symbolic Logic,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "The k-Feature Set problem is W[2]complete", "author": ["Carlos Cotta", "Pablo Moscato"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "Fundamentals of Parameterized Complexity", "author": ["Rodney G. Downey", "Michael R. Fellows"], "venue": "Texts in Computer Science. Springer,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Parameterized Complexity Theory. Texts in Theoretical Computer Science", "author": ["J\u00f6rg Flum", "Martin Grohe"], "venue": "An EATCS Series. Springer,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "Computers and Intractability \u2013 A Guide to the Theory of NP\u2013completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1979}, {"title": "Some optimal inapproximability results", "author": ["J. H\u030aastad"], "venue": "In Proceedings of the 29th ACM Symposium on the Theory of Computing (STOC),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1997}, {"title": "A polynomial-time algorithm for learning k\u2013variable pattern languages from examples", "author": ["Michael Kearns", "Leonard Pitt"], "venue": "In Proceedings of the 2nd Annual ACM Workshop on Computational Learning Theory,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1991}, {"title": "A sub-constant error-probability low-degree test, and a sub-constant error-probability PCP characterization of NP", "author": ["Ran Raz", "Shmuel Safra"], "venue": "In Proceedings of the 29th ACM Symposium on the Theory of Computing (STOC),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1997}], "referenceMentions": [{"referenceID": 1, "context": "We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]hard when parameterized by the size of the pattern set, and APX-hard).", "startOffset": 168, "endOffset": 171}, {"referenceID": 1, "context": "k + |\u03a3| + |B| W[2]-hard 3.", "startOffset": 15, "endOffset": 18}, {"referenceID": 1, "context": "1 k + |\u03a3| + s+ |B| W[2]-complete 3.", "startOffset": 20, "endOffset": 23}, {"referenceID": 1, "context": "natural parameterization by the number of desired schemata is W[2]-hard.", "startOffset": 63, "endOffset": 66}, {"referenceID": 9, "context": "Keans and Pitt [12] give a family of polynomial time algorithms for learning the language generated by a single such pattern with", "startOffset": 15, "endOffset": 19}, {"referenceID": 0, "context": "Angluin [1] studies the inverse problem of generating a pattern, with the central result a poylnomial time algorithm for the case where the pattern contains a single pattern variable.", "startOffset": 8, "endOffset": 11}, {"referenceID": 2, "context": "[3] examine forming teams, i.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "\u2022 Dominating Set is NP-complete, O(logn) \u2212 APX-hard and W[2]complete when parameterized by k, the size of the dominating set.", "startOffset": 57, "endOffset": 60}, {"referenceID": 7, "context": "\u2022 Vertex Cover is NP-complete and APX-hard, and remains NPcomplete when the input is a planar graph [10].", "startOffset": 100, "endOffset": 104}, {"referenceID": 1, "context": "\u2022 Set Cover is W[2]-complete when parameterized by the size of the set cover.", "startOffset": 16, "endOffset": 19}, {"referenceID": 1, "context": "\u2022 k-Feature Set is W[2]-complete when parameterized by the size of the feature set [7].", "startOffset": 20, "endOffset": 23}, {"referenceID": 4, "context": "\u2022 k-Feature Set is W[2]-complete when parameterized by the size of the feature set [7].", "startOffset": 83, "endOffset": 86}, {"referenceID": 0, "context": "While it is known that W[1] = W[1] and W[2] = W[2], for t \u2265 3, the best known containment relationship is W[t] \u2286 W[t] \u2286 W[2t\u2212 2].", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": "While it is known that W[1] = W[1] and W[2] = W[2], for t \u2265 3, the best known containment relationship is W[t] \u2286 W[t] \u2286 W[2t\u2212 2].", "startOffset": 31, "endOffset": 34}, {"referenceID": 1, "context": "While it is known that W[1] = W[1] and W[2] = W[2], for t \u2265 3, the best known containment relationship is W[t] \u2286 W[t] \u2286 W[2t\u2212 2].", "startOffset": 40, "endOffset": 43}, {"referenceID": 1, "context": "While it is known that W[1] = W[1] and W[2] = W[2], for t \u2265 3, the best known containment relationship is W[t] \u2286 W[t] \u2286 W[2t\u2212 2].", "startOffset": 47, "endOffset": 50}, {"referenceID": 6, "context": "For more detail on these results and the full definitions relating to first-order logic and structures we refer the reader to [9].", "startOffset": 126, "endOffset": 129}, {"referenceID": 6, "context": "In several of our intractability results we make use of the class para-NP, and a useful result due to Flum and Grohe with a detailed explanation in [9]", "startOffset": 148, "endOffset": 151}, {"referenceID": 3, "context": "We also employ the Whierarchy [5, 9].", "startOffset": 30, "endOffset": 36}, {"referenceID": 6, "context": "We also employ the Whierarchy [5, 9].", "startOffset": 30, "endOffset": 36}, {"referenceID": 5, "context": "The other parameterized complexity theory employed is more standard, thus for general definitions we refer the reader to standard texts [8, 9].", "startOffset": 136, "endOffset": 142}, {"referenceID": 6, "context": "The other parameterized complexity theory employed is more standard, thus for general definitions we refer the reader to standard texts [8, 9].", "startOffset": 136, "endOffset": 142}, {"referenceID": 1, "context": "Pattern Identification is W[2]-hard when parameterized by k, even if |\u03a3| = 2 and |B| = 1.", "startOffset": 27, "endOffset": 30}, {"referenceID": 1, "context": "PI with Small Patterns is W[2]-complete when parameterized by k and NP-complete even when s = 1, |\u03a3| = 2 and |B| = 1.", "startOffset": 27, "endOffset": 30}, {"referenceID": 1, "context": "The W[2]-hardness is apparent from the proof of Lemma 3.", "startOffset": 5, "endOffset": 8}, {"referenceID": 1, "context": "To show containment in W[2], we reduce PI with Small Patterns to MC(\u03a32,1).", "startOffset": 24, "endOffset": 27}, {"referenceID": 10, "context": "As Dominating Set has no constant factor fpt-approximation [6] and no c \u00b7 log n polynomial time approximation [13] and the reduction of Lemma 3.", "startOffset": 110, "endOffset": 114}, {"referenceID": 7, "context": "As Dominating Set is NP-complete on planar graphs of maximum degree 3 [10], the number of 1s in each string in the construction of the proof of Lemma 3.", "startOffset": 70, "endOffset": 74}, {"referenceID": 6, "context": "16 from [9].", "startOffset": 8, "endOffset": 11}, {"referenceID": 1, "context": "We note that Dominating Set is in FPT for graphs of bounded degree, so we do obtain a W[2]-hardness result.", "startOffset": 87, "endOffset": 90}, {"referenceID": 8, "context": "11 is strict and Vertex Cover is APX-hard [11].", "startOffset": 42, "endOffset": 46}, {"referenceID": 1, "context": "As G is planar, we can compute a proper 4-colouring in polynomial time [2].", "startOffset": 71, "endOffset": 74}, {"referenceID": 6, "context": "16 from [9].", "startOffset": 8, "endOffset": 11}, {"referenceID": 1, "context": "Containment Although the W[2]-hardness reduction is quite direct, containment of Pattern Identification when parameterized by k is not apparent.", "startOffset": 26, "endOffset": 29}, {"referenceID": 1, "context": "For PI with Small Patterns we have shown containment in W[2].", "startOffset": 57, "endOffset": 60}, {"referenceID": 3, "context": "In contrast, for PI with Large Patterns we can show containment in W[5].", "startOffset": 68, "endOffset": 71}, {"referenceID": 3, "context": "PI with Large Patterns \u2208 W[5] when parameterized by k + r.", "startOffset": 26, "endOffset": 29}, {"referenceID": 3, "context": "We reduce the problem to MC(\u03a3\u22175,1), which is complete for W [5].", "startOffset": 60, "endOffset": 63}, {"referenceID": 3, "context": "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].", "startOffset": 59, "endOffset": 62}, {"referenceID": 5, "context": "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].", "startOffset": 68, "endOffset": 71}, {"referenceID": 3, "context": "This also places PI with Large Patterns somewhere between W[5] and W[8] [5].", "startOffset": 72, "endOffset": 75}, {"referenceID": 1, "context": "We note that the above formula could be converted into prenex form, giving a tighter containment, however the central observation is that it will be greater than W[2], in contrast to the hardness result and the containment of PI with Small Patterns.", "startOffset": 163, "endOffset": 166}, {"referenceID": 1, "context": "Pattern Identification \u2208 W[2] when n \u2264 f(k) \u00b7 log |I| where |I| is the overall size of the instance and f(k) is a computable function of the parameter.", "startOffset": 26, "endOffset": 29}, {"referenceID": 1, "context": "It is not clear that we retain W[2]-hardness in this case however, so we unfortunately do not obtain a W[2]-completeness result.", "startOffset": 32, "endOffset": 35}, {"referenceID": 1, "context": "It is not clear that we retain W[2]-hardness in this case however, so we unfortunately do not obtain a W[2]-completeness result.", "startOffset": 104, "endOffset": 107}, {"referenceID": 1, "context": "If we consider a variant of PI with Small Patterns where we relax the constraint on the number of patterns in the solution, it is easy to see that this problem is inW[2].", "startOffset": 166, "endOffset": 169}, {"referenceID": 1, "context": "Although PI with Small Patterns is W[2]-complete, the general problem is only W[2]-hard, and the containment of PI with Large Patterns simply gives a loose upper bound, although does suggest that the problem is harder than PI with Small Patterns.", "startOffset": 36, "endOffset": 39}, {"referenceID": 1, "context": "Although PI with Small Patterns is W[2]-complete, the general problem is only W[2]-hard, and the containment of PI with Large Patterns simply gives a loose upper bound, although does suggest that the problem is harder than PI with Small Patterns.", "startOffset": 79, "endOffset": 82}, {"referenceID": 2, "context": "The problem, intuitively, also shares some similarities with p-Hypergraph(Non)-Dominating-Set which is W[3]-complete [5].", "startOffset": 104, "endOffset": 107}, {"referenceID": 3, "context": "The problem, intuitively, also shares some similarities with p-Hypergraph(Non)-Dominating-Set which is W[3]-complete [5].", "startOffset": 117, "endOffset": 120}, {"referenceID": 2, "context": "p-ColoredHypergraph-(Non)-Dominating-Set however is W[3]-complete [5] and appears \u201charder\u201d than Pattern Identification, hence we conjecture:", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "p-ColoredHypergraph-(Non)-Dominating-Set however is W[3]-complete [5] and appears \u201charder\u201d than Pattern Identification, hence we conjecture:", "startOffset": 66, "endOffset": 69}, {"referenceID": 2, "context": "Pattern Identification is W[3]-complete when parameterized by k.", "startOffset": 27, "endOffset": 30}], "year": 2017, "abstractText": "We study the complexity of the problem of searching for a set of patterns that separate two given sets of strings. This problem has applications in a wide variety of areas, most notably in data mining, computational biology, and in understanding the complexity of genetic algorithms. We show that the basic problem of finding a small set of patterns that match one set of strings but do not match any string in a second set is difficult (NP-complete, W[2]hard when parameterized by the size of the pattern set, and APX-hard). We then perform a detailed parameterized analysis of the problem, separating tractable and intractable variants. In particular we show that parameterizing by the size of pattern set and the number of strings, and the size of the alphabet and the number of strings give FPT results, amongst others.", "creator": "LaTeX with hyperref package"}}}