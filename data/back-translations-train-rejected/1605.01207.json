{"id": "1605.01207", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-May-2016", "title": "Ontology-Mediated Queries: Combined Complexity and Succinctness of Rewritings via Circuit Complexity", "abstract": "We give solutions to two fundamental computational problems in ontology-based data access with the W3C standard ontology language OWL 2 QL: the succinctness problem for first-order rewritings of ontology-mediated queries (OMQs), and the complexity problem for OMQ answering. We classify OMQs according to the shape of their conjunctive queries (treewidth, the number of leaves) and the existential depth of their ontologies. For each of these classes, we determine the combined complexity of OMQ answering, and whether all OMQs in the class have polynomial-size first-order, positive existential, and nonrecursive datalog rewritings. We obtain the succinctness results using hypergraph programs, a new computational model for Boolean functions, which makes it possible to connect the size of OMQ rewritings and circuit complexity.", "histories": [["v1", "Wed, 4 May 2016 10:10:37 GMT  (152kb)", "http://arxiv.org/abs/1605.01207v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.CC", "authors": ["meghyn bienvenu", "stanislav kikot", "roman kontchakov", "vladimir podolskii", "michael zakharyaschev"], "accepted": false, "id": "1605.01207"}, "pdf": {"name": "1605.01207.pdf", "metadata": {"source": "CRF", "title": "Ontology-Mediated Queries: Combined Complexity and Succinctness of Rewritings via Circuit Complexity", "authors": ["MEGHYN BIENVENU", "MICHAEL ZAKHARYASCHEV"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 160 5.01 207v 1 [cs.D B] 4M ay2 01Keywords: Ontology-Based Data Access, Description Logic, Ontology-Mediated Query, Query Rewriting, Succinctness, Computational Complexity, Circuit Complexity."}, {"heading": "1 Introduction", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1.1 Ontology-based data access", "text": "In fact, it is as if most people are able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is as if they were able to identify themselves. (...) It is so. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (It is. (...) It is. (It is. (...) It is. (It is. (...) It is. (It is. (...) It is. (It is. (...) It is. (It is. (...) It is. (It is. () It is. (It is. (it is. (it is.) It is. (it is. (it is.). (it is. (it is. (it.). (it is. (it is. (it.). (it is. (it.) It is. (it is. (It is. (it.) It is. (it is.). (it is. (it is. (it.). (it is. (it is. (it.) It is. (it.). (it is. (it is.) It is. (it is. (it is. (it is.) It is. (it is. (it.). (it is."}, {"heading": "1.2 Succinctness and complexity", "text": "This paper deals with two basic theoretical problems, the solutions of which will explain the computational costs of answering OMQs with OWL2QL ontologies. The conciseness problem for FO paraphrases is to understand how difficult it is to construct FOrewritings for OMQs in a given class and, in particular, to determine whether OMQs in the class have polynomial FO paraphrases or not. In other words, the successiveness problem illustrates the computational costs of reducing OMQs when answering database queries. On the other hand, it is also important to measure the resources needed to answer OMQs by the best possible algorithm, not necessarily a reduction to database query evaluation. Therefore, we are interested in the combined complexity of the OMQ database, which is the answer to a problem: given an OMQ Q Q Q database Q = (T, q (x) from a given class of multiple A, and a constant of it."}, {"heading": "1.3 Results", "text": "In fact, we are able to behave in a way that we have done in the past."}, {"heading": "3 Tree-Witness Rewriting", "text": "Now we define a certain paraphrase of OWL2QL OMQs, which will play a key role in the conciseness and complexity analysis that will be included later in the work. This paraphrase is a modification of Kikot et al. [49] (cf. [57, 52, 51] for paraphrases based on similar ideas. We start with two simple observations that will help us remove unnecessary filth from the definitions. Each OWL2QL ontology T consists of two parts: T \u2212, which contains all sentences, \"and the rest, T +, which is consistent with each instance of data.\" For each subsequent procedure (z) \u2212 consider the Boolean CQ-z constellation (z). It is not difficult to see that for each OMQ (T, q (x) and data instance A, a multiple a is a specific response to (T, q (x)))."}, {"heading": "A similar result holds for PE- and FO-rewritings.", "text": "The proof that we replace A (x) and P (x) is an NDL rewrite of Q (x) over complete data instances (x). Denotet will replace the result, each predicate S by a fresh predicate S (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x), each (x, each (x), each (x), each (x), each (x), each (x, each (x), each (x), each (x), each (x, each (x), each (x), each (x), each (x, each (x), each (x), each (x), each (x, each (x), each (x), each (x), x, each (x), x, each (x), each (x, each (x), each (x), each (x), x (x), each (x (x), each (x), each (x (x), each (x (x), each (x), each (x (x), each (x), each (x), each (x (x), each (x (x), each (x (x), each (x (x), each (x), each (x (x), each (x), each (x (x), each (x (x), each (x)"}, {"heading": "4 OMQ Rewritings as Boolean Functions", "text": "For each OMQ Q (x) = (T, q (x)) we define the Boolean functions f-Q and f-Q as follows: - if f-Q is calculated by a Boolean formula (monotonous formula or monotonous circuit) \u03a6, then Q has a FO- (resp. PE or NDL-) description of the quantity O (| | q-Q |); - if q-Q is a FO- (PE- or NDL-) description of Q, then f-Q is calculated by a Boolean formula (resp. monotonous formula or monotonous circuit) of the quantity O (| q-Q |)."}, {"heading": "4.1 Hypergraph Functions", "text": "Leave H = (V, E) a hypergraph with branches v (V) V and hyperedges e (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q) Q (Q) Q) Q (Q) Q (Q) Q) Q (Q) Q (Q) Q (Q) Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q (Q) Q (Q) Q (Q) Q (Q) Q (Q (Q) Q) Q (Q (Q) Q) Q (Q) Q (Q (Q) Q (Q)) Q (Q (Q)) Q (Q (Q)) Q (Q (Q (Q)))) Q (Q (Q (Q))) Q (Q (Q))) Q (Q (Q (Q))) Q (Q (Q (Q)))) Q (Q (Q (Q)))) Q (Q (Q (Q (Q))))) Q (Q (Q (Q)) Q (Q (Q))))) Q (Q (Q (Q (Q (Q))"}, {"heading": "4.2 Primitive Evaluation Functions", "text": "To get lower limits on the size of paraphrases, we associate with each OMQ Q a third Boolean function f \u00b2 | Q, which describes the result of the evaluation of Q on data instances with a single individual constant. Let's make \u03b3 \u00b2 0, 1 \u00b2 n be a vector that gives every single or binary predicate Si in Q. We associate the data instanceA (\u03b3) = {DL (a) | -tuple of as. We call f \u00b2 Q the primitive evaluation function for Q. Theorem 6 (Pi) = 1} and set f \u00b2 Q (\u03b3) = 1 iff T, A (\u03b3) | = q (a), where a formula is the x | -tuple of as. We call f \u00b2 Q the primitive evaluation function for Q. Theorem 6. (i) If q \u00b2 is a (PE) FO paraphrase of Q, then f \u00b2 is a variable of Q, then f \u00b2."}, {"heading": "4.3 Hypergraph Programs", "text": "The next goal is to create a model of calculation for these functions.A hypergraph program (HGP) P is a hypergraph H = (V, E), whose vertices are each marked with 0, 1 or a letter above a list p1. (As usual, a hypergraph, l, is a propositional variable or its negation.) An input for P is a tuple \u03b1, 1) n, which is used as a rating for p1,.., pn. The output P (\u03b1) of P is 1 iff. There is an independent subset of E that covers all zeros - that is, contains all the texts in V, whose designation is 0. We say that P calculates an n-ary boolean function f if f)."}, {"heading": "5 OMQs, hypergraphs and monotone hypergraph programs", "text": "We now note a correspondence between the structure of OMQs and hypergraphs."}, {"heading": "5.1 OMQs with ontologies of depth 2", "text": "First, we show that each hypergraph H = (V, E) by a polynomial quantity OMQ QH = (T, q) with a depth of 2. With each hypergraph V (V, E) we associate a uniform predicate Av, and with each hyperedge E (X, Y) we associate a uniform predicate E (D, E). We define T as the set of the following axioms, for e, E (E, E). We also take the Boolean CQ q with variables yv, for v, V, and ze, for e, E (E, Y)."}, {"heading": "5.2 Hypergraphs of Degree 2 and OMQs with Ontologies of Depth 1", "text": "(...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...)) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...)) (...) (...) (...) (...) (...) (...) (...)) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...) (...)"}, {"heading": "5.3 Tree-Shaped OMQs and Tree Hypergraphs", "text": "We call an OMQ Q = (T, q) tree-shaped if the CQ q is tree-shaped. We now note a close correspondence between tree-shaped OMQs and tree-shaped hypergraphs, which are defined as follows. 11Suppose T = (VT, ET) is an (undirected) tree. A leaf is a Grade 1 vertex. A sub-tree T = (V \u2032 T, E \u2032 T) of T is called a tree hypergraph if there is a tree T = (VT, ET), so that V = ET and each hyperedge of E is a convex sub-tree T {u, v}. In this case, we call the hypergraph H = (V, E) a tree hypergraph if there is a tree T = (ET) and each hyperedge e of E is a convex sub-tree of T {u}."}, {"heading": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka", "text": "It is not as if it were a tree whose edges and corners are P (u, u) in the form P (u, u) in the form P (u) in the form P (u) in the form P (u) in the form P (u) in the form P (u) in the form P (u) in the form P (u) in the form P1 (u) in the form P1 (u) in the form P1 (u), Pn (u) n (u) n (n) in the form P (u) in the form P (u) in the form P1 (u), Pn (u) n (u) n (n), in the form 2) in the form P (u)."}, {"heading": "5.4 OMQs with Bounded Treewidth CQs and Bounded Depth Ontologies", "text": "Remember (e.g.), [29] that a tree decomposition of an undirected graph G = (V, E) is a pair (T, \u03bb), where T is an (undirected) tree, and a function consists of the set of nodes from T to 2V, so that for each v, V, there is a (contiguous) subtree of T (N); - for each e, E, there is a node N (N); - for each v, V, the nodes (N) induce a (contiguous) subtree of T. We call the set (N) a bag of N, V a bag of N. The width of a tree is the size of its largest bag minus one. The width of a tree G is the minimum width across all tree decompositions of G. The treewidth of a CQ is the treewidth of its Gap. Example."}, {"heading": "5.5 Summary", "text": "In Tables 1 and 2, we summarize the results of Section 5, which are used in Section 7 to obtain lower and upper limits for the size of OMQ paraphrases. Table 1 shows how theorems 8 and 10 (on the form of tree tree tree tree hypergraphs) are combined with sentence 2 (ii), and Theorem 12 provides us with hypergraph programs that calculate tree tree hypergraphs for OMQs. Table 2 contains the presentation results of theorems 7, 9, and 11, which show how abstract hypergraphs can be embedded in tree tree tree hypergraphs of OMQs."}, {"heading": "6 Hypergraph Programs and Circuit Complexity", "text": "In the previous section, we looked at how different classes of OMQs led to different classes of monotonous HGPs with non-uniform circuits, and how different classes led to different classes of monotonous HGPs with non-uniform circuits, and how different classes led to different classes of monotonous HGPs with non-uniform circuits."}, {"heading": "2, 44]:", "text": "It is the first one we acquire, which we will look at in the next section of Boolean at the top of HGPs and monotonous HGPs at the top of HGP3 and mHGP3 of Boolean at the top of HGP3 and mHGP3.Proof.We construct one that we construct in HGP3 and mHGP3.Proof.We construct one that we construct in HGP3 and mHGP3.Proof.We construct one that we construct in HGP3 and mHGP3.Proof.We construct one that we construct in HGP3 and mHGP3 and mHGP3. We construct one that we construct in HGP3 and mHGP3 and mHGP3.Proof.We construct one that we are not in HGP3 and mHGP3."}, {"heading": "6.3 NL/poly and THGP(\u2113)", "text": "It is not as if it is a. \"S\" S \"S, but a.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S. \"S.\" S \"S.\" S. \"S.\" S \"S.\" S. \"S.\" S \"S.\" S. \"S\" S. \"S.\" S. \"S\" S. \"S.\" S \"S\" S. \"S.\" S. \"S\" S \"S.\" S \"S\" S. \"S.\" S \"S.\" S \"S\" S \"S.\" S \"S\" S. \"S.\" S \"S.\" S. \"S\" S \"S\" S \"S\" S \"S\" S. \"S\" S. \"S\" S \"S\" S. \"S\" S \"S.\" S \"S\" S \"S.\" S. \"S.\" S \"S.\" S \"S\" S. \"S\" S \"S.\" S \"S\" S. \"S\" S \"S\" S. \"S\" S. \"S\" S \"S.\" S \"S.\" S \"S\" S \"S.\" S \"S\" S. \"S\" S \"S.\" S \"S\" S \"S\" S \"S"}, {"heading": "6.4 LOGCFL/poly and THGP", "text": "It is the only way we can imagine if we are able to show us that we have the maximum number of gates and the maximum number of gates in a path from C to G (it does not exceed d).Let Sn be the amount of and the depth of the gate in C we mean the maximum number of gates and the gate in a path from C to G (it does not exceed d).We denoteby left (g) and right (g) the sub-circuits of the gate in C."}, {"heading": "2 and, possibly, one subtree of size less than m and degree 1.", "text": "It is not the only way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in the way in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which way in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which we behave in which they behave in which they behave in which they behave in which they behave in which they behave in which they behave in which they behave and they behave in which they behave in which they behave in which they behave in which they behave in which they behave in which they behave in which they behave and they behave in which we"}, {"heading": "7 The Size of OMQ Rewritings", "text": "In this section, by OMQ = (T, q) we mean a sequence {Qn = (Tn, qn)} n < \u03c9 of OMQs whose size is in n polynomial; by a paraphrase q \u2032 of Q we mean a sequence {q \u2032 n} n < \u03c9, each q \u2032 n a paraphrase of Qn for n < \u03c9.By combining the results of the previous three sections and some well-known facts from circuit complexity, we obtain the upper and lower boundaries with respect to the size of PE, NDL and FOrewritings for various OMQ classes collected in Table 4, where Exp means an exponential lower boundary, > Poly a superpolynomial lower boundary, Poly-\u04454 a polynomial size, and 4 paraphrase (i.e. a PE paraphrase with the matrix of form and a mimic, which is observed in each case, is actually formed in the polynomial)."}, {"heading": "7.1 Rewritings for OMQs with ontologies of depth 2", "text": "According to Theorem 13, OMQs with ontologies of depth 2, PDL - any NP-complete monotonous Q function, in particular the function clique with n (n \u2212 1) / 2 variables ejj \u2032, 1 \u2264 j < j \u2032 NP \u2264 n, the 1 iff graph with wells {1,.., n \u00b2 and edges {{j, j \u2032} | ejj \u2032 = 1} contains a k-clique, for some fixed k. A series of essays begun by Razborov [64] gave an exponentially lower limit for the size of monotonous circuits that calculate clique, namely, 2,000 (n \u00b2) k \u00b2 (n / logn) depth. For monotonous formulas, an even better lower limit is known: 2\u0435 (k) for 2n / 3 [63]."}, {"heading": "7.2 Rewritings for OMQs with ontologies of depth 1", "text": "reD \"iSe,\" according to the author further, \"is able to locate oneself.\" reD \"iSe,\" according to the author further, \"is able to locate oneself.\" reD \"iSe,\" according to the author, \"is able to locate oneself.\" reD \"iSe,\" according to the author, \"iSe\" continues, \"\" iSe \"n.\" nreD \"iSe,\" according to the author, \"iSe\" n. \"reD\" iSe, \"\" \"\" iSe, \"\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\" \"\" \"\" \"\", \"\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\", \"\" \"\" \",\" \"\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\" \",\" \"\" \",\" \"\" \",\" \"\" \",\" \"\" \"\", \"\" \"\" \",\" \"\" \",\" \"\" \"\" \"\", \"\" \"\", \"\" \"\" \"\" \",\" \",\" \"\" \"\", \"\" \"\", \"\" \"\" \"\", \"\", \"\" \",\" \"\" \"\" \",\", \"\" \"\", \"\" \"\" \"\" \",\" \"\" \",\" \",\", \"\" \"\", \"\" \"\", \"\" \",\" \"\", \"\" \",\" \"\" \"\", \"\" \"\", \"\" \"\" \"\", \"\", \"\", \"\" \",\" \",\" \"\", \"\", \"\" \"\" \",\", \"\" \"\" \"\" \"\" \",\", \"\" \"\", \"\", \"\" \",\" \",\" \"\", \"\" \",\" \"\" \"\" \"\" \"\", \"\" \",\" \",\" \"\", \"\" \",\" \"\", \"\" \"\" \"\" \"\" \"\" \"\" \",\" \",\" \",\" \"\" \",\" \",\" \"\" \"\", \"\" \"\" \"\" \"\" \""}, {"heading": "7.3 Rewritings for tree-shaped OMQs with a bounded number of leaves", "text": "Since according to Theorem 16 the hypergraph function of a leaf-delimited Q = 1.0 Q can be calculated for all quadratic Q = 1.0 quadratic size NBP, we have: Theorem 25. For all fixed \u2265 2, all tree-shaped OMQs with at most leaves have the polynomial size NDL-rewritings. The superpolynomial size underlying them is demonstrated in exactly the same way as Theorem 23, to be more precise: Theorems 15 and 11 instead of Theorems 14 and 9. Theorem 26. However, there is an OMQ with ontologies of Depth 2 and linear CQs, whereby each PE circumscription is of superpolynomial size (logn). Our next result is similar to Theorem 24: Theorem 27. The following are equivalent: (1) There are polynomials of size FO-rewritings for all quadratic Qs with linear CQs and ontologies of depth."}, {"heading": "7.4 Rewritings for OMQs with PFSP and bounded treewidth", "text": "Since OMQs with the polynomial fundamental theorem property (PFSP, see section 3) and CQs with limited tree width can similarly be translated into monotonous THGPs and mTHGP = mLOGCFL / poly mP / poly, using theorem 1 and the fact that OMQs with limited depth enjoy the PFSP, we obtain the following: 1. The following OMQs have polynomial NDL rewritings: - OMQs with limited depth ontologies and limited tree width CQs (limited tree width OMQs); - OMQs with theorologies without axioms of form (x, y) \u2192 ritings (limited tree width OMQs and limited tree width CQs)."}, {"heading": "7.5 Rewritings for OMQs with ontologies of depth 1 and CQs of bounded treewidth", "text": "We finally reveal that the Polynomie PE-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-"}, {"heading": "8 Combined Complexity of OMQ answering", "text": "The size of OMQ paraphrases we have studied so far is critical to classical OBDA paraphrasing, which relies on a reduction to the standard database query evaluation (assuming that it is efficient in the real world). However, this type of response to OMQs may not be optimal, so understanding the size of OMQ paraphrases does not shed much light on how difficult the OMQ response actually is. On the other hand, responding to OMQs from the evidence of Theorem 23 by PE paraphrasing implies superpolynomial time, while the accessibility problem encoded by these OMQs is NL-complete."}, {"heading": "8.1 OMQs with bounded-depth ontologies", "text": "We start by showing that the LOGCFL space is only a limited space with the CQs machine. (...) We start by showing that the LOGCFL space is only a limited space. (...) We start by showing that the LOGCFL space is only a limited space. (...) We start by showing that the LOGCFL space is only a limited space. (...) We start by showing that the LOGCFL space is only a limited space. (...) We start from the assumption that the LOGCFL space is only a limited space. (...) We start from the assumption that the LOGCFL space is only a limited space. (...) We start from the assumption that the LOGCFL space is only a limited space. (...) We start from the assumption that the LOGCFL space is a limited space. (...) We start from the assumption that the LOGCFL space is only a limited space."}, {"heading": "NL [4].", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "8.2 OMQs with bounded-leaf CQs", "text": "It remains the case, the complexity of the answer to questions (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A). (A)."}, {"heading": "9 Conclusions and open problems", "text": "It is about the question whether and to what extent the people are able to move in the world and about the question to what extent they are able to move in the world. It is about the question to what extent they are able to move in the world and about the question to what extent they are able to move in the world and about the question to what extent they are in the world of the world and about the question to what extent they are able to move in the world. It is about the question to what extent they have to move in the world. It is about the question to what extent they are in the world of the world of the world. It is about the question to what extent they are in the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of the world of"}, {"heading": "A Proof of Theorem 5", "text": "Theorem 5 (i) For each OMQ Q (x), the formulas q (x) and q (x) are equivalent, and so q (x) is a PE paraphrase of the formula Q (x) over complete data instances. (ii) Theorem 4 is still valid for f \"Q\" replaced by f \"Q.Proof. Let's leave Q (x) = (T), q\" x \"(x) =\" y \"(x, y). We start by showing that for each tree t for Q (x), we have the following chain of equivalents:\" z, \"z\"), \"q\" t \"(z),\" c \"t.\""}, {"heading": "B Proof of Theorem 11", "text": "(ii) Any tree based on a tree is one (ii). (ii). (ii) Every tree is one (ii). (ii) Every tree is one (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). Every tree is one (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (ii). (i.). (i.). (i.). (i.). (i.). (i. (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.). (i.).). (i.). (i.). (i.). (i.).). (i.). (i.). (i.). (i.).). (i.). (i.).). (i.).). (i.). (i. (i.).). (i.).). (i.). (i.).). (i.). (i.). (i.).). (i.).). (i.).). (i.). (i.). (i.). (i.).). (i.).). (i.).). (i.). (i.). (i.).). (i.).). (i.).). (i.).). (i.).). (i.)"}, {"heading": "C Proof of Proposition 4", "text": "Sentence 4. (i) For each degree H tree hypergraph \u2264 d there is a monotone THGP of size O (| H |) that calculates fH and such that its hypergraph has degree \u2264 max (2, d). (ii) For each generalized THGP P via n variables there is a THGP P \u00b2 that calculates the same function and such that | P \u00b2 n \u00b7 P |. Proof. (i) Consider a hypergraph H = (V, E) based on a tree T = (VT, ET) with V = ET. We label each v \u00b2 V with a variable pv and choose some ve \u00b2 e for each e \u00b2 E, add fresh vertices ae and become T with edges {ve, ae} and {ae, be} as well as a new hyperedge e \u00b2 n \u00b2. (ve, be) to E. We label the segment [ve, ae] with P and the segment [ae, be] with pe."}, {"heading": "D Proof of Theorem 12", "text": "Theoretically, we cannot be more than N in T, and each of them is replaced by two. (...) Theoretically, we cannot be more. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we can be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...) Theoretically, we can be. (...) Theoretically, we cannot be. (...) Theoretically, we cannot be. (...)"}, {"heading": "E Proofs of Theorems 15 and 16", "text": "\"We are not in a position to find a solution.\" \"We are not in a position.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"We.\" \"\" We. \"\" We. \"\" \"We.\" \"\" We. \"\" \"We.\" \"\" \"We.\" \"\" We. \".\" \"\" We. \"\". \"\" We. \"\" \"\" We. \"\". \"\" \"We.\" \"\" \"We.\" \"\" \"We.\". \"\" \"\" We. \".\" \"\" We. \"\" \"\" We. \"\" \"\" We. \".\" \"\" We. \"\" \"\" We. \"\" \"\" We. \"\" \"\" We.. \"\" \"\" We. \"\" \""}, {"heading": "F Proof of Theorems 17 and 18", "text": "We assume that it will be a way in which we can reconstruct the circuit in such a way that the circuit for all i \u2264 d, the and depth of the circuit does not change and the size of the circuit does not change at most by a factor of 2n.Consider a U-circuit. (G) We show that we can reconstruct the circuit in such a way that the circuit for all i \u2264 n, the and depth of the circuit does not change and the circuit considers a U-circuit by a factor of 2n.Consider. (G) of C, take the outputs of C \u2032 s and gates into Sn. This with most duplications of the size of the circuit and ensures the property for Sn. Now we apply the production hypothesis to both. (G)"}, {"heading": "G Proofs for Section 7", "text": "It is not the first time that we have been able to establish a new system in which we are trying to establish a new system. (...) It is the first time that we are trying to establish a new system. (...) It is the second time that we are trying to establish a new system. (...) It is the second time that we are trying to establish a new system. (...) It is the second time that we are trying to establish a new system. (...) It is the second time that we are trying to establish a new system. (...) It is the third time that we are trying to establish a new system. (...) It is the second time that we are trying to establish a new system. (...) It is the first time that we are trying to establish a new system. (...) It is the third time that we are trying to establish a new system. (...) It is the third time that we are trying to establish a new system. (...) It is the third time that we are trying to establish a new system. (...) It is the third time that we are trying to establish a new system."}, {"heading": "H Proof of LOGCFL membership in Theorem 34", "text": "We say that an iteration of the while loop is successful if the BLQuery procedure is not wrong, especially if none of the control operations is wrong. The following properties can easily be considered by testing the BLQuery and direct induction: For each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z 7), each tuple (z), each tuple (z 7), each tuple (z) that we add to the border, no tuple of shape (z 7), n (z), z (z), can ever be added to the border."}, {"heading": "I Proof of LOGCFL-hardness in Theorem 34", "text": "= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ="}, {"heading": "13. M. Bienvenu, B. ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through", "text": "In the USA, USA, 1999. A. Bretto. Hypergraph Theory (AAI 2016). AAAI, 2016. 15. A. Brandstaedt, V. B. Le, and J. P. Spinrad. Graph Classes: A Survey. SIAM, Philadelphia, PA, USA, 1999. A. Bretto. Hypergraph Theory: An Introduction. Springer, 2013. 17. A. Cal. I, G. Gottlob, and T. Lukasiewicz. A general datalog-based framework for tractable queryanswering over. Journal of Web Semantics, 14."}, {"heading": "38. P. Hansen, C. Lutz, I. Seylan, and F. Wolter. Efficient query rewriting in the description logic EL", "text": "And beyond. In Proc. of the 24th Int. Conf. on Artificial Intelligence (IJCAI 2015), pages 3034-3040. AAAI, 2015. 39. D. A. Huffman. A method for the construction of minimum-redundancy codes. Proceedings of the Institute of Radio Engineers, 40 (9): 1098-1101, 1952. 40. N. Everman. Nondeterministic space is closed under complementation. SIAM J. Comput., 17 (5): 935-938, 1988. D. Johnson and A. C. Klug. Testing containment of conjunctive programs of conjunctive queries under functional and inclusion dependencies. Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164-169. ACM, 1982. 42. S. Jukna. Boolean Function Complexity - Advances and Frontiers, volume 27 of Algorithms and comatorics."}], "references": [{"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "The monotone circuit complexity of boolean functions", "author": ["N. Alon", "R. Boppana"], "venue": "Combinatorica, 7(1):1\u201322,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1987}, {"title": "Computational Complexity: A Modern Approach", "author": ["S. Arora", "B. Barak"], "venue": "Cambridge University Press, New York, NY, USA, 1st edition,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "The DL-Lite family and relations", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "Journal of Artificial Intelligence Research (JAIR), 36:1\u201369,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2009}, {"title": "A linear-time algorithm for testing the truth of certain quantified boolean formulas", "author": ["B. Aspvall", "M. Plass", "R. Tarjan"], "venue": "Information Processing Letters, 8(3):121\u2013123,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1979}, {"title": "Eliminating definitions and Skolem functions in first-order logic", "author": ["J. Avigad"], "venue": "ACM Transactions on Computational Logic, 4(3):402\u2013415,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "On rules with existential variables: Walking the decidability line", "author": ["J.-F. Baget", "M. Lecl\u00e8re", "M.-L. Mugnier", "E. Salvat"], "venue": "Artificial Intelligence, 175(9\u201310):1620\u20131654,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "Theoretically optimal datalog rewritings for owl 2 ql ontology-mediated queries", "author": ["M. Bienvenu", "S. Kikot", "R. Kontchakov", "V. Podolskii", "M. Zakharyaschev"], "venue": "CoRR, abs/1604.05258,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2016}, {"title": "First-order rewritability of atomic queries in horn description logics", "author": ["M. Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 754\u2013760. IJCAI/AAAI,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Regular path queries in lightweight description logics: Complexity and algorithms", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus"], "venue": "Journal of Artificial Intelligence Research (JAIR), 53:315\u2013374,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2015}, {"title": "Tractable queries for lightweight description logics", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus", "G. Xiao"], "venue": "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 768\u2013774. IJCAI/AAAI,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Query-based comparison of OBDA specifications", "author": ["M. Bienvenu", "R. Rosati"], "venue": "In Proc. of the 28th International Workshop on Description Logics (DL 2015), volume 1350 of CEUR Workshop Proceedings, pages 55\u201366. CEUR-WS,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "B", "author": ["M. Bienvenu"], "venue": "ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through disjunctive datalog, csp, and MMSNP. ACM Transasctions on Database Systems, 39(4):33:1\u201344,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Beyond OWL 2 QL in OBDA: rewritings and approximations", "author": ["E. Botoeva", "D. Calvanese", "V. Santarelli", "D.F. Savo", "A. Solimando", "G. Xiao"], "venue": "In Proc. of the AAAI Conf. on Artificial Intelligence (AAAI 2016). AAAI,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "Graph Classes: A Survey", "author": ["A. Brandst\u00e4dt", "V.B. Le", "J.P. Spinrad"], "venue": "SIAM, Philadelphia, PA, USA,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "Hypergraph Theory: An Introduction", "author": ["A. Bretto"], "venue": "Springer,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "A general datalog-based framework for tractable query answering over ontologies", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "T. Lukasiewicz"], "venue": "Journal of Web Semantics,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Towards more expressive ontology languages: The query answering problem", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "A. Pieris"], "venue": "Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "The MASTRO system for ontology-based data access", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodriguez-Muro", "R. Rosati", "M. Ruzzi", "D.F. Savo"], "venue": "Semantic Web, 2(1):43\u201353,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Tractable reasoning and efficient query answering in description logics: the DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning, 39(3):385\u2013429,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "Optimal implementation of conjunctive queries in relational data bases", "author": ["A. Chandra", "P. Merlin"], "venue": "In Conference Record of the 9th Annual ACM Symposium on Theory of Computing (STOC\u201977), pages 77\u201390. ACM,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1977}, {"title": "Conjunctive query containment revisited", "author": ["C. Chekuri", "A. Rajaraman"], "venue": "Theoretical Computer Science, 239(2):211\u2013229,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2000}, {"title": "Optimized query rewriting for OWL 2 QL", "author": ["A. Chortaras", "D. Trivela", "G. Stamou"], "venue": "In Proc. of CADE-23, volume 6803 of LNCS, pages 192\u2013206. Springer,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "A broad class of first-order rewritable tuple-generating dependencies", "author": ["C. Civili", "R. Rosati"], "venue": "In Proc. of the 2nd Int. Datalog 2.0 Workshop, volume 7494 of Lecture Notes in Computer Science, pages 68\u201380. Springer,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2012}, {"title": "Effective computation of maximal sound approximations of description logic ontologies", "author": ["M. Console", "J. Mora", "R. Rosati", "V. Santarelli", "D.F. Savo"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part II, volume 8797 of Lecture Notes in Computer Science, pages 164\u2013179. Springer,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2014}, {"title": "Characterizations of pushdown machines in terms of time-bounded computers", "author": ["S.A. Cook"], "venue": "Journal of the ACM, 18(1):4\u201318,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1971}, {"title": "Query rewriting for Horn-SHIQ plus rules", "author": ["T. Eiter", "M. Ortiz", "M. \u0160imkus", "T.-K. Tran", "G. Xiao"], "venue": "In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI 2012), pages 726\u2013733. AAAI,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2012}, {"title": "Hypergraphes arbor\u00e9s", "author": ["C. Flament"], "venue": "Discrete Mathematics, 21(3):223\u2013227,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1978}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Texts in Theoretical Computer Science. An EATCS Series. Springer,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2006}, {"title": "Optique: Zooming in on big data", "author": ["M. Giese", "A. Soylu", "G. Vega-Gorgojo", "A. Waaler", "P. Haase", "E. Jim\u00e9nez-Ruiz", "D. Lanti", "M. Rezk", "G. Xiao", "\u00d6. \u00d6z\u00e7ep", "R. Rosati"], "venue": "IEEE Computer, 48(3):60\u201367,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "The price of query rewriting in ontology-based data access", "author": ["G. Gottlob", "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "T. Schwentick", "M. Zakharyaschev"], "venue": "Artificial Intelligence, 213:42\u201359,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2014}, {"title": "Computing LOGCFL certificates", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "In Proc. of the 26th Int. Colloquium on Automata, Languages and Programming (ICALP-99), volume 1644 of Lecture Notes in Computer Science, pages 361\u2013371. Springer,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1999}, {"title": "The complexity of acyclic conjunctive queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of the ACM, 48(3):431\u2013498,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2001}, {"title": "Ontological queries: Rewriting and optimization", "author": ["G. Gottlob", "G. Orsi", "A. Pieris"], "venue": "In Proc. of ICDE 2011, pages 2\u201313. IEEE Computer Society,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2011}, {"title": "Rewriting ontological queries into small nonrecursive datalog programs", "author": ["G. Gottlob", "T. Schwentick"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 254\u2013263. AAAI,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2012}, {"title": "When is the evaluation of conjunctive queries tractable? In Proc", "author": ["M. Grohe", "T. Schwentick", "L. Segoufin"], "venue": "of the 33rd Annual ACM Symposium on Theory of Computing (STOC 2001), pages 657\u2013 666. ACM,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2001}, {"title": "Queries with negation and inequalities over lightweight ontologies", "author": ["V. Guti\u00e9rrez-Basulto", "Y. Ib\u00e1\u00f1ez-Gar\u0107\u0131a", "R. Kontchakov", "E.V. Kostylev"], "venue": "J. Web Sem., 35:184\u2013202,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2015}, {"title": "Efficient query rewriting in the description logic EL and beyond", "author": ["P. Hansen", "C. Lutz", "I. Seylan", "F. Wolter"], "venue": "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3034\u20133040. AAAI,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2015}, {"title": "A method for the construction of minimum-redundancy codes", "author": ["D.A. Huffman"], "venue": "Proceedings of the Institute of Radio Engineers, 40(9):1098\u20131101,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 1952}, {"title": "Nondeterministic space is closed under complementation", "author": ["N. Immerman"], "venue": "SIAM J. Comput., 17(5):935\u2013938,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 1988}, {"title": "Testing containment of conjunctive queries under functional and inclusion dependencies", "author": ["D.S. Johnson", "A.C. Klug"], "venue": "In Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164\u2013169. ACM,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 1982}, {"title": "Boolean Function Complexity \u2014 Advances and Frontiers, volume 27 of Algorithms and combinatorics", "author": ["S. Jukna"], "venue": "Springer,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2012}, {"title": "Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning", "author": ["M. Kaminski", "Y. Nenov", "B. Cuenca Grau"], "venue": "In Proc. of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), pages 1077\u20131083. AAAI,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2014}, {"title": "Monotone circuits for connectivity require super-logarithmic depth", "author": ["M. Karchmer", "A.Wigderson"], "venue": "In Proc. of the 20th Annual ACM Symposium on Theory of Computing (STOC", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1988}, {"title": "Ontology based access to exploration data at Statoil", "author": ["E. Kharlamov", "D. Hovland", "E. Jim\u00e9nez-Ruiz", "D. Lanti", "H. Lie", "C. Pinkel", "M. Rezk", "M.G. Skj\u00e6veland", "E. Thorstensen", "G. Xiao", "D. Zheleznyakov", "I. Horrocks"], "venue": "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), Part II, volume 9367 of Lecture Notes in Computer Science, pages 93\u2013112. Springer,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2015}, {"title": "How semantic technologies can enhance data access at Siemens Energy", "author": ["E. Kharlamov", "N. Solomakhina", "\u00d6.L. \u00d6z\u00e7ep", "D. Zheleznyakov", "T. Hubauer", "S. Lamparter", "M. Roshchin", "A. Soylu", "S. Watson"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 601\u2013619. Springer,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2014}, {"title": "Exponential lower bounds and separation for query rewriting", "author": ["S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev"], "venue": "In Proc. of the 39th Int. Colloquium on Automata, Languages and Programming (ICALP 2012), volume 7392 of Lecture Notes in Computer Science, pages 263\u2013274. Springer,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2012}, {"title": "On (in)tractability of OBDA with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 24th Int. Workshop on Description Logics (DL 2011), volume 745, pages 224\u2013234. CEUR-WS,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2011}, {"title": "Conjunctive query answering with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 275\u2013285. AAAI,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2012}, {"title": "Query rewriting for existential rules with compiled preorder", "author": ["M. K\u00f6nig", "M. Lecl\u00e8re", "M.-L. Mugnier"], "venue": "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3106\u2013 3112. AAAI Press,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2015}, {"title": "Sound, complete and minimal ucq-rewriting for existential rules", "author": ["M. K\u00f6nig", "M. Lecl\u00e8re", "M.-L. Mugnier", "M. Thomazo"], "venue": "Semantic Web, 6(5):451\u2013475,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2015}, {"title": "The combined approach to query answering in DL-Lite", "author": ["R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev"], "venue": "In Principles of Knowledge Representation and Reasoning: Proceedings of the 12th Int. Conf. KR 2010, pages 247\u2013257. AAAI Press,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2010}, {"title": "Answering SPARQL queries over databases under OWL 2 QL entailment regime", "author": ["R. Kontchakov", "M. Rezk", "M. Rodriguez-Muro", "G. Xiao", "M. Zakharyaschev"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 552\u2013567. Springer,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2014}, {"title": "XPath for DL ontologies", "author": ["E.V. Kostylev", "J.L. Reutter", "D. Vrgoc"], "venue": "In Proc. of the 29th AAAI Conference on Artificial Intelligence (AAAI 2015), pages 1525\u20131531. AAAI,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2015}, {"title": "Mapping analysis in ontology-based data access: Algorithms and complexity", "author": ["D. Lembo", "J. Mora", "R. Rosati", "D.F. Savo", "E. Thorstensen"], "venue": "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), volume 9366 of Lecture Notes in Computer Science, pages 217\u2013234. Springer,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2015}, {"title": "Elements Of Finite Model Theory", "author": ["L. Libkin"], "venue": "Springer,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2004}, {"title": "The complexity of conjunctive query answering in expressive description logics", "author": ["C. Lutz"], "venue": "In Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008), number 5195 in LNAI, pages 179\u2013193. Springer,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2008}, {"title": "Description logic tboxes: Model-theoretic characterizations and rewritability", "author": ["C. Lutz", "R. Piro", "F. Wolter"], "venue": "In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), pages 983\u2013988. IJCAI/AAAI,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2011}, {"title": "Kyrie2: query rewriting under extensional constraints in ELHIO", "author": ["J. Mora", "R. Rosati", "\u00d3. Corcho"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), volume 8796 of Lecture Notes in Computer Science, pages 568\u2013583. Springer,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2014}, {"title": "A comparison of query rewriting techniques for DLlite", "author": ["H. P\u00e9rez-Urbina", "B. Motik", "I. Horrocks"], "venue": "In Proc. of the 22nd Inte. Workshop on Description Logics (DL 2009), volume 477 of CEUR Workshop Proceedings. CEUR-WS,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2009}, {"title": "E", "author": ["H. P\u00e9rez-Urbina"], "venue": "Rod\u0155\u0131guez-D\u0131\u0301az, M. Grove, G. Konstantinidis, and E. Sirin. Evaluation of query rewriting approaches for OWL 2. In Proc. of SSWS+HPCSW 2012, volume 943 of CEUR Workshop Proceedings. CEUR-WS,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2012}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "Journal on Data Semantics, X:133\u2013173,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2008}, {"title": "Monotone circuits for matching require linear depth", "author": ["R. Raz", "A. Wigderson"], "venue": "Journal of the ACM, 39(3):736\u2013744,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1992}, {"title": "Lower bounds for the monotone complexity of some Boolean functions", "author": ["A. Razborov"], "venue": "Dokl. Akad. Nauk SSSR, 281(4):798\u2013801,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 1985}, {"title": "Lower bounds for deterministic and nondeterministic branching programs", "author": ["A.A. Razborov"], "venue": "In Proc. of the 8th Int. Symposium on Fundamentals of Computation Theory (FCT\u201991), volume 529 of Lecture Notes in Computer Science, pages 47\u201360. Springer,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 1991}, {"title": "High performance query answering over DL-Lite ontologies", "author": ["M. Rodriguez-Muro", "D. Calvanese"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 308\u2013318. AAAI,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2012}, {"title": "Ontology-based data access: Ontop of databases", "author": ["M. Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 12th Int. Semantic Web Conf. (ISWC 2013), volume 8218 of Lecture Notes in Computer Science, pages 558\u2013573. Springer,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2013}, {"title": "The limits of querying ontologies", "author": ["R. Rosati"], "venue": "In Proc. of the 11th Int. Conf. on Database Theory (ICDT 2007), volume 4353 of Lecture Notes in Computer Science, pages 164\u2013178. Springer,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2007}, {"title": "Prexto: Query rewriting under extensional constraints in DL-Lite", "author": ["R. Rosati"], "venue": "In Proc. of the 9th Extended Semantic Web Conf. (EWSC 2012), volume 7295 of Lecture Notes in Computer Science, pages 360\u2013374. Springer,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2012}, {"title": "Improving query answering over DL-Lite ontologies", "author": ["R. Rosati", "A. Almatelli"], "venue": "In Proc. of the 12th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2010), pages 290\u2013300. AAAI Press,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2010}, {"title": "OBDA: query rewriting or materialization? in practice, both! In Proc", "author": ["J.F. Sequeda", "M. Arenas", "D.P. Miranker"], "venue": "of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 535\u2013551. Springer,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2014}, {"title": "On the tape complexity of deterministic context-free languages", "author": ["I.H. Sudborough"], "venue": "Journal of the ACM, 25(3):405\u2013414,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 1978}, {"title": "The method of forced enumeration for nondeterministic automata", "author": ["R. Szelepcs\u00e9nyi"], "venue": "Acta Informatica, 26(3):279\u2013284,", "citeRegEx": "73", "shortCiteRegEx": null, "year": 1988}, {"title": "The complexity of relational query languages (extended abstract)", "author": ["M. Vardi"], "venue": "In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC\u201982), pages 137\u2013146. ACM,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 1982}, {"title": "Properties that characterize LOGCFL", "author": ["H. Venkateswaran"], "venue": "Journal of Computer and System Sciences, 43(2):380\u2013404,", "citeRegEx": "75", "shortCiteRegEx": null, "year": 1991}, {"title": "Introduction to Circuit Complexity: A Uniform Approach", "author": ["H. Vollmer"], "venue": "Springer,", "citeRegEx": "76", "shortCiteRegEx": null, "year": 1999}, {"title": "Algorithms for acyclic database schemes", "author": ["M. Yannakakis"], "venue": "In Proc. of the 7th Int. Conf. on Very Large Data Bases (VLDB), pages 82\u201394. IEEE Computer Society,", "citeRegEx": "77", "shortCiteRegEx": null, "year": 1981}, {"title": "Pagoda: Pay-as-you-go ontology query answering using a datalog reasoner", "author": ["Y. Zhou", "B. Cuenca Grau", "Y. Nenov", "M. Kaminski", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research (JAIR), 54:309\u2013 367,", "citeRegEx": "78", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 61, "context": "[62] with the aim of facilitating query answering over complex, possibly incomplete and heterogeneous data sources.", "startOffset": 0, "endOffset": 4}, {"referenceID": 61, "context": "[62], the OBDA system employs the ontology and mappings in order to transform the user query into a query over the data sources, and then delegates the actual query evaluation to the underlying database engines and triplestores.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[20] and later extended by Artale et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4], was specifically designed to ensure the existence of FO-rewritings for all conjunctive queries (CQs).", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 17, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 23, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 67, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 36, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 9, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 53, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 61, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 91, "endOffset": 95}, {"referenceID": 69, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 111, "endOffset": 119}, {"referenceID": 68, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 111, "endOffset": 119}, {"referenceID": 48, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 144, "endOffset": 148}, {"referenceID": 33, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 195, "endOffset": 199}, {"referenceID": 50, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 206, "endOffset": 210}, {"referenceID": 59, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 303, "endOffset": 307}, {"referenceID": 22, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 315, "endOffset": 319}, {"referenceID": 26, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 329, "endOffset": 333}, {"referenceID": 58, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 344, "endOffset": 348}, {"referenceID": 18, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 70, "endOffset": 74}, {"referenceID": 60, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 95, "endOffset": 99}, {"referenceID": 70, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 114, "endOffset": 118}, {"referenceID": 29, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 145, "endOffset": 149}, {"referenceID": 66, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 192, "endOffset": 200}, {"referenceID": 52, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 192, "endOffset": 200}, {"referenceID": 45, "context": "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.", "startOffset": 228, "endOffset": 232}, {"referenceID": 44, "context": "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.", "startOffset": 245, "endOffset": 249}, {"referenceID": 35, "context": "[36, 56] and references therein.", "startOffset": 0, "endOffset": 8}, {"referenceID": 55, "context": "[36, 56] and references therein.", "startOffset": 0, "endOffset": 8}, {"referenceID": 46, "context": "[47] and Gottlob and Schwentick [35].", "startOffset": 0, "endOffset": 4}, {"referenceID": 34, "context": "[47] and Gottlob and Schwentick [35].", "startOffset": 32, "endOffset": 36}, {"referenceID": 34, "context": "Gottlob and Schwentick [35] and Gottlob et al.", "startOffset": 23, "endOffset": 27}, {"referenceID": 30, "context": "[31] showed that PE- (and so all other) \u2018rewritings\u2019 can be made polynomial under the condition that all relevant data instances contain two special constants.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "NFAs vs DFAs, and [6]).", "startOffset": 18, "endOffset": 21}, {"referenceID": 48, "context": "Our starting point is the observation that the tree-witness PE-rewriting of an OMQ Q = (T , q) introduced by [49] defines a hypergraph whose vertices are the atoms in q and whose hyperedges correspond to connected sub-queries of q that can be homomorphically mapped to labelled nulls of some chases for T .", "startOffset": 109, "endOffset": 113}, {"referenceID": 19, "context": "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity\u2014that is, of the same complexity as standard CQ evaluation in databases.", "startOffset": 12, "endOffset": 19}, {"referenceID": 3, "context": "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity\u2014that is, of the same complexity as standard CQ evaluation in databases.", "startOffset": 12, "endOffset": 19}, {"referenceID": 47, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 60, "endOffset": 64}, {"referenceID": 76, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 21, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 31, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 55, "context": "We remind the reader [56] that, for any CQ q(x) = \u2203y \u03c6(x,y), any first-order structure I and any tuple a from its domain \u2206, we have I |= q(a) iff there is a map h : x \u222a y \u2192 \u2206 such that (i) if S(z) \u2208 q then I |= S(h(z)), and (ii) h(x) = a.", "startOffset": 21, "endOffset": 25}, {"referenceID": 76, "context": "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].", "startOffset": 57, "endOffset": 65}, {"referenceID": 10, "context": "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].", "startOffset": 57, "endOffset": 65}, {"referenceID": 0, "context": "Recall [1] that a datalog program, \u03a0 , is a finite set of Horn clauses \u2200x (\u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3m \u2192 \u03b30), where each \u03b3i is an atom P (x1, .", "startOffset": 7, "endOffset": 10}, {"referenceID": 0, "context": "As defined, FO- and PE-rewritings are not necessarily domain-independent queries, while NDL-rewritings are not necessarily safe [1].", "startOffset": 128, "endOffset": 131}, {"referenceID": 18, "context": "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large\u2014exponentially-large in the size of the original CQ, to be more precise.", "startOffset": 39, "endOffset": 43}, {"referenceID": 46, "context": "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large\u2014exponentially-large in the size of the original CQ, to be more precise.", "startOffset": 79, "endOffset": 83}, {"referenceID": 73, "context": "In complexity-theoretic terms, the focus should not only be on the data complexity of OMQ answering, which is an appropriate measure for database query evaluation (where queries are indeed usually small) [74], but also on the combined complexity that takes into account the contribution of ontologies and queries.", "startOffset": 204, "endOffset": 208}, {"referenceID": 48, "context": "[49] (cf.", "startOffset": 0, "endOffset": 4}, {"referenceID": 56, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 51, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 50, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 16, "context": "It is not hard to see that, for any OMQ (T , q(x)) and data instance A, a tuple a is a certain answer to (T , q(x)) over A iff either T ,A |= q(a) or T ,A |= \u2203z \u03c8(z), for some \u03c8(z) \u2192 \u22a5 in T \u2212; see [17] for more details.", "startOffset": 197, "endOffset": 201}, {"referenceID": 66, "context": "Such classes of data instances can be defined, for example, by the integrity constraints in the database schema and the mapping [67].", "startOffset": 128, "endOffset": 132}, {"referenceID": 0, "context": "As is well-known [1], every pair (T ,A) of an ontology T and data instance A possesses a canonical model (or chase) CT ,A such that T ,A |= q(a) iff CT ,A |= q(a), for all CQs q(x) and a in ind(A).", "startOffset": 17, "endOffset": 20}, {"referenceID": 66, "context": "[67] used the term \u2018H-completeness\u2019; see also [50].", "startOffset": 0, "endOffset": 4}, {"referenceID": 49, "context": "[67] used the term \u2018H-completeness\u2019; see also [50].", "startOffset": 46, "endOffset": 50}, {"referenceID": 40, "context": "\u033an with n \u2264 p(|Q|) [41, 17].", "startOffset": 19, "endOffset": 27}, {"referenceID": 16, "context": "\u033an with n \u2264 p(|Q|) [41, 17].", "startOffset": 19, "endOffset": 27}, {"referenceID": 30, "context": "(In general, the bounded derivation depth property of an ontology language is a necessary and sufficient condition of FO-rewritability [31].", "startOffset": 135, "endOffset": 139}, {"referenceID": 46, "context": "The class of all OMQs (even with ontologies of finite depth and tree-shaped CQs) does not have the PFSP [47].", "startOffset": 104, "endOffset": 108}, {"referenceID": 48, "context": "Theorem 2 ([49]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 2, "context": ", [3, 42]) that an n-ary Boolean function, for n \u2265 1, is any function from {0, 1} to {0, 1}.", "startOffset": 2, "endOffset": 9}, {"referenceID": 41, "context": ", [3, 42]) that an n-ary Boolean function, for n \u2265 1, is any function from {0, 1} to {0, 1}.", "startOffset": 2, "endOffset": 9}, {"referenceID": 27, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 14, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 15, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 28, "context": ", [29]) that a tree decomposition of an undirected graph G = (V,E) is a pair (T, \u03bb), where T is an (undirected) tree and \u03bb a function from the set of nodes of T to 2 such that \u2013 for every v \u2208 V , there exists a node N with v \u2208 \u03bb(N); \u2013 for every e \u2208 E, there exists a node N with e \u2286 \u03bb(N); \u2013 for every v \u2208 V , the nodes {N | v \u2208 \u03bb(N)} induce a (connected) subtree of T .", "startOffset": 2, "endOffset": 6}, {"referenceID": 0, "context": "A (bag) type is an m-tuple of the form w = (w[1], .", "startOffset": 45, "endOffset": 48}, {"referenceID": 2, "context": ", [3, 42].", "startOffset": 2, "endOffset": 9}, {"referenceID": 41, "context": ", [3, 42].", "startOffset": 2, "endOffset": 9}, {"referenceID": 75, "context": "LOGCFL/poly (also known as SAC) is the class of Boolean functions computable by polynomialsize and logarithmic-depth circuits in which and-gates have two inputs but or-gates can have arbitrarily many inputs (unbounded fan-in) and not-gates can only be applied to inputs of the circuit [76].", "startOffset": 285, "endOffset": 289}, {"referenceID": 63, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 1, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 43, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 41, "context": "We remind the reader (consult [42] for more details)", "startOffset": 30, "endOffset": 34}, {"referenceID": 72, "context": "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then \u00acf is also computable by a polynomial-size NBP.", "startOffset": 16, "endOffset": 24}, {"referenceID": 39, "context": "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then \u00acf is also computable by a polynomial-size NBP.", "startOffset": 16, "endOffset": 24}, {"referenceID": 4, "context": "We first provide a graph-theoretic characterisation of independent sets covering all zeros based on the implication graph [5].", "startOffset": 122, "endOffset": 125}, {"referenceID": 38, "context": "As shown by Huffman [39], there is a prefix binary code such that each Dj is encoded by a word of length \u2308log(m/mj)\u2309.", "startOffset": 20, "endOffset": 24}, {"referenceID": 63, "context": "A series of papers, started by Razborov [64], gave an exponential lower bound for the size of monotone circuits computing Clique, namely, 2 \u221a k)", "startOffset": 40, "endOffset": 44}, {"referenceID": 1, "context": "for k \u2264 14 (n/ logn) 2/3 [2].", "startOffset": 25, "endOffset": 28}, {"referenceID": 62, "context": "For monotone formulas, an even better lower bound is known: 2 for k = 2n/3 [63].", "startOffset": 75, "endOffset": 79}, {"referenceID": 43, "context": "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.", "startOffset": 12, "endOffset": 20}, {"referenceID": 41, "context": "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.", "startOffset": 12, "endOffset": 20}, {"referenceID": 64, "context": "Since f is NL/poly-complete under NC-reductions [65], we obtain NL/poly \u2286 NC.", "startOffset": 48, "endOffset": 52}, {"referenceID": 64, "context": "Since f is NL/polycomplete under NC-reductions [65], we obtain NL/poly \u2286 NC.", "startOffset": 47, "endOffset": 51}, {"referenceID": 0, "context": "4 except that in the definition of E i , instead of considering all types wk of Ni, we only use wk = (w[1], .", "startOffset": 103, "endOffset": 106}, {"referenceID": 47, "context": "[48] is based on a flawed proof.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 42, "endOffset": 46}, {"referenceID": 76, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 90, "endOffset": 94}, {"referenceID": 21, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 121, "endOffset": 129}, {"referenceID": 35, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 121, "endOffset": 129}, {"referenceID": 32, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 166, "endOffset": 170}, {"referenceID": 19, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 45, "endOffset": 49}, {"referenceID": 3, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 54, "endOffset": 57}, {"referenceID": 47, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 114, "endOffset": 118}, {"referenceID": 30, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 123, "endOffset": 127}, {"referenceID": 32, "context": "We begin by showing that the LOGCFL upper bound for CQs of bounded treewidth [33] is preserved even in the presence of ontologies of bounded depth.", "startOffset": 77, "endOffset": 81}, {"referenceID": 31, "context": "As LOGCFL is closed under L reductions [32] and evaluation of CQs of bounded treewidth is LOGCFL-complete, it suffices to show that CT ,A can be computed by an L-transducer (a deterministic logspace Turing machine with a LOGCFL oracle).", "startOffset": 39, "endOffset": 43}, {"referenceID": 3, "context": "Finally, as entailment in OWL2QL is in NL [4], each of the following problems can be decided by making a call to an NL (hence LOGCFL) oracle: \u2013 decide whether a\u033a1 .", "startOffset": 42, "endOffset": 45}, {"referenceID": 3, "context": "The possible choices for z0 include ind(A) and aw \u2208 \u2206CT ,A such that |w| \u2264 2|T |+ |q|, which are enough to find a homomorphism if it exists [4].", "startOffset": 140, "endOffset": 143}, {"referenceID": 3, "context": "Finally, it should be clear that the subroutine canMap(z, u) can also be implemented in NL [4].", "startOffset": 91, "endOffset": 94}, {"referenceID": 47, "context": "It remains to settle the complexity of answering OMQs with arbitrary ontologies and boundedleaf CQs, for which neither the upper bounds from the preceding subsection nor the NP lower bound by [48] are applicable.", "startOffset": 192, "endOffset": 196}, {"referenceID": 25, "context": "An NAuxPDA [26] is a non-deterministic Turing machine with an additional work tape constrained to operate as a pushdown store.", "startOffset": 11, "endOffset": 15}, {"referenceID": 71, "context": "[72] showed that LOGCFL coincides with the class of problems that can be solved by NAuxPDAs running in logarithmic space and polynomial time (note that the space on the pushdown tape is not subject to the logarithmic space bound).", "startOffset": 0, "endOffset": 4}, {"referenceID": 74, "context": "The proof of LOGCFL-hardness is by reduction of the following problem: decide whether an input of length n is accepted by the nth circuit of a logspace-uniform family of SAC circuits, which is known to be LOGCFL-hard [75].", "startOffset": 217, "endOffset": 221}, {"referenceID": 32, "context": "This problem was used by [33] to show LOGCFLhardness of evaluating tree-shaped CQs.", "startOffset": 25, "endOffset": 29}, {"referenceID": 32, "context": "Following [33], we assume without loss of generality that the considered SAC circuits adhere to the following normal form: \u2013 fan-in of all and-gates is 2; \u2013 nodes are assigned to levels, with gates on level i only receiving inputs from gates on level i\u2212 1, the input gates on level 1 and the output gate on the greatest level; \u2013 the number of levels is odd, all even-level gates are or-gates, and all odd-level non-input gates are and-gates.", "startOffset": 10, "endOffset": 14}, {"referenceID": 32, "context": "It is well known [33, 75] that a circuit in normal form accepts an input \u03b1 iff there is a labelled rooted tree (called a proof tree) such that \u2013 the root node is labelled with the output and-gate; \u2013 if a node is labelled with an and-gate gi and gi = gj \u2227 gk, then it has two children labelled with gj and gk, respectively; \u2013 if a node is labelled with an or-gate gi and gi = gj1 \u2228 .", "startOffset": 17, "endOffset": 25}, {"referenceID": 74, "context": "It is well known [33, 75] that a circuit in normal form accepts an input \u03b1 iff there is a labelled rooted tree (called a proof tree) such that \u2013 the root node is labelled with the output and-gate; \u2013 if a node is labelled with an and-gate gi and gi = gj \u2227 gk, then it has two children labelled with gj and gk, respectively; \u2013 if a node is labelled with an or-gate gi and gi = gj1 \u2228 .", "startOffset": 17, "endOffset": 25}, {"referenceID": 32, "context": "The reduction [33], which is for presentation purposes reproduced here with minor modifications, encodes C and \u03b1 in the database and uses a Boolean tree-shaped CQ based on the skeleton proof tree.", "startOffset": 14, "endOffset": 18}, {"referenceID": 32, "context": "We point out that membership in LOGCFL implies that answering OMQs from the identified tractable classes can be \u2018profitably parallelised\u2019 (for details, consult [33]).", "startOffset": 160, "endOffset": 164}, {"referenceID": 7, "context": "In fact, much more work is required to construct NDL-rewritings that can be evaluated in LOGCFL and NL, which will be done in a follow-up publication; see technical report [8].", "startOffset": 172, "endOffset": 175}, {"referenceID": 66, "context": "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.", "startOffset": 92, "endOffset": 100}, {"referenceID": 52, "context": "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.", "startOffset": 92, "endOffset": 100}, {"referenceID": 65, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 68, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 54, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 11, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 57, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 8, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 12, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 42, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 37, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 13, "context": "Ideally, one would show that the simpler ontology is equivalent to the original with regards to query answering [14], and thus provides the exact set of answers.", "startOffset": 112, "endOffset": 116}, {"referenceID": 24, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 90, "endOffset": 98}, {"referenceID": 13, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 90, "endOffset": 98}, {"referenceID": 77, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 208, "endOffset": 212}, {"referenceID": 3, "context": "Without loss of generality we may choose h so that the image of h consists of elements aw with |w| \u2264 2|T |+ |q| [4].", "startOffset": 112, "endOffset": 115}, {"referenceID": 32, "context": "Since C accepts input \u03b1 iff there is a homomorphism h from q to D(\u03b1) [33], it suffices to show that there exists a homomorphism f from q\u2032 to CT\u03b1,A iff there is a homomorphism h from q to D(\u03b1):", "startOffset": 69, "endOffset": 73}], "year": 2016, "abstractText": "We give solutions to two fundamental computational problems in ontologybased data access with the W3C standard ontology language OWL2QL: the succinctness problem for first-order rewritings of ontology-mediated queries (OMQs), and the complexity problem for OMQ answering. We classify OMQs according to the shape of their conjunctive queries (treewidth, the number of leaves) and the existential depth of their ontologies. For each of these classes, we determine the combined complexity of OMQ answering, and whether all OMQs in the class have polynomial-size first-order, positive existential, and nonrecursive datalog rewritings. We obtain the succinctness results using hypergraph programs, a new computational model for Boolean functions, which makes it possible to connect the size of OMQ rewritings and circuit complexity.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}