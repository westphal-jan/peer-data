{"id": "1605.04263", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-May-2016", "title": "OBDA Constraints for Effective Query Answering (Extended Version)", "abstract": "In Ontology Based Data Access (OBDA) users pose SPARQL queries over an ontology that lies on top of relational datasources. These queries are translated on-the-fly into SQL queries by OBDA systems. Standard SPARQL-to-SQL translation techniques in OBDA often produce SQL queries containing redundant joins and unions, even after a number of semantic and structural optimizations. These redundancies are detrimental to the performance of query answering, especially in complex industrial OBDA scenarios with large enterprise databases. To address this issue, we introduce two novel notions of OBDA constraints and show how to exploit them for efficient query answering. We conduct an extensive set of experiments on large datasets using real world data and queries, showing that these techniques strongly improve the performance of query answering up to orders of magnitude.", "histories": [["v1", "Fri, 13 May 2016 17:29:28 GMT  (552kb)", "https://arxiv.org/abs/1605.04263v1", null], ["v2", "Mon, 16 May 2016 09:21:26 GMT  (569kb)", "http://arxiv.org/abs/1605.04263v2", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["dag hovland", "davide lanti", "martin rezk", "guohui xiao"], "accepted": false, "id": "1605.04263"}, "pdf": {"name": "1605.04263.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Dag Hovland", "Davide Lanti", "Martin Rezk", "Guohui Xiao"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 160 5.04 263v 2 [cs.D B] 16 M"}, {"heading": "1 Introduction", "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "2 Preliminaries", "text": "We assume that the reader will be familiar with relational algebra and SQL queries, as well as ontological languages, and in particular with the OWL 2 / 3 profile. (D) D (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s) s (D) s (D) s) s (D) s (D) s) s (D) s) s (D) s (D) s (D) s (D) s (D) s (D) s) s (D) s (D) s) s (D) s (D) s) s (D) s (D) s) s (D) s (D) s) s (D) s (D) s (D) s (D) s) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s (D) s) s (D) s) s (D) s (D) s) s (D) s (D) s (D) s) s (D) s (D) s (D) s (D) s (D) s (D) s"}, {"heading": "3 SPARQL Query Answering in OBDA", "text": "In this section, we describe the typical steps that an OBDA system takes to answer SPARQL questions and discuss performance challenges. To do this, we select the representative status-of-the-art OBDA system Ontop and discuss its functionality in detail.During its launch, Ontop classifies the ontology, \"compils\" the ontology into the mappings that generate a saturated RDF graphic.Formally, given a basic OBDA specification S = (T, M), the MT mappings are T mappings for S, if, for each OBDA instance O = (S, D), GO = G."}, {"heading": "4 OBDA Constraints", "text": "We will now formalize two properties via an OBDA instance: exact predicates and virtual functional dependencies. We will then add a constraint component to the OBDA specification and determine that all instances of the specification have such properties. We will show how this additional constraint component can be used to identify and remove redundant connections and connections from the unfolded queries. From now on, O = (S, D) shall be an OBDA instance of a specification S = (T, M, \u03a3)."}, {"heading": "4.1 Exact Predicates in an OBDA Instance", "text": "In real-world scenarios, it often happens that axioms in ontology do not enrich the responses to queries. Often, this is due to storage strategies that are not available to the OBDA system. This fact leads to redundant connections in the generated SQL, as shown in Example 7. However, in this section we will show how certain properties defined on the mappings and the 3, i.e., individuals in the class: Wellbore 4 Materializing the SQL in the mappings is not an option since the schema is fixed. 8 Dag Hovland1, Davide Lanti2, Martin Rezk2 and Guohui Xiao2predicates, ideally derived from such constraints, can be used to reduce the number of redundant unions in the generated SQL queries for a given OBDA instance."}, {"heading": "4.2 Functional Dependencies in an OBDA instance", "text": "Remember that in database theory a functional dependency (abbr. FD) is an expression of the form x \u2192 y, read x functionally determines y where x and y tuples of attributes are. We say that x \u2192 y is satisfied with an attribute if x R and y R are actually satisfied. Finally, x \u2192 y is satisfied with a relationship I to R, if x \u2192 y is satisfied with R and for all tuples u, v I, if the value u [x] of x in u is equal to the value v [x] of x in v, then u [y] = v [y]. Whenever R is clear from the context, let's just say that x \u2192 y is satisfied with I.A virtual functional dependency, intuitively describes a functional dependence on a saturated virtual RDF graph. We identify two types of virtual functional dependencies: - Branch VFD: This dependency describes the relationship between an object and a set of functional properties that provide information about that object."}, {"heading": "4.3 Enriching the OBDA Specification with Constraints", "text": "We propose to enrich the traditional OBDA specification with a constraint component so that the OBDA system can perform an improved optimization, as described in the previous section. Formally, an OBDA specification with constraints is a tuple of Sconstr = (S, C), where S is an OBDA specification, and C is a set of exact mappings, exact predicates, optimization of virtual functional dependencies, and optimization of class expressions. An instance of Sconstr is an OBDA instance of S that implies the constraints in C. Our intention is to be able to use more of the constraints that exist in real query optimization databases, as we often see that these cannot be expressed by existing database constraints (i.e. keys). Since S does not necessarily imply C, verification of the validity of C can take into account more information than just S. The constraints may be used by, for example, external tools such as by directives of the system below."}, {"heading": "5 Experiments", "text": "This year, most of them are not even able to play by the rules."}, {"heading": "6 Related work", "text": "However, our work does not relate to ontologies or databases, and their dependencies are not intended to optimize queries. There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF (taking ontology into account) do not necessarily correspond to a VFD. Furthermore, this work does not address the problem of SQL query optimization. The concept of perfect figure [8] is strongly related to the concept of exact imaging. However, there is one major difference: a perfect imaging must be conditioned by the OBDA specification, while exact images represent additional constraints that enrich the OBDA specification."}, {"heading": "7 Conclusions", "text": "In this paper, we presented two novel optimization techniques for OBDA that complement the standard optimizations in this area and enable efficient SPARQL queries to answer business data. We laid the theoretical foundations for these techniques OBDA Constraints for Effective Query Answering (Extended Version) 15 based on two novel OBDA constraints: virtual functional dependencies and exact predicates. We implemented these techniques into our OBDA system Ontop and demonstrated their effectiveness empirically through extensive experiments that demonstrated improvements in query execution time up to orders of magnitude. Recognition. This work is partially supported by the EU within the framework of the IP project Optique (Scalable End-User Access to Big Data), funding agreement n. FP7-318338."}, {"heading": "A Appendix", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "A.1 Background On SPARQL to SQL", "text": "In this section we recapitulate the complete SPARQL (P1, P2) solution (P2, P3, P3) solution (P3, P3, P3, P3) solution (P3, P3, P5, P5) solution (P4, P5, P5) solution (P3, P4) solution (P3, P4) solution (P6, P6, P6, P6, P6, P6, P7, P7, P7, P7, P6, P6, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P7, P3) solution (P3, P3, P3) solution (P3, P3, P3, P3) solution (P3, P3, P3, P3, P3, P3) solution (P3, P3, P3, P3, P3) solution (P3, P3, P3, P3, P5) solution (P5) solution (P4, P4, P4, P4, P4, P4, P5, P4, P5, P5, P5, P5, P5, P5, P5"}, {"heading": "A.2 Proofs of Section 4.1", "text": "Sentence 1: Let M \u2032 be exact for predicate A in T. Let M \u2032 T be the result of replacing all mappings that define A in MT with M \u2032. Then GO = G ((\u2205, M \u2032 T, \u03a3), D). Proof (sketch). After defining T mappings, we have GO = G \u2205, MT, D. For all predicates except A, MT and M \u2032 T produce the same set of triples, since the mappings that define them are identical. For predicate A, since M \u2032 in O is exact, MT and M \u2032 T also produce the same set of triples. Hence G \u2205, MT, D = G \u2205, M \u2032 T, D."}, {"heading": "A.3 Proofs of Section 4.2", "text": "Let P1,.., Pn properties in T be such that for each 1 \u2264 i < n, tid = t 1 d. Then the VFD is t1d 7 \u2192 b P1. < Pn is met in O if and only if for each 1 \u2264 i \u2264 n, the FD xi \u2192 yi on sqli (zi) D.Proof. t1d 7 \u2192 b P1. < Pn is met in GO m (definition 3) if the FD t1d: 1 \u2264 i \u2264 n: (s, o), the FD GO i GO (s, o \u2032)."}, {"heading": "Results and Proofs for PATH VFDs", "text": "In the episode, the VFD is t1d 7 \u2192 p P1. \u2212 pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp # pnp"}, {"heading": "Proofs for Main Results", "text": "Theorem 1: Let \u03b2 be an optimizable BGP w.r.t. td x P1 =. Pn (x = b, p) in O. Let \u03c0v / t1d, v1 / t 1 r,..., vn / t n r sql\u03b2 be the SQL translation of \u03b2 as explained in Section 3. Let sql \u2032 \u03b2 = sql1 (x1, y1., yn). Then sql D \u03b2 and sql \u2032 D \u03b2 return the same answers.Proof. Assumption that p P1... Pn. The evidence for the branching of functional dependencies is analogous. From the definition of triple patterns and the definition of cyql \u2032 D \u03b2 it follows that the BGP \u03b2 is: (\u03c0v0, v1fic / subj) p P1..."}, {"heading": "A.4 Lifting Basic OBDA Instance Assumption", "text": "We show that the \"basic OBDA Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q"}, {"heading": "A.5 Wisconsin Benchmark", "text": "This benchmark is designed to systematically evaluate database performance with respect to different query characteristics. It comes with a schema that is designed to quickly understand the structure of each table and the distribution of each attribute, allowing you to easily construct queries that are very difficult to evaluate. It also comes with a data generator that populates the schema. Unlike EPDS, the benchmark database contains synthetic data that allows a wide range of queries to be made. For example, in EPDS it is very difficult to specify a selection."}, {"heading": "A.6 Experiments Material and Tools", "text": "All material related to the Wisconsin experiment, as well as the tools used to find exact mappings and virtual functional dependencies, can be found at https: / / github.com / ontop / ontop-examples / tree / master / ruleml-2016."}], "references": [{"title": "editors", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "The Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press, 2nd edition,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "The implication problem for data dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "In Proc. of ICALP, volume 115 of LNCS, pages 73\u201385. Springer,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1981}, {"title": "Tractable queries for lightweight description logics", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus", "G. Xiao"], "venue": "In Proc. of IJCAI. IJCAI/AAAI,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "JAR, 39(3):385\u2013429,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2007}, {"title": "Semantic query optimization in expert systems and database systems", "author": ["U.S. Chakravarthy", "D.H. Fishman", "J. Minker"], "venue": "In Proc. of DEXA, pages 659\u2013674,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1986}, {"title": "R2RML: RDB to RDF mapping language", "author": ["S. Das", "S. Sundara", "R. Cyganiak"], "venue": "W3C Recommendation, W3C, Sept.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "The wisconsin benchmark: Past, present, and future", "author": ["D.J. DeWitt"], "venue": "In J. Gray, editor, The Benchmark Handbook. Morgan Kaufmann,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1993}, {"title": "Optimizing query rewriting in ontology-based data access", "author": ["F. Di Pinto", "D. Lembo", "M. Lenzerini", "R. Mancini", "A. Poggi", "R. Rosati", "M. Ruzzi", "D.F. Savo"], "venue": "In Proc. of EDBT, pages 561\u2013572. ACM Press,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "and C", "author": ["B. Glim"], "venue": "Ogbuji. SPARQL 1.1 entailment regimes. W3C Recommendation, W3C, Mar.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "The price of query rewriting in ontology-based data access", "author": ["G. Gottlob", "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "T. Schwentick", "M. Zakharyaschev"], "venue": "AIJ, 213:42\u201359,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Using conditional functional dependency to discover abnormal data in RDF graphs", "author": ["B. He", "L. Zou", "D. Zhao"], "venue": "In Proc. of SWIM, pages 43:1\u201343:7. ACM,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "OBDA constraints for effective query answering (extended version)", "author": ["D. Hovland", "D. Lanti", "M. Rezk", "G. Xiao"], "venue": "CoRR Technical Report abs/1605.04263, arXiv.org e-Print archive,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2016}, {"title": "Exponential lower bounds and separation for query rewriting", "author": ["S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev"], "venue": "In Proc. of ICALP, pages 263\u2013274. Springer,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Conjunctive query answering with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of KR, pages 275\u2013285,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Answering SPARQL queries over databases under OWL 2 QL entailment regime", "author": ["R. Kontchakov", "M. Rezk", "M. Rodriguez-Muro", "G. Xiao", "M. Zakharyaschev"], "venue": "In Proc. of ISWC, volume 8796 of LNCS, pages 552\u2013567. Springer,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "The NPD benchmark: Reality check for OBDA systems", "author": ["D. Lanti", "M. Rezk", "G. Xiao", "D. Calvanese"], "venue": "In Proc. of EDBT,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "kyrie2: Query rewriting under extensional constraints in elhio", "author": ["J. Mora", "R. Rosati", "O. Corcho"], "venue": "In Proc. of ISWC, pages 568\u2013583,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2014}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. on Data Semantics, X:133\u2013173,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Ontology-based data access: Ontop of databases", "author": ["M. Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of ISWC, volume 8218 of LNCS, pages 558\u2013573. Springer,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2013}, {"title": "Efficient SPARQL-to-SQL with R2RML mappings", "author": ["M. Rodriguez-Muro", "M. Rezk"], "venue": "J. of Web Semantics,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2015}, {"title": "Prexto: Query rewriting under extensional constraints in DL-Lite", "author": ["R. Rosati"], "venue": "In Proc. of ESWC, pages 360\u2013374,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2012}, {"title": "Improving query answering over DL-Lite ontologies", "author": ["R. Rosati", "A. Almatelli"], "venue": "In Proc. of KR, pages 290\u2013300,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2010}, {"title": "Reasoning about functional dependencies generalized for semantic data models", "author": ["G.E. Weddell"], "venue": "ACM Trans. Database Syst., 17(1):32\u201364, Mar.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1992}, {"title": "Extending functional dependency to detect abnormal data in RDF graphs", "author": ["Y. Yu", "J. Heflin"], "venue": "In Proc. of ISWC, volume 7031, pages 794\u2013809. Springer, October", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 17, "context": "1 Introduction In Ontology Based Data Access (OBDA) [18], the complexity of data storage is hidden by a conceptual layer on top of an existing relational database (DB).", "startOffset": 52, "endOffset": 56}, {"referenceID": 12, "context": "A wellknown theoretical result is that the size of the translation is worst-case exponential in the size of the input query [13].", "startOffset": 124, "endOffset": 128}, {"referenceID": 15, "context": "These worst-case scenarios are not only theoretical, but they also occur in real-world applications, as shown in [16], where some user SPARQL queries are translated into SQL queries containing thousands of join and union operators.", "startOffset": 113, "endOffset": 117}, {"referenceID": 18, "context": "This is mainly due to (i) SPARQL queries containing joins of ontological terms with rich hierarchies, which lead to redundant unions [19]; and (ii) reifications of n-ary relations in the database into triples over the RDF data model, which lead to SQL translations containing several (mostly redundant) self-joins.", "startOffset": 133, "endOffset": 137}, {"referenceID": 18, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 97, "endOffset": 104}, {"referenceID": 19, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 97, "endOffset": 104}, {"referenceID": 4, "context": "The standard solutions to tackle this problem are based on semantic and structural optimizations [19,20] originally from the database area [5].", "startOffset": 139, "endOffset": 142}, {"referenceID": 3, "context": "To simplify the notation we express OWL 2 QL axioms by their description logic counterpart DLLiteR [4].", "startOffset": 99, "endOffset": 102}, {"referenceID": 0, "context": "Semantics for entailment of assertions (|=) in OWL 2 QL KBs is given through Tarski-style interpretations in the usual way [1].", "startOffset": 123, "endOffset": 126}, {"referenceID": 3, "context": "The task of query answering in OWL 2 QL (DL-LiteR) can be addressed by query rewriting techniques [4].", "startOffset": 98, "endOffset": 101}, {"referenceID": 13, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 21, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 2, "context": "Many rewriting techniques have been proposed in the literature [14,22,3].", "startOffset": 63, "endOffset": 72}, {"referenceID": 8, "context": "SPARQL [9] is a W3C standard language designed to query RDF graphs.", "startOffset": 7, "endOffset": 10}, {"referenceID": 14, "context": "To ease the presentation of the technical development, in the rest of this paper we adopt the OWL 2 QL entailment regime for SPARQL query answering [15], but disallow complex class/property expressions in the query.", "startOffset": 148, "endOffset": 152}, {"referenceID": 14, "context": "This restriction can be lifted with the help of a standard query rewriting step [15].", "startOffset": 80, "endOffset": 84}, {"referenceID": 18, "context": "During its start-up, Ontop classifies the ontology, \u201ccompiles\u201d the ontology into the mappings generating the so-called T -mappings [19], and removes redundant mappings by using inclusion dependencies (e.", "startOffset": 131, "endOffset": 135}, {"referenceID": 9, "context": "[10]), and phases (d) and (e) because they are straightforward.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "As a result, the unfolded SQL queries cannot be efficiently handled by DB engines [16].", "startOffset": 82, "endOffset": 86}, {"referenceID": 22, "context": "The next example shows, similarly as in [23], that general path VFDs cannot be expressed as a combination of path VFDs of length 1.", "startOffset": 40, "endOffset": 44}, {"referenceID": 5, "context": "We also assume that queries sqli(zi) always contain a filter expression of the form \u03c3notNull(xi ,yi), even if we do not specify it explicitly in the examples, since URIs cannot be generated from nulls [6].", "startOffset": 201, "endOffset": 204}, {"referenceID": 6, "context": "In the appendix we ran additional controlled experiments using an OBDA benchmark built on top of the Wisconsin benchmark [7], and obtain similar results to the ones here.", "startOffset": 121, "endOffset": 124}, {"referenceID": 12, "context": "This situation triggered the introduction of OBDA in Statoil in the context of the Optique project [13].", "startOffset": 99, "endOffset": 103}, {"referenceID": 1, "context": "6 Related work Dependencies have been intensively studied in the context of traditional relational databases [2].", "startOffset": 109, "endOffset": 112}, {"referenceID": 22, "context": "Our work is related to the one in [23]; in particular their notion of path functional dependency is close to the notion of path VFD presented here.", "startOffset": 34, "endOffset": 38}, {"referenceID": 23, "context": "There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF do not necessarily correspond to a VFD (when considering the ontology).", "startOffset": 64, "endOffset": 71}, {"referenceID": 10, "context": "There are a number of studies on functional dependencies in RDF [24,11], but as shown in Example 12, functional dependencies in RDF do not necessarily correspond to a VFD (when considering the ontology).", "startOffset": 64, "endOffset": 71}, {"referenceID": 7, "context": "The notion of perfect mapping [8] is strongly related to the notion of exact mapping.", "startOffset": 30, "endOffset": 33}, {"referenceID": 20, "context": "The notion of EBox [21,17] was proposed as an attempt to include constraints in OBDA.", "startOffset": 19, "endOffset": 26}, {"referenceID": 16, "context": "The notion of EBox [21,17] was proposed as an attempt to include constraints in OBDA.", "startOffset": 19, "endOffset": 26}], "year": 2016, "abstractText": "In Ontology Based Data Access (OBDA) users pose SPARQL queries over an ontology that lies on top of relational datasources. These queries are translated on-the-fly into SQL queries by OBDA systems. Standard SPARQL-to-SQL translation techniques in OBDA often produce SQL queries containing redundant joins and unions, even after a number of semantic and structural optimizations. These redundancies are detrimental to the performance of query answering, especially in complex industrial OBDA scenarios with large enterprise databases. To address this issue, we introduce two novel notions of OBDA constraints and show how to exploit them for efficient query answering. We conduct an extensive set of experiments on large datasets using real world data and queries, showing that these techniques strongly improve the performance of query answering up to orders of magnitude.", "creator": "LaTeX with hyperref package"}}}