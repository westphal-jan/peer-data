{"id": "1606.00561", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Jun-2016", "title": "Mining Software Components from Object-Oriented APIs", "abstract": "Object-oriented Application Programing Interfaces (APIs) support software reuse by providing pre-implemented functionalities. Due to the huge number of included classes, reusing and understanding large APIs is a complex task. Otherwise, software components are admitted to be more reusable and understandable entities than object-oriented ones. Thus, in this paper, we propose an approach for reengineering object-oriented APIs into component-based ones. We mine components as a group of classes based on the frequency they are used together and their ability to form a quality-centric component. To validate our approach, we experimented on 100 Java applications that used Android APIs.", "histories": [["v1", "Thu, 2 Jun 2016 07:08:01 GMT  (615kb,D)", "http://arxiv.org/abs/1606.00561v1", null]], "reviews": [], "SUBJECTS": "cs.SE cs.AI", "authors": ["anas shatnawi", "abdelhak seriai", "houari sahraoui", "zakarea al-shara"], "accepted": false, "id": "1606.00561"}, "pdf": {"name": "1606.00561.pdf", "metadata": {"source": "CRF", "title": "Mining Software Components from Object-Oriented APIs", "authors": ["Anas Shatnawi", "Abdelhak Seriai", "Houari Sahraoui", "Zakarea Al-Shara"], "emails": ["alshara@lirmm.fr", "sahraoui@iro.umontreal.ca"], "sections": [{"heading": null, "text": "Keywords: Reuse \u00b7 Reusability \u00b7 Component \u00b7 API \u00b7 Object-oriented \u00b7 Reengineering \u00b7 Mining \u00b7 Understandability \u00b7 Frequent usage patterns."}, {"heading": "1 Introduction", "text": "In this context, it should be noted that the solution to problems that have arisen in the past is not a solution, but a solution that is capable of bringing about a solution."}, {"heading": "2 Putting Problem in Context", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 The Goal: Object to Component", "text": "This year, it has reached the stage where it will be able to take the lead in order to achieve the objectives I have mentioned."}, {"heading": "2.3 Component and Frequent Usage Pattern", "text": "FUPs are observations based on the analysis of past uses of APIs. They aim to help users of APIs by identifying recurring patterns composed of classes that are often shared. FUPs and components meet reuse needs in two ways. Components are units that can be directly reused and integrated into software applications, while FUPs are guidelines for reuse, not units for reuse. In addition, components and FUPs are structurally different. In terms of specification characteristics, classes that make up a component serve as a coherent package of services, while classes that make up a FUP can be associated with different services. In terms of autonomy characteristics, the dependencies of component classes are largely internal in nature, forming an autonomous entity."}, {"heading": "3 The Proposed Solution Foundations", "text": "Based on the observations in the previous sections, we consider the following: - In object-oriented APIs, a component is identified as a group of classes. - In order to transform the entire object-oriented API into a component-based one, each class of the API is mapped as part of at least one component. Each class is mapped either as a class of component interfaces or as part of the internal classes of the component. - Classes that software clients directly access represent end-user services. These classes form FUPs. These are the candidates for the provided interface of components that have been removed from the API. - Since a FUP can consist of classes that provide multiple services, its classes can be mapped as part of different component interfaces. - A class of an API can be part of multiple FUPs and participate in the implementation of multiple services."}, {"heading": "4 Identification of component interfaces", "text": "Classes that form an API component are identified by identifying classes that form the provided interfaces of that component. Classes that form these interfaces are those that the clients of the API directly access. Classes that belong to the same interface are those that are often used together, so they are identified by common usage patterns. Classes of the API that compile common usage patterns are identified by analyzing how API classes were used by the API clients."}, {"heading": "4.1 Extracting Transactions of Usage", "text": "A usage transaction is a series of interactions between an API and a client of that API. These interactions consist of calling methods, accessing attributes, inheriting, or creating an instance object based on an API class. They are identified by static analysis of the source code of the API and its clients. Transactions differ depending on the choice of API clients. Therefore, the choice of API clients directly influences the type of resulting patterns. A client can be considered either as a class, a group of classes, or the entire software application. To this end, we define a client as a group of classes that form a functional component in software applications. The idea is to find patterns related to functionalities that compose the applications."}, {"heading": "4.2 Mining Frequent Usage Patterns of Classes", "text": "In the previous step, the interactions of all client components with the API are identified as transactions. Based on these transactions, we identify FUPs. A FUP is a set of API classes that are often shared by client components. Itallows the detection of hidden usage correlations between classes in the API. We look for FUPs based on the FPGrowth algorithm [18]. In this algorithm, a pattern is considered to be common when it reaches a predefined interest boundary. This parameter is known as support. Support refers to the probability of finding a set of API classes in transactions. Using the Support metric separates the classes of the API into two groups, depending on whether they belong to at least one FUP or not. Classes that do not belong to any of the identified FUPs are the less commonly used classes. As each API class that belongs to a transaction is a class that is accessed by the clients, the classes that form the API must be included in each of the classes, hence the classes that form the least part of the API."}, {"heading": "4.3 Identifying Classes Composing Component Interfaces from Frequent Usage Patterns", "text": "Each FUP is divided into a group of groups, each group representing a component interface. Classes are grouped according to three heuristics that measure the likelihood that a set of classes is part of the same interface. The third heuristics is the lexical similarity between these classes based on the textual names of the classes, their methods, and their attributes. Based on the above heuristics, we propose a fitness function that is given below to measure the ability of a group of classes to form a component interface. We use LCC metric [19] to measure the cohesion of a group of classes, their methods, and their attributes."}, {"heading": "5 API as Library of Components", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5.1 Identifying Classes Composing Components", "text": "This means that API classes that form a component, in terms of their direct or indirect structural and behavioral dependencies, are identified with the classes that form the provided interfaces of the component. In other words, we begin to form the group of classes that form the interfaces, and then we add more classes to form a component based on the component quality measurement model. Classes that have either direct or indirect links to the interface classes represent the candidate classes that are added to them. In each step, we add a new API class, which is selected based on the quality value of the component by adding this class to those already selected. The class that maximizes the quality value is selected in this step."}, {"heading": "5.2 Organizing API as Layers of Components", "text": "As we have already mentioned, the API is structured in N layers of components. To identify components of layer L, we rely on components of layer L \u2212 1. We proceed similarly to identify the components of the first layer. We use required interfaces of components that have already been identified in layer L \u2212 1 to identify the interfaces provided by components of layer L. This continues until a layer in which the components either do not require or require already identified interfaces. Any interface that is defined as required for a component of layer L \u2212 1 is provided as being provided by a component of layer L, except those provided by the already identified components. All interfaces provided in layer L are grouped in clusters to identify those provided by the same component of layer L \u2212 1. The clusters are set as by a hierarchical cluster algorithm obtained by the already identified components. All interfaces provided in layer L are grouped into clusters to identify those provided by the same component of layer L \u2212 1. The clusters are set up as a hierarchical cluster algorithm (this group of algorithms, this algorithm uses the similarity function of classes ii), each of which forms a coherency function (the classes ii)."}, {"heading": "6 Experimentation and Results", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "6.1 Experimental Design", "text": "The average size of these applications in terms of the number of classes is 90. Application names are listed in the Appendix. These applications are related to the definition and management of user interfaces. The second API is that of the 361 classes. This API provides services related to the creation and management of user interfaces. The second API is the 361 classes. This API provides services related to the creation and management of user interfaces."}, {"heading": "6.2 Results", "text": "This year, it is at an all-time high in the history of the European Union."}, {"heading": "7 Related work", "text": "The first approach aims to identify components from OO software applications; the second aims to identify common patterns of API usage. Numerous approaches have been presented in terms of identifying software components from source code. Garcia et al. provide an overview of some of these approaches. [22] Detten et al. presented the Archimetrix approach, which aims to explore the architecture of outdated software. It relies on a cluster algorithm that divides the system classes into components."}, {"heading": "8 Conclusion and Future Work", "text": "This means that components are identified based on classes that compose their interfaces. Classes that compose the provided interface of the first layer components result in FUPs. We have tested our approach by applying it to a set of open source Java applications as customers for three android APIs. Results show that our approach determines the reusability of the API. How our approach is applied depends on the quality and number of uses of the API. This means that the identified FUPs rely on the software clients under consideration. Identification of the provided interfaces and then their corresponding components depend on the API clients. Consequently, it is essential to provide customers with the largest number of uses of the API. Our future work will focus on migrating the identified OO components to existing models such as OSGIDS."}], "references": [{"title": "Software reuse research: status and future", "author": ["W. Frakes", "K. Kang"], "venue": "IEEE Transactions on Software Engineering. 31(7), 529\u2013536", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Useful, but usable? factors affecting the usability of apis", "author": ["M. Zibran", "F. Eishita", "C. Roy"], "venue": "18th Working Conf. on Reverse Engineering (WCRE), pp. 151\u2013155.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "What should developers be aware of? an empirical study on the directives of api documentation", "author": ["M. Monperrus", "M. Eichberg", "E. Tekes", "M. Mezini"], "venue": "Empirical Software Engineering. 17(6), 703\u2013737", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Usage patterns of the java standard api", "author": ["H. Ma", "R. Amor", "E. Tempero"], "venue": "13th Asia Pacific Software Engineering Conf. (APSEC), pp. 342\u2013352.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2006}, {"title": "Temporal analysis of api usage concepts", "author": ["G. Uddin", "B. Dagenais", "M.P. Robillard"], "venue": "Proc. of the 2012 Inter. Conf. on Software Engineering (ICSE), pp. 804\u2013814. IEEE Press, Piscataway, NJ, USA", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2012}, {"title": "Mining succinct and high-coverage api usage patterns from source code", "author": ["J. Wang", "Y. Dang", "H. Zhang", "K. Chen", "T. Xie", "D. Zhang"], "venue": "Proc. of the 10th Working Conf. on Mining Software Repositories (MSR), pp. 319\u2013328. IEEE Press, Piscataway, NJ, USA", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "Documenting apis with examples: Lessons learned with the apiminer platform", "author": ["J. Montandon", "H. Borges", "D. Felix", "M. Valente"], "venue": "20th Working Conf. on Reverse Engineering (WCRE), pp. 401\u2013408.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Detecting missing method calls in objectoriented software", "author": ["M. Monperrus", "M. Bruch", "M. Mezini"], "venue": "European Conf. on Object-Oriented Programming ECOOP. LNCS, vol. 6183, pp. 2\u201325. Springer, Heidelberg", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Patterns of knowledge in api reference documentation", "author": ["W. Maalej", "M. Robillard"], "venue": "IEEE Transactions on Software Engineering. 39(9), 1264\u20131282", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Component Software: Beyond Object-Oriented Programming", "author": ["C. Szyperski"], "venue": "Pearson Education", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2002}, {"title": "Quality-centric approach for software component identification from object-oriented code", "author": ["S. Kebir", "A.D. Seriai", "S. Chardigny", "A. Chaoui"], "venue": "Joint Working IEEE/IFIP Conf. and European Conf. on Software Architecture (WICSA)/(ECSA), pp. 181\u2013190.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "From object-oriented applications to component-oriented applications via component-oriented architecture", "author": ["S. Allier", "S. Sadou", "H. Sahraoui", "R. Fleurquin"], "venue": "9th Working IEEE/IFIP Conf. on Software Architecture (WICSA), pp. 214\u2013223.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2011}, {"title": "Composition Environments for Deployable Software Components", "author": ["C. L\u00fcer", "A. Van Der Hoek"], "venue": "Citeseer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2002}, {"title": "Component-Based Software Engineering: Putting the Pieces Together", "author": ["G.T. Heineman", "W.T. Councill"], "venue": "Addison-Wesley Reading", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2001}, {"title": "Extraction of componentbased architecture from object-oriented systems", "author": ["S. Chardigny", "A. Seriai", "M. Oussalah", "D. Tamzalit"], "venue": "7th Working IEEE/IFIP Conf. on Software Architecture (WICSA), pp. 285\u2013288.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "Software Engineering \u2013 Product Quality \u2013 Part 1: Quality Model", "author": ["ISO"], "venue": "Technical Report ISO/IEC 9126-1, International Organization for Standardization", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2001}, {"title": "Search-based extraction of component-based architecture from object-oriented systems", "author": ["S. Chardigny", "A.D. Seriai", "M. Oussalah", "D. Tamzalit"], "venue": "2nd European Conf. in Software Architecture (ECSA). LNCS, vol. 5292, pp. 322\u2013325. Springer, Heidelberg", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2008}, {"title": "Data mining: concepts and techniques", "author": ["J. Han", "M. Kamber", "J. Pei"], "venue": "Morgan kaufmann", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "Cohesion and reuse in an object-oriented system", "author": ["J.M. Bieman", "B.K. Kang"], "venue": "Proc. of the 1995 Symposium on Software Reusability (SSR), pp. 259\u2013262. ACM, New York, NY, USA", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1995}, {"title": "The conceptual coupling metrics for object-oriented systems", "author": ["D. Poshyvanyk", "A. Marcus"], "venue": "22nd IEEE Inter. Conf. on Software Maintenance (ICSM), pp. 469\u2013478.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "A comparative analysis of software architecture recovery techniques", "author": ["J. Garcia", "I. Ivkovic", "N. Medvidovic"], "venue": "IEEE/ACM 28th Inter. Conf. on Automated Software Engineering (ASE), pp. 486\u2013496.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2013}, {"title": "Reengineering component-based software systems with archimetrix", "author": ["M. Von Detten", "M.C. Platenius", "S. Becker"], "venue": "Software & Systems Modeling 13(4), 1239\u20131268", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Extracting and facilitating architecture in service-oriented software systems", "author": ["R. Weinreich", "C. Miesbauer", "G. Buchgeher", "T. Kriechbaum"], "venue": "Joint Working IEEE/IFIP Conf. and European Conf. on Software Architecture (WICSA)/(ECSA), pp. 81\u201390.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2012}, {"title": "Mining reusable software components from objectoriented source code of a set of similar software", "author": ["A. Shatnawi", "A.D. Seriai"], "venue": "IEEE 14th Inter. Conf. on Information Reuse and Integration (IRI), pp. 193\u2013200.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2013}, {"title": "Automated api property inference techniques", "author": ["M. Robillard", "E. Bodden", "D. Kawrykow", "M. Mezini", "T. Ratchford"], "venue": "IEEE Transactions on Software Engineering. 39(5), 613\u2013637", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Fruit: Ide support for framework understanding", "author": ["M. Bruch", "T. Sch\u00e4fer", "M. Mezini"], "venue": "Proc. of the 2006 OOPSLA Workshop on Eclipse Technology eXchange, pp. 55\u2013 59. ACM, New York, NY, USA", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2006}, {"title": "Synthesizing api usage examples", "author": ["R.P.L. Buse", "W. Weimer"], "venue": "Proc. of the 2012 Inter. Conf. on Software Engineering (ICSE), pp. 782\u2013792. IEEE Press, Piscataway, NJ, USA", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "Nowadays, the development of large and complex software applications is based on reusing pre-existing functionalities instead of developing them from scratch [1, 2].", "startOffset": 158, "endOffset": 164}, {"referenceID": 1, "context": "Nowadays, the development of large and complex software applications is based on reusing pre-existing functionalities instead of developing them from scratch [1, 2].", "startOffset": 158, "endOffset": 164}, {"referenceID": 0, "context": "Application Programming Interfaces (APIs) are recognized as the most commonly used repositories supporting software reuse [1].", "startOffset": 122, "endOffset": 125}, {"referenceID": 1, "context": "APIs provide a preimplemented, tested and high quality set of functionalities [2, 3].", "startOffset": 78, "endOffset": 84}, {"referenceID": 2, "context": "APIs provide a preimplemented, tested and high quality set of functionalities [2, 3].", "startOffset": 78, "endOffset": 84}, {"referenceID": 1, "context": "Consequently, they increase software quality and reduce the effort spent on coding, testing and maintenance activities [2].", "startOffset": 119, "endOffset": 122}, {"referenceID": 3, "context": "000 classes, is not an easy task [4, 5].", "startOffset": 33, "endOffset": 39}, {"referenceID": 4, "context": "000 classes, is not an easy task [4, 5].", "startOffset": 33, "endOffset": 39}, {"referenceID": 5, "context": "Consequently, several approaches have been proposed, such as [6\u20138], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.", "startOffset": 61, "endOffset": 66}, {"referenceID": 6, "context": "Consequently, several approaches have been proposed, such as [6\u20138], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.", "startOffset": 61, "endOffset": 66}, {"referenceID": 7, "context": "Consequently, several approaches have been proposed, such as [6\u20138], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.", "startOffset": 61, "endOffset": 66}, {"referenceID": 8, "context": "These are used as guides for reusing API classes and are not themselves reusable entities [9].", "startOffset": 90, "endOffset": 93}, {"referenceID": 9, "context": "Otherwise, software components are admitted to be more reusable and understandable entities than Object-Oriented (OO) ones [10].", "startOffset": 123, "endOffset": 127}, {"referenceID": 10, "context": "Consequently many approaches have been proposed to identify components from OO software applications such as [11, 12].", "startOffset": 109, "endOffset": 117}, {"referenceID": 11, "context": "Consequently many approaches have been proposed to identify components from OO software applications such as [11, 12].", "startOffset": 109, "endOffset": 117}, {"referenceID": 9, "context": "Based on [10, 13, 14], we consider a component as, \u201ca software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model\u201d.", "startOffset": 9, "endOffset": 21}, {"referenceID": 12, "context": "Based on [10, 13, 14], we consider a component as, \u201ca software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model\u201d.", "startOffset": 9, "endOffset": 21}, {"referenceID": 13, "context": "Based on [10, 13, 14], we consider a component as, \u201ca software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model\u201d.", "startOffset": 9, "endOffset": 21}, {"referenceID": 10, "context": "Identifying Components in Software Applications : Synthesis of Previous Work We have proposed in our previous works related to ROMANTIC4 approach [11, 15] a set of metrics to measure the ability of a group of classes in a software application to form a component.", "startOffset": 146, "endOffset": 154}, {"referenceID": 14, "context": "Identifying Components in Software Applications : Synthesis of Previous Work We have proposed in our previous works related to ROMANTIC4 approach [11, 15] a set of metrics to measure the ability of a group of classes in a software application to form a component.", "startOffset": 146, "endOffset": 154}, {"referenceID": 15, "context": "Similar to the software quality model ISO 9126 [16], we proposed to refine the characteristics of the component into sub-characteristics.", "startOffset": 47, "endOffset": 51}, {"referenceID": 10, "context": "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.", "startOffset": 91, "endOffset": 99}, {"referenceID": 14, "context": "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.", "startOffset": 91, "endOffset": 99}, {"referenceID": 16, "context": "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.", "startOffset": 138, "endOffset": 142}, {"referenceID": 17, "context": "are frequently used together by customers [18].", "startOffset": 42, "endOffset": 46}, {"referenceID": 17, "context": "We mine FUPs based on the FPGrowth algorithm [18].", "startOffset": 45, "endOffset": 49}, {"referenceID": 18, "context": "We use LCC metric [19] to measure the cohesion of a set of classes, Conceptual Coupling metric [20] to measure classes\u2019 lexical similarity and Support metric to measure the association frequency of a set of classes.", "startOffset": 18, "endOffset": 22}, {"referenceID": 19, "context": "We use LCC metric [19] to measure the cohesion of a set of classes, Conceptual Coupling metric [20] to measure classes\u2019 lexical similarity and Support metric to measure the association frequency of a set of classes.", "startOffset": 95, "endOffset": 99}, {"referenceID": 0, "context": "Where E is a set of OO classes; LCC(E) is the Cohesion of E ; CC(E) is Conceptual Coupling of E ; S(E) is the Support of E ; and \u03bb1, \u03bb2, \u03bb3 are weight values, situated in [0-1].", "startOffset": 171, "endOffset": 176}, {"referenceID": 17, "context": "To answer the second question that related to the reusability, we use theK\u2212fold cross validation method [18].", "startOffset": 104, "endOffset": 108}, {"referenceID": 20, "context": "provide a survey of some of these approaches [21].", "startOffset": 45, "endOffset": 49}, {"referenceID": 21, "context": "In [22], Detten et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 10, "context": "In [11], Kebir et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "In [12] Allier et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 22, "context": "proposed, in [23], an approach to recover multi-view architecture model of software applications implemented based on service oriented architecture.", "startOffset": 13, "endOffset": 17}, {"referenceID": 23, "context": "In [24], an approach has been presented to mine reusable components from a set of similar software applications.", "startOffset": 3, "endOffset": 7}, {"referenceID": 24, "context": "provide a survey of these approaches [25].", "startOffset": 37, "endOffset": 41}, {"referenceID": 6, "context": "[7, 5]), supporting the documentation of APIs (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 4, "context": "[7, 5]), supporting the documentation of APIs (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 6, "context": "[7, 6]), or improving the bug detection task (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 5, "context": "[7, 6]), or improving the bug detection task (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 7, "context": "[8]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7, 6]), while other ones mine unordered patterns (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 5, "context": "[7, 6]), while other ones mine unordered patterns (e.", "startOffset": 0, "endOffset": 6}, {"referenceID": 7, "context": "[8, 26]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 25, "context": "[8, 26]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 6, "context": "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.", "startOffset": 17, "endOffset": 23}, {"referenceID": 5, "context": "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.", "startOffset": 17, "endOffset": 23}, {"referenceID": 25, "context": "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.", "startOffset": 96, "endOffset": 100}, {"referenceID": 25, "context": "[26]), clustering algorithms (e.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "[6]) or a heuristic defined by the authors such as [7, 8].", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[6]) or a heuristic defined by the authors such as [7, 8].", "startOffset": 51, "endOffset": 57}, {"referenceID": 7, "context": "[6]) or a heuristic defined by the authors such as [7, 8].", "startOffset": 51, "endOffset": 57}, {"referenceID": 4, "context": "used Principle Component Analysis with Clustering algorithm [5], and Buse and Weimer combined the clustering algorithm with their own proposed heuristic [27].", "startOffset": 60, "endOffset": 63}, {"referenceID": 26, "context": "used Principle Component Analysis with Clustering algorithm [5], and Buse and Weimer combined the clustering algorithm with their own proposed heuristic [27].", "startOffset": 153, "endOffset": 157}], "year": 2016, "abstractText": "Object-oriented Application Programing Interfaces (APIs) support software reuse by providing pre-implemented functionalities. Due to the huge number of included classes, reusing and understanding large APIs is a complex task. Otherwise, software components are admitted to be more reusable and understandable entities than object-oriented ones. Thus, in this paper, we propose an approach for reengineering objectoriented APIs into component-based ones. We mine components as a group of classes based on the frequency they are used together and their ability to form a quality-centric component. To validate our approach, we experimented on 100 Java applications that used Android APIs.", "creator": "TeX"}}}