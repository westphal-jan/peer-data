{"id": "1606.01930", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jun-2016", "title": "Consistency and Trust in Peer Data Exchange Systems", "abstract": "We propose and investigate a semantics for \"peer data exchange systems\" where different peers are related by data exchange constraints and trust relationships. These two elements plus the data at the peers' sites and their local integrity constraints are made compatible via a semantics that characterizes sets of \"solution instances\" for the peers. They are the intended -possibly virtual- instances for a peer that are obtained through a data repair semantics that we introduce and investigate. The semantically correct answers from a peer to a query, the so-called \"peer consistent answers\", are defined as those answers that are invariant under all its different solution instances. We show that solution instances can be specified as the models of logic programs with a stable model semantics. The repair semantics is based on null values as used in SQL databases, and is also of independent interest for repairs of single databases with respect to integrity constraints.", "histories": [["v1", "Mon, 6 Jun 2016 20:26:42 GMT  (1436kb,D)", "http://arxiv.org/abs/1606.01930v1", "To appear in Theory and Practice of Logic Programming (TPLP). It includes appendix that will be published only in electronic format"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming (TPLP). It includes appendix that will be published only in electronic format", "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["leopoldo bertossi", "loreto bravo"], "accepted": false, "id": "1606.01930"}, "pdf": {"name": "1606.01930.pdf", "metadata": {"source": "CRF", "title": "Consistency and Trust in Peer Data Exchange Systems", "authors": ["LEOPOLDO BERTOSSI", "LORETO BRAVO"], "emails": ["bertossi@scs.carleton.ca", "bravo@udd.cl"], "sections": [{"heading": "To appear in Theory and Practice of Logic Programming (TPLP).", "text": "Key concepts: peer data exchange, response set programs, disjunctive stable model semantics, metadata management, schema mappings, relational databases, integrity limitations, database repairs, consistency."}, {"heading": "1 Introduction", "text": "A Peer Data Exchange System (PDES) (also known as Peer Data Management System) can be conceived as a finite set P = {P1,..., Pn} of peers, each of whom has a local relationship scheme and database instance. If a peer P receives a request to answer it, the data of P is completed or modified according to the relevant data that other peers may have. To make this possible, P must relate directly to some neighbor peers Q through sets (P, Q) of logical mappings or data exchange \u043a."}, {"heading": "2 L. Bertossi, L. Bravo", "text": "They are first-order sentences that are expressed in terms of the elements of the database schemas of P and Q. [1] In this sense, DECs act as integrity constraints (ICs) on the combination of two schemas and their instances. However, they are not forced to be satisfied, and there is no mechanism in place to maintain them. Indeed, it is the inconsistency of a DEC that allows data to move between peers: when a peer P receives a query, it examines its DECs, on that basis it queries its neighbors who return consistent data to P."}, {"heading": "4 L. Bertossi, L. Bravo", "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "6 L. Bertossi, L. Bravo", "text": "The focus is on specifying the intended and legal database instances behind a system of like-minded people connected by schema cards. Various terms and forms of trust have been taken into account in P2P information exchange systems (Demolombe 2011; Sabater and Sierra 2005; Artz and Gil 2007; Marti and Garcia-Molina 2006) (cf. the special edition (Boutaba and Marshall 2006), but not much in the context of semantic PDESs, in which the trust relationships between like-minded people are used to essentially modulate or qualify the work. Emphasis is placed on the integration of trust and data exchange restrictions."}, {"heading": "2 The Basic PDES Scenario", "text": "Each peer in a PDES has a local relationship schema with a local relationship instance. For this reason, we first remember some basic terms from the relationships between the two systems. A relative schema S consists of a series of relative predicates. Each attribute of (a predicate) S has a possibly infinite data domain. (A) In general, we will identify with the union of attributes that acquire a single, possibly infinite data domain. (A) Each attribute of (a predicate in) S has a possibly infinite data domain, Dom (A). We will call U the association of attributes domains that dictate a predicate. (A) Predicates in a relative schema S, we have a set of built-in predicates (which have fixed semantics), e.g."}, {"heading": "8 L. Bertossi, L. Bravo", "text": "(a) A universal data exchange restriction (UDEC) between peers P, Q is an L (P, Q) set of the form: (n, i = 1Ri (x, i). (b) The data exchange restriction (RDEC) between peers P (P) and peers S (P). (a) The data exchange restriction (RDEC) between peers P (P) and peers S (Q) or atoms with predicates in B, x). (b) The data exchange restriction (RDEC) between peers P (P) is anL (P). (D) set of the form: \"X.\" (n, i = 1Ri). (x)."}, {"heading": "10 L. Bertossi, L. Bravo", "text": "The built-in atoms wrong in (4) and (5) are wrong in each instance. DECs in \u03a3 (P2, P2) are the local integrity constraints for P2, in this case a denial constraint (i.e. a prohibited compound of positive atoms) and a functional dependency that requires (the values for) the first attribute {lt2} to function (determine the values for) the second. Here, (P4) = \"peer\" (R2 (x, y), that S 2 (y, y, z), \"xy\" (R3, y), lt3 (x, y), the DEC in (7) is an RDEC, and all others are UDECs. Some of the accessibility diagrams are shown in Figure 3. Notice that AC (P1) = {P2, P2, P3, P3, P3, P3, P2, P2, P2, P2, P2, P3, P2, P2, P2, P2, P2."}, {"heading": "3 A General Semantic Framework for a PDES", "text": "Before introducing the formal semantics of the PDESs, we describe the intended semantics in intuitive and operational terms Q. (Consistency and trust in peer data exchange systems 11A query Q-L (P) is submitted to a peer P by a specific user U who may be an external user or another peer in P. Now, depending on the query characteristics, P examines the DECs in \u03a3 (P) to identify data from other neighboring peers Q that can be related to their own data. If predicate RQ-S (Q) appears in an external instance (P), then P queries from Q will produce the (contents of) relationship RQ. Q returns to P to a possible modified version of its relationship, because Q may need to consider data from its own neighbors (in the same way that P did when we received the user query) that might produce local discrepancies at the Q level that need to be fixed."}, {"heading": "12 L. Bertossi, L. Bravo", "text": "(a) An instance D \"for the scheme S (N (P)) is a neighborhood solution for P and D\" if: (i) D \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p"}, {"heading": "14 L. Bertossi, L. Bravo", "text": "(P, Q). (P, P). (P, P). (P, P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). \"(P).\" (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P). (P. (P). (P). (P). (P). (P. (P). (P). (P. (P). (P). (P. (). (). (). (). (). (P. (). (). (). (P. (). (). (). (P. (). (P.). (). (). (P.). (). (P.). (). (P.). (). (P.). ().). (). (P. (). (. ().).)."}, {"heading": "16 L. Bertossi, L. Bravo", "text": "The answer to this question is the semantically correct answer, which means that when answering the question, the peer consistently takes into account the data of his neighbors and the relationships of trust with them."}, {"heading": "18 L. Bertossi, L. Bravo", "text": "Note 3.2 Note that the definitions of the solution instance for Peer and the consistent response for Peer D are parameterized as follows: (a) The class of data exchange constraints. We have considered certain syntactic classes of FO sentences, and we will continue to do so throughout the rest of this work. However, our presentation so far has been sufficiently general to accommodate broader classes of FO sentences in the combined language of two peers. Restriction to the classes of FO sentences has not been requested or used so far. (b) A term of satisfaction, D | =, where D is a database instance, is an FO sentence in the language of the D scheme. Most commonly, D is a relational database that is considered as an FO structure, and classical logical satisfaction is used. However, if D contains uncertain information, then we may have to deviate from the FO logic, as we will see in Section 4. (c) The preorder relationships (we may be based) on the order of an instance of D and the order of an instance of D."}, {"heading": "4 Towards a Special PDES Semantics with NULL", "text": "In fact, the fact is that most of them are able to hold their own, and that they are able to hold their own."}, {"heading": "20 L. Bertossi, L. Bravo", "text": "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"}, {"heading": "22 L. Bertossi, L. Bravo", "text": "For example, for the queries in (10), Q. \"for the queries in (10), Q.\" for the queries in (10), Q. \"for the queries in (10), Q.\" for the queries in (10), Q. \"for the queries in (10), Q.\" for the queries in (10), Q. \"for the queries in (0), Q.\" (0), Q. \"(0), Q.\" (0), Q. \"(0), Q.\" (0), Q. \"(0), Q.\" (0), Q. \"(0).\" (0). (0). (0)."}, {"heading": "24 L. Bertossi, L. Bravo", "text": "The limitations that we consider in this work are, in particular, those that are in the form (2) in which we are not in a position to move in the way that they are in a position to behave. (3) It is the only possibility that we are in a position to behave in the way in which they do. (4) It is the only condition that we are in a position to behave in the way in which they are able to behave in the way in which they are in the way in which they act in the way in which they are in the way in which they are in a position in which they are in, in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the way in which they are in the position in which they are in the position in which they are in the way in which they are in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in which they are in the way in the way in which they are in the way in the way they are in the way in the way in which they are in the way they are in the way in the way in the way in which they are in the way in which they are in the way in the way in the way in which they are in the way they are in the way they are in the way in the way in the way in the way in which they are in the way they are in the way they are in the way in the way in the way in which they are in"}, {"heading": "26 L. Bertossi, L. Bravo", "text": "zero zero zero (zero zero zero), zero zero zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), zero (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero (zero), (zero), (zero), (zero), (zero), (zero), (zero), (zero (zero), (zero), (zero), (zero (zero), (zero), (zero), (zero), (zero (zero), (zero), (zero), (zero), (zero (zero), (zero), (zero (zero), (zero), (zero), (zero (zero), (zero), (zero (zero), (zero), (zero (zero), (zero), (zero (zero), (zero (zero), (zero (zero), (zero (zero), (zero), (zero), (zero (zero), (zero), (zero), (zero (zero), zero (zero (zero), (zero), (zero (zero (zero), zero (zero), (zero (zero), (zero (zero), (zero (zero), (zero (zero), zero (zero), zero (zero (zero), zero (zero (zero (zero), zero), zero (zero (zero), zero (zero (zero (zero), zero (zero (zero), zero (zero (zero), zero (zero (zero), zero (zero (zero), zero), zero (zero (zero)"}, {"heading": "28 L. Bertossi, L. Bravo", "text": "Accordingly, D | = N Q [f] is considered fulfilled because y (P (f, y) y > 5) matches in D, where 7 is considered a non-zero value for y, which makes the formula true. This result is confirmed by the paraphrase of Q (x). P A Bf 7 f 5 null 8b nullFor QN (x): y (P (x, y) y > 5 IsNotNull (y)), D | = QN [f] holds under classic satisfaction, treating zero as any other constant. Likewise, D | = N Q [null] applies. 2Example 4.9 (Example 4.1 continued) The query in (9) can be paraphrased as QN2 (x): y z (R, y, z) S (y) y > 2 y y 6 = zero (null) \u00b7 We had D 6 | = N Q2 [1]."}, {"heading": "5 Solution Semantics with NULL", "text": "In the previous section, we introduced an idea of satisfaction with formulas in database instances that may contain zero. We are now using it to define the semantics of a peer system in which the process of data movement is based on restoring the consistency of peer instances with respect to DECs. The value zero is used to replace existentially quantified variables in sequence of referential DECs and local referential ICs, as a way to consider asserting the consistency of DECs and IC. Another option for the same task is tuple deletion. The repair semantics that supports the restoration of consistency must capture the (possibly multiple) presence of zero in the database and its use to enforce consistency and be sensitive. Specifically, it must take into account the facts that say: consistency and trust in Peer Data Exchange existent variable Jo1. If atoms are inserted into the database, either one called a zero or one called a zero is not included in a database)."}, {"heading": "5.1 A restricted chase", "text": "In order to achieve the aforementioned objectives, we first introduce a limited ad hoc form of prosecution (Abiteboul et al. 1995), as an auxiliary construct, which is applied only to existing DECs and ICs that do not have problematic existential variables in their consequences. Enforcing this subset of restrictions introduces zero tuples for existential variables (which, however, do not occur in compounds).In the end, this prosecution will bring back a finite number of atoms, which will be used as a potentially generous upper limit for the permissible tuples inserts that generate repairs and solutions based on the entire sets of DECs. \u2212 Like any other form of prosecution, our limited pursuit forces the satisfaction of restrictions, but in our case the notion of satisfaction corresponds to the nullity of tuples introduced in Section 4.3.In the rest of this subsection."}, {"heading": "30 L. Bertossi, L. Bravo", "text": "This procedure finally ends, as we show below, but first some intuitions, explanations and examples (Q = 2). (Q = 2) The procedure disseminates and invents values based on the enforcement of RECs with non-problematic existential quantifiers and UDECs. (D = 3) However, the constants in the subsequent instance are already satisfied in the first instance, which explicitly appear in the sequence of DECs, or zero as the value for (non-problematic) existentially quantified variables.Example 5.1 Consider the following series of constraints, classified by definition 5.1: zero x: zero x (D = 0 x x x). (T, y) \u2192 R (x, y).x x x x, y).S (R, y)."}, {"heading": "5.2 Repair semantics with NULL and solutions", "text": "In (Bravo and Bertossi 2006; Bravo 2007) a repair semantics for individual relational databases and groups of ICs is proposed, which may include referential ICs. It introduces zero values of the kind described in Section 4.3. We will adopt and adapt this repair semantics in the context of PDESs, taking into account the constraints imposed by the tracking just introduced, as well as the trust relationships. Thus, to capture the \"proximity\" in our zero-based semantics, we need to compare instances and their tuples, the constant null. Definition 5.2 (Levene and Loizou 1997) for constants c, d, U, c for constants c, d & lt."}, {"heading": "32 L. Bertossi, L. Bravo", "text": "(1) or (2) in the language of the Schema. (1) D \"is the subset of D\" that excludes the DECs with problematic existential variables. \"(a) D\" is at least as close to D \"(is to D\"), designated as D \". (D\"), designated as D \". (D\"). (D \"). (D\".). (D \".).\" (D \".). (D\". (D \".\"). (D \".). (D\". \"). (D\". (D \".). (D\".). (D \".). (D\"). (D \".\" (D \"). (D\".). (D \"). (D\". \"(D.). (D.). (D\" (D \".). (D.). (D\" (D \".). (D\" (D \".). (D.). (D\" (D \"). (D\"). (D \"(D\".). (D \"(D\"). (D \"). (D\" (D \"). (D\"). (D \"(D\"). (D \"(D\".). (D \"(.).\" (D \"(D\"). (D \"(D\".). (D \"(D\"). (D \"(.). (D\" (.). (D \"). (D\" (D \"(D\").). (D \"(.). (D\" (.). (D \".). (D\" (.). (D \"(.). (D\" (.). (.). (D \"(.).). (D\" (.). (.). (D \"(.). (D\" (.). (.). (D \"(.). (.).). (.). (D\" (.). (.). (.). (.).). (D \"(. (.).). (.).).). (.).). ("}, {"heading": "34 L. Bertossi, L. Bravo", "text": "Similarly, the generic definition 3.2 of the solution and core for like-minded people with zero-based solution semantics (i.e., based on \u2264 -D relations to obtain specific versions of these definitions. Accordingly, we remember that if you give an instance D = {D (Q) | Q-P} for the scheme P, the core of Peer P is the intersection of its solutions: Core (P, D): = Sol (P, D).Example 5.5 (Example 2.1) Consider the following like-minded instances: D (P1) = {R1 (a, 2), D (P2) = {R2), R2 (R2) = {R2 (d, 5)}, D (P3) = {R3 (c)}, and D (P4), the like-minded instances: D (P4) and D (P4) = null."}, {"heading": "5.3 Complexity of neighborhood solutions", "text": "We will now examine the complexity of the decision-making problems associated with the general case of Form Q (12) DECs (see Section 4), combined with the zero-based repair semantics we have introduced in this paragraph.We will focus mainly on the case that is directly relevant to our upcoming Peer Set Programming (ASP) to specify solutions for individual peers when they have already collected their neighbourhood solutions.That is, we will look at specifications and reasoning at the neighbourhood level (see Section 6).Accordingly, we will begin to analyze the complexity of deciding whether an instance is a neighbourhood solution (see Definition 3.1).Definition 5.5 Considering a PDES scheme P = < P, S, T rust > and a Peer P. Given the consistency and trust in Peer Data Exchange Systems.eD, a neighbourhood solution (see Definition 5.5) is a neighbourhood solution (see Definition 5.5)."}, {"heading": "5.4 Complexity of the core and peer-consistent answers", "text": "Definition 5.6 Considering a PDES scheme P = < P, S, \u03a3, T-rust > and a peer P in it. Considering a neighbourhood instance D-Q-N (P) JQ for S (N (P)), the local core of P is the intersection of the neighbourhood solutions for P and D, but limited to the P scheme S (P): localCore (P, D): = (NS (P, D) S (P). 2In this definition, JQ is an arbitrary instance for peer Q, which may differ from what we have called the first instance D (Q) for Q (cf. Definition 3.2). In fact, JQ could be D (Q), but also a neighbourhood solution for Q, limited to its scheme, or the intersection of the second instance, etc. In this respect, we remember that a neighbourhood solution for P is defined in relation to its neighbourhood scheme, its local instances for Q, but not necessarily for its neighbourhood Q, but also for the neighbourhood Q-Q."}, {"heading": "36 L. Bertossi, L. Bravo", "text": "The solution to a global problem that involves a recursion, in this case, is the question of whether there is a recursion at all. (In this case, we have all the instances that represent the starting situation for each individual person. (In this case, it is) the question of whether there is actually a recursion. (In this case, it is) the question of whether there is actually a recursion. (In this case, it is) the question of whether there is a recursion. (In this case, it is) the question of whether there is a recursion. (In this case, it is) the question of whether there is a recursion. (In this case, it is) the question of whether there is actually a recursion. (In this case, it is) the question of whether there is a recursion. (In this case, there is) the question of whether there is a recursion."}, {"heading": "5.5 The import case", "text": "In this section, we look at a common situation, namely the import case, where we find that trust relationships are only of the form (P, less, Q) when P 6 = Q; and the DECs are used to import data from other peers. Definition 5.8 Consider a PDES scheme P = < P, S, \u03a3, T rust > and two different peers P and Q:"}, {"heading": "38 L. Bertossi, L. Bravo", "text": "(a) An import of UDEC (IUDEC) to P from Q is a UDEC (P, Q) in L (P, Q) in the form: \"x\" (n) i = 1Ri (x) \u2212 (Q (x))) in the form: \"x\" in the form: \"x\" in the form: \"x,\" \"Q\" in the form: \"x,\" \"x\" in the form: \"x,\" \"x\" in the form: \"x,\" \"x\" in the form: \"x,\" \"x\" in the form: x, \"\" x \"in the form: x.\" (b) An import of RDEC (IRDEC) to P is an RDEC in the form: \"x,\" \"x in the form:\" (x), \"x in the form:\" x."}, {"heading": "5.5.1 The unrestricted case", "text": "The unrestricted import case of PDES P as defined in 5.8 occurs when for each peer P-P (P, P) each peer solution (P, P) has a peer solution (32) and (33) to neighboring peer peers in which it has more confidence than in itself, but no local ICs. As a result of an unrestricted local repair process, a peer will receive data from its neighbors and at least practically integrate it into its own neighboring instance. Data from a neighboring peer is obtained only by making a subjunctive query that matches the predecessor of DEC. As an illustration, in Example 5.7, if P4 uses its import DEC from P2 (which is associated with P4, P2) to retrieve data from P2, then P4 sends the data to P2 the query: Q (x, y)."}, {"heading": "5.5.2 The restricted case", "text": "This case occurs when, under all of the above import assumptions, peers may have local restrictions, i.e., \u03a3 (P, P) 6 = \u2205. In this case, a peer imports data without restrictions from its neighbors, but local ICs are also taken into account when building neighborhood solutions. In this case, P. may have one or more solutions.Example 5.8 Consider the PDES scheme P = < P, S, \u03a3, T rust > according to Figure 7. Here, P = {R2 (\u00b7)}, S (P2, P3}, S = {R1), S (P2), S (P3), S (P1), S (P1)}, S (P1) = {R1 (\u00b7)}, S (P2)}, S (P3), P3 (\u00b7), R3 (\u00b7). The local cases are: D (P1) x."}, {"heading": "40 L. Bertossi, L. Bravo", "text": "Example 5.9 Consider D (P) = {P (a, b), P (a, c)}, D (Q) = {Q (a, d)} and Trust = {(P, less, Q)}. \u03a3 (P, Q) = {\u0432 x, y (Q (x, y) \u2192 P (x, y)}, and \u03a3 (P, P) = {\u0432 x-y-z-v (P (x, y) \u0445 P (x, z) \u0445 P (x, v) \u2192 y = z-z-z = v-v = y)}. The local constraints in \u03a3 (P, P) ensure that there are no more than two tuples in P with the same first attribute. In this case \u03a3 (P, Q) is of the import type and therefore P (a, d) belongs to all solutions. The local constraints in \u03a3 (P, P) force the removal of P (a, b) or P (a, c), and therefore P (a, d, 2, P) (P)."}, {"heading": "6 Answer Set Programs and the Solutions for a Peer", "text": "In fact, it is such that it is a matter of a way in which people act in the real world, in the real world, in the real world, in which they live, in the real world, in the real world, in which they live, in the real world, in which they live, in which they live, in which they live, in which they live, in which they live, in the real world, in which they live, in the real world, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, they live, in which they live, in which they live, in which they live, they live, in which they live, in which they live, in which they live, in which they live, in which they live, they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they live, in which they live, in which they live, in which they live, they live, in which they live, in the real world, in which they live."}, {"heading": "In the following, for a DEC \u03c8, A(\u03c8) and C (\u03c8) denote the set of database atoms", "text": "A consequence of the zero repair is that any RDEC that has connections between existential quantifiers can only be repaired by deleting tuples and not by inserting tuples with zero. Therefore, the most relevant RDECs in this setting are only in the form: (34) For this reason, and to simplify the representation, the logic program that follows this scheme only takes into account RDECs of this form. Definition 6.1 Consider a PDES scheme P = < P, S, \u03a3, T rust > and a peer P with local instance D (P) (for the scheme S (P))."}, {"heading": "42 L. Bertossi, L. Bravo", "text": "The following facts: dom (a), for each a) Adom (D), dom (null), and R (a), for each atom R (a), and d), and d), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c), and c)."}, {"heading": "44 L. Bertossi, L. Bravo", "text": "The minimal discrepancy between the generated and the original instances according to the definitions 3.1 and 5.3.Example 6.2 Consider P = {P1, P2}, with D (P1) = {R1 (a, 2), D (P2) = {R2 (d, 5)}, and the neighbourhood instance D (x, y) = D (P1, y). Suppose the solution program (P1, less, P2) contains: (we itemize in accordance with definition 6.1) 1. The facts dom (a), dom (d), dom (2), dom (null), dom (null), dom (null), dom (null), dom (zero), dom (R1), R2 (d, 5) \u00b7 2. R2."}, {"heading": "46 L. Bertossi, L. Bravo", "text": "This is clearly undesirable and can be avoided. We do not provide optimized versions here because they are more difficult to read.Sentence 6.1 still applies when P, instead of collecting the intersection of solutions from a neighbor Q, uses the intersection of solutions for Q, which is limited to the subschema of Q that contains the relationships of Q that occur in the corresponding quantifiers (P, Q) that P needs to execute its program.As we stated at the beginning of this section, our solution programs can be much more general. In particular, they can be modified to include rules for REDCs with existential quantifiers and merge in the sequences. For example, if the DEC contains, say, xy (x, y), S (y, z) \u2192 w (P, w), Q (w, z) x."}, {"heading": "6.1 ASPs and PCAs", "text": "With a solution program for P, PCAs to a query Q posed to P, one can get a query program in combination with the solution program Q. (F) First, a query program must be produced that is fairly standard, and next, queries with different queries can be produced. Example 6.5 (Example 6.2) is given under the careful stable semantics that declares true what is true in all stable models at the same time. (F) Of course, the same program with different queries can be used. Example 6.5 (Example 6.2 continue) To connect P1's PCAs to the query Q1 (x, y), the rule Ans1 (x, y)."}, {"heading": "48 L. Bertossi, L. Bravo", "text": "Finally, the program \u0430 (P1; D (P1) and Core (P2, D) (cf. example 6.2) is executed, which has only one solution, namely {R1 (a, 2), R1 (d, 5)}; and the PCAs for Q0 are < a, 2 > and < d, 5 >."}, {"heading": "6.2 The import case revisited", "text": "Let us first consider the unrestricted case introduced in Section 5.5.1, where each peer P has a solution program for Q (P) as defined in 6.1, with rules of the form: 2. S (y-j, t) n i = 1 Ri (x-i, t?), S (y-j, f?), S (y-j, f?), P (x-x), P (n), P (P) n i = 1 Ri-S (Q), for Q (P) n (P). 5. (b) Q (x) Q (x) Q (x-0, t), R (x-x), not aux2 (x-P), x-S (P) 6 = null \u00b7 S (P), for Q-S (Q), for Q-N (P). We also need the auxiliary rules (36), (35), and only for predicates in S (P)."}, {"heading": "7 Related Work", "text": "The answer to this question is: \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\" \"What is the answer to this question?,\""}, {"heading": "52 L. Bertossi, L. Bravo", "text": "In fact, the problem of data exchange among distributed independent sources has already been raised (Caroprese et al. 2006; Caroprese and Zumpano 2008; Caroprese and Zumpano 2011). The authors define a declarative semantics for P2P systems that allows one to import atoms that do not violate local integrity."}, {"heading": "8 Conclusions", "text": "The methodology is flexible and inconsistency tolerant, as each peer resolves its data and semantic conflicts at query time when it queries its own and the data of other peers. The general semantic framework can be specialized in several ways, and we presented some possibilities. In particular, we developed a specific semantics based on universal and referential data exchange constraints, and the use of SQL null values to deal with incomplete information. In this scenario, logic programs cannot 24 In our case, even a constraint on the form xy (S (x, y) \u2192 zT (x, z)) is imposed by giving z the value NULL (unless some other constraint prevents this)."}, {"heading": "54 L. Bertossi, L. Bravo", "text": "Among them we find the partial evaluation of programs and the solution instances they specify, since we are not interested in the solution per se, but in the PCAs. Specifically, techniques used in CQA, such as magic sentences for stable model semantics (Faber et al. 2007), and the identification of predicates relevant to queries and constraints, could also be used in this environment. In this way, the number of rules and the amount of data needed to execute the program is reduced (Caniupan et al. 2010; Eiter et al. 2008). The problem with query evaluation of disjunctive programs is that QP2 is completely in data (Dantsin et al. 2001), which coincides with the complexity of PCA, as we have found here. The problem with query evaluation of QS systems is that QP2 is completely in data we have developed for consistent systems, which can be developed for QS-consistent systems."}, {"heading": "56 L. Bertossi, L. Bravo", "text": "In fact, it is that we see ourselves as being able to assert ourselves, that we are able to change the world, and that we are able to change the world, \"he said."}, {"heading": "58 L. Bertossi, L. Bravo", "text": "ELECTRONIC ANNEX"}, {"heading": "Appendix A Discussion", "text": "In this section, we refer to the special semantics (introduced in Section 4.We have assumed that G (P) x is acyclic. However, peers who are not aware that they are in a cycle in G (P) may try to do the data exchange as described above. However, if an identifier falls back on a peer, it will recognize that it is in a cycle and act accordingly. Assuming the acyclicity of the accessibility graph is quite cautious in the sense that it excludes cases where reasonable semantics could still be given and the logical programs would work correctly, because the cycles in G (P) are not necessarily relevant. Example 1 Consider S (P1) = {R1 (\u00b7), S (\u00b7 2),"}, {"heading": "60 L. Bertossi, L. Bravo", "text": "However, it is possible to give some clues as to how to proceed. In (Caniupan and Bertossi 2010), the dependency graphs of database predicates in relation to a set of ICs were introduced and used to capture the notion of the possibly transitive relevance of one predicate to another that is in a consistent relationship to a similar relationship. In (Caniupan and Bertossi 2010) we can use the dependency graphs of database predicates in relation to a set of ICs."}, {"heading": "62 L. Bertossi, L. Bravo", "text": "R1 (a, b) is protected by R2 (a, e) because, since R1 (a, e) has limited uses, the only way to repair a violation related to \u03a3 (P1, P3) is to delete the tuple from R3. In this case, however, the tuple will be in the answer. We can see that the answer to question (A1) amounts to the output of P1 queries to P2, P3 about the content of their relationships, R2 and R3, which are answered by the latter by the classic query evaluation. After this data has been collected from P1, it goes to the evaluation (A1), which contains implicit repair processes. Now, the answers are to (A1) < a >, < c, d >, e >, exactly the PCAs we obtain taking into account all the explicit solutions for P1."}, {"heading": "64 L. Bertossi, L. Bravo", "text": "We assume that the data distributed at different levels must be appropriately collected in order to create approaches to a peer, and that different semantics may emerge as candidates, depending on how the granularity of the data sent between the individual levels is. However, in the context of the general semantic framework introduced in Section 3, we have developed a specific semantics in Section 4, according to which a peer Q goes back to a neighbor who builds his solutions, this is (part) his specific data. This is the one that is included in all of Q's solutions. Bravo 2007, Chapter 7) also develops and compares two other alternative semantics, in particular defining some conditions under which they agree or differ. These other semantics assume that more detailed information, such as illustrations and trust relationships, can be sent between peers. We describe them briefly. The first assumes that data, DECs and trust relationships can be sent between peers."}, {"heading": "66 L. Bertossi, L. Bravo", "text": "In this case, it is so that the programs can be compiled with their usual stable semantics (cf. Brewka 2004) and the references to it. Here we outline briefly how weak program restrictions are (Buccafurri et al. 2000; Leone et al. 2006) we declare the type of preferences that concern our needs. (Cf. Brewka 2004) For links between preferences in logic programs and weak restrictions.) Example 6 Consider the example 6.2, where (P1, less, P2) trust by the non-disjunctive repair ruleR1, y, y, t) we propose R2 (x, y, y, y, R1), y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y."}, {"heading": "Appendix B Proofs of Results", "text": "Evidence of Proposition 3.1: Consistency and trust in Peer Data Exchange Systems 2.J is a direct attraction to the neighborhood JJ (JP).J (JP) is an empty instance for the schema JP (JP).J (JP) is an empty instance for the schema JP (JP).J (JP) is an empty instance for the schema JP (JP).D (JP) is a neighborhood solution, or there is a neighborhood solution D (JP), so D (JP) is for a neighborhood solution D0. 2Proof of Corollary 3.1: All we need to note is that the possibly inconsistent sink peers in the accessibility curve always have local repairs (ICs in this case).A solution for a peer P can then exist through recursively propagating neighborhood solutions (which always exist through Proposition 3.1) for peers along the paths that is 2P. Proposition 5.J1 of Memorship (P)."}, {"heading": "68 L. Bertossi, L. Bravo", "text": "D (P1): D (P1): D (P1): D (P1): D (P2): D (P2): D (P1): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P1): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (D): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (D): D (P2): D (D): D (P2): D (P2): D (D): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (D): D (P2): D (P2): D (P2): D (D): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (D (D): D (P2): D (P2): D (P2): D (P2): D (P2): D (P2): D (D (P2): D (P2): D (P2): D (P2): D (P2): D (D): D (P2): D (P2): D (P2): D (P2): D (P2): D (2): D (P2): D (P2): D (2): D (P2): D (P2): D (P2): D (P2): D (2): D (2): D (P2): D ("}, {"heading": "70 L. Bertossi, L. Bravo", "text": "D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (P): D (D (P): D): D (D): D (P): D (P): D (D): D (P): D (P): D (P): D (D): D: D: D: D: D: D (P): D (D): D (D): D (D): D (D): D (P): D (D): D (D): D (D): D (D): D (P): D (P): D (P): D (P): D (P): D): D (P): D (P): D (P): D): D (P): D (P): D (P): D (P): D): D: D (P): D (P): D (P): D (P): D: D (P): D): D: D: D (P): D: D: D (P): D: D (P): D: D: D: D: D (P): D (D: D: D: D: D: D: D: D: D: D: D (D): D: D: D (D): D: D (D): D (D: D: D: D: D (D): D: D: D (D: D (D): D: D (D): D: D: D: D: D: D: D: D: D (D: D: D (D): D (P): D: D: D: D (P): D: D: D: D: D: D: D: D"}, {"heading": "72 L. Bertossi, L. Bravo", "text": "It is not just a question of whether the question is a question, but also a question of whether the question is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question, whether it is a question,"}, {"heading": "74 L. Bertossi, L. Bravo", "text": "A. IC is a UDEC = 1 Pi (x). Since M is a model of \"P\" (P), \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) \"D\" (D) (D) \"D\" (D) (D) (D) (D) \"(D)\" D \"(D)\" (D) \"D\" (D) \"D\" (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D)) (D) (D) (D) (D) (D) (D) (D)) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D)) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D)) (D) (D) (D) (D) (D) (D) (D) (D)) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D)) (D) (D)) (D) (D) (D) (D) (D) (D (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D) (D)"}, {"heading": "76 L. Bertossi, L. Bravo", "text": "(a) P (a) P (a) P (a) P (a) P (a) P (a) P (a) P (a) T?) P (a) T?) P (a) T?) P (a) T?) P (a) T?) P (a) T?) and P (a) T??) belong to M?, and no other P (a) P (a) V, V) / E M? (b) P (a) P (a) T), P (a) T?) and P (a) belong to M? (a), and no other P (a) V, v), for v? M (a) P (v), for v? A comment belongs to M?. If an atom belongs to a model M1, e.g. P (a) is to zero, and there is another model M2 in which it does not exist, then there must be a comment in M2."}], "references": [{"title": "Complex Preferences for Answer Set Optimization", "author": ["G. Brewka"], "venue": "Proc. International conference on Principles of Knowledge Representation and Reasoning. AAAI Press, 213\u2013223.", "citeRegEx": "Brewka,? 2004", "shortCiteRegEx": "Brewka", "year": 2004}, {"title": "Enhancing Disjunctive Datalog by Constraints", "author": ["F. Buccafurri", "N. Leone", "P. Rullo"], "venue": "IEEE Transactions on Knowledge and Data Engineering 12, 5, 845\u2013860.", "citeRegEx": "Buccafurri et al\\.,? 2000", "shortCiteRegEx": "Buccafurri et al\\.", "year": 2000}, {"title": "Minimal-Change Integrity Maintenance using Tuple Deletions", "author": ["J. Chomicki", "J. Marcinkowski"], "venue": "Information and Computation 197, 1-2, 90\u2013121.", "citeRegEx": "Chomicki and Marcinkowski,? 2005", "shortCiteRegEx": "Chomicki and Marcinkowski", "year": 2005}, {"title": "Magic Sets and their Application to Data Integration", "author": ["W. Faber", "G. Greco", "N. Leone"], "venue": "Journal of Computer and System Sciences 73, 4, 584\u2013609.", "citeRegEx": "Faber et al\\.,? 2007", "shortCiteRegEx": "Faber et al\\.", "year": 2007}, {"title": "Non-Determinism in Deductive Databases", "author": ["F. Giannotti", "D. Pedreschi", "D. Sacca", "C. Zaniolo"], "venue": "Proc. International Conference on Deductive and ObjectOriented Databases. Springer, LNCS 566, 129\u2013146.", "citeRegEx": "Giannotti et al\\.,? 1991", "shortCiteRegEx": "Giannotti et al\\.", "year": 1991}, {"title": "Prolegomena for a Logic of Trust and Reputation", "author": ["A. Herzig", "E. Lorini", "J. Hubner", "J. Ben-Naim", "C. Castelfranchi", "R. Demolombe", "D. Longin", "L. Vercouter"], "venue": "Proc. Third International Workshop on Normative Multiagent Systems. 143\u2013157.", "citeRegEx": "Herzig et al\\.,? 2008", "shortCiteRegEx": "Herzig et al\\.", "year": 2008}, {"title": "A Probabilistic Trust Model for Semantic Peer-to-Peer Systems", "author": ["G. Hien Nguyen", "P. Chatalic", "Rousset", "M.-C."], "venue": "Proc. European Conference on Artificial Intelligence. IOS Press, 881\u2013882.", "citeRegEx": "Nguyen et al\\.,? 2008", "shortCiteRegEx": "Nguyen et al\\.", "year": 2008}, {"title": "Completeness in the Polynomial-Time Hierarchy: A Compendium", "author": ["M. Schaefer", "Umans", "Ch."], "venue": "SIGACT News.", "citeRegEx": "Schaefer et al\\.,? 2008", "shortCiteRegEx": "Schaefer et al\\.", "year": 2008}, {"title": "PeerTrust: Supporting Reputation-Based Trust for Peerto-Peer Electronic Communities", "author": ["L. Xiong", "L. Liu"], "venue": "IEEE Transactions of Knowledge and Data Engineering 16, 7, 843\u2013857.", "citeRegEx": "Xiong and Liu,? 2004", "shortCiteRegEx": "Xiong and Liu", "year": 2004}, {"title": "Designing a Super-Peer Network", "author": ["B. Yang", "H. Garcia-Molina"], "venue": "Proc. International Conference on Data Engineering. IEEE Computer Society, 49.", "citeRegEx": "Yang and Garcia.Molina,? 2003", "shortCiteRegEx": "Yang and Garcia.Molina", "year": 2003}], "referenceMentions": [{"referenceID": 3, "context": "More specifically, techniques used in CQA, such as magic sets for stable model semantics (Faber et al. 2007), and identification of predicates that are relevant to queries and constraints, could also be used in this setting.", "startOffset": 89, "endOffset": 108}], "year": 2016, "abstractText": "We propose and investigate a semantics for peer data exchange systems where different peers are related by data exchange constraints and trust relationships. These two elements plus the data at the peers\u2019 sites and their local integrity constraints are made compatible via a semantics that characterizes sets of solution instances for the peers. They are the intended -possibly virtualinstances for a peer that are obtained through a data repair semantics that we introduce and investigate. The semantically correct answers from a peer to a query, the so-called peer consistent answers, are defined as those answers that are invariant under all its different solution instances. We show that solution instances can be specified as the models of logic programs with a stable model semantics. The repair semantics is based on null values as used in SQL databases, and is also of independent interest for repairs of single databases with respect to integrity constraints. To appear in Theory and Practice of Logic Programming (TPLP).", "creator": "LaTeX with hyperref package"}}}