{"id": "1606.03289", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Jun-2016", "title": "Tunable Online MUS/MSS Enumeration", "abstract": "In various areas of computer science, the problem of dealing with a set of constraints arises. If the set of constraints is unsatisfiable, one may ask for a minimal description of the reason for this unsatisifi- ability. Minimal unsatisifable subsets (MUSes) and maximal satisifiable subsets (MSSes) are two kinds of such minimal descriptions. The goal of this work is the enumeration of MUSes and MSSes for a given constraint system. As such full enumeration may be intractable in general, we focus on building an online algorithm, which produces MUSes/MSSes in an on-the-fly manner as soon as they are discovered. The problem has been studied before even in its online version. However, our algorithm uses a novel approach that is able to outperform current state-of-the art algorithms for online MUS/MSS enumeration. Moreover, the performance of our algorithm can be adjusted using tunable parameters. We evaluate the algorithm on a set of benchmarks.", "histories": [["v1", "Fri, 10 Jun 2016 12:24:35 GMT  (68kb,D)", "http://arxiv.org/abs/1606.03289v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["jaroslav bendik", "nikola benes", "ivana cerna", "jiri barnat"], "accepted": false, "id": "1606.03289"}, "pdf": {"name": "1606.03289.pdf", "metadata": {"source": "CRF", "title": "Tunable Online MUS/MSS Enumeration", "authors": ["Jaroslav Bend\u0301\u0131k", "Nikola Bene\u0161", "Ivana \u010cern\u00e1"], "emails": ["xbendik@fi.muni.cz", "xbenes3@fi.muni.cz", "cerna@fi.muni.cz", "barnat@fi.muni.cz"], "sections": [{"heading": "1 Introduction", "text": "In various areas of computer science, such as restriction processing, requirements analysis and model verification, the following problem often arises: we receive a series of restrictions and are asked whether the set of restrictions is practicable, i.e. whether all the restrictions together are satisfactory. In some requirement analyses, the restrictions represent the requirements for a particular system, which are usually described as formulas of an appropriate logic, and the question of feasibility is in fact whether all the requirements can actually be implemented at once. In some models, such as those using the Contraindicative Abstraction Refinement (CEGAR), an impracticable restriction system may arise as a result of the approximation of abstraction. In cases where the set of restrictions is impracticable, we would like to investigate the reasons for impracticability."}, {"heading": "1.1 Related Work", "text": "In fact, it is such that most of them will be able to move into another world, in which they are able to move, in which they move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they, in which they live, in which they are, in which they are, in which they are, in which they are, in which they live."}, {"heading": "1.2 Our Contribution", "text": "In this article, we present our own algorithm for online enumeration of MUSes and MSSes in general constraint satisfaction domains, which is capable of surpassing the current state-of-the-art MARCO algorithm. At the core of the algorithm is a novel binary search-based approach. Similar to MARCO, the algorithm is able to directly apply arbitrary shrink and expansion processes. In addition, our algorithm contains certain parameters that determine in which cases the shrink and expansion processes should be used. We evaluate our algorithm against a variety of benchmarks that show that the algorithm is actually better than MARCO."}, {"heading": "1.3 Outline of The Paper", "text": "In Section 2, we formally present the problem we are solving and define all the necessary terms. In Section 3, we describe the algorithm step by step, starting with the basic scheme of MUS / MSS calculation and gradually explaining the main ideas of our algorithm. Section 4 provides an experimental evaluation of a variety of benchmarks and compares our algorithm with MARCO. The paper is completed in Section 5."}, {"heading": "2 Preliminaries", "text": "This year, it will be in a position to achieve the objectives I have mentioned."}, {"heading": "3 Algorithm", "text": "In this section, we will gradually introduce an online MUS / MSS enumeration algorithm. First, we will consider a na\u00efve enumeration algorithm that explicitly checks each subset of C for satisfaction, divides the subsets of C into satisfactory and unsatisfactory subsets, and selects the maximum or minimum subsets of the two groups. The main drawback of this approach is the large number of satisfaction checks. Checking a given subset of C for satisfaction is a usefully expensive task, and the na\u00efve solution exponentially renders many of these checks unusable. Note that the MUS enumeration problem involves solving the problem of satisfaction of all subsets of C, since each unsatisfactory subset of C is a superset of any MUS. This means that any algorithm that solves the MUS enumeration problem must perform several satisfaction checks."}, {"heading": "3.1 Basic Schema", "text": "In fact, it is true that this is a way in which people have to focus on themselves and their environment. (...) It is not as if people are in a position to surpass themselves. \"(S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S."}, {"heading": "3.2 Symbolic Representation of Nodes", "text": "In this sense, the symbolic representation of the nodes is instead.We use the fact that the powerset grid P (C) can be seen and manipulated as Boolean algebra. So we encode the set of constraints C = c1. We use a symbolic representation of the nodes instead.We use the fact that the powerset grid P (C) can be seen as Boolean algebra. We encode the set of constraints C = c1. We use a set of Boolean variables X = {x1, xn}. Each subset of C (i.e. each node in our algorithm) is then represented by an evaluation of the variables."}, {"heading": "3.3 Unexplored Nodes Selection", "text": "We now clarify which nodes our algorithm selects in each of its iterations to be checked, and which nodes it includes in the number of candidates for MUSes and MSSes. We also extend the basic scheme presented as Algorithm 1. We want to minimize the ratio of checks performed to the number of nodes in P (C). Any algorithm to solve the problem of MUSes enumeration must perform at least as many checks as there is MUST, so this ratio can never be zero. Also, it is impossible to achieve the ratio with a minimum value without knowing which nodes are satisfactory and which information is not part of the input of our algorithm. Instead of minimizing this overall ratio, our algorithm tends to minimize this ratio locally in each of its iterations."}, {"heading": "10 else", "text": "This year it is more than ever before."}, {"heading": "3.4 Online MUS/MSS Enumeration", "text": "The algorithms as presented so far are only able to provide MUSes and MSSes in the second phase after exploring all nodes. < / / / / \"The shrink procedure is a type of shrink procedure that can represent an unsatisfactory node in the first phase of the node.\" \"The shrink procedure is an arbitrary method that can transform an unsatisfactory node into an MUS.\" \"The shrink procedure is a method that can transform a satisfactory node into MSS Ns.\" \"The simple variant of these two procedures is shown in Algorithms 3 and 4.\" The simple shrink method (grow) attempts to remove the limitations of Nu (Ns) by checking each new setting for satisfaction and any change that leaves the set unsatisfactory. \"These simple variants serve only as illustrations.\""}, {"heading": "3.5 Example Execution of Our Algorithm", "text": "s leave C = {c1 = a, c2 = \u20aca, c3 = b, c4 = \u20aca, b), S (x) = x, G (x) = x.First, MSScan = \u2205, MUScan = \u2205 and all nodes are unexplored, i.e. f (Unex) = True. Fig. 1 shows the values of the control variables in each iteration and also illustrates the current states of P (C). To save space, we encode nodes as bit vectors, for example, the node {c1, c3, c4} is written as 1011."}, {"heading": "I. iteration", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "II. iteration", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "III. iteration", "text": "After the last iteration of the first phase of our algorithm, there is no model of f (Unex) (meaning that Unex is empty), MSScan = {1010, 1001, 0111} and MUScan = {1100, 1011}. Since the functions S and G in this example are given as S (x) = x, G (x) = x, each candidate has shrunk to MUS or MSS alredy or grown to MUS or MSS, hence MSS (C) = MSScan, MUS (C) = MUScan and the second phase of our algorithm can be omitted. Note that in the first iteration, the node 1010 turned out to be MSS, which (due to the definition of MSS) means that all of its supersets are unsatisfactory. One would use this fact to mark all of the supersets of 1010 as examined, but our algorithm does not do this because some of these subsets MUST be (1011 in this example), if we could only erect all of them in the MSS."}, {"heading": "4 Experimental Results", "text": "This year it is more than ever before."}, {"heading": "5 Conclusion", "text": "In this paper, we have presented a novel algorithm for online enumeration of MUSS and MSSes that is applicable to all types of constraints; the core of the algorithm is based on a novel binary search approach that allows the algorithm to efficiently explore the space of all subsets of a given set of constraints; we have made an experimental comparison with MARCO, the most advanced algorithm for online enumeration of MUSS and MSS; the results show that our algorithm is better for both online enumeration and full enumeration; our algorithm can be built on any consistency solver and can use any implementation of shrinkage and growth methods; therefore, any future progress in this area can be reflected in the performance of our algorithm; one direction of future research is to seek parallel processing of the search space to improve the performance of our approach."}], "references": [{"title": "Reveal: A formal verification tool for verilog designs", "author": ["Z.S. Andraus", "M.H. Liffiton", "K.A. Sakallah"], "venue": "LPAR. Lecture Notes in Computer Science, vol. 5330, pp. 343\u2013352. Springer", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2008}, {"title": "Discovery of minimal unsatisfiable subsets of constraints using hitting set dualization", "author": ["J. Bailey", "P.J. Stuckey"], "venue": "Practical Aspects of Declarative Languages, pp. 174\u2013186. Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2005}, {"title": "Finding all minimal unsatisfiable subsets", "author": ["M.G. de la Banda", "P.J. Stuckey", "J. Wazny"], "venue": "Proceedings of the 5th ACM SIGPLAN international conference on Principles and practice of declaritive programming. pp. 32\u201343. ACM", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "MUSer2: An efficient MUS extractor", "author": ["A. Belov", "J. Marques-Silva"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation 8, 123\u2013128", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Consistent subsets of inconsistent systems: structure and behaviour", "author": ["E. Birnbaum", "E.L. Lozinskii"], "venue": "J. Exp. Theor. Artif. Intell. 15(1), 25\u201346", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2003}, {"title": "Restoring satisfiability or maintaining unsatisfiability by finding small unsatisfiable subformulae", "author": ["R. Bruni", "A. Sassano"], "venue": "Electronic Notes in Discrete Mathematics 9, 162\u2013173", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2001}, {"title": "An extensible sat-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "SAT. Lecture Notes in Computer Science, vol. 2919, pp. 502\u2013518. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2003}, {"title": "Deriving minimal conflict sets by cs-trees with mark set in diagnosis from first principles", "author": ["B. Han", "S. Lee"], "venue": "IEEE Trans. Systems, Man, and Cybernetics, Part B 29(2), 281\u2013286", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1999}, {"title": "A theory of measurement in diagnosis from first principles", "author": ["A. Hou"], "venue": "Artif. Intell. 65(2), 281\u2013328", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1994}, {"title": "CNFgen formula generator", "author": ["M. Lauria"], "venue": "http://massimolauria.github.io/ cnfgen/,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2016}, {"title": "Enumerating infeasibility: Finding multiple muses quickly", "author": ["M.H. Liffiton", "A. Malik"], "venue": "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, 10th International Conference, CPAIOR 2013, Yorktown Heights, NY, USA, May 18-22, 2013. Proceedings. Lecture Notes in Computer Science, vol. 7874, pp. 160\u2013175. Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Identifying conflicts in overconstrained temporal problems", "author": ["M.H. Liffiton", "M.D. Moffitt", "M.E. Pollack", "K.A. Sakallah"], "venue": "IJCAI. pp. 205\u2013211. Professional Book Center", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}, {"title": "Fast, flexible MUS enumeration", "author": ["M.H. Liffiton", "A. Previti", "A. Malik", "J. Marques-Silva"], "venue": "Constraints pp. 1\u201328", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2015}, {"title": "Algorithms for computing minimal unsatisfiable subsets of constraints", "author": ["M.H. Liffiton", "K.A. Sakallah"], "venue": "Journal of Automated Reasoning 40(1), 1\u201333", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "AMUSE: a minimally-unsatisfiable subformula extractor", "author": ["Y. Oh", "M.N. Mneimneh", "Z.S. Andraus", "K.A. Sakallah", "I.L. Markov"], "venue": "DAC. pp. 518\u2013523. ACM", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2004}, {"title": "Partial MUS enumeration", "author": ["A. Previti", "J. Marques-Silva"], "venue": "Proceedings of the Twenty-Seventh AAAI Conference on Artificial Intelligence, July 14-18, 2013, Bellevue, Washington, USA. AAAI Press", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "Extracting small unsatisfiable cores from unsatisfiable boolean formula", "author": ["L. Zhang", "S. Malik"], "venue": "SAT 3", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 0, "context": "Enumerating multiple MUSes is sometimes desirable: in requirements analysis, this gives better insight into the inconsistencies among requirements; in CEGAR-based model checking more MUSes lead to a better refinement that can reduce the complexity of the whole procedure [1].", "startOffset": 271, "endOffset": 274}, {"referenceID": 14, "context": "For example all of [15,6,17] uses information from a satisfiability solver to obtain an unsatisfiable subset but they do not guarantee its minimality.", "startOffset": 19, "endOffset": 28}, {"referenceID": 5, "context": "For example all of [15,6,17] uses information from a satisfiability solver to obtain an unsatisfiable subset but they do not guarantee its minimality.", "startOffset": 19, "endOffset": 28}, {"referenceID": 16, "context": "For example all of [15,6,17] uses information from a satisfiability solver to obtain an unsatisfiable subset but they do not guarantee its minimality.", "startOffset": 19, "endOffset": 28}, {"referenceID": 8, "context": "Explicit checking The first algorithm for enumerating all MUSes we are aware of was developed by Hou [9] in the field of diagnosis and is built on explicit enumeration of every subset of the unsatisfiable constraint system.", "startOffset": 101, "endOffset": 104}, {"referenceID": 7, "context": "Further improvements to this approach were made by Han and Lee [8] and also by de la Banda et.", "startOffset": 63, "endOffset": 66}, {"referenceID": 2, "context": "[3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 13, "context": "CAMUS A state-of-the-art algorithm for enumerating all MUSes called CAMUS by Liffiton and Sakallah [14] is based on the relationship between MUSes and the so-called minimal correction sets (MCSes), which was independently pointed out by [2,5,12].", "startOffset": 99, "endOffset": 103}, {"referenceID": 1, "context": "CAMUS A state-of-the-art algorithm for enumerating all MUSes called CAMUS by Liffiton and Sakallah [14] is based on the relationship between MUSes and the so-called minimal correction sets (MCSes), which was independently pointed out by [2,5,12].", "startOffset": 237, "endOffset": 245}, {"referenceID": 4, "context": "CAMUS A state-of-the-art algorithm for enumerating all MUSes called CAMUS by Liffiton and Sakallah [14] is based on the relationship between MUSes and the so-called minimal correction sets (MCSes), which was independently pointed out by [2,5,12].", "startOffset": 237, "endOffset": 245}, {"referenceID": 11, "context": "CAMUS A state-of-the-art algorithm for enumerating all MUSes called CAMUS by Liffiton and Sakallah [14] is based on the relationship between MUSes and the so-called minimal correction sets (MCSes), which was independently pointed out by [2,5,12].", "startOffset": 237, "endOffset": 245}, {"referenceID": 10, "context": "MARCO The desire to enumerate at least some MUSes even in the generally intractable cases led to the development of two independent but nearly identical algorithms: MARCO [11] and eMUS [16].", "startOffset": 171, "endOffset": 175}, {"referenceID": 15, "context": "MARCO The desire to enumerate at least some MUSes even in the generally intractable cases led to the development of two independent but nearly identical algorithms: MARCO [11] and eMUS [16].", "startOffset": 185, "endOffset": 189}, {"referenceID": 12, "context": "Both algorithms were later joined and presented in [13] under the name of MARCO.", "startOffset": 51, "endOffset": 55}, {"referenceID": 12, "context": "CAMUS and MARCO were experimentally compared in [13] and the former has shown to be faster in enumerating all MUSes in the tractable cases.", "startOffset": 48, "endOffset": 52}, {"referenceID": 1, "context": "One another algorithm, the Dualize and Advance (DAA) by Bailey and Stuckey [2] was also evaluated in these experiments.", "startOffset": 75, "endOffset": 78}, {"referenceID": 6, "context": "One of the SAT solvers that satisfies our requirements is miniSAT [7] that allows the user to fix values of some variables and to select a default polarity of variables at decision points during solving.", "startOffset": 66, "endOffset": 69}, {"referenceID": 3, "context": "These simple variants serve just as illustrations, there are known efficient implementations of both shrink and grow for specific constraint domains; as an example see MUSer2 [4] which implements the shrink method for Boolean constraints systems.", "startOffset": 175, "endOffset": 178}, {"referenceID": 12, "context": "We also give a comparison with MARCO algorithm [13].", "startOffset": 47, "endOffset": 51}, {"referenceID": 12, "context": "The pseudocodes of both variants can be found in [13].", "startOffset": 49, "endOffset": 53}, {"referenceID": 6, "context": "As both the SAT solver and constraint solver we used the miniSAT tool [7] and we used the simple implementation of the shrink and grow methods as described earlier.", "startOffset": 70, "endOffset": 73}, {"referenceID": 9, "context": "We used the generator of Boolean CNF formulae from [10] to generate tractable instances with a size of 30 to 40 constraints, 15 instances per each size.", "startOffset": 51, "endOffset": 55}], "year": 2016, "abstractText": "In various areas of computer science, the problem of dealing with a set of constraints arises. If the set of constraints is unsatisfiable, one may ask for a minimal description of the reason for this unsatisifiability. Minimal unsatisfiable subsets (MUSes) and maximal satisfiable subsets (MSSes) are two kinds of such minimal descriptions. The goal of this work is the enumeration of MUSes and MSSes for a given constraint system. As such full enumeration may be intractable in general, we focus on building an online algorithm, which produces MUSes/MSSes in an on-the-fly manner as soon as they are discovered. The problem has been studied before even in its online version. However, our algorithm uses a novel approach that is able to outperform the current state-of-the art algorithms for online MUS/MSS enumeration. Moreover, the performance of our algorithm can be adjusted using tunable parameters. We evaluate the algorithm on a set of benchmarks.", "creator": "LaTeX with hyperref package"}}}