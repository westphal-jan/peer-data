{"id": "1606.06125", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Jun-2016", "title": "Introducing a Calculus of Effects and Handlers for Natural Language Semantics", "abstract": "In compositional model-theoretic semantics, researchers assemble truth-conditions or other kinds of denotations using the lambda calculus. It was previously observed that the lambda terms and/or the denotations studied tend to follow the same pattern: they are instances of a monad. In this paper, we present an extension of the simply-typed lambda calculus that exploits this uniformity using the recently discovered technique of effect handlers. We prove that our calculus exhibits some of the key formal properties of the lambda calculus and we use it to construct a modular semantics for a small fragment that involves multiple distinct semantic phenomena.", "histories": [["v1", "Mon, 20 Jun 2016 14:05:59 GMT  (36kb)", "http://arxiv.org/abs/1606.06125v1", null], ["v2", "Fri, 8 Jul 2016 07:14:44 GMT  (36kb)", "http://arxiv.org/abs/1606.06125v2", null]], "reviews": [], "SUBJECTS": "cs.CL cs.PL", "authors": ["jirka mar\\v{s}\\'ik", "maxime amblard"], "accepted": false, "id": "1606.06125"}, "pdf": {"name": "1606.06125.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["maxime.amblard}@loria.fr"], "sections": [{"heading": null, "text": "ar Xiv: 160 6.06 125v 1 [cs.C L] 20 JuKeywords: composition, side effects, monads, handling, deixis, conventional implications"}, {"heading": "1 Introduction", "text": "The dominant methodology of formal semantics is compositivity in the sense of Frege: names of complex expressions are functions of the names of their immediate components. However, several phenomena have been identified that challenge this concept of compositivity. Examples include anaphoras, conjectures, quantification, deixis and conventional implications. In all of these examples, simple models of denotation (i.e. noun expressions are individuals, propositions are truth values) are entangled in complications, since the denotations may depend on external values (anaphora, deixis) or on something that is not an immediate constituent component (premise, quantification, conventional implication). Among the solutions to these challenges we find at least two types of solutions. First, we have those that relax the state of compositivity."}, {"heading": "2 Definition of the Calculus", "text": "Our calculus is an extension of the Simply Typed Lambda Calculation (STLC). We insert terms of free algebra into our language and a notation for handlers, composable interpreters of those terms. A handler of free algebra corresponds to a certain interaction that a piece of natural language can have with its context (e.g. a deictic expression could query the identity of the speaker with the help of an operator speaker to find its name).A handler gives an interpretation of each occurrence of an operator within a term (e.g. direct speech introduces a handler for the operator speaker that essentially binds the current speaker to another entity).2 Side effects are for programming languages what pragmatics is for natural languages: Both examine how expressions interact with the worlds of their users."}, {"heading": "2.1 Terms", "text": "In the following definition we are M, N,. Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area Area. The terms of our language are composed of the following terms: M, N: Mn, MN: MN [Application] | x [Variable] | c [Constant] | opMp (.Mc) [Operation]."}, {"heading": "2.2 Types", "text": "We give a syntax for the types of our operations together with a typing of the signatures. In the grammar below is \u03b2 \u03b2, \u03b2, \u03b3. Range over types, spectra over atomic types of any sentence T and E, E. \"The only novelty here is the signature (introduced below). However, the types of our language consist of: \u03b1, \u03b2, \u03b3: = \u03b2 [mode of operation] [mode of operation] [mode of operation symbols] come from the mode of action signature E. We call them compilation types and we call them compilation types because our algebraic expressions always represent some kind of program with effects. They are partial mappings from the series of operation symbols E to types of types. We will always represent the elements of the effect of the signature with effects."}, {"heading": "2.3 Reduction Rules", "text": "The semantics will be given in the form of a reduction relation to terms. Although the purpose of the calculation is to talk about effects, the reduction semantics will not be based on a fixed order of evaluation; any sub-term that is a code can be reduced in any context. The rules of reduction are given in Fig. 2."}, {"heading": "L (opi:Mi)i\u2208I , \u03b7:M\u03b7 M (\u03b7 N) \u2192 rule L \u03b7 M", "text": "The rest are function definitions for L M, \u2212 \u0445 and C. If we look at the definition of L M, we see that it is an iterator. It replaces any occurrence of the constructors opj and \u03b7 with Mj and M\u03b7, respectively. The C function reverses recursively C (\u03bbx.) with opMp (\u03bby.) using the cop rule. Finally, when C meets the \u03b7 constructor, it (\u03bbx.) swaps with \u03b7 and ends. Note that the constraint x / \u0445 FV (Mp) cannot usually be dismissed as cop by renaming bound variables. If the parameter Mp contains a free occurrence of x, the evaluation of C. C remains hanging. C is thus a subfunction: It is only applicable if none of the operations that are commutated with the \u03bb binder actually depend on the bound variable."}, {"heading": "2.4 Common Combinators", "text": "The following combinators will be helpful in the demonstration of the calculation in the next section. First, we define a sequence operator. The operator, called bind, replaces all \u03b1-typed atoms of an FE (\u03b1) -typed expression with FE (\u03b2) -typed expressions. More intuitive is M = N the program that executes M first to get its result x and then as program N x."}, {"heading": "3 Linguistic Phenomena as Effects", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Deixis", "text": "We will now try to use this calculation to do some semantics. Here is our tectogrammar in an abstract categorical grammar representation (6). John, Mary, me: NPloves: NP \u2212 DP \u00b7 Sp. [1] Mary: [2] JMaryK: [3] O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O \"O\" O"}, {"heading": "3.2 Quantification", "text": "We now turn our attention to quantifying noun phrases.every, a: N \u2212 \u043c NPman, Woman: NJeveryK: \"We want us to hold ourselves to the limits.\" (\"We want us to hold ourselves to the limits.\") (\"We want.\") (\"We want.\") (\"We want.\") (\"We want.\") (\"We want.\") (\"We want.\") (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\") (\"We want.\" (\"We want.\") (\"We want.\" (\") (\" We want. \") (\" We want. \"(\" We want. (\") (\" We want. \") (\" We want. \"(\" We want. \").\" (\"(\" We. \").\" (\"We.\" (. \").\" (\"We.\"). (\"We want.\" (. \"). (\") (\"(\"). (\"We want. (\"). (. (\"We want. (.\"). (\"). (. (\" We. (\"). (\" We want. (. (. \"). (. (. (. (.\"). (. (\"). (\"). (\"We want. (. (.\"). (. (. \"). (. (\"). (\"We want. (.\"). (. (. (. \"). ("}, {"heading": "3.3 Conventional Implicature", "text": "Our goal is to demonstrate the modularity of this approach and thus we will integrate another phenomenon into our growing fragment: conventional implications as analyzed by Potts (23). Specifically, we will focus on nominal implications. (4)) Jbest-friendK: = best friend (4), best friend (4), best friend (5), best friend (5), best friend (5), best friend (6), best friend (6), best friend (6), best friend (6), best friend (6), best friend (6), best friend (6), best friend (6), best (6), best (6), best (8), best (8), best (8), best (8), best (8), 8, 8, 8, 8 (8), 8, 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8, 8 (8), 8 (8), 8), 8, 8 (8), 8 (8), 8 (8), 8), 8 (8), 8 (8), 8 (8), 8), 8 (8), 8 (8), 8 (8), 8 (8), 8 (8), 8 (8), 8 (8) (8) (8) (8) (8) (8) (8) (8), 8) (8) (8) (8) (8) (8) (8) (8) (8), 8) (8) (8) (8), 8) (8) (8) (8) (8) (8) (8, 8) (8) (8) (8) (8) (8) (8) (8) (8) (8, 8) (8, 8) (8) (8) (8) (8) (8) (8) (8), 8) (8) (8) (8, 8,"}, {"heading": "3.4 Summary", "text": "Let us look back at the modularity of our approach and count how often, during the gradual development of our fragment, we either modify existing terms or explicitly mention previous effects in new terms. In quantifying: - in the old terms of verbs, we added the new SI handler so that clauses form a scope. In the addition of appositives and their conventional implications: - in the old terms of JsaiddsK, we added the new Accommodate handler to determine that conventional implications should not project from the cited language - in the new name of JapposK, we used the old SI handler to determine that appositives should form circumference islands. Otherwise, none of the denotations prescribed in our semantic lexicon needed to be changed."}, {"heading": "4 Properties of the Calculus", "text": "The calculation defined in section 2 to which we will refer has some satisfactory properties. First, the reduction rules preserve types of terms (subject reduction). The reduction relationship itself is fluid and, for well-typed terms, it is also terminating. This means that the type of reduction is strongly standardized. The proof of subject reduction is a mechanical proof by induction. Our reduction relationship is given as a set of rules that fit some patterns found in contracts from the rhetorical \"free variables.\" However, our language is also equipped with binding features, and so some of the rules are conditioned on whether certain variables occur in parts of the speech or not."}, {"heading": "5 Conclusion", "text": "In our article, we introduced a new calculus that is motivated by modelling detailed semantics and inspired by current work in programming language theory. Our calculus is an extension of the single-typed lambda calculus, which is de facto the lingua franca of semantics, and its purpose is to facilitate the communication of semantic ideas without having to rely on complex programming languages [19,15] and to do so with a well-defined formal semantics. We demonstrated the characteristics of our calculations using several examples showing phenomena such as divinity, quantification and conventional implications. While our calculation still requires some uninteresting plumbing work to be able to properly link all denotations, we have seen that the resulting denotations are very general. We have been able to add new phenomena without having to change much of what we have done before, and the changes we have made that appear to fit together the different places where the phenomena occurred."}], "references": [{"title": "Continuations and the nature of quantification", "author": ["C. Barker"], "venue": "Natural language semantics 10(3), 211\u2013242", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2002}, {"title": "Programming with algebraic effects and handlers", "author": ["A. Bauer", "M. Pretnar"], "venue": "arXiv preprint arXiv:1203.1539", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Programming and reasoning with algebraic effects and dependent types", "author": ["E. Brady"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "On the semantics of exceptional scope", "author": ["S. Charlow"], "venue": "Ph.D. thesis, New York University", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Towards abstract categorial grammars", "author": ["P. de Groote"], "venue": "Proceedings of the 39th Annual Meeting on Association for Computational Linguistics. pp. 252\u2013259. Association for Computational Linguistics", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2001}, {"title": "Towards a montagovian account of dynamics", "author": ["P. de Groote"], "venue": "Proceedings of SALT. vol. 16", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2006}, {"title": "Natural language semantics with enriched meanings", "author": ["G. Giorgolo", "A. Asudeh"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "On Logical Relations and Conservativity", "author": ["P. de Groote"], "venue": "NLCS\u201915. Third Workshop on Natural Language and Computer Science", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2015}, {"title": "Making computational sense of montague\u2019s intensional logic", "author": ["J. Hobbs", "S. Rosenschein"], "venue": "Artificial Intelligence 9(3), 287\u2013306", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1977}, {"title": "Handlers in action", "author": ["O. Kammar", "S. Lindley", "N. Oury"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "From discourse to logic: Introduction to modeltheoretic semantics of natural language, formal logic and discourse representation theory", "author": ["H. Kamp", "U. Reyle"], "venue": "No. 42, Kluwer Academic Pub", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1993}, {"title": "Applicative abstract categorial grammars", "author": ["O. Kiselyov"], "venue": "Proceedings of the Third Workshop on Natural Language and Computer Science", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2015}, {"title": "Extensible effects: an alternative to monad transformers", "author": ["O. Kiselyov", "A. Sabry", "C. Swords"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2013}, {"title": "C.c.: Lambda: the ultimate syntax-semantics interface", "author": ["O. Kiselyov", "Shan"], "venue": null, "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "Combinatory reduction systems: introduction and survey", "author": ["J.W. Klop", "V. Van Oostrom", "F. Van Raamsdonk"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1993}, {"title": "Term rewriting systems", "author": ["Klop", "J.W"], "venue": "Handbook of logic in computer science 2, 1\u2013116", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1992}, {"title": "Expression de la dynamique du discours \u00e0 l\u2019aide de continuations", "author": ["E. Lebedeva"], "venue": "Ph.D. thesis, Universit\u00e9 de Lorraine", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2012}, {"title": "Algebraic Effects and Handlers in Natural Language Interpretation", "author": ["J. Mar\u0161\u0301\u0131k", "M. Amblard"], "venue": "Natural Language and Computer Science", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "Functional programming with bananas, lenses, envelopes and barbed wire", "author": ["E. Meijer", "M. Fokkinga", "R. Paterson"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1991}, {"title": "Notions of computation and monads", "author": ["E. Moggi"], "venue": "Information and computation 93(1), 55\u201392", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1991}, {"title": "Handlers of algebraic effects", "author": ["G. Plotkin", "M. Pretnar"], "venue": "Programming Languages and Systems, pp. 80\u201394. Springer", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "The logic of conventional implicatures", "author": ["C. Potts"], "venue": "Oxford University Press", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2005}, {"title": "Logic and handling of algebraic effects", "author": ["M. Pretnar"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2010}, {"title": "Event in compositional dynamic semantics", "author": ["S. Qian", "M. Amblard"], "venue": "Logical Aspects of Computational Linguistics", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2011}, {"title": "Monads for natural language semantics", "author": ["C. Shan"], "venue": "arXiv cs/0205026", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2002}, {"title": "Linguistic side effects", "author": ["Shan", "C.c."], "venue": "Ph.D. thesis, Harvard University Cambridge, Massachusetts", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2005}, {"title": "Computational semantics with functional programming", "author": ["J. Van Eijck", "C. Unger"], "venue": "Cambridge University Press", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2010}, {"title": "The essence of functional programming", "author": ["P. Wadler"], "venue": "Proceedings of the 19th ACM SIGPLAN-SIGACT symposium on Principles of programming languages. pp. 1\u201314. ACM", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1992}], "referenceMentions": [{"referenceID": 24, "context": "It was previously observed [26] that the lambda terms and/or the denotations studied tend to follow the same pattern: they are instances of a monad.", "startOffset": 27, "endOffset": 31}, {"referenceID": 20, "context": "In this paper, we present an extension of the simplytyped lambda calculus that exploits this uniformity using the recently discovered technique of effect handlers [22].", "startOffset": 163, "endOffset": 167}, {"referenceID": 10, "context": "\u2013 the incremental algorithm used to build discourse representation structures in DRT, as presented in [12] \u2013 the \u03bb\u03bc calculus, used in [5] to analyze quantification, since, due to the lack of confluence, function terms do not denote functions over simple denotations \u2013 the use of exceptions and exception handlers in [18] to model presuppositions in an otherwise compositional framework \u2013 the parsetree interpretation step in the logic of conventional implicatures of [23] that builds the denotation of a sentence by extracting implicatures from the denotations of its subparts (including the non-immediate ones)", "startOffset": 102, "endOffset": 106}, {"referenceID": 16, "context": "\u2013 the incremental algorithm used to build discourse representation structures in DRT, as presented in [12] \u2013 the \u03bb\u03bc calculus, used in [5] to analyze quantification, since, due to the lack of confluence, function terms do not denote functions over simple denotations \u2013 the use of exceptions and exception handlers in [18] to model presuppositions in an otherwise compositional framework \u2013 the parsetree interpretation step in the logic of conventional implicatures of [23] that builds the denotation of a sentence by extracting implicatures from the denotations of its subparts (including the non-immediate ones)", "startOffset": 316, "endOffset": 320}, {"referenceID": 21, "context": "\u2013 the incremental algorithm used to build discourse representation structures in DRT, as presented in [12] \u2013 the \u03bb\u03bc calculus, used in [5] to analyze quantification, since, due to the lack of confluence, function terms do not denote functions over simple denotations \u2013 the use of exceptions and exception handlers in [18] to model presuppositions in an otherwise compositional framework \u2013 the parsetree interpretation step in the logic of conventional implicatures of [23] that builds the denotation of a sentence by extracting implicatures from the denotations of its subparts (including the non-immediate ones)", "startOffset": 467, "endOffset": 471}, {"referenceID": 0, "context": "the speaker and addressee for deixis, the current world for modality), since they amount to saying that a phrase denotes an indexed set of simpler meanings \u2013 the continuized semantics for quantification [1] in which denotations are functions of their own continuations \u2022 and more generally, any semantics using type raising or generalized quantifiers for noun phrase denotations \u2013 the dynamic denotations of [7] that are functions of the common ground and their continuation \u2013 compositional event semantics, such as the one in [25], that shift the denotations of sentences from truth-values to predicates on events", "startOffset": 203, "endOffset": 206}, {"referenceID": 5, "context": "the speaker and addressee for deixis, the current world for modality), since they amount to saying that a phrase denotes an indexed set of simpler meanings \u2013 the continuized semantics for quantification [1] in which denotations are functions of their own continuations \u2022 and more generally, any semantics using type raising or generalized quantifiers for noun phrase denotations \u2013 the dynamic denotations of [7] that are functions of the common ground and their continuation \u2013 compositional event semantics, such as the one in [25], that shift the denotations of sentences from truth-values to predicates on events", "startOffset": 408, "endOffset": 411}, {"referenceID": 23, "context": "the speaker and addressee for deixis, the current world for modality), since they amount to saying that a phrase denotes an indexed set of simpler meanings \u2013 the continuized semantics for quantification [1] in which denotations are functions of their own continuations \u2022 and more generally, any semantics using type raising or generalized quantifiers for noun phrase denotations \u2013 the dynamic denotations of [7] that are functions of the common ground and their continuation \u2013 compositional event semantics, such as the one in [25], that shift the denotations of sentences from truth-values to predicates on events", "startOffset": 527, "endOffset": 531}, {"referenceID": 19, "context": "\u2013 in denotational semantics to give the domain of interpretation for programming languages that involve side effects [21].", "startOffset": 117, "endOffset": 121}, {"referenceID": 27, "context": "\u2013 in functional programming to emulate programming with side effects via term-level encodings of effectful programs [29].", "startOffset": 116, "endOffset": 120}, {"referenceID": 25, "context": "The relationship between side effects in functional programming and computational semantics has been developed in several works [27,28], stretching as far back as 1977 [10].", "startOffset": 128, "endOffset": 135}, {"referenceID": 26, "context": "The relationship between side effects in functional programming and computational semantics has been developed in several works [27,28], stretching as far back as 1977 [10].", "startOffset": 128, "endOffset": 135}, {"referenceID": 8, "context": "The relationship between side effects in functional programming and computational semantics has been developed in several works [27,28], stretching as far back as 1977 [10].", "startOffset": 168, "endOffset": 172}, {"referenceID": 24, "context": "The usefulness of monads in particular has been discovered by Shan in 2002 [26].", "startOffset": 75, "endOffset": 79}, {"referenceID": 3, "context": "Charlow used the popular method of monad morphisms to combine several monads in his dissertation [4].", "startOffset": 97, "endOffset": 100}, {"referenceID": 6, "context": "Giorgolo and Asudeh have used distributive laws to combine monads [8], while Kiselyov has eschewed monads altogether in favor of applicative functors which enjoy easy composability [13].", "startOffset": 66, "endOffset": 69}, {"referenceID": 11, "context": "Giorgolo and Asudeh have used distributive laws to combine monads [8], while Kiselyov has eschewed monads altogether in favor of applicative functors which enjoy easy composability [13].", "startOffset": 181, "endOffset": 185}, {"referenceID": 1, "context": "Our approach follows the recent trend in adopting effects and handlers to combine side effects [2,11] and to encode effectful programs in pure functional programming languages [14,3].", "startOffset": 95, "endOffset": 101}, {"referenceID": 9, "context": "Our approach follows the recent trend in adopting effects and handlers to combine side effects [2,11] and to encode effectful programs in pure functional programming languages [14,3].", "startOffset": 95, "endOffset": 101}, {"referenceID": 12, "context": "Our approach follows the recent trend in adopting effects and handlers to combine side effects [2,11] and to encode effectful programs in pure functional programming languages [14,3].", "startOffset": 176, "endOffset": 182}, {"referenceID": 2, "context": "Our approach follows the recent trend in adopting effects and handlers to combine side effects [2,11] and to encode effectful programs in pure functional programming languages [14,3].", "startOffset": 176, "endOffset": 182}, {"referenceID": 18, "context": "See [20] for the introduction of banana brackets.", "startOffset": 4, "endOffset": 8}, {"referenceID": 22, "context": "When we say that an operator has arity \u03b2, where \u03b2 is a type, we mean that it takes one operand for every value of \u03b2 [24].", "startOffset": 116, "endOffset": 120}, {"referenceID": 18, "context": "See [20] for the difference.", "startOffset": 4, "endOffset": 8}, {"referenceID": 4, "context": "Here is our tectogrammar in an abstract categorial grammar presentation [6].", "startOffset": 72, "endOffset": 75}, {"referenceID": 11, "context": "8 Other solutions to this problem include separating the language of logical forms and the metalanguage used in the semantic lexical entries to manipulate logical forms as objects [13].", "startOffset": 180, "endOffset": 184}, {"referenceID": 7, "context": "9 Our C has been inspired by an operator of the same name proposed in [9]: de Groote introduces a structure that specializes applicative functors in a similar direction as monads by introducing the C operator and equipping it with certain laws; our C operator makes the FE type constructor an instance of this structure.", "startOffset": 70, "endOffset": 73}, {"referenceID": 21, "context": "Our goal is to show the modularity of this approach and so we will continue and plug in one more phenomenon into our growing fragment: conventional implicatures, as analyzed by Potts [23].", "startOffset": 183, "endOffset": 187}, {"referenceID": 14, "context": "Klop\u2019s Combinatory Reduction Systems (CRSs) [16] is one class of such rewriting systems.", "startOffset": 44, "endOffset": 48}, {"referenceID": 14, "context": "We will make use of the result that orthogonal CRSs are confluent [16].", "startOffset": 66, "endOffset": 70}, {"referenceID": 14, "context": "We refer the reader to [16] for the definition of CRSs.", "startOffset": 23, "endOffset": 27}, {"referenceID": 17, "context": "Its purpose is to facilitate the communication of semantic ideas without depending on complex programming languages [19,15] and to do so with a well-defined formal semantics.", "startOffset": 116, "endOffset": 123}, {"referenceID": 13, "context": "Its purpose is to facilitate the communication of semantic ideas without depending on complex programming languages [19,15] and to do so with a well-defined formal semantics.", "startOffset": 116, "endOffset": 123}, {"referenceID": 17, "context": "It will also be important to test the methodology on larger and more diverse fragments (besides this fragment, we have also created one combining anaphora, quantification and presupposition [19]).", "startOffset": 190, "endOffset": 194}, {"referenceID": 3, "context": "Last but not least, it would be interesting to delve deeper into the foundational differences between the approach used here, the monad transformers used by Charlow [4] and the applicative functors used by Kiselyov [13].", "startOffset": 165, "endOffset": 168}, {"referenceID": 11, "context": "Last but not least, it would be interesting to delve deeper into the foundational differences between the approach used here, the monad transformers used by Charlow [4] and the applicative functors used by Kiselyov [13].", "startOffset": 215, "endOffset": 219}], "year": 2017, "abstractText": "In compositional model-theoretic semantics, researchers assemble truth-conditions or other kinds of denotations using the lambda calculus. It was previously observed [26] that the lambda terms and/or the denotations studied tend to follow the same pattern: they are instances of a monad. In this paper, we present an extension of the simplytyped lambda calculus that exploits this uniformity using the recently discovered technique of effect handlers [22]. We prove that our calculus exhibits some of the key formal properties of the lambda calculus and we use it to construct a modular semantics for a small fragment that involves multiple distinct semantic phenomena.", "creator": "LaTeX with hyperref package"}}}