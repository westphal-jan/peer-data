{"id": "1606.06369", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Jun-2016", "title": "Contextual Weisfeiler-Lehman Graph Kernel For Malware Detection", "abstract": "In this paper, we propose a novel graph kernel specifically to address a challenging problem in the field of cyber-security, namely, malware detection. Previous research has revealed the following: (1) Graph representations of programs are ideally suited for malware detection as they are robust against several attacks, (2) Besides capturing topological neighbourhoods (i.e., structural information) from these graphs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods.", "histories": [["v1", "Tue, 21 Jun 2016 00:02:45 GMT  (145kb,D)", "http://arxiv.org/abs/1606.06369v1", null]], "reviews": [], "SUBJECTS": "cs.CR cs.LG", "authors": ["annamalai narayanan", "guozhu meng", "liu yang", "jinliang liu", "lihui chen"], "accepted": false, "id": "1606.06369"}, "pdf": {"name": "1606.06369.pdf", "metadata": {"source": "CRF", "title": "Contextual Weisfeiler-Lehman Graph Kernel For Malware Detection", "authors": ["Annamalai Narayanan", "Guozhu Meng", "Liu Yang", "Jinliang Liu", "Lihui Chen"], "emails": ["annamala002@e.ntu.edu.sg,", "yangliu}@ntu.edu.sg,", "liuj0081@e.ntu.edu.sg,", "elhchen@ntu.edu.sg"], "sections": [{"heading": null, "text": "This year it is so far that it will only be a matter of time before it is so far, until it is so far."}, {"heading": "II. BACKGROUND & MOTIVATION", "text": "In this section, we motivate the design of our kernel by describing why viewing only the structural information of PRG's 32PET data is insufficient to determine the malignancy of an example and how supplementing this example with contextual information helps to increase detection accuracy. To this end, we use a real-world request from Yahoo, but it does not steal the private information of the Geinimi family, which is aware of its behavior, with that of a well-known benign user, Yahoo Weather. The app is started by a background event such as receiving an SMS or a call. Once launched, it reads the user's personal information, such as geographical location and contacts, and leaks the same to a remote server. The (simplified) portion of malicious codes affecting the location information leak is shown in Fig. 1 (a) The method leaks the geographical location through latitude and longitudinal interfaces (APIs)."}, {"heading": "III. DEFINITIONS AND NOTATIONS", "text": "The formal definitions and notations used throughout the essay are explained in this section. Definition 1 (Program Representation Graph). PRG = (N, E, \u03bb, \u0430) is a directed graph where N is a series of nodes and each node n, N a program unit like a function or statement. E (N x N) is a set of edges and each edge e (n1, n2) E stands for either control or data flow or dependency from n1 to n2. \u03bb is a set of labels that characterize the (security-sensitive) operations of a node and ': N \u00b2 is a label function that assigns a label to each node."}, {"heading": "IV. CONTEXTUAL WEISFEILER-LEHMAN GRAPH KERNEL", "text": "In this section, we first explain how the regularWLK can be used for malware detection using PRGs and how it falls short. Then, we present our CWLK and discuss how it remedies the shortcomings of WLK. Finally, we prove the semi-definitivity of CWLK and analyze its temporal complexity."}, {"heading": "A. Regular Weisfeiler-Lehman Graph Kernel", "text": "WLK calculates the similarities between graphs based on the 1-dimensional WL check of graph isomorphisms (11). WL test of isomorphisms (11). Suppose we will determine whether a given pair of graphs G and G are called isomorphous. WL test of isomorphisms works by augmenting the node markers with the sorted graphs of adjacent nodes. This process is called label enrichment and new labels are called neighborhood markers. Thus, in each i iteration of the WL algorithm, we get a new label for each node n n, which includes the graph (s) that could optionally compress the ith-degree neighborhood by n. (n), using a hash function f."}, {"heading": "B. Contextual Weisfeiler-Lehman graph Kernel", "text": "The goal of CWLK is not only to capture neighborhoods around the node, but also to include the contexts in which each of the neighborhoods is reachable in the PRG. To this end, we modify the renaming step of WLK to take into account the context of each neighborhood. We refer to this process as contextual renaming and the sequence of the graphics obtained as a contextual WL sequence. Specifically, CWLK performs another step in the renaming process, which is to pin the contexts of each node to its neighborhood label, effectively indicating the contexts under which a particular neighborhood is reachable. The label obtained is referred to as a contextual neighborhood process. The contextual renaming process is detailed in Algorithm 1. The inputs for the algorithms are PRG, G and the degree of neighborhoods that are considered for renaming."}, {"heading": "V. EVALUATION", "text": "We conducted large-scale experiments with more than 50,000 Android apps from two real-world malware datasets to evaluate the accuracy and efficiency of CWLK. We compared the performance of CWLK with that of two modern cores and three Android malware detection solutions."}, {"heading": "A. Datasets", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "C. Experimental Design", "text": "Through our evaluations, we attempt to address the following research questions: (1) Has the inclusion of context information in PRGs by CWLK significantly improved the accuracy of malware detection? (2) Does the collection of context information lead to significant computational effort to impair efficiency? (3) Has our context-based detection approach surpassed existing malware detection solutions? Two separate experiments aim to address these questions. Experiment E1. To evaluate the first two questions, the following experiment is performed: First, the CGs of all training programs are constructed, then the WLK, NHGK, and CWLK kernels are applied to the CGs to obtain the respective kernel matrices, and then an SVM classifier is trained with each of these kernels to detect malicious apps. Finally, the test kits are used for apps."}, {"heading": "D. Results and Discussions", "text": "This year it is more than ever before in the history of the city."}, {"heading": "VI. CONCLUSION & FUTURE WORK", "text": "Unlike the existing cores, which capture only the security-sensitive neighborhoods in PRGs, CWLK captures these neighborhoods along with the context in which they are reachable, making CWLK more meaningful and, in turn, more accurate than existing kernels. Besides its meaningfulness, CWLK has two specific advantages: (1) demonstrates high efficiency, (2) supports the creation of explicit vector representations of PRGs. CWLK is evaluated in a large-scale experiment with more than 50,000 Android apps and shows that it outperforms two state-of-the-art graph cores and three malware detection techniques with respect to F-measures, while maintaining comparable efficiency."}, {"heading": "VII. ACKNOWLEDGMENT", "text": "We thank the authors of [4] and [5] for their suggestions that have helped us reimplement their methods. [1] Kaspersky 2014 Annual Threat Report. URL.https: / / securelist.com / files / 2015 / 12 / Kaspersky-Security-Bulletin2015 FINAL EN.pdf [2] Yang, Wei, et al. \"Appcontext: Differentiating malicious and benign mobile app behaviors using context.\" Proceedings of the International Conference on Software Engineering (ICSE). 2015. [3] Gascon, Hugo, et al. \"Structural detection of android malware using embedded call graphs.\" Proceedings of the Artificial intelligence and security. ACM, 2013. [4] Arp, Daniel, et al. \"Drebin: Effective and explain sustainable detection of android malware in your pocket.\""}], "references": [{"title": "Appcontext: Differentiating malicious and benign mobile app behaviors using context.", "author": ["Yang", "Wei"], "venue": "Proc. of the International Conference on Software Engineering (ICSE)", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2015}, {"title": "Structural detection of android malware using embedded call graphs.", "author": ["Gascon", "Hugo"], "venue": "Proceedings of the 2013 ACM workshop on Artificial intelligence and security. ACM,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Drebin: Effective and explainable detection of android malware in your pocket.", "author": ["Arp", "Daniel"], "venue": "Proceedings of the Annual Symposium on Network and Distributed System Security (NDSS)", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Empirical assessment of machine learning-based malware detectors for Android.", "author": ["Allix", "Kevin"], "venue": "Empirical Software Engineering", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "A machine learning approach to android malware detection.", "author": ["Sahs", "Justin", "Latifur Khan"], "venue": "Intelligence and Security Informatics Conference (EISIC), 2012 European", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Semantics-aware Android malware classification using weighted contextual API dependency graphs.", "author": ["Zhang", "Mu"], "venue": "Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security. ACM,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2014}, {"title": "Synthesizing near-optimal malware specifications from suspicious behaviors.", "author": ["Fredrikson", "Matt"], "venue": "Security and Privacy (SP),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Graph-based malware detection using dynamic analysis.", "author": ["Anderson", "Blake"], "venue": "Journal in Computer Virology", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Graph kernels.", "author": ["Vishwanathan", "S. Vichy N"], "venue": "The Journal of Machine Learning Research", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Weisfeiler-lehman graph kernels.", "author": ["Shervashidze", "Nino"], "venue": "The Journal of Machine Learning Research", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "A linear-time graph kernel.", "author": ["Hido", "Shohei", "Hisashi Kashima"], "venue": "Data Mining,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2009}, {"title": "Extending local features with contextual information in graph kernels", "author": ["N. Navarin", "A. Sperduti", "Tesselli", "November"], "venue": "In Neural Information Processing (pp", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "Fast neighborhood subgraph pairwise distance kernel.", "author": ["Costa", "Fabrizio", "Kurt De Grave"], "venue": "Proceedings of the 26th International Conference on Machine Learning. Omnipress,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2010}, {"title": "Protein function prediction via graph kernels.", "author": ["Borgwardt", "Karsten M"], "venue": "Bioinformatics 21.suppl", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2005}, {"title": "Assignment kernels for chemical compounds.", "author": ["Fr\u00f6hlich", "Holger", "J\u00f6rg K. Wegner", "Andreas Zell"], "venue": "Neural Networks,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "Graph kernels based on tree patterns for molecules.", "author": ["Mah\u00e9", "Pierre", "Jean-Philippe Vert"], "venue": "Machine learning", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Image classification with segmentation graph kernels.", "author": ["Harchaoui", "Z\u00e4id", "Francis Bach"], "venue": "Computer Vision and Pattern Recognition,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}], "referenceMentions": [{"referenceID": 0, "context": ", assembly code, call graphs) and detecting malicious code or behavior patterns using ML classifiers [2]\u2013[7].", "startOffset": 101, "endOffset": 104}, {"referenceID": 5, "context": ", assembly code, call graphs) and detecting malicious code or behavior patterns using ML classifiers [2]\u2013[7].", "startOffset": 105, "endOffset": 108}, {"referenceID": 1, "context": "Typically, the attackers produce large number of variants of the same malware by resorting to techniques such as variable renaming and junk code insertion [3, 4, 7, 8].", "startOffset": 155, "endOffset": 167}, {"referenceID": 2, "context": "Typically, the attackers produce large number of variants of the same malware by resorting to techniques such as variable renaming and junk code insertion [3, 4, 7, 8].", "startOffset": 155, "endOffset": 167}, {"referenceID": 5, "context": "Typically, the attackers produce large number of variants of the same malware by resorting to techniques such as variable renaming and junk code insertion [3, 4, 7, 8].", "startOffset": 155, "endOffset": 167}, {"referenceID": 6, "context": "Typically, the attackers produce large number of variants of the same malware by resorting to techniques such as variable renaming and junk code insertion [3, 4, 7, 8].", "startOffset": 155, "endOffset": 167}, {"referenceID": 1, "context": "However, higher level semantic representations such as call graphs, control- and data-flow graphs, control-, data- and program-dependency graphs mostly stay similar even when the code is considerably altered [3, 5, 7, 8].", "startOffset": 208, "endOffset": 220}, {"referenceID": 3, "context": "However, higher level semantic representations such as call graphs, control- and data-flow graphs, control-, data- and program-dependency graphs mostly stay similar even when the code is considerably altered [3, 5, 7, 8].", "startOffset": 208, "endOffset": 220}, {"referenceID": 5, "context": "However, higher level semantic representations such as call graphs, control- and data-flow graphs, control-, data- and program-dependency graphs mostly stay similar even when the code is considerably altered [3, 5, 7, 8].", "startOffset": 208, "endOffset": 220}, {"referenceID": 6, "context": "However, higher level semantic representations such as call graphs, control- and data-flow graphs, control-, data- and program-dependency graphs mostly stay similar even when the code is considerably altered [3, 5, 7, 8].", "startOffset": 208, "endOffset": 220}, {"referenceID": 6, "context": "In essence, such works cast malware detection as a graph classification problem and apply existing graph mining and classification techniques [8].", "startOffset": 142, "endOffset": 145}, {"referenceID": 0, "context": "Some methods such as [2, 3, 5] note that ML classifiers are readily applicable on data represented as vectors and attempt to encode PRGs as feature vectors.", "startOffset": 21, "endOffset": 30}, {"referenceID": 1, "context": "Some methods such as [2, 3, 5] note that ML classifiers are readily applicable on data represented as vectors and attempt to encode PRGs as feature vectors.", "startOffset": 21, "endOffset": 30}, {"referenceID": 3, "context": "Some methods such as [2, 3, 5] note that ML classifiers are readily applicable on data represented as vectors and attempt to encode PRGs as feature vectors.", "startOffset": 21, "endOffset": 30}, {"referenceID": 0, "context": "For instance, AppContext [2], a well-known Android malware detection approach represents apps as PRGs and ends up capturing features from individual nodes without their topological neighbourhood information.", "startOffset": 25, "endOffset": 28}, {"referenceID": 6, "context": ", [8]) are NP hard and have severe scalability issues, making them impractical for real-world malware detection [3, 9].", "startOffset": 2, "endOffset": 5}, {"referenceID": 1, "context": ", [8]) are NP hard and have severe scalability issues, making them impractical for real-world malware detection [3, 9].", "startOffset": 112, "endOffset": 118}, {"referenceID": 7, "context": ", [8]) are NP hard and have severe scalability issues, making them impractical for real-world malware detection [3, 9].", "startOffset": 112, "endOffset": 118}, {"referenceID": 9, "context": "Recently, efficient and expressive graph kernels such as [11]\u2013 [14] have been proposed and widely adopted in many application areas (e.", "startOffset": 57, "endOffset": 61}, {"referenceID": 12, "context": "Recently, efficient and expressive graph kernels such as [11]\u2013 [14] have been proposed and widely adopted in many application areas (e.", "startOffset": 63, "endOffset": 67}, {"referenceID": 13, "context": "g, bio- and chemo-informatics [15]\u2013[18]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 16, "context": "g, bio- and chemo-informatics [15]\u2013[18]).", "startOffset": 35, "endOffset": 39}, {"referenceID": 9, "context": "g, [11]\u2013[13]).", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "g, [11]\u2013[13]).", "startOffset": 8, "endOffset": 12}, {"referenceID": 1, "context": "Recently, three approaches [3], [6] and [9], have successfully demonstrated using these general purpose graph kernels for", "startOffset": 27, "endOffset": 30}, {"referenceID": 4, "context": "Recently, three approaches [3], [6] and [9], have successfully demonstrated using these general purpose graph kernels for", "startOffset": 32, "endOffset": 35}, {"referenceID": 7, "context": "Recently, three approaches [3], [6] and [9], have successfully demonstrated using these general purpose graph kernels for", "startOffset": 40, "endOffset": 43}, {"referenceID": 0, "context": ", structural) information from PRGs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods [2, 7] (explained in detail in \u00a7II).", "startOffset": 166, "endOffset": 172}, {"referenceID": 5, "context": ", structural) information from PRGs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods [2, 7] (explained in detail in \u00a7II).", "startOffset": 166, "endOffset": 172}, {"referenceID": 9, "context": "Many existing graph kernels such as [11] and [12] can capture and compare structural information from PRGs effectively.", "startOffset": 36, "endOffset": 40}, {"referenceID": 10, "context": "Many existing graph kernels such as [11] and [12] can capture and compare structural information from PRGs effectively.", "startOffset": 45, "endOffset": 49}, {"referenceID": 16, "context": "For similar domain-specific reasons, researchers from other fields such as computer vision [18], bio- and chemoinformatics [15]\u2013[17] have developed a number of kernels that specifically suit their applications.", "startOffset": 91, "endOffset": 95}, {"referenceID": 13, "context": "For similar domain-specific reasons, researchers from other fields such as computer vision [18], bio- and chemoinformatics [15]\u2013[17] have developed a number of kernels that specifically suit their applications.", "startOffset": 123, "endOffset": 127}, {"referenceID": 15, "context": "For similar domain-specific reasons, researchers from other fields such as computer vision [18], bio- and chemoinformatics [15]\u2013[17] have developed a number of kernels that specifically suit their applications.", "startOffset": 128, "endOffset": 132}, {"referenceID": 9, "context": "We apply this featureenrichment idea on a state-of-the-art graph kernel, namely, Weisfeiler-Lehman kernel (WLK) [11] to obtain the Contextual Weisfeiler-Lehman kernel (CWLK).", "startOffset": 112, "endOffset": 116}, {"referenceID": 5, "context": "As explained in [7] and [2], in the case of Android apps, one could determine whether a PRG node is reachable under user-aware or user-unaware context by examining its entry point nodes.", "startOffset": 16, "endOffset": 19}, {"referenceID": 0, "context": "As explained in [7] and [2], in the case of Android apps, one could determine whether a PRG node is reachable under user-aware or user-unaware context by examining its entry point nodes.", "startOffset": 24, "endOffset": 27}, {"referenceID": 6, "context": "the guard conditions that govern the execution of a node could be considered as its context [8].", "startOffset": 92, "endOffset": 95}, {"referenceID": 0, "context": "desktop OS) binaries, Android and iOS mobile apps typically have multiple entry points [2, 7].", "startOffset": 87, "endOffset": 93}, {"referenceID": 5, "context": "desktop OS) binaries, Android and iOS mobile apps typically have multiple entry points [2, 7].", "startOffset": 87, "endOffset": 93}, {"referenceID": 9, "context": "WLK computes the similarities between graphs based on the 1-dimensional WL test of graph isomorphism [11].", "startOffset": 101, "endOffset": 105}, {"referenceID": 9, "context": "For a detailed derivation and analysis of the time complexity of WLK, we refer the reader to [11].", "startOffset": 93, "endOffset": 97}, {"referenceID": 9, "context": "However, as mentioned in [11], a Bag-of-Features (BoF) model based optimization could be performed to arrive the kernel matrix in O(Khe+Khn) time.", "startOffset": 25, "endOffset": 29}, {"referenceID": 11, "context": "Two recently proposed graph kernels [13] and [14], consider incorporating the spatial context information to neighborhood subgraph features.", "startOffset": 36, "endOffset": 40}, {"referenceID": 12, "context": "Two recently proposed graph kernels [13] and [14], consider incorporating the spatial context information to neighborhood subgraph features.", "startOffset": 45, "endOffset": 49}, {"referenceID": 11, "context": "This reachability context is different from spatial context discussed in [13] and [14].", "startOffset": 73, "endOffset": 77}, {"referenceID": 12, "context": "This reachability context is different from spatial context discussed in [13] and [14].", "startOffset": 82, "endOffset": 86}, {"referenceID": 2, "context": "TABLE I: Composition of dataset Portion of dataset Dataset source # of samples Malware portion DREBIN [4], Virus Share [19] 29877 Benign portion Google Play [20] 25000 TABLE II: Dataset Statistics", "startOffset": 102, "endOffset": 105}, {"referenceID": 2, "context": "DREBIN [4] provides a collection on 5,560 Android malware apps collected from 2010 to 2012.", "startOffset": 7, "endOffset": 10}, {"referenceID": 5, "context": "The procedure proposed in DroidSIFT [7] is used to identify and categorize each entry point as being in \u2018user-aware\u2019 or \u2018user-unaware\u2019 context.", "startOffset": 36, "endOffset": 39}, {"referenceID": 9, "context": "CWLK\u2019s accuracy and efficiency is compared against those of WLK [11] and Neigh-", "startOffset": 64, "endOffset": 68}, {"referenceID": 10, "context": "borhood Hash Graph Kernel (NHGK) [12].", "startOffset": 33, "endOffset": 37}, {"referenceID": 2, "context": "Also, our approach is compared against three light-weight state-of-theart ML based Android malware detection solutions, namely, DREBIN [4], Allix et al.", "startOffset": 135, "endOffset": 138}, {"referenceID": 3, "context": "[5] and ADAGIO [3].", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[5] and ADAGIO [3].", "startOffset": 15, "endOffset": 18}, {"referenceID": 2, "context": "DREBIN [4] considers features such as sensitive Android APIs, permissions and components used by apps.", "startOffset": 7, "endOffset": 10}, {"referenceID": 3, "context": "[5] constructs the CFGs of individual methods and represent them as signature strings which are subsequently used as features.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "ADAGIO [3] constructs CGs and uses byte-code instructions to assign labels to nodes.", "startOffset": 7, "endOffset": 10}, {"referenceID": 10, "context": "NHGK [12] is used to extract CG neighborhoods as features and a histogram-intersection (HI) kernel SVM is trained to detect malware.", "startOffset": 5, "endOffset": 9}, {"referenceID": 2, "context": "In order to address question (3), we subject DREBIN [4], Allix et al.", "startOffset": 52, "endOffset": 55}, {"referenceID": 3, "context": "[5] and ADAGIO [3] solutions to the same training and test sets.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[5] and ADAGIO [3] solutions to the same training and test sets.", "startOffset": 15, "endOffset": 18}, {"referenceID": 3, "context": "Standard evaluation metrics such as Precision, Recall and F-measure are used to determine the effectiveness of malware detection [5].", "startOffset": 129, "endOffset": 132}, {"referenceID": 9, "context": "CG WLK [11] 71.", "startOffset": 7, "endOffset": 11}, {"referenceID": 10, "context": "88) NHGK [12] 63.", "startOffset": 9, "endOffset": 13}, {"referenceID": 9, "context": "ICFG WLK [11] 85.", "startOffset": 9, "endOffset": 13}, {"referenceID": 10, "context": "80) NHGK [12] 68.", "startOffset": 9, "endOffset": 13}, {"referenceID": 10, "context": "For further details on this limitation of NHGK, we refer the reader to the original work at [12] (particularly Section 5 where the authors discuss this limitation in detail).", "startOffset": 92, "endOffset": 96}, {"referenceID": 2, "context": "DREBIN [4] 97.", "startOffset": 7, "endOffset": 10}, {"referenceID": 3, "context": "[5] 88.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "54) ADAGIO [3] 92.", "startOffset": 11, "endOffset": 14}, {"referenceID": 8, "context": "In particular, it is more efficient than the classic walk-, tree- and path-based graph kernels (discussed in [10]) and is suitable for large-scale malware detection.", "startOffset": 109, "endOffset": 113}, {"referenceID": 10, "context": "In our future work, we plan to investigate incorporating contextual information in other sub-structure based graph kernels such as [12] and [14] and subsequently, study their suitability for performing malware detection.", "startOffset": 131, "endOffset": 135}, {"referenceID": 12, "context": "In our future work, we plan to investigate incorporating contextual information in other sub-structure based graph kernels such as [12] and [14] and subsequently, study their suitability for performing malware detection.", "startOffset": 140, "endOffset": 144}], "year": 2016, "abstractText": "In this paper, we propose a novel graph kernel specifically to address a challenging problem in the field of cyber-security, namely, malware detection. Previous research has revealed the following: (1) Graph representations of programs are ideally suited for malware detection as they are robust against several attacks, (2) Besides capturing topological neighbourhoods (i.e., structural information) from these graphs it is important to capture the context under which the neighbourhoods are reachable to accurately detect malicious neighbourhoods. We observe that state-of-the-art graph kernels, such as Weisfeiler-Lehman kernel (WLK) capture the structural information well but fail to capture contextual information. To address this, we develop the Contextual Weisfeiler-Lehman kernel (CWLK) which is capable of capturing both these types of information. We show that for the malware detection problem, CWLK is more expressive and hence more accurate than WLK while maintaining comparable efficiency. Through our largescale experiments with more than 50,000 real-world Android apps, we demonstrate that CWLK outperforms two state-ofthe-art graph kernels (including WLK) and three malware detection techniques by more than 5.27% and 4.87% F-measure, respectively, while maintaining high efficiency. This high accuracy and efficiency make CWLK suitable for large-scale real-world malware detection. keywords \u2014 graph kernels, malware detection, program analysis", "creator": "LaTeX with hyperref package"}}}