{"id": "1606.08130", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jun-2016", "title": "Propagators and Solvers for the Algebra of Modular Systems", "abstract": "Solving complex problems can involve non-trivial combinations of distinct knowledge bases and problem solvers. The Algebra of Modular Systems is a knowledge representation framework that provides a method for formally specifying such systems in purely semantic terms. Formally, an expression of the algebra defines a class of structures. Many expressive formalism used in practice solve the model expansion task, where a structure is given on the input and an expansion of this structure in the defined class of structures is searched (this practice overcomes the common undecidability problem for expressive logics). In this paper, we construct a solver for the model expansion task for a complex modular systems from an expression in the algebra and black-box propagators or solvers for the primitive modules. To this end, we define a general notion of propagators equipped with an explanation mechanism, an extension of the alge- bra to propagators, and a lazy conflict-driven learning algorithm. The result is a framework for seamlessly combining solving technology from different domains to produce a solver for a combined system.", "histories": [["v1", "Mon, 27 Jun 2016 05:53:57 GMT  (57kb)", "http://arxiv.org/abs/1606.08130v1", null], ["v2", "Mon, 3 Apr 2017 07:50:50 GMT  (881kb)", "http://arxiv.org/abs/1606.08130v2", "To appear in the proceedings of LPAR 21"]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["bart bogaerts", "eugenia ternovska", "david mitchell"], "accepted": false, "id": "1606.08130"}, "pdf": {"name": "1606.08130.pdf", "metadata": {"source": "CRF", "title": "Propagators and Solvers for the Algebra of Modular Systems", "authors": ["Bart Bogaerts", "David Mitchell"], "emails": ["bart.bogaerts@aalto.fi", "ter@cs.sfu.ca", "mitchell@cs.sfu.ca"], "sections": [{"heading": null, "text": "ar Xiv: 160 6.08 130v 1 [cs.A I] 2 7Ju n20 16Many expressive formalisms used in practice solve the problem of model extension, in which a structure is given on the input and an extension of this structure is sought in the defined structure class (this practice overcomes the usual problem of indecisiveness for expressive logic).In this paper we construct a solver for the task of model extension for complex modular systems consisting of an expression in algebra and black box propagators or solvers for primitive modules. To this end, we define a general idea of propagators equipped with an explanatory mechanism, an extension of algebra to propagators and a lazy conflict-driven learning algorithm. The result is a framework for seamlessly combining solution technologies from different areas to produce a solver for a combined system."}, {"heading": "1 Introduction", "text": "Almost all non-trivial commercial software systems use libraries of reusable components, and the theory of combining conventional imperative programs is relatively well developed. However, in knowledge-intensive computer systems characterized by the use of so-called declarative programming, research into reusable techniques is not very developed. It would be desirable to use a program written in Answer Set Programming (ASP) with a specification of an Integer Liner Program (ILP) as building blocks in a complex application, such a programming method, which may be found by existing components on the Web, would be extremely useful. The main challenge is that the programs can be written in different languages (even Legacy Languages), and rely on different solving technologies based on the semantic level of algebra of modular systems [38, 39]. Formally, a module in this algebra represents a class of structures, independently of each other."}, {"heading": "2 Modular Systems", "text": "Structures A (relational) 3 Vocabulary is a finite series of predicate symbols Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) A (ununiform) Q (ununiform) Q (ununiform) A (ununiform) Q (ununiform) Q (ununiform) Q) A (ununiform) Q) Q (ununiform) Q (ununiform) A (ununiform) Q (ununiform) Q) A (ununiform) Q) A (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q) A (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q) Q (ununiform) Q (ununiform) Q) A (ununiform) Q (ununiform) Q) A (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q (ununiform) Q ("}, {"heading": "3 Propagators and Solvers", "text": "We define a general idea of propagators. We show how propagators for atomic modules can be assembled into propagators for compound modules (A = > A). Intuitively, a propagator is a black box process that refines a partial (quadrivalent) structure by deriving consequences from a given module. \u2022 Definition 3.1. A propagator is a mapping of P from partial structures to partial structures, so the following sentence applies: \u2022 P is \u2264 p-monotonous: whenever A-A structure is derived. \u2022 P is information-conserving: P (A) \u2265 p for each A. Definition 3.2. In the face of a module E, a propagator P is \u2264 -P-monotonous: whenever A structures with two valents, it agrees with E, i.e. whenever A is bilateral, P (A) = A, when A-E, and P (A) is consistent with two valents, \"A-E can never lose.\""}, {"heading": "4 Explanations and Learning", "text": "In many different areas propagators are defined to explain their propagations in terms of simpler constructs = an initial explanation. For example, in CDCLbased ASP Solvers [17, 2, 12], the unfounded propagator sentence explains its propagation using clauses. Similar explanations are generated for complex constraints in programming (this is the lazy clause generation paradigm [37]) and in SAT modulo theories [15]. The idea of generating clauses to explain complex constraints has existed for a long time, see e.g. [29]. In integral programming, the method of interface [11] is used to force a solution to be more integral. In this methodology, when a rational interface is found that explains why this particular solution should be rejected, the idea of mutual abstraction [9] begins to detach from the idea [9]."}, {"heading": "A Conflict-Driven Learning Algorithm", "text": "The CDCL algorithms for SAT are at the heart of modern SAT solutions (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (B) (B) (B) (B) (B) (A) (A) (B) (A) (A) (A) (A) (A) (A) (A) (A) (A) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (B) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A) (A (A) (A) (A) (A) (A) (A) (A) (A) (A) ("}, {"heading": "5 Modular patterns", "text": "The first two optimizations are based on techniques recently used to obtain different SAT solvers to obtain a QBF solution. Disjunction of modules The separation of two modules is defined as E1 + E2 = (\u2212 E1), the latter optimization is based on techniques recently used to obtain a QBF solution. Separation of two modules is defined as E1 + E2 = (\u2212 E2). We define a propagator P1 + P2: A 7 \u2192 glb \u2264 p (P1), P2 (A)."}, {"heading": "6 Conclusion and Future Work", "text": "In this essay, we define general concepts of explanations and extenders for modular systems. We extended the algebra of modular systems to modular extenders and showed how to build solutions from extenders and vice versa. This means that we argued that our concept of extender generalizes terms from different areas. Furthermore, we added a concept of explanations to our extenders. These explanations generalize concepts from response programming, limitation programming, linear programming and more. We used these explanations to build learner redeemers and discussed how learner can be extended with a conflict analysis method, which effectively leads to a generalization of CDCL for arbitrary proof systems. Finally, we discussed several patterns of modular expressions, for which a more precise propagation is possible, than what would be achieved by the creation of the dissemination solutions according to the compositional rules, extensions, extensions, extensions, extensions, extensions, extensions, extensions."}], "references": [{"title": "WASP: A native ASP solver based on constraint learning", "author": ["Mario Alviano", "Carmine Dodaro", "Wolfgang Faber", "Nicola Leone", "Francesco Ricca"], "venue": "Proceedings of LPNMR,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Propagating logical combinations of constraints", "author": ["Fahiem Bacchus", "Toby Walsh"], "venue": "Proceedings of IJCAI, pp", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Heterogeneous constraint solving", "author": ["Fr\u00e9d\u00e9ric Benhamou"], "venue": "Proceedings of ALP, pp", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1996}, {"title": "Answer set programming modulo acyclicity", "author": ["Jori Bomanson", "Martin Gebser", "Tomi Janhunen", "Benjamin Kaufmann", "Torsten Schaub"], "venue": "Proceedings of LPNMR,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Towards \u201cpropagation = logic + control\u201d", "author": ["Sebastian Brand", "Roland H.C. Yap"], "venue": "Proceedings of ICLP, pp", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2006}, {"title": "Counterexample-guided abstraction refinement for symbolic model checking", "author": ["Edmund M. Clarke", "Orna Grumberg", "Somesh Jha", "Yuan Lu", "Helmut Veith"], "venue": "J. ACM,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2003}, {"title": "A relational model of data for large shared data banks", "author": ["E.F. Codd"], "venue": "Communications of the ACM,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1970}, {"title": "Solution of a largescale traveling-salesman problem", "author": ["G Dantzig", "R Fulkerson", "S Johnson"], "venue": "Operations Research,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1954}, {"title": "Model expansion in the presence of function symbols using constraint programming", "author": ["Broes De Cat", "Bart Bogaerts", "Jo Devriendt", "Marc Denecker"], "venue": "Proceedings of ICTAI,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Lazy model expansion: Interleaving grounding with search", "author": ["Broes De Cat", "Marc Denecker", "Maurice Bruynooghe", "Peter J. Stuckey"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "Lazy clause generation reengineered", "author": ["Thibaut Feydy", "Peter J. Stuckey"], "venue": "Proceedings of CP,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "DPLL(T): Fast decision procedures", "author": ["Harald Ganzinger", "George Hagen", "Robert Nieuwenhuis", "Albert Oliveras", "Cesare Tinelli"], "venue": "Proceedings of CAV, pp", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2004}, {"title": "SAT modulo graphs: Acyclicity", "author": ["Martin Gebser", "Tomi Janhunen", "Jussi Rintanen"], "venue": "Proceedings of JELIA, pp", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2014}, {"title": "Conflictdriven answer set solving: From theory to practice", "author": ["Martin Gebser", "Benjamin Kaufmann", "Torsten Schaub"], "venue": "AIJ, 187,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Systems integrating answer set programming and constraint programming", "author": ["Michael Gelfond", "Veena S. Mellarkod", "Yuanlin Zhang"], "venue": "Proceedings of LaSh, pp", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "Bridging the gap between dual propagation and CNF-based QBF solving", "author": ["Alexandra Goultiaeva", "Martina Seidl", "Armin Biere"], "venue": "Proceedings of DATE,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Structural tractability of propagated constraints", "author": ["Martin J. Green", "Christopher Jefferson"], "venue": "Proceedings of CP,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}, {"title": "SAT-TO- SAT: Declarative extension of SAT solvers with new propagators", "author": ["Tomi Janhunen", "Shahab Tasharrofi", "Eugenia Ternovska"], "venue": "in To Appear in the Proceedings of AAAI,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2016}, {"title": "Solving QBF by clause selection", "author": ["Mikol\u00e1s Janota", "Joao Marques-Silva"], "venue": "Proceedings of IJCAI, pp", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2015}, {"title": "An efficient filtering algorithm for disjunction of constraints", "author": ["Olivier Lhomme"], "venue": "Proceedings of CP,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2003}, {"title": "Arc-consistency filtering algorithms for logical combinations of constraints", "author": ["Olivier Lhomme"], "venue": "Proceedings of CPAIOR,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2004}, {"title": "Conflict-driven clause learning SAT solvers", "author": ["Jo\u00e3o P. Marques Silva", "In\u00eas Lynce", "Sharad Malik"], "venue": "Handbook of Satisfiability,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "GRASP: A search algorithm for propositional satisfiability", "author": ["Jo\u00e3o P. Marques-Silva", "Karem A. Sakallah"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1999}, {"title": "Hard problems for CSP algorithms", "author": ["David G. Mitchell"], "venue": "Proceedings of AAAI, pp", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1998}, {"title": "Clause-learning for modular systems", "author": ["David G. Mitchell", "Eugenia Ternovska"], "venue": "Proceedings of LPNMR, pp", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2015}, {"title": "Constructive disjunction in oz", "author": ["Tobias M\u00fcller", "J\u00f6rg W\u00fcrtz"], "venue": "Proceedings of WLP,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1995}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis\u2013Putnam\u2013 Logemann\u2013Loveland procedure to DPLL(T)", "author": ["Robert Nieuwenhuis", "Albert Oliveras", "Cesare Tinelli"], "venue": "J. ACM,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2006}, {"title": "ASP modulo CSP: The clingcon system", "author": ["Max Ostrowski", "Torsten Schaub"], "venue": "TPLP, 12(4\u20135),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2012}, {"title": "A comparative study of 2QBF algorithms", "author": ["Darsh P. Ranjan", "Daijue Tang", "Sharad Malik"], "venue": "Online Proceedings of SAT,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2004}, {"title": "Lazy satisability modulo theories", "author": ["Roberto Sebastiani"], "venue": "JSAT, 3(3-4),", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "Lazy clause generation: Combining the power of SAT and CP (and MIP?) solving\u2019, in CPAIOR", "author": ["Peter J. Stuckey"], "venue": null, "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2010}, {"title": "A semantic account for modularity in multi-language modelling of search problems", "author": ["Shahab Tasharrofi", "Eugenia Ternovska"], "venue": "Proceedings of FroCoS,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2011}, {"title": "Three semantics for modular systems", "author": ["Shahab Tasharrofi", "Eugenia Ternovska"], "venue": "Proceedings of NMR,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2014}, {"title": "Modular systems: Semantics, complexity", "author": ["Shahab Tasharrofi", "Eugenia Ternovska"], "venue": "Proceedings of HR workshop,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2015}, {"title": "Static and dynamic views on the algebra of modular systems", "author": ["Eugenia Ternovska"], "venue": "Proceedings of NMR,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2016}, {"title": "The wellfounded semantics for general logic programs", "author": ["Allen Van Gelder", "Kenneth A. Ross", "John S. Schlipf"], "venue": "J. ACM,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 1991}, {"title": "Constructive disjunction revisited", "author": ["J\u00f6rg W\u00fcrtz", "Tobias M\u00fcller"], "venue": "Proceedings of KI, pp", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 1996}, {"title": "Towards a symmetric treatment of satisfaction and conflicts in quantified boolean formula evaluation", "author": ["Lintao Zhang", "Sharad Malik"], "venue": "Proceedings of CP,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2002}], "referenceMentions": [{"referenceID": 31, "context": "The main challenge is that the programs may be written in different languages (even legacy languages), and rely on different solving technologies Integration on the semantic level has been achieved in the Algebra of Modular Systems [38, 39].", "startOffset": 232, "endOffset": 240}, {"referenceID": 32, "context": "The main challenge is that the programs may be written in different languages (even legacy languages), and rely on different solving technologies Integration on the semantic level has been achieved in the Algebra of Modular Systems [38, 39].", "startOffset": 232, "endOffset": 240}, {"referenceID": 6, "context": "Algebraical operations to manipulate such classes are defined, essentially generalising Codd\u2019s Relation Algebra [10] from tables to classes of structures.", "startOffset": 112, "endOffset": 116}, {"referenceID": 30, "context": "We equip these propagators with an explanation mechanism that generalises lazy clause generation [37], cutting plane generation [11] and counterexample-guided abstraction-refinement [9] (see Section 4, in particular Examples 4.", "startOffset": 97, "endOffset": 101}, {"referenceID": 7, "context": "We equip these propagators with an explanation mechanism that generalises lazy clause generation [37], cutting plane generation [11] and counterexample-guided abstraction-refinement [9] (see Section 4, in particular Examples 4.", "startOffset": 128, "endOffset": 132}, {"referenceID": 5, "context": "We equip these propagators with an explanation mechanism that generalises lazy clause generation [37], cutting plane generation [11] and counterexample-guided abstraction-refinement [9] (see Section 4, in particular Examples 4.", "startOffset": 182, "endOffset": 185}, {"referenceID": 22, "context": "We furthermore extend solvers based on these modular propagators with a conflict-analysis method that generalises resolution from conflict-driven clause learning [28].", "startOffset": 162, "endOffset": 166}, {"referenceID": 14, "context": "Examples include but are not limited to [18, 4, 33].", "startOffset": 40, "endOffset": 51}, {"referenceID": 27, "context": "Examples include but are not limited to [18, 4, 33].", "startOffset": 40, "endOffset": 51}, {"referenceID": 26, "context": "Combined solving is perhaps most developed in the SAT modulo theories (SMT) community, where theory propagations are tightly interleaved with satisfiability solving [32, 36].", "startOffset": 165, "endOffset": 173}, {"referenceID": 29, "context": "Combined solving is perhaps most developed in the SAT modulo theories (SMT) community, where theory propagations are tightly interleaved with satisfiability solving [32, 36].", "startOffset": 165, "endOffset": 173}, {"referenceID": 12, "context": "For example, acyclicity is added to SAT and ASP as a special propagator [16, 7].", "startOffset": 72, "endOffset": 79}, {"referenceID": 3, "context": "For example, acyclicity is added to SAT and ASP as a special propagator [16, 7].", "startOffset": 72, "endOffset": 79}, {"referenceID": 4, "context": "Combining propagators has been studied in detail in constraint programming [8, 20, 23].", "startOffset": 75, "endOffset": 86}, {"referenceID": 16, "context": "Combining propagators has been studied in detail in constraint programming [8, 20, 23].", "startOffset": 75, "endOffset": 86}, {"referenceID": 2, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 145, "endOffset": 151}, {"referenceID": 25, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 184, "endOffset": 196}, {"referenceID": 36, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 184, "endOffset": 196}, {"referenceID": 19, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 184, "endOffset": 196}, {"referenceID": 20, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 260, "endOffset": 267}, {"referenceID": 1, "context": "This research is often limited to a subset of the operations we consider here, for instance studying only conjunction of two constraint programs [5, 1], disjunction of two constraints [31, 43, 24] or connectives from propositional logic applied to constraints [25, 3].", "startOffset": 260, "endOffset": 267}, {"referenceID": 16, "context": "Second, the traditional treatment of propagation emphasises tractability [20] (the focus is on propagators that can be computed in polynomial time).", "startOffset": 73, "endOffset": 77}, {"referenceID": 30, "context": "Third, we equip our propagators with a learning mechanism that generalizes for instance lazy clause generation [37] from constraint programming and a conflict analysis mechanism that generalises conflict-driven clause learning [28] from SAT [27].", "startOffset": 111, "endOffset": 115}, {"referenceID": 22, "context": "Third, we equip our propagators with a learning mechanism that generalizes for instance lazy clause generation [37] from constraint programming and a conflict analysis mechanism that generalises conflict-driven clause learning [28] from SAT [27].", "startOffset": 227, "endOffset": 231}, {"referenceID": 21, "context": "Third, we equip our propagators with a learning mechanism that generalizes for instance lazy clause generation [37] from constraint programming and a conflict analysis mechanism that generalises conflict-driven clause learning [28] from SAT [27].", "startOffset": 241, "endOffset": 245}, {"referenceID": 31, "context": "In earlier papers [38, 39], the algebra was presented slightly differently; here, we restrict to a minimal syntax; this is discussed in detail in Section 5.", "startOffset": 18, "endOffset": 26}, {"referenceID": 32, "context": "In earlier papers [38, 39], the algebra was presented slightly differently; here, we restrict to a minimal syntax; this is discussed in detail in Section 5.", "startOffset": 18, "endOffset": 26}, {"referenceID": 24, "context": "Mitchell and Ternovska [30] have defined methods to apply the lazy clause generation (LCG) paradigm [14] to solve the model expansion problem for modular systems.", "startOffset": 23, "endOffset": 27}, {"referenceID": 10, "context": "Mitchell and Ternovska [30] have defined methods to apply the lazy clause generation (LCG) paradigm [14] to solve the model expansion problem for modular systems.", "startOffset": 100, "endOffset": 104}, {"referenceID": 35, "context": "largest unfounded set of P with respect to A [42].", "startOffset": 45, "endOffset": 49}, {"referenceID": 6, "context": "This structure encodes that the value of c is in the interval [10, 90] and d in the interval [20, 80].", "startOffset": 62, "endOffset": 70}, {"referenceID": 16, "context": "This structure encodes that the value of c is in the interval [10, 90] and d in the interval [20, 80].", "startOffset": 93, "endOffset": 101}, {"referenceID": 33, "context": "That is not surprising, since Tasharrofi and Ternovska [40] already showed that the projection operation increases the complexity of the task of deciding whether a structure is a member of a given module or not.", "startOffset": 55, "endOffset": 59}, {"referenceID": 13, "context": "For instance in CDCLbased ASP solvers [17, 2, 12], the unfounded set propagator explains its propagation by means of clauses.", "startOffset": 38, "endOffset": 49}, {"referenceID": 0, "context": "For instance in CDCLbased ASP solvers [17, 2, 12], the unfounded set propagator explains its propagation by means of clauses.", "startOffset": 38, "endOffset": 49}, {"referenceID": 8, "context": "For instance in CDCLbased ASP solvers [17, 2, 12], the unfounded set propagator explains its propagation by means of clauses.", "startOffset": 38, "endOffset": 49}, {"referenceID": 30, "context": "Similar explanations are generated for complex constraints in constraint programming (this is the lazy clause generation paradigm [37]) and in SAT modulo theories [15].", "startOffset": 130, "endOffset": 134}, {"referenceID": 11, "context": "Similar explanations are generated for complex constraints in constraint programming (this is the lazy clause generation paradigm [37]) and in SAT modulo theories [15].", "startOffset": 163, "endOffset": 167}, {"referenceID": 23, "context": "[29].", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": "In integer programming, the cutting plane method [11] is used to enforce a solution to be integer.", "startOffset": 49, "endOffset": 53}, {"referenceID": 5, "context": "Similarly, in QBF solving, counterexampleguided abstraction-refinement (the CEGAR methodology) counterexample guided abstraction-refinement [9] starts from the idea to first solve a relaxed problem (an abstraction), and on-the-fly add explanations why a certain solution to the relaxation is rejected.", "startOffset": 140, "endOffset": 143}, {"referenceID": 9, "context": "[13] defined a methodology where complex formulas are grounded on-the-fly.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "This particular explanation is used for instance in MinisatID [12] and many other lazy clause generation", "startOffset": 62, "endOffset": 66}, {"referenceID": 9, "context": "When grounding lazily [13], one can consider propagators P\u03c6 that perform some form of propagation for a first-order formula \u03c6.", "startOffset": 22, "endOffset": 26}, {"referenceID": 32, "context": ", [39]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 32, "context": ", [39]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 17, "context": "[21] recently defined a solver that combines two SAT solver.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "If the result of this call is not empty, it propagates a conflict and generates an explanation using Explain(A|\u03c4) (see [21] for details).", "startOffset": 119, "endOffset": 123}, {"referenceID": 28, "context": "It actually forms to essence of many SAT-based QBF algorithms [34, 44, 19, 22].", "startOffset": 62, "endOffset": 78}, {"referenceID": 37, "context": "It actually forms to essence of many SAT-based QBF algorithms [34, 44, 19, 22].", "startOffset": 62, "endOffset": 78}, {"referenceID": 15, "context": "It actually forms to essence of many SAT-based QBF algorithms [34, 44, 19, 22].", "startOffset": 62, "endOffset": 78}, {"referenceID": 18, "context": "It actually forms to essence of many SAT-based QBF algorithms [34, 44, 19, 22].", "startOffset": 62, "endOffset": 78}, {"referenceID": 17, "context": "[21] further improved this method by introducing a notion of an underapproximation.", "startOffset": 0, "endOffset": 4}, {"referenceID": 34, "context": "The Algebra of Modular Systems has been extended with a recursion operator (see for instance [41]); researching what are good propagators for this operator is an open challenge.", "startOffset": 93, "endOffset": 97}], "year": 2017, "abstractText": "Solving complex problems can involve non-trivial combinations of distinct knowledge bases and problem solvers. The Algebra of Modular Systems is a knowledge representation framework that provides a method for formally specifying such systems in purely semantic terms. Formally, an expression of the algebra defines a class of structures. Many expressive formalism used in practice solve the model expansion task, where a structure is given on the input and an expansion of this structure in the defined class of structures is searched (this practice overcomes the common undecidability problem for expressive logics). In this paper, we construct a solver for the model expansion task for a complex modular systems from an expression in the algebra and black-box propagators or solvers for the primitive modules. To this end, we define a general notion of propagators equipped with an explanation mechanism, an extension of the algebra to propagators, and a lazy conflict-driven learning algorithm. The result is a framework for seamlessly combining solving technology from different domains to produce a solver for a combined system.", "creator": "LaTeX with hyperref package"}}}