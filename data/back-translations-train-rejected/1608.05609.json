{"id": "1608.05609", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Aug-2016", "title": "Implementing a Relevance Tracker Module", "abstract": "PC(ID) extends propositional logic with inductive definitions: rule sets under the well-founded semantics. Recently, a notion of relevance was introduced for this language. This notion determines the set of undecided literals that can still influence the satisfiability of a PC(ID) formula in a given partial assignment. The idea is that the PC(ID) solver can make decisions only on relevant literals without losing soundness and thus safely ignore irrelevant literals.", "histories": [["v1", "Fri, 19 Aug 2016 14:19:21 GMT  (129kb)", "http://arxiv.org/abs/1608.05609v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["joachim jansen", "jo devriendt", "bart bogaerts", "gerda janssens", "marc denecker"], "accepted": false, "id": "1608.05609"}, "pdf": {"name": "1608.05609.pdf", "metadata": {"source": "CRF", "title": "Implementing a Relevance Tracker Module", "authors": ["Joachim Jansen", "Jo Devriendt", "Bart Bogaerts", "Gerda Janssens", "Marc Denecker"], "emails": ["first.lastname@kuleuven.be,", "bart.bogaerts@aalto.fi"], "sections": [{"heading": null, "text": "ar Xiv: 160 8.05 609v 1 [cs.A I] 1 9A ug"}, {"heading": "1 Introduction", "text": "This year, it will be ready to leave the country in order to return to the EU in order to enter the EU."}, {"heading": "2 Preliminiaries: SAT(ID), Relevance", "text": "Here we give a brief introduction to PC (ID), SAT (ID), justifications, relevance and recall how relevance can be used to improve PC (ID) solvers. For a more detailed presentation, please refer to Jansen et al. [2016]."}, {"heading": "2.1 PC(ID)", "text": "We briefly recall the syntax and semantics of the Propositional Calculus, which are extended with inductive definitions (PC (ID)). We briefly recall the syntax and semantics of the Propositional Calculus, which are extended with inductive definitions (PC (ID), 2009). A truth value is one of {t, f, u, u, u, p; t represents a finite series of symbols called atoms. A literal l is an atom p or its negation p. In the first case, we call l positive; in the second, we call l negative. We use l negative to name the set of all letters in the dictionary."}, {"heading": "2.2 Justifications", "text": "Consider a directed graph G = (V, E), with V a row of nodes VI = VI and J a row of edges J = J. If G contains an edge from l to l (i.e., (l, l) \"E\"), we say that l is a parent of l \"in G and that l\" is a child of l \"in G. A node l is called a sheet of G if it has no children in G. Otherwise, it is called an internal case in G. Define the union of two graphs (denotes G\" G \") as a graph of V\" V \"and edges of E. Suppose l is a literal case with p\" and p \"literally\" defs \"with definition p.\""}, {"heading": "2.3 Relevance", "text": "For a more detailed description of the theoretical foundations, we refer to Jansen et al. [2016].Theorem 1 ([Jansen et al., 2016]; Theorem 3.1).T is satisfactory if and only if there is a partial interpretation I and a justification J that justifies pT in I.Definition 1 ([Jansen et al., 2016]; Definition 3.2).Faced with a PC (ID) theory T = {pT, \u0445} and a partial interpretation I, we inductively define the set of relevant dictionaries referred to as RT, I, as follows - pT is relevant if pT is not justified, - l is relevant if l \u00b2 theory is not justified and there are some l \u00b2 theorems that are relevant (l \u00b2, l) and l \u00b2 theory.The central theorem in relation to relevance shows that any search algorithm that arrives in a state is literally justified."}, {"heading": "3 The Basic Framework", "text": "The aim of this work is to discuss the implementation of an algorithm to track relevant dictionaries. As stated in Theorem 1, the solver aims to arrive at a state where pT is justified in I. The solver does this by making decisions, propagation, and traceability. To prevent the solver from making \"useless\" decisions, we need to know whether dictionaries in I. We consider the underlying solver to be an internal state S of the form S = < \u03a3, T, I >, with (1) \u03a3, the set of dictionaries used in the solver, (2) T = {pT, \u2206} a DEFNF theory, and (3) I consider the present partial interpretation in the solution. During the search process, the (CDCL) solver adds learned conflict clauses to the theory. However, learned conflict clauses are logical consequences of the theory, and for this reason we do not consider them reserved for S. Instead, the theory is T reserved for T."}, {"heading": "4 Deriving the justification status of literals", "text": "The definition of relevance is based on the knowledge of which letters in the solver are justified, except that each definition is justified. (...) The method creates a new atom called \"justification.\" (...) The intended interpretation of j (...) is that j (...) is true, that j (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is true, that iff (...) is false, that iff (...) is false, and (...) is false, that iff (...) is false, that the justification (...) is justified."}, {"heading": "5 Implementing the relevance tracker", "text": "The source code implementing the techniques discussed here can be found at https: / / dtai.cs.kuleuven.be / static / krr / files / experiments / idp _ relevance _ experiments.tar.gz.The Solver maintains a subgraph of the dependency graph to track the set of relevant literals, which is called the Relevance Graph and contains all relevant and all the edges between them (in the dependency graph). As such, the task of the candidate is to determine whether a particular candidate is a member of that graph or not. We store this graph using a data structure, the named candidate candidates Parents (l), which are literally associated with a set of words called Parents. \"The\" Candidate Candidate Parents \"are the dictionaries, the parents of l are the dictionaries that are parents of l in the Relevance Graph. I.e."}, {"heading": "5.1 Data Structures", "text": "Unless otherwise specified, we use hash sets and hash maps. The implementation uses std:: disordered sets and std:: disordered sets provided by the standard C + + library. Internally, we store the dependency relationship dd \u0445 with two maps in our module called Children and Parents. These data structures literally represent a set of literals. The first map (children) literally represents a set of children in dd \u0445. The second map (parents) literally represents a set of parents in dd \u0445. They are initialized using the notifyNewRulemethod. Once initialized, they remain fixed. We use a map (illuminated only) to transform a normal letter literally into its justification word (p 7 \u2192 j (p), \u00ac p 7 \u2192 \u00ac j (p)))."}, {"heading": "5.2 Notification-based Algorithms", "text": "Considering that the initial parents are in solver state S = < \u03a3, T, I >, we want to make the necessary changes so that they are in solver state S \u2032 = < \u03a3, T, I [p: tv] > with an atom and tv one of {t, f, u}.We will initiate our viewing algorithms as follows. If tv = t, then we can trigger further internal naming. If tv = f, then we will call the viewing BecomesTrue (\u00ac p). If tv = u, then we will call the viewing Becomesunnh (p).This call may trigger other internal naming."}, {"heading": "5.3 Maintaining watches instead of sets of candidates", "text": "For efficiency reasons, the Relevance Tracker will not actively maintain this set of candidate parents. Instead, it will track a single candidate parent as a \"supervised\" parent. This supervised parent is maintained by a card called \"supervised parent\" (l), which is literally assigned to a single parent of l. The method is now relevant (l) and checks whether a particular literal l has a supervised parent or not. We will only keep track of a single supervised parent (l, l) to minimize how often a cycle detection algorithm needs to be called. Manipulation of the group of candidate parents, along with invoking a cycle detection algorithm, will be performed as a follow-up otifyAddCandidateParent (l, l) to test the following criteria - l does not yet have a supervised parent - l is not justified - l is relevant - l is a child of l \u00b2 if they can call an algorithm (l), if an algorithm (l) is not suitable for a parent (l)."}, {"heading": "5.4 Detecting Cycles", "text": "For our implementation of cycle detection, we use parts of the existing unfounded set propagation algorithm [Gebser et al., 2012; Marie \ufffd n et al., 2007], which has a subcomponent that searches for cycles via negative literals."}, {"heading": "6 Conclusion and Future Work", "text": "The idea of relevance is related to the Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of logic programming in the sense that the resulting program of magic does not perform the transformation to a program P and query Q in parts of P that do not solve the query Q.One area where relevance should give great accelerations is a stable model counting. If this is justified, the number of solutions that this partial allocation represents is equal to 2n with the number of unallocated open atoms. Stable model contracts generally cease when the justified residual program [Aziz et al., 2015] does not justify pT the other way round. There are other cases where pT is justified but the justified residual program is not empty."}, {"heading": "Acknowledgements", "text": "This research was supported by the GOA 13 / 010 Research Fund KU Leuven and the FWO (Research Foundation - Flanders) projects G.0489.10, G.0357.12 and G.0922.13. Bart Bogaerts is supported by the Finnish Center of Excellence in Computational Inference Research (COIN), which is funded by the Finnish Academy (grant number 251170)."}], "references": [{"title": "Principles of Constraint Programming", "author": ["Krzysztof R. Apt"], "venue": null, "citeRegEx": "Apt.,? \\Q2003\\E", "shortCiteRegEx": "Apt.", "year": 2003}, {"title": "Stable model counting and its application in probabilistic logic programming", "author": ["Rehan Abdul Aziz", "Geoffrey Chu", "Christian J. Muise", "Peter James Stuckey"], "venue": null, "citeRegEx": "Aziz et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Aziz et al\\.", "year": 2015}, {"title": "Magic sets and other strange ways to implement logic programs (extended abstract)", "author": ["Francois Bancilhon", "David Maier", "Yehoshua Sagiv", "Jeffrey D Ullman"], "venue": "In Proceedings of the Fifth ACM SIGACT-SIGMOD Symposium on Principles of Database Systems,", "citeRegEx": "Bancilhon et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Bancilhon et al\\.", "year": 1986}, {"title": "Satisfiability modulo theories", "author": ["Clark W. Barrett", "Roberto Sebastiani", "Sanjit A. Seshia", "Cesare Tinelli"], "venue": "Handbook of Satisfiability,", "citeRegEx": "Barrett et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2009}, {"title": "Special issue: Database logic progamming on the power of magic", "author": ["Catriel Beeri", "Raghu Ramakrishnan"], "venue": "The Journal of Logic Programming,", "citeRegEx": "Beeri and Ramakrishnan.,? \\Q1991\\E", "shortCiteRegEx": "Beeri and Ramakrishnan.", "year": 1991}, {"title": "Design and results of the fifth answer set programming competition", "author": ["Francesco Calimeri", "Martin Gebser", "Marco Maratea", "Francesco Ricca"], "venue": "Artif. Intell.,", "citeRegEx": "Calimeri et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2016}, {"title": "Negation as failure. In Logic and Data Bases, pages 293\u2013322", "author": ["Keith L. Clark"], "venue": null, "citeRegEx": "Clark.,? \\Q1978\\E", "shortCiteRegEx": "Clark.", "year": 1978}, {"title": "Lazy model expansion: Interleaving grounding with search", "author": ["Broes De Cat", "Marc Denecker", "Maurice Bruynooghe", "Peter J. Stuckey"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Cat et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Cat et al\\.", "year": 2015}, {"title": "The well-founded semantics is the principle of inductive definition", "author": ["Marc Denecker"], "venue": "JELIA, volume 1489 of LNCS,", "citeRegEx": "Denecker.,? \\Q1998\\E", "shortCiteRegEx": "Denecker.", "year": 1998}, {"title": "Justification semantics: A unifying framework for the semantics of logic programs", "author": ["Marc Denecker", "Danny De Schreye"], "venue": "URL https:// lirias.kuleuven.be/handle/123456789/133075", "citeRegEx": "Denecker and Schreye.,? \\Q1993\\E", "shortCiteRegEx": "Denecker and Schreye.", "year": 1993}, {"title": "A logic of nonmonotone inductive definitions", "author": ["Marc Denecker", "Eugenia Ternovska"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "Denecker and Ternovska.,? \\Q2008\\E", "shortCiteRegEx": "Denecker and Ternovska.", "year": 2008}, {"title": "Well-founded semantics and the algebraic theory of non-monotone inductive definitions", "author": ["Marc Denecker", "Joost Vennekens"], "venue": "LPNMR, volume 4483 of Lecture Notes in Computer Science,", "citeRegEx": "Denecker and Vennekens.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2007}, {"title": "The well-founded semantics is the principle of inductive definition, revisited", "author": ["Marc Denecker", "Joost Vennekens"], "venue": "URL http://www.aaai.org/ocs/index.php/KR/KR14/paper/view/7957", "citeRegEx": "Denecker and Vennekens.,? \\Q2014\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2014}, {"title": "A Tarskian informal semantics for answer set programming", "author": ["law Truszczy\u0144ski", "Joost Vennekens"], "venue": "ICLP (Technical Communications),", "citeRegEx": "Truszczy\u0144ski and Vennekens.,? \\Q2012\\E", "shortCiteRegEx": "Truszczy\u0144ski and Vennekens.", "year": 2012}, {"title": "solving: From theory to practice", "author": ["Joachim Jansen", "Bart Bogaerts", "Jo Devriendt", "Gerda Janssens", "Marc Denecker"], "venue": null, "citeRegEx": "Jansen et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Jansen et al\\.", "year": 2012}, {"title": "Model Generation for ID-Logic", "author": ["Maarten Mari\u00ebn"], "venue": "PhD thesis,", "citeRegEx": "Mari\u00ebn.,? \\Q2009\\E", "shortCiteRegEx": "Mari\u00ebn.", "year": 2009}, {"title": "Integrating inductive definitions in SAT", "author": ["Maarten Mari\u00ebn", "Johan Wittocx", "Marc Denecker"], "venue": "In Nachum Derschowitz and Andrei Voronkov, editors, LPAR,", "citeRegEx": "Mari\u00ebn et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Mari\u00ebn et al\\.", "year": 2007}, {"title": "SAT(ID): Satisfiability of propositional logic extended with inductive definitions", "author": ["Maarten Mari\u00ebn", "Johan Wittocx", "Marc Denecker", "Maurice Bruynooghe"], "venue": "SAT, volume 4996 of LNCS,", "citeRegEx": "Mari\u00ebn et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Mari\u00ebn et al\\.", "year": 2008}, {"title": "GRASP: A search algorithm for propositional satisfiability", "author": ["Jo\u00e3o P. Marques-Silva", "Karem A. Sakallah"], "venue": "IEEE Transactions on Computers,", "citeRegEx": "Marques.Silva and Sakallah.,? \\Q1999\\E", "shortCiteRegEx": "Marques.Silva and Sakallah.", "year": 1999}, {"title": "Lazy clause generation: Combining the power of SAT and CP (and MIP?) solving", "author": ["Peter J. Stuckey"], "venue": "In CPAIOR,", "citeRegEx": "Stuckey.,? \\Q2010\\E", "shortCiteRegEx": "Stuckey.", "year": 2010}], "referenceMentions": [{"referenceID": 18, "context": "Since the addition of conflict-driven clause learning [Marques-Silva and Sakallah, 1999], SAT solvers have made huge leaps forward.", "startOffset": 54, "endOffset": 88}, {"referenceID": 3, "context": "Research fields such as SAT Modulo Theories (SMT) [Barrett et al., 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 50, "endOffset": 72}, {"referenceID": 0, "context": ", 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 37, "endOffset": 48}, {"referenceID": 19, "context": ", 2009], Constraint Programming (CP) [Apt, 2003] in the form of lazy clause generation [Stuckey, 2010], or Answer Set Programming (ASP) [Marek and Truszczy\u0144ski, 1999] could be seen as following this approach.", "startOffset": 87, "endOffset": 102}, {"referenceID": 16, "context": "In this paper, we focus on the logic PC(ID): the Propositional Calculus extended with Inductive Definitions [Mari\u00ebn et al., 2007].", "startOffset": 108, "endOffset": 129}, {"referenceID": 17, "context": "The satisfiability problem for PC(ID) encodings is called SAT(ID) [Mari\u00ebn et al., 2008].", "startOffset": 66, "endOffset": 87}, {"referenceID": 14, "context": "Jansen et al. [2016] have studied relevance extensively from the theoretical perspective and ran experiments to determine how relevance influences the number of choices and the number of conflicts a solver encounters.", "startOffset": 0, "endOffset": 21}, {"referenceID": 14, "context": "For a more elaborate exposition we refer to Jansen et al. [2016].", "startOffset": 44, "endOffset": 65}, {"referenceID": 15, "context": "We briefly recall the syntax and semantics of Propositional Calculus extended with Inductive Definitions (PC(ID)) [Mari\u00ebn, 2009].", "startOffset": 114, "endOffset": 128}, {"referenceID": 11, "context": "We use the parametrised well-founded semantics for inductive definitions [Denecker and Vennekens, 2007].", "startOffset": 73, "endOffset": 103}, {"referenceID": 15, "context": "Without loss of generality [Mari\u00ebn, 2009], we assume that every PC(ID) theory is in Definition Normal Form (DEFNF), where T = {pT , \u2206} and \u2013 pT is an atom,", "startOffset": 27, "endOffset": 41}, {"referenceID": 8, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 10, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 12, "context": "It has been argued many times before [Denecker, 1998; Denecker and Ternovska, 2008; Denecker and Vennekens, 2014] that all sensible definitions in mathematical texts are total definitions.", "startOffset": 37, "endOffset": 113}, {"referenceID": 17, "context": "This problem is NP-complete [Mari\u00ebn et al., 2008].", "startOffset": 28, "endOffset": 49}, {"referenceID": 8, "context": "Denecker and De Schreye [1993] and later also Denecker et al.", "startOffset": 0, "endOffset": 31}, {"referenceID": 8, "context": "Denecker and De Schreye [1993] and later also Denecker et al. [2015] showed that many semantics of logic programs can be captured by justifications.", "startOffset": 0, "endOffset": 69}, {"referenceID": 14, "context": "For a more detailed exposition of the theoretical foundations, we refer to Jansen et al. [2016].", "startOffset": 75, "endOffset": 96}, {"referenceID": 16, "context": "We assume a solver that performs unit propagation and unfounded set propagation [Gebser et al., 2012; Mari\u00ebn et al., 2007], i.", "startOffset": 80, "endOffset": 122}, {"referenceID": 6, "context": "In this case l is justified in I if and only if l is derivable by unit propagation on the completion[Clark, 1978] of \u2206 and unfounded set propagations.", "startOffset": 100, "endOffset": 113}, {"referenceID": 16, "context": "For our implementation of the detection of cycles, we re-use parts of the existing unfounded set propagation algorithm [Gebser et al., 2012; Mari\u00ebn et al., 2007].", "startOffset": 119, "endOffset": 161}, {"referenceID": 2, "context": "The notion of relevance is related to Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of Logic Programming in the sense that the resulting program of the magic set transformation on a program P and query Q does not execute parts of P that do not contribute towards solving query Q.", "startOffset": 49, "endOffset": 103}, {"referenceID": 4, "context": "The notion of relevance is related to Magic Sets [Bancilhon et al., 1986; Beeri and Ramakrishnan, 1991] in the field of Logic Programming in the sense that the resulting program of the magic set transformation on a program P and query Q does not execute parts of P that do not contribute towards solving query Q.", "startOffset": 49, "endOffset": 103}, {"referenceID": 1, "context": "Stable model counters generally stop when the justified residual program [Aziz et al., 2015] is empty.", "startOffset": 73, "endOffset": 92}, {"referenceID": 16, "context": "\u2013 Our method for keeping track of the relevance status of literals reuses the existing unfounded set detection techniques [Gebser et al., 2012; Mari\u00ebn et al., 2007] for detection of cyclic dependencies between \u201ccandidate parents\u201d.", "startOffset": 122, "endOffset": 164}, {"referenceID": 5, "context": ", from the benchmarks in the latest ASP competitions [Calimeri et al., 2016].", "startOffset": 53, "endOffset": 76}], "year": 2016, "abstractText": "PC(ID) extends propositional logic with inductive definitions: rule sets under the well-founded semantics. Recently, a notion of relevance was introduced for this language. This notion determines the set of undecided literals that can still influence the satisfiability of a PC(ID) formula in a given partial assignment. The idea is that the PC(ID) solver can make decisions only on relevant literals without losing soundness and thus safely ignore irrelevant literals. One important insight that the relevance of a literal is completely determined by the current solver state. During search, the solver state changes have an effect on the relevance of literals. In this paper, we discuss an incremental, lightweight implementation of a relevance tracker module that can be added to and interact with an out-of-the-box SAT(ID) solver.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}