{"id": "1608.08015", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Aug-2016", "title": "Event Selection Rules to Compute Explanations", "abstract": "Explanations have been introduced in the previous century. Their interest in reducing the search space is no longer questioned. Yet, their efficient implementation into CSP solver is still a challenge. In this paper, we introduce ESeR, an Event Selection Rules algorithm that filters events generated during propagation. This dynamic selection enables an efficient computation of explanations for intelligent backtracking al- gorithms. We show the effectiveness of our approach on the instances of the last three MiniZinc challenges", "histories": [["v1", "Mon, 29 Aug 2016 12:07:04 GMT  (34kb,D)", "http://arxiv.org/abs/1608.08015v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["charles prud'homme", "xavier lorca", "narendra jussien"], "accepted": false, "id": "1608.08015"}, "pdf": {"name": "1608.08015.pdf", "metadata": {"source": "CRF", "title": "Event Selection Rules to Compute Explanations", "authors": ["Charles Prud\u2019homme", "Xavier Lorca", "Narendra Jussien"], "emails": ["FirstName.LastName@mines-nantes.fr", "Narendra.Jussien@telecom-lille.fr"], "sections": [{"heading": "1 Introduction", "text": "In recent years, Lazy Clause Generation Solvers [10] (through hybrid SAT-CSP) have brought attention back to explanations. Declarations in pure CSP solvers, despite their undoubted interest, had several disadvantages: they generally required a profound refactoring of the intended solver, and the calculation itself was both memory and CPU consuming. In a few words, they were not considered worth the bother. In this paper, we claim that explanations in pure CSP solvers still have a bright future. Here, we present a simple but efficient algorithm for calculating explanations for CSP solvers: ESeR (Event Selection Rules). We use event-related information in a novel way to focus on those that are fundamentally related to failure."}, {"heading": "2 Background", "text": "A limitation of satisfaction problem (CSP) is a triple < V, D, C > where V is the sequence (v1, v2,.., vn) of variables, D is the sequence (d1, d2,.., dn) of domain Xiv: 160 8,08 015v 1 [cs.A I] 2 9A ug2 01 associated with variables, and C is the set {c1, c2,.., cm} of constraints. The domain di is a finite set of integer values to which the variable vi can be associated. The constraint cj, associated with a sub-sequence V, defines the allowed combinations of values that satisfy cj. A constraint is equipped with a function pcj that removes itself from the domains of V (cj), the values that can not satisfy cj."}, {"heading": "3 Intelligent backtracking", "text": "They enable intelligent traceability (non-chronological) and can significantly reduce the number of decisions made and speed up resolution. Furthermore, it is to be determined which sub-assignments cannot be extended to a solution so as not to reproduce them in the rest of the search tree. Definition 1 can be generalized to include either assignments or distances. Definition 2 (Generalized nogood [8]) is a set of assignments and relocations, not all designed in a solution of the CSP.Katsirelos [8] 1. Decision schema, an algorithm for learning g-nogoods during the search. First, any event caused by a constraint is designed with a solution of the CSP.Katsirelos [8] 1. Decision schema, an algorithm for learning g-nogoods during the search."}, {"heading": "4 Event selection rules to compute explanations", "text": "We now introduce Event Selection Rules (ESeR), an algorithm based on the ability to determine relevant event-based information. It takes advantage of the types of change variables and relies on an asynchronous calculation of explanations. First, we present the preconditions and then describe the concept of the event selection rule. Finally, we describe the algorithm itself. Preconditions To evaluate the events, we must store them in a chronologically ordered list, called \u03a3, during propagation. To keep the events sorted, it is necessary to recognize the inheritance between them. The index of the last stored event is traceable, so outdated events are automatically reversed. The cause that an event has generated is explained by an explanation scheme, or e-schema, which is able to show which (previous) event can be the source of the event. A decision is event-independent and therefore indicates no event; a rebuttal is explained by decisions made previously [4]."}, {"heading": "4.1 Event selection rules", "text": "In other words, how to recognize relevant events that have caused propagation to explain the failure. It can be considered a negative of an event. The nature of the changes can be as follows: the event that has removed a specific value of v is relevant, \u03c0u: the events that have modified the lower limit of v are relevant \": the events that have modified the upper limit of v are relevant, \u03c0d: all events that occur on v are relevant. In the event list, of course, the\" above events (resp. upp events) are arranged in such a way that the lower limit of a given variable only increases (resp. decreases)."}, {"heading": "4.2 Using ESeR in intelligent backtracking algorithms", "text": "They rely on a loosening of the defined explanatory decisions so that all of them must be retrieved in order to be correct. Second, those who accept incomplete explanations such as conflict-oriented backjumping. Only the deepest decision from the explanatory decisions is interesting to jump back to it, so that is enough. Finally, those who accept incomplete explanations with the need to continue their calculations later, such as dynamic backtracking. Dynamic tracing mimics conflict-oriented backjumping, but when jumping the deepest decision, decisions and rebuttals made between failure and bounce must be maintained by the search. Conclusions depend on previous decisions and, potentially, from which one must jump back."}, {"heading": "5 Evaluation", "text": "Our explanation engine was implemented in Choco-3.3.13 [13], a Java library for constraint programming. We evaluated three configurations: a standard backtrack search (choco), a conflict-oriented backjumping search, the incomplete explanations (CBJ), and CBJ allows incomplete explanations (CBJ-i). Not all (global) limitations are explained natively in Choco. If not, the na\u00efve but valid e-scheme is presented in Section 4.1. Benchmarks used consist of the instances of the MiniZinc Challenges4 (2012, 2013, and 2014), and it is composed of 269 instances of 66 problems. Models are based on a wide variety of limitations, including global limitations, and each problem describes a dedicated search strategy. Each of the 269 instances was executed with a 15-minute span interval."}, {"heading": "6 Conclusion", "text": "This dynamic selection enables an efficient calculation of explanations for intelligent traceability algorithms. In practice, the efficiency of our approach has been validated using a dataset of 269 instances from the last three MiniZinc challenges. Further work includes improving the possibilities offered by ESeR by extracting g-nogoods from the selection rules, and investigating alternative intelligent traceability algorithms."}], "references": [{"title": "Enhancement schemes for constraint processing: Backjumping, learning, and cutset decomposition", "author": ["Rina Dechter"], "venue": "Artif. Intell.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1990}, {"title": "Lazy explanations for constraint propagators", "author": ["Ian P. Gent", "Ian Miguel", "Neil C.A. Moore"], "venue": "Practical Aspects of Declarative Languages,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "Dynamic backtracking", "author": ["Matthew L. Ginsberg"], "venue": "J. Artif. Intell. Res. (JAIR), 1:25\u2013", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1993}, {"title": "The versatility of using explanations within constraint programming", "author": ["Narendra Jussien"], "venue": "Habilitation a\u0300 diriger des recherches, Universite\u0301 de Nantes,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "The palm system: explanation-based constraint programming", "author": ["Narendra Jussien", "Vincent Barichard"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2000}, {"title": "Maintaining arcconsistency within dynamic backtracking", "author": ["Narendra Jussien", "Romuald Debruyne", "Patrice Boizumault"], "venue": "In Principles and Practice of Constraint Programming (CP 2000),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2000}, {"title": "The path repair algorithm", "author": ["Narendra Jussien", "Olivier Lhomme"], "venue": "Electronic Notes in Discrete Mathematics,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "Choco: implementing a cp kernel", "author": ["F. Laburthe"], "venue": "In Proceedings of Techniques foR Implementing Constraint programming Systems", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2000}, {"title": "Propagation via lazy clause generation", "author": ["Olga Ohrimenko", "Peter J. Stuckey", "Michael Codish"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Travelling in the world of local searches in the space of partial assignments", "author": ["C\u00e9dric Pralet", "G\u00e9rard Verfaillie"], "venue": "In CPAIOR,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2004}, {"title": "MAC-CBJ: maintaining arc consistency with conflict-directed backjumping", "author": ["P. Prosser"], "venue": "Technical Report Research Report/95/177,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1995}, {"title": "Choco3 Documentation. TASC, INRIA Rennes, LINA CNRS UMR 6241", "author": ["Charles Prud\u2019homme", "Jean-Guillaume Fages", "Xavier Lorca"], "venue": "COSLING S.A.S.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "Explanation-based large neighborhood", "author": ["Charles Prud\u2019homme", "Xavier Lorca", "Narendra Jussien"], "venue": "search. Constraints,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "Efficient constraint propagation engines", "author": ["Christian Schulte", "Peter J. Stuckey"], "venue": "ACM Trans. Program. Lang. Syst.,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}], "referenceMentions": [{"referenceID": 8, "context": "In recent years, Lazy Clause Generation solvers [10] (through hybrid SAT-CSP) have brought explanations back to attention.", "startOffset": 48, "endOffset": 52}, {"referenceID": 0, "context": "Combining this technique with asynchronous constraint explanation schemas enables to easily plug intelligent backtracking algorithms in (such as CBJ [1,12]).", "startOffset": 149, "endOffset": 155}, {"referenceID": 10, "context": "Combining this technique with asynchronous constraint explanation schemas enables to easily plug intelligent backtracking algorithms in (such as CBJ [1,12]).", "startOffset": 149, "endOffset": 155}, {"referenceID": 7, "context": "How the domain of a variable changes is characterized by events [9,15].", "startOffset": 64, "endOffset": 70}, {"referenceID": 13, "context": "How the domain of a variable changes is characterized by events [9,15].", "startOffset": 64, "endOffset": 70}, {"referenceID": 2, "context": "Nogoods and explanations have been used for a long time to improve search [3,7,8,12,14].", "startOffset": 74, "endOffset": 87}, {"referenceID": 6, "context": "Nogoods and explanations have been used for a long time to improve search [3,7,8,12,14].", "startOffset": 74, "endOffset": 87}, {"referenceID": 10, "context": "Nogoods and explanations have been used for a long time to improve search [3,7,8,12,14].", "startOffset": 74, "endOffset": 87}, {"referenceID": 12, "context": "Nogoods and explanations have been used for a long time to improve search [3,7,8,12,14].", "startOffset": 74, "endOffset": 87}, {"referenceID": 0, "context": "Definition 1 (Nogood [1]).", "startOffset": 21, "endOffset": 24}, {"referenceID": 1, "context": "[2] suggest not to store the g-nogood but a polymorphic function able to retrieve it from a given event.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "Definition 3 (Deduction [4]).", "startOffset": 24, "endOffset": 27}, {"referenceID": 3, "context": "Definition 4 (Explanation [4]).", "startOffset": 26, "endOffset": 29}, {"referenceID": 4, "context": "Jussien and Barichard [5] introduced PaLM, an explanation based constraint programming system.", "startOffset": 22, "endOffset": 25}, {"referenceID": 3, "context": "The code of the constraints are modified in consequence, but low-intrusive techniques can be implemented, such as the ones described in [4].", "startOffset": 136, "endOffset": 139}, {"referenceID": 0, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 107, "endOffset": 113}, {"referenceID": 10, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 107, "endOffset": 113}, {"referenceID": 2, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 136, "endOffset": 141}, {"referenceID": 5, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 136, "endOffset": 141}, {"referenceID": 6, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 155, "endOffset": 161}, {"referenceID": 9, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 155, "endOffset": 161}, {"referenceID": 12, "context": "Explanation is the key point of intelligent backtracking algorithms, such as Conflict-directed Backjumping [1,12], Dynamic Backtracking [3,6], Path Repair [7,11] or Explanation-based LNS [14].", "startOffset": 187, "endOffset": 191}, {"referenceID": 3, "context": "A decision is event-independent and thus points out no event, a refutation is explained by previously taken decisions [4].", "startOffset": 118, "endOffset": 121}, {"referenceID": 11, "context": "1 [13], a Java library for constraint programming.", "startOffset": 2, "endOffset": 6}], "year": 2016, "abstractText": "Explanations have been introduced in the previous century. Their interest in reducing the search space is no longer questioned. Yet, their efficient implementation into CSP solver is still a challenge. In this paper, we introduce ESeR, an Event Selection Rules algorithm that filters events generated during propagation. This dynamic selection enables an efficient computation of explanations for intelligent backtracking algorithms. We show the effectiveness of our approach on the instances of the last three MiniZinc challenges.", "creator": "LaTeX with hyperref package"}}}