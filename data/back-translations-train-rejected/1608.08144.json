{"id": "1608.08144", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Aug-2016", "title": "Achievements in Answer Set Programming (Preliminary Report)", "abstract": "This paper describes an approach to the methodology of answer set programming (ASP) that can facilitate the design of encodings that are easy to understand and provably correct. Under this approach, after appending a rule or a small group of rules to the emerging program we include a comment that states what has been \"achieved\" so far. This strategy allows us to set out our understanding of the design of the program by describing the roles of small parts of the program in a mathematically precise way.", "histories": [["v1", "Mon, 29 Aug 2016 16:59:43 GMT  (27kb)", "http://arxiv.org/abs/1608.08144v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["vladimir lifschitz"], "accepted": false, "id": "1608.08144"}, "pdf": {"name": "1608.08144.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["vl@cs.utexas.edu"], "sections": [{"heading": null, "text": "ar Xiv: 160 8.08 144v 1 [cs.A I] 2 9A ug"}, {"heading": "1 Introduction", "text": "This work describes an approach to the methodology of response set programming [13,14], which can facilitate the design of encodings that are easy to understand and demonstrably correct. In the framework of this approach, after appending a rule or a small set of rules to the aspiring program, the programmer would include a comment stating what has been \"achieved\" so far, in a certain sense. Let's consider the program in Fig. Its first rule, which is considered a one% program 8Queensland. Col (I, J): col (I, J): col (I), line (J)}} The Queen (I, J), Queen (I, J), Queen (JJ), Queen (JJ), Queen (I), Queen (I, Queen (J), Queen (J), Queen (II), Queen (II), Queen (II, J)."}, {"heading": "2 Programs, Prefixes, and Achievements", "text": "In this thesis we understand a list of rules R1,.., Rn (n \u2265 1) in the input language of a solution set, such as clingo [9] or dlv [6]. The order of the rules should reflect the order in which the programmer writes them in the process of creating the program. It does not affect the semantics of the program, but it is essential for understanding the process of programming. We limit attention to programs without classical negation. (This limitation is discussed in the conclusion.) Stable models of a program without classification are sets of basic atoms that do not contain arithmetic operations, interpretations or pools. [9, Sect. 3.1.7, 3.1.10]. Such basic atoms are referred to as precomputed.1. An interpretation is a set of pre-calculated atoms. The k-th prefix of a program R1,."}, {"heading": "3 Programs with Input", "text": "The value of a placeholder, such as the constant n in Fig. 2, is a type of input that a solver can expect, in addition to the rules of the program. A definition of an \"extensional predicate\" that occurs in the rule fields is another kind. For example, Hamilton's program (Fig. 3) must be supplemented by definitions of the predicate Vertex / 1, which represents the set of vertices of a finite directed graph G - the predicate edge / 2 that represents the edge of G - the placeholder v0, which is a vertex of G. If i is a valid input for a program, then we can talk about models that are stable for input i or \"i-stable.\" 2For a program with input, an input is defined as a relationship between valid inputs and sets of interpretations. Such a relationship R is called the performance of a prefix, if R (i)."}, {"heading": "4 Records of Achievement", "text": "A track record for a program is a function that maps some (possibly all) prefixes of \"including\" itself \"to their performance. For example, the function that maps the prefixes of\" 8Queens \"to conditions (1) - (6) is a track record, as is the function that maps the first, second, fourth, and fifth prefixes of\" Hamiltons \"to conditions (8) - (11). Each program has a trivial track record that maps all of its prefixes to the identically true condition. A track record can be illustrated by adding a comment after each prefix\" to the area \"a\" describing the condition \"a.\" In Fig. 4, we use a convention that helps us describe these conditions succinctly: in the comments \"achieves: line / 1 = {1,..., n} we understand line / 1 as an abbreviation of\" the set of pre-calculated terms i so that the meta line (i) belongs to S."}, {"heading": "5 Completeness", "text": "It is clear that a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a condition, a, a, a, a condition, a, a, a, a, a, a, a, a condition, a, a condition, a condition, a, a condition, a, a, a condition, a condition, a, a, a, a, a, a, a, a, a, a, a, a"}, {"heading": "6 Achievement-Based Answer Set Programming", "text": "The only rule in these programs that is not followed by a performance comment is the first rule in the recursive definition of what is achieved. The role of this rule cannot be properly explained unless we treat it as part of the definition. Developing an ASP program along with a complete and detailed performance record can be called \"performance-based\" programming of answers. This strategy allows us to demonstrate our understanding of the design of the program by mathematically accurately describing the roles of individual rules or small rule groups. To further illustrate this idea, in Fig. 6-8 we present three \"real\" ASP programs accompanied by complete, detailed performance records. In Fig. 7, the rule is: - hb (N, X, Y, Y), hb (N, Z), not hb (N, X, Z)."}, {"heading": "7 Conclusion", "text": "This year, it has reached the stage where it will be able to take the lead."}, {"heading": "Acknowledgements", "text": "Thanks to Michael Gelfond, Amelia Harrison, Yuliya Lierler, Julian Michael, and Liangkun Zhao for comments on drafts of this work. Conversations and e-mail exchanges with Mark Denecker, Esra Erdem, Martin Gebser, Roland Kaminski, Johannes Oetsch, Dhananjay Raju, and Mirek Truszczynski helped the author develop a better understanding of the methodology of programming response sentences, which was partially supported by the National Science Foundation under grant IIS-1422455."}], "references": [{"title": "Event-sequence testing using answer-set programming", "author": ["M. Brain", "E. Erdem", "K. Inoue", "J. Oetsch", "J. P\u00fchrer", "H. Tompits", "C. Yilmaz"], "venue": "International Journal on Advances in Software 5, 237\u2013251", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Inferring phylogenetic trees using answer set programming", "author": ["D.R. Brooks", "E. Erdem", "S.T. Erdo\u011fan", "J.W. Minett", "D. Ringe"], "venue": "Journal of Automated Reasoning 39, 471\u2013511", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "ASP-Core-2: Input language format", "author": ["F. Calimeri", "W. Faber", "M. Gebser", "G. Ianni", "R. Kaminski", "T. Krennwallner", "N. Leone", "F. Ricca", "T. Schaub"], "venue": "Available at https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03b.pdf", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Democratix: A declarative approach to winner determination", "author": ["G. Charwat", "A. Pfandler"], "venue": "Proc. of the 4th International Conference on Algorithmic Decision Theory", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "The humble programmer", "author": ["E.W. Dijkstra"], "venue": "Communications of the ACM 15, 859\u2013 866", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1972}, {"title": "The KR system dlv: Progress report, comparisons and benchmarks", "author": ["T. Eiter", "N. Leone", "C. Mateis", "G. Pfeifer", "F. Scarcello"], "venue": "Cohn, A., Schubert, L., Shapiro, S. (eds.) Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR). pp. 406\u2013417", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1998}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan and Claypool Publishers", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2012}, {"title": "Abstract Gringo", "author": ["M. Gebser", "A. Harrison", "R. Kaminski", "V. Lifschitz", "T. Schaub"], "venue": "Theory and Practice of Logic Programming 15, 449\u2013463", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "Potassco User Guide, version 2.0", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Lindauer", "M. Ostrowski", "J. Romero", "T. Schaub", "S. Thiele"], "venue": "http://potassco.sourceforge.net", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Knowledge Representation, Reasoning, and the Design of Intelligent Agents: The Answer-Set Programming Approach", "author": ["M. Gelfond", "Y. Kahl"], "venue": "Cambridge University Press", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Towards a theory of elaboration tolerance: Logic programming approach", "author": ["M. Gelfond", "H. Przymusinska"], "venue": "International Journal of Software Engineering and Knowledge Engineering 6(1), 89\u2013112", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1996}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7(3), 499\u2013562", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczynski"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective, pp. 375\u2013 398. Springer Verlag", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1999}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1999}], "referenceMentions": [{"referenceID": 12, "context": "This paper describes an approach to the methodology of answer set programming [13,14] that can facilitate the design of encodings that are easy to understand and provably correct.", "startOffset": 78, "endOffset": 85}, {"referenceID": 13, "context": "This paper describes an approach to the methodology of answer set programming [13,14] that can facilitate the design of encodings that are easy to understand and provably correct.", "startOffset": 78, "endOffset": 85}, {"referenceID": 4, "context": "On the contrary: the programmer should let correctness proof and program grow hand in hand [5].", "startOffset": 91, "endOffset": 94}, {"referenceID": 8, "context": ", Rn (n \u2265 1) in the input language of an answer set solver, such as clingo [9] or dlv [6].", "startOffset": 75, "endOffset": 78}, {"referenceID": 5, "context": ", Rn (n \u2265 1) in the input language of an answer set solver, such as clingo [9] or dlv [6].", "startOffset": 86, "endOffset": 89}, {"referenceID": 10, "context": ", n} (7) 2 Programs with input are similar to lp-functions in the sense of Gelfond and Przymusinska [11].", "startOffset": 100, "endOffset": 104}, {"referenceID": 0, "context": "[1].", "startOffset": 0, "endOffset": 3}], "year": 2016, "abstractText": "This paper describes an approach to the methodology of answer set programming (ASP) that can facilitate the design of encodings that are easy to understand and provably correct. Under this approach, after appending a rule or a small group of rules to the emerging program we include a comment that states what has been \u201cachieved\u201d so far. This strategy allows us to set out our understanding of the design of the program by describing the roles of small parts of the program in a mathematically precise way.", "creator": "LaTeX with hyperref package"}}}