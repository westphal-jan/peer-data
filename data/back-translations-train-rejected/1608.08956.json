{"id": "1608.08956", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Aug-2016", "title": "Knowledge Representation Analysis of Graph Mining", "abstract": "Many problems, especially those with a composite structure, can naturally be expressed in higher order logic. From a KR perspective modeling these problems in an intuitive way is a challenging task. In this paper we study the graph mining problem as an example of a higher order problem. In short, this problem asks us to find a graph that frequently occurs as a subgraph among a set of example graphs. We start from the problem's mathematical definition to solve it in three state-of-the-art specification systems. For IDP and ASP, which have no native support for higher order logic, we propose the use of encoding techniques such as the disjoint union technique and the saturation technique. ProB benefits from the higher order support for sets. We compare the performance of the three approaches to get an idea of the overhead of the higher order support.", "histories": [["v1", "Wed, 31 Aug 2016 17:23:58 GMT  (85kb,D)", "http://arxiv.org/abs/1608.08956v1", "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016"]], "COMMENTS": "Paper presented at the 9th Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP 2016), New York City, USA, 16 October 2016", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["matthias van der hallen", "sergey paramonov", "michael leuschel", "gerda janssens"], "accepted": false, "id": "1608.08956"}, "pdf": {"name": "1608.08956.pdf", "metadata": {"source": "CRF", "title": "Knowledge Representation Analysis of Graph Mining", "authors": ["Matthias van der Hallen", "Sergey Paramonov", "Michael Leuschel", "Gerda Janssens"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In fact, it is the case that you are able to play by the rules."}, {"heading": "2 Formalization of the graph mining problem", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Patterns", "text": "We start with a comprehensive formal definition of the graph mining problem. Definition 1. A labeled graph G is a triple < V, E, l > where V is the finite set of nodes or nodes, E is a binary predicate on V that represents the set of (directed) edges, and l is an unary function of V to a set of labels.Definition 2. A graph G = < V, E, l > is for each pair of nodes v and v \u00b2 in V, there is an edge (v, v \u00b2).E or there is a sequence v, v1."}, {"heading": "2.2 Canonical patterns", "text": "Definition 5. A graph isomorphism f between two designated graphs G = < V, E, l > and G \u2032 = < V \u2032, E \u2032, l \u2032, G \u2032 > is a one-to-one figure V \u2192 V \u2032, so that f represents a homomorphism from G to G \u2032, and its inverse f \u2212 1 is a homomorphism from G \u2032 to G. If graph isomorphisms between G \u2032 and G \u2032 exist, say that G and G \u2032 are isomorphisms. In view of the graph-mining problem as described in Fig. 1, we have already established that Fig. 2a is a valid pattern. If we try to degrade a second pattern, we could suggest a pattern that both in Fig. 2a is a valid pattern."}, {"heading": "2.3 Rewording", "text": "We will explore how this formal mathematical definition can be expressed in the logic underlying the IDP > > DP and the ProB [Leuschel and Schneider, 2014] system. < l We will rephrase the earlier Def. 4 into an equivalent formal definition that uses logical sentences and linguistic constructs that are available in general logic, making it clear that the graph mining problem has basic graphs that lead to a higher definition and specification. Vertices in the graph mining problem do not have a pronounced property and can be reused between different sample graphics and patterns. Therefore, we will proceed from a common sufficiently large set of vertices V and present sample graphics. < Edge, Label, Class >, consisting of a (binary) marginal relationship on V and a labeling function on V and a classification (positive / negative).6."}, {"heading": "3 Modeling", "text": "In this section, we will show how state-of-the-art KR systems without support for higher order logic, such as IDP and ASP, can model the graph mining problem and its features of higher order using coding techniques. We will identify the desirable properties that, from a KR perspective, should be valid for a good modeling of the graph mining problem, and we will evaluate how modeling in ProB, as a KR language with support for higher order sets, fulfills these properties."}, {"heading": "3.1 IDP", "text": "In fact, it is the case that most people are able to understand themselves and understand what they are doing. (...) In fact, it is the case that most people who are able are able to understand themselves and understand what they are doing. (...) It is as if people are able to understand themselves. (...) It is as if they are able to understand themselves. (...) It is as if people are able to understand themselves. (...) It is as if they are able to understand themselves. (...) It is as if people are able to understand themselves, as if they are doing it, as if they are doing it, as if they are doing it. (...)"}, {"heading": "3.2 ASP", "text": "One of the main differences between ASP and IDP is the choice of semantics: ASP searches for the models of the response sentences, while IDP looks for well-founded models. ASP uses the minimal property of the response sentences, thus preventing the invalid models of the example discussed in Issue 3. The corresponding technique is called saturation technique [Eiter et al., 2009] and can prevent the creation of two separate theories and the writing of a procedure code required by IDP. Using this technique, ASP detects negative sample diagrams for which the f does not represent homomorphism, and requires for these example diagrams that f must represent each node of the pattern on each node of this example diagram and drop the injectivity restriction."}, {"heading": "3.3 ProB", "text": "The ProB system can handle mathematical specifications using higher order logic and set theory. Consequently, ProB specifications can cover the polynomial hierarchy PH [Immerman, 1999]. Higher order logic Because of the logic of the higher order of ProB, we can treat graphs as the inherent objects of higher order that they represent < E, l, c >. This allows us to quantify via a graph and easily access all of their characteristic predicates and functions. Higher order logic also allows us to quantify locally via the functions f, which represent homorphisms: there is no need to explain the function f globally, instead they are defined within the context of homomorphic positive (negative) examples. Here, the representation of these functions f is direct, without a graph identifier that corresponds to the disjunctural uniformity, which is limited to the IDP."}, {"heading": "3.4 Comparative Summary", "text": "From the graph mining problem as a case study, we derive a number of desirable properties that should meet a good KR specification. 1. Graphs described are the main concept in the mathematical definition of the graph mining problem. Here, labeled graphs are considered a mathematical object consisting of an edge relationship and a markup function, and should be treated in the specification as objects of higher order. 2. All sample diagrams are independent, so that the search for a homomorphism between a pattern and a given example diagram can be performed independently of each other. Essentially, we want to enable a local quantification of second order. 3. The search for a homomorphism between pattern and example diagram is always the same, regardless of the character of the example diagram (negative or positive). The only difference is the maximum / at least limitation of the number of homomorphisms."}, {"heading": "4 Performance", "text": "To compare the performance of higher order and first order systems, we compared the IDP system with the ProB system (which uses higher order specifications) using the positive examples of the Yoshida [Rruckert and Kramer, 2007] dataset derived from biochemistry for graph mining. First, we randomly selected an example to use as a template. Next, we extracted a pattern from this template, with the threshold N + = 13 (5% of the size of the sample set). During the mining process, we tracked the time it took to extract the i = 1.. n-th pattern."}, {"heading": "5 A faithful encoding", "text": "In Listing 1.8 we are now proposing a new encoding for a language that combines a pattern of higher order (= 1). (Edmond (= 1). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmond). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (2. (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (2. (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund. (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund). (Edmund)."}, {"heading": "6 Conclusion and future work", "text": "In this paper, we used graph mining as an example of a higher-order problem and conducted a thorough analysis of the problem from the viewpoint of knowledge representation. Although there are techniques to express these higher-order problems in first-order logic, sometimes an explicit indication of the additional structure that HO exhibits allows systems to function better. In the case of graph mining, for example, higher-order logic preserves the local coherence of graphs and the independence from homomorphisms for the various examples, a property that a higher solver can exploit to increase efficiency. However, in its current state, no technique combines the expressiveness of higher order with high-performance solving techniques. Inspired by this case study, we propose higher-level language extensions for IDP and suggest alternative ways to implement them in the solver. In particular, as shown in Section 4, the use of subsolvers seems promising and is explored together with the idea of Benders decomposition [Hooker and Ottosson]."}, {"heading": "A Higher Order Logic Simulation Description", "text": "Key data set characteristics for the experiments presented in Fig. 3 can be found in Table 2.The experimental setup for the results presented in Fig. 3 is as follows: both in models of fragmented union and in models of higher order, we have iteratively reduced the pattern from smaller to larger. First, we set the pattern length, equal to the number of nodes, to two, then calculated graph coverage for the pattern. Based on the cover, we add the pattern as frequent and then calculate isomorphic patterns in the template. For each isomorphic diagram in the template, we add a bad clause. Once all frequent patterns of length n are mined, i.e. the solver cannot find other non-isomorphic patterns of length n, we increase the pattern length to n + 1, remove all goods and repeat the processes.The key difference between the fragmented union model and the simulation model of higher order is in the cover calculation."}, {"heading": "C Code", "text": "This appendix provides the relevant code for the IDP, ASP and ProB systems. The full IDP pattern is available at: < / / dtai.cs.kuleuven.be / static / krr / files / experiments / static / krr / files / experiments / aspocp16 _ ASP.zip and the ProB code at https: / / dtai.cs.kuleuven.be / static / aspocp16 _ ProB.zip.Listing 1.9: IDP positive constraint 1 vocabulary V {2 type isa nat 3 type graphid."}], "references": [{"title": "Meta-programming in Logic Programming", "author": ["H. Abramson", "H. Rogers"], "venue": null, "citeRegEx": "Abramson and Rogers.,? \\Q1989\\E", "shortCiteRegEx": "Abramson and Rogers.", "year": 1989}, {"title": "Constraint programming for itemset mining", "author": ["L. De Raedt", "T. Guns", "S. Nijssen"], "venue": "system. CoRR,", "citeRegEx": "Raedt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Raedt et al\\.", "year": 2016}, {"title": "Mining patterns in networks using homomorphism", "author": ["A. Dries", "S. Nijssen"], "venue": "In Proceedings of the Twelfth SIAM International", "citeRegEx": "Dries and Nijssen.,? \\Q2008\\E", "shortCiteRegEx": "Dries and Nijssen.", "year": 2008}, {"title": "Knowledge-based Sequence Mining with ASP", "author": ["M. Gebser", "T. Guyet", "R. Quiniou", "J. Romero", "T. Schaub"], "venue": "Notes in Computer Science,", "citeRegEx": "Gebser et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2009}, {"title": "Descriptive complexity. Graduate texts in computer science", "author": ["N. Immerman"], "venue": "Logic Programming and Nonmonotonic Reasoning: 11th International Conference,", "citeRegEx": "Immerman.,? \\Q1998\\E", "shortCiteRegEx": "Immerman.", "year": 1998}, {"title": "Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers", "author": ["Springer Berlin Heidelberg", "Berlin", "Heidelberg", "2011. L. Lamport"], "venue": null, "citeRegEx": "Heidelberg et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Heidelberg et al\\.", "year": 2011}, {"title": "ProB: An automated analysis toolset for the B method", "author": ["M. Leuschel", "M.J. Butler"], "venue": "STTT, 10(2):185\u2013203,", "citeRegEx": "2002", "shortCiteRegEx": "2002", "year": 2008}, {"title": "Universal sorting problems", "author": [], "venue": "Problems of Information Transmission,", "citeRegEx": "Levin.,? \\Q1973\\E", "shortCiteRegEx": "Levin.", "year": 1973}, {"title": "Springer, Dec", "author": ["August"], "venue": "2015. D. Plagge and M. Leuschel. Validating b, Z and TLA + using prob and kodkod. In D. Giannakopoulou and D. M\u00e9ry, editors,", "citeRegEx": "August,? 2015", "shortCiteRegEx": "August", "year": 2015}, {"title": "Optimizing feature sets for structured data", "author": ["U. R\u00fcckert", "S. Kramer"], "venue": "ECML \u201907,", "citeRegEx": "R\u00fcckert and Kramer.,? \\Q2007\\E", "shortCiteRegEx": "R\u00fcckert and Kramer.", "year": 2007}], "referenceMentions": [{"referenceID": 0, "context": "On the one hand, meta-programming, as known from Logic Programming [Abramson and Rogers, 1989], has inspired the introduction of higher-order atoms in DLVHex [Eiter et al.", "startOffset": 67, "endOffset": 94}, {"referenceID": 7, "context": "This introduces theNP-coplete problem of graph homomorphism [Levin, 1973], and its many variations, which in imperative languages lead to many different algorithms [Yan and Han, 2002, Dries and Nijssen, 2012].", "startOffset": 60, "endOffset": 73}, {"referenceID": 1, "context": "This problem is of propositional nature: De Raedt et al. [2008] modeled it using CP techniques, while J\u00e4rvisalo [2011] used ASP.", "startOffset": 44, "endOffset": 64}, {"referenceID": 1, "context": "This problem is of propositional nature: De Raedt et al. [2008] modeled it using CP techniques, while J\u00e4rvisalo [2011] used ASP.", "startOffset": 44, "endOffset": 119}, {"referenceID": 1, "context": "This problem is of propositional nature: De Raedt et al. [2008] modeled it using CP techniques, while J\u00e4rvisalo [2011] used ASP. Recently, focus has shifted from unstructured towards structured mining, such as graph or sequence mining N\u00e9grevergne and Guns [2015], Gebser et al.", "startOffset": 44, "endOffset": 263}, {"referenceID": 1, "context": "This problem is of propositional nature: De Raedt et al. [2008] modeled it using CP techniques, while J\u00e4rvisalo [2011] used ASP. Recently, focus has shifted from unstructured towards structured mining, such as graph or sequence mining N\u00e9grevergne and Guns [2015], Gebser et al. [2016]. Here, the items being mined exhibit additional structure, for example the edge relation in the case of graph mining.", "startOffset": 44, "endOffset": 285}, {"referenceID": 4, "context": "[Immerman, 1998] has shown that this is inherently linked to IDPs limit to Existential Second Order.", "startOffset": 0, "endOffset": 16}, {"referenceID": 9, "context": "To this end, we used the positive examples of the Yoshida [R\u00fcckert and Kramer, 2007] dataset, which is derived from biochemics, for graph mining.", "startOffset": 58, "endOffset": 84}], "year": 2016, "abstractText": "Many problems, especially those with a composite structure, can naturally be expressed in higher order logic. From a KR perspective modeling these problems in an intuitive way is a challenging task. In this paper we study the graph mining problem as an example of a higher order problem. In short, this problem asks us to find a graph that frequently occurs as a subgraph among a set of example graphs. We start from the problem\u2019s mathematical definition to solve it in three state-of-the-art specification systems. For IDP and ASP, which have no native support for higher order logic, we propose the use of encoding techniques such as the disjoint union technique and the saturation technique. ProB benefits from the higher order support for sets. We compare the performance of the three approaches to get an idea of the overhead of the higher order support. We propose higher-order language extensions for IDP-like specification languages and discuss what kind of solver support is needed. Native higher order shifts the burden of rewriting specifications using encoding techniques from the user to the solver itself.", "creator": "LaTeX with hyperref package"}}}