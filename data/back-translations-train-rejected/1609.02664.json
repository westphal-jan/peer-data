{"id": "1609.02664", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Sep-2016", "title": "Machine Learning with Guarantees using Descriptive Complexity and SMT Solvers", "abstract": "Machine learning is a thriving part of computer science. There are many efficient approaches to machine learning that do not provide strong theoretical guarantees, and a beautiful general learning theory. Unfortunately, machine learning approaches that give strong theoretical guarantees have not been efficient enough to be applicable. In this paper we introduce a logical approach to machine learning. Models are represented by tuples of logical formulas and inputs and outputs are logical structures. We present our framework together with several applications where we evaluate it using SAT and SMT solvers. We argue that this approach to machine learning is particularly suited to bridge the gap between efficiency and theoretical soundness. We exploit results from descriptive complexity theory to prove strong theoretical guarantees for our approach. To show its applicability, we present experimental results including learning complexity-theoretic reductions rules for board games. We also explain how neural networks fit into our framework, although the current implementation does not scale to provide guarantees for real-world neural networks.", "histories": [["v1", "Fri, 9 Sep 2016 06:04:17 GMT  (43kb)", "http://arxiv.org/abs/1609.02664v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.LO", "authors": ["charles jordan", "{\\l}ukasz kaiser"], "accepted": false, "id": "1609.02664"}, "pdf": {"name": "1609.02664.pdf", "metadata": {"source": "CRF", "title": "Machine Learning with Guarantees using Descriptive Complexity and SMT Solvers", "authors": ["Charles Jordan", "Lukasz Kaiser"], "emails": ["skip@ist.hokudai.ac.jp", "lukaszkaiser@gmail.com"], "sections": [{"heading": null, "text": "ar Xiv: 160 9.02 664v 1 [cs.L G] 9S epIn this paper, we present a logical approach to machine learning. Models are represented by tuples of logical formulas and inputs and outputs are logical structures. We present our framework along with several applications in which we evaluate it using SAT and SMT solvers. We argue that this approach to machine learning is particularly suitable for bridging the gap between efficiency and theoretical soundness. We use the results of descriptive complexity theory to demonstrate strong theoretical guarantees for our approach. To demonstrate its applicability, we present experimental results, including rules for learning complexity-theoretical reductions for board games. We also explain how neural networks fit into our framework, although the current implementation does not scale to provide guarantees for real neural networks."}, {"heading": "1. Introduction", "text": "In fact, it is such that we are in a position to claim that we are in a position to claim that we are in a position to claim that we are in a position to claim that we are in a position to claim that we are in a position to claim that we are in a world, that we are in a position to claim that we are in a world, that we are in a world, that we are in a world, in a world, in which we are in, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we, in which we live, in which we live, in which we, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we live, in which we, in which we live, in which we live, in which we live, in which we, in which we live, in which we live, in which we, in which we live, in which we live, in which we, in which we live, in which we live, in which we, in which we live, in which we live, in which we, in which we, we live, in which we, in which we, in which we live, we, in which we live, in which we, in which we live, we, in which we, in which we, in which we, we live, in which we, in which we are, in which we are, in which we live, in which we, in which we are, in which we are, in which we are, in which we are, in which we are, in which we are, in which we are, we are, in which we are, in which we are, in which we are, in which we are, in which we are, in which we are, in which we are, in which we are"}, {"heading": "1.1 Related Work", "text": "Machine learning and inductive synthesis (the subfield closest to our approach) have a long history; there is an enormous amount of work that we do not cover. We refer the reader (Gulwani, 2010; Kitzelmann, 2010) to get a general perspective on inductive synthesis. Much of our motivation stems from recent work that uses ideas from descriptive complexity in inductive synthesis, for example, through a specification in an expressive logic (second order) (Itzhaky et al., 2010) equivalent formulas have been synthesized into less meaningful protocols that can be evaluated more efficiently. Automatic identification of complexity-theoretical reductions between computational problems was first considered (Crouch et al., 2010). They focused on quantity-free reductions, a weak class of reduction defined by tuples of quantity-free formulas well as on inductive synthesis."}, {"heading": "2. Background in Logic and Descriptive Complexity", "text": "In this section, we briefly consider the necessary background of descriptive complexity; for more details, see (Everman, 1999) or Chapter 3 of (Grapples, Kolaitis, Libkin, Marx, Spencer, Vardi, Venema, & Weinstein, 2007) for an overview and background, or (Grapples & Meer, 1996) and (Grapples & Gurevich, 1998) for details on R-structures and their logics; there are many possible representations of models or programs; in this paper, we focus on logical representations; one advantage of the logical approach is that we can treat structures like graphics directly, rather than encoding them in words or numbers; this allows us to successively express many interesting models that provide guidance on hypotheses and improve the intelligibility of learned models."}, {"heading": "2.1 Queries", "text": "We can define the properties or decision problems, but in general we represent models as queries (also referred to as interpretations).Queries maple-level - structures that define the universe, relationships, constants and functions using logical formulas. A query of first order from structures of first order to structures of second order is a r + s + t + 2 tuples, q: = (k, 0, 1,.). The number k is the dimension of the figure. Each of these figures is a formula of first order via the signature. Let us be a structure with universe UA. Formula 0 has free variables x1,..., xk and defines the universe of q (A), U: (u1,., uk)."}, {"heading": "2.2 Extensions of first-order logic", "text": "In fact, it is a way in which people are able to determine for themselves what they want and what they want."}, {"heading": "2.3 Outlines", "text": "In fact it is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) It is. (...) In fact it is. (...) It is not. (...) It is not. (...) It is not. (...) It is not. (...) It is. (...) It is. (...) It is. \"It is.\" (...) It is. \"It is.\" (...) It is. \"It is.\" (...) It is. \"It is.\" It is. \"(...).\" It is. \"(...).\" It is. \"(...).\" It is. (...). (...) It is. (...). \"It is. (...).\" It is. (...). \"It is. (...).\" It is. (...). \"It is. (...).\" It is. (...). \"It is. (...).\" It is. \"It is. (...\" It is. (...). \"It is. (...\" It is. (...). It is. (...). It is. (... \"It is. (...). It is. It is. (...). It is. (...\" It is. (...). It is. (... \"It is. (...). It is. (...). It is. It is. It is. (...). It is. It is. It is. (...). It is. It is. It is. It is. (...). (...). It is. (it is. It is. (...). It is. (...). (it. (it is. It is. It is. It is. It is. It is. (...). (it is. It is. It is. It is. It is. It is. It is. It is. It is. It is. (...). It is. It is. It is. It is. (). It is. (). (). It is. It is. It is. (). It is. It is."}, {"heading": "3. Learning Logical Queries", "text": "In this section we will clarify later when we discuss the completion of the learning process."}, {"heading": "3.1 Restricted Uniform Learner", "text": "It is therefore possible to simply try them all and find a suitable construction, but the following construction is advantageous for an efficient construction."}, {"heading": "3.2 Restricted Uniform Teacher", "text": "(Definition 4: Let C's Struc (\u03c4) \u00b7 Struc (\u03c3) be a target class, PC = {3, 3),......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "3.3 Termination of Uniform Restricted Learning", "text": "It is only a question of time in which we answer the question whether there is at all an answer to the question, whether there is at all an answer to the question, whether there is at all an answer to the question, whether there is at all an answer to the question, whether there is at all an answer to the question to the question, whether there is at all an answer to the question to the question, whether there is at all an answer to the question to the question, whether there is at all an answer to the question to the question, whether there is an answer to the question to the question to the question, whether the question to the question after the answer to the question after the question, whether the question to the question after the answer to the question after the answer to the question after the answer to the question after the answer to the question after the answer to the question after the question after the answer to the question after the question after the answer to the question after the question after the question after the question after the question after the answer to the question after the question after the question after the question after the answer to the question after the question after the question after the question after the question after the answer to the question after the question after the question after the answer to the question after the question after the question after the question after the question after the question after the question after the answer to the question after the answer to the question after the question after the question after the answer after the question after the question after the question after the question after the answer after the answer after the question after the question after the answer after the question after the answer after the question after the question after the answer after the question after the question after the question after the answer after the question after the answer after the question after the question after the question after the answer after the question after the question after the answer after the question after the question after the question after the answer after the question after the answer after the question after the answer after the question after the question after the question after the question after the question after the answer after the question after the question after the question after the question after the question after the question after the question after the answer after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question after the question"}, {"heading": "3.4 Unrestricted Uniform Learning", "text": "In the previous two sections, we have presented a limited learning model that can exploit the efficiency of QT solvers."}, {"heading": "4. Applications", "text": "As described above, the learning problem in our model consists of the specification of the teacher and the sketch for the learner. For different learning tasks, it might be advantageous to choose different outlines. Thus, some tasks require only a very simple Boolean circuit to solve, while for others we need the full power of polynomial time programs with loops and intermediate definitions. In this section, we present some parameterized classes of outlines with increasing computing power. With each class of outlines, we present a learning task that is well suited for this sketch, and discuss how the task is solved in our model. We start with outlines for very simple quantifiable-free formulas of first order. It turns out that even such basic outlines are useful: they are a good candidate for finding reductions as we will discuss in the next section. Afterwards, we move to outlines of first order. These correspond to uniform AC0 circuits, and we show that they can be used for learning patterns and rules at our relative level."}, {"heading": "4.1 Learning Quantifier-Free First-Order Formulas", "text": "It is an important tool for determining the relative hardness of arithmetic problems and other applications that exist. (...) It is a question of (automatic) learning and verification processes whether we consider a number of different approaches to problem solving. (...) It is a question of (automatic) learning and verification processes initiated by Crouch et al. (...) It is a question of (automatic) learning and verification processes. (...) It is a question of descriptive complexity, a question of (...) ownership and verification processes. (...) It is a question of (...) verification processes. (...) It is a question of (...) verification processes and verification processes. (...) It is a question of (...) verification processes. (...)"}, {"heading": "4.2 Learning First-Order Formulas", "text": "Basically, the system works by calculating minimal formulas for structures, e.g. formulas satisfied by structures representing winning positions, and not by any of the losers. We implement the calculation of formulas within our framework and compare them with performance. Problem: Let's all have finite sets of structures. We want to learn a formula that does not require free variables, namely for all A proportions and for no A proportions. Unlike previous tasks, we want a minimal formula, not only for an arbitrary formula, but also for a teacher."}, {"heading": "4.3 Learning Threshold Circuits (Formulas with Reals)", "text": "For the first time in a long time, we have been able to provide a complete set of tools for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search engine for the search for the search for the search engine for the search for the search for the search engine for the search for the search for the search for the search for the search for the search"}, {"heading": "4.4 Learning Polynomial-Time Programs", "text": "In this case, it's about whether and to what extent the US and the EU will be able to establish a common currency. In this case, it's about whether the US wants a common currency or not. In this case, it's about whether the EU wants a common currency or not. In this case, it's about whether the EU wants a common currency or not. In this case, it's about whether Europe wants a common currency or not. In this case, it's about whether the EU wants a common currency or not. In this case, it's about whether the EU wants a common currency or not. In this case, it's about whether the EU wants a common currency or not. In this case, it's about whether Europe wants a common currency or not. In this case, it's about whether Europe wants a common currency or a common currency or not. In this case, it's about whether the EU wants a common currency or a common currency or not."}, {"heading": "5. Conclusions and Future Work", "text": "We prove that our approach comes with strong theoretical guarantees: as long as a model exists in a given complexity class (e.g. NL, P, NP), it will be found. Thanks to the efficiency of modern SAT and QBF approaches, our general approach outperforms specialized approaches both in terms of learning reduction (Crouch et al., 2010) and in terms of learning from examples (Kaiser, 2012). We consider these early results to be promising and encourage further experiments with our freely available implementations.There are many questions that we leave unanswered. For example, there is a large variation in duration depending on the exact set of counter-examples given by the teacher. We would like to know how to select \"good\" counter-examples and whether randomness (Zeugmann, 2006) can help. We ask which outlines are \"good,\" how to choose them in order to find the solutions that are desired."}], "references": [{"title": "The isomorphism conjecture for constant depth reductions", "author": ["M. Agrawal"], "venue": "Journal of Computer and System Sciences, 77 (1), 3\u201313.", "citeRegEx": "Agrawal,? 2011", "shortCiteRegEx": "Agrawal", "year": 2011}, {"title": "Reducing the complexity of reductions", "author": ["M. Agrawal", "E. Allender", "R. Impagliazzo", "T. Pitassi", "S. Rudich"], "venue": "Computational Complexity,", "citeRegEx": "Agrawal et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Agrawal et al\\.", "year": 2001}, {"title": "On a theory of computation and complexity over the real numbers: NP -completeness, recursive functions and universal machines", "author": ["L. Blum", "M. Shub", "S. Smale"], "venue": "Bull. Amer. Math. Soc. (N.S.),", "citeRegEx": "Blum et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Blum et al\\.", "year": 1989}, {"title": "Finding reductions automatically", "author": ["M. Crouch", "N. Immerman", "J.E.B. Moss"], "venue": "In Fields of Logic and Computation \u2013 Essays Dedicated to Yuri Gurevich on the Occasion of His 70th Birthday,", "citeRegEx": "Crouch et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Crouch et al\\.", "year": 2010}, {"title": "Generalized first-order spectra and polynomial-time recognizable sets", "author": ["R. Fagin"], "venue": "Complexity of Computation, SIAM-AMS Proceedings, Vol. 7, pp. 43\u201373.", "citeRegEx": "Fagin,? 1974", "shortCiteRegEx": "Fagin", "year": 1974}, {"title": "Metafinite model theory", "author": ["E. Gr\u00e4del", "Y. Gurevich"], "venue": "Information and Computation,", "citeRegEx": "Gr\u00e4del and Gurevich,? \\Q1998\\E", "shortCiteRegEx": "Gr\u00e4del and Gurevich", "year": 1998}, {"title": "Descriptive Complexity Theory over the Real Numbers", "author": ["E. Gr\u00e4del", "K. Meer"], "venue": "Mathematics of Numerical Analysis: Real Number Algorithms,", "citeRegEx": "Gr\u00e4del and Meer,? \\Q1996\\E", "shortCiteRegEx": "Gr\u00e4del and Meer", "year": 1996}, {"title": "The quest for a logic capturing PTIME", "author": ["M. Grohe"], "venue": "Proceedings, Twenty-Third Annual IEEE Symposium on Logic in Computer Science, LICS 2008, pp. 267\u2013271.", "citeRegEx": "Grohe,? 2008", "shortCiteRegEx": "Grohe", "year": 2008}, {"title": "Dimensions in program synthesis", "author": ["S. Gulwani"], "venue": "Proceedings of the 12th International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming, PPDP \u201910, pp. 13\u201324.", "citeRegEx": "Gulwani,? 2010", "shortCiteRegEx": "Gulwani", "year": 2010}, {"title": "Solving and verifying the boolean Pythagorean triples problem via cube-and-conquer", "author": ["M.J.H. Heule", "O. Kullmann", "V.W. Marek"], "venue": "In Theory and Applications of Satisfiability Testing, 19th International Conference,", "citeRegEx": "Heule et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Heule et al\\.", "year": 2016}, {"title": "Relational queries computable in polynomial time", "author": ["N. Immerman"], "venue": "Inform. Control, 68, 86\u2013104.", "citeRegEx": "Immerman,? 1986", "shortCiteRegEx": "Immerman", "year": 1986}, {"title": "Languages that capture complexity classes", "author": ["N. Immerman"], "venue": "SIAM J. Comput., 16 (4), 760\u2013778.", "citeRegEx": "Immerman,? 1987", "shortCiteRegEx": "Immerman", "year": 1987}, {"title": "Descriptive Complexity", "author": ["N. Immerman"], "venue": "Springer-Verlag.", "citeRegEx": "Immerman,? 1999", "shortCiteRegEx": "Immerman", "year": 1999}, {"title": "A simple inductive synthesis methodology and its applications", "author": ["S. Itzhaky", "S. Gulwani", "N. Immerman", "M. Sagiv"], "venue": "In Proceedings of the 25th Annual ACM SIGPLAN Conference on Object-Oriented Programming,", "citeRegEx": "Itzhaky et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Itzhaky et al\\.", "year": 2010}, {"title": "Solving QBF with counterexample guided refinement", "author": ["M. Janota", "W. Klieber", "J. Marques-Silva", "E. Clarke"], "venue": "In Theory and Applications of Satisfiability Testing, SAT 2012, 15th International Conference,", "citeRegEx": "Janota et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Janota et al\\.", "year": 2012}, {"title": "Benchmarks from reduction finding", "author": ["C. Jordan", "L. Kaiser"], "venue": "International Workshop on Quantified Boolean Formulas", "citeRegEx": "Jordan and Kaiser,? \\Q2013\\E", "shortCiteRegEx": "Jordan and Kaiser", "year": 2013}, {"title": "Experiments with reduction finding", "author": ["C. Jordan", "L. Kaiser"], "venue": "In Theory and Applications of Satisfiability Testing, 16th International Conference,", "citeRegEx": "Jordan and Kaiser,? \\Q2013\\E", "shortCiteRegEx": "Jordan and Kaiser", "year": 2013}, {"title": "Learning games from videos guided by descriptive complexity", "author": ["L. Kaiser"], "venue": "Proceedings of the 26th Conference on Artificial Intelligence, AAAI-12, pp. 963\u2013970.", "citeRegEx": "Kaiser,? 2012", "shortCiteRegEx": "Kaiser", "year": 2012}, {"title": "A unified approach to boundedness properties in MSO", "author": ["L. Kaiser", "M. Lang", "S. Le\u00dfenich", "C. L\u00f6ding"], "venue": "In 24th EACSL Annual Conference on Computer Science Logic (CSL 2015),", "citeRegEx": "Kaiser et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kaiser et al\\.", "year": 2015}, {"title": "Inductive programming: A survey of program synthesis techniques", "author": ["E. Kitzelmann"], "venue": "Approaches and Applications of Inductive Programming, Third International Workshop, AAIP 2009, Edinburgh, UK, September 2009, Revised Papers, Vol. 5812 of Lecture Notes in Computer Science, pp. 50\u201373.", "citeRegEx": "Kitzelmann,? 2010", "shortCiteRegEx": "Kitzelmann", "year": 2010}, {"title": "Computer-aided proof of Erd\u0151s discrepancy properties", "author": ["B. Konev", "A. Lisitsa"], "venue": "Artificial Intelligence,", "citeRegEx": "Konev and Lisitsa,? \\Q2015\\E", "shortCiteRegEx": "Konev and Lisitsa", "year": 2015}, {"title": "The QBF Gallery: Behind the scenes", "author": ["F. Lonsing", "M. Seidl", "A. Van Gelder"], "venue": "Artificial Intelligence,", "citeRegEx": "Lonsing et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Lonsing et al\\.", "year": 2016}, {"title": "Challenging SMT solvers to verify neural networks", "author": ["L. Pulina", "A. Tacchella"], "venue": "AI Commun.,", "citeRegEx": "Pulina and Tacchella,? \\Q2012\\E", "shortCiteRegEx": "Pulina and Tacchella", "year": 2012}, {"title": "Recent progress on the complexity of the decision problem for the reals", "author": ["J. Renegar"], "venue": "Quantifier Elimination and Cylindrical Algebraic Decomposition, Texts and Monographs in Symbolic Computation, pp. 220\u2013241. Springer Vienna.", "citeRegEx": "Renegar,? 1998", "shortCiteRegEx": "Renegar", "year": 1998}, {"title": "Combinatorial sketching for finite programs", "author": ["A. Solar-Lezama", "L. Tancau", "R. Bodik", "S. Seshia", "V. Saraswat"], "venue": "In Proceedings of the 12th International Conference", "citeRegEx": "Solar.Lezama et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Solar.Lezama et al\\.", "year": 2006}, {"title": "A Decision Method for Elementary Algebra and Geometry", "author": ["A. Tarski"], "venue": "University of California Press. Originally published as RAND Report R-109, 1948. Also available in Quantifier Elimination and Cylindrical Algebraic Decomposition, pp. 24\u201384, Springer 1998.", "citeRegEx": "Tarski,? 1951", "shortCiteRegEx": "Tarski", "year": 1951}, {"title": "The complexity of relational query languages", "author": ["M.Y. Vardi"], "venue": "Proceedings of the 14th Annual ACM Symposium on Theory of Computing, May 1982, San Francisco, California, USA, pp. 137\u2013146.", "citeRegEx": "Vardi,? 1982", "shortCiteRegEx": "Vardi", "year": 1982}, {"title": "Succinct representation, leaf languages, and projection reductions", "author": ["H. Veith"], "venue": "Information and Computation, 142 (2), 207\u2013236.", "citeRegEx": "Veith,? 1998", "shortCiteRegEx": "Veith", "year": 1998}, {"title": "From learning in the limit to stochastic finite learning", "author": ["T. Zeugmann"], "venue": "Theoret. Comput. Sci., 364 (1), 77\u201397.", "citeRegEx": "Zeugmann,? 2006", "shortCiteRegEx": "Zeugmann", "year": 2006}], "referenceMentions": [{"referenceID": 8, "context": "We refer the reader to (Gulwani, 2010; Kitzelmann, 2010) for a general perspective on inductive synthesis.", "startOffset": 23, "endOffset": 56}, {"referenceID": 19, "context": "We refer the reader to (Gulwani, 2010; Kitzelmann, 2010) for a general perspective on inductive synthesis.", "startOffset": 23, "endOffset": 56}, {"referenceID": 13, "context": "For example, given a specification in an expressive logic (second-order), (Itzhaky et al., 2010) synthesized equivalent formulas in less expressive log-", "startOffset": 74, "endOffset": 96}, {"referenceID": 3, "context": "Automatically finding complexity-theoretic reductions between computational problems was first considered by (Crouch et al., 2010).", "startOffset": 109, "endOffset": 130}, {"referenceID": 12, "context": "For more details, see (Immerman, 1999) or Chapter 3 of (Gr\u00e4del, Kolaitis, Libkin, Marx, Spencer, Vardi, Venema, & Weinstein, 2007) for an overview and background, or (Gr\u00e4del & Meer, 1996) and (Gr\u00e4del & Gurevich, 1998) for details on R-structures and their logics.", "startOffset": 22, "endOffset": 38}, {"referenceID": 12, "context": "5 of (Immerman, 1999).", "startOffset": 5, "endOffset": 21}, {"referenceID": 12, "context": "(Immerman, 1999)).", "startOffset": 0, "endOffset": 16}, {"referenceID": 4, "context": "As this example indicates, second-order logic is very powerful; existential SO corresponds exactly to NP (Fagin, 1974).", "startOffset": 105, "endOffset": 118}, {"referenceID": 10, "context": "Over relational structures2, polynomial time is captured by least fixed-point logic (LFP) (Immerman, 1986; Vardi, 1982), and the same holds for PR and functional fixed-point (FFP) (Gr\u00e4del & Meer, 1996).", "startOffset": 90, "endOffset": 119}, {"referenceID": 26, "context": "Over relational structures2, polynomial time is captured by least fixed-point logic (LFP) (Immerman, 1986; Vardi, 1982), and the same holds for PR and functional fixed-point (FFP) (Gr\u00e4del & Meer, 1996).", "startOffset": 90, "endOffset": 119}, {"referenceID": 11, "context": "Although LFP is presumably more expressive than transitive closure logic (TC), TC captures all problems solvable in non-deterministic logarithmic space (NL) on relational structures (Immerman, 1987).", "startOffset": 182, "endOffset": 198}, {"referenceID": 12, "context": "See (Immerman, 1999) for an overview of logics capturing other complexity classes.", "startOffset": 4, "endOffset": 20}, {"referenceID": 7, "context": "(Grohe, 2008).", "startOffset": 0, "endOffset": 13}, {"referenceID": 25, "context": "Model-checking first-order formulas over the real field is known to be computable (Tarski, 1951) and efficient algorithms for this problem exist (Renegar, 1998).", "startOffset": 82, "endOffset": 96}, {"referenceID": 23, "context": "Model-checking first-order formulas over the real field is known to be computable (Tarski, 1951) and efficient algorithms for this problem exist (Renegar, 1998).", "startOffset": 145, "endOffset": 160}, {"referenceID": 3, "context": "(Crouch et al., 2010), and we have also (Jordan & Kaiser, 2013b) implemented, benchmarked and evaluated a number of different approaches to the problem.", "startOffset": 0, "endOffset": 21}, {"referenceID": 0, "context": "While polynomial time or logspace reductions are most common, such power is usually not necessary for reductions and only causes additional difficulties (Agrawal, 2011; Agrawal, Allender, Impagliazzo, Pitassi, & Rudich, 2001; Veith, 1998).", "startOffset": 153, "endOffset": 238}, {"referenceID": 27, "context": "While polynomial time or logspace reductions are most common, such power is usually not necessary for reductions and only causes additional difficulties (Agrawal, 2011; Agrawal, Allender, Impagliazzo, Pitassi, & Rudich, 2001; Veith, 1998).", "startOffset": 153, "endOffset": 238}, {"referenceID": 3, "context": "(Crouch et al., 2010).", "startOffset": 0, "endOffset": 21}, {"referenceID": 3, "context": "(Crouch et al., 2010) and therefore allow us to compare with ReductionFinder as well.", "startOffset": 0, "endOffset": 21}, {"referenceID": 17, "context": "2 Learning First-Order Formulas Recently, a system was implemented (Kaiser, 2012) that represents board games as relational structures and learns their rules from observing example play videos.", "startOffset": 67, "endOffset": 81}, {"referenceID": 17, "context": "Results We substituted our SAT-based learner for the procedure for computing distinguishing formulas used in (Kaiser, 2012).", "startOffset": 109, "endOffset": 123}, {"referenceID": 17, "context": "Breakthrough Connect4 Gomoku Pawn-Whopping Original system 39s 14s 4s 473s SAT-based system 2s 5s 2s 130s We use the same example plays for both systems \u2013 these examples were chosen by hand for the original system (Kaiser, 2012).", "startOffset": 214, "endOffset": 228}, {"referenceID": 13, "context": "(Itzhaky et al., 2010) considered a similar problem, however they focused on synthesizing formulas in more specialized logics.", "startOffset": 0, "endOffset": 22}, {"referenceID": 12, "context": "11 in (Immerman, 1999)).", "startOffset": 6, "endOffset": 22}, {"referenceID": 3, "context": "Thanks to the efficiency of modern SAT and QBF solvers, our general procedure outperforms specialized approaches both in learning reductions (Crouch et al., 2010) and in learning from examples (Kaiser, 2012).", "startOffset": 141, "endOffset": 162}, {"referenceID": 17, "context": ", 2010) and in learning from examples (Kaiser, 2012).", "startOffset": 38, "endOffset": 52}, {"referenceID": 28, "context": "We would like to know how to choose \u201cgood\u201d counter-examples and whether randomness (Zeugmann, 2006) can help.", "startOffset": 83, "endOffset": 99}], "year": 2016, "abstractText": "Machine learning is a thriving part of computer science. There are many efficient approaches to machine learning that do not provide strong theoretical guarantees, and a beautiful general learning theory. Unfortunately, machine learning approaches that give strong theoretical guarantees have not been efficient enough to be applicable. In this paper we introduce a logical approach to machine learning. Models are represented by tuples of logical formulas and inputs and outputs are logical structures. We present our framework together with several applications where we evaluate it using SAT and SMT solvers. We argue that this approach to machine learning is particularly suited to bridge the gap between efficiency and theoretical soundness. We exploit results from descriptive complexity theory to prove strong theoretical guarantees for our approach. To show its applicability, we present experimental results including learning complexity-theoretic reductions rules for board games. We also explain how neural networks fit into our framework, although the current implementation does not scale to provide guarantees for real-world neural networks.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}