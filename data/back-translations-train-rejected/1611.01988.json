{"id": "1611.01988", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Nov-2016", "title": "Differentiable Functional Program Interpreters", "abstract": "We discuss a range of modeling choices that arise when constructing an end-to-end differentiable programming language suitable for learning programs from input-output examples. Taking cues from programming languages research, we study the effect of memory allocation schemes, immutable data, type systems, and built-in control-flow structures on the success rate of learning algorithms. We build a range of models leading up to a simple differentiable functional programming language. Our empirical evaluation shows that this language allows to learn far more programs than existing baselines.", "histories": [["v1", "Mon, 7 Nov 2016 11:09:19 GMT  (37kb)", "https://arxiv.org/abs/1611.01988v1", "Submitted to ICLR 2017"], ["v2", "Thu, 2 Mar 2017 13:26:11 GMT  (70kb)", "http://arxiv.org/abs/1611.01988v2", null]], "COMMENTS": "Submitted to ICLR 2017", "reviews": [], "SUBJECTS": "cs.PL cs.LG", "authors": ["john k feser", "marc brockschmidt", "alexander l gaunt", "daniel tarlow"], "accepted": false, "id": "1611.01988"}, "pdf": {"name": "1611.01988.pdf", "metadata": {"source": "META", "title": "Differentiable Functional Program Interpreters", "authors": ["John K. Feser", "Marc Brockschmidt", "Alexander L. Gaunt", "Daniel Tarlow"], "emails": ["<feser@csail.mit.edu>."], "sections": [{"heading": null, "text": "ar Xiv: 161 1.01 988v 2 [cs.P L] 2M ar2 017 induces computer programs on the basis of input-output examples. It can be regarded as a kind of machine learning in which the hypotheses space is the set of legal programs in a programming language. Recent work on differentiable interpreters loosen the discrete space of programs into a continuous space, so that the search for programs can be performed by means of gradient-based optimization. Although conceptually powerful, the previously differentiated interpretation-based program synthesis has only been able to solve very simple problems. In this thesis, we investigate the modeling options that arise during the construction of a differentiable programming language and their effects on the success of the synthesis. The main motivation for modeling programming languages lies in functional programming: We study the effects of memory allocation schemes, fixed data, type systems and control structures that allow us to empathize with existing functional languages."}, {"heading": "1. Introduction", "text": "In fact, most of them are able to determine for themselves what they want and what they want."}, {"heading": "2. Related Work", "text": "In fact, most of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move and to move."}, {"heading": "3. Differentiable Interpreters", "text": "We start by putting the heap and the newly created heap cell in the center. (...) We start by putting the heap and the heap cell in the center. (...) We assume that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that the heap cell (...), that they (...), that they (...), that they (...), that they (...), that they (...), that they (...), that they (...), that they (...), that they (..., that they (...), that they (...), that they (..., that they), that they (..., that they (...), that they (...), that they (... (...), that they (...), that they (... (...), that they (...), that they (..., that they), that they (... (...), that they (..., that they), that they (..., that they), that they (..., that they), that they (... (..., that they), that they), that they (... (..., that they), that they), that they (... (... (..., that they), that they), that they), that they (... (... (..., that they), that they), that they), that they (... (... (... (..., that they), that they), that they), that they (... (... (..., that they), that they), that they), that they (... (... (..., that they), that they... (..., that they), that they (..., that they), that they), that they... (... (... (... (..., that they), that..., that they), that..., that..., that they..., that..., that they..., that they..., that"}, {"heading": "4. Differentiable Functional Program Interpreters", "text": "In the following, we will discuss how and why to add functional programming functions to differentiated interpreters. We will start with the simple assembly language from the previous section and arrive at a differentiated version of a simple functional programming language. We will begin with the development of an observation model for list structured data and then make four modelling recommendations inspired by functional programming. Empirically, we will demonstrate the usefulness of these recommendations in Section 5."}, {"heading": "4.1. Observation Model for List Data", "text": "In fact, it is true that it is a way in which people are able to survive on their own, and in which people are able to survive on their own. \"(S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S. S."}, {"heading": "4.3. Memory Management", "text": "Most modern programming languages avoid manual memory management and pointer manipulation where possible."}, {"heading": "4.4. Immutable Data", "text": "Functional programming expects functions to have no side effects, and all data is invariable, which helps programmers think about their code, since it eliminates the possibility that a variable cannot be initialized or retrieved in an inconsistent state. In addition, no data is \"lost\" by being overwritten or mutated. In initial training models, we observed that many random initializations of program parameters would overwrite input data or important intermediate results. In models with combinators that provide a way to collect result values, we can work around this problem by making registers unchangeable. To do this, we create one register per time step and fix the output of each statement to the register for its period of time. The argument parameters then extend across all registers initialized in previous timeframes, with the exception of the closures executed by a combinator. Here, each statement gets access to the registry only by copying the input values, and then closing them."}, {"heading": "4.5. Types", "text": "In programming languages, expressive type systems are used to protect programmers from writing programs that will fail. In practice, a type checker is able to exclude many syntactically correct programs that are certain to fail at runtime, thus limiting the space available for valid programs. We expect the learned program to be typed well, so we are introducing a simple type system. We have explored two approaches to add a type system. Our first attempt expanded the goal to include a penalty for type errors. In our programs, we use three simple types of data - integers, pointers, and booleans - as well as a special type that represents type errors."}, {"heading": "5. Experiments", "text": "We have set out in search of new paths that will lead us into the future."}, {"heading": "5.1. Straight-line programs", "text": "In our first experiment, we look at two families of simple problems - solvable with rectilinear programs - to examine the interaction of our modeling decisions with program length. Our first benchmark task is to duplicate a scalar input k times to create a list of length k. Our second yardstick is to retrieve the k element of a list and fix k beforehand (we will consider generalizing this task, where k will later be a program input). We set the hyperparameters for all models to allow 11 statements, i.e. for A and A + F we have set program length to 11, and for the A + L and C * models we have the prefix and loop length to 0 and the suffix length to 11. For models where the number of registers does not depend on the number of time points, we use 3 registers, with one initialized on input."}, {"heading": "5.2. Simple loop programs", "text": "In our second experiment, we compared our models using three simple list algorithms: calculating the length of a list, reversing a list, and summarizing a list. Model parameters were set to allow for 6 statements for the A and A + F models, as well as empty prefixes, empty suffixes, and 2 statements in the loop for the other models. In models where the number of registers does not depend on the number of timestamps, we use 4 registers, one of which has been initialized to the input. The results of our evaluation are presented in Tab. 1 and clearly illustrate the recommendation (L) to use predefined loop structures. We speculate that learning explicit jump targets is extremely difficult because changes in the parameters controlling the jump target instructions have an excessive impact on all calculated (intermediate and output) values. On the other hand, models that could choose between different list iteration primitives showed programs for all 4We that vary from M."}, {"heading": "5.3. Loop Programs", "text": "In our main experiment, we look at a larger set of common list-manipulating tasks (such as checking whether all / one element of a list is larger than a limit, retrieving a list element by index, determining the index of a value, and calculating the maximum value). Descriptions of all tasks are given in paragraph A.1 in the appendix. We do not show results for models A and A + F, which always fail. We set the parameters for the other models to M = 32 (M = H = 34 for the others), the length of the prefix to 1, the length of the closure / abrasive body to 3, and the length of the suffix to 2. Again, these parameters are somewhat larger than prescribed by the largest program to learn. The results for our experiments on these tasks are in Tab. 2. Note the modified results of the examples from Abs. / abrasive body to 3 and the length of the suffix to 2. Registers. Again, these parameters are slightly larger than the largest program to learn."}, {"heading": "5.4. Comparison with NRAM", "text": "Our hypothesis was that the NRAM controller would not generalize if trained on a small set of input-output examples. Since we believe that programming by example use cases is usually based on a small number of examples, we explicitly tested this hypothesis on the simplest listing task len. Although it was not taken into consideration (Kurach et al., 2016), it is somewhat simpler than the ListK and ListSearch tasks, which are classified as \"hard tasks.\" We point out that the NRAM model is very different, but implements some of our recommendations: The RNN-like structure imposes a basic loop structure, and the output of each module (i.e., the statement in our setting) is stored in a fixed register, which is stored during a loop iteration.For our experiments, we significantly simplified the NRAM model and only provided the modules read a basic loop structure, i.e., the output in our modules (and the output)."}, {"heading": "6. Discussion and Future Work", "text": "Empirically, we have developed these recommendations for significantly improving the success ratio of tutorials based on input / output examples, and we expect these results to be generalized to similar models that attempt to learn programs. In this paper, we look at list-manipulating programs, but we are interested in supporting more data structures, such as arrays (which should be a straightforward extension) and associative maps. We currently only support loops over lists, but are interested in extending our models to include built-in support for loops that count up (and down) integer values. Generalizing this concept would be an extension that allows learning and using recursive functions. Recursion is still more structured than raw goto calls, but more flexible than the combinators we currently use. Efficient implementation of recursion is a challenging research problem, but it could allow us to use much more complex programs than raw goto calls, which are more flexible than the structured calls we currently use."}, {"heading": "A. Appendix", "text": "A.1. Experiment TasksName Descriptionlen Returns the length of a list. rev Reverse a list. add up all the elements of a list. allGtK Check if all the elements of a list. exGtK Check if at least one element of a list. findLastIdx Find the index of the last list element that is the same v. getIdx Returns the kth element of a list. last2 Returns the second-last element of a list. pairwiseSum Create list in which each element of the input list k was added. Create mapInc list in which each element of the input list is incremented. max Returns the maximum element of a list. pairwiseSum list in which each element creates the sum of the associated elements of the input liste.revMapInc list and increments each element. Fundition. Our sample tasks for loop-based programs. \"Simple\" tasks lie above the line.dididelediled."}], "references": [{"title": "Letters to the Editor: Go to Statement", "author": ["Dijkstra", "Edsger W"], "venue": null, "citeRegEx": "Dijkstra and W.,? \\Q2016\\E", "shortCiteRegEx": "Dijkstra and W.", "year": 2016}, {"title": "Neural programmerinterpreters", "author": ["Reed", "Scott E", "de Freitas", "Nando"], "venue": "In Proceedings of the 4th International Conference on Learning Representations (ICLR),", "citeRegEx": "Reed et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Reed et al\\.", "year": 2016}, {"title": "Programming with a differentiable forth interpreter", "author": ["Riedel", "Sebastian", "Bosnjak", "Matko", "Rockt\u00e4schel", "Tim"], "venue": "CoRR, abs/1605.06640,", "citeRegEx": "Riedel et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Riedel et al\\.", "year": 2016}, {"title": "Learning simple algorithms from examples", "author": ["Zaremba", "Wojciech", "Mikolov", "Tomas", "Joulin", "Armand", "Fergus", "Rob"], "venue": "In Proceedings of the 33nd International Conference on Machine Learning (ICML),", "citeRegEx": "Zaremba et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zaremba et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 2, "context": ", 2016)), and a small amount of recent work on gradient-based program induction (Bunel et al., 2016; Riedel et al., 2016; Gaunt et al., 2016).", "startOffset": 80, "endOffset": 141}, {"referenceID": 3, "context": "Zaremba et al. (2016) induce algorithms using a reinforcement learning setup, which avoids the need for the smoothing operations.", "startOffset": 0, "endOffset": 22}, {"referenceID": 3, "context": "Zaremba et al. (2016) induce algorithms using a reinforcement learning setup, which avoids the need for the smoothing operations. Like the other above works, it uses a neural network controller to decide the order in which to perform operations. Reed & de Freitas (2016) learn algorithms from strong supervision specifying which operation to perform at each step.", "startOffset": 0, "endOffset": 271}, {"referenceID": 3, "context": "Zaremba et al. (2016) induce algorithms using a reinforcement learning setup, which avoids the need for the smoothing operations. Like the other above works, it uses a neural network controller to decide the order in which to perform operations. Reed & de Freitas (2016) learn algorithms from strong supervision specifying which operation to perform at each step. Li et al. (2017) weakens the supervision requirement somewhat but still requires supervision in the form of sequences of basic actions and some strong supervision.", "startOffset": 0, "endOffset": 381}, {"referenceID": 2, "context": "(2016) and Riedel et al. (2016) have used program models similar to assembly (resp.", "startOffset": 11, "endOffset": 32}, {"referenceID": 2, "context": "(2016) and Riedel et al. (2016) have used program models similar to assembly (resp. Forth) source code to initialize solutions, and either optimize or complete them. Gaunt et al. (2016) develops a framework that allows comparing differentiable interpreters to several alternative synthesis systems, focusing on low-level programmingmodels including Turing machines, Boolean circuits, and an assembly-like language.", "startOffset": 11, "endOffset": 186}, {"referenceID": 2, "context": "(Graves et al., 2014; Kurach et al., 2016; Bunel et al., 2016; Riedel et al., 2016; Gaunt et al., 2016)) and replace all discrete values with probability distributions over their values and lift all operations to operate on probability distributions instead of discrete values by averaging over all the possibilities with weights given by the probability distributions.", "startOffset": 0, "endOffset": 103}], "year": 2017, "abstractText": "Programming by Example (PBE) is the task of inducing computer programs from input-output examples. It can be seen as a type of machine learning where the hypothesis space is the set of legal programs in some programming language. Recent work on differentiable interpreters relaxes the discrete space of programs into a continuous space so that search over programs can be performed using gradient-based optimization. While conceptually powerful, so far differentiable interpreter-based program synthesis has only been capable of solving very simple problems. In this work, we study modeling choices that arise when constructing a differentiable programming language and their impact on the success of synthesis. The main motivation for the modeling choices comes from functional programming: we study the effect of memory allocation schemes, immutable data, type systems, and built-in control-flow structures. Empirically we show that incorporating functional programming ideas into differentiable programming languages allows us to learn much more complex programs than is possible with existing differentiable languages.", "creator": "LaTeX with hyperref package"}}}