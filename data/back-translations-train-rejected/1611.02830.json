{"id": "1611.02830", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Nov-2016", "title": "Online Learning for Wireless Distributed Computing", "abstract": "There has been a growing interest for Wireless Distributed Computing (WDC), which leverages collaborative computing over multiple wireless devices. WDC enables complex applications that a single device cannot support individually. However, the problem of assigning tasks over multiple devices becomes challenging in the dynamic environments encountered in real-world settings, considering that the resource availability and channel conditions change over time in unpredictable ways due to mobility and other factors. In this paper, we formulate a task assignment problem as an online learning problem using an adversarial multi-armed bandit framework. We propose MABSTA, a novel online learning algorithm that learns the performance of unknown devices and channel qualities continually through exploratory probing and makes task assignment decisions by exploiting the gained knowledge. For maximal adaptability, MABSTA is designed to make no stochastic assumption about the environment. We analyze it mathematically and provide a worst-case performance guarantee for any dynamic environment. We also compare it with the optimal offline policy as well as other baselines via emulations on trace-data obtained from a wireless IoT testbed, and show that it offers competitive and robust performance in all cases. To the best of our knowledge, MABSTA is the first online algorithm in this domain of task assignment problems and provides provable performance guarantee.", "histories": [["v1", "Wed, 9 Nov 2016 06:21:27 GMT  (1593kb,D)", "http://arxiv.org/abs/1611.02830v1", "10 pages, 8 figures, conference"]], "COMMENTS": "10 pages, 8 figures, conference", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["yi-hsuan kao", "kwame wright", "bhaskar krishnamachari", "fan bai"], "accepted": false, "id": "1611.02830"}, "pdf": {"name": "1611.02830.pdf", "metadata": {"source": "CRF", "title": "Online Learning for Wireless Distributed Computing", "authors": ["Yi-Hsuan Kao", "Kwame Wright", "Bhaskar Krishnamachari", "Fan Bai"], "emails": ["bkrishna}@usc.edu", "fan.bai@gm.com"], "sections": [{"heading": null, "text": "These devices, which either suffer from heavy battery use, such as mobile devices, or limited computing power, such as sensors, are unable to perform compute-intensive tasks independently of each other. Nevertheless, what can these devices do when they are connected and collaborating with each other? Networked devices on the network that share resources provide a platform with abundant computing resources that allows complex applications to run [1]. Traditional cloud services provide access to high performance and reliable servers."}, {"heading": "A. Why online learning?", "text": "Since the resource network is subject to drastic changes over time and is difficult to model by stationary stochastic processes, we need an algorithm called Xiv: 161 1.02 830v 1 [cs.L G] 9N ov2 016, which is applicable to all possible scenarios, learns the environment at runtime and adapts to changes. Existing work focuses on solving optimization problems in the face of known deterministic profiles or known stochastic distributions [6]. These problems are difficult to solve. More importantly, algorithms lacking learning ability could be severely damaged by statistical changes or mismatches between the profile (offline training) and the runtime environment. Therefore, we use an online learning approach that takes into account performance during the learning phase and aims to quickly learn the environment and adapt to changes."}, {"heading": "B. Contributions", "text": "A new formulation of task assignment issues, taking into account the general and dynamic environment: We use a novel formulation of the opposing multi-armed bandit (MAB) that makes no assumptions about the dynamic environment, i.e. it applies to all realistic scenarios. A light algorithm that learns the environment quickly, with demonstrable performance guarantees: MABSTA runs with ease of complexity and storage, allowing performance guarantee and learning time that are significantly improved over the existing MAB algorithm. Wide range of applications in wireless device networks: MABSTA enhances collaborative computing over wireless devices and enables more potential applications in mobile cloud computing, wireless sensor networks, and the Internet of Things."}, {"heading": "II. BACKGROUND ON MULTI-ARMED BANDIT PROBLEMS", "text": "The Multi-Armed Bandit (MAB) problem is a sequential decision problem, where at any time an agent chooses over a number of \"weapons,\" gets the profit from the selected weapons and tries to learn the statistical information from scanning. These phrases have recently been considered in the context of opportunistic spectrum access for cognitive wireless networks, but these phrases differ significantly from ours in that they focus only on channel assignment and not on assignment of computing tasks to servers [9], [10]. In the face of an online algorithm on a MAB problem, its performance is measured by a regret function, which indicates how much the agent loses due to the unknown information at the beginning [11] and not on assignment of computing tasks to servers [10]. In the face of an online algorithm on a MAB problem, its performance is measured by a regret function, which indicates how much the agent loses due to the unknown information at the beginning [11]."}, {"heading": "III. PROBLEM FORMULATION", "text": "Suppose a data processing application consists of N tasks, where their dependencies are described by a targeted reward. (DAG) G = (V, E) as shown in Figure 1 means that some data exchange between task m and task n is necessary and therefore task n cannot begin until task m is completed. (D) There is an incoming data stream that needs to be processed (T data frame total), where for each data frame t it is necessary to go through all tasks and leave keywords. There are M devices available. The assignment strategy of the data frame t is represented by a vector = xt1, \u00b7 xtN, where xti names the device that performs task i. Given an assignment strategy, the stage-wised costs for each node (task) apply to compilation and each edge for communication. The cost can correspond to the resource consumption for a task, for example, energy consumption."}, {"heading": "IV. MABSTA ALGORITHM", "text": "We summarize MABSTA in algorithm 1. For each data frame t, MABSTA will randomly select a practicable mapping (arm x x x x x F) from a probability distribution that depends on the weights of the arms (wy (t)), then update the weights based on the reward samples. From (2), MABSTA will randomly switch between two phases: exploitation (with probability 1 \u2212 N) and exploration (with probability N). In the exploitation phase, MABSTA will select an arm based on its weight. Therefore, the one with higher reward samples will be more likely to be selected. In the exploration phase, MABSTA consistently selects an arm without taking into account its performance. The fact that MABSTA checks each weapon makes it adaptable to environmental changes, compared to the case where the static strategy plays the best role so far, without other weapons having to know that they need a better performance."}, {"heading": "V. POLYNOMIAL TIME MABSTA", "text": "In algorithm 1, since there are exponentially many arms, implementation can lead to exponential storage and complexity. However, below we propose an equivalent but efficient implementation. We show that if the task diagram belongs to a subset of DAG that appears in practical applications (namely parallel tree chains), algorithm 1 can be executed in polynomial time with polynomial storage. Therefore, we write (6) aswy (t + 1) = exp (t) = 1 Ry (t)) = cancelled."}, {"heading": "A. Tree-structure Task Graph", "text": "Now let's focus on calculating the sum of weights in (8). We start with tree structure task diagrams and solve the more general graphs by using the proposed algorithm for trees as a polynomial number of times.We assume that the task diagram is a tree with N nodes where the N node is the root (last task).Let e (j) i = exp (j) i) i (j) i (j) i (j) i) s task (n) s task (last task).Let e (j) i = exp (j) i (j) s task (j) i (j) s task (j) s task (j)."}, {"heading": "B. More general task graphs", "text": "For task diagrams where there is a node with multiple outgoing edges, we split the task diagram into several trees and solve them separately and combine the solutions at the end. In the following, we will use an example of a task diagram consisting of several trees to illustrate our work.Figure 3 shows a task diagram that has two trees rooted by task i1 and i2. If we leave the partial problem (j2 | j1) i2 | i1, we will describe the sum of weights that i2 is assigned to the task and i1 is assigned to task i1."}, {"heading": "C. Marginal Probability", "text": "From (8) we can calculate the limit probability P {xti = j} if we can solve the sum of the weights over all possible tasks assigned to task i to the device j. If task i is the root (node N), then algorithm 2 solves the task i (j) i = \u2211 y: yi = jwy (t) exactly. If task i is not the root, we can still execute algorithm 2 to solve the task i (j) p \u00b7 yi = j, which determines the assignment of task i to device j when solved by the parent i. That is, [\u03c9 (j) p] yi = j (j \u2032) p e (jj \u2032) ip."}, {"heading": "D. Sampling", "text": "Since we can calculate the boundary probabilities efficiently, we propose an efficient sampling policy, which is summarized in algorithm 3. Algorithm 3 first selects a random number s between 0 and 1. If s is less than \u03b3, it refers to the exploration phase in which MABSTA simply selects an arm uniformly. Otherwise, MABSTA selects an arm based on the probability distribution py (t), which aspy (t) = P {xt1 = y1} \u00b7 P {xt2 = y2 | xt1 = y1} \u00b7 \u00b7 P {xtN = y1, \u00b7 \u00b7, xtN \u2212 1 = yN \u2212 1} can be written. Therefore, MABSTA assigns each task in the order based on which the assignment to previous tasks is given."}, {"heading": "VI. NUMERICAL EVALUATION", "text": "In this section, we will first examine how MABSTA adapts to the dynamic environment, then perform a trace data emulation to verify MABSTA's performance guarantee and compare it with other algorithms."}, {"heading": "A. MABSTA\u2019s Adaptivity", "text": "Here, we examine the adaptability of MABSTA to the dynamic environment and compare it with the optimal strategy based on the existing profile. We use a two-device setup where the cost of performing the task is characterized by two different Markov processes. We neglect the channel communication costs, so the optimal strategy is the short-sighted strategy, that is, the assignment of tasks to the device with the highest belief that it is in \"good\" condition [17]. We conduct our experiment with an application consisting of 10 tasks and process the incoming data frames one by one. The environment changes in the 100th frame, where the transition matrices of two Markov processes alternate. Starting with Figure 4, there is an optimal mapping (dashed line), so that the performance remains as good as it was before the 100th frame. However, short-sighted strategy with the incorrect information of the transition matrices fails to adapt to the changes. Starting from 100, MABA relies on the probability that the result will not only change, but also on the previous samples."}, {"heading": "B. Trace-data Emulation", "text": "We create a network of 10 IEEE 802.15.4-based wireless embedded devices and conduct a series of experiments to measure two performance characteristics used by MABSTA, namely channel conditions and the availability of computing resources. To assess channel conditions, the time it takes to perform a simulated task for an evenly distributed number of iterations is measured. Parameters of distribution are shown in Table I. Since latency is positively correlated with the power consumption of the device and the wireless transmission performance is kept constant in these experiments, it can also be used as an indicator of energy costs. We use these samples as reward sequences in the following emulation. We present our assessment as a regret compared to solving the problem in real life."}, {"heading": "VII. APPLICATIONS TO WIRELESS DEVICE NETWORKS", "text": "MABSTA is applicable to many realistic scenarios, including the following device networks."}, {"heading": "A. Mobile Cloud Computing", "text": "Computational offloading - the migration of intensive tasks to more inventive servers - is a widely used approach to expanding computing on a resource-limited device. [18] Instead of solving deterministic optimizations based on profiles, such as MAUI [19], or offering heuristic solutions without performance guarantees, such as Odessa [15], MABSTA can be used to learn the optimal offloading decision (task assignment) in a dynamic environment. B. Vehicular Ad Hoc Networks (VANETs) Applications on VANETs have lately gained commercial relevance. These applications, such as downloading content, rely on both vehicle-to-vehicle (V2V) and vehicle-to-infrastructure (V2I) communications [20]. Computational offloading or Service Discovery over VANETs are promising approaches with the help of active units running through these historic roads [21] and other efficient vehicles."}, {"heading": "C. Wireless Sensor Networks and IoT", "text": "Wireless Sensor Networks (WSN) suffer from severe power consumption on each node in real-world applications. These sensors are often equipped with functional microprocessors for specific tasks. Therefore, in some cases, WSN applications face the dilemma of pre-processing tasks on lower-performance devices or transmitting raw data to back-end processors [16]. Depending on channel conditions, MABTSA can adjust strategies by assigning pre-processing tasks to front-end sensors when the channel is bad, or simply transmitting raw data when the channel is good. In addition, MABSTA can also take battery status into account, so that the assignment strategy adapts to the battery that remains on each node to extend the lifetime of the network.In future IoT networks, fog computing is a concept similar to wireless distributed computing, but scales to a larger number of nodes and generalized heterogeneity on devices, communication protocols, 22 and [2]."}, {"heading": "VIII. CONCLUSION", "text": "The concept of wireless distributed computing enables complex applications that a single device cannot support individually as the number of computer and communication enabled devices increases. However, intermittent and heterogeneous connections and different device behavior make performance highly variable over time. In this paper, we have proposed a new online learning formula for wireless distributed computing that does not allow for stationary stochastic assumptions across channels and devices. We have presented MABSTA, which to the best of our knowledge is the first online learning algorithm tailored to this problem class. We have proven that MABSTA can be efficiently implemented and provides a performance guarantee for an all-dynamic environment. Trace data emulation has shown that MABSTA competes with the optimal offline strategy and adapts to changes in the environment. Finally, we have identified several wireless distributed computing applications where MABSTA can be used fruitfully."}, {"heading": "APPENDIX A PROOF OF THEOREM 1", "text": "We will first prove the following terms: In the test, where the result applies to each t, we will use more compressed notations such as R-i for R-i (yi) i (t) and R-i (ymyn) mn for R-i (ymyn) mn (t)."}, {"heading": "A. Proof of lemmas", "text": "Lemma 1: F py (t) R py (t) R py (t) R py (t) R py (t) R py (n) R py (t) R py (t) R py (t) R py (t) R py (n) R py (m, n) y (t) y py (m) n py (m) n py (m) n py (m, n) n py (m) n py (n) n py (m) n py (m) y (m) y py (m) n py (m) n py (m) n py (m) n py (m) n py (m) n py (n) n (n) n (n) n (y (n) n (n) n (n) n (n) n (n) n (n) n (m) n (n) n (n) n (m) n (n) n (n) n (m) n (n) n (n) n (n) n (m) n (n) n (n) n (n) n) n (n) n (n) n (n) n (n) n) n (n) n (n) n (n) n (n) n) n (n) n (n) n (n) n) n (n) n (n) n (n) n (n) n (n) n (n) n) n py (n (n) n (n) n (n) n (n) n) n py (n (n) n (n) n (n) n (n) n) n (n) n py (n) n (n (n) n (n) n (m) n) n py (n) n (m (n) n py (n) n (m) n) n py (m (n) n (n) n) n (n) n (m (n) n) n) n (n) n (n) n) n (n) n (n) n (n) n (m py (m."}, {"heading": "B. Proof of Theorem 1", "text": "The proof: Let us leave Wt = 2 \u2212 F wy (t) = 2 \u2212 F wy (t). We designate the order of the decisions made on each frame as x = [x1, \u00b7 \u00b7, xT], where xt \u2212 F \u2212 n \u2212 is the arm drawn in step t. Then, for all data frames, we get t, Wt + 1 Wt = 3 W = 4 F wy (t)."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Abstract\u2014There has been a growing interest for Wireless Distributed Computing (WDC), which leverages collaborative computing over multiple wireless devices. WDC enables complex applications that a single device cannot support individually. However, the problem of assigning tasks over multiple devices becomes challenging in the dynamic environments encountered in real-world settings, considering that the resource availability and channel conditions change over time in unpredictable ways due to mobility and other factors. In this paper, we formulate a task assignment problem as an online learning problem using an adversarial multi-armed bandit framework. We propose MABSTA, a novel online learning algorithm that learns the performance of unknown devices and channel qualities continually through exploratory probing and makes task assignment decisions by exploiting the gained knowledge. For maximal adaptability, MABSTA is designed to make no stochastic assumption about the environment. We analyze it mathematically and provide a worstcase performance guarantee for any dynamic environment. We also compare it with the optimal offline policy as well as other baselines via emulations on trace-data obtained from a wireless IoT testbed, and show that it offers competitive and robust performance in all cases. To the best of our knowledge, MABSTA is the first online algorithm in this domain of task assignment problems and provides provable performance guarantee.", "creator": "LaTeX with hyperref package"}}}