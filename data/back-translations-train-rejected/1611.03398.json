{"id": "1611.03398", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2016", "title": "XCSP3: An Integrated Format for Benchmarking Combinatorial Constrained Problems", "abstract": "We propose a major revision of the format XCSP 2.1, called XCSP3, to build integrated representations of combinatorial constrained problems. This new format is able to deal with mono/multi optimization, many types of variables, cost functions, reification, views, annotations, variable quantification, distributed, probabilistic and qualitative reasoning. The new format is made compact, highly readable, and rather easy to parse. Interestingly, it captures the structure of the problem models, through the possibilities of declaring arrays of variables, and identifying syntactic and semantic groups of constraints. The number of constraints is kept under control by introducing a limited set of basic constraint forms, and producing almost automatically some of their variations through lifting, restriction, sliding, logical combination and relaxation mechanisms. As a result, XCSP3 encompasses practically all constraints that can be found in major constraint solvers developed by the CP community. A website, which is developed conjointly with the format, contains many models and series of instances. The user can make sophisticated queries for selecting instances from very precise criteria. The objective of XCSP3 is to ease the effort required to test and compare different algorithms by providing a common test-bed of combinatorial constrained instances.", "histories": [["v1", "Thu, 10 Nov 2016 17:00:56 GMT  (494kb,D)", "http://arxiv.org/abs/1611.03398v1", "230 pages"]], "COMMENTS": "230 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["frederic boussemart", "christophe lecoutre", "c\\'edric piette"], "accepted": false, "id": "1611.03398"}, "pdf": {"name": "1611.03398.pdf", "metadata": {"source": "CRF", "title": "XCSP3 An Integrated Format for Benchmarking Combinatorial Constrained Problems", "authors": ["Fr\u00e9d\u00e9ric Boussemart", "Christophe Lecoutre", "C\u00e9dric Piette"], "emails": ["boussemart@cril.fr", "lecoutre@cril.fr", "piette@cril.fr"], "sections": [{"heading": null, "text": "XCSP3An Integrated Format for BenchmarkingCombinatorial Constrained ProblemsFre \u00d3ric Boussemart Christophe Lecoutre Ce \u0301 dric PietteCRIL- CNRS, UMR 8188, University of Artois Rue de l'universite \u0301, SP 16, 62307 Lens, Francewww.xcsp.orgXCSP3 Specifications - Version 3.0.4 August 20, 2016ar Xiv: 161 1,03 398v 1 [cs.A] 1 0N ov2 016Please do not hesitate to give us feedback. Send an email to: {boussemart, lecoutre, piette} @ cril.frXCSP3 Website: www.xcsp.orgAbstractWe are major revision of the format XCSP 2.1, called XCSP3, to build integrated representations of combinatorial confined problems."}, {"heading": "1 Introduction 7", "text": "1.1. Features of XCSP3........................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "2 Variables 23", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "3 Objectives 39", "text": "3.1 Goals in functional forms................................................................................................. 40 3.3 Multi-goal optimisation................................."}, {"heading": "II Constraints 43", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4 Constraints over Simple Discrete Variables 45", "text": "The personal data will be published in the next few weeks, and the personal data will be published in the coming weeks and months."}, {"heading": "5 Constraints over Complex Discrete Variables 90", "text": "The number of unemployed in Germany has risen slightly compared to the previous year."}, {"heading": "6 Constraints over Continuous Variables 106", "text": "6.1. Restrictions on real variables..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "III Advanced Forms of Constraints 112", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "7 Lifted and Restricted Forms of Constraints 114", "text": "The number of unemployed in Germany has risen slightly compared to the previous year."}, {"heading": "8 Meta-Constraints 136", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "9 Soft Constraints 146", "text": "The vast majority of respondents is of the opinion that the vast majority of respondents is of the opinion that the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority the vast majority of the vast majority the vast majority of the vast majority the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the vast majority of the majority of the"}, {"heading": "IV Groups, Frameworks and Annotations 159", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "10 Groups, Blocks, Reification, Views and Aliases 160", "text": "10.1 Constraint Templates and Groups..................................... 160 10.2 Blocks and Classes.............................. 164 10.3 Maturity.............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................."}, {"heading": "11 Frameworks 170", "text": "The personal data of the vast majority of people in Germany who work for the rights of women and children have declined significantly over the last ten years, not only in relation to child rearing, but also in relation to child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing, child rearing and much more."}, {"heading": "12 Annotations 194", "text": "12.1 Comments on variables..................................................................................................................... 197 12.3 Comments on pre-processing and search......................................................................................................................................................................"}, {"heading": "A KeyWords 202", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "B Syntax 203", "text": "This year, it will only take a year for a solution to be found and for a solution to be found."}, {"heading": "1.3 XML versus JSON", "text": "For various reasons, some people prefer to work with JSON rather than XML. \"As shown in Appendix D. We can easily convert XCSP3 instances from XML to JSON by following a few rules, as shown in the previous examples. (Example:\" XCSP3, \"\" XML, \"\" XML, \"\" XML, \"\" XML, \"\" \"XML,\" \"\" XML, \"\" \"XML,\" \"\" XML, \"\" \"XML\")."}, {"heading": "1.5 Important Notes about Syntax and Semantics", "text": "As already indicated, for the syntax that invites the reader to consult Appendix B. < \"In this section we will discuss some important points.\" < \"Every important decision refers to the way in which the boundary parameters are defined.\" < \"Most of the time in which we define a constraint is a main list of variables (not necessarily their full extent) that need to be handled. We have opted for call3 es < list of the most important variables (with their type / form) that allows us to derive variants from constraints in a very simple and natural way, using alternative forms such as < sentence > and < mset > as shown in Chapter 7.2. Also, quite often we need to introduce numerical conditions (comparisons) that operate from an operator and a right-hand side that is a value, an interval.\""}, {"heading": "1.6 Notes (Short Comments) and Classes", "text": "In XCSP3, it is possible to associate a note (short comment) with each element. Suffice it to use the attribute note, the value of which can be any string. Of course, when displaying the syntax, we will never write [note = \"string\"] every time an element is introduced. Here, there is a small instance with two variables and a constraint, each accompanied by a comment. Example 7 < instance format = \"XCSP3\" type = \"CSP\" > < variables > < var id = \"x\" note = \"x\" x \"is a number between 1 and 10\" > 1.. 10 < / var > < var id = \"y\" note = \"y denotes the square of x\" > 1.. 100 < / var > < variables > < note = \"x is a number between 1 and 10\" > 10 < / var > < < < < < < \"y = < < < < < < < <\" the square of < / var = < < < / note = < < < < < cony = < < < < < the constraint is a number between 1 and 10 \"> < < > < < < < < the constraint is < < < < < the configurable = < < < < <\" is < < \"containers)."}, {"heading": "1.7 Structure of the Document", "text": "The document is organized in four parts. In the first part, we will show you how to define different types of variables (Chapter 2) and objectives (Chapter 3) < < p > Variables (Chapter 5) and Continuous Variables (Chapter 6). In the second part, we will describe basic forms of constraints via simple discrete variables (Chapter 4), complex discrete variables (Chapter 5) and continuous variables (Chapter 6). Advanced (i.e. non-basic) forms of constraints are presented in the third part of the document: they correspond to lifted and restricted constraints (Chapter 7), meta constraints (Chapter 8) and soft constraints (Chapter 9) and soft constraints (Chapter 9). Finally, in the fourth part, we will introduce groups, reifications, views and aliases (Chapter 11) and annotations (Chapter 12)."}, {"heading": "2.1 0/1 Variables", "text": "Note 3 In XCSP3, there is no difference between a 0 / 1 variable and a Boolean variable: if applicable, 0 is false and 1 is true."}, {"heading": "2.2 Integer Variables", "text": "< p & p > p & p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p & p > p > p & p > p > p > p & p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p & p & p > p & p > p > p & p > p > p & p > p > p & p > p > p & p > p > p > p & p > p > p & p > p > p > p & p > p > p > p & p > p > p > p > p & p > p > p > p & p > p > p > p > p & p > p > p > p > p & p > p > p > p & p > p > p > p > p & p > p > p > p > p & p > p > p > p > p > p > p > p > p & p > p > p > p > p > p > p & p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p & p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p"}, {"heading": "2.3 Symbolic Variables", "text": "A symbolic variable is defined by a finite domain containing a sequence of symbols as possible values (spaces as separators), which are identifiers and must therefore begin with a letter. A symbolic variable requires the attribute type for the element < var >, and its value must be \"symbolic.\" 26 Syntax 8 < var id = \"identifier\" type = \"symbolic\" > (symbol space) * < / var > For example, variables light, whose domain is {green, orange, red}, and person, whose domain is {tom, oliver, john, marc}. Example 12 < var id = \"light\" type = \"symbolic\" > green orange red < / var > < var id = \"person\" type = \"tom oliver john marc < / var > Remark 6 Integer values and symbolic values must not be mixed within the same domain."}, {"heading": "2.4 Real Variables", "text": "The contents of an element < var >, which is a real variable, contains an ordered sequence of real intervals (two boundaries separated by a comma and enclosed between open or closed square brackets), the boundaries of which are integer, decimal, or rational values. In practice, there is only one interval most of the time. For example, a real variable requires the attribute type for element < var >, and its value must be \"real.\" Syntax 9 < var id = \"identifier\" type = \"real\" > (realIntvl wspace) * < / var > For example: Example: 13 < var id = \"w\" type = \"real\" < var id = \"real\" > [0, + infinity, \"var > < var wspace =\" real. \""}, {"heading": "2.5 Set Variables", "text": "< & < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < &lt"}, {"heading": "2.6 Graph Variables", "text": "< < & & & < & < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < &lt"}, {"heading": "2.7 Stochastic Variables", "text": "In some situations, when modeling a problem, it is useful to link a probability distribution to the values that exist in the domain of an integer variable. Such variables are typically uncontrollable (i.e. no decision variables), such as the stochastic CSP (SCSP) framework introduced by T. Walsh [135] to capture combinational decision problems with uncertainty. In XCSP3, the domain of an integer stochastic variable can be defined as usual by a sequence of integer numbers and integer intervals, but each element of the sequence is preceded by a probability that the symbol \":\" The value of a probability of a qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"}, {"heading": "2.8 Qualitative Variables", "text": "In the qualitative spatial and temporal reasoning (QSTR) [70], one has to argue with entities that correspond to points, intervals, regions... The introduced variables represent such entities, and their domains that are continuous cannot be described extensively, which is why we simply use the attribute type to refer to the implicit domain of qualitative variables. In XCSP3, we can currently refer to the following types: \u2022 \"point\" when we refer to the possible dates (or equivalent points of the line) \u2022 \"interval\" when we refer to the possible time intervals (or equivalent intervals of the line) 31 \u2022 \"region\" when we refer to possible regions in the Euclidean type type type type (or in a topological space) syntax 16 < var id = \"he\" type = \"< < var id =\" intervar \"> >; &ltid =\" type; type = \"var =\" var =:"}, {"heading": "2.9 Arrays of Variables", "text": "< < array = > array = > array = > array = > type = [type = \"varType\"] size = \"Dimensions\" [Index = \"integer\"] > < / array > Therefore, for each such element there is a required attribute ID and a required attribute array whose value defines the structure of the array under the form \"[type = nbp].\" ltables of nb1,. nbp being strict positive integers. The number of dimensions of an array is the number of pairs of opening / closing square brackets, and the size of each array is defined by its parenthesable value."}, {"heading": "2.9.1 Using Compact Forms", "text": "Sometimes you are interested in selecting some variables from an array, for example the variables in the first line of a 2-dimensional array. We use integer intervals for this purpose, as in x [3.. 5] and y [2.. 3] [0.. 1], and we refer to such expressions as compact lists of array variables. In a context where a list of variables is expected, it is possible to use this type of notation, and the result is then considered a list of variables, ordered by lexicographic order on index variables (for example y [2] [4] is before y [2] [5] since (2, 4)."}, {"heading": "2.9.2 Dealing With Mixed Domains", "text": "Sometimes, of course, variables from the same array have mixed domains. & < Another solution with XCSP3 is to build a large array suitable for all variables and then have inconsistent domain constraints. & & < < < Another solution with XCSP3 is to insert the different domain definitions within the < array > element. If several subsets of variables in an array have different domains, we simply need to have an element < domain > for each of these subsets. An attribute for this array indicates the list of variables that the domain definition applies to. \"Only one element &ltls] can be a sequence (white space as delimiter) of variable identifiers (authorized with compact forms) or the special value\" other \"that is used to declare a default domain.\""}, {"heading": "2.10 Empty Domains and Useless Variables", "text": "In some (rare) cases, you may want to represent variables with empty domains < < < < < / p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p"}, {"heading": "2.11 Solutions", "text": "< p > < p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p"}, {"heading": "3.1 Objectives in Functional Forms", "text": "The default value for type is \"expression,\" which means that the content of the element < minimize > or < maximize > is necessarily a numeric function expression (of course, possibly just a vari-39able) composed of the operators for COP instances (which deal only with integer values) described in Tables 4.1 and 5.1 and Table 6.1 for NCOP instances (which deal with real values), so a functional lens is defined by an element < minimize > or < maximize >. We only specify the syntax of < minimize > (since the syntax for < maximize > is quite similar) for COP instances. Here, an integer function expression is referred to as an intexpr in the syntax field below it; its exact syntax is specified in Appenditure B.Syntax 21 < maximize [= \"expression] < mize < > < > and minimize for > / object."}, {"heading": "3.2 Objectives in Specialized Forms", "text": "Whatever the type is under \"sum,\" \"product,\" \"minimum,\" \"maximum,\" \"nValues\" and \"lex,\" two forms are possible. < < < < < < < < < < < < < < < < < \"maximum,\" \"maximum,\" \"maximum,\" maximum, \"\" maximum. \"< < < <\" maximum, \"maximum.\" < < \"maximum,\" maximum. < \"<\" minimized, \"minimized,\" minimized, \"minimized.\" < / minimized. \"< / minimized.\""}, {"heading": "3.3 Multi-objective Optimization", "text": "This year, it has come to the point where it will be able to find a solution that is capable of finding a solution, that is capable of finding a solution, that is capable of finding a solution that is capable of finding a solution, and that is able to find a solution that is capable of finding a solution, that is able to find a solution that is capable of finding a solution, that is able to find a solution that is capable of finding a solution that is capable of finding a solution."}, {"heading": "4.1 Constraints over Integer Variables", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4.1.1 Generic Constraints", "text": "In this section, we present general types of constraint representation, namely intentional and extensional forms of constraints < < < < < < < / > Contexts of constraints < < / > Contexts we introduce are: 1. intension2. extension4.1.1.1 Constraint intensionIntensive constraints are an important type of constraints. They are defined by Boolean expressions that are usually referred to as predicates. For example, the function name appears first, followed by operations between parameters (with commands as separators).The XCSP3 representation of the constraint x, y, and z is eq (add (x, y), z). Operators on integers (including Booleans), as we assume that incorrect predicates can be used, are shown in Table 4.1."}, {"heading": "4.1.2 Constraints defined from Languages", "text": "< < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "4.1.3 Comparison-based Constraints", "text": "In this section, we present restrictions based on comparisons between variable pairs < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < / > < < < / > < / > < < / > < / > < / > < / > < / > < / > < / > < < < / > < / \""}, {"heading": "4.1.4 Counting and Summing Constraints", "text": "In this section, we present limitations based on the count of the number of time variables or values & & & < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < \";\"; \";\"; \";\" &; \";\"; \";\" &; \";\"; \";\" < \";\"; < \";\"; \"; <\"; < \";\"; < \";\"; < \"; <\"; \"; < <\"; \";\"; \"; <\"; \"; < < <\"; \"; <\"; \"; <\"; \";\"; < \";\"; < < \";\"; < \"; <\"; \"; <\"; \";\"; < \";\"; \"; <\"; < \";\"; \"; <\"; \"; <\"; < \"; <\"; \";\";"}, {"heading": "4.1.5 Connection Constraints", "text": "In this section, we present restrictions that establish a link between various variables. & & < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < / > < < < < < < < < < < / > < < < < < < < < < < / > < < < < / > < < < < < < < < < < < < / > < < < < < < < < < < < < < < < / < < < < < / < < < < < < < < < < < < < < < < / < < < < < < < < < < < < < < < < < < / < < < < < < < < < < < < < < < < < < < < < < /; < < < < < &lt"}, {"heading": "4.1.6 Packing and Scheduling Constraints", "text": "< < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < / \"< /\" < \"<\" < /. \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"<\" < / \"< /\" < \"< /\" < / \"< /\" < \"< /\" < / \"<\" < / \"<\" < / \"<\" < / \"< /\" < \"< /\" < / \"<\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < / \"< /\" < \"< /\"; / \");\" < / \"<\" < / \";\" < / \");\" < / \"<\"); \"<\" < \"/\"); \"< <\" / \"/\" / \");\" < \"/\"); \"<\" / \");\" < < / \""}, {"heading": "4.1.7 Constraints on Graphs", "text": "In this section we present constraints defined on graphs & & < < < > Circuit (encoding called \"successor variables\"). < < < / > Circuit (circuit) & < < List >, the variables x1, x2,. Note: The assumption is that each pair (i, xi) represents an arc (or edge) of the graph to be created; if xi = j, it means that the successor of the node i is the node j. Note that a loop (also called self-loop) corresponds to a variable xi, which xi = i; it is isolated if there is no variable xj with j 6 = i, so that xj = i.4.1.7.1 Synstraint Circuit Restriction [8] ensures that the values generated by the variables in < List > that each pair (xi) represents a circuit."}, {"heading": "4.1.8 Elementary Constraints", "text": "In this section, we present some elementary limitations that occur frequently. < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < / \";\"; \";\"; \";\" \";\"; \"\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\"; \";\""}, {"heading": "4.2 Constraints over Symbolic Variables", "text": "Many of the above constraints on integer variables can be used with symbolic variables. Basically, this is always the case when no arithmetic calculation is involved. In the current version of this document, we will not exhaustively list all such cases. We will only give an illustration of an extended constraint that includes three symbolic variables of the domain {a, b, c}. Example 78 < extension id = \"c1\" > < list > x1 x2 x3 < / list > < supports > (a, b, a, c) (b, c, b) (c, a, b) (c, b) < / supports > < / extension > 895 Constraints over ComplexDiscrete VariablesIn this chapter, we will introduce constraints on complex discrete variables, namely set and graph variables. We will use the terms setVar and graphVar to define a set and a graph variable each, and a graph variable. These terms are also set, as well as those used in, for example, Vendial."}, {"heading": "5.1 Constraints over Set Variables", "text": "& & lt; < < < < < < < / / > > > > Vocabulary is marked with lowercase letters that may be marked. & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 10; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & & # 160; & & # 160; & & # 160; & & # 160; & & # 160; & & # 160; & # 160; & & # 160; & # 160; & # 160; & & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & & # 160; & # 160; & # 160; & # 160; & & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160 & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160 & # 160; & # 160; & # 160 & & # 160; & # 160; & # 160; & & & # 160; & # 160; & & # 160; & # 160; & & # 160; & & & # 160 & # 160; & & # 160; & & & & # 160; & # 160; & # 160; &"}, {"heading": "5.2 Constraints over Graph Variables", "text": "< < < < / > > < p > < p > < p > < p > < p > < p > path > path > path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path, path,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"}, {"heading": "6.1 Constraints over Real Variables", "text": "< < < < < < < < / > > > > > (linear) constraints are usually performed using intensive arithmetic constraints and the sum of (linear) constraints. < < > > > > In the future, however, we may introduce some global constraints that are adapted to real variables. < < > > > Constraint intensionA constraint intensionA constraint intensionA constraint intensionA constraint on real variables is constructed in a similar way to a constraint intensity defined for integers (and Boolean variables) in Table 4.1.An intensified constraint is defined by an element that shows the specific operators that can be used to build predicates with real operands. Of course, it is possible to combine such operators with those that are defined for integers (and Boolean) in Table 4.1. An intensified constraint is defined by an element defined by &ltate > that contains an &ltate > that contains an element < X that is a diameter that is described as a function."}, {"heading": "6.2 Constraints over Qualitative Variables", "text": "In fact, the fact is that most of them will be able to move to another world in which they are able, in which they are able to integrate."}, {"heading": "7.1 Constraints lifted to Lists, Sets and Multisets", "text": "Many constraints that were previously introduced on integer variables can be extended to lists (tuples), sets and multisets. In XCSP3, this is relatively easy to handle: replace, if appropriate, any integer variable in a list with an element < list >, or replace each of them with an element < set >, or replace each of them with an element < mset >. Of course, the semantics that were originally given for a sequence of variables are expanded to a sequence of variable lists, a sequence of variables, and a sequence of multisets of variables. Semantics must now handle tuples of values, sets of values, and multisets of values, because: The values assigned to the variables of an element < List > represent a tuple of values. For example, if we < List > x2 x3 & ltables & lt. < List > x2 / List <"}, {"heading": "7.1.1.1 On lists (tuples)", "text": "If allDifferent specifies multiple lists of integer variables as a parameter, the constraint > > ensures that the tuple of values taken from variables of the first element is different from the tuple of values taken from variables of the second element < List >. If more than two elements are specified < List >, all tuples must be different. A variant forces tuples to take different values except those associated with specific tuples (often the single tuple contains only 0), which are specified in the optional element < except >.115 Syntax 115 < allDifferent > (< List > (intVar wspace) 2 + < / List >) 2 + [< except > (\"intVal (,\" intVal) +, \"intVal\") + \"(\" intVal \") +\" (\"intVal\") + < / allent \"Different\" (except] > < / List > < / List >), 2 + [< except > (\"intVal\"), \"intVal\") + \") +\" (\"intVal\") + \") + < / allDifferent\" Different \"(except] < List > < / List >, < / List >) 2 + [< Explains this section < as in the Introduction."}, {"heading": "7.1.1.2 On sets", "text": "If allDifferent allows multiple sets of integer variables as parameters, the constraint ensures that the values taken from variables of the first element < set > are different from the values taken from variables of the second element < set >. If more than two elements < set > are given, all sentences must be different. A variant forces the values to be different except for those assigned to specific sentences in the optional element < except for >.116 syntax 116 < allDifferent > (< set > (intVar wspace) + < / set >) 2 + [< except for > (\"intVal (\" intVal) * \"}\") + < / except for > Syntax 116 < allDifferent > (< set >) < / allDifferent > As explained in the introduction of this section, Different-Set refers to different sets &ltX &ltX < &ltX & < < < < < < & & < < < < < < <"}, {"heading": "7.1.1.3 On multisets", "text": "If allDifferent allows multiple multisets of integer variables as parameters, then the constraint ensures that the multisets of the variables of the first element < mset > are different from the multisets of the variables of the second element < mset >. If more than two elements < mset > are given, all multisets must be different. A variant forces multisets to be different except for those that correspond to certain multisets in the optional element < except >.Syntax 117 < allDifferent > (< mset > (intVar wspace) 2 + < / mset >) 2 + [< except > (\"intVal (,\" intVal) + \"} + 0, alli\")}) + < / allDifferent (except >] < / allvltmset > Different > As explained in the introduction of this section, the difference mset refers to different multisets."}, {"heading": "7.1.2.1 On lists (tuples)", "text": "Syntax 118 < allEqual > (< list > (intVar wspace) 2 + < / list >) 2 + < / allEqual > Semantics 79allEqual-list (X), with X = < X1, X2,... >, iff-list (i, j): 1 \u2264 i < j \u2264 | X |, Xi = XjPrerequisite: | X | \u2265 2 and i: 1 \u2264 i < | X |, | Xi | = | Xi + 1 | \u2265 2Restrictions covered by the allEqual-list from the Global Compulsory Catalog: lex equal118"}, {"heading": "7.1.2.2 On sets", "text": "Syntax 119 < allEqual > (< set > (intVar wspace) + < / set >) 2 + < / allEqual > Semantics 80allEqual-set (X), with X = < X1, X2,... >, iff-set (i, j): 1 \u2264 i < j \u2264 | X |, {Xi} = {Xj} Requirement: | X | \u2265 2: 1 \u2264 i \u2264 | X |, | Xi | \u2265 1"}, {"heading": "7.1.2.3 On multisets", "text": "Syntax 120 < allEqual > (< mset > (intVar wspace) 2 + < / mset >) 2 + < / allEqual > Semantics 81allEqual-mset (X), with X = < X1, X2,.. >, iff. (i, j): 1 \u2264 i < j \u2264 | X |, {Xj}} = {Xj} Requirements: | X | \u2265 2. Similar to allDifferent and allEqual, allDistant can be raised to lists, sets and multisets. Of course, we need to clarify the distances used when looking at pairs of lists, sets and multisets."}, {"heading": "7.1.3.1 On lists (tuples)", "text": "Syntax 121 < allDistant > (< list > (intVar wspace) 2 + < / list >) 2 + < condition > \"(\" operator, \"\" operand \")\" < / condition > < / allDistant > Semantics 82allDistant-list (X, (, k)), with X = < X1, X2,... >, iff-list (i, j): 1 \u2264 i < j \u2264 | X |, distH (Xi, Xj) kPrerequisite: | X | \u2265 2; i: 1 \u2264 i < | X |, | Xi + 1 | \u2265 2Constraints recorded by allDistant-list from the Global Constraint Catalog: \u2022 differ from at least k pos \u2022 differ from exactly k pos \u2022 all differ from at least k pos \u2022 all differ from at most k pos \u2022 all differ from at most k pos \u2022 all differ from exactly"}, {"heading": "7.1.3.2 On sets", "text": "Syntax 122 < allDistant > (< set > (intVar wspace) + < / set > > >) 2 + < condition > \"(\" operator, \"operand\") \"< / condition > < / allDistant > Semantics 83allDistant-set (X, (, k)), with X = < X1, X2,. >, iff-set (i, j): 1 \u2264 i < j \u2264 | X |, distinf ({Xi}, {Xj}) kPrerequisite: | X = < X1 \u2264 i \u2264 | X |, Xi | \u2265 1We propose to identify two types of allDistant-set, according to the case in which all sets must be separated (value\" disjoint, \"{Xj}) and the case in which all sets must be separated (value\" disjoint, \"\" disjoint \"> > > > > > > Distlt3;\" Distltxcase \"&ltx2\" < < < \"vallapping;"}, {"heading": "7.1.3.3 On multisets", "text": "Syntax 123 < allDistant > (< mset > (intVar wspace) 2 + < / mset >) 2 + < condition > \"(\" operator, \"\" operand \")\" < / condition > < / allDistant > Semantics 84allDistant-mset (X, (, k)), with X = < X1, X2,.. >, iff. (i, j): 1 \u2264 i < j < j \u2264 | X |, distM ({{Xi}}, {{Xj}} kPrerequisite: | X | \u2265 2 \u0432 i: 1 \u2264 i < | X |, | Xi + 1 | 2Remark 29 In the future, we plan to deal with other distances by introducing an attribute removal while fixing the terminology (values that can be used for the removal)."}, {"heading": "7.1.4.1 On lists (tuples)", "text": "Since this constraint is very popular, it is allowed to use < lex = > < list > instead of > > > q = > < lex, see [32, 54], which ensures that the tuple formed by the values assigned to the variables of the first element is < list > with respect to the operator specified in < operator >. If more than two elements < list > are specified, the entire order of the tuples must be ordered; this then covers lexChain [31].Syntax 124 < lex > (< list > (intVar wspace) 2 + < / list >) 2 + < operator > \"lt\" | \"le\" | lesylt \"| lesylt\" | lesltltltltltltltltlex; / ltltltlex, > lex; & ltltltltltltltltltltltltlt; / lex > lex; & ltxlex (&ltxlex > (&ltxlex >) > (< Xi; wltspace) < < &ltlt; < > < > &ltlt; < > < >; < < < >; > >;"}, {"heading": "7.1.4.2 On sets", "text": "The constraint ensures that the value set taken from variables of the first element < set > is related to the value set of variables of the second element < set > in relation to a relational set operator. If more than two elements < set > are given, the entire order of the sets must be ordered. Syntax 125 < ordered > (< set > (intVar wspace) + < / set >) 2 + < operator > \"subset\" | \"supseq\" | \"supseq\" | \"supset\" < / operator > < / ordered > semantics 86ordered-set (X,), with X = {X1, X2,."}, {"heading": "7.1.4.3 On multisets", "text": "Syntax 126 < ordered > (< mset > (intVar wspace) 2 + < / mset >) 2 + < operator > \"subset\" | \"supseq\" | \"supset\" < / operator > < / ordered > semantics 87ordered-mset (X,), with X = {X1, X2,.} and [[X1,,,,}, iff, i: 1 < [11].123Remark 30 In the future, we project to deal with other orders by introducing an attribute order while specifying the terminology (values that can be used for an order).7.1.5 Liabint This condition Y is not fully definable because the orders are not comparable."}, {"heading": "7.1.5.1 On lists (tuples)", "text": "All items < list > must match tuples that are all incomparable (for ordering the product).Syntax 127 < allIncomparable > (< list > (intVar wspace) 2 + < / list >) 2 + < / allIncomparable > semantics 88Incomparable list (X), with X = < X1, X2,.. >, iff list (i, j): 1 \u2264 i < j \u2264 | X |, (k, l): 1 \u2264 k < l \u2264 | Xi | xi, k > xj, k-xi, l < xj, lPrerequisite: | X | \u2265 2 \u2264 i <"}, {"heading": "7.1.5.2 On sets", "text": "All elements < set > must be incomparable (for recording).Syntax 128 < allIncomparable > (< set > (intVar wspace) + < / set >) 2 + < / allIncomparable > 124Semantics 89allIncomparable-set (X), with X = < X1, X2,.. >, iff-set (i, j): 1 \u2264 i < j \u2264 | X |, {Xi} 6 {Xj} 6 {Xj} 6 {Xi} Prerequisite: | X | 2: 1 \u2264 i \u2264 | X |, | Xi | 1"}, {"heading": "7.1.5.3 On multisets", "text": "All elements < mset > (intVar wspace) 2 + < / mset >) 2 + < / allIncomparable > semantics 90allIncomparable mset (X), with X = < X1, X2,... >, iff. (i, j): 1 \u2264 i < j \u2264 | X |, {Xi} 6 {Xj}} 6 {{Xj}} 6 {{Xj}} 6 {{XJ}} Requirement: | X | 2 \u0438 i < | X |, | Xi + 1 | \u2265 2Note 31 In the future, we plan to deal with other suborders by introducing an attribute order while fixing terminology (values that can be used for order). 7.1.6 Restrictions or values that are understood as \"multiplied\" in a natural way."}, {"heading": "7.1.6.1 On lists", "text": "This constraint, sometimes referred to as nvectors, ensures that the number of different tuples taken by variables of different elements < List > (same size) must respect a numerical state. A variant forces tuples to take different values, except for those associated with specific tuples (often the only tuples containing only 0) found in the optional element < except >.Syntax 130 < nValues > (< List > (intVar wspace) 2 + < / List >) 2 + [< except > (\"intVal (,\" intVal) + \")\") \") + < / except > < / nValues (\" Operator, \"Operand\") \"< / Condition > < < < / Condition > < < / nValues > (< / nValues >): < / nValues (< / nValues > < < >, < X) (X)."}, {"heading": "7.1.6.2 On sets", "text": "Syntax 131 < nValues > (< set > (intVar wspace) + < / set >) 2 + [< except > (\"{\" intVal (\", intVal) *\"} \") + < / except >] < condition >\" (\"Operator,\" Operand \")\" < / condition > < / nValues > Semantics 92nValues-set (X, E, (, k)), with X = < X1, X2,... >, iff | {Xi}: 1 \u2264 i \u2264 | X | |}\\ E | k nValues-set (X, (, (k))) iff nValues (X, \u2205, (, k)) Requirement: | X | \u2265 2 and i \u2264 i \u2264 | X | X, | Xi | \u2265 1126"}, {"heading": "7.1.6.3 On multisets", "text": "Syntax 132 < nValues > (< mset > (intVar wspace) 2 + < / mset >) 2 + [< except > (\"{\" intVal (\", intVal) +\"} \") + < / except > < condition >\" (\"operator,\" operand \")\" < / condition > < / nValues > Semantics 93nValues-mset (X, E, (, k)), with X = < X1, X2,.. >, iff | [[Xi]]: 1 \u2264 i \u2264 | X |}\\ E | k nValues-mset (X, (, (k))) iff nValues (X, \u2205, (, (, (k)))) Requirements:"}, {"heading": "7.2 Constraints lifted to Matrices", "text": "Some limitations previously defined on the list (s) of integer variables can naturally be extended to matrices of variables. < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < &lt"}, {"heading": "7.3 Restricted Constraints", "text": "A few global limitations are defined as specific limited cases of others; the limitation here means a hardening. < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "8.6 Meta-Constraint or", "text": "In fact, it is a purely reactionary project, which is a reactionary project, which is primarily a purely reactionary project, in which it is a reactionary project."}, {"heading": "9.1 Relaxed Constraints and Cost Functions", "text": "A soft constraint in XCSP3 is an XML constraint element with an attribute type set to the value \"soft.\" < a soft constraint in XCSP3 is either a relaxed constraint or a cost function. In XCSP3, however, a relaxed constraint is a constraint that explicitly integrates a cost component, which means that the XML constraint element contains either an element < costs >, which is also necessarily the last child of the constraint. This new element < costs > can contain a numerical condition (similar to an element < condition >), which typically includes a cost variable as an operator: the actual costs of an instantiation are related to the value of the cost variable are related to the given relative operator. < costs > > can also contain a numerical condition (similar to a cost, which may include a cost, < the costs may include a cost, a cost, a cost, a cost, a cost, a cost, a cost) < &; &; the actual cost of an < < the cost of an instantiation is related to the value of the specified relative operator. < costs > a cost > a condition may include a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a cost, a condition. < < < a cost, a cost, a cost, a cost, a cost, a cost, a cost, a condition. < < < a cost, which can be a cost, a cost, a cost, a cost, a condition. < < < a cost, a cost, a cost, a condition."}, {"heading": "9.2 Simple Relaxation", "text": "< < < < < < < < < / / > / / > / / > / / < < < < < < < < < < / / / > / / / / < < < < < < < < / / > / / / / \"/\" /, \"\" /, \"\" /, \"\" \",\" \"\", \"\" \",\" \",\" \",\" \",\" \",\" \",\", \"\", \"\", \"\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \"\", \",\", \",\", \"\", \",\", \"\", \",\", \",\" \",\", \",\" \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\""}, {"heading": "9.3 Complex Relaxation of Generic Constraints", "text": "In this section we will show you how to perform complex relaxation of generic constraint types < < intension > and < extension >. This relaxation form is more general than the simple one described in Section 9.2 (but tailored to these two specific constraint types). < < < intenint > constraint types, we need to modify the way these constraints are classically built: an integer function is created an integer function (as), and elements < tuple > replace elements < supports > and < conflicts >, respectively.1 Constraint soft-intension.ltltltltltltltltltltltltltltltltltltltltlt.If relaxing ltltltls of an intensive constraint, one has to replace in < function > elements < which returns either 0, standing for false, or 1, standing for true) by an integer functional expression (that may return any integer, and should return 0 when the original constraint)."}, {"heading": "9.4 Complex Relaxation of Global Constraints", "text": "The way global constraints are defined (i.e., their internal elements or parameters) remain the same, unlike what we have for < intension > and < extension >, other values could be introduced in the future if this attribute is not presented.It is then possible to mitigate global constraints by referring to some known infringement measures [101, 130]. An infringement measure is simply a cost function that guarantees that costs are 0 and only consistent with the constraints."}, {"heading": "9.5 Summary", "text": "Soft (cost-based) constraints in XCSP3 can be managed either by relaxed constraints or cost functions. On the one hand, it is important to note that relaxed constraints must be understood and treated as hard constraints; they include (typically) cost variables that may (i.e. not necessarily) be used for optimization; on the other hand, cost functions necessarily imply an implicit optimization task, which is to minimize the sum of the constraint costs. Currently, it is not possible in XCSP3 to have both a cost function and an explicit objective function (although enhancements are envisaged in the future); it is important that 157, if a cost function is available, is necessarily the type of instance \"WCSP\"; see Section 11.3.1.Finally, a soft constraint is easily identifiable: its attribute type is given the value \"soft.\" It is also easy to determine whether we have a relaxed or a cost function."}, {"heading": "10.1 Constraint Templates and Groups", "text": "\"I think it's going to take a lot of time to get to the bottom of it,\" he said, \"but I think it's going to take a lot of time to get to the bottom of it.\""}, {"heading": "10.2 Blocks and Classes", "text": "In fact, we are able to assert ourselves, we are able to assert ourselves, we are able to assert ourselves, we are able to assert ourselves, we are able to assert ourselves, we are able to achieve our objectives, and we are able to achieve our objectives."}, {"heading": "10.3 Reification", "text": "< < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "10.4 Views", "text": "< < < < < < < < < < / p > \">\" > \">\" > \">\" > \">\" > \">\" < < < < < < < < / p > \">\" > \">\" > \">\" > \">\" > \">\", \"\" \"\" \"\", \"\" \"\" \"\" \",\" \"\" \"\", \"\" \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\", \"\", \"\", \"\", \"\", \"\", \",\" \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \"\", \",\", \"\", \"\", \",\", \",\" \",\" \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \",\", \""}, {"heading": "11.1 Dealing with Satisfaction (CSP)", "text": "A discrete constraint network (CN) P is a pair (X, C), where X is a finite set of variables and C is a finite set of constraints; a CN is also called a CSP instance. To define a CSP instance, in XCSP3, you must set the attribute type < instance > to \"CSP\"; variables (at least one) within < variables >; \u2022 constraints within < constraints >; the syntax is as follows: Syntax 161 < instance format = \"XCSP3\" type = \"CSP\" > < variables > (< var... / > < array... / >) + < / variables > < < / Constraints > < < > < > < < > Array = < & ltx; & ltx; < < metaConstraint... / > < < > < > Constraint = < < > < > < < > > Array = < < > < > Constraint = < < > < > < > > Array = < < > / > > > / Constraint."}, {"heading": "11.2 Dealing with Optimization (COP)", "text": "< COP instance is defined by a set of variables X, a set of constraints > > > problem, as for a CN, together with a set of objective functions O. Mono-objective optimization is when only one objective function is present in O. Otherwise, this is multi-objective optimization.To define a COP instance, in XCSP3, you have to: \u2022 set the attribute type of < instance > to \"COP\"; enumerate variables (least one) within < variables > enumerate constraints (if any) within < enumerate obstraints (if any) within < enumerate objectives (least one) within < imerate consultants is as follows: Syntax 162 < instance format = \"XCSP3\" > < type \"> < variables\" > group \"> < variables...\""}, {"heading": "11.3 Dealing with Preferences through Soft Constraints", "text": "The classic CSP framework can be extended by introducing ratings associated with constraint tuples [24], making it possible to express preferences. Below, we show how two main specializations of the Valued Constraint Satisfaction Problem (VCSP) are represented in XCSP3."}, {"heading": "11.3.1 WCSP", "text": "< D \"ir for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green for the green. < D\" ir for the green for the green for the green for the green."}, {"heading": "11.3.2 FCSP", "text": "< < < < / cnbsp; / cnbsp; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cnha; / cndU \"s\" nI \"hta nvo,\" cndU \"a,\" csdsa \"lsa,\" nvo \"nvo\" nvo, \"ldsa,\" ldsa, \"ldsa.\""}, {"heading": "11.4 Dealing with Quantified Variables", "text": "In this context, it should be noted that this is a very complex and complex matter."}, {"heading": "11.5 Stochastic Constraint Reasoning", "text": "Two frameworks have been introduced for dealing with uncontrollable variables: SCSP (Stochastic Constraint Satisfaction Problem) and SCOP (Stochastic Constraint Optimization Problem)."}, {"heading": "11.5.1 SCSP", "text": "< < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "11.5.2 SCOP", "text": "To define a SCOP instance in XCSP3, you must: \u2022 set the attribute type < instance > to \"SCOP\"; \u2022 specify variables (at least one) within < variables >; \u2022 specify constraints (at least one) within < constraints >; \u2022 specify stages with one element < stages >; \u2022 specify targets (at least one) within < targets >;"}, {"heading": "11.6 Qualitative Spatial Temporal Reasoning", "text": "Qualitative Spatiotemporal Relationship (QSTR) deals with qualitative calculations. A qualitative calculation is defined by a finite set B of basic relations on a domain D. The elements of D183 represent temporal or spatial units, and the elements of B represent all possible configurations between two units. B is a set that fulfills the following properties [84]: B forms a partition of D \u00b7 D, B contains the identity relationship Id, and B is closed under the reverse operation (\u2212 1). A (complex) relationship is the union of some basic relations, but it is customary to represent a relationship as the set of basic relations contained in it. Therefore, the set of relations 2B represents the set of relations of the qualitative computation.A QSTR instance is a pair composed of a set of variables and a set of constraints. Each variable represents a spatial / temporal unit of the modeled system."}, {"heading": "11.6.1 Interval Calculus", "text": "& & # < < < < > > < < < < < < / > > > > Intervals are intervals of the rational line. & # 8222; The definition of this calculation is the quantity {eq, p, pi, m, o, oi, s, si, d, di, f, fi} of thirteen binary relationships representing all orders of the four endpoints of two intervals. & # 8220; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & # 10; & &"}, {"heading": "11.6.2 Point Calculus", "text": "Point Algebra (PA) is a simple qualitative algebra defined for points in time. To define a QSTR instance based on point algebra in XCSP3, you need to list 185 \u00b7 the < instance attribute type > to \"QSTR,\" \u2022 point variables (at least one) within < variables >; \u2022 point constraints within < constraints >. Syntax is: Syntax 173 < instance format = \"XCSP3\" type = \"QSTR\" > < variables > (< var type = \"point... / > | < array type =\" point \"/ >) + < / variables > < constraints > < point / > > > point = > / constraints > point > =; [< notes... / >] < < & & & & < < < < < > < < > <"}, {"heading": "11.6.3 Region Connection Calculus", "text": "RCC8 consists of 8 basic relationships that are possible between two regions: 186 \u2022 separated (DC) \u2022 externally connected (EC) \u2022 equal (EQ) \u2022 partially overlapping (PO) \u2022 tangential ownership (TPP) \u2022 tangential ownership invers (TPPi) \u2022 non-tangential ownership (NTPP) \u2022 non-tangential ownership invers (NTPPi). So to define a QSTR instance based on the region Connection Calculus 8, inXCSP3, as before, you must: \u2022 set the attribute type < example > to \"QSTR,\" \u2022 regional variables (at least one) within < variables >; \u2022 rcc8 constraints within < constraints >."}, {"heading": "11.6.4 TCSP", "text": "< p = < p = < p = & < p = > < p = > < p = > < p = > < p = > < p = > < p = > \"< p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \"p.\" p. \".\" p. \"p.\" p. \"p.\" p. \"p.\". \"p.\" p. \"p.\" p. \"p.\" p. \".\". \"p.\" p. \".\". \"p.\" p. \"p.\". \".\" p. \"p.\". \".\" p. \".\" p. \".\". \"p.\". \".\" p. \"p.\" p. \"p.\". \"p.\". \"p.\""}, {"heading": "11.7 Continuous Constraint Solving", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "11.7.1 NCSP", "text": "Numerical CSP instances are defined as CSP instances but contain real variables and constraints. To define an NCSP instance, you must enumerate in XCSP3 the attribute type < instance > to \"NCSP\"; variables (at least one) within < variables >; \u2022 constraints within < constraints within < constraints >; the syntax is as follows: Syntax 175 < instance format = \"XCSP3\" type = \"NCSP\" > < variables > (< var type = \"real\"... / > | < array type = \"real\" / >) + < / variables > < < constraints > < Intension > (< sub; < < < < / instance > > > > SPy \"(sum; / >) < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < >; < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "11.7.2 NCOP", "text": "Numeric COP instances are defined as COP instances, but contain real variables and constraints. In XCSP3, you must set the attribute type < instance > to \"NCOP\" \u2022 Variables (at least one) within < Variables >; 189 \u2022 Restrictions within < Restrictions >; \u2022 Targets (at least one) within < Targets > The syntax is as follows: Syntax 176 < / Variables > < Instance format = \"XCSP3 type\" = \"NCOP\" > < Variables > (< var type = \"real... / > | < type =\" real \"/ >) + < / Variables > < Restrictions > (< Intension... / > < sum... / >) < / Restrictions > < < < < < < < < > < > < > < < > / >; < < < > / > / >;"}, {"heading": "11.8 Distributed Constraint Reasoning", "text": "Distributed Constraint Reasoning was investigated for both satisfaction and optimisation."}, {"heading": "11.8.1 DisCSP", "text": "In fact, most of them are able to survive on their own. < < < p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p > p"}, {"heading": "11.8.2 DisWCSP (DCOP)", "text": "A DisWCSP (Distributed WCSP) instance, often referred to in literature as DCOP > > > >, is defined as a classic WCN P = (X, C, k), along with a set of p-agents A = {a1, a2,..., ap}. To define a DisWCSP instance, in XCSP3 you need to set the attribute type of the < instance > to \"DisWCSP,\" \u2022 Variables (at least one) within < Variables > enumerate (Variables >; \u2022 Weighted Restrictions (at least one) within < Restrictions >; \u2022 Consistencies within < Agent >.19312 Comments In XCSP3 it is possible to insert an element < Comments > Comments > to express advice. & ltltltltltltltltltlt; In this chapter, we present this taking into account integral frameworks, which can be adapted directly to CS.eP > > >."}, {"heading": "12.1 Annotations about Variables", "text": "In fact, it is a \"real\" case in which the perpetrator is able to commit his act without being able to interfere in the act."}, {"heading": "12.2 Annotations about Constraints", "text": "It is possible to associate annotations with constraints by introducing an element < constraints > within < annotations >. First, you can specify at which filter level the solver should try to enforce specified constraints by using elements < filtering > with the type attribute set to the desired value. Currently, there are five possible values for type: \u2022 \"boundsZ\" for the propagation of integer boundaries. See Limits (R) in [38]. \u2022 \"boundsD\" for a stronger integer propagation. See Limits (D) in [38]. \u2022 \"boundsR\" for the propagation of real boundaries. See Limits (R) in [38]. \u2022 \"AC\" for (generalized) arc consistency. This value applies to both binary and non-binary boundaries (if usually referred to as GAC). & ltsR \"for (generalized) arc consistency."}, {"heading": "12.3 Annotations about Preprocessing and Search", "text": "This year it has come to the point that it has never come as far as this year."}], "references": [{"title": "Extending chip in order to solve complex scheduling and placement problems", "author": ["A. Aggoun", "N. Beldiceanu"], "venue": "Mathematical and Computer Modelling, 17(7):57\u201373,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1993}, {"title": "An interval-based representation of temporal knowledge", "author": ["J.F. Allen"], "venue": "Proceedings of IJCAI\u201981, pages 221\u2013226,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1981}, {"title": "Principles of Constraint Programming", "author": ["K.R. Apt"], "venue": "Cambridge University Press,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "Revisiting the cardinality operator and introducing the cardinality-path constraint family", "author": ["N. Beldiceanu", "M. Carlsson"], "venue": "Proceedings of ICLP\u201901, pages 59\u201373,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "A new multi-resource cumulatives constraint with negative heights", "author": ["N. Beldiceanu", "M. Carlsson"], "venue": "Proceedings of CP\u201902, pages 63\u201379,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "Global constraint catalog", "author": ["N. Beldiceanu", "M. Carlsson", "J.-X. Rampon"], "venue": "Technical Report T2012:03, TASC-SICS-LINA,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Cost-filtering algorithms for the two sides of the sum of weights of distinct values", "author": ["N. Beldiceanu", "M. Carlsson", "S. Thiel"], "venue": "Technical Report T2002-14, Swedish Institute of Computer Science,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2002}, {"title": "Introducing global constraints in CHIP", "author": ["N. Beldiceanu", "E. Contejean"], "venue": "Mathematical and Computer Modelling, 20(12):97\u2013123,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1994}, {"title": "The tree constraint", "author": ["N. Beldiceanu", "P. Flener", "X. Lorca"], "venue": "Proceedings of CPAIOR\u201905, pages 64\u201378,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "The increasing nvalue constraint", "author": ["N. Beldiceanu", "F. Hermenier", "X. Lorca", "T. Petit"], "venue": "Proceedings of CPAIOR\u201910, pages 25\u201339,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Filtering algorithms for the Same and UsedBy constraints", "author": ["N. Beldiceanu", "I. Katriel", "S. Thiel"], "venue": "Technical Report MPI-I-2004-1-001, Max Planck Institut Informartik,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2004}, {"title": "Cost evaluation of soft global constraints", "author": ["N. Beldiceanu", "T. Petit"], "venue": "Proceedings of CPAIOR\u201904, pages 80\u201395,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "QCSP made practical by virtue of restricted quantification", "author": ["M. Benedetti", "A. Lallouet", "J. Vautard"], "venue": "Proceedings of IJCAI\u201907, pages 6\u201312,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2007}, {"title": "Quantified constraint optimization", "author": ["M. Benedetti", "A. Lallouet", "J. Vautard"], "venue": "Proceedings of CP\u201908, pages 463\u2013477,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "Arc consistency and arc consistency again", "author": ["C. Bessiere"], "venue": "Artificial Intelligence, 65:179\u2013190,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1994}, {"title": "The range and roots constraints: Specifying counting and occurrence problems", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of IJCAI\u201905, pages 60\u201365,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2005}, {"title": "Filtering algorithms for the nvalue constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Constraints, 11(4):271\u2013293,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "The range constraint: Algorithms and implementation", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of CPAIOR\u201906, pages 59\u201373,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "The roots constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of CP\u201906, pages 75\u201390,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2006}, {"title": "SLIDE: A useful special case of the CARDPATH constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of ECAI\u201908, pages 475\u2013479,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2008}, {"title": "The balance constraint family", "author": ["C. Bessiere", "E. Hebrard", "G. Katsirelos", "Z. Kiziltan", "E. Picard-Cantin", "C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201914, pages 174\u2013189,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Arc consistency for general constraint networks: preliminary results", "author": ["C. Bessiere", "J. R\u00e9gin"], "venue": "Proceedings of IJCAI\u201997, pages 398\u2013404,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1997}, {"title": "An optimal coarse-grained arc consistency algorithm", "author": ["C. Bessiere", "J.-C. R\u00e9gin", "R. Yap", "Y. Zhang"], "venue": "Artificial Intelligence, 165(2):165\u2013185,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2005}, {"title": "Semiringbased CSPs and valued CSPs: Frameworks, properties, and comparison", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi", "T. Schiex", "G. Verfaillie", "H. Fargier"], "venue": "Constraints, 4(3):199\u2013240,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1999}, {"title": "Beyond NP: Arc-Consistency for quantified constraints", "author": ["L. Bordeaux", "E. Monfroy"], "venue": "Proceedings of CP\u201902, pages 371\u2013386,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2002}, {"title": "Boosting systematic search by weighting constraints", "author": ["F. Boussemart", "F. Hemery", "C. Lecoutre", "L. Sais"], "venue": "Proceedings of ECAI\u201904, pages 146\u2013150,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2004}, {"title": "New methods to color the vertices of a graph", "author": ["D. Brelaz"], "venue": "Communications of the ACM, 22:251\u2013256,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1979}, {"title": "Views and iterators for generic constraint implementations", "author": ["G. Tack"], "venue": "In Proceedings of CSCLP\u201905,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2005}, {"title": "Bin packing with linear usage costs - an application to energy management in data centres", "author": ["H. Cambazard", "D. Mehta", "B. O\u2019Sullivan", "H. Simonis"], "venue": "In Proceedings of CP\u201913,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2013}, {"title": "The one-machine sequencing problem", "author": ["J. Carlier"], "venue": "European Journal of Operational Research, 11:42\u201347,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1982}, {"title": "Arc-consistency for a chain of lexicographic ordering constraints", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Technical Report T2002-18, Swedish Institute of Computer Science,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}, {"title": "Revisiting the lexicographic ordering constraint", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Technical Report T2002-17, Swedish Institute of Computer Science,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2002}, {"title": "From constraints to finite automata to filtering algorithms", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Proceedings of ESOP\u201904, pages 94\u2013108,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2004}, {"title": "An open-ended finite domain constraint solver", "author": ["M. Carlsson", "M. Ottosson", "B. Carlson"], "venue": "Proceedings of PLILP\u201997, pages 191\u2013306,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1997}, {"title": "Maintaining generalized arc consistency on ad-hoc n-ary Boolean constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Proceedings of ECAI\u201906, pages 78\u201382,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2006}, {"title": "Maintaining generalized arc consistency on ad-hoc r-ary constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Proceedings of CP\u201908, pages 509\u2013523,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2008}, {"title": "An MDD-based generalized arc consistency algorithm for positive and negative table constraints and some global constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Constraints, 15(2):265\u2013304,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2010}, {"title": "Finite domain bounds consistency revisited", "author": ["C. Choi", "W. Harvey", "J. Lee", "P. Stuckey"], "venue": "Proceedings of Australian Conference on Artificial Intelligence, pages 49\u201358,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2006}, {"title": "Soft arc consistency revisited", "author": ["M. Cooper", "S. de Givry", "M. Sanchez", "T. Schiex", "M. Zytnicki", "T. Werner"], "venue": "Artificial Intelligence,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2010}, {"title": "Dulmage-mendelsohn canonical decomposition as a generic pruning technique", "author": ["R. Cymer"], "venue": "Constraints, 17(3):234\u2013272,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2012}, {"title": "The modelling language Zinc", "author": ["M. Garcia de la Banda", "K. Marriott", "R. Rafeh", "M. Wallace"], "venue": "In Proceedings of CP\u201906,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2006}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence, 49(1-3):61\u201395,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1991}, {"title": "A cost-regular based hybrid column generation approach", "author": ["S. Demassey", "G. Pesant", "L.-M. Rousseau"], "venue": "Constraints, 11(4):315\u2013333,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2006}, {"title": "CP(Graph): Introducing a graph computation domain in constraint programming", "author": ["G. Dooms", "Y. Deville", "P. Dupont"], "venue": "Proceedings of CP\u201905, pages 211\u2013225,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2005}, {"title": "Exploitation de structures de graphe en programmation par contraintes", "author": ["J.-G. Fages"], "venue": "PhD thesis, Ecole nationale sup\u00e9rieure des mines de Nantes,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2014}, {"title": "Revisiting the tree constraint", "author": ["J.-G. Fages", "X. Lorca"], "venue": "Proceedings of CP\u201911, pages 271\u2013285,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2011}, {"title": "Cost based filtering for the constrained knapsack problem", "author": ["T. Fahle", "M. Sellmann"], "venue": "Annals OR, 115(1-4):73\u201393,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2002}, {"title": "Probl\u00e8mes de satisfaction de contraintes flexibles - application \u00e0 l\u2019ordonnancement de production", "author": ["H. Fargier"], "venue": "PhD thesis, Universit\u00e9 Paul Sabatier de Toulouse,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1994}, {"title": "Half reification and flattening", "author": ["T. Feydy", "Z. Somogyi", "P. Stuckey"], "venue": "Proceedings of CP\u201911, pages 286\u2013301,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2011}, {"title": "Breaking row and column symmetries in matrix models", "author": ["P. Flener", "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "J. Pearson", "T. Walsh"], "venue": "Proceedings of CP\u201902, pages 462\u2013476,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2002}, {"title": "Introducing ESRA, a relational language for modelling combinatorial problems", "author": ["P. Flener", "J. Pearson", "M. \u00c5gren"], "venue": "LOPSTR\u201903: Revised Selected Papers, pages 214\u2013232,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2004}, {"title": "Cost-based domain filtering", "author": ["F. Focacci", "A. Lodi", "M. Milano"], "venue": "Proceedings of CP\u201999, pages 189\u2013203,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 1999}, {"title": "The design of ESSENCE: A constraint language for specifying combinatorial problems", "author": ["A. Frisch", "M. Grum", "C. Jefferson", "B. Martinez Hernandez", "I. Miguel"], "venue": "Proceedings of IJCAI\u201907, pages 80\u201387,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2007}, {"title": "Global constraints for lexicographic orderings", "author": ["A. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of CP\u201902, pages 93\u2013108,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2002}, {"title": "Look-ahead value ordering for constraint satisfaction problems", "author": ["D. Frost", "R. Dechter"], "venue": "Proceedings of IJCAI\u201995, pages 572\u2013578,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 1995}, {"title": "Dual viewpoint heuristics for binary constraint satisfaction problems", "author": ["P.A. Geelen"], "venue": "Proceedings of ECAI\u201992, pages 31\u201335,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 1992}, {"title": "Data structures for generalised arc consistency for extensional constraints", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel", "P. Nightingale"], "venue": "Proceedings of AAAI\u201907, pages 191\u2013197,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2007}, {"title": "Generalised arc consistency for the alldifferent constraint: An empirical survey", "author": ["I.P. Gent", "I. Miguel", "P. Nightingale"], "venue": "Artificial Intelligence, 172(18):1973\u20132000,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2008}, {"title": "Interval propagation to reason about sets: Definition and implementation of a practical language", "author": ["C. Gervet"], "venue": "Constraints, 1(3):191\u2013244,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 1997}, {"title": "Constraints over structured domains", "author": ["C. Gervet"], "venue": "Handbook of Constraint Programming, chapter 17, pages 603\u2013636. Elsevier,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2006}, {"title": "Length-lex ordering for set CSPs", "author": ["C. Gervet", "P. Van Hentenryck"], "venue": "Proceedings of AAAI\u201906, pages 48\u201353,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2006}, {"title": "Increasing tree search efficiency for constraint satisfaction problems", "author": ["R.M. Haralick", "G.L. Elliott"], "venue": "Artificial Intelligence, 14:263\u2013313,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 1980}, {"title": "Generality versus specificity: An experience with AI and OR techniques", "author": ["P. Van Hentenryck", "J.-P. Carillon"], "venue": "Proceedings of AAAI\u201988, pages 660\u2013664,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1988}, {"title": "Global constraints for round robin tournament scheduling", "author": ["M. Henz", "T. Mller", "S. Thiel"], "venue": "European Journal of Operational Research, 153(1):92\u2013101,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 2004}, {"title": "Integrated Methods for Optimization", "author": ["J.N. Hooker"], "venue": "Springer,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2012}, {"title": "Efficient context-free grammar constraints", "author": ["S. Kadioglu", "M. Sellmann"], "venue": "Proceedings of AAAI\u201908, pages 310\u2013316,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2008}, {"title": "Grammar constraints", "author": ["S. Kadioglu", "M. Sellmann"], "venue": "Constraints, 15(1):117\u2013144,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2010}, {"title": "The seqbin constraint revisited", "author": ["G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "Proceedings of ICP\u201912, pages 332\u2013347,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2012}, {"title": "A compression algorithm for large arity extensional constraints", "author": ["G. Katsirelos", "T. Walsh"], "venue": "Proceedings of CP\u201907, pages 379\u2013393,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2007}, {"title": "Temporal CSPs", "author": ["M. Koubarakis"], "venue": "Handbook of Constraint Programming, chapter 19, pages 663\u2013695. Elsevier,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2006}, {"title": "Node and arc consistency in weighted CSP", "author": ["J. Larrosa"], "venue": "Proceedings of AAAI\u201902, pages 48\u201353,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2002}, {"title": "In the quest of the best form of local consistency for Weighted CSP", "author": ["J. Larrosa", "T. Schiex"], "venue": "Proceedings of IJCAI\u201903, pages 363\u2013376,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 2003}, {"title": "Solving weighted CSP by maintaining arc consistency", "author": ["J. Larrosa", "T. Schiex"], "venue": "Artificial Intelligence, 159(1-2):1\u201326,", "citeRegEx": "73", "shortCiteRegEx": null, "year": 2004}, {"title": "Global constraints for integer and set value precedence", "author": ["Y.C. Law", "J. Lee"], "venue": "Proceedings of CP\u201904, pages 362\u2013376,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 2004}, {"title": "STR2: Optimized simple tabular reduction for table constraints", "author": ["C. Lecoutre"], "venue": "Constraints, 16(4):341\u2013371,", "citeRegEx": "75", "shortCiteRegEx": null, "year": 2011}, {"title": "A study of residual supports in arc consistency", "author": ["C. Lecoutre", "F. Hemery"], "venue": "Proceedings of IJCAI\u201907, pages 125\u2013130,", "citeRegEx": "76", "shortCiteRegEx": null, "year": 2007}, {"title": "A path-optimal GAC algorithm for table constraints", "author": ["C. Lecoutre", "C. Likitvivatanavong", "R. Yap"], "venue": "Proceedings of ECAI\u201912, pages 510\u2013515,", "citeRegEx": "77", "shortCiteRegEx": null, "year": 2012}, {"title": "Reasonning from last conflict(s) in constraint programming", "author": ["C. Lecoutre", "L. Sais", "S. Tabary", "V. Vidal"], "venue": "Artificial Intelligence, 173(18):1592\u20131614,", "citeRegEx": "78", "shortCiteRegEx": null, "year": 2009}, {"title": "Generalized arc consistency for positive table constraints", "author": ["C. Lecoutre", "R. Szymanek"], "venue": "Proceedings of CP\u201906, pages 284\u2013298,", "citeRegEx": "79", "shortCiteRegEx": null, "year": 2006}, {"title": "Enforcing arc consistency using bitwise operations", "author": ["C. Lecoutre", "J. Vion"], "venue": "Constraint Programming Letters, 2:21\u201335,", "citeRegEx": "80", "shortCiteRegEx": null, "year": 2008}, {"title": "Arc-consistency filtering algorithms for logical combinations of constraints", "author": ["O. Lhomme"], "venue": "Proceedings of CPAIOR\u201904, pages 209\u2013224,", "citeRegEx": "81", "shortCiteRegEx": null, "year": 2004}, {"title": "Practical reformulations with table constraints", "author": ["O. Lhomme"], "venue": "Proceedings of ECAI\u201912, pages 911\u2013912,", "citeRegEx": "82", "shortCiteRegEx": null, "year": 2012}, {"title": "A fast arc consistency algorithm for n-ary constraints", "author": ["O. Lhomme", "J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201905, pages 405\u2013410,", "citeRegEx": "83", "shortCiteRegEx": null, "year": 2005}, {"title": "What is a qualitative calculus? a general framework", "author": ["G. Ligozat", "J. Renz"], "venue": "Proceedings of PRICAI\u201904, pages 53\u201364,", "citeRegEx": "84", "shortCiteRegEx": null, "year": 2004}, {"title": "Consistency in networks of relations", "author": ["A.K. Mackworth"], "venue": "Artificial Intelligence, 8(1):99\u2013 118,", "citeRegEx": "85", "shortCiteRegEx": null, "year": 1977}, {"title": "An optimal filtering algorithm for table constraints", "author": ["J.-B. Mairy", "P. van Hentenryck", "Y. Deville"], "venue": "In Proceedings of CP\u201912,", "citeRegEx": "86", "shortCiteRegEx": "86", "year": 2012}, {"title": "Filtering bounded knapsack constraints in expected sublinear time", "author": ["Y. Malitsky", "M. Sellmann", "R. Szymanek"], "venue": "Proceedings of AAAI\u201910, pages 141\u2013146,", "citeRegEx": "87", "shortCiteRegEx": null, "year": 2010}, {"title": "Sequencing and counting with the multicost-regular constraint", "author": ["J. Menana", "S. Demassey"], "venue": "Proceedings of CPAIOR\u201909, pages 178\u2013192,", "citeRegEx": "88", "shortCiteRegEx": null, "year": 2009}, {"title": "Soft constraints", "author": ["P. Meseguer", "F. Rossi", "T. Schiex"], "venue": "Handbook of Constraint Programming, chapter 9, pages 281\u2013328. Elsevier,", "citeRegEx": "89", "shortCiteRegEx": null, "year": 2006}, {"title": "Activity-based search for black-box constraint programming solvers", "author": ["L. Michel", "P. Van Hentenryck"], "venue": "Proceedings of CPAIOR\u201912, pages 228\u2013243,", "citeRegEx": "90", "shortCiteRegEx": null, "year": 2012}, {"title": "Minimizing conflicts: a heuristic repair method for constraint-satisfaction and scheduling problems", "author": ["S. Minton", "M.D. Johnston", "A.B. Philips", "P. Laird"], "venue": "Artificial Intelligence, 58(1-3):161\u2013205,", "citeRegEx": "91", "shortCiteRegEx": null, "year": 1992}, {"title": "Arc and path consistency revisited", "author": ["R. Mohr", "T.C. Henderson"], "venue": "Artificial Intelligence, 28:225\u2013233,", "citeRegEx": "92", "shortCiteRegEx": null, "year": 1986}, {"title": "Short and long supports for constraint propagation", "author": ["P. Nightingale", "I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "Journal of Artificial Intelligence Research, 46:1\u201345,", "citeRegEx": "93", "shortCiteRegEx": null, "year": 2013}, {"title": "Improving GAC-4 for Table and MDD constraints", "author": ["G. Perez", "J.-C. R\u00e9gin"], "venue": "Proceedings of CP\u201914, pages 606\u2013621,", "citeRegEx": "94", "shortCiteRegEx": null, "year": 2014}, {"title": "A filtering algorithm for the stretch constraint", "author": ["G. Pesant"], "venue": "Proceedings of CP\u201901, pages 183\u2013195,", "citeRegEx": "95", "shortCiteRegEx": null, "year": 2001}, {"title": "A regular language membership constraint for finite sequences of variables", "author": ["G. Pesant"], "venue": "Proceedings of CP\u201904, pages 482\u2013495,", "citeRegEx": "96", "shortCiteRegEx": null, "year": 2004}, {"title": "Counting solutions of knapsack constraints", "author": ["G. Pesant", "C.-G. Quimper"], "venue": "Proceedings of CPAIOR\u201908, pages 203\u2013217,", "citeRegEx": "97", "shortCiteRegEx": null, "year": 2008}, {"title": "SPREAD: A balancing constraint based on statistics", "author": ["G. Pesant", "J.-C. R\u00e9gin"], "venue": "Proceedings of CP\u201905, pages 460\u2013474,", "citeRegEx": "98", "shortCiteRegEx": null, "year": 2005}, {"title": "A generalized arc-consistency algorithm for a class of counting constraint", "author": ["T. Petit", "N. Beldiceanu", "X. Lorca"], "venue": "Proceedings of IJCAI\u201911, pages 643\u2013648,", "citeRegEx": "99", "shortCiteRegEx": null, "year": 2011}, {"title": "Meta-constraints on violations for over constrained problems", "author": ["T. Petit", "J.-C. R\u00e9gin", "C. Bessiere"], "venue": "Proceedings of ICTAI\u201900, pages 358\u2013365,", "citeRegEx": "100", "shortCiteRegEx": null, "year": 2000}, {"title": "Specific filtering algorithms for over-constrained problems", "author": ["T. Petit", "J.-C. R\u00e9gin", "C. Bessiere"], "venue": "Proceedings of CP\u201901, pages 451\u2013463,", "citeRegEx": "101", "shortCiteRegEx": null, "year": 2001}, {"title": "A quadratic propagator for the interdistance constraint", "author": ["C.-G. Quimper", "A. Lopez-Ortiz", "G. Pesant"], "venue": "Proceedings of AAAI\u201906, pages 123\u2013128,", "citeRegEx": "102", "shortCiteRegEx": null, "year": 2006}, {"title": "Beyond finite domains: The all different and global cardinality constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201905, pages 812\u2013816,", "citeRegEx": "103", "shortCiteRegEx": null, "year": 2005}, {"title": "Decomposing global grammar constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201907, pages 590\u2013604,", "citeRegEx": "104", "shortCiteRegEx": null, "year": 2007}, {"title": "Decompositions of grammar constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of AAAI\u201908, pages 1567\u20131570,", "citeRegEx": "105", "shortCiteRegEx": null, "year": 2008}, {"title": "A spatial logic based on regions and connection", "author": ["D.A. Randell", "Z.Cui", "A.G. Cohn"], "venue": "In Proceedings of KR\u201992,", "citeRegEx": "106", "shortCiteRegEx": "106", "year": 1992}, {"title": "Impact-based search strategies for constraint programming", "author": ["P. Refalo"], "venue": "Proceedings of CP\u201904, pages 557\u2013571,", "citeRegEx": "107", "shortCiteRegEx": null, "year": 2004}, {"title": "A filtering algorithm for constraints of difference in CSPs", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201994, pages 362\u2013367,", "citeRegEx": "108", "shortCiteRegEx": null, "year": 1994}, {"title": "Generalized arc consistency for global cardinality constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201996, pages 209\u2013215,", "citeRegEx": "109", "shortCiteRegEx": null, "year": 1996}, {"title": "The global minimum distance constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Technical report, ILOG,", "citeRegEx": "110", "shortCiteRegEx": null, "year": 1997}, {"title": "The symmetric alldiff constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of IJCAI\u201999, pages 420\u2013425,", "citeRegEx": "111", "shortCiteRegEx": null, "year": 1999}, {"title": "Cost-based arc consistency for global cardinality constraints", "author": ["J.-C. R\u00e9gin"], "venue": "Constraints, 7(3-4):387\u2013405,", "citeRegEx": "112", "shortCiteRegEx": null, "year": 2002}, {"title": "Global constraints: a survey", "author": ["J.-C. R\u00e9gin"], "venue": "Hybrid Optimization, chapter 2, pages 63\u2013134. Springer,", "citeRegEx": "113", "shortCiteRegEx": null, "year": 2011}, {"title": "The cardinality matrix constraint", "author": ["J.-C. R\u00e9gin", "C.P. Gomes"], "venue": "Proceedings of CP\u201904, pages 572\u2013587,", "citeRegEx": "114", "shortCiteRegEx": null, "year": 2004}, {"title": "An original constraint based approach for solving over constrained problems", "author": ["J.-C. R\u00e9gin", "T. Petit", "C. Bessiere", "J.-F. Puget"], "venue": "Proceedings of CP\u201900, pages 543\u2013548,", "citeRegEx": "115", "shortCiteRegEx": null, "year": 2000}, {"title": "A filtering algorithm for global sequencing constraints", "author": ["J.-C. R\u00e9gin", "J.-F. Puget"], "venue": "Proceedings of CP\u201997, pages 32\u201346,", "citeRegEx": "116", "shortCiteRegEx": null, "year": 1997}, {"title": "Building models through formal specification", "author": ["G. Renker", "H. Ahriz"], "venue": "Proceedings of CPAIOR\u201904, pages 395\u2013401,", "citeRegEx": "117", "shortCiteRegEx": null, "year": 2004}, {"title": "Solving Balancing and Bin-Packing problems with Constraint Programming", "author": ["P. Schaus"], "venue": "PhD thesis, Universit\u00eb catholique de Louvain la Neuve,", "citeRegEx": "118", "shortCiteRegEx": null, "year": 2009}, {"title": "Simplification and extension of the SPREAD constraint", "author": ["P. Schaus", "Y. Deville", "P. Dupont", "J.-C. R\u00e9gin"], "venue": "Proceedings of CPAI\u201906 Workshop held with CP\u201906, pages 72\u201392,", "citeRegEx": "119", "shortCiteRegEx": null, "year": 2006}, {"title": "The Deviation constraint", "author": ["P. Schaus", "Y. Deville", "P. Dupont", "J.-C. R\u00e9gin"], "venue": "Proceedings of CPAIOR\u201907, pages 260\u2013274,", "citeRegEx": "120", "shortCiteRegEx": null, "year": 2007}, {"title": "Approximated consistency for knapsack constraints", "author": ["M. Sellmann"], "venue": "Proceedings of CP\u201903, pages 679\u2013693,", "citeRegEx": "121", "shortCiteRegEx": null, "year": 2003}, {"title": "The theory of grammar constraints", "author": ["M. Sellmann"], "venue": "Proceedings of CP\u201906, pages 530\u2013 544,", "citeRegEx": "122", "shortCiteRegEx": null, "year": 2006}, {"title": "A constraint for bin packing", "author": ["P. Shaw"], "venue": "Proceedings of CP\u201904, pages 648\u2013662,", "citeRegEx": "123", "shortCiteRegEx": null, "year": 2004}, {"title": "The brelaz heuristic and optimal static orderings", "author": ["B.M. Smith"], "venue": "Proceedings of CP\u201999, pages 405\u2013418, Alexandria, VA,", "citeRegEx": "124", "shortCiteRegEx": null, "year": 1999}, {"title": "A dynamic programming approach for consistency and propagation for knapsack constraints", "author": ["M. Trick"], "venue": "Annals OR, 118(1-4):73\u201384,", "citeRegEx": "125", "shortCiteRegEx": null, "year": 2003}, {"title": "A computer-aided constraint programming system", "author": ["E. Tsang", "P. Mills", "R. Williams", "J. Ford", "J. Borrett"], "venue": "Proceedings of PACLP\u201999, pages 81\u201393,", "citeRegEx": "126", "shortCiteRegEx": null, "year": 1999}, {"title": "An algorithm for subgraph isomorphism", "author": ["J.R. Ullmann"], "venue": "Journal of the ACM, 23(1):31\u201342,", "citeRegEx": "127", "shortCiteRegEx": null, "year": 1976}, {"title": "The OPL Optimization Programming Language", "author": ["P. van Hentenryck"], "venue": null, "citeRegEx": "128", "shortCiteRegEx": "128", "year": 1999}, {"title": "The cardinality operator: A new logical connective for constraint logic programming", "author": ["P. van Hentenryck", "Y. Deville"], "venue": "In Proceedings of ICLP\u201991,", "citeRegEx": "129", "shortCiteRegEx": "129", "year": 1991}, {"title": "On global warming: Flow-based soft global constraints", "author": ["W. van Hoeve", "G. Pesant", "L.-M. Rousseau"], "venue": "Journal of Heuristics,", "citeRegEx": "130", "shortCiteRegEx": "130", "year": 2006}, {"title": "The alldifferent constraint: a survey", "author": ["W.J. van Hoeve"], "venue": "In Proceedings of the Sixth Annual Workshop of the ERCIM Working Group on Constraints,", "citeRegEx": "131", "shortCiteRegEx": "131", "year": 2001}, {"title": "Revisiting the sequence constraint", "author": ["W.J. van Hoeve", "G. Pesant", "L.-M. Rousseau", "A. Sabharwal"], "venue": "In Proceedings of CP\u201906,", "citeRegEx": "133", "shortCiteRegEx": "133", "year": 2006}, {"title": "Stochastic constraint programming", "author": ["T. Walsh"], "venue": "Proceedings of ECAI\u201902, pages 111\u2013115,", "citeRegEx": "135", "shortCiteRegEx": null, "year": 2002}, {"title": "Symmetry breaking using value precedence", "author": ["T. Walsh"], "venue": "Proceedings of ECAI\u201906, pages 168\u2013172,", "citeRegEx": "136", "shortCiteRegEx": null, "year": 2006}, {"title": "Optimizing STR algorithms with tuple compression", "author": ["W. Xia", "R. Yap"], "venue": "Proceedings of CP\u201913, pages 724\u2013732,", "citeRegEx": "137", "shortCiteRegEx": null, "year": 2013}, {"title": "Introduction to the constraint language NCL", "author": ["J. Zhou"], "venue": "Journal of Logic Programming, 45(1-3):71\u2013103,", "citeRegEx": "138", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 127, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 4, "endOffset": 9}, {"referenceID": 125, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 16, "endOffset": 21}, {"referenceID": 135, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 27, "endOffset": 32}, {"referenceID": 50, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 39, "endOffset": 43}, {"referenceID": 40, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 50, "endOffset": 54}, {"referenceID": 52, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 67, "endOffset": 71}, {"referenceID": 116, "context": "org) has also been used to build nice (high-level) problem models [117]", "startOffset": 66, "endOffset": 71}, {"referenceID": 3, "context": "Example 13 <var id=\"w\" type=\"real\"> [0,+ infinity[ </var > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [2/3 ,8.", "startOffset": 84, "endOffset": 90}, {"referenceID": 9, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 13, "endOffset": 19}, {"referenceID": 7, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 20, "endOffset": 26}, {"referenceID": 19, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 20, "endOffset": 26}, {"referenceID": 58, "context": "It is usual that a set domain is approximated by a set interval specified by its upper and lower bounds (subset-bound representation), defined by some appropriate ordering on the domain values [59, 60].", "startOffset": 193, "endOffset": 201}, {"referenceID": 59, "context": "It is usual that a set domain is approximated by a set interval specified by its upper and lower bounds (subset-bound representation), defined by some appropriate ordering on the domain values [59, 60].", "startOffset": 193, "endOffset": 201}, {"referenceID": 60, "context": "1There exist alternatives to represent domains, as the length-lex representation [61].", "startOffset": 81, "endOffset": 85}, {"referenceID": 43, "context": "More precisely, graph variables have domains that are approximated by the lattice of graphs included between two bounds: the greatest lower bound and the least upper bound of the lattice [44].", "startOffset": 187, "endOffset": 191}, {"referenceID": 132, "context": "Walsh [135] to capture combinatorial decision problems involving uncertainty.", "startOffset": 6, "endOffset": 11}, {"referenceID": 69, "context": "In qualitative spatial and temporal reasoning (QSTR) [70], one has to reason with entities that corresponds to points, intervals, regions, .", "startOffset": 53, "endOffset": 57}, {"referenceID": 9, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 63, "endOffset": 67}, {"referenceID": 4, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 137, "endOffset": 140}, {"referenceID": 7, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 140, "endOffset": 143}, {"referenceID": 9, "context": "Example 19 <array id=\"x\" size=\"[10]\"> 1.", "startOffset": 31, "endOffset": 35}, {"referenceID": 4, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 7, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 37, "endOffset": 40}, {"referenceID": 4, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 87, "endOffset": 90}, {"referenceID": 11, "context": "6:1/6 </array > <array id=\"z\" size=\"[12]\" type=\"symbolic set\"> <required > a b </required > <possible > c d </possible > </array >", "startOffset": 36, "endOffset": 40}, {"referenceID": 3, "context": "For example, assuming that 0 is the \u201cstarting index\u201d, x[0] is the first variable of the array x, and y[4][7] the last variable of the array y.", "startOffset": 102, "endOffset": 105}, {"referenceID": 6, "context": "For example, assuming that 0 is the \u201cstarting index\u201d, x[0] is the first variable of the array x, and y[4][7] the last variable of the array y.", "startOffset": 105, "endOffset": 108}, {"referenceID": 1, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 233, "endOffset": 236}, {"referenceID": 3, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 236, "endOffset": 239}, {"referenceID": 1, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 251, "endOffset": 254}, {"referenceID": 4, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 254, "endOffset": 257}, {"referenceID": 2, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 34, "endOffset": 37}, {"referenceID": 3, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 40, "endOffset": 43}, {"referenceID": 4, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 49, "endOffset": 52}, {"referenceID": 1, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 34, "endOffset": 37}, {"referenceID": 1, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 46, "endOffset": 49}, {"referenceID": 2, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 64, "endOffset": 67}, {"referenceID": 0, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 67, "endOffset": 70}, {"referenceID": 1, "context": "For example, y[2][] is equivalent to y[2][0.", "startOffset": 14, "endOffset": 17}, {"referenceID": 1, "context": "For example, y[2][] is equivalent to y[2][0.", "startOffset": 38, "endOffset": 41}, {"referenceID": 0, "context": "<matrix > (y[0][0] ,y[0][1] ,.", "startOffset": 24, "endOffset": 27}, {"referenceID": 6, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 12, "endOffset": 15}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 21, "endOffset": 24}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": ",y[1][7]) .", "startOffset": 2, "endOffset": 5}, {"referenceID": 6, "context": ",y[1][7]) .", "startOffset": 5, "endOffset": 8}, {"referenceID": 3, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 2, "endOffset": 5}, {"referenceID": 3, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 11, "endOffset": 14}, {"referenceID": 0, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 14, "endOffset": 17}, {"referenceID": 3, "context": ",y[4][7]) </matrix >", "startOffset": 2, "endOffset": 5}, {"referenceID": 6, "context": ",y[4][7]) </matrix >", "startOffset": 5, "endOffset": 8}, {"referenceID": 1, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 9, "endOffset": 12}, {"referenceID": 1, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 17, "endOffset": 20}, {"referenceID": 0, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 20, "endOffset": 23}, {"referenceID": 2, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 25, "endOffset": 28}, {"referenceID": 2, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 33, "endOffset": 36}, {"referenceID": 0, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 36, "endOffset": 39}, {"referenceID": 3, "context": "of array y have {2, 4, 6} as domain except for y[4] whose domain is {0, 1}.", "startOffset": 48, "endOffset": 51}, {"referenceID": 1, "context": "1][] and z[][2][2.", "startOffset": 12, "endOffset": 15}, {"referenceID": 2, "context": "Example 20 <array id=\"x\" size=\"[3][5]\"> <domain for=\"x[0][]\"> 1.", "startOffset": 31, "endOffset": 34}, {"referenceID": 4, "context": "Example 20 <array id=\"x\" size=\"[3][5]\"> <domain for=\"x[0][]\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 0, "context": "10 </domain > <domain for=\"x[1][]\"> 1.", "startOffset": 28, "endOffset": 31}, {"referenceID": 1, "context": "20 </domain > <domain for=\"x[2][]\"> 1.", "startOffset": 28, "endOffset": 31}, {"referenceID": 9, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 44, "endOffset": 48}, {"referenceID": 3, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 65, "endOffset": 68}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 155, "endOffset": 158}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 158, "endOffset": 161}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 161, "endOffset": 164}, {"referenceID": 1, "context": "1][] z[][2][2.", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "As an illustration, below, the variable z[5] is undefined.", "startOffset": 41, "endOffset": 44}, {"referenceID": 9, "context": "Example 22 <array id=\"z\" size=\"[10]\"> <domain for=\"z[0.", "startOffset": 31, "endOffset": 35}, {"referenceID": 7, "context": "Example 23 <array id=\"t\" size=\"[8][8]\"> 1.", "startOffset": 31, "endOffset": 34}, {"referenceID": 7, "context": "Example 23 <array id=\"t\" size=\"[8][8]\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "The following instance involves an array of 4 variables, but one of them, x[3], is useless.", "startOffset": 75, "endOffset": 78}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <intension > eq(add(x[0],x[1]),x[2]) </intension > </constraints > </instance >", "startOffset": 67, "endOffset": 70}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <intension > eq(add(x[0],x[1]),x[2]) </intension > </constraints > </instance >", "startOffset": 73, "endOffset": 76}, {"referenceID": 0, "context": "To represent the solution x[0] = 1, x[1] = 1, x[2] = 2, one can choose between the three following representations:", "startOffset": 37, "endOffset": 40}, {"referenceID": 1, "context": "To represent the solution x[0] = 1, x[1] = 1, x[2] = 2, one can choose between the three following representations:", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "Example 26 <instantiation type=\"solution\"> <list > x[0] x[1] x[2] </list > <values > 1 1 2 </values > </instantiation >", "startOffset": 57, "endOffset": 60}, {"referenceID": 1, "context": "Example 26 <instantiation type=\"solution\"> <list > x[0] x[1] x[2] </list > <values > 1 1 2 </values > </instantiation >", "startOffset": 62, "endOffset": 65}, {"referenceID": 2, "context": "For the last representation, we could have chosen the value 2 or the value 3 for the last variable x[3].", "startOffset": 100, "endOffset": 103}, {"referenceID": 112, "context": "Note that many global constraints have been introduced in CP; see [132, 113, 6].", "startOffset": 66, "endOffset": 79}, {"referenceID": 5, "context": "Note that many global constraints have been introduced in CP; see [132, 113, 6].", "startOffset": 66, "endOffset": 79}, {"referenceID": 84, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 59, "endOffset": 63}, {"referenceID": 91, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 69, "endOffset": 73}, {"referenceID": 14, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 79, "endOffset": 83}, {"referenceID": 22, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 92, "endOffset": 96}, {"referenceID": 75, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 102, "endOffset": 106}, {"referenceID": 79, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 115, "endOffset": 119}, {"referenceID": 21, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 70, "endOffset": 74}, {"referenceID": 82, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 87, "endOffset": 91}, {"referenceID": 56, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 106, "endOffset": 110}, {"referenceID": 78, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 119, "endOffset": 123}, {"referenceID": 74, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 130, "endOffset": 134}, {"referenceID": 85, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 145, "endOffset": 149}, {"referenceID": 76, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 156, "endOffset": 160}, {"referenceID": 93, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 171, "endOffset": 175}, {"referenceID": 92, "context": "On the one hand, it may be particularly useful to integrate shortened tuples (based on short supports) [93] in tables.", "startOffset": 103, "endOffset": 107}, {"referenceID": 68, "context": "On the other hand, to reduce space complexity, one may also seek to integrate compressed tuples [69, 137] in tables.", "startOffset": 96, "endOffset": 105}, {"referenceID": 134, "context": "On the other hand, to reduce space complexity, one may also seek to integrate compressed tuples [69, 137] in tables.", "startOffset": 96, "endOffset": 105}, {"referenceID": 32, "context": "1 Constraint regular The constraint regular [33, 96] ensures that the sequence of values assigned to the variables it involves forms a word that can be recognized by a deterministic (or non-deterministic) finite automaton.", "startOffset": 44, "endOffset": 52}, {"referenceID": 95, "context": "1 Constraint regular The constraint regular [33, 96] ensures that the sequence of values assigned to the variables it involves forms a word that can be recognized by a deterministic (or non-deterministic) finite automaton.", "startOffset": 44, "endOffset": 52}, {"referenceID": 121, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 103, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 65, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 104, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 66, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 34, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 35, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 36, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 93, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 107, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 130, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 57, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 5, "context": "A variant, called allDifferentExcept in the literature [6, 40], enforces variables to take distinct values, except those that are assigned to some specified values (often, the single value 0).", "startOffset": 55, "endOffset": 62}, {"referenceID": 39, "context": "A variant, called allDifferentExcept in the literature [6, 40], enforces variables to take distinct values, except those that are assigned to some specified values (often, the single value 0).", "startOffset": 55, "endOffset": 62}, {"referenceID": 109, "context": "In [110, 102], this constraint is studied with respect to the operator \u2265, and called interDistance.", "startOffset": 3, "endOffset": 13}, {"referenceID": 101, "context": "In [110, 102], this constraint is studied with respect to the operator \u2265, and called interDistance.", "startOffset": 3, "endOffset": 13}, {"referenceID": 124, "context": "A form of sum, sometimes called subset-sum or knapsack [125, 97] involves the operator \u201cin\u201d, and ensures that the obtained sum belongs (or not) to a specified interval.", "startOffset": 55, "endOffset": 64}, {"referenceID": 96, "context": "A form of sum, sometimes called subset-sum or knapsack [125, 97] involves the operator \u201cin\u201d, and ensures that the obtained sum belongs (or not) to a specified interval.", "startOffset": 55, "endOffset": 64}, {"referenceID": 7, "context": "2 Constraint count The constraint count, introduced in CHIP [8] and Sicstus [34], ensures that the number of variables in <list> which are assigned a value in <values> respects a numerical condition.", "startOffset": 60, "endOffset": 63}, {"referenceID": 33, "context": "2 Constraint count The constraint count, introduced in CHIP [8] and Sicstus [34], ensures that the number of variables in <list> which are assigned a value in <values> respects a numerical condition.", "startOffset": 76, "endOffset": 80}, {"referenceID": 16, "context": "The constraint nValues [17], ensures that the number of distinct values taken by variables in <list> respects a numerical condition.", "startOffset": 23, "endOffset": 27}, {"referenceID": 16, "context": "A variant, called nValuesExcept [17] discards some specified values (often, the single value 0).", "startOffset": 32, "endOffset": 36}, {"referenceID": 108, "context": "The constraint cardinality, also called globalCardinality or gcc, see [109, 65], ensures that the number of occurrences of each value in <values>, taken by variables of <list>, is related to a corresponding element (value, variable or interval) in <occurs>.", "startOffset": 70, "endOffset": 79}, {"referenceID": 64, "context": "The constraint cardinality, also called globalCardinality or gcc, see [109, 65], ensures that the number of occurrences of each value in <values>, taken by variables of <list>, is related to a corresponding element (value, variable or interval) in <occurs>.", "startOffset": 70, "endOffset": 79}, {"referenceID": 111, "context": "The constraint cardinalityWithCosts [112] will be discussed in Section 8.", "startOffset": 36, "endOffset": 41}, {"referenceID": 5, "context": "5 Constraint balance The constraint balance [6, 21] ensures that the difference between the maximum number of occurrences and the minimum number of occurrences among the values assigned to the variables", "startOffset": 44, "endOffset": 51}, {"referenceID": 20, "context": "5 Constraint balance The constraint balance [6, 21] ensures that the difference between the maximum number of occurrences and the minimum number of occurrences among the values assigned to the variables", "startOffset": 44, "endOffset": 51}, {"referenceID": 20, "context": "If the optional element <values> is present, then all variables must be assigned to a value from this set; see balance\u2217 in [21].", "startOffset": 123, "endOffset": 127}, {"referenceID": 97, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 118, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 117, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 119, "context": "The constraint deviation [120, 118] ensures that the deviation of values taken by variables of <list> respects a numerical condition.", "startOffset": 25, "endOffset": 35}, {"referenceID": 117, "context": "The constraint deviation [120, 118] ensures that the deviation of values taken by variables of <list> respects a numerical condition.", "startOffset": 25, "endOffset": 35}, {"referenceID": 6, "context": "Finally, by replacing the element <list> by an element <set>, we can represent the constraint sum of weights of distinct values [7], where any cost is defined per value and can be taken into account only once.", "startOffset": 128, "endOffset": 131}, {"referenceID": 62, "context": "3 Constraint element The constraint element [63] ensures that <value> is element of <list>, i.", "startOffset": 44, "endOffset": 48}, {"referenceID": 73, "context": "6 Constraint precedence The constraint precedence, see [74, 136], ensures that if a variable x of <list> is assigned the i+ 1th value of <values>, then another variable of <list>, that precedes x, is assigned the ith value of <values> The optional attribute covered indicates whether each value of <values> must be assigned by at least one variable in <list> (\"false\", by default).", "startOffset": 55, "endOffset": 64}, {"referenceID": 133, "context": "6 Constraint precedence The constraint precedence, see [74, 136], ensures that if a variable x of <list> is assigned the i+ 1th value of <values>, then another variable of <list>, that precedes x, is assigned the ith value of <values> The optional attribute covered indicates whether each value of <values> must be assigned by at least one variable in <list> (\"false\", by default).", "startOffset": 55, "endOffset": 64}, {"referenceID": 94, "context": "1 Constraint stretch The constraint stretch [95] aims at grouping values in sequences.", "startOffset": 44, "endOffset": 48}, {"referenceID": 64, "context": "2 Constraint noOverlap We start with the one dimensional form of noOverlap [65] that corresponds to disjunctive [30] and ensures that some tasks, defined by their origins and durations (lengths), must not overlap.", "startOffset": 75, "endOffset": 79}, {"referenceID": 29, "context": "2 Constraint noOverlap We start with the one dimensional form of noOverlap [65] that corresponds to disjunctive [30] and ensures that some tasks, defined by their origins and durations (lengths), must not overlap.", "startOffset": 112, "endOffset": 116}, {"referenceID": 7, "context": "The k-dimensional form of noOverlap corresponds to diffn [8] and ensures that, given a set of n-dimensional boxes; for any pair of such boxes, there exists at least one dimension where one box is after the other, i.", "startOffset": 57, "endOffset": 60}, {"referenceID": 0, "context": "The constraint cumulative [1] enforces that at each point in time, the cumulated height of tasks that overlap that point, respects a numerical condition.", "startOffset": 26, "endOffset": 29}, {"referenceID": 4, "context": "A refined form of cumulative corresponds to the constraint sometimes called cumulatives [5].", "startOffset": 88, "endOffset": 91}, {"referenceID": 122, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 117, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 28, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 46, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 120, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 86, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 7, "context": "1 Constraint circuit The constraint circuit [8] ensures that the values taken by the variables in <list> forms a circuit, with the assumption that each pair (i,xi) represents an arc.", "startOffset": 44, "endOffset": 47}, {"referenceID": 8, "context": "5 Constraint tree The constraint tree [9, 46] ensures that the values taken by variables in <list> forms an antiarborescence (covering all nodes) whose root is specified by <root>, with the assumption that each pair (i,xi) represents an arc (with such representation, we do obtain an anti-arborescence).", "startOffset": 38, "endOffset": 45}, {"referenceID": 45, "context": "5 Constraint tree The constraint tree [9, 46] ensures that the values taken by variables in <list> forms an antiarborescence (covering all nodes) whose root is specified by <root>, with the assumption that each pair (i,xi) represents an arc (with such representation, we do obtain an anti-arborescence).", "startOffset": 38, "endOffset": 45}, {"referenceID": 0, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 170, "endOffset": 173}, {"referenceID": 1, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 180, "endOffset": 183}, {"referenceID": 2, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 190, "endOffset": 193}, {"referenceID": 3, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 200, "endOffset": 203}, {"referenceID": 4, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 210, "endOffset": 213}, {"referenceID": 15, "context": "3 Constraint range The constraint range [16, 18] holds iff the set of values taken by variables of <list> at indices given by <index> is exactly the set <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 17, "context": "3 Constraint range The constraint range [16, 18] holds iff the set of values taken by variables of <list> at indices given by <index> is exactly the set <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 15, "context": "In the following example, the constraints c1 and c2, taken together, permit to represent nValues({x0, x1, x2, x3, x4, x5}, y); see [16].", "startOffset": 131, "endOffset": 135}, {"referenceID": 15, "context": "4 Constraint roots The constraint roots [16, 19] holds iff <index> represents exactly the set of indices of variables in <list> which are assigned a value in <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 18, "context": "4 Constraint roots The constraint roots [16, 19] holds iff <index> represents exactly the set of indices of variables in <list> which are assigned a value in <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 15, "context": "In the following example, the constraints c1 and c2, taken together, permit to represent among(2,{x0, x1, x2, x3, x4, x5}, {0, 1}); see [16].", "startOffset": 136, "endOffset": 140}, {"referenceID": 44, "context": "7 Constraint nCliques The constraint nCliques, called nclique in [45], ensures that the value taken by the graph variable in <graph> represents a set of cliques whose cardinality must respect a numerical condition.", "startOffset": 65, "endOffset": 69}, {"referenceID": 1, "context": "Interval Algebra, also called Allen\u2019s calculus [2] handles temporal entities that represent intervals on the rational line.", "startOffset": 47, "endOffset": 50}, {"referenceID": 105, "context": "3 Constraint rcc8 RCC8 [106] is a region connection calculus for reasoning about regions in Euclidean space.", "startOffset": 23, "endOffset": 28}, {"referenceID": 41, "context": "4 Constraint dbd For Temporal Constraint Satisfaction [42], variables represent time points and temporal information is represented by a set of unary and binary constraints, each specifying a set of permitted intervals.", "startOffset": 54, "endOffset": 58}, {"referenceID": 69, "context": "For this framework, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]).", "startOffset": 146, "endOffset": 150}, {"referenceID": 29, "context": "In the following example, the constraint expresses that either x2\u2212 x1 must be in [30, 40] or in [60,+infinity[.", "startOffset": 81, "endOffset": 89}, {"referenceID": 39, "context": "In the following example, the constraint expresses that either x2\u2212 x1 must be in [30, 40] or in [60,+infinity[.", "startOffset": 81, "endOffset": 89}, {"referenceID": 29, "context": "Example 97 <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd >", "startOffset": 56, "endOffset": 64}, {"referenceID": 39, "context": "Example 97 <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd >", "startOffset": 56, "endOffset": 64}, {"referenceID": 102, "context": "The constraint allDifferent, introduced earlier on integer variables, can be naturally extended to lists (tuples), sets and multisets [103].", "startOffset": 134, "endOffset": 139}, {"referenceID": 31, "context": "The constraint lex, see [32, 54], ensures that the tuple formed by the values assigned to the variables of the first element <list> is related to the tuple formed by the values assigned to the variables of the second element <list> with respect to the operator specified in <operator>.", "startOffset": 24, "endOffset": 32}, {"referenceID": 53, "context": "The constraint lex, see [32, 54], ensures that the tuple formed by the values assigned to the variables of the first element <list> is related to the tuple formed by the values assigned to the variables of the second element <list> with respect to the operator specified in <operator>.", "startOffset": 24, "endOffset": 32}, {"referenceID": 30, "context": "If more than two elements <list> are given, the entire sequence of tuples must be ordered; this captures then lexChain [31].", "startOffset": 119, "endOffset": 123}, {"referenceID": 15, "context": "This captures uses [16].", "startOffset": 19, "endOffset": 23}, {"referenceID": 10, "context": "This captures usedBy [11].", "startOffset": 21, "endOffset": 25}, {"referenceID": 112, "context": "1 Constraint allDifferent-matrix The constraint allDifferent-matrix, called alldiffmatrix in [113] and in JaCoP, ensures that the values taken by variables on each row and on each column of a matrix are all different.", "startOffset": 93, "endOffset": 98}, {"referenceID": 49, "context": "2 Constraint ordered-matrix (lex2) The constraint ordered-matrix, that can be called lex-matrix too, corresponds to lex2 in the literature [50].", "startOffset": 139, "endOffset": 143}, {"referenceID": 0, "context": "Xn] and = {<,\u2264,\u2265, >}, iff lex(\u3008M[1], .", "startOffset": 32, "endOffset": 35}, {"referenceID": 0, "context": ",M[n]\u3009, ) lex(\u3008M [1], .", "startOffset": 17, "endOffset": 20}, {"referenceID": 113, "context": "4 Constraint cardinality-matrix The constraint cardinality-matrix, see [114], ensures a constraint cardinality on each row and each column.", "startOffset": 71, "endOffset": 76}, {"referenceID": 110, "context": "symmetric [111] is a classical restriction of allDifferent.", "startOffset": 10, "endOffset": 15}, {"referenceID": 63, "context": "This is called oneFactor in [64].", "startOffset": 28, "endOffset": 32}, {"referenceID": 9, "context": "increasing [10] combines nValues and ordered :increasing.", "startOffset": 11, "endOffset": 15}, {"referenceID": 51, "context": "allDifferent [52], also called minimumWeightAllDifferent in the literature, is the conjunction of sumCosts and allDifferent.", "startOffset": 13, "endOffset": 17}, {"referenceID": 19, "context": "A general mechanism, or meta-constraint, that is useful to post constraints on sequences of variables is slide [20].", "startOffset": 111, "endOffset": 115}, {"referenceID": 19, "context": "The attribute offset of <list> is optional (value 1, by default); it permits, when sliding, to skip more than just one variable of the sequence, capturing slidej in [20].", "startOffset": 165, "endOffset": 169}, {"referenceID": 7, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 51, "endOffset": 59}, {"referenceID": 112, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 51, "endOffset": 59}, {"referenceID": 3, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 86, "endOffset": 89}, {"referenceID": 3, "context": "2 Constraint slidingSum The constraint slidingSum [4], enforces a set of sum constraints over a sequence of variables.", "startOffset": 50, "endOffset": 53}, {"referenceID": 98, "context": "The meta-constraint seqbin [99, 68] ensures that a binary constraint holds down a sequence of variables, and counts how many times another binary constraint is violated.", "startOffset": 27, "endOffset": 35}, {"referenceID": 67, "context": "The meta-constraint seqbin [99, 68] ensures that a binary constraint holds down a sequence of variables, and counts how many times another binary constraint is violated.", "startOffset": 27, "endOffset": 35}, {"referenceID": 67, "context": "Remark 35 Note that in our definition, we do not add 1 to z as proposed in [68], and implicitly defined in [99].", "startOffset": 75, "endOffset": 79}, {"referenceID": 98, "context": "Remark 35 Note that in our definition, we do not add 1 to z as proposed in [68], and implicitly defined in [99].", "startOffset": 107, "endOffset": 111}, {"referenceID": 80, "context": "Sometimes, it may be interesting to combine logically constraints [81, 82].", "startOffset": 66, "endOffset": 74}, {"referenceID": 81, "context": "Sometimes, it may be interesting to combine logically constraints [81, 82].", "startOffset": 66, "endOffset": 74}, {"referenceID": 131, "context": "1 Constraint gen-sequence A general form of sequence, with name gen-sequence, has been proposed in [133].", "startOffset": 99, "endOffset": 104}, {"referenceID": 115, "context": "The global sequencing constraint (gsc) [116] combines sequence with cardinality.", "startOffset": 39, "endOffset": 44}, {"referenceID": 111, "context": "3 Constraint cardinalityWithCosts The constraint cardinalityWithCosts [112] combines cardinality with sumCosts.", "startOffset": 70, "endOffset": 75}, {"referenceID": 42, "context": "4 Constraints costRegular and multicostRegular The constraint costRegular [43] combines regular with sumCosts.", "startOffset": 74, "endOffset": 78}, {"referenceID": 87, "context": "It is possible, by introducing several constraints sumCosts to represent multicostregular [88].", "startOffset": 90, "endOffset": 94}, {"referenceID": 114, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 99, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 11, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 70, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 72, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 88, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 38, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 100, "context": "It is then possible to soften global constraints by referring to some known violation measures [101, 130].", "startOffset": 95, "endOffset": 105}, {"referenceID": 129, "context": "It is then possible to soften global constraints by referring to some known violation measures [101, 130].", "startOffset": 95, "endOffset": 105}, {"referenceID": 11, "context": "For example, the violation measure \"var\" can be refined [12] by indicating the subset of variables that are allowed to change their values, when measuring.", "startOffset": 56, "endOffset": 60}, {"referenceID": 128, "context": "1 Constraint soft-and (Cardinality Operator) The cardinality operator [129], which must not be confused with the cardinality constraint, connects a cost variable with a set (conjunction) of constraints: the value of the cost variable is the number of violated constraints in the set.", "startOffset": 70, "endOffset": 75}, {"referenceID": 3, "context": "2 Constraint soft-slide (cardPath) A general scheme, or meta-constraint, that is useful to post constraints on sequences of variables is cardPath [4].", "startOffset": 146, "endOffset": 149}, {"referenceID": 3, "context": "Finally, we illustrate soft-slide with the constraint softSlidingSum [4].", "startOffset": 69, "endOffset": 72}, {"referenceID": 100, "context": "For the relaxed version [101, 132] of allDifferent, we can use the two general-purpose violation measures \"var\" and \"dec\".", "startOffset": 24, "endOffset": 34}, {"referenceID": 129, "context": "For the soft version of cardinality, we can use \"var\" as well as the measure \"val\" defined in [130].", "startOffset": 94, "endOffset": 99}, {"referenceID": 129, "context": "5 Constraint soft-regular For the relaxed version of regular, we can use \"var\" as well as the measure \"edit\" defined in [130].", "startOffset": 120, "endOffset": 125}, {"referenceID": 129, "context": "6 Constraint soft-permutation (same) For the relaxed version of permutation (same), we can use \"var\" [130], while discarding the optional element <mapping> of the hard version.", "startOffset": 101, "endOffset": 106}, {"referenceID": 0, "context": "The following group of constraints is equivalent to post: \u2022 g[0]: x0 + x1 = x2 \u2022 g[1]: x3 + x4 = x5 \u2022 g[2]: x6 + x7 = x8 1We might extend the possibilities of building groups, in the future.", "startOffset": 82, "endOffset": 85}, {"referenceID": 1, "context": "The following group of constraints is equivalent to post: \u2022 g[0]: x0 + x1 = x2 \u2022 g[1]: x3 + x4 = x5 \u2022 g[2]: x6 + x7 = x8 1We might extend the possibilities of building groups, in the future.", "startOffset": 103, "endOffset": 106}, {"referenceID": 0, "context": "With T = {(1, 2), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)}, the following group of constraints is equivalent to post: \u2022 h[0]: (w, x) \u2208 T \u2022 h[1]: (w, z) \u2208 T \u2022 h[2]: (x, y) \u2208 T", "startOffset": 139, "endOffset": 142}, {"referenceID": 1, "context": "With T = {(1, 2), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)}, the following group of constraints is equivalent to post: \u2022 h[0]: (w, x) \u2208 T \u2022 h[1]: (w, z) \u2208 T \u2022 h[2]: (x, y) \u2208 T", "startOffset": 158, "endOffset": 161}, {"referenceID": 2, "context": "Example 144 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 144 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 112, "endOffset": 115}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 120, "endOffset": 123}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 142, "endOffset": 145}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 150, "endOffset": 153}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 153, "endOffset": 156}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 158, "endOffset": 161}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 161, "endOffset": 164}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 183, "endOffset": 186}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 191, "endOffset": 194}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 194, "endOffset": 197}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 199, "endOffset": 202}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 202, "endOffset": 205}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 232, "endOffset": 235}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 240, "endOffset": 243}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 268, "endOffset": 271}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 273, "endOffset": 276}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 276, "endOffset": 279}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 281, "endOffset": 284}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 284, "endOffset": 287}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 309, "endOffset": 312}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 314, "endOffset": 317}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 317, "endOffset": 320}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 322, "endOffset": 325}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 325, "endOffset": 328}, {"referenceID": 2, "context": "Example 145 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 145 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 50, "endOffset": 53}, {"referenceID": 1, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 74, "endOffset": 77}, {"referenceID": 0, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 124, "endOffset": 127}, {"referenceID": 1, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 148, "endOffset": 151}, {"referenceID": 2, "context": "Example 146 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 146 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 2, "context": "Example 147 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 147 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 86, "endOffset": 89}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 110, "endOffset": 113}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 160, "endOffset": 163}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 184, "endOffset": 187}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 214, "endOffset": 217}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 217, "endOffset": 220}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 222, "endOffset": 225}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 225, "endOffset": 228}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 247, "endOffset": 250}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 255, "endOffset": 258}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 258, "endOffset": 261}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 266, "endOffset": 269}, {"referenceID": 48, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 26, "endOffset": 30}, {"referenceID": 1, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 4, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 2, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 0, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 3, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 48, "context": "Another example taken from [49] is: x > 4 \u2228 allDifferent(x, y, y \u2212 x)", "startOffset": 27, "endOffset": 31}, {"referenceID": 27, "context": "are able to cope directly with such formulations through the concept of views [28].", "startOffset": 78, "endOffset": 82}, {"referenceID": 7, "context": "Example 151 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[8]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 72, "endOffset": 75}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 77, "endOffset": 80}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 87, "endOffset": 90}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 92, "endOffset": 95}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 97, "endOffset": 100}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 102, "endOffset": 105}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 167, "endOffset": 170}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 180, "endOffset": 183}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 193, "endOffset": 196}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 206, "endOffset": 209}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 219, "endOffset": 222}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 232, "endOffset": 235}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 245, "endOffset": 248}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 314, "endOffset": 317}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 327, "endOffset": 330}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 340, "endOffset": 343}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 353, "endOffset": 356}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 366, "endOffset": 369}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 379, "endOffset": 382}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 392, "endOffset": 395}, {"referenceID": 1, "context": "Example 156 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[2][4]\"> 0.", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "Example 156 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[2][4]\"> 0.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 145, "endOffset": 148}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 180, "endOffset": 183}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 183, "endOffset": 186}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 191, "endOffset": 194}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 215, "endOffset": 218}, {"referenceID": 1, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 218, "endOffset": 221}, {"referenceID": 1, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 226, "endOffset": 229}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 250, "endOffset": 253}, {"referenceID": 2, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 253, "endOffset": 256}, {"referenceID": 2, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 261, "endOffset": 264}, {"referenceID": 2, "context": "As an illustration, let us consider the Coins problem: what is the minimum number of coins that allows one to pay exactly any price p smaller than one euro [3].", "startOffset": 156, "endOffset": 159}, {"referenceID": 23, "context": "The classical CSP framework can be extended by introducing valuations to be associated with constraint tuples [24], making it possible to express preferences.", "startOffset": 110, "endOffset": 114}, {"referenceID": 71, "context": "see [72]).", "startOffset": 4, "endOffset": 8}, {"referenceID": 0, "context": "Each fuzzy constraint represents a fuzzy relation on its scope: it associates a value in [0, 1] (either a rational, a decimal or one of the integers 0 and 1), called membership degree, with each constraint tuple \u03c4 , indicating to what extent \u03c4 belongs to the relation and therefore satisfies the constraint.", "startOffset": 89, "endOffset": 95}, {"referenceID": 47, "context": "As an illustration, let us consider the XCSP3 representation of the problem instance described in [48], page 110.", "startOffset": 98, "endOffset": 102}, {"referenceID": 24, "context": "QCSP and its semantics were introduced in [25].", "startOffset": 42, "endOffset": 46}, {"referenceID": 12, "context": "QCSP is an extension of QCSP, introduced in [13] to overcome some difficulties that may occur when modeling real problems with classical QCSP.", "startOffset": 44, "endOffset": 48}, {"referenceID": 13, "context": "2 QCOP() QCOP(), Quantified Constraint Optimization problem, is a framework [14] that allows us to formally express preferences over QCSP() strategies.", "startOffset": 76, "endOffset": 80}, {"referenceID": 13, "context": "However, when no element <minimize> or <maximize> is present for an element <exists>, this implicitly corresponds to the atom any [14].", "startOffset": 130, "endOffset": 134}, {"referenceID": 13, "context": "As an illustration, here is the XCSP3 representation of the toy problem introduced in [14], page 472.", "startOffset": 86, "endOffset": 90}, {"referenceID": 132, "context": "Here is an illustration taken from [135] about modeling a simple m quarter production planning problem.", "startOffset": 35, "endOffset": 40}, {"referenceID": 83, "context": "B is a set that satisfies the following properties [84]: B forms a partition of D\u00d7D, B contains the identity relation Id, and B is closed under the converse operation (\u22121).", "startOffset": 51, "endOffset": 55}, {"referenceID": 1, "context": "1 Interval Calculus A well known temporal qualitative formalism is the Interval Algebra, also called Allen\u2019s calculus [2].", "startOffset": 118, "endOffset": 121}, {"referenceID": 41, "context": "4 TCSP A well-known framework for time reasoning is TCSP (Temporal Constraint Satisfaction Problem) [42].", "startOffset": 100, "endOffset": 104}, {"referenceID": 69, "context": "For this framework, as seen in Chapter 6, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]).", "startOffset": 168, "endOffset": 172}, {"referenceID": 41, "context": "Here is an example taken from [42].", "startOffset": 30, "endOffset": 34}, {"referenceID": 69, "context": "Following [70], we can introduce the following variables: x0 for a special time point denoting the beginning of time (7:00 in our case), x1 for the time at which John left home, x2 for the time at which John arrived at work, x3 for the time at which Fred left home, and x4 for the time at which Fred arrived at work.", "startOffset": 10, "endOffset": 14}, {"referenceID": 9, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 277, "endOffset": 285}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 277, "endOffset": 285}, {"referenceID": 29, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 353, "endOffset": 361}, {"referenceID": 39, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 353, "endOffset": 361}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 445, "endOffset": 453}, {"referenceID": 29, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 445, "endOffset": 453}, {"referenceID": 39, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 454, "endOffset": 462}, {"referenceID": 49, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 454, "endOffset": 462}, {"referenceID": 9, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 530, "endOffset": 538}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 530, "endOffset": 538}, {"referenceID": 59, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 606, "endOffset": 614}, {"referenceID": 69, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 606, "endOffset": 614}, {"referenceID": 3, "context": "Example 171 <instance format=\"XCSP3\" type=\"NCSP\"> <variables > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [-4,4] </var > </variables > <constraints > <intension > eq(sub(y,pow(x,2)) ,0) </intension > <intension > eq(sub(y,add(x,1)) ,0) </intension > </constraints > </instance >", "startOffset": 88, "endOffset": 94}, {"referenceID": 3, "context": "Example 171 <instance format=\"XCSP3\" type=\"NCSP\"> <variables > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [-4,4] </var > </variables > <constraints > <intension > eq(sub(y,pow(x,2)) ,0) </intension > <intension > eq(sub(y,add(x,1)) ,0) </intension > </constraints > </instance >", "startOffset": 128, "endOffset": 134}, {"referenceID": 61, "context": "\u2022 \"dom\" [62].", "startOffset": 8, "endOffset": 12}, {"referenceID": 126, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 8, "endOffset": 13}, {"referenceID": 25, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 33, "endOffset": 37}, {"referenceID": 55, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 49, "endOffset": 58}, {"referenceID": 106, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 49, "endOffset": 58}, {"referenceID": 89, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 72, "endOffset": 76}, {"referenceID": 26, "context": "We can then use complex types, as for example: \u2022 \"dom/deg\", \"dom/ddeg\" and \"dom/wdeg\" \u2022 \"dom+ddeg\" For example, \"dom+ddeg\" is known as the Brelaz heuristic [27, 124].", "startOffset": 156, "endOffset": 165}, {"referenceID": 123, "context": "We can then use complex types, as for example: \u2022 \"dom/deg\", \"dom/ddeg\" and \"dom/wdeg\" \u2022 \"dom+ddeg\" For example, \"dom+ddeg\" is known as the Brelaz heuristic [27, 124].", "startOffset": 156, "endOffset": 165}, {"referenceID": 77, "context": "By means of the attribute lc, it is also possible to indicate that last conflict reasoning [78] should be employed: the value of the attribute indicates the maximal size (k) of the testing set.", "startOffset": 91, "endOffset": 95}, {"referenceID": 90, "context": "Here, conflicts refers to the number of conflicts with neighbors [91, 55].", "startOffset": 65, "endOffset": 73}, {"referenceID": 54, "context": "Here, conflicts refers to the number of conflicts with neighbors [91, 55].", "startOffset": 65, "endOffset": 73}, {"referenceID": 37, "context": "See Bounds(Z) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 37, "context": "See Bounds(D) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 37, "context": "See Bounds(R) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 2, "context": "For example, x[0][3] becomes x_0_3 and g[0] becomes g_0.", "startOffset": 17, "endOffset": 20}, {"referenceID": 0, "context": "<constraints > <intension > eq(x,0) </intension > <extension > <list > t[0] t[1] </list > <supports > (2,4)(3,5) </supports > </extension > <intension > le(y,z) </intension > </constraints >", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "\"constraints\": { \"intension\": \"eq(x,0)\", \"extension\": { \"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\" }, \"intension\": \"le(y,z)\" }", "startOffset": 71, "endOffset": 74}, {"referenceID": 0, "context": "\"constraints\": { \"intension\": [\"eq(x,0)\", \"le(y,z)\"], \"extension\": { \"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\" } }", "startOffset": 84, "endOffset": 87}], "year": 2016, "abstractText": "We propose a major revision of the format XCSP 2.1, called XCSP3, to build integrated representations of combinatorial constrained problems. This new format is able to deal with mono/multi optimization, many types of variables, cost functions, reification, views, annotations, variable quantification, distributed, probabilistic and qualitative reasoning. The new format is made compact, highly readable, and rather easy to parse. Interestingly, it captures the structure of the problem models, through the possibilities of declaring arrays of variables, and identifying syntactic and semantic groups of constraints. The number of constraints is kept under control by introducing a limited set of basic constraint forms, and producing almost automatically some of their variations through lifting, restriction, sliding, logical combination and relaxation mechanisms. As a result, XCSP3 encompasses practically all constraints that can be found in major constraint solvers developed by the CP community. A website, which is developed conjointly with the format, contains many models and series of instances. The user can make sophisticated queries for selecting instances from very precise criteria. The objective of XCSP3 is to ease the effort required to test and compare different algorithms by providing a common test-bed of combinatorial constrained instances.", "creator": "LaTeX with hyperref package"}}}