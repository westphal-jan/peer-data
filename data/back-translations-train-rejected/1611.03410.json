{"id": "1611.03410", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2016", "title": "Binomial Checkpointing for Arbitrary Programs with No User Annotation", "abstract": "Heretofore, automatic checkpointing at procedure-call boundaries, to reduce the space complexity of reverse mode, has been provided by systems like Tapenade. However, binomial checkpointing, or treeverse, has only been provided in Automatic Differentiation (AD) systems in special cases, e.g., through user-provided pragmas on DO loops in Tapenade, or as the nested taping mechanism in adol-c for time integration processes, which requires that user code be refactored. We present a framework for applying binomial checkpointing to arbitrary code with no special annotation or refactoring required. This is accomplished by applying binomial checkpointing directly to a program trace. This trace is produced by a general-purpose checkpointing mechanism that is orthogonal to AD.", "histories": [["v1", "Thu, 10 Nov 2016 17:29:24 GMT  (32kb,D)", "http://arxiv.org/abs/1611.03410v1", "Extended abstract presented at the AD 2016 Conference, Sep 2016, Oxford UK"]], "COMMENTS": "Extended abstract presented at the AD 2016 Conference, Sep 2016, Oxford UK", "reviews": [], "SUBJECTS": "cs.PL cs.LG cs.MS", "authors": ["jeffrey mark siskind", "barak a pearlmutter"], "accepted": false, "id": "1611.03410"}, "pdf": {"name": "1611.03410.pdf", "metadata": {"source": "CRF", "title": "Binomial Checkpointing for Arbitrary Programs with No User Annotation\u2217", "authors": ["Jeffrey Mark Siskind", "Barak A. Pearlmutter"], "emails": [], "sections": [{"heading": "Binomial Checkpointing for Arbitrary Programs with No User Annotation\u2217", "text": "This is not the first time that we have refactored a framework for the application of binomial control mechanisms. We present a framework for the application of binomial control mechanisms that indicate a specific annotation or refactoring, which is produced by applying binomial control mechanisms directly to a program trace. This trace is produced by a universal control mechanism that is orthogonal to AD.Listing 1: Fortran examplesuutine f (x)."}, {"heading": "Acknowledgments", "text": "This work has been partially supported by NSF Scholarship 1522954-IIS and Science Foundation Ireland Scholarship 09 / IN.1 / I2637. Any opinions, findings, conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the sponsors."}], "references": [{"title": "Automatic computation of derivatives with the use of the multilevel differentiating technique \u2014 I: Algorithmic basis", "author": ["Yu. M. Volin", "G.M. Ostrovskii"], "venue": "Computers and Mathematics with Applications,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1985}, {"title": "The data-flow equations of checkpointing in reverse automatic differentiation", "author": ["Benjamin Dauvergne", "Laurent Hasco\u00ebt"], "venue": "Computational Science \u2013 ICCS 2006,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Achieving logarithmic growth of temporal and spatial complexity in reverse automatic differentiation", "author": ["Andreas Griewank"], "venue": "Optimization Methods and Software,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1992}, {"title": "Algorithm 799: Revolve: An implementation of checkpoint for the reverse or adjoint mode of computational differentiation", "author": ["Andreas Griewank", "Andrea Walther"], "venue": "ACM Transactions on Mathematical Software,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2000}, {"title": "The discoveries of continuations", "author": ["John C Reynolds"], "venue": "Lisp and symbolic computation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1993}, {"title": "FADBAD, a flexible C++ package for automatic differentiation", "author": ["C. Bendtsen", "Ole Stauning"], "venue": "Technical Report IMM\u2013 REP\u20131996\u201317, Department of Mathematical Modelling,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1996}, {"title": "Scheme: An interpreter for extended lambda calculus", "author": ["Gerald Jay Sussman", "Guy L. Steele", "Jr."], "venue": "AI Memo 349,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1975}, {"title": "A compilation target for probabilistic programming languages", "author": ["Brooks Paige", "Frank Wood"], "venue": "In Proceedings of The 31st International Conference on Machine Learning,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "Compiling with continuations", "author": ["Andrew W Appel"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "Whole-program compilation in MLton", "author": ["Stephen Weeks"], "venue": "URL http://www.mlton.org/References.attachments/ 060916-mlton.pdf. Workshop on ML", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2006}], "referenceMentions": [{"referenceID": 0, "context": "Heretofore, automatic checkpointing at procedure-call boundaries [1], to reduce the space complexity of reverse mode, has been provided by systems like Tapenade [2].", "startOffset": 65, "endOffset": 68}, {"referenceID": 1, "context": "Heretofore, automatic checkpointing at procedure-call boundaries [1], to reduce the space complexity of reverse mode, has been provided by systems like Tapenade [2].", "startOffset": 161, "endOffset": 164}, {"referenceID": 2, "context": "However, binomial checkpointing, or treeverse [3], has only been provided in AD systems in special cases, e.", "startOffset": 46, "endOffset": 49}, {"referenceID": 3, "context": "Yet the user may still wish to reap the benefits of an optimal binomial checkpointing schedule [4].", "startOffset": 95, "endOffset": 98}, {"referenceID": 4, "context": "and the implementations of \u00d0\u2192 J and \u2190\u00d0 J in the host) take inputs as function-call arguments and yield outputs as functioncall return values [5].", "startOffset": 141, "endOffset": 144}, {"referenceID": 5, "context": "AD is performed by overloading the basis functions in the host, in a fashion similar to fadbad++ [6], x \u22b3 x\u0301 denotes recursively bundling a data structure containing primals with a data structure containing tangents, or alternatively recursively unbundling such when used as a binder, and y \u22b2 \u1ef3 denotes running the reverse sweep on the tape y with the output cotangent \u1ef3, or alternatively extracting the primal y and input cotangent x\u0300 from the tape when used as a binder y \u22b2 x\u0300.", "startOffset": 97, "endOffset": 100}, {"referenceID": 6, "context": "One way of implementing the generalpurpose checkpointing interface is to convert the evaluator from direct style to continuation-passing style (CPS, [7]),", "startOffset": 149, "endOffset": 152}, {"referenceID": 7, "context": "One can use posix fork() much in the same way that it has been used to implement the requisite nondeterminism in probabilistic programming languages like probabilistic c [8].", "startOffset": 170, "endOffset": 173}, {"referenceID": 8, "context": "Existing high-performance compilers, like sml/nj [9], for functional languages like sml, already generate target code in CPS, so by adapting such to the purpose of AD with binomial checkpointing, it seems feasible to achieve high performance.", "startOffset": 49, "endOffset": 52}, {"referenceID": 9, "context": "In fact, the overhead of the requisite instrumentation for step counting, step limits, and checkpointing interruptions need not be onerous because the step counting, step limits, and checkpointing interruptions for basic blocks can be factored, and those for loops can be hoisted, much as is done for the instrumentation needed to support storage allocation and garbage collection in implementations like MLton [10], for languages like sml, that achieve very low overhead for automatic", "startOffset": 411, "endOffset": 415}], "year": 2016, "abstractText": "Heretofore, automatic checkpointing at procedure-call boundaries [1], to reduce the space complexity of reverse mode, has been provided by systems like Tapenade [2]. However, binomial checkpointing, or treeverse [3], has only been provided in AD systems in special cases, e.g., through user-provided pragmas on DO loops in Tapenade, or as the nested taping mechanism in adol-c for time integration processes, which requires that user code be refactored. We present a framework for applying binomial checkpointing to arbitrary code with no special annotation or refactoring required. This is accomplished by applying binomial checkpointing directly to a program trace. This trace is produced by a general-purpose checkpointing mechanism that is orthogonal to AD. Listing 1: Fortran example", "creator": "LaTeX with hyperref package"}}}