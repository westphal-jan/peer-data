{"id": "1611.06951", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Nov-2016", "title": "Enforcing Relational Matching Dependencies with Datalog for Entity Resolution", "abstract": "Entity resolution (ER) is about identifying and merging records in a database that represent the same real-world entity. Matching dependencies (MDs) have been introduced and investigated as declarative rules that specify ER policies. An ER process induced by MDs over a dirty instance leads to multiple clean instances, in general. General \"answer sets programs\" have been proposed to specify the MD-based cleaning task and its results. In this work, we extend MDs to \"relational MDs\", which capture more application semantics, and identify classes of relational MDs for which the general ASP can be automatically rewritten into a stratified Datalog program, with the single clean instance as its standard model.", "histories": [["v1", "Mon, 21 Nov 2016 19:02:19 GMT  (30kb)", "https://arxiv.org/abs/1611.06951v1", "Conference submission"], ["v2", "Sat, 25 Feb 2017 23:23:27 GMT  (30kb)", "http://arxiv.org/abs/1611.06951v2", "New revisions applied. To appear in Proc. FLAIRS'17"]], "COMMENTS": "Conference submission", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["zeinab bahmani", "leopoldo bertossi"], "accepted": false, "id": "1611.06951"}, "pdf": {"name": "1611.06951.pdf", "metadata": {"source": "CRF", "title": "Enforcing Relational Matching Dependencies with Datalog for Entity Resolution", "authors": ["Zeinab Bahmani", "Leopoldo Bertossi"], "emails": ["zbahmani@connect.carleton.ca,", "bertossi@scs.carleton.ca"], "sections": [{"heading": null, "text": "ar Xiv: 161 1,06 951v 2 [cs.D B] 25 Feb 20"}, {"heading": "1 Introduction", "text": "The presence in a database of duplicate and generic solutions to data purification problems [Bertossi and Bravo] this year are the logical peculiarities of the proposed intelligence. Applications running on top of the database or of a query response process may not be able to tell them apart, and the results may actually lead to ambiguity, semantic problems such as unintended inconsistencies and erroneous results. In this situation, the database needs to be cleaned up. The entire range of entity resolution (ER) deals with the identification and merging of data sets in a database that relate to the same real entity [Bleiholder and Naumann 2008; Elmagarmid, Ipeirotis and Verykios 2007], eliminating duplicates from the database while creating new tuplicates through the merge process. ER is one of the most common and difficult problems in data purification."}, {"heading": "2 Background", "text": "We look at the relational schema R with a possibly infinite dataset U, a finite set of databases, which we then consider key terms (e.g. R, and a series of built-in predicates, e.g. A, 2). We can assume that the Ais are different and that different predicates do not have common attributes. We will assume that the attributes can share the same domain. An attribute forR is a finite set of soil atoms (or tuples) of the form R (c1,., cn), with R, ci, DomAi. We will assume that tuples have the same properties as in Example 1. They allow us to compare extensions of the same predicate in different instances, and accept changes in attribute values."}, {"heading": "3 Relational MDs", "text": "T2 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T2 \"T3\" T2 \"T3\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T3 \"T3\" T2 \"T3\" T2 \"T3\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T3 \"T2\" T3 \"T2\" T2 \"T3\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T3\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T3 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\" T2 \"T2\""}, {"heading": "4 Single-Clean-Instance Classes", "text": "The same applies to the case where it is a case which is not a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is not a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which is a case which"}, {"heading": "5 Datalog Programs for SRI Classes", "text": "The general ASPs for classical MDs can be easily modified to deal with relational MDs by including the new relational atoms as additional conditions.5E.g. R [B] \u2248 R [B] \u2192 R [A], R [A] \u2248 R [A] \u2192 R [B]. = R [B] give rise to two SFAI tests (two queries).6For each of the three types introduced in Section 4, an ASP can be generated for them of the general form of Section 2."}, {"heading": "6 Conclusions", "text": "Matching dependencies (MDs) are an important complement to declarative approaches to data cleansing, especially to the common and difficult problem of entity resolution (ER).We have shown that MDs can be expanded to capture additional semantic knowledge, which is particularly important in machine learning applications.Computing with MDs has a relatively high data complexity [Bertossi, Kolahi and Lakshmanan 2012], but some classes of MDs (possibly in combination with an instance) can be identified for which ER can be executed in data in polynomial time."}], "references": [{"title": "V", "author": ["S. Abiteboul", "R. Hull", "Vianu"], "venue": "Foundations of Databases. Addison-Wesley,", "citeRegEx": "Abiteboul. Hull. and Vianu 1995", "shortCiteRegEx": null, "year": 1995}, {"title": "Design and Implementation of the LogicBlox System", "author": ["Aref"], "venue": null, "citeRegEx": "Aref,? \\Q2015\\E", "shortCiteRegEx": "Aref", "year": 2015}, {"title": "Declarative Entity Resolution via Matching Dependencies and Answer Set Programs", "author": ["Bahmani"], "venue": "Proc. KR\u201912,", "citeRegEx": "Bahmani,? \\Q2012\\E", "shortCiteRegEx": "Bahmani", "year": 2012}, {"title": "ERBlox: Combining Matching Dependencies with Machine Learning for Entity Resolution", "author": ["Bahmani", "Bertossi", "Z. Vasiloglou 2015] Bahmani", "L. Bertossi", "N. Vasiloglou"], "venue": "Int. J. of Approximate Reasoning,", "citeRegEx": "Bahmani et al\\.,? \\Q2017\\E", "shortCiteRegEx": "Bahmani et al\\.", "year": 2017}, {"title": "Generic and Declarative Approaches to Data Quality Management", "author": ["Bertossi", "L. Bravo 2013] Bertossi", "L. Bravo"], "venue": "In S. Sadiq (ed.),Handbook of Data Quality - Research and Practice,", "citeRegEx": "Bertossi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bertossi et al\\.", "year": 2013}, {"title": "Data Cleaning and Query Answering with Matching Dependencies and Matching Functions", "author": ["Bertossi", "Kolahi", "L. Lakshmanan 2012] Bertossi", "S. Kolahi", "L. Lakshmanan"], "venue": "Theory of Computing Systems,", "citeRegEx": "Bertossi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bertossi et al\\.", "year": 2013}, {"title": "Collective Entity Resolution in Relational Data", "author": ["Bhattacharya", "I. Getoor 2007] Bhattacharya", "L. Getoor"], "venue": "TKDD,", "citeRegEx": "Bhattacharya et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bhattacharya et al\\.", "year": 2007}, {"title": "Answer Set Programming at a Glance", "author": ["Brewka", "Eiter", "G. Truszczynski 2011] Brewka", "T. Eiter", "M. Truszczynski"], "venue": "Comm. of the ACM,", "citeRegEx": "Brewka et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Brewka et al\\.", "year": 2011}, {"title": "L", "author": ["S. Ceri", "G. Gottlob", "Tanca"], "venue": "Logic Programming and Databases. Springer,", "citeRegEx": "Ceri. Gottlob and Tanca 1989", "shortCiteRegEx": null, "year": 1989}, {"title": "On the Computational Cost of Disjunctive Logic Programming: Propositional Case", "author": ["Eiter", "T. Gottlob 1995] Eiter", "G. Gottlob"], "venue": "Annals of Math. and Artif. Intell.,", "citeRegEx": "Eiter et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 1995}, {"title": "Duplicate Record Detection: A Survey", "author": ["Elmagarmid", "Ipeirotis", "A. Verykios 2007] Elmagarmid", "P. Ipeirotis", "V. Verykios"], "venue": "IEEE Transactions in Knowledge and Data Engineering,", "citeRegEx": "Elmagarmid et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Elmagarmid et al\\.", "year": 2007}, {"title": "Dependencies Revisited for Improving Data Quality", "author": ["W. Fan"], "venue": "Proc. PODS", "citeRegEx": "Fan,? \\Q2008\\E", "shortCiteRegEx": "Fan", "year": 2008}, {"title": "Classical Negation in Logic Programs and Disjunctive Databases", "author": ["Gelfond", "M. Lifschitz 1991] Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1991}, {"title": "and the Design of Intelligent Agents", "author": ["M. Gelfond", "Kahl", "J. Knowledge Representation", "Reasoning"], "venue": "Cambridge U. Press,", "citeRegEx": "Gelfond and Kahl 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["Leone"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "Leone,? \\Q2006\\E", "shortCiteRegEx": "Leone", "year": 2006}, {"title": "Entity Resolution with Iterative Blocking", "author": ["Whang"], "venue": "Proc. Sigmod,", "citeRegEx": "Whang,? \\Q2009\\E", "shortCiteRegEx": "Whang", "year": 2009}], "referenceMentions": [{"referenceID": 11, "context": "In this direction, matching dependencies (MDs) have been proposed [Fan 2008; Fan et al. 2009].", "startOffset": 66, "endOffset": 93}, {"referenceID": 0, "context": "For all these classes, we show that the general ASP mentioned above can be automatically and syntactically transformed into an equivalent stratified Datalog program with the single clean instance as its standard model, which can be computed bottom-up from D in polynomial time in the size of D [Abiteboul, Hull, and Vianu 1995; Ceri, Gottlob and Tanca 1989].", "startOffset": 294, "endOffset": 357}, {"referenceID": 8, "context": "For all these classes, we show that the general ASP mentioned above can be automatically and syntactically transformed into an equivalent stratified Datalog program with the single clean instance as its standard model, which can be computed bottom-up from D in polynomial time in the size of D [Abiteboul, Hull, and Vianu 1995; Ceri, Gottlob and Tanca 1989].", "startOffset": 294, "endOffset": 357}, {"referenceID": 0, "context": "We keep doing this on the resulting instance, in a chase-like procedure [Abiteboul, Hull, and Vianu 1995], until a stable instance is reached (cf.", "startOffset": 72, "endOffset": 105}, {"referenceID": 13, "context": "The program constraints in \u03a0(D0,\u03a3) make it unstratified [Gelfond and Kahl 2014].", "startOffset": 56, "endOffset": 79}], "year": 2017, "abstractText": "Entity resolution (ER) is about identifying and merging records in a database that represent the same real-world entity. Matching dependencies (MDs) have been introduced and investigated as declarative rules that specify ER policies. An ER process induced by MDs over a dirty instance leads to multiple clean instances, in general. General answer sets programs have been proposed to specify the MD-based cleaning task and its results. In this work, we extend MDs to relational MDs, which capture more application semantics, and identify classes of relational MDs for which the general ASP can be automatically rewritten into a stratified Datalog program, with the single clean instance as its standard model.", "creator": "LaTeX with hyperref package"}}}