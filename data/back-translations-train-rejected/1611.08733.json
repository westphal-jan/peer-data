{"id": "1611.08733", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Nov-2016", "title": "BliStrTune: Hierarchical Invention of Theorem Proving Strategies", "abstract": "Inventing targeted proof search strategies for specific problem sets is a difficult task. State-of-the-art automated theorem provers (ATPs) such as E allow a large number of user-specified proof search strategies described in a rich domain specific language. Several machine learning methods that invent strategies automatically for ATPs were proposed previously. One of them is the Blind Strategymaker (BliStr), a system for automated invention of ATP strategies.", "histories": [["v1", "Sat, 26 Nov 2016 18:48:43 GMT  (68kb,D)", "http://arxiv.org/abs/1611.08733v1", "Submitted to Certified Programs and Proofs (CPP 2017)"]], "COMMENTS": "Submitted to Certified Programs and Proofs (CPP 2017)", "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.LG", "authors": ["jan jakubuv", "josef urban"], "accepted": false, "id": "1611.08733"}, "pdf": {"name": "1611.08733.pdf", "metadata": {"source": "CRF", "title": "BliStrTune: Hierarchical Invention of Theorem Proving Strategies", "authors": ["Jan Jakub\u016fv", "Josef Urban"], "emails": ["jakubuv@gmail.com", "josef.urban@gmail.com", "Mizar@Turing"], "sections": [{"heading": null, "text": "In this article, we introduce BliStrTune - a hierarchical extension of BliStrTune. BliStrTune enables the exploration of much larger areas of e-strategies by linking the search for high-level parameters with fine-tuning them. We use BliStrTune to invent new strategies that are also based on new clauses-weighting functions that target problems from large ITP libraries. We show that the new strategies significantly improve the performance of E in solving problems from the Mizar Mathematical Library.Keywords Automated Theorem Proving, Machine Learning, Proof Search Heuristics, Clause Weight Functions."}, {"heading": "1. Introduction: ATP Strategy Invention", "text": "In recent years, it has become clear that the different strategies we apply are not only strategies, but also strategies developed by the libraries of today's interactive theory developers (ITP) (Blanchette et al., Gauthier and Kaliszyk 2015). Automated strategy generation has become an attractive topic. It seems unlikely that the manual (\"theory-driven\") construction of strategies can lead to a large number of strategies."}, {"heading": "2. Proof Search Strategies", "text": "In this section, we briefly describe the search for evidence by automated saturation-based theory testers (ATPs). Section 2.1 describes the control capabilities of E-testers (Schulz 2002, 2013). Section 2.2 describes our previous development of similarity-based sentence selection strategies (Jakubu-v and Urban 2016), which we apply and evaluate here. Many state-of-the-art ATPs are based on the predetermined sentence algorithm introduced by Otter (McCune 1989, 1990, 1994). The input problem T-C is translated into a refutationally equivalent set of clauses. Then, the search for a contradiction, represented by the empty sentence, is performed while retaining two sentences: the sentence P of the processed clauses and the sentence U of the unprocessed clauses. First, all input clauses are unprocessed; the algorithm repeatedly selects a certain sentence g from U and generates all possible conclusions and the processed clauses from this P or the newly processed clauses."}, {"heading": "2.1 Proof Search Strategies in E Prover", "text": "The selection of a particular clause in E is implemented by a combination of priority and weight functions. A priority function assigns an integer number to a clause and is used to use pre-order clauses for weighting. each CEF selects the clause with the smallest pair (priority, weight) and assigns a real number to each clause, which is called weight. A clause valuation function (CEF) is specified by a priority function, weight function and its arguments. Each CEF selects the clause with the smallest pair (priority, weight) for conclusions. Each CEF is specified with the syntaxWeightFunction (priority function,...) with a variable number of comma separated arguments of the weight function. E allows a user to choose expert heuristics on the command line in the format (n1 * CEF1, nk * CEFk *)."}, {"heading": "2.2 Similarity Based Clause Selection Strategies", "text": "The following sections cover the new weight functions, which we will evaluate later in Section 5.1 and Section 5.2.1."}, {"heading": "3. Blind Strategymaker (BliStr)", "text": "In this section, we describe Blind Strategymaker (BliStr) (Urban 2015), which we will expand on in the following section. BliStr is a system that develops e-prover protocols that target a specific large number of issues. The basic idea is to interleave the global problems (i) iterated low-timelimit local search for small sets of similar easy problems with (ii) highertimelimit evaluation of the new protocols on all issues. The cumulative results of the global high-time runs are used to define and develop the notion of similar simple problems, and to control the selection of the next protocol to be improvised. The main criterion for BliStr is as follows. CRITERION 1 (Max) invents a set of e-protocols that together solve as many of the given benchmarks."}, {"heading": "3.1 ParamILS and Its Use in the BliStr Loop", "text": "Let A be an algorithm whose parameters come from a configuration space (product of possible values). A parameter configuration is an element \u03b8, and A (\u03b8) denotes the algorithm A with the parameter configuration \u03b8. Given a distribution (set) of problem cases D, the configuration problem of the algorithm is to find the parameter configuration that results in the best performance of A (\u03b8) on the distribution D. ParamILS is an implementation of an iterated local search algorithm (ILS) for the configuration problem of the algorithm. In short, starting with an initial configuration \u03b80, paramILS loop between two steps: (i), which disrupt the configuration in order to escape a local optimum, and (ii) iterative improvement of the malfunctioning configuration of the algorithm problem. The result of the step (ii) is accepted if it improves the previous best configuration."}, {"heading": "4. BliStrTune: Hierarchical Invention", "text": "BliStr uses a fixed set of CEFs to invent new protocols, and the arguments of these fixed CEFs (the priority function, weight function arguments) cannot be changed during iterative protocol improvement by ParamILS. One simple way to achieve an invention (fine-tuning) of the CEF arguments would be to extend the ParamILS configuration space, but this leads to an increase in the configuration space from approximately 107 to 10120 possible combinations. Initial experiments have shown that a configuration space of this size does not produce satisfactory results in a reasonable time.In this section we describe our new extension of BliStr - BliStrTune - where the invention of good high-level protocol parameters (Section 4.1) is linked to the invention of good CEF arguments (Section 4.2)."}, {"heading": "4.1 Global Parameter Invention", "text": "The ParamILS runs used in the global matching phase of BliStrTune are essentially the same as in the case of BliStr, with the following minor exceptions. BliStr uses a fixed configuration space for all ParamILS runs. This is possible because a small set (currently 12) of CEFs is hard coded for each ParamILS run. This collection can be arbitrary, but we only use the 50 best arguments for the global matching phase to limit the size of the configuration space for the global matching phase. The notion of \"best performing CEFs\" evolves over time and is discussed in detail in Section 4.3. Additionally, BliStrTune introduces additional arguments for the global matching phase to limit the maximum number of CEFs."}, {"heading": "4.2 Invention of the CEF Arguments", "text": "Considering the result of the global weight functions, we extract the reasonable values from the automatic schedule for our preliminary weight functions. Considering the result of the global weight functions that we use. Considering our preliminary weight functions that we use. Considering that the result of the global weight functions that we use is constructed by (1) specifying the parameter values of (1) and by (2) introducing new parameters that make it possible to change the values of the arguments of the CEFs used in (1). Considering the different number and semantics of arguments of the weight functions that we do not allow to change the space of possible values of the CEF arguments. Considering the values provided in Section 2.1, we know its nature (such as the symbol weight, operating costs, the weight multiplier, etc.) for each type we have specified the weight functions that we have predetermined from the original weight functions that we have predetermined in the weight functions."}, {"heading": "4.3 Maintaining Collections of CEFs", "text": "The global tuning phase of BliStrTune requires the capture C of the CEFs as input. It is desirable that this capture C is limited in size (currently we use max. 50 CEFs) and that it contains the most powerful CEFs. First, for each weight function defined in E, we extracted the CEF that is most commonly used in the E-Auto Schedule mode. We added a CEF for each of our new weight functions, which gave us the initial capture of 21 CEFs. Then, we use a global database (shared by different BliStrTune runs) in which we store all CEFs together with the use counter that indicates how often each CEF was used in a protocol invented by BliStrTune. Remember that in a BliStrTune iteration paramILS is executed four times (two phases of global tuning and two phases of fine tuning the database)."}, {"heading": "5. Experimental Evaluation", "text": "In Section 5.1, we compare our improved BliStrTune with the original BliStr, and we use BliStrTune to evaluate the added value of the new weight functions. In Section 5.2, we evaluate the BliStrTune runs with different parameters. In Section 5.3, we discuss and compare several methods to construct a protocol scheduler that attempts to solve multiple protocols. Section 5.4 then compares the best protocol scheduler with the most modern ATPs, namely E 1.9 in auto-schema mode and with Vampires 4.0.For evaluation, we use problems from the Mizar @ Turing Division of the CASC 2012 (Turing100) competition, which is mentioned in Section 1. These problems stem from the MPTP1 test. All experiments were assigned to 2x16 cores Intel (R) Xeon (R) CPU E52698 v3 @ 2.30GHz memory capacity problems."}, {"heading": "5.1 Hierarchical Invention and Weight Functions", "text": "To evaluate the hierarchical invention, we gave BliStr and BliStrTune with equivalent arguments. In addition, we used two instances of BliStrTune to evaluate the performance added by the new weight functions in Section 2.2. The first instance was allowed to use only the original E 1.9 weight functions, while the second additionally used our new weight functions. BliStr and BliStrTune used the same input arguments. The first argument is the amount of training problems. We used the 1000 training problems from the Mizar @ Turing competition in all experiments. Other arguments are: Timprove the time limit (seconds) for one ParamILS run, tcut the time limit for E prover runs within ParamILS, teval the time limit for the protocol evaluation in BliStr / Tune.In BliStrTune, ParamILS is run four times in each iteration, hence we set Timprove = 100 in BliTune and Timprove = 400 Str in BliStr."}, {"heading": "5.2 Influence of the BliStrTune Input Arguments", "text": "In this section, we evaluate several BliStrTune runs with different input arguments. We perform all combinations of Timprove (100, 300) and ccef (6, 10) and tcutoff (1, 2), which gives us 6 different BliStrTune runs. We always set teval = 5 \u00b7 tcutoff.The results are summarized in Table 1. Column iter contains the number of iterations performed by the corresponding BliStrTune run, proto is the total number of logs generated, runtime is the total runtime of the given BliStrTune run, best protocol is the number of training problems solved by the best protocol within the time limit, and solved is the total number of training problems solved by all generated logs, provided each protocol is teval in time. We can see that an enormous number of training programs have been created, but only a few of them have been used for the final evaluation, as described in Section 5.3, those that are considered to be the shortest runs, and considered to be the shortest ones."}, {"heading": "5.3 Selecting Best Protocol Scheduler", "text": "In this section, we try to select the best subset of protocols and construct a protocol scheduler that attempts to solve a problem sequentially across multiple protocols. We experiment only with the simplest recorders, where the time limit for solving a problem is evenly distributed among all protocols within a recorder. Therefore, the problem of recorder construction is reduced to selecting the right protocols. We use three different ways to select recorder protocols. First, we use a greedy approach, as follows: We evaluate all protocols for all protocols within a set time limit. Then, we construct a greedy coverage sequence that begins with the best protocol, and each next protocol in the sequence is the protocol that adds the most solutions to the Union of Problems."}, {"heading": "5.4 Best Protocol Scheduler Evaluation", "text": "In this section we evaluate the best scheduler greedy1, selected in the previous section 5.3 about the test problems with a time limit of 60 seconds. We compare greedy1 with two state-of-the-art ATPs: (1) with the E-Checker 1.9 in Automatic Schedule mode and (2) with Vampire 4.0 in CASC mode. Results are summarized in Table 3. We see that E outperforms greedy1 Vampires by 5.2% with the planner invented by BliStrTune, and the improvement over E in Automatic Schedule mode is even more significant. Figure 2 provides a graphical representation of the progress of the ATPs. For each second (x-axis, logarithmic scale) we count the number of problems solved so far (y-axis). We can see that greedy1 outperforms vampires throughout the evaluation."}, {"heading": "6. Conclusions and Future Work", "text": "In this paper we described BliStrTune, an extension of a previously published BliStr system that can be used for the hierarchical invention of protocols that target a specific benchmark problem. BliStrTune's main contribution is that it takes into account a much larger space of protocols by linking the global synchronization phase with the fine-tuning of arguments. We evaluated the original BliStr and our BliStrTune based on the same input data and experimentally demonstrated that BliStrTune exceeds BliStr. We evaluated several ways of creating protocol schedulers and showed that E 1.9 using the best protocol scheduler constructed from BliStrTune protocols for training problems is better than the state of the art. ATP Vampire 4.0 for independent test problems exceeds BliStr by more than 5%. In addition, we used BliStrTune to evaluate a contribution of our previously designed weight functions in e-provers. We have shown that the new weight schedules, at least two of which allow us to solve more frequently, were the new functions and more complex."}, {"heading": "Acknowledgments", "text": "Supported by ERC Consolidator grant number 649043 AI4REASON."}], "references": [{"title": "Premise selection for mathematics by corpus analysis and kernel methods", "author": ["J. Alama", "T. Heskes", "D. K\u00fchlwein", "E. Tsivtsivadze", "J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Alama et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Alama et al\\.", "year": 2014}, {"title": "Hammering towards QED", "author": ["J. Blanchette", "C. Kaliszyk", "L. Paulson", "J. Urban"], "venue": "Journal of Formalized Reasoning,", "citeRegEx": "Blanchette et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Blanchette et al\\.", "year": 2016}, {"title": "A learning-based fact selector for Isabelle/HOL", "author": ["J.C. Blanchette", "D. Greenaway", "C. Kaliszyk", "D. K\u00fchlwein", "J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Blanchette et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Blanchette et al\\.", "year": 2016}, {"title": "Premise selection and external provers for HOL4", "author": ["T. Gauthier", "C. Kaliszyk"], "venue": "LNCS. Springer,", "citeRegEx": "Gauthier and Kaliszyk.,? \\Q2015\\E", "shortCiteRegEx": "Gauthier and Kaliszyk.", "year": 2015}, {"title": "Mizar in a nutshell", "author": ["A. Grabowski", "A. Korni\u0142owicz", "A. Naumowicz"], "venue": "J. Formalized Reasoning,", "citeRegEx": "Grabowski et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Grabowski et al\\.", "year": 2010}, {"title": "ParamILS: an automatic algorithm configuration framework", "author": ["F. Hutter", "H.H. Hoos", "K. Leyton-Brown", "T. St\u00fctzle"], "venue": "J. Artificial Intelligence Research,", "citeRegEx": "Hutter et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hutter et al\\.", "year": 2009}, {"title": "Extending E prover with similarity based clause selection strategies", "author": ["J. Jakub\u016fv", "J. Urban"], "venue": "In Intelligent Computer Mathematics - 9th International Conference,", "citeRegEx": "Jakub\u016fv and Urban.,? \\Q2016\\E", "shortCiteRegEx": "Jakub\u016fv and Urban.", "year": 2016}, {"title": "Learning-assisted automated reasoning with Flyspeck", "author": ["C. Kaliszyk", "J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Kaliszyk and Urban.,? \\Q2014\\E", "shortCiteRegEx": "Kaliszyk and Urban.", "year": 2014}, {"title": "MizAR 40 for Mizar 40", "author": ["C. Kaliszyk", "J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Kaliszyk and Urban.,? \\Q2015\\E", "shortCiteRegEx": "Kaliszyk and Urban.", "year": 2015}, {"title": "Efficient semantic features for automated reasoning over large theories", "author": ["C. Kaliszyk", "J. Urban", "J. Vyskocil"], "venue": null, "citeRegEx": "Kaliszyk et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kaliszyk et al\\.", "year": 2015}, {"title": "Machine learner for automated reasoning", "author": ["C. Kaliszyk", "J. Urban", "J. Vyskocil"], "venue": "PAAR-2014. 4th Workshop on Practical Aspects of Automated Reasoning,", "citeRegEx": "Kaliszyk et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kaliszyk et al\\.", "year": 2015}, {"title": "First-order theorem proving and Vampire", "author": ["L. Kov\u00e1cs", "A. Voronkov"], "venue": "CAV, volume 8044 of LNCS,", "citeRegEx": "Kov\u00e1cs and Voronkov.,? \\Q2013\\E", "shortCiteRegEx": "Kov\u00e1cs and Voronkov.", "year": 2013}, {"title": "MaLeS: A framework for automatic tuning of automated theorem provers", "author": ["D. K\u00fchlwein", "J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "K\u00fchlwein and Urban.,? \\Q2015\\E", "shortCiteRegEx": "K\u00fchlwein and Urban.", "year": 2015}, {"title": "Mining of Massive Datasets, 2nd Ed", "author": ["J. Leskovec", "A. Rajaraman", "J.D. Ullman"], "venue": null, "citeRegEx": "Leskovec et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Leskovec et al\\.", "year": 2014}, {"title": "Binary Codes Capable of Correcting Deletions, Insertions and Reversals", "author": ["V. Levenshtein"], "venue": "Soviet Physics Doklady,", "citeRegEx": "Levenshtein.,? \\Q1966\\E", "shortCiteRegEx": "Levenshtein.", "year": 1966}, {"title": "Otter 3.0 reference manual and guide, volume 9700", "author": ["W.W. McCune"], "venue": "Argonne National Laboratory Argonne,", "citeRegEx": "McCune.,? \\Q1994\\E", "shortCiteRegEx": "McCune.", "year": 1994}, {"title": "Breeding theorem proving heuristics with genetic algorithms", "author": ["S. Sch\u00e4fer", "S. Schulz"], "venue": "Global Conference on Artificial Intelligence,", "citeRegEx": "Sch\u00e4fer and Schulz.,? \\Q2015\\E", "shortCiteRegEx": "Sch\u00e4fer and Schulz.", "year": 2015}, {"title": "E \u2013 a brainiac theorem prover", "author": ["S. Schulz"], "venue": "AI Communications,", "citeRegEx": "Schulz.,? \\Q2002\\E", "shortCiteRegEx": "Schulz.", "year": 2002}, {"title": "The 6th IJCAR automated theorem proving system competition - CASC-J6", "author": ["G. Sutcliffe"], "venue": "AI Commun.,", "citeRegEx": "Sutcliffe.,? \\Q2013\\E", "shortCiteRegEx": "Sutcliffe.", "year": 2013}, {"title": "MPTP - Motivation, Implementation, First Experiments", "author": ["J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Urban.,? \\Q2004\\E", "shortCiteRegEx": "Urban.", "year": 2004}, {"title": "MPTP 0.2: Design, implementation, and initial experiments", "author": ["J. Urban"], "venue": "J. Autom. Reasoning,", "citeRegEx": "Urban.,? \\Q2006\\E", "shortCiteRegEx": "Urban.", "year": 2006}, {"title": "BliStr: The Blind Strategymaker", "author": ["J. Urban"], "venue": "GCAI", "citeRegEx": "Urban.,? \\Q2015\\E", "shortCiteRegEx": "Urban.", "year": 2015}, {"title": "MaLARea SG1 - Machine Learner for Automated Reasoning with Semantic Guidance", "author": ["J. Urban", "G. Sutcliffe", "P. Pudl\u00e1k", "J. Vysko\u010dil"], "venue": "IJCAR, volume 5195 of LNCS,", "citeRegEx": "Urban et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Urban et al\\.", "year": 2008}, {"title": "Simple fast algorithms for the editing distance between trees and related problems", "author": ["K. Zhang", "D. Shasha"], "venue": "SIAM J. Comput.,", "citeRegEx": "Zhang and Shasha.,? \\Q1989\\E", "shortCiteRegEx": "Zhang and Shasha.", "year": 1989}], "referenceMentions": [{"referenceID": 22, "context": "Starting with Blind Strategymaker (BliStr) (Urban 2015) that was used to invent E\u2019s strategies for MaLARea (Urban et al. 2008; Kaliszyk et al. 2015b) on the 2012 Mizar@Turing competition problems (Sutcliffe 2013), several systems have been recently developed to invent targeted ATP strategies (Sch\u00e4fer and Schulz 2015; K\u00fchlwein and Urban 2015).", "startOffset": 107, "endOffset": 149}, {"referenceID": 5, "context": "The underlying methods used so far include genetic algorithms and iterated local search, as popularized by the ParamILS (Hutter et al. 2009) system.", "startOffset": 120, "endOffset": 140}, {"referenceID": 13, "context": "Term frequency \u2013 inverse document frequency, is a numerical statistic intended to reflect how important a word is to a document in a corpus (Leskovec et al. 2014).", "startOffset": 140, "endOffset": 162}, {"referenceID": 5, "context": "1) makes the set of meaningful protocol parameters very large for a straightforward use of iterative local search as done by the ParamILS (Hutter et al. 2009) system.", "startOffset": 138, "endOffset": 158}, {"referenceID": 0, "context": "translation (Urban 2004, 2006; Alama et al. 2014) of the Mizar Mathematical Library (Grabowski et al.", "startOffset": 12, "endOffset": 49}, {"referenceID": 4, "context": "2014) of the Mizar Mathematical Library (Grabowski et al. 2010).", "startOffset": 40, "endOffset": 63}], "year": 2016, "abstractText": "Inventing targeted proof search strategies for specific problem sets is a difficult task. State-of-the-art automated theorem provers (ATPs) such as E allow a large number of userspecified proof search strategies described in a rich domain specific language. Several machine learning methods that invent strategies automatically for ATPs were proposed previously. One of them is the Blind Strategymaker (BliStr), a system for automated invention of ATP strategies. In this paper we introduce BliStrTune \u2013 a hierarchical extension of BliStr. BliStrTune allows exploring much larger space of E strategies by interleaving search for high-level parameters with their fine-tuning. We use BliStrTune to invent new strategies based also on new clause weight functions targeted at problems from large ITP libraries. We show that the new strategies significantly improve E\u2019s performance in solving problems from the Mizar Mathematical Library.", "creator": "LaTeX with hyperref package"}}}