{"id": "1611.09014", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Nov-2016", "title": "Blocking and Other Enhancements for Bottom-Up Model Generation Methods", "abstract": "Model generation is a problem complementary to theorem proving and is important for fault analysis and debugging of formal specifications of security protocols, programs and terminological definitions. This paper discusses several ways of enhancing the paradigm of bottom-up model generation. The two main contributions are new, generalized blocking techniques and a new range-restriction transformation. The blocking techniques are based on simple transformations of the input set together with standard equality reasoning and redundancy elimination techniques. These provide general methods for finding small, finite models. The range-restriction transformation refines existing transformations to range-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and classical range-restriction were tested on the clausal problems of the TPTP Version 6.0.0 with an implementation based on the SPASS theorem prover using a hyperresolution-like refinement. Unrestricted domain blocking gave best results for satisfiable problems showing it is a powerful technique indispensable for bottom-up model generation methods. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Limiting the creation of terms during the inference process by using the new range restricting transformation has paid off, especially when using it together with a shifting transformation. The experimental results also show that classical range restriction with unrestricted blocking provides a useful complementary method. Overall, the results showed bottom-up model generation methods were good for disproving theorems and generating models for satisfiable problems, but less efficient than SPASS in auto mode for unsatisfiable problems.", "histories": [["v1", "Mon, 28 Nov 2016 07:54:50 GMT  (49kb)", "https://arxiv.org/abs/1611.09014v1", null], ["v2", "Tue, 29 Nov 2016 22:30:09 GMT  (49kb)", "http://arxiv.org/abs/1611.09014v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["peter baumgartner", "renate a schmidt"], "accepted": false, "id": "1611.09014"}, "pdf": {"name": "1611.09014.pdf", "metadata": {"source": "CRF", "title": "Blocking and Other Enhancements for Bottom-Up Model Generation Methods", "authors": ["Peter Baumgartner", "Renate A. Schmidt"], "emails": [], "sections": [{"heading": null, "text": "Model generation is a complementary problem to theory testing and is important for error analysis and debugging formal specifications of, for example, safety protocols, programs, and terminology definitions. This paper discusses several ways to improve the paradigm of bottom-up model generation. The two most important contributions are new, generalized blocking techniques and a new range constraint transformation. The blocking techniques are based on simple transformations of the input set along with standard equality arguments and redundancy elimination techniques. These provide general methods for determining small, finite models. The range constraint transformation refines existing transformations to domain-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and a classical range constraint techniques have been applied to the small, finite models. The scope constraint transformation refines existing transformations to domain-limited clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and a classical range constraint technique have been applied to classical domain-based transformation.0, with the impleASS implementer technology being a domain constraint technique."}, {"heading": "1 Introduction", "text": "In fact, most people who are able to survive themselves are able to survive themselves, \"he told\" Welt am Sonntag \":\" I don't think they will be able to change the world. \"He added:\" I don't think they will be able to change the world. \"He added:\" I don't think they will be able to change the world. \"He added:\" I don't think they will be able to change the world. \"He added:\" I don't think they will be able to change the world. \"He added:\" I don't think they will be able to change the world. \""}, {"heading": "2 Basic Definitions", "text": "We assume that there is a distinction between the terms \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and\" and \"and.\" We assume that a distinction involves a binary predicate, \"which is used in the infix form. We write clauses in a logical-programming style, that is, we write H1\" and \"B1\" instead of H1. \u00b7 \u00b7 \u00b7 Hm \"B1\" and \"Bk.\" \u00b7 \"Bk\" and \"Bk\" Bk, \"where m,\" k \"0.\" Each hi is referred to as a head atom, and each Bj is referred to as a body atom."}, {"heading": "3 BUMG Methods", "text": "In this Paper5, we are interested in bottom-up model generation approaches (BUMG). BUMG approaches use a forward-looking reasoning approach in which implications or clauses, H \u2190 B, are read as rules and repeatedly used to derive (instances of) H from (instances of) B. The family of BUMG approaches includes many well-known calculations and evidence procedures such as Smullyan-type semantic tableaux [Smullyan, 1971], SATCHMO [Manthey and Bry, 1988, Geisler et al., 1997], positive unit hyperresolution (PUHR) tableaux [Bry and Yahya, 2000, Bry and Torge, 1998], the model generation theorem proverMGTP [Fujita et al., 1995] and hypertableaux [Baumgartner et al., 1996]."}, {"heading": "4 Range-Restricting Transformations", "text": "The transformation can be defined by a procedure that performs the following steps on a particular set of clauses. (0) The constant c can be \"fresh\" or added to a constant. (1) The constant c can be \"fresh\" or belong to a constant. (2) The constant c is a \"fresh\" predicate that is not contained in the constant P. (2) The constant B in crr (M), leave the constant B in crr (x1), leave the constant. (2) The constant B in crr (M), leave the constant in H, but not in B. The place H in B by the6clauseH (x1). We refer to this clause as the corresponding clause B (3)."}, {"heading": "5 Shifting Transformation", "text": "The clauses we have introduced in step (2) of the new rr transformation are initially (deep): \"M.\" The clauses we have introduced in step (2) of the new rr transformation are (deep): \"M.\" The clauses we have introduced in step (2) of the new rr transformation are (deep): \"M.\" The clauses we have set in motion are (possibly a large number of) instances of the terms that occur in the clause that occur in the domain. These are sometimes unnecessary and can lead to the non-termination of BUMG processes. The shift that is introduced next can address this problem. It consists of two partial transformations in which P is not a fresh predicate symbol uniquely associated with the predicate symbol P. If P is the equality symbol, we do not write P as a 6 symbol and use the fundamental shift of a clause."}, {"heading": "6 Blocking", "text": "The final transformation contained in this paper is called blockade and provides a mechanism for recognizing repetitions in the derived models. The blocking transformation is designed to realize a loop check for the construction of a domain by filtering out the available, powerful reasoning technology and redundancy criteria from the saturation theorem. To be suitable, a resolution-oriented prover should support, for example, hyperresolution-like inference, strong equality inference (for example, superimposition or ordered paraphrasing), splitting, and the ability to search for separated equations first, and standard redundancy elimination techniques."}, {"heading": "6.1 Subterm Domain Blocking", "text": "By definition definition blocked the sub-term Domain sentence sentence sentence transformation sentence sentence sentence sentence M is the sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence sentence"}, {"heading": "6.2 Subterm Predicate Blocking", "text": "The idea of the subterm (unary) predicate blocking transformation is similar, but it only merges the (sub) terms in the extension of the unary predicate symbols, which differ from those of dom in the current interpretation. Same goes for step (1) in the definition of sdb. (2) Subterm predicate blocking is defined as follows: (0) Initialization let spb (M): = M. (1) Axioms that block the subterm relationship. (Same goes for step (1) in the definition of sdb. (2) Subterm equality case analysis. Expand spb (M) with these clauses, for each unary predicate symbol p. (Recall that blocks the subterm relationship does not block distinction.) x."}, {"heading": "6.3 Unrestricted Domain Blocking", "text": "The two previous \"subdomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomaindomindomaindomaindomaindomindomaindomaindomindomaindomaindomaindomaindomindomindomindomindomaindomaindomindomaindomaindomindomindomindomaindomindomindomaindomaindomindomindomindomaindomindomindomindomindomaindomaindomindomaindomindomaindomaindomindomindomindomindomindomaindomaindomindomindomaindomindomindomaindomindomindomaindomaindomaindomaindomindomindomaindomaindomaindomindomindomaindomindomaindomindomaindomaindomindomaindomaindomindomaindomaindomindomaindomindomaindomindomindomindomindomaindomaindomaindomaindomaindomainindomindomainininindomindomininindomaindomaindomaindomaindomaindomaindomaindomindomindomaindomininindomaindomainindomaindominininininindominaindomaindomaindomin"}, {"heading": "6.4 Unrestricted Predicate Blocking", "text": "The definition of the last variant of blocking, the unrestricted (simple) predicate block transformation, is as follows: (0) Initialization. First, let upb (M): = M. (1) Term equality case analysis. Expand upb (M) with these clauses for each predicate symbol p-p-x-x-y-x-x-x-x-x-y-p-y-y-y-y-y-y-y-y-y-x-x-yto-upb (M). This transformation allows two (different) terms in a p relationship, if any, to be equated. Motivation is a combination of the above to block cycles on p-literals when they arise and to calculate models with small domains."}, {"heading": "6.5 Comparison on an Example", "text": "It is instructive to compare the effects of the four blocking transformations on an example from Description Practice (cf. the description of local knowledge bases (vhs) and their translation into Description Practice (vhs) into Description Practice (vhs) into Description Practice (vhs) into Description Practice (vhs) into Description Practice (vhs) into Description Practice (vhs) into Description Practice (vhs) in Description Practice (vhs) in Description Practice (vhs) in Description Practice (vhs) in Description Practice (vhs) in Description Practice (vhs) in Description Practice (vhs) in Description Practice)."}, {"heading": "7 Soundness and Completeness of the Transfor-", "text": "The reversal, i.e. the solidity of the transformation, is easy to prove. Basically, it must be noted that the clauses added in steps (2) and (1) of the blocking transformations recognize a case distinction between whether two terms are equal or not. Trivial is one of the two cases always holds.Putting all the transformations and the corresponding results together, we can give the main theoretical result of the blocking transformations (2) and (1) of the blocking transformations."}, {"heading": "8 Decidability of BS classes", "text": "The Bernays Scho \ufffd nfinkel class is a decision-making process for the BS class. It can be decided by transformations in Rangerestricted clauses, which do not contain quantifiers. A clause is a BS clause, i.e. all functional terms contained therein. Schmidt and Hustadt [2005] prove that hyperresolution and all refinements decide the class of range-limited BS clauses without equality. Here, it is assumed that language implies equality. Theorem 2. The class of range-limited BS clauses (with equality) is decided by hyperresolution (and paramodulation) and all refinements. This means that all refinements of hyperresolution (and some forms of equality grounds) in connection with any kind of crauses (with any transfer to the range-limited BS clauses)."}, {"heading": "9 Experimental Evaluation", "text": "We have implemented the transformations described in the previous sections and experiments on problems from the TPTP library, version 6.0.0.23The implementation, in the SWI prologue, is referred to as Yarralumla (And yet another ranger restriction, which is expressed in much less assumptions).Since the transformations introduced in this paper are defined for clauses issues, we have all CNF problems from the TPTP suite.In our initial research, we have integrated Yarralumla with the MSPASS theorem prover, version 2.0g.1.4 [Hustadt and Schmidt, 2000] as the additional features of MSPASS have been integrated in the mean time integrated in the SPASS theorem prover. [Weidenbach et al., 2007] and SPASS has evolved significantly since version 2.0, for the current paper we have combined Yarralumla with the SPASS 3.8d system as BUMG."}, {"heading": "9.1 Results", "text": "The last column with the automatic results for the car preparations 3.3 and 4.0 comprise the results for the TPTP library 3.0 for the car preparations 3.0 for the car preparations 3.0 for the car preparations 3.0 for the car preparations 3.0 for the car preparations 4.0 for the car preparations 4.0 for the car preparations 4.0 for the car preparations 4.0 for the car parameters 4.0 for the car presentation 4.0 for the car presentation 4.0 for the car presentation 4.0 for the car presentation 4.0 for the car presentation 4.0 for the car presentation 4.0 for the car presentation and 4.0 for the car presentation 4.0 for the car presentation."}, {"heading": "9.2 Findings", "text": "The results of the study show that the search for a suitable candidate is not about a candidate, but about a candidate who is able to choose a candidate."}, {"heading": "10 Conclusions", "text": "This year, it is more than ever in the history of the city, where it is so far that it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place, where it is a place."}], "references": [{"title": "An overview of tableau algorithms for description logics", "author": ["F. Baader", "U. Sattler"], "venue": "Studia Logica,", "citeRegEx": "Baader and Sattler.,? \\Q2001\\E", "shortCiteRegEx": "Baader and Sattler.", "year": 2001}, {"title": "Equational reasoning in saturation-based theorem proving", "author": ["L. Bachmair", "H. Ganzinger"], "venue": "Automated Deduction\u2014 A Basis for Applications,", "citeRegEx": "Bachmair and Ganzinger.,? \\Q1998\\E", "shortCiteRegEx": "Bachmair and Ganzinger.", "year": 1998}, {"title": "Resolution theorem proving", "author": ["L. Bachmair", "H. Ganzinger"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Bachmair and Ganzinger.,? \\Q2001\\E", "shortCiteRegEx": "Bachmair and Ganzinger.", "year": 2001}, {"title": "Blocking and other enhancements for bottom-up model generation methods", "author": ["P. Baumgartner", "R.A. Schmidt"], "venue": "Automated Reasoning: IJCAR 2006,", "citeRegEx": "Baumgartner and Schmidt.,? \\Q2006\\E", "shortCiteRegEx": "Baumgartner and Schmidt.", "year": 2006}, {"title": "Hyper tableaux", "author": ["P. Baumgartner", "U. Furbach", "I. Niemel\u00e4"], "venue": "Logics in Artificial Intelligence: JELIA\u201996,", "citeRegEx": "Baumgartner et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1996}, {"title": "Computing answers with model elimination", "author": ["P. Baumgartner", "U. Furbach", "F. Stolzenburg"], "venue": "Artificial Intelligence,", "citeRegEx": "Baumgartner et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1997}, {"title": "Implementing the model evolution calculus", "author": ["P. Baumgartner", "A. Fuchs", "C. Tinelli"], "venue": "International Journal of Artificial Intelligence Tools,", "citeRegEx": "Baumgartner et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 2006}, {"title": "Hyper tableaux with equality", "author": ["P. Baumgartner", "U. Furbach", "B. Pelzer"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Baumgartner et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 2007}, {"title": "Disproving distributivity in lattices using geometry logic", "author": ["M. Bezem"], "venue": "In Proceedings of CADE-20 Workshop on Disproving,", "citeRegEx": "Bezem.,? \\Q2005\\E", "shortCiteRegEx": "Bezem.", "year": 2005}, {"title": "On deciding satisfiability by theorem proving with speculative inferences", "author": ["M.P. Bonacina", "C. Lynch", "L.M. de Moura"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Bonacina et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bonacina et al\\.", "year": 2011}, {"title": "A deduction method complete for refutation and finite satisfiability", "author": ["F. Bry", "S. Torge"], "venue": "Logics in Artificial Intelligence: JELIA\u201998,", "citeRegEx": "Bry and Torge.,? \\Q1998\\E", "shortCiteRegEx": "Bry and Torge.", "year": 1998}, {"title": "Positive unit hyperresolution tableaux for minimal model generation", "author": ["F. Bry", "A. Yahya"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Bry and Yahya.,? \\Q2000\\E", "shortCiteRegEx": "Bry and Yahya.", "year": 2000}, {"title": "New techniques that improve MACE-style finite model building", "author": ["K. Claessen", "N. S\u00f6rensson"], "venue": "Proceedings of CADE-19 Workshop on Model Computation,", "citeRegEx": "Claessen and S\u00f6rensson.,? \\Q2003\\E", "shortCiteRegEx": "Claessen and S\u00f6rensson.", "year": 2003}, {"title": "Automatic generation of some results in finite algebra", "author": ["M. Fujita", "J. Slaney", "F. Bennett"], "venue": "In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Fujita et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Fujita et al\\.", "year": 1995}, {"title": "Satchmo: The compiling and functional variants", "author": ["T. Geisler", "S. Panne", "H. Sch\u00fctz"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Geisler et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Geisler et al\\.", "year": 1997}, {"title": "Non-horn magic sets to incorporate top-down inference into bottom-up theorem proving", "author": ["R. Hasegawa", "K. Inoue", "Y. Ohta", "M. Koshimura"], "venue": "In Automated Deduction: CADE-14,", "citeRegEx": "Hasegawa et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hasegawa et al\\.", "year": 1997}, {"title": "On the relation of resolution and tableaux proof systems for description logics", "author": ["U. Hustadt", "R.A. Schmidt"], "venue": "Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence:", "citeRegEx": "Hustadt and Schmidt.,? \\Q1999\\E", "shortCiteRegEx": "Hustadt and Schmidt.", "year": 1999}, {"title": "MSPASS: Modal reasoning by translation and first-order resolution", "author": ["U. Hustadt", "R.A. Schmidt"], "venue": "Automated Reasoning with Analytic Tableaux and Related Methods, International Conference: TABLEAUX 2000,", "citeRegEx": "Hustadt and Schmidt.,? \\Q2000\\E", "shortCiteRegEx": "Hustadt and Schmidt.", "year": 2000}, {"title": "MSPASS: Subsumption testing with SPASS", "author": ["U. Hustadt", "R.A. Schmidt", "C. Weidenbach"], "venue": "Proceedings of International Workshop on Description", "citeRegEx": "Hustadt et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 1999}, {"title": "A refined tableau calculus with controlled blocking for the description logic SHOI", "author": ["M. Khodadadi", "R.A. Schmidt", "D. Tishkovsky"], "venue": "Automated Reasoning with Analytic Tableaux and Related Methods: TABLEAUX 2013,", "citeRegEx": "Khodadadi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Khodadadi et al\\.", "year": 2013}, {"title": "Unsound theorem proving", "author": ["C. Lynch"], "venue": "In Computer Science Logic, 18th International Workshop, CSL, volume 3210 of LNCS,", "citeRegEx": "Lynch.,? \\Q2004\\E", "shortCiteRegEx": "Lynch.", "year": 2004}, {"title": "SATCHMO: a theorem prover implemented in Prolog", "author": ["R. Manthey", "F. Bry"], "venue": "Automated Deduction: CADE-9,", "citeRegEx": "Manthey and Bry.,? \\Q1988\\E", "shortCiteRegEx": "Manthey and Bry.", "year": 1988}, {"title": "A Davis-Putnam Program and its Application to Finite FirstOrder Model Search: Quasigroup Existence Problems", "author": ["W. McCune"], "venue": "Technical Report MCS-TM-194,", "citeRegEx": "McCune.,? \\Q1994\\E", "shortCiteRegEx": "McCune.", "year": 1994}, {"title": "Mace4 reference manual and guide", "author": ["W. McCune"], "venue": "Technical Memorandum 264, Argonne National Laboratory,", "citeRegEx": "McCune.,? \\Q2003\\E", "shortCiteRegEx": "McCune.", "year": 2003}, {"title": "Paramodulation-based theorem proving", "author": ["R. Nieuwenhuis", "A. Rubio"], "venue": "Handbook of Automated Reasoning,", "citeRegEx": "Nieuwenhuis and Rubio.,? \\Q2001\\E", "shortCiteRegEx": "Nieuwenhuis and Rubio.", "year": 2001}, {"title": "A tableau calculus for minimal modal model generation", "author": ["F. Papacchini", "R.A. Schmidt"], "venue": "Electronic Notes in Theoretical Computer Science,", "citeRegEx": "Papacchini and Schmidt.,? \\Q2011\\E", "shortCiteRegEx": "Papacchini and Schmidt.", "year": 2011}, {"title": "System description: E-KRHyper", "author": ["B. Pelzer", "C. Wernhard"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Pelzer and Wernhard.,? \\Q2007\\E", "shortCiteRegEx": "Pelzer and Wernhard.", "year": 2007}, {"title": "The design and implementation of VAMPIRE", "author": ["A. Riazanov", "A. Voronkov"], "venue": "AI Communications,", "citeRegEx": "Riazanov and Voronkov.,? \\Q2002\\E", "shortCiteRegEx": "Riazanov and Voronkov.", "year": 2002}, {"title": "Automatic deduction with hyper-resolution", "author": ["J.A. Robinson"], "venue": "International Journal of Computer Mathematics,", "citeRegEx": "Robinson.,? \\Q1965\\E", "shortCiteRegEx": "Robinson.", "year": 1965}, {"title": "Solvability with resolution of problems in the Bernays-Sch\u00f6nfinkel class", "author": ["R.A. Schmidt", "U. Hustadt"], "venue": "Presented at Dagstuhl Seminar", "citeRegEx": "Schmidt and Hustadt.,? \\Q2006\\E", "shortCiteRegEx": "Schmidt and Hustadt.", "year": 2006}, {"title": "Using tableau to decide expressive description logics with role negation", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "The Semantic Web: ISWC 2007 + ASWC 2007,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2007\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2007}, {"title": "A general tableau method for deciding description logics, modal logics and related first-order fragments", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "Automated Reasoning: IJCAR 2008,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2008\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2008}, {"title": "Automated synthesis of tableau calculi", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "Logical Methods in Computer Science,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2011\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2011}, {"title": "Using tableau to decide description logics with full role negation and identity", "author": ["R.A. Schmidt", "D. Tishkovsky"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Schmidt and Tishkovsky.,? \\Q2013\\E", "shortCiteRegEx": "Schmidt and Tishkovsky.", "year": 2013}, {"title": "Axiomatic and tableau-based reasoning for Kt(H,R)", "author": ["R.A. Schmidt", "J.G. Stell", "D. Rydeheard"], "venue": "Advances in Modal Logic, Volume", "citeRegEx": "Schmidt et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Schmidt et al\\.", "year": 2014}, {"title": "FINDER (finite domain enumerator): Notes and guide", "author": ["J. Slaney"], "venue": "Technical Report TR-ARP-1/92, Australian National University,", "citeRegEx": "Slaney.,? \\Q1992\\E", "shortCiteRegEx": "Slaney.", "year": 1992}, {"title": "First Order Logic", "author": ["R.M. Smullyan"], "venue": null, "citeRegEx": "Smullyan.,? \\Q1971\\E", "shortCiteRegEx": "Smullyan.", "year": 1971}, {"title": "Upside-down meta-interpretation of the model elimination theorem-proving procedure for deduction and abduction", "author": ["M.E. Stickel"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Stickel.,? \\Q1994\\E", "shortCiteRegEx": "Stickel.", "year": 1994}, {"title": "System description: SPASS version 3.0", "author": ["C. Weidenbach", "R.A. Schmidt", "T. Hillenbrand", "R. Rusev", "D. Topic"], "venue": "Automated Deduction: CADE-21,", "citeRegEx": "Weidenbach et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Weidenbach et al\\.", "year": 2007}, {"title": "SPASS version 3.5", "author": ["C. Weidenbach", "D. Dimova", "A. Fietzke", "R. Kumar", "M. Suda", "P. Wischnewski"], "venue": "Automated Deduction: CADE-22,", "citeRegEx": "Weidenbach et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Weidenbach et al\\.", "year": 2009}, {"title": "System description: KRHyper", "author": ["C. Wernhard"], "venue": "In Proceedings of CADE-19 Workshop on Model Computation,", "citeRegEx": "Wernhard.,? \\Q2003\\E", "shortCiteRegEx": "Wernhard.", "year": 2003}, {"title": "SEM: A system for enumerating models", "author": ["H. Zhang"], "venue": "In Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Zhang.,? \\Q1995\\E", "shortCiteRegEx": "Zhang.", "year": 1995}], "referenceMentions": [{"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al.", "startOffset": 280, "endOffset": 2072}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases.", "startOffset": 280, "endOffset": 2171}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class.", "startOffset": 280, "endOffset": 2727}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003].", "startOffset": 280, "endOffset": 3083}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003].", "startOffset": 280, "endOffset": 3111}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003]. In contrast, MACEstyle model builders such as, for example, the methods of Claessen and S\u00f6rensson [2003] and McCune [1994] reduce model search to testing of propositional satisfi-", "startOffset": 280, "endOffset": 3293}, {"referenceID": 0, "context": "One of the contributions of the paper is the introduction to first-order logic of blocking techniques partially inspired by techniques already successfully used in description and modal logic tableau-based theorem proving [Hustadt and Schmidt, 1999, Schmidt and Tishkovsky, 2007, Baader and Sattler, 2001]. We adapt and generalize these blocking techniques to full first-order logic. Blocking is an important technique for turning tableau systems into decision procedures for modal and description logics. Though different blocking techniques exist, and not all modal and description logic tableau systems are designed to return models, blocking is essentially a mechanism for systematically merging terms in order to find finite models. In our approach blocking is encoded on the clausal level and is combined with standard resolution techniques, the idea being that with a suitable prover small, finite models are constructed and can be easily read off from the derived clauses. Our blocking techniques are generic and pose no restrictions on the logic they can be used for. They can even be used for undecidable logics. We introduce four different blocking techniques. The main idea of our blocking techniques is that clauses are added to the input problem which lead in the derivation to splittable clauses causing terms in the partially constructed models to be merged. The difference between the four techniques is how restrictive blocking is. With unrestricted domain blocking domain minimal models can be generated. With subterm domain blocking or subterm predicate blocking larger models are produced because two terms are only merged if one is a subterm of the other. With unrestricted predicate blocking and subterm predicate blocking two terms are merged if they both belong to the extension of a unary predicate symbol, the intention being that less constrained, finite model can be found. The second contribution of the paper is a refinement of the well-known \u2018transformation to range-restricted form\u2019 as introduced in the eighties by Manthey and Bry [1988] in the context of the SATCHMO prover and later improved, for example, by Baumgartner et al. [1997]. These range-restricting transformations have the disadvantage that they generally force BUMG methods to enumerate the entire Herbrand universe and are therefore non-terminating except in the simplest cases. One solution is to combine classical range-restriction transformations with blocking techniques. Another solution, presented in this paper, is to modify the range-restricting transformation so that new terms are created only when needed. Our method extends and combines the range-restricting transformation introduced in Schmidt and Hustadt [2005] for reducing first-order formulae and clauses into range-restricted clauses, which was used to develop general-purpose resolution decision procedures for the Bernays-Sch\u00f6nfinkel class. Other methods for model computation can be classified as methods that directly search for a finite model, such as the extended PUHR tableau method of Bry and Torge [1998], the method of Bezem [2005] and the methods in the SEM-family [Slaney, 1992, Zhang, 1995, McCune, 2003]. In contrast, MACEstyle model builders such as, for example, the methods of Claessen and S\u00f6rensson [2003] and McCune [1994] reduce model search to testing of propositional satisfi-", "startOffset": 280, "endOffset": 3311}, {"referenceID": 3, "context": "This paper is an extended and improved version of Baumgartner and Schmidt [2006].", "startOffset": 50, "endOffset": 81}, {"referenceID": 36, "context": "The family of BUMG approaches includes many familiar calculi and proof procedures such as Smullyan type semantic tableaux [Smullyan, 1971], SATCHMO [Manthey and Bry, 1988, Geisler et al.", "startOffset": 122, "endOffset": 138}, {"referenceID": 13, "context": ", 1997], positive unit hyperresolution (PUHR) tableaux [Bry and Yahya, 2000, Bry and Torge, 1998], the model generation theorem proverMGTP [Fujita et al., 1995] and hypertableaux [Baumgartner et al.", "startOffset": 139, "endOffset": 160}, {"referenceID": 4, "context": ", 1995] and hypertableaux [Baumgartner et al., 1996].", "startOffset": 26, "endOffset": 52}, {"referenceID": 28, "context": "A well-established and widely known method for BUMG is hyperresolution [Robinson, 1965].", "startOffset": 71, "endOffset": 87}, {"referenceID": 21, "context": "Existing transformations to range-restricted form followManthey and Bry [1988] (or are variations of it).", "startOffset": 56, "endOffset": 79}, {"referenceID": 10, "context": "However, the method has been shown to be useful for (domain-)minimal model generation when combined with other techniques [Bry and Yahya, 2000, Bry and Torge, 1998]. In particular, Bry and Torge [1998] use splitting and the \u03b4-rule to generate domain minimal models.", "startOffset": 144, "endOffset": 202}, {"referenceID": 40, "context": "The same behaviour can be achieved, for example, with the KRHyper BUMG prover, a hypertableaux theorem prover [Wernhard, 2003].", "startOffset": 110, "endOffset": 126}, {"referenceID": 27, "context": ", 2007, 2009], but is now also part of VAMPIRE [Riazanov and Voronkov, 2002] and E [Schulz, 2013].", "startOffset": 47, "endOffset": 76}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework.", "startOffset": 68, "endOffset": 223}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework.", "startOffset": 68, "endOffset": 289}, {"referenceID": 4, "context": "Splitting is an integral part of the hypertableau prover E-KRHyper [Baumgartner et al., 2007, Pelzer and Wernhard, 2007]. Blocking has the same goal as the unsound theorem proving technique introduced first in Lynch [2004]. Instances of unsound theorem proving exemplified in Lynch [2004] include replacing a clause by one that subsumes it, and by adding equations for joining equivalence classes in the abstract congruence closure framework. Unsound theorem proving has been incorporated later in DPLLT-based theorem proving Bonacina et al. [2011]. In the following we introduce four different, but closely related, blocking transformations, called subterm domain blocking, subterm predicate blocking, unrestricted domain blocking and unrestricted predicate blocking.", "startOffset": 68, "endOffset": 549}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006].", "startOffset": 83, "endOffset": 114}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006]. Subterm predicate blocking is inspired by and related to the blocking technique described in Hustadt and Schmidt [1999]. Unrestricted domain blocking is the first-order version of the unrestricted blocking rule introduced in Schmidt and Tishkovsky [2007] and used for developing terminating tableau calculi for logics with the effective finite model property in Schmidt and Tishkovsky [2008, 2011].", "startOffset": 84, "endOffset": 236}, {"referenceID": 3, "context": "blocking was introduced in the short version of this paper under the name blocking [Baumgartner and Schmidt, 2006]. Subterm predicate blocking is inspired by and related to the blocking technique described in Hustadt and Schmidt [1999]. Unrestricted domain blocking is the first-order version of the unrestricted blocking rule introduced in Schmidt and Tishkovsky [2007] and used for developing terminating tableau calculi for logics with the effective finite model property in Schmidt and Tishkovsky [2008, 2011].", "startOffset": 84, "endOffset": 371}, {"referenceID": 30, "context": "Using the ideas of the termination proof in Schmidt and Tishkovsky [2013] for semantic ground tableau with unrestricted domain blocking for description logics with the expressive power similar to the two-variable fragment of firstorder logic, it can be shown BUMG with unrestricted domain blocking can return finite models, if they exist, even for problems of undecidable fragments.", "startOffset": 44, "endOffset": 74}, {"referenceID": 30, "context": "Using the ideas of the termination proof in Schmidt and Tishkovsky [2013] for semantic ground tableau with unrestricted domain blocking for description logics with the expressive power similar to the two-variable fragment of firstorder logic, it can be shown BUMG with unrestricted domain blocking can return finite models, if they exist, even for problems of undecidable fragments. Carrying over also the results in Schmidt and Tishkovsky [2008] implies unrestricted domain blocking can be used in BUMG methods to return domain minimal models for logics with the effective finite model property.", "startOffset": 44, "endOffset": 447}, {"referenceID": 0, "context": "An advantage of our approach to blocking as opposed to blocking without equality reasoning used in mainstream description logic systems [Baader and Sattler, 2001] is that it applies to any first-order clause set, not only to clauses from the translation of description logic problems.", "startOffset": 136, "endOffset": 162}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al.", "startOffset": 0, "endOffset": 27}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al.", "startOffset": 0, "endOffset": 58}, {"referenceID": 15, "context": "Hustadt and Schmidt [1999], Schmidt and Tishkovsky [2013] and Khodadadi et al. [2013]. Because standard loop checking mechanisms used in description logic systems do not require backtracking, appropriate search strategies and restrictions for performing inferences and applying blocking need to be used.", "startOffset": 0, "endOffset": 86}, {"referenceID": 29, "context": "It is proved in Schmidt and Hustadt [2005] that hyperresolution and any refinements decide the class of range-restricted BS clauses without equality.", "startOffset": 16, "endOffset": 43}, {"referenceID": 29, "context": "In Schmidt and Hustadt [2005] a similar but different transformation is used to prove this result for hyperresolution and BS without equality.", "startOffset": 3, "endOffset": 30}, {"referenceID": 3, "context": "In our initial research [Baumgartner and Schmidt, 2006] we used Yarralumla with the MSPASS theorem prover, Version 2.", "startOffset": 24, "endOffset": 55}, {"referenceID": 17, "context": "4 [Hustadt and Schmidt, 2000].", "startOffset": 2, "endOffset": 29}, {"referenceID": 38, "context": "As the extra features of MSPASS have in the mean time been integrated into the SPASS theorem prover [Weidenbach et al., 2007] and SPASS has significantly evolved since Version 2.", "startOffset": 100, "endOffset": 125}, {"referenceID": 34, "context": "An investigation with SPASS-Yarralumla on translations of modal logic problems has revealed a different picture [Schmidt et al., 2014].", "startOffset": 112, "endOffset": 134}, {"referenceID": 19, "context": "Experiments with blocking restricted by excluding a finite subset of the domain have shown better results than for unrestricted domain blocking for consistency testing on a large corpus of ontologies [Khodadadi et al., 2013].", "startOffset": 200, "endOffset": 224}, {"referenceID": 6, "context": "Initial results with another prover, Darwin [Baumgartner et al., 2006], are very encouraging.", "startOffset": 44, "endOffset": 70}, {"referenceID": 5, "context": ", 1997, Stickel, 1994], a typed version of range-restriction [Baumgartner et al., 1997], and minimal model computation [Bry and Yahya, 2000, Bry and Torge, 1998, Papacchini and Schmidt, 2011].", "startOffset": 61, "endOffset": 87}], "year": 2016, "abstractText": "Model generation is a problem complementary to theorem proving and is important for fault analysis and debugging of formal specifications of, for example, security protocols, programs and terminological definitions. This paper discusses several ways of enhancing the paradigm of bottom-up model generation. The two main contributions are new, generalized blocking techniques and a new range-restriction transformation. The blocking techniques are based on simple transformations of the input set together with standard equality reasoning and redundancy elimination techniques. These provide general methods for finding small, finite models. The range-restriction transformation refines existing transformations to range-restricted clauses by carefully limiting the creation of domain terms. All possible combinations of the introduced techniques and a classical range-restriction technique were tested on the clausal problems of the TPTP Version 6.0.0 with an implementation based on the SPASS theorem prover using a hyperresolution-like refinement. Unrestricted domain blocking gave best results for satisfiable problems showing it is a powerful technique indispensable for bottom-up model generation methods. Both in combination with the new range-restricting transformation, and the classical range-restricting transformation, good results have been obtained. Limiting the creation of terms during the inference process by using the new range restricting transformation has paid off, especially when using it together with a shifting transformation. The experimental results also show that classical range restriction with unrestricted blocking provides a useful complementary method. Overall, the results showed bottom-up model generation methods were good for disproving theorems and generating models for satisfiable problems, but less efficient than SPASS in auto mode for unsatisfiable problems.", "creator": "LaTeX with hyperref package"}}}