{"id": "1701.07123", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-Jan-2017", "title": "Towards Automatic Learning of Heuristics for Mechanical Transformations of Procedural Code", "abstract": "The current trends in next-generation exascale systems go towards integrating a wide range of specialized (co-)processors into traditional supercomputers. Due to the efficiency of heterogeneous systems in terms of Watts and FLOPS per surface unit, opening the access of heterogeneous platforms to a wider range of users is an important problem to be tackled. However, heterogeneous platforms limit the portability of the applications and increase development complexity due to the programming skills required. Program transformation can help make programming heterogeneous systems easier by defining a step-wise transformation process that translates a given initial code into a semantically equivalent final code, but adapted to a specific platform. Program transformation systems require the definition of efficient transformation strategies to tackle the combinatorial problem that emerges due to the large set of transformations applicable at each step of the process. In this paper we propose a machine learning-based approach to learn heuristics to define program transformation strategies. Our approach proposes a novel combination of reinforcement learning and classification methods to efficiently tackle the problems inherent to this type of systems. Preliminary results demonstrate the suitability of this approach.", "histories": [["v1", "Wed, 25 Jan 2017 01:20:34 GMT  (433kb,D)", "http://arxiv.org/abs/1701.07123v1", "In Proceedings PROLE 2016,arXiv:1701.03069. This paper is based onarXiv:1603.03022, and has a thorough description of the proposed approach"]], "COMMENTS": "In Proceedings PROLE 2016,arXiv:1701.03069. This paper is based onarXiv:1603.03022, and has a thorough description of the proposed approach", "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["guillermo vigueras", "manuel carro", "salvador tamarit", "julio mari\\~no"], "accepted": false, "id": "1701.07123"}, "pdf": {"name": "1701.07123.pdf", "metadata": {"source": "CRF", "title": "Towards Automatic Learning of Heuristics for Mechanical Transformations of Procedural Code\u2217", "authors": ["Guillermo Vigueras Manuel Carro", "Salvador Tamarit", "Julio Mari\u00f1o"], "emails": ["guillermo.vigueras@imdea.org", "manuel.carro@imdea.org", "salvador.tamarit@upm.es", "julio.marino@upm.es"], "sections": [{"heading": null, "text": "In fact, it is not that we are able to find a solution that we can solve the problems we have had in recent years. (...) It is not that we can solve them. (...) It is not that we can solve them. (...) It is not that we can solve them. (...) It is not that we can solve them. (...) It is not that we can solve them. (...) It is not that we can solve them. (...) It is not that we can solve them. (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...). (...).). (...). (...). (...). (...).). (...). (...).). (...). (...).). (...). (...).). (...).). (...).). (...).). (...). (...).). (...).). (...). (...).). (...).). (...). (.).). (...).). (...).).). (...). (...).). (...).). (.). (...).).). (...).). (...).).). (. (...).). (....).).). (...).).).)... (...).).. (...).).. (...).)................)...."}, {"heading": "1 Introduction", "text": "This year it has come to the point where it will be able to put itself at the top, \"he said.\" We have to put ourselves at the top, \"he said.\" We have to put ourselves at the top, \"he said.\" We have to put ourselves at the top. \""}, {"heading": "2 State of the Art", "text": "Rule-based program transformation systems support the formulation of basic code transformation steps as generic rules and order their automatic application. However, this scheme provides the flexibility to split complex code transformations into small steps and allow efficient implementations that can be applied to large programs. By adding more rules, the transformation system can also expand its capabilities in a scalable way. Rule-based systems also allow the definition of transformation steps (i.e. rule applications) to be decoupled from the strategies for applying the rules. This decoupling provides more flexibility to test different transformation strategies and select the best ones according to the purpose of the system [2, 14]. Rule-based transformations have previously been used to generate code for different computer platforms."}, {"heading": "3 Program Transformation Toolchain for Heterogeneous systems", "text": "In this thesis, we propose the automatic learning of transformation strategies for a rules-based transformation platform [17, 16]. This type of system offers greater flexibility in relation to the compilation platform, in which the code transformations and optimizations are embedded in the compilation platform. Basically, the input code is reformed taking into account two main steps (Fig). In the first phase, the input C code is converted into a semantically equivalent C code, which is more suitable for a specific platform."}, {"heading": "4 Mapping Code to Abstraction", "text": "As already mentioned, machine learning works with descriptions of the problem domain (in our case C code). We use code abstractions as descriptions; these should be rich enough to reflect the changes made by the transformation rules at the AST level. Therefore, we include quantitative descriptions in the abstractions, which include features such as AST patterns, control flow, data layout, data dependencies, etc. Current code abstraction consists of a (later described) vector of features that capture features modified by the transformation rules and also reflect code patterns that meet the syntactical-semantic constraints of target compiler / programmer models. These abstractions are generated by a code analysis tool that analyzes the AST to extract the previously mentioned features, while implementing a function."}, {"heading": "A : Code\u2192 Abstraction", "text": "The reason for this is that most of them are not able to abide by the rules that they have imposed on themselves. (...) The reason for this is that they are not able to understand the rules. (...) The reason for this is that they are not able to abide by the rules. \"(...)\" I do not believe that they are able to understand the rules. \"(...)\" I do not believe that they are able to understand the rules. \"(...)\" I do not believe that they are able to understand them. \"(...)\" I do not believe that they are able to understand them. \"(...)\" I do not believe that they are able to understand them. \"(...)\" I do not believe that they are able to understand them. \""}, {"heading": "5 Automatic Learning of Transformation Heuristics", "text": "As already mentioned, the problem of the transformation machine is to efficiently find transformation sequences in a very large (even infinite) state space with a non-monotonous fitness function and decide when to stop searching, as there is no a priori general method to determine whether an optimal (in the sense of the most efficient possible code) state has been reached. Our approach uses classification trees to solve the latter, and amplification to solve the former. We will describe our approaches in the next sections."}, {"heading": "5.1 Classification Trees", "text": "In fact, the problem of identifying the category to which a new observation belongs is within a set of predefined categories. Classification is based on a set of data that contain observations for which they are known. [10] Different approaches can be used to classify them. We have decided to evaluate the appropriateness of classification trees for our problem, as they perform the selection without complex data preparation. A classification tree is a simple representation of examples of a set of input functions. Input functions should have finite discrete domains and there is a single target variable called classification. Each element of the target variable is referred to as class."}, {"heading": "5.2 Reinforcement Learning", "text": "Reinforcement Learning [10] is an area of machine learning that focuses on how software agents should take action in an environment to maximize an idea of cumulative reward. A reinforcement learning agent interacts with its environment in discrete time steps. At any time, the agent receives an observation that typically includes the reward rt. He then selects an action from the series of available actions that is then sent to the environment. The environment moves from the current state st to a new state st + 1, which associates the reward rt + 1 with the transition (st, st + 1). The goal of an reinforcement learning agent is to collect as much reward as possible. According to the previous description, reinforcement learning seems well suited to represent the optimization process of a programmer or compiler, since it usually consists of iterative improvement of an initial program in discrete steps where code changes and versioning are achieved during the optimization process."}, {"heading": "SM : Abstraction\u2192 State Q : State \u00d7 Action\u2192 R", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "AM : Rule\u2192 Action RS : Code \u2192 Rule", "text": "The discount factor implements the concept of delayed reward by determining the meaning of future rewards. A factor of 0 will make the agent opportunistic by taking into account only current rewards, while a factor close to 1 will cause him to strive for long-term rewards. If the discount factor reaches or exceeds 1, the values in Q may vary [10]. To use the gain, we need to define some mappings. Abstraction of a concrete code is provided by function A (described in section 4). Code abstractions and transformation rules must be mapped to states and actions in order to index the state action table. This mapping is performed by functions SM and AM (Figure 2). Based on the mapping of abstractions and rules that are defined, the amplification of the state action table can be modeled (1)."}, {"heading": "5.3 A Simple Example", "text": "The first rule (R0), which is considered in the example, transforms a non-1D array into a 1D array. The second rule (R1) implements a collapse of two nested rows to produce a single loop. (The first, middle, and final codes extracted from the application of these rules are described below. Listing 6 to Listing 9 highlights changes in the code that use this style to display the part of the code that changes after applying the rule and the code is highlighted. (Listing 1 shows the code that changes after applying a transformation rule.Listing 1 shows the initial code and the associated vector of properties, as a code comment in Section 4. Listing 6 shows the result of applying rule R0 to the code in Listing 1. The array input image is transformed into a 1-D array and the vector of functions associated with the code is modified accordingly."}, {"heading": "6 Results", "text": "We will first show evidence to support our claim made in Section 5.2, with respect to the non-monotonous behavior of non-functional properties for transformation sequences and, secondly, we will evaluate the applicability of amplification patterns to learn from these non-monotonous sequences. Non-monotonous formation has two sides: on the one hand, the best performance on a CPU is not necessarily the most efficient execution of (sequential) code used on a form that is more suitable for a final platform, the efficiency observed in a CPU for a good sequence can be increased and decreased. On the other hand, the final code that extracts the best performance on a CPU is not necessarily the most efficient used on the final platform. To demonstrate this behavior, we have identified four different transformation sequences for a use case that performs image compression using the discrete cosmic form. Each sequence identified to be executed on the CPU is sufficient to eventually produce a C-type of code."}, {"heading": "7 Conclusions and Future Work", "text": "We have proposed an approach based on machine learning to learn heuristics to control the code transformation process of a rules-based program transformation system [17, 16]. This type of system raises a number of problems, such as the state explosion resulting from the application of transformation rules in an arbitrary sequence or the definition of a stop criterion. For the latter, we have proposed the use of classification trees, and for the former, we have proposed a novel approach based on reinforcement learning. We have also conducted a preliminary assessment of the approach, which yielded promising results demonstrating the suitability of the approach to this type of transformation systems. As a future work, we plan to further expand the set of use cases for the training of the various machine learning techniques used. Consequently, we expect the code features to be enriched to obtain program abstractions in order to demonstrate new code patterns, the suitability of the set of learning techniques."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The current trends in next-generation exascale systems go towards integrating a wide range of specialized (co-)processors into traditional supercomputers. Due to the efficiency of heterogeneous systems in terms of Watts and FLOPS per surface unit, opening the access of heterogeneous platforms to a wider range of users is an important problem to be tackled. However, heterogeneous platforms limit the portability of the applications and increase development complexity due to the programming skills required. Program transformation can help make programming heterogeneous systems easier by defining a step-wise transformation process that translates a given initial code into a semantically equivalent final code, but adapted to a specific platform. Program transformation systems require the definition of efficient transformation strategies to tackle the combinatorial problem that emerges due to the large set of transformations applicable at each step of the process. In this paper we propose a machine learning-based approach to learn heuristics to define program transformation strategies. Our approach proposes a novel combination of reinforcement learning and classification methods to efficiently tackle the problems inherent to this type of systems. Preliminary results demonstrate the suitability of this approach.", "creator": "LaTeX with hyperref package"}}}