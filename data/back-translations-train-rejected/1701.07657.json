{"id": "1701.07657", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Jan-2017", "title": "Logic Programming Petri Nets", "abstract": "With the purpose of modeling, specifying and reasoning in an integrated fashion with procedural and declarative aspects (both commonly present in cases or scenarios), the paper introduces Logic Programming Petri Nets (LPPN), an extension to the Petri Net notation providing an interface to logic programming constructs. Two semantics are presented. First, a hybrid operational semantics that separates the process component, treated with Petri nets, from the constraint/terminological component, treated with Answer Set Programming (ASP). Second, a denotational semantics maps the notation to ASP fully, via Event Calculus. These two alternative specifications enable a preliminary evaluation in terms of reasoning efficiency.", "histories": [["v1", "Thu, 26 Jan 2017 11:21:50 GMT  (23kb)", "http://arxiv.org/abs/1701.07657v1", "draft version"]], "COMMENTS": "draft version", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["giovanni sileno"], "accepted": false, "id": "1701.07657"}, "pdf": {"name": "1701.07657.pdf", "metadata": {"source": "CRF", "title": "Logic Programming Petri Nets", "authors": ["Giovanni Sileno"], "emails": ["g.sileno@uva.nl"], "sections": [{"heading": null, "text": "As a rule, Petri networks are not considered meaningful enough to argue; in fact, they do not explicitly refer to any informational / representative concepts. In their simplest form, tokens are indefinable and do not transport data. Nevertheless, the modelers introduce labels to establish a correspondence between the modeling units and the modeled units, which allows them to read the results of the simulation in relation to the modeled system."}, {"heading": "1 Representing and processing knowledge", "text": "This year, the time has come for an agreement to be reached, and it will only take a few days."}, {"heading": "1.3 Logical conditionals and causal dependencies", "text": "A prototypical example of this problem is the use of the term \"rule of production.\" However, in (formal) linguistics, rules of production define the grammar of a language, i.e. the combinatorial system that defines valid linguistic elements. In the tradition of expert systems and active databases, rules of production are reactive rules: rules that guide actions or interventions in response to certain conditions. These interpretations deal with two perspectives: one concerns objects (e.g. symbols) and their relationships, and the other concerns patterns of action, mechanisms or processes (which concern objects) - the declarative and procedural dichotomy in turn (formal logic is the prototypical domain of the first perspective, just like the process modeling of the second."}, {"heading": "1.4 Why Logic Programming Petri Nets?", "text": "A proper handling of a case or scenario is based on two preconditions: on the one hand, the capture of the relationships expressed through language components - i.e. the symbols we use to represent the target system, which are formally related to each other in a local ontology relevant to the scenario; on the other, the reproduction of the same changes that the target system exhibits; the first aspect is the typical application domain of knowledge bases and, more recently, semantic ontologies introduced with the explicit purpose of describing reusable concepts and relationships (\"terms\") and defining specific problem areas; the second aspect is the main concern of process modeling, which is used for both descriptive and prescriptive purposes. Unfortunately, methodologies associated with one of the two aspects usually have a limited treatment of the other component, or they refer to specific mediation mechanisms that we cannot deal with directly from scenarios; therefore, a proper treatment is not an appropriate one."}, {"heading": "2 Informal presentation to LPPNs", "text": "Many extensions and variations of the basic Petrine net notation have been proposed in the literature, some of which - e.g. Colored Petrine Nets (CPN) [14] or Simple Logic Petrine Nets (SLPN) [5] - suggest integrating the descriptive function of labels with the executable nature of the net.The basic idea is that, in order to enable full computational operationalization, labels should be written in a kind of declarative language that is fully integrated into operational semantics. We are following the same idea, although we have different requirements. 88 CPNs are very powerful in terms of expressiveness, and they are used in many areas; however, they introduce many details that are not important in our environment (e.g. expressions on arcs), and this overload does not pay for their advancement. If a language is needed to model a world and its mechanisms, there should be a correspondence between the modeling entities (the Petrine Entities) and the PNP components (the Petrine Components), which should be given to the PNP components."}, {"heading": "2.1 Net components", "text": "LPPNs use the standard components of petri nets in a specific way: - Tokens are currently existing entities that are described with sentence names; - Places, containers for tokens that act as a kind of local relational database; - Transitions that consume and produce tokens when firing act as a kind of mechanism of withdrawal and enforcement. In addition, LPPNs contain a new type of component: - Logic nodes that are used to set logical constraints or for logical compositions that connect places or transitions."}, {"heading": "2.2 Labeling", "text": "Two specification levels are available for the labels: the token instance level (for tokens) and the type class level (for places and transitions) - the label of a token defines the sentence content of the associated sentence (a fact of a knowledge base); - the label of a place defines the relationship model of the local database associated with that place; - the label of a transition defines the parameters of transition events that can be burned. SLPNs were introduced for a purpose other than intermediate notation to transform an AgentSpeak (L) script into an ASP program for model testing. Beyond these considerations, both notations neglect the declarative (e.g. terminological) dimension of the modeled system. 9 A similar line of research can be found in the database system literature, with the distinction between deductive rules and active rules making an important contribution."}, {"heading": "2.3 Procedural mechanisms", "text": "An example of a subnet based on a procedural mechanism is in Fig. 1. In (a) two facts apply: p1 (a1) and p2 (a2, b1). The transition is not able to fire because the variable bond required by this event (the same parameter for A) is not fulfilled by the current inputs. In (b) there is an additional fact p2 (a1, b2) which enables the transition that fires. Due to the fire in (c), a new fact is forged with the consumed elements after the designation of the place of issue."}, {"heading": "2.4 Declarative mechanisms", "text": "The LPPN notation adds logical operation nodes that are applied to places or transitions. An example of a sub-network with logical operation nodes that operate on places (small black squares) is in Fig. 2. These are used to create logical compositions of places (via operators such as NEG, AND, OR, etc.) or to specify logical interdependencies (via logical conditional IMPLIES). Similarly, transitions can be connected declaratively via logical operators that operate on transitions (black circles) as in Fig. 3. These connections can be interpreted as channels that allow the fire to spread immediately. In this case, we do not have the usual logical operators, only implication or possibly double implication, because only one source transition is available for entangling semantics (Fig. 3)."}, {"heading": "3 Formalization", "text": "This section provides a formal representation of the notation of Logic Programming Petri Nets (LPPN). Despite the different notations, we begin similar to the formalization of Simple Logic Petri Nets (SLPN) [5]. However, if we turn to denotational semantics, we explicitly refer to Event Calculation (EC) [17,30] instead of considering ad hoc transformations to ASP, as these authors do (cf. also [3,2]), which anticipates a future integration into the existing literature on linguistic semantics (e.g. [18]).10 The semantics of the stable model applies ideas of autoepistemic logic [24] and standard logic [28]."}, {"heading": "3.1 Labeling language", "text": "Definition 1 (Term).Let CONST be a finite set of constants, VAR a finite set of variables, and FUNC a finite set of function symbols. The (possibly infinite) set of terms TERMS consists of: - all constants CONST, - all variables VAR, - all associations of function symbols FUNC to terms, in the form f (t1,. \u2212, tn), with f (person).Definition 2 (Ground Term).. A basic term is a term that does not contain variables.Definition 3 (atom).Definition L is a finite set of predicate symbols PRED."}, {"heading": "3.2 Net topology", "text": "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "3.3 Syntaxic constraints on topology", "text": "We derive the following constraints from ASP: - CP cannot map starting places for standard negation literals; in ASP, negation polarities can only be used in the rulebook (standard negation literals), but if it is necessary for the modeler, only indecisiveness with respect to positive or negative polarity (nulliterals); - CT cannot map transitions to standard negation literals (L instead of L); - when mapping a negation (\u00ac, \u2212), it requires only one input location; - a conjunction or disjunction (requires a disjunction), it requires at least one input location; - a negation, a conjunction or disjunction (\u00ac, a disjunction)."}, {"heading": "3.4 Hybrid operational semantics", "text": "In fact, it is so that most of them are able to survive themselves, and that they are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...) Most of them are able to survive themselves. (...)"}, {"heading": "3.5 Denotational semantics", "text": "\"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"iSe,\" \"\" iSe, \"\" \"iSe,\" \"\" \"iSe,\" \"\" \"iSe,\" \"\" \",\" \"\" \"\", \"\" \"\" \",\" \"\" \"\" \",\" \"\" \"\", \"\" \"\" \"\", \"\" \"\" \"\" \",\" \"\" \"\" \",\" \"\" \",\" \"\" \",\" \"\", \"\", \"\", \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\", \"\" \"\", \",\", \"\", \"\" \"\", \",\" \"\" \",\" \"\", \",\" \"\" \",\" \",\" \"\" \",\", \"\" \",\" \",\" \",\" \",\" \"\", \"\" \",\" \",\" \"\", \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\" \"\" \",\" \",\" \"\" \"\" \",\" \"\" \"\" \",\" \"\", \"\" \"\" \"\", \"\" \"\" \",\" \"\" \"\" \",\" \"\" \"\", \"\" \"\" \"\", \"\" \"\" \"\" \",\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \",\" \"\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\", \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\" \"\" \"\", \"\" \"\" \"\", \"\" \"\" \"\", \"\" \"\" \"\" \"\" \",\" \",\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\" \"\", \"\" \"\" \"\" \"\" \"\" \",\" \"\" \"\" \"\" \""}, {"heading": "4 Evaluation", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}], "references": [{"title": "Learning and memory: an integrated approach", "author": ["J.R. Anderson"], "venue": "John Wiley & Sons, Inc.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Encoding Higher Level Extensions of Petri Nets in Answer Set Programming", "author": ["S. Anwar", "C. Baral", "K. Inoue"], "venue": "Logic Programming and Nonmonotonic Reasoning Lecture Notes in Computer Science", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "Encoding Petri nets in answer set programming for simulation based reasoning", "author": ["S. Anwar", "C. Baral", "K. Inoue"], "venue": "TPLP 13(4-5-Online-Supplement)", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "An Event Calculus for Event Recognition", "author": ["A. Artikis", "M. Sergot", "G. Paliouras"], "venue": "IEEE Transactions on Knowledge and Data Engineering 27(4), 895\u2013908", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Model checking multi-agent systems with logic based Petri nets", "author": ["T.M. Behrens", "J. Dix"], "venue": "Annals of Mathematics and Artificial Intelligence 51(2-4), 81\u2013121", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2008}, {"title": "Transaction Logic Programming", "author": ["A.J. Bonner", "M. Kifer"], "venue": "International Conference on Logic Programming pp. 257\u2013279", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1993}, {"title": "Core concepts of law: taking common-sense seriously", "author": ["J. Breuker", "R. Hoekstra"], "venue": "Proc. of Formal Ontologies in Information", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2004}, {"title": "A user\u2019s guide to gringo, clasp, clingo, and iclingo", "author": ["T. Eiter", "W. Faber", "M. Fink", "S. Woltran"], "venue": "Annals of Mathematics and Artificial Intelligence 51(2-4), 123\u2013165", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2008}, {"title": "Representing first-order causal theories by logic programs", "author": ["P. Ferraris", "J. Lee"], "venue": "Theory and Practice of Logic Programming 12(03), 383\u2013412", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Coala: A compiler from action languages to ASP", "author": ["M. Gebser", "T. Grote", "T. Schaub"], "venue": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics) 6341 LNAI, 360\u2013364", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Action languages", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Electronic Transactions on AI", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1998}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium pp. 1070\u20131080", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1988}, {"title": "Predicate/Transition Nets", "author": ["H.J. Genrich"], "venue": "Proceedings Advances in Petri nets 1986. pp. 207\u2013247", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1987}, {"title": "Coloured Petri Nets: Basic Concepts, Analysis Methods and Practical Use", "author": ["K. Jensen"], "venue": "Springer-Verlag, London, UK", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1996}, {"title": "Nouns and verbs in the brain: Implications of linguistic typology for cognitive neuroscience", "author": ["D. Kemmerer", "A. Eggleston"], "venue": "Lingua 120(12), 2686\u20132690", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2010}, {"title": "Integrating logic programming and production systems in abductive logic programming agents", "author": ["R. Kowalski", "F. Sadri"], "venue": "Web Reasoning and Rule Systems LNCS 5837, 1\u201323", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "A logic based calculus of events", "author": ["R. Kowalski", "M. Sergot"], "venue": "New Generation Computing 4(June 1975), 67\u201395", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1986}, {"title": "The Proper Treatment of Events", "author": ["M. van Lambalgen", "F. Hamm"], "venue": "Wiley-Blackwell, Oxford, UK", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "System f2lp - computing answer sets of first-order formulas", "author": ["J. Lee", "R. Palla"], "venue": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics) 5753 LNAI, 515\u2013521", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "A First Order Forward Chaining for Answer Set Computing", "author": ["C. Lefevre", "P. Nicolas"], "venue": "LPNMR 2009 LNCS 5753, 196\u2013208", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2009}, {"title": "Decomposing Alignment-Based Conformance Checking of Data-Aware Process Models", "author": ["M. de Leoni", "J. Munoz-Gama", "J. Carmona", "W.M.P. van der Aalst"], "venue": "Meersman, R., Panetto, H., Dillon, T., Missikoff, M., Liu, L., Pastor, O., Cuzzocrea, A., Sellis, T. (eds.) On the Move to Meaningful Internet Systems: OTM 2014, pp. 3\u201320. Springer Berlin Heidelberg, Berlin, Heidelberg", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Two-Valued Logic Programs", "author": ["V. Lifschitz"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Some philosophical problems from the standpoint of artificial intelligence", "author": ["J. McCarthy", "P.J. Hayes"], "venue": "Machine Intelligence, pp. 1\u201351. Edimburgh University Press", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1969}, {"title": "Semantical Considerations on Nonmonotonic Logic", "author": ["R.C. Moore"], "venue": "Artificial Intelligence 25(1), 75\u201394", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1985}, {"title": "Performance evaluation of petri nets execution algorithms", "author": ["R.P. Moreno", "J.L.V. Salcedo"], "venue": "Conference Proceedings - IEEE International Conference on Systems, Man and Cybernetics pp. 1400\u20131407", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2007}, {"title": "Single-Entry Single-Exit decomposed conformance checking", "author": ["J. Munoz-Gama", "J. Carmona", "W.M.P. Van Der Aalst"], "venue": "Information Systems 46, 102\u2013122", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2014}, {"title": "Performance evaluation of petri nets centralized implementation", "author": ["R. Piedrafita", "J.L. Villarroel"], "venue": "The execution time controller. Discrete Event Dynamic Systems: Theory and Applications 21(2), 139\u2013169", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2011}, {"title": "A logic for default reasoning", "author": ["R. Reiter"], "venue": "Artificial Intelligence 13(1-2), 81\u2013132", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1980}, {"title": "Knowledge in action: logical foundations for specifying and implementing dynamical systems", "author": ["R. Reiter"], "venue": null, "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2001}, {"title": "The event calculus explained", "author": ["M. Shanahan"], "venue": "Artificial intelligence today pp. 409\u2013 430", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1999}, {"title": "Aligning Law and Action", "author": ["G. Sileno"], "venue": "Ph.D. thesis, University of Amsterdam", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2016}, {"title": "From situation calculus to fluent calculus: State update axioms as a solution to the inferential frame problem", "author": ["M. Thielscher"], "venue": "Artificial Intelligence 111(1-2), 277\u2013299", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1999}], "referenceMentions": [{"referenceID": 13, "context": "For its generality, applicative value and popularity, the most important notation following this approach is certainly Coloured Petri Nets (CPNs) [14], which, for many aspects, is a descendant of Predicate/Transition Nets [13].", "startOffset": 146, "endOffset": 150}, {"referenceID": 12, "context": "For its generality, applicative value and popularity, the most important notation following this approach is certainly Coloured Petri Nets (CPNs) [14], which, for many aspects, is a descendant of Predicate/Transition Nets [13].", "startOffset": 222, "endOffset": 226}, {"referenceID": 4, "context": "Other examples exist, however, tailored to specific purposes; for instance, Simple Logic Petri Nets (SLPNs), used to perform model-checking of agent programs [5] and Petri Nets with Data (DPN), used to perform conformance checking on deviations of data produced by processes [21].", "startOffset": 158, "endOffset": 161}, {"referenceID": 20, "context": "Other examples exist, however, tailored to specific purposes; for instance, Simple Logic Petri Nets (SLPNs), used to perform model-checking of agent programs [5] and Petri Nets with Data (DPN), used to perform conformance checking on deviations of data produced by processes [21].", "startOffset": 275, "endOffset": 279}, {"referenceID": 0, "context": "In psychology, knowledge is traditionally divided between procedural knowledge (the know-how), often implicit and concerned by how to perform actions, and declarative knowledge (the know-what), which is conscious and can be communicated in a verbal form [1].", "startOffset": 254, "endOffset": 257}, {"referenceID": 19, "context": "The intuition that there is a relation between ASP and forward chaining is confirmed in ASPeRiX [20].", "startOffset": 96, "endOffset": 100}, {"referenceID": 22, "context": "This is, very simplistically, the principle behind situation calculus [23,29], event calculus [17,30], and fluent calculus [32].", "startOffset": 70, "endOffset": 77}, {"referenceID": 28, "context": "This is, very simplistically, the principle behind situation calculus [23,29], event calculus [17,30], and fluent calculus [32].", "startOffset": 70, "endOffset": 77}, {"referenceID": 16, "context": "This is, very simplistically, the principle behind situation calculus [23,29], event calculus [17,30], and fluent calculus [32].", "startOffset": 94, "endOffset": 101}, {"referenceID": 29, "context": "This is, very simplistically, the principle behind situation calculus [23,29], event calculus [17,30], and fluent calculus [32].", "startOffset": 94, "endOffset": 101}, {"referenceID": 31, "context": "This is, very simplistically, the principle behind situation calculus [23,29], event calculus [17,30], and fluent calculus [32].", "startOffset": 123, "endOffset": 127}, {"referenceID": 10, "context": "the idea of all Action languages [11].", "startOffset": 33, "endOffset": 37}, {"referenceID": 9, "context": "Even when the dichotomy is made clear, however, operationalizations of these languages often result in compiling action programs to logic programs [10,9], returning to \u2018snapshot-handling\u2019 solutions again.", "startOffset": 147, "endOffset": 153}, {"referenceID": 8, "context": "Even when the dichotomy is made clear, however, operationalizations of these languages often result in compiling action programs to logic programs [10,9], returning to \u2018snapshot-handling\u2019 solutions again.", "startOffset": 147, "endOffset": 153}, {"referenceID": 25, "context": "[26]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "As convincingly noted by [16], there is a widespread confusion in cognitive science and computational disciplines around the notion of rules, primarily because of the lack of neat distinction between declarative rules and reactive rules.", "startOffset": 25, "endOffset": 29}, {"referenceID": 30, "context": "7 The LPPN notation has been first introduced in [31], as a solution to deal with the alignemnt of representations of law (norms), representations of implementations of law (services, i.", "startOffset": 49, "endOffset": 53}, {"referenceID": 6, "context": "From a conceptual point of view, this choice moves towards mirroring the common-sense distinction between objects and events [7], roughly reflecting the prototypical use of the noun/verb categories in language (cf.", "startOffset": 125, "endOffset": 128}, {"referenceID": 14, "context": "[15]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "Coloured Petri Nets (CPN) [14] or Simple Logic Petri Nets (SLPN) [5]\u2014propose to integrate the descriptive function of labels with the executable nature of the net.", "startOffset": 26, "endOffset": 30}, {"referenceID": 4, "context": "Coloured Petri Nets (CPN) [14] or Simple Logic Petri Nets (SLPN) [5]\u2014propose to integrate the descriptive function of labels with the executable nature of the net.", "startOffset": 65, "endOffset": 68}, {"referenceID": 5, "context": "An important contribution of this track is transaction logic programming (TLP) [6].", "startOffset": 79, "endOffset": 82}, {"referenceID": 21, "context": "Operationally, these declarative components will be treated integrating the semantics of answer set programming (ASP) [22].", "startOffset": 118, "endOffset": 122}, {"referenceID": 21, "context": "Answer Set Programming ASP is a declarative programming paradigm [22] based on the stable-model semantic [12], oriented towards difficult (NP-hard) search problems.", "startOffset": 65, "endOffset": 69}, {"referenceID": 11, "context": "Answer Set Programming ASP is a declarative programming paradigm [22] based on the stable-model semantic [12], oriented towards difficult (NP-hard) search problems.", "startOffset": 105, "endOffset": 109}, {"referenceID": 4, "context": "Despite the different notation, we start similarly to the formalization of Simple Logic Petri Nets (SLPN) [5].", "startOffset": 106, "endOffset": 109}, {"referenceID": 2, "context": "also [3,2]), we explicitly refer to event calculus (EC) [17,30], prefiguring future integration with existing literature on linguistic semantics (e.", "startOffset": 5, "endOffset": 10}, {"referenceID": 1, "context": "also [3,2]), we explicitly refer to event calculus (EC) [17,30], prefiguring future integration with existing literature on linguistic semantics (e.", "startOffset": 5, "endOffset": 10}, {"referenceID": 16, "context": "also [3,2]), we explicitly refer to event calculus (EC) [17,30], prefiguring future integration with existing literature on linguistic semantics (e.", "startOffset": 56, "endOffset": 63}, {"referenceID": 29, "context": "also [3,2]), we explicitly refer to event calculus (EC) [17,30], prefiguring future integration with existing literature on linguistic semantics (e.", "startOffset": 56, "endOffset": 63}, {"referenceID": 17, "context": "[18]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "10 Stable-model semantics apply ideas of auto-epistemic logic [24] and default logic [28].", "startOffset": 62, "endOffset": 66}, {"referenceID": 27, "context": "10 Stable-model semantics apply ideas of auto-epistemic logic [24] and default logic [28].", "startOffset": 85, "endOffset": 89}, {"referenceID": 16, "context": "Event Calculus axioms An existing solution to treat change in logic programming is event calculus (EC) [17,30].", "startOffset": 103, "endOffset": 110}, {"referenceID": 29, "context": "Event Calculus axioms An existing solution to treat change in logic programming is event calculus (EC) [17,30].", "startOffset": 103, "endOffset": 110}, {"referenceID": 7, "context": "For instance, running our example with the ASP engine clingo [8], we obtain: 14 The full code of the example is available online at http://justinian.", "startOffset": 61, "endOffset": 64}, {"referenceID": 30, "context": ") using LPPN can be found in [31].", "startOffset": 29, "endOffset": 33}, {"referenceID": 24, "context": "For instance, execution algorithms alternative to brute execution [25,27]; or decomposition techniques, for instance in single-entry-single-exit (SESE) components [26], that open up the possibility of concurrent execution.", "startOffset": 66, "endOffset": 73}, {"referenceID": 26, "context": "For instance, execution algorithms alternative to brute execution [25,27]; or decomposition techniques, for instance in single-entry-single-exit (SESE) components [26], that open up the possibility of concurrent execution.", "startOffset": 66, "endOffset": 73}, {"referenceID": 25, "context": "For instance, execution algorithms alternative to brute execution [25,27]; or decomposition techniques, for instance in single-entry-single-exit (SESE) components [26], that open up the possibility of concurrent execution.", "startOffset": 163, "endOffset": 167}, {"referenceID": 10, "context": "the already cited Action languages [11], related works (e.", "startOffset": 35, "endOffset": 39}, {"referenceID": 18, "context": "F2LP [19]) and applications (CCalc, Coala, Cplus2ASP); optimized versions of Event Calculus (e.", "startOffset": 5, "endOffset": 9}, {"referenceID": 3, "context": "[4]); applications based on LTL, CTL and related formalisms.", "startOffset": 0, "endOffset": 3}], "year": 2017, "abstractText": "With the purpose of modeling, specifying and reasoning in an integrated fashion with procedural and declarative aspects (both commonly present in cases or scenarios), the paper introduces Logic Programming Petri Nets (LPPN), an extension to the Petri Net notation providing an interface to logic programming constructs. Two semantics are presented. First, a hybrid operational semantics that separates the process component, treated with Petri nets, from the constraint/terminological component, treated with Answer Set Programming (ASP). Second, a denotational semantics maps the notation to ASP fully, via Event Calculus. These two alternative specifications enable a preliminary evaluation in terms of reasoning efficiency.", "creator": "LaTeX with hyperref package"}}}