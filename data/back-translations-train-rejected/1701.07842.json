{"id": "1701.07842", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Jan-2017", "title": "Learning Asynchronous Typestates for Android Classes", "abstract": "In event-driven programming frameworks, such as Android, the client and the framework interact using callins (framework methods that the client invokes) and callbacks (client methods that the framework invokes). The protocols for interacting with these frameworks can often be described by finite-state machines we dub *asynchronous typestates*. Asynchronous typestates are akin to classical typestates, with the key difference that their outputs (callbacks) are produced asynchronously.", "histories": [["v1", "Thu, 26 Jan 2017 19:06:45 GMT  (81kb,D)", "http://arxiv.org/abs/1701.07842v1", "Submitted to CAV 2017"]], "COMMENTS": "Submitted to CAV 2017", "reviews": [], "SUBJECTS": "cs.LO cs.LG cs.PL", "authors": ["arjun radhakrishna", "nicholas lewchenko", "shawn meier", "sergio mover", "krishna chaitanya sripada", "damien zufferey", "bor-yuh evan chang", "pavol \\v{c}ern\\'y"], "accepted": false, "id": "1701.07842"}, "pdf": {"name": "1701.07842.pdf", "metadata": {"source": "CRF", "title": "Learning Asynchronous Typestates for Android Classes", "authors": ["Arjun Radhakrishna", "Nicholas Lewchenko", "Shawn Meier", "Sergio Mover", "Krishna Chaitanya Sripada", "Damien Zufferey", "Bor-Yuh Evan Chang", "Pavol \u010cern\u00fd"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "In fact, it is the case that most of them will be able to move into a different world, in which they are able to move, in which they move, in which they move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they live, in which they, in which they live, in which they live."}, {"heading": "2 Illustrative Example", "text": "Consider the asynchronous typing in Figure 1, taken from the documentation for the Android class called MediaPlayer. Callins are represented by single arrows and callbacks by double arrows. Consider a part of the protocol that regulates the interaction between client and framework. First, the client calls the callin setDataSource () and the protocol transitions to the initialized state. In this state, the client can call the callin prepareAsync (), and the protocol transitions to the preparation state. In the preparation state, the client cannot call callins, but the framework can call the onPrepared () callback, and then the protocol transitions to the prepared state. Only at this point can the client call the start () callin, and the media begin to play."}, {"heading": "3 The Asynchronous Typestate Learning Problem", "text": "We present interface models, define the asynchronous typing problem and present an impossibility result when learning typing."}, {"heading": "3.1 Definitions and Problem Statement", "text": "We abstract parameters and return values of callins and callbacks and model a behavior of the interface as a predetermined sequence of all possible traces of the interface automata. We use interface automata [12] to represent asynchronous interfaces. An interface automata A is defined by < Q, qando, squando, squando, quando, quando, quando, quando, quando, quando, quando, quando, quando, quando, quando, quando, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo, quo"}, {"heading": "3.2 The Theory and Practice of Learning Typestates", "text": "In general, it is impossible to learn asynchronous typing that only uses membership issues; \u00b7 no finite series of membership requests remedies a unique interface automaton (see Appendix B for a formal statement). However, asynchronous typing can be effectively learned as additional assumptions are made. In the following, we will analyze the causes behind the impossibility and highlight the assumption that is necessary to overcome it. Unlimited asynchronization alone does not tell us whether the interface sends more outputs (callbacks) at any given time. Therefore, we assume: Assumption 1: quiescence is observable. This assumption is commonly used in ioco test systems [33]. In our environment, we add an input wait time and an output rest, where silence is returned only after a wait time if there are no other pending callbacks. In practice, rest can be implemented using timeouts, i.e. pending callbacks are accepted to arrive within a fixed time span."}, {"heading": "4 Learning Asynchronous Typestates using L\u2217", "text": "Assuming 1 and Assumption 3, we first build a \"synchronous shutter\" of an asynchronous interface (Section 4.1) and then show how to effectively learn the synchronous shutter under Assumption 2 (Section 4.2 and 4.3)."}, {"heading": "4.1 From Asynchronous to Synchronous Interfaces", "text": "Assuming 1 and 3, we build a synchronous version of an interface in which inputs and outputs alternate strictly according to [1]. In the case of synchronous interfaces, we can derive learning techniques from existing work [5,1,22,28]. Let us define that inputs and outputs are equal to Q. The purpose of the additional inputs and outputs is discussed below. Synchronous closure is an asynchronous interface I = < Answer i = Qi."}, {"heading": "4.2 L\u2217: Learning Mealy Machines", "text": "For the sake of completeness, we describe the classical L-shaped learning algorithm Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-"}, {"heading": "4.3 An Equivalence Oracle using Membership Queries", "text": "Given a black box interface in practice, it is not feasible to Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-"}, {"heading": "4.4 Putting it all together", "text": "Theorem 5. In view of a deterministic interface I with observable rest and the membership oracle MOracle [I]. Suppose there exists an interface automaton A with n states with differentiated BDist modeling of type I. Interface automaton A can be learned with O (| i | \u00b7 n3 + n \u00b7 | BDist) membership queries. Proof sketch. Starting from an asynchronous interface I and a membership oracle MOracle [I] we can construct the membership oracle MOracle [Is] for the synchronous closure Is of I. In view of the distinction limit (or a state limited by acceptance 2 and theorem 3) we can construct an equivalence oracle EOracle [Is] with the help of typology 2."}, {"heading": "5 Applying Active Learning to Android", "text": "We have implemented our method in a tool called Starling. In this section we describe how it works, the practical challenges we faced when working with Android, and our solutions to overcome them. Starling is implemented as an Android application and learns asynchronous spellings within Android."}, {"heading": "5.1 Designing an Experiment", "text": "An experiment is a small code harness that covers the usual inputs of an active learning algorithm, as well as the specific inputs for learning on Android. The main components are: Class of Study. Starling learns the typestate of Java classes. The user specifies this learning class and provides a constructor and optionally a destructor that can be used to reset the environment and isolate membership requests Distinguisher Bound. If known, the distinction boundary can be set directly. Otherwise, it can be obtained from Adoption 2 by Theorem 3. Instrumented Alphabet specifies an abstract alphabet for the learning algorithm and the translation between the abstract alphabet and concrete callbacks / callbacks of the learning class. Query Filter. The user can restore the order of symbols in the alphabet with a filter for sequences that are already known or uninteresting."}, {"heading": "5.2 Observing Asynchronous Callbacks", "text": "In our approach, we assume a limited asynchrony (assumption 1) and can therefore observe when the interface does not produce new output (rest). We implement this assumption on a real system with timeouts: The query algorithm waits for a new output for a specified period of time tmax, provided that rest is reached when this time has expired. However, Android does not offer the worst possible execution time for the asynchronous operations and we rely on the user to select a sufficiently large tmax. The membership query also assumes the existence of a minimum period of time tmin before a call back. This ensures that we can execute a membership query with two consecutive calls (i.e. without an intermediate wait), i.e. we have the time to execute the second call before the output of the first call occurs before the output of the first call."}, {"heading": "5.3 Checking and Enforcing our Assumptions", "text": "In fact, we are in a position to change the world without being able to control it."}, {"heading": "6 Empirical Evaluation", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "7 Related Work", "text": "Work that automatically synthesizes specifications of valid sequences of method calls (e.g. [3,30,4,16]) typically ignores asynchronous callbacks. Static analysis has been used successfully to derive specifications of types (important, without callbacks) [3,20,30]. The work in [3] suggests interfaces for Java classes that use L classes. In contrast, our approach is based on testing. Therefore, we avoid the practical problem of abstracting the frame code. Unlike dynamic mining, we do not rely on the availability of client applications or on a set of execution histories. The L algorithm guides the use of client program execution histories through a framework to another common approach [4,36,2,11,15,34,37,25]. Unlike dynamic mining, we do not rely on the availability of client applications or a set of executables."}, {"heading": "36. John Whaley, Michael C. Martin, and Monica S. Lam. Automatic extraction of", "text": "In Proceedings of the 2002 ACM SIGSOFT International Symposium on Software Testing and Analysis, ISSTA '02, pp. 218-228, New York, NY, USA, 2002. ACM. 37. Jinlin Yang, David Evans, Deepali Bhardwaj, Thirumalesh Bhat, and Manuvir Das. Perracotta: Mining temporal api rules from imperfect traces. In Proceedings of the 28th International Conference on Software Engineering, ICSE' 06, pp. 282-291, New York, NY, USA, 2006. ACM."}, {"heading": "A Detailed Descriptions of the Results", "text": "In fact, most of us will be able to play by the rules they have established in the past."}, {"heading": "C Proofs for theorems in Section 4", "text": "\u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2"}], "references": [{"title": "Learning I/O automata", "author": ["F. Aarts", "F. Vaandrager"], "venue": "CONCUR", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2010}, {"title": "Mining interface specifications for generating checkable robustness properties", "author": ["M. Acharya", "T. Xie", "J. Xu"], "venue": "In Software Reliability Engineering,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Synthesis of interface specifications for Java classes", "author": ["R. Alur", "P. \u010cern\u00fd", "P. Madhusudan", "W. Nam"], "venue": "In POPL,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Mining specifications", "author": ["Glenn Ammons", "Rastislav Bod\u0301\u0131k", "James R. Larus"], "venue": "In POPL,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2002}, {"title": "Learning regular sets from queries and counterexamples", "author": ["Dana Angluin"], "venue": "Inf. Comput.,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1987}, {"title": "FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps", "author": ["Steven Arzt", "Siegfried Rasthofer", "Christian Fritz", "Eric Bodden", "Alexandre Bartel", "Jacques Klein", "Yves Le Traon", "Damien Octeau", "Patrick McDaniel"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Scalable race detection for android applications", "author": ["Pavol Bielik", "Veselin Raychev", "Martin T. Vechev"], "venue": "In OOPSLA,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Selective control-flow abstraction via jumping", "author": ["Sam Blackshear", "Bor-Yuh Evan Chang", "Manu Sridharan"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "Edgeminer: Automatically detecting implicit control flow transitions through the android framework", "author": ["Yinzhi Cao", "Yanick Fratantonio", "Antonio Bianchi", "Manuel Egele", "Christopher Kruegel", "Giovanni Vigna", "Yan Chen"], "venue": "In NDSS,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "Testing software design modeled by finite-state machines", "author": ["T.S. Chow"], "venue": "IEEE Transactions on Software Engineering,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1978}, {"title": "Mining object behavior with adabu", "author": ["Valentin Dallmeier", "Christian Lindig", "Andrzej Wasylkowski", "Andreas Zeller"], "venue": "In Proceedings of the 2006 International Workshop on Dynamic Systems Analysis,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Apposcopy: Semantics-based detection of Android malware through static analysis", "author": ["Yu Feng", "Saswat Anand", "Isil Dillig", "Alex Aiken"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2014}, {"title": "Ghedamsi. Test selection based on finite state models", "author": ["S. Fujiwara", "G. v. Bochmann", "F. Khendek", "M. Amalou"], "venue": "IEEE Transactions on Software Engineering,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1991}, {"title": "Javert: Fully automatic mining of general temporal properties from dynamic traces", "author": ["Mark Gabel", "Zhendong Su"], "venue": "In Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering, SIGSOFT \u201908/FSE16,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Online inference and enforcement of temporal properties", "author": ["Mark Gabel", "Zhendong Su"], "venue": "In ICSE,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "A method for the design of fault detection experiments", "author": ["Guney Gonenc"], "venue": "IEEE Trans. Computers,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1970}, {"title": "Information-flow analysis of Android applications in DroidSafe", "author": ["Michael I. Gordon", "Deokhwan Kim", "Jeff Perkins", "Limei Gilham", "Nguyen Nguyen", "Martin Rinard"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Fault detecting experiments for sequential circuits", "author": ["F.C. Hennie"], "venue": "In 5th Annual Symposium on Switching Circuit Theory and Logical Design, Princeton,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1964}, {"title": "Permissive interfaces", "author": ["Thomas A. Henzinger", "Ranjit Jhala", "Rupak Majumdar"], "venue": "In Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2005}, {"title": "Race detection for event-driven mobile applications", "author": ["Chun-Hung Hsiao", "Jie Yu", "Satish Narayanasamy", "Ziyun Kong", "Cristiano L. Pereira", "Gilles A. Pokam", "Peter M. Chen", "Jason Flinn"], "venue": "In PLDI,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2014}, {"title": "Domain-specific optimization in automata learning", "author": ["H. Hungar", "O. Niese", "B. Steffen"], "venue": "In CAV,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}, {"title": "Static analysis of event-driven node.js javascript applications", "author": ["Magnus Madsen", "Frank Tip", "Ond\u0159ej Lhot\u00e1k"], "venue": "In OOPSLA,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2015}, {"title": "Race detection for android applications", "author": ["Pallavi Maiya", "Aditya Kanade", "Rupak Majumdar"], "venue": "PLDI", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2014}, {"title": "Automatic generation of object usage specifications from large method traces", "author": ["Michael Pradel", "Thomas R. Gross"], "venue": "In ASE,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Inference of finite automata using homing sequences", "author": ["Ronald L. Rivest", "Robert E. Schapire"], "venue": "Inf. Comput.,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1993}, {"title": "A new technique for generating protocol test", "author": ["Krishan K. Sabnani", "Anton T. Dahbura"], "venue": "Proceedings of the Ninth Symposium on Data Communications, British Columbia,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1985}, {"title": "Inferring mealy machines. In FM 2009: Formal Methods, Second World Congress, Eindhoven, The Netherlands, November", "author": ["Muzammil Shahbaz", "Roland Groz"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "A Second Course in Formal Languages and Automata Theory", "author": ["J. Shallit"], "venue": null, "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "Static specification mining using automata-based abstractions", "author": ["Sharon Shoham", "Eran Yahav", "Stephen Fink", "Marco Pistoia"], "venue": "In ISSTA,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2007}, {"title": "Fail fast [software debugging", "author": ["J. Shore"], "venue": "IEEE Software,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2004}, {"title": "Typestate: A programming language concept for enhancing software reliability", "author": ["R. Strom", "S. Yemini"], "venue": "IEEE Trans. Software Eng.,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1986}, {"title": "On the relationship between process algebra and input/output automata", "author": ["Frits W. Vaandrager"], "venue": "In Proceedings of the Sixth Annual Symposium on Logic in Computer Science (LICS \u201991),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1991}, {"title": "Inferring finite-state models with temporal constraints", "author": ["N. Walkinshaw", "K. Bogdanov"], "venue": "In Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2008}, {"title": "Amandroid: A precise and general inter-component data flow analysis framework for security vetting of android apps", "author": ["Fengguo Wei", "Sankardas Roy", "Xinming Ou", "Robby"], "venue": "In SIGSAC,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}, {"title": "Automatic extraction of object-oriented component interfaces", "author": ["John Whaley", "Michael C. Martin", "Monica S. Lam"], "venue": "In Proceedings of the 2002 ACM SIGSOFT International Symposium on Software Testing and Analysis,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2002}], "referenceMentions": [{"referenceID": 30, "context": "Typestates [32] were introduced to describe synchronous interfaces that specify order of method calls.", "startOffset": 11, "endOffset": 15}, {"referenceID": 4, "context": "The core algorithm is based on Angluin\u2019s L\u2217 algorithm [5] adapted to Mealy machines [28].", "startOffset": 54, "endOffset": 57}, {"referenceID": 26, "context": "The core algorithm is based on Angluin\u2019s L\u2217 algorithm [5] adapted to Mealy machines [28].", "startOffset": 84, "endOffset": 88}, {"referenceID": 9, "context": "Unfortunately, the equivalence check implemented in this way (as is done in previous algorithms [10,14] for conformance testing) is exponential in k.", "startOffset": 96, "endOffset": 103}, {"referenceID": 12, "context": "Unfortunately, the equivalence check implemented in this way (as is done in previous algorithms [10,14] for conformance testing) is exponential in k.", "startOffset": 96, "endOffset": 103}, {"referenceID": 29, "context": "Such APIs are coded defensively and are fail-fast [31], i.", "startOffset": 50, "endOffset": 54}, {"referenceID": 31, "context": "This assumption is commonly used in ioco-testing frameworks [33].", "startOffset": 60, "endOffset": 64}, {"referenceID": 0, "context": "See [1] for a detailed theoretical discussion of how non-determinism affects learnability.", "startOffset": 4, "endOffset": 7}, {"referenceID": 0, "context": "Using Assumption 1 and 3, we build a synchronous version of an interface in which inputs and outputs strictly alternate following [1].", "startOffset": 130, "endOffset": 133}, {"referenceID": 4, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 0, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 20, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 26, "context": "For synchronous interfaces, we can draw learning techniques from existing work [5,1,22,28].", "startOffset": 79, "endOffset": 90}, {"referenceID": 4, "context": "For the sake of completeness, we describe the classical L\u2217 learning algorithm by Angluin [5] as adapted to Mealy machines in [28].", "startOffset": 89, "endOffset": 92}, {"referenceID": 26, "context": "For the sake of completeness, we describe the classical L\u2217 learning algorithm by Angluin [5] as adapted to Mealy machines in [28].", "startOffset": 125, "endOffset": 129}, {"referenceID": 24, "context": "For the full description of the choice of suffix, see [26,28].", "startOffset": 54, "endOffset": 61}, {"referenceID": 26, "context": "For the full description of the choice of suffix, see [26,28].", "startOffset": 54, "endOffset": 61}, {"referenceID": 26, "context": "Theorem 1 ([28]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 9, "context": "Popular conformance testing algorithms, like the W-method [10] and the Wpmethod [14], are based on state bounds and have an unavoidable O(|\u03a3\u0303i|State)", "startOffset": 58, "endOffset": 62}, {"referenceID": 12, "context": "Popular conformance testing algorithms, like the W-method [10] and the Wpmethod [14], are based on state bounds and have an unavoidable O(|\u03a3\u0303i|State)", "startOffset": 80, "endOffset": 84}, {"referenceID": 17, "context": "The other common algorithm, the D-method [19,17], does not apply in our setting either.", "startOffset": 41, "endOffset": 48}, {"referenceID": 15, "context": "The other common algorithm, the D-method [19,17], does not apply in our setting either.", "startOffset": 41, "endOffset": 48}, {"referenceID": 25, "context": "For similar reasons, conformance testing algorithms such as the UIO-method [27] do not apply either.", "startOffset": 75, "endOffset": 79}, {"referenceID": 0, "context": "The Query Filter and the Instrumented Alphabet together comprise a Learning Purpose [1], i.", "startOffset": 84, "endOffset": 87}, {"referenceID": 0, "context": "Hence, in such cases, we use the technique of learning purposes [1] to learn a regular approximations of the infinite typestate.", "startOffset": 64, "endOffset": 67}, {"referenceID": 2, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 28, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 3, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 14, "context": "[3,30,4,16]) typically ignore the asynchronous callbacks.", "startOffset": 0, "endOffset": 11}, {"referenceID": 2, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 18, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 28, "context": "Static analysis has been successfully used to infer typestates specifications (importantly, without callbacks) [3,20,30].", "startOffset": 111, "endOffset": 120}, {"referenceID": 2, "context": "The work in [3] infers interfaces for Java classes using L\u2217.", "startOffset": 12, "endOffset": 15}, {"referenceID": 3, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 34, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 1, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 10, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 13, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 32, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 23, "context": "Inferring the interface using execution traces of client programs using framework is another common approach [4,36,2,11,15,34,37,25].", "startOffset": 109, "endOffset": 132}, {"referenceID": 5, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 7, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 8, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 21, "context": "[6,8,9,23]).", "startOffset": 0, "endOffset": 10}, {"referenceID": 5, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 7, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 16, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 33, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 11, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 118, "endOffset": 132}, {"referenceID": 22, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 19, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 6, "context": "Analyses of Android applications mostly focus on either statically proving program correctness or security properties [6,8,18,35,13] or dynamically detecting race conditions [24,21,7].", "startOffset": 174, "endOffset": 183}, {"referenceID": 4, "context": "Our work builds on the seminal paper of Angluin [5] and the subsequent extensions and optimizations.", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "In particular, we build on L\u2217 for I/O automata [1,28].", "startOffset": 47, "endOffset": 53}, {"referenceID": 26, "context": "In particular, we build on L\u2217 for I/O automata [1,28].", "startOffset": 47, "endOffset": 53}, {"referenceID": 24, "context": "The optimizations we use include the counterexample suffix analysis from [26] and the optimizations for prefix-closed languages from [22].", "startOffset": 73, "endOffset": 77}, {"referenceID": 20, "context": "The optimizations we use include the counterexample suffix analysis from [26] and the optimizations for prefix-closed languages from [22].", "startOffset": 133, "endOffset": 137}, {"referenceID": 9, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 12, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 17, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 15, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}, {"referenceID": 25, "context": "The relation to conformance testing methods [10,14,19,17,27] has been discussed in Remark 2.", "startOffset": 44, "endOffset": 60}], "year": 2017, "abstractText": "In event-driven programming frameworks, such as Android, the client and the framework interact using callins (framework methods that the client invokes) and callbacks (client methods that the framework invokes). The protocols for interacting with these frameworks can often be described by finite-state machines we dub asynchronous typestates. Asynchronous typestates are akin to classical typestates, with the key difference that their outputs (callbacks) are produced asynchronously. We present an algorithm to infer asynchronous typestates for Android framework classes. It is based on the L\u2217 algorithm that uses membership and equivalence queries. We show how to implement these queries for Android classes. Membership queries are implemented using testing. Under realistic assumptions, equivalence queries can be implemented using membership queries. We provide an improved algorithm for equivalence queries that is better suited for our application than the algorithms from literature. Instead of using a bound on the size of the typestate to be learned, our algorithm uses a distinguisher bound. The distinguisher bound quantifies how two states in the typestate are locally different. We implement our approach and evaluate it empirically. We use our tool, Starling, to learn asynchronous typestates for Android classes both for cases where one is already provided by the documentation, and for cases where the documentation is unclear. The results show that Starling learns asynchronous typestates accurately and efficiently. Additionally, in several cases, the synthesized asynchronous typestates uncovered surprising and undocumented behaviors.", "creator": "TeX"}}}