{"id": "1701.08191", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jan-2017", "title": "Incremental Maintenance Of Association Rules Under Support Threshold Change", "abstract": "Maintenance of association rules is an interesting problem. Several incremental maintenance algorithms were proposed since the work of (Cheung et al, 1996). The majority of these algorithms maintain rule bases assuming that support threshold doesn't change. In this paper, we present incremental maintenance algorithm under support threshold change. This solution allows user to maintain its rule base under any support threshold.", "histories": [["v1", "Fri, 27 Jan 2017 21:02:52 GMT  (569kb)", "http://arxiv.org/abs/1701.08191v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["mohamed anis bach tobji", "mohamed salah gouider"], "accepted": false, "id": "1701.08191"}, "pdf": {"name": "1701.08191.pdf", "metadata": {"source": "CRF", "title": "INCREMENTAL MAINTENANCE OF ASSOCIATION RULES UNDER SUPPORT THRESHOLD CHANGE", "authors": ["Mohamed Anis BACH TOBJI", "Mohamed Salah GOUIDER"], "emails": ["anis.bach@isg.rnu.tn", "ms.gouider@isg.rnu.tn"], "sections": [{"heading": null, "text": "Since the work of Cheung et al., 1996, several incremental maintenance algorithms have been proposed, the majority of which maintain basic rules under the assumption that the support threshold will not change. In this paper, we present an incremental maintenance algorithm under the modification of the support threshold. This solution allows the user to maintain his rule base under each support threshold."}, {"heading": "KEYWORDS", "text": "Association rules, incremental maintenance."}, {"heading": "1. INTRODUCTION", "text": "The problem of association rules mining (ARM) (Agrawal et al, 1993) receives a lot of attention. This attention is motivated by several fields of application such as market basket analysis, telecommunications analysis, web logs analysis, etc. Several ARM algorithms were designed to solve this problem (Agrawal and Srikant, 1994), (Savasere et al, 1995), (Zaki et al, 1997), (Pasquier et al, 1999), (Han et al, 2000), which calculate association rules that describe a data set. Nevertheless, data sources are frequently updated. It follows that extracted rules describe a data set at a moment, the mining moment. This change in data implies the invalidity of rules and the need to maintain them. Several algorithms of incremental maintenance have been proposed (Cheung et al, 1996), (Tsai et al, 1999), (Zhang et, 1997), the first algorithm called UP was achieved in 1996."}, {"heading": "2. PROBLEM DESCRIPTION", "text": "Let me be a set of n elements, I = {i1, i2, i3,...., in}. Let BD be a database of D transactions with schema < tid, items >. Each transaction is in I. An association rule is XY with X, Y I, X and X-Y = \u00f8. Rule support is the number of occurrences of XY in BD, and their trust is support (XY) / support (X). Given a minimum support threshold s% and a minimum confidence threshold c%, the ARM problem (Agrawal et al, 1993) is to find out all association rules that exceed support s% and trust c%. An item set is a set of items. It said that in BD it often occurs when its support in BD (X.supportBD) exceeds s% (X.supportBD) (X.Bortal, 1993, c, find the problem is to fix all trust and%)."}, {"heading": "3. THE IMSC APPROACH", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3.1 Winner, loser and persistent itemsets", "text": "To solve this problem, we propose a new approach, which we call IMSC (Incremental Maintenance of Association Rules under Support threshold Change), based on the FUP (Fast UPdate) algorithm (Cheung et al., 1996). FUP maintains a rule base that is incrementally below the same support threshold. If s = s', IMSC and FUP are practically identical, let BD '= BDbd. BD \"contains four types of articles: Winning articles that are not s-frequent in BD (F) and that are s-frequent in BD (F).\" Stable article sentences that are s-frequent in BD (F) and winner-frequent in BD (F). Loser-article-article-sets-often in BD (F). Loser-article-article-sets-often in BD (F) and article-frequently in BD (F)."}, {"heading": "3.2 Description of IMSC", "text": "The IMSC algorithm searches the search space (item sets grid) in the first width; it calculates frequent item sets layer by layer. In other words, it calculates frequent item sets of size i before calculating item sets of size i + 1. For each grid level, frequent item sets are calculated in two steps. Suppose we want to create the set F'i (set S 'frequent item sets of size i), IMSC proceeds as follows:"}, {"heading": "I \u2013 IMSC scans bd :", "text": "1- Generation of Ci, set of candidate pieces of size i. Ci = Apriori _ gen (Fi-1) / Fi. Apriori _ gen includes Apriori candidate generation function defined in (Agrawal and Srikant, 1994). We eliminate the set Fi because it is dealt with in the next phase (II). 2- During the scanning of bd we update the support for Fi and Ci.3- We insert in F'i persistent elements generated from Fi (X.supportBD '\u2265 s' (D + d)). 4- The set Ci contains possible winners. A candidate set X is a possible winner if its support in bd exceeds the CPT detected by Candidate Pruning Threshold (see problem 1). Lemma 1 (Candidate Pruning Threshold) A candidate set X is a possible winner in BD 'if and only if its support in bd exceeds the threshold CPT + CT (1.0)."}, {"heading": "X is a possible winner if :", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "X.supportBD\u2019 \u2265 s\u2019\u00d7(d+D)  X.supportbd+X.supportBD \u2265 s\u2019\u00d7(d+D)  X.supportbd \u2265 s\u2019\u00d7(d+D) - X.supportBD", "text": "We know that XF, so X.supportBD < s \u00b7 D, is the maximum support value of X in BD (s \u00b7 D -1). X.supportbd \u2265 s' (d + D) - s \u00b7 D + 1 X.supportbd \u2265 s' \u00b7 d + D \u00b7 (s' -s) + 1.III- IMSC scans BD: 1- Updating candidate itemsets supports. In the end, we have their support in BD '.2- Insertion of winner itemsets in F'i.IMSC iterates n + 1 times to compute F', where n is the size of the longest s' -frequent itemsets. Just like FUP, the return to BD is achieved to match the winning itemsets of candidate itemsets in F'i.IMSC iterates n + 1 times to compute F ', where n is the size of the longest s' -frequent itemsets in T."}, {"heading": "3.3 IMSC algorithm", "text": "In this section, we present the IMSC algorithm, which consists of three procedures; each procedure responds to a scenario. The description of the algorithm is given in pseudo-code comments:"}, {"heading": "IMSC Algorithm :", "text": "Input: BD: Initial Database.D: Cardinal of BD.bd: Data increment.d: Cardinal of bd.F = Fk (Union of Sentences Fk).s: Support, under the F computed.s \": Support, under which we want to maintain F.Output:"}, {"heading": "F\u2019= F\u2019k (Union of sets F\u2019k).", "text": "Algorithm: Starts01 cpt = s '\u00b7 d / 100 + D \u00b7 (s '-s) / 100 + 1 / * CPT Calculation using algorithm parameters and comfortable method execution * / 02 If cpt \u2264 d and cpt > 0 then03 IMSC1 (BD, D, bd, d, F) 04 ElseIf cpt < 1 Then05 IMSC2 (BD, D, bd, F) 06 Else07 IMSC3 (BD, D, bd, d, F) 08 EndIfEnd"}, {"heading": "IMSC1 Procedure", "text": "Same input and output from IMSC."}, {"heading": "Begin", "text": "01 F [1].CopyIn (Fk) / * Fk contains in BD * / 02 Scanbd (Fk, Ck) / * During the scanning of bd supports of F1 are updated and C1 is created * / 03 min _ supp = s '\u00d7 (d + D) / 10004 Fk.Prune (min _ supp) / * Elements of F1 that do not exceed s' frequency in BD 'are discarded * / 05 cpt = s' \u00b7 d / 100 + D \u00d7 (s' -s) / 10006 Ck.Prune (cpt) / * Elements of C1 that do not exceed s' frequency in BD 'are discarded * / 07 ScanBD (Ck) / * During the scanning of BD supports of C1 are updated * / 08 Ck.Prune (min _ supp) / * Only elements of C1 that do not exceed s' frequency in BD 'are discarded in C1 / k (Ck) / F * (Union is * *)."}, {"heading": "10 While (F\u2019k.Empty = false) Do /*F\u2019", "text": "The calculation is done on level * / 11 F '.Insert (F'k) / * F'k becomes in F '/ / 12 k = k + 1 / * Going next level * / 13 F [k].CopyIn (Fk) 14 Apriori _ gen (Ck, F'k) / * Making Ck that isAprioi _ gen of F'k * / 15 Fk = Fk.Intersect (Ck) / * Only items belonging to FkCk can be persistent, they only need a bd-scan, because we supportin bd * / 16 Ck = Ck.Minus (Fk) / * Other Ck-items need aBD'scan, because we support them in BD * / 17 Scanbd (Fk, Ck) / * Endsets of Computing itemsets supportin bd for Fk and Ck * / 18 Fk.Prune Whist (min _ supp) / Disk-Sets (Fk-Sk *, Ck-Sk-Sk *)"}, {"heading": "IMSC2 Procedure", "text": "Same input and output of IMSC.Begin01 F [1].CopyIn (Fk) 02 Scanbd (Fk, Ck) 03 min _ supp = s '\u00d7 (d + D) / 10004 Fk.Prune (min _ supp) 05 ScanBD (Ck, F [1]) / * Elements that do not belong to C1 and F [1] are inserted in C1; they can s' -frequently inBD '* / 06 Ck.Prune (min _ supp) 07 F'k = Union (Fk, Ck) 08 While (F'k.Empty = false) Do09 F'.Insert (F'k) 10 k = k + 111 F [k].CopyIn (Fk) 12 Apriori _ gen (Ck, F'k) 13 Ck = Ck.Minus (Fk) 14 Scanbd (Fk, Ck) 15 ScanBD (C.Prk.Prune (Ck) 16 Prk _ F (17)"}, {"heading": "IMSC3 Procedure", "text": "Same input and output of IMSC.Begin01 F [1].CopyIn (Fk) 02 Scanbd (Fk) 03 min _ supp = s '( d + D) / 10004 Fk.Prune (min _ supp) 05 F'k = Union (Fk, Ck) 06 While (F'k.Empty = false) Do07 F '.Insert (F'k) 08 k = k + 109 F [k].CopyIn (Fk) 10 Scanbd (Fk) 11 Fk.Prune (min _ supp) 12 F'k = Union (Fk, Ck) 13 EndWhileEnd"}, {"heading": "3.4 IMSC example", "text": "The IMSC process three possible scenarios for maintaining the frequency of patterns below the support threshold Change = 1. Let's have an initial BD database (see Figure 1), an increment bd and different values of s and s. \"Following, we run IMSC to obtain F's, i.e., to calculate F's: First scenario: 0 < CPT \u2264 dLet s = 30%, then F's is {A7, B5, C6, D4, BC4, CD3}. Let bd is an increase in data containing the following transactions (each transaction is a double). (Tid, Items)): {B4, BD, D4, BCC4, BC4, BCCC4, BC4.\" We have d = 3.Let's an increase in transactions with the following transactions (cps)."}, {"heading": "4. PERFORMANCE STUDY", "text": "In this section, we present experiments to test the efficiency of IMSC. We implemented IMSC and Apriori and tested them on synthetic dataset T5.I2.D100 k. Generation synthetic dataset follows the same technique as (Agrawal et al, 1993).In the first experimental phase, we divided the database into two partitions: BD, which consists of 70K transactions, and BD, which consists of 30K transactions. Initial extraction occurs on BD after a support threshold of 30%. As a result, this extraction in F, s% and F, we executed IMSC to reach the maintenance threshold of 1% to 60%. In the same way, we will apply the frequent itemsets of this extraction."}, {"heading": "5. CONCLUSION AND PERSPECTIVES", "text": "Many other ARM algorithms are more efficient when it comes to correlated databases (Pasquier et al., 1999), (Bastide et al., 2002). It is interesting to develop methods for incremental maintenance under different types of constraints and not just the antimonotonous constraints as for IMSC. Many algorithms use the idea of incremental maintenance in inductive databases (Imielinski et al., 1995), i.e. the gradual maintenance of patterns under different types of constraints and not just the antimonotonous constraints as for IMSC. Many algorithms use the vertical representation of databases (Eclat et al., 1997), partition (Savasere et al., 1995), etc.)."}], "references": [{"title": "Mining Association Rules Between Sets of Items in Large Databases", "author": ["R. Agrawal", "T. Imielinski", "A Swami"], "venue": "In Proceedings ACM SIGMOD International Conference on Management of Data, Washington DC,", "citeRegEx": "Agrawal et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Agrawal et al\\.", "year": 1993}, {"title": "Fast Algorithms for Mining Association Rules", "author": ["R. Agrawal", "R Srikant"], "venue": "In Proceedings of the 20th International Conference on Very Large Data Bases (VLDB\u201994),", "citeRegEx": "Agrawal and Srikant,? \\Q1994\\E", "shortCiteRegEx": "Agrawal and Srikant", "year": 1994}, {"title": "Pascal : un algorithme d'extraction des motifs fr\u00e9quents", "author": ["Y. Bastide", "R. Taouil", "N. Pasquier", "G. Stumme", "L Lakhal"], "venue": "Techniques et Science Informatiques, Herme\u0300s Science,", "citeRegEx": "Bastide et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Bastide et al\\.", "year": 2002}, {"title": "Maintenance of Discovered Association Rules in Large Databases : An Incremental Update technique", "author": ["Cheung", "D-W", "J. Han", "Ng", "V-T", "Wang", "C-Y"], "venue": "In Proceedings of The Twelf International Conference on Data Engineering,", "citeRegEx": "Cheung et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Cheung et al\\.", "year": 1996}, {"title": "Mining Frequent Patterns without Candidate Generation", "author": ["J. Han", "J. Pei", "Y Yin"], "venue": "In Proceedings of the 2000 ACMSIGMOD Int\u2019l Conf. On Management of Data. Dallas, Texas,", "citeRegEx": "Han et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Han et al\\.", "year": 2000}, {"title": "A database perspective on knowledge discovery", "author": ["T. Imielinski", "H Mannila"], "venue": "Communications of the ACM,", "citeRegEx": "Imielinski and Mannila,? \\Q1995\\E", "shortCiteRegEx": "Imielinski and Mannila", "year": 1995}, {"title": "Efficient Mining of Association Rules Using Closed Itemset Lattices", "author": ["N. Pasquier", "Y. Bastide", "T. Taouil", "L Lakhal"], "venue": "Information Systems,", "citeRegEx": "Pasquier et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Pasquier et al\\.", "year": 1999}, {"title": "An Efficient Algorithm for Mining Association Rules in Large Databases", "author": ["A. Savasere", "E. Omiecinski", "S Navathe"], "venue": "In Proceedings of the 21th conference on VLDB (VLDB\u201995),", "citeRegEx": "Savasere et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Savasere et al\\.", "year": 1995}, {"title": "An Efficient Approach for Incremental Association Rule Mining", "author": ["P Tsai", "S.M", "Lee", "C-C", "A Chen", "L.P"], "venue": "In Proceedings of the Third Pacific-Asia KDD\u201999,", "citeRegEx": "Tsai et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Tsai et al\\.", "year": 1999}, {"title": "New Algorithms for fast discovery of Association Rules", "author": ["M.J. Zaki", "S. Parthasarathy", "M. Ogihara", "W Li"], "venue": "In Proceedings of the 3rd Int\u2019l Conference on KDD and data mining (KDD\u201997),", "citeRegEx": "Zaki et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Zaki et al\\.", "year": 1997}, {"title": "Post-Mining : Maintenance of Association Rules by Weighting", "author": ["S. Zhang", "C. Zhang", "X Yan"], "venue": "Information Systems", "citeRegEx": "Zhang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 1, "context": "Several ARM algorithms have been constructed to solve this problem (Agrawal and Srikant, 1994), (Savasere et al, 1995), (Zaki et al, 1997), (Pasquier et al, 1999), (Han et al, 2000).", "startOffset": 67, "endOffset": 94}, {"referenceID": 1, "context": "This algorithm is based on Apriori (Agrawal and Srikant, 1994) that is oriented sparse databases such as transactional databases.", "startOffset": 35, "endOffset": 62}, {"referenceID": 1, "context": "Apriori_gen being Apriori candidate generation function defined in (Agrawal and Srikant, 1994).", "startOffset": 67, "endOffset": 94}, {"referenceID": 5, "context": "We also propose to integrate the incremental maintenance idea in inductive databases (Imielinski and Mannila, 1995), i.", "startOffset": 85, "endOffset": 115}], "year": 2017, "abstractText": "Maintenance of association rules is an interesting problem. Several incremental maintenance algorithms were proposed since the work of (Cheung et al, 1996). The majority of these algorithms maintain rule bases assuming that support threshold doesn't change. In this paper, we present incremental maintenance algorithm under support threshold change. This solution allows user to maintain its rule base under any support threshold.", "creator": "Microsoft\u00ae Word 2010"}}}