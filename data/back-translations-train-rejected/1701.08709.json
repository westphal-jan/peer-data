{"id": "1701.08709", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jan-2017", "title": "Diversification Methods for Zero-One Optimization", "abstract": "We introduce new diversification methods for zero-one optimization that significantly extend strategies previously introduced in the setting of metaheuristic search. Our methods incorporate easily implemented strategies for partitioning assignments of values to variables, accompanied by processes called augmentation and shifting which create greater flexibility and generality. We then show how the resulting collection of diversified solutions can be further diversified by means of permutation mappings, which equally can be used to generate diversified collections of permutations for applications such as scheduling and routing. These methods can be applied to non-binary vectors by the use of binarization procedures and by Diversification-Based Learning (DBL) procedures which also provide connections to applications in clustering and machine learning. Detailed pseudocode and numerical illustrations are provided to show the operation of our methods and the collections of solutions they create.", "histories": [["v1", "Mon, 30 Jan 2017 17:01:31 GMT  (462kb)", "http://arxiv.org/abs/1701.08709v1", "28 pages, 7 illustrations, 4 pseudocodes"], ["v2", "Thu, 23 Mar 2017 04:19:25 GMT  (462kb)", "http://arxiv.org/abs/1701.08709v2", "28 pages, 7 illustrations, 4 pseudocodes"]], "COMMENTS": "28 pages, 7 illustrations, 4 pseudocodes", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["fred glover"], "accepted": false, "id": "1701.08709"}, "pdf": {"name": "1701.08709.pdf", "metadata": {"source": "CRF", "title": "Diversification Methods for Zero-One Optimization", "authors": ["Fred Glover"], "emails": ["glover@colorado.edu"], "sections": [{"heading": null, "text": "We will present new diversification methods for zero-one optimization that expand on strategies previously introduced in metaheuristic search, including easy-to-implement strategies for allocating value to variables, accompanied by processes known as augmentation and shift that provide greater flexibility and universality, and then demonstrate how the resulting collection of diversified solutions can be further diversified through permutation mappings that can also be used to generate diversified permutation collections for applications such as scheduling and routing, which can be applied to non-binary vectors through the use of binarization techniques and through Diversification-Based Learning (DBL) techniques that also connect to cluster and machine learning applications. Detailed pseudocodes and numerical illustrations will be provided to demonstrate the workings of our methods and the collection of solutions they create; mathematical keywords; meteubinary adaptation; optimization."}, {"heading": "1. Introduction", "text": "The main questions and answers on this subject are: \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" \"What is the cause?,\" and \"What is the cause?.\""}, {"heading": "1.1 Basic Notation and Conventions", "text": "In fact, it is in such a way that it is a way in which people are able to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live, to live"}, {"heading": "2.1 Overview", "text": "Let N (i), i = 1,... iLast denote a partition of N = = {1,..., n} At each stage of the method, each quantity N (i) of the current partition is divided into two equal parts (or as close as possible if N (i) contains an odd number of elements), generating a total of iLast additional quantities N (i). Let v denotethe integer upper limit of v, i.e., the smallest integer v (hence v = v + 1 if v is fragmentary). To begin with, iLast = 1 and N (1) = N = {1, n}. N (1) denotethe integer upper limit of v, i.e., the smallest integer v (hence v = v + 1 if v is fragmentary)."}, {"heading": "2.2 Implementation", "text": "The algorithm can be conveniently implemented by observing that there is no need to store the records N (i) = = special case (i) at each step. Instead, it is sufficient to record only two numbers (First (i) and Load (i), the N (i) as of N (i) = {j: First (i) \u2264 j Load (i)}. The exact number of elements in a record N (i) is currently considered x, which we call SetSize, is then split by SetSize = Load (i) + 1 - First (i).N (i) can thus be used by using Split = SetSize = SetSize / 2 if i is even. These results when creating appropriate \"First\" and \"Load\" values for the records NL (i) and NR (i) as follows: SplitPoint = i) as follows: First (i) + LastSize / 2 LastSize is ungeros and Size (Lasti) is LastungSize / 2 and LastSize is last."}, {"heading": "2.3 Illustration", "text": "We illustrate the method applied to the case for N = {1, 2, 11, 11} and so on. Results for each iteration are shown in a block specified by \"Iter = 1,\" \"Iter = 2\" and so on. Each group N (i) for the current itter is identified within the {1} parentheses = {1} ({2}) {1} x 2 ({2) {1} x 2 ({2) x x 2 ({2) x 0 (0) x 0 (0) x 0 (0) x 2) x 0 (0) x x (0) x x x x 2) x 0 (0) x (0) x x 2) x 0 (0) x 0) x 0 (0) x 2) x 0 (0) x 0 (0) x 2 (0) x 2 (2) x (1) x 1 x 1 (1) x 1 x 1 (1) x 1 x 1 (1) x 1 (1) x 1 x 1 (1) x 1 (1) x 1 (1) x 1 (1) x 1 (1) x (1) x 1 (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1) x (1 (1) x (1) x (1) x (1) x (1 x (1) x (1) x (1) x (1) x (1 x (1) x (1) x (1) x (1 x (1) x (2) x (1) x (1) x (1 x (1) x (1) x (1 x (1) x (1) x (1) x (1) x (1 x (1) x (1) x (1 x (1) x (1) x (1 x (1) x (1) x (1) x (1 x (1) x (1) x (1 x (1) x (1) x (1) x (1) x (1 x (1) x (1) x (2) x (1 x (1 x (1) x (1"}, {"heading": "2.4 Modifying x' to Produce Different Numbers of Complemented Variables", "text": "We can change the vector x 'generated at each level of the method by changing the handling of each second or third element so that xj' = 1 - xj, setting xj '= xj instead (e.g., by setting x4', x7 ', and x10' in the last iteration of the above figure to 0 when every second completed element is changed, and x5 'and x10' to 0 when every third completed element is changed.) Likewise, we can set every second or third element so that xj '= xj sets xj instead xj' = 1 - xj (which sets x3 'and x8' to 1 in the last iteration of the previous figure when every second such element is changed, and sets only x6 'equals 1 when every third such element is changed), which differs from the max / min approach that creates vectors consisting of approximately the same number of completed and non-completed elements, and only sets x6' when each additional element is changed immediately, although this element is generated by approximately 4 / 1, and vice versa)."}, {"heading": "3. Augmented-Max/Min Diversification Generator", "text": "The augmented max / min generation method, as in the case of the max / min generation approach, commits to subdivide j successively into k different subsets of approximately equal size, since k goes beyond k = 2, 4, 8, 16,..., each subset being constructed in such a way that it differs \"as much as possible\" from all the others. Also, as in the max / min method, each subset contains approximately (n / k) +.5 elements. Furthermore, the augmented max / min approach contains numbers of subsets halfway between these values and adds the values of k = 3, 6, 12,... (hence k = 2p-1 + 2p, for p = 2, 3, 3,... Each vector that is generated is accompanied by the generation of its complement, just as in the case of the max / min method."}, {"heading": "3.1 Illustration", "text": "For n = 51 we start with the values s = (n / k) +.5 for k = 2, 3, 4, 6 (since sLim = (51.5 +.5 = 7), which results in x (((25), consisting of 26 1's, followed by 25 0's,... x (16), consisting of 16 1's, then 16 0's, then 16 1's, then 16 0's, then 3 1's.x (12), consisting of 12 1' s, then 12 0's,..., then 3 1' s x ((8), consisting of 8 1's, then 8 0' s,..., then 3 1'sThe sequence is then completed by x ((6), consisting of 6 1' s, then 6 0's,..., then 3 1' s x ((((5)), consisting of 5 1's, then 5 0' s,..., then 1 (1)."}, {"heading": "3.2 Extension by a Shifting Procedure", "text": "We increase the quantity x (s) by creating an additional vector xo (s) for each value of s > 1 by inserting s / 2 0 (s) at the beginning of x (s), and dropping the last s / 2 components of x (s). (Therefore, xo (s) x (s) shifts to the right by s / 2 components.) We do not bother to consider xo ((1), as this vector would by definition shift x ((1) by 0 components. (The alternative of moving x ((1) by 1 component is of no interest, since it only generates the complementarity of x (1).) As in the case of x (s) vectors, we also generate the complementarity of each xo (s) by 0 components. The collection generated by the Augmented Max / Min method contains a little more than twice as many vectors generated by the Max (s) method."}, {"heading": "4. Expanded Diversification by Permutation Mappings", "text": "We now introduce a procedure that works by mapping a given vector collection into one or more new collections that differ from the original collection in a way that is consistent with the concept of previously applied diversity. This method includes a method proposed in Glover (1997) and used by Campos, Laguna and Marti (2005) to generate various permutations, which we modify and then expand to provide a series of additional mappings. Adapted to the current context, the method extends the collection of vectors x (r), r = 0 to rAdd by adding vectors x (r) for r that range from r = rAdd + 1 to rLim (the selected limit for the total number of such vectors produced).We refer to a gap value g and a starting value s that ranges from 1 to g. We select an iteration index k that ranges from 0 to a maximum value Max s (k = k) so that we identify the largest of the constants (hence, k / k) in particular, is the one of the constants."}, {"heading": "4.1 Structure of the Diverse Permutations.", "text": "The generated permutations are derived from working on a given number vector (1,..., n), which we use as indices of the variable xj for j = 1 to n. In this context, we construct a permutation Pn (g) from (1,..., n) with reference to a series of \"sub-permutations\" Pn (g: s) for s = 1 to g, the components of which are given by Pn (g: s) = (s + kg: k = 0 to kMax) or equivalentlyPn (g: s) = (s, s + g, s + 2g,..., s + kMaxg). The sub-permutations Pn (g: s) can be strung together in any order to produce Pn (g). However, we prefer the reverse order, i.e. the generation of Pn (g: s) = (Pn (g: s): for s, g - 1,...)."}, {"heading": "4.1.1 Illustration", "text": "Consider the permutation Pn (g) for the case n = 14 and g = 6 (= n / 2 - 1). The sub-permutations of Pn (g) are Pn (g: 1) = (1 7 13) Pn (g: 2) = (2 8 14) Pn (g: 3) = (3 9) Pn (g: 4) = (4 10) Pn (g: 5) = (5 11) Pn (g: 6) = (6 12) Putting together these sub-permutations in reverse order results in Pn (g) = (6 12 5 11 4 10 3 9 2 8 14 1 7 13)"}, {"heading": "4.2 Employing Pn(g) as a Permutation Mapping", "text": "We treat Pn (g) as a mapping M = (m (1), m (2),..., m (n), which creates a vector y (r) from a given vector x (r) by definition of yj (r) = xm (j) (r), resulting in a new collection of various vectors y (r), r = 1 to rLoad from the original collection x (r), r = 1,..., rLoad in the following manner. Permutation Mapping AlgorithmFor r = 1 to rLastFor j = 1 to ni = m (j) yj (r) = xi (r) Endfor (j) Endfor (r) If the permutation mapping algorithm is applied to increase a current collection of vectors x (r), r = 1 to rAdd, the vector yj (r) above is replaced by xj (r + rAdd) (therefore xj (r + rAdd) =.xi) as a total number of 1, if the process can be stopped by 1."}, {"heading": "4.3 Recursive Permutation Mapping", "text": "Figure M = (m (1), m (2)..., m (n)) can be applied to any permutation P = (p (1),..., p (n) of indexes j = 1 to n and not only to the initial permutation Po = (1, 2,..., n). We therefore define Figure M (P) = P '= (p' (1),..., p '(n) byp' (j) (j) = (j))) for j = 1,..., m. (4.1) Therefore, the preceding figure replaces the jth element of P 'with the m (j) th element of P. Note that if P = Po = (1, 2,..., n) then P' = M (P) = M. Since M itself can be a permutation, it follows that Po is the identity element of M in relation to all these figures; i.e., Po (M) = M (M), where M = s = 1."}, {"heading": "4.3.1 Recursive Use of M", "text": "To use M recursively, we must apply M to Po to get M (Po) = M as the first permutation of a row. This first M, which we designate by M1, is the one used to create yj (r) = xi (r), because i = m (j), j = 1 to n, by the permutation mapping algorithm. Then we apply the mapping M again to get the mapping M (M) in this algorithm by m2 (Po) = M 2, where we define M2 = M (M). Now, the permutation mapping algorithm with M replaced by M2 in its description applies. (I.e.) We replace m in this algorithm with m2 (m2 1), m2 (n)."}, {"heading": "4.4 Illustrated Use of Recursion", "text": "We illustrate this recursive process for n = 9, where only a relatively small number of mappings are generated before the cycle. To a larger extent, we apply the mapping M = Pn (g) simultaneously to all vectors generated by the Max / Min algorithm of Section 2. For n = 9, we have g = n / 2 - 1 = 3, and henceforth P9 (1: 3) = (1 4 7) P9 (2: 3) = (2 5 8) P9 (3: 3) = (3 6 9) to Yield M = Pn (g) = (3 6 9 2 5 8 1 4 7) The first (upper left) section of Table 1 below shows the 8 vectors generated by the Max / Min algorithm and lists the indexes j = 1 to n, the mapping M and the initial vector Po (shown as P0 5 8 1 4 7) above them. The next section, just below the first section, shows the corresponding vectors that can be generated by the first section from j = 1 to n."}, {"heading": "5. Diversified Vectors from Balanced Sub-Vectors", "text": "A helpful diversification approach results from a construction that is roughly the opposite of the one underlying the max / min generation method. Instead of performing a \"successive binary partitioning\" of the index set for a seed vector as the basis for identifying complementary variables, we start at the other end and use a constructive process to achieve a goal similar to that of the max / min generation method."}, {"heading": "5.1 Sub-Vector Coverage", "text": "Let us call y = (y1, yp) a p-dimensional sub-vector that we want to include within a vector x 'by repeating it multiple times within x'. We will produce a collection Y of these p-dimensional sub-vectors and use each y Y to form a different vector x '. Obviously, we want the vectors y in Y to differ from each other, as this will also distinguish the resulting vectors x', and if the differences between the vectors y in Y are not large, they will be magnified in the vectors x ', as the latter will differ by a greater number (and proportions) of their components. To facilitate the analysis, we will take the seed vector x again and understand that the mapping xj' = 0 and the mapping xj 'and the mapping xj'."}, {"heading": "6. Conclusions", "text": "Strategies that generate meaningful collections of different vectors are highly desirable in metaheuristic optimization. As a basis for creating such collections, we have shown how different forms of a max-min principle lead to diversification methods that can be meaningfully refined and generalized by enlarging and shifting procedures, as well as special types of permutation mappings. Going backwards, we also show how useful forms of diversification can be achieved by a simple constructive approach to generating balanced sub-vectors. Our methods motivate future research to apply these methods in the presence of constraints imposed to achieve intensification and diversification goals, by limiting permissible objective functional values or setting limits on permissible distances to earlier high-quality solutions, and using supportive methods such as strategic oscillation that alternately drive the search to violate such boundaries and then re-enforce them by notifying and manipulating search areas."}, {"heading": "F; Glover (2005) \"Adaptive Memory Projection Methods for Integer Programming,\u201d in", "text": "It is the largest gap in the search for general classes of binary optimization problems, \"Computers and OR, In Press.M. Laguna and R. Mart\u00ed (2003) Scatter Search: Methodology and Implementations in CKluwer Academic Publishers: Boston, ISBN: 1-4020-7376-3.E. Mayoraz and M. Moreira (1999)\" Combinatorial Approach for Data Binarization, \"Chapter Principles of Data Mining and Knowledge Discovery, Volume 04 of the series 17pp-4P."}, {"heading": "To illustrate for the case where the seed vector is x = (0, 0, \u2026, 0), the procedure generates the", "text": "This is the reason why the algorithm restricts the value sLim to 1, if g = 2, whereby the vector for s = 2, g = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 1, x = 2, x = 1, x = 2, x = 2, x = 1, x = 2, x = 2, x = 1, x = 1, x = 2, x = 2, x = 2, x = 2, x = 1, x = 1, x = 1, x = 1, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x, x = 2, x, x = 2, x, x = 2, 2, 2 = 2, x, x = 2, x, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x, x = 2, x = 2, x, x = 1, x, x = 2, x = 1, x = 2, x = 2, x = 2, x = 1, x = 2, x = 1, x = 2, x = 2, x = 2, x = 2, x = 2, x = 1, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 1, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 2, x = 1, x = 2, x = 2, x = 2, x = 1, x, x = 2, x = 1, x = 2, x = 2, x = 2, x = 2, x = 2, x, x = 2, x = 2, x = 2, x, x, x = 2, x = 2, x,"}], "references": [{"title": "An Experimental Evaluation of a Scatter Search for the Linear Ordering Problem,", "author": ["V. Campos", "F. Glover", "M. Laguna", "R. Mart\u00ed"], "venue": "Journal of Global Optimization,", "citeRegEx": "Campos et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Campos et al\\.", "year": 2001}, {"title": "Context-Independent Scatter and Tabu Search for Permutation Problems,", "author": ["V. Campos", "M. Laguna", "R. Mart\u00ed"], "venue": "INFORMS Journal on Computing,", "citeRegEx": "Campos et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Campos et al\\.", "year": 2005}, {"title": "Tabu Search for the Maximum Diversity Problem,", "author": ["A. Duarte", "R. Mart\u00ed"], "venue": "European Journal of Operational Research,", "citeRegEx": "Duarte and Mart\u00ed,? \\Q2007\\E", "shortCiteRegEx": "Duarte and Mart\u00ed", "year": 2007}, {"title": "Heuristics Algorithm for the Maximum Diverstity Problem,", "author": ["M. Gallego", "A. Duarte", "M. Laguna", "R. Mart\u00ed"], "venue": "Computational Optimization and Application,", "citeRegEx": "Gallego et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Gallego et al\\.", "year": 2008}, {"title": "Heuristics for Integer Programming Using Surrogate Constraints,", "author": ["F. Glover"], "venue": "Decision Sciences", "citeRegEx": "Glover,? \\Q1977\\E", "shortCiteRegEx": "Glover", "year": 1977}, {"title": "Tabu Search for Nonlinear and Parametric Optimization (with Links to Genetic Algorithms),", "author": ["F. Glover"], "venue": "Discrete Applied Mathematics", "citeRegEx": "Glover,? \\Q1994\\E", "shortCiteRegEx": "Glover", "year": 1994}, {"title": "A Template for Scatter Search and Path Relinking,", "author": ["F. Glover"], "venue": "Artificial Evolution, Lecture Notes in Computer Science", "citeRegEx": "Glover,? \\Q1997\\E", "shortCiteRegEx": "Glover", "year": 1997}, {"title": "Scatter Search and Path Relinking,", "author": ["F. Glover"], "venue": "New Ideas in Optimization,", "citeRegEx": "Glover,? \\Q1999\\E", "shortCiteRegEx": "Glover", "year": 1999}, {"title": "Multi-Start and Strategic Oscillation Methods \u2013 Principles to Exploit Adaptive Memory,\u201d Computing Tools for Modeling, Optimization and Simulation: Interfaces in Computer", "author": ["F. Glover"], "venue": "Science and Operations Research,", "citeRegEx": "Glover,? \\Q2000\\E", "shortCiteRegEx": "Glover", "year": 2000}, {"title": "Adaptive Memory Projection Methods for Integer Programming,", "author": ["Glover"], "venue": "Metaheuristic Optimization Via Memory and Evolution,", "citeRegEx": "F and Glover,? \\Q2005\\E", "shortCiteRegEx": "F and Glover", "year": 2005}, {"title": "Diversification-Based Learning in Computing and Optimization,", "author": ["F. Glover", "J.-K. Hao"], "venue": "Research Report, College of Engineering and Applied Science,", "citeRegEx": "Glover and Hao,? \\Q2017\\E", "shortCiteRegEx": "Glover and Hao", "year": 2017}, {"title": "Black Box Scatter Search for General Classes of Binary Optimization Problems,", "author": ["F. Gortazar", "A. Duarte", "M. Laguna", "R. Mart\u00ed"], "venue": "Computers and OR,", "citeRegEx": "Gortazar et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Gortazar et al\\.", "year": 2010}, {"title": "Scatter Search: Methodology and Implementations in C Kluwer Academic Publishers: Boston, ISBN: 1-4020-7376-3", "author": ["M. Laguna", "R. Mart\u00ed"], "venue": null, "citeRegEx": "Laguna and Mart\u00ed,? \\Q2003\\E", "shortCiteRegEx": "Laguna and Mart\u00ed", "year": 2003}, {"title": "Combinatorial Approach for Data Binarization,", "author": ["E. Mayoraz", "M. Moreira"], "venue": null, "citeRegEx": "Mayoraz and Moreira,? \\Q1999\\E", "shortCiteRegEx": "Mayoraz and Moreira", "year": 1999}], "referenceMentions": [{"referenceID": 13, "context": "Diversification for zero-one optimization can also be applied to nonlinear continuous (global) optimization, taking advantage of the fact that binarization methods developed for converting discrete and continuous data into binary data (Mayoraz and Moreira, 1999) have proved to be quite effective for making certain types of global continuous problems susceptible to solution by zeroone optimization, notably in the realms of cluster analysis and machine learning.", "startOffset": 235, "endOffset": 262}, {"referenceID": 4, "context": ", in exploiting strongly determined and consistent variables; as in Glover (1977, 2001) and Glover and Laguna (1997)).", "startOffset": 68, "endOffset": 117}, {"referenceID": 6, "context": "In this paper we introduce new diversification strategies for zero-one optimization that extend a framework for generating diverse collections of zero-one vectors originally proposed in the context of the Scatter Search and Path Relinking evolutionary algorithms (Glover, 1997).", "startOffset": 263, "endOffset": 277}, {"referenceID": 10, "context": ", Laguna an Marti, 2003), while the Max/Min method has advantages for achieving certain kinds of diversification, and is relevant to the topic of learning procedures for metaheuristic optimization, as embodied in the approach called Diversification-based Learning (DBL) (Glover and Hao, 2017).", "startOffset": 270, "endOffset": 292}, {"referenceID": 4, "context": "This procedure incorporates a method proposed in Glover (1997) and applied by Campos, Laguna and Marti (2005) for generating diverse permutations, which we modify and then extend to provide a set of additional mappings.", "startOffset": 49, "endOffset": 63}, {"referenceID": 4, "context": "This procedure incorporates a method proposed in Glover (1997) and applied by Campos, Laguna and Marti (2005) for generating diverse permutations, which we modify and then extend to provide a set of additional mappings.", "startOffset": 49, "endOffset": 110}], "year": 2017, "abstractText": "We introduce new diversification methods for zero-one optimization that significantly extend strategies previously introduced in the setting of metaheuristic search. Our methods incorporate easily implemented strategies for partitioning assignments of values to variables, accompanied by processes called augmentation and shifting which create greater flexibility and generality. We then show how the resulting collection of diversified solutions can be further diversified by means of permutation mappings, which equally can be used to generate diversified collections of permutations for applications such as scheduling and routing. These methods can be applied to non-binary vectors by the use of binarization procedures and by Diversification-Based Learning (DBL) procedures which also provide connections to applications in clustering and machine learning. Detailed pseudocode and numerical illustrations are provided to show the operation of our methods and the collections of solutions they create.", "creator": "Microsoft\u00ae Word 2016"}}}