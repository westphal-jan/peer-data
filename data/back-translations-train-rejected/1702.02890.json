{"id": "1702.02890", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2017", "title": "Answer Set Solving with Bounded Treewidth Revisited", "abstract": "Parameterized algorithms are a way to solve hard problems more efficiently, given that a specific parameter of the input is small. In this paper, we apply this idea to the field of answer set programming (ASP). To this end, we propose two kinds of graph representations of programs to exploit their treewidth as a parameter. Treewidth roughly measures to which extent the internal structure of a program resembles a tree. Our main contribution is the design of parameterized dynamic programming algorithms, which run in linear time if the treewidth and weights of the given program are bounded. Compared to previous work, our algorithms handle the full syntax of ASP. Finally, we report on an empirical evaluation that shows good runtime behaviour for benchmark instances of low treewidth, especially for counting answer sets.", "histories": [["v1", "Thu, 9 Feb 2017 16:50:23 GMT  (564kb,D)", "http://arxiv.org/abs/1702.02890v1", "This paper extends and updates a paper that has been presented on the workshop TAASP'16 (arXiv:1612.07601). We provide a higher detail level, full proofs and more examples"]], "COMMENTS": "This paper extends and updates a paper that has been presented on the workshop TAASP'16 (arXiv:1612.07601). We provide a higher detail level, full proofs and more examples", "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.CC", "authors": ["johannes fichte", "markus hecher", "michael morak", "stefan woltran"], "accepted": false, "id": "1702.02890"}, "pdf": {"name": "1702.02890.pdf", "metadata": {"source": "CRF", "title": "Answer Set Solving with Bounded Treewidth Revisited\u2217", "authors": ["Johannes K. Fichte", "Michael Morak", "Markus Hecher", "Stefan Woltran"], "emails": ["lastname@dbai.tuwien.ac.at"], "sections": [{"heading": "1 Introduction", "text": "Parametrized algorithms [14, 5] have aroused considerable interest in recent years and make it possible to address difficult problems by directly exploiting a small parameter of the input problem. A specific goal in this area is to find guarantees that runtime is exponential only in the parameters, and polynomial in the input size (so-called fixed parameters tractable algorithms). A parameter that has been extensively researched is treewidth [16, 2]. Generally, treewidth measures the proximity of a graph to a tree, based on the observation that problems on trees are often easier than on arbitrary graphs. A parametrized algorithm that uses small treewidth representing an arrangement of a graph in a tree, and evaluates the problem in parts, via Dynamic Programming (DP) on tree decomposition."}, {"heading": "2 Formal Background", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1 Answer Set programming (ASP)", "text": "The question that arises is whether this is a type of rule that is not negative. (...) An election rule is an expression of form, {a1;.... an expression of form, {a1;... an expression of form, {a1;... an expression of form, {a1;... an expression of form, {a1;... an expression of form,. am. + 1,.. an.,. an.,., a., a.,., a., a.,.,. a.,. a.,. a.,. a..,. a.... a..... a.... a.... a.... a.... a... a... a... a........................................ a.................................... a.................................... a................................ a............................ a.......................... a.............................. a.............................. a.......................... a........................................... a....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... a......."}, {"heading": "2.2 Tree Decompositions", "text": "Let us G = (V, E) be a graph, T = (N, F, n) a rooted tree, and we (N) a function that makes each node a series of indentations. (D) A node is a node. (D) A node is a node. (T) A node is a node. (T) A node is a node. (D) A node is a node. (D) A node is a node. (D) A node is a node. (T) A node is a node. (D) A node. (T) A node is a node. (D) A node. (D) A node. (D) A node. (D) A node. (D) A node. (D) A node. (D) A node. (D) A node."}, {"heading": "2.3 Graph Representations of Programs", "text": "To use TDs for the ASP solution, we need special graph representations of ASP programs. The primary graph P of the program has the atoms of \"as vertices and an edge a b if there is a rule for\" r \"and\" a, b \"at\" r. \"The incidence graph I of\" i \"is the two-sided graph that has the atoms and rules of\" i \"as vertices and an edge a\" r \"at\" r \"for some rule\" r. \"These definitions adapt similar concepts from SAT [17]. Example 3. Let's call the program of\" i \"from Example 1. We observe that graph\" G1 (G2) in the left (right) part of Figure 1 is the primary (incidence) graph \"of.\""}, {"heading": "2.4 Sub-Programs", "text": "Let T = (T,) be a beautiful TD of graph representation H = (I,), P ()} of a program (T,) and T = (N, \u00b7, n). Further, the bag rules are defined as follows: \"t: = {r | r],\" \"t,\" \"t,\" \"t,\" \"t,\" \"t,\" \"t,\" \"\" t, \"\" \"t: =\" t, \"\" t, \"\" \"t,\" \"\" t, \"\" \"t,\" \"t,\" \"t,\" \"t,\" \"t,\" \"t,\" \"t,\" \",\" \"t,\" \"\" t, \"\" \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\" \"\", \"\" \"\", \"\" \"\", \"\" \",\" \"\", \"\" \",\" \",\" \"\", \"\", \"\", \"\", \"\", \",\" \",\" \"\" \",\" \"\", \",\" \"\" \",\" \"\", \"\" \",\" \"\" \"\", \"\", \"\" \"\", \",\", \",\" \"\" \"\" \",\", \"\", \"\" \"\", \"\" \",\" \",\" \"\" \"\", \",\", \"\", \",\" \"\" \"\", \"\" \",\", \"\" \"\" \",\" \"\", \",\", \"\" \"\" \",\", \",\" \"\" \",\", \"\", \",\", \"\" \",\", \"\" \"\", \",\", \"\", \",\", \",\", \"\" \"\", \",\", \",\" \",\" \"\", \",\" \",\" \"\", \"\", \",\", \"\", \"\" \",\" \",\" \",\" \",\" \"\", \"\", \",\" \"\" \",\", \",\" \",\", \",\" \",\" \"\" \"\" \"\", \",\", \"\", \"\" \",\", \",\" \",\" \",\", \",\" \"\", \",\", \",\""}, {"heading": "3 ASP via Dynamic Programming on TDs", "text": "In the next two sections, we propose two dynamic programming algorithms (DP): < < < < < < and DP INC, for ASP without optimization rules, based on two different graphs, namely the primary and the incidence graphs. < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "3.1 Using Decompositions of Primal Graphs", "text": "In this section, we present our PRIM algorithms in two parts: (i) finding witnesses (i) and (ii) finding witnesses (ii). < (i) finding witnesses (ii) finding witnesses (ii). (i) We refer to the resulting table results obtained during the period after the order was placed. < (i) Let us see the results of the reply to the reply to the answer to the answer to the answer to the answer to the answer to the answer to the answer to the answer of the answer to the answer to the answer to the answer to the answer to the answer to the answer to the answer to the answer to the answer to the question after the answer to the answer to the question after the answer to the answer to the question after the answer to the answer to the question after the answer to the question after the answer to the question of the question after the answer to the question we."}, {"heading": "3.2 Using Decompositions of Incidence Graphs", "text": "Our next algorithm (DP INC) uses the incidence graph as a representation of the input program. < < p > p > p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p (p (p) p (p) p (p) p (p) p (p) p (p) p (r) p (p) p (r) p (r) p (r) p (r) p (r) p (r) p (r) p) p (r) p (r) p) p (r) p (r) p (r) p) p (r) p (r) p) p (r) p) p (r) p (r) p) p) p (r) p (r) p) p (r) p (r) p) p (r) p) p (r) p) p) p (r) p) p) p) p (r) p) p) p) p (p) p) p) p) p) p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"(p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"(p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p.\" p \"p\" p \"p\" p \"p\" p \""}, {"heading": "3.3 Extensions for Optimization and Counting", "text": "In order to find an answer to a number of programs with optimization statements or the number of optimal solutions (# AspO), we need to expand our PRIM and INC algorithms. (< < < < < < m) When describing the cost and number of observed sets, we only need to make adjustments for INC. We specify which parts of INC we adapt to the calculation of the number of optimal solutions in algorithm 4 (# OINC). In order to slightly simplify the presentation of optimization rules, we assume, without loss of generality, that every time an atom a is introduced, in pocket (t) for some nodes of the TD, the optimization rule r, where one occurs, belongs in the pocket (t). First, we explain how we deal with the costs that we have defined the cst (B, M, A) function as defined in Section 2. In a line (1) we set the cost (leaf) to 0."}, {"heading": "4 Experimental Evaluation", "text": "In fact, we will be able to find a solution that puts the needs of the people first."}, {"heading": "5 Conclusion", "text": "In this paper, we have presented novel DP algorithms for ASP that extend previous work [11] to cover the full ASP syntax. Our algorithms are based on two graphical representations of programs and run in linear time with respect to the tree width of these diagrams and weights used in the program. Experiments indicate that our approach seems to be suitable for practical use, at least for certain classes of instances with small tree width, and could therefore fit into a portfolio-based solver."}, {"heading": "A Additional Examples", "text": "In the following example, we briefly describe how we calculate counter-witnesses using Algorithm 3 (INC) for selected interesting cases, similar to Example 6, but with the handling of counter-witnesses for the PRIM algorithm. Example 10. We consider \"witnesses\" from Example 1 and \"witnesses\" from Example 3 and \"witnesses\" from Example 3 and explain how we calculate the tables \"witnesses\" 1,.., \"\" witnesses \"from Example 3 (right) using DP INC. Table\" witnesses \"from Example 1 and\" witnesses \"from Example 3 > as type (t1). Node t2 introduces\" atom c, \"from which table\" < {c}, \"witnesses,\" \"witnesses\" and \"witnesses.\" Then node t3 introduces \"rule r1\" and node t4 \"rule r2.\" As a result, the table contains \"witnesses\" 4 \"additional calculated rule states\" (see SatRules) for witnesses and \"witnesses.\" No. 5. \""}, {"heading": "B Omitted Proofs", "text": "We can obtain probative force by a slight modification of the probative force of a program, we know that for each rule r there is such a rule r. (t) We can replace the mappings and relevant conditions for the satisfaction of the respective rules by defining a primary diagram of the respective rules. (t) We know that for each rule r there is a rule r. (t) We can directly determine the satisfaction of a rule if we contain all the atoms of a rule, if we calculate the tables. (t) We can directly determine the reliability of a rule if we obtain the reliability of a rule. (t) We can directly decide the reliability of a rule if we obtain the reliability of a rule. (t) We can obtain all the atoms of a rule if we obtain the reliability and reliability."}, {"heading": "C Experiments", "text": "C.1 SolversThe Solvers tested include our own prototypical implementation, which we referto as DynASP and the existing solvers \u2022 Cachet 1.21 [18], which is a SAT model counter, \u2022 DepQBF05, which is the solver DepQBF [9] where we added a naive implementation using methods described by Lonsing [8], \u2022 Clasp 3.1.4 [9], which is an ASP solver, and \u2022 SharpSAT 12.08 [20], which is a SAT model counter.C.2 EnvironmentWe run the experiments on an Ubuntu 12.04 Linux cluster of 3 nodes with two AMD Opteron 6176 SE CPUs of 12 physical cores each at 2.3Ghz clock speed and 128GB RAM. Input inputs were given to the solvers via shared memory. All solvers have been compiled with gcc version 4.9.3."}, {"heading": "Appendix References", "text": "[1] Hans L. Bodlaender. A linear-time algorithm for find tree-decompositions of small treewidth. SIAM J. Comput., 25 (6): 1305-1317, 1996. [2] J. et al. Czebotar. GTFS data exchange. www.gtfs-data-exchange.com, 2016. [4] Holger Dell and Frances Rosamond. The 1st parameterized algorithms and computational experiments challenge - Track A: Treewidth. Technical report, 2016. [4] Artan Dermaku, Tobias Ganzow, Georg Gottlob, Ben McMahan, Nysret Musliu, and Marko Samer. Heuristic methods for hypertree decomposition. In MICAI '08, pp. 1-11. Springer, 2008. [5] J. K. Fichte. daajoe / gtfs2graphs answer."}], "references": [{"title": "A linear-time algorithm for finding tree-decompositions of small treewidth", "author": ["Hans L. Bodlaender"], "venue": "SIAM J. Comput.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1996}, {"title": "Czebotar. GTFS data exchange", "author": [], "venue": "www.gtfs-data-exchange.com,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2016}, {"title": "The 1st parameterized algorithms and computational experiments challenge \u2013 Track A: Treewidth", "author": ["Holger Dell", "Frances Rosamond"], "venue": "Technical report,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2016}, {"title": "Heuristic methods for hypertree decomposition", "author": ["Artan Dermaku", "Tobias Ganzow", "Georg Gottlob", "Ben McMahan", "Nysret Musliu", "Marko Samer"], "venue": "In MICAI\u201908,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2008}, {"title": "Fichte. daajoe/gtfs2graphs \u2013 a GTFS transit feed to graph format converter", "author": ["K. J"], "venue": "https://github. com/daajoe/gtfs2graphs,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2016}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "AIJ, 187\u2013188,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Treewidth. Computations and Approximations, volume", "author": ["Ton Kloks"], "venue": "LNCS. Springer,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "DepQBF: A dependency-aware QBF solver system description", "author": ["F. Lonsing", "A. Biere"], "venue": "J. Sat., Bool. Model. and Comp.,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}], "referenceMentions": [{"referenceID": 4, "context": "Parameterized algorithms [14, 5] have attracted considerable interest in recent years and allow to tackle hard problems by directly exploiting a small parameter of the input problem.", "startOffset": 25, "endOffset": 32}, {"referenceID": 1, "context": "A parameter that has been researched extensively is treewidth [16, 2].", "startOffset": 62, "endOffset": 69}, {"referenceID": 2, "context": "ASP [3, 13] is a logic-based declarative modelling language and problem solving framework where solutions, so called answer sets, of a given logic program directly represent the solutions of the modelled problem.", "startOffset": 4, "endOffset": 11}, {"referenceID": 2, "context": ", [3, 13].", "startOffset": 2, "endOffset": 9}, {"referenceID": 3, "context": "Stateof-the-art ASP grounders support the full ASP-Core-2 language [4] and output smodels input format [19], which we will use for our algorithms.", "startOffset": 67, "endOffset": 70}, {"referenceID": 5, "context": "Hardness is a direct consequence of #\u00b7coNP-hardness for the problem of counting subset minimal models of a CNF formula [6], since answer sets of negation-free programs and subset-minimal models of CNF formulas are essentially the same objects.", "startOffset": 119, "endOffset": 122}, {"referenceID": 1, "context": "For some arbitrary but fixed integer k and a graph of treewidth at most k, we can compute a TD of width 6 k in time 2O(k ) \u00b7 |V | [2].", "startOffset": 130, "endOffset": 133}, {"referenceID": 1, "context": "For every TD, we can compute a nice TD in linear time without increasing the width [2].", "startOffset": 83, "endOffset": 86}, {"referenceID": 6, "context": ", [17, 7].", "startOffset": 2, "endOffset": 9}, {"referenceID": 0, "context": "In order to draw conclusions about the efficiency of DynASP2, we mainly inspected the cpu running time and number of timeouts using the average over three runs per instance (three fixed seeds allow certain variance [1] for heuristic TD computation).", "startOffset": 215, "endOffset": 218}, {"referenceID": 7, "context": "We limited available memory (RAM) to 4GB (to run SharpSAT on large instances), and cpu time to 300 seconds, and then compared DynASP2 with the dedicated #SAT solvers SharpSAT [20] and Cachet [18], the QBF solver DepQBF0, and the ASP solver Clasp [9].", "startOffset": 246, "endOffset": 249}], "year": 2017, "abstractText": "Parameterized algorithms are a way to solve hard problems more efficiently, given that a specific parameter of the input is small. In this paper, we apply this idea to the field of answer set programming (ASP). To this end, we propose two kinds of graph representations of programs to exploit their treewidth as a parameter. Treewidth roughly measures to which extent the internal structure of a program resembles a tree. Our main contribution is the design of parameterized dynamic programming algorithms, which run in linear time if the treewidth and weights of the given program are bounded. Compared to previous work, our algorithms handle the full syntax of ASP. Finally, we report on an empirical evaluation that shows good runtime behaviour for benchmark instances of low treewidth, especially for counting answer sets.", "creator": "LaTeX with hyperref package"}}}