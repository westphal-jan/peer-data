{"id": "1703.00757", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Mar-2017", "title": "Predicting Rankings of Software Verification Competitions", "abstract": "Software verification competitions, such as the annual SV-COMP, evaluate software verification tools with respect to their effectivity and efficiency. Typically, the outcome of a competition is a (possibly category-specific) ranking of the tools. For many applications, such as building portfolio solvers, it would be desirable to have an idea of the (relative) performance of verification tools on a given verification task beforehand, i.e., prior to actually running all tools on the task.", "histories": [["v1", "Thu, 2 Mar 2017 12:28:12 GMT  (143kb,D)", "http://arxiv.org/abs/1703.00757v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.SE", "authors": ["mike czech", "eyke h\\\"ullermeier", "marie-christine jakobs", "heike wehrheim"], "accepted": false, "id": "1703.00757"}, "pdf": {"name": "1703.00757.pdf", "metadata": {"source": "CRF", "title": "Predicting Rankings of So\u0081ware Verification Competitions\u2217", "authors": ["Mike Czech", "Eyke H\u00fcllermeier", "Marie-Christine Jakobs", "Heike Wehrheim"], "emails": [], "sections": [{"heading": null, "text": "In this paper, we present a machine learning approach for predicting rankings of tools based on verification problems. e-Method is based on so-called label ranking algorithms, which we complement with appropriate cores that provide similarity measurement for verification tasks. Our cores use a graph representation for so-called source code, which mixes elements of control and program dependency graphs with abstract syntax trees. Using SV-COMP data sets, we demonstrate our ranking prediction technique to generalize well and achieve a relatively high predicativity. In particular, our method surpasses a recently proposed function-based approach by Demyanova et al. (when applied to ranking predictions).CCS CONCEPTS \u2022 Computing Methodologies \u2192 Ranking; Support Vectormachines; Cross-Validation; \u2022 So ware and its Engineering \u2192 So veri; Formal Relocation so Recation Marie, WYlerware Mike EYi Czech Reference: ACM, ACM Reference Marie, EYDS EYDS Mike EYi."}, {"heading": "1 INTRODUCTION", "text": "This year is the highest in the history of the country."}, {"heading": "2 REPRESENTING VERIFICATION TASKS", "text": "Our goal is to predict rankings of so-called verification competitions by machine learning. To do this, training data must be made available to the learning algorithm, which in our case is available from the SV-COMP website. Let's start by explaining what data our prediction technique is equipped with and how these data are presented. The purpose of SV-COMP is to compare verification tools with respect to their effectiveness and efficiency. For this purpose, the tools are compared with verification tasks.De nition 2.1: A verification task (P, \u03c6) consists of a program P (for SV-COMP wri en in C) and a property (also called specification) \u03c6 (typically as a claim in the program).Figure 1 shows our ongoing example PSUM of a verification task (calculation n times 2 via addition). In a verification run, a verification tool is executed on such a verification task to determine the result."}, {"heading": "1 int i; 6 i = 0;", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 int n; 7 while (i <= n)", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3 int sn; 8 sn = sn + 2;", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4 n = input(); 9 i = i + 1;", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5 sn = 0; 10 assert (sn == n*2 || sn == 0);", "text": "This year it has come to the point that it has never come as far as this year."}, {"heading": "1 int i = 0; 1 int i = 0;", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 int n = abs(input()); 2 int n = abs(input());", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3 while (i < n) 3 while (i < n)", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "4 i++; 4 i++;", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "5 assert (i == n); 5 assert (i != n);", "text": "The fact is that we see ourselves in a position to be in, to be in, to be in, and to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in, to be in a position to be in."}, {"heading": "3 PREDICTING RANKINGS", "text": "The \"Rankings\" section begins with a brief description of the necessary background in machine learning. More specifically, we explain the problem of label ranking and the method of ranking by pair comparison to solve this problem. In the second part, we recall the binary classification with support vector machines and present our core functions on verification tasks. 3 Only partially, actually, because full formalization would require definitions of CFGs, PDGs and ASTs, which cannot all be given here due to lack of space."}, {"heading": "3.1 Label Ranking", "text": "Consider a nite set of K alternatives, defined by the class names Y = {y1,.., yK}; in our case, the alternatives correspond to the comparison tools. Formally, we are interested in the overall accounting relationship to Y, i.e., complete, transitive, and anti-symmetrical relations, where yi yj indicates that yi is in the order before yj. Formally, a total accounting can use a permutation of the sentence [K] = {1,., K}, so that \u03c0 (i) is the position of yi in the order M. We refer to the class of permutations of [K] (the symmetrical group of order K) by SK. By misusing terminology, although it is adjusted in the light of the above-mentioned one-to-one correspondence, we refer to elements x as both permutations and mutations."}, {"heading": "3.2 Ranking by Pairwise Comparison", "text": "Ranking by Pair Comparison (RPC) is a meta-learning technique that reduces a label ranking task to a series of binary classification problems [12]. Specifically, the idea is to learn a separate model (base learner) Mi, j for each label pair (yi, yj). For the training, the original data D is first converted into binary classification data. Di, j, 1 \u2264 i < j \u2264 K; for this purpose, a total number of K (K \u2212 1) / 2 models is required (see Figure 4 for an illustration). For the training, the original data D is first converted into binary classification data. Di, j, 1 \u2264 i < j \u2264 i. For this purpose, any preference information from the form yi x yj (extracted from complete or partial information about a ranking \u03c0x) is turned into a positive (classification) example."}, {"heading": "3.3 Support Vector Machines", "text": "As already mentioned, the support of vector machines (SVMs) as base learners in RPC is necessary. SVMs are so-called \"Large Margin\" Classi ers (19). ey separate positive from negative training instances in Rm (w > 1) is replaced by the normal vector w > Rm and the bias term b). en, encoding the two classes by \u00b1 1, the margin of atraining example (xi, yi).s The hyperplane (xi) is replaced by the normal vector w \"Rm\" and the bias term b. \"en, encoding the two classes by \u00b1 1, the margin of atraining example (xi, yi).s The negative margin corresponds to an error in the training data.e\" so Marge \"allows the addition of a variable problem."}, {"heading": "3.4 Graph Kernels for Veri cation Tasks", "text": "There are a number of graphs that already exist, for example, based on several thousand lines of code, and therefore we have decided to proceed from our own core development based on Weisfeiler-Lehman sub-trees known to er.Weisfeiler-Lehman extensions are extensions of the Weisfeiler-Lehman tests between two discretely described graphs [26]. is a test that essentially compares graphs by their node labels."}, {"heading": "4 IMPLEMENTATION AND EXPERIMENTAL EVALUATION", "text": "This year, as never before in the history of a country in which it is a country in which it is a country in which it is a country in which it is a country, a country in which it is not a country, a country in which it is not a country, but a country in which it is a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country, a country"}, {"heading": "5 CONCLUSION", "text": "In recent years, machine learning has racted increasing attention in so ware engineering and related elds where it has been used, for example in program creation and analysis. In 4h p: / / jgrapht.org 5h p: / / scikit-learn.org 6h p: / / forsyte.at / so ware / verifolio / 7h ps: / / github.com / zenscr / PyPRSVTthis paper we have proposed a method for predicting rankings of location tools on specific programs. Our rank prediction technique relies on existing methods for label ranking via pairwise comparison. To this end, we have developed a meaningful representation of the source code that captures various forms of dependencies between program elements. Instead of explicitly extracting functions from programs tailored to Veri-cation, we have constructed a kernel that compares programs by their elements and the connections between them. Due to its generic nature, we speculate that other types of kernel will also be useful for learning."}], "references": [{"title": "So\u0089ware Veri\u0080cation and Veri\u0080able Witnesses - (Report on SV-COMP 2015)", "author": ["Dirk Beyer"], "venue": "In TACAS 2015 (LNCS), Christel Baier and Cesare Tinelli (Eds.),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2015}, {"title": "CPAchecker: A Tool for Con\u0080gurable So\u0089ware Veri\u0080cation", "author": ["Dirk Beyer", "M. Erkan Keremoglu"], "venue": "In Computer Aided Veri\u0080cation ,CAV (Lecture Notes in Computer Science), Ganesh Gopalakrishnan and Shaz Qadeer (Eds.),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "A Training Algorithm for Optimal Margin Classi\u0080ers", "author": ["Bernhard E. Boser", "Isabelle Guyon", "Vladimir Vapnik"], "venue": "In ACM Conference on Computational Learning \u008aeory,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1992}, {"title": "PAC learning-based veri\u0080cation and model synthesis", "author": ["Yu-Fang Chen", "Chiao Hsieh", "Ondrej Leng\u00e1l", "Tsung-Ju Lii", "Ming-Hsien Tsai", "Bow- Yaw Wang", "Farn Wang"], "venue": "In International Conference on So\u0087ware Engineering,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2016}, {"title": "Predicting Rankings of So\u0087ware Veri\u0080cation Tools using Kernels for Structured Data", "author": ["Mike Czech"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2016}, {"title": "Round Robin Classi\u0080cation", "author": ["J. F\u00fcrnkranz"], "venue": "Journal of Machine Learning Research", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "Preference Learning and Ranking by Pairwise Comparison", "author": ["Johannes F\u00fcrnkranz", "Eyke H\u00fcllermeier"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}, {"title": "\u008ce Use of Program Dependence Graphs in So\u0089ware Engineering", "author": ["Susan Horwitz", "\u008comas W. Reps"], "venue": "In International Conference on So\u0087ware Engineering,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1992}, {"title": "On predictive accuracy and risk minimization in pairwise label ranking", "author": ["E. H\u00fcllermeier", "J. F\u00fcrnkranz"], "venue": "J. Comput. System Sci", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Label Ranking by Learning Pairwise Preferences", "author": ["E. H\u00fcllermeier", "J. F\u00fcrnkranz", "W. Cheng", "K. Brinker"], "venue": "Arti\u0080cial Intelligence", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Programming by Demonstration: a Machine Learning Approach", "author": ["Tessa Lau"], "venue": "Ph.D. Dissertation. University of Washington", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2001}, {"title": "Probabilistic outputs for support vector machines and comparisons to regularized likelihood methods. In Advances in Large Margin Classi\u0080ers", "author": ["John Pla"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1999}, {"title": "Learning programs from noisy data", "author": ["Veselin Raychev", "Pavol Bielik", "Martin T. Vechev", "Andreas Krause"], "venue": "In Symposium on Principles of Programming Languages, POPL, Rastislav Bod\u0131\u0301k and Rupak Majumdar (Eds.). ACM,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2016}, {"title": "Predicting Program Properties from \u201dBig Code", "author": ["Veselin Raychev", "Martin T. Vechev", "Andreas Krause"], "venue": "In Symposium on Principles of Programming  Languages,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2015}, {"title": "A Machine Learning Approach to Android Malware Detection", "author": ["Justin Sahs", "Latifur Khan"], "venue": "In European Intelligence and Security Informatics Conference,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Dyad Ranking using a Bilinear Placke\u008a- Luce Model. In Proceedings ECML/PKDD\u20132015, European Conference on Machine Learning and Knowledge Discovery in Databases", "author": ["D. Sch\u00e4fer", "E. H\u00fcllermeier"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond", "author": ["B. Sch\u00f6lkopf", "AJ. Smola"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Kernel Methods for Pa\u0088ern Analysis", "author": ["John Shawe-Taylor", "Nello Cristianini"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2004}, {"title": "Weisfeiler-Lehman Graph Kernels", "author": ["Nino Shervashidze", "Pascal Schweitzer", "Erik Jan van Leeuwen", "Kurt Mehlhorn", "Karsten M. Borgwardt"], "venue": "Journal of Machine Learning Research", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2011}, {"title": "\u008ce proof and measurement of association between two things", "author": ["Charles Spearman"], "venue": "American Journal of Psychology", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1904}, {"title": "MUX: algorithm selection for so\u0089ware model checkers", "author": ["Varun Tulsian", "Aditya Kanade", "Rahul Kumar", "Akash Lal", "Aditya V. Nori"], "venue": "In Conference on Mining So\u0087ware Repositories,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2014}, {"title": "Statistical Learning \u008aeory", "author": ["V.N. Vapnik"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1998}, {"title": "Label Ranking Algorithms: A Survey", "author": ["Shankar Vembu", "\u008comas G\u00e4rtner"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2010}, {"title": "A reduction of a graph to a canonical form and an algebra arising during this reduction", "author": ["Boris Weisfeiler", "A.A. Lehman"], "venue": "Nauchno Technicheskaya Informatsia", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1968}, {"title": "SATzilla: Portfolio-based Algorithm Selection for SAT", "author": ["Lin Xu", "Frank Hu\u008aer", "Holger H. Hoos", "Kevin Leyton-Brown"], "venue": "CoRR abs/1111.2249", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2011}], "referenceMentions": [{"referenceID": 0, "context": "the Competition on So\u0089ware Veri\u0080cation SV-COMP [1].", "startOffset": 47, "endOffset": 50}, {"referenceID": 6, "context": "Our method for rank prediction builds upon machine learning techniques, more precisely on so-called label ranking algorithms [9] using support vector machines [3] as base learners.", "startOffset": 125, "endOffset": 128}, {"referenceID": 2, "context": "Our method for rank prediction builds upon machine learning techniques, more precisely on so-called label ranking algorithms [9] using support vector machines [3] as base learners.", "startOffset": 159, "endOffset": 162}, {"referenceID": 17, "context": "\u008ce key ingredient of our approach is the de\u0080nition of a number of kernels [20], which act as similarity measures on veri\u0080cation tasks.", "startOffset": 74, "endOffset": 78}, {"referenceID": 20, "context": "So far, two other machine learning methods for selecting tools or algorithms for veri\u0080cation have been proposed [6, 23], both of them being based on feature vectors: while Tulsian et al.", "startOffset": 112, "endOffset": 119}, {"referenceID": 20, "context": "[23] only employ structural features of programs (like the number of arrays, loops, recursive functions), Demyanova et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[23] is di\u0081cult due to non-reproducability of their results.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "kernel framework [21] that compares graphs not only according to their labels (and how o\u0089en they occur) but also according to associations between labels (via edges in the graph).", "startOffset": 17, "endOffset": 21}, {"referenceID": 18, "context": "\u008ce choice of Weisfeiler-Lehman kernels is motivated by their be\u008aer scalability compared to other graph kernels, such as random walk or shortest path kernels (see [21]).", "startOffset": 162, "endOffset": 166}, {"referenceID": 6, "context": "\u008ce ranking is \u0080nally computed by a method for rank prediction via pairwise comparison [9], using support vector machines as base learners.", "startOffset": 86, "endOffset": 89}, {"referenceID": 19, "context": "\u008ce experiments show that our technique can predict rankings with a rather high accuracy, using Spearman\u2019s rank correlation [22] to compare predicted with true rankings.", "startOffset": 123, "endOffset": 127}, {"referenceID": 17, "context": "[20]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "In the two approaches existing so far [6, 23], corresponding features of programs, such as the number of loops, conditionals, pointer variables, or arrays in a program, are de\u0080ned in an explicit way.", "startOffset": 38, "endOffset": 45}, {"referenceID": 7, "context": "Ref variable reference Int Literal Small integer literal in [0,10]", "startOffset": 60, "endOffset": 66}, {"referenceID": 7, "context": "Function Call function call Int Literal Medium integer literal in [10,100]", "startOffset": 66, "endOffset": 74}, {"referenceID": 7, "context": "Program dependence graphs: PDGs [10] represent dependencies between elements in programs.", "startOffset": 32, "endOffset": 36}, {"referenceID": 22, "context": "[25]), preferences on Y are \u201ccontextualized\u201d by instances x \u2208 X, where X is an underlying instance space; in our case, instances are programs to be veri\u0080ed.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "A common example of such a loss is D(\u03c0 , \u03c0\u0302 ) = 1 \u2212 S(\u03c0 , \u03c0\u0302 ), where S(\u03c0 , \u03c0\u0302 ) is the Spearman rank correlation [22]:", "startOffset": 114, "endOffset": 118}, {"referenceID": 9, "context": "Ranking by pairwise comparison (RPC) is a meta-learning technique that reduces a label ranking task to a set of binary classi\u0080cation problems [12].", "startOffset": 142, "endOffset": 146}, {"referenceID": 0, "context": "For example, the output of a probabilistic classi\u0080er would be a number in the unit interval [0, 1] that can be interpreted as a probability of the preference yi x yj .", "startOffset": 92, "endOffset": 98}, {"referenceID": 16, "context": "In our approach, we use support vector machines as base learners [19, 24] .", "startOffset": 65, "endOffset": 73}, {"referenceID": 21, "context": "In our approach, we use support vector machines as base learners [19, 24] .", "startOffset": 65, "endOffset": 73}, {"referenceID": 5, "context": "\u008ce simplest approach is to extend the (weighted) voting procedure that is o\u0089en applied in pairwise classi\u0080cation [7]: For each label yi , a score", "startOffset": 113, "endOffset": 116}, {"referenceID": 8, "context": "Apart from its computational e\u0081ciency, it turned out to be relatively robust in practice and, moreover, it possesses some provable optimality properties in the case where Spearman\u2019s rank correlation is used as an underlying accuracy measure [11].", "startOffset": 241, "endOffset": 245}, {"referenceID": 16, "context": "SVMs are so-called \u201clarge margin\u201d classi\u0080ers [19].", "startOffset": 45, "endOffset": 49}, {"referenceID": 0, "context": "So-called Pla\u008a scaling is a post-processing step, in which distances are mapped to [0, 1] via a logistic transformation; thus, each instance is assigned a (pseudo-)probability of belonging to the positive class [14].", "startOffset": 83, "endOffset": 89}, {"referenceID": 11, "context": "So-called Pla\u008a scaling is a post-processing step, in which distances are mapped to [0, 1] via a logistic transformation; thus, each instance is assigned a (pseudo-)probability of belonging to the positive class [14].", "startOffset": 211, "endOffset": 215}, {"referenceID": 18, "context": "However, most of these graph kernels do not scale well to large graphs [21].", "startOffset": 71, "endOffset": 75}, {"referenceID": 18, "context": "As our graphs are representations of programs with several thousands lines of code, and hence very large, we have chosen to proceed from our own kernel development based on Weisfeiler-Lehman subtree kernels [21], which are known to scale be\u008aer.", "startOffset": 207, "endOffset": 211}, {"referenceID": 23, "context": "Weisfeiler-Lehman kernels are extensions of the Weisfeiler-Lehman test of isomorphism between two discretely labelled, undirected graphs [26].", "startOffset": 137, "endOffset": 141}, {"referenceID": 4, "context": "We can show the following result (for the proof, we refer to [5]):", "startOffset": 61, "endOffset": 64}, {"referenceID": 4, "context": "[5]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "For the computation of our veri\u0080cation graphs, we used the con\u0080gurable so\u0089ware analysis framework CPAChecker [2]: To", "startOffset": 109, "endOffset": 112}, {"referenceID": 7, "context": "In case of data dependencies, we utilized the integrated reaching de\u0080nition analysis as is described in [10].", "startOffset": 104, "endOffset": 108}, {"referenceID": 7, "context": "Also according to [10], we computed control dependencies.", "startOffset": 18, "endOffset": 22}, {"referenceID": 20, "context": "Our approach can be seen as a tool for algorithm selection, a problem that has also been tackled by other authors [6, 23, 27].", "startOffset": 114, "endOffset": 125}, {"referenceID": 24, "context": "Our approach can be seen as a tool for algorithm selection, a problem that has also been tackled by other authors [6, 23, 27].", "startOffset": 114, "endOffset": 125}, {"referenceID": 10, "context": "Other applications of machine learning include the learning of programs from examples ([13, 15]) and the prediction of properties of programs (e.", "startOffset": 87, "endOffset": 95}, {"referenceID": 12, "context": "Other applications of machine learning include the learning of programs from examples ([13, 15]) and the prediction of properties of programs (e.", "startOffset": 87, "endOffset": 95}, {"referenceID": 13, "context": ", types for program variables [16] or malware in Android apps [17]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 14, "context": ", types for program variables [16] or malware in Android apps [17]).", "startOffset": 62, "endOffset": 66}, {"referenceID": 3, "context": "A machine learning approach to so\u0089ware veri\u0080cation itself has recently been proposed in [4].", "startOffset": 88, "endOffset": 91}, {"referenceID": 15, "context": "Recently, a generalization of label ranking called dyad ranking has been proposed, in which not only the instances but also the alternatives to be ranked can be described in terms of properties [18].", "startOffset": 194, "endOffset": 198}], "year": 2017, "abstractText": "So\u0089ware veri\u0080cation competitions, such as the annual SV-COMP, evaluate so\u0089ware veri\u0080cation tools with respect to their e\u0082ectivity and e\u0081ciency. Typically, the outcome of a competition is a (possibly category-speci\u0080c) ranking of the tools. For many applications, such as building portfolio solvers, it would be desirable to have an idea of the (relative) performance of veri\u0080cation tools on a given veri\u0080cation task beforehand, i.e., prior to actually running all tools on the task. In this paper, we present a machine learning approach to predicting rankings of tools on veri\u0080cation tasks. \u008ce method builds upon so-called label ranking algorithms, which we complement with appropriate kernels providing a similarity measure for veri\u0080cation tasks. Our kernels employ a graph representation for so\u0089ware source code that mixes elements of control \u0083ow and program dependence graphs with abstract syntax trees. Using data sets from SV-COMP, we demonstrate our rank prediction technique to generalize well and achieve a rather high predictive accuracy. In particular, our method outperforms a recently proposed feature-based approach of Demyanova et al. (when applied to rank predictions).", "creator": "LaTeX with hyperref package"}}}