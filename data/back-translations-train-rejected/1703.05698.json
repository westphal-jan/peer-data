{"id": "1703.05698", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Mar-2017", "title": "Bayesian Sketch Learning for Program Synthesis", "abstract": "We present a data-driven approach to the problem of inductive computer program synthesis. Our method learns a probabilistic model for real-world programs from a corpus of existing code. It uses this model during synthesis to automatically infer a posterior distribution over sketches, or syntactic models of the problem to be synthesized. Sketches sampled from this posterior are then used to drive combinatorial synthesis of a program in a high-level programming language.", "histories": [["v1", "Thu, 16 Mar 2017 16:23:30 GMT  (376kb,D)", "http://arxiv.org/abs/1703.05698v1", null], ["v2", "Tue, 21 Mar 2017 18:29:10 GMT  (377kb,D)", "http://arxiv.org/abs/1703.05698v2", null], ["v3", "Mon, 17 Jul 2017 02:29:37 GMT  (229kb,D)", "http://arxiv.org/abs/1703.05698v3", null]], "reviews": [], "SUBJECTS": "cs.PL cs.LG", "authors": ["vijayaraghavan murali", "letao qi", "swarat chaudhuri", "chris jermaine"], "accepted": false, "id": "1703.05698"}, "pdf": {"name": "1703.05698.pdf", "metadata": {"source": "CRF", "title": "Bayesian Sketch Learning for Program Synthesis", "authors": ["Vijayaraghavan Murali", "Swarat Chaudhuri", "Chris Jermaine"], "emails": ["<vijay@rice.edu>,", "<swarat@rice.edu>,", "<cmj4@rice.edu>."], "sections": [{"heading": null, "text": "The main technical innovation of our approach - embodied in a system called BAYOU - is to use evidence provided by the user about the desired behavior of the program, together with a Bayesian update, to obtain a posterior distribution over the true, latent specification of the program (which in turn results in a posterior view over possible sketches). As we demonstrate experimentally, explicit modeling of uncertainty in the specification significantly increases the accuracy of the synthesis algorithm. We evaluate the ability of BAYOU to synthesize Java and Android methods."}, {"heading": "1. Introduction", "text": "In fact, most of them will be able to play by the rules they have set themselves in order to play by the rules."}, {"heading": "2. Motivating Examples", "text": "This year, the number of new arrivals has decreased many times over the previous year, and the number of new arrivals has increased many times over the previous year."}, {"heading": "3. Bayesian Sketch Learning", "text": "In this section, we formalize the methodology of Bayesian Sketch Learning. Considering an example we have developed, this approach learns a probabilistic model that can iteratively derive a sketch using rules from a grammar. Specifically, the learned model can be derived from a distribution P (Xi | xi \u2212 1), where Xi is a random variable that captures the i-th derivative step, and xi \u2212 1 is the list of steps derived up to (and including) step i \u2212 1. To give an example of X (X | xi \u2212 1) that corresponds to a complete sketch, the model first sets x0 = < > the derivative steps derived from X1 to (X2) step i \u2212 1."}, {"heading": "4. A Bayesian Encoder-Decoder", "text": "To realize the algorithm, we must address the question of whether it is a way in which the different types of distribution mechanisms are applicable in practice. (...) The approach we propose is in the sense in which it applies a Bayesian divergence between P (...) and P (...) to generate the posterior distribution P (...). (...) We begin our development of the Bayesian code by pointing out that the KL divergence between P (...) and P (...) is applicable. (...) The KL divergence between P (...) and P (...) is applicable in order to begin the posterior distribution between P (...) and P (...) is applicable. (...) The KL divergence between P (...) and P (...) is applicable in order to begin the posterior distribution between P (...) by indicating that we are coding the KL (...)."}, {"heading": "5. Language Abstractions", "text": "Formally, a sketch is a statement S generated by the grammar in Fig. 3. Grammar allows the syntax for calls to a predefined set of API methods, branches, loops, no-ops, statement sequences, and exceptions. The abstraction does not capture details such as variable names or local assignments. A call to an API method is abstracted by the name of method a and types \u03c41... A Boolean guard cond for a loop or branch is abstracted by the set of API calls that appear in the wake. A behavior is a sequence of symbols call, each of which has an API call.While choosing a language for sketches, you are faced with two competing objectives. For faster combinatorial synthesis, we want sketches to have enough details about the structure of a program.On the other hand, to allow common learning, we skip an instance (BRS) ()."}, {"heading": "6. Neural Decoder", "text": "The neural decoder function is the implementation of the sampler for X-P (X-P). This is done recursively using repeated examples drawn as Xi-P (Xi-1). < # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"}, {"heading": "7. Program Synthesis", "text": "Now we describe the main elements of the combinatorial search used to synthesize a Java program from a given sketch. A key feature of this \"concretization process\" is that it does not alter the syntactic structure of a sketch. Instead, it replaces types and abstract guardians of loops and branches in S with concrete Java expressions. Specifically, our concretization process transforms the syntax tree of a sketch recursively. Its parameters include a sketch S and an environment E that defines names and types of local variables and formal parameters to the extent. Now, we highlight three important cases of this transformation. \u2022 Assume S is \"a\" (suppose 1,.,., perck), where a is an API method name and each enthi is a type. If the return type of a is empty, the algorithm concretizes the sketch of Jz."}, {"heading": "8. Experiments", "text": "In evaluating our method, we are looking for answers to the following questions: \u2022 How does BAYOU work in terms of its ability to synthesize programs? \u2022 Has the central technical idea in this paper - the use of a Bayesian framework to trigger uncertainty - actually led to greater accuracy in synthetic programs? \u2022 How well is BAYOU able to find solutions for programming tasks that were not encountered during the training period? Data sets that we used to answer these questions, we have selected two repositories (Linstead et al, 2009; Androiddrawer) that together have provided a total of 37,000 Java and Android projects. Recall is what our grammar of sketches has parameterized. These methods were selected from classes in several commonly used Java APIs, such as Java lang.lang.lang.Throwable (the interface for exceptions)."}, {"heading": "9. Related work", "text": "Many current efforts in the programming language community (Solar-Lezama et al., 2006; Gulwani, 2011; Albarghouthi et al., 2013; Feser et al., 2015; Osera & Zdancewic, 2015) aim at the synthesis of search and limitation methods. However, the consensus here is that the synthesis and generalization of examples must be syntactically limited to the space of feasible programs (Alur et al., 2013), either by adding a human-provided sketch to a problem instance (Solar-Lezama et al., 2006), or by limiting the synthesis a priori to a narrow DSL (Gulwani et al., 2015; Barowy et al., 2015). In contrast, our approach begins with a universal language and is mutually distinct."}, {"heading": "10. Conclusion", "text": "We have developed a data-driven, probabilistic method of program synthesis based on sample behaviors. Our central contribution is a Bayesian probabilistic model that is trained on real code and treats user-specific examples as evidence of the specification and structure of a program. From this information, sketches of likely solutions to a synthesis problem can be derived, which can then be used for combinatorial methods of synthesis. We have shown that the model can be efficiently implemented in the form of BEDs. Finally, we have presented an implementation, BAYOU, for the concrete context of synthesis of API-heavy Android and Java code, and demonstrated that it can often generate non-trivial programs from a very small number of examples. Recognition This research has been supported by the DARPA MUSE Award # FA8750-14-2-0270 and a Google Research Award. The views, opinions and / or results contained in this article are those of the authors and should not be interpreted as the official views of the US Department of Defense or the Department of Defense."}], "references": [{"title": "Recursive program synthesis", "author": ["Albarghouthi", "Aws", "Gulwani", "Sumit", "Kincaid", "Zachary"], "venue": "In CAV,", "citeRegEx": "Albarghouthi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Albarghouthi et al\\.", "year": 2013}, {"title": "Mining idioms from source code", "author": ["Allamanis", "Miltiadis", "Sutton", "Charles"], "venue": "In Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering,", "citeRegEx": "Allamanis et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Allamanis et al\\.", "year": 2014}, {"title": "Syntax-guided synthesis", "author": ["Alur", "Rajeev", "Bod\u0131\u0301k", "Rastislav", "Juniwal", "Garvit", "Martin", "Milo M. K", "Raghothaman", "Mukund", "Seshia", "Sanjit A", "Singh", "Rishabh", "Solar-Lezama", "Armando", "Torlak", "Emina", "Udupa", "Abhishek"], "venue": "In FMCAD, pp", "citeRegEx": "Alur et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Alur et al\\.", "year": 2013}, {"title": "Deepcoder: Learning to write programs", "author": ["Balog", "Matej", "Gaunt", "Alexander L", "Brockschmidt", "Marc", "Nowozin", "Sebastian", "Tarlow", "Daniel"], "venue": "arXiv preprint arXiv:1611.01989,", "citeRegEx": "Balog et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Balog et al\\.", "year": 2016}, {"title": "PHOG: probabilistic model for code", "author": ["Bielik", "Pavol", "Raychev", "Veselin", "Vechev", "Martin T"], "venue": "In ICML, pp", "citeRegEx": "Bielik et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bielik et al\\.", "year": 2016}, {"title": "The inference of regular LISP programs from examples", "author": ["Biermann", "Alan W"], "venue": "IEEE transactions on Systems, Man, and Cybernetics,", "citeRegEx": "Biermann and W.,? \\Q1978\\E", "shortCiteRegEx": "Biermann and W.", "year": 1978}, {"title": "Adaptive neural compilation", "author": ["Bunel", "Rudy R", "Desmaison", "Alban", "Mudigonda", "Pawan K", "Kohli", "Pushmeet", "Torr", "Philip"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Bunel et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bunel et al\\.", "year": 2016}, {"title": "Synthesizing data structure transformations from input-output examples", "author": ["Feser", "John K", "Chaudhuri", "Swarat", "Dillig", "Isil"], "venue": "In PLDI,", "citeRegEx": "Feser et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Feser et al\\.", "year": 2015}, {"title": "Terpret: A probabilistic programming language for program induction", "author": ["Gaunt", "Alexander L", "Brockschmidt", "Marc", "Singh", "Rishabh", "Kushman", "Nate", "Kohli", "Pushmeet", "Taylor", "Jonathan", "Tarlow", "Daniel"], "venue": "arXiv preprint arXiv:1608.04428,", "citeRegEx": "Gaunt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Gaunt et al\\.", "year": 2016}, {"title": "Neural turing machines", "author": ["Graves", "Alex", "Wayne", "Greg", "Danihelka", "Ivo"], "venue": "arXiv preprint arXiv:1410.5401,", "citeRegEx": "Graves et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Graves et al\\.", "year": 2014}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["Gulwani", "Sumit"], "venue": "In POPL,", "citeRegEx": "Gulwani and Sumit.,? \\Q2011\\E", "shortCiteRegEx": "Gulwani and Sumit.", "year": 2011}, {"title": "Inductive programming meets the real world", "author": ["Gulwani", "Sumit", "Hern\u00e1ndez-Orallo", "Jos\u00e9", "Kitzelmann", "Emanuel", "Muggleton", "Stephen H", "Schmid", "Ute", "Zorn", "Benjamin"], "venue": "Commun. ACM,", "citeRegEx": "Gulwani et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Gulwani et al\\.", "year": 2015}, {"title": "Jsketch: Sketching for java", "author": ["Jeon", "Jinseong", "Qiu", "Xiaokang", "Foster", "Jeffrey S", "Solar-Lezama", "Armando"], "venue": "In Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering,", "citeRegEx": "Jeon et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Jeon et al\\.", "year": 2015}, {"title": "Inferring algorithmic patterns with stack-augmented recurrent nets", "author": ["Joulin", "Armand", "Mikolov", "Tomas"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Joulin et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Joulin et al\\.", "year": 2015}, {"title": "Auto-encoding variational bayes", "author": ["Kingma", "Diederik P", "Welling", "Max"], "venue": "In ICLR,", "citeRegEx": "Kingma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "Neural random-access machines", "author": ["Kurach", "Karol", "Andrychowicz", "Marcin", "Sutskever", "Ilya"], "venue": "arXiv preprint arXiv:1511.06392,", "citeRegEx": "Kurach et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Kurach et al\\.", "year": 2015}, {"title": "Sourcerer: Mining and searching internet-scale software repositories", "author": ["Linstead", "Erik", "Bajracharya", "Sushil", "Ngo", "Trung", "Rigor", "Paul", "Lopes", "Cristina", "Baldi", "Pierre"], "venue": "Data Min. Knowl. Discov.,", "citeRegEx": "Linstead et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Linstead et al\\.", "year": 2009}, {"title": "Neural programmer: Inducing latent programs with gradient descent", "author": ["Neelakantan", "Arvind", "Le", "Quoc V", "Sutskever", "Ilya"], "venue": "arXiv preprint arXiv:1511.04834,", "citeRegEx": "Neelakantan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neelakantan et al\\.", "year": 2015}, {"title": "Graph-based statistical language model for code", "author": ["Nguyen", "Anh Tuan", "Tien N"], "venue": "In Proceedings of the 37th International Conference on Software Engineering - Volume 1,", "citeRegEx": "Nguyen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Nguyen et al\\.", "year": 2015}, {"title": "A statistical semantic language model for source code", "author": ["Nguyen", "Tung Thanh", "Anh Tuan", "Hoan Anh", "Tien N"], "venue": "In Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering,", "citeRegEx": "Nguyen et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Nguyen et al\\.", "year": 2013}, {"title": "Type-andexample-directed program synthesis", "author": ["Osera", "Peter-Michael", "Zdancewic", "Steve"], "venue": "In PLDI,", "citeRegEx": "Osera et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Osera et al\\.", "year": 2015}, {"title": "Neuro-symbolic program synthesis", "author": ["Parisotto", "Emilio", "Mohamed", "Abdel-rahman", "Singh", "Rishabh", "Li", "Lihong", "Zhou", "Dengyong", "Kohli", "Pushmeet"], "venue": "arXiv preprint arXiv:1611.01855,", "citeRegEx": "Parisotto et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Parisotto et al\\.", "year": 2016}, {"title": "Flashmeta: A framework for inductive program synthesis", "author": ["Polozov", "Oleksandr", "Gulwani", "Sumit"], "venue": "ACM SIGPLAN Notices,", "citeRegEx": "Polozov et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Polozov et al\\.", "year": 2015}, {"title": "Code completion with statistical language models", "author": ["Raychev", "Veselin", "Vechev", "Martin", "Yahav", "Eran"], "venue": "In Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Raychev et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Raychev et al\\.", "year": 2014}, {"title": "Predicting program properties from big code", "author": ["Raychev", "Veselin", "Vechev", "Martin", "Krause", "Andreas"], "venue": "In POPL,", "citeRegEx": "Raychev et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Raychev et al\\.", "year": 2015}, {"title": "Learning programs from noisy data", "author": ["Raychev", "Veselin", "Bielik", "Pavol", "Vechev", "Martin T", "Krause", "Andreas"], "venue": "In Proceedings of the 43rd Annual ACM SIGPLANSIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "Raychev et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Raychev et al\\.", "year": 2016}, {"title": "Programming with a differentiable forth", "author": ["Riedel", "Sebastian", "Bosnjak", "Matko", "Rockt\u00e4schel", "Tim"], "venue": "interpreter. CoRR,", "citeRegEx": "Riedel et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Riedel et al\\.", "year": 2016}, {"title": "The sketching approach to program synthesis", "author": ["Solar-Lezama", "Armando"], "venue": "In Asian Symposium on Programming Languages and Systems,", "citeRegEx": "Solar.Lezama and Armando.,? \\Q2009\\E", "shortCiteRegEx": "Solar.Lezama and Armando.", "year": 2009}, {"title": "Combinatorial sketching for finite programs", "author": ["Solar-Lezama", "Armando", "Tancau", "Liviu", "Bod\u0131\u0301k", "Rastislav", "Seshia", "Sanjit A", "Saraswat", "Vijay A"], "venue": "In ASPLOS,", "citeRegEx": "Solar.Lezama et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Solar.Lezama et al\\.", "year": 2006}, {"title": "A methodology for LISP program construction from examples", "author": ["Summers", "Phillip D"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "Summers and D.,? \\Q1977\\E", "shortCiteRegEx": "Summers and D.", "year": 1977}, {"title": "Simple fast algorithms for the editing distance between trees and related problems", "author": ["Zhang", "Kaizhong", "Shasha", "Dennis"], "venue": "SIAM journal on computing,", "citeRegEx": "Zhang et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 1989}, {"title": "Topdown tree long short-term memory networks. In NAACL HLT 2016, The 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language", "author": ["Zhang", "Xingxing", "Lu", "Liang", "Lapata", "Mirella"], "venue": null, "citeRegEx": "Zhang et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 2, "context": "There has been a recent resurgence of interest in this problem (Alur et al., 2013; Solar-Lezama et al., 2006; Gulwani, 2011; Feser et al., 2015), and tools solving versions of the problem have begun to see industrial adoption (Gulwani et al.", "startOffset": 63, "endOffset": 144}, {"referenceID": 28, "context": "There has been a recent resurgence of interest in this problem (Alur et al., 2013; Solar-Lezama et al., 2006; Gulwani, 2011; Feser et al., 2015), and tools solving versions of the problem have begun to see industrial adoption (Gulwani et al.", "startOffset": 63, "endOffset": 144}, {"referenceID": 7, "context": "There has been a recent resurgence of interest in this problem (Alur et al., 2013; Solar-Lezama et al., 2006; Gulwani, 2011; Feser et al., 2015), and tools solving versions of the problem have begun to see industrial adoption (Gulwani et al.", "startOffset": 63, "endOffset": 144}, {"referenceID": 11, "context": ", 2015), and tools solving versions of the problem have begun to see industrial adoption (Gulwani et al., 2015).", "startOffset": 89, "endOffset": 111}, {"referenceID": 2, "context": "Existing approaches to the problem commonly frame it as search over a space of programs (Alur et al., 2013).", "startOffset": 88, "endOffset": 107}, {"referenceID": 2, "context": "A popular way of addressing these challenges is to assume some syntactic constraints on the program that is to be synthesized (Alur et al., 2013).", "startOffset": 126, "endOffset": 145}, {"referenceID": 28, "context": "These constraints are imposed either by having a incomplete syntactic model, known as a program sketch (Solar-Lezama et al., 2006; Solar-Lezama, 2009), as part of the problem instance, or by restricting synthesis to a domain-specific language (DSL) (Gulwani, 2011; Barowy et al.", "startOffset": 103, "endOffset": 150}, {"referenceID": 7, "context": "The resulting abstraction is then passed to a synthesizer based on type-directed search (Feser et al., 2015), which attempts to use the abstraction to create a Java program that could have produced the user-supplied sequences.", "startOffset": 88, "endOffset": 108}, {"referenceID": 31, "context": "Since a sketch is tree-structured, we use a top-down tree-structured RNN similar to (Zhang et al., 2016).", "startOffset": 84, "endOffset": 104}, {"referenceID": 31, "context": "Similar to the notion of a \u201cdependency path\u201d in (Zhang et al., 2016), we define a production path as a sequence of pairs \u3008(v1, e1), (v2, e2), .", "startOffset": 48, "endOffset": 68}, {"referenceID": 31, "context": "4 of (Zhang et al., 2016) for more details.", "startOffset": 5, "endOffset": 25}, {"referenceID": 7, "context": "These expressions are identified through type-directed enumeration (Feser et al., 2015).", "startOffset": 67, "endOffset": 87}, {"referenceID": 21, "context": "This encoder can be seen to implement the high-level ideas of the encoder used in (Parisotto et al., 2016), although low-level details may differ as their inputs are I/O examples.", "startOffset": 82, "endOffset": 106}, {"referenceID": 12, "context": "For example, JSKETCH (Jeon et al., 2015) synthesizes Java code, but expects the input to include a detailed program sketch.", "startOffset": 21, "endOffset": 40}, {"referenceID": 7, "context": "While tools like \u03bb (Feser et al., 2015) do not require sketches, they assume restricted programming languages and cannot synthesize programs that use complex APIs.", "startOffset": 19, "endOffset": 39}, {"referenceID": 28, "context": "Many recent efforts in the programming language community (Solar-Lezama et al., 2006; Gulwani, 2011; Albarghouthi et al., 2013; Feser et al., 2015; Osera & Zdancewic, 2015) target synthesis using search and constraint solving.", "startOffset": 58, "endOffset": 172}, {"referenceID": 0, "context": "Many recent efforts in the programming language community (Solar-Lezama et al., 2006; Gulwani, 2011; Albarghouthi et al., 2013; Feser et al., 2015; Osera & Zdancewic, 2015) target synthesis using search and constraint solving.", "startOffset": 58, "endOffset": 172}, {"referenceID": 7, "context": "Many recent efforts in the programming language community (Solar-Lezama et al., 2006; Gulwani, 2011; Albarghouthi et al., 2013; Feser et al., 2015; Osera & Zdancewic, 2015) target synthesis using search and constraint solving.", "startOffset": 58, "endOffset": 172}, {"referenceID": 2, "context": "A consensus here is that to scale synthesis and generalize well from examples, one must syntactically limit the space of feasible programs (Alur et al., 2013).", "startOffset": 139, "endOffset": 158}, {"referenceID": 28, "context": "This is done either by adding a human-provided sketch to a problem instance (Solar-Lezama et al., 2006), or by restricting synthesis a priori to a narrow DSL (Gulwani, 2011; Barowy et al.", "startOffset": 76, "endOffset": 103}, {"referenceID": 7, "context": "For example, the BAYOU system uses type-guided search techniques developed in prior work (Feser et al., 2015).", "startOffset": 89, "endOffset": 109}, {"referenceID": 9, "context": "One category of methods frame synthesis as the problem of learning an endto-end differentiable, neural model of a program (Graves et al., 2014; Kurach et al., 2015; Neelakantan et al., 2015; Reed & De Freitas, 2015; Joulin & Mikolov, 2015).", "startOffset": 122, "endOffset": 239}, {"referenceID": 15, "context": "One category of methods frame synthesis as the problem of learning an endto-end differentiable, neural model of a program (Graves et al., 2014; Kurach et al., 2015; Neelakantan et al., 2015; Reed & De Freitas, 2015; Joulin & Mikolov, 2015).", "startOffset": 122, "endOffset": 239}, {"referenceID": 17, "context": "One category of methods frame synthesis as the problem of learning an endto-end differentiable, neural model of a program (Graves et al., 2014; Kurach et al., 2015; Neelakantan et al., 2015; Reed & De Freitas, 2015; Joulin & Mikolov, 2015).", "startOffset": 122, "endOffset": 239}, {"referenceID": 8, "context": "A second category of methods learn interpretable programs (Gaunt et al., 2016; Riedel et al., 2016; Bunel et al., 2016), but requires new learning for each synthesis task.", "startOffset": 58, "endOffset": 119}, {"referenceID": 26, "context": "A second category of methods learn interpretable programs (Gaunt et al., 2016; Riedel et al., 2016; Bunel et al., 2016), but requires new learning for each synthesis task.", "startOffset": 58, "endOffset": 119}, {"referenceID": 6, "context": "A second category of methods learn interpretable programs (Gaunt et al., 2016; Riedel et al., 2016; Bunel et al., 2016), but requires new learning for each synthesis task.", "startOffset": 58, "endOffset": 119}, {"referenceID": 3, "context": "DeepCoder (Balog et al., 2016) uses a neural network to predict binary attributes of the solution to a synthesis problem, and uses these predictions to set goals for a combinatorial synthesizer.", "startOffset": 10, "endOffset": 30}, {"referenceID": 21, "context": "In neuro-symbolic synthesis (Parisotto et al., 2016), a neural architecture is used to encode a set of input examples and decode the resulting representation into a program in a DSL.", "startOffset": 28, "endOffset": 52}, {"referenceID": 24, "context": "Another body of related work learns hidden specifications (Raychev et al., 2015) and syntactic patterns (Allamanis & Sutton, 2014; Nguyen et al.", "startOffset": 58, "endOffset": 80}, {"referenceID": 19, "context": ", 2015) and syntactic patterns (Allamanis & Sutton, 2014; Nguyen et al., 2013; Nguyen & Nguyen, 2015; Raychev et al., 2015; Bielik et al., 2016) from code in large software repositories.", "startOffset": 31, "endOffset": 144}, {"referenceID": 24, "context": ", 2015) and syntactic patterns (Allamanis & Sutton, 2014; Nguyen et al., 2013; Nguyen & Nguyen, 2015; Raychev et al., 2015; Bielik et al., 2016) from code in large software repositories.", "startOffset": 31, "endOffset": 144}, {"referenceID": 4, "context": ", 2015) and syntactic patterns (Allamanis & Sutton, 2014; Nguyen et al., 2013; Nguyen & Nguyen, 2015; Raychev et al., 2015; Bielik et al., 2016) from code in large software repositories.", "startOffset": 31, "endOffset": 144}, {"referenceID": 23, "context": "The two most relevant efforts (Raychev et al., 2014; 2016) use statistical language models for code completion.", "startOffset": 30, "endOffset": 58}], "year": 2017, "abstractText": "We present a data-driven approach to the problem of inductive computer program synthesis. Our method learns a probabilistic model for realworld programs from a corpus of existing code. It uses this model during synthesis to automatically infer a posterior distribution over sketches, or syntactic models of the problem to be synthesized. Sketches sampled from this posterior are then used to drive combinatorial synthesis of a program in a high-level programming language. The key technical innovation of our approach \u2014 embodied in a system called BAYOU\u2014 is utilizing user-supplied evidence as to the program\u2019s desired behavior, along with a Bayesian update, to obtain a posterior distribution over the program\u2019s true, latent specification (indicating user intent), which in turn produces a posterior over possible sketches. As we show experimentally, explicitly modeling uncertainty in specification significantly increases the accuracy of the synthesis algorithm. We evaluate BAYOU\u2019s ability to synthesize Java and Android methods. We find that using just a few example API sequences to communicate user intent, BAYOU can synthesize complex method bodies, some implementing tasks never encountered during training.", "creator": "TeX"}}}