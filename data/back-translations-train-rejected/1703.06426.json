{"id": "1703.06426", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Mar-2017", "title": "Semi-Supervised Learning with Competitive Infection Models", "abstract": "The goal of semi supervised learning methods is to effectively combine labeled and unlabeled data to arrive at a better model. Many such methods rely on graph-based approaches, where continuous labels are propagated through a graph on the input points. Here we argue that it is more effective to consider infection processes on these graphs, whereby at any point in time nodes can infect other nodes with their labels. Since the dynamics of these processes is stochastic, we develop algorithms for efficiently estimating the expected labels over time. We show that our approach addresses many of the limitations of graph based learning, and is also empirically effective.", "histories": [["v1", "Sun, 19 Mar 2017 12:49:51 GMT  (49kb)", "https://arxiv.org/abs/1703.06426v1", null], ["v2", "Sun, 21 May 2017 07:17:41 GMT  (1289kb)", "http://arxiv.org/abs/1703.06426v2", null], ["v3", "Mon, 16 Oct 2017 21:26:17 GMT  (1313kb)", "http://arxiv.org/abs/1703.06426v3", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["nir rosenfeld", "amir globerson"], "accepted": false, "id": "1703.06426"}, "pdf": {"name": "1703.06426.pdf", "metadata": {"source": "CRF", "title": "Semi-Supervised Learning with Competitive Infection Models", "authors": ["Nir Rosenfeld", "Amir Globerson"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 170 3.06 426v 3 [cs.L G] 16 Oct 201 7The goal of semi-monitored learning methods is to combine labeled and unlabeled data effectively to arrive at a better model. Many methods are based on graph-based approaches, in which labels are propagated through a graph over the input examples. In most current methods, the propagation mechanism underlying the learning target is randomly based. Although theoretically elegant, randomness has several disadvantages that can impair predictive effectiveness. In this paper, we investigate dynamic infection processes as an alternative propagation mechanism in which blank nodes can be \"infected\" with the label of their already infected neighbors. We offer an efficient, scalable and parallelizable algorithm for assessing the expected infection outbreaks. We also describe an optimization view of the method that uses it with laplactic approaches in learning approaches, and finally demonstrate that several experiments are highly competitive across benchmarks and that the method is very competitive."}, {"heading": "1 Introduction", "text": "This year, as never before in the history of a country in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in"}, {"heading": "2 Propagating Labels with Infections", "text": "In this section, we present our infected nodes in a sober state, in which we determine the state of the infected nodes. (We are able to identify the infected nodes.) (We are able to identify the infected nodes.) (We are not able to identify the infected nodes.) We focus on the infected nodes, where the goal is to predict the labels of all the uninfected nodes. (The core idea of our method is to disseminate the labels of the infected nodes.) The process is initialized with all the infected nodes in an infected state and all the infected nodes. (We are unable to identify the labels of the infected nodes.) We are able to identify the labels of all the infected nodes in an infected state and all the infected nodes. (We are not able to identify the labels of all the infected nodes.)"}, {"heading": "2.1 Competitive Infection Models for Graph Labeling", "text": "As mentioned above, our SSL method is based on an infection process in which the nodes of the graph are infected with labels. Of course, there are many variants of infection processes, and we have described some relevant ones below."}, {"heading": "2.1.1 The Independent Cascade model", "text": "Since its introduction in [18], the simple but powerful Independent Cascade (IC) model (Wuv = infected) has been widely used. The original IC model, which is briefly reviewed below, is a discrete time-dependent, network-dependent interpretation of the classic Susceptible Infected Recovered (SIR) epidemiological model [26]. At t = 0, seed nodes are initialized into an infected state, and all other nodes into a vulnerable state. If the node u is infected at step t, then at t + 1 it attempts to infect each of its non-infected neighbors v Nei (u), and most likely succeeds in doing so puv."}, {"heading": "2.1.2 Continuous Time Dynamics", "text": "An important generalization is the continuous-time IC model (CTIC) [19]. This model is well suited for SSL because it is flexible, does not require a tie-break and allows for the inclusion of node priorities. In this model, a successful infection attempt entails an \"incubation period\" after which the node is infected. Thus, if u succeeds in infecting v at a certain point in time, it obtains an incubation period \u03b4uv \u0445 D (\u03b8uv), and v can become infected at a certain point in time \u03c4uv = \u03c4u + \u03b4uv. As in the IC model, v inherits label of its earliest infector \u03c1 (v) = argminu \u03c4uv. The competing CTIC model generalizes the competing IC model for an appropriate choice of D, setting Size to 1 with the probability of pe and -pe with the probability of 1 \u2212 pe."}, {"heading": "2.2 Computing Infections Efficiently", "text": "For infection models as in paragraph 2.1, we would like to calculate predictions as in Equation (2). A naive approach would be to do this by simulating the infection process N times and averaging. However, this is inefficient for discrete time IC, requires a continuous time simulation for CTIC and does not apply to general models. Therefore, we offer an equivalent efficient alternative below."}, {"heading": "2.2.1 Infections as Shortest Paths", "text": "Let us now present an alternative view of the scanning process, which enables efficient implementation and expansion. First, let us consider the discrete time IC process. For a single instance of the process, let us remember that if u succeeds, the edge (u, v) is considered active. We use the set of active edges A (sam-pled throughout the instantiation until termination) to plot the active graph GA = (V, E, WA) with weights WAe = 1 for e-A and W-E for e-E-A. An important observation is that the node v is infected when terminating iff, there is a path in GA from some seed nodes S to v with finite weight. We refer to this as an active path. Since the actual infection time of v is determined by the earliest successful infection, it is also the length of the shortest active path of some s-S. The above formulation allows us to replace the time with diagrams."}, {"heading": "2.2.2 Improved Efficiency via Modified Dijkstra", "text": "Recall that for a single instance of infection a node inherits its its label from the nearest seminal node. Based on this, algorithm 1 provides a direct approach to calculating f, where shortest paths from each of the k-seminal nodes to each unlabeled node v, U with k-calls to Dijkstra are calculated. Although correct, this method suffers from an unnecessary factor of k in its runtime. To reduce this overhead, we modify Dijkstra's initialization and updating so that only a single call would suffice. Algorithm 2 implements this idea for the more general CTIC model and allows node prioritization (Sec. 2). The correctness of the algorithm is stated below, and proof is provided in the supplementary material. Proposition 2. Algorithm 2 correctly calculates the average infection probability f, which is in Eq. (1).The worst case complexity of Dijstra, and therefore each Iteration, is practical in 2."}, {"heading": "3 What do infections optimize?", "text": "Many SSL methods suggest an optimization target that encrypts a notion of smoothness. For example, the classic LabelProp algorithm [46] encourages neighboring nodes to agree on their predicted names by minimizing a square penalty term: flp = argmin f \u00b2. In this section, we show that InfProp has a related interpretation. Specifically, we show that the InfProp predictions minimize f \u00b2 and the square target f \u00b2. (13) While the fundamental difference between equality (5) and (13) lies in how weights are determined."}, {"heading": "3.1 A Laplacian Interpretation for InfProp", "text": "An interesting property of LabelProp is that its target can be expressed via the graph Laplacian = E (S). For a directed weighted graph, the standard Laplacian is: Llp = D \u2212 W (6), where D is a diagonal matrix with Duu = \u2211 v Wuv (and W is symmetrical).The output of LabelProp can be calculated by solving the system Llpf \u2032 = 0 for the unlabeled nodes. We now show that the infection-based predictions of InfProp also correspond to the solution of a particular Laplacian system determined by the seed set quantity and infection dynamics. Consider a single infection instance and denotes by Tuv (S) the random variable indicating whether u has been infected by v for seed S, namely Tuv (S) = 1 {u = determination (v)}. We refer to the matrix T as the infector matrix we expect the T matrix to be the next T (infector T matrix)."}, {"heading": "3.2 InfProp as Optimization", "text": "Next, we use the laplac insight above to provide a lens minimized by the InfProp solution. Let's start with the remark that for LabelProp, Eq. (6) can be redefined as: 2flp = argmin f. \"Llpf.\" 22 = argmin f. \"u (f.\" u. \"vWuvf.\" v. \"2 (11), where the minimization occurs only via the unlabeled nodes, resulting in an alternative quadratic goal that expresses lower limits Eq. (5), 3, and directly the steady state of the average dynamic of LabelProp. Similarly, we can define Eq. (8) as: f (S) = argmin f.\" L (S).b (S).22 (12).uD. \"u.c.\" u.u.u.c. \"u.c.\" \"The symmetry and normalization of 3w using Jensen's Inequality.\" v. \"(S) and Expansion (S) v.\" v. (11) Denov."}, {"heading": "4 Other Learning Settings", "text": "In this section, we briefly describe how our method extends to other learning settings used in our experiments. For more details, please see the reserved material.Include characteristics and priority data: Many network-based datasets contain additional node features or priority values. Our method incorporates priority values directly into the CTIC dynamics by penalizing incubation times. Include priority for labeling v and allow q: [0, 1] \u2192 R to be a punishment function. If u succeeds in infecting v, the incubation period will be penalized by an additional q (\u03c1v). For a decreasing q, high priority values cause low penalties and vice versa. Although penalties are applied locally, they delay the global spread of the punished label via the graph. Trust and active learning: Remember that v does not remain infected with the probability of fv0. It follows that as a measure of confidence, S = 1 \u2212 V."}, {"heading": "5 Related Work", "text": "As in unsupervised learning processes, methods for semi-supervised learning processes are often based on assumptions about the structure of the unnamed data. One such assumption is that of smoothness, which means that examples that are close are likely to have similar names. In classical label distribution algorithms [46], adjacent nodes are encouraged to mark their names with a square penalty. Some variants add regularization terms. [41] Or they contain normalization and unused seeds. [45] An interesting feature of this approach is that undirected graphics can be interpreted as a target."}, {"heading": "6 Experiments", "text": "We have evaluated our method on various learning assignments via three benchmark data sets, which include network-based data for multiclass learning with [39] and without properties [38] and multilabel learning [33]. The data sets include various networks such as social networks, quotation and co-authorship graphs, product and item networks and hyperlink graphs. Dataset statistics can be found in the supplementary material. Our experimental setup follows the standard graphbased semi-supervised learning evaluation approach. Specifically, we draw a set of size k uniformly at random in each instance, acquire its labels, and then use the graph and labeled seeds set to generate labels for all nodes. We repeat this method for 10 random set selections and for different values of k (where k is set to be a fixed percentage of the number of nodes in the graphical scale) and report average results for all nodes. We do not include both our current method of baselists and the art."}, {"heading": "7 Conclusions", "text": "In this paper, we presented an SSL method in which labels spread over the graph using dynamic infection models, which have a strong connection to ensembles with short distances and to the representation of laplakers, allow efficient computation and show empirical potential. Our work was motivated by the idea that different types of graphs may require different dynamics, which led us to consider alternatives to random walks and average dynamics. We used a competitive CTIC variant, but other infection models (and other dynamics in general) can be considered. Dynamics selection can be used as a means of expressing foreknowledge and coding structure and dependencies. The models we use have very few adjustable parameters, but nevertheless one can look at highly parameterized models. Such parameters can be used to control infection probabilities, nodes or label specificity, they relate to characteristics and even adjust the dynamics themselves."}, {"heading": "1 Proof of Proposition 2 in Main Text", "text": "In this section, we prove the correctness of our algorithm. The proof takes into account the more general CTIC infection dynamics and allows node characteristics or priors (via a tightening function). In the infection dynamics presented in the publication, the labeling of a node remains fixed. In contrast, in the course of the algorithm, the labeling of a node may change with each removal update. Therefore, it remains to be shown that the algorithm outputs the desired labels. To support our assertion, it will be easier to assume that instead of first inserting all nodes in Q, we will add a dummy root node r to V, with longitudinal edges wrs = 0 to all s, and initialize Q to include only r. It is easy to see that after extracting r from Q we will return to our original algorithm instead of inserting all nodes in Q. Let's call on the standard that the node that offers the important dijstra distance (1) is correct."}, {"heading": "2 Extensions", "text": "In this section we describe in more detail some useful enhancements to our method. These include applying the method to the linear threshold model, including node features and priors in infection dynamics, and a framework for using our method in an active SSL environment."}, {"heading": "2.1 The Linear Threshold model", "text": "In this section, we will show how InfProp can be applied with Linear Threshold (LT) dynamics, rather than implementing the IC or CTIC dynamics discussed in the text, including adapting the algorithm to calculate expected labels to the LT model, and supporting node characteristics and priorities. Input to the LT model is a weighted graph G = (V, E, W) and an initial set of infected nodes S. We assume that the weights are positive, and that the sum of incoming weight characteristics and priorities.Input to the LT model is a weighted graph G = (V, E, W) and an initial set of infected nodes S. Before the process begins, each node u is assigned a threshold uniformly assigned from the interval, and that the sum of incoming weight characteristics and priory.The balance is at most 1 (thought can be strictly less than 1)."}, {"heading": "2.2 Incorporating node features and priors", "text": "In this section, we describe a novel generalization of the competing infection models presented above, which incorporate class priorities into the dynamics. In this context, our approach is to first train a probabilistic classifier (e.g. logistic regression) on the marked seed set and then use its predictions on the unmarked node as a precursor to our model. Our method uses node prices by transforming them into penalties on incubation times. Let's consider a single instance of an infection process. Assume node u has just been infected with the label \"Y\" and has been successful in its attempt to infect node v with an incubation period of \"uv.\" If the infectious time of \"uv\" is short, then it is very likely that v will also be infected with \"vels.\" On the other hand, if the prediction \"V\" is large, then other nodes may have a chance to infect with this infection."}, {"heading": "2.3 Confidence and Active Learning", "text": "Remember that a node v has a probability of fv0 not to be infected by any labeling, which indicates a very natural level of confidence in our prediction, namely: \u03c3v (S) = 1 \u2212 fv0 = L \u2211 = 1fv, \u03c3 (S) = \u2211 v\u03c3v (S) (16) The function \u03c3 quantifies trust in labeling, which differs conceptually from trust in a labeling. Our model clearly supports both concepts. The former is controlled by activating p, since they determine accessibility in the active diagram and are agnostic for labeling. The latter is controlled by \u03b8, since it influences the speed of propagation of labeling. The concept of trust allows us to apply our method to an active learning environment. Instead of assuming that the seed is given as an input, in this setting we are allowed to select the seed sown [seed taking into account a cardinality condition of the budget], which is then to select the good target of a seed."}, {"heading": "3 Non-Homogeneous Laplacian", "text": "Here we prove that: L (S) f = b (S), where: bu (S) = vb (S) vu, b (S) vu = cov [Tvu (S), Yu] we drop the notational dependence on S. We start by extending Fus with Y and T: fu = E [Tu \u00b7 Y \u00b7 s] = E [Tu \u00b7 Y \u00b7 s] = VE [TuvYvs] = VE [Tuv] E [Yvs] + cov [TuvYvs]) = Vs (T uvfvs + buvs), where the last step applies to the product of general random variables. Transcription in matrix form results in: f = T f + b. We get reordered: (I \u2212 T) f = Lf \u2212 vvvvvvu = vv (T), as required."}, {"heading": "4 Details for the Illustrative Synthetic Experiment", "text": "To illustrate this, we have designed a synthetic experimental setup in which our goal is to capture the structure of real networks. A well-known characteristic of such networks is that they often have a community-like structure, with many edges within the community but few edges within the community. In many cases, only a few specific nodes within a community were also connected to other communities. Therefore, we randomly created small networks with the above characteristics. Specifically, each network was designed to have three communities with 64 nodes each. Edges were randomly added between these nodes with a probability of 0.1. For community A, 8 nodes were assigned to community B, and an additional 8 to community C (and similar for the other communities). These edges were added with a probability of 0.1."}, {"heading": "5 Datasets", "text": "We evaluated our methodology using various learning exercises across three sets of benchmark data sets, which include network-based data sets for multi-level learning with features6 [39], multi-level learning without 6 http: / / linqs.umiacs.umd.edu / projects / / projects / lbc / features7 [38] and multi-level learning without 6 [33].The following table provides some statistics."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The goal of semi-supervised learning methods is to effectively combine labeled and unlabeled data to arrive at a better model. Many methods rely on graph-based approaches, where labels are propagated through a graph over the input examples. In most current methods, the propagation mechanism underlying the learning objective is based on random walks. While theoretically elegant, random walks suffer from several drawbacks which can hurt predictive performance. In this work, we explore dynamic infection processes as an alternative propagation mechanism. In these, unlabeled nodes can be \u201cinfected\u201d with the label of their already infected neighbors. We provide an efficient, scalable, and parallelizable algorithm for estimating the expected infection outcomes. We also describe an optimization view of the method, relating it to Laplacian approaches. Finally, experiments demonstrate that the method is highly competitive across multiple benchmarks and for various learning settings.", "creator": "dvips(k) 5.996 Copyright 2016 Radical Eye Software"}}}