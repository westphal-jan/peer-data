{"id": "1703.07994", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2017", "title": "Containment for Rule-Based Ontology-Mediated Queries", "abstract": "Many efforts have been dedicated to identifying restrictions on ontologies expressed as tuple-generating dependencies (tgds), a.k.a. existential rules, that lead to the decidability for the problem of answering ontology-mediated queries (OMQs). This has given rise to three families of formalisms: guarded, non-recursive, and sticky sets of tgds. In this work, we study the containment problem for OMQs expressed in such formalisms, which is a key ingredient for solving static analysis tasks associated with them. Our main contribution is the development of specially tailored techniques for OMQ containment under the classes of tgds stated above. This enables us to obtain sharp complexity bounds for the problems at hand. We also apply our techniques to pinpoint the complexity of problems associated with two emerging applications of OMQ containment: distribution over components and UCQ rewritability of OMQs.", "histories": [["v1", "Thu, 23 Mar 2017 10:44:18 GMT  (174kb)", "http://arxiv.org/abs/1703.07994v1", null], ["v2", "Sun, 2 Apr 2017 16:13:16 GMT  (176kb)", "http://arxiv.org/abs/1703.07994v2", null], ["v3", "Wed, 19 Apr 2017 00:26:02 GMT  (176kb)", "http://arxiv.org/abs/1703.07994v3", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["pablo barcelo", "gerald berger", "reas pieris"], "accepted": false, "id": "1703.07994"}, "pdf": {"name": "1703.07994.pdf", "metadata": {"source": "CRF", "title": "Containment for Rule-Based Ontology-Mediated Queries", "authors": ["Pablo Barcel\u00f3", "Andreas Pieris"], "emails": ["pbarcelo@dcc.uchile.cl", "gberger@dbai.tuwien.ac.at", "apieris@inf.ed.ac.uk"], "sections": [{"heading": null, "text": "In this context, it should be noted that there have been three families of formalisms: cautious, non-recursive and sticky sets of formalisms. In this thesis, we examine the containment problem for OMQs expressed in such formalisms, and this is a key component for solving the static analysis tasks associated with them. Our main contribution is the development of specially tailored techniques for OMQ containment among the above classes of Tgds. This allows us to obtain sharp limits on the complexity of the problems of OMQs."}, {"heading": "1. INTRODUCTION", "text": "The question of why and why, the way in which people deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they respond to the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they respond to the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they deal with the question, how they are"}, {"heading": "2. PRELIMINARIES", "text": "An instance of S is an expression of the form R (v), in which R (v) S is an expression of the nature n > 0 and v (v), in which R (n) is an n > tuple of terms. A fact is a fact whose arguments consist only of constants. An instance of S is a set of atoms above S containing constants and zeros, while a database of S is a finite series of facts about S. We can call an instance and a database of S instance and S database."}, {"heading": "3. OMQ CONTAINMENT: THE BASICS", "text": "The aim of this thesis is to examine in detail the problem of whether an OMQ Q1 is contained in an OMQ Q2, both via the same data scheme S, and, equivalent to whether Q1 (D) Q2 (D) is contained in any (finite) S database D. In this case, we write Q1 Q2; we write Q1 Q2 if Q1 Q2 and Q2 Q1. The OMQ containment problem in question is defined as follows: O1 and O2 are OMQ languages (C, Q) where C is a class of tgds (e.g. linear, non-recursive, sticky, etc.) and Q {CQ, UCQ}: PROBLEM: Cont (O1, O2) INPUT: Two OMQs Q1, O1, and Q2 O2."}, {"heading": "3.1 Evaluation vs. Containment", "text": "As you might expect OMQ (D), OMQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QQ (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D), QE (D) (D), QE (D), QE (D)."}, {"heading": "3.2 From UCQs to CQs", "text": "Before proceeding with the complexity analysis of the containment for the OMQ languages in question, let us give the following useful result: sentence 9. If we create an OMQ Q (C, UCQ) with C (G, L, NR, S), we can construct an OMQ Q (C, CQ) in polynomial time so that Q \u2261 Q. \"The proof for sentence 9 is based on the idea of encoding Boolean operations (in our case, the\" or \"operator) using a set of atoms; this idea has been used in several other works (see e.g. [13, 20, 34]). Sentence 9 allows us to focus on OMQs based on CQs; in fact, Cont (((C1, CQ), (C2, CQ) is C-complete, with C1, C2 (G, L, NR, S) and C being a complexity class closed by polynomial time reduction."}, {"heading": "3.3 Plan of Attack", "text": "We are now ready to proceed with the complexity analysis of containment for the OMQ languages in question. Our attack plan can be summarized as follows: \u2022 We consider in Section 4 Cont (((C, CQ))) for C, {L, NR, S}. These languages have a crucial property, the so-called UCQ rewritability, which is very useful for our purposes. This property allows us to show the following result: If the containment language does not hold, then this is observed via a \"small\" database, which in turn allows us to develop simple rate-and-check algorithms. \u2022 We then proceed to Section 5 with Cont ((G, CQ). This OMQ language does not have rewritability, and the task of establishing a small witness property as described above proved challenging. However, we show the following: If the containment language does not hold, then this is observed via a \"tree\" database, which allows us to develop a decision-making process based on two trees."}, {"heading": "4. UCQ REWRITABLE LANGUAGES", "text": "Definition 1. (UCQ re-writability) An OMQ language (C, CQ) in which C is TGD, re-writable if we can construct a UCQ language (C, CQ) for each OMQ = (S, \u03a3, q (x)) so that Q (D) = q (D) is re-writable for each S database. We continue to establish our desired small certificate property based on the UCQ re-writability. By defining UCQ re-writability, for each language O that is re-writable, we can have a calculable function fO for the natural numbers so that the following applies: For each OMQ = (S, q) database, q (x) database."}, {"heading": "4.1 Linearity", "text": "The problem of transcribing UCQ for OMQs in (L, CQ) was investigated in [33], where a resolution-based procedure called XRewrite was proposed. This transcription algorithm accepts an implicit query Q = (S, \u03a3, q (x))) Q (L, CQ) and constructs a UCQ transcription q \u2032 (x) over S by starting from q and applying complete transcription steps based on resolution. Let's illustrate this with a simple example: let's assume that S = {P, T}. Let's consider those consisting of the linear tgdsP (x) consisting of the linear tgdsP (x, y), R (x), y), if P (x), P (x), and the CQ (x), and the CQ (x) x, y), x (y), x (y).XRewrite will first solve the atom y (P)."}, {"heading": "4.2 Non-Recursiveness", "text": "Although the language of OMQ (NR, CQ) is not explicitly taken into account in [33], where the algorithm XRewrite is defined, the same algorithm can handle (NR, CQ). Analyzing the UCQ rewritings constructed by XRewrite, we can conclude that the body (Ps) briefly denotes the body of tgd proposition 14. It holds thatf (NR, CQ) (S, \u03a3, q) \u2264 (max."}, {"heading": "4.3 Stickiness", "text": "Let us now focus on (S, CQ). As shown in [33], in the face of a Q-Q problem (S, \u03a3, q), there is an execution of XRewrite that causes UCQ rewrite q1 (x-Q) \u00b7 \u00b7 \u00b7 qn (x-Q) via S with the following property: for each i-Q database (.., n), if a variable v occurs in more than one atom, then v already occurs in q. This property was used in [33] to bind the number of atoms that can appear in a single CQ database. We write T (q) for the set of terms (constants and variables) that occur in q, C (suited) for the set of constants that occur in q, and ar (S) for the maximum predicates of S. Proposition 17. It holds thatf (S, CQ, q, q, q, q, q)."}, {"heading": "5. GUARDEDNESS", "text": "In fact, the majority of them are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move,"}, {"heading": "5.1 Tree Witness Property", "text": "From the informal discussion mentioned above, it is clear that tree-like databases are crucial to our analysis, and let us specify this idea using tree decomposition techniques. A tree decomposition of a database D is a labeled, rooted tree T = (V, E, \u03bb), in which trees (V, 2dom (D), so that: (i) for each atom R (t1,.., tn).D, it v, V, so that tree decomposition is called T, [U] -guarded where U, V, and (ii) for each term t-dom (D), the set (V,.).D that produces a contiguous subtree of T when T, [U] -guarded, where U V, if for each node v, V\\ U, there is a database."}, {"heading": "5.2 Encoding Tree-like Databases", "text": "It is well known that a database D, whose tree width3 is limited by an integer k, cannot be converted into a tree (tree). (tree) can be converted (tree). (tree) converted into a series of finite sequences of natural numbers, including the empty sequence. A tree labeled with a tree is a pair of L = (T, \u03bb), where T \"N\" is closed under prefixes, and: T \"tree\" is the labeling function. The elements of T identify the nodes of L. It can be shown that D and a tree resolution T of D can be encoded with width k as tree L, where \"L,\" where we are an alphabet of the double exponential database in k, so that each node of T corresponds to exactly one node of L and vice versa."}, {"heading": "5.3 Constructing Tree Automata", "text": "We have the above result in place and place, we can now proceed with our automatic procedure. \"Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q -Q -Q -Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" Q \"Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \"-Q\" Q \"Q\" -Q \"-Q\" -Q \"-Q\" -Q \"Q\" -Q \"-Q\" -Q \"-Q\" Q \"-Q\" -Q \"-Q\" -Q \"Q\" -Q \"-Q\" -Q \"-Q\" Q \"-Q\" -Q \"-Q\" -Q \"-Q\" -Q \""}, {"heading": "6. COMBINING LANGUAGES", "text": "In the two preceding sections, we examined the containment problem in relation to a language O, i.e. both OMQs fall into O. However, it is natural to consider the version of the problem in which the OMQs involved fall into different languages, which is the aim of this section. Our analysis starts from the two cases in which the query on the left (LHS) falls into a rewritable language or is monitored."}, {"heading": "6.1 The LHS Query is UCQ Rewritable", "text": "As a direct consequence of Theorem 11, we obtain the following result: Cont ((C1, CQ), (C2, CQ), for C1 6 = C2, C1, C1, {L, NR, S} and C2, (L, NR, S, G) is decideable. By using the algorithm underlying Theorem 11, we create optimal limits for all existing problems with the only exception of Cont ((((S, CQ), (NR, CQ))). For the latter, we obtain an upper limit of ExpSpace by providing an analysis similar to Cont ((((NR, CQ)), while a lower limit of NExptime is inherited by exploiting Proposition 5. It is quite lengthy and not very interesting from a technical point of view to go through all the containment problems in Question 4 and explain in detail how the exact limits are reached; a summary of these problems can be found by reducing the quantity of both Q and Q (respectively)."}, {"heading": "6.2 The LHS Query is Guarded", "text": "We continue with the case in which the LHS-Query is protected as a QQ-Query, and show the following result: QQ = QQ = Q Q Q = QQ = Q Q Q = Q Q = Q Q = Q Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q = Q"}, {"heading": "7. APPLICATIONS", "text": "Interestingly, our results on Cont ((G, CQ)) can be applied to other important static analysis tasks, in particular to component distribution and UCQ rewritability. Each of these tasks is considered in the following two sections."}, {"heading": "7.1 Distribution Over Components", "text": "The concept of component distribution was introduced in [2], and it states that the answer to a query Q (Q) Q (Q) can be calculated by parallelizing the (maximally connected) components of the input database, but let us first specify what a component is. Moreover, a set of atoms Q (Q) is connected if there is a sequence \u03b11 for all c, d and dom (Q) q (A),...., n \u2212 1}, a component of atoms in A if (i) B is connected, and (ii) for all components of Q (\u03b1i + 1) 6 = \u2205, for each database of i {1,.., n \u2212 1}. We call B A a component of A if (i) B and (ii) for each component of A\\ B, B \u00b2, B and B \u00b2 that is not connected.5 Let co (A) introduce the components of A. We are now ready to introduce the concept of component distribution over components."}, {"heading": "7.2 Deciding UCQ Rewritability", "text": "This year, we have reached the point where we feel we can put ourselves at the top, in the way that we put ourselves at the top, in the way that we put ourselves at the top."}, {"heading": "8. CONCLUSIONS", "text": "We have developed specially tailored OMQ containment techniques that have allowed us to get a relatively complete picture of the complexity of the problem at hand. Our main conclusion is that for the OMQ languages in question, i.e. those based on linear, sticky, non-recursive, and protected tgds, the containment problem (under widely accepted assumptions of complexity) is more difficult than query evaluation, with the exception of linear OMQs via schemes of infinite force, where both problems are complete for PSpace. We have also used our techniques to close problems related to component distribution and UCQ re-describability. Specifically, the problem of deciding whether a protected OMQ is distributed across components is 2Exptitime-complete, while the problem of deciding whether a protected OMQ, which only mentions inconsistent and binary relationships, can be solved, UCQ-OMQ is also a problem that OMQ can currently be solved."}, {"heading": "APPENDIX", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "PRELIMINARIES Definition of Non-recursiveness", "text": "In the main part of the essay, we define non-recursive sets of tgds on the concept of predicate diagram. Here, we give an alternative definition based on the well-known concept of stratification, which is more convenient for the combinatorial analysis we will perform in the verification of sentence 14. Consider a series of tgds. A stratification of \u03a3 is a partition {1,..., n}, where n > 0 is such that it applies to any function \u00b5: sch (\u03a3) \u2192 {0,.., n}: 1. For each predicate R-sch (\u03a3), all tgds with R in their head belong to the same group of partitions. 2. If there is a tgd in the body so that the predicate R appears in its body while the predicate P appears in its head, then \u00b5 (R) < P (we say that a predicate is solid)."}, {"heading": "Definition of Stickiness", "text": "In the main part of the essay we give an intuitive explanation of stickiness. Here we remember the formal definition of the sticky sets of Tgds introduced in [24]. Let us fix a series of Tgds; w.l.o.g., let us assume that for each pair (\u03c3, \u03c3 \") a series of variables are not divided. For the convenience of notation, an atom \u03b1 and a variable x occurring in a series of Tgds, the definition 4. Let us consider a series of positions in \u03b1 where x occurs; a position P [i] identifies the i-th attribute of the predicate P. The definition of stickiness depends on the notion of marked variables occurring in a series of Tgds. Definition 4. Let us consider a Tgd group in which x occurs, and a variable x occurring in the body of Tgds variable, and a variable x occurring in which variable occurs in a head of Tgds. Let us define 4. Let us consider a Tgd group in which x occurs, and a variable x occurs in the body of Tgds variable variable x, and let us define when x follows an inductively in x:"}, {"heading": "PROOFS OF SECTION 3 Proof of Proposition 5", "text": "Consider an OMQ Q = (S, \u03a3, q (x)) (C, CQ) where C is a class of tgds, an S database D and a tuple c-dm (D) | x-dm. We show that: c-dm (D), (sch) -dm, c-dm, c-dm, and a tuple c-dm (sch), c-dm (D), and t-dm (q) Q2. (\u21d2) We assume that Q1 is 6 Q2. This implies that there is a sch-dm database D \u00b2, and a tuple of t-dm constants such as thatt-qD, c-dm (D), and t-dm-q (D)."}, {"heading": "Proof of Proposition 9", "text": "The construction underlying Proposition 9 is based on the idea of encoding the Boolean operations (in our case q = q = q) or using a series of atoms; this idea has been exploited in several other works; see, for example, [13, 20, 34]. We assume that the predicates of S (C, UCQ) do not appear in the head of a tgd database; we can \"chase\" the content of a relationship R / k \u00b2 S into an auxiliary predicate R (x1, x.g. that the predicates of S do not appear in the head of a tgd database; we can \"chase\" the content of a relationship R / k \u00b2 S into an auxiliary predicate."}, {"heading": "PROOFS OF SECTION 4 Proof of Proposition 10", "text": "We assume that q (x) = 1 qi (x) = 1 q (Q) = Q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q) = q (Q). We conclude that c (x) will be a tuple of constants by replacing each variable x in x (x) with the constant c (x). Since there is an S database obtained by Qi after replacing each variable x in qi with the constant c (x), we show that there is such a constant c (x)."}, {"heading": "Proof of Proposition 14", "text": "We assume that the predicates of S in the head of a Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-Q-"}, {"heading": "Proof of Theorem 16", "text": "A proof of the horizontal (resp., vertical) compatibility is given in the main part of the paper, while s is a problem on the first row. We move on to the determination of the PNEXP hardness. Our proof is the reduction of a tile problem recently introduced in [30], which in turn is based on the standard solution of the exponential tiling problem. Let us first return to the latter problem. An instance of the exponential tiling problem is a tuple (n, m, H, V, s), where n, m are numbers (in singular), H, V are subsets of {1,.,.,. \u00d7 {1, m}, and s is a sequence of numbers {1,., m, m, m}. Such a tuple specifies that we want a 2n \u00d7 2n grid in which each cell is represented with a tile of {1,.,.,.,.,.,.,.,} resontal (H,.,.) while the horizontal part is represented by the initial function."}, {"heading": "Data Schema S", "text": "The data scheme S consists of: \u2022 0-ary predicates Cji, for each i = 0,.., k \u2212 1} and j = 1,.., m}; the atom C j i indicates that si = j."}, {"heading": "The Query Q1", "text": "The purpose of query Q1 is twofold: (i) to verify that the so-called existence of the input database (i.e., for every input database, for every input database, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file, for every input file."}, {"heading": "The Query Q2", "text": "The purpose of query Q2 is twofold: (i) to check whether the so-called uniqueness of the input database, i.e. for each i {0,.., k \u2212 1}, is satisfied, and (ii) to check whether (n, m, H2, V2, s), where s is the input database encoded sequence of tilts, has a solution. Query Q2 mentions the same predictors as Q1 and is defined as (S, p \u00b2, target), where Economy 2 consists of the following Tgds: \u2022 Uniqueness check For each i-problem {0,..., k \u2212 1} and J, p \u00b2 {1,.., m} with j <: Cji, C i \u2192 Target \u2022 The rest of query 2 encodes the tile problem (n, m, H2, Vs, exactly like Q1 <)."}, {"heading": "Proof of Proposition 18", "text": "The set \u0441n consists of the following tgds; for the sake of brevity we write x-ji for xi, xi + 1,.., xj: 8S (x1,.., xn) \u2192 Pn (x1,..., xn) Pi (x-i \u2212 1, z, x-n i + 1, z, o), Pi (x-i \u2212 1, o, o), Pi (x-i, o, o), Pi \u2212 1 (x-i \u2212 1, z, x-n i + 1, z, o), 1 \u2264 i \u2264 n, P0 (z,.., z-n, z, o) \u2192 Ans (z, o), while q = Ans (0, 1). It can be verified that for each {S} database D, Qn (D) -6 =."}, {"heading": "Proof of Theorem 19", "text": "The coNExpTime upper limit and the PP2 hardness in the case of Q-Q (Q-Q) 01 are discussed in the main part of the thesis. Here we show the coNExpTime hardness. The proof is done in two steps: 1. We show that Cont ((((FNR, CQ), (L, UCQ))) is coNExpTime hard, where FNR denotes the class of complete non-recursive sets of tgds, i.e., non-recursive sets of tgds without existentially quantified variables.2. Then we reduce Cont (((FNR, CQ), (L, UCQ)) to Cont (S, CQ), (L, UCQ)))))) by showing that (under some assumptions explained below) each query can be rewritten in (FNR, CQ) as one (S, CQ) upper limit."}, {"heading": "Data Schema S", "text": "The data scheme S consists of: \u2022 2n-ary predicates TiledByi, for each i \u2264 m; the atom TiledByi (x1,..., xn, y1,.., yn) indicates that the cell with the coordinates (((x1,.., xn), (y1,.., yn)) \u0441 {0, 1} n \u00d7 {0, 1} n of tile i. Note that we use n-bit binary numbers to represent a coordinate; this is the main difference between our construction and that of [13]."}, {"heading": "The Query QT", "text": "The goal of the query QT is the claim that the input database encodes a candidate for tiling, i.e., whether the entire grid is tiled, without taking into account the restrictions, i.e., the compatibility relationships and the restriction on the initial part of the first line. \u2022 For this purpose, the query QT will mention the following predicates: \u2022 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: both: 1: both: 1: 1: both: 1: 1: 1: both: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 2: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1"}, {"heading": "The Query Q\u2032T", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "PROOFS OF SECTION 5", "text": "Remember that for the sake of technical clarity, we focus on constant free tgds and CQs, but all results can be extended to the general case, at the cost of more definitions and proofs involved. Furthermore, we assume that tgds have only one atom in mind. This does not affect the generality of our evidence, since each set of guarded tgds can be converted in polynomial time into a group of guarded tgds with the above property; see e.g. [22]. Finally, for convenience, we also assume that the body of a tgds is not empty, i.e. the body of a tgds is always an atom and not the symbol."}, {"heading": "Proof of Proposition 21", "text": "We begin by remembering the key concepts of tree decomposition."}, {"heading": "The Guarded Chase Forest", "text": "In view of a database D and a series of guarded tgds, the guarded tracking forest for D and \u03a3 is a forest (whose edges and nodes are labeled) structured as follows: 1. Add for each fact R (a) in D a node labeled R (a). 2. Add a node w labeled \u03b2 for each node v labeled \u03b2, and for each atom \u03b2 that results from a one-step application of a rule, if \u03b1 is the image of the guardian in this application, then a node w labeled \u03b2, and insert an arc from v to w labeled \u03c4. We can assume that the guarded tracking forest is always built inductively according to a fixed, deterministic version of the tracking procedure. The unguarded nodes are then completely ordered according to a relationship that reflects their generation sequence. Furthermore, we can extend it to database catoms by selecting a lexicographic sequence among them."}, {"heading": "Guarded Unraveling", "text": "Let me be an instance about S. We say that X'dom (I) can be ordered according to its natural order and order, and that we guard each one of them individually. Let me be an instance about S. We say that X'dom (I) is guarded according to its natural order and order, if there is a1. (I) is presented as an instance (I) as such. (I) as a series of finite sequences of the form X0X1 \u00b7 Xn, where we largely follow the concepts introduced in [1, 12]. Fix at the S instance I and some X0 dom (I). Let me be the series of finite sequences of the form X0X1 \u00b7 Xn, where Xi is a guarded set in I, and for i instance 0, Xi + 1 = Xi {a} for a particular group."}, {"heading": "Proof of Lemma 22", "text": "One can of course imagine that the number of trees that occur in a tree depends on the size of the tree, depends on the size of the tree, and the maximum arrangement of S, the alphabet of the encoding will depend on the number of trees. Let us remember that a tree is a pair of t = (T, \u00b5) in which the caption is an alphabet and (N, {0}) the number of finite sequences of positive integers, including the empty sequence, will be. (N, {0}) The labeling of elements is the labeling of functions and T that are closed under prefixes, i.e., x, i, i, T implies x x, for all x. (N, 0) The labeling of elements is the function of elements. (N, {0}) The labeling of elements is the function of elements."}, {"heading": "Proof of Lemma 23", "text": "Before we move on to the proof of Lemma 23, we first present the corresponding machine model."}, {"heading": "Automata Techniques", "text": "For a set of propositional variables X's, we are referred to by B + (X) = > transition. < < / / (X) > The set of Boolean formulas using variables from X, the terminals, and the constants true, false. < / (X) A twin-track, alternating parity automation (2WAPA) on trees is a tuple A = (S) the transition function in which we set Tran (A): = {< / (S) s is a finite set of states that are an alphabet (the input alphabet of A), (S), (S), and (S) the transition function in which we place Tran (A) s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\" s \"s\""}, {"heading": "Proof of Lemma 24", "text": "First, we need to introduce some additional auxiliary terms."}, {"heading": "Strictly Acyclic Queries", "text": "We can, of course, consider q as an instance [q] whose domain is the set of variables of q and contains the body atoms of q as facts. In the following, we will often overload the notation and write q for both the q query and the [q] instance. Terms of tree width, acyclicity, etc. then extend directly to CQs. In view of tree decomposition of q (i.e., of [q]), we say that the quantification of q is strict if any bag of CC contains all variables that are free in q (cf. also [32]). Accordingly, q is strictly called acyclic if there is a guarded tree decomposition of q (i.e. of [q])."}, {"heading": "Squid Decompositions", "text": "It is quite simple that for an S instance I say that I am [V] -acyclic when there is a guarded tree decomposition that is the omits V definition 13. Let me be a BCQ definition 12. Let me be a BCQ decomposition over S. It is a tuple decomposition of q +, H, T, V) where q + is where q + is a guarded tree decomposition that is omits V definition 13. Let q be a BCQ decomposition of S. It is a tuple decomposition of q +, H, T, V) where q + is an S cover of q, \u00b5: var (q +) an image of q + var (q +)."}, {"heading": "Derivation trees", "text": "Let D be an S database and a set of guarded rules. Let q0 (x) be a strictly acyclic query whose free variables are exactly those of x: = x1,.., xn and let a response be: = a1,.., a tuple of dom (D). A derivative tree for (a), q0 (x), x (x), with respect to D and zi is a finite tree T, whose node has a function with pairs of form (b1,., bk; q; q (y1,., yk), where bk., bk., constants of dom (D) and q., yk) are a strictly acyclic query about S (.,.) with exactly y1,., yk free, so that the following conditions are met: 1. (a), q0 (x.)."}, {"heading": "PROOFS OF SECTION 6 Proof of Theorem 26", "text": "A proof that the variables of q occur only in an atom is given in the main collection of work. However, the fact that Cont (G, CQ), (S, CQ), (S, CQ), (S, CQ), (S, CQ), (S, CQ), (S, CQ), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S), (S, S, S, S, S, S, S, S, S (S, S, S, S, S, S, S, S, S, S, S (S), S (S), S (S, S, S, S (S), S (S), S (S, S, S (S), S (S, S, S, S, S, S (S), S (S), S (S (S), S (S), S (S (S), S (S, S, S, S, S, S (S), S (S, S, S, S, S, S (S), S (S), S (S, S, S, S, S, S, S, S (S), S (S, S), S (S, S, S, S, S, S, S, S, S, S (S, S), S (S, S, S, S (S), S, S (S, S, S (S), S, S, S, S, S, S (S, S (S, S, S, S, S, S, S, S, S), S (S, S, S (S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S"}, {"heading": "PROOFS OF SECTION 7", "text": "Remember that we focus on simple and binary predicates. Furthermore, we look at constant-free tgds and CQs and assume that tgds have only one atom in mind."}, {"heading": "Proof of Proposition 30", "text": "We say that a tree occurs only in the root of T and its immediate successors. \u2022 It follows from the previous element that every child of V = 6 in T has a unique new element of C (D). In addition, we require that c in the bag of every child of v.Intuitively, C trees D, which represent the actual tree structure of D. It is fairly easy to see that every C tree has a lean tree decomposition."}, {"heading": "Proof of Proposition 31", "text": "It is a question of whether it is a tree that can be defined only as a \"tree,\" except that its transitions between the trees (B) may also be referred to as a \"tree.\" (B) It is a question of whether \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"tree\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B),\" (B), \"(B) (B),\" (B), \"(B),\" (B) (B), \"(B),\" (B), \"(B) (),\" (B) (B (), \"(B),\" (B () (), \"(B (),\" (B), \"(),\" (B (B) (), \"(B (),\" (), \"(B () (),\" (B (), \"(B) (),\" (B (), \"(B (),\" (), \"(B (),\" (), \"() (() ((B),\" (), \"(() ((((),\" (B)."}, {"heading": "9. REFERENCES", "text": "[1] A. Amarilli, M. Benedikt, P. Bourhis, and M. Vanden Boom. Query answering with transitive and linear-ordered data.In IJCAI, pages 893-899, 2016. [2] T. J. Ameloot, B. Ketsman, F. Neven, and D. Zinn. Weaker forms of monotonicity for declarative networking: A more fine-grained answer to the calm-conjecture. [4] T. J. Ameloot, F. Neven, F. Neven, and D. Zinn. Datalog queries distributing over components. In ICDT, pages 308-323, 2015. [4] T. J. Ameloot, F. Neven, and J. V. den Bussche. Relational transducers for declarative networking. J. ACM, 60 (2): 15, 2013. [5] M. Arenas, R. Hull, W. Martens, T. Schwentick."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "Many efforts have been dedicated to identify restrictions<lb>on ontologies expressed as tuple-generating dependencies<lb>(tgds), a.k.a. existential rules, that lead to the decidabil-<lb>ity for the problem of answering ontology-mediated queries<lb>(OMQs). This has given rise to three families of formalisms:<lb>guarded, non-recursive, and sticky sets of tgds. In this work,<lb>we study the containment problem for OMQs expressed in<lb>such formalisms, which is a key ingredient for solving static<lb>analysis tasks associated with them. Our main contribu-<lb>tion is the development of specially tailored techniques for<lb>OMQ containment under the classes of tgds stated above.<lb>This enables us to obtain sharp complexity bounds for the<lb>problems at hand.<lb>We start with OMQs based on linear (a core fragment<lb>of guarded tgds), non-recursive and sticky sets of tgds,<lb>which share the property of UCQ rewritability. By exploit-<lb>ing this property, we obtain a small witness property for<lb>non-containment that allows us to devise standard \u201cguess-<lb>and-check\u201d algorithms. Based on this, we prove that OMQ<lb>containment for linear tgds is PSpace-complete, but<lb>\u03a02 -<lb>complete if the arity of the schema is fixed, while for sticky<lb>sets of tgds it is coNExpTime-complete, and<lb>\u03a02 -complete<lb>in the case of fixed arity. For non-recursive sets of tgds, the<lb>problem is in ExpSpace and P-hard even for fixed-arity<lb>schemas. Hence, in all the cases the containment problem<lb>is harder (under widely accepted complexity assumptions)<lb>than query evaluation, with the exception of linear tgds<lb>over schemas of unbounded arity, where both problems are<lb>complete for PSpace. For OMQs based on guarded tgds,<lb>which are not UCQ rewritable in general, we establish a<lb>tree witness property, and use it in combination with tree<lb>automata techniques to prove that OMQ containment has<lb>the same complexity as query evaluation, i.e., 2ExpTime-<lb>complete. Unlike query evaluation, though, OMQ contain-<lb>ment for guarded tgds remains 2ExpTime-hard over fixed-<lb>arity schemas. Lastly, we apply our techniques to pinpoint<lb>the complexity of problems associated with two emerging<lb>applications of OMQ containment: distribution over com-<lb>ponents and UCQ rewritability of OMQs.", "creator": "LaTeX with hyperref package"}}}