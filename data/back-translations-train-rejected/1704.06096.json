{"id": "1704.06096", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Apr-2017", "title": "The Dependent Doors Problem: An Investigation into Sequential Decisions without Feedback", "abstract": "We introduce the dependent doors problem as an abstraction for situations in which one must perform a sequence of possibly dependent decisions, without receiving feedback information on the effectiveness of previously made actions. Informally, the problem considers a set of $d$ doors that are initially closed, and the aim is to open all of them as fast as possible. To open a door, the algorithm knocks on it and it might open or not according to some probability distribution. This distribution may depend on which other doors are currently open, as well as on which other doors were open during each of the previous knocks on that door. The algorithm aims to minimize the expected time until all doors open. Crucially, it must act at any time without knowing whether or which other doors have already opened. In this work, we focus on scenarios where dependencies between doors are both positively correlated and acyclic.The fundamental distribution of a door describes the probability it opens in the best of conditions (with respect to other doors being open or closed). We show that if in two configurations of $d$ doors corresponding doors share the same fundamental distribution, then these configurations have the same optimal running time up to a universal constant, no matter what are the dependencies between doors and what are the distributions. We also identify algorithms that are optimal up to a universal constant factor. For the case in which all doors share the same fundamental distribution we additionally provide a simpler algorithm, and a formula to calculate its running time. We furthermore analyse the price of lacking feedback for several configurations governed by standard fundamental distributions. In particular, we show that the price is logarithmic in $d$ for memoryless doors, but can potentially grow to be linear in $d$ for other distributions.We then turn our attention to investigate precise bounds. Even for the case of two doors, identifying the optimal sequence is an intriguing combinatorial question. Here, we study the case of two cascading memoryless doors. That is, the first door opens on each knock independently with probability $p\\_1$. The second door can only open if the first door is open, in which case it will open on each knock independently with probability $p\\_2$. We solve this problem almost completely by identifying algorithms that are optimal up to an additive term of 1.", "histories": [["v1", "Thu, 20 Apr 2017 11:35:44 GMT  (50kb,D)", "http://arxiv.org/abs/1704.06096v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["amos korman", "yoav rodeh"], "accepted": false, "id": "1704.06096"}, "pdf": {"name": "1704.06096.pdf", "metadata": {"source": "CRF", "title": "The Dependent Doors Problem: An Investigation into Sequential Decisions without Feedback\u2217", "authors": ["Amos Korman", "Yoav Rodeh"], "emails": ["amos.korman@irif.fr", "yoav.rodeh@gmail.com"], "sections": [{"heading": null, "text": "The basic distribution of a door describes the probability with which it opens under the best conditions (in view of the fact that other doors are open or closed). We show that if corresponding doors share the same basic distribution in two door configurations, these configurations have the same optimal runtime to a universal constant, regardless of the interdependencies between doors and which distributions. We also identify algorithms that are optimal up to a universal constant factor. In addition, if all doors share the same basic distribution, we provide a simpler algorithm and formula for calculating its runtime. In addition, we analyze the price lack of feedback for several configurations regulated by standard fundamental distributions. In particular, we show that the price in d for memory-less doors is logarithmic, but can potentially grow to be linear in d for other distributions."}, {"heading": "1 Introduction", "text": "This year, it has reached the point where it will be able to leave the country in which it is located, unless it is able to, it is able to reform it."}, {"heading": "1.1 Context and Related Work", "text": "This paper falls within the framework of decision-making under uncertainty, a large research object that has received considerable attention from researchers in various disciplines, including computer science, operative research, biology, sociology, economics and even psychology and cognition, see, for example, [2, 3, 5, 6, 7, 8, 9, 16]. Performing it despite limited feedback would fit within the framework of enhanced learning [17] and is inherent in the study of problems in the field of exploration vs. exploitation, including multi-armed bandit problems [10]. In this paper, we examine the effects of any feedback. Understanding this extreme scenario can serve as an approximation for cases where feedback is severely limited or limited in its effect. For1In fact, the distribution associated with some doors i may depend on the state of other doors (which are open or closed), not only with the current knock, but also with each of the previous knocks on the door, i.e. if it turns out that the price associated with some doors i may prove to be particularly difficult for two to use, the feedback it may prove to be small."}, {"heading": "1.2 Setting", "text": "The goal is to minimize the number of doors until all doors are opened. Crucially, the algorithm has no feedback on whether or not a door has been opened, unless all doors are open, in which case the task is complete. The probability that a door opens may depend on the condition of other doors (which are opened or closed), at the time of the current knock, as well as on their condition during each of the previous knocks on the door. For example, the probability that a particular knocking point on the door i depends on the number of previous knocking doors, but only on those that were made. The idea behind this definition is that we invest more time to open a door, and the quality of each knocking door depends on what has been done while some other specific doors have been opened."}, {"heading": "1.3 Our Results", "text": "We have two main results. The first, presented in Section 2, states that two similar configurations have the same optimal runtime up to a constant factor. We emphasize that this constant factor is universal in the sense that it does not depend on the specific distributions or number of doors. In addition, considering a configuration, we identify an algorithm that is optimal for it up to a constant factor. We then show that for configurations in which all doors are similar, there is a much simpler algorithm that is optimal up to a constant factor and describe a formula that calculates its approximate runtime. We close Section 2 by analyzing the price of lack of feedback for multiple configurations regulated by standard fundamental distributions. In particular, we show that the price is logarithmic in d for memorable doors, but can potentially grow to be linear in d for other distributions."}, {"heading": "2 Near Optimal Algorithms", "text": "The following important problem is demonstrated in Appendix B.1 by a coupling argument: Lemma 1. Consider similar configurations C, X, and I, where X is cascading and I am independent. For each sequence \u03c0, TI (\u03c0) \u2264 TC (\u03c0) \u2264 TX (\u03c0) decisions. This also implies that TI \u2264 TC \u2264 TX. The next theoreme represents a near-optimal sequence of strokes for a given configuration. In fact, from Lemma 1 this configuration is nearly optimal for any similar configuration, and thus we obtain that the optimal runtime for two similar configurations is the same up to a universal multiplicative factor.Theorem 2. There is a polynomial algorithm m2, which, in the face of a configuration C, generates such a configuration that TC (TI) =. Indeed, TC (\u03c0) \u2264 2 + 4TI \u2264 2 + 4TC.Proof. Denote by 1, d, the basic distribution of doors C."}, {"heading": "2.1 Configurations where all Doors are Similar", "text": "In this section, we focus on configurations where all doors have the same basic distribution p (n). We provide simple algorithms that are optimal up to a universal constant, and determine the price for lack of feedback regarding a few natural distributions. Evidence to this effect appears in Appendix C."}, {"heading": "2.1.1 Simple Algorithms", "text": "Consider the following very simple algorithm Asimp. It runs in phases in which it knocks on each door once in each phase, in order. As a consequence, we can write Asimp = (1, 2,.., d) \u221e. Let X1,.., Xd be random variables that take positive integer values, which satisfies Pr [Xi > n] = p (n). The following is simple: Claim 4. TI (Asimp) = BA (d \u00b7 E [max {X1,.,., Xd}]) This is less trivial: Claim 5. If all doors are similar, then TI (Asimp) = BA (TI) The above assertion states that Asimp is optimal up to a multiplicative constant factor in the independent case where all doors are similar. Consequently, we can also show: Claim 6. Let us denote by ordering 1 2n,."}, {"heading": "2.1.2 On the Price of Lacking Feedback", "text": "Claims 4 and 5 examine the price of lack of feedback if all doors are similar. (1) Note that we omitted dependence on the configuration, as in Theorem 2, up to constant factors. (E [max {X1,.., Xd}]] E [X1]) (1). Firstly: Lemma 7. If X1,.., Xd are i.i.d. random variables taking natural numerical values, then: E [max (X1,., Xd)] = E [max (X1,., Xd)] = 1 (X. + d). (Xi > n]) Where we open the door (X1) (X1 > n). (Xlt; 1 / d) Example 8. After the first knock, each door will most likely open 1 \u2212 1 / d and if it does not open, we will knock on the door = 1)."}, {"heading": "3 Two Memoryless Cascading Doors", "text": "It can be said that we have solved much of the problem of dependent doors through Theorem 2. There is an equivalence of independent and cascading models, and we give an up to constant factor optimal algorithm for each situation. Nevertheless, we find the question of finding the true optimal sequences for cascading doors interesting. What are the exact costs of having no feedback, in numbers? Even the simple case of two doors, each sequence with the probability of 1 / 2 at each break, proves to be quite difficult and has a not so intuitive optimal sequence. In this section, we focus on a very simple but interesting case of cascading door problem and solve it almost exactly. We have two doors that open sequence with the probability of p1, each time we knock on it, and door 2 opens with the probability of p2. We expand the setting to take into account different durations. Specifically, we assume that a knock on door 1 requires a unit of time and a unit of time 2."}, {"heading": "3.1 Equivalence of Models", "text": "Theorem 12: The probability that door 1 will be closed after the completion of door 1 is the probability that door 1 will be closed."}, {"heading": "3.2 The Optimal Semi-Fractional Sequence", "text": "A great advantage of the semi-fraction model is that we can find an optimal sequence for it. To do this, we need some preparation: Definition 14. For a semi-fraction sequence \u03c0, and some 0 \u2264 x \u2264 1, denote by Ex [\u03c0] the expected runtime of \u03c0 when we start with the probability of being closed x. In this notation, E [\u03c0] = E1 [\u03c0].Lemma 15. Leave y = x / (q2 + p2x). Then: Ex [1t \u00b7 \u03c0] = t + Eqt1x [\u03c0] Ex [2 \u00b7 \u03c0] = c + xy Ey [\u03c0] Proof. The first equation is clear, since we start with the probability x and then knock on it, the probability is that this door is closed qt1x.As for the second equation, if door 1 is closed with the probability x, then we knock."}, {"heading": "3.2.1 The Actual Semi-Fractional Sequence", "text": "Theorem 18: There is an optimal semi-fractional sequence \u03c0? of the form 1s (21t) \u221e = for some positive real values s = 1and its runtime is: E [\u03c0?] = min z [0,1] (logq1 (1 \u2212 z) + c + (1 \u2212 p2z) logq1 (1 \u2212 p2z) logq1 (1 \u2212 p2z) proof. Claim 26 of appendix D.1 states that there is an optimal semi-fractional sequence \u03c0. It clearly starts with a non-zero knock, and so we can write \u03c0 = 1s2p. Intuitively, this sequence starts at 1, goes down for some time with a 1 knock, and then jumps up again with a 2 knock. The state we have already passed on the first 1 knock, and so, as this is an optimal sequence, we can assume that they select as before and go down further."}, {"heading": "3.3 Actual Numbers", "text": "Theorem 18 gives the optimal semi-fractional sequence and a formula for calculating its expected runtime. This formula can be approximated as accurately as we would like for certain values of p1, p2, and c, but it is difficult to get a formula from it in closed form. Lemma 27 in Appendix D.3 gives us a pretty good result if p1 \u2248 p2, especially if they are small, as in Observation 25, we get Log (1 / (1 \u2212 p1) \u2248 p1, and therefore the additive error in the formula is something like 1.In general, if p1 is small, then \u03b8 (see Lemma 27) is about cp1 / p2, which is the expected time to open door 2 on its own, divided by the time to open door 1 for itself - a natural measurement of the system. If we then ignore the additive error, we get that the lower limit is approximately F (\u03b8) / p1, where F is a function that does not depend on the parameters of the system (for example, two of the two parameters are equal to F)."}, {"heading": "3.4 Examples", "text": "Simulations show that the best algorithm for this case is slightly more than 5.8, so the lower limit is quite narrow, but our upper limit is 6.747, which is quite wide. However, the sequence we get from the top limit evidence begins with: 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2,... The value it gives is about 5.832, which is very close to the optimum. For p1 = p2 = 1 / 100 and c = 1, the sequence we get is: 197, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, and the lower limit, which is about 1, and we see that the lower limit is 1, 2, 2, 2, 2, 2, and 754."}, {"heading": "A \u201cReal Life\u201d Example", "text": "The following, greatly simplified scenario is the focus of [4]. A treasure \u03c4 is placed on a leaf of a square root tree of the depth d. A mobile agent starting at the root wishes to find it as quickly as possible and is actually allowed to move along the edges. At each node there is an advice pointer pointing to one of its neighbors. The agent can move between two adjacent nodes in a unit of time and view the advice on the current node hosting it. Minimizing the expected runtime to find the treasure turns out to be non-trivial, and the crux of the problem is that the advice is permanent and therefore cannot be reinforced by audit."}, {"heading": "B General Dependencies", "text": "In the main text of the paper we will focus on two specific cases, those of independent doors and those of falling doors. In what follows, we will introduce the possibility of much more general dependencies and show that the two cases mentioned above are actually the most extreme and therefore prove their equivalence is enough to prove them for all cases. To this end, we must reconsider our basic definition of doors and knocks.Acyclic dependencies. We assume that the directed graph of dependencies between doors is acyclic. In such cases, the doors can be arranged in a topological order so that a door can only depend on lower index doors. In what follows, we will always assume that doors are ordered in such an order.Configuration. A configuration C for d doors can be indexed 1,."}, {"heading": "B.1 The Cascading and Independent Configurations", "text": "Considering the above definitions, we define the two most important configurations: 1. Basic doors. The distribution associated with a door is independent of whether other doors are open or not. Formally, door i > 1 cannot open unless door i \u2212 1 is already open. Only after door i \u2212 1 is opened, do we start knocking at door i. Formally, i \u2212 1,. Xk) = k ({1,.,.,..,. that door i \u2212 1 is not open if the number of Xjs is equal to {1,.,., i \u2212 1}. For configurations A and B, we say that A dominates if for each i and each X. (X1,.,.,.,.,.) we dominate."}, {"heading": "B.2 A Simple Upper Bound on the Price of Lacking Feedback", "text": "Claim 22. For each configuration C, price (C) \u2264 d. Proof. Denotes by X the cascading configuration that resembles C. Denotes \u03c0 = (1, 2,.., d) \u221e. With Lemma 1, TC \u2264 TC (\u03c0) \u2264 TX (\u03c0), the behavior of door i in the cascading case can be described in a simple way: It does not open until all the lower index doors are open, and from that point on behaves according to Pi. It follows that the expected number of door knockers i until it opens when counting begins after all doors j < i are open, exactly Ogg. In the order \u03c0, dEi needs to guarantee that the door i has been knocked several times. Thus, from the straightforwardness of the expectation, it follows that the expected time until we open all doors in X is at best d \u0445 d i = 1Ei. By dividing by \u0438 i = 1Ei, we obtain the result."}, {"heading": "B.3 Existence of an Optimal Sequence", "text": "Say that there is no optimal sequence. Let's remember that the basic distribution of each door allows it to be opened in finite, expected time. It is then easy to see that the sequence (1, 2,.. d) opens all doors in finite time, no matter what configuration the configuration is, as long as it is acyclic. Therefore, we can assume that I = inf\u03c0 TC (\u03c0) exist.Take a sequence of sequences \u03c0 (1), \u03c0 (2),.... where Limn \u2192 consecutive sequence TC (n) = I. W.l.o.g., we can assume that the sequence (n + 1) coincides with the sequence n in all the first n places. How so? There is at least one door number that appears as the first sequence that is resolved in an endless number of the sequence. Let's take such a number, and all sequences that do not appear in the first place."}, {"heading": "C Proofs Related to Section 2", "text": "C.1 Asimp is optimal up to a constant factor for identical Independent DoorsClaim = 5. If all doors are similar, then TI (Asimp) = vid (TI) is proof. According to Claim 23, there is a fixed sequence \u03c0 so that TI (\u03c0) = ti (t) indicates the number of doors i was knocked on over time, indicates (t) the number of doors i was knocked on over time t. Obviously, i \u03c0i (t) = t.TI = \u2212 p (p) (p) = p (t).) Over time t = number of doors tried more than 2t / d is the number of doors, less than d / 2. So at least half of the doors are."}, {"heading": "C.2 A Simple Algorithm for General Configurations Where all Doors are Similar", "text": "Claim 6. Indicate by \u03b1n the sequence 1 2n,.., d2 n. If all doors are similar, then for each configuration C, TC (\u03b10 \u00b7 \u03b11 \u00b7 \u03b12 \u00b7 \u00b7 \u00b7) = \u0432 (TC). Indicate \u03c0 = \u03b10 \u00b7 \u03b11 \u00b7 \u00b7, and note that | \u03b1n | = 2. For Lemma 1, we only need to consider TX (\u03c0). Suppose = d + 2d +. + 2. and use the right side of the observation 3 (where indices are shifted to take into account the fact that a0 is the first element and not a1): TX (\u03c0) \u2264 d + \u221e n = 0 2n + 1d \u00b7 SCX (\u03c0 [d + 2d +. TC +. + 2. + 2. + 2.)]) \u2264 d + 2 \u2012 n = 0 2. \u00b7 SCX (SCX) = 2 \u00b0 SCX (\u03b1n) = 0 2n \u2212 1d \u00b7 SCI (Asimp [2.] + 4TI (Asians + 2. + 2.) (Asians + 2.) (where we use the last stage) and (2. \u00b0)."}, {"heading": "C.3 Expected Maximum of iid Random Variables", "text": "Lemma 7. If X1,. \u2212 \u2212 If Xd i.i.i.d. are random variables taking into account natural numerical values, then: E [max (X1,., Xd) = \u0432 (3,.) p (n) p (n) = Pr [Xi > n]. The expectation we are interested in is: \u221e t = 0 1 \u2212 Pr [X \u2264 t] d = prognostically t = 0 1 \u2212 (1 \u2212 p (t) d (4) the first term is at least positive t = 0 1 \u2212 (1 \u2212 p (t)) d = positive t = 1 \u2212 (1 \u2212 1 \u2212 d) the first term is at least positive t = 1 \u2212 (1 \u2212 1 d) the second term is clearly p (1 \u2212 1 \u2212 d) and the second implicit d (1 \u2212 d)."}, {"heading": "C.4 Proofs for the Examples of Subsection 2.1.2", "text": "Example 9: p (n) = qn for any 1 / 2 < q < 1, then price = equal (log (d)). Proof. In this case: p = dlog1 / q (d) e, and E [Xi] = 1 / (1 \u2212 q), i.e. after (1): Price = (1 \u2212 q) log1 / q (d) + d (1 \u2212 q). Where we have used observation 25 below, the second term within the brackets is equal to dq \u00b2 1. The first term is at least: 1 \u2212 q ln (1 / q) ln (d) q q ln (d). Where we have used observation 25 below, it is at most: (1 \u2212 q) ln (d) 1 \u2212 q) ln (d)."}, {"heading": "D Proofs Related to Section 3", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "D.1 The Existence of an Optimal Semi-Fractional Sequence", "text": "Claim 26: There is an optimal semi-broken sequence \u03c0 =. That is, for each semi-broken sequence \u03c0 \u2032, E [\u03c0] \u2264 E [\u03c0 \u2032] evidence. Suppose it does not exist. However, it is clear that I = inf\u03c0 (E [\u03c0]) exists. Let us take a series \u03c0 1, \u03c02,. where we can assume that for each row i, the row {\u03c0 n] = I. We consider a sequence as its sequence of 1 knock lengths. That is, it is the length of the i-th 1 knock in \u03c0n. We show first that we can assume that for each i, the row {\u03c0ni | n \u2265 1} is jumped. To this end, we first establish that if for some semi-broken sequences \u03b1, E [\u03b1] < M, then for each i < Mq i \u2212 1 2. This is because we have probability of at least q i \u2212 1 of the algorithm actually knocking the i-th."}, {"heading": "D.2 Memoryless Doors Imply Memoryless Algorithms", "text": "Lemma 17. If w x-invariant and Ex [w\u03c0] \u2264 Ex [\u03c0] then Ex [w \u221e] \u2264 Ex [w\u03c0]. Proof. As in (2) there must be \u03b1: Ex [w\u03b1] = a + bEx [\u03b1] for each sequence, where a and b are functions of x and w. Since w is not empty and 1-beats reduce the state and 2-beats increase it, there must be at least one 2-beats in w, and thus b < 1. Thus: Ex [w\u03c0] = a + bEx [\u03c0] = a + bEx [\u03c0] \u2265 a + bEx [w\u03c0] = \u21d2 Ex [w\u03c0] \u2265 a1 \u2212 bOn the other hand: Ex [w \u221e] = a + bEx [w \u221e] = \u21d2 Ex [w \u0445] = a1 \u2212 bAnd we conclude from this."}, {"heading": "D.3 Approximating the Optimal Semi-Fractional Running Time", "text": "Theorem 18 gives a way to calculate the expectation of the best semi-fractional sequence \u03c0? for our configuration. Unfortunately, we were unable to get an approximate formula for this value."}, {"heading": "D.4 Similar Independent Memoryless Doors", "text": "Claim 28. Consider the configuration I of two similar doors which open independently with the probability p. Then TI (Asimp) = 3p \u2212 1.Proof. Until the first door opens (either door 1 or door 2), each knock has the probability p to open. Therefore, the first door opens in the expected time 1 / P. From this point on, every strange knock on the other door will be successful with the probability p. Thus, the expected time to open the second door after the first one opens is 2 / p \u2212 1, and overall we have expected the time 3 / p \u2212 1."}, {"heading": "D.5 The Golden Ratio", "text": "To return to the case in which c = 1 and p1 = p2 are very small. As we have already said, \u03b8 tends from term 27 to 1, and so it tends to be there (\u221a 5 \u2212 1) / 2. This is actually the value of z that minimizes the expression of theorem 18. If we look at the proof of the theorem, we get the length of 1 beats (except the first one), is = logq (x / y) = logq (q + px) = logq (1 \u2212 pz) = log (1 \u2212 pz) log (1 \u2212 p) For small x, log (1 + x) \u2248 x and the way that p goes to zero, the above ratio tends to z and in our case to \u0432. Thus, the length of 1 beats is a pronounced relation, and that of 2 beats is 1. In the long run, the length of the first 1 beats is insignificant, and the transformation of theorem 12 results in the ratio between the number of 2 beats and the ratio of 1-1, which is the gold-1."}], "references": [{"title": "On the complexity of trial and error", "author": ["Xiaohui Bei", "Ning Chen", "Shengyu Zhang"], "venue": "In Symposium on Theory of Computing Conference,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2013}, {"title": "Regret in decision making under uncertainty", "author": ["David E. Bell"], "venue": "Operations Research,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1982}, {"title": "The bayesian learner is optimal for noisy binary search (and pretty good for quantum as well)", "author": ["Michael Ben-Or", "Avinatan Hassidim"], "venue": "Annual IEEE Symposium on Foundations of Computer Science,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Searching on trees with noisy memory", "author": ["Lucas Boczkowski", "Amos Korman", "Yoav Rodeh"], "venue": "CoRR, abs/1611.01403,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2016}, {"title": "Decision making with and without feedback: The role of intelligence, strategies, executive functions, and cognitive styles", "author": ["Matthias Brand", "Christian Laier", "Mirko Pawlikowski", "Hans J. Markowitsch"], "venue": "Journal of Clinical and Experimental Neuropsychology,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2009}, {"title": "Deterministic and probabilistic binary search in graphs", "author": ["Ehsan Emamjomeh-Zadeh", "David Kempe", "Vikrant Singhal"], "venue": "In Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2016}, {"title": "Computing with noisy information", "author": ["Uriel Feige", "Prabhakar Raghavan", "David Peleg", "Eli Upfal"], "venue": "SIAM J. Comput.,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "Social Foraging Theory. Monographs in behavior and ecology", "author": ["L.A. Giraldeau", "T. Caraco"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2000}, {"title": "Noisy binary search and its applications", "author": ["Richard M. Karp", "Robert Kleinberg"], "venue": "In Proceedings of the Eighteenth Annual ACM-SIAM Symposium on Discrete Algorithms,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "The multi-armed bandit problem: Decomposition and computation", "author": ["Michael N. Katehakis", "Arthur F. Veinott", "Jr."], "venue": "Math. Oper. Res.,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1987}, {"title": "An Introduction to Computational Learning Theory", "author": ["Michael J. Kearns", "Umesh V. Vazirani"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1994}, {"title": "Toward more localized local algorithms: removing assumptions concerning global knowledge", "author": ["Amos Korman", "Jean-S\u00e9bastien Sereni", "Laurent Viennot"], "venue": "Distributed Computing,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "A simple parallel algorithm for the maximal independent set problem", "author": ["Michael Luby"], "venue": "SIAM J. Comput.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1986}, {"title": "Machine Learning. McGraw-Hill, Inc., New York, NY, USA, 1 edition", "author": ["Thomas M. Mitchell"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1997}, {"title": "Design and Analysis of Experiments", "author": ["Douglas C. Montgomery"], "venue": null, "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2006}, {"title": "Searching games with errors - fifty years of coping with liars", "author": ["Andrzej Pelc"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2002}, {"title": "Introduction to Reinforcement Learning", "author": ["Richard S. Sutton", "Andrew G. Barto"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1998}], "referenceMentions": [{"referenceID": 3, "context": "This research has actually originated from our research on heuristic search on trees [4].", "startOffset": 85, "endOffset": 88}, {"referenceID": 9, "context": "exploitation problems, where it is typically the case that deficient performances on the exploration part may result in much waste on the exploitation part [10, 17].", "startOffset": 156, "endOffset": 164}, {"referenceID": 16, "context": "exploitation problems, where it is typically the case that deficient performances on the exploration part may result in much waste on the exploitation part [10, 17].", "startOffset": 156, "endOffset": 164}, {"referenceID": 0, "context": "It can also be seen as the question of balance between searching and verifying in algorithms that can be partitioned thus [1, 15].", "startOffset": 122, "endOffset": 129}, {"referenceID": 14, "context": "It can also be seen as the question of balance between searching and verifying in algorithms that can be partitioned thus [1, 15].", "startOffset": 122, "endOffset": 129}, {"referenceID": 1, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 2, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 4, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 5, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 6, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 7, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 8, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 15, "context": ", [2, 3, 5, 6, 7, 8, 9, 16].", "startOffset": 2, "endOffset": 27}, {"referenceID": 16, "context": "Performing despite limited feedback would fit the framework of reinforced learning [17] and is inherent to the study of exploration vs.", "startOffset": 83, "endOffset": 87}, {"referenceID": 9, "context": "exploitation type of problems, including Multi-Armed Bandit problems [10].", "startOffset": 69, "endOffset": 73}, {"referenceID": 0, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 121, "endOffset": 128}, {"referenceID": 14, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 121, "endOffset": 128}, {"referenceID": 10, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 160, "endOffset": 172}, {"referenceID": 13, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 160, "endOffset": 172}, {"referenceID": 16, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 160, "endOffset": 172}, {"referenceID": 11, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 201, "endOffset": 209}, {"referenceID": 12, "context": "Numerous strategies are based on this interplay, including heuristics based on brute force or trail and error approaches [1, 15], sample and predict approaches [11, 14, 17], iterative local algorithms [12, 13], and many others.", "startOffset": 201, "endOffset": 209}, {"referenceID": 0, "context": "In this case, door i can be associated with a function pi : N\u2192 [0, 1], where pi(n) is the probability that door i is not open after knocking on it n times.", "startOffset": 63, "endOffset": 69}, {"referenceID": 0, "context": "In general, given a configuration, each door i defines a non-decreasing function pi : N\u2192 [0, 1], called the fundamental distribution of the door, where pi(n) is the probability that the door is not open after knocking on it n times in the best of conditions, i.", "startOffset": 89, "endOffset": 95}, {"referenceID": 1, "context": "n=1 2 \u00b7 SCI(\u03c0[2]) \u2264 2 + 4TI(\u03c0)", "startOffset": 13, "endOffset": 16}, {"referenceID": 0, "context": "E [\u03c0] = min z\u2208[0,1] ( logq1(1\u2212 z) + c+ (1\u2212 p2z) logq1(1\u2212 p2z) p2z )", "startOffset": 14, "endOffset": 19}, {"referenceID": 3, "context": "The following scenario, much simplified, is the focus of [4].", "startOffset": 57, "endOffset": 60}, {"referenceID": 3, "context": "It is shown in [4] that if q & 1/ \u221a \u2206, then no algorithm has running time which is polynomial in d.", "startOffset": 15, "endOffset": 18}, {"referenceID": 3, "context": "It is shown in [4] that \u03b1(l) \u2248 q for q < 1/ \u221a \u2206.", "startOffset": 15, "endOffset": 18}, {"referenceID": 3, "context": "Of course, assuming there is no feedback at all in this situation is an over approximation, and while it gives a non-trivial result, using much more sophisticated arguments, it is shown in [4] that there is an O( \u221a \u2206d) algorithm, and that it is in fact optimal.", "startOffset": 189, "endOffset": 192}, {"referenceID": 0, "context": ", i\u2212 1}} \u2192 [0, 1]", "startOffset": 11, "endOffset": 17}, {"referenceID": 0, "context": "For each door i, choose uniformly at random a real number ai \u2208 [0, 1].", "startOffset": 63, "endOffset": 69}, {"referenceID": 0, "context": "E [\u03c0] = min z\u2208[0,1] ( logq1(1\u2212 z) + c+ (1\u2212 p2z) logq1(1\u2212 p2z) p2z )", "startOffset": 14, "endOffset": 19}, {"referenceID": 0, "context": "By the definition of \u03b8 in the statement of the lemma, and denoting: Y = \u2212 (1\u2212 p2z) log(1\u2212 p2z) p2z We get: E [\u03c0] = 1 log(q1) min z\u2208[0,1] ( log(1\u2212 z)\u2212 \u03b8 z \u2212 Y )", "startOffset": 131, "endOffset": 136}, {"referenceID": 0, "context": "= 1 log(1/q1) min z\u2208[0,1] ( log ( 1 1\u2212 z ) + \u03b8 z + Y )", "startOffset": 20, "endOffset": 25}, {"referenceID": 0, "context": "It follows that: E [\u03c0] \u2208 1 log(1/q1) ( min z\u2208[0,1] ( log ( 1 1\u2212 z ) + \u03b8 z ) + [1\u2212 p2, 1] ) (5)", "startOffset": 45, "endOffset": 50}, {"referenceID": 0, "context": "Where we took the root that is in [0, 1].", "startOffset": 34, "endOffset": 40}], "year": 2017, "abstractText": "We introduce the dependent doors problem as an abstraction for situations in which one must perform a sequence of possibly dependent decisions, without receiving feedback information on the effectiveness of previously made actions. Informally, the problem considers a set of d doors that are initially closed, and the aim is to open all of them as fast as possible. To open a door, the algorithm knocks on it and it might open or not according to some probability distribution. This distribution may depend on which other doors are currently open, as well as on which other doors were open during each of the previous knocks on that door. The algorithm aims to minimize the expected time until all doors open. Crucially, it must act at any time without knowing whether or which other doors have already opened. In this work, we focus on scenarios where dependencies between doors are both positively correlated and acyclic. The fundamental distribution of a door describes the probability it opens in the best of conditions (with respect to other doors being open or closed). We show that if in two configurations of d doors corresponding doors share the same fundamental distribution, then these configurations have the same optimal running time up to a universal constant, no matter what are the dependencies between doors and what are the distributions. We also identify algorithms that are optimal up to a universal constant factor. For the case in which all doors share the same fundamental distribution we additionally provide a simpler algorithm, and a formula to calculate its running time. We furthermore analyse the price of lacking feedback for several configurations governed by standard fundamental distributions. In particular, we show that the price is logarithmic in d for memoryless doors, but can potentially grow to be linear in d for other distributions. We then turn our attention to investigate precise bounds. Even for the case of two doors, identifying the optimal sequence is an intriguing combinatorial question. Here, we study the case of two cascading memoryless doors. That is, the first door opens on each knock independently with probability p1. The second door can only open if the first door is open, in which case it will open on each knock independently with probability p2. We solve this problem almost completely by identifying algorithms that are optimal up to an additive term of 1.", "creator": "LaTeX with hyperref package"}}}