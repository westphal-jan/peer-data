{"id": "1704.08716", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Apr-2017", "title": "Artificial Intelligence Based Malware Analysis", "abstract": "Artificial intelligence methods have often been applied to perform specific functions or tasks in the cyber-defense realm. However, as adversary methods become more complex and difficult to divine, piecemeal efforts to understand cyber-attacks, and malware-based attacks in particular, are not providing sufficient means for malware analysts to understand the past, present and future characteristics of malware.", "histories": [["v1", "Thu, 27 Apr 2017 18:53:37 GMT  (7438kb,D)", "http://arxiv.org/abs/1704.08716v1", null]], "reviews": [], "SUBJECTS": "cs.CR cs.AI", "authors": ["avi pfeffer", "brian ruttenberg", "lee kellogg", "michael howard", "catherine call", "alison o'connor", "glenn takata", "scott neal reilly", "terry patten", "jason taylor", "robert hall", "arun lakhotia", "craig miles", "dan scofield", "jared frank"], "accepted": false, "id": "1704.08716"}, "pdf": {"name": "1704.08716.pdf", "metadata": {"source": "CRF", "title": "Artificial Intelligence Based Malware Analysis", "authors": ["Avi Pfeffera", "Brian Ruttenberga", "Lee Kellogg", "Michael Howard", "Catherine Call", "Alison O\u2019Connor", "Glenn Takata", "Scott Neal Reilly", "Terry Patten", "Jason Taylor", "Robert Hall", "Arun Lakhotia", "Craig Miles", "Dan Scofield", "Jared Frank"], "emails": ["apfeffer@cra.com", "bruttenberg@cra.com"], "sections": [{"heading": null, "text": "However, as the adversary's methods become more complex and difficult to divine, piecemeal efforts to understand cyber attacks and malware-based attacks, especially for malware analysts, do not offer sufficient means to understand the past, present and future characteristics of malware. In this article, we present the Malware Analysis and Attributed using Genetic Information (MAAGI) system. The underlying idea of the MAAGI system is that there are strong similarities between malware behavior and biological organism behavior, and the application of biologically inspired methods to analyze malware can help analysts better understand the malware attack ecosystem. Due to the complexity of the malware and the analysis, the MAAGI system relies heavily on artificial intelligence techniques to provide this capability."}, {"heading": "1. Introduction", "text": "Indeed, there is a huge need for artificial intelligence capable of automating tasks and supporting human analytics by reducing the space available to a patient for possible diagnostic procedures and helping the healthcare professionals underlying certain illnesses. [1] It is a field that has benefited enormously from the explosive growth of artificial intelligence. Spam filters, commercial detection systems are just a small example of artificial intelligence applications in the virtual world."}, {"heading": "2. Background and Motivation", "text": "In fact, most people are able to decide for themselves what they want and what they want."}, {"heading": "3. The Cyber Genome Program", "text": "The most important questions and answers on this topic are: What is the reason why we are able to change the world?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason?, \"he asked in the round.\" What is the reason? \"What is the reason?\" he asked in the round."}, {"heading": "4. Overview of MAAGI system", "text": "In fact, most of them are able to decide for themselves what they want."}, {"heading": "5. MAAGI Persistent Malware Hierarchy", "text": "While most malware analysis focuses on learning as much as possible about a particular malware binary, analysis is both facilitated and improved by first collecting incoming malware binaries in families with all previously seen malware. First, it supports the triage process by immediately associating new malware binaries with any similar, previously seen malware, making it possible to either assign those binaries to analysts familiar with that family, or to lower their priority if the family to which they are assigned is deemed uninteresting, or if the binary file is only superficially different from the malware analyzed previously. Second, providing cluster results to an analyst improves the potential quality of the information collected through the in-depth analysis process."}, {"heading": "5.1. Hierarchy", "text": "At the heart of our approach is a hierarchical data structure. Malware is inserted into the hierarchy as it is introduced into the system. The various steps of our incremental algorithm operate through this data structure, and there are a number of properties and constraints to support these operations. Hierarchy is a tree structure with nodes and edges, and there are no restrictions on the number of children a node can have. There is a single root at the top and the malware itself is on the leaves. All nodes that are not leaves are referred to as representatives of all malware among them. Just as the binaries in the system are represented by some characteristics, examples are presented in the same attribute space below them."}, {"heading": "5.2. Online Operation", "text": "The hierarchical organization of malware is an effective approach to managing the data volume, but we also need to take into account the speed at which new binaries are discovered and added to the system. As new malware binaries emerge quickly, we need a means to integrate them into the hierarchy that is fast, flexible, and precise, and places new binaries in new or existing families. A na\u00efve approach to controlling the flow of new binaries is to regroup the entire database after the arrival of a minimum number of new binaries to create a new hierarchy. Again, this has the obvious disadvantage that large amounts of the hierarchy remain unchanged, and unnecessary work is done with each regrouping. Another na\u00efve approach is to add new malware binaries to existing families in the hierarchy, using a certain classification algorithm. Again, this is problematic because families could not be changed, as binaries would never match the same families, even if they were arranged into different families."}, {"heading": "5.2.1. Algorithm Basics", "text": "Before going into more detail about the function of the incremental cluster algorithm, we first define some basic terms and concepts. Let H be a hierarchy of malware binaries in which each node i in the hierarchy is represented by a copy of egg and let Cni = {E1,..., Ek} be the descendants of the specimen egg in depth n. Furthermore, we define Fi the properties of egg in a attribute space F. F 0i are the original characteristics of egg at the time of its creation. We further define a function condition: F \u00b7 \u00b7 \u00b7 F \u2192 F, which aggregates characteristics from a series of examples into a single attribute representation. We now define what it means for a function condition to be transitive in the hierarchy. Definition 1. Transitive function Function Function is a function, Transitive function of the egg, Transitive function of the egg."}, {"heading": "5.2.2. Algorithm Detail", "text": "If a sufficient amount of new malware binaries is collected only after visiting all of their children, the algorithm is integrated into the hierarchy. However, the first thing the algorithm does is insert each new malware binary into an existing family in the hierarchy (Fig. 2). Since the existing families are defined in the hierarchy as sheet copies, the removal of each new malware copy is calculated using the removal function, and a child is added as a child to the minimum removal copy. If the existing families are added in the hierarchy, the removal of each new malware copy is marked as modified. After the classification step, we perform a post-processing of the hierarchy."}, {"heading": "5.2.3. Clustering Correctness", "text": "The hierarchy is a representation of a database of malware, and changes to the hierarchy should reflect only changes in the underlying database, which means that if the clustering algorithm changes, the algorithm will not be able to detect any changes in the underlying database, unless the clustering algorithm changes the algorithm. \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \""}, {"heading": "5.2.4. Clustering Time Complexity", "text": "Dre rf\u00fc rf\u00fc rf\u00fc rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc the rf\u00fc"}, {"heading": "5.3. Implementation", "text": "For an actual implementation of the system, a number of details must be specified, including a way to represent the elements in memory, a method to compare these representations, a \u03b8 function to aggregate them, to create representations of sample nodes, and a hierarchical cluster algorithm."}, {"heading": "5.3.1. Feature\u2013Based Representation", "text": "For the sake of brevity, we only provide a brief overview of the generation and presentation of features for malware binaries, and refer the reader to previous work for a complete description of malware feature extraction and analysis [12, 17, 18].While our system is defined to handle different feature types, a modified feature model representing the different features of an item provides the basis for our implementation. We extract three types of features from the malware that we use as words, the first two being the strings found in a binary date and the libraries it imports; the third type of feature is n-grams above the binary date procedure call graph (PCG). The PCG is a directed graph block extracted from a binary file, with the nodes included in the binary file and the edges."}, {"heading": "5.3.2. Creating Exemplars and Defining Distance", "text": "We must also define methods to create examples from a series of binary types or other examples (e.g. the actual distance is represented by a weighting). As explained in Section 5.2, we must define \u03b8 as a transitive function for the correct behaviour of the algorithm. We propose two methods in our implementation: intersection and weighted average. \u03b8 is simply defined as \u03b8 (F1,..., Fn) = F1-F2-F2-Fn.The definition of average examples is somewhat more complicated, as it is necessary to take into account the number of malware binary types represented by each child of an example. In this case, we must also assign a weighting to each word in the bag model. We define as\u03b8 (F1,., Fn) = {(f, wf)} distances represented by each child of an example."}, {"heading": "5.3.3. Other Parameters", "text": "In addition to the preferred measure of distance and pattern hierarchy, the user is confronted with additional choices regarding the preferred cluster algorithm, along with its adjustable parameters. \"Join Neighbor\" [21] and \"Lion\" [15] are both practicable hierarchical cluster methods implemented in our system. While both methods have proven successful, specific conditions or preferences can cause the user to execute one instead of the other. Another adjustable parameter arises from the fact that the hierarchical cluster algorithms return a hierarchy that extends to each individual element so that no element shares one parent. At this point, each element is located in its own family. To create a hierarchy that represents the optimal family mapping, the hierarchy must be flattened by merging families from the bottom to the point at which the items are optimally grouped under the same parent."}, {"heading": "5.4. Experiments", "text": "To test our system, we conducted various experiments to evaluate its effectiveness in various areas, including the scalability of the system, the correctness of the families it produces, its sensitivity to various parameters, and its ability to adapt to changes in implementation details, and how these changes affect accuracy and speed."}, {"heading": "5.4.1. Datasets and Metrics", "text": "For our correctness tests, we used a set of 8,336 malware binaries provided by MIT Lincoln Labs during the Independent Verification and Validation (IV & V) of the Cyber Genome Program. The data set included 128 clean-room binaries created by MIT Lincoln Labs and comprised six different families of malware, 128 of which provided the basic truth; the others were gathered from the wilderness and provided the background for the test; the accuracy of a cluster was determined by performing cluster evaluation metrics using cluster assignments for the 128 binaries; the metrics used were the Jaccard Index, Purity, Inverse Purity, and Adjusted Rand Index. Jaccard Index is defined as the number of pairs of elements of the same truth family correctly assigned to the same cluster, divided by the number of pairs belonging to the same truth family and / cluster assigned to the same."}, {"heading": "5.4.2. Base Accuracy Results", "text": "To assess the accuracy of our incremental system, we compared the clustering produced by our system with that by simply clustering the entire data set at once, both using the Neighbor Join algorithm for clustering. The incremental run uses batches of 1,000 binaries and sets dr to 6 (to put that in perspective, there is an incremental hierarchy about this data set typically in the order of 50-100 generations deep). Fig 4 (a) also shows the evaluation metrics for both methods. Both rate well the families on the 128 ground truth binaries, where the incremental method is only slightly inferior to the single batch version. The entire incremental result (all 8,336 binaries) was also obtained using the single batch run as the truth, which has the overall high similarity between the two cluster assignments for the entire data set, whereas the incremental result (all 8,336 binaries) is slightly inferior to the single batch run."}, {"heading": "6. MAAGI Analysis Framework", "text": "The MAAGI system includes several malware analysis tools that rely heavily on AI techniques to analyze the capabilities of the user. Each of these techniques builds on the malware hierarchy described in paragraph 5.1, which serves as a permanent organization of the detected malware in families. Details of each of the analyses are presented in the following sections."}, {"heading": "6.1. Component Identification", "text": "Malware development is often guided by the sharing and adaptation of functional components that fulfil a desired purpose. Therefore, the ability to identify shared components of malware is of central importance for the problem of determining similarities and evolution of malware. A component can be considered as a region of binary codes that logically implements a \"unit\" of malicious operations. For example, the code responsible for key logging would be a component. Components are specifically aimed at providing a specific malware capability. Sharing functional components within a malware component corpus would thus give insight into the functional relationships between the binary files in a corpus and suggest a connection between their attackers. Detecting the existence of such shared components is not a trivial task. The function of a component is the same in each malware component corpus, but the instantiation of the components in each binary system may be different authors of the individual components or cause different optimizations in the component components."}, {"heading": "6.1.1. Generative Process", "text": "The basic idea of the unattended learning task can be seen as the reverse engineering of a malware-generative process, as in Fig. 5. A malware binary file consists of several shared components that perform malicious operations, each component consisting of one or more procedures. Similarly, we assume that each procedure is represented by a set of characteristics; in our system, characteristics are extracted from the code blocks of the procedure, but abstractly they can be any meaningful feature of a procedural. The basic idea behind our method is that characteristics from the procedures between instances of the same component found in different binaries should be similar to each other. Due to authorship, polymorphism, and compiler variations or optimizations, they cannot be exact. However, we expect that two functionally similar procedures initiated in different binaries should be more similar to each other than a random process from the learning corpus that forms the basis for our identification process."}, {"heading": "6.1.2. Basic Algorithm", "text": "This means that we cannot assume that every method consists of a set of significant features that describe the function of the method. However, details of the features we apply in our implementation and evaluation can be found in sections 6.1.4 and 6.1.6.1. However, we are only able to observe Ti, j, which is the instance of the ith component in Mj. If the component is not part of the binary Mj, then the component is not part of the binary Mj, j, j is undefined."}, {"heading": "6.1.3. Assumption Relaxation", "text": "Consider the example shown in Fig. 8. There are two components in four binary packages, each of which consists of two procedures. Assuming that the uniqueness of the component is incorrect, the second procedure in each binary package may be very similar to each other (it is possible that they perform a basic function to set up malicious behavior). After the first step, p2,1, p2,2, p2,3, and p2,4 are placed in the same cluster, resulting in the creation of ~ S2 that is not similar to any other cluster vector. Therefore, any clustering of ~ S2 with ~ S1 or ~ S3 leads to an incorrect identification of the procedures in each component. To correct this error, we use an algorithm called cluster \"column,\" which is detected in the first step of the algorithm before the second stage of clustering is performed."}, {"heading": "6.1.4. Implementation", "text": "The number, size, function and distribution of these components is generally unknown, so our system architecture reflects a combination of unattended learning methods coupled with a semantic generalization of binary codes. The system uses two main components: 1. BinJuice: To extract the processes and generate appropriate juice traits; 2. Clustering Engine: To perform actual clustering based on the properties, we use the BinJuice system from Lakhotia et al. [12] to translate the code of each base block into four types of traits: code, semantics, gene semantics and gene code. Since each trait is a string, they can be represented by a specified size hash, such as md5. Since a procedure consists of a series of base blocks, a procedure is presented as a disordered set of hashes on the blocks of the procedure."}, {"heading": "6.1.5. Clustering Engine", "text": "For the first phase of clustering, we choose a data-driven clustering method. Therefore, even if we know the number of divided components in a corpus, it is much less likely that we know how many procedures are in each component. Therefore, it makes sense to use a method that is not based on prior knowledge of the number of procedure clusters. We use Louvain clustering for the cluster step of the procedure [15]. Louvain clustering is a greedy agglomerative clustering method, originally formulated as a graph cluster algorithm that uses modularity optimization [23]. We consider procedures as nodes in a graph and the weighting of edges between nodes as a Jaccard index between procedural features. Modularity optimization attempts to maximize the modularity of a graph that is defined as groups of procedures that exhibit a higher intra-group similarity and lower cluster similarity than cluster formation combined together."}, {"heading": "6.1.6. Experiments", "text": "This year, it has reached the point where it is a kind of infinite forest in which people find themselves in the forests of the world."}, {"heading": "6.2. Lineage", "text": "As a result, malware within a malware family (i.e. malware that is closely related in function and structure) often has strong parent-child relationships (or parents and children). Determining the nature of these relationships within a malware family can be a useful tool for understanding how malware evolves over time, which parts of the malware are transmitted from parent to child, and how quickly that development occurs. Analyzing the malware is a common task for malware analysis, and one that has always relied on artificial intelligence."}, {"heading": "6.2.1. Lineage as a Probabilistic Model", "text": "This year, it has come to the point where it only takes one year to get there, to get old."}, {"heading": "6.2.2. Inference Algorithm", "text": "As shown in Eqn. 4, the line provided by the MAAGI system to the user subsequently is the maximum probability line given the creation times and the malware features. Since the creation times are unknown, we need to derive both the line and the creation times jointly. To achieve this, we have an iterative algorithm (similar to the expectation maximization) to collectively derive the most likely binary creation time and line. The algorithm runs as follows, and is also shown in the figure."}, {"heading": "6.2.3. Learning", "text": "For example, we need to know the previous probability that the timestamp of a binary was obscured, and all the parameters of the conditional probability of the time in which the malware was first seen in the wild due to its origin. To determine these parameters, we learn them from a training dataset, as in Fig. 15. We create three previous variables, each of which is a beta distribution. The obfuscation variables that the priors use are Bernoulli random variables, whereas the conditional probability distribution between the observed time and the creation time is an exponential distribution (still using a beta distribution as the previous one). The learning process is as follows: We take a value of the priors and calculate the probability of the proof of the model that indicates the previous values if the proof is the time and the timestamp information for each binary."}, {"heading": "6.2.4. Implementation and Experiments", "text": "In fact, it is such that most people are able to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to fight, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to move, to"}, {"heading": "6.3. Trend Prediction", "text": "The attacker initiates an attack, and the defenders must find a way to respond to the attack, mitigate its damage, and prevent a repetition, a process that inevitably favors the attacker. Preventive cyber defense has the potential to shift the advantage away from the attacker and toward the defender. In preventive defense, the defender tries to predict future attacks and respond to them before they happen, but requires an effective ability to predict future cyber developments. So far, most malware trend analyses are retrospective analyses of existing malware [3] or predictions that reflect the opinions of human experts and have a broad, high-level focus [27, 28]. This kind of prediction may not be of practical use for a malware analyst, as they are unable to quantify the threat level of a malware family or trend. A number of tools and systems that make predictions of novelty or malware anomalies may not be significant in terms of malware analytics suggested under the rule of significant malware changes in individual malware analyses."}, {"heading": "6.3.1. Prediction Problem", "text": "When a new binary malware is encountered (i.e., a malware that is not clustered into an existing family), the MAAGI prediction tool tries to predict different characteristics of the entire family from the individual instance of the family, as shown in Fig. 18. The tool first extracts a set of characteristics from the binary, which are used as input values for the prediction algorithm. Attributes at the family level are ultimately derived from the characteristics of the binary ones they contain. Temporal aspects of the family are derived from an external source such as VirusTotal.The list of characteristics that are extracted from a binary malware is as follows: 1. The number of blocks, library imports, strings and procedures contained in a binary family; 2. The average length of a block in a binary.3. The number of rare and unique blocks, strings, imports and procedures contained in a binary."}, {"heading": "6.3.2. Prediction Methods and Training", "text": "The prediction frame consists of a set of prediction algorithms that are applied to a user-supplied malware. However, before this, we must select a set of training data, a prediction model or algorithm, and a test set of data. We first use a feature aggregation program to extract properties from a feature database and create a data set that is suitable as input for machine learning models. A set of families and binary data is provided as input to the aggregation program, along with a data set that is trained on the input features of the earliest binary in each cluster (family) and that predicts the corresponding output properties of the full family. Models are trained separately against each output action."}, {"heading": "6.3.3. Experiments and Results", "text": "This year, it has come to the point where it only takes one year to get to the next round."}, {"heading": "6.4. Functional Analysis", "text": "The objective of Functional Analysis (FP) is to perform a more thorough and in-depth analysis of malware in order to characterize its function and context. Functional Analysis recognizes multiple purposes that exist simultaneously in a malware sample, and uses structured, context-based considerations to infer complex purposes. For example, the theft of credentials is a complex purpose that involves the capture of credentials and the extraction of data, each of which can be realized in a variety of ways. This reasoning includes basic characterizations of the attack and the attacker, such as the degree of complexity. Functional Analysis uses only the results of static analysis. We have found that in many cases a malware sample does not exhibit its behavior in a sandbox, so we cannot rely on dynamic analyses. However, the use of only static analyses is more difficult because API calls in static code are not structured by nature, so we cannot start from the order of the API calls."}, {"heading": "FA Request (From MAAGI Analysis Client)", "text": "Since we only use static analysis results, we cannot directly apply NLP methods, which depend on the arrangement of words in a sentence. We have to treat a sentence with a bag of word models and try to identify components of meaning from it. Similarly, as in language, we can analyze writing skills based on the sentence and word complexity, so that in the malware we can identify attack and attack characteristics based on the words used and their organization. Our representation is based on the systemic functional linguistics that Grammars (SFGs) organizes according to the function and context of the language. They provide a functional hierarchy for meaning and purpose, as well as an overlapping context hierarchy for the context. Therefore, it is possible to judge the purpose and context of the words. Similar mechanisms can be used to puzzle about the function and characteristics of the malware."}, {"heading": "6.4.1. Functional Analysis Design", "text": "Fig.20 describes the functional analysis workflow.The creation of a static analysis call chart, step 1 above, is transparently triggered when a sample is submitted for static analysis. Steps 2-5: Lexical analysis, analysis, analysis-prioritization, and report generation; initiated by a user request and performed within the functional analysis software component (detailed in the next section).As illustrated in Fig. 21, the system performs analysis at several different stages, each passing its results on to the next. The system enters three sets of data, the first two representing domain knowledge and the conclusions the system is trying to make; that is, the systemic functional grammar that captures generalizations and characterizations of malicious software functions, and the preprocessor definition file that provides preprocessing instructions and grammar metadata. These files represent domain knowledge and tend to be static."}, {"heading": "6.4.2. Grammar Representation", "text": "In this context, it has to be said that the solution to problems that have arisen in the past is not a solution, but a solution that is capable of bringing about a solution."}, {"heading": "6.4.3. Parsing and Classification", "text": "Essentially, SFG layers are analogous to decision trees, with realization rules serving as queries about what conditions (vis-\u00e0-vis characteristics) are observed in a given set of inputs. Each permutation of decisions in the contextual layer represents a possible context in a given area, and the permutation of decisions in the grammatical layer that remain out of that context after preselection represents the space of possible interpretations of the data for the context. Conversely, in an interpretation that is known to be valid, we can derive the contexts that support it. We refer to the feature set in an interpretation and its context as a traverse. The set of realization rules associated with a traverse are the series of queries that must be fulfilled for the characteristics of that traverse to be valid for the input data. As mentioned above, these rules take the form of constraints, and thus a traverse describes an expression over a traverse."}, {"heading": "6.4.4. Testing and Experimentation", "text": "Functional analysis in MAAGI has been able to reliably function through a set of 283 unpacked malware samples (CITE) from the Banker Family, while providing accurate characterizations of their command and control behavior and theft of personal information. However, having tracked a large number of alternative approaches to this and related malicious activations, we have identified some of the limitations and successes of functional analysis in MAAGI. However, currently, the MAAGI Systemic Functional Grammar Parser (SFG) and the Grammar Representation Language can express an impressive variety of malware behaviors and actions. However, in our current environment, the lack of data flow and time information can limit the variety of behaviors expressed. If two behaviors differ only in terms of data flow or runtime characteristics, the grammatical representation of these two behaviors is identical. Often, this information is the key to distinguish between the same sample and a malicious one."}, {"heading": "7. Conclusion", "text": "In this article, we introduced the MAAGI malware analysis system, which leverages many of the advances in artificial intelligence in recent decades to provide malware analysts with a comprehensive system to understand the past, present and future features of malware. As a practical application of artificial intelligence, the MAAGI system will have a huge impact on the cyber defense community. Although the cyber defense community has always used artificial intelligence methods to analyze malware, to the best of our knowledge no one has yet attempted to integrate these technologies into a single system where various analyses use the results of other analyses to model, learn and predict characteristics of malware. We hope that the MAAGI system will also inspire other innovative artificial intelligence applications in the cyber defense community. To this end, the MAAGI system is also expandable, and we envision that new and intelligent methods for analyzing malware in the future will be integrated into the system, making cyber-defenders a powerful tool for combating malware."}, {"heading": "8. Acknowledgments", "text": "This work was supported by DARPA under the contract with the US Air Force FA8750-10-C-0171, with thanks to Timothy Fraser. The views expressed are those of the authors and do not reflect the official policy or position of the Department of Defense or the US government."}], "references": [{"title": "Artificial intelligence in medical diagnosis", "author": ["P. Szolovits", "R.S. Patil", "W.B. Schwartz"], "venue": "Annals of internal medicine 108 (1) ", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1988}, {"title": "Artificial intelligence in cyber defense", "author": ["E. Tyugu"], "venue": "in: Cyber Conflict (ICCC), 2011 3rd International Conference on, IEEE", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "BitShred: feature hashing malware for scalable triage and semantic analysis", "author": ["J. Jang", "D. Brumley", "S. Venkataraman"], "venue": "in: Proceedings of the 18th ACM conference on Computer and communications security, CCS \u201911, ACM, New York, NY, USA", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2011}, {"title": "Scalable", "author": ["U. Bayer", "P.M. Comparetti", "C. Hlauschek", "C. Kruegel", "E. Kirda"], "venue": "behavior-based malware clustering., in: NDSS, Vol. 9, Citeseer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Automatic analysis of malware behavior using machine learning", "author": ["K. Rieck", "P. Trinius", "C. Willems", "T. Holz"], "venue": "Journal of Computer Security 19 (4) ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Scalable fine-grained behavioral clustering of http-based malware", "author": ["R. Perdisci", "D. Ariu", "G. Giacinto"], "venue": "Computer Networks 57 (2) ", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Incremental hierarchical clustering of text documents", "author": ["N. Sahoo", "J. Callan", "R. Krishnan", "G. Duncan", "R. Padman"], "venue": "in: Proceedings of the 15th ACM international conference on Information and knowledge management, ACM", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2006}, {"title": "Malware phylogeny generation using permutations of code", "author": ["M.E. Karim", "A. Walenstein", "A. Lakhotia", "L. Parida"], "venue": "Journal in Computer Virology 1 (1-2) ", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2005}, {"title": "Fast location of similar code fragments using semantic \u2018juice", "author": ["A. Lakhotia", "M. Dalla Preda", "R. Giacobazzi"], "venue": "in: SIGPLAN Program Protection and Reverse Engineering Workshop, ACM", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "On the resemblance and containment of documents", "author": ["A.Z. Broder"], "venue": "in: Compression and Complexity of Sequences 1997. Proceedings, IEEE", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1997}, {"title": "Practical probabilistic programming", "author": ["A. Pfeffer"], "venue": "in: Inductive Logic Programming, Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Fast unfolding of communities in large networks", "author": ["V.D. Blondel", "J.-L. Guillaume", "R. Lambiotte", "E. Lefebvre"], "venue": "Journal of Statistical Mechanics: Theory and Experiment 2008 (10) ", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2008}, {"title": "J", "author": ["A. Pfeffer", "C. Call", "J. Chamberlain", "L. Kellogg", "J. Ouellette", "T. Patten", "G. Zacharias", "A. Lakhotia", "S. Golconda"], "venue": "Bay, et al., Malware analysis and attribution using genetic information, in: Malicious and Unwanted Software (MALWARE), IEEE", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "Identifying shared software components to support malware forensics", "author": ["B.E. Ruttenberg", "C. Miles", "L. Kellogg", "V. Notani", "M. Howard", "C. LeDoux", "A. Lakhotia", "A. Pfeffer"], "venue": "in: To appear in 11th Conference on Detection of Intrusions and Malware and Vulnerability Assessment", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2014}, {"title": "The distribution of the flora in the alpine zone", "author": ["P. Jaccard"], "venue": "1, New phytologist 11 (2) ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1912}, {"title": "M", "author": ["N. Saitou"], "venue": "Nei, The neighbor-joining method: a new method for reconstructing phylogenetic trees., Molecular biology and evolution 4 (4) ", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1987}, {"title": "Pattern Recognition", "author": ["S. Theodoridis", "K. Koutroumbas"], "venue": "Elsevier Science", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2008}, {"title": "Modularity and community structure in networks", "author": ["M.E. Newman"], "venue": "Proceedings of the National Academy of Sciences 103 (23) ", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2006}, {"title": "Comparing partitions", "author": ["L. Hubert", "P. Arabie"], "venue": "Journal of classification 2 (1) ", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1985}, {"title": "Towards automatic software lineage inference", "author": ["J. Jang", "M. Woo", "D. Brumley"], "venue": "in: Proceedings of the 22nd USENIX conference on Security, USENIX Association", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Neuer beweis eines satzes \u00fcber permutationen", "author": ["H. Pr\u00fcfer"], "venue": "Arch. Math. Phys 27 ", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1918}, {"title": "Malware threats, trend and predictions for 2014, McAfee Labs", "author": ["R. Blanch"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2014}, {"title": "Malware classification method via binary content comparison", "author": ["B. Kang", "T. Kim", "H. Kwon", "Y. Choi", "E.G. Im"], "venue": "in: Proceedings of the 2012 ACM Research in Applied Computation Symposium, ACM", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2012}, {"title": "Specialized genetic algorithm based simulation tool designed for malware evolution forecasting", "author": ["V. Juzonis", "N. Goranin", "A. Cenys", "D. Olifer"], "venue": "in: Annales UMCS, Informatica, Vol. 12", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2012}, {"title": "Introduction to the logistic regression model", "author": ["D.W. Hosmer", "S. Lemeshow", "R.X. Sturdivant"], "venue": "Wiley Online Library", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2000}, {"title": "Distilling free-form natural laws from experimental data", "author": ["M. Schmidt", "H. Lipson"], "venue": "science 324 (5923) ", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2009}, {"title": "Logistic regression and artificial neural network classification models: a methodology review", "author": ["S. Dreiseitl", "L. Ohno-Machado"], "venue": "Journal of biomedical informatics 35 (5) ", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2002}, {"title": "LIBSVM: A library for support vector machines", "author": ["C.-C. Chang", "C.-J. Lin"], "venue": "ACM Transactions on Intelligent Systems and Technology 2 ", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2011}, {"title": "The cn2 induction algorithm", "author": ["P. Clark", "T. Niblett"], "venue": "Machine learning 3 (4) ", "citeRegEx": "37", "shortCiteRegEx": null, "year": 1989}, {"title": "Induction of decision trees", "author": ["J.R. Quinlan"], "venue": "Machine learning 1 (1) ", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1986}], "referenceMentions": [{"referenceID": 0, "context": "For instance, artificial intelligence is often applied in the medical field to assist in diagnostic efforts by reducing the space of possible diagnoses for a patient and helping medical professionals understand the complex processes underlying certain diseases [1].", "startOffset": 261, "endOffset": 264}, {"referenceID": 1, "context": "Spam filters, commercial malware software, and intrusion detection systems are just small example of applications of artificial intelligence to the cyber security realm [2].", "startOffset": 169, "endOffset": 172}, {"referenceID": 2, "context": "The triage phase typically involves some signature or hash\u2013based filtering [4].", "startOffset": 75, "endOffset": 78}, {"referenceID": 3, "context": "A lot of work has been done towards applying clustering techniques to malware, including approaches based on locality\u2013 sensitive hashing [5], prototype\u2013based hierarchical clustering and classification [6], and other incremental hierarchical approaches [7, 8].", "startOffset": 137, "endOffset": 140}, {"referenceID": 4, "context": "A lot of work has been done towards applying clustering techniques to malware, including approaches based on locality\u2013 sensitive hashing [5], prototype\u2013based hierarchical clustering and classification [6], and other incremental hierarchical approaches [7, 8].", "startOffset": 201, "endOffset": 204}, {"referenceID": 5, "context": "A lot of work has been done towards applying clustering techniques to malware, including approaches based on locality\u2013 sensitive hashing [5], prototype\u2013based hierarchical clustering and classification [6], and other incremental hierarchical approaches [7, 8].", "startOffset": 252, "endOffset": 258}, {"referenceID": 6, "context": "A lot of work has been done towards applying clustering techniques to malware, including approaches based on locality\u2013 sensitive hashing [5], prototype\u2013based hierarchical clustering and classification [6], and other incremental hierarchical approaches [7, 8].", "startOffset": 252, "endOffset": 258}, {"referenceID": 7, "context": "Research has been done towards automatically learning lineages of malware families [10], and even smarter methods based on AI techniques could provide major improvements and time savings over human analyst\u2013driven methods.", "startOffset": 83, "endOffset": 87}, {"referenceID": 8, "context": "In addition to other features of the binary including strings and API imports, it generates a semantic representation of the function of code blocks, called BinJuice [12].", "startOffset": 166, "endOffset": 170}, {"referenceID": 9, "context": "Search functions are also available to allow users to find related samples according to their features, including searches for specific features, text\u2013based searches, and searches for the most similar procedures in the database to a particular procedure, which uses MinHash [13] as an approximation of the similarity between sets of BinJuice blocks.", "startOffset": 274, "endOffset": 278}, {"referenceID": 10, "context": "Lineage analysis uses a probabilistic model of malware development, built using the Figaro probabilistic programming language [14], to learn an inheritance graph over a set of malware.", "startOffset": 126, "endOffset": 130}, {"referenceID": 11, "context": "In the first step it clusters together similar procedures across the set of binaries using Louvain clustering, which is a greedy agglomerative clustering method [15].", "startOffset": 161, "endOffset": 165}, {"referenceID": 8, "context": "For brevity, we only provide a brief overview of the feature generation and representation for malware binaries, and refer the reader to previous works for a complete description of malware feature extraction and analysis [12, 17, 18].", "startOffset": 222, "endOffset": 234}, {"referenceID": 12, "context": "For brevity, we only provide a brief overview of the feature generation and representation for malware binaries, and refer the reader to previous works for a complete description of malware feature extraction and analysis [12, 17, 18].", "startOffset": 222, "endOffset": 234}, {"referenceID": 13, "context": "For brevity, we only provide a brief overview of the feature generation and representation for malware binaries, and refer the reader to previous works for a complete description of malware feature extraction and analysis [12, 17, 18].", "startOffset": 222, "endOffset": 234}, {"referenceID": 9, "context": "The labels of the n\u2013grams are based on MinHashing [13], a technique typically used to approximate the Jaccard Index [19] between two sets.", "startOffset": 50, "endOffset": 54}, {"referenceID": 14, "context": "The labels of the n\u2013grams are based on MinHashing [13], a technique typically used to approximate the Jaccard Index [19] between two sets.", "startOffset": 116, "endOffset": 120}, {"referenceID": 8, "context": "Each procedure is composed of a set of code blocks, and each block is represented by its BinJuice [12], a representation of the semantic function of a code block that also abstracts away registers and memory addresses.", "startOffset": 98, "endOffset": 102}, {"referenceID": 15, "context": "The Neighbor Join [21] and Louvain methods [15] are both viable hierarchical clustering methods implemented in our system.", "startOffset": 18, "endOffset": 22}, {"referenceID": 11, "context": "The Neighbor Join [21] and Louvain methods [15] are both viable hierarchical clustering methods implemented in our system.", "startOffset": 43, "endOffset": 47}, {"referenceID": 0, "context": "Hence, we convert this cluster into the point ~ S1 = [1, 0, 0, 1], and convert the other clusters into the vector space representation as well.", "startOffset": 53, "endOffset": 65}, {"referenceID": 0, "context": "Hence, we convert this cluster into the point ~ S1 = [1, 0, 0, 1], and convert the other clusters into the vector space representation as well.", "startOffset": 53, "endOffset": 65}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 5, "endOffset": 17}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 5, "endOffset": 17}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 23, "endOffset": 35}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 23, "endOffset": 35}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 23, "endOffset": 35}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 23, "endOffset": 35}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 41, "endOffset": 53}, {"referenceID": 0, "context": "S1 = [1, 0, 1, 0] S2 = [1, 1, 1, 1] S3 = [0, 1, 0, 1] C1 C3 C2 M4 M3 M2", "startOffset": 41, "endOffset": 53}, {"referenceID": 13, "context": "[18] for more details.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "\u2019s BinJuice system [12] to translate the code of each basic block into four types of features: code, semantics, gen semantics, and gen code.", "startOffset": 19, "endOffset": 23}, {"referenceID": 16, "context": "We measure similarity between a pair of procedures using the Jaccard index [22] of their sets of features.", "startOffset": 75, "endOffset": 79}, {"referenceID": 11, "context": "We use Louvain clustering for the procedure clustering step [15].", "startOffset": 60, "endOffset": 64}, {"referenceID": 17, "context": "Louvain clustering is a greedy agglomerative clustering method, originally formulated as a graph clustering algorithm that uses modularity optimization [23].", "startOffset": 152, "endOffset": 156}, {"referenceID": 18, "context": "We also used the Adjusted Rand Index [24] to measure how effective our algorithm is at finding binaries with the same components.", "startOffset": 37, "endOffset": 41}, {"referenceID": 7, "context": "used unsupervised clustering methods to construct a lineage of a well\u2013known worm [10].", "startOffset": 81, "endOffset": 85}, {"referenceID": 19, "context": "[25] also used unsupervised clustering to infer the order and a subsequent straight line lineage of a set of malware.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "For a set of N synthetic binaries, we first created ground\u2013truth lineages from randomly generated Prufer sequences [26].", "startOffset": 115, "endOffset": 119}, {"referenceID": 21, "context": "To date, most malware trend analyses are retrospective analyses of existing malware [3], or are predictions that reflect the opinions of human experts and have a broad, high level focus [27, 28].", "startOffset": 186, "endOffset": 194}, {"referenceID": 22, "context": "A number of tools and systems [29, 30, 31] have been proposed for detecting novelty or anomaly among individual malware binaries.", "startOffset": 30, "endOffset": 42}, {"referenceID": 23, "context": "A number of tools and systems [29, 30, 31] have been proposed for detecting novelty or anomaly among individual malware binaries.", "startOffset": 30, "endOffset": 42}, {"referenceID": 24, "context": "This includes generalized linear models such as logistic[32] and Poisson regression[33]; genetic algorithms learning formulas of input features[34]; neural networks[35]; support vector machines with sigmoid, polynomial, radial basis and linear kernels[16][36]; CN2 rules[37], and classification trees and", "startOffset": 56, "endOffset": 60}, {"referenceID": 25, "context": "This includes generalized linear models such as logistic[32] and Poisson regression[33]; genetic algorithms learning formulas of input features[34]; neural networks[35]; support vector machines with sigmoid, polynomial, radial basis and linear kernels[16][36]; CN2 rules[37], and classification trees and", "startOffset": 143, "endOffset": 147}, {"referenceID": 26, "context": "This includes generalized linear models such as logistic[32] and Poisson regression[33]; genetic algorithms learning formulas of input features[34]; neural networks[35]; support vector machines with sigmoid, polynomial, radial basis and linear kernels[16][36]; CN2 rules[37], and classification trees and", "startOffset": 164, "endOffset": 168}, {"referenceID": 27, "context": "This includes generalized linear models such as logistic[32] and Poisson regression[33]; genetic algorithms learning formulas of input features[34]; neural networks[35]; support vector machines with sigmoid, polynomial, radial basis and linear kernels[16][36]; CN2 rules[37], and classification trees and", "startOffset": 255, "endOffset": 259}, {"referenceID": 28, "context": "This includes generalized linear models such as logistic[32] and Poisson regression[33]; genetic algorithms learning formulas of input features[34]; neural networks[35]; support vector machines with sigmoid, polynomial, radial basis and linear kernels[16][36]; CN2 rules[37], and classification trees and", "startOffset": 270, "endOffset": 274}, {"referenceID": 29, "context": "random forests[38].", "startOffset": 14, "endOffset": 18}], "year": 2017, "abstractText": "Artificial intelligence methods have often been applied to perform specific functions or tasks in the cyber\u2013 defense realm. However, as adversary methods become more complex and difficult to divine, piecemeal efforts to understand cyber\u2013attacks, and malware\u2013based attacks in particular, are not providing sufficient means for malware analysts to understand the past, present and future characteristics of malware. In this paper, we present the Malware Analysis and Attributed using Genetic Information (MAAGI) system. The underlying idea behind the MAAGI system is that there are strong similarities between malware behavior and biological organism behavior, and applying biologically inspired methods to corpora of malware can help analysts better understand the ecosystem of malware attacks. Due to the sophistication of the malware and the analysis, the MAAGI system relies heavily on artificial intelligence techniques to provide this capability. It has already yielded promising results over its development life, and will hopefully inspire more integration between the artificial intelligence and cyber\u2013defense communities.", "creator": "LaTeX with hyperref package"}}}