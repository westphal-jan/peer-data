{"id": "1705.00047", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Apr-2017", "title": "Kiwi - A Minimalist CP Solver", "abstract": "Kiwi is a minimalist and extendable Constraint Programming (CP) solver specifically designed for education. The particularities of Kiwi stand in its generic trailing state restoration mechanism and its modulable use of variables. By developing Kiwi, the author does not aim to provide an alternative to full featured constraint solvers but rather to provide readers with a basic architecture that will (hopefully) help them to understand the core mechanisms hidden under the hood of constraint solvers, to develop their own extended constraint solver, or to test innovative ideas.", "histories": [["v1", "Fri, 28 Apr 2017 19:34:19 GMT  (6239kb)", "http://arxiv.org/abs/1705.00047v1", null], ["v2", "Tue, 2 May 2017 01:18:47 GMT  (6239kb)", "http://arxiv.org/abs/1705.00047v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.SE", "authors": ["renaud hartert"], "accepted": false, "id": "1705.00047"}, "pdf": {"name": "1705.00047.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Renaud Hartert"], "emails": [], "sections": [{"heading": null, "text": "ar Xiv: 170 5.00 047v 1"}, {"heading": "1 Introduction", "text": "The hybridization of constraint solvers with other combinatorial technologies such as mixed-integer programming [1,3,14], local search [12,15,16,18] and, above all, conflict-driven clause learning [6,7,17] has been the focus of considerable progress in many areas of application. Unfortunately, the fact that there are many open-source constraint solvers [4,5,8,9,10,11] may prove to be a time-consuming and discouraging adventure triggered by the impressive number of lines of code in these open-source projects, in order to hybridize them with other technologies, to expand them with specific structured domains or to extend them with new functionalities."}, {"heading": "2 Overview of the Solver", "text": "We begin the presentation of Kiwi by briefly describing its three main components: propagation, search and state restoration.Propagation The propagation system reduces the range of variables by filtering values that, according to the constraints, are part of no solution.The architecture of this system is described in Section 4.Search. Unfortunately, propagation alone is usually not sufficient to solve a problem of satisfying constraints. Restriction solutions therefore rely on a division process that implicitly develops a search tree in which each node is a partial problem of its ancestors. The leaves of this search tree are either failed nodes - i.e. inconsistent partial problems - or solutions. Propagation is used at the beginning of each node to reduce the domain of the variables and thus prune fruitless branches of the search tree."}, {"heading": "3 State restoration", "text": "There are three main approaches to implementing such a system: - Copying. A full copy of the domains is performed and stored before they change their state. - Domains are incremental and undone when they are recalculated from scratch. - State restoration is, of course, not limited to domains and can also be used to maintain incremental data structures or other components. - Domain changes are incremental and undone when needed. Trailing is the prominent approach used in many constraint solvers. - The idea behind trailing is to maintain the sequence of changes."}, {"heading": "3.1 Changes as an Abstraction", "text": "Such reversal information can take many forms, but is usually represented by a pair of a location and its corresponding value. In Kiwi, we have decided to store the functions responsible for reversal of state changes directly as first-class objects, i.e. as closures. Each state object is thus based on its own reversal mechanism, which is handled by the closure itself. The abstract class of a reversal operation, namely Change, is presented in code 3.1. It contains a single reversal of the function which, as its name suggests, is used to undo the change.1 abstract class Change {2 def undo (): Unit / / Undo the change3} Code 3.1: The Change abstract class. The full implementation of a state-changing integer class is presented in section 3.3."}, {"heading": "3.2 The Trail", "text": "Our towing system is implemented with two stacks: - The first is a stack of change objects representing the path. It is sorted chronologically so that the last change is on the stack (the root node is the empty stack) - The second stack represents each node of the current branch with its corresponding prefix in the path. Thanks to the incrementality of the path, only the position of the last change leading to a node needs to be stored to characterize the entire sequence of changes to that node. Figure 2 illustrates the relationship between the two stacks. The entire implementation of Trail, our towing system, is represented in code 3.2. Changes are registered using the memory function that pushes them onto the path (line 6). The new nodefunction registers the state of the current node by saving the current size of the path (line 8). In contrast, the undode function restores the previous node to the previous node (up to the size of the previous node), reverting it to the size of the previous node (up to the size of the 17)."}, {"heading": "3.3 Trailed Integer", "text": "We now have all the pieces needed to build our first stateful object: a stateful integer variable called TrailedInt. As with classic integer variables, the value of TrailedInt can be accessed and updated, but it keeps track of the different values it has been assigned to to recover them each time. () Integer variable here refers to a variable Integer.1 class Trail {2 / Stacks to map nodes to the trail3 private Trail = new Stack [Change] 4 private Nodes = new Stack [Int] () 5 / Store the change6 def store (Change: Change): Unit = trail.push (Change) the beginning of a new Stack [Change] (): Unit = nodef newNode (): Unit = nodes.push (trail.size) 9 / / Restore the previous nodef def store (Change: Change)."}, {"heading": "3.4 Improvements", "text": "For example, TrailedInt keeps track of all the values it has been assigned to, but only the values it was assigned to at the beginning of each state are needed. Hopefully, we can just fix this problem with timestamps. The idea is to assign a timestamp to each search node and only register the current value of TrailedInt if it does not exceed 1 class TrailedValue (trail: Trail, initValue: Int). Change {2 private val oldValues = new Stack [Int] () 3 private var currentValue: Int = initialValue4 def getValue: Int = currentValue setValue (value: Int): Unit = {6 if (value! = currentValue) {7 oldValue (currentValue).push (currentValue) = traine5 def setue (Int: (12) Unit: (Int)."}, {"heading": "4 The Propagation System", "text": "To achieve this, the Kiwi propagation system relies on the following units: - The propagators responsible for the propagation of constraints by updating the range of variables or notifying that a conflict has occurred. They contain the actual filtering procedures of their respective constraints. Propagators are registered to various types of events, such as the reduction of the range of a variable, and must be propagated each time one of these events occurs. - The propagation queue that propagators synchronize to carry out the propagation until no further filtering can be achieved or a conflict has been detected. - The variables that are updated by propagators and are responsible for reporting the propagation queue when a propagator has to be taken into account for further propagation. The interaction between these Figure 3 illustrates that the propagation queue does not interact directly with the propagation."}, {"heading": "4.1 Propagators", "text": "Kiwi does not contain an object that actually constitutes a restriction. Instead, a restriction is defined implicitly by the group of propagators who must ensure that the logical relationship of the restriction holds. Therefore, a restriction may consist of a single propagator registered to all variables within the scope of the restriction, or of a group of propagators, each of whom is registered to a subset of the scope of the restriction. The abstract class propagator is presented in Code 4.1. It contains the following functions: - The set Boolean flag is a flag used by the propagator queue to indicate that the propagator is awake and waiting for the propagator to propagate. - The function init registers the propagator for the events of interest and performs its initial propagation. It returns true if the propagation was successful and false if it leads to a conflict."}, {"heading": "4.2 The Propagation Queue", "text": "The propagation queue, PropagQueue, contains all propagators waiting for propagation. It is responsible for synchronizing these propagators until no further filtering can be achieved or until a conflict has been detected. When executed, the propagation process takes a propagator out of the propagation queue and calls its propagation function to reduce the range of some variables. Of course, reducing the range of a variable usually calls new propagators, who then queue up in the propagation queue. This process repeats itself incessantly as the propagation queue becomes empty, meaning that no further propagation is possible, or until a conflict occurs. The implementation of propagation queue is presented in code 4.2.The propagation function of the propagation queue includes a propagator in the propagation queue, but only if it is not already contained in it (lines 5 to 10) does not fulfill the propagation function (the main propagation function)."}, {"heading": "4.3 Variables", "text": "This year, it is more than ever before in the history of the country in which it is a country, in which it is not a country, but a country in which it is a country, in which it is a country."}, {"heading": "4.4 The Lower or Equal Constraint", "text": "We now have all the components at hand to understand and implement our first constraint. We focus on the simple binary constraint x \u2264 y, where both x and y are interval variables (see code 4.3).The x-shaped constraint is made by a single distributor named LowerEqual (see code 4.4). Its propaganda function ensures the following rules: - The maximum value of x is always lower or equal to the maximum value of y (line 12).5 We actually deny the domain of the variables, because this change comes directly from backtracking.1 class IntervalVar (pQueue: PropagandaQueue, Trail: 2 initMax: Int, initMax: Inval min = new TrailedInt (trail, initMin).4 private Val max = new Tracking.4"}, {"heading": "4.5 Improvement and Discussion", "text": "If the maximum value of x becomes lower or equal to the minimum value of y, then no further filtering is possible. We say that the propagator is involved and therefore does not need to be propagated any more. Another improvement is to add different priority levels to propagators. In fact, some propagators have a much faster filtering process than others, so it is useful to propagate these propagators first in order to give slower propagators as much information as possible. Interested readers can refer to the fourth and twelfth chapters of [13] for detailed additional improvements to Boolean. Otherwise, it makes sense to propagate these propagators first in order to give slower propagators as much information as possible."}, {"heading": "5 Search", "text": "The last part of our solution program is the search system. Its goal is to explore the entire search space of the problem in search of solutions or proof that there is no solution. It uses hauling to manage the nodes of the search tree, and applies propagation to fruitless branches. The search system is based on a depth search algorithm based on heuristics to determine the order in which the nodes are examined. In the following sections, these components are described."}, {"heading": "5.1 Heuristics and Decisions", "text": "Dei rf\u00fc ide rf\u00fc ide rf\u00fc the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green the green"}, {"heading": "5.2 The Depth-First-Search", "text": "This year it is more than ever before."}, {"heading": "14. Domenico Salvagnin and Toby Walsh. A hybrid mip/cp approach", "text": "for multiactive layer planning. In Principles and practice of constraint programming, pp. 633-646. Springer, 2012. 15. Pierre Schaus. Variable objective large neighborhood search. Submitted to CP13, 2013. 16. Pierre Schaus and Renaud Hartert. Multi-objective large neighborhood search. In Principles and Practice of Constraint Programming, pp. 611-627. Springer, 2013. 17. Andreas Schutt, Thibaut Feydy, Peter J Stuckey, and Mark G Wallace. Why cumulative decomposition is not as it. In Principles and Practice of Constraint ProgramingCP 2009, pp. 746-761. Springer, 2009. 18. P. Shaw. Using constraint programming and local search methods to solve vehicle routing problems. Principles and practice of Constraint programming - CP98, pp. 417-431, 1998."}], "references": [{"title": "A hybrid approach to scheduling with earliness and tardiness costs", "author": ["J Christopher Beck", "Philippe Refalo"], "venue": "Annals of Opera- tions Research,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2003}, {"title": "Global constraint catalogue: Past, present and future", "author": ["Nicolas Beldiceanu", "Mats Carlsson", "Sophie Demassey", "Thierry Petit"], "venue": "Clear trail and decisions", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Detecting infeasibility and generating cuts for mip using cp", "author": ["Alexander Bockmayr", "Nicolai Pisaruk"], "venue": "In Proceedings of the 5th International Workshop on Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, CPAIOR,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Choco3 documentation. TASC, INRIA Rennes, LINA CNRS UMR 6241", "author": ["Xavier Lorca Charles Prud\u2019homme", "Jean-Guillaume Fages"], "venue": "COSLING S.A.S.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "An extensible sat-solver", "author": ["Niklas E\u00e9n", "Niklas S\u00f6rensson"], "venue": "In Theory and applications of satisfiability testing,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Semantic learning for lazy clause generation", "author": ["Thibaut Feydy", "Andreas Schutt", "Peter J Stuckey"], "venue": "In Proceedings of TRICS Workshop: Techniques foR Implementing Constraint programming Systems,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "Lazy clause genera- tion reengineered", "author": ["Thibaut Feydy", "Peter J Stuckey"], "venue": "In Principles and Practice of Constraint Programming-CP", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2009}, {"title": "Gecode: Generic constraint development", "author": ["Gecode Team"], "venue": "environ- ment,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2006}, {"title": "or-tools: Google optimization tools, 2015. Avail- able from https://developers.google.com/optimization", "author": ["Or-tools Team"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "Propagation guided large neighborhood search. Principles and Practice of Constraint Programming\u2013CP", "author": ["Laurent Perron", "Paul Shaw", "Vincent Furnon"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2004}, {"title": "Handbook of constraint programming", "author": ["Francesca Rossi", "Peter Van Beek", "Toby Walsh"], "venue": "Elsevier Science,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "A hybrid mip/cp approach for multi-activity shift scheduling", "author": ["Domenico Salvagnin", "Toby Walsh"], "venue": "In Principles and practice of constraint programming,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Variable objective large neighborhood search", "author": ["Pierre Schaus"], "venue": "Sub- mitted to CP13,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "Multi-objective large neigh- borhood search", "author": ["Pierre Schaus", "Renaud Hartert"], "venue": "In Principles and Practice of Constraint Pro- gramming,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "Why cumulative decomposition is not as bad as it sounds", "author": ["Andreas Schutt", "Thibaut Feydy", "Peter J Stuckey", "Mark G Wallace"], "venue": "In Principles and Practice of Constraint Programming-", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Using constraint programming and local search methods to solve vehicle routing problems", "author": ["P. Shaw"], "venue": "Principles and Practice of Constraint Programming\u2014CP98,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1998}], "referenceMentions": [{"referenceID": 0, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 112, "endOffset": 120}, {"referenceID": 2, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 112, "endOffset": 120}, {"referenceID": 11, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 112, "endOffset": 120}, {"referenceID": 9, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 135, "endOffset": 148}, {"referenceID": 12, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 135, "endOffset": 148}, {"referenceID": 13, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 135, "endOffset": 148}, {"referenceID": 15, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 135, "endOffset": 148}, {"referenceID": 5, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 199, "endOffset": 207}, {"referenceID": 6, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 199, "endOffset": 207}, {"referenceID": 14, "context": "The hybridization of constraint solvers with other combinatorial technologies such as mixed integer programming [1,3,14], local search [12,15,16,18], and particularly conflict driven clause learning [6,7,17] has been at the center of substantial advances in many domains of application.", "startOffset": 199, "endOffset": 207}, {"referenceID": 3, "context": "Unfortunately, while many open-source constraint solvers exist [4,5,8,9,10,11], modifying these solvers to hybridize them", "startOffset": 63, "endOffset": 78}, {"referenceID": 4, "context": "Unfortunately, while many open-source constraint solvers exist [4,5,8,9,10,11], modifying these solvers to hybridize them", "startOffset": 63, "endOffset": 78}, {"referenceID": 7, "context": "Unfortunately, while many open-source constraint solvers exist [4,5,8,9,10,11], modifying these solvers to hybridize them", "startOffset": 63, "endOffset": 78}, {"referenceID": 8, "context": "Unfortunately, while many open-source constraint solvers exist [4,5,8,9,10,11], modifying these solvers to hybridize them", "startOffset": 63, "endOffset": 78}, {"referenceID": 1, "context": "The reader that is interested by global constraints and propagators may refer to [2] for a wide catalogue of global constraints and links towards the relevant literature.", "startOffset": 81, "endOffset": 84}, {"referenceID": 3, "context": "Trailing is the prominent approach used in many constraint solvers [4,5,9,10,11].", "startOffset": 67, "endOffset": 80}, {"referenceID": 4, "context": "Trailing is the prominent approach used in many constraint solvers [4,5,9,10,11].", "startOffset": 67, "endOffset": 80}, {"referenceID": 8, "context": "Trailing is the prominent approach used in many constraint solvers [4,5,9,10,11].", "startOffset": 67, "endOffset": 80}, {"referenceID": 7, "context": "2 Although, some solvers such as Gecode [8] rely on an hybrid state restoration mechanism based on both copying and recomputation.", "startOffset": 40, "endOffset": 43}, {"referenceID": 10, "context": "The interested reader can refer to the 12th chapter of [13] for detailed explanations on how to improve trailing systems.", "startOffset": 55, "endOffset": 59}, {"referenceID": 10, "context": "This design choice is one of the reasons that facilitates the extension of Kiwi with additional structured domain representations [13].", "startOffset": 130, "endOffset": 134}, {"referenceID": 10, "context": "4 Interval variables are commonly used by bound-consistent propagators [13].", "startOffset": 71, "endOffset": 75}, {"referenceID": 10, "context": "The interested reader can refer to the 4th and 12th chapters of [13] for detailed additional improvements.", "startOffset": 64, "endOffset": 68}], "year": 2017, "abstractText": "Kiwi is a minimalist and extendable Constraint Programming (CP) solver specifically designed for education. The particularities of Kiwi stand in its generic trailing state restoration mechanism and its modulable use of variables. By developing Kiwi, the author does not aim to provide an alternative to full featured constraint solvers but rather to provide readers with a basic architecture that will (hopefully) help them to understand the core mechanisms hidden under the hood of constraint solvers, to develop their own extended constraint solver, or to test innovative ideas.", "creator": "LaTeX with hyperref package"}}}