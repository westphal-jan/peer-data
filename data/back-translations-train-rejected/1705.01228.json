{"id": "1705.01228", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-May-2017", "title": "A Versatile, Sound Tool for Simplifying Definitions", "abstract": "We present a tool, simplify-defun, that transforms the definition of a given function into a simplified definition of a new function, providing a proof checked by ACL2 that the old and new functions are equivalent. When appropriate it also generates termination and guard proofs for the new function. We explain how the tool is engineered so that these proofs will succeed. Examples illustrate its utility, in particular for program transformation in synthesis and verification.", "histories": [["v1", "Wed, 3 May 2017 01:49:29 GMT  (20kb)", "http://arxiv.org/abs/1705.01228v1", "In Proceedings ACL2Workshop 2017,arXiv:1705.00766"]], "COMMENTS": "In Proceedings ACL2Workshop 2017,arXiv:1705.00766", "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["alessandro coglio", "matt kaufmann", "eric w smith"], "accepted": false, "id": "1705.01228"}, "pdf": {"name": "1705.01228.pdf", "metadata": {"source": "CRF", "title": "A Versatile, Sound Tool for Simplifying Definitions", "authors": ["Alessandro Coglio", "Matt Kaufmann", "Eric W. Smith"], "emails": ["coglio@kestrel.edu", "kaufmann@cs.utexas.edu", "eric.smith@kestrel.edu"], "sections": [{"heading": null, "text": "Warren Hunt Jr. and Anna Slobodova (ed.): ACL2 Theorem Prover and its Applications EPTCS 249, 2017, pp. 61-77, doi: 10.4204 / EPTCS.249.5c \u00a9 A. Coglio, M. Kaufmann & E. W. Smith This work is licensed under the Creative Commons Attribution License.A Versatile, Sound Tool for Simplifying DefinitionsAlessandro CoglioKestrel Institute 3260 Hillview Avenue, Palo Alto, CA 94304, USAcoglio @ kestrel.eduMatt KaufmannDepartment of Computer Science The University of Texas at Austin, TX, USAkaufmann @ cs.utexas.eduEric W. SmithKestrel Institute 3260 Hillview Avenue, Palo Alto, CA 94304, USAeric.smith @ kestrel.eduWe present a tool that converts the definition of a given function into a simplified function, representing a corresponding function for a new proof of an ACS."}, {"heading": "1 Introduction", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before."}, {"heading": "1.1 Simple Illustrative Examples", "text": "In fact, it is the case that it will be able to retaliate, \"he said in an interview with the German Press Agency.\" We have to play by the rules, \"he said.\" We have to play by the rules, \"he said.\" We have to play by the rules that we have set ourselves. \""}, {"heading": "2 Some Applications", "text": "This section presents some practical examples of simplify-defun in program transformation, using some keyword options described in Section 3, but hopefully self-explanatory. Notes generated by simplify-defun to automate evidence, such as the reuse of earlier guards, measures, and guard and termination theories, are not shown here; this is briefly discussed in the following sections."}, {"heading": "2.1 Combining a Filter with a Doubly-Recursive Producer", "text": "iSe rf\u00fc-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0"}, {"heading": "2.2 Converting between Unbounded and Bounded Integer Operations", "text": "The reason for this is that the project is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, which is a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a project, a"}, {"heading": "3 Options", "text": "These sections briefly cover the keyword arguments of simplify-defun. Here, we assume that the definition of the given function is not recursive; in this case, and other details, see the XDOC theme for simplify-defun provided by the supporting materials. A list of assumptions under which the body is simplified can be disabled by the keyword: assumptions. However, this default can specify the assumptions with a function symbol.Controlling of the result with the keyword: hyp-fn. By default, the new function symbol is disabled when the input function symbol is disabled."}, {"heading": "4 Implementation", "text": "Simplify-defun is designed to apply the expander, in particular the tool2-fn function in the misc / expander.lisp community book, which provides an interface to the ACL2 rewriter in a context based on the use of forward concatenation and linear arithmetic, with the goal of simplifying the definition as it is defined, and ensuring that all resulting evidence is fully automatic and quickly successful. This section discusses how simplify-defun achieves this goal, with a few (probably rare) exceptions in the case of evidence of waking, termination, or (discussed below) that assumptions are preserved by recursive calls. First, we explain the complete form generated by a call to simplify-defun, which we call its expansion; this form carefully orchestrates the evidence; then we dive deeper by showing the evidence for the \"become\" theorem, which focuses on the functional instantiation."}, {"heading": "4.1.1 Prelude", "text": "The foreplay is largely independent of f, but the name of f is supplied to install-non-normalized. (SET-INHIBIT-WARNINGS \"theory\") (SET-IGNORE-OK T) (SET-IRRELEVANT-FORMALS-OK T) (LOCAL (INSTALL-NORMALIZED F)) (LOCAL (SET-DEFAULT-HINTS NIL))) (LOCAL (SET-OVERRIDE-HINTS NIL))))) The first form avoids warnings due to the use of small theories to instruct the tester. The next two forms allow simplification to make some formalities unused or irrelevant in the new definition. The use of install-non-normalized is a bit subtle perhaps, but not complicated: by default, ACL2 stores a simplified or normalized body for a function symbol."}, {"heading": "4.1.2 New Defun Form", "text": "The following new definition has the same simplified body as for the corresponding example in Section 1. As before, by executing the expander on the non-normalized body of f. (DEFUN F {1} (X) (DECLARE (XARGS: NORMALIZE NIL: GUARD (NATP X): MEASURE (ACL2-COUNT X): VERIFY-GUARDS T: GUARD-HINTS ((\"Target\": USE (: GUARD-THEOREM F)...)): HINTS ((\"Target\": USE (: TERMINATION-THEOREM F))))) (IF (ZP X) 0 (+ 2 (F {1} (+ -1 X))))) The guard and the measure are (by default) inherited from f., then by default also the new function."}, {"heading": "4.1.3 Local Events", "text": "In fact, most of them are able to save themselves. (...) Most of them are not able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are not able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are not able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are able to save themselves. (...) Most of them are able to save themselves. (...) They are not able to save themselves. (...)"}, {"heading": "4.1.4 \u2018Becomes\u2019 Theorem", "text": "The \"will\" theorem in this example says the same theorem as the one described above (although we will see in Section 4.3 that this is not always the case). The: in-theoretical hint serves to prevent the ACL2 rewriter from getting stuck during the proof. (DEFTHM F-BECOMES-F {1} (EQUAL (F X) (F {1} X): HINTS ((((\"Target\": USE F-BECOMES-F {1} -LEMMA: IN-THEORY NIL))))"}, {"heading": "4.2 Proving the \u2018Becomes\u2019 Theorem", "text": "Next, we see how the functional instantiation is used to prove the \"will\" theorem about, or more precisely, its local problem. Remember, above a: is used by hint, which replaces f {1} -copy with f in the f {1} -is-f {1} -copy (EQUAL (F {1} -COPY X))) to prove: (EQUAL (F {1} X)). This substitution works perfectly (modulo pendulum of equality, which: is tolerated by hint), but requires proof of the following property, which states that f fulfills the constraint for f {1} -hint. (EQUAL (f {1} X) (IF (ZP X) '0 (BINARY +' 2 (f (BINARY + '-1 X)))), but the right side is exactly what was created by putting the exander on the body when applying two things (BAR-)."}, {"heading": "4.3 Assumptions", "text": "The following trivial example shows how assumptions change the simplify-defun expansion. (defun foo (x) (explain (xargs: guard (true-listp x)))) (if (consp x) (foo (cdr x))) x))) Under the assumption of the guard, (true-listp x), the variable x in the body is simplified to the constant nil, using its context (not (consp x). (ACL2! (simplify-defun foo: assumptions: guard: show-only t) (ENCAPSULATE NILprelude (as before); new defun form: (DEFUN FOO {1} (IF (FOO {1} (CDR X)))))), which only t: show-only t (ENCAPSULATE NILprelude (as before); new defun form: (DEFUN FOO {1} (FOX), the assumptions: \"we\""}, {"heading": "4.4 Implementation Notes", "text": "Here we discuss at a high level how such forms are generated. Consider the first example from the introduction, below, and let us see their single-stage macro expansion. (defun f (x) (if (zp x) 0 (+ 1 1 (f (+ -1 x)))) ACL2! >: trans1 (simplify-defun f) (WITH-OUTPUT: GAG-MODE NIL: OFF: ALL: ON ERROR (MAKE-EVENT (SIMPLIFY-DEFUN-FN 'F' NIL ': NONE... STATE)))) ACL2! > This use of with-output prevents output unless there is an error. The make-event call indicates simplify-defun-fn to generate an event of the form (progn E A (value-triple' D))), where E is the expansion profs, an appropriate expansion system to support a printed one."}, {"heading": "5 Conclusion", "text": "The use of simplifications, especially rewriting rules, is an old and important idea in program transformation. Simplify-defun translates this idea into ACL2, using the existing proof procedures, libraries, and environments of the examiner. It is one of the transformations of the APT tool suite for transforming programs and program specifications, which is useful for both synthesis and verification. While simplify-defun is suitable for equivalence-preserving refinements, other APT transformations are suitable for other types of refinements. For example, specifications that allow more than one implementation (see [4, Section 2] for an example) can be refined by APTs limiting transformation (which is not discussed here). We have used simplify-defun quite extensively in program derivatives to demonstrate its robustness and usefulness. This paper does not only describe the general use of simplify-defun for implementing, but also L2specific ones."}, {"heading": "Acknowledgments", "text": "This material is based on work partially supported by DARPA under contract number FA8750-15-C-0007. We thank the referees, who have all provided very helpful feedback that we have incorporated."}], "references": [{"title": "Algorithm for Computer Control of a Digital Plotter", "author": ["Jack Bresenham"], "venue": "IBM Systems Journal", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1965}, {"title": "Second-Order Functions and Theorems in ACL2", "author": ["Alessandro Coglio"], "venue": "Proceedings of the Thirteenth International Workshop on the ACL2 Theorem Prover and its Applications,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "A Tool for Simplifying Files of ACL2 Definitions", "author": ["Matt Kaufmann"], "venue": "Proceedings of the Fourth International Workshop on the ACL2 Theorem Prover and its Applications,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "KIDS: A Semiautomatic Program Development System", "author": ["Douglas R. Smith"], "venue": "IEEE Trans. Software Eng", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1990}, {"title": "Axe: An Automated Formal Equivalence Checking Tool for Programs", "author": ["Eric W. Smith"], "venue": "Ph.D. dissertation,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}], "referenceMentions": [{"referenceID": 3, "context": "The idea of using simplification rules to transform programs is not new [7, 2].", "startOffset": 72, "endOffset": 78}, {"referenceID": 2, "context": "This paper could be viewed as a follow-up to an earlier paper on a related tool [6].", "startOffset": 80, "endOffset": 83}, {"referenceID": 0, "context": "Consider this Java implementation of Bresenham\u2019s line drawing algorithm [3] for the first octant.", "startOffset": 72, "endOffset": 75}, {"referenceID": 4, "context": "The Axe tool [8] can automatically generate a representation similar to this one from Java (byte)code, with some additional input from the user (e.", "startOffset": 13, "endOffset": 16}], "year": 2017, "abstractText": "We present a tool, simplify-defun, that transforms the definition of a given function into a simplified definition of a new function, providing a proof checked by ACL2 that the old and new functions are equivalent. When appropriate it also generates termination and guard proofs for the new function. We explain how the tool is engineered so that these proofs will succeed. Examples illustrate its utility, in particular for program transformation in synthesis and verification.", "creator": "LaTeX with hyperref package"}}}