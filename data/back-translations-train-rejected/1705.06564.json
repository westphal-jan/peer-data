{"id": "1705.06564", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-May-2017", "title": "Stepwise Debugging of Answer-Set Programs", "abstract": "We introduce a stepping methodology for answer-set programming (ASP) that allows for debugging answer-set programs and is based on the stepwise application of rules. Similar to debugging in imperative languages, where the behaviour of a program is observed during a step-by-step execution, stepping for ASP allows for observing the effects that rule applications have in the computation of an answer set. While the approach is inspired from debugging in imperative programming, it is conceptually different to stepping in other paradigms due to non-determinism and declarativity that are inherent to ASP. In particular, unlike statements in an imperative program that are executed following a strict control flow, there is no predetermined order in which to consider rules in ASP during a computation. In our approach, the user is free to decide which rule to consider active in the next step following his or her intuition. This way, one can focus on interesting parts of the debugging search space. Bugs are detected during stepping by revealing differences between the actual semantics of the program and the expectations of the user. As a solid formal basis for stepping, we develop a framework of computations for answer-set programs. For fully supporting different solver languages, we build our framework on an abstract ASP language that is sufficiently general to capture different solver languages. To this end, we make use of abstract constraints as an established abstraction for popular language constructs such as aggregates. Stepping has been implemented in SeaLion, an integrated development environment for ASP. We illustrate stepping using an example scenario and discuss the stepping plugin of SeaLion. Moreover, we elaborate on methodological aspects and the embedding of stepping in the ASP development process.", "histories": [["v1", "Thu, 18 May 2017 13:02:19 GMT  (1154kb,D)", "http://arxiv.org/abs/1705.06564v1", "Under consideration in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "Under consideration in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI cs.LO cs.PL", "authors": ["johannes oetsch", "j\\\"org p\\\"uhrer", "hans tompits"], "accepted": false, "id": "1705.06564"}, "pdf": {"name": "1705.06564.pdf", "metadata": {"source": "CRF", "title": "Stepwise Debugging of Answer-Set Programs", "authors": ["JOHANNES OETSCH", "HANS TOMPITS"], "emails": ["johannes.oetsch@tuwien.ac.at)", "puehrer@informatik.uni-leipzig.de)", "tompits@kr.tuwien.ac.at)"], "sections": [{"heading": null, "text": "We introduce a step-by-step method for programming responses, which observes the behavior of a program during a step-by-step execution. ASP's step-by-step approach allows for monitoring the impact that rule applications have on the calculation of a response set. While the approach is inspired by debugging in imperative programming, it is conceptually different from other paradigms due to the non-determinism and declarativity inherent in ASP. Unlike statements in an imperative program that are executed after a strict control flow, there is no predetermined sequence in which rules are taken into account in ASP during a calculation. In our approach, the user is free to choose which rule to consider active in the next step according to his or her intuition."}, {"heading": "1 Introduction", "text": "In fact, it is such that most of them will be able to move into another world, in which they are able to move into another world, in which they are able to move into another world, in which they are able to move, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they live, in which they, in which they live, in which they live, in which they live, in which they, in which they live, in which they, in which they, in which they live, in which they live, in which they live, in which they live, in which they live, in which they, in which they, in which they, in which they, in which they live, in which they are able to"}, {"heading": "1 {color(1, red), color(1, green), color(1, blue)} 1 :- node(1).", "text": "In fact, it is not that we are able to behave in the way we have done in the past. (...) It is not that we have been able to get involved in such a situation. (...) It is not that we are able to get involved in such a situation. (...) It is not that we are able to get involved in such a situation. (...) It is not that we are able to get involved in it. (...) It is not that we are able to get involved in it. (...) It is that we are able to get involved in it. (...) It is not that we are able to get involved in it. (...) It is that we are not able to get involved in it. (...) It is that they are able to get involved in it. (...) It is as if they are able to get involved in it. (...) It is as if they are able. \"(...) It is not that we are able to survive them. (...)"}, {"heading": "Outline", "text": "Next, we will present the formal background necessary for our approach. We will remember the syntax of the disjunctive programs for abstract constraints and the semantics on which we build our framework (Oetsch et al. 2012a). Section 3 introduces a framework for calculations that makes it possible to break down semantics to the level of individual rules. After defining states and calculations, we will show several characteristics of the framework, especially solidity and completeness in the sense that the result of a successful calculation is a set of answers and that each set of answers can be constructed with a calculation. In addition, we will examine language fragments for which a simpler form of calculation is sufficient. In Section 4, we will present the step-by-step technique for debugging programs based on our frame of calculation. We will explain steps and jumps as a means to move forward in a calculation."}, {"heading": "2 Background", "text": "As motivated in the introduction, we represent grounded response programs by programs with abstract constraints (Marek and Remmel 2004; Marek and Truszczyn \u0301 ski 2004; Oetsch et al. 2012a). Programs that are not grounded are designated by programs in the input language of Gringo. Therefore, we implicitly assume that grounding (ungrounded) translates gringo rules into rules of programs with abstract constraints. For a detailed formal representation of our framework in the ungrounded environment, we refer the interested reader to the dissertation of Pu hrer (2014). We assume a fixed set of A soil atoms. Definition 1 An interpretation is a set of I A soil atoms. A soil atom a matches under Interpretation I, symbolically I | = a if an \"I,\" otherwise it is wrong under I. We will use the symbol 6 | = to indicate the complement of a relationship that is related to the symbol | in different contexts."}, {"heading": "2.1 Syntax of Abstract-Constraint Programs", "text": "The definition 3 (Marek and Remmel 2004; Marek and Truszczyn \u0301 ski 2004) An abstract constraint, abstract constraint atom, or C atom, is a pair A = < D, C >, where D'A is a finite set designated as the domain of A, and C '2D is a collection of basic atoms designated as the satisfying of A."}, {"heading": "2.2 Satisfaction Relation", "text": "Intuitively, a C atom < D, C > is a literal word whose truth depends on the truth of all atoms in D. The satisfying ones in C explicitly list which combinations of true atoms in D. Definition 7 An interpretation that I satisfy fulfills a C atom < D, C >, symbolically I | = < D, C > if I | D, C > iff I 6 | = < D, C >. Important criteria for distinguishing classes of C atom relate to their semantic behavior in relation to growing (or shrinking) interpretations. In this regard, we identify monotonous properties in the following interpretation. Definition 8 A-A literal L is monotonous if it is an interpretation."}, {"heading": "2.3 Viewing ASP Constructs as Abstract Constraints", "text": "We want to use abstract constraints as a unified means of representing common constructs in ASP solution languages. As an example, we recall how weight constraints (Simons et al. 2002) can be expressed as C atoms. Similarly, we can use them as abstractions of e.g. aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al. 2005). Note that the relationship between abstract constraints and ASP constructs is primarily known and motivated, abstract constraints (cf. Marek and Remmel 2004; Marek and Truszczyn ski 2004). Definition 10 (Simons et al. 2002) Weight constraint is an expression of forml [a1 = w1,.. ak = wk, not ak + 1 = wk + 1,."}, {"heading": "2.4 Semantics and Characterisations based on External Support and Unfounded Sets", "text": "In fact, most people are able to decide for themselves what they want and what they want."}, {"heading": "3 Computation Framework", "text": "In this section, we want to break down the conceptual complexity of semantics to artifacts that the programmer is familiar with: the rules written by the user, or, more precisely, their basic instances. To this end, we introduce a framework of calculations that captures the semantics described in the previous section. In this calculation model, which we will introduce step by step in Section 4, we will interpret by taking into account an increasing number of rule instances that are active. A calculation in our framework is a sequence of states that are structures that contain information, which rules and atoms have already been taken into account, and which truth values have been assigned to these atoms."}, {"heading": "3.1 States", "text": "Our framework is based on sequences of states where calculations are reassembled, taking into account an increasing number of ground rules that build a monotonously growing interpretation. < b > > Rules are taken into account that require a monotonously growing interpretation. < b > Definition 15 A state structure S is a tuple < P, I -, I -, II - >, where P is a set of C rules, I am an interpretation, I - a set of atoms that I and I - are split, and it is a collection of atoms. We call DS = I - the domain of S and define PS = P, IS = I \u2212 S =, and a state structure < P, I - >, I \u2212, I - a state that is founded."}, {"heading": "3.2 Computations", "text": "Next, we show how we can proceed in a calculation, i.e. which states could follow a given state by using a succession arrangement for state structures. Definition 17For a state S = < P, I \u2032, and a state structure S \u2032 = < P \u2032, I \u2032, I \u2032, I \u2032, S \u2032 is a successor to S, if there is a C rule, r \u2032 P \u2032, and sets \"Dr Dr Dr so that (i) P \u2032 = P \u2032 r,\" (ii) I \u2032, \"I \u2032,\" I \u2032, \"I \u2032,\" I \u2032, \"I,\" I, \"I,\" I, \"I,\" I, \"(i) Dr.,\" (iv) I, \"I,\" \"I,\" I, \"I,\" I, \"I,\" I, \"I,\" I, \"I,\" I, \"I,\" I, \"I,\", \",\", \",\" I, \",\", \",\" I, \",\" I, \"I,\" I, \",\", \"I,\" I, \"I,\" I, \",\" I, \",\" I, \"I,\", \"I,\", \"I,\""}, {"heading": "Proof", "text": "We show that the conditions (i), (ii) and (iii) of definition 15 apply to S. Consider some rule r \"PS.\" In the case r = rnew (S, S \"), IS\" | = B (r) and IS \"| = H (r) apply due to point (v) of definition 17 and Dr. DS\" due to point (iii) of the same definition. In addition, in case r = rnew (S, S \") r\" PS. \"Since S is a condition, we have Dr. DS.\" Therefore, since DS \"there is also Dr. DS.\" Note that IS \"| Dr = IS | Dr due to point (ii) of definition 17. Since IS | = B (r) and IS | = H (r) is a state, IS\" | = B (r) and IS \u2032 = H (r) are also stable. From these two cases, we see that the conditions (i) and (item) of the definition (Sdefinition) for \"SVI\" are stable."}, {"heading": "3.3 Properties", "text": "Next, if a calculation fails, gets stuck, is completed or does not succeed. (Intuitively, failure means that the calculation has reached a point where no response from the C program can be reached. < < < < < < 4 > < 4 < 4 < 4} {{}} {{{{}} {{2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2} {2) {2) {2) {2) {2) {2) {2) {2) {2) {2) {2) {2) {2) {2) {, {) {, {2, {) {, {, {) {, {, {), {2, {, {), {, {), {), {), {, {), {), {), {), {), {), {), {), {), {), {), {), {), {). (2), {), {), {), {), {), {)."}, {"heading": "Proof", "text": "Since C is complete for P, we have P ISn PSn. Conversely, we have PSn P ISn because we have r-P and ISn-B (r) for each r-PSn. Through stability of Sn, we get these ISn-AS (PSn). Since then, the assumption is ISn-AS (P ISn). The calculation model is also complete in the following sense: Theorem 3 Let S0 be a state, P be a C program with PS0 P, and I have a response rate of P with IS0 I and I \u2212 S0 =. Then there is a calculation S0,... Sn that was so successful for P that PSn = P I and ISn = I. Since the empty state < 5, 5, 5, 5, {4} > is trivial, we can clarify the completeness aspect of the previous result in the following sequence: PSn I and Sollary that Sollary, P and Sollary, then I, Sary and Sollary, Sollary and Sollary."}, {"heading": "Proof", "text": "The assertion stems directly from Theorem 3 in cases S0 = < \u2205, \u2205, \u2205, {\u2205} >. Note that there are states that do not arise from entrenched calculations, e.g. the state < {a \u2190 b}, {a, b}, \u2205, {a, b}, {b} > is not a successor of any other state. However, for stable states we can guarantee the existence of entrenched calculations. Episode 4 Let S be a stable state. Then there is a entrenched calculation S0,..., Sn with Sn = S."}, {"heading": "Proof", "text": "The result is a direct sequence of conclusion 3 and definition 16. The next theorem lays the groundwork for the jump technique that we present in Section 4. It allows the extension of a calculation by considering several rules of a program at once and using ASP to create this extension itself. Theorem 4 Let P be a C program, C = S0,..., Sn a calculation for P, P'a a set of C rules with P \u2032 P, and I get an answer from PSn P \u2032 with ISn I and I \u2212 Sn = \u2205. Then there is a calculation C \u2032 = S0,..., Sn, Sn + 1,..., Sm for P, so that Sm is stable, PSm = PSn P \u2032 I and ISm = I."}, {"heading": "Proof", "text": "According to theorem 3, there is a calculation Sn,..., Sm, which was so successful for PSn-P \"that PSm = (PSn-P\") I and ISm = I. Then Sm is stable and as PSnI = PSn we have PSm = PSn-P \"I. As PSm\" P \"we have this C\" = S0,.., Sn, Sn + 1,..., Sm is a calculation for P. The following result shows that the direction you choose to build a certain interpretation, i.e. the order of rules that are taken into account in a calculation is irrelevant in the sense that ultimately the same state is reached. Suggestion 1 Let P be a C program and C = S0."}, {"heading": "Proof", "text": "The \"if\" direction is trivial. Leave I = ISn = IS \"m. On the way to a contradiction, one goes from PSn 6 = PS\" m. Without loss of universality, we focus on the case that there is any r \u2212 PSn that contradicts our assumption. Then, I | = r, I | = B (r) and r \u00b2 P. \"Consequently, from the completeness of C \u2212 m, we have r \u00b2 PS \u00b2 m, which contradicts our assumption. Therefore, we have PSn = PS \u00b2 m. Without loss of universality, we focus on the case that there is any\" I \u2212 Sn \"and PSn = PS \u00b2 m."}, {"heading": "Proof", "text": "Note that 0 < j as IS0 = I \u2212 S0 = DPS0 = \u2205. Since Sj is a successor of Sj \u2212 1, we have ISj = ISj \u2212 1 and I \u2212 Sj \u2212 Sj \u2212 1 as contradictions. As we have ISj \u2212 1 = ISn, Sj \u2212 Drnew (Sj \u2212 1, Sj), DSj \u2212 1, Sp \u2212 1, and Drnew (Sj \u2212 1, Sj) as contradictions. As we have ISj \u2212 1 = ISn | DPSj \u2212 1 and I \u2212 Sj \u2212 1 = SISS1 = SISS1, SPSj \u2212 1, S1, Sp \u2212 n."}, {"heading": "3.4 Stable Computations", "text": "This section is about the existence of stable C programs, i.e. calculations that do not include unfounded sets. < b > < p > p > p > p < p > p > p > p < p > p > p < p {p} p {p} p {p} p {p} p {p} p {p} p {p} p {p) p {p) p {p) p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" c \"c c\" c c c c \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" c \"c\" c c \"c\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" c \"p\" p \"p\" p \"p\" p \"p\" c \"c\" c \"c\" c c c \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" c \"c\" c \"c\" c \"c\" c \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"c\" c \"c\" c \"c\" c \"c\" c \"c\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \"p\" p \""}, {"heading": "Proof", "text": "From I-AS (P) we get as sequence 3 that there is a rooted calculation S0,..., Sn so that PSn = P I and ISn = I. Note that S0 is the empty state. S0 and Sn are stable according to definition 16. From theorem 5 we can deduce the existence of another calculation C-S-0,..., S-n so that S0 = S-0 and Sn = S-n is stable."}, {"heading": "4 Theory and Practice of Stepping", "text": "In this section, we present our methodology for quilting response programs based on the calculation model introduced in the previous section. Step by step, the execution of a program is practiced in procedural programming languages, in which developers can debug and study the behavior of their programs in incremental way.The technique introduced in this thesis shows how this popular form of debugging can be applied to ASP, despite the true declarative semantics of response programs that lack a control flow.Its main application is debugging, but it is also beneficial in other contexts, such as improving the understanding of a response program or imparting the response semantics to beginners."}, {"heading": "4.1 Example Scenario - Maze Generation", "text": "It was a benchmark problem of the second ASP competition (Denecker et al. 2009), to which it was submitted by Martin Brain. The original problem description is available on the website of the competition. 2As the name of the problem shows, the task we are dealing with is to create a labyrinth, i.e., a labyrinth structure in a grid that meets certain conditions. In particular, we are dealing with two-dimensional grids of cells in which each cell can be assigned to be either an empty space or a wall. In addition, there are two (distinct) empty squares at the edge of the grid, known as the entrance and exit. One way is a finite sequence of 2 http: / / dtai.cs.kuleuven.be / events / ASP-competition / MazeGeneration.shtmcellls."}, {"heading": "4.2 General Idea", "text": "We introduce Stepping for ASP as a strategy to identify inconsistencies between the intended semantics of a response program under development and its actual semantics. Stepping is a method of splitting this problem into smaller parts and structuring the search for an error. The general idea is to build an interpretation by adding at each step literals derived from a rule that is active in relation to the interpretation received in the previous step. The process is interactive in that at each such step the user selects the active rule he continues with and decides which literals of the rule should be considered true or false in the target interpretation, thereby adding only rules that he believes are active in an expected or unintended actual set of responses."}, {"heading": "4.3 Steps", "text": "We consider a setting in which a programmer has automatically written an answer program in a solution language for which he must apply the abstraction of his grounding. Furthermore, we assume that the programmer has received a calculation for P that is neither stuck in P nor complete for P. To perform a step, one must find a successor state Sn + 1 for Sn in such a way that C + 1 is a calculation for P. We propose a sequence of three user actions to perform a step. Intuitively, to quickly find a successor state (using the debugging environment), we suggest selecting a non-soil rule with active soil instances, then2. select an active basic rule among the instances of the non-soil rule, and3. select for still undefined atoms in the domain of the soil instance that they are considered true or false."}, {"heading": "4.4 Jumps", "text": "If you want to simulate the calculation of an answer, you only have to go through the selected rules, so many steps are necessary, because there are active rules in the grounding under I. Although the number of active basic instances is usually much less than the total number of rules in the grounding, many rules would still have to be taken into account. To focus on the parts of a calculation the user is interested in, we have to introduce a jump technique to quickly consider rules that are of little interest, e.g. rules that are already considered correct. We say that by executing a jump we want to find a state that could be reached by a compilation that might expand the current program by several states. If such a state can be found, one can extend a compression further, while ensuring that the same states can only be achieved by using steps. Jumps can be done by using Theorem 4."}, {"heading": "4.6 Methodology", "text": "We identify three conceptual levels as a methodology: The technical level corresponds to the iterative development of a calculation, which is summarized in sections 4.3 and 4.4 of the step cycle (Fig. 2). Next, we describe application-level tap as a method for debugging and program analysis. We then examine how tap is embedded in the broader context of ASP development from a top-level perspective. Finally, we illustrate our approach in various application scenarios. In Appendix A, we provide practical guidelines for our methodology."}, {"heading": "Program Analysis and Debugging Level Methodology", "text": "eSi rf\u00fc ide eeisrrteeSrteeeeeteeteeteerteerterterr rf\u00fc eid eeisrlrlllteeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeiiiiiueeeeeeeeeeeVnlrrrrlrrrlrrrrlrlrlrlrlrlrlrrrrlrrrrrrrlrrrrrrrlrrrrrlrrrrlrrrrlrrrrrlrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"}, {"heading": "Top-Level Methodology", "text": "Stepping must be understood as part of the programming and modeling process, i.e. the technique must be recognized in the context of the development of response programs. A practical consequence of viewing sequences of steps on the whole are several ways to use the information obtained during the development of a program to make step speed and accuracy. As a response program develops, the programmer in many cases calculates sets of responses of preliminary versions of the program for testing purposes. If these response sets persist, they can often be used as a starting point for step sessions for later versions of the program. For example, if the generation P of a previous version of a program is a subset of the current grounding P, it is obvious that a successful calculation C for P is also a calculation for P. Therefore, the user can initiate a step session starting from C. Also, if P 6, P \u00b2 P is a subset of the current creation of a program, the sign stepping system may be used as a continuation of it (the one of which already constitutes an automatic response to an earlier calculation, or P may be used as a part of an earlier calculation)."}, {"heading": "Use Cases", "text": "Next, we will show application scenarios of stepping with our running example. The first scenario illustrates the step towards a (interpretation) that is a response of the program taking into account. Example 8 We want to approach an answer of our partial encoding of the labyrinth generation problem, i.e., we want to achieve an answer that is not compatible with the labyrinth generation shown in the figure. (Therefore, we continue our free ride with the calculation C4, i.e., we start with the step from the state S4 that we received in Example 7. In particular, we want to achieve an answer that is compatible with the labyrinth generation solution shown in the figure. 1. To achieve this goal, we start with the step through the active instances of the rule {wall (X, Y): col (Y), no limit (X, Y). The only active instance of the rule (X, Y) is not."}, {"heading": "5 Related Work", "text": "This year, it is as far as ever in the history of the city, where it is as far as never before in the history of the city."}, {"heading": "6 Conclusion", "text": "This year, it has come to the point that it has never come as far as it has this year."}, {"heading": "Acknowledgements", "text": "We would like to thank the reviewers for their helpful comments. This work was partly supported by the Austrian Science Fund (FWF) in project P21698, the German Research Foundation (DFG) in project BR-1817 / 7-1 and BR 1817 / 7-2 and the European Commission in project IST-2009-231875 (OntoRule)."}, {"heading": "Appendix A Guidelines for Stepping", "text": "In fact, it is so that most people are able to abide by the rules that they have imposed on themselves. (...) In fact, it is so that they are able to abide by the rules. (...) In fact, it is so that they are able to change the rules. (...) \"It is as if.\" (...) \"It is so.\" (...) \"\" It is so. \"(...)\" (...) \"(...)\" (...) \"(...)\" () \"()\" () (() \"() () (()\" () () () (() \"() ()\" () () (() \"()\" () \"()\" () \"() () ()\" () () (() \"()\" () \"() () () () () () () () () () () ()) () () () () () () () () () () () ()) () () () () () () () () () () () () () () () ()) () () () () ()) () () () () ()) () () () ()) () () ()) () () () () ()) () () () ()) () () () () () () () () ()) () () () () () () () () ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (() () () () () () () () () (() () () () () () () () () () () (() () () (() (() () (()"}, {"heading": "Store computation for later use", "text": "DONEfinda buganalyse the programyes noan unintended answer setno answer sets exists although some shouldyesnoa missing answer setyes noa (part of a) saved computation for a trusted part of the program, a computation generated from an answer set of a trusted part of the program, a computation generated from an answer set of a small-scope hypothesis for ASP (Oetsch et al. 2012).Visualization answer sets and step states noyesFig. A 1: Stepping guidethat bugs are detected early, using small programs is suggested by an evaluation of the small-scope hypothesis for ASP (Oetsch et al. 2012).Visualization answer sets and step states. Tools like Kara (Kloimu \u00bc llner et al. 2013) (that is implemented in SeaLion), ASPVIZ et al."}, {"heading": "Proof", "text": "(i) \u21d2 (ii) It is obvious that rnew (S, S) is also an external support for X (DA). (DA) It is obvious that rnew (DA, S) is no external support for X (DA). (DA, S). (DA). (DA, S). (DA, S). (DA). (DA, S). (DA). (DA). (DA., S). (DA). (DA.). (DA). (DA). (DA). (DA). (DA). (DA.). (DA.). (DA.). (DA.). (DA.). (DA. (DA.). (DA. (DA.). (DA.). (DA.). (DA.). (DA.) DA. (DA.). (DA.). (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA.). (DA. (DA.). (DA.). (DA.). (DA.). (DA.). (DA.). (DA. (DA.). (DA.). (DA.). (DA.). (DA. (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA.). (DA. (DA.). (DA. (DA.). (DA.). (DA.). (DA. (DA. (DA.).). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA. (DA.). (DA.). (DA. (DA.). (DA.). (DA. (DA. (DA.). (DA. (DA.).). (DA. (DA. (DA.).). (DA. (DA.). (DA. (DA.). (DA"}, {"heading": "Proof", "text": "The proof is that Dr & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x010D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # x0D & # 0x0D & # 0x0D & # 0x0D & # 0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0D & # 0x0D & # 0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0x0D & # 0x0x0D & 0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0D & # 0x0x0x0x0x0D & # 0x0x0x0D & # 0x0x0x0x0x0x0x0x0x0D & # 0x0x0D & # 0x0x0x0x0x0x0D & # 0x0x0x0x0x0x0x0D & # 0x0x0x0x0x0x0x0x0D & # 0x0x0x0x0x0x0x0D & 0x0x0x0x0x0x0D & 0x0x0x0x0x0x0x0D & 0x0x0x0x0x0"}, {"heading": "Proof", "text": "Suppose that G (P) is not acyclic. Thus, according to the definition of G (P), a sequence r1,.., rn \u2212 1 must be such that for each 1 \u2264 i < n, we have such a sequence that for each 1 \u2264 i \u2264 n \u2212 1, ri P, ai \u0445 posOcc (H (ri) and ai + 1 posOcc (H (ri)) and ai + 1 posOcc (B (ri)). Therefore, we must have a sequence for each 1 \u2264 i < n \u2212 1, ri \u2212 R ri. Note that a1 posOcc (H (r1)) and a1 posOcc (B (ri) posOcc (P)."}, {"heading": "Proof", "text": "According to definition 21, G (P) is acyclic. Therefore, GR (P) according to Lemma 1 is also acyclic. The assumption is valid, because every directed acyclic tree has a topological order. We now have the means to show theorem 5, which guarantees the existence of stable calculations. Theorem 5 let C = S0,..., Sn is a calculation, so that S0 and Sn are stable and P \u0445 = PSn\\ PS0 is a normal, convex and absolutely tight C program. Then there is a stable calculation C \u2032 = S \u2032 0,..., S \u2032 n, so that S0 = S \u2032 0 and Sn = S \u2032 n."}, {"heading": "Proof", "text": "\u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2 \u00b2."}], "references": [{"title": "Advances in WASP", "author": ["M. Alviano", "C. Dodaro", "N. Leone", "F. Ricca"], "venue": "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, Sept. 27-30, 2015. Proceedings, F. Calimeri, G. Ianni, and M. Truszczy\u0144ski, Eds. LNCS, vol. 9345. Springer, 40\u201354.", "citeRegEx": "Alviano et al\\.,? 2015", "shortCiteRegEx": "Alviano et al\\.", "year": 2015}, {"title": "Propositional semantics for disjunctive logic programs", "author": ["R. Ben-Eliyahu", "R. Dechter"], "venue": "Annals of Mathematics and Artificial Intelligence 12, 1-2, 53\u201387.", "citeRegEx": "Ben.Eliyahu and Dechter,? 1994", "shortCiteRegEx": "Ben.Eliyahu and Dechter", "year": 1994}, {"title": "A pragmatic programmer\u2019s guide to answer set programming", "author": ["M. Brain", "O. Cliffe", "M. De Vos"], "venue": "Proceedings of the 2nd International Workshop on Software Engineering for Answer-Set Programming (SEA\u201909), Potsdam, Germany, M. De Vos and T. Schaub, Eds. 49\u201363.", "citeRegEx": "Brain et al\\.,? 2009", "shortCiteRegEx": "Brain et al\\.", "year": 2009}, {"title": "Debugging logic programs under the answer set semantics", "author": ["M. Brain", "M. De Vos"], "venue": "Proceedings of the 3rd International Workshop on Answer Set Programming (ASP\u201905), Advances in Theory and Implementation, Bath, UK, Sept. 27-29, 2005, M. De Vos and A. Provetti, Eds. CEUR Workshop Proceedings, vol. 142. CEUR-WS.org.", "citeRegEx": "Brain and Vos,? 2005", "shortCiteRegEx": "Brain and Vos", "year": 2005}, {"title": "That is illogical Captain! The debugging support tool spock for answer-set programs \u2013 System description", "author": ["M. Brain", "M. Gebser", "J. Puehrer", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceeding of the 1st International Workshop on Software Engineering for Answer Set Programming (SEA\u201907), Tempe, AZ, USA, May 14, 2007, M. De Vos and T. Schaub, Eds. 71\u201385.", "citeRegEx": "Brain et al\\.,? 2007", "shortCiteRegEx": "Brain et al\\.", "year": 2007}, {"title": "Debugging ASP programs by means of ASP", "author": ["M. Brain", "M. Gebser", "J. P\u00fchrer", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907), Tempe, AZ, USA, May 15-17, 2007, C. Baral, G. Brewka, and J. S. Schlipf, Eds. LNCS, vol. 4483. Springer, 31\u201343.", "citeRegEx": "Brain et al\\.,? 2007", "shortCiteRegEx": "Brain et al\\.", "year": 2007}, {"title": "Abstract disjunctive answer set solvers", "author": ["R. Brochenin", "Y. Lierler", "M. Maratea"], "venue": "Proceedings of the 21st European Conference on Artificial Intelligence (ECAI\u201914), Prague, Czech Republic, Aug. 18-22, 2014, T. Schaub, G. Friedrich, and B. O\u2019Sullivan, Eds. Frontiers in Artificial Intelligence and Applications, vol. 263. IOS Press, 165\u2013170.", "citeRegEx": "Brochenin et al\\.,? 2014", "shortCiteRegEx": "Brochenin et al\\.", "year": 2014}, {"title": "Sealion: An eclipse-based IDE for answer-set programming with advanced debugging support", "author": ["Busoniu", "P.-A.", "J. Oetsch", "J. P\u00fchrer", "P. Sko\u010dovsk\u00fd", "H. Tompits"], "venue": "Theory and Practice of Logic Programming 13, 4-5, 657\u2013673.", "citeRegEx": "Busoniu et al\\.,? 2013", "shortCiteRegEx": "Busoniu et al\\.", "year": 2013}, {"title": "A theoretical framework for the declarative debugging of datalog programs", "author": ["R. Caballero", "Y. Gar\u0107\u0131a-Ruiz", "F. S\u00e1enz-P\u00e9rez"], "venue": "Revised Selected Papers of the 3rd International Workshop on Semantics in Data and Knowledge Bases (SDKB\u201908), Nantes, France, Mar. 29, 2008, K.-D. Schewe and B. Thalheim, Eds. LNCS, vol. 4925. Springer, 143\u2013159.", "citeRegEx": "Caballero et al\\.,? 2008", "shortCiteRegEx": "Caballero et al\\.", "year": 2008}, {"title": "ASPVIZ: Declarative visualisation and animation using answer set programming", "author": ["O. Cliffe", "M. De Vos", "M. Brain", "J.A. Padget"], "venue": "Proceedings of the 24th International Conference on Logic Programming (ICLP\u201908), Udine, Italy, Dec. 9-13, 2008, M. G. de la Banda and E. Pontelli, Eds. LNCS, vol. 5366. Springer, 724\u2013728.", "citeRegEx": "Cliffe et al\\.,? 2008", "shortCiteRegEx": "Cliffe et al\\.", "year": 2008}, {"title": "Extending classical logic with inductive definitions", "author": ["M. Denecker"], "venue": "Proceedings of the 1st International Conference on Computational Logic (CL\u201910), London, UK, July 24-28, 2000, J. W. Lloyd, V. Dahl, U. Furbach, M. Kerber, K. Lau, C. Palamidessi, L. M. Pereira, Y. Sagiv, and P. J. Stuckey, Eds. LNCS, vol. 1861. Springer, 703\u2013717.", "citeRegEx": "Denecker,? 2000", "shortCiteRegEx": "Denecker", "year": 2000}, {"title": "A logic of nonmonotone inductive definitions", "author": ["M. Denecker", "E. Ternovska"], "venue": "ACM Transactions on Computational Logic 9, 2.", "citeRegEx": "Denecker and Ternovska,? 2008", "shortCiteRegEx": "Denecker and Ternovska", "year": 2008}, {"title": "The second answer set programming competition", "author": ["M. Denecker", "J. Vennekens", "S. Bond", "M. Gebser", "M. Truszczy\u0144ski"], "venue": "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201909), Potsdam, Germany, Sept. 14-18, 2009, E. Erdem, F. Lin, and T. Schaub, Eds. LNCS, vol. 5753. Springer, 637\u2013654.", "citeRegEx": "Denecker et al\\.,? 2009", "shortCiteRegEx": "Denecker et al\\.", "year": 2009}, {"title": "Interactive debugging of non-ground ASP programs", "author": ["C. Dodaro", "P. Gasteiger", "B. Musitsch", "F. Ricca", "K.M. Shchekotykhin"], "venue": "Logic Programming and Nonmonotonic Reasoning - 13th International Conference, LPNMR 2015, Lexington, KY, USA, Sept. 27-30, 2015. Proceedings, F. Calimeri, G. Ianni, and M. Truszczy\u0144ski, Eds. LNCS, vol. 9345. Springer, 279\u2013293.", "citeRegEx": "Dodaro et al\\.,? 2015", "shortCiteRegEx": "Dodaro et al\\.", "year": 2015}, {"title": "A uniform integration of higher-order reasoning and external evaluations in answer-set programming", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905), Edinburgh, Scotland, UK, July 30-Aug. 5, 2005, L. P. Kaelbling and A. Saffiotti, Eds. Professional Book Center, 90\u201396.", "citeRegEx": "Eiter et al\\.,? 2005", "shortCiteRegEx": "Eiter et al\\.", "year": 2005}, {"title": "Recursive aggregates in disjunctive logic programs: Semantics and complexity", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA\u201904). LNCS, vol. 3229. Springer, 200\u2013212.", "citeRegEx": "Faber et al\\.,? 2004", "shortCiteRegEx": "Faber et al\\.", "year": 2004}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "G. Pfeifer", "N. Leone"], "venue": "Artificial Intelligence 175, 1, 278\u2013298.", "citeRegEx": "Faber et al\\.,? 2011", "shortCiteRegEx": "Faber et al\\.", "year": 2011}, {"title": "Logic programs with propositional connectives and aggregates", "author": ["P. Ferraris"], "venue": "ACM Transactions on Computational Logic 12, 4, 25.", "citeRegEx": "Ferraris,? 2011", "shortCiteRegEx": "Ferraris", "year": 2011}, {"title": "Debugging answer-set programs with Ouroboros \u2013 Extending the SeaLion plugin", "author": ["M. Fr\u00fchst\u00fcck", "J. P\u00fchrer", "G. Friedrich"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913), Corunna, Spain, Sept. 15-19, 2013, P. Cabalar and T. C. Son, Eds. LNCS, vol. 8148. Springer, 323\u2013328.", "citeRegEx": "Fr\u00fchst\u00fcck et al\\.,? 2013", "shortCiteRegEx": "Fr\u00fchst\u00fcck et al\\.", "year": 2013}, {"title": "Advances in gringo series", "author": ["M. Gebser", "R. Kaminski", "A. K\u00f6nig", "T. Schaub"], "venue": null, "citeRegEx": "Gebser et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Artificial Intelligence 187-188, 52\u201389.", "citeRegEx": "Gebser et al\\.,? 2012", "shortCiteRegEx": "Gebser et al\\.", "year": 2012}, {"title": "On elementary loops of logic programs", "author": ["M. Gebser", "J. Lee", "Y. Lierler"], "venue": "Theory and Practice of Logic Programming 11, 6, 953\u2013988.", "citeRegEx": "Gebser et al\\.,? 2011", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "A meta-programming technique for debugging answer-set programs", "author": ["M. Gebser", "J. P\u00fchrer", "T. Schaub", "H. Tompits"], "venue": "Proceedings of the 23rd AAAI Conference on Artificial Intelligence (AAAI\u201908), Chicago, IL, USA, July 13-17, 2008, D. Fox and C. P. Gomes, Eds. AAAI Press, 448\u2013453.", "citeRegEx": "Gebser et al\\.,? 2008", "shortCiteRegEx": "Gebser et al\\.", "year": 2008}, {"title": "spock: A debugging support tool for logic programs under the answer-set semantics", "author": ["M. Gebser", "J. P\u00fchrer", "T. Schaub", "H. Tompits", "S. Woltran"], "venue": "Revised Selected Papers of the 17th International Conference on Applications of Declarative Programming and Knowledge Management (INAP\u201907) and 21st Workshop on (Constraint) Logic Programming (WLP\u201907), D. Seipel, M. Hanus, and A. Wolf, Eds. LNCS,", "citeRegEx": "Gebser et al\\.,? 2009", "shortCiteRegEx": "Gebser et al\\.", "year": 2009}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 3/4, 365\u2013386.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Kara: A system for visualising and visual editing of interpretations for answer-set programs", "author": ["C. Kloim\u00fcllner", "J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Revised Selected Papers of the 19th International Conference on Applications of Declarative Programming and Knowledge Management (INAP\u201911) and the 25th Workshop on Logic Programming (WLP\u201911), Vienna, Austria, Sept. 28-30, 2011. LNCS, vol. 7773. Springer,", "citeRegEx": "Kloim\u00fcllner et al\\.,? 2013", "shortCiteRegEx": "Kloim\u00fcllner et al\\.", "year": 2013}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905), Edinburgh, Scotland, UK, July 30-Aug 5, 2005, L. P. Kaelbling and A. Saffiotti, Eds. Professional Book Center, 503\u2013508.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7, 3, 499\u2013562.", "citeRegEx": "Leone et al\\.,? 2006", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Debugging ASP using ILP", "author": ["T. Li", "M.D. Vos", "J. Padget", "K. Satoh", "T. Balke"], "venue": "Technical Communications of the 31st International Conference on Logic Programming (ICLP 2015), Cork, Ireland, Aug. 31 - Sept. 4, 2015., M. D. Vos, T. Eiter, Y. Lierler, and F. Toni, Eds. CEUR Workshop Proceedings, vol. 1433. CEUR-WS.org.", "citeRegEx": "Li et al\\.,? 2015", "shortCiteRegEx": "Li et al\\.", "year": 2015}, {"title": "Abstract answer set solvers with backjumping and learning", "author": ["Y. Lierler"], "venue": "Theory and Practice of Logic Programming 11, 2-3, 135\u2013169.", "citeRegEx": "Lierler,? 2011", "shortCiteRegEx": "Lierler", "year": 2011}, {"title": "On abstract modular inference systems and solvers", "author": ["Y. Lierler", "M. Truszczy\u0144ski"], "venue": "Artificial Intelligence 236, 65\u201389.", "citeRegEx": "Lierler and Truszczy\u0144ski,? 2016", "shortCiteRegEx": "Lierler and Truszczy\u0144ski", "year": 2016}, {"title": "Logic programs with abstract constraint atoms: The role of computations", "author": ["L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczy\u0144ski"], "venue": "Artificial Intelligence 174, 3-4, 295\u2013315.", "citeRegEx": "Liu et al\\.,? 2010", "shortCiteRegEx": "Liu et al\\.", "year": 2010}, {"title": "Set constraints in logic programming", "author": ["V.W. Marek", "J.B. Remmel"], "venue": "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904), Fort Lauderdale, FL, USA, Jan 6-8, 2004, V. Lifschitz and I. Niemel\u00e4, Eds. LNCS, vol. 2923. Springer, 167\u2013179.", "citeRegEx": "Marek and Remmel,? 2004", "shortCiteRegEx": "Marek and Remmel", "year": 2004}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "In The Logic Programming Paradigm: a 25-Year Perspective, K. R. Apt, V. W. Marek, M. Truszczy\u0144ski, and D. S. Warren, Eds. Springer, 375\u2013398.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1999", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Logic programs with abstract constraint atoms", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "In Proceedings of the 19th National Conference on Artificial Intelligence (AAAI\u201904), San Jose, CA, USA, July 25-29, 2004, G. Ferguson and D. McGuinness, Eds. AAAI Press, 86\u201391.", "citeRegEx": "Marek and Truszczy\u0144ski,? 2004", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 2004}, {"title": "Towards debugging of answerset programs in the language PSpb", "author": ["A. Mikitiuk", "E. Moseley", "M. Truszczy\u0144ski"], "venue": "Proceedings of the 2007 International Conference on Artificial Intelligence (ICAI\u201907), Volume II, Las Vegas, NV, USA, June 25-28, 2007, H. R. Arabnia, M. Q. Yang, and J. Y. Yang, Eds. CSREA Press, 635\u2013640.", "citeRegEx": "Mikitiuk et al\\.,? 2007", "shortCiteRegEx": "Mikitiuk et al\\.", "year": 2007}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 3-4, 241\u2013273.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Solving SAT and SAT modulo theories: From an abstract davis\u2013putnam\u2013logemann\u2013loveland procedure to dpll(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM 53, 6, 937\u2013977.", "citeRegEx": "Nieuwenhuis et al\\.,? 2006", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "On the small-scope hypothesis for testing answer-set programs", "author": ["J. Oetsch", "M. Prischink", "J. P\u00fchrer", "M. Schwengerer", "H. Tompits"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201912), Rome, Italy, June 10-14, 2012, G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press.", "citeRegEx": "Oetsch et al\\.,? 2012", "shortCiteRegEx": "Oetsch et al\\.", "year": 2012}, {"title": "Catching the Ouroboros: On debugging non-ground answer-set programs", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Theory and Practice of Logic Programming 10, 4-6 (July), 513\u2013529.", "citeRegEx": "Oetsch et al\\.,? 2010", "shortCiteRegEx": "Oetsch et al\\.", "year": 2010}, {"title": "Let\u2019s break the rules: Interactive procedural-style debugging of answer-set programs", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Proceedings of the 24th Workshop on (Constraint) Logic Programming (WLP\u201910), Cairo, Egypt, Sept. 14-16, 2010, S. Abdennadher, Ed. Technical Report, Faculty of Media Engineering and Technology, German University in Cairo. 77\u201387.", "citeRegEx": "Oetsch et al\\.,? 2010", "shortCiteRegEx": "Oetsch et al\\.", "year": 2010}, {"title": "Stepping through an answer-set program", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Proceedings of the 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201911), Vancouver, Canada, May 16-19, 2011. LNCS, vol. 6645. Springer, 134\u2013147.", "citeRegEx": "Oetsch et al\\.,? 2011", "shortCiteRegEx": "Oetsch et al\\.", "year": 2011}, {"title": "An FLP-style answer-set semantics for abstract-constraint programs with disjunctions", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Technical Communications of the", "citeRegEx": "Oetsch et al\\.,? 2012a", "shortCiteRegEx": "Oetsch et al\\.", "year": 2012}, {"title": "Stepwise debugging of descriptionlogic programs", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Correct Reasoning - Essays on Logic-Based AI in Honour of Vladimir Lifschitz, E. Erdem, J. Lee, Y. Lierler, and D. Pearce, Eds. LNCS, vol. 7265. Springer, 492\u2013508.", "citeRegEx": "Oetsch et al\\.,? 2012b", "shortCiteRegEx": "Oetsch et al\\.", "year": 2012}, {"title": "The SeaLion has landed: An IDE for answer-set programming\u2014Preliminary report", "author": ["J. Oetsch", "J. P\u00fchrer", "H. Tompits"], "venue": "Revised Selected Papers of the 19th International Conference on Applications of Declarative Programming and Knowledge Management (INAP\u201911) and the 25th Workshop on Logic Programming (WLP\u201911), Vienna, Austria, Sept. 28-30, 2011. LNCS, vol. 7773. Springer, 305\u2013324.", "citeRegEx": "Oetsch et al\\.,? 2013", "shortCiteRegEx": "Oetsch et al\\.", "year": 2013}, {"title": "Debugging non-ground ASP programs with choice rules, cardinality constraints and weight constraints", "author": ["A. Polleres", "M. Fr\u00fchst\u00fcck", "G. Schenner", "G. Friedrich"], "venue": "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201913), Corunna, Spain, Sept. 15-19, 2013, P. Cabalar and T. C. Son, Eds. LNCS, vol. 8148. Springer, 452\u2013464.", "citeRegEx": "Polleres et al\\.,? 2013", "shortCiteRegEx": "Polleres et al\\.", "year": 2013}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. Pontelli", "T.C. Son", "O. El-Khatib"], "venue": "Theory and Practice of Logic Programming 9, 1, 1\u201356.", "citeRegEx": "Pontelli et al\\.,? 2009", "shortCiteRegEx": "Pontelli et al\\.", "year": 2009}, {"title": "Stepwise debugging in answer-set programming: Theoretical foundations and practical realisation", "author": ["J. P\u00fchrer"], "venue": "Ph.D. thesis, Vienna University of Technology, Vienna, Austria. http://repositum.tuwien.ac.at/urn:nbn:at:at-ubtuw:1-75281 [Online; accessed Dec. 14, 2016].", "citeRegEx": "P\u00fchrer,? 2014", "shortCiteRegEx": "P\u00fchrer", "year": 2014}, {"title": "The dlvhex system for knowledge representation: recent advances (system description)", "author": ["C. Redl"], "venue": "Theory and Practice of Logic Programming 16, 5-6, 866\u2013883.", "citeRegEx": "Redl,? 2016", "shortCiteRegEx": "Redl", "year": 2016}, {"title": "Algorithmic program debugging", "author": ["E.Y. Shapiro"], "venue": "Ph.D. thesis, Yale University, New Haven, CT, USA.", "citeRegEx": "Shapiro,? 1982", "shortCiteRegEx": "Shapiro", "year": 1982}, {"title": "Interactive query-based debugging of ASP programs", "author": ["K.M. Shchekotykhin"], "venue": "Proceedings of the 29th AAAI Conference on Artificial Intelligence (AAAI\u201915), Austin, TX, USA, Jan. 25-30, 2015, B. Bonet and S. Koenig, Eds. AAAI Press, 1597\u20131603.", "citeRegEx": "Shchekotykhin,? 2015", "shortCiteRegEx": "Shchekotykhin", "year": 2015}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence 138, 181\u2013234.", "citeRegEx": "Simons et al\\.,? 2002", "shortCiteRegEx": "Simons et al\\.", "year": 2002}, {"title": "Lonsdaleite", "author": ["A. Smith"], "venue": "https://github.com/rndmcnlly/Lonsdaleite. [Online; accessed Dec. 14, 2016].", "citeRegEx": "Smith,? 2011", "shortCiteRegEx": "Smith", "year": 2011}, {"title": "Debugging inconsistent answer set programs", "author": ["T. Syrj\u00e4nen"], "venue": "Proceedings of the 11th International Workshop on Non-Monotonic Reasoning (NMR\u201906), Lake District, UK, May 30-June 1, 2006, J. Dix and A. Hunter, Eds. Institut f\u00fcr Informatik, Technische Universit\u00e4t Clausthal, Technical Report, 77\u201383.", "citeRegEx": "Syrj\u00e4nen,? 2006", "shortCiteRegEx": "Syrj\u00e4nen", "year": 2006}, {"title": "Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs", "author": ["M. Truszczy\u0144ski"], "venue": "Artificial Intelligence 174, 16-17, 1285\u2013 1306.", "citeRegEx": "Truszczy\u0144ski,? 2010", "shortCiteRegEx": "Truszczy\u0144ski", "year": 2010}, {"title": "IDPDraw, a tool used for visualizing answer sets", "author": ["J. Wittocx"], "venue": "https://dtai.cs. kuleuven.be/software/idpdraw. [Online; accessed Dec. 14, 2016].", "citeRegEx": "Wittocx,? 2009", "shortCiteRegEx": "Wittocx", "year": 2009}, {"title": "Debugging for model expansion", "author": ["J. Wittocx", "H. Vlaeminck", "M. Denecker"], "venue": "Proceedings of the 25th International Conference on Logic Programming (ICLP\u201909), Pasadena, CA, USA, July 14-17, 2009, P. M. Hill and D. S. Warren, Eds. LNCS, vol. 5649. Springer, 296\u2013311.", "citeRegEx": "Wittocx et al\\.,? 2009", "shortCiteRegEx": "Wittocx et al\\.", "year": 2009}], "referenceMentions": [{"referenceID": 36, "context": "Answer-set programming (ASP) (Niemel\u00e4 1999; Marek and Truszczy\u0144ski 1999) is a paradigm for declarative problem solving that is popular amongst researchers in artificial intelligence and knowledge representation.", "startOffset": 29, "endOffset": 72}, {"referenceID": 33, "context": "Answer-set programming (ASP) (Niemel\u00e4 1999; Marek and Truszczy\u0144ski 1999) is a paradigm for declarative problem solving that is popular amongst researchers in artificial intelligence and knowledge representation.", "startOffset": 29, "endOffset": 72}, {"referenceID": 53, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 4, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 22, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 23, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 46, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 39, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 39, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 41, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 43, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 45, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 18, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 50, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015).", "startOffset": 62, "endOffset": 340}, {"referenceID": 2, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015). These previous works are important contributions towards ASP development support, however current approaches come with limitations to their practical applicability. First, existing techniques and tools only capture a basic ASP language fragment that does not include many language constructs that are available and frequently used in modern ASP solver languages, e.g.,, aggregates or choice rules are not covered by current debugging strategies (with the exception of the work by Polleres et al. (2013), where cardinality constraints are dealt with by translation).", "startOffset": 101, "endOffset": 845}, {"referenceID": 2, "context": "In recent years, debugging in ASP has received some attention (Brain and De Vos 2005; Syrj\u00e4nen 2006; Brain et al. 2007; P\u00fchrer 2007; Gebser et al. 2008; Gebser et al. 2009; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al. 2010; Oetsch et al. 2011; Oetsch et al. 2012b; Polleres et al. 2013; Fr\u00fchst\u00fcck et al. 2013; Shchekotykhin 2015). These previous works are important contributions towards ASP development support, however current approaches come with limitations to their practical applicability. First, existing techniques and tools only capture a basic ASP language fragment that does not include many language constructs that are available and frequently used in modern ASP solver languages, e.g.,, aggregates or choice rules are not covered by current debugging strategies (with the exception of the work by Polleres et al. (2013), where cardinality constraints are dealt with by translation). Second, usability aspects are often not considered in current approaches, in particular, the programmer is required to either provide a lot of data to a debugging system or he or she is confronted with a huge amount of information from the system (tackling this problem in query-based debugging has been addressed by Shchekotykhin (2015)).", "startOffset": 101, "endOffset": 1246}, {"referenceID": 19, "context": "Consider the following encoding of an instance of the three-colouring problem in the Gringo language (Gebser et al. 2011):", "startOffset": 101, "endOffset": 121}, {"referenceID": 32, "context": "To this end, we make use of abstract constraints (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004) as an established abstraction for language constructs such as aggregates, weight constraints, and external atoms.", "startOffset": 49, "endOffset": 101}, {"referenceID": 34, "context": "To this end, we make use of abstract constraints (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004) as an established abstraction for language constructs such as aggregates, weight constraints, and external atoms.", "startOffset": 49, "endOffset": 101}, {"referenceID": 42, "context": "We rely on a semantics for arbitrary abstract-constraint programs with disjunctions that we introduced for this purpose in previous work (Oetsch et al. 2012a).", "startOffset": 137, "endOffset": 158}, {"referenceID": 20, "context": "In contrast to other semantics for this type of programs, it is compatible with the semantics of all the ASP solvers we want to support, namely, Clasp (Gebser et al. 2012), DLV (Leone et al.", "startOffset": 151, "endOffset": 171}, {"referenceID": 27, "context": "2012), DLV (Leone et al. 2006), and DLVHEX (Redl 2016).", "startOffset": 11, "endOffset": 30}, {"referenceID": 48, "context": "2006), and DLVHEX (Redl 2016).", "startOffset": 18, "endOffset": 29}, {"referenceID": 19, "context": "In contrast to other semantics for this type of programs, it is compatible with the semantics of all the ASP solvers we want to support, namely, Clasp (Gebser et al. 2012), DLV (Leone et al. 2006), and DLVHEX (Redl 2016). Note that our framework for computations for abstractconstraint programs differs from the one by Liu et al. (2010). We did not build on this existing notion for three reasons.", "startOffset": 152, "endOffset": 337}, {"referenceID": 47, "context": "In order to close this gap between formal and practical ASP, P\u00fchrer developed abstractions of the grounding step together with an abstract notion of non-ground answer-set program as the base language for the stepping methodology in his PhD thesis (P\u00fchrer 2014).", "startOffset": 247, "endOffset": 260}, {"referenceID": 44, "context": "The stepping technique has been implemented in SeaLion (Oetsch et al. 2013), an integrated development environment for ASP.", "startOffset": 55, "endOffset": 75}, {"referenceID": 39, "context": "1 The framework introduced in this paper subsumes and significantly extends previous versions of the stepping technique for normal logic programs (Oetsch et al. 2010; Oetsch et al. 2011) and DL-programs (Oetsch et al.", "startOffset": 146, "endOffset": 186}, {"referenceID": 41, "context": "1 The framework introduced in this paper subsumes and significantly extends previous versions of the stepping technique for normal logic programs (Oetsch et al. 2010; Oetsch et al. 2011) and DL-programs (Oetsch et al.", "startOffset": 146, "endOffset": 186}, {"referenceID": 43, "context": "2011) and DL-programs (Oetsch et al. 2012b).", "startOffset": 22, "endOffset": 43}, {"referenceID": 42, "context": "We recall the syntax of disjunctive abstract-constraint programs and the semantics on which we base our framework (Oetsch et al. 2012a).", "startOffset": 114, "endOffset": 135}, {"referenceID": 29, "context": "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 38, "endOffset": 106}, {"referenceID": 30, "context": "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 38, "endOffset": 106}, {"referenceID": 6, "context": "(2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 38, "endOffset": 106}, {"referenceID": 28, "context": "We compare stepping to other debugging approaches for ASP and discuss the relation of our computation framework to that of Liu et al. (2010) and transition systems for ASP (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al.", "startOffset": 123, "endOffset": 141}, {"referenceID": 32, "context": "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004; Oetsch et al. 2012a).", "startOffset": 108, "endOffset": 181}, {"referenceID": 34, "context": "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004; Oetsch et al. 2012a).", "startOffset": 108, "endOffset": 181}, {"referenceID": 42, "context": "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004; Oetsch et al. 2012a).", "startOffset": 108, "endOffset": 181}, {"referenceID": 32, "context": "As motivated in the introduction, we represent grounded answer-set programs by abstract-constraint programs (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004; Oetsch et al. 2012a). Non-ground programs will be denoted by programs in the input language of Gringo. Thus, we implicitly assume that grounding translates (non-ground) Gringo rules to rules of abstract-constraint programs. For a detailed formal account of our framework in the non-ground setting we refer the interested reader to the dissertation of P\u00fchrer (2014). We assume a fixed set A of ground atoms.", "startOffset": 109, "endOffset": 526}, {"referenceID": 32, "context": "Definition 3 (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004) An abstract constraint, abstract-constraint atom, or C-atom, is a pair A = \u3008D ,C \u3009, where D \u2286 A is a finite set called the domain of A, denoted by DA, and C \u2286 2 is a collection of sets of ground atoms, called the satisfiers of A, denoted by CA.", "startOffset": 13, "endOffset": 65}, {"referenceID": 34, "context": "Definition 3 (Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004) An abstract constraint, abstract-constraint atom, or C-atom, is a pair A = \u3008D ,C \u3009, where D \u2286 A is a finite set called the domain of A, denoted by DA, and C \u2286 2 is a collection of sets of ground atoms, called the satisfiers of A, denoted by CA.", "startOffset": 13, "endOffset": 65}, {"referenceID": 51, "context": "As an example, we recall how weight constraints (Simons et al. 2002) can be expressed as C-atoms.", "startOffset": 48, "endOffset": 68}, {"referenceID": 15, "context": ", aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al.", "startOffset": 13, "endOffset": 51}, {"referenceID": 16, "context": ", aggregates (Faber et al. 2004; Faber et al. 2011) or external atoms (Eiter et al.", "startOffset": 13, "endOffset": 51}, {"referenceID": 14, "context": "2011) or external atoms (Eiter et al. 2005).", "startOffset": 24, "endOffset": 43}, {"referenceID": 34, "context": "Note that the relation between abstract constraints and ASP constructs is well known and motivated abstract constraints in the first place (cf. Marek and Remmel 2004; Marek and Truszczy\u0144ski 2004).", "startOffset": 139, "endOffset": 195}, {"referenceID": 51, "context": "Definition 10 (Simons et al. 2002) A weight constraint is an expression of form", "startOffset": 14, "endOffset": 34}, {"referenceID": 42, "context": "The semantics we use (Oetsch et al. 2012a) extends the FLP-semantics (Faber et al.", "startOffset": 21, "endOffset": 42}, {"referenceID": 15, "context": "2012a) extends the FLP-semantics (Faber et al. 2004; 2011) and coincides with the original notion of answer sets by Gelfond and Lifschitz (1991) on many important classes of logic programs, including elementary C-programs.", "startOffset": 33, "endOffset": 58}, {"referenceID": 15, "context": "2012a) extends the FLP-semantics (Faber et al. 2004; 2011) and coincides with the original notion of answer sets by Gelfond and Lifschitz (1991) on many important classes of logic programs, including elementary C-programs.", "startOffset": 34, "endOffset": 145}, {"referenceID": 42, "context": "Definition 12 (Oetsch et al. 2012a) Let P be a C-program, and let I be an interpretation.", "startOffset": 14, "endOffset": 35}, {"referenceID": 26, "context": "Such rules are referred to as external support (Lee 2005).", "startOffset": 47, "endOffset": 57}, {"referenceID": 17, "context": "Note that Gringo/Clasp treats aggregates in the way suggested by Ferraris (2011). As a consequence, its semantics differs from our semantics in some cases, when recursion is used through negated c-atoms, as ours is an extension of the FLP semantics.", "startOffset": 65, "endOffset": 81}, {"referenceID": 17, "context": "Note that Gringo/Clasp treats aggregates in the way suggested by Ferraris (2011). As a consequence, its semantics differs from our semantics in some cases, when recursion is used through negated c-atoms, as ours is an extension of the FLP semantics. For an in-depth comparison of FLP-semantics and Ferraris semantics we refer to work by Truszczy\u0144ski (2010). An example where the semantics differ is given by the single rule Gringo program a :- not 0{a}0 that has only the empty set as answer set under our semantics, whereas Clasp also admits {a} as an answer set.", "startOffset": 65, "endOffset": 357}, {"referenceID": 42, "context": "Definition 13 (Oetsch et al. 2012a) Let r be a C-rule, X a set of atoms, and I an interpretation.", "startOffset": 14, "endOffset": 35}, {"referenceID": 42, "context": "Definition 14 (Oetsch et al. 2012a) Let P be a C-program, X a set of atoms, and I an interpretation.", "startOffset": 14, "endOffset": 35}, {"referenceID": 42, "context": "Corollary 1 (Oetsch et al. 2012a) Let P be a C-program and I an interpretation.", "startOffset": 12, "endOffset": 33}, {"referenceID": 1, "context": "One could assume that absolute tightness paired with convexity or monotonicity is sufficient to guarantee stable computations because absolute tightness forbids positive dependencies among disjuncts and the absence of such dependencies lowers the complexity of elementary C-programs (Ben-Eliyahu and Dechter 1994).", "startOffset": 283, "endOffset": 313}, {"referenceID": 44, "context": "A prototype our stepping framework has been implemented in SeaLion, an integrated development environment (IDE) for ASP (Oetsch et al. 2013).", "startOffset": 120, "endOffset": 140}, {"referenceID": 12, "context": "It has been a benchmark problem of the second ASP competition (Denecker et al. 2009) to which it was submitted by Martin Brain.", "startOffset": 62, "endOffset": 84}, {"referenceID": 49, "context": "In debugging, having the programmer in the role of an oracle is a common scenario as it is reasonable to assume that a programmer has good intuitions on where to guide the search (Shapiro 1982).", "startOffset": 179, "endOffset": 193}, {"referenceID": 25, "context": "The stepping feature is integrated with the Kara plugin of SeaLion (Kloim\u00fcllner et al. 2013) that can create user-defined graphical representations of interpretations.", "startOffset": 67, "endOffset": 92}, {"referenceID": 25, "context": "Visualisations in Kara are defined using ASP itself, for further information we refer to earlier work (Kloim\u00fcllner et al. 2013).", "startOffset": 102, "endOffset": 127}, {"referenceID": 7, "context": "A comprehensive discussion of other features of SeaLion is given in a related paper (Busoniu et al. 2013) on the IDE.", "startOffset": 84, "endOffset": 105}, {"referenceID": 28, "context": "The goal of the work by Pontelli et al. (2009) is to explain the truth values of literals with respect to a given actual answer set of a program.", "startOffset": 30, "endOffset": 47}, {"referenceID": 28, "context": "Pontelli et al. (2009) use sequences of three-valued interpretations (called computations) in which monotonously more atoms are considered true, respectively, false.", "startOffset": 6, "endOffset": 23}, {"referenceID": 4, "context": "Another early approach (Brain et al. 2007; P\u00fchrer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.", "startOffset": 23, "endOffset": 55}, {"referenceID": 4, "context": "The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al.", "startOffset": 72, "endOffset": 111}, {"referenceID": 23, "context": "The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al.", "startOffset": 72, "endOffset": 111}, {"referenceID": 22, "context": "2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; P\u00fchrer 2007).", "startOffset": 116, "endOffset": 149}, {"referenceID": 39, "context": "The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al.", "startOffset": 167, "endOffset": 187}, {"referenceID": 45, "context": "2010) and also to programs with cardinality constraints (Polleres et al. 2013).", "startOffset": 56, "endOffset": 78}, {"referenceID": 18, "context": "It has been implemented in the Ouroboros plugin of SeaLion (Fr\u00fchst\u00fcck et al. 2013).", "startOffset": 59, "endOffset": 82}, {"referenceID": 22, "context": "Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low.", "startOffset": 92, "endOffset": 132}, {"referenceID": 39, "context": "Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low.", "startOffset": 92, "endOffset": 132}, {"referenceID": 4, "context": "(2015) use control atoms quite similar to that of the tagging approach (Brain et al. 2007; P\u00fchrer 2007) to identify sets of rules that lead to inconsistency of a program under the requirement that a given set of atoms is true in some intended answer set.", "startOffset": 71, "endOffset": 103}, {"referenceID": 0, "context": "An implementation is provided that profits from a tight integration with the ASP solver WASP (Alviano et al. 2015).", "startOffset": 93, "endOffset": 114}, {"referenceID": 31, "context": "Syrj\u00e4nen (2006) aimed at finding explanations why a program has no answer sets.", "startOffset": 0, "endOffset": 16}, {"referenceID": 1, "context": "Another early approach (Brain et al. 2007; P\u00fchrer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets. Debugging requests can be posed by adding further rules that can employ tags as well. That is, ASP is used itself for debugging answer-set programs. The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; P\u00fchrer 2007). The technique is based on ASP meta-programming, i.e., a program over a metalanguage is used to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP). It addresses the question why some interpretation is not an answer set of the given program. Answers are given in terms of unsatisfied rules and unfounded loops. The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al. 2013). It has been implemented in the Ouroboros plugin of SeaLion (Fr\u00fchst\u00fcck et al. 2013). Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al.", "startOffset": 24, "endOffset": 1411}, {"referenceID": 1, "context": "Another early approach (Brain et al. 2007; P\u00fchrer 2007) is based on program rewritings using some additional control atoms, called tags, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets. Debugging requests can be posed by adding further rules that can employ tags as well. That is, ASP is used itself for debugging answer-set programs. The translations needed were implemented in the command-line tool Spock (Brain et al. 2007; Gebser et al. 2009) which also incorporates the translations of another approach in which also ASP is used for debugging purposes (Gebser et al. 2008; P\u00fchrer 2007). The technique is based on ASP meta-programming, i.e., a program over a metalanguage is used to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP). It addresses the question why some interpretation is not an answer set of the given program. Answers are given in terms of unsatisfied rules and unfounded loops. The approach has later been extended from propositional to disjunctive logic programs with constraints, integer arithmetic, comparison predicates, and strong negation (Oetsch et al. 2010) and also to programs with cardinality constraints (Polleres et al. 2013). It has been implemented in the Ouroboros plugin of SeaLion (Fr\u00fchst\u00fcck et al. 2013). Moreover, Shchekotykhin (2015) developed a method on top of the meta-programming approaches (Gebser et al. 2008; Oetsch et al. 2010) that poses questions to the user in order to find a desired problem diagnosis while keeping the amount of required interaction low. In a related approach, Dodaro et al. (2015) use control atoms quite similar to that of the tagging approach (Brain et al.", "startOffset": 24, "endOffset": 1689}, {"referenceID": 0, "context": "An implementation is provided that profits from a tight integration with the ASP solver WASP (Alviano et al. 2015). In order to reduce the possible outcomes, the debugger asks the user about the intended truth of further atoms in an interactive session. In another paper, Li et al. (2015) use inductive logic programming to repair answer-set programs.", "startOffset": 94, "endOffset": 289}, {"referenceID": 22, "context": "(2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010).", "startOffset": 172, "endOffset": 212}, {"referenceID": 39, "context": "(2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010).", "startOffset": 172, "endOffset": 212}, {"referenceID": 10, "context": "(2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.", "startOffset": 101, "endOffset": 145}, {"referenceID": 11, "context": "(2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.", "startOffset": 101, "endOffset": 145}, {"referenceID": 46, "context": "Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence.", "startOffset": 21, "endOffset": 43}, {"referenceID": 22, "context": "The previous meta-programming based debugging technique (Gebser et al. 2008; P\u00fchrer 2007) and follow-up works (Oetsch et al.", "startOffset": 56, "endOffset": 89}, {"referenceID": 39, "context": "2008; P\u00fchrer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program.", "startOffset": 39, "endOffset": 81}, {"referenceID": 45, "context": "2008; P\u00fchrer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program.", "startOffset": 39, "endOffset": 81}, {"referenceID": 53, "context": "Syrj\u00e4nen\u2019s diagnosis technique (Syrj\u00e4nen 2006) is limited to the setting when a program has no answer set at all.", "startOffset": 31, "endOffset": 46}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al.", "startOffset": 0, "endOffset": 24}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.", "startOffset": 0, "endOffset": 480}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily.", "startOffset": 0, "endOffset": 1044}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set.", "startOffset": 0, "endOffset": 1552}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set.", "startOffset": 0, "endOffset": 1881}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; P\u00fchrer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology).", "startOffset": 0, "endOffset": 2355}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; P\u00fchrer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology). Syrj\u00e4nen\u2019s diagnosis technique (Syrj\u00e4nen 2006) is limited to the setting when a program has no answer set at all. The same holds for the work of Dodaro et al. (2015), however the authors demonstrate how other debugging problems can be reduced to that of inconsistency.", "startOffset": 0, "endOffset": 2724}, {"referenceID": 8, "context": "Caballero et al. (2008) developed a declarative debugging approach for datalog using a classification of error explanations similar to that of the aforementioned meta-programming technique (Gebser et al. 2008; Oetsch et al. 2010). Their approach is tailored towards query answering and the language is restricted to stratified datalog. However, the authors provide an implementation that is based on computing a graph that reflects the execution of a query. Wittocx et al. (2009) show how a calculus can be used for debugging first-order theories with inductive definitions (Denecker 2000; Denecker and Ternovska 2008) in the context of model expansion problems, i.e., problems of finding models of a given theory that expand some given interpretation. The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem. The authors provide a system that allows for interactively exploring the proof tree. Besides the mentioned approaches which rely on the semantical behaviour of programs, Mikitiuk et al. (2007) use a translation from logic-program rules to natural language in order to detect program errors more easily. This seems to be a potentially useful feature for an IDE as well, especially for non-expert ASP programmers. We can categorise the different methods by their setting of their debugging tasks. Here, one aspect is whether a technique works with factual or desired answer sets. Approaches that focus on actual answer sets of the program to be debugged include the algorithm by Brain and De Vos (2005) that aims at explaining the presence of atoms in an answer set. Also, justifications (Pontelli et al. 2009) are targeted towards explanations in a given actual answer set, with the difference that they focus on a single atom but can not only explain their presence but also their absence. The approach by Caballero et al. (2008) can also be seen to target a single actual answer set. Due to their focus on actual answer sets of the debugged program, these methods cannot be applied on (erroneous) programs without any answer set. The previous meta-programming based debugging technique (Gebser et al. 2008; P\u00fchrer 2007) and follow-up works (Oetsch et al. 2010; Polleres et al. 2013) deal with a single intended but non-actual answer set of the debugged program. In the approach of Wittocx et al. (2009), the user can specify a class of intended semantic structures which are not preferred models of the theory at hand (corresponding to actual answer sets of the program to be debugged in ASP terminology). Syrj\u00e4nen\u2019s diagnosis technique (Syrj\u00e4nen 2006) is limited to the setting when a program has no answer set at all. The same holds for the work of Dodaro et al. (2015), however the authors demonstrate how other debugging problems can be reduced to that of inconsistency. The method requires an intended answer set but offers the means to generate that in an interactive way, building on the technique by Shchekotykhin (2015). Stepping does not require actual or intended answer sets as a prerequisite, as the user can explore the behaviour of his or her program under different interpretations that may or may not be extended to answer sets by choosing different rules instances.", "startOffset": 0, "endOffset": 2981}, {"referenceID": 4, "context": "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms.", "startOffset": 98, "endOffset": 117}, {"referenceID": 56, "context": "First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules.", "startOffset": 99, "endOffset": 120}, {"referenceID": 46, "context": "Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al.", "startOffset": 127, "endOffset": 172}, {"referenceID": 22, "context": "2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrj\u00e4nen 2006).", "startOffset": 25, "endOffset": 45}, {"referenceID": 53, "context": "2008), or simple choice rules (Syrj\u00e4nen 2006).", "startOffset": 30, "endOffset": 45}, {"referenceID": 4, "context": "The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols.", "startOffset": 36, "endOffset": 55}, {"referenceID": 39, "context": "Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs.", "startOffset": 61, "endOffset": 81}, {"referenceID": 45, "context": "It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules.", "startOffset": 54, "endOffset": 76}, {"referenceID": 46, "context": "This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging.", "startOffset": 77, "endOffset": 99}, {"referenceID": 2, "context": "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrj\u00e4nen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified.", "startOffset": 99, "endOffset": 1195}, {"referenceID": 2, "context": "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrj\u00e4nen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. P\u00fchrer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al.", "startOffset": 99, "endOffset": 3081}, {"referenceID": 2, "context": "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrj\u00e4nen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. P\u00fchrer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al. (2015) as well as Shchekotykhin (2015) can be considered interactive.", "startOffset": 99, "endOffset": 3106}, {"referenceID": 2, "context": "A related form of this type of debugging is also available in one feature of the tagging approach (Brain et al. 2007) that aims at extrapolating non-existent answer sets by switching off rules and guessing further atoms. Here, the stepping technique can be considered more focused, as the interpretation under investigation is determined by the choices of the user in stepping but is essentially arbitrary in the tagging approach if the user does not employ explicit restrictions. Next, we compare the ASP languages supported by different approaches. First, the language of theories with inductive definitions used in one of the debugging approaches (Wittocx et al. 2009) differs from the remaining approaches that are based on logic-programming rules. Many of these works deal only with the basic ASP setting of debugging ground answer-set programs, supporting only normal rules (Brain and De Vos 2005; Pontelli et al. 2009), disjunctive rules (Gebser et al. 2008), or simple choice rules (Syrj\u00e4nen 2006). The work on tagging-based debugging (Brain et al. 2007) sketches how to apply the approach to programs with variables by means of function symbols. The approach by Caballero et al. (2008) deals with non-ground normal programs which have to be stratified. Explicit support for variables is also given in an extension (Oetsch et al. 2010) of the meta-programming approach for disjunctive programs. It was later extended to allow for weight constraints (Polleres et al. 2013) by compiling them away to normal rules. A commonality of the previous approaches is that they target ASP languages that can be considered idealised proper subsets of current solver languages. In this respect, stepping is the first debugging approach that overcomes these limitations as the use of C-programs and abstract grounding (cf. P\u00fchrer 2014) make the framework generic enough to be applied to ASP solver languages. While this does not mean that other approaches cannot be adapted to fit a solver language, it is no always immediately clear how. For our approach, instantiating our abstractions to the language constructs and the grounding method of a solver is sufficient to have a ready-to-use debugging method. Most existing debugging approaches for ASP can be seen as declarative in the sense that a user can pose a debugging query, and receives answers in terms of different declarative definitions of the semantics of answer-set programs, e.g., in terms of active or inactive rules with respect to some interpretation. In particular, the approaches do not take the execution strategy of solvers into account. This also holds for our approach, however stepping and online justifications (Pontelli et al. 2009) are exceptional as both involve a generic notion of computation which adds a procedural flavour to debugging. Nonetheless, the computation model we use can be seen as a declarative characterisation of the answer-set semantics itself as it does not apply a fix order in which to apply rules to build up an answer set. Besides stepping, also the approaches by Wittocx et al. (2009) and Dodaro et al. (2015) as well as Shchekotykhin (2015) can be considered interactive.", "startOffset": 99, "endOffset": 3138}, {"referenceID": 13, "context": "works (Dodaro et al. 2015; Shchekotykhin 2015) use interaction for filtering the resulting debugging information.", "startOffset": 6, "endOffset": 46}, {"referenceID": 50, "context": "works (Dodaro et al. 2015; Shchekotykhin 2015) use interaction for filtering the resulting debugging information.", "startOffset": 6, "endOffset": 46}, {"referenceID": 4, "context": "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering.", "startOffset": 22, "endOffset": 61}, {"referenceID": 22, "context": "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering.", "startOffset": 22, "endOffset": 61}, {"referenceID": 46, "context": "Unlike the three-valued ones used for online justifications (Pontelli et al. 2009), these carry only information about atoms considered true.", "startOffset": 60, "endOffset": 82}, {"referenceID": 2, "context": "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering. The approaches mentioned in this paragraph realise declarative debugging in the sense of Shapiro (1982), where the user serves as an oracle for guiding the search for errors.", "startOffset": 23, "endOffset": 292}, {"referenceID": 2, "context": "Also in further works (Brain et al. 2007; Gebser et al. 2008) which do not explicitely cover interleaved communication between user and system, user information can be used for filtering. The approaches mentioned in this paragraph realise declarative debugging in the sense of Shapiro (1982), where the user serves as an oracle for guiding the search for errors. It is worth highlighting that stepping can be seen as orthogonal to the basic ideas of all the other approaches we discussed. That is, it is reasonable to have a development kit that supports stepping and other debugging methods simultaneously. While debugging is the main focus of this paper, we also consider the computation framework for disjunctive abstract constraint programs introduced in Section 3 an interesting theoretical contribution by itself. Here, an important related work is that of Liu et al. (2010), who also use a notion of computation to characterise a semantics for normal C-programs.", "startOffset": 23, "endOffset": 881}, {"referenceID": 29, "context": "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 141, "endOffset": 209}, {"referenceID": 30, "context": "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 141, "endOffset": 209}, {"referenceID": 6, "context": "Another branch of research, that is related to our notion of computation, focuses on transition systems for analysing answer-set computation (Lierler 2011; Lierler and Truszczy\u0144ski 2016; Brochenin et al. 2014).", "startOffset": 141, "endOffset": 209}, {"referenceID": 37, "context": "These works build on the ideas of a transition system for the DPLL procedure for SAT solving (Nieuwenhuis et al. 2006).", "startOffset": 93, "endOffset": 118}, {"referenceID": 29, "context": "for backjumping and learning as used in modern solvers (Lierler 2011).", "startOffset": 55, "endOffset": 69}, {"referenceID": 6, "context": "There has been work on transition systems for disjunctive programs (Brochenin et al. 2014).", "startOffset": 67, "endOffset": 90}, {"referenceID": 28, "context": "for backjumping and learning as used in modern solvers (Lierler 2011). In contrast, our framework generates ideal (possibly failed) computations without backtracking. Another main difference is that all proposed transition systems have a transition rule for arbitrary assignment of decision literals whereas in our framework truth assignments are restricted to the domain of the C-rule added in the current step. Regarding supported language constructs, to the best of our knowledge, existing transition systems for ASP focus on elementary atoms, i.e., they do not cover aggregates. However, Lierler and Truszczy\u0144ski (2016) also proposed transition systems for multi-logic systems including ASP.", "startOffset": 56, "endOffset": 624}, {"referenceID": 6, "context": "There has been work on transition systems for disjunctive programs (Brochenin et al. 2014). These are based on integrating two sets of transition rules, one for guessing and one for checking of answer set candidates. Similarly, as in the work by Liu et al. (2010), states in transition systems do not keep track of ASP rules as our states do.", "startOffset": 68, "endOffset": 264}, {"referenceID": 19, "context": "It might be worthwhile to explore alternative representations for unstability such as elementary loops (Gebser et al. 2011) that possibly provide more pinpoint information.", "startOffset": 103, "endOffset": 123}, {"referenceID": 2, "context": "Among these measures are best practices for ASP development that have been discussed in a paper by Brain et al. (2009). For working with the stepping method in particular, we give the following recommendations.", "startOffset": 99, "endOffset": 119}, {"referenceID": 38, "context": "that bugs are detected early, using small programs is suggested by an evaluation of the small-scope hypothesis for ASP (Oetsch et al. 2012).", "startOffset": 119, "endOffset": 139}, {"referenceID": 25, "context": "Tools like Kara (Kloim\u00fcllner et al. 2013) (that is implemented in SeaLion), ASPVIZ (Cliffe et al.", "startOffset": 16, "endOffset": 41}, {"referenceID": 9, "context": "2013) (that is implemented in SeaLion), ASPVIZ (Cliffe et al. 2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.", "startOffset": 47, "endOffset": 67}, {"referenceID": 55, "context": "2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.", "startOffset": 15, "endOffset": 29}, {"referenceID": 52, "context": "2008), IDPDraw (Wittocx 2009), or Lonsdaleite (Smith 2011) allow for visualising interpretations.", "startOffset": 46, "endOffset": 58}], "year": 2017, "abstractText": "We introduce a stepping methodology for answer-set programming (ASP) that allows for debugging answer-set programs and is based on the stepwise application of rules. Similar to debugging in imperative languages, where the behaviour of a program is observed during a step-by-step execution, stepping for ASP allows for observing the effects that rule applications have in the computation of an answer set. While the approach is inspired from debugging in imperative programming, it is conceptually different to stepping in other paradigms due to non-determinism and declarativity that are inherent to ASP. In particular, unlike statements in an imperative program that are executed following a strict control flow, there is no predetermined order in which to consider rules in ASP during a computation. In our approach, the user is free to decide which rule to consider active in the next step following his or her intuition. This way, one can focus on interesting parts of the debugging search space. Bugs are detected during stepping by revealing differences between the actual semantics of the program and the expectations of the user. As a solid formal basis for stepping, we develop a framework of computations for answer-set programs. For fully supporting different solver languages, we build our framework on an abstract ASP language that is sufficiently general to capture different solver languages. To this end, we make use of abstract constraints as an established abstraction for popular language constructs such as aggregates. Stepping has been implemented in SeaLion, an integrated development environment for ASP. We illustrate stepping using an example scenario and discuss the stepping plugin of SeaLion. Moreover, we elaborate on methodological aspects and the embedding of stepping in the ASP development process. Under consideration in Theory and Practice of Logic Programming (TPLP). ar X iv :1 70 5. 06 56 4v 1 [ cs .A I] 1 8 M ay 2 01 7 2 J. Oetsch, J. P\u00fchrer, and H. Tompits", "creator": "LaTeX with hyperref package"}}}