{"id": "1705.07226", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-May-2017", "title": "RankPL: A Qualitative Probabilistic Programming Language", "abstract": "In this paper we introduce RankPL, a modeling language that can be thought of as a qualitative variant of a probabilistic programming language with a semantics based on Spohn's ranking theory. Broadly speaking, RankPL can be used to represent and reason about processes that exhibit uncertainty expressible by distinguishing \"normal\" from\" surprising\" events. RankPL allows (iterated) revision of rankings over alternative program states and supports various types of reasoning, including abduction and causal inference. We present the language, its denotational semantics, and a number of practical examples. We also discuss an implementation of RankPL that is available for download.", "histories": [["v1", "Fri, 19 May 2017 23:58:26 GMT  (34kb)", "http://arxiv.org/abs/1705.07226v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.PL", "authors": ["tjitze rienstra"], "accepted": false, "id": "1705.07226"}, "pdf": {"name": "1705.07226.pdf", "metadata": {"source": "CRF", "title": "RankPL: A Qualitative Probabilistic Programming Language", "authors": ["Tjitze Rienstra"], "emails": ["tjitze@gmail.com"], "sections": [{"heading": null, "text": "ar Xiv: 170 5.07 226v 1 [cs.A I] 1 9M ay"}, {"heading": "1 Introduction", "text": "Probabilistic programming languages (PPLs) are programming languages extended with statements to (1) draw values at random from a given probability distribution, and (2) perform conditioning due to observation. Probabilistic programs yield, rather than a deterministic result, a probability distribution over possible outcomes. PPLs much simplification of, and reasoning with rich probabilistic models [6]. Ranking theory is a qualitative abstraction of probability theory, in which events receive discrete degree of surprise called [11]. That is, events are ranking 0 (not surprised), 2 (very surprised), and reasence goes back to Kozen [6]. Ranking theory is a qualitative abstraction of probability theory which is receive discrete degree of surprise."}, {"heading": "2 Ranking Theory", "text": "The definition of a ranking function presupposes a finite set of possibilities and a Boolean algebra A over subsets of events that we assign to events. Definition 1. A ranking function is a function that associates each possibility with a ranking order. [As mentioned in the introduction] A ranking order is extended over events by defining ranking B as a degree of surprise or alternatively as an inverse degree of plausibility. A requirement that rank (w) = 0 is equivalent to the condition that at least one w = 0 is equivalent to the condition that at least one w = 0 is given abilities. We sometimes work with functions that violate this condition."}, {"heading": "3 RankPL", "text": "We begin with a brief overview of the properties of RankPL, based on a minimal imperative consisting of integer variables, an if -then-else statement, and a while-do construct. We expand it with the two special statements mentioned in the introduction. We call the first ranked choice. It is in the form of {s1} < e > {s2}. Intuitively, it states that either s1 or s2 is executed, the first being a normal (rank 0) event and the second a typically surprising event, the rank of which is the value of the expression e. In other words, it is a randomly executed statement from a ranking function across two choices. Note that we can set e to zero to represent a tie of two equally probable choices, and that larger sets of choices by nesting. The second special statement is called a statement: ltx: the observation. It states that the condition &b; y is met."}, {"heading": "3.1 Syntax", "text": "We fix a set of variables (surrounded by x) and use Val to denote the set of integers, including \u221e (surrounded by n). We use e, b, and s to rank above the numerical expressions, Boolean expressions, and statements. They are defined by the following BNF rules: e: = n | x | rank b | (e1 \u2666 e2) (for \u2666 {\u2212, +, \u00d7, \u00f7}) b: = \u00ac b | (b1 b2) | (e1 e2) (for \u0432 {=, <}) s: = {s0; s1} | x: = e | if b then {s1} else {s2} | while b do {s1} < e > {s2} | we omit braces and curly braces if possible and define them in terms of price and euros."}, {"heading": "3.2 Semantics", "text": "The meaning of a statement s as a function DJsK is not fully defined in two ways. Subjects of these rankings are program states represented by ratings, i.e., functions that assign values to all variables. The initial rating, which is defined by 0, sets all variables to 0. The initial ranking, which is defined by 0, characters 0 to 0 and others, is determined by the actual rating before execution s, then DJsK (note: DJsK) is the degree of rating before execution s, then DJsK (note: DJsK) is the degree of surprise before execution. DJsK (note: DJsK) is the degree of surprise that the actual rating is after execution DJsK. If we refer to the result of execution of the program, we refer to the ranking DJsK (note: DJsK)."}, {"heading": "4 Noisy Observation and Iterated Revision", "text": "This is not desirable if we have to deal again with recurring changes in beliefs or unreliable observations, since after conditioning A we can set a condition on events that are not in accord with A. J conditioning [3] is a more general form of conditioning that addresses this problem. It is parameterized by a precedence x, which indicates the steadfastness with which the evidence must be credible. Definition 3. Let A-Z-Z have a precedence over such (A), a precedence (A), a precedence (A), and a precedence x. The J-Z conditioning of A with the strength x, which is defined by an x-Z. Definition x (B) = min. (B), a precedence (B), a precedence (A) + x. In words, the effect of J conditioning of A with the strength x is that A is believed with the firmness."}, {"heading": "5 Implementation", "text": "A RankPL interpreter written in Java can be found at http: / / github.com / tjitze / RankPL. It executes programs written with the syntax described in this essay or constructed with Java classes that comply with this syntax, which allows RankPL programs to be embedded in Java code and interact with classes and methods written in Java. The interpreter follows the semantics described in Section 3 and implements the strategy of the most plausible initial execution discussed in Section 3.2. All examples discussed in this essay are included, as well as a number of other examples."}, {"heading": "6 Conclusion and Future Work", "text": "We have introduced RankPL, a language that is semantically similar to probabilistic programming, but based on Spohn's ranking theory, demonstrating its usefulness with examples of abduction and revision. We believe that the approach has great potential for applications where PPLs are too demanding due to their computational complexity and dependence on precise probability values. Furthermore, we hope that our approach will create a broader and more practical scope for the topics of ranking theory and belief revision, which have been examined in the past mainly from purely theoretical perspectives. A number of aspects have not been touched upon and will be addressed in future work, including a finer characterization of termination and a discussion of the relationship to non-deterministic programming, which is a specific case of RankPL. Furthermore, we have omitted examples to show that RankPL ranking networks can be subsumed and used to reason about exclusive rules and actions."}], "references": [{"title": "On the logic of iterated belief revision", "author": ["A. Darwiche", "J. Pearl"], "venue": "Artificial intelligence 89(1-2), 1\u201329", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1996}, {"title": "Handbook of logic in artificial intelligence and logic programming (vol", "author": ["P. G\u00e4rdenfors", "H. Rott"], "venue": "4). chap. Belief Revision, pp. 35\u2013132. Oxford University Press, Oxford, UK", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1995}, {"title": "Qualitative probabilities for default reasoning, belief revision, and causal modeling", "author": ["M. Goldszmidt", "J. Pearl"], "venue": "Artificial Intelligence 84(1), 57\u2013112", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1996}, {"title": "Church: a language for generative models", "author": ["N.D. Goodman", "V.K. Mansinghka", "D.M. Roy", "K. Bonawitz", "J.B. Tenenbaum"], "venue": "McAllester, D.A., Myllym\u00e4ki, P. (eds.) UAI 2008, Proceedings of the 24th Conference in Uncertainty in Artificial Intelligence, Helsinki, Finland, July 9-12, 2008. pp. 220\u2013229. AUAI Press", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "Reasoning about uncertainty", "author": ["J.Y. Halpern"], "venue": "MIT Press", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2005}, {"title": "Semantics of probabilistic programs", "author": ["D. Kozen"], "venue": "J. Comput. Syst. Sci. 22(3), 328\u2013 350", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1981}, {"title": "Probability and the logic of rational belief", "author": ["H.E. Kyburg Jr."], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1961}, {"title": "Venture: a higher-order probabilistic programming platform with programmable inference", "author": ["V.K. Mansinghka", "D. Selsam", "Y.N. Perov"], "venue": "CoRR abs/1404.0099", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2014}, {"title": "System Z: A natural ordering of defaults with tractable applications to nonmonotonic reasoning", "author": ["J. Pearl"], "venue": "Parikh, R. (ed.) Proceedings of the 3rd Conference on Theoretical Aspects of Reasoning about Knowledge, Pacific Grove, CA, March 1990. pp. 121\u2013135. Morgan Kaufmann", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1990}, {"title": "Figaro: An object-oriented probabilistic programming language", "author": ["A. Pfeffer"], "venue": "Charles River Analytics Technical Report 137", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "The Laws of Belief - Ranking Theory and Its Philosophical Applications", "author": ["W. Spohn"], "venue": "Oxford University Press", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}], "referenceMentions": [{"referenceID": 3, "context": "Examples of modern PPLs include Church, Venture and Figaro [4,8,10], while early work goes back to Kozen [6].", "startOffset": 59, "endOffset": 67}, {"referenceID": 7, "context": "Examples of modern PPLs include Church, Venture and Figaro [4,8,10], while early work goes back to Kozen [6].", "startOffset": 59, "endOffset": 67}, {"referenceID": 9, "context": "Examples of modern PPLs include Church, Venture and Figaro [4,8,10], while early work goes back to Kozen [6].", "startOffset": 59, "endOffset": 67}, {"referenceID": 5, "context": "Examples of modern PPLs include Church, Venture and Figaro [4,8,10], while early work goes back to Kozen [6].", "startOffset": 105, "endOffset": 108}, {"referenceID": 10, "context": "Ranking theory is a qualitative abstraction of probability theory in which events receive discrete degrees of surprise called ranks [11].", "startOffset": 132, "endOffset": 136}, {"referenceID": 0, "context": "belief revision and non-monotonic reasoning [1,3]) as well as formal epistemology [11].", "startOffset": 44, "endOffset": 49}, {"referenceID": 2, "context": "belief revision and non-monotonic reasoning [1,3]) as well as formal epistemology [11].", "startOffset": 44, "endOffset": 49}, {"referenceID": 10, "context": "belief revision and non-monotonic reasoning [1,3]) as well as formal epistemology [11].", "startOffset": 82, "endOffset": 86}, {"referenceID": 0, "context": "This is a form of revision consistent with the well-known AGM and DP postulates for (iterated) revision [1,2].", "startOffset": 104, "endOffset": 109}, {"referenceID": 1, "context": "This is a form of revision consistent with the well-known AGM and DP postulates for (iterated) revision [1,2].", "startOffset": 104, "endOffset": 109}, {"referenceID": 10, "context": "Here we present the necessary basics of ranking theory, all of which is due to Spohn [11].", "startOffset": 85, "endOffset": 89}, {"referenceID": 6, "context": "A similar notion of belief does not exist for probabilities, as is demonstrated by the Lottery paradox [7].", "startOffset": 103, "endOffset": 106}, {"referenceID": 10, "context": "This correspondence also underlies notions such as (conditional) independence and ranking nets (the ranking-based counterpart of Bayesian networks) that have been defined in terms of rankings [11].", "startOffset": 192, "endOffset": 196}, {"referenceID": 5, "context": "Firstly, the semantics of RankPL can be thought of as a ranking-based variation of the Kozen\u2019s semantics of probabistic programs [6] (i.", "startOffset": 129, "endOffset": 132}, {"referenceID": 2, "context": "J-conditioning [3] is a more general form of conditioning that addresses this problem.", "startOffset": 15, "endOffset": 18}, {"referenceID": 2, "context": "L-conditioning [3] is another kind of generalized conditioning.", "startOffset": 15, "endOffset": 18}, {"referenceID": 10, "context": "Unlike J-conditioning, L-conditioning satisfies two properties that are desirable for modeling noisy observation: reversibility ((\u03baA\u2191x)A\u2191x = \u03ba) and commutativity ((\u03baA\u2191x)B\u2191x = (\u03baB\u2191x)A\u2191x) [11].", "startOffset": 186, "endOffset": 190}, {"referenceID": 2, "context": "Furthermore, we have omitted examples to show that RankPL subsumes ranking networks and can be used to reason about causal rules and actions [3].", "startOffset": 141, "endOffset": 144}, {"referenceID": 8, "context": ", [9]).", "startOffset": 2, "endOffset": 5}, {"referenceID": 3, "context": "These features are also supported by PPLs such as Church [4], Venture [8] and Figaro [10].", "startOffset": 57, "endOffset": 60}, {"referenceID": 7, "context": "These features are also supported by PPLs such as Church [4], Venture [8] and Figaro [10].", "startOffset": 70, "endOffset": 73}, {"referenceID": 9, "context": "These features are also supported by PPLs such as Church [4], Venture [8] and Figaro [10].", "startOffset": 85, "endOffset": 89}], "year": 2017, "abstractText": "In this paper we introduce RankPL, a modeling language that can be thought of as a qualitative variant of a probabilistic programming language with a semantics based on Spohn\u2019s ranking theory. Broadly speaking, RankPL can be used to represent and reason about processes that exhibit uncertainty expressible by distinguishing \u201cnormal\u201d from \u201csurprising\u201d events. RankPL allows (iterated) revision of rankings over alternative program states and supports various types of reasoning, including abduction and causal inference. We present the language, its denotational semantics, and a number of practical examples. We also discuss an implementation of RankPL that is available for download.", "creator": "LaTeX with hyperref package"}}}