{"id": "1705.07429", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-May-2017", "title": "Sketched Answer Set Programming", "abstract": "Answer Set Programming (ASP) is a powerful modeling formalism for combinatorial problems. However, writing ASP models is not trivial. We propose a novel method, called Sketched Answer Set Programming (SkASP), aiming at supporting the user in resolving this issue. The user writes an ASP program while marking uncertain parts open with question marks. In addition, the user provides a number of positive and negative examples of the desired program behaviour. The sketched model is rewritten into another ASP program, which is solved by traditional methods. As a result, the user obtains a functional and reusable ASP program modelling her problem. We evaluate our approach on 21 well known puzzles and combinatorial problems inspired by Karp's 21 NP-complete problems and demonstrate a use-case for a database application based on ASP.", "histories": [["v1", "Sun, 21 May 2017 11:03:53 GMT  (1455kb,D)", "http://arxiv.org/abs/1705.07429v1", "15 pages, 11 figures"]], "COMMENTS": "15 pages, 11 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["sergey paramonov", "christian bessiere", "anton dries", "luc de raedt"], "accepted": false, "id": "1705.07429"}, "pdf": {"name": "1705.07429.pdf", "metadata": {"source": "CRF", "title": "Sketched Answer Set Programming", "authors": ["Sergey Paramonov", "Christian Bessiere", "Anton Dries", "Luc De Raedt"], "emails": ["sergey.paramonov@kuleuven.be)"], "sections": [{"heading": null, "text": "Key concepts: Answer Programming; Relational Learning; Constraint Learning"}, {"heading": "1 Introduction", "text": "Many AI problems can be formulated as a condition of using the satisfaction problems that can be solved by status-of-the-art constraint programming (CP) (CP et al., 2006) or answering programming (ASP) techniques (Lifschitz, 2008). Although these frameworks offer declarative representations that are in principle easy to understand, writing models in such languages is not always easy. The idea of the program sketch is to start from a sketched program and some examples to complete the program. a sketched program is essentially a program in which some of the tests and constructs are open because the programmer does not know what exactly the instructions are to use."}, {"heading": "2 ASP and Sketching", "text": "It's not like it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way, in which it's about a way and a way and a way, and a way and a way, and a way and a way and a way and a way, and a way and a way and a way, and a way and a way, and a way and a way, a way and a way, a way and a way, a way and a way, a way and a way, a way, a way and a way, a way, a way and a way, a way, a way and a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way, a way,"}, {"heading": "3 Rewritting Schema", "text": "The key idea behind our approach is to rewrite a SkASP problem (P, S, D, f, E +, E \u2212) into an ASP program, so that the original sketching program has a solution to the ASP program. This is achieved by 1) inserting decision variables into the outlined predicates, and 2) introducing example connoisseurs into the predicator. The original SkASP problem is then converted into an ASP problem to allow the use of decision variables and solutions to the ASP problem, the SkASP substitution.The rewrite procedure has four important steps: expansion, substitution generation, predicate maturation, and constraint splitting. Example identifiers To allow the use of multiple examples in the program, each relevant predicate is extended with an additional argument representing the example program."}, {"heading": "4 Experimental Evaluation", "text": "This year is the highest in the history of the country."}, {"heading": "5 Use-case: database query completeness", "text": "It is about the question of to what extent it is actually about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way and in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about a way, in which it is about which it is about a way, in which it is about a way, in which it is about which it is about which it is about which it is about a way, in which it is about which it is about which it is about which it is about a way, in which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about a way, in which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which it is about which"}, {"heading": "6 Related Work", "text": "This year, it is more than ever before in the history of the country in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is a country, in which it is not a country, but in which it is a country, a country and a country."}, {"heading": "7 Discussion and Conclusions", "text": "Our contribution is quadruple: we have introduced the problem of the ASP outlined; we have created a solid and complete paraphrase scheme for the ASP outlined; we have shown that the complexity of paraphrasing is identical to the existence of an AS; we have created a dataset of outlined problems and have empirically proven our approach to be efficient and effective.User interaction is an interesting direction for future work, namely to suggest constraints and examples. If we are not able to reject a negative example, we can construct a constraint that would discard the negative examples and none of the positive examples. As for the examples, if we have two solutions to a problem, we can create an example that distinguishes between them and ask the user to clarify it, while this may not always be possible, as symmetric assignments could lead to semantically identical programs. In practice, however, this could be an important addition to the simplification of the end user sketch for the ASP, which is an interesting direction to use."}, {"heading": "Appendix A Dataset Description", "text": "In Table A 1 we provide an overview of the data set and its characteristics, such as the number of variables sketched in each problem and the number of rules, other columns describe the number of specific types of variables sketched, e.g. \"? not\" indicates how many atoms with the sketched problem? = =?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\""}], "references": [{"title": "A model seeker: Extracting global constraint models from positive examples", "author": ["N. BELDICEANU", "H. SIMONIS"], "venue": "CP, pp. 141\u2013157.", "citeRegEx": "BELDICEANU and SIMONIS,? 2012", "shortCiteRegEx": "BELDICEANU and SIMONIS", "year": 2012}, {"title": "Constraint acquisition via partial queries", "author": ["C. BESSIERE", "R. COLETTA", "E. HEBRARD", "G. KATSIRELOS", "N. LAZAAR", "N. NARODYTSKA", "C. QUIMPER", "T. WALSH"], "venue": "IJCAI, pp. 475\u2013481.", "citeRegEx": "BESSIERE et al\\.,? 2013", "shortCiteRegEx": "BESSIERE et al\\.", "year": 2013}, {"title": "A sat-based version space algorithm for acquiring constraint satisfaction problems", "author": ["C. BESSIERE", "R. COLETTA", "F. KORICHE"], "venue": "ECML, pp. 23\u201334. Springer.", "citeRegEx": "BESSIERE et al\\.,? 2005", "shortCiteRegEx": "BESSIERE et al\\.", "year": 2005}, {"title": "Asprin: Customizing answer set preferences without a headache", "author": ["G. BREWKA", "J. DELGRANDE", "J. ROMERO", "T. SCHAUB"], "venue": "AAAI, pp. 1467\u20131474. AAAI Press.", "citeRegEx": "BREWKA et al\\.,? 2015", "shortCiteRegEx": "BREWKA et al\\.", "year": 2015}, {"title": "Predicate logic as a modeling language: Modeling and solving some machine learning and data mining problems with IDP3", "author": ["M. BRUYNOOGHE", "H. BLOCKEEL", "B. BOGAERTS", "B. DE CAT", "S.D. POOTER", "J. JANSEN", "A. LABARRE", "J. RAMON", "M. DENECKER", "S. VERWER"], "venue": "CoRR abs/1309.6883.", "citeRegEx": "BRUYNOOGHE et al\\.,? 2013", "shortCiteRegEx": "BRUYNOOGHE et al\\.", "year": 2013}, {"title": "Logical and Relational Learning: From ILP to MRDM (Cognitive Technologies)", "author": ["Sergey Paramonov", "Christian Bessiere", "Anton Dries", "L. Luc De Raedt DE RAEDT"], "venue": null, "citeRegEx": "Paramonov et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Paramonov et al\\.", "year": 2008}, {"title": "Reasoning web", "author": ["Springer-Verlag New York", "Inc.", "NJ Secaucus", "T. USA. EITER", "G. IANNI", "T. KRENNWALLNER"], "venue": "semantic technologies for infor-", "citeRegEx": "York et al\\.,? 2009", "shortCiteRegEx": "York et al\\.", "year": 2009}, {"title": "Inductive programming meets the real world", "author": ["B. ZORN"], "venue": "Commun. ACM 58, 11, 90\u201399. H\u00d6LLDOBLER, S. AND SCHWEIZER, L. 2014. Answer set programming and clasp a tutorial. In Young", "citeRegEx": "ZORN,? 2015", "shortCiteRegEx": "ZORN", "year": 2015}, {"title": "Jsketch: sketching for java", "author": ["J. JEON", "X. QIU", "J.S. FOSTER", "A.S. LEZAMA"], "venue": "Scientists International Workshop on Trends in Information Processing (YSIP),", "citeRegEx": "JEON et al\\.,? \\Q2015\\E", "shortCiteRegEx": "JEON et al\\.", "year": 2015}, {"title": "On learning constraint problems", "author": ["A. pp. 934\u2013937. LALLOUET", "M. LOPEZ", "L. MARTIN", "C. VRAIN"], "venue": null, "citeRegEx": "LALLOUET et al\\.,? \\Q2010\\E", "shortCiteRegEx": "LALLOUET et al\\.", "year": 2010}, {"title": "The sketching approach to program synthesis", "author": ["Springer International Publishing", "A.S. Cham. LEZAMA"], "venue": "APLAS, pp. 4\u201313. LEZAMA, A. S. 2013. Program sketching. STTT 15, 475\u2013495. LI, T., VOS, M. D., PADGET, J., SATOH, K., AND BALKE, T. 2015. Debugging ASP using ILP. In", "citeRegEx": "Publishing and LEZAMA,? 2009", "shortCiteRegEx": "Publishing and LEZAMA", "year": 2009}, {"title": "What is answer set programming? AAAI", "author": ["Technical Communications ICLP Cork", "V. Ireland. LIFSCHITZ"], "venue": "MUGGLETON, S. AND DE RAEDT, L. 1994. Inductive logic programming: Theory and methods. Journal", "citeRegEx": "Cork and LIFSCHITZ,? 2008", "shortCiteRegEx": "Cork and LIFSCHITZ", "year": 2008}, {"title": "Implementing query completeness reasoning", "author": ["ing. TPLP", "W. 4-5-Online-Supplement. NUTT", "S. PARAMONOV", "O. SAVKOVIC"], "venue": null, "citeRegEx": "13 et al\\.,? \\Q2015\\E", "shortCiteRegEx": "13 et al\\.", "year": 2015}, {"title": "CSPLib problem 110: Peaceably co-existing armies of queens", "author": [], "venue": null, "citeRegEx": "147", "shortCiteRegEx": "147", "year": 2015}, {"title": "Completeness of queries over incomplete databases", "author": ["W. NUTT"], "venue": "PVLDB 4,", "citeRegEx": "RAZNIEWSKI and NUTT,? \\Q2011\\E", "shortCiteRegEx": "RAZNIEWSKI and NUTT", "year": 2011}, {"title": "MAGIK: managing completeness", "author": ["O. Elsevier. SAVKOVIC", "P. MIRZA", "S. PARAMONOV", "W. NUTT"], "venue": null, "citeRegEx": "SAVKOVIC et al\\.,? \\Q2012\\E", "shortCiteRegEx": "SAVKOVIC et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 4, "context": "Currently, we have implemented preferences using a post-processing approach (which will also allow to apply the schema to other formalism such as CP or IDP (Bruynooghe et al., 2013)), in which we first generate the set of all solutions O (without taking into account the preferences), and then post-process O.", "startOffset": 156, "endOffset": 181}, {"referenceID": 3, "context": "In future work, we plan to make the search more effective by using the preferences in the search process (using ASP extensions (Brewka et al., 2015)) or by formulating the SkASP task as an optimisation problem (using built-in ASP constructs).", "startOffset": 127, "endOffset": 148}, {"referenceID": 1, "context": ", 2005, 2017) and QUACQ (Bessiere et al., 2013) learn a set of propositional constraints, and ModelSeeker (Beldiceanu and Simonis, 2012) learns global constraints governing a particular set of examples.", "startOffset": 24, "endOffset": 47}, {"referenceID": 0, "context": ", 2013) learn a set of propositional constraints, and ModelSeeker (Beldiceanu and Simonis, 2012) learns global constraints governing a particular set of examples.", "startOffset": 66, "endOffset": 96}, {"referenceID": 3, "context": "Another interesting direction is to incorporate preference handling into the ASP model using the extensions of ASP for preference handling, such as asprin (Brewka et al., 2015).", "startOffset": 155, "endOffset": 176}], "year": 2017, "abstractText": "Answer Set Programming (ASP) is a powerful modeling formalism for combinatorial problems. However, writing ASP models is not trivial. We propose a novel method, called Sketched Answer Set Programming (SkASP), aiming at supporting the user in resolving this issue. The user writes an ASP program while marking uncertain parts open with question marks. In addition, the user provides a number of positive and negative examples of the desired program behaviour. The sketched model is rewritten into another ASP program, which is solved by traditional methods. As a result, the user obtains a functional and reusable ASP program modelling her problem. We evaluate our approach on 21 well known puzzles and combinatorial problems inspired by Karps 21 NP-complete problems and demonstrate a use-case for a database application based on ASP.", "creator": "LaTeX with hyperref package"}}}