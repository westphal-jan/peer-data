{"id": "1705.08992", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-May-2017", "title": "Matroids Hitting Sets and Unsupervised Dependency Grammar Induction", "abstract": "This paper formulates a novel problem on graphs: find the minimal subset of edges in a fully connected graph, such that the resulting graph contains all spanning trees for a set of specifed sub-graphs. This formulation is motivated by an un-supervised grammar induction problem from computational linguistics. We present a reduction to some known problems and algorithms from graph theory, provide computational complexity results, and describe an approximation algorithm.", "histories": [["v1", "Wed, 24 May 2017 22:53:56 GMT  (62kb,D)", "https://arxiv.org/abs/1705.08992v1", null], ["v2", "Sat, 15 Jul 2017 20:24:11 GMT  (62kb,D)", "http://arxiv.org/abs/1705.08992v2", "11 pages 4 figures"]], "reviews": [], "SUBJECTS": "cs.DM cs.CL cs.DS", "authors": ["nicholas harvey", "vahab mirrokni", "david karger", "virginia savova", "leonid peshkin"], "accepted": false, "id": "1705.08992"}, "pdf": {"name": "1705.08992.pdf", "metadata": {"source": "CRF", "title": "Matroids Hitting Sets and Unsupervised Dependency Grammar Induction", "authors": ["Nicholas Harvey", "David Karger", "Vahab Mirrokni", "Virginia Savova", "Leonid Peshkin"], "emails": ["peshkin@gmail.com"], "sections": [{"heading": "1 Introduction", "text": "In fact, it is such that most of them are able to survive themselves without there being a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, in which there is a process, a process, in which there is a process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process, the process,"}, {"heading": "2 The Problem for Spanning-Trees", "text": "Let G = (V, E) be a diagram and let S1,.., Sk be any subset of V. Our goal is to find a set of edges F'E so that \u2022 F contains a voltage tree for each induced subgraph G [Si], and \u2022 | F | is minimized. We call this the problem of the Min Spanning Tree Hitting Set. Figure 3 illustrates an example of this problem. A diagram G consists of two subgraphs G1 and G2. We present a possible correct solution on the left (| F | = 4) and two erroneous solutions (| F | = 5) on the right. The problem of the Min SpanningTree Hitting Set problem can be generalized to a weight function w at the edges of G. The goal for the weighted problem is the same as before, except that we try to minimize the node w (F)."}, {"heading": "2.1 Hardness for Weighted Instances", "text": "We now show that the weighted problem NP-heavy is within a factor of log n > r weight. To do this, we show a reduction of Min Hitting Set, which is known to be difficult to approximate within log. An instance of Min Hitting Set consists of a universe U = {u1,., un} and a collection of sets T = {T1,., Tm}, each of which is a subset of U. We construct a weighted instance of Min Spanning-Tree Hitting Set as follows. Let's be a new vertex. We set V = U + rE = KU {r, ui}: for all ui, U} S {i, j} for 1."}, {"heading": "2.2 Hardness for Unweighted Instances", "text": "We show APX hardness for the unweighted problem by reducing Vertex Cover = > G coverage. The approach is similar to the construction in Section 2.1. Suppose we have an example of G hardness for the Vertex Cover problem. \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 We use the fact that Vertex Cover corresponds to the min-hit set in which U = E 'and T = E'. The design only differs in that E 'cover is used instead of the edge set KU; the sentences S'i, j' are adjusted accordingly. Leave h the minimal cardinality of a spanning tree-hitting set in G. Leave c the minimal cardinality of a vertex cover in G '. A claim identical to Claim 1 shows that h = c + | E'.Remember that Vertex Cover is APX hard, even for constant degree spacing; e.g., see Cover V, VirV]."}, {"heading": "3 The Problem for Matroids", "text": "The Min Spanning-Tree Hitting Set can be reformulated as a question about matroids. Let E be a base set. Let Mi = (E, Ii) be a matroid for 1 \u2264 i \u2264 k. Our goal is to find F'E so that \u2022 F contains a foundation for each Mi and \u2022 | F | is minimized. We call this the Minimum Basis Hitting Set Problem."}, {"heading": "3.1 Connection to Matroid Intersection", "text": "Suppose we switch to the dual matroids. Note that F contains a basis for Mi if and only E\\ F-I-i. Then our goal is to find F'E so that \u2022 F'I-i is maximized for each i and \u2022 | F \"|. Suppose such a set is found, and leave F: = E\\ F.\" The first property implies that F contains a basis for each Mi. The second property implies that | F | is minimized. In this way, it is exactly the matroid-k intersection problem. So, from the point of view of exact algorithms, min-base-hitting set and matroid-k intersection problems are equivalent. However, this reduction is not nearly gentle and implies nothing about approximation algorithms."}, {"heading": "3.2 Hardness", "text": "Theorem 2 Min Base Hitting Set is NP-Hard.Proof: We perform a reduction of the known problem Minimum Hitting Set. An example of this problem consists of a family of sets C = {C1,..., Ck}. The goal is to find a set of F'E so that F-Ci 6 = \u2205 Ci for each i. This problem is NP-Complete.Now we reduce it to Minimum Base Hitting Set. For each set Ci, set Mi = (E, Ii) is the matroid, for the Ii = {c}: c-Ci}. That is, Wed is the ranking-1 uniform matroid on Ci. Thus, a basic striking set for these matroids corresponds exactly to a striking set for the sets C.Corollary 3 Min Base Hitting Set is NP-heavy with c-Log n for any positive constant c.Proof: It is known that Min Base Hitting Set corresponds to the cover and therefore within the protocol Min Base Hitting Set is roughly equal to 3."}, {"heading": "3.3 An Approximation Algorithm", "text": "Let O'E denote an optimal solution. Let rankj be the rank function for matroid Mj and let rj be the rank of Mj, i.e., rj = rankj (E). Let Fi denote the sentence chosen after the last step of the algorithm. First, we have F0 = \u2264 \u2212 P \u2212 \u2212 p = \u2212 p \u2212 p = 1 (rankj (S + e) \u2212 rankj (S) \u2212 rankj (S)); intuitively, this is the total gain that is made, or rank that is achieved by adding e to S. Let Ri denote k j = 1 (rj \u2212 rankj (Fi) j j = 1 (S + e) \u2212 rankj (S) \u2212 rankj (S) rankj (S) rankj (S) rankj (S)."}, {"heading": "3.4 Contrast with Matroid Union", "text": "Consider the Matroid Union problem for Matroids M * i. The Matroid Union problem is: max [| i Si |: Si] I * i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i. \"In other words: Si\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" i \"i\" contains a basis for Mi. \"And maximizing the size of the Union is the same as minimizing the size of the complement of the Union. So an equivalent problem is: min\" i \"i\" Si \": Si\" contains a basis for Mi. \"The minimum does not change if we assume that Si is actually a foundation. So, if we call Ti\" S \"i\" i \"i\" i \"i,\" we get the equivalent problem: min \"i\" Ti \"is a foundation for Mi,\" except that \"there is a\" compound \"because there is only a matroid-union."}, {"heading": "3.5 Empirical study", "text": "We conducted preliminary experiments with the approximation algorithm for the child-controlled language of adults in the CHILDES corpus. [9] These experiments showed that the algorithm performs better than the baseline adjacency heuristic because of its ability to pick out non-adjacent dependencies. For example, the sentence \"Is that a woof?\" is divided into the following associations: woof-is, das-is, a-woof. The associations correspond to the correct parse tree of the sentence, whereas the baseline adjacency heuristic would classify the sentence in is-that; that-a; and a-woof, which does not capture the dependence between the predicate word \"woof\" and the verb, and postulates a non-existent dependence between the determinator \"a\" and the subject \"that.\" However, more work is needed to assess the performance thoroughly. A problem for the direct application is the repetition of this sentence, where the repeated phrase cannot be completely dependent on the current sentence, where the current sentence is repeated in the sentence."}, {"heading": "4 Discussion", "text": "We presented some theoretical results for a problem on graphs inspired by the unattended linkgrammatical induction problem from linguistics. Among the many possible directions for future work is the search for more efficient approximation algorithms under various additional constraints on permissible overstretching trees, as well as the characterization of cases of the problem that could be efficiently solved; another possible direction is to allow an \"ungrammatic\" corpus as input, e.g. efficient search for partial solutions where several sentences remain unparsed or not completely parsed; another direction is to look for a solution for a directed graph analogous to the problem under consideration here, finding minimal arborescences and referring to the directed parsing of dependence; another question that remains open is an edge balancing scheme that would reflect syntactical considerations and specific language-related constraints, as in the so-called optimality theory [10]."}], "references": [{"title": "Three new probabilistic models for dependency parsing: An exploration", "author": ["J. Eisner"], "venue": "In Proceedings of the 16th International Conference on Computational Linguistics", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1996}, {"title": "A compendium on steiner tree problems", "author": ["M. Hauptmann", "M. Karpinski"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Foundations of Statistical Natural Language Processing", "author": ["C.D. Manning", "H. Sch\u00fctze"], "venue": "The MIT Press, Cambridge, Massachusetts", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1999}, {"title": "Parentheticals and discontinuous constituent structure", "author": ["J. McCawley"], "venue": "Linguistic Inquiry, 13:91\u2013106", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1982}, {"title": "Non-projective dependency parsing using spanning tree algorithms", "author": ["R. McDonald", "F. Pereira", "K. Ribarov", "J. Hajic"], "venue": "HLT/EMNLP", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2005}, {"title": "A linear precedence account of cross-serial dependencies", "author": ["A. Ojeda"], "venue": "Linguistics and Philosophy, 11:457\u2013 492", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1988}, {"title": "Taxemes and immediate constituents", "author": ["K. Pike"], "venue": "Language, 19:65\u201382", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1943}, {"title": "Free word order and phrase structure rules", "author": ["G. Pullum"], "venue": "Proceedings of NELS, volume 12", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1982}, {"title": "Parsing the CHILDES database: Methodology and lessons learned", "author": ["K. Sagae", "A. Lavie", "B. MacWhinney"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2001}, {"title": "Structures and Strings", "author": ["V. Savova"], "venue": "PhD thesis, Johns Hopkins University", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "Approximation Algorithms", "author": ["V. Vazirani"], "venue": "Springer", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2001}], "referenceMentions": [{"referenceID": 0, "context": "Some work is concerned with inducing parameters of the grammar from annotated corpora, for example see work by Eisner on dependency parsing [1] or more recent work by McDonald et al.", "startOffset": 140, "endOffset": 143}, {"referenceID": 4, "context": "[5] and references therein.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "It has been pointed out [5] that parsing with dependency grammars is related to Minimal Spanning Tree algorithms in general and in particular Chu-Liu-Edmonds MST algorithm was applied to dependency parsing.", "startOffset": 24, "endOffset": 27}, {"referenceID": 2, "context": "An established computational linguistics textbook has the following to say on the subject [3]: \u201d.", "startOffset": 90, "endOffset": 93}, {"referenceID": 6, "context": "Non-projective structures include wh-relative clauses [7], parentheticals [4], cross-serial constructions of the type found in Dutch and Swiss-German [6], as well as free or relaxed word order languages [8].", "startOffset": 54, "endOffset": 57}, {"referenceID": 3, "context": "Non-projective structures include wh-relative clauses [7], parentheticals [4], cross-serial constructions of the type found in Dutch and Swiss-German [6], as well as free or relaxed word order languages [8].", "startOffset": 74, "endOffset": 77}, {"referenceID": 5, "context": "Non-projective structures include wh-relative clauses [7], parentheticals [4], cross-serial constructions of the type found in Dutch and Swiss-German [6], as well as free or relaxed word order languages [8].", "startOffset": 150, "endOffset": 153}, {"referenceID": 7, "context": "Non-projective structures include wh-relative clauses [7], parentheticals [4], cross-serial constructions of the type found in Dutch and Swiss-German [6], as well as free or relaxed word order languages [8].", "startOffset": 203, "endOffset": 206}, {"referenceID": 1, "context": "Notice that the problem initially appears similar to the group Steiner problem [2], since the objective is to connect certain subsets of the nodes.", "startOffset": 79, "endOffset": 82}, {"referenceID": 8, "context": "We ran preliminary experiments with the approximation algorithm on adult child-directed speech from the CHILDES corpus [9].", "startOffset": 119, "endOffset": 122}, {"referenceID": 9, "context": "One other question which remains open is an edge weighing scheme which would reflect syntactic consideration and particular language-related constraints, as in the so-called Optimality Theory [10].", "startOffset": 192, "endOffset": 196}], "year": 2017, "abstractText": "This paper formulates a novel problem on graphs: find the minimal subset of edges in a fully connected graph, such that the resulting graph contains all spanning trees for a set of specified subgraphs. This formulation is motivated by an unsupervised grammar induction problem from computational linguistics. We present a reduction to some known problems and algorithms from graph theory, provide computational complexity results, and describe an approximation algorithm.", "creator": "TeX"}}}