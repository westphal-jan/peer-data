{"id": "1705.09970", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-May-2017", "title": "Probabilistic Program Abstractions", "abstract": "Abstraction is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of pro- gram abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstraction, which is more tractable. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices made by traditional program abstractions. We upgrade key theoretical program abstraction insights to the probabilistic context. Probabilistic program abstractions provide avenues for utilizing abstraction techniques from the programming languages community to improve the analysis of probabilistic programs.", "histories": [["v1", "Sun, 28 May 2017 17:53:01 GMT  (24kb)", "https://arxiv.org/abs/1705.09970v1", null], ["v2", "Fri, 14 Jul 2017 15:46:25 GMT  (26kb)", "http://arxiv.org/abs/1705.09970v2", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["steven holtzen", "todd millstein", "guy van den broeck"], "accepted": false, "id": "1705.09970"}, "pdf": {"name": "1705.09970.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["sholtzen@cs.ucla.edu", "todd@cs.ucla.edu", "guyvdb@cs.ucla.edu"], "sections": [{"heading": null, "text": "ar Xiv: 170 5.09 970v 2 [cs.A I] 1 4Ju l 2Abstraction is a basic tool for thinking about complex systems. Program abstraction has been used with great success to analyze deterministic programs. At the core of program abstraction is the relationship between a concrete program that is difficult to analyze and an abstract program that is easier to understand. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying non-deterministic decisions. Our framework evaluates key definitions and properties of abstractions in the probabilistic context. We also discuss preliminary ideas for performing conclusions on probabilistic abstractions and general probabilistic programs."}, {"heading": "1 INTRODUCTION & MOTIVATION", "text": "Abstraction is typically an approximation of a program: every execution that is possible in the original program is contained within the abstraction. Abstraction allows abstractions to prove program variants: every property of all executions in the abstraction also applies to all executions in the original program. To achieve this goal, while being more tractable than the concrete program, abstractions work in a simplified field. Abstraction selectively models certain aspects of the original program, while using non-determinism to model the remainders conservatively. Non-deterministic abstractions are useful to verify properties such as accessibility in a concrete program. However, abstractions are clearly not probabilistic: they deal with the possible, not the probable."}, {"heading": "2 NON-DETERMINISTIC PROGRAM ABSTRACTION", "text": "In this section, we present the semantics and properties of excessive non-deterministic abstraction and provide an example of a certain class of approximations known as predicate abstractions."}, {"heading": "2.1 SEMANTICS AND PROPERTIES", "text": "A concrete program is a syntactic object written C. The semantics of a concrete program, which represents a concrete function DC for simplicity, is a function of input states to output states via a concrete domain DC. Concrete states are total mappings to all variables in the concrete domain, which we call a concrete function. In general, the problem of proving that a particular program fulfills a desired invariant is not decidable. Advances in theoretical proof techniques such as Satisfiability Modulo Theory (SMT) solvers (e.g. De Moura and Bj\u00f8rner (2008))) of rendering reasoning are understandable in many useful theories, but there are common program structures that lie outside supported theories. The framework of abstract interpretation (Cousot and Cousot, 1977) provides a general technique to relate a concrete program C to another program that we call an abstraction."}, {"heading": "2.2 PREDICATE ABSTRACTION", "text": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf und Sa\u00efdi, 1997; Ball et al., 2001). Predicate abstractions are known as Boolean programs: the domain DA = {T, F} n. Security checking in Boolean programs is decidable: a Boolean program has a finite number of states with a fixed number of Boolean variables, making it possible to determine the amount of achievable states. In a concrete program C and a set of n predicates (p1,.., pn) over the concrete domain DC, the goal of the predicate abstraction process is to construct an abstract Boolean program that forms a solid approximation of C and is as precise as possible relative to the given predicates (plt.x)."}, {"heading": "2.2.1 Abstracting Branches", "text": "Let us consider a conditional statement of the form (p) {\u00b7 \u00b7} else {\u00b7 \u00b7} in the concrete program. Let us designate pT the strongest sentence formula about the predicates p1,.., pn which is implicated by p, and pF the strongest sentence formula about the predicates p1,.., pn which is implied by! p. These formulas represent the most precise information we can know within the then or the other branches, since the predicates are given in the abstraction. They can be obtained by queries to an SMT solver, provided that p and the n predicates are all contained in decidable logical theories; see Ball et al. (2001) for details. The predicate abstraction process translates the above condition as follows in the Boolean program: if (*) {p T (T}) {s assume ({p F}); otherwise {F}}}} {s {s {s is} {and} {ltat the same time} < < < < < < but in each {and < T;"}, {"heading": "2.2.2 Abstracting Assignment Statements", "text": "Consider an assignment statement of the form x = e in the concrete program. < If we want to update the {pi} variable, we must simultaneously update the values of all Boolean variables to update to the value of x. Suppose we want to update the variable {pi}. Let pTi specify the weakest statement formula about predicates p1,.., pn so that pFi is sufficient before assignment x = e to ensure that pi will be true after assignment. < Let pFi specify the weakest statement formula about predicates p1,. < pn so that pFi is sufficient before assignment x = e to ensure that pi will be wrong after assignment. < Again, an SMT solver can be used to obtain these formulas the default of the weakest precondition of an assignment in relation to a predicate (Dijstra)."}, {"heading": "2.2.3 Proving Program Invariants", "text": "A predicate abstraction is a solid approximation of the original concrete program. Since a Boolean program has a finite set of possible states at each point in the program, it can be comprehensively examined by a form of model verification that the program performs conceptually in all possible ways (Ball and Rajamani, 2000). Model verification generates the set of achievable states at each point in the program, and this information can be used to verify invariants of the original program. Consider the Boolean program in Figure 3. All versions of this program end in a state in which the Boolean variable {x < -4} has the value F. This implies that x always ends in a value greater than or equal to -4 in the original program in Figure 2. On the other hand, our predicate abstraction is not precise enough to verify that x always ends in a non-negative value, although this is true for the original predictive program. A different predicate selection would allow such an argument to be made."}, {"heading": "3 PROBABILISTIC PROGRAM ABSTRACTION", "text": "The primary contribution of this paper is the extension of the non-deterministic program abstractions of the previous section to the probabilistic context. We begin with the definition of a simple probabilistic programming language. Syntactically, our probabilistic predicate abstractions will simply be probabilistic programs in that language. Next, we generalize the abstraction semantics from Section 2.1 to the probabilistic context and define solidity criteria for probabilistic program abstractions. Finally, we generalize the predicate abstraction process from Section 2.2 to the probabilistic context by placing distributions on the non-deterministic decisions."}, {"heading": "3.1 PROBABILISTIC PROGRAMMING", "text": "We define a simple probabilistic programming language, BERN, which contains only (1) Boolean variables; (2) Boolean operators; (3) Boolean assignments; (4) if statements; (5) a flip (\u03b8) operator, which is a Bernoulli random variable with parameters \u03b8; and (6) an observation statement that ignores statements that do not meet a condition. Note that observation statements can also be captured by a conditional probability query on the distribution side (Ball et al., 2001). An extension of BERN is the introduction of a goto construct that would allow it to think about underlying concrete programs with any control flow. The predicate abstraction framework makes thinking about loopy-specific programs comprehensible (Ball et al., 2001); however, we postpone the generalization of the semantics of loopy-probabilistic abstractions to future work."}, {"heading": "3.2 PROBABILISTIC SEMANTICS", "text": "We generalize this non-deterministic semantics to probabilistic semantics by creating families of compatible probability distributions described by limitations on their support. Since syntactically abstractions will be strongly probabilistic programs, the abstract semantics of probabilistic semantics is simply the semantics of this program, broadly defined. Abstract semantics. The abstract semantics of a probabilistic semantics of a probabilistic abstraction is simply the semantics of this program, which describes a conditional probability distribution over abstract domain DA that defines the probability of transitioning from an initial set of states into an output state. To define the concrete semantics of a probabilistic abstraction, we must first define the function of probabilization to the probabilistic context."}, {"heading": "3.2.1 Non-Deterministic Semantics", "text": "A solid probabilistic overapproximation is a generalization of a solid non-deterministic overapproximation, which we specify in the following definitions: Definition 3.6. Non-deterministic semantics. Let A be a probabilistic program abstraction with compatible concretization distribution Pr\u03b3 and abstraction function \u03b1. Then there is a corresponding non-deterministic concretization function \u03b3 (a) \u2193 = {z (z | a) > 0)} and an abstract non-deterministic program A (a) \u2193 = {a \u2032 | PrA (a) > 0)}. We find that \u03b3 (a) a concretization function is compatible with \u03b1 (z | a) > definition. Furthermore, the solidity of a probabilistic program is implicit if it is (a) > 0)} unsound."}, {"heading": "3.2.2 Concretization Invariance", "text": "The concrete semantics Pr [[A]] is necessary in order to think about the concrete domain. However, the direct analysis of Pr [[A]] is complicated by the need to select some compatible concretization distributions Pr\u03b3. Significantly, A alone provides a sufficient structure to calculate a probability in Pr [[A] independent of the choice of Pr\u03b3: Theorem 3.2. invariance of the concretization distributions. Let A be a probabilistic program abstraction with strongly compatible concretization distributions Pr\u03b3 and abstraction functions \u03b1. In other words, the probability of an abstract event occurring in the concrete sequence is equivalent to the probability that a distributive (ao | zi) = PrA (ao | zi) = PrA (z)."}, {"heading": "3.3 PROBABILISTIC PREDICATE ABSTRACTIONS", "text": "So far we have seen semantics for probabilistic program abstraction, but we do not yet have a way to generate one for a particular program. In this section we will try to generalize predicate abstraction to the probabilistic domain and show that probabilistic predicate abstraction is generally a family of Boolean probabilistic programs with Bernoulli flip parameters."}, {"heading": "3.3.1 Branch Statements", "text": "We saw in Section 2.2.1 that a predicate abstraction of an if statement from the Formif (*) {conjecture (\u03b1)....}, where \u03b1 and \u03b2 represent the most accurate information we can know about the state of predicates in the then and other branches of the program, is not deterministic in the case where both \u03b1 and \u03b2 are valid. A probabilistic predicate abstraction of this statement should explicitly quantify the probability of choosing a particular path if both paths in the abstraction are possible by first rewriting the if statement of the predicate abstraction equivalent to: if (\u00ac \u03b2) & < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < <"}, {"heading": "3.3.2 Assignment Statements", "text": "Section 2.2.2 showed that a concrete assignment to a series of predicate assignments of the form \u03b3 = select (\u03b1, \u03b2) is abstracted, where \u03b3 is a predicate and \u03b1 and \u03b2 encode the most precise update we can make to \u03b3. Abstraction does not behave deterministically: it can be either true or false if neither \u03b1 nor \u03b2 applies. Therefore, the probable generalization of an assignment statement must represent the conditional probability of what is given to us. First, we rewrite the selection statement and introduce a non-deterministic * operator similar to the previous paragraph. We can write an equivalent update to \u03b3: 2Hint that by constructing \u03b1 and \u03b2 both cannot be wrong."}, {"heading": "3.4 INVARIANTS", "text": "In the non-deterministic case, enforcing invariants with predicates is a lightweight process of inserting assumptions to increase the precision of abstraction. Similarly, in the probabilistic case, we want to represent distributions of predicates while prohibiting inconsistent predicate states. In this section, we will examine the consequences of enforcing invariants on abstraction. An initial approach to enforcing invariants is simply to generalize the non-deterministic procedure by inserting observing (I) statements between each allocation, being the invariant that must hold above the predicates. For example, for the concrete program x + 10 with predicates {x < -4} and {x < 3} we generate the following abstraction: {x < -4} that is not obtainable."}, {"heading": "4 DISCUSSION", "text": "This paper focuses on the definition and key properties of probabilistic program abstractions. In this section we will discuss the next natural steps. Traditional non-deterministic program abstractions are typically used to generate the set of achievable program states to verify invariants. Analogous operation of probabilistic program abstraction is inference. First, we will discuss possible approaches to inference for probabilistic predicate abstractions by using both model verification and weighted model counting. Second, we will discuss how the ability to draw conclusions from a probabilistic abstraction could be a key factor in a new approach to performing inferences on more general probabilistic programs. The main idea is to reduce conclusions about a probabilistic program to the task of selecting specific flip probabilities for a corresponding probabilistic abstraction."}, {"heading": "4.1 INFERENCE FOR PROBABILISTIC PREDICATE ABSTRACTIONS", "text": "We believe that existing techniques from the literature of programming languages that are designed to work with non-deterministic Boolean programs can be expanded to perform conclusions about BERN programs. We can then use weighted model counting to evaluate queries. We note that abstractions allow us to question the marginal probability of an event at any point in the program, not just after program completion. Probabilistic model verification The problem of calculating the amount of achievable states in a Boolean program is known as a model verification problem and has been extensively investigated by the programming language community. Usually, the amount of achievable states at any point in the program is presented as some Boolean knowledge base. In many existing tools, this model is presented using a binary decision diagram (Ball and Rajamani, 2000). Consequences in BERN are therefore an extension of the traditional paradigm verification model, in which we treat weighted variables for each flip; during the flip-in-flip mode."}, {"heading": "4.2 INFERENCE FOR GENERAL PROBABILISTIC PROGRAMS", "text": "Consider the probability program in Figure 5a and assume that we want to evaluate Pr [[[C]] (c < 5). We outline an approach to this using probability predicates abstractions.Figure 5b shows a probability predicate abstraction for our original probability program, triggered by predicates {a < 5}, {b < 5} and {c < 5}. First, each flip has its own parameter to represent its probability. In the figure, we show certain values for each parameter calculated by performing fragments of the original concrete program. For example, the concrete assignment a = unif [0, 10) is abstracted to {a < 5} = abstractability (1 / 2) by calculating Pr (a < 5)."}, {"heading": "5 RELATED WORK", "text": "Probabilistic Thinking and Static Analysis. Several recent works use a probabilistic model to guide refinements of a program abstraction (Grigore and Yang, 2016; Zhang et al., 2017). However, the abstractions themselves are not probabilistic. Gehr et al. (2016) use static analyses of a probabilistic program to dissect the problem of inference along paths that are then sent to specialized integration tools depending on the limitations of each path; this work analyzes the original concrete program and does not rely on abstractions. Probabilistic abstract interpretation is used to argue about programs with probabilistic semantics, for example, to set upper limits on the probability of a particular path (Monniaux, 2000) or to construct abstract Monte Carlo methods (Monniaux, 2001); this line of work does not examine the links between abstractions and probabilistic programs, nor does it model concrete marginalizations."}, {"heading": "6 CONCLUSION", "text": "Probabilistic program abstractions are currently unexplored terrain for program analysis, despite the popularity of probabilistic programming. We provided a formal framework, derived useful properties, and described probabilistic predicate abstraction techniques. Much theoretical and practical work remains to be done to explore alternative characterizations, demonstrate connections between concrete programs and their abstractions, and develop practical probabilistic abstraction tools. We hope that our framework provides the basic theory to enable this progress in the future."}, {"heading": "Acknowledgements", "text": "This work is partially supported by NSF grants # CCF1527923, # IIS-1657613 and # IIS-1633857 as well as DARPA grants # N66001-17-2-4032."}], "references": [{"title": "Bebop: A symbolic model checker for boolean programs", "author": ["T. Ball", "S.K. Rajamani"], "venue": "In SPIN Model Checking and Software Verification,", "citeRegEx": "Ball and Rajamani.,? \\Q2000\\E", "shortCiteRegEx": "Ball and Rajamani.", "year": 2000}, {"title": "The SLAM project: Debugging system software via static analysis", "author": ["T. Ball", "S.K. Rajamani"], "venue": "In Proc. of POPL,", "citeRegEx": "Ball and Rajamani.,? \\Q2002\\E", "shortCiteRegEx": "Ball and Rajamani.", "year": 2002}, {"title": "Automatic predicate abstraction of c programs", "author": ["T. Ball", "R. Majumdar", "T. Millstein", "S.K. Rajamani"], "venue": "In Proc. of PLDI,", "citeRegEx": "Ball et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Ball et al\\.", "year": 2001}, {"title": "Probabilistic inference in hybrid domains by weighted model integration", "author": ["V. Belle", "A. Passerini", "G. Van den Broeck"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Belle et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Belle et al\\.", "year": 2015}, {"title": "Hashingbased approximate probabilistic inference in hybrid domains", "author": ["V. Belle", "G. Van den Broeck", "A. Passerini"], "venue": "In Proc. of UAI,", "citeRegEx": "Belle et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Belle et al\\.", "year": 2015}, {"title": "Stan: A probabilistic programming language", "author": ["B. Carpenter", "A. Gelman", "M. Hoffman", "D. Lee", "B. Goodrich", "M. Betancourt", "M.A. Brubaker", "P. Li", "A. Riddell"], "venue": "J. Statistical Software,", "citeRegEx": "Carpenter et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Carpenter et al\\.", "year": 2016}, {"title": "A scalable approximatemodel counter", "author": ["S. Chakraborty", "K.S. Meel", "M.Y. Vardi"], "venue": "In Proc. of CP,", "citeRegEx": "Chakraborty et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Chakraborty et al\\.", "year": 2013}, {"title": "On probabilistic inference by weighted model counting", "author": ["M. Chavira", "A. Darwiche"], "venue": "J. Artificial Intelligence,", "citeRegEx": "Chavira and Darwiche.,? \\Q2008\\E", "shortCiteRegEx": "Chavira and Darwiche.", "year": 2008}, {"title": "Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints", "author": ["P. Cousot", "R. Cousot"], "venue": "In Proc. of POPL,", "citeRegEx": "Cousot and Cousot.,? \\Q1977\\E", "shortCiteRegEx": "Cousot and Cousot.", "year": 1977}, {"title": "Probabilistic abstract interpretation", "author": ["P. Cousot", "M. Monerau"], "venue": "In Proc. of ESOP,", "citeRegEx": "Cousot and Monerau.,? \\Q2012\\E", "shortCiteRegEx": "Cousot and Monerau.", "year": 2012}, {"title": "A Knowledge Compilation Map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Proc. of IJCAI,", "citeRegEx": "Darwiche and Marquis.,? \\Q2001\\E", "shortCiteRegEx": "Darwiche and Marquis.", "year": 2001}, {"title": "An efficient smt solver", "author": ["L. De Moura", "N. Bj\u00f8rner. Z"], "venue": "In Proc. of TACAS/ETAPS,", "citeRegEx": "Moura and Z3,? \\Q2008\\E", "shortCiteRegEx": "Moura and Z3", "year": 2008}, {"title": "A Discipline of Programming", "author": ["E.W. Dijkstra"], "venue": "PrenticeHall, Englewood Cliffs, New Jersey,", "citeRegEx": "Dijkstra.,? \\Q1976\\E", "shortCiteRegEx": "Dijkstra.", "year": 1976}, {"title": "Psi: Exact symbolic inference for probabilistic programs", "author": ["T. Gehr", "S. Misailovic", "M. Vechev"], "venue": "Proc. of ESOP/ETAPS,", "citeRegEx": "Gehr et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Gehr et al\\.", "year": 2016}, {"title": "Model counting", "author": ["C.P. Gomes", "A. Sabharwal", "B. Selman"], "venue": "Handbook of Satisfiability,", "citeRegEx": "Gomes et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 2009}, {"title": "A language for generative models", "author": ["N.D. Goodman", "V.K. Mansinghka", "D.M. Roy", "K. Bonawitz", "J.B. Tenenbaum. Church"], "venue": "In Proc. of UAI,", "citeRegEx": "Goodman et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Goodman et al\\.", "year": 2008}, {"title": "Construction of abstract state graphs with PVS", "author": ["S. Graf", "H. Sa\u00efdi"], "venue": "In Proc. of CAV,", "citeRegEx": "Graf and Sa\u00efdi.,? \\Q1997\\E", "shortCiteRegEx": "Graf and Sa\u00efdi.", "year": 1997}, {"title": "Abstraction Refinement Guided by a Learnt ProbabilisticModel", "author": ["R. Grigore", "H. Yang"], "venue": "Proc. of POPL,", "citeRegEx": "Grigore and Yang.,? \\Q2016\\E", "shortCiteRegEx": "Grigore and Yang.", "year": 2016}, {"title": "Lifted probabilistic inference", "author": ["K. Kersting"], "venue": "In Proc. of ECAI, pages 33\u201338,", "citeRegEx": "Kersting.,? \\Q2012\\E", "shortCiteRegEx": "Kersting.", "year": 2012}, {"title": "Approximate probabilistic inference with bounded error for hybrid probabilistic logic programming", "author": ["S. Michels", "A. Hommersom", "P.J.F. Lucas"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Michels et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Michels et al\\.", "year": 2016}, {"title": "Blog: Probabilistic models with unknown objects", "author": ["B. Milch", "B. Marthi", "S. Russell", "D. Sontag", "D.L. Ong", "A. Kolobov"], "venue": "In Proc. of IJCAI,", "citeRegEx": "Milch et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Milch et al\\.", "year": 2005}, {"title": "Abstract interpretation of probabilistic semantics", "author": ["D. Monniaux"], "venue": "In International Symposium on Static Analysis,", "citeRegEx": "Monniaux.,? \\Q2000\\E", "shortCiteRegEx": "Monniaux.", "year": 2000}, {"title": "An abstract monte-carlo method for the analysis of probabilistic programs", "author": ["D. Monniaux"], "venue": "SIGPLAN Not.,", "citeRegEx": "Monniaux.,? \\Q2001\\E", "shortCiteRegEx": "Monniaux.", "year": 2001}, {"title": "The complexity of computing the permanent", "author": ["L.G. Valiant"], "venue": "J. Theoretical Computer Science,", "citeRegEx": "Valiant.,? \\Q1979\\E", "shortCiteRegEx": "Valiant.", "year": 1979}, {"title": "A new approach to probabilistic programming inference", "author": ["F. Wood", "J.W. van de Meent", "V. Mansinghka"], "venue": "In Proc. of AISTATS,", "citeRegEx": "Wood et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Wood et al\\.", "year": 2014}, {"title": "Closing the gap between short and long xors for model counting", "author": ["S. Zhao", "S. Chaturapruek", "A. Sabharwal", "S. Ermon"], "venue": "In Proc. of AAAI,", "citeRegEx": "Zhao et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zhao et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 8, "context": "Program abstractions are a richly studied method from the programming languages community for reasoning about intractably complex programs (Cousot and Cousot, 1977).", "startOffset": 139, "endOffset": 164}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al.", "startOffset": 2, "endOffset": 24}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al. (2013); Wood et al.", "startOffset": 2, "endOffset": 47}, {"referenceID": 14, "context": ", Goodman et al. (2008); Fierens et al. (2013); Wood et al. (2014); Carpenter et al.", "startOffset": 2, "endOffset": 67}, {"referenceID": 5, "context": "(2014); Carpenter et al. (2016)).", "startOffset": 8, "endOffset": 32}, {"referenceID": 16, "context": "A well-known construction of non-deterministic program abstractions is that of a predicate abstraction (Graf and Sa\u00efdi, 1997; Ball et al., 2001).", "startOffset": 103, "endOffset": 144}, {"referenceID": 2, "context": "A well-known construction of non-deterministic program abstractions is that of a predicate abstraction (Graf and Sa\u00efdi, 1997; Ball et al., 2001).", "startOffset": 103, "endOffset": 144}, {"referenceID": 8, "context": "The framework of abstract interpretation (Cousot and Cousot, 1977) provides a general technique for relating a concrete program C to another program A which we refer to as an abstraction.", "startOffset": 41, "endOffset": 66}, {"referenceID": 16, "context": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf and Sa\u00efdi, 1997; Ball et al., 2001) (see the previous section for the definition of a predicate domain).", "startOffset": 106, "endOffset": 147}, {"referenceID": 2, "context": "A predicate abstraction is a well-studied program abstraction whose abstract domain is a predicate domain (Graf and Sa\u00efdi, 1997; Ball et al., 2001) (see the previous section for the definition of a predicate domain).", "startOffset": 106, "endOffset": 147}, {"referenceID": 2, "context": "Following the notation of Ball et al. (2001), the * operator represents nondeterministic choice, and the Boolean variable associated with predicate p is denoted {p}.", "startOffset": 26, "endOffset": 45}, {"referenceID": 2, "context": "They can be obtained through queries to an SMT solver, assuming that p and the n predicates are all in decidable logical theories; see Ball et al. (2001) for details.", "startOffset": 135, "endOffset": 154}, {"referenceID": 12, "context": "Again an SMT solver can be used to obtain these formulas, leveraging the standard notion of the weakest precondition of an assignment statement with respect to a predicate (Dijkstra, 1976).", "startOffset": 172, "endOffset": 188}, {"referenceID": 0, "context": "Further, because a Boolean program has a finite set of possible states at each point in the program, it can be exhaustively explored via a form of model checking, which conceptually executes the program in all possible ways (Ball and Rajamani, 2000).", "startOffset": 224, "endOffset": 249}, {"referenceID": 0, "context": ", Ball and Rajamani (2002)).", "startOffset": 2, "endOffset": 27}, {"referenceID": 2, "context": "The predicate abstraction framework makes reasoning about loopy concrete programs tractable (Ball et al., 2001); however, we defer generalizing the semantics of loopy probabilistic predicate abstractions to future work.", "startOffset": 92, "endOffset": 111}, {"referenceID": 5, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 15, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 24, "context": "As such, infrastructure for computing queries on probabilistic programs has begun to develop in the AI and programming languages communities (Carpenter et al., 2016; Goodman et al., 2008; Wood et al., 2014; Fierens et al., 2013).", "startOffset": 141, "endOffset": 228}, {"referenceID": 0, "context": "In many existing tools, \u2206 is represented using a binary decision diagram (Ball and Rajamani, 2000).", "startOffset": 73, "endOffset": 98}, {"referenceID": 0, "context": "See Ball and Rajamani (2000) for more details.", "startOffset": 4, "endOffset": 29}, {"referenceID": 0, "context": "The programming languages community has two primary methodologies for computing the set of reachable states in a Boolean program: (1) knowledge compilation to binary decision diagrams (Ball and Rajamani, 2000), and (2) satisfiability methods (Donaldson et al.", "startOffset": 184, "endOffset": 209}, {"referenceID": 10, "context": "The knowledge compilation approach to model checking is already capable of performing weighted model counting due to the nature of the queries efficiently supported by a binary decision diagram (Darwiche and Marquis, 2001), and is used for inference in discrete probabilistic programs (Fierens et al.", "startOffset": 194, "endOffset": 222}, {"referenceID": 7, "context": ", 2013) and Bayesian networks (Chavira and Darwiche, 2008).", "startOffset": 30, "endOffset": 58}, {"referenceID": 23, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al.", "startOffset": 24, "endOffset": 39}, {"referenceID": 6, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al., 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al.", "startOffset": 105, "endOffset": 171}, {"referenceID": 25, "context": "This problem is #P-hard (Valiant, 1979), but a number of recent approximation methods have been explored (Chakraborty et al., 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al.", "startOffset": 105, "endOffset": 171}, {"referenceID": 3, "context": ", 2013; Belle et al., 2015b; Zhao et al., 2016); see Gomes et al. (2009) for a survey of the subject.", "startOffset": 8, "endOffset": 73}, {"referenceID": 17, "context": "Several recent works leverage a probabilistic model to guide refinements of a program abstraction (Grigore and Yang, 2016; Zhang et al., 2017).", "startOffset": 98, "endOffset": 142}, {"referenceID": 13, "context": "Gehr et al. (2016) use static analysis of a probabilistic program to decompose the problem of inference along paths, which are then dispatched to specialized integration tools depending on the constraints of each path; this work analyzes the original concrete program and does not rely on abstractions.", "startOffset": 0, "endOffset": 19}, {"referenceID": 21, "context": "Probabilistic abstract interpretation is used to reason about programs with probabilistic semantics, for example to place upper bounds on the probability of a particular path (Monniaux, 2000) or construct Monte-Carlo methods (Monniaux, 2001); this line of work does not explore the connections between abstractions and probabilistic programs, nor does it model concrete programmarginals.", "startOffset": 175, "endOffset": 191}, {"referenceID": 22, "context": "Probabilistic abstract interpretation is used to reason about programs with probabilistic semantics, for example to place upper bounds on the probability of a particular path (Monniaux, 2000) or construct Monte-Carlo methods (Monniaux, 2001); this line of work does not explore the connections between abstractions and probabilistic programs, nor does it model concrete programmarginals.", "startOffset": 225, "endOffset": 241}, {"referenceID": 9, "context": "The framework of Cousot and Monerau (2012) is a highly general framework for reasoning about programs using probabilistic abstract interpretation; however, they do not consider the abstraction itself to be a statistical model.", "startOffset": 17, "endOffset": 43}, {"referenceID": 15, "context": "Systems such as Church (Goodman et al., 2008), Anglican (Wood et al.", "startOffset": 23, "endOffset": 45}, {"referenceID": 24, "context": ", 2008), Anglican (Wood et al., 2014), Stan (Carpenter et al.", "startOffset": 18, "endOffset": 37}, {"referenceID": 5, "context": ", 2014), Stan (Carpenter et al., 2016), BLOG (Milch et al.", "startOffset": 14, "endOffset": 38}, {"referenceID": 20, "context": ", 2016), BLOG (Milch et al., 2005), and others directly analyze the concrete program.", "startOffset": 14, "endOffset": 34}, {"referenceID": 19, "context": "Several probabilistic inference approaches capture distributions in continuous domains by using Boolean predicates, either as an approximation (Michels et al., 2016) or as an exact representation (Belle et al.", "startOffset": 143, "endOffset": 165}, {"referenceID": 18, "context": "Finally, program abstraction with the purpose of inference is an instance of approximate lifted inference (Kersting, 2012): the abstract domain groups together sets of concrete states, with the aim of reasoning at the higher level.", "startOffset": 106, "endOffset": 122}], "year": 2017, "abstractText": "Abstraction is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of program abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstract program, which is more tractable. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices. Our framework upgrades key definitions and properties of abstractions to the probabilistic context. We also discuss preliminary ideas for performing inference on probabilistic abstractions and general probabilistic programs.ion is a fundamental tool for reasoning about complex systems. Program abstraction has been utilized to great effect for analyzing deterministic programs. At the heart of program abstraction is the relationship between a concrete program, which is difficult to analyze, and an abstract program, which is more tractable. Program abstractions, however, are typically not probabilistic. We generalize non-deterministic program abstractions to probabilistic program abstractions by explicitly quantifying the non-deterministic choices. Our framework upgrades key definitions and properties of abstractions to the probabilistic context. We also discuss preliminary ideas for performing inference on probabilistic abstractions and general probabilistic programs.", "creator": "LaTeX with hyperref package"}}}