{"id": "1705.10639", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-May-2017", "title": "Grammatical Inference as a Satisfiability Modulo Theories Problem", "abstract": "The problem of learning a minimal consistent model from a set of labeled sequences of symbols is addressed from a satisfiability modulo theories perspective. We present two encodings for deterministic finite automata and extend one of these for Moore and Mealy machines. Our experimental results show that these encodings improve upon the state-of-the-art, and are useful in practice for learning small models.", "histories": [["v1", "Tue, 30 May 2017 13:48:15 GMT  (14kb)", "http://arxiv.org/abs/1705.10639v1", "Submitted and selected for oral presentation at the LearnAut workshop at LICS 2017"]], "COMMENTS": "Submitted and selected for oral presentation at the LearnAut workshop at LICS 2017", "reviews": [], "SUBJECTS": "cs.FL cs.LG cs.LO", "authors": ["rick smetsers"], "accepted": false, "id": "1705.10639"}, "pdf": {"name": "1705.10639.pdf", "metadata": {"source": "CRF", "title": "Grammatical Inference as a Satisfiability Modulo Theories Problem", "authors": ["Rick Smetsers"], "emails": ["r.smetsers@cs.ru.nl"], "sections": [{"heading": null, "text": "It is indeed the case that we are able to correct the errors that have been mentioned, and that we are able to correct them in order to correct them."}, {"heading": "II. SATISFIABILITY MODULO THEORIES", "text": "Let us first remember some basic terms for predictive logic, if at least it is wrong. In our presentation, we borrow notational conventions [5]. Let us be a set of Boolean variables. (Let us be a set of Boolean variables.) (Let us be a set of Boolean variables. (Let us be a set of Boolean variables.) (Let us be a set of Boolean variables.) (Let us be a formula that is either true or false.) The negation of a formula C is a conjunction of the negations of its literals. (Let us be a formula that is a formula.) A formula F is a conjunction of clauses C1. (Partial) Mapping M is a (partial) mapping of the variables to true or false. (Partial) mapping of the variables to true or false. (Partial) mapping can be seen as a conjunction of literals, and hence as a formulation.A clause C is true in an mapping M is true if it is wrong. (Partial) mapping the variables to true or false."}, {"heading": "III. GRAMMATICAL INFERENCE AS A SMT PROBLEM", "text": "One of the best-studied problems in q = FA is the search for a minimal-size deterministic finite automaton (DFA) that accepts a certain set of positive examples and rejects a given set of negative examples of an unknown regular language. A DFA is a finite state machine that accepts and rejects strings that are sequences of symbols. Formally, we define it as a tuple (\u03a3, Q, q0, \u03b4, \u03bb) that is a finite alphabet of symbols, Q is a finite series of states, q0 is the initial state, Q0 is the initial state: Q \u00b7 \u03a3 \u2192 Q is a transitional function for states and symbols, \u03bb: Q \u2192 B is an output function that applies when a state is accepted, and false when it is rejected. If we leave x to be a string, we use xi to mark the symbol at the position of x."}, {"heading": "A. A natural encoding", "text": "This leads us to a natural encoding of the above-mentioned problem of satisfying modulo theories of inequality and uninterpreted functions. Let us consider the set of states of D as a series of non-negative integers. Then the following axioms assert that D has at most n states:...., n \u2212 1}, a), a), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c)), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c), c)), c), c)), c)), c)), c)), c)), c)), c))), c)), c))), c))), c)))), c))), c)))), c))))), c)))), c))))), c))))), c))))))), c))), c)))))))))))), (c), (c))), ())), ()))), ())), ())), ()), ()), ()))), ()), (), ()), (), (), ())), (), (), (), (), ()), (), (), (), ()), (), (), (), (), (), (), (), ()), (), (), (), (), (), (), (), (), (), (), ()), (), (), (), (), (), (), (), (), (),),"}, {"heading": "B. A more expressive encoding", "text": "One solution is to define the constraints implied by strings in a non-nested manner Q = Q \u00b7. Similar to Heule and Verwer [3] and Bruynooghe et. al. [4], we use an extended prefix tree (APT) for this. However, we introduce a more precise set of constraints. An APT A can be considered a partial, tree-shaped DFA that is exactly in line with S, i.e. it only accepts the sentence S + and rejects only the sentence S \u2212. For each state q of A, there is exactly one string ending in q. Therefore, we denounce the unique state that a string x ends in qx. This implies that two strings accept x and only the same state if they share a prefix, i.e. x [1, i] = y [1], i] for some countries where there is a solution."}, {"heading": "C. An extension for Moore and Mealy machines", "text": "One advantage of the encoding presented in Section III-B (as opposed to the encoding presented in Section III-A) is that it can be easily expanded to learn Moore and Mealy machines. In this section, we present such encoding. A Moore machine is a converter that produces an output symbol in any state, and: Formally, it is a tuple (\u03a3, Q, q0, Moore) in which an output mark, Q, q0, and \u03b4 are the same as for a DFA, as well as a finite alphabet of output symbols, and \u03bb: Q \u2192 is an output function. A Moore machine produces an output symbol every time it (re-) enters a state. Therefore, a sample S for a Moore machine consists of tracks (x, y) that are pairs (x, y). x | x | x is a machine that produces Q1."}, {"heading": "IV. EXPERIMENTAL RESULTS", "text": "We have implemented our encodings using the Python frontend of Z3 [9], and we have conducted some initial experiments that evaluate the scalability of the various encodings and their applicability in practice. In our first set of experiments, we name the runtimes of the following encodings: \u2022 Howl and Verwer's propositional encoding without re-dundant constraints [3, Table 1] (HV-1), \u2022 Howl and Verwers propositional encoding with reducing constraints [3, Table 1] (HV-2), \u2022 Section III-A with equation 1 (III-A-1), \u2022 Section III-A with equation 2 (III-A-2), \u2022 Section III-B with equation 7), and \u2022 Section III-B with equation 7 (III-B-8)."}, {"heading": "V. CONCLUSIONS AND FUTURE WORK", "text": "Our experimental results show that these encodings improve the state of the art and are useful in practice. However, the time it takes to learn a model is growing rapidly in its number of states. In the future, we would like to address this problem and extend this work by: 1) defining a counter-example driven algorithm that mentally refines a minimally consistent model, 2) combining our approach with existing learning algorithms, and 3) expanding the encoding for richer model formalisms, such as register machines. 2See http: / / automata.cs.ru.nl / BenchmarkBankcard."}, {"heading": "ACKNOWLEDGMENTS", "text": "This work is supported by the Dutch project 628.001.009 of the Organisation for Scientific Research (NWO) on Learning Extended State Machine for Malware Analysis (LEMMA)."}], "references": [{"title": "Language identification in the limit", "author": ["E.M. Gold"], "venue": "Information and Control, vol. 10, no. 5, pp. 447\u2013474, 1967. [Online]. Available: http://dx.doi.org/10.1016/S0019-9958(67)91165-5", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1967}, {"title": "Regular inference as a graph coloring problem", "author": ["F. Coste", "J. Nicolas"], "venue": "Proc. ICML, 1997.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1997}, {"title": "Software model synthesis using satisfiability solvers", "author": ["M.J.H. Heule", "S. Verwer"], "venue": "Empirical Software Engineering, vol. 18, no. 4, pp. 825\u2013856, 2013. [Online]. Available: http://dx.doi.org/10.1007/s10664-012-9222-z", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2013}, {"title": "Predicate logic as a modeling language: modeling and solving some machine learning and data mining problems with idp3", "author": ["M. Bruynooghe", "H. Blockeel", "B. Bogaerts", "B. De Cat", "S. De Pooter", "J. Jansen", "A. Labarre", "J. Ramon", "M. Denecker", "S. Verwer"], "venue": "Theory and Practice of Logic Programming, vol. 15, no. 6, p. 783817, 2015.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis\u2013Putnam\u2013Logemann\u2013Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "J. ACM, vol. 53, no. 6, pp. 937\u2013977, Nov. 2006. [Online]. Available: http://dx.doi.org/10.1145/1217856.1217859", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2006}, {"title": "Equality logic and uninterpreted functions", "author": ["D. Kroening", "O. Strichman"], "venue": "Decision Procedures: An Algorithmic Point of View. Berlin, Heidelberg: Springer Berlin Heidelberg, 2008, pp. 59\u201380. [Online]. Available: http://dx.doi.org/10.1007/978-3-540-74105-3 3", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2008}, {"title": "Satisfiability modulo theories: Introduction and applications", "author": ["L. De Moura", "N. Bj\u00f8rner"], "venue": "Commun. ACM, vol. 54, no. 9, pp. 69\u201377, Sep. 2011. [Online]. Available: http://doi.acm.org/10.1145/1995376.1995394", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "Introduction to Automata Theory, Languages, and Computation", "author": ["J. Hopcroft", "J. Ullman"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1979}, {"title": "Z3: An efficient smt solver", "author": ["L. de Moura", "N. Bj\u00f8rner"], "venue": "Proc. TACAS, C. R. Ramakrishnan and J. Rehof, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2008, pp. 337\u2013340. [Online]. Available: http://dx.doi.org/10.1007/978-3-540-78800-3 24", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "Formal models of bank cards for free", "author": ["F. Aarts", "J. de Ruiter", "E. Poll"], "venue": "Proc. ICSTW. IEEE, 2013. [Online]. Available: http://dx.doi.org/10.1109/ICSTW.2013.60", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2013}, {"title": "Model learning", "author": ["F. Vaandrager"], "venue": "Commun. ACM, vol. 60, no. 2, pp. 86\u2013 95, Jan. 2017. [Online]. Available: http://doi.acm.org/10.1145/2967606", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2017}, {"title": "Test selection based on finite state models", "author": ["S. Fujiwara", "G. von Bochmann", "F. Khendek", "M. Amalou", "A. Ghedamsi"], "venue": "Software Engineering, vol. 17, no. 6, pp. 591\u2013603, 1991.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1991}], "referenceMentions": [{"referenceID": 0, "context": "It is the optimization variant of the problem of finding a consistent DFA of a fixed size, which has been shown to be NP-complete [1].", "startOffset": 130, "endOffset": 133}, {"referenceID": 1, "context": "In [2], Coste and Nicolas observe that this problem can be encoded as a graph coloring problem.", "startOffset": 3, "endOffset": 6}, {"referenceID": 2, "context": "In [3], Heule and Verwer propose an encoding of the aforementioned graph coloring problem in propositional logic.", "startOffset": 3, "endOffset": 6}, {"referenceID": 3, "context": "[4], who express the encoding by Heule and Verwer in a predicate logic.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "In our presentation, we borrow notational conventions from [5].", "startOffset": 59, "endOffset": 62}, {"referenceID": 5, "context": "We refer to [6] and [5] for a more detailed explanation.", "startOffset": 12, "endOffset": 15}, {"referenceID": 4, "context": "We refer to [6] and [5] for a more detailed explanation.", "startOffset": 20, "endOffset": 23}, {"referenceID": 6, "context": "For a more detailed introduction to SMT we refer to [7].", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "Similarly to Heule and Verwer [3], and Bruynooghe et.", "startOffset": 30, "endOffset": 33}, {"referenceID": 3, "context": "[4], we use an augmented prefix tree (APT) for this.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "It has been shown in [8] that Moore and Mealy machines are equi-expressive if we neglect the output produced by the initial", "startOffset": 21, "endOffset": 24}, {"referenceID": 8, "context": "We have implemented our encodings using the Python frontend of Z3 [9], and we have conducted some initial experiments that assess the scalability of the different encodings and their applicability in practice.", "startOffset": 66, "endOffset": 69}, {"referenceID": 9, "context": "In our second set of experiments we simulate the case study from [10].", "startOffset": 65, "endOffset": 69}, {"referenceID": 10, "context": "Here, the authors use model learning [11]", "startOffset": 37, "endOffset": 41}, {"referenceID": 11, "context": "We first use the Wp-method [12] to generate a characterizing sample for these Mealy machines.", "startOffset": 27, "endOffset": 31}], "year": 2017, "abstractText": "The problem of learning a minimal consistent model from a set of labeled sequences of symbols is addressed from a satisfiability modulo theories perspective. We present two encodings for deterministic finite automata and extend one of these for Moore and Mealy machines. Our experimental results show that these encodings improve upon the state-of-the-art, and are useful in practice for learning small models.", "creator": "LaTeX with hyperref package"}}}