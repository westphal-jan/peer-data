{"id": "1706.03906", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Jun-2017", "title": "A New Probabilistic Algorithm for Approximate Model Counting", "abstract": "Constrained counting is important in domains ranging from artificial intelligence to software analysis. There are already a few approaches for counting models over various types of constraints. Recently, hashing-based approaches achieve both theoretical guarantees and scalability, but still rely on solution enumeration. In this paper, a new probabilistic polynomial time approximate model counter is proposed, which is also a hashing-based universal framework, but with only satisfiability queries. A variant with a dynamic stopping criterion is also presented. Empirical evaluation over benchmarks on propositional logic formulas and SMT(BV) formulas shows that the approach is promising.", "histories": [["v1", "Tue, 13 Jun 2017 05:26:02 GMT  (207kb,D)", "http://arxiv.org/abs/1706.03906v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["cunjing ge", "feifei ma", "tian liu", "jian zhang"], "accepted": false, "id": "1706.03906"}, "pdf": {"name": "1706.03906.pdf", "metadata": {"source": "CRF", "title": "A New Probabilistic Algorithm for Approximate Model Counting", "authors": ["Cunjing Ge", "Feifei Ma", "Tian Liu", "Jian Zhang"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "This year, it has come to the point where it will be able to take the lead, at a time when it is not as far away as it was in the first one, when it is not so far away."}, {"heading": "2 Preliminaries", "text": "Let S and SF denote the entire space and the solution space of F. Let # F denote the cardinality of the formula F, i.e. the number of solutions of F. (,.) -bound To count # F, an (,.) approach algorithm is an algorithm that prints a number Y on each input formula F, > 0, and \u03b4 > 0 so that Pr [(1 +) \u2212 1 # F \u2264 Y value (1 +) # F value. These are denoted (,.) value and (,.) value of formula H as formula F. Hash function LetHF is a family of XOR-based bit functions based on the variables of an SMF."}, {"heading": "3 Related Works", "text": "[1] showed that a nearly uniform sampling of propositional constraints, a closely related problem with restricted counting, can be solved with a NP oracle in probabilistic polynomial time. Building on this, [8] the first scalable approximate model counting algorithm ApproxMC proposed for propositional formulas. ApproxMC is based on a family of 2 universal bit-level hash functions that calculate XOR randomly selected propositional variables. [6] subsequently presented an approximate model counter that uses word-level hash functions that directly utilize the power of sophisticated SMT solvers, although the framework of the probabilistic algorithm is similar to [8]. In the current work, the family of hash functions is adopted in [8], which was shown in [18] to be 3-independent and have better properties than the experimental results and theoretical analysis in the current working method."}, {"heading": "4 Algorithm", "text": "The following approximation is a key to the new algorithmPr Fd (Fd is unsatisfactory if no solution of F is satisfactory, i.e. PrFd (Fd is unsat) # 1. (1) Based on Equation (1), an approximation of # F is achieved by setting logarithm to the value of PrFd (Fd is unsat), which in turn is estimated by sampling d. (1) An approximation of # F is achieved by setting logarithm to the value of PrFd (Fd is unsat), which in turn is estimated by sampling d. (1) An approximation of # F is achieved by setting logarithm to the value of PrFd (Fd is unsat)."}, {"heading": "5 Analysis", "text": "In this section, we assume that Equation (1) \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212 \u2212"}, {"heading": "6 Evaluation", "text": "To evaluate the performance and effectiveness of our approach, two prototype implementations STAC CNF and STAC BV were built with dynamic stop criteria for statement logic formulas and SMT (BV) formulas, respectively. We looked at a wide range of benchmarks from different areas: network networks, plan recognition, DQMR networks, Langford sequences, circuit synthesis, random 3-CNF, logistics problems and program synthesis [26,22,8,6]. Due to lack of space, we present the results only for a subset of benchmarks. All our experiments were conducted on a single core of an Intel Xeon 2.40GHz (16 cores) machine with 32GB of memory and CentOS6.5 operating system."}, {"heading": "6.1 Quality of Approximation", "text": "Remember that our approach is based on Equation (1), which has not been proven, so we would like to see if the approximation fits the limit. We experimented 100 times on each instance. In Table 1, column 1 gives the instance name, column 2 the number of Boolean variables n, column 3 the exact numbers # F, and column 4 the interval [1.8 \u2212 1 # F, 1.8 # F]. The frequency of approximations that lie in the interval [1.8 \u2212 1 # F, 1.8 # F] in 100 experiments are represented in column 5. Average time consumption, number of iterations, and average number of SAT query calls are shown in columns 6, 7, and 8 respectively, which also show the advantages of our approach. Under the dynamic stop criterion, the numbers returned by our approach should be in an interval."}, {"heading": "6.2 Performance Comparison with ( , \u03b4)-counters", "text": "Both STAC CNF and ApproxMC2 use CryptoMiniSAT [29], an efficient SAT solver designed for XOR clauses. STAC BV and SMTApproxMC use the state-of-the-art SMT (BV) solver Boolector [4]. Initially, we conducted experiments with = 0.8, = 0.2, which are also used in previous work [9,6]. Figure 1 shows a comparison of performance between STAC CNF and ApproxMC2. Each point represents an instance whose x-coordinate and y-coordinate represent the runtimes of STAC CNF and ApproxMC2 in this case."}, {"heading": "6.3 Performance Comparison with Bounding and Guarantee-less Counters", "text": "Since our approach is not a (,) counter in theory, we also compared STAC CNF with limited problems (SampleCount [16], MBound [17]) and guaranteed counters (ApproxCount [33], SampleTreeSearch [14]). Table 5 shows the experimental results. For SampleCount we have 1 x 2 x 2 x 3 x 3 x 3 x 4 x 4 x 4 x 4 x 4 x 4 x 4 x 4 x 6 x 6 x 6 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 7 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 8 x 0 x 9 x 0 x 0 x 9 x 9 x 0 x 9 x 9 x 9 x 9 x 0 x 9 x 9 x 9 x 9 x 9 x 9 x 10 x 10 x 10 x 10 x 10 x 10 x x 10 x x x 10 x x x 10 x x x 10 x x x x 10 x x 10 x 10 x x x x 10 x 10 x 10 x 10 x 10 x 10 x 10 x x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x 10 x"}, {"heading": "7 Conclusion", "text": "In this paper, we propose a new hash-based approximate algorithm with dynamic stop criterion. Our approach has two key strengths: it requires only one satisfaction query for each cut and ends as soon as it meets the theoretical guarantee of accuracy. We implemented prototype tools for propositional logic formulas and SMT (BV) formulas. Extensive experiments show that our approach is efficient and promising. Although we are unable to prove the correctness of the equation (1), the experimental results fit in quite well. This phenomenon could be caused by some hidden properties of the hash functions. To fully understand these functions and their correlation with the model number of hacked formulas, it could pose an interesting problem for the community."}], "references": [{"title": "Uniform generation of NP-witnesses using an NP-oracle", "author": ["M. Bellare", "O. Goldreich", "E. Petrank"], "venue": "Inf. Comput.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Hashing-based approximate probabilistic inference in hybrid domains", "author": ["V. Belle", "G.V. Broeck", "A. Passerini"], "venue": "In Proc. of UAI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2015}, {"title": "Interval estimation for a binomial proportion", "author": ["L.D. Brown", "T.T. Cai", "A. Dasgupta"], "venue": "Statistical Science,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "Boolector: An efficient SMT solver for bit-vectors and arrays", "author": ["R. Brummayer", "A. Biere"], "venue": "In Proc. of TACAS,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Distribution-aware sampling and weighted model counting for SAT", "author": ["S. Chakraborty", "D.J. Fremont", "K.S. Meel", "S.A. Seshia", "M.Y. Vardi"], "venue": "In Proc of AAAI,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Approximate probabilistic inference via word-level counting", "author": ["S. Chakraborty", "K.S. Meel", "R. Mistry", "M.Y. Vardi"], "venue": "In Proc. of AAAI,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2016}, {"title": "A scalable and nearly uniform generator of SAT witnesses", "author": ["S. Chakraborty", "K.S. Meel", "M.Y. Vardi"], "venue": "In Proc. of CAV,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "A scalable approximate model counter", "author": ["S. Chakraborty", "K.S. Meel", "M.Y. Vardi"], "venue": "In Proc. of CP,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Algorithmic improvements in approximate counting for probabilistic inference: From linear to logarithmic SAT calls", "author": ["S. Chakraborty", "K.S. Meel", "M.Y. Vardi"], "venue": "In Proc. of IJCAI,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2016}, {"title": "On probabilistic inference by weighted model counting", "author": ["M. Chavira", "A. Darwiche"], "venue": "Artif. Intell.,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Approximate counting in SMT and value estimation for probabilistic programs", "author": ["D. Chistikov", "R. Dimitrova", "R. Majumdar"], "venue": "In Proc. of TACAS,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2015}, {"title": "Probabilistic planning via heuristic forward search and weighted model counting", "author": ["C. Domshlak", "J. Hoffmann"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2007}, {"title": "Embed and project: Discrete sampling with universal hashing", "author": ["S. Ermon", "C.P. Gomes", "A. Sabharwal", "B. Selman"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Uniform solution sampling using a constraint solver as an oracle", "author": ["S. Ermon", "C.P. Gomes", "B. Selman"], "venue": "In Proc. UAI,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Probabilistic symbolic execution", "author": ["J. Geldenhuys", "M.B. Dwyer", "W. Visser"], "venue": "In Proc. of ISSTA,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "From sampling to model counting", "author": ["C.P. Gomes", "J. Hoffmann", "A. Sabharwal", "B. Selman"], "venue": "In Proc. of IJCAI,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2007}, {"title": "Model counting: A new strategy for obtaining good bounds", "author": ["C.P. Gomes", "A. Sabharwal", "B. Selman"], "venue": "In Proc. of AAAI,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "Near-uniform sampling of combinatorial spaces using XOR constraints", "author": ["C.P. Gomes", "A. Sabharwal", "B. Selman"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2006}, {"title": "On computing minimal independent support and its applications to sampling and counting", "author": ["A. Ivrii", "S. Malik", "K.S. Meel", "M.Y. Vardi"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2016}, {"title": "Using CSP look-back techniques to solve real-world SAT instances", "author": ["R.J. Bayardo Jr.", "R. Schrag"], "venue": "In Proc. of AAAI,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1997}, {"title": "Monte-carlo approximation algorithms for enumeration problems", "author": ["R.M. Karp", "M. Luby", "N. Madras"], "venue": "J. Algorithms,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1989}, {"title": "Leveraging belief propagation, backtrack search, and statistics for model counting", "author": ["L. Kroc", "A. Sabharwal", "B. Selman"], "venue": "Annals of OR,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "Program analysis: from qualitative analysis to quantitative analysis", "author": ["S. Liu", "J. Zhang"], "venue": "In Proc. of ICSE,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}, {"title": "Constrained sampling and counting: Universal hashing meets SAT solving", "author": ["K.S. Meel", "M.Y. Vardi", "S. Chakraborty", "D.J. Fremont", "S.A. Seshia", "D. Fried", "A. Ivrii", "S. Malik"], "venue": "In Proceedings of Workshop on Beyond NP(BNP),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2016}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Artif. Intell.,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1996}, {"title": "Performing bayesian inference by weighted model counting", "author": ["T. Sang", "P. Beame", "H.A. Kautz"], "venue": "In Proc. of AAAI,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "Combining component caching and clause learning for effective model counting", "author": ["Tian Sang", "Fahiem Bacchus", "Paul Beame", "Henry A. Kautz", "Toniann Pitassi"], "venue": "In Proc. of SAT,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2004}, {"title": "A complexity theoretic approach to randomness", "author": ["M. Sipser"], "venue": "In Proc. of the 15th Annual ACM Symposium on Theory of Computing,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1983}, {"title": "Extending SAT solvers to cryptographic problems", "author": ["M. Soos", "K. Nohl", "C. Castelluccia"], "venue": "In Proc. of SAT,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2009}, {"title": "The complexity of approximate counting (preliminary version)", "author": ["L.J. Stockmeyer"], "venue": "In Proc. of the 15th Annual ACM Symposium on Theory of Computing,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1983}, {"title": "The complexity of enumeration and reliability problems", "author": ["L.G. Valiant"], "venue": "SIAM J. Comput.,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1979}, {"title": "Binomial confidence intervals and contingency tests: Mathematical fundamentals and the evaluation of alternative methods", "author": ["S. Wallis"], "venue": "Journal of Quantitative Linguistics,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2013}, {"title": "A new approach to model counting", "author": ["W. Wei", "B. Selman"], "venue": "In Proc. of SAT,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2005}, {"title": "Probable inference, the law of succession and statistical inference", "author": ["E.B. Wilson"], "venue": "Journal of the American Statistical Association,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1927}], "referenceMentions": [{"referenceID": 24, "context": "Its interesting applications in several fields include probabilistic inference [25,10], planning [12], combinatorial designs and software engineering [23,15].", "startOffset": 79, "endOffset": 86}, {"referenceID": 9, "context": "Its interesting applications in several fields include probabilistic inference [25,10], planning [12], combinatorial designs and software engineering [23,15].", "startOffset": 79, "endOffset": 86}, {"referenceID": 11, "context": "Its interesting applications in several fields include probabilistic inference [25,10], planning [12], combinatorial designs and software engineering [23,15].", "startOffset": 97, "endOffset": 101}, {"referenceID": 22, "context": "Its interesting applications in several fields include probabilistic inference [25,10], planning [12], combinatorial designs and software engineering [23,15].", "startOffset": 150, "endOffset": 157}, {"referenceID": 14, "context": "Its interesting applications in several fields include probabilistic inference [25,10], planning [12], combinatorial designs and software engineering [23,15].", "startOffset": 150, "endOffset": 157}, {"referenceID": 30, "context": "However, model counting is a canonical #P-complete problem, even for polynomial-time solvable problems like 2-SAT [31], thus presents fascinating challenges for both theoreticians and practitioners.", "startOffset": 114, "endOffset": 118}, {"referenceID": 23, "context": "Recently, hashing-based approximate counting achieves both strong theoretical guarantees and good scalability [24].", "startOffset": 110, "endOffset": 114}, {"referenceID": 27, "context": "The use of universal hash functions in counting problems began in [28,30], but the resulting algorithm scaled poorly in practice.", "startOffset": 66, "endOffset": 73}, {"referenceID": 29, "context": "The use of universal hash functions in counting problems began in [28,30], but the resulting algorithm scaled poorly in practice.", "startOffset": 66, "endOffset": 73}, {"referenceID": 7, "context": "A scalable approximate counter ApproxMC in [8] scales to large problem instances, while preserves rigorous approximation guarantees.", "startOffset": 43, "endOffset": 46}, {"referenceID": 12, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 111, "endOffset": 119}, {"referenceID": 4, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 111, "endOffset": 119}, {"referenceID": 1, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 111, "endOffset": 119}, {"referenceID": 18, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 182, "endOffset": 188}, {"referenceID": 5, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 182, "endOffset": 188}, {"referenceID": 8, "context": "ApproxMC has been extended to finite-domain discrete integration, with applications to probabilistic inference [13,5,2], and improved by designing efficient universal hash functions [19,6] and reducing the use of NP-oracle calls from linear to logarithmic [9].", "startOffset": 256, "endOffset": 259}, {"referenceID": 16, "context": "An algorithm called MBound [17] only invokes satisfiability query once for each cut.", "startOffset": 27, "endOffset": 31}, {"referenceID": 20, "context": "These are called ( , \u03b4)-counters and ( , \u03b4)bound, respectively [21].", "startOffset": 63, "endOffset": 67}, {"referenceID": 0, "context": "[1] showed that almost uniform sampling from propositional constraints, a closely related problem to constrained counting, is solvable in probabilistic polynomial time with an NP oracle.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "Building on this, [8] proposed the first scalable approximate model counting algorithm ApproxMC for propositional formulas.", "startOffset": 18, "endOffset": 21}, {"referenceID": 5, "context": "Subsequently, [6] presented an approximate model counter that uses word-level hash functions, which directly leverage the power of sophisticated SMT solvers, though the framework of the probabilistic algorithm is similar to [8].", "startOffset": 14, "endOffset": 17}, {"referenceID": 7, "context": "Subsequently, [6] presented an approximate model counter that uses word-level hash functions, which directly leverage the power of sophisticated SMT solvers, though the framework of the probabilistic algorithm is similar to [8].", "startOffset": 224, "endOffset": 227}, {"referenceID": 7, "context": "In the current work, the family of hash functions in [8] is adopted, which was shown to be 3-independent in [18], and is revealed to possess better properties than expected by the experimental results and the theoretical analysis in the current work.", "startOffset": 53, "endOffset": 56}, {"referenceID": 17, "context": "In the current work, the family of hash functions in [8] is adopted, which was shown to be 3-independent in [18], and is revealed to possess better properties than expected by the experimental results and the theoretical analysis in the current work.", "startOffset": 108, "endOffset": 112}, {"referenceID": 7, "context": "For completeness, ApproxMC [8,11] is listed here as Algorithm 1.", "startOffset": 27, "endOffset": 33}, {"referenceID": 10, "context": "For completeness, ApproxMC [8,11] is listed here as Algorithm 1.", "startOffset": 27, "endOffset": 33}, {"referenceID": 5, "context": "The general algorithm in [6] is similar to Algorithm 1, but could cut the cell with dynamically determined proportion instead of the constant 12 , due to the word-level hash functions.", "startOffset": 25, "endOffset": 28}, {"referenceID": 8, "context": "[9] improves ApproxMCCore via binary search to reduce the number of enumeration queries from linear to logarithmic.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "A commonly used formula q\u00b1z1\u2212\u03b4 \u221a q(1\u2212q) t [3,32] is adopted, which is justified by the central limit theorem to compute the 1 \u2212 \u03b4 confidence interval.", "startOffset": 42, "endOffset": 48}, {"referenceID": 31, "context": "A commonly used formula q\u00b1z1\u2212\u03b4 \u221a q(1\u2212q) t [3,32] is adopted, which is justified by the central limit theorem to compute the 1 \u2212 \u03b4 confidence interval.", "startOffset": 42, "endOffset": 48}, {"referenceID": 7, "context": "This method is adopted by all previous hashingbased ( , \u03b4)-counters [8,11,6].", "startOffset": 68, "endOffset": 76}, {"referenceID": 10, "context": "This method is adopted by all previous hashingbased ( , \u03b4)-counters [8,11,6].", "startOffset": 68, "endOffset": 76}, {"referenceID": 5, "context": "This method is adopted by all previous hashingbased ( , \u03b4)-counters [8,11,6].", "startOffset": 68, "endOffset": 76}, {"referenceID": 6, "context": "A heuristic called leap-frogging to overcome this bottleneck was proposed in [7,8].", "startOffset": 77, "endOffset": 82}, {"referenceID": 7, "context": "A heuristic called leap-frogging to overcome this bottleneck was proposed in [7,8].", "startOffset": 77, "endOffset": 82}, {"referenceID": 33, "context": "The following interval [34]", "startOffset": 23, "endOffset": 27}, {"referenceID": 25, "context": "We considered a wide range of benchmarks from different domains: grid networks, plan recognition, DQMR networks, Langford sequences, circuit synthesis, random 3-CNF, logistics problems and program synthesis [26,22,8,6].", "startOffset": 207, "endOffset": 218}, {"referenceID": 21, "context": "We considered a wide range of benchmarks from different domains: grid networks, plan recognition, DQMR networks, Langford sequences, circuit synthesis, random 3-CNF, logistics problems and program synthesis [26,22,8,6].", "startOffset": 207, "endOffset": 218}, {"referenceID": 7, "context": "We considered a wide range of benchmarks from different domains: grid networks, plan recognition, DQMR networks, Langford sequences, circuit synthesis, random 3-CNF, logistics problems and program synthesis [26,22,8,6].", "startOffset": 207, "endOffset": 218}, {"referenceID": 5, "context": "We considered a wide range of benchmarks from different domains: grid networks, plan recognition, DQMR networks, Langford sequences, circuit synthesis, random 3-CNF, logistics problems and program synthesis [26,22,8,6].", "startOffset": 207, "endOffset": 218}, {"referenceID": 8, "context": "We compared our tools with ApproxMC2 [9] and SMTApproxMC [6] which are hashingbased ( , \u03b4)-counters.", "startOffset": 37, "endOffset": 40}, {"referenceID": 5, "context": "We compared our tools with ApproxMC2 [9] and SMTApproxMC [6] which are hashingbased ( , \u03b4)-counters.", "startOffset": 57, "endOffset": 60}, {"referenceID": 28, "context": "Both STAC CNF and ApproxMC2 use CryptoMiniSAT [29], an efficient SAT solver designed for XOR clauses.", "startOffset": 46, "endOffset": 50}, {"referenceID": 3, "context": "STAC BV and SMTApproxMC use the state-of-the-art SMT(BV) solver Boolector [4].", "startOffset": 74, "endOffset": 77}, {"referenceID": 8, "context": "2 which are also used in evaluation in previous works [9,6].", "startOffset": 54, "endOffset": 59}, {"referenceID": 5, "context": "2 which are also used in evaluation in previous works [9,6].", "startOffset": 54, "endOffset": 59}, {"referenceID": 15, "context": "Since our approach is not a ( , \u03b4)-counter in theory, we also compared STAC CNF with bounding counters (SampleCount [16], MBound [17]) and guarantee-less counters (ApproxCount [33], SampleTreeSearch [14]).", "startOffset": 116, "endOffset": 120}, {"referenceID": 16, "context": "Since our approach is not a ( , \u03b4)-counter in theory, we also compared STAC CNF with bounding counters (SampleCount [16], MBound [17]) and guarantee-less counters (ApproxCount [33], SampleTreeSearch [14]).", "startOffset": 129, "endOffset": 133}, {"referenceID": 32, "context": "Since our approach is not a ( , \u03b4)-counter in theory, we also compared STAC CNF with bounding counters (SampleCount [16], MBound [17]) and guarantee-less counters (ApproxCount [33], SampleTreeSearch [14]).", "startOffset": 176, "endOffset": 180}, {"referenceID": 13, "context": "Since our approach is not a ( , \u03b4)-counter in theory, we also compared STAC CNF with bounding counters (SampleCount [16], MBound [17]) and guarantee-less counters (ApproxCount [33], SampleTreeSearch [14]).", "startOffset": 199, "endOffset": 203}, {"referenceID": 26, "context": "Note that ApproxCount calls exact model counter Cachet [27] and Relsat [20] after formula simplifications, so it sometimes returns the exact counts, such as blockmap 05 01, blockmap 05 02, 5step and tire-1.", "startOffset": 55, "endOffset": 59}, {"referenceID": 19, "context": "Note that ApproxCount calls exact model counter Cachet [27] and Relsat [20] after formula simplifications, so it sometimes returns the exact counts, such as blockmap 05 01, blockmap 05 02, 5step and tire-1.", "startOffset": 71, "endOffset": 75}], "year": 2017, "abstractText": "Constrained counting is important in domains ranging from artificial intelligence to software analysis. There are already a few approaches for counting models over various types of constraints. Recently, hashing-based approaches achieve both theoretical guarantees and scalability, but still rely on solution enumeration. In this paper, a new probabilistic polynomial time approximate model counter is proposed, which is also a hashing-based universal framework, but with only satisfiability queries. A variant with a dynamic stopping criterion is also presented. Empirical evaluation over benchmarks on propositional logic formulas and SMT(BV) formulas shows that the approach is promising.", "creator": "LaTeX with hyperref package"}}}