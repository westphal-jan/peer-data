{"id": "1706.05070", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jun-2017", "title": "Learning Disjunctions of Predicates", "abstract": "Let $F$ be a set of boolean functions. We present an algorithm for learning $F_\\vee := \\{\\vee_{f\\in S} f \\mid S \\subseteq F\\}$ from membership queries. Our algorithm asks at most $|F| \\cdot OPT(F_\\vee)$ membership queries where $OPT(F_\\vee)$ is the minimum worst case number of membership queries for learning $F_\\vee$. When $F$ is a set of halfspaces over a constant dimension space or a set of variable inequalities, our algorithm runs in polynomial time.", "histories": [["v1", "Thu, 15 Jun 2017 20:21:38 GMT  (652kb,D)", "http://arxiv.org/abs/1706.05070v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["nader h bshouty", "dana drachsler-cohen", "martin vechev", "eran yahav"], "accepted": false, "id": "1706.05070"}, "pdf": {"name": "1706.05070.pdf", "metadata": {"source": "CRF", "title": "Learning Disjunctions of Predicates", "authors": ["Nader H. Bshouty", "Dana Drachsler-Cohen", "Martin Vechev", "Eran Yahav", "BSHOUTY DRACHSLER-COHEN", "VECHEV YAHAV"], "emails": ["BSHOUTY@CS.TECHNION.AC.IL", "DDANA@CS.TECHNION.AC.IL", "MARTIN.VECHEV@INF.ETHZ.CH", "YAHAVE@CS.TECHNION.AC.IL"], "sections": [{"heading": null, "text": "The problem we are dealing with is of practical importance in the field of program synthesis, where the goal is to synthesize a program that meets certain requirements. Program synthesis has become especially popular in environments that aim to help end users. In such environments, the requirements are not provided in advance and the synthesizer can only learn them by submitting membership requests to the end user. Our work allows such synthesizers to learn the exact requirements while the number of membership requests is limited."}, {"heading": "1. Introduction", "text": "It is about the question, to what extent it is about a way, in which it is about the question, to what extent it is about a way, in which people are able to understand the world. (...) The question is to what extent people are able to understand the world. (...) The question is to what extent they are able to understand the world. (...) The question is to what extent the world in the world is able to understand the world. (...) The question is to what extent people are able to understand the world. (...) The question is to what extent the world in the world is the world, the world of people in the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world, the world."}, {"heading": "2. The Model and Class", "text": "Let F be a finite set of Boolean functions over a domain X (possibly infinite). We look at the class of functions F: = {\u0435f \u0445Sf | S F}. Our model assumes a teacher who has a target function F-F, and a learner who knows F-F, but not the target function. The teacher can answer membership requests for the target function - that is, the teacher returns x-X (from the learner). The goal of the learner (the learning algorithm) is to find the target function with a minimum number of member queries. Below, some notations that are used throughout the work. OPT (F) denotes the minimum number of member queries required to learn a function F in F-F. Given F-ig, we refer to S (F) as the group that consists of all functions in F. Formally, we define S (F) = olean subset of F so that F = f-interpretation-S."}, {"heading": "3. Definitions and Preliminary Results", "text": "In this section, we present the definitions used in this paper and present preliminary results. We begin by defining an equivalence relationship based on the set of disjunctions and the definition of the representatives of the equivalence classes. We then define a partial order based on the disjunctions and related terms (descendant, ascendant and lowest / largest common descendant / ascendant) and complete this section with the introduction of a witness, which is central to our algorithm."}, {"heading": "3.1. An Equivalence Relation Over F\u2228", "text": "In this section, we will present an equivalence relationship over F \u00b2 and define the representatives of the equivalence classes. This will allow us to focus on the representative elements of F \u00b2 in later sections. F \u00b2 is a series of Boolean functions over domain X. The equivalence ratio = over F \u00b2 is defined as follows: two disjunctions F1, F2, F \u00b2 are equivalent (F1 = F2) if F1 \u00b2 is logically equal to F2. In other words, they represent the same function (from X to {0, 1}). We write F1 \u00b2 F2 to indicate that F1 and F2 are identical; that is, they have the same representation. For example, consider f1, f2: {0, 1} \u2192 {0, 1} where f1 (x) = 1 and f2 (x) = x. Then, f2 (f2) = x."}, {"heading": "3.2. A Partial Order Over F\u2228", "text": "In this section we define a partial order over G2 and current related definitions."}, {"heading": "3.3. Witnesses", "text": "Finally, we define the term witness. Let G1 and G2 be elements in G (F). An element a (G) X is a witness for G1 and G2 (a) 6 = G2 (a). We now show two central Lemmatas.Lemma 7 Let G1 be a direct descendant of G2. If an x is a witness for G1 and G2, then: 1. G1 (a) = 0 and G2 (a) = 1. For each f \u00b7 S (G1), f (a) = 0. 3. For each f = S (G2)\\ S (G1), f (a) = 1.Evidence since G1 \u21d2 G2, it must be this G2 (a) = 1 and G1 (a) = 0. Namely for each f = S (G1), f (a), f (a) = 0."}, {"heading": "4. The Algorithm", "text": "In this section we introduce our algorithm to learn a target disjunction about F, called SPEX (abbreviation for specifications from examples). Our algorithm is based on the following results. Lemma 9 Let G \"is a direct descendant of G.\" In particular S (G \") S (G\") S (G \") and G\" is a descendant of G. \"If G\" (a) is neither a descendant of G, \"nor a descendant of G.\" (G \") S (G\") S (G \") S (G\") and G \"(G\") is a descendant of G. \"(G\") and G \"G\" (G \") is a descendant of G.\" (G \") is a descendant of G.\" (G \") is a descendant of G\" and G \"(G\") is a descendant of G. \"(G\")"}, {"heading": "4.1. Lower Bound", "text": "Theorem 12 Any learning algorithm in which F \"is learned must at least max\" (log \"G\"), \"maxG\" (F \")\" ask. \"In particular SPEX\" (algorithm 1) \"ask at most\" F \"(OPT\" F \").\" Proof that G \"should be such that m =\" De \"(G\") | = maxG \"G\" (F \") | De (G) |.\" Let G1... \"be the direct descendants of G.\" If the target function is either G \"or one of its immediate descendants, then each learning algorithm must ask a question about membership\" i \"(G\"), so that G can distinguish \"i\" (a witness G \") and\" only \"G\" (Gi \") between one (Gi\") and one (Gi)."}, {"heading": "4.2. Finding All Immediate Descendants of G", "text": "A missing detail in our algorithm is how we find the direct descendants of G in the Hasse Chart H (G) (G). In this section, we will first explain how we can obtain them. (G) How we calculate the direct descendants in H (G) that lead to an operation requiring an immediate descendant of G (G), which is necessary because the direct descendants are part of H (G). (G) Finally, we will show how we calculate descendants that lead to different direct descendants. (G) How we can obtain all direct descendants of G (G). (G) How we can obtain all direct descendants of G (G) that lead to an operation leading to an immediate descendant of G (G). (G) How we can obtain all direct descendants of G (G)."}, {"heading": "4.3. Critical Points", "text": "In this section we show that if one can find certain points (the critical points), then the immediate descendants can be calculated in polynomial time (in the number of these points) and thus SPEX runin polynomial time. In particular, if the number of points is polynomial and they can be obtained in polynomial time, then SPEX runs in polynomial time."}, {"heading": "5. A Polynomial Time Algorithm for Halfspaces in a Constant Dimension", "text": "In this section we show two results. The first is that if F is a series of hemispheres over a constant dimension, one can find a semi-constant critical point set in a semi-constant time, and therefore SPEX can run in a polynomial time. We then show that if P = NP, this result cannot be extended to non-constant dimensions. [1] A semi-constant space of dimension d is a boolean function of form: f (x1,.., xd) = [a1xd] = {1 if a1xd \u2265 b] = {1 if a1x1 + adxd \u00b2 n dimension. [2] A semi-constant space of dimension d is a boolean function of form. < d) and a1,."}, {"heading": "6. Duality and a Polynomial Time Algorithm for Variable Inequality Predicates", "text": "In this section, we examine the learning ability of conjunctions on variable inequality. In the acyclic case, we provide a polynomial time learning algorithm. In general, we show that the learning problem is equivalent to the open problem of enumerating all the maximum acyclic subgraphs of a given directed graph. Consider the set of Boolean functions FI: = {xi > xj] | (i, j). In this section, we assume that (i) [n] 2, where [n] = {1, 2,., n} and the variables xi are interpreted as real numbers. We define [xi > xj] = 1 if xi > xj]; and 0 otherwise. In this section, we assume that (i) 6, I for all i. We consider the dual class F: = {f, Sf, Sf | S, F}."}, {"heading": "6.1. Acyclic Sets", "text": "It is a matter of time before we find an answer to the question whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question, whether there is an answer to the question."}, {"heading": "6.2. Cyclic Sets", "text": "In this section we look at the general case in which I [n] 2 can be any problem (JJ = JJ = JJ = JJ). (JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JJ = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = = JP = = JP = = JP = = = JP = = JP = = JP = = = JP = = JP = = JP = = = JP = = JP = = JP = = JP = = JP = = JP = = JP = = = JP = = JP = = = JP = = JP = JP = = = JP = JP = JP = JP = JP = JP = JP = = JP = JP = JP = JP = JP = JP = JP = = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP = JP"}, {"heading": "7. Application to Program Synthesis", "text": "In this section we explain the natural integration of SPEX into the program synthesis."}, {"heading": "7.1. Example: Synthesis of Time-series Patterns", "text": "In this section we will consider the placement of synthesizer programs that recognize time series patterns. Specifications of these programs are via FI ratios for some I knowledge (s) 2 and thus the synthesizer will learn the target program within first person memberships queries. Experts use these diagrams to predict important events (e.g. trend changes in stock prices) by searching for patterns in the diagrams. There are a variety of platforms that allow users to write programs to recognize a pattern in a time series diagram. In this thesis we will consider a domain specific language (DSL) of a popular trading platform, AmiBroker. Our synthesizer can easily expand to other DSLs.A time series diagrams to expand c ratios c."}, {"heading": "8. Related Work", "text": "The synthesis of the Synthesis Program (Solar-Lezama, 2008) has attracted a lot of attention in the last decade, especially in the creation of synthesis systems based on examples known as PBE (e.g. Gulwani (2010); Lau et al. (2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani et al. (2013); Singh and Gulwani et al. (2012); Barowy et al. (2015); Yessenov et al. (2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani et al. (2014); Barowy et al. (2015); Polozov and Gulwani al. (2015)."}, {"heading": "9. Conclusion", "text": "In this paper, we examined the learning ability of disjunctions (and conjunctions) across a number of Boolean functions F. We demonstrated an algorithm called SPEX that asks for membership at most. We also showed two classes that SPEX can learn in polynomial time. We then showed a practical application of SPEX that expands PBE synthesizers and allows them to output the target program as intended by the end user. Finally, we showed an asynthesizer that learns time series patterns in polynomial time and issues an executable program while interacting with the end user through visual diagrams. Acknowledgements The research leading to these results was funded by the Seventh Framework Programme (FP7) of the European Union under Funding Agreement No. 615688-ERC-COGPRIME."}, {"heading": "Appendix A. The Dual SPEX Algorithm", "text": "Figure 3 shows the dual SPEX algorithm for learning F functions."}, {"heading": "Appendix B. Proofs for Section 3.2", "text": "Evidence for Lemma 2 Consider GF = GF, G1 \u00b2 GF \u00b2 G2. By defining the immediate offspring we get the result. Evidence for Lemma 3 Bullet 1: Consider GF = F and GF \u00b2 G (F \u00b2). Evidence for Lemma 4 Since G1, G2 \u00b2 lca (G1, G2) we get G1 \u00b2 G2 lca (G1, G2). Evidence for Lemma 4 Since G1, G2 \u00b2 lca (G1, G2) we get G1 \u00b2 G2 lca (G1, G2). Evidence for Lemma 4 Since G1, G2 \u00b2 G2 \u00b2 (G1, G2) we get G1 \u00b2 G2 \u00b2 S (G1, G2). Evidence for Lemma 6 Let G = GCd (G1, G2)."}, {"heading": "Appendix C. Additional Proofs for Section 6", "text": "The proof for Lemma 24 is provided only if: Suppose F1 = F2. Suppose, on the contrary, there is i, j so that w.l.o.g. R (I (F1) i, j = 0 and R (I (F2))) i, j = 1. Since I am acyclic and R (I (F2) i, j = 1, there is no way from j to i in GI (and therefore in GI (F1))) i, j = 0, there is also no way from i to j in GI (F1). Therefore, we can unify the vertices i and j in GI (F1) (unify them into a single vertex) and get an acyclic graph G. \"With the help of the topological sorting of G\" we get a satisfactory mapping for I that is ai = aj. We now show that F2 (a) and thus a contradiction."}, {"heading": "Appendix D. Additional Figures", "text": "Here we present Figures 4, 5, 6 and 7."}], "references": [{"title": "Learning boolean halfspaces with small weights from membership queries", "author": ["Hasan Abasi", "Ali Z. Abdi", "Nader H. Bshouty"], "venue": "In Algorithmic Learning Theory: 25th International Conference,", "citeRegEx": "Abasi et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Abasi et al\\.", "year": 2014}, {"title": "Learning threshold functions with small weights using membership queries", "author": ["Elias Abboud", "Nader Agha", "Nader H. Bshouty", "Nizar Radwan", "Fathi Saleh"], "venue": "In Proceedings of the Twelfth Annual Conference on Computational Learning Theory,", "citeRegEx": "Abboud et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Abboud et al\\.", "year": 1999}, {"title": "Telling stories: Enumerating maximal directed acyclic graphs with a constrained set of sources and targets", "author": ["Vicente Acua", "Etienne Birmel", "Ludovic Cottret", "Pierluigi Crescenzi", "Fabien Jourdan", "Vincent Lacroix", "Alberto Marchetti-Spaccamela", "Andrea Marino", "Paulo Vieira Milreu", "Marie-France Sagot", "Leen Stougie"], "venue": "Theoretical Computer Science,", "citeRegEx": "Acua et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Acua et al\\.", "year": 2012}, {"title": "Recursive program synthesis", "author": ["Aws Albarghouthi", "Sumit Gulwani", "Zachary Kincaid"], "venue": "In Computer Aided Verification - 25th International Conference,", "citeRegEx": "Albarghouthi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Albarghouthi et al\\.", "year": 2013}, {"title": "Learning a hidden matching", "author": ["Noga Alon", "Richard Beigel", "Simon Kasif", "Steven Rudich", "Benny Sudakov"], "venue": "In Proceedings of the 43rd Symposium on Foundations of Computer Science, FOCS \u201902,", "citeRegEx": "Alon et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Alon et al\\.", "year": 2002}, {"title": "Syntaxguided synthesis", "author": ["Rajeev Alur", "Rastislav Bodik", "Garvit Juniwal", "Milo M.K. Martin", "Mukund Raghothaman", "Sanjit A. Seshia", "Rishabh Singh", "Armando Solar-Lezama", "Emina Torlak", "Abhishek Udupa"], "venue": "In Formal Methods in Computer-Aided Design,", "citeRegEx": "Alur et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Alur et al\\.", "year": 2013}, {"title": "Charting patterns on price history", "author": ["Saswat Anand", "Wei-Ngan Chin", "Siau-Cheng Khoo"], "venue": "In Proceedings of the Sixth ACM SIGPLAN International Conference on Functional Programming (ICFP", "citeRegEx": "Anand et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Anand et al\\.", "year": 2001}, {"title": "Queries and concept learning", "author": ["Dana Angluin"], "venue": "Machine Learning,", "citeRegEx": "Angluin.,? \\Q1988\\E", "shortCiteRegEx": "Angluin.", "year": 1988}, {"title": "Learning a hidden graph using queries per edge", "author": ["Dana Angluin", "Jiang Chen"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Angluin and Chen.,? \\Q2008\\E", "shortCiteRegEx": "Angluin and Chen.", "year": 2008}, {"title": "Timefork: Interactive prediction of time series", "author": ["Sriram Karthik Badam", "Jieqiong Zhao", "Shivalik Sen", "Niklas Elmqvist", "David S. Ebert"], "venue": "In Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems,", "citeRegEx": "Badam et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Badam et al\\.", "year": 2016}, {"title": "Stat!: An interactive analytics environment for big data", "author": ["Mike Barnett", "Badrish Chandramouli", "Robert DeLine", "Steven Drucker", "Danyel Fisher", "Jonathan Goldstein", "Patrick Morrison", "John Platt"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Barnett et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Barnett et al\\.", "year": 2013}, {"title": "Flashrelate: Extracting relational data from semi-structured spreadsheets using examples", "author": ["Daniel W. Barowy", "Sumit Gulwani", "Ted Hart", "Benjamin Zorn"], "venue": "In Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Barowy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Barowy et al\\.", "year": 2015}, {"title": "Multiple Access Channels: Theory and Practice", "author": ["E. Biglieri", "L. Gyrfi"], "venue": null, "citeRegEx": "Biglieri and Gyrfi.,? \\Q2007\\E", "shortCiteRegEx": "Biglieri and Gyrfi.", "year": 2007}, {"title": "Optimal two-stage algorithms for group testing problems", "author": ["Annalisa De Bonis", "Leszek Gasieniec", "Ugo Vaccaro"], "venue": null, "citeRegEx": "Bonis et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bonis et al\\.", "year": 2005}, {"title": "Telling stories fast", "author": ["Michele Borassi", "Pierluigi Crescenzi", "Vincent Lacroix", "Andrea Marino", "Marie-France Sagot", "Paulo Vieira Milreu"], "venue": "Experimental Algorithms: 12th International Symposium,", "citeRegEx": "Borassi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Borassi et al\\.", "year": 2013}, {"title": "Optimizing synthesis with metasketches", "author": ["James Bornholt", "Emina Torlak", "Dan Grossman", "Luis Ceze"], "venue": "In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "Bornholt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bornholt et al\\.", "year": 2016}, {"title": "Cayuga: A high-performance event processing engine", "author": ["Lars Brenna", "Alan Demers", "Johannes Gehrke", "Mingsheng Hong", "Joel Ossher", "Biswanath Panda", "Mirek Riedewald", "Mohit Thatte", "Walker White"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Brenna et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Brenna et al\\.", "year": 2007}, {"title": "Encyclopedia of Chart Patterns", "author": ["Thomas N. Bulkowski"], "venue": "Wiley, 2nd edition,", "citeRegEx": "Bulkowski.,? \\Q2005\\E", "shortCiteRegEx": "Bulkowski.", "year": 2005}, {"title": "High-performance dynamic pattern matching over disordered streams", "author": ["Badrish Chandramouli", "Jonathan Goldstein", "David Maier"], "venue": "In PVLDB,", "citeRegEx": "Chandramouli et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chandramouli et al\\.", "year": 2010}, {"title": "Ecg anomaly detection via time series analysis", "author": ["Mooi Choo Chuah", "Fen Fu"], "venue": "In Frontiers of High Performance Computing and Networking ISPA 2007 Workshops: ISPA 2007 International Workshops SSDSN,", "citeRegEx": "Chuah and Fu.,? \\Q2007\\E", "shortCiteRegEx": "Chuah and Fu.", "year": 2007}, {"title": "Group testing. In Fault-Tolerant Search Algorithms, pages 139\u2013173", "author": ["Ferdinando Cicalese"], "venue": null, "citeRegEx": "Cicalese.,? \\Q2013\\E", "shortCiteRegEx": "Cicalese.", "year": 2013}, {"title": "Introduction to Algorithms", "author": ["Thomas H. Cormen", "Clifford Stein", "Ronald L. Rivest", "Charles E. Leiserson"], "venue": "McGraw-Hill Higher Education,", "citeRegEx": "Cormen et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Cormen et al\\.", "year": 2001}, {"title": "Synthesizing view definitions from data", "author": ["Anish Das Sarma", "Aditya Parameswaran", "Hector Garcia-Molina", "Jennifer Widom"], "venue": "In Database Theory - ICDT \u201910, 13th International Conference,", "citeRegEx": "Sarma et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Sarma et al\\.", "year": 2010}, {"title": "The detection of defective members of large populations", "author": ["Robert Dorfman"], "venue": "The Annals of Mathematical Statistics,", "citeRegEx": "Dorfman.,? \\Q1943\\E", "shortCiteRegEx": "Dorfman.", "year": 1943}, {"title": "Combinatorial Group Testing and Its Applications", "author": ["D. Du", "F. Hwang"], "venue": "Applied Mathematics. World Scientific,", "citeRegEx": "Du and Hwang.,? \\Q2000\\E", "shortCiteRegEx": "Du and Hwang.", "year": 2000}, {"title": "Pooling Designs and Nonadaptive Group Testing: Important Tools for DNA Sequencing", "author": ["D. Du", "F. Hwang"], "venue": "Series on applied mathematics. World Scientific,", "citeRegEx": "Du and Hwang.,? \\Q2006\\E", "shortCiteRegEx": "Du and Hwang.", "year": 2006}, {"title": "Reconstructing a hamiltonian cycle by querying the graph: Application to DNA physical mapping", "author": ["Vladimir Grebinski", "Gregory Kucherov"], "venue": "Discrete Appl. Math.,", "citeRegEx": "Grebinski and Kucherov.,? \\Q1998\\E", "shortCiteRegEx": "Grebinski and Kucherov.", "year": 1998}, {"title": "Dimensions in program synthesis", "author": ["Sumit Gulwani"], "venue": "In Proceedings of the 12th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming,", "citeRegEx": "Gulwani.,? \\Q2010\\E", "shortCiteRegEx": "Gulwani.", "year": 2010}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["Sumit Gulwani"], "venue": "In Proceedings of the 38th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "Gulwani.,? \\Q2011\\E", "shortCiteRegEx": "Gulwani.", "year": 2011}, {"title": "Spreadsheet data manipulation using examples", "author": ["Sumit Gulwani", "William R. Harris", "Rishabh Singh"], "venue": "Commun. ACM,", "citeRegEx": "Gulwani et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gulwani et al\\.", "year": 2012}, {"title": "Spreadsheet table transformations from examples", "author": ["William R. Harris", "Sumit Gulwani"], "venue": "In Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Harris and Gulwani.,? \\Q2011\\E", "shortCiteRegEx": "Harris and Gulwani.", "year": 2011}, {"title": "Generalized teaching dimensions and the query complexity of learning", "author": ["Tibor Heged\u0171s"], "venue": "In Proceedings of the Eighth Annual Conference on Computational Learning Theory, COLT", "citeRegEx": "Heged\u0171s.,? \\Q1995\\E", "shortCiteRegEx": "Heged\u0171s.", "year": 1995}, {"title": "IBM streams processing language: Analyzing big data in motion", "author": ["M. Hirzel", "H. Andrade", "B. Gedik", "G. Jacques-Silva", "R. Khandekar", "V. Kumar", "M. Mendell", "H. Nasgaard", "S. Schneider", "R. Soul\u00e9", "K.-L. Wu"], "venue": "IBM J. Res. Dev.,", "citeRegEx": "Hirzel et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hirzel et al\\.", "year": 2013}, {"title": "Oracle-guided component-based program synthesis", "author": ["Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "In Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1,", "citeRegEx": "Jha et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2010}, {"title": "The Art of Computer Programming, Volume 1 (3rd Ed.)", "author": ["Donald E. Knuth"], "venue": null, "citeRegEx": "Knuth.,? \\Q1997\\E", "shortCiteRegEx": "Knuth.", "year": 1997}, {"title": "Programming by demonstration using version space algebra", "author": ["Tessa A. Lau", "Steven A. Wolfman", "Pedro Domingos", "Daniel S. Weld"], "venue": "Machine Learning,", "citeRegEx": "Lau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lau et al\\.", "year": 2003}, {"title": "Flashextract: A framework for data extraction by examples", "author": ["Vu Le", "Sumit Gulwani"], "venue": "In ACM SIGPLAN Conference on Programming Language Design and Implementation,", "citeRegEx": "Le and Gulwani.,? \\Q2014\\E", "shortCiteRegEx": "Le and Gulwani.", "year": 2014}, {"title": "A machine learning framework for programming by example", "author": ["Aditya Krishna Menon", "Omer Tamuz", "Sumit Gulwani", "Butler W. Lampson", "Adam Kalai"], "venue": "In Proceedings of the 30th International Conference on Machine Learning,", "citeRegEx": "Menon et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Menon et al\\.", "year": 2013}, {"title": "Pattern recognition to forecast seismic time series", "author": ["A. Morales-Esteban", "F. Martnez-lvarez", "A. Troncoso", "J.L. Justo", "C. Rubio-Escudero"], "venue": "Expert Systems with Applications,", "citeRegEx": "Morales.Esteban et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Morales.Esteban et al\\.", "year": 2010}, {"title": "A survey on combinatorial group testing algorithms with applications to DNA library screening", "author": ["Hung Q Ngo", "Ding-Zhu Du"], "venue": "DIMACS Series in Discrete Mathematics and Theoretical Computer Science,", "citeRegEx": "Ngo and Du.,? \\Q2000\\E", "shortCiteRegEx": "Ngo and Du.", "year": 2000}, {"title": "Searching games with errors\u2014fifty years of coping with liars", "author": ["Andrzej Pelc"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "Pelc.,? \\Q2002\\E", "shortCiteRegEx": "Pelc.", "year": 2002}, {"title": "Learning semantic string transformations from examples", "author": ["Rishabh Singh", "Sumit Gulwani"], "venue": "PVLDB, 5(8):740\u2013751,", "citeRegEx": "Singh and Gulwani.,? \\Q2012\\E", "shortCiteRegEx": "Singh and Gulwani.", "year": 2012}, {"title": "Synthesizing data structure manipulations from storyboards", "author": ["Rishabh Singh", "Armando Solar-Lezama"], "venue": "In SIGSOFT/FSE\u201911 19th ACM SIGSOFT Symposium on the Foundations of Software Engineering (FSE-19) and ESEC\u201911: 13th European Software Engineering Conference", "citeRegEx": "Singh and Solar.Lezama.,? \\Q2011\\E", "shortCiteRegEx": "Singh and Solar.Lezama.", "year": 2011}, {"title": "Program synthesis by sketching", "author": ["Armando Solar-Lezama"], "venue": "ProQuest,", "citeRegEx": "Solar.Lezama.,? \\Q2008\\E", "shortCiteRegEx": "Solar.Lezama.", "year": 2008}, {"title": "Sketching concurrent data structures", "author": ["Armando Solar-Lezama", "Christopher Grant Jones", "Rastislav Bodik"], "venue": "In Proceedings of the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation,", "citeRegEx": "Solar.Lezama et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Solar.Lezama et al\\.", "year": 2008}, {"title": "Stream processing with a spreadsheet", "author": ["Mandana Vaziri", "Olivier Tardieu", "Rodric Rabbah", "Philippe Suter", "Martin Hirzel"], "venue": "In ECOOP 2014 - Object-Oriented Programming - 28th European Conference,", "citeRegEx": "Vaziri et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Vaziri et al\\.", "year": 2014}, {"title": "Enumeration of enumeration algorithms", "author": ["Kunihiro Wasa"], "venue": "CoRR, abs/1605.05102,", "citeRegEx": "Wasa.,? \\Q2016\\E", "shortCiteRegEx": "Wasa.", "year": 2016}, {"title": "High-performance complex event processing over streams", "author": ["Eugene Wu", "Yanlei Diao", "Shariq Rizvi"], "venue": "In Proceedings of the ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "Wu et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2006}, {"title": "A colorful approach to text processing by example", "author": ["Kuat Yessenov", "Shubham Tulsiani", "Aditya Krishna Menon", "Robert C. Miller", "Sumit Gulwani", "Butler W. Lampson", "Adam Kalai"], "venue": "In The 26th Annual ACM Symposium on User Interface Software and Technology,", "citeRegEx": "Yessenov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Yessenov et al\\.", "year": 2013}, {"title": "Automatically synthesizing sql queries from input-output examples", "author": ["Sai Zhang", "Yuyin Sun"], "venue": "In 2013 28th IEEE/ACM International Conference on Automated Software Engineering,", "citeRegEx": "Zhang and Sun.,? \\Q2013\\E", "shortCiteRegEx": "Zhang and Sun.", "year": 2013}, {"title": "Deciphering threshold functions of k-valued logic. In Discrete Analysis and Operations Research", "author": ["N. Yu. Zolotykh", "V.N. Shevchenko"], "venue": "Novosibirsk 2(3),", "citeRegEx": "Zolotykh and Shevchenko.,? \\Q1997\\E", "shortCiteRegEx": "Zolotykh and Shevchenko.", "year": 1997}], "referenceMentions": [{"referenceID": 7, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 46, "endOffset": 61}, {"referenceID": 23, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 165, "endOffset": 180}, {"referenceID": 8, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 224, "endOffset": 248}, {"referenceID": 12, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al.", "startOffset": 321, "endOffset": 347}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 430, "endOffset": 449}, {"referenceID": 26, "context": ", 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 30, "endOffset": 60}, {"referenceID": 40, "context": ", 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002).", "startOffset": 77, "endOffset": 89}, {"referenceID": 11, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 36, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 28, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 33, "context": "One of these is programming by example (PBE), a popular setting of program synthesis (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011; Jha et al., 2010).", "startOffset": 85, "endOffset": 188}, {"referenceID": 11, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 36, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 28, "context": "The common setting of PBE is to synthesize a program based on a typically small set of user-provided examples, which are often an under-specification of the target program (Polozov and Gulwani, 2015; Barowy et al., 2015; Le and Gulwani, 2014; Gulwani, 2011).", "startOffset": 172, "endOffset": 257}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al.", "startOffset": 431, "endOffset": 596}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al.", "startOffset": 431, "endOffset": 615}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 636}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 657}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007).", "startOffset": 431, "endOffset": 674}, {"referenceID": 4, "context": "Introduction Learning from membership queries (Angluin, 1988) has flourished due to its many applications in group testing (Du and Hwang, 2000, 2006), blood testing (Dorfman, 1943), chemical leak testing, chemical reactions (Angluin and Chen, 2008), electrical short detection, codes, multi-access channel communications (Biglieri and Gyrfi, 2007), molecular biology, VLSI testing, AIDS screening, whole-genome shotgun sequencing (Alon et al., 2002), DNA physical mapping (Grebinski and Kucherov, 1998) and game theory (Pelc, 2002). For a list of many other applications, see Du and Hwang (2000); Ngo and Du (2000); Bonis et al. (2005); Du and Hwang (2006); Cicalese (2013); Biglieri and Gyrfi (2007). Many of the new applications present new models and new problems.", "startOffset": 431, "endOffset": 701}, {"referenceID": 33, "context": "small (finite) set of programs and ask the user membership queries while there are non-equivalent programs in the search space (Jha et al., 2010).", "startOffset": 127, "endOffset": 145}, {"referenceID": 2, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 14, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 46, "context": "If the set is cyclic (\u2227F = 0), we show that learning is equivalent to the problem of enumerating all the maximal acyclic subgraphs of a directed graph, which is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 183, "endOffset": 236}, {"referenceID": 17, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al.", "startOffset": 66, "endOffset": 83}, {"referenceID": 19, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al.", "startOffset": 94, "endOffset": 114}, {"referenceID": 38, "context": "Time charts are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (Morales-Esteban et al., 2010).", "startOffset": 131, "endOffset": 161}, {"referenceID": 25, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al.", "startOffset": 80, "endOffset": 95}, {"referenceID": 25, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al.", "startOffset": 80, "endOffset": 127}, {"referenceID": 0, "context": "We note that there are other applications for learning halfspaces; for example, Heged\u0171s (1995); Zolotykh and Shevchenko (1995); Abboud et al. (1999); Abasi et al.", "startOffset": 128, "endOffset": 149}, {"referenceID": 0, "context": "(1999); Abasi et al. (2014). The second class we consider is conjunctions over F , where F is the set of variable inequalities, i.", "startOffset": 8, "endOffset": 28}, {"referenceID": 33, "context": "Also, it is known that a topological sorting for an acyclic set can be found in linear time (see Knuth (1997), Volume 1, Section 2.", "startOffset": 97, "endOffset": 110}, {"referenceID": 21, "context": "3 and Cormen et al. (2001)).", "startOffset": 6, "endOffset": 27}, {"referenceID": 2, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 14, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 46, "context": "The problem of enumerating all the maximal acyclic subgraphs of a directed graph is still an open problem (Acua et al., 2012; Borassi et al., 2013; Wasa, 2016).", "startOffset": 106, "endOffset": 159}, {"referenceID": 37, "context": ", Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 2, "endOffset": 29}, {"referenceID": 37, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 38}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al.", "startOffset": 39, "endOffset": 58}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)).", "startOffset": 39, "endOffset": 82}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al.", "startOffset": 39, "endOffset": 285}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al.", "startOffset": 39, "endOffset": 313}, {"referenceID": 5, "context": "(2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)). \u2022 Synthesizers that assume that Y describes only input\u2013output examples (known as PBE synthesizers). Namely, all formulas in the specification take the form of xin = in\u21d2xout = out (e.g., Gulwani (2011); Polozov and Gulwani (2015); Barowy et al. (2015)).", "startOffset": 39, "endOffset": 335}, {"referenceID": 17, "context": "Time-series are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (MoralesEsteban et al.", "startOffset": 66, "endOffset": 83}, {"referenceID": 19, "context": "Time-series are used in many domains including financial analysis (Bulkowski, 2005), medicine (Chuah and Fu, 2007), and seismology (MoralesEsteban et al.", "startOffset": 94, "endOffset": 114}, {"referenceID": 43, "context": "For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al.", "startOffset": 19, "endOffset": 39}, {"referenceID": 33, "context": "For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.", "startOffset": 109, "endOffset": 127}, {"referenceID": 18, "context": ", MetaTrader, MetaStock, NinjaTrader, and Microsoft\u2019s StreamInsight (Chandramouli et al., 2010).", "startOffset": 68, "endOffset": 95}, {"referenceID": 10, "context": "Another tool designed to help analysts is Stat! (Barnett et al., 2013), an interactive tool enabling analysts to write queries in StreamInsight.", "startOffset": 48, "endOffset": 70}, {"referenceID": 9, "context": "TimeFork (Badam et al., 2016) is an interactive tool that helps analysts with predictions based on automatic analysis of the past stock price.", "startOffset": 9, "endOffset": 29}, {"referenceID": 6, "context": "CPL (Anand et al., 2001) is a Haskell-based high-level language designed for chart pattern queries.", "startOffset": 4, "endOffset": 24}, {"referenceID": 47, "context": "SASE (Wu et al., 2006) is a system designed for RFID (radio frequency identification) streams that offers a user-friendly language and can handle large volumes of data.", "startOffset": 5, "endOffset": 22}, {"referenceID": 16, "context": "Cayuga (Brenna et al., 2007) is a system for detecting complex patterns in streams, whose language is based on Cayuga algebra.", "startOffset": 7, "endOffset": 28}, {"referenceID": 32, "context": "SPL (Hirzel et al., 2013) is IBM\u2019s stream processing language supporting pattern detections.", "startOffset": 4, "endOffset": 25}, {"referenceID": 45, "context": "ActiveSheets (Vaziri et al., 2014) is a platform that enables Microsoft Excel to process real-time streams from within spreadsheets.", "startOffset": 13, "endOffset": 34}, {"referenceID": 17, "context": ", Gulwani (2010); Lau et al.", "startOffset": 2, "endOffset": 17}, {"referenceID": 17, "context": ", Gulwani (2010); Lau et al. (2003); Das Sarma et al.", "startOffset": 2, "endOffset": 36}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 32}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 59}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al.", "startOffset": 12, "endOffset": 75}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al.", "startOffset": 12, "endOffset": 98}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al.", "startOffset": 12, "endOffset": 124}, {"referenceID": 13, "context": "(2003); Das Sarma et al. (2010); Harris and Gulwani (2011); Gulwani (2011); Gulwani et al. (2012); Singh and Gulwani (2012); Yessenov et al. (2013); Albarghouthi et al.", "startOffset": 12, "endOffset": 148}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al.", "startOffset": 8, "endOffset": 35}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al.", "startOffset": 8, "endOffset": 57}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al.", "startOffset": 8, "endOffset": 78}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al.", "startOffset": 8, "endOffset": 101}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)).", "startOffset": 8, "endOffset": 123}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)).", "startOffset": 8, "endOffset": 151}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 810}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al.", "startOffset": 8, "endOffset": 841}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al.", "startOffset": 8, "endOffset": 861}, {"referenceID": 3, "context": "(2013); Albarghouthi et al. (2013); Zhang and Sun (2013); Menon et al. (2013); Le and Gulwani (2014); Barowy et al. (2015); Polozov and Gulwani (2015)). Commonly, PBE algorithms synthesize programs consistent with the examples, which may not capture the user intent. Some works, however, guarantee to output the target program. For example, CEGIS (Solar-Lezama, 2008) learns a program via equivalence queries, and oracle-based synthesis (Jha et al., 2010) assumes that the input space is finite, which allows it to guarantee correctness by exploring all inputs (i.e., without validation queries). Synthesis has also been studied in a setting where a specification and the program\u2019s syntax are given and the goal is to find a program over this syntax meeting the specification (e.g., Solar-Lezama et al. (2008); Singh and Solar-Lezama (2011); Alur et al. (2013); Bornholt et al. (2016)).", "startOffset": 8, "endOffset": 885}], "year": 2017, "abstractText": "LetF be a set of boolean functions. We present an algorithm for learningF\u2228 := {\u2228f\u2208Sf | S \u2286 F} from membership queries. Our algorithm asks at most |F| \u00b7OPT(F\u2228) membership queries where OPT(F\u2228) is the minimum worst case number of membership queries for learning F\u2228. When F is a set of halfspaces over a constant dimension space or a set of variable inequalities, our algorithm runs in polynomial time. The problem we address has practical importance in the field of program synthesis, where the goal is to synthesize a program that meets some requirements. Program synthesis has become popular especially in settings aiming to help end users. In such settings, the requirements are not provided upfront and the synthesizer can only learn them by posing membership queries to the end user. Our work enables such synthesizers to learn the exact requirements while bounding the number of membership queries.", "creator": "LaTeX with hyperref package"}}}