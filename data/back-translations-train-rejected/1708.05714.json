{"id": "1708.05714", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Aug-2017", "title": "A Stronger Foundation for Computer Science and P=NP", "abstract": "This article constructs a Turing Machine which can solve for $\\beta^{'}$ which is RE-complete. Such a machine is only possible if there is something wrong with the foundations of computer science and mathematics. We therefore check our work by looking very closely at Cantor's diagonalization and construct a novel formal language as an Abelian group which allows us, through equivalence relations, to provide a non-trivial counterexample to Cantor's argument. As if that wasn't enough, we then discover that the impredicative nature of G\\\"odel's diagonalization lemma leads to logical tautology, invalidating any meaning behind the method, leaving no doubt that diagonalization is flawed. Our discovery in regards to these foundational arguments opens the door to solving the P vs NP problem.", "histories": [["v1", "Fri, 18 Aug 2017 22:36:07 GMT  (136kb,D)", "http://arxiv.org/abs/1708.05714v1", "21 pages, 1 figure"]], "COMMENTS": "21 pages, 1 figure", "reviews": [], "SUBJECTS": "cs.CC cs.AI cs.LO", "authors": ["mark inman"], "accepted": false, "id": "1708.05714"}, "pdf": {"name": "1708.05714.pdf", "metadata": {"source": "CRF", "title": "A Stronger Foundation for Computer Science and P=NP", "authors": ["Mark Inman"], "emails": ["mark.inman@egs.edu"], "sections": [{"heading": null, "text": "This article constructs a Turing machine that can solve \u03b2 \u2032"}, {"heading": "1 Turing\u2019s Proof on the Entscheidungsproblem has", "text": "A fatal mistake"}, {"heading": "1.1 Overview", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1.1.1 Context", "text": "His motivation was the logic problem known as the decision problem, which raises the question of whether there is an algorithm that can determine whether a first-order logic input is valid or invalid. However, he did not provide the actual construction of such a machine, but only its possibility to exist. His proof then depends on the fact that this H-machine is unable to validate itself. He gives a detailed description of why it cannot validate itself. However, a closer reading of his paper shows an additional assumption by Turing when he constructs his H-machine. While this assumption does not affect the design or effectiveness of a universal Turing machine, it has an effect on the overall result."}, {"heading": "1.1.2 Preliminary Considerations", "text": "The terms Circular Machine and Circle-free Machine are appropriate for our description, and we will use Turing's own definition of a calculator. It is convenient to point out here that Turing considers a Circular Machine to be unsatisfactory because it has an infinite loop, redundant from a repetitive pattern. Turing also considers a Circle-free Machine to be satisfactory because it can continue to decide indefinitely without entering an infinite loop. We have chosen to maintain Turing's original terminology for clarity purposes when comparing the work of this article with that of Turing's original paper. We also choose its terminology because Turing's description of the maintenance problem is entirely mechanical, while many modern descriptions rely on an oracle, Cantor's diagonalization or logic similar to Go-del's Diagonalization Lemma. Turing's description is independent from these reductions as a mechanical process. This helps the reader compare this article directly with the original."}, {"heading": "1.1.3 Turing\u2019s Claim", "text": "Turing claims that H is circular by construction, but if H is given the description number for H, it becomes circular. [7] In the eighth section of Turing's essay on the decision problem, Turing claims that \u03b2 \"cannot be determined for the following reason:\" The instructions for calculating R (K) -th [figure] would amount to \"calculating the first R (K) -th numbers calculated by H and writing down R (K) -th.\" This R (K) -th would never be found. I.e. H is circular... \"[7] This is because H, in determining it relies on certain subroutines when it reaches K and tries to evaluate it, must call itself, which provides instructions for reading inputs from 1 to K-1 to call the R (K) -th figure, but can never get there because it repeats its own instruction loop [7]."}, {"heading": "1.1.4 Turing\u2019s False Assumption", "text": "Turing assumed that there is no program that can recognize itself arbitrarily and move into a circular state after this realization. He assumed that each program would have to be programmed in such a way that, when it reads itself and calls its own instructions, it must be circular when it tries to determine whether it is circular or not, as described in the previous subsection. However, this is not necessarily the case, and if we can provide an example of a program that recognizes itself arbitrarily so that it can switch to a circular state, then we have found a way to write an H machine in such a way that it can solve \u03b2. The question then is whether there is a Turing machine that can recognize itself arbitrarily when it reaches its own description number (D.N.) so that any H machine configuration \u03b2 prints out?"}, {"heading": "1.2 The Existence of Self-validating Computers", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "1.2.1 Supermachine", "text": "Consider that H \"is a controller machine with a D.N. of K.\" It controls two different H machines: H0 and H1. H0 and H1 each have the ability to detect \"u\" or \"s\" on a D.N. input, except H0 tests as Turing describes, counting from D.N 1 upwards (each D.N is a natural number) and H1 tests from a particular two-pack of any number that is tested by H0 as parallel input, so its subsequent D.N is one less than the previously tested D.N Let us represent each D.N by some integral number i. H0 and H1 have a unique D.N of K0 or K1 respectively. 2Upon input of i0 to be read by H0, let H \"store the value pair\" (i0, z) until i0 determines whether the output is satisfactory or unsatisfactory."}, {"heading": "1.3 Consequences", "text": "If Turing were right, it would be impossible to find a solution to this issue. As we have solved \u03b2 ', we must consider the possibility that there is a problem with our configuration that makes it impossible, or that something is fundamentally wrong with our current foundations of mathematics. Therefore, in the next section we will continue to examine Kantor's Diagonal Argument, whose method Turing is equivalent in that they can reduce the same results to each other. If there is nothing fundamentally wrong with the foundations of mathematics and computer science, we should expect that there will be no counter-examples to the CDA or will be trivial. However, if we can find counter-examples of arbitrary solutions, such solutions will not be trivial and amplify the results of this first section on the decision problem."}, {"heading": "2 A Non-Trivial Counterexample to Cantor\u2019s Diag-", "text": "Onealizing argument"}, {"heading": "2.1 Overview", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.1.1 Method and Foundations", "text": "Conventional thinking about CDA is that we would need a completely new axiom scheme to find a counter-example to the CDA method [2]. However, no new axioms are required in this article to find a counter-example to CDA. In this section, we will introduce a new grammar to generate a formal language for the representation of an \u03c9-regular language through recognized foundations of set theory and the principles of formal languages. To examine logical consistency, we cannot directly assume that CDA is a method that produces theorems, nor can we rely on theorems derived from CDA, or theorems that are reduced to it. This includes Turing's proof of the decision problem, as discussed in a permeable section, that CDA is a method that produces theorems, and we cannot rely on theorems derived from CDA downwards Lowenheim-Scolem Theorem, which are derived from a hierarchy, or the results of complexity."}, {"heading": "2.2 Representing an \u03c9-language by a Recursively Enumerable Language", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.2.1 Notation and Preliminaries", "text": "Definition Let's let the natural numbers of N. Definition Let's define the rank of N by which von Neumann's hierarchy is defined. Definition Let's let the natural numbers of N and the cardinality of each set of bijective to N.Definition A \u03c9 expansion is an unlimited expansion of symbols on a string of symbols Lim. Definition An iteration of symbols, however, has gone through an unlimited series of symbols, e.g., so that the cardinality of the series of symbols represented by the number of iterations must include an unlimited expansion of symbols. Definition An iteration of symbols has an unlimited series of repetitions of symbols in a string that has a symbol or the empty string. Definition Let's let's exhaustion be a necessary change in the output of such a repetition of symbols where s is the symbol at the end of the string."}, {"heading": "2.2.2 A Grammar for a Language in T", "text": "The foundations for working in generative grammars and our understanding of computer syntax laid down Chomsky, Backus and Naur with the Backus-Naur form and the Chomsky hierarchy among other means of representing and categorizing generative grammar structures. Here, we use formal language theory to generate the following grammar, which results in a context-sensitive language that can be recursively enumerated \u2212 \u2212. [3] Definition Let the grammar LT B (B) be a tuple, {V, \u2211, R, S, B, S}. S-V, \u2211 2, \u2211 3, \u2211 4 \u0432, so that: V ctuings = GOP, V, T, A, B, B, B, C, C, C, C, Q, Q, U, \u2211 2 = L, 0, 0, 0, 0, B, 1, [Lemberg], 2 = {0.1, 1, 1, 1, [1]}, A, B, B, Africa, [only] \u2192 \u2192 \u2192 \u2192 \u2192 \u2192 \u2192 \u2192, are districtable, we are districtable, the elements of 1, 1, T, 1, 1, 1, 1, B, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1"}, {"heading": "2.2.3 Addition in \u03c1\u2217", "text": "wUS1 (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (PLUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (PLUS) (PLUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (wUS) (PLUS) (PLUS) (wUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (2 PLUS) (wUS) (wUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 PLUS) (1 (1) (1) (1) (1) (1) (1) (1) (1) (1 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1 (1) (1) (1) (1) (1 (1) (1) (1) (1) (1) (1 (1) (1) (1) (1) (1) (1 (1) (1) (1) (1 (1) (1) (1) (1) (1 (1) (1) (1) (1 (1) (1) (1) (1) (1) (1 (1) (1) (1) (1) (1) (1 (1) (1) (1) (1"}, {"heading": "2.3 A Non-trivial Counterexample to Cantor\u2019s Diagonal Argument", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2.3.1 Formalizing a Diagonal Argument Function", "text": "For Cantor's diagonal argument, one can generalize an argument function for proof by contradiction by inserting an arbitrary sequence of infinite length strings in any order into a N-N matrix of symbols and considering all rows of the matrix as exceptions, but then proceeding to the ithcolumn, the jth line of the matrix, where (i, j) moves along the diagonal of the matrix - (1,1), (2,2), (3,3)... etc. The symbol at this position is then changed to another symbol within the language of the system and concatenated to create a new string constructed in such a way that the new string of symbols cannot be found in any row or column of the matrix, thus providing a string of a value that is not listed in the matrix. The new string is considered transcendental in the Cantor universe, and the proof tells us by contradiction that a larger string of a string cannot be calculated in the universe."}, {"heading": "2.3.2 Additional Notations and Preliminaries", "text": "Consider evidence by inconsistency as an argumentation function f (S) over a series of S (S) to which we will apply an argumentation function f (S) (S)."}, {"heading": "2.3.3 Theorem", "text": "\u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0. \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0. \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0 \u00b0"}, {"heading": "2.4 Discussion", "text": "We can easily generalize this counter-example for all elements by choosing the appropriate order of the elements used to construct the diagonal. Finding such a non-trivial counter-example to CDA leads to a new understanding of the limits of predictability, and these results confirm the error found in the decision problem. It would be wise for logicians, mathematicians and computer scientists to revise all their texts accordingly. However, I recognize that this is quite an ordeal, so we will go a step further, beyond what would be required of any other essay or result, and provide a third argument, since it refers to Goedel's diagonalization lema, a third method that differs from the two already discussed but is reducible to the same result."}, {"heading": "3 Go\u0308del\u2019s Diagonalization Lemma is Not Logically", "text": "Quota"}, {"heading": "3.1 Some Impredicative Statements Reduce to Circular Logic", "text": "An unpredictable statement is a statement with an example of an unpredictable definition. We would not accept the logical statement as true, but only as a fact that invalidates a proposition, but, as we will show, a certain class of unpredictable statements are intrinsically circulating and tautologically. Such circular logic is not well formed to prove a statement that depends on its circular nature, and is therefore not logically contentententent.In this section we will show that Go-del's diagonalization of Lemma is within this class of unpredictable statements. We will then verify this problem and show that its use of substitution is not strict enough for a strong foundation in logic. In addition, we will actually construct the numbers that are suitable for its proof, and perform the operations to see if actually such an arithmetic statement lies outside a system, Q.First, we must determine a means to identify when a tautology is unpredictable in a definition."}, {"heading": "3.2 Go\u0308del\u2019s Diagonalization Lemma Depends on a Tautological Impredicative", "text": "Go \ufffd del's diagonalization Lemma states that there is a proposition that is provable in Q, where o # (\u0441) is the Go \ufffd del number and F is some well-formed formula that is provable in a formal system. It is clear that the statement with respect to \u0430 is a tautological imreditative, as Go \ufffd del deduces from the following evidence."}, {"heading": "3.2.1 Go\u0308del\u2019s Diagonalization Lemma", "text": "The question we can ask ourselves is whether there is a formula that can refer to this formula (F (n) that we use to replace this process with the function (F (x)) (o), and that it is possible that n (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o), the condition (o, the condition (o), the condition (o, the condition (o), the condition (o), the condition (o, the (o), the condition (o), the condition (o, the (o), the condition (o), the condition (o, the (o), the condition (o, the (o), the (o, the (o), the condition (o, the (o), the condition (o, the (o), the condition (o, the (o), the condition (o, the (o, the), the condition (o (o, the (o), the (o, the (o), the condition (o, the (o, the), the (o, the), the (o (o, the), the (o (o, the), the (o, the (o, the (o, the), the condition (o, the (o, the), the (o, the (o, the (o, the), the (o, the (o, the), the (o, the (o, the), the (o, the (o, the (o, the), the (o, the (o, the (o, the), the (o, the), the (o, the), the (o"}, {"heading": "3.2.2 Q ` \u03a8\u2194 F (o#(\u03a8)) is a Tautological Impredicative", "text": "Let the formal system Q be represented by the statement S in Q. Let o # (x) be the property P (x) so that Q'bay \u2194 F (o # (B): = S'bay \u2194 F (P (A))), then \u2194 S'z [F (z) \u0445 S (k, k, z)], since k \u2194 P (x) and z \u2194 k \u2192 P (P (x), then P (x) \u2194 P (P (x)) \u2192 z, which proves our first condition of tautological unpredictability. If you do, then P (x) and P (x) \u2194 P (P (x)) \u2192 z, then you will find that P (x) \u2192 P (P (x)) \u2192 z, i.e. P (z) \u2012 P (x) \u2192 P (deaf) \u2012 P (P (x) \u2012 implant, which is not satisfactory."}, {"heading": "3.2.3 Discussion", "text": "The answer to such a question may be a matter of opinion. Either it is okay to prove the existence of a statement that is a logical tautology in a formal system, or it is not. If it is, I believe, we would also have to assume that it would be difficult to prevent such a tautology, or that tautologies must be desirable in a consistent system. However, because tautologies are not desirable, since they open systems to paradox, irrelevance, and contradiction, I believe that it would be a higher opinion to seek a rule that invalidates their existence in a consistent system; that any system that can prove tautologies is actually inconsistent. Such a rule is relatively easy to find. It seems that unless one can offer an additional example than that provided by Go Biel, that tautologies in a formal system like Q are only possible through the abuse of substitutions."}, {"heading": "4 Conclusion, P=NP", "text": "While only one method was really necessary, through three new, independent and rigorous methods, we were able to deconstruct one of the most important foundations of mathematics and computer science."}], "references": [{"title": "On a decision method in restricted second order arithmetic", "author": ["J.R. B\u00fcchi"], "venue": "Proc. International Congress on Logic, Method, and Philosophy of Science", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1960}, {"title": "Introduction to Formal Systems and Computation CS121", "author": ["Lewis", "Harry"], "venue": "Harvard College December 2007 http://www.seas.harvard.edu/courses/cs121", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "Introduction to the Theory of Computation, 3rd ed", "author": ["M. Sipser"], "venue": "Cengage Learning,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Axiomatic Set Theory Mineola", "author": ["Suppes", "Patrick"], "venue": "NY: Dover Publications,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1972}], "referenceMentions": [{"referenceID": 1, "context": "Conventional thought on CDA is that we would need an entirely new axiom schema to find a counterexample to the method [2].", "startOffset": 118, "endOffset": 121}, {"referenceID": 2, "context": "[3]", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "[1]", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1", "startOffset": 111, "endOffset": 116}, {"referenceID": 0, "context": "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1", "startOffset": 121, "endOffset": 126}, {"referenceID": 0, "context": "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1", "startOffset": 134, "endOffset": 139}, {"referenceID": 0, "context": "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1", "startOffset": 144, "endOffset": 149}, {"referenceID": 0, "context": "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]", "startOffset": 117, "endOffset": 122}, {"referenceID": 0, "context": "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]", "startOffset": 127, "endOffset": 132}, {"referenceID": 0, "context": "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]", "startOffset": 141, "endOffset": 146}, {"referenceID": 0, "context": "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]", "startOffset": 174, "endOffset": 179}, {"referenceID": 2, "context": "[3] The following construction maps the set \u03c1\u2217 with equivalent strings in P, showing that the diagonal argument applied to a special ordering of subsets in P, yields a non-trivial counterexample to Cantor\u2019s argument function.", "startOffset": 0, "endOffset": 3}], "year": 2017, "abstractText": "This article constructs a Turing Machine which can solve for \u03b2 \u2032 which is REcomplete. Such a machine is only possible if there is something wrong with the foundations of computer science and mathematics. We therefore check our work by looking very closely at Cantor\u2019s diagonalization and construct a novel formal language as an Abelian group which allows us, through equivalence relations, to provide a non-trivial counterexample to Cantor\u2019s argument. As if that wasn\u2019t enough, we then discover that the impredicative nature of G\u00f6del\u2019s diagonalization lemma leads to logical tautology, invalidating any meaning behind the method, leaving no doubt that diagonalization is flawed. Our discovery in regards to these foundational arguments opens the door to solving the P vs NP problem. 1 Turing\u2019s Proof on the Entscheidungsproblem has", "creator": "LaTeX with hyperref package"}}}