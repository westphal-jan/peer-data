{"id": "1708.06665", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Aug-2017", "title": "Software engineering and the SP theory of intelligence", "abstract": "This paper describes a novel approach to software engineering derived from the \"SP theory of intelligence\" and its realisation in the \"SP computer model\". These are the bases of a projected industrial-strength \"SP machine\" which, when mature, is anticipated to be the vehicle for software engineering as described in this paper. Potential benefits of this new approach to software engineering include: the automation of semi-automation of software development, with non-automatic programming of the SP system where necessary; allowing programmers to concentrate on 'real-world' parallelism, without worries about parallelism to speed up processing; the ambitious long-term goal of programming the SP system via written or spoken natural language; reducing or eliminating the distinction between 'design' and 'implementation'; reducing or eliminating operations like compiling or interpretation; reducing or eliminating the need for verification of software; reducing the need for an explicit process of validation of software; no formal distinction between program and database; potential for substantial reductions in the number of types of data file and the number of computer languages; benefits for version control; and reducing technical debt.", "histories": [["v1", "Fri, 18 Aug 2017 19:27:49 GMT  (42kb,D)", "http://arxiv.org/abs/1708.06665v1", null]], "reviews": [], "SUBJECTS": "cs.SE cs.AI", "authors": ["j gerard wolff"], "accepted": false, "id": "1708.06665"}, "pdf": {"name": "1708.06665.pdf", "metadata": {"source": "CRF", "title": "Software engineering and the SP theory of intelligence", "authors": ["J Gerard Wolff"], "emails": ["jgw@cognitionresearch.org;"], "sections": [{"heading": null, "text": "Keywords: SP Theory of Intelligence, Software Development, Automatic Programming, Natural Language Processing, Compilation, Interpretation, Verification, Validation, Parallel Processing, Version Control, Technical Debt. \u043a Dr. Gerry Wolff, BA (Cantab), PhD (Wales), CEng, MBCS, MIEEE; CognitionResearch.org, Menai Bridge, UK; jgw @ cognitionresearch.org; + 44 (0) 1248 712962; + 44 (0) 7746 290775; Skype: gerry.wolff; Web: www.cognitionresearch.org.1ar Xiv: 170 8.06 665v 1 [cs.S E] 18 Aug 2"}, {"heading": "1 Introduction", "text": "This paper is about a novel approach to software development with potential advantages over standard approaches. It is a considerable revision, extension and development of preliminary ideas in [24, Section 6.6], and summarizes some ideas scattered in other publications. The novelty of the approach is that it is derived from the SP system, a radically new alternative to conventional computers that includes SP intelligence theory and its implementation in the SP computer model. It is intended that these two things will form the basis for an industry-strong SP machine that would be the vehicle for software development, as described in this paper. There is a sketch description of the SP system in Appendix A. With hints where more complete information can be found. The potential advantages of the SP system in software development are described and discussed in most of the following sections."}, {"heading": "2 How concepts in the SP system relate to con-", "text": "On the surface, the functioning of the SP system, as described in Appendix A.1, is very different from the functioning of an ordinary computer. However, this section shows with a few simple examples that with corresponding SP patterns, most of the concepts known in ordinary programming can be modeled in the SP system."}, {"heading": "2.1 Programs, procedures, functions, subroutines, call-", "text": "In fact, the fact is that most of them are able to survive themselves, by seeing themselves able to survive themselves, and that they are able to survive themselves, by seeing themselves able to survive themselves, and that they are able to survive themselves, and that they are able to survive themselves, and that they are able to survive themselves, \"he said in an interview with the\" New York Times. \""}, {"heading": "2.2 Unordered parameters", "text": "Parameters for a conventional program sometimes work like the example in Section 2.1, where the values for parameters must be specified in the correct order to ensure that each program is applied in the right place. However, for other types of programs there is flexibility in arranging the parameters because a label for each value ensures that it is applied correctly. This kind of flexibility can be modeled in the SP system, such as the grammar shown in Figure 3 and the grammar shown in Figure 6.In grammar, each of the possible values for the slot \"ST... # ST\" is given the symbol pair \"< P1 >... < / P1 >\" (meaning \"Parameter 1\") and also for the possible values in the other two slots: values for \"MC... # MC\" are provided with \"New Plt; P2 > P2 >\" (\"Parameter 2\") and values for \"PD # PD # PD.\""}, {"heading": "2.3 Variables, values, and types", "text": "In addition to the programming concepts already considered, the terms \"variable,\" \"value\" and \"type\" in the SP system can be modeled. For example, consider SP grammar in Figure 5. This is an extension of the \"salad\" main course entry in the grammar in Figure 1. Rather than simply specifying the name of the dish, this grammar provides for the selection of ingredients in four categories: lettuce leaves (\"L... # L\"), root vegetables (\"R... # R\"), side dishes (\"G... # G\") and dressing (\"D... # D\"). If the SP computer model is executed with the new pattern \"MC 2 1 0 1 # MC\" and old patterns that include the patterns shown in Figure 5, the best SP multiplex alignment generated by the SP computer model shown in Figure 6.This example illustrates the three terms \"variable,\" \"\" value \"and\" variable \"type,\" are # G within the pattern: G \u2022 G."}, {"heading": "2.4 Structured programming", "text": "An established feature of today's software development, which is now partially but not fully subsumed by object-oriented programming (next), is \"structured programming,\" [4] where the central idea is that programs should have well-defined structures that reflect the structure of the data to be processed and should never use the \"goto\" instruction of an earlier era. SP system largely integrates these principles of structured programming, since unattended learning in SP system creates structures that reflect the structure of the incoming data, and other types of processing in SP system, such as pattern recognition or reasoning, are achieved by recognizing and processing similar structures in new data without using anything like a \"goto\" instruction."}, {"heading": "2.5 Object-oriented design or programming", "text": "Since its introduction in the computer language Simula [1], \"object-oriented design\" (OOD) and closely related \"object-oriented programming\" (OOP) have been common in software development and in programming languages as widespread as C + + and Java. Key ideas in OOD / OOP are that the structure of each computer program should reflect the objects it is related to - people, packages, forklifts, etc. - and the classes and subclasses to which each object belongs. This not only helps to understand computer programs easily, but also means that the properties of each specific object can be \"inherited\" from the classes and subclasses to which it belongs. The same applies to all other objects in a particular class, meaning that there is a general storage or compression of information compared to what would be needed without inheritance. In this respect, the OOD / OOP unit very much corresponds to the central importance of information compression in the system hierarchy SP."}, {"heading": "2.6 Recursion", "text": "The SP system does not provide for the repetition of procedures over this type of statement: during..., do..., for..., or repeat... until.... But the same effect can be achieved by recursion as in Figure 8.In the figure, the symbols \"a6 b1 b1 c4 d3\" in the new row 0 (\"pg a6 b1 c4 # pg\") can be considered parameters for SP \"program\" 11 or grammar for this example, as in Section 2.1."}, {"heading": "3 The full or partial automation of software de-", "text": "This and the following main parts are intended to describe the potential advantages of the SP system in software engineering over software engineering with conventional computers. This section covers the complete or partial automation of software and the associated problem of software generalization and how to avoid undergeneralization and overgeneralization.12"}, {"heading": "3.1 Automation of software development", "text": "Assuming that the SP machine (Appendix A.5) has been developed to provide robust capabilities for unattended learning with both one-dimensional and two-dimensional SP patterns, and assuming that the remaining problems in this area have been solved (Appendix A.4), the SP machine is likely to prove useful in both automatic and semi-automatic creation of software. The former is discussed here and the latter will be discussed in the next section. In the context of the concept of \"structured programming,\" it has been recognized for some time that the structure of the software should reflect the structure of the data it is supposed to process [4]. This fits well with the observation that in forms of unattended learning, such as grammatical conclusions, the structure of the resulting grammar should reflect the structure of the object designed in the structure of the system. \""}, {"heading": "3.1.1 Example: learning in an autonomous robot", "text": "Perhaps the best example of how the SP system can facilitate automatic programming are autonomous robots, which continuously learn through their senses, just as humans do. [22] In this context, the ever-growing knowledge of the robot, together with any built-in motivations, provides the basis for many potential conclusions ([18, Chapter 7], [20, Section 10]) and, perhaps more importantly in the current context, the creation of one or more plans ([18, Chapter 8], [20, Section 12]), each of which can be considered a program for controlling robot activities. [2] See, for example, \"Programming by Example,\" Wikipedia, bit.ly / 2uMyVYP; \"Programming by Demonstration,\" Wikipedia, bit.ly / 2v3phy8; \"Inductive Logic of Programming,\" Wikipedia, bit.ly / 2ttwBpn; \"Programming by Subversion,\" Wikipedia, bit.ly / 2uMyVYP; \"Programming by Demonstration,\" bit.ly / 2v3phy8; \"Inductive Logic of Programming,\" Wikipedia, bit.ly / 2v3phy8; \"Inductive Programming by Subversion,\" and \"automation,\" could be described in two sections, \"Automatization,\" and \"by 13P.\""}, {"heading": "3.1.2 Example: processing data received by the SKA", "text": "Fully automatic creation of software should be possible in situations where there is a data body that represents the entire problem or a realistic large sample of it. An example is the large amounts of data that the Square Kilometre Array (SKA) 3 collects after its completion. With data such as this, unattended learning by the SP machine should form grammars that represent units and classes of units - such as stars and galaxies - at least in two dimensions and possibly in three dimensions. And, its grammars should also include \"procedural\" or \"process\" regularities in the time dimension. Any such grammar can be considered a \"program\" for analyzing similar types of data in the future. A neat feature of the SP system is that the SPMultiple Aligment construct not only serves unattended learning, but also, without modifications, in operations such as pattern recognition, reasoning, and more (Appendix B.2) may occur in connection with certain events, such as the SKA, which may necessarily occur during the course of application processing, or by the SKA, some data may be observed during the course of the SKA."}, {"heading": "3.1.3 Example: programming by demonstration", "text": "Another situation in which the SP machine can achieve fully automated software creation is with a robot programming technique called \"programming by demonstration.\" 4As an example, a person trained in any procedure to build a car (such as painting the front of the car) can take the \"hand\" of a robot and guide it through the sequence of actions required to complete the 3See, for example, \"Square Kilometre Array,\" Wikipedia, bit.ly / 2t16xxW, to retrieve 2017-07-15.4See, for example, \"Programming by Demonstration,\" Wikipedia, bit.ly / 2v3phy8, to retrieve 2017-07-15.14given operation. Here, signals from sensors in different parts of the robot arm, including the actuators or \"muscles,\" would be recorded and the recording would represent a preliminary type of \"program\" of the different positions of the arm and the actuators, which might be required by any of the provisional actuators, including those required by the provisional actuators."}, {"heading": "3.1.4 Possible augmentations", "text": "One assumption behind the two examples just described is that the grammar or program generated by unattended learning would do everything that is needed. This would probably be true in many cases. This is because of a neat feature of the SP system: that the SP multiple alignment subsystem is not only an important part of unattended learning, but is also the key to operations such as pattern recognition, different ways of thinking, retrieving information, and problem solving (Appendix B.2). In the SKA example (Section 3.1.2), these operations can be anything that is required. When programming by demonstration example (Section 3.1.3), the program created by unattended learning can function directly in controlling the robot arm. But the user of the SKA system might want to do things like show stars in red, galaxies in green, etc. And the user programming by demonstration system could add some ringing and playing sounds such as the sound of the robot."}, {"heading": "3.2 Semi-automatic creation of software", "text": "For some types of applications, it seems unlikely that the creation of relevant software could be fully automated in the foreseeable future - with knowledge of people, vehicles, furniture, parcels, warehouses, relevant rules and regulations, etc. Another example is the type of software required to manage a business - with knowledge of people, equipment, warehouses, relevant rules and regulations, etc. In the latter type of problem, there seems to be potential for the system to help refine man-made software by detecting redundancies in any 15 draft designs, and inconsistencies from one part of the design to another. Assuming that the software is developed using SP patterns and hosted on an SP machine (as described in Section 4), the SP machine can be a vehicle for verification and validation of the software as described in sections 9 and 10."}, {"heading": "3.3 Generalisation and the avoidance of under- and over-", "text": "GeneralizationIn general, any given computer program is more general than any set of examples it could process. For example, since we have considered the possibility that software can be created automatically or semi-automatically in the manner of unsupervised learning (Sections 3 and 3.2), we must consider how the system could be correctly generalized on the basis of the examples given, without under-generalization (sometimes referred to as \"over-adaptation\") or over-generalization (sometimes referred to as \"under-adaptation\").The SP system provides an answer that is outlined in [20, Section 5.3], 5 with some evidence. In short, it seems that a correct generalization can be achieved without under-generalization or over-generalization, as follows: 1. Given a body of raw data, I compress it as far as possible with the Unattended Learning program."}, {"heading": "4 Non-automatic programming of the SP system", "text": "If the automatic creation of software is not feasible, or if more than minor revisions are required with semi-automatically generated software, then something like ordinary programming is necessary. In principle, this can be done directly with SP patterns. But, mainly for human psychology reasons, it can be helpful if the programming environment, when the first symbol (\"NP\") is typed, automatically inserts the last balancing symbol (\"# NP\"). Unless or until programmers get used to how things work in the SP system, it can be helpful to create a programming environment in which SP concepts are presented in a manner similar to ordinary programming concepts, as in Section 2. \u2022 Ingredients of the object-oriented concept of a class hierarchy (Part 2.5) and parts of a specification of SP-5 are presented."}, {"heading": "5 Parallel processing in the real world and in the", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "SP machine", "text": "With the SP system, there is a need to distinguish sharply between two types of parallel processing: \u2022 Parallel processing in the real world \u2022 This is the kind of parallel processing that a cook could apply when he or she prepares the icing for a cake while the cake is baking in the oven, or which a pianist uses when he or she plays with both hands. This kind of parallel processing would be visible to the user of the SP machine and would be part of his or her thinking about the task in the hand.17 \u2022 Parallel processing in the workflows of the SP machine can be represented and executed by the use of two-dimensional SP patterns, as described in [22, Sections V-G, V-H and V-I and Appendix C.] In order to speed up the SP machine, parallel processing is intended to be used in the working environment of the SP machine, in such tasks as finding matches between patterns and the construction of multiple orientations."}, {"heading": "6 Programming via natural language", "text": "One of the strengths of the SP system lies in the processing of natural language, which is mentioned in Appendices B.1 and B.2 and described in more detail in [20, Section 8] and [18, Chapter 5]. Clearly, the SP system has potential for the development of writing processing and, ultimately, language on a human level, but there will be some difficult hurdles to overcome that will probably require a two-pronged attack: addressing problems in processing natural language along with problems in unattended learning of syntactic knowledge, semantic knowledge and syntactic-semantic associations [12, Sections 9 and 10]. If or when these problems are solved, there is potential for programming the SP system with written or spoken natural language, similar to the 6For a description of some of these problems see \"Parallel computing,\" Wikipedia, bit.ly / 1MPI5kA, retrieved 2017-08-10.18 persons."}, {"heading": "7 Bringing \u2018design\u2019 closer to \u2018implementation\u2019", "text": "It has been established for some time that in conventional software development, one should start with a relatively abstract design at a high level (which is often presented graphically) and then translate it into a work program. There seem to be three main reasons for this approach: \u2022 For any type of design, it is often useful to create a relatively abstract \"big picture\" before filling in details. \u2022 For the reasons described in Section 4, it can be useful to hide the details of a program behind syntactic sugar, which is more pleasant for programmers. \u2022 Even for high-level programming languages such as C + +, Python or Java, or \"declarative\" systems such as Prolog, it is often necessary to pay attention to the details of how the underlying machine will execute a program, details that are not relevant to the more abstract \"design\" of the software, with its focus on entities and processes that are important to the user. The SP system probably makes no difference for the first and the above-mentioned ways, but it is likely to be achieved with the third, or it is helpful with the reduction."}, {"heading": "8 Possible reductions in the need for operations", "text": "At first glance, the SP system eliminates the need to compile or interpret patterns, since it functions entirely by searching for complete or partial matches between SP patterns or pattern parts with corresponding uniformities. However, it is likely that in the development of the SP machine, indexing will be introduced to record the first match between a given symbol and any other symbol, thus speeding up the subsequent retrieval of the zero or more matching partners of the given symbol [12, Section 3.4]. And it is likely that similar measures will be introduced into the SP neuronal computer model [12, Section 13.2], a version of SP theory expressed in terms of neurons and their connections. Indexing of this kind is in some respects similar to the use of calculation or interpretation in a conventional computer system. Therefore, it would be misleading to suggest that the SP system would eliminate the need for such operations."}, {"heading": "9 Verification", "text": "The SP system has the potential to reduce the need for \"verification\" of software - i.e. processes to reduce or eliminate \"errors\" in the software through dynamic testing or static analysis - and there is corresponding potential to improve software quality. The main reasons for these potential benefits are: \u2022 The potential of the system for automatic or semi-automatic creation of software (Sections 3 and 3.2). To the extent that automatic or semi-automatic creation of software is possible, it should reduce or eliminate man-made errors in the software. \u2022 Potential reduction in the size of software systems. The potential of the system to reduce the overall size of software systems (Section 12) means that there are likely to be fewer opportunities to introduce errors into the software and probably fewer searches for detection of errors through static software analysis. \u2022 Bring the \"design\" closer to \"implementation.\""}, {"heading": "10 Validation", "text": "In addition to its potential in verification, the SP system has the potential to strengthen the process of \"validation\" in software development - i.e., to verify that each software fulfills its intended purpose. As with verification, the potential of the SP system in automatic or semi-automatic software creation means eliminating or reducing the types of human error that can derail a program.20Also, the potential of the SP system to bring \"design\" and \"implementation\" closer together (Section A.1) can mean that a program has fewer opportunities to move away from its original concept.11 Seamless integration of \"software\" with \"database\" In the SP system, all kinds of knowledge are represented by arrays of atomic symbols in one or two dimensions (Appendix A.1), and all types of processing are achieved through matching and standardization of patterns. For these two reasons, and because of the potential of universal artificial intelligence, \"there is no distinction between the SP and the conventional intelligence in the system."}, {"heading": "11.1 Hybrid systems", "text": "One limitation is that until arithmetic processing is provided in the SP system [20, Section 3.3], it may be necessary to provide such capabilities via a hybrid of a conventional arithmetic co-processor working in conjunction with an SP machine."}, {"heading": "12 An overall simplification of computing appli-", "text": "By and large, this potential stems from the way traditional software often includes repetitive procedures for searching for data, and similar \"low-level\" operations that are needed to overcome deficiencies in traditional CPUs. In an SP system, the \"CPU\" is relatively complex, but has fewer deficiencies than traditional CPUs, so this relative complexity is likely to be more than offset by simplifications in the software. This relative advantage is likely to grow roughly in proportion to the number of applications and their size. This type of idea is not new. In the early days of databases, each database had its own procedures for searching and retrieving information, and it had its own user interface and procedures for printing, and so on."}, {"heading": "13 Reducing the variety of formats and for-", "text": "As mentioned in Section 11, the SP system has potential for universal artificial intelligence. What this means in the SP research program and how the concept of a UAI differs from alternatives such as the concept of a universal Turing machine is discussed in Appendix B. If this expectation is indeed true and the evidence is convincing, there is a clear potential for the use of the SP machine to remove the curse of diversity in the thousands of different formats and formalities that exist for displaying data, and in the hundreds of different computer languages to describe how data can be processed (Appendix C)."}, {"heading": "14 Version control", "text": "In a typical software engineering project, there is a need to keep an eye on the parts and subsets of the development program, while at the same time keeping an eye on a hierarchy of versions and subversions, and in connection with each part or version, there may be several different types of documents, including a requirement statement, a high-level design, a flat design, and notes. To avoid embarrassing inconsistencies, these things should be integrated smoothly. 7The SP system provides a neat solution to the problem of integrating a class hierarchy with an integral hierarchy, as outlined above, as described in [20, Section 9.1] and [18, Section 6.4]. Although these sources do not support the point, it appears that the SP system also provides one or more associated documents for each version or part, as outlined above. 7The problem of integrating a class hierarchy with an integral hierarchy - a problem that is related to developing an \"Integrated Project or Part of Software Support\" (the multi-system version of the IPSE, as described above), is the problem with a multi-layer version of the S22."}, {"heading": "15 Technical debt", "text": "As mentioned in [24, Section 6.6.6], the SP system has the potential to reduce or eliminate the problem of \"technical debt,\" i.e. the way in which software systems can become increasingly uncontrollable over time, due to a accumulation of deferred or abandoned maintenance tasks or a progressive deterioration in the design quality or maintainability of the software by repeatedly applying \"bug fixes\" in response to short-term problems without taking sufficient account of their global and long-term effects. The SP system can reduce or eliminate the problem of technical debt by streamlining the process of software development through automatic or semi-automatic automation of software development, by narrowing the gap between design and implementation, by streamlining the processes of verification and validation and other facilities described in previous sections."}, {"heading": "16 Conclusion", "text": "It is as if this is the kind of thing that has happened time and again in the past."}, {"heading": "A Outline of the SP system", "text": "In fact, it is the case that most of them will be able to abide by the rules which they have imposed on themselves, and that they will be able to understand the rules which they have imposed on themselves. (...) In fact, it is the case that they are able to understand the rules which they have imposed on themselves. (...) \"\" It is indeed the case that they are able to understand the rules which they have imposed on themselves. (...) \"(...)\" (\") (\") (\") (\") (\") ((\") (\") (\") (() () () () (\") () () (\") () () () (\") () () () () () () () (\" () () () () () () () () () () () (\"() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) () () () () ()) () () () ()) () () () () () ()) () () () () () () () ()) () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (() () () () (() () (() () () (() () ((() (() () () (() ((() () ((() () ((() () () () () () (((() () (((() (() (() () () ((() (() (((() () (((() () ((() () ("}, {"heading": "B Towards universal artificial intelligence (UAI)", "text": "In fact, most of them will be able to move to another world, in which they are able, in which they are able to move, and in which they are able to change the world."}, {"heading": "C The curse of variety in computing and what", "text": "In fact, most of them are able to determine for themselves what they want and what they want."}], "references": [{"title": "Simula Begin", "author": ["G.M. Birtwistle", "O-J Dahl", "B. Myhrhaug", "K. Nygaard"], "venue": "Studentlitteratur, Lund", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1973}, {"title": "The Calculi of Lamda-Conversion", "author": ["A. Church"], "venue": "volume 6 of Annals of Mathematical Studies. Princeton University Press, Princeton", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1941}, {"title": "Cogprime: an integrative architecture for embodied artificial general intelligence", "author": ["B. Goertzel"], "venue": "Technical report, The Open Cognition Project", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Principles of Program Design", "author": ["M.A. Jackson"], "venue": "Academic Press, New York", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1975}, {"title": "Smart machines: IBM\u2019s Watson and the era of cognitive computing", "author": ["J.E. Kelly", "S. Hamm"], "venue": "Columbia University Press, New York, Kindle edition", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "Overcoming catastrophic forgetting in neural networks", "author": ["J. Kirkpatrick"], "venue": "Proceedings of the National Academy of Sciences of the United States of America, 114(13):3521\u20133526", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2017}, {"title": "An Introduction to Kolmogorov Complexity and Its Applications", "author": ["M. Li", "P. Vit\u00e1nyi"], "venue": "Springer, New York, 3rd edition", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "You can\u2019t play 20 questions with nature and win: projective comments on the papers in this symposium", "author": ["A. Newell"], "venue": "W. G. Chase, editor, Visual Information Processing, pages 283\u2013308. Academic Press, New York", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1973}, {"title": "editor", "author": ["A. Newell"], "venue": "Unified Theories of Cognition. Harvard University Press, Cambridge, Mass.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1990}, {"title": "Pr\u00e9cis of Unified Theories of Cognition", "author": ["A. Newell"], "venue": "Behavioural and Brain Sciences, 15(3):425\u2013437", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1992}, {"title": "Development of a new machine for artificial intelligence", "author": ["V. Palade", "J.G. Wolff"], "venue": "Technical report, CognitionResearch.org", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2017}, {"title": "Formal reductions of the general combinatorial decision problem", "author": ["E.L. Post"], "venue": "American Journal of Mathematics, 65:197\u2013268", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1943}, {"title": "A formal theory of inductive inference", "author": ["R.J. Solomonoff"], "venue": "Parts I and II. Information and Control, 7:1\u201322 and 224\u2013254", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1964}, {"title": "The discovery of algorithmic probability", "author": ["R.J. Solomonoff"], "venue": "Journal of Computer and System Sciences, 55(1):73\u201388", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1997}, {"title": "On computable numbers with an application to the Entscheidungsproblem", "author": ["A.M. Turing"], "venue": "Proceedings of the London Mathematical Society, 42:230\u2013265 and 544\u2013546", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1936}, {"title": "Medical diagnosis as pattern recognition in a framework of information compression by multiple alignment", "author": ["J.G. Wolff"], "venue": "unification and search. Decision Support Systems, 42:608\u2013625", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Unifying Computing and Cognition: the SP Theory and Its Applications", "author": ["J.G. Wolff"], "venue": "CognitionResearch.org, Menai Bridge", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "Towards an intelligent database system founded on the SP theory of computing and cognition", "author": ["J.G. Wolff"], "venue": "Data & Knowledge Engineering, 60:596\u2013624", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2007}, {"title": "The SP theory of intelligence: an overview", "author": ["J.G. Wolff"], "venue": "Information, 4(3):283\u2013 341", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "Application of the SP theory of intelligence to the understanding of natural vision and the development of computer vision", "author": ["J.G. Wolff"], "venue": "SpringerPlus, 3(1):552\u2013570", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Autonomous robots and the SP theory of intelligence", "author": ["J.G. Wolff"], "venue": "IEEE Access, 2:1629\u20131651", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Big data and the SP theory of intelligence", "author": ["J.G. Wolff"], "venue": "IEEE Access, 2:301\u2013 315, 2014. bit.ly/2qfSR3G. This paper, with minor revisions, is reproduced in Fei Hu (Ed.), Big Data: Storage, Sharing, and Security (3S), Taylor & Francis LLC, CRC Press", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2016}, {"title": "The SP theory of intelligence: benefits and applications", "author": ["J.G. Wolff"], "venue": "Information, 5(1):1\u201327", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2014}, {"title": "Commonsense reasoning, commonsense knowledge, and the SP theory of intelligence. 2016", "author": ["J.G. Wolff"], "venue": "Submitted for publication", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2016}, {"title": "The SP theory of intelligence: its distinctive features and advantages", "author": ["J.G. Wolff"], "venue": "IEEE Access, 4:216\u2013246", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2016}], "referenceMentions": [{"referenceID": 3, "context": "An established feature of software engineering today, which is now partly but not entirely subsumed by object-oriented programming (next), is \u2018structured programming\u2019 [4] in which the central idea is that programs should comprise well-defined structures which should reflect the structure of the data that is to be processed and should never use the \u2018goto\u2019 statement of an earlier era.", "startOffset": 167, "endOffset": 170}, {"referenceID": 0, "context": "From its introduction in the Simula computer language [1], \u2018object-oriented design\u2019 (OOD) and the closely-related \u2018object-oriented programming\u2019 (OOP) have become central in software engineering and in such widely-used programming languages as C++ and Java.", "startOffset": 54, "endOffset": 57}, {"referenceID": 18, "context": "Reproduced with permission from Figure 15 in [20].", "startOffset": 45, "endOffset": 49}, {"referenceID": 3, "context": "2, it has been recognised for some time, in connection with the concept of \u201cstructured programming\u201d, that the structure of software should mirror the structure of the data that it is designed to process [4].", "startOffset": 203, "endOffset": 206}, {"referenceID": 20, "context": "Perhaps the best example of how the SP system may facilitate automatic programming is in autonomous robots that learn continually via their senses, much as people do [22].", "startOffset": 166, "endOffset": 170}, {"referenceID": 20, "context": "At some point in the future, it is conceivable that knowledge about how a business operates may, at some stage, be built up by an intelligent autonomous robot of the kind described in [22] that is allowed to explore different areas of the business, observing the kinds entity and operation that are involved, asking questions, and so on.", "startOffset": 184, "endOffset": 188}, {"referenceID": 16, "context": "The SP system is described most fully in [18] and quite fully but more briefly in [20].", "startOffset": 41, "endOffset": 45}, {"referenceID": 18, "context": "The SP system is described most fully in [18] and quite fully but more briefly in [20].", "startOffset": 82, "endOffset": 86}, {"referenceID": 8, "context": "303] and his work on Unified Theories of Cognition [10]; and it is in keeping with the quest for \u201cArtificial General Intelligence\u201d (Wikipedia, bit.", "startOffset": 51, "endOffset": 55}, {"referenceID": 18, "context": "Adapted with permission from Figure 1 in [20].", "startOffset": 41, "endOffset": 45}, {"referenceID": 16, "context": "1 in [18].", "startOffset": 5, "endOffset": 9}, {"referenceID": 17, "context": "Adapted with permission from Figures 1 in [19].", "startOffset": 42, "endOffset": 46}, {"referenceID": 10, "context": "As mentioned earlier, it is envisaged that an industrial-strength SP machine will be developed from the SP theory and the SP computer model [12].", "startOffset": 140, "endOffset": 144}, {"referenceID": 24, "context": "Distinctive features of the SP system and its main advantages compared with AI-related alternatives are described in [26].", "startOffset": 117, "endOffset": 121}, {"referenceID": 5, "context": "A solution has been proposed in [6] but it appears to be partial, and it is unlikely to be satisfactory in the long run.", "startOffset": 32, "endOffset": 35}, {"referenceID": 21, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 65, "endOffset": 69}, {"referenceID": 20, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 150, "endOffset": 154}, {"referenceID": 19, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 258, "endOffset": 262}, {"referenceID": 17, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 319, "endOffset": 323}, {"referenceID": 15, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 382, "endOffset": 386}, {"referenceID": 23, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 436, "endOffset": 440}, {"referenceID": 22, "context": "htm: the SP system may help to solve nine problems with big data [23]; it may help in the development of human-like intelligence in autonomous robots [22]; the SP system may help in the understanding of human vision and in the development of computer vision [21]; it may function as a database system with intelligence [19]; it may assist medical practitioners in medical diagnosis [17]; it provides insights into commonsense reasoning [25]; and it has several other potential benefits and applications described in [24].", "startOffset": 516, "endOffset": 520}, {"referenceID": 14, "context": "The purpose of this appendix is to describe what this means and to distinguish the concept from alternatives such as a \u2018universal Turing machine\u2019 (UTM) [16].", "startOffset": 152, "endOffset": 156}, {"referenceID": 11, "context": "The idea that the SP system has potential for UAI may at first sight seem to be redundant since it has been recognised for some time that all kinds of computing may be understood in terms of the workings of a UTM or ideas which are recognised as equivalent such as Post\u2019s \u2018canonical system\u2019 [13], or Church\u2019s \u2018lambda calculus\u2019 [2], or indeed the many conventional computers that are in use today.", "startOffset": 291, "endOffset": 295}, {"referenceID": 1, "context": "The idea that the SP system has potential for UAI may at first sight seem to be redundant since it has been recognised for some time that all kinds of computing may be understood in terms of the workings of a UTM or ideas which are recognised as equivalent such as Post\u2019s \u2018canonical system\u2019 [13], or Church\u2019s \u2018lambda calculus\u2019 [2], or indeed the many conventional computers that are in use today.", "startOffset": 327, "endOffset": 330}, {"referenceID": 3, "context": "This problem was largely solved by the introduction of \u2018structured programming\u2019 (see, for example, [4]).", "startOffset": 99, "endOffset": 102}, {"referenceID": 19, "context": "These other aspects of intelligence include: analysis and production of natural language; pattern recognition that is robust in the face of errors in data; pattern recognition at multiple levels of abstraction; computer vision [21]; best-match and semantic kinds of information retrieval; several kinds of reasoning (more under the next bullet point); planning; and problem solving ([18, Chapters 5 to 8], []).", "startOffset": 227, "endOffset": 231}, {"referenceID": 12, "context": "The close connection that is known to exist between information compression and concepts of prediction and probability [14, 15, 7], the central role of information compression in the SP-multiple-alignment framework (Section A.", "startOffset": 119, "endOffset": 130}, {"referenceID": 13, "context": "The close connection that is known to exist between information compression and concepts of prediction and probability [14, 15, 7], the central role of information compression in the SP-multiple-alignment framework (Section A.", "startOffset": 119, "endOffset": 130}, {"referenceID": 6, "context": "The close connection that is known to exist between information compression and concepts of prediction and probability [14, 15, 7], the central role of information compression in the SP-multiple-alignment framework (Section A.", "startOffset": 119, "endOffset": 130}, {"referenceID": 9, "context": "Although Allen Newell called for the development of Unified Theories of Cognition [11, 10], and researchers in \u2018Artificial General Intelligence\u2019 are aiming for a similar kind of integration in AI, it appears that none of the resulting systems are fully integrated: \u201cWe have not discovered any one algorithm or approach capable of yielding the emergence of [general", "startOffset": 82, "endOffset": 90}, {"referenceID": 8, "context": "Although Allen Newell called for the development of Unified Theories of Cognition [11, 10], and researchers in \u2018Artificial General Intelligence\u2019 are aiming for a similar kind of integration in AI, it appears that none of the resulting systems are fully integrated: \u201cWe have not discovered any one algorithm or approach capable of yielding the emergence of [general", "startOffset": 82, "endOffset": 90}, {"referenceID": 4, "context": "in those floods of data [5, 8].", "startOffset": 24, "endOffset": 30}], "year": 2017, "abstractText": "This paper describes a novel approach to software engineering derived from the SP theory of intelligence and its realisation in the SP computer model. These are the bases of a projected industrial-strength SP machine which, when mature, is anticipated to be the vehicle for software engineering as described in this paper. Potential benefits of this new approach to software engineering include: the automation of semi-automation of software development, with non-automatic programming of the SP system where necessary; allowing programmers to concentrate on \u2018real-world\u2019 parallelism, without worries about parallelism to speed up processing; the ambitious long-term goal of programming the SP system via written or spoken natural language; reducing or eliminating the distinction between \u2018design\u2019 and \u2018implementation\u2019; reducing or eliminating operations like compiling or interpretation; reducing or eliminating the need for verification of software; reducing the need for an explicit process of validation of software; no formal distinction between program and database; potential for substantial reductions in the number of types of data file and the number of computer languages; benefits for version control; and reducing technical debt.", "creator": "LaTeX with hyperref package"}}}