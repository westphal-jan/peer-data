{"id": "1709.00084", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Aug-2017", "title": "Behavior Trees in Robotics and AI, an Introduction", "abstract": "A Behavior Tree (BT) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. In this book, we will first give an introduction to BTs, then we describe how BTs relate to, and in many cases generalize, earlier switching structures. These ideas are then used as a foundation for a set of efficient and easy to use design principles. Properties such as safety, robustness, and efficiency are important for an autonomous system, and we describe a set of tools for formally analyzing these using a state space description of BTs. With the new analysis tools, we can formalize the descriptions of how BTs generalize earlier approaches. Finally, we describe an extended set of tools to capture the behavior of Stochastic BTs, where the outcomes of actions are described by probabilities. These tools enable the computation of both success probabilities and time to completion.", "histories": [["v1", "Thu, 31 Aug 2017 21:05:18 GMT  (7737kb,D)", "http://arxiv.org/abs/1709.00084v1", null], ["v2", "Thu, 21 Sep 2017 07:33:32 GMT  (7737kb,D)", "http://arxiv.org/abs/1709.00084v2", null]], "reviews": [], "SUBJECTS": "cs.RO cs.AI", "authors": ["michele colledanchise", "petter \\\"ogren"], "accepted": false, "id": "1709.00084"}, "pdf": {"name": "1709.00084.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Petter \u00d6gren"], "emails": [], "sections": [{"heading": null, "text": "Personal data from the roboticists and the AIAn. Personal data from the roboticists and roboticists. Personal data from the roboticists. Personal data from the roboticists and roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists. Personal data from the roboticists."}, {"heading": "2 How Behavior Trees Generalize and Relate to Earlier Ideas . . . . . . . . . 23", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "4 Analysis of Efficiency, Safety, and Robustness . . . . . . . . . . . . . . . . . . . . . 55", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "5 Formal Analysis of How Behavior Trees Generalize Earlier Ideas . . . . 77", "text": "......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"}, {"heading": "1 http://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/ Behavior_trees_for_AI_How_they_work.php", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "2 http://aigamedev.com/open/article/fsm-age-is-over/", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "3 https://forums.unrealengine.com/showthread.php?6016-Behavior-", "text": "A Behavior Tree (BT) is a way to structure the transition between different tasks 1 in an autonomous agent, such as a robot or virtual entity in a computer game. An example of a BT can be seen in Fig. 1.1a. As explained, BT is a very efficient way to create complex systems that are both modular and reactive, properties that are critical in many applications, which has led to the spread of BT from computer game programming in many branches of AI and robotics. In this book, we will first give an introduction to BTs, in this chapter. Then, in Chapter 2, we will describe how BT relates to and in many cases generalizes previous switching structures, and then use these ideas as the basis for a series of efficient and easy-to-use tools described in Chapter 3. Properties such as safety, robustness and efficiency are important for an autonomous system in which we formally describe these approaches."}, {"heading": "1.1 A Short History of BTs", "text": "BTs were developed in the video game industry as a tool to increase modularity in the control structures of non-player characters (NPCs) [18, 7, 19, 25, 36]. In this billion dollar industry, modularity is a key attribute that enables code reuse, incremental design of functionality, and efficient testing. In games, the control structures of NPCs were often formulated in terms of finite state machines (FSMs), but just as Petri Nets [29] is an alternative to FSMs that support concurrency, BTs offer an alternative view of FSMs that support modularity."}, {"heading": "1.2 What is wrong with FSMs? The Need for Reactiveness and Modularity", "text": "In fact, it is that one is able to hide, and that one is able to turn to a place where one is able to move."}, {"heading": "1.3 Classical Formulation of BTs", "text": "Essentially, the BTs are built from a small set of simple components when they have reached categories that concern the goal of controlling two, but in this book we will see how this simple formalism can be used to create very rich structures, both in terms of applications and in theory. Formally, a BT is a guided root tree in which the internal nodes have at least one child. Graphically, the children of a node are placed below what is shown in Figures 1.2-1.4.A BT, its execution begins from the root node, which generates signals that enable the execution of a node with a predetermined frequency to be sent to its children. A node is executed when and only when it is executed Tick. The child immediately returns to his parents when its execution takes place under the root node, which allows the execution of a node with a predetermined frequency to be sent to his children."}, {"heading": "1.3.1 Execution Example of a BT", "text": "Consider the BT in Figure 1.6, which is designed so that an agent looks for a ball, approaches it, grabs it, goes to a trash and puts the ball in the trash. This example illustrates the execution of the BT, including the reactivity when another (external) agent takes the ball from the first agent so that the latter searches for the ball and approaches it again. As the execution begins, the ticks traverse the BT and reach the condition node ball found. The agent does not know the ball position, so the condition node knows the failures and the ticks reach the action ball that runs back (see Figure 1.7a). During the execution of this action, the agent sees the ball with the camera. In10 1 What are behaviors? this new situation where the agent knows the ball position, so the condition node ball found now achieves success, which causes the ticks to reach the action node no longer (see Figure 7a and the action will prevent the ball from reaching)."}, {"heading": "1.3.2 Control Flow Nodes with Memory", "text": "As seen in the above example, to provide reactivity, the control flow sequence and fallback nodes are repeatedly checked to the children to the left of a running child to check if a child needs to be run again and the current node needs to be prevented. However, sometimes the user knows that a child does not need to be run again after its execution. Nodes with memory [25] have been introduced to allow the designer to avoid the unwanted reexecution of some nodes. Control flow nodes with memory always remember whether a child has returned success or failure, and avoid re-running the child until the entire sequence or fallback is either successful or failed. In this book, nodes with memory are graphically represented by the addition of the \"\u0439\" symbol (e.g. a sequence node with memory is graphically represented by a field with a \"\u2192 named node.\" The memory is deleted if the parent node succeeds or all of them fail, so that the next one is enabled."}, {"heading": "1.4 Creating a BT for Pac-Man from Scratch", "text": "The source code of all examples is publicly available and editable, see Appendix A. We use a clone of Namco's Pac-Man computer game, the inFigure 1.93. In the test environment, a BT steers the agent, Pac-Man, through a labyrinth that contains two ghosts, a large number of pills, including two so-called Power Pills. The goal of the game is to consume all the pills without being eaten by the ghosts. The Power Pills are such that Pac-Man gets temporary super powers and is able to eat the ghosts. The Power Pills are such that Pac-Man gets the temporary super powers, and the greed pills are eaten."}, {"heading": "1.5 Creating a BT for a Mobile Manipulator Robot", "text": "In this section we create a series of BTs to control a mobile manipulator. The source code of all examples is publicly available and can be edited. In the scenario, there are several colored cubes lying on the surface. The goal is to move the green cube while avoiding the other cubes."}, {"heading": "1.6 Use of BTs in Robotics and AI", "text": "In this section, we describe the use of BTs in a range of real-world robot applications and projects, ranging from autonomous navigation to industrial robotics."}, {"heading": "1.6.1 BTs in autonomous vehicles", "text": "There is no standard CA for autonomous vehicles, however the CAs that were used to tackle the DARPA Grand Challenge, an autonomous vehicle competition, are reviewed, we note that most teams used FSMs designed and developed specifically for this challenge.1.6 The use of BTs in robotics and AI 17iQmatic is a Scania-led project that aims to develop a fully autonomous heavy vehicle, i.e. a truck, for freight transportation, mining and other industrial applications. The vehicle's software must be reusable, maintainable and easy to develop. For this reason, the developers of iQmatic chose BTs as the CA for the project. BTs are valued in iQmatic for their human readability that supports the design and 4 Picture courtesy of Scania.com18 1 What are Behavior Trees? development of early prototypes; and their maintainability that facilitates the processing of the two clauses used in the illustration 17."}, {"heading": "1.6.2 BTs in industrial robotics", "text": "In fact, future generations of industrial robots will operate in less structured environments and will work closely with humans. Several research projects are exploring this area of research. CoSTAR is a project that aims to develop a software framework that includes tools for industrial collaboration, with use cases involving untrained operators who perform complex behaviors. BTs have found successful applications in this project, while simplifying the composition of sub-tasks."}, {"heading": "1.6.3 BTs in the Amazon Picking Challenge", "text": "The Amazon Picking Challenge (APC) is an international robot competition where robots must independently remove a wide range of products from a shelf and place them in a container. It was designed with the aim of strengthening the links between industrial and academic robot research and promoting common solutions to some of the outstanding problems in unstructured automation. Over thirty companies and research laboratories from different continents competed against each other in the preparatory stages of the APC. The highest performing teams were given the right to participate in the finals and the source codes of the finalists were made public. KTH's contribution to the final challenge used BTs in both editions (2015 and 2016). BTs were valued for their modularity and reusability of the code, enabling the integration of different functionalities developed by programmers with different backgrounds and coding styles. In 2015, the KTH contribution achieved the best result among the four teams competing with PR2 robots."}, {"heading": "1.6.4 BTs inside the social robot JIBO", "text": "JIBO is a social robot that can recognise faces and voices, tell jokes, play games and share information. It is designed for household use and offers the functionality of a tablet, but with a user interface based on speech and video rather than a touch screen. BTs are a fundamental part of JIBO12 \"s software architecture, including an open SDK that invites external collaborators to develop new skills for the robot.12 https: / / developopers.jibo.com / docs / behavior-trees.html22 1 What are behavioural trees? Chapter 2 How behavioural trees generalise and relate to earlier ideasIn this chapter we describe how BT relates to and frequently generalises a range of well-known control architectures, including finite state machines (2,1), subsumption architecture (2,2), teleo-reactive approach (2,3) and decision trees (2,4)."}, {"heading": "2.1 Finite State Machines", "text": "An FSM is one of the most basic mathematical calculation models. The FSM consists of a series of states, transitions and events, as shown in Figure 2.1, which shows an example of an FSM designed to perform a grab-and-throw task. Note that the discussion here applies to all CAs based on FSMs, including Mealy [27] and Moore [24] machines."}, {"heading": "2.1.1 Advantages and disadvantages", "text": "FSMs are widely used due to their three main advantages: \u2022 Very common structure, which is used in many different areas of computer science. \u2022 Intuitive and easy to understand. \u2022 Easy to implement. However, the disadvantages of FSMs cause problems when the modelled system increases in complexity and number of states, as briefly described in Section 1.2. In particular, we have the following disadvantages \u2022 Compromises in terms of reactivity / modularity. A reactive system requires many transitions, and each transition corresponds to a goto-statement, see Section refsec: Modularity. In particular, the transitions lead to the following problems: - Maintainability: Adding or removing states may require a reassessment of all transitions and internal states of the entire FSM. This makes FSMs highly susceptible to human construction errors and makes them inefficient to be used and generated by computer programs. - Scalability: FSMs with many states and many transitions between them are difficult to modify, both for computers and for use in practice."}, {"heading": "2.1.2 Hierarchical Finite State Machines", "text": "Hierarchical Finite State Machines (HFSM), also known as State Charts [16], are designed to mitigate some of the disadvantages of FSMs. In an HFSM, a state can in turn contain one or more sub-states; a state with two or more sub-states is referred to as a super-state; in an HFSM, a generalized transition is a transition between super-states. Generalized transitions can reduce the number of transitions by connecting two super-states rather than connecting a larger number of sub-states individually; each super-state has a substate that is identified as the source state and whenever a transition to the super-state takes place. Figure 2.2 shows an example of a HFSM for a video game character."}, {"heading": "2.1.2.1 Advantages and disadvantages", "text": "This year, it is closer than ever before in the history of the country."}, {"heading": "2.1.3 Creating a FSM that works like a BTs", "text": "Imagine if we had a state in an FSM that has 3 transitions, corresponding to these 3 return instructions. Add a tick source that collects the return transitions and transfers the execution back to the state, as shown in Figure 2.5, we have a structure that is a BT. We can now assemble such FSM states using both fallback and sequence constructs. FSM, which corresponds to the fallback example in Figure 2.6, would then look like the FSM shown in Figure 2.7, which corresponds to the sequence example in Figure 2.8, would then look like the two-level FSM code shown in Figure 2.9, as shown in Figure 2.10, would look like the FSM shown in Figure 2.11.A some observations can be made from the above examples."}, {"heading": "2.1.4 Creating a BT that works like a FSM", "text": "If you have an FSM design and want to convert it to a BT, the easiest way is to create a state variable that is available to all parts of the BT, and then list all states of the FSM and the corresponding transitions and actions as shown in Figure 2.13."}, {"heading": "2.2 Subsumption Architecture", "text": "The Subsumption Architecture [4] is strongly associated with the behavior-based robot architecture, which was very popular in the late 1980s and 1990s and has found a number of successful applications. [5] The basic idea of the Subsumpion Architecture is that several controllers, each performing a task, run in parallel. Each controller is allowed to output both its operating commands and a binary value indicating whether it wants to control the robot or not. Controllers are ordered by priority (usually user-defined), and the controller with the highest priority that wants to control the robot has access to the actuators. Thus, a higher priority controller is able to subsume a lower level. Figure 2.14 shows an example of a subsumption architecture."}, {"heading": "2.2.1 Advantages and disadvantages", "text": "The Subsumption Architecture has many practical advantages, in particular: 2.2 Subsumption Architecture 33 \u2022 Easy Development: The Subsumption Architecture is, of course, well suited for iterative development and testing. \u2022 Modularity: The Subsumption Architecture combines limited task-specific actions. \u2022 Hierarchy: Controllers are hierarchically ordered, making it possible to define high-priority behaviors (e.g. security guarantees) that override others. \u2022 Scalability: Designing complex action choices through a distributed system of inhibition and suppression can be difficult. \u2022 Maintainability: Due to the lack of structure, the consequences of adding or removing controllers are difficult to assess."}, {"heading": "2.2.2 How BTs Generalize the Subsumption Architecture", "text": "If each controller in the SA is converted to a BT action and executed, if the binary output indicates that it wants to run and fail the rest of the time, a standard fallback composition generates an equivalent BT. As an example, the structure in Fig. 2.14 is represented by the BT in Fig. 2.15. A more formal argument using a state space representation of BTs is given in Section 5.2.34."}, {"heading": "2.3 Teleo-Reactive programs", "text": "The mento-reactive (TR) programs were introduced in 1994 by Nils Nilsson [31] at Stanford University to allow engineers to define the behavior of a robot system that had to achieve certain goals while simultaneously reacting to changes in the environment. A TR program consists of a set of prioritized Conditional Action Rules that guide the agent toward a target state (hence the term teleo) while monitoring environmental changes (hence the term reactive). In its simplest form, a TR program is described by a list of Conditional Action Rules as follows: c1 \u2192 a1 c2 \u2192 a2 \u00b7 cm \u2192 where the ci conditions and ai actions are. The list of Conditional Action Rules is scanned from above until it finds a condition that holds, then the corresponding action is executed. In a TR program, actions are usually permanent and not discrete."}, {"heading": "2.3.1 Advantages and disadvantages", "text": "The main advantages of a TR program are: \u2022 Reactive execution: TR programs enable reactive execution by continuously monitoring conditions and aborting actions if necessary. \u2022 Intuitive structure: The list of rules for the condition action is to be designed intuitively for small problems. The main disadvantages of a TR program are: \u2022 Maintainability: Due to its structure (a long list of rules), adding or removing rules for the condition action tends to cause errors when a TR program has to encode a complex system. In these cases, a TR program takes the form of a long list. \u2022 Error handling: To enable failure management, a TR program must have a condition that checks if an action fails. 2.3.2 How to generalize BT's Teleo-Reactive programs The basic idea of continuously checking conditions and applying the corresponding rules can be captured by a fallback node and pairs of conditions and actions."}, {"heading": "2.4 Decision Trees", "text": "A Decision Tree (DT) is a directional tree that represents a list of nested if-then clauses used to derive decisions [37]. Leaf nodes describe decisions, conclusions, or actions 36 2 How behavior trees generalize and refer to earlier ideasto, while non-leaf nodes describe predicates to be evaluated. Figure 2.18 shows a DT where a robot decides under certain conditions what to do."}, {"heading": "2.4.1 Advantages and disadvantages", "text": "The main advantages of a DT are: \u2022 Modularity: The DT structure is modular in the sense that a sub-DT can be developed and added independently of the rest of the DT. \u2022 Hierarchy: The structure of a DT is hierarchical in the sense that predicates are evaluated from top to bottom. \u2022 Intuitive structure: It is easy to design and understand DT. The main disadvantages of a DT are: \u2022 No flow of information from the nodes, which prevents error handling. \u2022 Repetitions: To describe a reactive behavior, a given predicate must be adapted at different depths of the tree, which results in a DT with many repetitions. \u2022 Maintenance: If the number of outgoing slurs of a predicate changes, this affects the entire tree where such predicates appear."}, {"heading": "2.4.2 How BTs Generalize Decision Trees", "text": "By converting the predicate to a state where the sheets are executed over and over again, we can map every decision node of the DT to a small BT. Applying the mapping to the DT of Fig. 2.18, we get the BT of Fig. 2.20. A more formal argument using a statespace representation of the BTs is given in Section 5.1. Note that this structure requires actions to be performed over and over again, which reflects the disadvantage of the DTs that no information from the story38 2 generalizes like behavioral trees and relates to earlier ideas."}, {"heading": "2.5 Advantages and Disadvantages of Behavior Trees", "text": "Having looked at how BTs relate to a number of existing control architectures, we will now take a step back and list a number of advantages and disadvantages of BTs."}, {"heading": "2.5.1 Advantages", "text": "This year it is more than ever before."}, {"heading": "2.5.2 Disadvantages", "text": "In this section we will describe some of the drawbacks of BTs experienced by different BTs. BTs can be implemented in a complex way, and implementing BTs can be complicated by programming individual threads sequentially.In order to guarantee the full functionality of BTs, generation and traversal must be performed in parallel to action executation.BTs only need to be implemented once, and multiple BTs are available, as if they were coming from the shelf of the software library.The BTs must meet several conditions in order to implement the closed-loop task execution."}, {"heading": "3.1 Improving Readability using Explicit Success Conditions", "text": "One advantage of BTs is that the switching structure is clearly represented in the tree graphical representation. However, one detail that is not represented is when the individual actions bring back success and failure. 4546 3 Design Principles Consider the sequence in Figure 3.1. One can assume that Enlock Door succeeds if it has unlocked the door, but what if it is called when the door is already unlocked? Depending on the implementation, it could either succeed immediately or actually try to unlock the door again, with the possibility of returning a failure if the key cannot be turned any further. Similar uncertainty applies to the implementation of Open Door (what if the door is already open?) and Pass through Door. To solve this problem and eliminate uncertainties about implementation, explicit conditions for success in the BTs can be set. In Figure 3.2, the BT from Figure 3.1 has been expanded to include explicit conditions for success. These conditions are added in a pair of action with a corresponding back."}, {"heading": "3.2 Improving Reactivity using Implicit Sequences", "text": "It turns out that we can further improve the reactivity of the BT in Figure 3.2 by taking advantage of the fact that the BT in Figure 3.2 generalizes the telereactive approach, see Section 2.3.2. Consider the case when the agent has already passed the door but the door behind it is closed. BT in Figure 3.2 would then proceed to unlock the door, open it, and then determine that it has already passed it and successfully returned.3.4 The key observation necessary to improve the reactivity is to recognize that the goal is to get through the door, and that the other actions are only means to achieve that goal. In BT in Figure 3.3, we reversed the sequence of actions to check the target state first. We then changed the fallbacks to the sequences and vice versa, and finally changed the conditions. Rather than reviewing the results or reviewing the success conditions, as we did in Figure 3.2, we review the conditions to execute the appropriate measures that are required."}, {"heading": "3.3 Handling Different Cases using a Decision Tree Structure", "text": "The fact that BT's decision trees generalize can then be exploited, see Section 2.4.2. A simple Pac-Man example can be found in Figure 3.4. Cases are separated by the two conditions Ghost Close and Ghost Scared. If no ghost is near, Pac-Man continues to eat tablets. If a ghost is near, BT checks the second condition, Ghost Scared, which proves true when Pac-Man eats a power pill. If the ghost is afraid, PacMan chases it, if not, Pac-Man avoids the ghost."}, {"heading": "3.4 Improving Safety using Sequences", "text": "These undesirable situations can be so simple that they do not reach the charging station until they run out of battery, or so serious that they fall down a flight of stairs and injure someone. A sequence node can be used to ensure safety, as shown in Fig. 3.5. Taking a closer look at the BT in Fig. 3.5, we see that it is likely to lead to undesirable chatting behavior. It recharges until it reaches just over 20%, and then begins with the main task, but stops once the battery is back at 20%, and possibly ends with 48 3 Design Principle Shading, i.e. fast switching between the two tasks. The solution is to make sure that the robot waits after charging until the battery is back at 100%. This can be achieved by creating Deliberative BTs with Backchaining 49 in Fig. 3.6.3.5."}, {"heading": "3.5 Creating Deliberative BTs using Backchaining", "text": "We will use an example to see how this happens. Let's imagine we have a series of small BTs like the ones in Figures 3.8 and 3.9, which are each successful in the format of the general post-condition precondition action (PPA) BT in Figure 3.11. If we have such a set, we can move backwards from the target (backchaining) by replacing the preconditions with the corresponding post-condition action (PPA). If we replace the individual conditions in Figure 3.7 with Figure 3.8, we will get Figure 3.8."}, {"heading": "3.6 Creating Un-Reactive BTs using Memory Nodes", "text": "As already mentioned in Section 1.3.2, once a child has been executed, it does not need to be re-run for the entire execution of a task. Memory control nodes are used to simplify the design of a BT to avoid the unwanted re-execution of some nodes. Use of memory nodes is recommended only for cases where there is no unexpected event that reverses the execution of the sub-tree in a composition with memory, as in Example 3.1 below. Example 3.1 (Memory nodes). Consider the behavior of an industrial manipulator in a production line, which must select, move and place objects. The actions of the robot are performed in a fixed working area, with high precision. Human operators ensure that nothing changes on the line. If they require a change in the line, the software is updated accordingly manually. In this example, the robot works in a structured environment that is completely predictable in space and time. In this case, we can make sure that any unexpected change in the BT is not accompanied by the desired behavior of the object."}, {"heading": "3.7 Choosing the Proper Granularity of a BT", "text": "In a BT frame, this is translated into selecting what should be considered a leaf node: \u2022 Module to reuse: It is advisable to aggregate a behavior in a leaf node if this behavior needs to be reused in different parts of the tree or in different projects. As in an example 3.2 below. \u2022 Module that needs to be reexecuted due to unexpected changes in the environment: It is advisable to regain behavior in a leaf node if this behavior is reused in other parts of the tree."}, {"heading": "4.1 Statespace Formulation of BTs", "text": "In this section we present a new formulation of BTs."}, {"heading": "4.2 Efficiency and Robustness", "text": "In this section, we will show how some aspects of time efficiency and robustness need to be achieved to measure effectiveness."}, {"heading": "4.3 Safety", "text": "In this section we will show how some aspects of security in the areas of security, security, security, security, security, security etc. in the areas of security, security, security, security, security etc. in the areas of security, security, security, security, security, security etc. in the areas of security, security, security, security, security, security, security, safety, security, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, security, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, safety, security, safety, safety, security, safety, safety, security, safety, security, safety, safety, safety, safety, safety, safety, safety, safety, etc."}, {"heading": "4.4 Examples", "text": "In this section, we will show some sample BTs and analyze their characteristics. Section 4.4.1 illustrates how to analyze the robustness and efficiency of a robot performing a generic task. Section 4.3 illustrates the calculation of safety using the functional representation of Section 4.1. Section 6.4 illustrates how to calculate the performance estimate of a given BT. Finally, Section 4.4.3 illustrates the characteristics of a complex BT. All BTs were implemented with the ROS BT package.1 A video showing the execution of the BTs used in Section 4.4.2-4.1 is publicly available. 2"}, {"heading": "4.4.1 Robustness and Efficiency", "text": "To illustrate Lemma 4.3, we look at the BT of Figure 4.9, which controls a NAO robot, then we actually apply this combination to 4.3. < The BT has three sub-trees Walk Home, which are tried first, if this does not succeed (the robot cannot walk if it does not get up), it tries to activate the sub-tree Sit to Stand, and if that fails, it tries to lie down on Sit Up. < Each fallback action brings the system into the running region of the action to the left, e.g. the result of Sit to Stand is to activate the execution of Walk Home.4. Let xk = (x1k, x2k), where x1k [0,0.5] the horizontal position of the robot head and x2k is the vertical position (height above the ground) of the robot head. The goal of the robot is to get to the target (0,0.48).First, we describe the sets, Si, Ri, and the corresponding oration fields."}, {"heading": "4.4.2 Safety", "text": "The idea is that the first sub-tree in the sequence (called \"Guarantee Power Supply\") is to guarantee that the second part of the battery (called \"Guarantee Power Supply\") does not fail, while the second level (called \"Guarantee Power Supply\") implements the sets Si, Fi, Ri and the associated vector fields of functional representation. Then, we apply \"Lemma 4.5\" to see that the combination actually guarantees against battery leakage. Example 4.5: Let's leave \"Guarantee Power Supply\" and \"T2 be Do other tasks.\" < Let's continue to apply xk = (x2k), where x1k [0,100] is the distance from the current position to the charging station and x2k [0,100] is the battery level."}, {"heading": "4.4.3 Complex BT", "text": "In fact, it is in such a way that we see ourselves in a position to move into another world, in which we see ourselves in a position in which we are, and in which we put ourselves in another world, in which we are in a position in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are but in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are, but in which we are, in which we are in which we are in which we are, in which we are in which we are in which we are, in which we are in which we are in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we are, in which we are in which we, in which we are in which we, in which we are in which we are, in which we are, in which we are in which we, in which we are in which we are, in which we are, in which we are in which we are, in which we are in which we are, in which we are, in which we are in which we are, in which we are, in which we are in which we are, in which we are, in which we are in which we are, in which we are in which we are, in which we are, in which we are in which we are in which we are, in which we are, in which we are in which we are in which we are, in which we are, in which we are in which are in which are in which we are, in which we are in which are in which we are, in which we are in which are in which we are in which are in which we are in which we are in which we are, in which we are in which we are in which we are in which we are in which are in which we are in which are, in which we are in which we are in which we are, in which are in which we are in which we are in which we are in which are in which we are in which we are in which are in which we are in which are in which are"}, {"heading": "5.1 How BTs Generalize Decision Trees", "text": "In fact, it is the case that most of them are able to abide by the rules they have applied in practice, and that they are able to abide by the rules they have applied in practice. (7) In practice, it is the case that they are able to abide by the rules. (7) In practice, it is the case that they are able to abide by the rules. (7) In practice, it is as if they were able to break the rules. (8)"}, {"heading": "5.2 How BTs Generalize the Subsumption Architecture", "text": "In this section we will see how the Subsumption architecture, proposed by Brooks [4], can be realized by using a fallback composition. [4] The basic idea in a80 was 5 Formal Analysis of How Behavior Trees Generalize Early Ideasnumber of controllers set in parallel and each controller was allowed to output both actuator commands and a binary value indicating whether or not it wanted to control the robot. Controllers were then ordered according to a certain priority, and the highest priority of the controller signing up for the action was allowed to control the robot, allowing a higher controller to subsume the actions of a lower level."}, {"heading": "5.3 How BTs Generalize Sequential Behavior Compositions", "text": "In this section we will see how the fallback composition, and Lemma 4.3, can also be used to implement the Sequential Behavior Compositions proposed in [6]. The basic idea proposed by [6] is to expand the region of attraction by using a family of controllers in which the asymptotically stable balance of each controller is either the target state or region of attraction of another controller positioned earlier in the sequence. We will now describe the construction of [6] in some detail and then see how this concept is captured within the BT framework. Given a family of controllers U = {\u03a6i}, 82 5 Formal Analysis of How Behavior Trees Generalize Early Ideaswe say that the approach is being prepared."}, {"heading": "5.4 How BTs Generalize TRs", "text": "s TRs TRs 83Lemma 5.4 (TR-BT analogy). Given a TR in terms of conditions ki and actions ai, an equivalent BT can be constructed as followsTT R = Fallback (Sequence (c1, a1),., Sequence (cm, am)), (5,8) where we convert the True / False of Conditions into Success / Failure, and only trace the actions back Running.Proof. It is easy to see that the BT above executes exactly the same as the original TR, depending on the values of the ci conditions, i.e. it finds the first condition ci that brings success, and executes the appropriate tool."}, {"heading": "5.4.1 Universal TRs and FT-Successful BTs", "text": "The idea of proof is indeed urgent, but we shall see that it is a pioneering version of Lemma 5.5, which also contains a series of assumptions. (...) It will not be a matter of whether it is a pure problem. (...) It will not be a matter of solving a pure problem. (...) \"It will not be a matter of solving a pure problem. (...)\" \"It will not be a matter of solving a pure problem. (...)\" (...) \"(...)\" (...) \"(...)\" (...) \"(...)\" (\") (()\" () () () \"() () ()\" () () () (() \"() () () () (() () () () () () () () () () (() () () () () () () () (() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (() () () () () (() () () () () (() (() () (() () () (() () ((() (() () () (() (() (() (() ((() (() ((() (() (() ((() (() ((() (() () () (() (() ((() () () (() (((((() () () (() (() ((() ((() (() (((() (() (() ("}, {"heading": "6.1 Stochastic BTs", "text": "In this section we will show how some probabilistic metrics, such as the term Mean Time to Succeed (MTTS), Mean Time to Fail (MTTF) and probability, can be applied over time to modular compositions of BTs. The advantage of using BTs lies in their modularity and hierarchical structure, which, as explained below, provides good scalability; these characteristics would be lost if the entire process from problem formulation to solution were carried out within the classical framework. To demonstrate the above characteristics, we need to introduce some concepts from Markov Theory.6.1 Stochastic BTs 89"}, {"heading": "6.1.1 Markov Chains and Markov Processes", "text": "The Markov theory [32] deals with memory-less processes. If a process is given by a sequence of actions that changes the state of the system taking into account its history, a DTMC is suitable to model the execution of the plan. If a process is given by a transition rate between states, a continuous behavior of the Markov chain (CTMC) is then suitable to model such a plan execution. A DTMC is given by a collection of states in which S = {s1, s2,. The stochastic sequence is n = 0,1,2,. A TMC is given by a collection of states, the S and the transition rates q \u2212 1i j between states si and s j. Definition 6.1,. The stochastic sequence is n = 0,1,2,.} a DTMC assuming that: P {Xn + 1 = sn, Xn \u2212 sn \u2212 1,."}, {"heading": "6.1.2 Formulation", "text": "We start with a formal definition of BTs, first introduced in Chapter 1. Definition 6.7. An action A in a BT is called success if there is a chance of success: \u2022 The probability of success is known for a time span that could be zero or not zero, then consistently returns to either success or failure, for the rest of the execution of its parents node1. \u2022 The probability of success and the probability of failure is known that the chances of success (t) and the probability of failure lead to failure f (t) and to failure f (t) are distributed exponentially with the following probability that the probability functions (PDFs) are successful: p (t) = ps\u00b5t (6.13) p (t) p (t) p (f) p (6.14) from which we can calculate the cumulative distribution functions (CDFs)."}, {"heading": "6.2 Transforming a SBT into a DTMC", "text": "The first step of our approach is to define for each control node in V a vector representation of the children's results and a description of their execution policy. < p > p > p > p > p > p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p (0) p) p (0) p (0) p) p (0) p (0) p (0) p) p (0) p (0) p) p (0) p) p (0) p) p (0) p (0) p) p (0) p (p) p (p) p (p) p (p) p (p) p (p) p) (p) p (0) p (p) p (0) p (0) p (0) p) p (0) p (0) p) p (0) p (0) p (0) p) p (0) p (0) p) p (0) p (0) p) p (0) p (p) p (p) p (0) p (p) p (p) p (p) p (p (p) p (p) p (p) p (p (p) p (p) p (p) p (p) p (p (p) p (p) p (p) p (p) p (p) p (p) p (p (p) p) p (p) p (p) p (p) p (p) p (p) p (p (p) p (p (p) p) (p (p) p) (p (p (p) p (p) (p) p (p) (p) p) p (p) p (p (p (p) p (p (p) p (p) p) p (p) (p (p) p (p) p (p) (p) p (p (p) p) p (p) p (p) p (p (p) p (p (p) p) p (p (p)"}, {"heading": "6.2.1 Computing Transition Properties of the DTMC", "text": "The RG of a BT node includes all achievable markers, the transitions between them describe events that have a certain probability of success / failure. We can then map the execution of the node to a DTMC where the states are the markers in the RG100 6 Stochastic BT, and the one-stage transition matrix P is given by the probability of jumping between the markers, with diagonal entries defined as follows: 6.3 Reliability of an SBT 101pi j = p, if m j \u2212 mi TMF (m j \u2212 mi) > 0 p, if m \u2212 f h, if m \u2212 mi \u2212 F (mi)."}, {"heading": "6.3 Reliability of a SBT", "text": "It is not the first time that the EU Commission has taken such a step."}, {"heading": "6.3.1 Average sojourn time", "text": "For a BT node with psi, p f i, \u00b5i, \u03bdi, specified for each child, the average dwell time in a marker is mi: 102 6 stochastic BTsSJi = (\u2211 h: eh F (mi) (psh \u00b5h + p f h) \u2212 1) \u2212 1 (6.40) with h: eh F (mi).Proof. Each marker describes one of the following events: the running child h fails or succeeds. To take into account both probabilities and time intervals influencing the average dwell time, we describe the execution of the child with an additional CTMC, represented in Fig. 6.11 Loud (6.9), the average dwell time in a marker is: \u03c4i = p f h\u00b5h + psh\u03bdh\u00b5h = psh \u00b5h + p f h h h."}, {"heading": "6.3.2 Mean Time To Fail and Mean Time To Succeed", "text": "To derive a closed form of the mean time to failure (MTTF) and the mean time to success (MTTS) of a BT node, we take the probability of achieving a successful (failed) state from the DTCM, and the average time spent in each state before this state is reached (6,40). We rearrange the state space of the DTMC so that the initial state is first the transient state, second is the default state, and the success states are the last: P > c = T 0 0RF I (6,43), where T is the matrix that describes the one-step transition from one transit state to another, RF is the matrix that describes the one-step transition from one transit state to a failure, and RS is the matrix that describes the one-step transition from one transit state to a success state."}, {"heading": "6.3.3 Probabilities Over Time", "text": "Since all markers of a BT node have a non-zero average residence time, the corresponding DTMC is an EMC of a CTMC with an infinitesimal generator matrix Q (t) in the sense of (6.7). Therefore, we can calculate the probability distribution of the node according to (6.8) with the initial condition \u03c00 = [1 0] >, which represents the state in which none of the children returned success / failure.6.3 Reliability of an SBT 105"}, {"heading": "6.3.4 Stochastic Execution Times", "text": "Proposition 6.1. Given an SBT with known probabilistic parameters for actions and conditions, we can calculate probabilistic measures for the rest of the tree as follows: For each node whose children know probabilistic measures, we calculate the associated DTMC. Now, the probability that a node will return success ps (t) (error p (t)) (error p (t))) (error p (t))) is given by the sum of the probabilities of the DTMC to be in a success (failure) state. If we leave SS (t) and SF (error) SA) = / 0.Then we have a set of success and failure states of a DTMC that relate to a node, i.e. those states that represent a marker in which the node returns success or failure (failure), with SF (t) = SA and SF (error) = / 0.Then we have a series of success and failure states of a DTMC (SS): (si) (Dsi) (DT):"}, {"heading": "6.3.5 Deterministic Execution Times", "text": "Since the formulation of the deterministic case includes the Dirac delta functions, see Equation (6,17) - (6,18), the above approach could lead to arithmetic difficulties. Alternatively, we can take advantage of the fact that we know the exact time of possible transitions. Thus, the probabilities of success and failure of a deterministic node (6,56) are unchanged in the intervals between the MT T F and the MT T T T S of its children.Example 6.6. Consider the faithful T = fallback (A1, A2) (6,56) 106 6 Stochastic BTS representation in Fig. 6.13 and let the ministerial ability (\u03c4Fi) the MT T F (MT T T T T S) of the action i and p f i (psi) its probability of failure (success).The probability of success / failure over time. The probability of success / failure over time of the time of the tree is represented as a discrete T function in 14.Hb."}, {"heading": "6.4 Examples", "text": "In this section we present three examples: the first example is the BT in Figure 6.15a, which is relatively small and allows us to show the details of each step; the second example is the deterministic time version of the same BT, which illustrates the differences between the two cases; the third example includes a more complex BT, which is shown in Figure 6.16. This example is used to numerically verify the approach by running Monte Carlo simulations and comparing the numerical results with the analytical ones, see Table 6.2 and Figure 6.19. It is also used to illustrate the difference in power metrics between two equivalent BTs, see Figure 6.21.We will now perform the calculation of the probability parameters for an example of SBPS7. Given the tree shown in Figure 6.15a, its probability parameters are given by evaluating the dorsal node as it is the child of the root node."}], "references": [{"title": "An Integrated System for Autonomous Robotics Manipulation", "author": ["J. Andrew (Drew) Bagnell", "Felipe Cavalcanti", "Lei Cui", "Thomas Galluzzo", "Martial Hebert", "Moslem Kazemi", "Matthew Klingensmith", "Jacqueline Libby", "Tian Yu Liu", "Nancy Pollard", "Mikhail Pivtoraiko", "Jean-Sebastien Valois", "Ranqi Zhu"], "venue": "In IEEE/RSJ International Conference on Intelligent Robots and Systems,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2012}, {"title": "Reacting, planning, and learning in an autonomous agent", "author": ["Scott Benson", "Nils J Nilsson"], "venue": "In Machine intelligence", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1995}, {"title": "Extending the JADE Agent Behaviour Model with JBehaviourtrees Framework", "author": ["Iva Bojic", "Tomislav Lipic", "Mario Kusek", "Gordan Jezic"], "venue": "In Agent and Multi-Agent Systems: Technologies and Applications,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "A Robust Layered Control System for a Mobile Robot", "author": ["R. Brooks"], "venue": "Robotics and Automation, IEEE Journal of,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1986}, {"title": "Elephants don\u2019t play chess", "author": ["R.A. Brooks"], "venue": "Robotics and autonomous systems,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1990}, {"title": "Sequential Composition of Dynamically Dexterous Robot Behaviors", "author": ["Robert R Burridge", "Alfred A Rizzi", "Daniel E Koditschek"], "venue": "The International Journal of Robotics Research,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1999}, {"title": "Understanding Behavior Trees", "author": ["A.J. Champandard"], "venue": "AiGameDev. com,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2007}, {"title": "Performance Analysis of Stochastic Behavior Trees", "author": ["Michele Colledanchise", "Alejandro Marzinotto", "Petter \u00d6gren"], "venue": "In Robotics and Automation (ICRA),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "How behavior trees modularize hybrid control systems and generalize sequential behavior compositions, the subsumption architecture, and decision trees", "author": ["Michele Colledanchise", "Petter \u00d6gren"], "venue": "IEEE Transactions on Robotics,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2017}, {"title": "Letters to the editor: go to statement considered harmful", "author": ["Edsger W. Dijkstra"], "venue": "Commun. ACM,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1968}, {"title": "Differential Equations with Discontinuous Righthand Sides: Control Systems", "author": ["A.F. Filippov", "F.M. Arscott"], "venue": "Mathematics and its Applications. Kluwer Academic Publishers,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1988}, {"title": "Bart - behavior architecture for robotic tasks, https://code.google.com/p/bart", "author": ["Thomas Galluzzo", "Moslem Kazemi", "Jean-Sebastien Valois"], "venue": "Technical report,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Product modularity: definitions and benefits", "author": ["JK Gershenson", "GJ Prasad", "Y Zhang"], "venue": "Journal of Engineering design,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2003}, {"title": "A teleo-reactive architecture for fast, reactive and robust control of mobile robots", "author": ["Gerhard Gubisch", "Gerald Steinbauer", "Martin Weiglhofer", "Franz Wotawa"], "venue": "In New Frontiers in Applied Artificial Intelligence,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2008}, {"title": "A framework for enduser instruction of a robot assistant for manufacturing", "author": ["Kelleher R. Guerin", "Colin Lea", "Chris Paxton", "Gregory D. Hager"], "venue": "In IEEE International Conference on Robotics and Automation (ICRA),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "Statecharts: A visual formalism for complex", "author": ["David Harel"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1987}, {"title": "Semi-autonomous simulated brain tumor ablation with raven ii surgical robot using behavior tree", "author": ["Danying Hu", "Yuanzheng Gong", "Blake Hannaford", "Eric J. Seibel"], "venue": "In IEEE International Conference on Robotics and Automation (ICRA),", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2015}, {"title": "Handling Complexity in the Halo 2 AI", "author": ["D. Isla"], "venue": "In Game Developers Conference,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2005}, {"title": "Halo 3-building a Better Battle", "author": ["Damian Isla"], "venue": "In Game Developers Conference,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2008}, {"title": "The Modelica BehaviorTrees Library: Mission planning in continuous-time for unmanned aircraft", "author": ["Andreas Kl\u00f6ckner", "Franciscus van der Linden", "Dirk Zimmer"], "venue": "In Proceedings of the 10th International Modelica Conference,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "Interfacing Behavior Trees with the World Using Description Logic", "author": ["Andreas Kl\u00f6kner"], "venue": "In AIAA conference on Guidance, Navigation and Control,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2013}, {"title": "Evolving Behaviour Trees for the Commercial Game DEFCON", "author": ["C.U. Lim", "R. Baumgarten", "S. Colton"], "venue": "Applications of Evolutionary Computation,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2010}, {"title": "Towards a Unified Behavior Trees Framework for Robot Control", "author": ["Alejandro Marzinotto", "Michele Colledanchise", "Christian Smith", "Petter \u00d6gren"], "venue": "In Robotics and Automation (ICRA),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2014}, {"title": "A method for synthesizing sequential circuits", "author": ["G.H. Mealy"], "venue": "The Bell System Technical Journal,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1955}, {"title": "Artificial intelligence for games", "author": ["Ian Millington", "John Funge"], "venue": "CRC Press,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2009}, {"title": "Junior: The stanford entry in the urban challenge", "author": ["Michael Montemerlo", "Jan Becker", "Suhrid Bhat", "Hendrik Dahlkamp", "Dmitri Dolgov", "Scott Ettinger", "Dirk Haehnel", "Tim Hilden", "Gabe Hoffmann", "Burkhard Huhnke"], "venue": "Journal of field Robotics,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "Gedanken-experiments on sequential machines", "author": ["Edward F Moore"], "venue": "Automata studies,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1956}, {"title": "Simplification Of Teleo-Reactive sequences", "author": ["Seyed R Mousavi", "Krysia Broda"], "venue": "Imperial College of Science, Technology and Medicine, Department of Computing,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2003}, {"title": "Petri nets: Properties, analysis and applications", "author": ["Tadao Murata"], "venue": "Proceedings of the IEEE,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1989}, {"title": "Evolutionary behavior tree approaches for navigating platform games", "author": ["M. Nicolau", "D. Perez-Liebana", "M. O\u2019Neill", "A. Brabazon"], "venue": "IEEE Transactions on Computational Intelligence and AI in Games,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2016}, {"title": "Teleo-reactive programs for agent control", "author": ["Nils J. Nilsson"], "venue": "JAIR, 1:139\u2013158,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1994}, {"title": "Markov Chains. Number no. 2008 in Cambridge Series in Statistical and Probabilistic Mathematics", "author": ["J.R. Norris"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1998}, {"title": "Increasing Modularity of UAV Control Systems using Computer Game Behavior Trees", "author": ["Petter \u00d6gren"], "venue": "In AIAA Guidance, Navigation and Control Conference,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2012}, {"title": "Costar: Instructing collaborative robots with behavior trees and vision", "author": ["Chris Paxton", "Andrew Hundt", "Felix Jonathan", "Kelleher Guerin", "Gregory D Hager"], "venue": "arXiv preprint arXiv:1611.06145,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2016}, {"title": "The Sting Racing Team\u2019s Entry to the Urban Challenge", "author": ["Matthew Powers", "Dave Wooden", "Magnus Egerstedt", "Henrik Christensen", "Tucker Balch"], "venue": "In Experience from the DARPA Urban Challenge,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2012}, {"title": "Game AI Pro, chapter 6. The Behavior Tree Starter Kit", "author": ["Steve Rabin"], "venue": "CRC Press,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2014}, {"title": "Imitation in Animals and Artifacts, chapter Learning to Fly, page 171", "author": ["Claude Sammut", "Scott Hurst", "Dana Kedzier", "Donald Michie"], "venue": null, "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2002}, {"title": "Parameterizing Behavior Trees", "author": ["Alexander Shoulson", "Francisco M Garcia", "Matthew Jones", "Robert Mead", "Norman I Badler"], "venue": "In Motion in Games. Springer,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2011}, {"title": "Probability, Markov chains, queues, and simulation: the mathematical basis of performance modeling", "author": ["William J Stewart"], "venue": null, "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2009}, {"title": "Autonomous driving in urban environments: Boss and the urban challenge", "author": ["Chris Urmson", "Joshua Anhalt", "Drew Bagnell", "Christopher Baker", "Robert Bittner", "MN Clark", "John Dolan", "Dave Duggins", "Tugrul Galatali", "Chris Geyer"], "venue": "Journal of Field Robotics,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2008}, {"title": "Tartan racing: A multi-modal approach to the darpa urban challenge", "author": ["Chris Urmson", "J Andrew Bagnell", "Christopher R Baker", "Martial Hebert", "Alonzo Kelly", "Raj Rajkumar", "Paul E Rybski", "Sebastian Scherer", "Reid Simmons", "Sanjiv Singh"], "venue": null, "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2007}, {"title": "Solving navigation tasks with learned teleo-reactive programs", "author": ["Blanca Vargas", "E Morales"], "venue": "Proceedings of IEEE International Conference on Robots and Systems (IROS),", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2008}], "referenceMentions": [], "year": 2017, "abstractText": null, "creator": "LaTeX with hyperref package"}}}