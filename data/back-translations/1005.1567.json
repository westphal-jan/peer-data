{"id": "1005.1567", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-May-2010", "title": "On The Power of Tree Projections: Structural Tractability of Enumerating CSP Solutions", "abstract": "The problem of whether CSP instances allow solutions has been extensively investigated in the literature, and several structural traceability results have been derived to date. However, satisfaction with constraints is considered in practice to be a calculation problem where the focus is either on finding a solution or on enumerating all solutions that may be projected via a given set of output variables; the paper examines the structural traceability of the problem of enumerating (possibly projected) solutions, with traceability here being calculated with polynomial delay (WPD), as generally many solutions can be calculated exponentially; a general framework is considered based on the notion of the traceability of hypergraphs, generalizing all known decomposition methods; traceability results have been obtained both for structure classes in which output variables are part of their specification, and for structural classes in which traceability must be ensured.", "histories": [["v1", "Mon, 10 May 2010 14:46:29 GMT  (57kb)", "http://arxiv.org/abs/1005.1567v1", null], ["v2", "Wed, 30 Jun 2010 14:05:01 GMT  (58kb)", "http://arxiv.org/abs/1005.1567v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["gianluigi greco", "francesco scarcello"], "accepted": false, "id": "1005.1567"}, "pdf": {"name": "1005.1567.pdf", "metadata": {"source": "CRF", "title": "On The Power of Tree Projections: Structural Tractability of Enumerating CSP Solutions", "authors": ["Gianluigi Greco", "Francesco Scarcello"], "emails": ["ggreco@mat.unical.it,", "scarcello@deis.unical.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n00 5.\n15 67\nv1 [\ncs .A\nI] 1\n0 M\nay 2\n01 0"}, {"heading": "1 Introduction", "text": ""}, {"heading": "1.1 Constraint Satisfaction and Decomposition Methods", "text": "Constraint satisfaction is often formalized as a homomorphism problem that takes as input two finite relational structures A (modeling variables and scopes of the constraints) and B (modeling the relations associated with constraints), and asks whether there is a homomorphism from A to B. Since the general problem is NP-hard, many restrictions have been considered in the literature, where the given structures have to satisfy additional conditions. In this paper, we are interested in restrictions imposed on the (usually said) left-hand structure, i.e., A must be taken from some suitably defined class A of structures, while B is any arbitrary structure from the class \u201c\u2212\u201d of all finite structures.1 Thus, we face the so-called uniform constraint satisfaction problem, shortly denoted as CSP(A,\u2212), where both structures are part of the input (nothing is fixed).\nThe decision problem CSP(A,\u2212) has intensively been studied in the literature, and various classes of structures over which it can be solved in polynomial time have already been singled out (see [6, 9, 16, 1], and the references therein). These approaches, called decomposition methods, are based on properties of the hypergraph HA associated with each structure A \u2208 A. In fact, it is well-known that, for the class Aa of all structures whose associated hypergraphs are acyclic, CSP(Aa,\u2212) is efficiently solvable by just enforcing generalized arc consistency (GAC)\u2014roughly, by filtering constraint relations until every pair of constraints having some variables X\u0304 in common agree on X\u0304 (that is, they have precisely the same set of allowed tuples of values on these variables X\u0304).\nLarger \u201cislands of tractability\u201d are then identified by generalizing hypergraph acyclicity. To this end, every decomposition method DM associates with any hypergraphHA some measure w of its cyclicity, called the DM-width of HA. The tractable classes A of instances (according to DM) are those (with\n1 Note that the finite property is a feature of this framework, and not a simplifying assumption. E.g., on structures with possibly infinite domains, the open question in [8] (just recently answered by [13] on finite structures) would have been solved in 1993 [21].\nhypergraphs) having bounded width, that is, whose degree of cyclicity is below some fixed threshold. For every instance A in such a class A and every structure B, the instance (A,B) can be solved in polynomial-time by exploiting the solutions of a set of suitable subproblems, that we call views, each one solvable in polynomial-time (in fact, exponential in the\u2014fixed\u2014width, for all known methods). In particular, the idea is to arrange some of these views in a tree, called decomposition, in order to exploit the known algorithms for acyclic instances. In fact, whenever such a tree exists, instances can be solved by just enforcing GAC on the available views, even without computing explicitly any decomposition. This very general approach traces back to the seminal database paper [8], and it is based on the graph-theoretic notion of tree-projection of the pair of hypergraphs (HA,HV), associated with the input structure A and with the structure V of the available views, respectively (tree projections are formally defined in Section 2).\nFor instance, assume that the fixed threshold on the width is k: in the generalized hypertree-width method [11], the available views are all subproblems involving at most k constraints from the given CSP instance; in the case of treewidth [19], the views are all subproblems involving at most k variables; for fractional hypertree-width, the views are all subproblems having fractional cover-width at most k (in fact, if we require that they are computable in polynomial-time, we may instead use those subproblems defined in [17] to compute a O(k3) approximation of this notion).\nNote that, for the special case of generalized hypertree-width, the fact that enforcing GAC on all clusters of k constraints is sufficient to solve the given instance, without computing a decomposition, has been re-derived in [5] (with proof techniques different from those in [8]). Moreover, [5] actually provided a stronger result, as it is proved that this property holds even if there is some homomorphically equivalent subproblem having generalized hypertree-width at most k. However, the corresponding only if result is missing in that paper, and characterizing the precise power of this GAC procedure for the views obtained from all clusters of k constraints (short: k-GAC) remained an open question. For any class A of instances having bounded arity (i.e., with a fixed maximum number of variables in any constraint scope of every instance of the class), the question has been answered in [2]: \u2200A \u2208 A, k-GAC is correct for every right-hand structure B if, and only if, the core of A has tree width at most k (recall that treewidth and generalized hypertree-width identify the same set of bounded-arity tractable classes). In its full version, the question has been answered recently in [13]: \u2200A \u2208 A, k-GAC is correct for every right-hand structure B if, and only if, for the core A\u2032 of A, the pair (HA,HV) has a tree projection, where HV is the hypergraph associated with the views considered by the generalized hypertree-width method with the bound k.\nIn fact, for any recursively enumerable class of bounded-arity structures A, it is known that this method is essentially optimal: CSP(A,\u2212) is solvable in polynomial time if, and only if, the cores of the structures in A have bounded treewidth (under standard complexity theoretic assumptions) [15]. Note that the latter condition may be equivalently as follows: for every A \u2208 A there is some A\u2032 homomorphically equivalent to A and such that its treewidth is below the required fixed threshold. For short, we say that such a class has bounded treewidth modulo homomorphic equivalence.\nThings with unbounded-arity classes are not that clear. Generalized hypertree-width does not characterize all classes of (arbitrary) structures where CSP(A,\u2212) is solvable in polynomial time [16]. It seems that a useful characterization may be obtained by relaxing the typical requirement that views are computable in polynomial time, and by requiring instead that such tasks are fixed-parameter tractable (FPT) [7]. In fact, towards establishing such characterization, it was recently shown in [18] that (under some reasonable technical assumptions) the problem CSP(H), i.e., CSP(A,\u2212) restricted to the instances whose associated hypergraphs belong to the class H, is FPT if, and only if, hypergraphs in H have bounded submodular width\u2014a new hypergraph measure more general than fractional hypertreewidth and, hence, than generalized hypertree-width.\nIt is worthwhile noting that the above mentioned tractability results for classes of instances defined modulo homomorphically equivalence are actually tractability results for the promise version of the\nproblem. In fact, unless P = NP, there is no polynomial-time algorithm that may check whether a given instance A actually belongs to such a class A. In particular, it has been observed by different authors [22, 4] that there are classes of instances having bounded treewidth modulo homomorphically equivalence for which answers computable in polynomial time cannot be trusted. That is, unless P = NP, there is no efficient way to distinguish whether a \u201cyes\u201d answer means that there is some solution of the problem, or that A 6\u2208 A.\nIn this paper, besides promise problems, we also consider the so-called no-promise problems, which seems more appealing for practical applications. In this case, either certified solutions are computed, or the promise A \u2208 A is correctly disproved. For instance, the algorithm in [5] solves the no-promise search-problem of computing a homomorphism for a given CSP instance (A,B). This algorithm either computes such a homomorphism or concludes that HA has generalized hypertree-width greater than k."}, {"heading": "1.2 Enumeration Problems", "text": "While the structural tractability of deciding whether CSP instances admit solutions has been deeply studied in the literature, the structural tractability of the corresponding computation problem received considerably less attention so far [4], though this is certainly a more appealing problem for practical applications.\nIn this paper, we embark on this study, by focusing on the problem ECSP of enumerating (possibly projected) solutions. Since even easy instances may have an exponential number of solutions, tractability means here having algorithms that compute solutions with polynomial delay (WPD): An algorithm M solves WPD a computation problem P if there is a polynomial p(\u00b7) such that, for every instance of P of size n, M discovers if there are no solutions in time O(p(n)); otherwise, it outputs all solutions in such a way that a new solution is computed within O(p(n)) time from the previous one.\nBefore stating our contribution, it is worthwhile noting that there are different facets of the enumeration problem, and thus different research directions to be explored:\n(Which Decomposition Methods?) We considered the more general framework of the tree projections, where subproblems (views) may be completely arbitrary, so that our results are smoothly inherited by all (known) decomposition methods. We remark that this choice posed interesting technical challenges to our analysis, and called for solution approaches that were not explored in the earlier literature on traditional methods, such as treewidth. For instance, in this general context, we cannot speak anymore of \u201cthe core\u201d of a structure, because different isomorphic cores may have different structural properties with respect to the available views.\n(Only full solutions or possibly projected solutions?) In this paper, an ECSP instance is a triple (A,B, O), for which we have to compute all solutions (homomorphisms) projected over a set of desired output variables O, denoted by AB[O]. We believe this is the more natural approach. Indeed, modeling real-world applications through CSP instances typically requires the use of \u201cauxiliary\u201d variables, whose precise values in the solutions are not relevant for the user, and that are (usually) filtered-out from the output. In these cases, computing all combinations of their values occurring in solutions means wasting time, possibly exponential time. Of course, this aspect is irrelevant for the problem of computing just one solution, but is crucial for the enumeration problem.\n(Should classes of structures be aware of output variables?) This is an important technical question. We are interested in identifying classes of tractable instances based on properties of their left-hand structures, while right-hand structures have no restrictions. What about output variables? In principle, structural properties may or may not consider the possible output variables, and in fact both approaches have been explored in the literature (see, e.g., [15]), and both approaches are dealt with in this paper. In the former output-aware case, possible output variables are suitably described in the instance structure. Unlike previous approaches that considered additional \u201cvirtual\u201d constraints covering together all possible output variables [15], in this paper possible output variables are described as those variables\nX having a domain constraint dom(X), that is, a distinguished unary constraint specifying the domain of this variable. Such variables are said domain restricted. In fact, this choice reflects the classical approach in constraint satisfaction systems, where variables are typically associated with domains, which are heavily exploited by constraint propagation algorithms. Note that this approach does not limit the number of solutions, while in the tractable classes considered in [15] only instances with a polynomial number of (projected) solutions may be dealt with. As far as the latter case of arbitrary sets of output variables is considered, observe that in general stronger conditions are expected to be needed for tractability. Intuitively, since we may focus on any desired substructure, no strange situations may occur, and the full instance should be really tractable."}, {"heading": "1.3 Contribution", "text": "Output-aware classes of ECSPs:\n(1) We define a property for pairs (A, O), where A is a structure and O \u2286 A is a set of variables, that allows us to characterize the classes of tractable instances. Roughly, we say that (A, O) is tp-covered through the decomposition method DM if variables in O occur in a tree projection of a certain hypergraph w.r.t. to the (hypergraph associated with the) views defined according to DM. (2) We describe an algorithm that solves the promise enumeration problem, by computing with polynomial delay all solutions of a given instance (A,B, O), whenever (A, O) is tp-covered through DM. (3) For the special case of (generalized hyper)tree width, we show that the above condition is also necessary for the correctness of the proposed algorithm (for every B). In fact, for these traditional decomposition methods we now have a complete characterization of the power of the k-GAC approach. (4) For recursively enumerable classes of structures having bounded arity, we exhibit a dichotomy showing that the above tractability result is tight, for DM = treewidth (and assuming FPT 6= W [1]).\nECSP instances over arbitrary output variables:\n(1) We describe an algorithm that, on input (A,B, O), solves the no-promise enumeration problem. In particular, either all solutions are computed, or it infers that there exists no tree projection of HA w.r.t. HV (the hypergraph associated with the views defined according to DM). This algorithm generalizes to the tree projection framework the enumeration algorithm of projected solutions recently proposed for the special case of treewidth [4]. (2) Finally, we give some evidence that, for bounded arity classes of instances, we cannot do better than this. In particular, having bounded width tree-decompositions of the full structure seems a necessary condition for enumerating WPD. We speak of \u201cevidence,\u201d instead of saying that our result completely answers the open question in [15, 4], because our dichotomy theorem focuses on classes of structures satisfying the technical property of being closed under taking minors (in fact, the same property assumed in the first dichotomy result on the complexity of the decision problem on classes of graphs [14])."}, {"heading": "2 Preliminaries: Relational Structures and Homomorphisms", "text": "A constraint satisfaction problem may be formalized as a relational homomorphism problem. A vocabulary \u03c4 is a finite set of relation symbols of specified arities. A relational structure A over \u03c4 consists of a universe A and an r-ary relation RA \u2286 Ar, for each relation symbol R in \u03c4 .\nIfA andA\u2032 are two relational structures over disjoint vocabularies, we denote by A\u228eA\u2032 the relational structure over the (disjoint) union of their vocabularies, whose domain (resp., set of relations) is the union of those of A and A\u2032.\nA homomorphism from a relational structure A to a relational structure B is a mapping h : A 7\u2192 B such that, for every relation symbol R \u2208 A, and for every tuple \u3008a1, . . . , ar\u3009 \u2208 RA, it holds that \u3008h(a1), . . . , h(ar)\u3009 \u2208 RB. For any set X \u2286 A, denote by h[X ] the restriction of h to X . The set of all possible homomorphisms from A to B is denoted by AB, while AB[X ] denotes the set of their restrictions to X .\nAn instance of the constraint satisfaction problem (CSP) is a pair (A,B) where A is called a lefthand structure (short: \u2113-structure) and B is called a right-hand structure (short: r-structure). In the classical decision problem, we have to decide whether there is a homomorphism from A to B, i.e., whether AB 6= \u2205. In an instance of the corresponding enumeration problem (denoted by ECSP) we are additionally given a set of output elements O \u2286 A; thus, an instance has the form (A,B, O). The goal is to compute the restrictions to O of all possible homomorphisms from A to B, i.e., AB[O]. If O = \u2205, the computation problem degenerates to the decision one. Formally, let h\u03c6 : \u2205 7\u2192 true denote (the constant mapping to) the Boolean value true; then, define AB[\u2205] = {h\u03c6} (resp., AB[\u2205] = \u2205) if there is some (resp., there is no) homomorphism from A to B.\nIn the constraint satisfaction jargon, the elements of A (the domain of the \u2113-structure A) are the variables, and there is a constraint C = (\u3008a1 . . . , ar\u3009, RB) for every tuple \u3008a1 . . . , ar\u3009 \u2208 RA and every relation symbol R \u2208 \u03c4 . The tuple of variables is usually called the scope of C, while RB is called the relation of C. Any homomorphism from A to B is thus a mapping from the variables in A to the elements in B (often called domain values) that satisfies all constraints, and it is also called a solution (or a projected solution, if it is restricted to a subset of the variables).\nTwo relational structures A and A\u2032 are homomorphically equivalent if there is a homomorphisms from A to A\u2032 and vice-versa. A structure A\u2032 is a substructure of A if A\u2032 \u2286 A and RA \u2032\n\u2286 RA, for each symbol R \u2208 \u03c4 . Moreover, A\u2032 is a core of A if it is a substructure of A such that: (1) there is a homomorphism from A to A\u2032, and (2) there is no substructure A\u2032\u2032 of A\u2032, with A\u2032\u2032 6= A\u2032, satisfying (1)."}, {"heading": "3 Decomposition Methods, Views, and Tree Projections", "text": "Throughout the following sections we assume that (A,B) is a given connected CSP instance, and we shall look for computing its solutions (possibly restricted over a desired set of output variables) by combining the solutions of suitable sets of subproblems, available as additional distinguished constraints called views.\nLet AV be an \u2113-structure with the same domain as A. We say that AV is a view structure (short: v-structure) if\n\u2013 its vocabulary \u03c4V is disjoint from the vocabulary \u03c4 of A; \u2013 every relation RAV contains a single tuple whose variables will be denoted by var(RAV ). That is,\nthere is a one-to-one correspondence between views and relation symbols in \u03c4V , so that we shall often use the two terms interchangeably; \u2013 for every relation R \u2208 \u03c4 and every tuple t \u2208 RA, there is some relation Rt \u2208 \u03c4V , called base view, such that {t} = RAVt , i.e., for every constraint in A there is a corresponding view in AV .\nLet BV be an r-structure. We say that BV is legal (w.r.t. AV and (A,B)) if \u2013 its vocabulary is \u03c4V ; \u2013 For every view R \u2208 \u03c4V , RBV \u2287 AB[w] holds, where w = var(RAV ). That is, every subproblem is\nnot more restrictive than the full problem. \u2013 For every base view Rt \u2208 \u03c4V , R BV t \u2286 R\nB. That is, any base view is at least as restrictive as the \u201coriginal\u201d constraint associated with it.\nThe following fact immediately follows from the above properties.\nFact 1 Let BV be any r-structure that is legal w.r.t. AV and (A,B). Then, \u2200O \u2286 A, the ECSP instance (AV ,BV , O) has the same set of solutions as (A,B, O).\nIn fact, all structural decomposition methods define some way to build the views to be exploited for solving the given CSP instance. In our framework, we associate with any decomposition method DM a pair of polynomial-time computable functions \u2113-DM and r-DM that, given any CSP instance (A,B), compute the pair (AV ,BV), where AV = \u2113-DM(A) is a v-structure, and BV = r-DM(A,B) is a legal r-structure.2\nFor instance, for any fixed natural number k, the generalized hypertree decomposition method [10] (short: hwk) is associated with the functions \u2113-hwk and r -hwk that, given a CSP instance (A,B), build the pair (\u2113-hwk (A), r -hwk (A,B)) where, for each subset C of at most k constraints from (A,B), there is a view RC such that: (1) var (R \u2113-hwk (A) C ) is the set of all variables occurring in C, and (2) the tuples in Rr-hwk (A,B)C are the solutions of the subproblem encoded by C. Similarly, the tree decomposition method [19] (twk) is defined as above, but we consider each subset of at most k variables in A instead of each subset of at most k constraints."}, {"heading": "3.1 Tree Projections for CSP Instances", "text": "In this paper we are interested in restrictions imposed on left-hand structures of CSP instances, based on some decomposition method DM. To this end, we associate with any \u2113-structure A a hypergraph HA = (A,H), whose set of nodes is equal to the set of variables A and where, for each constraint scope in RA, the set H of hyperedges contains a hyperedge including all its variables (no further hyperedge is in H). In particular, the v-structure AV = \u2113-DM(A) is associated with a hypergraph HAV = (A,H), whose set of nodes is the set of variables A and where, for each view R \u2208 \u03c4V , the set H contains the hyperedge var(RAV ). In the following, for any hypergraph H, we denote its nodes and edges by nodes(H) and edges(H), respectively.\nExample 1. Consider the \u2113-structure A whose vocabulary just contains the binary relation symbol R, and such that RA = {\u3008F,E\u3009, \u3008A,E\u3009, \u3008A,C\u3009, \u3008A,B\u3009, \u3008B,C\u3009, \u3008D,B\u3009, \u3008D,C\u3009}. Such a simple onebinary-relation structure may be easily represented by the directed graph in the left part of Figure 1,\n2 A natural extension of this notion we may be to consider FPT decomposition methods, where functions \u2113-DM and r-DM are computable in fixed-parameter polynomial-time. For the sake of presentation and of space, we do not consider FPT decomposition methods in this paper, but our results can be extended to them rather easily.\nwhere edge orientation reflects the position of the variables in R. In this example, the associated hypergraph HA is just the undirected version of this graph. Let DM be a method that, on input A, builds the v-structure AV = \u2113-DM(A) consisting of the seven base views of the form Rt, for each tuple t \u2208 RA, plus the three relations R1, R2, and R3 such that R AV 1 = {\u3008A,E, F \u3009}, R AV 2 = {\u3008A,B,C, F \u3009}, and RAV3 = {\u3008C,D, F \u3009}. Figure 1 also reports HAV . \u22b3\nA hypergraph H is acyclic iff it has a join tree [3], i.e., a tree JT (H), whose vertices are the hyperedges of H, such that if a node X occurs in two hyperedges h1 and h2 of H, then h1 and h2 are connected in JT (H), and X occurs in each vertex on the unique path linking h1 and h2 in JT (H).\nFor two hypergraphs H1 and H2, we write H1 \u2264 H2 iff each hyperedge of H1 is contained in at least one hyperedge of H2. Let H1 \u2264 H2. Then, a tree projection of H1 with respect to H2 is an acyclic hypergraph Ha such that H1 \u2264 Ha \u2264 H2. Whenever such a hypergraphHa exists, we say that the pair (H1,H2) has a tree projection (also, we say that H1 has a tree projection w.r.t. H2). The problem of deciding whether a pair of hypergraphs has a tree projection is called the tree projection problem, and it has recently been proven to be NP-complete [12].\nExample 2. Consider again the setting of Example 1. It is immediate to check that the pair of hypergraphs (HA,HAV ) does not have any tree projection. Consider instead the (hyper)graph HA\u2032 reported on the right of Figure 1. The acyclic hypergraphHa is a tree projection of HA\u2032 w.r.t. HAV . In particular, note that the hyperedge {A,B,C} \u2208 edges(Ha) \u201cabsorbs\u201d the cycle in HA\u2032 , and that {A,B,C} is in its turn contained in the hyperedge {A,B,C, F} \u2208 edges(HAV ). \u22b3\nNote that all the (known) structural decomposition methods can be recast as special cases of tree projections, since they just differ in how they define the set of views to be built for evaluating the CSP instance. For instance, a hypergraph HA has generalized hypertree width (resp., treewidth) at most k if and only if there is a tree projection of HA w.r.t. H\u2113-hwk (A) (resp., w.r.t. H\u2113-twk (A)).\nHowever, the setting of tree projections is more general than such traditional decomposition approaches, as it allows us to consider arbitrary sets of views, which often require more care and different techniques. As an example, we shall illustrate below that in the setting of tree projections it does not make sense to talk about \u201cthe\u201d core of an \u2113-structure, because different isomorphic cores may differently behave with respect to the available views. This phenomenon does not occur, e.g., for generalized hypertree decompositions, where all combinations of k constraints are available as views.\nExample 3. Consider the structure A illustrated in Example 1, and the structures A\u2032 and A\u2032\u2032 over the same vocabulary as A, and such that RA \u2032 = {\u3008A,C\u3009, \u3008A,B\u3009, \u3008B,C\u3009} and RA \u2032\u2032\n= {\u3008B,C\u3009, \u3008D,B\u3009, \u3008D,C\u3009}. The hypergraphsHA\u2032 and HA\u2032\u2032 are reported in Figure 1. Note that A\u2032 and A\u2032\u2032 are two (isomorphic) cores of A, but they have completely different structural properties. Indeed, (HA\u2032 ,HAV ) admits a tree projection (recall Example 2), while (HA\u2032\u2032 ,HAV ) does not. \u22b3"}, {"heading": "3.2 CSP Instances and tp-Coverings", "text": "We complete the picture of our unifying framework to deal with decomposition methods for constraint satisfaction problems, by illustrating some recent results in [13], which will be useful to our ends. Let us start by stating some preliminary definitions.\nFor a set of variables O = {X1, . . . , Xr}, let SO denote the structure with a fresh r-ary relation symbol RO and domain O, such that R AO O = {\u3008X1, . . . , Xr\u3009}.\nDefinition 1. Let AV be a v-structure. A set of variables O \u2286 A is tp-covered in AV if there exists a core A\u2032 of A \u228e SO such that (HA\u2032 ,HAV ) has a tree projection. 3\n3 For the sake of completeness, note that we use here a core A\u2032 because we found it more convenient for the presentation and the proofs. However, it is straightforward to check that this notion can be equivalently stated in terms of any structure homomorphically equivalent to A \u228e SO. The same holds for the related Definition 3.\nFor instance, it is easily seen that the variables {A,B,C} are tp-covered in the v-structure AV discussed in Example 1. In particular, note that the structure A \u228e S{A,B,C} is associated with the same hypergraph HA\u2032 that has a tree projection w.r.t. HAV (cf. Example 3). Instead, the variables {B,C,D} are not tp-covered in AV .\nGiven a CSP instance (AV ,BV), we denote by GAC(AV ,BV) the r-structure that is obtained by enforcing generalized arc consistency on (AV ,BV).\nThe following result, proved in [13] for a different setting, states the precise relationship between generalized-arc-consistent views and tp-covered sets of variables.\nTheorem 2. Let A be an \u2113-structure, and let AV be a v-structure. The following are equivalent:\n(1) A set of variables O \u2286 A is tp-covered in AV ; (2) For every r-structure B, for every r-structure BV that is legal w.r.t. AV and (A,B), and for every\nrelation R \u2208 \u03c4V with O \u2286 var(RAV ), RGAC(AV ,BV)[O] = AB[O].\nNote that the result answered a long standing open question [8, 21] about the relationship between the existence of tree projections and (local and global) consistency properties in databases [13]. In words, the result states that just enforcing generalized arc consistency on the available views is a sound and complete procedure to solve ECSP instances if, and only if, we are interested in (projected) solutions over output variables that are tp-covered and occur together in some available view. Thus, in these cases, all solutions can be computed in polynomial time. The more general case where output variables are arbitrary (i.e., not necessarily included in some available view) is explored in the rest of this paper.\nWe now leave the section by specializing Theorem 2 to the case of generalized hypertree decomposition and tree decomposition methods.\nTheorem 2-bis. Let DM be a decomposition method in {twk, hwk}, let A be an \u2113-structure, and let AV = \u2113-DM(A). The following are equivalent:\n(1) A set of variables O \u2286 A is tp-covered in AV ; (2) For every r-structure B, and for every relation R \u2208 \u03c4V with O \u2286 var(RAV ), RGAC(AV ,BV)[O] =\nA B[O], where BV = r-DM(A,B).\nProof (Sketch). Preliminarily, it is easy to see that (2) in Theorem 2 may be equivalently stated as follows:\n(2\u2019) For every r-structure B, for every r-structure BV that is legal w.r.t. AV and (A,B) and such that BV = GAC(AV ,BV), and for every relation R \u2208 \u03c4V with O \u2286 var (RAV ), RBV [O] = AB[O].\nThe fact that (1) \u21d2 (2) trivially follows from Theorem 2. We have to show that (2) \u21d2 (1) holds as well. To this end, observe that if O is not tp-covered in \u2113-DM(A), by Theorem 2 (actually, (1) \u21d2 (2\u2032)), we can conclude the existence of: (1) an r-structure B, (2) an r-structure BV that is legal w.r.t. AV and (A,B) and such that BV = GAC(AV ,BV), and (3) a relation R \u2208 \u03c4V with O \u2286 var(RAV ) such that RBV [O] 6= AB[O] (of course, RBV [O] \u2283 AB[O] by the legality of BV ). Consider now the r-structure B \u2032 V = r -hwk (A,B). Recall that each view in B \u2032 V contains all the solutions of the subproblem encoded by the constraints over which it is defined. Since BV = GAC(AV ,BV), it can be shown that each view in BV contains only solutions of the subproblem encoded by the constraints over which it is defined. Thus, for each relation R \u2208 \u03c4V , RB \u2032 V \u2287 RBV holds, which implies RB \u2032\nV [O] \u2283 AB[O]. The same line of reasoning applies to the tree decomposition method. \u22b3\nNote that if we consider decision problem instances (O = \u2205) and the treewidth method (AV = \u2113-twk (A)), from Theorem 2-bis, we (re-)obtain the nice characterization of [2] about the relationship between k-local consistency and treewidth modulo homomorphic equivalence. If we consider generalized hypertree-width (AV = \u2113-hwk (A)), we get the answer to the corresponding open question for the unbounded arity case, that is, the precise power of the procedure enforcing k-union (of constraints) consistency (i.e., the power of the algorithm for the decision problem described in [5])."}, {"heading": "4 Enumerating Solutions of Output-Aware CSP Instances", "text": "The goal of this section is to study the problem of enumerating CSP solutions for classes of instances where possible output variables are part of the structure of the given instance. This is formalized by assuming that the relational structure contains domain constraints that specify the domains for such variables.\nDefinition 2. A variable X \u2208 A is domain restricted in the \u2113-structure A if there exists a unary distinguished (domain) relation symbol dom(X) \u2208 \u03c4 such that {\u3008X\u3009} = dom(X)A. The set of all domain restricted variables is denoted by drv(A).\nWe say that an ECSP instance (A,B, O) is domain restricted if O \u2286 drv (A). Of course, if it is not, then one may easily build in linear time an equivalent domain-restricted ECSP instance where an additional fresh unary constraint is added for every output variable, whose values are taken from any constraint relation where that variable occurs. We say that such an instance is a domain-restricted version of (A,B, O).\nFigure 2 shows an algorithm, named ComputeAllSolutionsDM, that computes the solutions of a given ECSP instance. The algorithm is parametric w.r.t. any chosen decomposition method DM, and works as follows. Firstly, ComputeAllSolutionsDM starts by transforming the instance (A,B, O) into a domain restricted one, and by constructing the views in (AV ,BV) via DM. Then, it invokes the procedure Propagate. This procedure backtracks over the output variables {X1, . . . , Xm}: At each step i, it tries to assign a value to Xi from its domain view,4 and defines this value as the unique one available in that domain, in order to \u201cpropagate\u201d such an assignment over all other views. This is accomplished by enforcing generalized arc-consistency each time the procedure is invoked. Eventually, whenever an assignment is computed for all the variables in O, this solution is returned in output, and the algorithm proceeds by backtracking again trying different values.\n4 With an abuse of notation, in the algorithm we denote by dom(X) the base view in \u03c4V associated with the input constraint dom(A) \u2208 \u03c4 (in fact, no confusion may arise because the algorithm only works on views).\n4.1 Tight Characterizations for the Correctness of ComputeAllSolutionsDM\nTo characterize the correctness of ComputeAllSolutionsDM, we need to define a structural property that is related to the one stated in Definition 1. Below, differently from Definition 1 where the set of output variables O is treated as a whole, each variable in O has to be tp-covered as a singleton set.\nDefinition 3. Let (A,B, O) be an ECSP instance. We say that (A, O) is tp-covered through DM if there is a core A\u2032 of A \u228e \u228e\nX\u2208O S{X} such that (HA\u2032 ,H\u2113-DM(A)) has a tree projection.\nNote that the above definition is purely structural, because (the right-hand structure) B plays no role there. In fact, we next show that this definition captures classes of instances where ComputeAllSolutionsDM is correct.\nTheorem 3. Let DM be a decomposition method, let A be an \u2113-structure, and let O \u2286 A be a set of variables. Assume that (A, O) is tp-covered through DM. Then, for every r-structure B, ComputeAllSolutionsDM computes the set A B[O].\nProof (Sketch). Let Bin be any r-structure. Preliminarily observe that if the original input instance, say Iin = (Ain,Bin, O), is tp-covered through DM, the same property is enjoyed by its equivalent domainrestricted version, say I0 = (A,B0, O), computed in the starting phase of the algorithm. Thus, there is a core A\u2032 of A \u228e \u228e\nX\u2208O S{X} such that (HA\u2032 ,HAV ) has a tree projection, where AV = \u2113-DM(A). This entails that, \u2200X \u2208 O, {X} is tp-covered in HAV . It is sufficient to show that, if A B 0 6= \u2205, at the generic call of Propagate with i as its first argument, activeValues is initialized at Step 2 with a non-empty set that contains all those values that Xi \u2208 O may take, in any solution of (A,B0) extending the current partial solution \u3008a1, ..., ai\u22121\u3009; otherwise (AB0 = \u2205), activeValues = \u2205, and the algorithm correctly terminates with an empty output without ever entering the for cycle. For the sake of presentation, we just prove what happens in the first call.The generalization to the generic case is then straightforward.\nLet i = 1 and assume that B\u2032V := GAC(AV ,BV) has been computed. From the tp-covered property of variables in O and Theorem 2, it follows that \u2200X \u2208 O, its domain view dom(X) is such that dom(X)B \u2032\nV = AB0 [{X}]. Thus, all values in the domain views associated with output variables occur in some solutions. This holds in particular for dom(X1) that is empty if, and only if, AB0 = \u2205, in which case the cycle is skipped and the algorithm immediately halts with an empty output. Assume now that this is not the case, so that activeValues = AB0 [{X1}] 6= \u2205, and let a1 be the chosen value at Step 3. Consider a new instance I1 = (A,B1, O) where the domain constraint for X1 contains the one value a1. From the above discussion it follows that AB1 6= \u2205, and clearly the solutions of I1 are all and only those of I0 that extend the partial solution \u3008a1\u3009. Moreover, it is easy to check that the r-structure B\u2032V obtained after the execution of Step 7 is legal w.r.t. (A,B1), and recall that nothing is changed in the pair (A, O), which is (still) tp-covered through DM. Therefore, when we call recursively Propagate at Step 8 with i = 2, we are in the same situation as in the first call, but going to enumerate the solutions of I1. At the end of this call, we just repeat this procedure with the next available value for X1, say a2, until all elements in activeValues = AB0 [{X1}] have been considered (and propagated). \u22b3\nBelow, we complete the picture by showing that Definition 3 also delineates the necessary conditions for the correctness of ComputeAllSolutionsDM, in the case where DM is a decomposition method in {twk, hwk}.\nTheorem 4. Let DM be a decomposition method in {twk, hwk}, let A be an \u2113-structure, and let O \u2286 A be a set of variables. Assume that, for every r-structure B, ComputeAllSolutionsDM computes A\nB[O]. Then, (A, O) is tp-covered through DM.\nProof (Sketch). Assume that (A, O) is not tp-covered through DM, and let O\u2032 \u2286 O be a maximal set of output variables such that (A, O\u2032) is tp-covered throughDM. In the case whereO\u2032 = \u2205, there is no coreA\u2032 of A such that (HA\u2032 ,H\u2113-DM(A)) has a tree projection. Thus, we can apply Theorem 2-bis and conclude that there are an r-structure B, and a relation R \u2208 \u03c4V such that AB has a solution while RGAC(\u2113-DM(A),BV ) is empty, withBV = r-DM(A,B). It follows that ComputeAllSolutionsDM will not produce any output. Consider now the case where O\u2032 6= \u2205, and where any X \u2208 O \\O\u2032 is a variable such that (A, O\u2032 \u222a {X}) is not tp-covered through DM. Let A\u0304 be the relational structure A \u228e \u228e\nY \u2208O\u2032 S{Y }, which is such that (HA\u0304,H\u2113-DM(A)) has a tree projection. Then, {X} is not tp-covered in \u2113-DM(A\u0304). By Theorem 2-bis, there are an r-structure B, and a relation R \u2208 \u03c4V with {X} \u2286 var (RA\u0304V ) such that RGAC(A\u0304V ,BV)[{X}] \u2283 A\u0304\nB[{X}], where BV = r-DM(A\u0304,B). In fact, we can show that such a \u201ccounterexample\u201d structure B can be chosen in such a way that there are (full) solutions h for the problem having the following property: some values in RGAC(A\u0304V ,BV)[{X}] \\ A\u0304B[{X}] belongs to the generalized arc consistent structure B\u2032 where variables in O\u2032 are fixed according to h[O\u2032]. Thus while enumerating such a solution h[O\u2032], ComputeAllSolutionsDM generates wrong extensions of this solution to the variable X . \u22b3"}, {"heading": "4.2 Tight Characterizations for Enumerating Solutions with Polynomial Delay", "text": "We next analyze the complexity of ComputeAllSolutionsDM.\nTheorem 5. Let A be an \u2113-structure, and O \u2286 A be a set of variables. If (A, O) is tp-covered through DM, then ComputeAllSolutionsDM runs WPD.\nProof. Assume that (A, O) is tp-covered through DM. By Theorem 3, we know that ComputeAllSolutionsDM computes the set A\nB[O]. Thus, if the algorithm does not output any tuple, we can immediately conclude that the ECSP instance does not have solutions. Concerning the running time, we preliminary notice that the initialization steps are feasible in polynomial time. In particular, computing AV and BV is feasible in polynomial time, by the properties of the decomposition method DM (see Section 3). To characterize the complexity of the recursive invocations of Propagate, we have to consider instead two cases.\nIn the case where there is no solution, we claim that the r-structure B\u2032V obtained by enforcing generalized arc consistency in the first invocation of Propagate (i.e., for i = 1) is empty. Indeed, since (A, O) is tp-covered through DM, then {X1} is tp-covered in AV\u2014just compare Definition 1 and Definition 3. It follows that we can apply Theorem 2 on the set {X1} in order to conclude that, for every relation R \u2208 \u03c4V with X1 \u2208 var(RAV ), RGAC(AV ,BV)[{X1}] = AB[{X1}]. Since, AB[O] is empty, the above implies that GAC(AV ,BV) is empty too. Thus, ComputeAllSolutionsDM invokes just once Propagate, where the only operation carried out is to enforce generalized arc consistency, which is feasible in polynomial time.\nConsider now the case where AB[O] is not empty. Then, the first solution is computed after m recursive calls of the procedure Propagate, where the dominant operation is to enforce generalized arc consistency on the current pair (AV ,BV). In particular, by the arguments in the proof of Theorem 3, it follows that Propagate does not have to backtrack to find this solution: after enforcing generalized arc consistency at step i, any active value for Xi is guaranteed to occur in a solution with the current fixed values for the previous variables Xj , 1 \u2264 j < i. Since GAC can be enforced in polynomial time, this solution can be computed in polynomial time as well.\nTo complete the proof, observe now that any solution is provided in output when Propagate is invoked for i = m. After returning a tuple of values \u3008a1, ..., am\u3009, Propagate may need to backtrack to a certain index i\u2032 \u2265 1 having some further (different) value ai\u2032 to be processed, fix Xi\u2032 with this value, propagate this assignment, and continue by processing variable Xi\u2032+1. Thus, at most m invocations of Propagate are needed to compute the next solution, and no backtracking step may occur before we found it. Therefore, ComputeAllSolutionsDM runs WPD. \u22b3\nBy the above theorem and the definition of domain restricted variables, the following can easily be established.\nCorollary 1. Let A be any class of \u2113-structures such that, for each A \u2208 A, (A, drv (A)) is tp-covered through DM. Then, for every r-structure B, and for every set of variables O \u2286 drv(A), the ECSP instance (A,B, O) is solvable WPD.\nIn the case of bounded arity structures and if the (hyper)tree width is the chosen decomposition method, it is not hard to see that the result in Corollary 1 is essentially tight. Indeed, the implication (2) \u21d2 (1) in the theorem below easily follows from the well-known dichotomy for the decision version [15], which is obtained in the special case of ECSP instances without output variables (O = \u2205).\nTheorem 6. Assume FPT 6= W [1]. Let A be any class of \u2113-structures of bounded arity. Then, the following are equivalent:\n(1) A has bounded treewdith modulo homomorphic equivalence; (2) For every A \u2208 A, for every r-structure B, and for every set of variables O \u2286 drv(A), the ECSP\ninstance (A,B, O) is solvable WPD.\nActually, from an application perspective of this result, we observe that there is no efficient solution for the no-promise problem for such classes, by actually proving a slightly stronger statement. We say that a pair (h, c) is a certified projected solution of an instance (A,B, O) if, by using the certificate c, one may check in polynomial-time (w.r.t. the size of (A,B, O)) whether h \u2208 AB[O]. For instance, any full solution extending h is clearly such a certificate. If O = \u2205, h is also empty, and c is intended to be a certificate that (A,B) is a \u201cYes\u201d instance of the decision CSP. Finally, we assume that the empty output is always a certified answer, in that it entails that the input is a \u201cNo\u201d instance, without the need for an explicit certificate of this property.\nProposition 1. The following problem is NP-hard: Given any ECSP instance (A,B, O), compute a certified solution in AB[O], whenever (A, O) is tp-covered through DM; otherwise, there are no requirements and any output is acceptable. Hardness holds even if DM is the treewidth method with k = 2, the vocabulary contains just one binary relation symbol, and O = \u2205.\nProof. We show a polynomial-time Turing reduction from the NP-hard 3-colorability problem. Let M be a Turing transducer that solves the problem, that is, whenever (A, O) is tp-covered through DM, at the end of a computation on a given input (A,B, O) its output tape contains a certified solution in AB[O], otherwise, everything is acceptable. In particular, we do not pretend that M recognizes whether the above condition is fulfilled.\nThen, we use M as an oracle procedure within a polynomial time algorithm that solves the 3- colorability problem. Let G = (N,E) be any given graph, and assume w.l.o.g. that it contains a triangle {n1, n2}, {n2, n3}, and {n3, n1}. (Otherwise, select any arbitrary vertex n1 of G and connect it to two fresh vertices n2 and n3, also connected to each other. It is easy to check that this new graph is 3-colorable if, and only if, the original graph G is 3-colorable, as the two fresh vertices have no connections with the rest of the graph.) Build the (classical) binary CSP (AG,B3c) where the vocabulary contains one relation symbol RE , and the set of variables is AG = N . Moreover, R AG E = {\u3008ni, nj\u3009 | {ni, nj} \u2208 E}, and R B3c E = {\u3008c, c \u2032\u3009 | c 6= c\u2032, {c, c\u2032} \u2286 {1, 2, 3}}. Consider the treewidth method for k = 2, and compute in polynomial time the pair (AV ,BV ) where AV = \u2113-tw2 (AG) and BV = r -tw2 (B3c). In particular, observe that the hypergraphHAV contains a hyperedge {ni, nj, nl} for every triple of vertices of G.\nIt is well-known and easy to see that G is 3-colorable if, and only if, AB3cG 6= \u2205, that is, if there is a homomorphism from AG to a triangle (indeed, B3c is a triangle). Therefore, if G is 3-colorable, the\ntriangle substructure A\u2032 such that RA \u2032\nE = {\u3008ni, nj\u3009 | {i, j} \u2282 {1, 2, 3} | i 6= j} is homomorphically equivalent to AG. Moreover, in this case the hypergraph consisting of the single hyperedge {n1, n2, n3} is a tree projection of HA\u2032 w.r.t. HAV , or, equivalently, the treewidth of A\n\u2032 is 2. Now, run M on input (AG,B3c, \u2205) and consider its first output certificate c\u2014say, for the sake of presentation, a full solution for the problem. Then check in polynomial time whether c is a legal certificate\u2014in our exemplification, whether it encodes a solution of the given instance. If this is the case, we know that G is 3-colorable; otherwise, we conclude that G is not 3-colorable. Indeed, M must be correct on 3-colorable graphs, because there exists a tree projection of HA\u2032 (and thus of any core of AG\u2014note that O = \u2205 and thus there is no further requirement) w.r.t. HAV . Since all these steps are feasible in polynomial-time, we are done. \u22b3"}, {"heading": "5 Enumerating Solutions over Arbitrary Output Variables", "text": "In this section we consider structural properties that are independent of output variables, so that tractability must hold for any desired sets of output variables. For this case, we are able to provide certified solutions WPD, which seems the more interesting notion of tractability for actual applications.\nFigure 3 shows the ComputeCertifiedSolutionsDM algorithm computing all solutions of an ECSP instance, with a certificate for each of them. The algorithm is parametric w.r.t. any chosen decomposition method DM, and resembles in its structure the ComputeAllSolutionsDM algorithm. The main difference is that, after having found an assignment \u3008a1, ..., am\u3009 for the variables in O, ComputeCertifiedSolutionsDM still iterates over the remaining variables in order to find a certificate for that projected solution. Of course, ComputeCertifiedSolutionsDM does not backtrack over the possible values to be assigned to the variables in {Xm+1, ..., Xn}, since just one extension suffices to certify that this partial solution can be extended to a full one. Thus, we break the cycle after an element \u3008ai\u3009 is picked from its domain and correctly propagated, for each i > m, so that in these cases we eventually backtrack directly to i = m (to look for a new projected solution).\nNote that ComputeCertifiedSolutionsDM incrementally outputs various solutions, but it halts the computation if the current r-structure B\u2032V becomes empty. As an important property of the algorithm, even when this abnormal exit condition occurs, we are guaranteed that all the elements provided as output until this event are indeed solutions. Moreover, if no abnormal termination occurs, then we are guaranteed that all solutions will actually be computed. Correctness follows easily from the same arguments used for ComputeAllSolutionsDM, by observing that, whenever (HA,H\u2113-DM(A)) has a tree projection, the full set of variables A is tp-covered through DM.\nTheorem 7. Let A be an \u2113-structure, and O \u2286 A be a set of variables. Then, for every r-structure B, ComputeCertifiedSolutionsDM computes WPD a subset of the solutions in A\nB[O], with a certificate for each of them. Moreover,\n\u2013 If ComputeCertifiedSolutionsDM outputs \u201cDM failure\u201d, then (HA,H\u2113-DM(A)) does not have a tree projection; \u2013 otherwise, ComputeCertifiedSolutionsDM computes WPD A B[O].\nMoreover, we next give some evidence that, for bounded arity classes of instances, we cannot do better than this. In particular, having bounded width tree-decompositions of the full structure seems a necessary condition for the tractability of the enumeration problem WPD w.r.t. arbitrary sets of output variables (and for every r-structure).\nThe main gadget of the proof that tree-decompositions are necessary for tractability is based on a nice feature of grids. Figure 4 shows the basic idea for the simplest case of a relational structure Au with only one relation symbol Ru such that RAuu is (the edge set of) an undirected grid. Then, any substructure A1 of Au where RA1u contains just one tuple is a core of Au. However, if we consider the variant of Au where there is a domain constraint dom(X) for every corner X of the grid (depicted with the circles in the figure), then the unique core is the whole structure. In fact, we next prove that this property holds for any relational structure whose Gaifman graph is a grid.\nLemma 1. Let A be an \u2113-structure whose Gaifman graph is a grid G. Moreover, let O \u2286 A be the set of its four corners, and assume they are domain restricted, i.e., O \u2286 drv(A). Then, A is a core.\nProof (Sketch). Let G be such a k1 \u00d7 k2 grid, and consider any homomorphism h that maps A to any of its substructures A\u2032. Since the four corners v1,1, v1,k2 , vk1,1, vk1,k2 are domain restricted, h(X) = X must hold for each of them (as \u3008X\u3009 is the one tuple of its domain constraint dom(X)A). We say that such elements are fixed.\nConsider the first row r1 = (v1,1, v1,2, . . . , v1,k2) of G. We have seen that its endpoints, which are grid-corners, are fixed. It is easy to check that h cannot map the path r1 to any path that is longer than r1. However, r1 is the shortest path connecting the fixed endpoints v1,1 and v1,k2 , and hence it must be mapped to itself. That is, h(X) = X for every element X occurring in r1, and thus, by the same reasoning, for every element X occurring in the last row, and in the first and the last columns of the grid. It follows that the endpoints v2,1 and v2,k2 of the second row r2 are fixed as well, and we may apply the same argument to show that all elements occurring in r2 are fixed, too. Eventually, row after row, we get that all elements of A are fixed, and thus the identity mapping is the only possible endomorphism for A, which entails that A is a core. \u22b3\nWe also exploit the grid-based construction from [15], whose properties relevant to this paper may be summarized as follows.\nProposition 2 ([15]). Let k \u2265 2 and K = ( k 2 )\n, and let A be any \u03c4 -structure such that the (k \u00d7 K)grid is a minor of the Gaifman graph of a core of A. For any given graph G, one can compute in polynomial time (w.r.t. \u2016G\u2016) a \u03c4 -structure BA,G such that G contains a k-clique if, and only if, there is a homomorphism from A to BA,G.\nWe can now prove the necessity of bounded treewidth for tractability WPD.\nTheorem 8. Assume FPT 6= W[1]. Let A be any bounded-arity recursively-enumerable class of \u2113structures closed under taking minors. Then, the following are equivalent:\n(1) A has bounded treewdith; (2) For every A \u2208 A, for every r-structure B, and for every set of variables O \u2286 A, the ECSP instance\n(A,B, O) is solvable WPD.\nProof. The fact that (1) \u21d2 (2) holds follows by specializing Theorem 7 to the tree decomposition method. We next focus on showing that (2) \u21d2 (1) also holds.\nLet A be such a bounded-arity class of \u2113-structures closed under taking minors, and having unbounded treewidth. From this latter property, by the Excluded Grid Theorem [20] it follows that every grid is a minor of the Gaifman graph of some \u2113-structure in A. Moreover, because this class is closed under taking minors, every grid is actually the Gaifman graph of some \u2113-structure in A.\nAssume there is a deterministic Turing machine M that is able to solve with polynomial delay any ECSP instance (A,B, O) such that A \u2208 A. We show that this entails the existence of an FPT algorithm to solve the W[1]-hard problem p-CLIQUE, which of course implies FPT = W[1].\nLet G be a graph instance of the p-CLIQUE problem, with the fixed parameter k \u2265 2. We have to decide whether G has a clique of cardinality k. We enumerate the recursively enumerable class A until we eventually find an \u2113-structure A whose Gaifman graph is the (k \u00d7 K)-grid. Let \u03c4 be its vocabulary. Note that searching for this structure A depends on the fixed parameter k only (in particular, it is independent of G).\nLet O \u2286 A be the variables at the four corners of this grid, and let A\u2032 be the extension of A such that, for every variable X \u2208 O, the vocabulary \u03c4 \u2032 of A\u2032 contains the domain relation-symbol dom(X). Thus, the Gaifman graph of A\u2032 is the same (k\u00d7K)-grid as for A, but its four corners are domain-restricted in A\n\u2032 (O \u2286 drv (A\u2032)). From Lemma 1, A\u2032 is a core. Recall now the grid-based construction in Proposition 2: We can build in polynomial time (w.r.t.\n\u2016G\u2016) a structure B\u2032 A\u2032,G such that there is a homomorphism from A \u2032 to B\u2032 A\u2032,G if, and only if, G has a clique of cardinality k. Consider the ECSP instance (A,B, O) where A \u2208 A by construction, and B is the restriction of B \u2032 A\u2032,G to the vocabulary \u03c4 . Thus, compared with B \u2032 A\u2032,G, the r-structureB may miss the domain constraint dom(X) for some output variable X \u2208 O. It is easy to see that h is a homomorphism from A\u2032 to B\u2032 A\u2032,G if, and only if, h is a homomorphism from A to B such that, for every X \u2208 O, h(X) \u2208 dom(X)B \u2032\nA\u2032,G . Therefore, to decide whether such a homomorphism exists (and hence to solve the clique problem), we can just enumerate WPD the set of solutions AB[O] and check whether the four domain constraints on the corners of A\u2032 are satisfied by any of these solutions. Now, recall that B\u2032\nA\u2032,G is built in polynomial time from G, and thus every variable may take only a polynomial number of values, and of course all combinations of four values from dom(X)B \u2032\nA\u2032,G , X \u2208 O, are polynomially many. It follows that M actually takes polynomial time for computing AB[O], and one may then check in polynomial time whether the additional domain constraints in A\u2032 are satisfied or not by some solution in AB[O].\nBy combining the above ingredients, we got an FPT algorithm to decide whether G has a clique of cardinality k. \u22b3"}], "references": [{"title": "Tree-Related Widths of Graphs and Hypergraphs", "author": ["I. Adler"], "venue": "SIAM Journal Discrete Mathematics,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "On the Power of k-Consistency", "author": ["A. Atserias", "A. Bulatov", "V. Dalmau"], "venue": "In Proc. of ICALP\u201907,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2007}, {"title": "The power of natural semijoins", "author": ["P.A. Bernstein", "N. Goodman"], "venue": "SIAM Journal on Computing,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1981}, {"title": "Enumerating Homomorphism", "author": ["A. Bulatov", "V. Dalmau", "M. Grohe", "D. Marx"], "venue": "In Proc. of STACS\u201909,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Beyond Hypertree Width: Decomposition Methods Without Decompositions", "author": ["H. Chen", "V. Dalmau"], "venue": "In Proc. of CP\u201905,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2005}, {"title": "A unified theory of structural tractability for constraint satisfaction problems", "author": ["D. Cohen", "P. Jeavons", "M. Gyssens"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1999}, {"title": "The tree projection theorem and relational query processing", "author": ["N. Goodman", "O. Shmueli"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1984}, {"title": "A Comparison of Structural CSP Decomposition Methods", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Artificial Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2000}, {"title": "Hypertree decompositions and tractable queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2002}, {"title": "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "J. of Computer and System Sciences,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "Generalized hypertree decompositions: NP-hardness and tractable variants", "author": ["G. Gottlob", "Z. Mikl\u00f3s", "T. Schwentick"], "venue": "Journal of the ACM,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2009}, {"title": "When is the evaluation of conjunctive queries tractable", "author": ["M. Grohe", "T. Schwentick", "L. Segoufin"], "venue": "In Proc. of STOC\u201901,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2001}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2007}, {"title": "Constraint solving via fractional edge covers", "author": ["M. Grohe", "D. Marx"], "venue": "In Proc. of SODA\u201906,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2006}, {"title": "Approximating fractional hypertree width", "author": ["D. Marx"], "venue": "In Proc. of SODA\u201909,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Graph minors III: Planar tree-width", "author": ["N. Robertson", "P.D. Seymour"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1984}, {"title": "Graph minors V: Excluding a planar graph", "author": ["N. Robertson", "P.D. Seymour"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1986}, {"title": "Solving Queries by Tree Projections", "author": ["Y. Sagiv", "O Shmueli"], "venue": "ACM Transaction on Database Systems,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1993}, {"title": "Uniform Constraint Satisfaction Problems and Database Theory", "author": ["F. Scarcello", "G. Gottlob", "G. Greco"], "venue": "In Complexity of Constraints,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2008}], "referenceMentions": [{"referenceID": 5, "context": "The decision problem CSP(A,\u2212) has intensively been studied in the literature, and various classes of structures over which it can be solved in polynomial time have already been singled out (see [6, 9, 16, 1], and the references therein).", "startOffset": 194, "endOffset": 207}, {"referenceID": 8, "context": "The decision problem CSP(A,\u2212) has intensively been studied in the literature, and various classes of structures over which it can be solved in polynomial time have already been singled out (see [6, 9, 16, 1], and the references therein).", "startOffset": 194, "endOffset": 207}, {"referenceID": 14, "context": "The decision problem CSP(A,\u2212) has intensively been studied in the literature, and various classes of structures over which it can be solved in polynomial time have already been singled out (see [6, 9, 16, 1], and the references therein).", "startOffset": 194, "endOffset": 207}, {"referenceID": 0, "context": "The decision problem CSP(A,\u2212) has intensively been studied in the literature, and various classes of structures over which it can be solved in polynomial time have already been singled out (see [6, 9, 16, 1], and the references therein).", "startOffset": 194, "endOffset": 207}, {"referenceID": 7, "context": "with possibly infinite domains, the open question in [8] (just recently answered by [13] on finite structures) would have been solved in 1993 [21].", "startOffset": 53, "endOffset": 56}, {"referenceID": 18, "context": "with possibly infinite domains, the open question in [8] (just recently answered by [13] on finite structures) would have been solved in 1993 [21].", "startOffset": 142, "endOffset": 146}, {"referenceID": 7, "context": "This very general approach traces back to the seminal database paper [8], and it is based on the graph-theoretic notion of tree-projection of the pair of hypergraphs (HA,HV), associated with the input structure A and with the structure V of the available views, respectively (tree projections are formally defined in Section 2).", "startOffset": 69, "endOffset": 72}, {"referenceID": 10, "context": "For instance, assume that the fixed threshold on the width is k: in the generalized hypertree-width method [11], the available views are all subproblems involving at most k constraints from the given CSP instance; in the case of treewidth [19], the views are all subproblems involving at most k variables; for fractional hypertree-width, the views are all subproblems having fractional cover-width at most k (in fact, if we require that they are computable in polynomial-time, we may instead use those subproblems defined in [17] to compute a O(k) approximation of this notion).", "startOffset": 107, "endOffset": 111}, {"referenceID": 16, "context": "For instance, assume that the fixed threshold on the width is k: in the generalized hypertree-width method [11], the available views are all subproblems involving at most k constraints from the given CSP instance; in the case of treewidth [19], the views are all subproblems involving at most k variables; for fractional hypertree-width, the views are all subproblems having fractional cover-width at most k (in fact, if we require that they are computable in polynomial-time, we may instead use those subproblems defined in [17] to compute a O(k) approximation of this notion).", "startOffset": 239, "endOffset": 243}, {"referenceID": 15, "context": "For instance, assume that the fixed threshold on the width is k: in the generalized hypertree-width method [11], the available views are all subproblems involving at most k constraints from the given CSP instance; in the case of treewidth [19], the views are all subproblems involving at most k variables; for fractional hypertree-width, the views are all subproblems having fractional cover-width at most k (in fact, if we require that they are computable in polynomial-time, we may instead use those subproblems defined in [17] to compute a O(k) approximation of this notion).", "startOffset": 525, "endOffset": 529}, {"referenceID": 4, "context": "Note that, for the special case of generalized hypertree-width, the fact that enforcing GAC on all clusters of k constraints is sufficient to solve the given instance, without computing a decomposition, has been re-derived in [5] (with proof techniques different from those in [8]).", "startOffset": 226, "endOffset": 229}, {"referenceID": 7, "context": "Note that, for the special case of generalized hypertree-width, the fact that enforcing GAC on all clusters of k constraints is sufficient to solve the given instance, without computing a decomposition, has been re-derived in [5] (with proof techniques different from those in [8]).", "startOffset": 277, "endOffset": 280}, {"referenceID": 4, "context": "Moreover, [5] actually provided a stronger result, as it is proved that this property holds even if there is some homomorphically equivalent subproblem having generalized hypertree-width at most k.", "startOffset": 10, "endOffset": 13}, {"referenceID": 1, "context": ", with a fixed maximum number of variables in any constraint scope of every instance of the class), the question has been answered in [2]: \u2200A \u2208 A, k-GAC is correct for every right-hand structure B if, and only if, the core of A has tree width at most k (recall that treewidth and generalized hypertree-width identify the same set of bounded-arity tractable classes).", "startOffset": 134, "endOffset": 137}, {"referenceID": 13, "context": "In fact, for any recursively enumerable class of bounded-arity structures A, it is known that this method is essentially optimal: CSP(A,\u2212) is solvable in polynomial time if, and only if, the cores of the structures in A have bounded treewidth (under standard complexity theoretic assumptions) [15].", "startOffset": 293, "endOffset": 297}, {"referenceID": 14, "context": "Generalized hypertree-width does not characterize all classes of (arbitrary) structures where CSP(A,\u2212) is solvable in polynomial time [16].", "startOffset": 134, "endOffset": 138}, {"referenceID": 6, "context": "It seems that a useful characterization may be obtained by relaxing the typical requirement that views are computable in polynomial time, and by requiring instead that such tasks are fixed-parameter tractable (FPT) [7].", "startOffset": 215, "endOffset": 218}, {"referenceID": 19, "context": "In particular, it has been observed by different authors [22, 4] that there are classes of instances having bounded treewidth modulo homomorphically equivalence for which answers computable in polynomial time cannot be trusted.", "startOffset": 57, "endOffset": 64}, {"referenceID": 3, "context": "In particular, it has been observed by different authors [22, 4] that there are classes of instances having bounded treewidth modulo homomorphically equivalence for which answers computable in polynomial time cannot be trusted.", "startOffset": 57, "endOffset": 64}, {"referenceID": 4, "context": "For instance, the algorithm in [5] solves the no-promise search-problem of computing a homomorphism for a given CSP instance (A,B).", "startOffset": 31, "endOffset": 34}, {"referenceID": 3, "context": "While the structural tractability of deciding whether CSP instances admit solutions has been deeply studied in the literature, the structural tractability of the corresponding computation problem received considerably less attention so far [4], though this is certainly a more appealing problem for practical applications.", "startOffset": 240, "endOffset": 243}, {"referenceID": 13, "context": ", [15]), and both approaches are dealt with in this paper.", "startOffset": 2, "endOffset": 6}, {"referenceID": 13, "context": "Unlike previous approaches that considered additional \u201cvirtual\u201d constraints covering together all possible output variables [15], in this paper possible output variables are described as those variables", "startOffset": 124, "endOffset": 128}, {"referenceID": 13, "context": "Note that this approach does not limit the number of solutions, while in the tractable classes considered in [15] only instances with a polynomial number of (projected) solutions may be dealt with.", "startOffset": 109, "endOffset": 113}, {"referenceID": 0, "context": "(4) For recursively enumerable classes of structures having bounded arity, we exhibit a dichotomy showing that the above tractability result is tight, for DM = treewidth (and assuming FPT 6= W [1]).", "startOffset": 193, "endOffset": 196}, {"referenceID": 3, "context": "This algorithm generalizes to the tree projection framework the enumeration algorithm of projected solutions recently proposed for the special case of treewidth [4].", "startOffset": 161, "endOffset": 164}, {"referenceID": 13, "context": "We speak of \u201cevidence,\u201d instead of saying that our result completely answers the open question in [15, 4], because our dichotomy theorem focuses on classes of structures satisfying the technical property of being closed under taking minors (in fact, the same property assumed in the first dichotomy result on the complexity of the decision problem on classes of graphs [14]).", "startOffset": 98, "endOffset": 105}, {"referenceID": 3, "context": "We speak of \u201cevidence,\u201d instead of saying that our result completely answers the open question in [15, 4], because our dichotomy theorem focuses on classes of structures satisfying the technical property of being closed under taking minors (in fact, the same property assumed in the first dichotomy result on the complexity of the decision problem on classes of graphs [14]).", "startOffset": 98, "endOffset": 105}, {"referenceID": 12, "context": "We speak of \u201cevidence,\u201d instead of saying that our result completely answers the open question in [15, 4], because our dichotomy theorem focuses on classes of structures satisfying the technical property of being closed under taking minors (in fact, the same property assumed in the first dichotomy result on the complexity of the decision problem on classes of graphs [14]).", "startOffset": 369, "endOffset": 373}, {"referenceID": 9, "context": "2 For instance, for any fixed natural number k, the generalized hypertree decomposition method [10] (short: hwk) is associated with the functions l-hwk and r -hwk that, given a CSP instance (A,B), build the pair (l-hwk (A), r -hwk (A,B)) where, for each subset C of at most k constraints from (A,B), there is a view RC such that: (1) var (R l-hwk (A) C ) is the set of all variables occurring in C, and (2) the tuples in Rr-hwk (A,B) C are the solutions of the subproblem encoded by C.", "startOffset": 95, "endOffset": 99}, {"referenceID": 16, "context": "Similarly, the tree decomposition method [19] (twk) is defined as above, but we consider each subset of at most k variables in A instead of each subset of at most k constraints.", "startOffset": 41, "endOffset": 45}, {"referenceID": 2, "context": "A hypergraph H is acyclic iff it has a join tree [3], i.", "startOffset": 49, "endOffset": 52}, {"referenceID": 11, "context": "The problem of deciding whether a pair of hypergraphs has a tree projection is called the tree projection problem, and it has recently been proven to be NP-complete [12].", "startOffset": 165, "endOffset": 169}, {"referenceID": 7, "context": "Note that the result answered a long standing open question [8, 21] about the relationship between the existence of tree projections and (local and global) consistency properties in databases [13].", "startOffset": 60, "endOffset": 67}, {"referenceID": 18, "context": "Note that the result answered a long standing open question [8, 21] about the relationship between the existence of tree projections and (local and global) consistency properties in databases [13].", "startOffset": 60, "endOffset": 67}, {"referenceID": 1, "context": "Note that if we consider decision problem instances (O = \u2205) and the treewidth method (AV = l-twk (A)), from Theorem 2-bis, we (re-)obtain the nice characterization of [2] about the relationship between k-local consistency and treewidth modulo homomorphic equivalence.", "startOffset": 167, "endOffset": 170}, {"referenceID": 4, "context": ", the power of the algorithm for the decision problem described in [5]).", "startOffset": 67, "endOffset": 70}, {"referenceID": 13, "context": "Indeed, the implication (2) \u21d2 (1) in the theorem below easily follows from the well-known dichotomy for the decision version [15], which is obtained in the special case of ECSP instances without output variables (O = \u2205).", "startOffset": 125, "endOffset": 129}, {"referenceID": 0, "context": "Assume FPT 6= W [1].", "startOffset": 16, "endOffset": 19}, {"referenceID": 13, "context": "We also exploit the grid-based construction from [15], whose properties relevant to this paper may be summarized as follows.", "startOffset": 49, "endOffset": 53}, {"referenceID": 13, "context": "Proposition 2 ([15]).", "startOffset": 15, "endOffset": 19}, {"referenceID": 0, "context": "Assume FPT 6= W[1].", "startOffset": 15, "endOffset": 18}, {"referenceID": 17, "context": "From this latter property, by the Excluded Grid Theorem [20] it follows that every grid is a minor of the Gaifman graph of some l-structure in A.", "startOffset": 56, "endOffset": 60}, {"referenceID": 0, "context": "We show that this entails the existence of an FPT algorithm to solve the W[1]-hard problem p-CLIQUE, which of course implies FPT = W[1].", "startOffset": 74, "endOffset": 77}, {"referenceID": 0, "context": "We show that this entails the existence of an FPT algorithm to solve the W[1]-hard problem p-CLIQUE, which of course implies FPT = W[1].", "startOffset": 132, "endOffset": 135}], "year": 2017, "abstractText": "The problem of deciding whether CSP instances admit solutions has been deeply studied in the literature, and several structural tractability results have been derived so far. However, constraint satisfaction comes in practice as a computation problem where the focus is either on finding one solution, or on enumerating all solutions, possibly projected over some given set of output variables. The paper investigates the structural tractability of the problem of enumerating (possibly projected) solutions, where tractability means here computable with polynomial delay (WPD), since in general exponentially many solutions may be computed. A general framework based on the notion of tree projection of hypergraphs is considered, which generalizes all known decomposition methods. Tractability results have been obtained both for classes of structures where output variables are part of their specification, and for classes of structures where computability WPD must be ensured for any possible set of output variables. These results are shown to be tight, by exhibiting dichotomies for classes of structures having bounded arity and where the tree decomposition method is considered.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}