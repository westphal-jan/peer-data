{"id": "1107.0042", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Restricted Value Iteration: Theory and Algorithms", "abstract": "Value estimation is a popular algorithm for finding approximately optimal guidelines for POMDPs. It is inefficient because the entire belief space must be taken into account, which requires the solution of a large number of linear programs. In this paper, we examine the value estimation, which is limited to beliefs. We show that a limited value estimation, together with correctly selected beliefs, results in near-optimal guidelines and we give a condition for whether a particular belief division would result in savings in time and space. We also apply a limited value estimation to two interesting classes of POMDPs, namely informative POMDPs and nearly recognizable POMDPs.", "histories": [["v1", "Thu, 30 Jun 2011 20:38:52 GMT  (275kb)", "http://arxiv.org/abs/1107.0042v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["n l zhang", "w zhang"], "accepted": false, "id": "1107.0042"}, "pdf": {"name": "1107.0042.pdf", "metadata": {"source": "CRF", "title": "Restricted Value Iteration: Theory and Algorithms", "authors": ["Weihong Zhang", "Nevin L. Zhang"], "emails": ["wzhang@cs.wustl.edu", "lzhang@cs.ust.hk"], "sections": [{"heading": "1. Introduction", "text": "Partially Observable Markov Decision Processes (POMDPs) provide a general framework for sequential decision-making tasks where the effects of an agent\u2019s actions are nondeterministic and the states of the world or environment are not known with certainty. Due to the model generality, POMDPs have found a variety of potential applications in reality (Monahan, 1982; Cassandra, 1998b). However, solving POMDPs is computationally intractable. Extensive efforts have been devoted to developing efficient algorithms for finding solutions to POMDPs (Parr & Russell, 1995; Cassandra, Littman, & Zhang, 1997; Cassandra, 1998a; Hansen, 1998; Zhang, 2001).\nValue iteration is a popular algorithm for solving POMDPs. Two central concepts in value iteration are belief state and value function. A belief state, a probability distribution over the state space, measures the probability that the environment is in each state. All possible belief states constitute a belief space. A value function specifies a payoff or cost for each belief state in the belief space. Value iteration proceeds in an iterative fashion. Each iteration, referred to as a dynamic programming (DP) update, computes a new value function from the current one. When the algorithm terminates, the final value function is used for the agent\u2019s action selection. Value iteration is computationally expensive because, at each iteration, it updates the current value function over the entire belief space, which necessitates the solution of a large number of linear programs.\nOne generic strategy to accelerate value iteration is to restrict value iteration, that is, DP updates, to a subset of the belief space. For simplicity, a subset of the belief space is referred to as belief subset. Existing value iteration algorithms working with belief subsets include a family of grid-based algorithms where DP updates calculate values for a finite grid (Lovejoy,\nc\u00a92005 AI Access Foundation. All rights reserved.\n1991; Hauskrecht, 1997; Zhou & Hansen, 2001), and several (maybe anytime) algorithms where DP updates calculate values for a growing belief subset (Dean, Kaelbling, Kirman, & Nicholson, 1993; Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000). By restricting value iteration into a belief subset, the complexity of value functions is reduced and also DP updates are more efficient. These advantages have been observed by several researchers (Hauskrecht & Fraser, 1998; Roy & Gordon, 2002; Zhang & Zhang, 2001b; Pineau, Gordon, & Thrun, 2003).\nA fundamental issue in restricted value iteration is how to select a belief subset. The efficiency of value iteration and the quality of its generated value functions strongly depend on the selected belief subset. In one extreme case, if the subset is chosen to be a singleton set, value iteration is efficient, but the quality of value functions can be arbitrarily poor. In the other extreme case, if the subset is the belief space, the quality of value functions is retained, but the algorithm is inefficient. There exists a tradeoff between the size of the belief subset and the quality of value functions.\nIn this paper, we show that it is indeed possible for value iteration to not only work with a belief subset but also retain the quality of value functions. This is achieved by deliberately selecting a belief subset for value iteration. Sometimes, we refer to the algorithm working with our selected belief subset as subset value iteration. (For distinction, restricted value iteration refers to value iteration working with any belief subset.) The efficiency of subset value iteration depends on the size of the selected subset. We characterize a condition to a priori determine whether the subset is proper 1 with respect to the belief space for a given POMDP. If this is the case, subset value iteration carries the space and time advantages.\nWe also study two special POMDP classes, namely informative POMDPs and neardiscernible POMDPs. An informative POMDP assumes that an agent has a good albeit imperfect idea about world states at any time point. For an informative POMDP, there exists a natural belief subset so that value iteration restricted to it can be more efficient than standard value iteration (Zhang & Liu, 1997). A near-discernible POMDP assumes that an agent has a good idea about world states once in a while. For a near-discernible POMDP, we propose a restricted value iteration algorithm that starts with a small belief subset and grows it gradually. The algorithm terminates as a proper tradeoff between size of the subset and policy quality is found. Because of near-discernibility, the algorithm is able to find a good tradeoff before the subset grows too large.\nThe algorithms developed in this paper have been tested in a variety of small maze problems designed to possess various properties as desired, and a number of problems adapted from existing research or created from our office environment. Our results show that by exploiting problem characteristics, restricted value iterations can solve larger POMDPs than standard value iteration. We show how the algorithmic performances vary with the properties of the selected belief subset for the maze problems. These small problems facilitate exposition of the properties of the chosen belief subsets. Meanwhile, the experiments provide clues on which POMDP classes are amenable to perspective algorithms.\nThe rest of the paper is organized as follows. In the next section, we introduce the POMDP model and value iteration. In the two subsequent sections, we present our subset value iteration algorithm and analyze its theoretical properties. In particular, in Section\n1. Set A is a proper subset of set B if (1) A is a subset of B, and (2) there exists at least one element in B such that it does not belong to A.\n3, we show how to select the belief subset and how the selected subset is related to the belief space. In Section 4, we describe the subset value iteration algorithm and discuss why it is able to achieve near optimality. In Section 5, we examine informative POMDPs and show how the algorithm that exploits the informativeness is related to the general subset value iteration (Zhang & Liu, 1997). In Section 6, we examine near-discernible POMDPs and develop an anytime algorithm. We empirically demonstrate that the algorithm is able to compute value functions of high quality. In Section 7, we survey related work to this research."}, {"heading": "2. POMDPs and Value Iteration", "text": "This section gives a brief overview of the POMDP model and value iteration."}, {"heading": "2.1 POMDPs", "text": "A POMDP is a sequential decision model for an agent who acts in a stochastic environment with only partial knowledge about the state of its environment. The set of possible states of the environment is referred to as the state space and is denoted by S. At each point in time, the environment is in one of the possible states. The agent does not directly observe the state. Rather, it receives an observation about it. We denote the set of all possible observations as Z. After receiving the observation, the agent chooses an action from a set A of possible actions and executes that action. Thereafter, the agent receives an immediate reward and the environment evolves stochastically into a next state.\nMathematically, a POMDP is specified by: three sets S, Z, and A; a reward function r(s, a) for s in S and a in A; a transition probability function P (s\u2032|s, a); and an observation probability function P (z|s\u2032, a) for z in Z and s\u2032 in S. The reward function characterizes the dependency of the immediate reward on the current state s and the current action a. The transition probability characterizes the dependency of the next state s\u2032 on the current state s and the current action a. The observation probability characterizes the dependency of the observation z at the next time point on the next state s\u2032 and the current action a."}, {"heading": "2.2 Policies and Value Functions", "text": "Since the current observation does not necessarily fully reveal the identity of the current state, the agent needs to consider all previous observations and actions when choosing an action. Information about the current state contained in the current observation, previous observations, and previous actions can be summarized by a probability distribution over the state space (Astro\u0308m, 1965). The probability distribution is sometimes called a belief state and denoted by b. For any possible state s, b(s) is the probability that the current state is s. The set of all possible belief states is called the belief space. We denote it by B.\nA policy prescribes an action for each possible belief state. In other words, it is a mapping from B to A. Associated with a policy \u03c0 is its value function V \u03c0. For each belief state b, V \u03c0(b) is the expected total discounted reward that the agent receives by following the policy starting from b, i.e., V \u03c0(b) = E\u03c0,b[ \u2211\u221e t=0 \u03bb\ntrt] where rt is the reward received at time t and \u03bb (0\u2264\u03bb<1) is the discount factor. It is known that there exists a policy \u03c0\u2217 such that V \u03c0 \u2217 (b)\u2265V \u03c0(b) for any other policy \u03c0 and any belief state b (Puterman, 1994).\nSuch a policy is called an optimal policy. The value function of an optimal policy is called the optimal value function. We denote it by V \u2217. For any positive number \u01eb, a policy \u03c0 is \u01eb-optimal if V \u03c0(b) + \u01eb \u2265 V \u2217(b) for any b in B."}, {"heading": "2.3 Value Iteration", "text": "To explain value iteration, we need to consider how the belief state evolves over time. Let b be the current belief state. The belief state at the next point in time is determined by the current belief state, the current action a, the next observation z. We denote it by \u03c4(b, a, z). For any state s\u2032, \u03c4(b, a, z) is given by\n\u03c4(b, a, z)(s\u2032) =\n\u2211\ns P (z, s \u2032|s, a)b(s)\nP (z|b, a) , (1)\nwhere P (z, s\u2032|s, a)=P (z|s\u2032, a)P (s\u2032|s, a) and P (z|b, a)= \u2211 s,s\u2032 P (z, s \u2032|s, a)b(s) is the renormalization constant. As the notation suggests, the constant can also be interpreted as the probability of observing z after taking action a in belief state b.\nWith the concept of belief state, a POMDP model can be transformed into a belief space MDP as follows.\n\u2022 The state space is B and the action space is A.\n\u2022 Given a belief state b and an action a, the transition model specifies the transition probability as follows.\nP (b\u2032|b, a) =\n{\nP (z|b, a) if b\u2032 = \u03c4(b, a, z) for some z, 0 otherwise.\n\u2022 Given a belief state b and action a, the reward model specifies immediate reward r(b, a) as r(b, a) = \u2211\ns\u2208S b(s)r(s, a).\nDue to this reformulation, the task of solving a POMDP can be accomplished by solving the reformulated MDP. It has been proven that the reformulated MDP has a stationary optimal policy, which can be found by stochastic dynamic programming (Bellman, 1957; Puterman, 1994).\nValue iteration is a dynamic programming algorithm for finding \u01eb-optimal policies for an MDP. It starts with an initial value function V0 and iterates using the following formula:\nVn+1(b) = max a\n[r(b, a) + \u03bb \u2211\nz\nP (z|b, a)Vn(\u03c4(b, a, z))] \u2200b \u2208 B (2)\nwhere Vn is referred to as the nth-step value function. It is known that Vn geometrically converges to V \u2217 as n goes to infinity.\nFor a given value function V , a policy \u03c0 is said to be V -improving if\n\u03c0(b) = arg max a\n[r(b, a) + \u03bb \u2211\nz\nP (z|b, a)V (\u03c4(b, a, z))] \u2200b \u2208 B. (3)\nThe following theorem tells one when to terminate value iteration given a precision requirement \u01eb (Puterman, 1994). The stopping criterion depends on the quantity maxb\u2208B |Vn(b)\u2212 Vn\u22121(b)|, which is the maximum difference between Vn and Vn\u22121 over the belief space. The quantity is often called Bellman residual between Vn and Vn\u22121 (Puterman, 1994).\nTheorem 1 If maxb |Vn(b) \u2212 Vn\u22121(b)| \u2264 \u01eb(1 \u2212 \u03bb)/(2\u03bb), then the Vn\u22121-improving policy is \u01eb-optimal.\nSince there are infinitely many belief states, value functions cannot be explicitly represented. Fortunately, value functions that one encounters in the process of value iteration admit implicit finite representations (Sondik, 1971)."}, {"heading": "2.4 Technical and Notational Considerations", "text": "For convenience, we view functions over the state space as vectors of size |S|. We use lower case Greek letters \u03b1 and \u03b2 to refer to vectors and script letters V and U to refer to sets of vectors. In contrast, the upper case letters V and U always refer to value functions, that is functions over the belief space B.\nA set V of vectors induces a piecewise linear convex value function (say f) as follows: f(b) = max\u03b1\u2208V \u03b1\u00b7b for any b in B where \u03b1\u00b7b is the inner product of \u03b1 and b. For convenience, we shall abuse notation and use V to denote both a set of vectors and the value function induced by the set. Under this convention, the quantity f(b) can be written as V(b).\nA vector in a set is useless if its removal does not affect the function that the set induces. It is useful otherwise. A set of vectors is minimal if it contains no useless vectors. Let \u03b1 be a vector in set V. It is known that \u03b1 is useful if and only if there is at least one belief state b such that \u03b1\u00b7b > \u03b1\u2032\u00b7b, \u2200\u03b1\u2032 \u2208 V\\{\u03b1}. Such a belief state is called a witness point of \u03b1 because it testifies to the fact that \u03b1 is useful (Kaelbling, Littman, & Cassandra, 1998). To determine the usefulness of a vector in a set, it is sufficient to solve one linear program. To compute a minimal set for a given set V of vectors, it is sufficient to solve |V| linear programs. The procedure of computing a minimal set for a given set of vectors is often referred to as pruning a set."}, {"heading": "2.5 Finite Representation of Value Functions and Value Iteration", "text": "A value function V is represented by a set of vectors if it equals the value function induced by the set. When a value function is representable by a finite set of vectors, there is a unique minimal set that represents the function (Littman, Cassandra, & Kaelbling, 1995).\nSondik (1971) has shown that if a value function is representable by a finite set of vectors, then so are the subsequent value functions derived by DP updates. The process of obtaining the minimal representation for Vn+1 from the minimal representation of Vn is usually referred to as dynamic programming (DP) update.\nIn practice, value iteration for POMDPs is not carried out directly in terms of value functions themselves. Rather, it is carried out in terms of sets of vectors that represent the value functions. One begins with an initial set of vectors V0 (often set to a zero-vector). At each iteration, one performs a DP update on the previous minimal set Vn of vectors and obtains a new minimal set Vn+1 of vectors. One continues until the Bellman residual maxb |Vn+1(b) \u2212 Vn(b)|, which is determined by solving a sequence of linear programs, falls below a threshold."}, {"heading": "3. Belief Subset Selection", "text": "In this section, we show how to select a belief subset for value iteration. We describe a condition determining whether the selected subset is proper w.r.t. the belief space. In addition, we discuss the minimal representation of value functions w.r.t. the selected subset. In the next section, we develop the subset value iteration algorithm and show why it is able to achieve near optimality."}, {"heading": "3.1 Subset Selection", "text": "Our belief subset selection rests on belief updating. Let the agent\u2019s current belief be b. Its next belief state is \u03c4(b, a, z) if it performs action a and receives observation z. If we vary the belief state b in the belief space B, we obtain a set {\u03c4(b, a, z)|b \u2208 B}. Abusing our notation, we denote this set by \u03c4(B, a, z). In words, no matter which belief state the agent starts with, if it receives z after performing a, its next belief state must be in \u03c4(B, a, z).\nThe union \u222aa,z\u03c4(B, a, z) takes into account the sets of belief states for all possible combinations of actions and observations. It contains all the belief states that the agent can encounter. In other words, the agent\u2019s belief state at any time point must belong to this set regardless of its initial belief state, performed actions and received observations. We denote the set by \u03c4(B,A,Z) or simply \u03c4(B). It is a closed set in the sense that no action can lead the agent to belief states outside \u03c4(B) if the agent starts with a belief state in it. Furthermore, any belief subset between the set \u03c4(B) and the belief space B is closed.\nLemma 1 The set \u03c4(B) is closed. Moreover, if \u03c4(B) \u2286 B\u2032 \u2286 B, B\u2032 is closed.\nAs is apparent, the set \u03c4(B) is a subset of the belief space B. Its definition is an application of reachability analysis (Boutilier, Brafman, & Geib, 1998; Dean et al., 1993). Under the terminology in reachability analysis, the subset \u03c4(B, a, z) comprises the one-step reachable belief states if the agent performs action a and receives observation z, while the subset \u03c4(B) comprises the one-step reachable belief states regardless of performed actions and received observations. Although the belief subset \u03c4(B) is the set of one-step reachable belief states, an appealing property, to be shown in the next subsection, is that value iteration working with it can preserve the quality of the generated value functions."}, {"heading": "3.2 Subset Representation", "text": "Subset representation addresses how to represent the subsets \u03c4(B, a, z) and \u03c4(B). For this, we introduce the concept of belief simplex.\nDefinition 1 Let B = {b1, b2, ..., bk} be a set of belief states. A belief simplex \u03a8 generated by B is the set of belief states {\n\u2211k i=1 \u03bbibi|\u03bbi \u2265 0 and \u2211k i=1 \u03bbi = 1.0}.\nThe set B is said to be a basis of the belief simplex \u03a8. From the definition, the belief simplex (or simply simplex) is the set of convex combinations of the belief states in the basis. Following the standard terms in linear algebra, we can also talk about the minimum basis of a simplex. For convenience, we use notation B\u03a8 to denote a basis of a given simplex \u03a8. Additionally, the simplex with the basis {b1, b2, \u00b7 \u00b7 \u00b7 , bk} is denoted by \u03a8(b1, b2, \u00b7 \u00b7 \u00b7 , bk).\nOur result is that for any a and z, the subset \u03c4(B, a, z) is a simplex. The intuition follows. Let the number of states in a POMDP be n. For each i \u2208 {1, 2, . . . , n}, bi is a unit\nvector, i.e., bi(s) equals 1.0 for s = i and 0.0 otherwise. For belief state bi, if P (z|bi, a) > 0, \u03c4(bi, a, z) is a belief state in \u03c4(B, a, z); if P (z|bi, a) = 0, by the belief update equation \u03c4(bi, a, z) is undefined. In the belief space B, it is trivial to note that any belief state can be represented as a convex combination of belief states in {b1, b2, \u00b7 \u00b7 \u00b7 , bn}. Correspondingly, in the belief subset \u03c4(B, a, z), any belief state can be represented as a convex combination of belief states in {\u03c4(bi, a, z)|P (z|bi, a) > 0}. Hence, {\u03c4(bi, a, z)|P (z|bi, a) > 0} is a basis of \u03c4(B, a, z). For convenience, we denote such a basis by B\u03c4(B,a,z).\nTheorem 2 For any pair [a, z], the subset \u03c4(B, a, z) is a simplex.\nProof: See Appendix A. \u2737 By the above theorem, the subset \u03c4(B) is a union of simplices. Although the subset \u03c4(B) is not linearly representable in its own, it is the union of linearly representable sets. Later in the section, this property is crucial to and will be exploited in finding the minimal representing sets of value functions w.r.t. the belief subset \u03c4(B).\nTo concretize the ideas on subset representation, we give a POMDP example and visualize the simplices for actions and observations. Before presenting the example, we mention that we shall use it for additional purposes later on in this paper. First, we shall use it to show the difference between two conditions determining whether the subset \u03c4(B) is a proper subset of the belief space. Second, we shall use it to demonstrate the fundamental differences between two restricted value iteration algorithms. Example The POMDP has three states {s1, s2, s3}, two actions {a1, a2} and two observations {z1, z2}. We define the transition and observation model for action a1. These models for a2 can be defined similarly. To shorten notations, we use pij to denote the transition probability P (sj |si, a1) and qij to denote the observation probability P (zj |si, a1). We assume that (1) for any state si, the probability pi1 is equal to pi2, i.e., pi1 = pi2; (2) at each state si, observations z1 and z2 are received with the same probability, i.e., qi1 = qi2 = 0.5 for each i; and (3) p11 > p21 > p31. Under these assumptions, the matrix\nPa1z1 =\n\n \n0.5p11 0.5p21 0.5p31 0.5p11 0.5p21 0.5p31\n0.5(1 \u2212 2p11) 0.5(1 \u2212 2p21) 0.5(1 \u2212 2p31)\n\n  . (4)\nBecause of the first assumption, the first two rows of the matrix are the same. In the third row, the probability pi3 is replaced with 1 \u2212 pi1 \u2212 pi2, i.e., 1 \u2212 2pi1.\nWe compute the basis of the belief subset \u03c4(B, a1, z1). Let the basis of the belief space B be the set {(1.0, 0, 0)T , (0, 1.0, 0)T , (0, 0, 1.0)T }. (For a matrix or vector A, AT denotes its transpose.) For action a1 and observation z1, the next belief states, denoted by Ais, are:\nA1 = \u03c4((1.0, 0, 0) T , a1, z1) = (p11, p11, 1.0 \u2212 2p11) T A2 = \u03c4((0, 1.0, 0) T , a1, z1) = (p21, p21, 1.0 \u2212 2p21) T A3 = \u03c4((0, 0, 1.0) T , a1, z1) = (p31, p31, 1.0 \u2212 2p31) T\n(5)\nInterestingly, it can be shown that A2 is a convex combination of A1 and A3. In fact, in can be verified that\n\u03c4((0, 1.0, 0)T , a1, z1) = \u03bb1\u03c4((1.0, 0, 0) T , a1, z1) + \u03bb2\u03c4((0, 0, 1.0) T , a1, z1)\nwhere \u03bb1 = p21\u2212p31 p11\u2212p31 and \u03bb2 = p11\u2212p21 p11\u2212p31\n. Thus \u03bb1 + \u03bb2 = 1.0. Our third assumption ensures that \u03bb1 and \u03bb2 are greater than 0.0. Because A2 is a convex combination of A1 and A3, the three belief states A1 to A3 lie in the same straight line.\nFigure 1 visualizes the belief space B in the left and the simplex \u03c4(B, a1, z1) in the right. The right chart is based on these parameters: p11 = 0.5, p21 = 0.4 and p31 = 0.1. The belief states Ais are the following: A1 = (0.5, 0.5, 0.0) T , A2 = (0.4, 0.4, 0.2) T and A3 = (0.1, 0.1, 0.8) T . We see that the belief space is a triangle area and the belief simplex is a line segment in that area. In the next subsection, we shall return to this point and show why.\nTo show the belief subset \u03c4(B), we continue to define the transition and the observation models for action a2.\n2 We may follow the three assumptions for a1 to define these models for a2, but give a different set of transition probabilities so that a2 differs from a1.\nBy the second assumption that observation z1 and z2 are received with the same probability, the matrix Pai,z1 is identical to Pai,z2 for i \u2208 {1, 2}. So, the simplex \u03c4(B, ai, z1) is identical to \u03c4(B, ai, z2) for each i. As such, the subset \u03c4(B) consists of two line segments in the entire belief space. \u2737"}, {"heading": "3.3 Belief Subset and Belief Space", "text": "We discuss the relationship between the set \u03c4(B) and the belief space B. Since the set \u03c4(B) is a union of simplices, it helps to show how each simplex \u03c4(B, a, z) is related to the belief space B. For an action a and observation z, it turns out that a matrix derived from the transition and observation models plays a central role in determining the simplex. Such a matrix, denoted by Paz, is of dimension |S| \u00d7 |S| and its entry at (s, s\n\u2032) is the joint probability P (s\u2032, z|s, a), i.e.,\nPaz =\n\n   \nP (s\u20321, z|s1, a) P (s \u2032 1, z|s2, a) \u00b7 \u00b7 \u00b7 P (s \u2032 1, z|sn, a) P (s\u20322, z|s1, a) P (s \u2032 2, z|s2, a) \u00b7 \u00b7 \u00b7 P (s \u2032 2, z|sn, a) \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 P (s\u2032n, z|s1, a) P (s \u2032 n, z|s2, a) \u00b7 \u00b7 \u00b7 P (s \u2032 n, z|sn, a)\n\n    .\n2. Other components of the POMDP do not affect our discussions here and are omitted for convenience.\nThe matrix can be used to relate the next belief \u03c4(b, a, z) and the current b. If b and \u03c4(b, a, z) are viewed in column vector form, the belief update Equation (1) can be rewritten as \u03c4(b, a, z) = 1\np(z|b,a)Pazb. Hence, \u03c4(b, a, z) is a transformation of b and the matrix Paz is called the transformational matrix. The following lemma characterizes a condition under which the simplex \u03c4(B, a, z) is the same as the belief space B.\nLemma 2 For any [a, z], there exists a bijection between the simplex \u03c4(B, a, z) and the space B if the matrix Paz is invertible 3.\nThis can be seen from the fact \u03c4(b, a, z) = 1 p(z|b,a)Pazb and \u03c4(B, a, z) is the set of the transformed belief states from the belief space. Consequently, the simplex \u03c4(B, a, z) is a proper subset of B if the matrix Paz is degenerate. We note that the matrix Paz is degenerate if there exists a state s\u2032 such that P (z|s\u2032, a) = 0.0, i.e., there is a state such that the agent can never receive the observation z (if action a is performed). This is because all the entries in the row corresponding to s\u2032 are 0.0 in the matrix. In this case, by the lemma, the set \u03c4(B, a, z) must be a proper subset of the belief space B.\nCorollary 1 If there is a state s such that P (z|s, a) = 0.0, the set \u03c4(B, a, z) is a proper subset of the belief space B.\nHowever, that \u03c4(B, a, z) is a proper subset does not necessarily imply that there exists a state s such that P (z|s, a) = 0.0. Consequently, to determine if a belief simplex is proper, the above corollary provides a sufficient condition; in contrast, Lemma 2 provides a sufficient and necessary condition. This will be illustrated by continuing our discussions on the POMDP example.\nExample (Continued) We consider the simplex \u03c4(B, a1, z1). By the second assumption, z1 can be observed at any state. So, there does not exist a state s such that P (z1|s, a1) = 0.0. On the other hand, the matrix Pa1z1 is degenerate because it has the same two rows. By Lemma 2, the simplex \u03c4(B, a1, z1) is a proper set of the belief space. In fact, as seen in Figure 1, it is a line segment, which can be viewed as a degenerate belief space. \u2737\nWe proceed to discover the relationship between the belief set \u03c4(B, a, z) and the belief space B. Since \u03c4(B, a, z) is the union of the simplices \u03c4(B, a, z), it is a proper subset of the belief space if so is each simplex. In turn, this requires that each transformational matrix is degenerate.\nTheorem 3 The subset \u03c4(B) is a proper subset of belief space B only if the transformational matrices for all actions and observations are degenerate."}, {"heading": "3.4 Subset Value Functions", "text": "We discuss value functions whose domains are belief subset \u03c4(B, a, z) or \u03c4(B). For simplicity, we refer to them as subset value functions. The problem we will examine is, given a set of vectors representing a subset value function, how to compute a minimal set w.r.t. a belief subset. We first consider the case where the subset is a simplex.\n3. A matrix is invertible if its determinant is non-zero. It is degenerate otherwise.\nIn order to calculate a minimal set of vectors, one needs to determine the usefulness of a vector in a set w.r.t. the simplex. Let \u03b2 be a vector in set V and the simplex be \u03c4(B, a, z). The vector \u03b2 is useful w.r.t. \u03c4(B, a, z) if and only if there is a belief state b in the simplex such that \u03b2 \u00b7 b \u2265 \u03b1 \u00b7 b + x where x is a sufficiently small positive number and \u03b1 is a vector in the set V\u2212{\u03b2}. Moreover, if such a belief state b exists, since it is in the simplex, b must be representable by the belief states in the basis B\u03c4(B,a,z), i.e., b = \u2211\ni \u03bbi\u03c4(bi, a, z). If we replace b by \u2211\ni \u03bbi\u03c4(bi, a, z) in \u03b2 \u00b7 b \u2265 \u03b1 \u00b7 b + x, the condition of determining \u03b2\u2019s usefulness is equivalent to this: whether there exists a series of nonnegative numbers \u03bbis such that for any vector \u03b1 in V,\n\u03b2 \u00b7 \u2211\ni\n\u03bbi\u03c4(bi, a, z) \u2265 \u03b1 \u00b7 \u2211\ni\n\u03bbi\u03c4(bi, a, z) + x.\nRewriting the above inequality, we have\n\u2211\ni\n[\u03b2 \u00b7 \u03c4(bi, a, z)]\u03bbi \u2265 \u2211\ni\n[\u03b1 \u00b7 \u03c4(bi, a, z)]\u03bbi + x. (6)\nTo determine \u03b2\u2019s usefulness, the procedure simplexLP in Table 1 is used. When the optimality of the linear program is reached, one checks its objective x. If it is positive, there exists a belief state in belief simplex \u03c4(B, a, z) such that at this belief state \u03b2 dominates other vectors. The belief state is a witness point of \u03b2. It is represented as \u2211\ni \u03bbi\u03c4(bi, a, z) where \u03bbis are the solutions (values of variables) of the linear program. In this case, the belief state \u2211\ni \u03bbi\u03c4(bi, a, z) is returned. For other cases, no belief state is returned and \u03b2 is a useless vector.\nTo determine a vector\u2019s usefulness in a given set, one linear program needs to be solved. If a vector is useless, its removal does not change the value function that the set induces.\nTherefore, to compute a minimal set for a given set V w.r.t. a simplex, one needs to solve |V| linear programs.\nThis procedure is implemented in simplexPrune of Table 1. Its input has two arguments: a set of vectors V 4 and a basis of the simplex B\u03c4(B,a,z). A set U is initialized to be the set V and the set V to be empty at line 1. Useful vectors are added to the set V in the sequel. For each vector in set U , at line 3 the procedure simplexLP is called to determine its uselessness. If it returns a belief state, the vector is added to the set V at line 5. Eventually, the set V becomes the minimal representation of U w.r.t. simplex \u03c4(B, a, z).\nTo compute a minimal set of vectors w.r.t. the subset \u03c4(B), one needs to determine a vector\u2019s usefulness w.r.t. the subset. In turn, one needs to determine its usefulness w.r.t. each simplex. Again, let the set be V and the vector be \u03b2. If \u03b2 is useful w.r.t. a simplex, it must be useful w.r.t. the subset. However, if it is useless w.r.t. a simplex, it may be useful w.r.t. another simplex. Hence, for a simplex, if \u03b2 has been identified as useful, there is no need to check it again for subsequent simplices. After all the simplices have been examined, if \u03b2 is useless w.r.t. all simplices, it is useless w.r.t. the subset. By removing all useless vectors w.r.t. the subset, one obtains the minimal set."}, {"heading": "4. Subset Value Iteration", "text": "In this section, we first describe the value iteration algorithm in belief subset \u03c4(B). We then show that the algorithm is able to achieve near optimality. Finally, we analyze its complexity and report empirical studies."}, {"heading": "4.1 Belief Subset MDP", "text": "Because the subset \u03c4(B) is closed, we are able to define a so-called belief subset MDP (or simply subset MDP). Its state space is the chosen subset \u03c4(B) and other components are the same as those in the MDP transformed from the original POMDP (Section 2.3). The only difference between the two MDPs lies in their state spaces: the state space of the belief subset MDP is a subset of the state space of the belief space MDP."}, {"heading": "4.2 Subset DP Updates", "text": "By MDP theory, the subset MDP admits the following DP update equation where V \u03c4(B) n represents its nth-step value function.\nV \u03c4(B) n+1 (b) = maxa {r(b, a) + \u03bb \u2211\nz\nP (z|b, a)V \u03c4(B)n (\u03c4(b, a, z))} \u2200b \u2208 \u03c4(B). (7)\nFollowing the equation, an implicit DP update computes the minimal set V \u03c4(B) n+1 representing value function V \u03c4(B) n+1 from V \u03c4(B) n representing V \u03c4(B) n . Note that the domains of value functions are belief subset \u03c4(B). For simplicity, such a step is called subset DP update. Implicit subset DP updates can be carried out as standard DP updates. Here, we present a two-pass algorithm due to its conceptual simplicity (Monahan, 1982). It constructs the\n4. For simplicity, we assume that the set V does not contain duplicate vectors. Duplicates can be removed by a simple componentwise check.\nnext set of vectors in two steps \u2013 an enumeration step enumerating all possible vectors and a reduction step removing useless vectors. In the following, we focus on the enumeration step. For the reduction step, since the usefulness of a vector is w.r.t. the subset \u03c4(B), the techniques in the preceding section can be used.\nGiven a set V \u03c4(B) n , a vector in the representing set of V \u03c4(B) n+1 can be defined by a pair of action and a mapping from the set Z of observations to the set V \u03c4(B) n . To be precise, for an action a and a mapping \u03b4, a vector, denoted by \u03b2a,\u03b4, is defined as follows 5. For each s \u2208 S,\n\u03b2a,\u03b4(s) = r(s, a) + \u03bb \u2211\nz\n\u2211\ns\u2032\nP (s\u2032|s, a)P (z|s\u2032, a)\u03b4z(s \u2032) (8)\nwhere \u03b4z is the mapped vector for observation z.\nIf we enumerate all possible combinations of actions and mappings above, we can define various vectors. These vectors form a set\n{\u03b2a,\u03b4|a \u2208 A, \u03b4 : Z \u2192 V \u03c4(B) n & \u2200z, \u03b4z \u2208 V \u03c4(B) n }. (9)\nThe set is denoted by V \u03c4(B) n+1 . By MDP theory, it represents the value function V \u03c4(B) n+1 if the set V \u03c4(B) n represents V \u03c4(B) n .\nLemma 3 The set V \u03c4(B) n+1 represents value function V \u03c4(B) n+1 if V \u03c4(B) n represents V \u03c4(B) n .\nThe above DP update works in a collective fashion in that it directly computes value functions over \u03c4(B). An alternative way to conduct DP updates is to compute value functions for individual simplices one by one. The rationale is that, by letting a DP update work with the finer-grained belief subsets, it could be more efficient than its collective version. A DP update in an individual fashion constructs a collection {V \u03c4(B,a,z) n+1 } of vector sets from a given collection {V \u03c4(B,a,z) n |a \u2208 A, z \u2208 Z} where each V \u03c4(B,a,z) n represents V \u03c4(B) n in the simplex \u03c4(B, a, z). We consider how to construct a set V \u03c4(B,a\u2032,z\u2032) n+1 for one simplex \u03c4(B, a \u2032, z\u2032).\nLikewise, a vector \u03b2a,\u03b4 in V \u03c4(B,a\u2032,z\u2032) n+1 can be defined by an action a and a mapping \u03b4. The fact that \u03c4(b, a, z) must be in \u03c4(B, a, z) for any b implies that for any z, \u03b4z can be restricted to a vector in the set V \u03c4(B,a,z) n . By altering actions and mappings, one obtains the following set:\n{\u03b2a,\u03b4|a \u2208 A, \u03b4 : Z \u2192 \u222aa,zV \u03c4(B,a,z) n , & \u2200z, \u03b4z \u2208 V \u03c4(B,a,z) n }. (10)\nIt differs from (8) in that for an observation z, the mapped vector by \u03b4 is restricted to the set V \u03c4(B,a,z) n . The above set is denoted by V \u03c4(B,a\u2032,z\u2032) n+1 . To obtain its minimal representation, one removes useless vectors from the set w.r.t. the simplex \u03c4(B, a\u2032, z\u2032). The value function that the set V \u03c4(B,a\u2032,z\u2032) n+1 induces is equal to the value function V \u03c4(B) n in the belief simplex \u03c4(B, a\u2032, z\u2032).\n5. The procedure of defining a vector actually constructs an (n+1)th-step policy tree. (See, e.g., Zhang and Liu 1997, for details.)\nLemma 4 For any action a and observation z, each set V \u03c4(B,a,z) n+1 represents the same value function V \u03c4(B) n+1 in the simplex \u03c4(B, a, z) if each V \u03c4(B,a,z) n represents V \u03c4(B) n in the same simplex.\nAlthough subset DP updates can be carried out either collectively or individually, they are essentially equivalent in terms of value functions induced.\nTheorem 4 Let U = \u222aa,zV \u03c4(B,a,z) n+1 . For any b \u2208 \u03c4(B), U(b) = V \u03c4(B) n+1 (b).\nIt is worthwhile to note that for two pairs of actions and observations, the simplices \u03c4(B, a1, z1) and \u03c4(B, a2, z2) might not be disjoint. A few remarks are in order for this case. First, by Theorem 4, for any b in the intersection of the simplices, V \u03c4(B,a1,z1) n+1 (b) = V \u03c4(B,a2,z2) n+1 (b). This is because both sets represent V \u03c4(B) n+1 in \u03c4(B). Second, if a subset DP update is carried out individually, it may generate more vectors than its collective version. This is because the two sets V \u03c4(B,a1,z1) n+1 and V \u03c4(B,a2,z2) n+1 may contain duplicate vectors.\nFinally, we note that to achieve computational savings, sophisticated algorithms for standard DP updates can be applied to subset DP updates. Let us take incremental pruning, one of the most efficient algorithms, as an example (Cassandra et al., 1997; Zhang & Liu, 1997). In standard incremental pruning, all the pruning operations are w.r.t. the belief space; however, when it is used in subset DP updates, all the pruning operations are w.r.t. the belief subsets."}, {"heading": "4.3 Analysis", "text": "We analyze several theoretical properties of the subset value iteration algorithm. Our main results include: value functions generated by subset value iteration are equivalent to those by standard value iteration in some sense; to achieve near optimality, value iteration needs to account for at least the belief subset \u03c4(B); the value function generated by subset value iteration can be used for near optimal decision-making in the entire belief space if the algorithm is appropriately terminated."}, {"heading": "4.3.1 Belief Subset, Value Functions and Value Iterations", "text": "Subset value iteration generates a series {V \u03c4(B) n } of value functions. If its initial value function V \u03c4(B) 0 is the same as the initial V0 of standard value iteration in \u03c4(B), subset value iteration generates the same series of value functions as standard value iteration in \u03c4(B).\nTheorem 5 If V \u03c4(B) 0 (b) = V0(b) for any b in \u03c4(B), then V \u03c4(B) n (b) = Vn(b) for any n and any b in \u03c4(B).\nProof: We first consider one DP update computing value function Vn+1 from the current Vn by DP Equation (2). In its right hand side, since \u03c4(b, a, z) must belong to the subset \u03c4(B), the notation Vn(\u03c4(., ., .)) can be interpreted as a value function over subset \u03c4(B) rather than belief space B. Comparing DP Equation (2) for the belief space B and Equation (7) for belief subset \u03c4(B), we see that Vn+1 and V \u03c4(B) n+1 represent the same value function in \u03c4(B) if so do Vn and V \u03c4(B) n .\nThe theorem is true for n = 0 by the given condition. It is true for n > 0 by induction. \u2737\nMore interestingly, the value function V \u03c4(B) n at step n can be used to derive the value function Vn+1 in standard value iteration. To see why, we first note that a subset value function V \u03c4(B) can be used to define a value function (say V ) by one-step lookahead operation as follows:\nV (b) = max a\n{r(b, a) + \u03bb \u2211\nz\nP (z|b, a)V \u03c4(B)(\u03c4(b, a, z))} \u2200 b \u2208 B. (11)\nThe so-defined V is called V \u03c4(B)-improving value function. Second, comparing Equations (11) and (2), we see that the V \u03c4(B) n -improving value function is actually Vn+1 if V \u03c4(B) n is equal to Vn in \u03c4(B). Consequently, although subset value iteration works with \u03c4(B), value functions generated in standard value iteration can be derived. In this sense, we say \u03c4(B) is a sufficient belief subset since it enables subset value iteration to preserve standard value functions without \u201closs\u201d.\nSince subset value iteration retains the quality of value functions, it can be regarded as an exact algorithm. One interesting question is, if value iteration intends to retain quality, can it work with a proper subset of \u03c4(B)? In general, the answer is no. The reason follows. To compute Vn+1, one needs to keep values V \u03c4(B) n for belief states in \u03c4(B). Otherwise, if one accounts for a proper subset B\u2032 of \u03c4(B), it can be proven that there exists a belief state b in B, an action a and an observation z such that \u03c4(b, a, z) does not belong to B\u2032. It\u2019s known that the value update of Vn+1(b) depends on the values for all possible next belief states. Due to the unavailability of V \u03c4(B) n (\u03c4(b, a, z)), the value Vn+1(b) cannot be calculated exactly. Consequently, if value iteration works with a proper subset of \u03c4(B), it cannot be exact. In other words, it should be an approximate algorithm. To make it be exact, value iteration needs consider at least \u03c4(B). In this sense, the subset \u03c4(B) is said to be a minimal sufficient set.\nInformally we use Figure 2 to illustrate the relationship between belief subsets and value iteration. In the figure, circles represent belief sets. The minimum belief subset for value iteration to retain quality is \u03c4(B), while the maximum subset is the belief space B itself. If value iteration works with belief subset B\u2032 (denoted by dashed circles) between \u03c4(B) and B, its quality is also retained. However, if it works with a proper belief subset of \u03c4(B), in general it is unable to retain the quality of value functions."}, {"heading": "4.3.2 Stopping criterion and decision making", "text": "Subset value iteration starts with an initial value function. As it continues, the Bellman residual maxb\u2208\u03c4(B) |V \u03c4(B) n (b) \u2212 V \u03c4(B) n\u22121 (b)|, the maximum difference between two value functions over the subset \u03c4(B), must become smaller. By MDP theory, if the quantity falls below \u01eb(1\u2212\u03bb)/(2\u03bb), the value function V \u03c4(B) n\u22121 is \u01eb-optimal w.r.t. the subset MDP. In the following, we show that the \u01eb-optimality can be extended to the entire belief space by appropriately terminating the subset value iteration algorithm.\nLet the output value function be V \u03c4(B) n\u22121 . It can be used to define a policy for any belief state in B as in Equation (3) where V is replaced by V \u03c4(B) n\u22121 . The policy \u03c0 is said to be V \u03c4(B) n\u22121 -improving. Note that the policy prescribes an action for any belief state in the belief space. The following theorem tells one when to terminate subset value iteration such that the V \u03c4(B) n\u22121 -improving policy is \u01eb-optimal over the belief space.\nTheorem 6 If maxb\u2208\u03c4(B) |V \u03c4(B) n (b)\u2212V \u03c4(B) n\u22121 (b)| \u2264 \u01eb(1 \u2212 \u03bb)/(2\u03bb 2|Z|), then the V \u03c4(B) n\u22121 -improving policy is \u01eb-optimal over the entire belief space B.\nProof: See Appendix A. \u2737 This theorem is important for two reasons. First, although subset value iteration outputs a subset value function, \u01eb-optimal value functions over the entire space can be induced by one-step lookahead operation. Second, it implies that the V \u03c4(B) n\u22121 -improving policy is \u01eboptimal if the condition is met. We know that \u03c4(B) consists of all possible belief states the agent encounters after the initial belief state. However, we have no assumption about the initial belief state. It may or may not belong to this set. The theorem means that the agent is still able to select a near optimal action for an initial belief state even if it is not in the subset. In fact, the agent can always select near optimal action for any belief state in the entire belief space.\nFinally, we note that to guarantee the \u01eb-optimality, when compared with the condition in Theorem 1, subset value iteration uses a more restrictive condition. For convenience, it is sometimes called a strict stopping criterion. In contrast, the condition in standard value iteration is called a loose stopping criterion."}, {"heading": "4.4 Complexity", "text": "To put in use for a POMDP, the subset value iteration algorithm would take two steps: determining if the algorithm can bring about savings in time and then running the subset value iteration if it can. The first step needs to compute |A||Z| determinants |Paz|. Since the complexity of computing |Paz| is |S|\n3, the first step has the complexity of O(|A||Z||S|3). This is the polynomial part of the complexity of subset value iteration. The second step is much harder than the first step. It is known that finding the optimal policy for even a simplified finite horizon POMDP is PSPACE-complete (Papadimitriou & Tsitsiklis, 1987; Burago, de Rougemont, & Slissekno, 1996; Littman, Goldsmith, & Mundhenk, 1998). Recently, it has been proven that finding the optimal policy for an infinite-horizon POMDP is incomputable (Madani., Hanks, & Condon, 1999).\nWe compare the subset value iteration with standard value iteration. Standard DP updates improve values for the space B, while subset DP updates improve values for the\nsubset \u03c4(B). If the initial set V \u03c4(B) 0 is equal to the initial set V0 in standard value iteration, because \u03c4(B) is a subset of B, the vectors in V \u03c4(B) 1 must be in V1, and V \u03c4(B) 1 is a subset of V1. Inductively, V \u03c4(B) n is a subset of Vn for any n. This analysis suggests two advantages of subset value iteration if the subset \u03c4(B) is a proper subset of the belief space B. First, fewer vectors are needed to represent a value function over a belief subset. This is the representational advantage in space. For Vn+1, its size can be as large as |A||Vn| |Z|. For V \u03c4(B) n+1 , its size can be as large as |A||V \u03c4(B) n | |Z| . Clearly, subset DP update generates fewer vectors. Second, fewer vectors means lesser degree of time complexity since computing vectors needs to solve linear programs. This is the computational advantage in time.\nHowever, the advantages strongly depend upon the size of the subset \u03c4(B). If each simplex \u03c4(B, a, z) is the same as the belief space B and DP updates are conducted in an individual fashion, subset DP updates could be |A||Z| times slower than standard DP updates. This is the worst case complexity. Fortunately, by discussions in the previous section (Theorem 3), we know that given a POMDP we are able to determine whether the selected subset \u03c4(B) is a proper subset of the belief space before solving it.\nAlthough Theorem 3 gives a condition to determine when the subset value iteration is more efficient than standard value iteration for a POMDP, it does not answer the question that how much savings the algorithm can bring about, which turns out to be a very difficult problem in theoretical analysis. The difficulty lies in not only the size of the set \u03c4(B) but also the vectors representing the step and the optimal value functions. Let us assume that \u03c4(B) is a proper subset of the belief space. We can imagine at least two cases. In one case, if at each iteration the step value function has very few useful vectors in the subset \u03c4(B), the subset value iteration can be very efficient. In the other case, if at each iteration the step value function has all useful vectors in the subset \u03c4(B), subset value iteration has the same complexity as standard value iteration in an asymptotic sense. In general, given a POMDP, it is difficult to predict how these vectors scatter around the belief subsets and the belief space. Consequently, it is hard to predict how much saving the subset value iteration algorithm can bring about for a POMDP without solving it."}, {"heading": "4.5 Empirical Studies", "text": "We present our empirical results on two variants of a designed maze problem and the problems in a standard test-bed in this subsection. Some common settings to all experiments in the paper are as follows. The experiments are conducted on an UltraSparc II machine with dual CPUs and 256MB of RAM. Our codes are written in C and executed under a UNIX operating system Sola 2.6. When solving linear programs, we use a commercial package CPLEX V6.0. The discount factor is set at 0.95 and round-off precision is set at 10\u22126. When not stated otherwise, the quality requirement \u01eb is set to 0.01. We use incremental pruning to compute representing sets of value functions over the belief space or belief subsets.\nWe compare the performances of subset and standard value iteration. For simplicity, we denote them respectively by ssVI and VI. At each iteration, we compare VI and ssVI in two measures: sizes of sets representing value functions and total time of DP updates."}, {"heading": "4.5.1 The Maze Problem", "text": "The maze problem is specified in Figure 3. There are 10 locations and the goal is location 9. A robot agent can execute four \u201cmove\u201d actions to change its position, optionally a \u201clook\u201d action to observe its surroundings and a \u201cdeclare\u201d action to announce its success of goalattainment. The \u201cmove\u201d actions can achieve their intended effects with probability 0.8, but might have no effects with probability 0.1 (the agent\u2019s position remains unchanged) or lead to overshooting with probability 0.1. Moving against maze walls leaves the agent at its original location. Other actions do not change the agent\u2019s position. At each time point, the robot receives a \u201cnull\u201d observation giving no useful information at all, or reads four sensors so as to reason about its current position. Each sensor informs the robot whether there is a wall or nothing along a direction. In the figure thick lines stand for walls and thin lines for nothing (open). For instance, if the agent is at location 2, ideally a string \u201cowow\u201d (in the order of East, South, West and North) is received. Specific parameters will be instantiated in relevant empirical analysis. The robot is required to maximize the infinite discounted sum of rewards.\nTwo variants of the above maze are designed to test ssVI and VI. They are denoted by maze1 and maze2. For maze1, ssVI is more efficient; for maze2, ssVI is less efficient.\nCase I: \u03c4(B) \u2282 B The maze1 problem has a state space of 10 locations, an action space of size 5 (four \u201cmove\u201d and one declare) and an observation space of size 6 (strings of four letters). An ideal string is received with certainty after any action is performed. When the agent declares goal at location 9, it receives a reward of 1 unit; if it does so at location 10, it receives a reward of \u22121. Other combinations of actions and observations lead to no reward.\nWe collect the results in Figure 4. The first chart in the figure depicts the total time of DP updates in log-scale for VI with the loose stopping criterion and ssVI with the strict one (Section 4.3.2). To compute a 0.01-optimal value function, VI took 20,000 seconds after 162 iterations while ssVI with strict stopping criterion took 900 seconds after 197 iterations. We note that ssVI needs more iterations but it still takes much less time. The performance difference is big. Moreover, more iterations means that the value function generated by ssVI is closer to optimality.\nThis is not a surprising result if we take a look at the matrix Paz for an action a and observation z. We know that the matrix impacts the size of the simplex \u03c4(B, a, z). The dimension of the matrix is 10 \u00d7 10. The entry of Paz at (i, j) is the product of the transition probability P (sj |si, a) and observation probability P (z|sj , a). Let us assume that\nthe observation be owow. Hence, the possible locations may be 2 or 5. Regardless of actions executed, only entries in row 2 and 5 of Paz can be non-zero. Therefore, the matrix is highly sparse and non-invertible and the simplex \u03c4(B, a, z) is much smaller than B. This analysis holds similarly for other combinations of actions and observations. Hence, ssVI accounts for only a small portion of the belief space. This explains why ssVI is more efficient than VI. In addition, we expect that the sets generated by ssVI are much smaller than those by VI.\nThis is confirmed in the second chart of the figure. It depicts the sizes of the sets representing the value functions generated by ssVI and VI at each iteration. When counting the size of V \u03c4(B) n , we collect the sum of the sizes of representing sets over |A||Z| simplices. We note that at the same iteration VI always generates much more vectors than ssVI. The sizes at both curves increase sharply at first iterations and then stabilize. The size for VI reaches its peak of 2466 at iteration 11 and the maximum size for ssVI is 139 at iteration 10. This size in VI is about 20 times many as that in ssVI. This is a magnitude consistent with the performance difference. After the sizes stabilize, the sizes of the sets generated by VI are around 130 and they are around 50 in ssVI.\nCase II: \u03c4(B) = B\nThe problem maze2 is designed to show that ssVI could be less efficient than VI when the selected belief subset \u03c4(B) is equal to the belief space B. The problem has a state space of 10 locations, an action space of size 6 (four moves, one stay and one declare) and an observation space of size 7 (6 strings and a null telling nothing). The action stay does not change the agent\u2019s position. maze2 has more complications on the observation model. Due to hardware limitations, after a move action, with a probability of 0.1, the agent receives a wrong report where the string owow is collected as owww and woww as wowo. If the declare action is executed, the agent always receives a null observation. In addition, if the agent executes stay, it receives either a null observation with probability 0.9 or the ideal string about the surrounding locations with probability 0.1.\nThe reward model is accordingly changed to reflect new design considerations. We assume that the agent needs to pay for its information about states. For this purpose, if the\nagent executes stay, it really does nothing and thus yields no cost (i.e., negative reward). In contrast, the \u201cmove\u201d actions always cause a cost of 2. Depending on the locations at which it executes declare, it receives rewards or costs: if the location is state 9, it receives a reward of 1; if state 10, it receives a cost of 1; otherwise, it leads to no rewards. The stay action is attractive in that it yields no cost but it leads to an useful observation about states with a small likelihood.\nThe empirical results are collected in Figure 5. First, we note both VI and ssVI are able to run only 11 iterations within a reasonable time limit (8 hours). The first chart in the figure presents the time costs along iterations. To run 11 iterations, ssVI takes 53,000 seconds while VI takes around 30,900 seconds. Therefore, ssVI is slower than VI for this problem. However, the magnitude of performance difference is not big. To explain this, let us consider the matrix Paz for action stay and observation null. The transition matrix is an identity and each state can lead to the null observation with probability of 0.9 if stay is executed. Therefore, the matrix Paz is invertible and the simplex \u03c4(B, a, z) is the same as the belief space B. Because ssVI needs to account for additional simplices for other combinations of actions and observations, ssVI must be less efficient than VI. This explains the performance difference in time between ssVI and VI.\nIt is also anticipated that ssVI should generate more vectors than VI at the same iteration because the size of V \u03c4(B) n is defined to be sum of the individual sets in it. This is confirmed and demonstrated in the second chart of Figure 5. The curve for ssVI is always on the upper side of that for VI. For the 11th iteration, ssVI generates 3,300 vectors and VI generates around 1,700 vectors."}, {"heading": "4.5.2 More Experiments on the Test-Bed", "text": "To validate the performance of the subset value iteration over different problem domains, we collected the results of the algorithm on the standard test-bed maintained by Tony Cassandra 6. In the literature, the eight problems are commonly referred to as 4x3CO, Cheese, 4x4, Part Painting, Tiger, Shuttle, Network, and Aircraft. Table 2 presents detailed\n6. See the URL http://pomdp.org/pomdp/examples/index.shtml\nstatistics for these problems. In the table, Rows 2\u20134 give the sizes of problem parameters, namely the number of states, observations and actions. Row 5 and 6 show the CPU seconds for the standard and subset value iteration algorithms to compute the 0.01-optimal policy for each problem. Row 7 shows the number of the vectors representing the 0.01-optimal value function in standard value iteration. In our experiments, we implemented the subset value iteration in the individual fashion. In Row 8, an entry takes the form \u00b7/\u00b7, denoting the total number of vectors over all |A| \u00b7 |Z| simplices and the maximum number of vectors among these simplices when the subset value iteration terminates. The last row shows whether the belief subset \u03c4(B) is a proper subset of the belief space.\nIn discussing the performances of the subset value iteration algorithm, we categorize the tested problems into three classes. In the first class, the subset \u03c4(B) is actually the same as the belief space. Subset value iteration must be less efficient than standard value iteration. The reason is as follows: there exists at least one belief simplex such that value iteration over it has the same complexity as standard value iteration; moreover, subset value iteration needs to account for other simplices. Example problems are tiger and paint. Let us take the paint problem as an instance. Our results show that there are two simplices are the same as the belief space. The 0.01-optimal value functions over them are represented by 9 vectors, each of which has the same number of vectors representing the 0.01-optimal value function over the entire belief space. In the second class of the tested problems, the set \u03c4(B) is a proper subset of the belief space, and meanwhile the numbers of the vectors representing value functions over the belief space and individual simplices are very small. Subset value iteration may not be so efficient as standard value iteration because of the overhead of accounting for a large number of simplices. Example problems include 4X3CO, cheese and 4X4. Let us take 4X3CO as an instance. The 0.01-optimal value function over the entire belief space is represented by only 4 vectors, whereas the 0.01-optimal value function over each simplex is represented by only 1 vector. Since the subset value iteration has to account for 44 simplices, subset value iteration is less efficient than standard value iteration. In the third class of tested problems, the set \u03c4(B) is a proper subset of the belief space, and meanwhile the numbers of the vectors representing value functions over the belief space are moderately large. The subset value iteration algorithm is more efficient than the standard value iteration algorithm. Examples include shuttle, network and aircraft. Let us take network as an instance. The 0.01-optimal value function in the belief space is represented\nby 491 vectors, whereas the 0.01-optimal value function in \u03c4(B) is represented by less than 201 vectors (note that there are duplicates across belief simplices). The maximum size of the representing sets over all simplices is 50. In this case, we expect that the savings brought by the subset value iteration outweighs the overhead of accounting for the simplices. The result shows that subset value iteration is about 5 times faster than standard value iteration.\nCombining these results with those on the maze problem, we see that the computational savings brought by the subset value iteration vary with different problem domains. Theorem 3 can be used to determine whether subset value iteration can bring about computational savings for a POMDP. In the event that the belief set \u03c4(B) is a proper subset of the belief space, the magnitude of the savings needs to be determined through empirical evaluation."}, {"heading": "5. Informative POMDPs", "text": "In this section, we study a special POMDP class, namely informative POMDPs. For this POMDP class, there are natural belief subsets for value iteration to work with. We will show how to formally define these subsets. As the value iteration over these belief subsets has been described (Zhang & Liu, 1997), our focus is to compare the algorithm with the general subset value iteration developed in the previous section."}, {"heading": "5.1 Motivation", "text": "As noted by some authors, in reality an agent often has a good, although imperfect, idea about its locations (Roy & Gordon, 2002). For instance, mobile robots and other real world systems have local uncertainty, but rarely encounter global uncertainty. Let us exemplify this using the maze in Figure 3. Suppose that at each time point an agent receives a string of four letters with certainty. In total, there are 6 observations, owww, owow, owoo, wwow, wowo and woww regardless of executed actions. If we enumerate all possible observations and the set of locations at which the agent receives such observations, we end up with the following table.\nobservations states observations states\nowww {1 } owow { 2, 5} owoo { 3,4 } wwow { 6 } wowo { 7,8} woww { 9,10 }\nOn the other hand, the strings can be used to infer the agent\u2019s locations. For instance, if a string owoo is received, the world must be at location 3 or 4. Hence, the observation owoo restricts the world into a small range of world states. In fact, any observation can restrict the world into at most two states although the world has ten. For this reason, the POMDP is said to be informative.\nIn general, an agent perceives the world via observations. Starting from any state, if the agent executes an action a and receives an observation z, the world states can be categorized into two classes by the observation model: states the agent can be in and states it cannot. Formally, the former is {s|s \u2208 S and P (z|s, a) > 0}. The set is denoted by Saz. We use the set to define the informativeness. An [a, z] pair is said to be informative if the size |Saz| is much smaller than |S|. An observation z is informative if [a, z] is informative for every action a giving rise to z. A POMDP is informative if all observations are informative.\nIn informative POMDPs, since any observation restricts the world into a small set of states, the agent knows that the world cannot be in the state outside this small set. In other words, for those states outside the set, the agent has zero beliefs. Consequently, an observation can also restrict belief states into a belief subset."}, {"heading": "5.2 Belief Subset Selection", "text": "For informative POMDPs, we can select belief subset \u03c4(B) as before. Combining the informativeness assumption and Corollary 1, we know that \u03c4(B) is a proper subset of the belief space. So, value iteration over \u03c4(B) carries the space and time savings. In this section, we choose an alternative belief subset for value iteration. Compared against the subset \u03c4(B), the subset that we choose yields several advantages. First, it is conceptually simple and geometrically intuitive. Second, it facilitates employing the low dimensional representation of vectors. Third, it may lead to additional savings in time if the observation models of a POMDP are independent of actions. The latter two advantages will be shown later.\nTo define the belief subset (say \u03c6(B)), we first define a subset \u03c6(B, a, z) for an action and observation pair. Then, the belief subset \u03c6(B) is formed by taking the union of \u03c6(B, a, z) over all action and observation pairs. To be specific,\n\u03c6(B, a, z) = {b| \u2211\ns\u2208Saz\nb(s) = 1.0, \u2200s \u2208 Saz, b(s) \u2265 0} (12)\nand \u03c6(B) = \u222aa,z\u03c6(B, a, z).\nIt is trivial to see that \u03c6(B, a, z) is a belief simplex. It can be proven that for any belief state b, \u03c4(b, a, z) must be in \u03c6(B, a, z). Therefore, \u03c4(B, a, z) is a subset of \u03c6(B, a, z). Consequently, \u03c4(B) is a subset of \u03c6(B). This is summarized in the lemma below. The lemma is useful when we discuss the value iteration algorithm working with the belief subset \u03c6(B).\nLemma 5 For a POMDP, \u03c4(B) \u2286 \u03c6(B).\nIt is of interest to compare the \u03c4 -simplex and \u03c6-simplex for a pair of a and z. Although both simplices are generated by a list of belief states, \u03c6-simplex has more intuitive geometric meaning. Each belief state in the basis of \u03c6(B, a, z) is a unit vector, i.e., it has probability mass on one state. Therefore, the belief state in the basis must be a boundary point of the belief space. In contrast, a belief state in the basis of a \u03c4 -simplex can be an interior point. See Figure 1 for an example, where A2, A3 are interior points and A1 is a boundary point of the belief space."}, {"heading": "5.3 Value Iteration over \u03c6(B)", "text": "From the theoretical perspective, the feasibility of conducting value iteration in \u03c6(B) is justified by Lemma 1. Combined with Lemma 5, the subset \u03c6(B) is a closed set. Hence, the MDP theory is applicable to defining the DP update equation. By our discussions on the relationship and value iteration in Section 4.3, value iteration working with \u03c6(B) retains the quality of value functions.\nWe further exploit the informative feature in value iteration over \u03c6(B). We briefly outline the subset value iteration algorithm and refer the readers to a detailed description (Zhang\n& Liu, 1997). The basic idea is to reduce the dimensions of vectors in representing sets of value functions. Note that for any pair [a, z], since the beliefs in states outside Saz are zero, a vector in the representing set of a value function over the simplex \u03c6(B, a, z) needs only |Saz| components. In an individual fashion, a DP update over \u03c6(B) computes a collection {V \u03c6(B,a,z) n+1 } from a collection {V \u03c6(B,a,z) n } where V \u03c6(B,a,z) n is the nth-step value function and the vectors in it have |Saz| dimensions. The procedure of conducting a DP update is parallel to that in Section 4.2 except that \u03c4(B, a, z) is replaced by \u03c6(B, a, z). In the enumeration step, when building a vector \u03b2 in a belief simplex \u03c6(B, a\u2032, z\u2032) using Equation (10), we need only define its components corresponding to the set Sa \u2032z\u2032 . In the reduction step, for each constructed set V \u03c6(B,a\u2032,z\u2032) n+1 , a pruning procedure is called to remove useless vectors to obtain the minimal representation of the set. Note that the lower dimension feature is also used to cut down the number of variables in setting up linear programs.\nInterestingly, DP updates over \u03c6(B) account for a larger subset than those over \u03c4(B). Hopefully, since DP updates over \u03c6(B) explicitly employ the economy of representation, they could be more efficient. In addition, DP updates over \u03c6(B) have another advantage in the event that the observation models of a POMDP are independent of actions, i.e., the probabilities P (z|s, a) being independent of a. Hence, given an observation z, the simplices \u03c6(B, a, z) are the same for all actions. Therefore, DP updates over \u03c6(B) only account for |Z| \u03c6-simplices. However, DP updates over \u03c4(B) usually need to account for |A||Z| \u03c4 -simplices because an observation determines different \u03c4 -simplices when combined with different actions."}, {"heading": "5.4 Empirical Studies", "text": "We have conducted experiments to compare VI, ssVI and infoVI, which refers to value iteration exploiting the low-dimension feature. The experiments on maze1 (defined in Section 4.5) can be found elsewhere (Zhang & Zhang, 2001; Zhang, 2001). The results, together with existing results (Zhang & Liu, 1997), showed that value iteration over \u03c6(B) can be significantly more efficient than standard value iteration. For reference, we mention that it is feasible to integrate a point-based technique and value iteration over \u03c6(B) in order to take advantage of both reducing the iteration number and accelerating the iterative steps (Zhang & Zhang, 2001b). To demonstrate this, we include results on a 96-state POMDP in Appendix B."}, {"heading": "5.5 Restricted Value Iteration and Dimension Reduction", "text": "We compare the value iteration algorithms in this and the previous section. Through the comparison, we would like to emphasize that working with belief subsets does not imply working with low-dimensional vectors.\nAlthough both algorithms work with belief subsets, the mechanisms exploited to achieve the computational gains are different. The general value iteration works with the belief subset \u03c4(B) but the dimension of representing vectors is the same as the number of states, whereas value iteration over \u03c6(B) works with a superset of \u03c4(B) but the dimension of the vectors is smaller than the number of the states. To facilitate demonstrating how a reduced belief set and the low-dimensional representation respectively contribute to the computational gains, we experimented with a carefully designed maze problem that is amenable to\nboth algorithms. However, it is worth pointing out that working with a reduced belief set does not mean that the vectors can be represented in low dimensions. We illustrate this point by continuing our discussions of the example in Section 3.3. Such an example shows that the primary advantage of value iteration over \u03c4(B) stems from the size of the chosen belief subset rather than dimension reduction of the representing vectors.\nExample (Continued) For the POMDP example presented in Section 3.2, the subset \u03c4(B) consists of only two line segments in the entire belief space. Clearly value iteration over \u03c4(B) is more efficient than standard value iteration. However, if one runs value iteration over \u03c6(B) on this POMDP anyhow, the algorithm is less efficient than the standard value iteration algorithm. This follows from (1) the set Saizj is equal to the set of states S for any action ai and observation zj by the second assumption, and (2) each \u03c6-simplex is actually the same as the belief space by the definition in Equation (12). To solve this POMDP, the susbet value iteration algorithm is definitely a better choice than the value iteration algorithm for informative POMDPs. \u2737"}, {"heading": "6. Near-Discernible POMDPs", "text": "In this section, we study near-discernible POMDPs. For this POMDP class, we develop an anytime value iteration algorithm working with growing belief subsets."}, {"heading": "6.1 Motivation", "text": "A discernible POMDP assumes that once in a while the uncertainty about world states vanishes if a particular action is executed and the observations pertain to the action fully reveal the identities of the world (Hansen, 1998). Our research on near-discernible POMDPs was motivated by two aspects. One of them arises from the origin of applying POMDP as a framework for planning under uncertainty. To achieve a goal location, an agent has to not only change its positions by performing goal-achieving actions but also reason about its surroundings by performing information-gathering actions. However, at one time point the agent cannot simultaneously move its positions and observe its environments. For instance, if an information-gathering action is performed, the agent cannot move its positions meanwhile. The other aspect motivating the concept of near-discernibility arises from existing research in the community. Near-discernible POMDPs generalize discernible POMDPs in that even when an information-gathering action is performed, the agent can get a rough, rather than exact, idea about world states and uncertainty vanishes in some sense.\nWe revise the maze problem to fix ideas on the first motivation. The action space consists of six actions: four \u201cmoving\u201d actions, look and declare. If move actions or declare are performed, an observation null is received and the agent gets no information at all. If look is performed, an ideal string is received and the agent gets imperfect information since different locations might yield the same string. On one hand, to achieve the goal location, the agent has to change its positions. On the other hand, to declare goal attainment with confidence, it has to perform look and reason about the environment. Arbitrarily declaring goal attainment leads to a penalty. Consequently, at a time point the agent faces the problem of choosing a move or look.\nWe note that the subset value iteration algorithm usually yields no computational advantage for near-discernible POMDPs. We give an example in which the subset \u03c4(B) is the same as the belief space B under some assumptions. Suppose the maze is a square grid. Locations are numbered such that at each row the indices of the locations increase from left to right. We assume that a move action achieves its intended effects with a high likelihood, but may have no effect (i.e., the agent\u2019s location remains unchanged) or may lead to overshooting with a small probability. Under these assumptions, the transition matrix for action east is upper-triangular and invertible. If at each location null is received with a positive probability after a move, the transformational matrix Peast,null is invertible. By Theorem 3, the belief subset \u03c4(B, east, null) is equal to the belief space B.\nOur solution to near-discernible POMDPs rests on the intuition that the agent needs to interleave goal-achieving actions and information-gathering actions. A typical sequence of executed actions should consist of several goal-achieving actions and an informationgathering action. The difficulty is how frequently the agent should execute an informationgathering action. In this section, we consider the action and observation sequences containing more goal-achieving actions incrementally. We show that such sequences can be used to determine belief simplices. As more sequences are added, the union of the belief simplices grows. In the following, we give some technical preparations and then describe the algorithm designed for near-discernible POMDPs. In order to put our discussions under a general context, we shall use information-rich and information-poor actions instead of information-gathering and goal-achieving actions respectively."}, {"heading": "6.2 Histories, Belief Subsets and Value Functions", "text": "A history is a sequence of ordered pairs of actions and observations. We usually denote a history by h. The number of pairs of actions and observations is referred to as the length of a history. A history of length l is denoted by [a1, z1, \u00b7 \u00b7 \u00b7 , al, zl]. If an agent\u2019s initial belief state is b and a history h of length l is realized, its belief state can be updated at each time step. The notation \u03c4(b, h) denotes the belief at the time point l. The set \u03c4(B, h) is defined to be \u222ab\u2208B\u03c4(b, h), consisting of all possible belief states that the agent can be in at step l if it starts with any belief and history h is realized. Note that if h is of length 1(say h = [a, z]), \u03c4(B, h) degenerates to our previous notation \u03c4(B, a, z).\nLemma 6 For any history h, the belief subset \u03c4(B, h) is a simplex.\nA set of histories is usually denoted by H. The belief subset \u03c4(B,H) denotes the union of simplices for all histories in the set H, i.e., \u222ah\u2208H\u03c4(B, h). Value functions over the simplex \u03c4(B, h) and belief subset \u03c4(B,H) are referred to as V \u03c4(B,h) and V \u03c4(B,H) respectively. Given a set V\u03c4(B,h) representing value function V \u03c4(B,h), the procedure simplexPrune(V, B\u03c4(B,h)) in Table 1 computes the minimal representation of V\u03c4(B,h). In the context of history, the occurrences of the basis B\u03c4(B,a,z) should be replaced by B\u03c4(B,h)."}, {"heading": "6.3 Space Progressive Value Iteration", "text": "We describe the space progressive value iteration (SPVI) algorithm. As an anytime algorithm, SPVI begins with a belief subset and gradually grows it. When a certain stopping\ncriterion is met, SPVI terminates and returns a set of vectors for the agent\u2019s decision making."}, {"heading": "6.3.1 Algorithmic structure", "text": "SPVI interleaves value iteration (computing a value function for a belief subset) and subset expansion (expanding the current belief subset to a larger one). The belief subsets in SPVI are introduced by sets of histories. Subset expansion is achieved through incorporating more histories. For convenience, the set of histories determining the i-th belief subset is denoted by Hi. The belief subset determined by Hi is \u03c4(B,Hi). The value function constructed by SPVI for Hi is V \u03c4(B,Hi).\nThe pseudo-code in Table 3 implements SPVI. A set of histories H0 (and therefore the belief subset \u03c4(B,H0)), a value function V\n\u03c4(B,H0) and the quality precision \u03b7 are initialized at line 1. This step can be regarded as the 0th-step expansion of belief subset. Note that we set the initial value function to be the minimum reward for all pairs of actions and states. (This is for the convergence issue discussed later.) Value iteration over the current subset \u03c4(B,Hi) is conducted at line 3, and the belief subset is expanded to the subset \u03c4(B,Hi+1) through constructing a superset Hi+1 of the current set Hi at line 4. Value function V \u03c4(B,Hi) for the current belief subset is set to be the initial value function for the next subset at line 5. If the stopping condition is not satisfied at line 7, SPVI goes to the next iteration; otherwise, it terminates and returns the latest value function V\u03c4(B,Hi\u22121).\nTo ensure the efficiency of SPVI, its initial belief subset should be chosen to be small. To this end, we set H0 to be {[a, z] | a \u2208 AIR, z \u2208 ZIR} where AIR is the set of information-rich actions and ZIR is the set of observations led to by those actions. The subset \u03c4(B,H0) is small due to the discernability property.\nIn the sequel, we discuss value iteration in a belief subset, subset expansion and the stopping criterion in detail."}, {"heading": "6.3.2 Value iteration in a belief subset", "text": "Given a set V of vectors, a set H of histories and a precision threshold \u03b7, value iteration computes an improved value function over the belief subset \u03c4(B,H). This is accomplished by conducting a sequence of DP updates. In the following, we discuss implicit DP updates, the convergence issue and the stopping criterion in the value iteration step.\nAn implicit DP update computes a new value function from the current one for belief subset \u03c4(B,H). Let Uj (U0 = V) denote the j-step value function. Thus, a DP update computes value function Uj+1 from Uj . The procedure of computing Uj+1 from Uj is parallel to the collective DP update in Section 4. In particular, when defining a vector \u03b2a,\u03b4 given an action a and a mapping \u03b4 in Equation (9), the occurrences of V \u03c4(B) n are replaced by Uj . By enumerating actions and mappings, all defined vectors form the set Uj+1. Its minimal representation is obtained by removing useless vectors w.r.t. the subset \u03c4(B,H).\nThe convergence issue arises because the subset \u03c4(B,H) may not be a closed set. To guarantee the convergence of value iteration, we set Uj+1 to be the union of set Uj+1 and Uj after a DP update. Together with the fact that the initial value function is set to be the minimum reward for all actions and states, the sequence {Uj} monotonically increases in terms of induced value functions. On the other hand, the value functions in the\nsequence are upper bounded by the optimal value function. Consequently, value iteration in \u03c4(B,H) must converge. As a result, the Bellman residual between value functions, maxb\u2208\u03c4(B,H) |Uj+1(b)\u2212Uj(b)|, becomes smaller in \u03c4(B,H) as value iteration continues. When the residual falls below the threshold \u03b7, value iteration terminates.\nThe value iteration step is implemented as the procedure subsetVI in Table 3. Given a set V of vectors, a set H of histories and a threshold \u03b7, the procedure computes an improved value function for belief subset \u03c4(B,H). Value function U0 is set to be the input set V at line 1. The new value function Uj+1 is computed by a DP update at line 3. To guarantee convergence, Uj+1 to set to be the union of Uj and Uj+1 at line 4. The stopping criterion is tested at line 6. If it is met, the latest value function Uj\u22121 is returned."}, {"heading": "6.3.3 Subset expansion", "text": "Given a set V of vectors and a set H of histories, the subset expansion step expands the belief subset \u03c4(B,H) to a larger one. This is achieved by generating a superset H\u2032 of H. The new\nbelief subset \u03c4(B,H\u2032) is thus a superset of \u03c4(B,H). Hence, the key in subset expansion is how to generate a history set H\u2032. In the following, we propose two approaches to generating the history set using our intuition for near-discernible POMDPs. Both approaches generate new histories by exploiting the vectors in V. We begin with an analysis of the vectors in the set V and show how to use them to generate histories.\nLet \u03b2 be a vector in the set V. Remember that \u03b2 is defined by a pair of action a and mapping \u03b4. For convenience, such an action is said to be the associated action of \u03b2. In addition, if \u03b2 is useful in the set V w.r.t. the belief subset \u03c4(B,H), there must exist a history h in H such that \u03b2 is useful w.r.t. the belief simplex \u03c4(B, h). The history h is said to be the associated history of \u03b2. The associated history of a vector can be used to generate new histories by extending the history, i.e., appending the pairs of informative-poor actions and observations to the history. Let AIP be the set of the information-poor actions and ZIP be the set of the observations led to by those actions. Extending history h results in a set {[h, a, z]|a \u2208 AIP , z \u2208 ZIP }. The set contains |AIP ||ZIP | histories. Each history in the set is called an extension of history h.\nTo generate H\u2032 from the set H and the set V, one generic approach works as follows. Each vector \u03b2 in the set V is examined. If its associated history is long and the associated action is information-poor, we produce all extensions of its associated history. An extension is added to H\u2032 if it is not in H\u2032. (The reason is that the associated action of a vector should be information-rich if its associated history is sufficiently long.) To ensure that H\u2032 is a superset of H, we set H\u2032 to be H in the beginning. Apparently, this approach to generating histories suffers from the exponential increase of the size |H\u2032| in |AIP | and |ZIP |. In the worst case where all the vectors in V are associated with information-poor actions, the size |H\u2032| is |H||AIP ||ZIP |. Consequently, after the i-step subset expansion, |Hi+1| can be as large as |AIR||ZIR|(|AIP ||ZIP |) i where |AIR||ZIR| is the size of initial history set.\nTo alleviate this problem, we use a heuristic approach to generating H\u2032 in hope that the size H\u2032 increases moderately. The above exhaustive approach extends the histories associated with the vectors prescribing informative-poor actions. The heuristic approach does not extend all such histories. Instead it extends only maximal histories in the set H. (A history is said to be maximal in a set if none of its extensions is in the set.) This is the only change made from the above approach. As indicated in the experiments, this restriction can effectively cut down the size of the history sets. Nonetheless, the heuristic approach shares the same worst-case complexity with the exhaustive approach.\nThe subset expansion step is implemented as the procedure subsetExpansion in Table 3. Given a set V of vectors and a set H of histories, it computes an expanded set H\u2032 and an expanded belief subset \u03c4(B,H\u2032). The set H\u2032 is initialized to be H at line 1. For each vector \u03b2 in V at line 2, if its associated history is maximal in H and its action is information-poor (line 3), all the extensions of its associated history are added to H\u2032 (line 5). The expanded set H\u2032 and also the expanded belief subset \u03c4(B,H\u2032) are returned at line 6."}, {"heading": "6.3.4 Stopping criterion and Decision-Making", "text": "As an anytime algorithm, SPVI can be terminated if a hard deadline is reached. Another stopping criterion of interest can be set as follows. Given a sufficiently large amount of time, SPVI would account for as many histories as possible. If a (near) optimal policy of the\nPOMDP requires that information-rich actions be executed after a sequence of informationpoor actions, SPVI should be able to compute a value function for the belief subset, which consists of all possible belief states that the agent encounters if it is guided by such a policy. After sufficiently many expansions of history sets and hence belief subsets, any vector associated with a maximal history prescribes an information-rich action. If all the vectors in the representing set prescribe information-rich actions, SPVI terminates. If a (near) optimal policy has the desired structure in its sequence of actions, the output value function should be near optimal in the final belief subset.\nWhen SPVI terminates, the value function V\u03c4(B,Hi\u22121) can be used for decision making. Similarly to Equation (3), a V\u03c4(B,Hi\u22121)-improving policy can be defined over the belief space."}, {"heading": "6.3.5 Efficiency of SPVI", "text": "The efficiency of SPVI depends on the selected belief subsets. If these belief subsets are close to the belief space in size, SPVI must be inefficient. Fortunately, our approach for belief subset expansion ensures that the initial belief subset is small and the subsequent subsets grow slowly. First, since H0 is the set of the pairs of information-rich actions and observations, the initial belief \u03c4(B,H0) is relatively small. Second, the subsequent belief subsets \u03c4(B,Hi) do not grow too quickly. The reason follows. In extending a history, the information-poor pairs are added to its end. Hence, the first action and observation pair of the histories in a set Hi must be information-rich. Therefore, for a history h in the set Hi, \u03c4(B, h) is small in size. Meanwhile, due to the heuristic for generating history sets, the sizes |Hi| would not increase too fast. These characteristics make SPVI efficient when compared with the standard value iteration algorithm.\nAlthough the above analysis is empirically confirmed in our experiments below, it is worthy to mention that in the worst case the number of belief simplices grows exponentially in the number of |AIP ||ZIP |. Since a history determines a belief simplex, in the worst case the number of the belief simplices after the i-step subset expansion is the same as the number of histories, i.e., |AIR||ZIR|(|AIP ||ZIP |) i (see the third paragraph of Section 6.3.3)."}, {"heading": "6.4 Empirical Results", "text": "Since SPVI works in an anytime manner, our primary interest is to demonstrate how the quality of the generated value functions varies with the time cost. However, the availability of optimal solutions strongly depends on the \u201ctractability\u201d of the problems. If a near optimality is available, we compare it directly with the value function generated by SPVI by simulations. Otherwise, we simply compare value functions from SPVI against those from an approximate algorithm QMDP (Littman et al., 1995; Hauskrecht, 2000). Although the comparison is not strict in a formal sense, it can provide clues about the quality of value functions.\nWe report our results on two variants of the base maze problem and an office navigation problem. In one variant, SPVI terminated after a finite number of iterations and the output value function is near optimal; in the other variant, SPVI can quickly find a high-quality value function as time goes by (Zhang & Zhang, 2001a; Zhang, 2001). In the rest of this section, we report our results on the office navigation problem.\nThe environment is modeled after the floor plan of the authors\u2019 home department. The layout is shown in Figure 6. There are 35 states: 34 locations plus one terminal state. The action space is of size 6 (four move, one look and one beep replacing declare in the maze problem). Any action except look leads to a null observation. To introduce other observations, we note that in the figure, black bars represents doors and grey bars represent walls with display boards. The look action yields observation of strings of four letters for a location indicating, for each of the four directions, where there is a door (d), an empty wall (w), a wall with a display board (b), or nothing (o). In total, there are 22 different strings. Hence, plus the null observation, the observation space is of size 23. Transition probabilities for moves are specified identically as in the maze problem. Neither look nor beep changes the states of the environment. At each location, look produces the ideal string for that location with probability 0.75. With probability 0.05, it produces the null observation. Also with probability 0.05, it produces a string that is ideal for some other location and that differs from the ideal string for the current location by only 1 character. The robot receives a reward of 50 when beeping at location 22 and a reward of -10 when beeping at any other location (we don\u2019t want the robot to make a lot of noise). The move actions bring about a reward of -2 if they lead the robot to bumping into walls or doors. They have no rewards otherwise. The reward for the look action is always -1. The robot needs to get to location 22 and beep so that someone in the main office can come out and hand the robot some mail.\nWe conduct simulations about the generated value functions because no existing exact algorithm can find the near optimal value function. The simulation consists of 1000 trials. Each trial starts from a random initial belief state and is allowed to run up to 100 steps. The average reward across all the trials is used as a measurement of the quality of policies derived by value functions.\nFigure 7 presents the results about the quality against time costs. We see that SPVI found a policy whose average reward is 19.6 in about 80,000 seconds. SPVI was manually terminated after running about 24 hours. It is found that the algorithm conducted three steps of subset expansion. By our data, after the first and second expansion steps, both\nrewards by simulation are 18.4. This is not far from 19.6 obtained after the third expansion step although it is difficult to say how close those polices are to the optimal. Compared with the solutions generated by QMDP, the policies generated by SPVI are clearly better.\nFor reference, Table 4 gives detailed statistics on the number of the histories, iterations and vectors after each subset expansion. A note is about the number of iterations in the third column: when conducting value iteration over subsets, we also use the point-based improvements (Zhang, 2001). In the column, the number of point-based steps are excluded. The fourth column about the number of vectors provides some idea of why SPVI takes long time for this problem. This is because it generates a great number of vectors. After the third expansion, it uses 7,225 vectors to represent a value function over the belief subset."}, {"heading": "7. Related Work", "text": "In this paper, we propose restricted value iteration algorithms to accelerate value iteration for POMDPs. Two basic ideas behind restricted value iterations are (1) reducing the complexity of DP updates and (2) reducing the complexity of value functions. In this section, we discuss related work under these two categories. In addition, we give an overview on special POMDPs in the literature and the algorithms exploiting their problem characteristics."}, {"heading": "7.1 Reducing the Complexity of DP Updates", "text": "In a broad sense, approaches reducing the complexity of DP updates can be roughly categorized into two classes: approaches conducting value updates over a (stationary) belief subset and approaches conducting value updates over a growing subset, although the boundary between these two classes is ambiguous in some cases.\nThe first class includes a family of grid-based algorithms, algorithms based on reachability analysis, algorithms using state-space decomposition and others. Grid-based algorithms update values for a finite grid and extrapolate values for non-grid belief states (Lovejoy, 1991; Hauskrecht, 1997; Zhou & Hansen, 2001). However, to guarantee optimality, the grid size is often exponential in the dimension of the state space. To tackle POMDPs with large state spaces, reachability analysis is a generally applicable technique. If an agent is informed of its initial belief, all belief states it can encounter form a finite set in case of a finite decision horizon. These belief states can be structured in a decision tree or AND/OR tree (Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000). Although sometimes near optimality can be achieved at the initial belief state (Hansen, 1998), the algorithms in the cited articles cannot be applied to the case with unknown initial belief. State-space decomposition is an effective way to alleviate the curse of dimensionality. This approach has been successfully applied to MDPs (Dean & Lin, 1995; Dean, Givan, & Kim, 1998; Parr, 1998; Koller & Parr, 2000). Typically, to solve an MDP, one solves a number of small MDPs and uses their solutions to approximate that of the original MDP. However, the state-space decomposition approach cannot directly generalize to the POMDP context because of the inherent difficulty incurred by the continuum of the belief space.\nOur theory and algorithms on restricted value iteration have significant differences from the above approaches. Through a well chosen belief subset, restricted value iterations can achieve convergence and optimality. It differs from grid-based algorithms in that it computes vector-based representations of value functions. Despite this difference, it is possible that grid-based algorithms can benefit from our theory on belief subset selection. This possibility is yet to be investigated. For instance, while choosing grid points, one should choose those within the belief subset \u03c4(B). The reason follows. Since the belief states outside the set are never reachable, their values do not directly contribute to value updates for beliefs in the grid. With regard to the differences between the aforementioned algorithms and ours, our approach has no assumption about an agent\u2019s initial belief, although the belief subset is chosen via reachability analysis. Our algorithm differs from the decomposition techniques in that it solves a reformulated MDP instead of a set of small MDPs.\nApproaches conducting value updates for a growing belief subset include real-time dynamic programming (RTDP) in the POMDP context (Barto, Bradtke, & Singh, 1995; Geffner & Bonet, 1998), a synthetic projection algorithm (Drummond & Bresina, 1990) and the envelope algorithm for Plexus planner in the MDP context (Dean et al., 1993). Naturally, they run as anytime algorithms. In RTDP, value updates are carried out for a belief subset, which grows as an agent explores the belief space. The main difference between SPVI and the above algorithms is how they expand the belief/state subset and how they choose beliefs/states for value updates. For subset expansion, SPVI adds more belief simplices, which often contains an infinite number of belief states, while the above\nalgorithms mostly add a finite number of belief states. (It is also noted that reachability analysis is used in these expansions.) For value updates, SPVI improves values for the entire belief subset, while the above algorithms typically select a limited number of beliefs or states in the current subset."}, {"heading": "7.2 Reducing the Complexity of Value Functions", "text": "Another idea behind restricted value iteration is concerned with the representational complexity of value functions. Intuitively, the representing set of a value function over a belief subset contains fewer vectors than that of the same value function over the belief space. This fact has been observed (Boutilier & Poole, 1996; Hauskrecht & Fraser, 1998), where POMDPs are represented compactly. When states are depicted by a set of variables, they are classified into observable variables and hidden variables. It is also noted that some belief states cannot be reached for certain combinations of observable variables and hidden variables. This fact has been exploited in approximating the solution to a medical treatment example (Hauskrecht & Fraser, 1998). Recent work along this thread includes a state-space compression technique exploiting the representational advantage (Poupart & Boutilier, 2002), and a technique of Principle Component Analysis (PCA) aiming at reducing the complexity of value functions (Roy & Gordon, 2002). However, it is unclear whether it is feasible to combine state-space compression with subset value iteration before we know how to conduct value iteration over a belief space induced by a compressed state space."}, {"heading": "7.3 Solving Special POMDPs", "text": "Since solving a POMDP generally is computationally intractable, it is advisable to study POMDPs with special characteristics. The hope is that these characteristics may be exploited to find their near optimal solutions more efficiently. Special POMDPs examined in the literature include regional-observable POMDPs (Zhang & Liu, 1997), memory-resetting and discernible POMDPs (Hansen, 1998), even-odd POMDPs (Zubek & Dietterich, 2000) and generalized near-discernible POMDPs (Zhang, 2001). Interestingly, these POMDPs assume the existence of informative actions or observations such that somehow an agent is able to get more information about the world. In the following, we briefly discuss the assumptions behind informative POMDPs and near-discernible POMDPs and review existing work closely related to them. Before concluding this subsection, we also mentioned a couple of extensions to our current work.\nAn informative POMDP assumes that any observation restricts the world into a small set of states. This assumption is validated by a few problem instances with compact representations of state space. In the literature, some POMDP examples are actually informative POMDPs. One example is the slotted Aloha protocol problem (Bertsekas & Gallagher, 1995; Cassandra, 1998a), where the state of the system consists of the number of backlogged messages and the channel status. The channel status is observable and its possible assignments form the observation space. However, the system has no access to the number of backlogged messages. If the maximum number of backlogged messages is set to m and there are n possible values for the channel status, the number of states is m \u00b7 n. A particular assignment of channel status will restrict the system into m states out of m \u00b7 n. A similar problem\ncharacteristic also exists in a non-stationary environment model proposed for reinforcement learning (Choi, Yeung, & Zhang, 1999).\nA regional observable POMDP assumes that at any point in time an agent is restricted to a handful of world states (Zhang & Liu, 1997). The assumption leads to a value iteration algorithm that works with a belief subset and also exploits the low dimensional representation of vectors. We used the algorithm to solve informative POMDPs. However, we would like to discuss several differences. First, conceptually the assumptions are different for the two POMDP classes. In regional observable POMDPs, when the agent is restricted to a set of states (i.e., a region), the states in such a set are geometrically neighboring ones. However, in informative POMDPs, when the agent is restricted to a set of states, the states in a set are obtained by formally analyzing the observation model of the POMDP. It is possible that the states in the set are spatially distant from one another. Second, the algorithms for the two POMDP classes work in a quite different way. To ease presentation, we use infoVI and roVI to respectively denote our value iteration for informative POMDPs and that for regional observation POMDPs. In infoVI, the number of state sets is the product of the number of actions and the number of observations, while in roVI, the number of regions is subjectively chosen. In addition, the observations in roVI are augmented. An augmented observation consists of an original observation and a specific region. So, the number of augmented observations is the product of the number of original observations and the number of regions. Hence, roVI has to account for many more observations than infoVI. This fact is useful when comparing the efficiency of infoVI and roVI. Imagine what happens if roVI works with the region system, which consists of the state sets defined by infoVI, for an informative POMDP. Because infoVI accounts for fewer observations than roVI, it should be more efficient. Finally, the quality of the value function returned by infoVI is guaranteed for the entire belief space when it terminates with the strict stopping criterion. However, the quality of the value function by roVI in its original description is problematic even for the considered belief subset.\nThe other POMDP class examined in this paper is near-discernible POMDPs. A near discernible POMDP assumes that the actions are classified into information-rich ones and information-poor ones. The assumption is reasonable in several realistic domains. The first domain is the path planning problems (Cassandra, 1998a). The actions are categorized into goal-achieving and information-gathering ones, as discussed earlier. Another application domain is machine maintenance problems (Smallwood & Sondik, 1973; Hansen, 1998), where an agent usually can execute the following set of actions: manufacture, examine, inspect and replace. Among these actions, \u201cinspect\u201d is information-rich and the remaining three actions are information-poor.\nA near discernible POMDP is a generalization of a memory-resetting (discernible) POMDP, which assumes that there exists actions resetting the world to an unique state. If such actions are performed, the agent knows that the world must be in a definite state. If the initial belief state is known and an optimal policy must execute one of such actions periodically, the number of belief states that the agent visits is finite. Accordingly, DP updates over a finite set of beliefs are much cheaper. However, after the discernibility assumption is relaxed, the agent may visit an infinite number of states and DP updates become more expensive. We therefore developed an anytime algorithm seeking a tradeoff between the solution quality and the size of the belief subset.\nWe also experimented with one extension of using SPVI to approximate the solutions of more general POMDPs (Zhang, 2001). The approximation scheme employs a thresholding technique. Given a POMDP and a threshold, a POMDP can be transformed to a new one, which differs from the original one in the observation model. The observation model in the transformed POMDP is obtained by ignoring the probabilities (in the original model) less than the threshold 7. If the transformed POMDP is near discernible, its solution can be found by SPVI and be used to approximate that of the original POMDP. We have designed another maze problem that has no informative action/observation pair and therefore is expected to be not amenable to SPVI (Zhang, 2001). However, the transformed POMDP is amenable to SPVI. The experiments show that SPVI can quickly find a high quality solution for the transformed POMDP. In another case, if the transformed POMDP is informative, the algorithm exploiting low dimensional representations for informative POMDPs can be applied."}, {"heading": "8. Conclusions", "text": "In this paper, we studied value iterations working with belief subset. We applied reachability analysis to select a particular subset. The subset is (1)closed in that no actions can lead the agent to belief states outside it; (2)sufficient in that value function defined over it can be extended into the belief space; and (3)minimal in that value iteration needs to consider at least the subset if it intends to achieve the quality of value functions. That the subset is closed enables one to formulate a subset MDP. We addressed the issues of representing the subset and pruning a set of vectors w.r.t. the subset. We then described the subset value iteration algorithm. For a given POMDP, whether the subset is proper can be determined a priori. If this is the case, subset value iteration carries the advantages of representation in space and efficiency in time. We also studied informative POMDPs and near-discernible POMDPs. For informative POMDPs, there are natural belief subsets for value iteration to work with. For near-discernible POMDPs, we developed an anytime value iteration algorithm seeking a tradeoff between the policy quality and the size of belief subsets."}, {"heading": "Acknowledgments", "text": "Research was partially supported by Hong Kong Research Grants Council under grant HKUST6088 / 01E. The authors thank Tony Cassandra and Eric Hansen for sharing with us their programs. The first author would like to thank Eric Hansen for in-depth discussions on belief subset selection and low dimensional representation, and Judy Goldsmith for valuable comments on an earlier writeup of the ideas in this paper. We are also grateful for the three anonymous reviewers who provided insightful comments and suggestions on this paper."}, {"heading": "Appendix A. Proofs", "text": "Theorem 2 For any pair [a, z], the subset \u03c4(B, a, z) is a simplex.\n7. To complete the definition of the approximate observation model, one needs to re-normalize model parameters such that for an action and a state, the probabilities for all observations sum up to 1.0.\nProof: Suppose bi is a belief state such that bi(s) = 1.0 for s = si and 0 otherwise. It can be seen that {b1, b2, \u00b7 \u00b7 \u00b7 , bn} is a basis of belief space B. Each belief state b(= (b(s1), b(s2), \u00b7 \u00b7 \u00b7 , b(sn)) can be represented as \u2211n i=1 b(si)bi.\nLet k be the cardinality of the set {\u03c4(bi, a, z)|P (z|bi, a) > 0}. Without loss of generality, we enumerate the set as {\u03c4(b1, a, z), \u00b7 \u00b7 \u00b7, \u03c4(bk, a, z)}. It suffices to show that \u03c4(B, a, z) = \u03a8(\u03c4(b1, a, z), \u03c4(b2, a, z), \u00b7 \u00b7 \u00b7 , \u03c4(bk, a, z)). To prove it, we prove:\n(1) \u03c4(B, a, z) \u2286\u03a8(\u03c4(b1, a, z), \u03c4(b2, a, z), \u00b7 \u00b7 \u00b7 , \u03c4(bk, a, z)) and (2) \u03a8(\u03c4(b1, a, z), \u03c4(b2, a, z), \u00b7 \u00b7 \u00b7 , \u03c4(bk, a, z)) \u2286 \u03c4(B, a, z).\nFirst, we prove (1). It suffices to show that any belief state b\u2032 in \u03c4(B, a, z) must belong to the simplex \u03a8. Since b\u2032 is in \u03c4(B, a, z), there must exist a belief state b in B such that b\u2032 = \u03c4(b, a, z). We define a few constants as follows.\n\u2022 For any i \u2208 {1, \u00b7 \u00b7 \u00b7 , k}, Cbi is the probability of observing z when action a is executed in belief state bi. Formally, Cbi = \u2211 s\u2032,s P (z|s \u2032, a)P (s\u2032|s, a)bi(s).\n\u2022 Cb is the probability of observing z when action a is performed in b. Formally, Cb = \u2211\ns\u2032,s P (z|s \u2032, a)P (s\u2032|s, a)b(s).\n\u2022 For any i \u2208 {1, \u00b7 \u00b7 \u00b7 , k}, define \u03bbi = Cbi/Cb.\nGiven these constants, we are going to prove b\u2032 = \u2211 i \u03bbi\u03c4(bi, a, z). If this is true, i.e., b \u2032 can be represented as a convex combination of the vectors in the basis, (1) is proven.\nWe start from b\u2032 = \u03c4(b, a, z). If \u03c4(b, a, z) is replaced by its definition, for a state s\u2032,\nb\u2032(s\u2032) = 1\nCb\n\u2211\ns\nP (z|s\u2032, a)P (s\u2032|s, a)b(s)\nBy the definition of belief state bi, we can rewrite the above equation as\nb\u2032(s\u2032) = 1\nCb\n\u2211\ns\n\u2211\ni\u2208{1,\u00b7\u00b7\u00b7,k}\nP (z|s\u2032, a)P (s\u2032|s, a)bi(s).\nTrivially,\nb\u2032(s\u2032) = 1\nCb\n\u2211\ns\nCbi\n\u2211\ni\nP (z|s\u2032, a)P (s\u2032|s, a)bi(s)\nCbi .\nBy the definition of \u03c4(bi, a, z), rewriting the above equation, we have\nb\u2032(s\u2032) = \u2211\ni\n( Cbi Cb )\u03c4(bi, a, z)(s \u2032).\nBy the definition of \u03bbi, the above equation yields\nb\u2032(s\u2032) = \u2211\ni\n\u03bbi\u03c4(bi, a, z)(s \u2032).\nIf b\u2032 and \u03c4(bi, a, z) are regarded as column vectors, the above equation means\nb\u2032 = \u2211\ni\n\u03bbi\u03c4(bi, a, z).\nTherefore, we prove that if there is a belief state b such that b\u2032 = \u03c4(b, a, z), b\u2032 can be represented as a convex combination of the vectors in the basis. This means b\u2032 must be in the simplex \u03a8.\nTo prove (2), we prove that any belief state b\u2032 in the simplex \u03a8 must be in the subset \u03c4(B, a, z). It suffices to show that there exists a belief state b in B such that b\u2032 = \u03c4(b, a, z).\nSince b\u2032 is in \u03a8, there must exist a set of nonnegative \u03bbis such that b \u2032 = \u2211k i=1 \u03bbi\u03c4(bi, a, z).\nIf we replace \u03c4(bi, a, z) by its definition, then: for a state s \u2032,\nb\u2032(s\u2032) = \u2211\ni\n\u03bbi\n\u2211\ns P (z|s \u2032, a)P (s\u2032|s, a)bi(s)\n\u2211\ns\u2032,s P (z|s \u2032, a)P (s\u2032|s, a)bi(s)\n.\nIf we denote \u2211 s\u2032,s P (z|s \u2032, a)P (s\u2032|s, a)bi(s) by a constant Cbi , then\nb\u2032(s\u2032) = \u2211\ni\n\u2211\ns\nP (z|s\u2032, a)P (s\u2032|s, a)bi(s) \u03bbi Cbi .\nExchanging the summation order of i and s and making use of the definition of bs(i), we have\nb\u2032(s\u2032) = \u2211\ns\n\u03bbs Cbs P (z|s\u2032, a)P (s\u2032|s, a).\nWe define a belief state b as follows: for any s,\nb(s) = \u03bbs/Cbs \u2211\ns\n\u03bbs/Cbs .\nIt can be seen that\nb\u2032(s\u2032) =\n\u2211\ns P (z|s \u2032, a)P (s\u2032|s, a)b(s)\n\u2211\ns\u2032,s P (z|s \u2032, a)P (s\u2032|s, a)b(s)\n.\nTherefore, we proved that for any b\u2032 in \u03a8 there exists a belief state b such that b\u2032 = \u03c4(b, a, z). Consequently, b\u2032 \u2208 \u03c4(B, a, z). \u2737\nTheorem 6 If maxb\u2208\u03c4(B) |V \u03c4(B) n (b)\u2212V \u03c4(B) n\u22121 (b)| \u2264 \u01eb(1 \u2212 \u03bb)/(2\u03bb 2|Z|), then the V \u03c4(B) n\u22121 -improving policy is \u01eb-optimal over the entire belief space B.\nProof: It suffices to show maxb\u2208B |Vn+1(b) \u2212 Vn(b)| \u2264 \u01eb(1 \u2212 \u03bb)/(2\u03bb). For any b \u2208 B,\n|Vn+1(b) \u2212 Vn(b)|\n= |maxa{r(b, a)+\u03bb \u2211 z V \u03c4(B,a,z) n (\u03c4(b, a, z))}\u2212maxa{r(b, a)+\u03bb \u2211 z V \u03c4(B,a,z) n\u22121 (\u03c4(b, a, z))}| (1) \u2264 |r(b, a\u2217) + \u03bb \u2211\nz V \u03c4(B,a\u2217,z) n (\u03c4(b, a\u2217, z)) \u2212 r(b, a\u2217) \u2212 \u03bb \u2211 z V \u03c4(B,a\u2217,z) n\u22121 (\u03c4(b, a \u2217, z))| (2)\n\u2264 |\u03bb \u2211 z(V \u03c4(B,a\u2217,z) n (\u03c4(b, a\u2217, z)) \u2212 V \u03c4(B,a\u2217,z) n\u22121 (\u03c4(b, a \u2217, z)))| (3) \u2264 \u03bb|Z|maxz |V \u03c4(B,a\u2217,z) n (\u03c4(b, a\u2217, z)) \u2212 V \u03c4(B,a\u2217,z) n\u22121 (\u03c4(b, a\n\u2217, z))| (4) \u2264 \u03bb|Z|\u01eb(1 \u2212 \u03bb)/(2\u03bb2|Z|) (5) \u2264 \u01eb(1 \u2212 \u03bb)/(2\u03bb) (6)\nwhere\n\u2022 At Step (1), value functions are replaced by their definitions;\n\u2022 At Step (2), a\u2217 is the V \u03c4(B) n -improving action for b but it is not necessarily V \u03c4(B) n\u22121 -\nimproving;\n\u2022 At Step (5), the given condition is used;\n\u2022 Other steps are trivial. \u2737"}, {"heading": "Appendix B. Informative POMDPs: An Elevator Problem", "text": "This appendix describes a 96-state informative POMDP and empirical results of value iteration over \u03c6(B). The problem is adapted from existing research (Choi et al., 1999). Our purpose is to show that restricted value iteration is able to solve larger POMDPs than standard value iteration.\nProblem Formulation\nAn elevator operates in a two-floor residential building. There are three patterns on the passengers\u2019 arrival: high arrival rate in the first floor and low in the second floor; low arrival rate in the first floor and high in the second floor; equal arrival rates. As time varies from the morning to the night in a day, these patterns change according to a probability distribution. To keep track of the pick-up and drop-off requests, the elevator sets up four buttons in its control panel: two buttons record the pick-up and drop-off requests for the first floor, two other buttons keep the same information for the second floor. The elevator is also aware of which floor it is on. In order to fulfill the requests at a floor, the elevator first moves upwards or downwards so that it reaches the floor; then, the elevator stays at the floor until the passengers finish entering or exiting. The objective of the elevator is to minimize certain penalty or cost in the long run.\nThe problem can be formulated into a POMDP framework. A state consists of six components: the arrival pattern, the pick-up requests for two floors, the drop-off requests for two floors and the elevator\u2019s position. We use six variables to denote the components respectively. A state is an assignment to all the variables. The arrival pattern takes on three possible values for three different patterns. If there are passengers waiting in the lobby of the first floor, the pick-up request is set; otherwise, it is unset. If there are passengers in the elevator intending to get off at the first floor, the drop-off request for the first floor is set; otherwise, it is unset. Similarly, for the second floor, the variables for the pick-up/drop-off requests can be set accordingly. If the elevator is at the first floor, its position is set to first; for the second floor, its position is set to second. The number of states is 3\u22172\u22172\u22172\u22172\u22172 = 96. Each observation has five components; it has the same components as a state except the arrival pattern. There are as many as 2 \u2217 2 \u2217 2 \u2217 2 \u2217 2 = 32 observations. The elevator may execute one of three actions, namely go.up, go.down and stay. The restriction is, when it is at the first floor, it cannot perform go.down; when it is at the second floor, the action go.up cannot be performed.\nThe uncertainty stems from the probabilities of the changes of the arrival patterns. When the elevator executes go.up, each component evolves as follows. The arrival pattern changes according to a predetermined probability distribution. The components for pickup/drop-off requests remain. The position changes from first to second. The effects of the action go.down can be described similarly. When the elevator performs the action stay, the arrival pattern changes similarly. All the requests at the floor are fulfilled and the corresponding variables are reset. For instance, if a passenger would like to get off at the first floor, when the elevator at the first floor performs stay, the passenger is able to get off. We say that the elevator fulfills the drop-off requests for the first floor. For another instance, if passengers like to enter the elevator at the second floor, they can do so only when the elevator performs action stay at the second floor. We say the pickup request at the second floor is fulfilled in this case. It is also allowable for the elevator to fulfill two requests at one time point. For example, if there are both pick-up and drop-off requests at the first floor, when the elevator performs action stay, the passengers can enter and exit within one time point. We say it fulfills two requests. Note that only when an action stay is performed, the elevator can fulfill its request. Since the variable of arrival pattern changes at any time moment, the elevator changes its states probabilistically after performing any action.\nThe elevator is informed of partial knowledge of its state transition. After the elevator performs an action, it knows the changes of components of its states: variables pick-up and drop-off for each floor and its position. However, since it does not know the arrival pattern and it is a component of the state, the observations cannot reveal the identities of the states. This is the partial observability. However, since there are only three possible arrival patterns, each observation reveals that the elevator must be in only three possible states. Therefore, the POMDP is informative.\nThe performance of the elevator can be measured in different ways for diverse applications. We define a measure to minimize the unsatisfactory degree of the service the elevator provides. We encode this in our reward model. At any time point, the elevator serves one of four requests: pick-up requests at the first/second floor, drop-off requests at the first/second floor. After performing an action, if any of these 4 requests is unfulfilled, the elevator receives a penalty of 0.25. For instance, if the elevator un-fulfills either the pick-up or drop-off request(if they are set) at the first floor, it receives a penalty of 0.25 \u2217 2 = 0.5. The objective of the elevator is to minimize total discounted penalty in a long run.\nFor convenience, we use A.i to denote arrival patterns for i = 1, 2, 3. In our experiments, the transition probabilities are set as in the following table. Basically, each pattern remains fixed with probability 0.90 and changes to another with 0.05.\nA.1 A.2 A.3\nA.1 0.90 0.05 0.05 A.2 0.05 0.90 0.05 A.3 0.05 0.05 0.90\nEmpirical Studies\nWe collect the time costs and the actual number of vectors generated at each iteration of algorithms VI, ssVI, infoVI and infoVIPB referring to infoVI integrated with a pointbased procedure (Zhang, 2001). The results are presented in Figure 8.\nThe first chart in the figure shows the time costs against the iterations. The algorithms are set to compute a 0.1-optimal value function. For infoVIPB, we exclude the iterations for point-based improvements. Overall, we see that VI and ssVI by no means can solve the problem, infoVI is likely to solve it given sufficient time and infoVIPB is able to solve it easily. When infoVIPB runs, it uses the loose stopping criterion. This is because if the strict one is used, the threshold is close to the round-off precision parameter.\nFor the first seven iterations, ssVI takes 190,000 seconds, infoVI only 32 seconds. The performance difference is drastic. As infoVI proceeds, it takes about 1,100 seconds for one iteration. It is evident that infoVI is able to compute a near optimal value function if given sufficient time. When the point-based technique is integrated, infoVIPB is able to terminate in 94 seconds after five steps of DP updates over \u03c6(B). Since most of these algorithms cannot terminate within a reasonable time limit, we compare the data on the 6th iteration among them. This is the last iteration we are able to gather statistics for VI. For this iteration, VI takes 76,000 seconds, ssVI 6,000 seconds, infoVIPB only 8 seconds.\nThe second chart in Figure 8 depicts the number of vectors generated at each iteration for the tested algorithms. For ssVI, we collect the sum of the numbers of vectors representing value functions over |A| \u00b7 |Z| \u03c4 -simplices. For infoVI and infoVIPB, we collect the sum of the numbers of representing vectors for |Z| \u03c6-simplices. This is because for this problem the observation models are independent of the actions.\nFrom the chart, we see that VI generates significantly more vectors than ssVI and infoVI. In our experiments, after infoVIPB terminates, it produces 1,132 vectors. For the same reason as above, we compare the numbers of the vectors after the 6th iterations for these algorithms. After the iteration, VI generates 12,000 vectors. For ssVI and infoVI, this number is 252 and 136 respectively. As DP updates proceed, it is conceivable that the number of vectors generated by VI will increase sharply and hence the DP updates are extremely inefficient. For infoVIPB, since the final number of generated vectors are rather\nsmall, together with the fact that point-based improvement effectively reduces the number of iterations over the \u03c6(B), it is possible to compute a near optimal value function within a rather small time limit as it turns out."}], "references": [{"title": "Optimal control of Markov decision processes with incomplete state estimation", "author": ["K.J. Astr\u00f6m"], "venue": "Journal of Mathematical Analysis and Applications,", "citeRegEx": "Astr\u00f6m,? \\Q1965\\E", "shortCiteRegEx": "Astr\u00f6m", "year": 1965}, {"title": "Learning to act using real-time dynamic programming", "author": ["A.G. Barto", "S.J. Bradtke", "S.P. Singh"], "venue": "Artificial Intelligence,", "citeRegEx": "Barto et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Barto et al\\.", "year": 1995}, {"title": "Dynamic Programming", "author": ["R. Bellman"], "venue": null, "citeRegEx": "Bellman,? \\Q1957\\E", "shortCiteRegEx": "Bellman", "year": 1957}, {"title": "Planning with incomplete information as heuristic search in belief space", "author": ["B. Bonet", "H. Geffner"], "venue": "In Proceedings of the 6th International Conference on Artificial Intelligence in Planning Systems (AIPS),", "citeRegEx": "Bonet and Geffner,? \\Q2000\\E", "shortCiteRegEx": "Bonet and Geffner", "year": 2000}, {"title": "Structured reachability analysis for Markov decision processes", "author": ["C. Boutilier", "R.I. Brafman", "C. Geib"], "venue": "In Proceedings of the 14th Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Boutilier et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 1998}, {"title": "Computing optimal policies for partially observable decision processes using compact representations", "author": ["C. Boutilier", "D. Poole"], "venue": "In Thirteenth National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Boutilier and Poole,? \\Q1996\\E", "shortCiteRegEx": "Boutilier and Poole", "year": 1996}, {"title": "On the complexity of partially observed Markov decision processes", "author": ["D. Burago", "M. de Rougemont", "A. Slissekno"], "venue": "Theoretical Computer Science,", "citeRegEx": "Burago et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Burago et al\\.", "year": 1996}, {"title": "Exact and approximate algorithms for partially observable Markov decision processes", "author": ["A.R. Cassandra"], "venue": "Ph.D. thesis,", "citeRegEx": "Cassandra,? \\Q1998\\E", "shortCiteRegEx": "Cassandra", "year": 1998}, {"title": "A survey of POMDP applications", "author": ["A.R. Cassandra"], "venue": "In Working Notes of AAAI 1998 Fall Symposium on Planning with Partially Observable Markov Decision Processes,", "citeRegEx": "Cassandra,? \\Q1998\\E", "shortCiteRegEx": "Cassandra", "year": 1998}, {"title": "Incremental pruning: a simple, fast, exact method for partially observable Markov decision processes", "author": ["A.R. Cassandra", "M.L. Littman", "N.L. Zhang"], "venue": "In Proceedings of the 13th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "Cassandra et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cassandra et al\\.", "year": 1997}, {"title": "An environment model for nonstationary reinforcement learning", "author": ["S.P.M. Choi", "D.Y. Yeung", "N.L. Zhang"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "Choi et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Choi et al\\.", "year": 1999}, {"title": "Solving planning problems with large state and action spaces", "author": ["T. Dean", "R. Givan", "K. Kim"], "venue": "In Proceedings of the 4th International Conference on Artificial Intelligence in Planning Systems (AIPS),", "citeRegEx": "Dean et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Dean et al\\.", "year": 1998}, {"title": "Planning with deadlines in stochastic domains", "author": ["T.L. Dean", "L.P. Kaelbling", "J. Kirman", "A. Nicholson"], "venue": "In Proceedings of the 9th National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Dean et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Dean et al\\.", "year": 1993}, {"title": "Decomposition techniques for planning in stochastic domains", "author": ["T.L. Dean", "S.H. Lin"], "venue": "In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Dean and Lin,? \\Q1995\\E", "shortCiteRegEx": "Dean and Lin", "year": 1995}, {"title": "Anytime synthetic projection: maximizing the probability of goal satisfaction", "author": ["M. Drummond", "J. Bresina"], "venue": "In Proceedings of National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Drummond and Bresina,? \\Q1990\\E", "shortCiteRegEx": "Drummond and Bresina", "year": 1990}, {"title": "Solving large POMDPs using real time dynamic programming", "author": ["H. Geffner", "B. Bonet"], "venue": "In Working Notes Fall AAAI Symposium on POMDPs,", "citeRegEx": "Geffner and Bonet,? \\Q1998\\E", "shortCiteRegEx": "Geffner and Bonet", "year": 1998}, {"title": "Finite memory control of partially observable systems", "author": ["E.A. Hansen"], "venue": "Ph.D. thesis, Dept of Computer Science,", "citeRegEx": "Hansen,? \\Q1998\\E", "shortCiteRegEx": "Hansen", "year": 1998}, {"title": "Heuristic search in cyclic AND/OR graphs", "author": ["E.A. Hansen", "S. Ziberstein"], "venue": "In Proceedings of National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Hansen and Ziberstein,? \\Q1998\\E", "shortCiteRegEx": "Hansen and Ziberstein", "year": 1998}, {"title": "Incremental methods for computing bounds in partially observable Markov decision processes", "author": ["M. Hauskrecht"], "venue": "In Proceedings of National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Hauskrecht,? \\Q1997\\E", "shortCiteRegEx": "Hauskrecht", "year": 1997}, {"title": "Value-function approximations for partially observable Markov decision processes", "author": ["M. Hauskrecht"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Hauskrecht,? \\Q2000\\E", "shortCiteRegEx": "Hauskrecht", "year": 2000}, {"title": "Modeling treatment of ischemic heart disease with partially observable Markov decision processes", "author": ["M. Hauskrecht", "H. Fraser"], "venue": "In American Medical Informatics Association annual symposium on Computer Applications in Health Care,", "citeRegEx": "Hauskrecht and Fraser,? \\Q1998\\E", "shortCiteRegEx": "Hauskrecht and Fraser", "year": 1998}, {"title": "Planning and acting in partially observable stochastic domains", "author": ["L.P. Kaelbling", "M.L. Littman", "A.R. Cassandra"], "venue": "Artificial Intelligence,", "citeRegEx": "Kaelbling et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Kaelbling et al\\.", "year": 1998}, {"title": "Policy iteration for factored MDPs", "author": ["D. Koller", "R. Parr"], "venue": "In Proceedings of the Sixteenth Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Koller and Parr,? \\Q2000\\E", "shortCiteRegEx": "Koller and Parr", "year": 2000}, {"title": "Efficient dynamic programming updates in partially observable Markov decision processes", "author": ["M.L. Littman", "A.R. Cassandra", "L.P. Kaelbling"], "venue": "Tech. rep. CS-95-19,", "citeRegEx": "Littman et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Littman et al\\.", "year": 1995}, {"title": "The computational complexity of probabilistic planning", "author": ["M.L. Littman", "J. Goldsmith", "M. Mundhenk"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Littman et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Littman et al\\.", "year": 1998}, {"title": "Computationally feasible bounds for partially observed Markov decision processes", "author": ["W.S. Lovejoy"], "venue": "Operations Research,", "citeRegEx": "Lovejoy,? \\Q1991\\E", "shortCiteRegEx": "Lovejoy", "year": 1991}, {"title": "On the undecidability of probabilistic planning and infinite horizon partially observable Markov decision problems", "author": ["O. Madani", "S. Hanks", "A. Condon"], "venue": null, "citeRegEx": "Madani. et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Madani. et al\\.", "year": 1999}, {"title": "A survey of partially observable Markov decision processes: theory, models, and algorithms", "author": ["G.E. Monahan"], "venue": "Management Science,", "citeRegEx": "Monahan,? \\Q1982\\E", "shortCiteRegEx": "Monahan", "year": 1982}, {"title": "The complexity of Markov decision processes", "author": ["C.H. Papadimitriou", "J.N. Tsitsiklis"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Papadimitriou and Tsitsiklis,? \\Q1987\\E", "shortCiteRegEx": "Papadimitriou and Tsitsiklis", "year": 1987}, {"title": "Flexible decomposition algorithms for weakly coupled Markov decision problems", "author": ["R. Parr"], "venue": "In Proceedings of the 14th Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Parr,? \\Q1998\\E", "shortCiteRegEx": "Parr", "year": 1998}, {"title": "Approximating optimal policies for partially observable stochastic domains", "author": ["R. Parr", "S. Russell"], "venue": "In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Parr and Russell,? \\Q1995\\E", "shortCiteRegEx": "Parr and Russell", "year": 1995}, {"title": "Point-based value iteration: an anytime algorithm for POMDPs", "author": ["J. Pineau", "G. Gordon", "S. Thrun"], "venue": "In International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Pineau et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Pineau et al\\.", "year": 2003}, {"title": "Value-directed compresseion of POMDPs", "author": ["P. Poupart", "C. Boutilier"], "venue": "In Proceedings of Advances in Neural Information Processing Systems (NIPS),", "citeRegEx": "Poupart and Boutilier,? \\Q2002\\E", "shortCiteRegEx": "Poupart and Boutilier", "year": 2002}, {"title": "Markov decision processes: discrete stochastic dynamic programming", "author": ["M.L. Puterman"], "venue": null, "citeRegEx": "Puterman,? \\Q1994\\E", "shortCiteRegEx": "Puterman", "year": 1994}, {"title": "Exponential family PCA for belief compression in POMDPs", "author": ["N. Roy", "G. Gordon"], "venue": "In Proceedings of Advances in Neural Information Processing Systems (NIPS),", "citeRegEx": "Roy and Gordon,? \\Q2002\\E", "shortCiteRegEx": "Roy and Gordon", "year": 2002}, {"title": "The optimal control of partially observable Markov processes over a finite horizon", "author": ["R.D. Smallwood", "E.J. Sondik"], "venue": "Operations Research,", "citeRegEx": "Smallwood and Sondik,? \\Q1973\\E", "shortCiteRegEx": "Smallwood and Sondik", "year": 1973}, {"title": "The optimal control of partially observable decision processes", "author": ["E.J. Sondik"], "venue": "Ph.D. thesis,", "citeRegEx": "Sondik,? \\Q1971\\E", "shortCiteRegEx": "Sondik", "year": 1971}, {"title": "BI-POMDP: Bounded, incremental partially-observable Markovmodel planning", "author": ["R. Washington"], "venue": "In Proceedings of the 4th European Conference on Planning (ECP),", "citeRegEx": "Washington,? \\Q1997\\E", "shortCiteRegEx": "Washington", "year": 1997}, {"title": "A model approximation scheme for planning in partially observable stochastic domains", "author": ["N.L. Zhang", "W. Liu"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Zhang and Liu,? \\Q1997\\E", "shortCiteRegEx": "Zhang and Liu", "year": 1997}, {"title": "Space-progressive value iteration: an anytime algorithm for a class of POMDPs", "author": ["N.L. Zhang", "W. Zhang"], "venue": "In Sixth European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU),", "citeRegEx": "Zhang and Zhang,? \\Q2001\\E", "shortCiteRegEx": "Zhang and Zhang", "year": 2001}, {"title": "Speeding up the convergence of value iteration in partially observable Markov decision processes", "author": ["N.L. Zhang", "W. Zhang"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Zhang and Zhang,? \\Q2001\\E", "shortCiteRegEx": "Zhang and Zhang", "year": 2001}, {"title": "Algorithms for partially observable Markov decision processes", "author": ["W. Zhang"], "venue": "Ph.D. thesis, Department of Computer Science, the Hong Kong University of Science and Technology", "citeRegEx": "Zhang,? \\Q2001\\E", "shortCiteRegEx": "Zhang", "year": 2001}, {"title": "Solving informative partially observable Markov decision processes", "author": ["W. Zhang", "N.L. Zhang"], "venue": "In Proceedings of the 6th European Conference on Planning (ECP)", "citeRegEx": "Zhang and Zhang,? \\Q2001\\E", "shortCiteRegEx": "Zhang and Zhang", "year": 2001}, {"title": "An improved grid-based approximation algorithm for POMDPs", "author": ["R. Zhou", "E. Hansen"], "venue": "In Proceedings of the 17th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Zhou and Hansen,? \\Q2001\\E", "shortCiteRegEx": "Zhou and Hansen", "year": 2001}, {"title": "A POMDP approximation algorithm that anticipates the need to observe", "author": ["V.B. Zubek", "T.G. Dietterich"], "venue": "In Proceedings of PRICAI-2000,", "citeRegEx": "Zubek and Dietterich,? \\Q2000\\E", "shortCiteRegEx": "Zubek and Dietterich", "year": 2000}], "referenceMentions": [{"referenceID": 27, "context": "Due to the model generality, POMDPs have found a variety of potential applications in reality (Monahan, 1982; Cassandra, 1998b).", "startOffset": 94, "endOffset": 127}, {"referenceID": 16, "context": "Extensive efforts have been devoted to developing efficient algorithms for finding solutions to POMDPs (Parr & Russell, 1995; Cassandra, Littman, & Zhang, 1997; Cassandra, 1998a; Hansen, 1998; Zhang, 2001).", "startOffset": 103, "endOffset": 205}, {"referenceID": 41, "context": "Extensive efforts have been devoted to developing efficient algorithms for finding solutions to POMDPs (Parr & Russell, 1995; Cassandra, Littman, & Zhang, 1997; Cassandra, 1998a; Hansen, 1998; Zhang, 2001).", "startOffset": 103, "endOffset": 205}, {"referenceID": 37, "context": "1991; Hauskrecht, 1997; Zhou & Hansen, 2001), and several (maybe anytime) algorithms where DP updates calculate values for a growing belief subset (Dean, Kaelbling, Kirman, & Nicholson, 1993; Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000).", "startOffset": 147, "endOffset": 273}, {"referenceID": 16, "context": "1991; Hauskrecht, 1997; Zhou & Hansen, 2001), and several (maybe anytime) algorithms where DP updates calculate values for a growing belief subset (Dean, Kaelbling, Kirman, & Nicholson, 1993; Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000).", "startOffset": 147, "endOffset": 273}, {"referenceID": 0, "context": "Information about the current state contained in the current observation, previous observations, and previous actions can be summarized by a probability distribution over the state space (Astr\u00f6m, 1965).", "startOffset": 187, "endOffset": 201}, {"referenceID": 33, "context": "It is known that there exists a policy \u03c0\u2217 such that V \u03c0 \u2217 (b)\u2265V (b) for any other policy \u03c0 and any belief state b (Puterman, 1994).", "startOffset": 114, "endOffset": 130}, {"referenceID": 2, "context": "It has been proven that the reformulated MDP has a stationary optimal policy, which can be found by stochastic dynamic programming (Bellman, 1957; Puterman, 1994).", "startOffset": 131, "endOffset": 162}, {"referenceID": 33, "context": "It has been proven that the reformulated MDP has a stationary optimal policy, which can be found by stochastic dynamic programming (Bellman, 1957; Puterman, 1994).", "startOffset": 131, "endOffset": 162}, {"referenceID": 33, "context": "The following theorem tells one when to terminate value iteration given a precision requirement \u01eb (Puterman, 1994).", "startOffset": 98, "endOffset": 114}, {"referenceID": 33, "context": "The quantity is often called Bellman residual between Vn and Vn\u22121 (Puterman, 1994).", "startOffset": 66, "endOffset": 82}, {"referenceID": 36, "context": "Fortunately, value functions that one encounters in the process of value iteration admit implicit finite representations (Sondik, 1971).", "startOffset": 121, "endOffset": 135}, {"referenceID": 6, "context": "When a value function is representable by a finite set of vectors, there is a unique minimal set that represents the function (Littman, Cassandra, & Kaelbling, 1995). Sondik (1971) has shown that if a value function is representable by a finite set of vectors, then so are the subsequent value functions derived by DP updates.", "startOffset": 136, "endOffset": 181}, {"referenceID": 12, "context": "Its definition is an application of reachability analysis (Boutilier, Brafman, & Geib, 1998; Dean et al., 1993).", "startOffset": 58, "endOffset": 111}, {"referenceID": 27, "context": "Here, we present a two-pass algorithm due to its conceptual simplicity (Monahan, 1982).", "startOffset": 71, "endOffset": 86}, {"referenceID": 9, "context": "Let us take incremental pruning, one of the most efficient algorithms, as an example (Cassandra et al., 1997; Zhang & Liu, 1997).", "startOffset": 85, "endOffset": 128}, {"referenceID": 41, "context": "5) can be found elsewhere (Zhang & Zhang, 2001; Zhang, 2001).", "startOffset": 26, "endOffset": 60}, {"referenceID": 16, "context": "A discernible POMDP assumes that once in a while the uncertainty about world states vanishes if a particular action is executed and the observations pertain to the action fully reveal the identities of the world (Hansen, 1998).", "startOffset": 212, "endOffset": 226}, {"referenceID": 23, "context": "Otherwise, we simply compare value functions from SPVI against those from an approximate algorithm QMDP (Littman et al., 1995; Hauskrecht, 2000).", "startOffset": 104, "endOffset": 144}, {"referenceID": 19, "context": "Otherwise, we simply compare value functions from SPVI against those from an approximate algorithm QMDP (Littman et al., 1995; Hauskrecht, 2000).", "startOffset": 104, "endOffset": 144}, {"referenceID": 41, "context": "In one variant, SPVI terminated after a finite number of iterations and the output value function is near optimal; in the other variant, SPVI can quickly find a high-quality value function as time goes by (Zhang & Zhang, 2001a; Zhang, 2001).", "startOffset": 205, "endOffset": 240}, {"referenceID": 41, "context": "A note is about the number of iterations in the third column: when conducting value iteration over subsets, we also use the point-based improvements (Zhang, 2001).", "startOffset": 149, "endOffset": 162}, {"referenceID": 25, "context": "Grid-based algorithms update values for a finite grid and extrapolate values for non-grid belief states (Lovejoy, 1991; Hauskrecht, 1997; Zhou & Hansen, 2001).", "startOffset": 104, "endOffset": 158}, {"referenceID": 18, "context": "Grid-based algorithms update values for a finite grid and extrapolate values for non-grid belief states (Lovejoy, 1991; Hauskrecht, 1997; Zhou & Hansen, 2001).", "startOffset": 104, "endOffset": 158}, {"referenceID": 37, "context": "These belief states can be structured in a decision tree or AND/OR tree (Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000).", "startOffset": 72, "endOffset": 154}, {"referenceID": 16, "context": "These belief states can be structured in a decision tree or AND/OR tree (Washington, 1997; Hansen & Ziberstein, 1998; Hansen, 1998; Bonet & Geffner, 2000).", "startOffset": 72, "endOffset": 154}, {"referenceID": 16, "context": "Although sometimes near optimality can be achieved at the initial belief state (Hansen, 1998), the algorithms in the cited articles cannot be applied to the case with unknown initial belief.", "startOffset": 79, "endOffset": 93}, {"referenceID": 29, "context": "This approach has been successfully applied to MDPs (Dean & Lin, 1995; Dean, Givan, & Kim, 1998; Parr, 1998; Koller & Parr, 2000).", "startOffset": 52, "endOffset": 129}, {"referenceID": 12, "context": "Approaches conducting value updates for a growing belief subset include real-time dynamic programming (RTDP) in the POMDP context (Barto, Bradtke, & Singh, 1995; Geffner & Bonet, 1998), a synthetic projection algorithm (Drummond & Bresina, 1990) and the envelope algorithm for Plexus planner in the MDP context (Dean et al., 1993).", "startOffset": 311, "endOffset": 330}, {"referenceID": 16, "context": "Special POMDPs examined in the literature include regional-observable POMDPs (Zhang & Liu, 1997), memory-resetting and discernible POMDPs (Hansen, 1998), even-odd POMDPs (Zubek & Dietterich, 2000) and generalized near-discernible POMDPs (Zhang, 2001).", "startOffset": 138, "endOffset": 152}, {"referenceID": 41, "context": "Special POMDPs examined in the literature include regional-observable POMDPs (Zhang & Liu, 1997), memory-resetting and discernible POMDPs (Hansen, 1998), even-odd POMDPs (Zubek & Dietterich, 2000) and generalized near-discernible POMDPs (Zhang, 2001).", "startOffset": 237, "endOffset": 250}, {"referenceID": 16, "context": "Another application domain is machine maintenance problems (Smallwood & Sondik, 1973; Hansen, 1998), where an agent usually can execute the following set of actions: manufacture, examine, inspect and replace.", "startOffset": 59, "endOffset": 99}, {"referenceID": 41, "context": "We also experimented with one extension of using SPVI to approximate the solutions of more general POMDPs (Zhang, 2001).", "startOffset": 106, "endOffset": 119}, {"referenceID": 41, "context": "We have designed another maze problem that has no informative action/observation pair and therefore is expected to be not amenable to SPVI (Zhang, 2001).", "startOffset": 139, "endOffset": 152}, {"referenceID": 10, "context": "The problem is adapted from existing research (Choi et al., 1999).", "startOffset": 46, "endOffset": 65}, {"referenceID": 41, "context": "We collect the time costs and the actual number of vectors generated at each iteration of algorithms VI, ssVI, infoVI and infoVIPB referring to infoVI integrated with a pointbased procedure (Zhang, 2001).", "startOffset": 190, "endOffset": 203}], "year": 2011, "abstractText": "Value iteration is a popular algorithm for finding near optimal policies for POMDPs. It is inefficient due to the need to account for the entire belief space, which necessitates the solution of large numbers of linear programs. In this paper, we study value iteration restricted to belief subsets. We show that, together with properly chosen belief subsets, restricted value iteration yields near-optimal policies and we give a condition for determining whether a given belief subset would bring about savings in space and time. We also apply restricted value iteration to two interesting classes of POMDPs, namely informative POMDPs and near-discernible POMDPs.", "creator": "dvips(k) 5.90a Copyright 2002 Radical Eye Software"}}}