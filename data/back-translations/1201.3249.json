{"id": "1201.3249", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2012", "title": "A Spiking Neural Learning Classifier System", "abstract": "This paper presents an LCS in which each traditional rule is represented by a spiking neural network, a kind of network with a dynamic internal state. We use a constructivist growth model of both neurons and dendrites, which realizes flexible learning by developing structures of sufficient complexity to solve a well-known problem in which continuous, real-valued inputs play a role. Furthermore, we extend the system to allow decomposition of the temporal state. By allowing our LCS to chain sequences of heterogeneous actions into macro actions, it proves optimal in a problem in which traditional methods cannot find a solution in a reasonable time. Our final system is tested on a simulated robotics platform.", "histories": [["v1", "Mon, 16 Jan 2012 13:19:55 GMT  (1222kb)", "http://arxiv.org/abs/1201.3249v1", "20 pages"]], "COMMENTS": "20 pages", "reviews": [], "SUBJECTS": "cs.NE cs.LG cs.RO", "authors": ["gerard howard", "larry bull", "pier-luca lanzi"], "accepted": false, "id": "1201.3249"}, "pdf": {"name": "1201.3249.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["david4.howard@uwe.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 1.\n32 49\nv1 [\ncs .N\nE ]\n1 6\nJa n\nKeywords Learning Classifier Systems \u00b7 Spiking Neural Networks \u00b7 Self-adaptation \u00b7 Constructivism"}, {"heading": "1 Introduction", "text": "Many real-world processes encompass some temporal element that describes or affects the state of a given system through time. Artificial Intelligence ubiquitously utilises abstractions of real-world or natural systems, however many representations opt to remove these temporal facets during the abstraction process. Missing out on underlying temporal patterns in a problem potentially denies a system access to a\nG. Howard Faculty of Environment and Technology, University of the West of England, E-mail: david4.howard@uwe.ac.uk\nL. Bull Faculty of Environment and Technology, University of the West of England,\nP.-L. Lanzi Dipartimento di Elettronica e Informazione, Politecnico di Milano\nrich vein of information which can be harnessed to generate more efficient solutions.\nWithin machine learning, temporal problems are particularly prevalent in the field of robot control, whereby robotic agents act through a number of time-steps to achieve some user-defined goal. To achieve any kind of reasonably complex behaviour, temporal aspects of the environment must be taken into account. This is perhaps most easily realised by using some temporally-dependent solution representation to match the nature of the problem representation. In this work, we concentrate on Spiking Neural Networks (SNNs), which are temporally-sensitive abstractions of biological neural networks. They are of particular interest to us as (i) they have been successfully applied to myriad robotic control problems (ii) there is growing evidence that the more biologicallyrealistic spiking models are efficient forms of knowledge representation (e.g. Maass (1997), Saggie-Wexler et al (2006)).\nOur specific approach to temporal machine learning involves the use of a Learning Classifier System, or LCS (Holland, 1976), a form of online evolutionary reinforcement-based learning that evolves a population of (condition, action, prediction) rules using a Genetic Algorithm (GA) (Holland, 1975).\nTraditionally, LCSs have used a ternary rule condition structure, comprising binary digits {0,1} and a generalisation character {#} to match in certain subspaces of a binaryrepresented state space. However, such a representation limits the application of LCSs to problems which can be binaryrepresented. Rule representations have since been extended to handle integer and real-valued states using several representations including intervals (Wilson (2000) and Wilson (2001b) respectively), hyperellipsoids (Butz et al, 2006) and convex hulls (Lanzi and Wilson, 2006), opening LCSs to more varied problem domains.\nFurther extensions enlarged the remit of LCS, including LISP S-expression rule conditions (Lanzi and Perrucci, 1999), computed actions (Ahluwalia and Bull, 1999), and\nfuzzy logic with computed actions (Valenzuela-Rendo\u0301n, 1991). Artificial neural networks have also been used to the same effect (Bull, 2002). We follow previous work with LCS using neural classifiers, (e.g. Howard et al (2008)), which has shown that it is possible to allow evolution to control both the number of hidden layer nodes (termed Neural Constructivism) and the number of node connections (termed Connection Selection) during the reinforcement learning process, alongside each classifier\u2019s rates of mutation. In particular, the work has utilized multi-layered perceptrons (MLP) (Rumelhart and McClelland, 1986) to generate optimal action selection policies by calculating actions based on the input state.\nTo date, only one scheme that can utilise temporal information has been used within LCS; a form of recurrent Boolean logic network (Bull, 2009). Here, we combine a modern LCS with a temporally dynamic SNN representation by replacing each classifier condition/action pair with a SNN. It is shown that the use of a SNN allows the classifiers to harness the network\u2019s persistent, dynamic internal state to produce temporally-dependant activation patterns. Additionally, we modify our LCS as in (Studley and Bull, 2005) to create a Temporal Classifier System (TCS), which facilitates generalisation in both time and space, thereby enabling more direct use of the temporal behaviour of the neurons for determining actions.\nOur hypothesis is that (i) the evolved SNN networks will display significant benefits compared to previous work using MLP network (Howard et al, 2009) (ii) the use of temporallysensitive SNN classifiers will extend the remit of XCSF to solving a class of problems that include an element of time e.g. semi-Markov Decision Processes (MDPs) (Sutton et al, 1999).\nSpecifically, we address the following research questions: does the use of SNN networks compared to MLP networks provide any significant advantage in terms of performance, solution size or network parsimony? Does the evolutionary design process evolve the networks in different ways? How well does the system compare to a benchmark reinforcement learner? Is there synergy between TCS and SNN classifiers, in that TCS provides a framework that allows the SNNs to harness their temporal element more effectively, which in turn increases the performance of TCS?\nTo address these questions, we test our SNN representation against both an MLP representation and a tabular Qlearner (Watkins, 1989), which acts as a benchmark, on a standard Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem (a 2-D grid world). We then modify the environment to include a temporal element and test our SNNTCS against an MLP-TCS, to demonstrate the utility of the former network representation over the latter. One final modification increases the difficulty of the environment by increasing the amount of steps it takes to reach the goal state;\nagain we compare to a Q-learner to demonstrate the ability of TCS to generate optimal action policies in a more difficult environment by using underlying temporal information in the problem. It is further shown that this temporal, spiking LCS performs optimally in a more challenging, realistic simulated robotics task.\nThe main contributions of this paper are (i) the combination of spiking networks and a temporally-sensitive, selfadaptive and constructive LCS framework, which are shown to perform optimally in continuous time and space where tabular Q-learning performs poorly (ii) the subsequent deployment of the aforementioned system in a simulated robotics task, demonstrating the power of the system in a nontrivial semi-MDP."}, {"heading": "2 Neural Representations", "text": "The initial work exploring artificial neural networks within LCS used traditional feedforward MLPs to represent the rules (Bull, 2002). Recurrent MLPs were then shown able to provide memory for a simple maze task (Bull and Hurst, 2003). Radial Basis Function (RBF) networks (e.g. Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks. Analysis of the rule sets produced in (Bull and O\u2019Hara, 2002) shows networks evolve that compute different actions that vary depending upon the environmental input, as long as the correct payoff value for those (state,action) combinations is identical. The authors hypothesize that it may be possible for the system to function optimally with only a single neural rule per possible payoff value, attesting to the compact rule representation and generalization capabilities of the neural LCS. Both MLP and RBF networks have been shown amenable to a constructionist approach, which can be defined as a method whereby the number of nodes within the hidden layer is under evolutionary control, along with the connection weights (Bull (2002); Hurst and Bull (2006)). We have recently extended this vein of research by introducing explicit network-wide feature selection, termed \u201cconnection selection\u201d, which allows each inter-neural connection to be probabilistically enabled or disabled, with the aim of reducing the number of connection weights within the rules (Howard and Bull, 2008).\nThe use of spiking networks is based on the assumption that simpler network forms can constrain the types of solutions evolved by the system in a manner that is detrimental to performance or solution parsimony, especially when considering temporal factors. Two well-known formal spiking implementations are the Leaky Integrate and Fire (LIF) model and the Spike Response Model (SRM). They are covered in detail in (Gerstner and Kistler, 2002). A number of previous studies have evolved single spiking networks. Neuroevolution (the use of evolution to design neural achitectures) was\nfirst applied to spiking networks by Korkin et al (1998), in this case evolving networks that produce temporally-dependant outputs. SRM networks were later evolved for vision-based robot navigation (Floreano and Mattiussi, 2001). The authors conclude that the inherent dynamics of a spiking network may be suited to certain robotics tasks. A survey of various methods for evolving both connection weights and architectures in neural networks is presented in (Floreano et al, 2008). To our knowledge, the work presented in this article is the first approach to evolving spiking neurons that includes both variable network sizes, connection selection and self-adaptive parameters within an ensemble of networks (population of classifiers). By combining these elements within XCSF, we are able to demonstrate generalization performance in excess of our previous MLP-based systems."}, {"heading": "3 XCSF", "text": "XCSF comprises a population of classifiers, the main components of which are the condition, action and prediction. The condition is used to determine whether or not the classifier matches the current st , the action is the action the classifier advocates, and the prediction is the predicted payoff the classifier expects from carrying out its action given the state st . Each classifier also keeps track of myriad other parameters, including the last time it was involved in GA activity, the accuracy of its prediction value, and the fitness of the classifier. For further details, we refer the interested reader to (Wilson, 2001a).\nWithin XCSF, the fitness of a classifier is related to the accuracy of its prediction of payoffs. This leads to a system where all areas (not just high reward areas) of the problem landscape are covered by classifiers that predict expected payoff with a high degree of accuracy. XCSF further increases its generalization capabilities by computing predicted payoffs. That is, classifier prediction is not a constant value as in other LCS, such as XCS (Wilson, 1995). Rather, prediction is calculated linearly as the product of the sensory input and a prediction weight vector, which allows the same classifier to generalize by predicting different payoff values in different areas of the environment. At the start of each experiment, each classifier is initialized with a prediction weight vector w, used to compute the classifiers prediction. This vector has one element for each input, plus an additional element w0 which corresponds to j0, a constant input that is set as a parameter of XCSF. Each prediction weight vector element is initially 0.\nXCSF involves two varieties of trial, exploration and exploitation, which are carried out with approximately equal frequency. At each time-step, XCSF builds a match set, [M], from [P] consisting of all classifiers whose conditions match the current input state st . In the binary case, each classifier condition has one element per state variable, where state\nvariables are binary and classifier conditions are a ternary string augmented with #, where # is a generalisation character that matches any state input at that position. A classifier is said to match if it has either (i) the same binary digit as the corresponding state or (ii)# at each position in its condition. In traditional XCSF, each action must be present in each [M]. If this is not the case, covering is used to generate classifiers that advocate the missing action(s); covering generates a new classifier whose condition is a copy of the input state, with generalisation characters probabilistically inserted. Once [M] is formed, the prediction array is created. Classifier prediction (cl.p) is calculated linearly as a product of the environmental input (or state, st ) and the prediction weight vector (w) associated with each classifier, shown in equation 1.\ncl.p(st) = j0 +\u2211 i>0 cl.wi \u2217 st(i) (1)\nThe prediction array is the fitness-weighted average of the calculated predictions for each possible action. The prediction array is then used to decide on an action to take (in traditional XCSF this is deterministic during an exploit trial and random during an explore trial). Once an action is selected, all classifiers that advocate the selected action form the action set [A]. The action is taken and, if the goal state is reached, a reward is returned from the environment that is used to update the parameters of the classifiers in [A]. A discounted reward is propagated to the previous action set [A\u22121] if it exists. During reinforcement, rather than updating the classifier\u2019s prediction value, the prediction weight vector of each classifier in the action set is updated using a version of the delta rule. Prediction error is then updated as in (Wilson, 2001a).\nXCSF makes use of macroclassifiers to enhance computational efficiency. A macroclassifier represents a number of virtual single classifiers, or microclassifiers, and its numerosity indicates the number of identical microclassifiers that the macroclassifier represents. This provides a computational advantage over representing each microclassifier individually. Subsumption is the mechanism by which macroclassifiers are formed; XCSF uses two forms of subsumption. GA subsumption checks whether a child condition is already represented by more general parent, and increases the parents\u2019 numerosity by one if this is the case. Action set subsumption checks the most general classifier in [A] against all other members of [A], and increases its numerosity by one if its condition is more general than theirs. In either scenario, the subsumed classifier is deleted from [P]. The GA may then activate if the average time since the last GA application to the classifiers in [A] exceeds a threshold \u03b8GA. Traditionally in XCSF, two offspring classifiers are generated by reproducing, crossing, and mutating the parents. The offspring are inserted into the population, two classifiers are deleted if the maximum population is reached.\nAs happens in all other models of classifier systems, parents stay in the population competing with their offspring."}, {"heading": "4 Neural XCSF", "text": "Transitioning to a neural classifier representation (N-XCSF) requires modifications to be made to the algorithm detailed in Sect. 3. It should be noted that the use of neural classifiers only alters the matching, covering and action selection mechanisms. It is also important to note the distinction between \u201cconnection weight\u201d, which refers to a node-to-node weight within a neural network and \u201cprediction weight\u201d, which is used as in XCSF to calculate classifier prediction linearly (after Wilson (2001a)).\nBy using a neural network to replace the condition, and calculate the matching and action of a classifier, we increase generalisation by allowing the classifier to advocate heterogeneous actions in different regions of the problem subspace. The input state, st , is used by the classifier in two regards: (i) to calculate whether the classifier matches in the problem subspace, and determine the action it advocates if it does match (ii) to calculate prediction values for the classifier in a given problem subspace in which it matches.\nFor all experiments considered here, output neurons (realvalued numbers in the case of MLPs, spike trains in the case of SNNs) must be discretised into having either high or low activation for the purposes of action calculation. Each network comprises a problem-dependent number of input neurons, a number of hidden layer neurons under evolutionary control (see Sect. 5.1), and three output neurons. The first two output neurons are used to calculate the action. Similarly to Bull (2002), the final output neuron is a dont-match neuron that excludes the classifier from the match set if it is highly activated. This is necessary as the action of the classifier must be re-calculated for each state the classifier encounters, i.e. a classifier may advocate different actions in different regions of state space. Covering is altered to repeatedly generate random networks until the network action matches the desired output for a given input state. Fig. 1 shows how a neural classifier relates to a traditional classifier condition and action.\n4.1 MLP Classifiers\nThe MLP network is a highly abstracted neural model that can produce real-valued outputs from real-valued inputs. Each neuron uses a sum-over-inputs, constrained by a sigmoid function, to produce an output value. Each classifier condition/action pair is represented by a vector that is realized as a feed-forward MLP. Each weight in this condition is uniformly initialized randomly in the range [-1, 1] so that a\nnode can have both positive and negative postsynaptic connections. Networks are initially fully-connected. MLP networks cannot have recurrent connections, nor can they have connections within the same layer. High activation is > 0.5, low is \u22640.5.\n4.2 SNN Classifiers\nSpiking neural networks present a biologically plausible phenomenological model of information processing in the brain. Mathematical models of the most basic current spiking neuron, the Leaky Integrate and Fire (LIF) neuron, can be traced back to as early as 1907 (Lapicque, 1907). We base our spiking implementation on the LIF model, although it must be stressed that our model is heavily simplified in terms of the number of simulation steps used per action calculation. Newly initialized networks are fully connected, and both recurrent connections and hidden-to-hidden layer connections are legal. Each connection weight is uniformly initialized randomly in the range [0, 1] and cannot become negative via GA action, as the type of node determines the nature (positive or negative) of the connection. Hidden layer nodes are initially excitory with 50% probability, otherwise they are inhibitory. All input and output layer nodes are excitory. Action calculation involves the current input state being processed five times by each network. Each output neuron has an activation window that records the spike train produced by that neuron over these five steps. To calculate actions, we classify an output spike train as highly activated if it has spikes in over half of the positions in the sampling window\nafter five runs (3 - 5 spikes); otherwise it is said to have low activation.\nNeurons can be stimulated either by an external current or by spikes from other connected neurons. Each neuron has an internal state (or membrane potential, m) which acts as a measure of its current activation level. As spikes are received by the neuron, the value of m is altered. If m surpasses a threshold, mthresh, the neuron sends a spike with value 1 to all connected neurons, who then receive a reduced current relative to the connection weight between those two neurons. A leak constant is used to gradually reduce m to 0 over time (m is always >0). At time t, the membrane potential of a neuron is given in equation 2:\nm(t + 1) = m(t)+ (I+ a\u2212 bm(t)) (2)\ni f (m(t)> mthresh)m(t) = c (3)\nEquation 3 shows the reset formula. Here, m(t) is the membrane potential at time t, I is the input current to the neuron, a is a positive constant, b is the degradation (leak) constant and c is the reset membrane potential of the neuron. Normally, spiking neurons have their initial membrane potentials m set to the membrane reset value c. We employ a bootstrapping mechanism whereby the initial membrane potential of every network is set to c ini rather than c, where c ini > c. This allows the networks to achieve their first spike quicker, giving less setup cycles as the networks begin to respond more strongly to the inputs, allowing us to (i) use smaller window sizes at the output neurons - a performance-enhancing measure (ii) benefit from faster general emergence of temporally-sensitive activation patterns within the networks. Note that after an initial spike, neurons are reset to c and not c ini; boot-strapping only affects the time to first spike of each neuron in the network.\n4.3 Discovery Component\nIn N-XCSF, the GA is modified to be a two-stage process. Stage 1, detailed in the following paragraph, controls the rates of mutation and constructivism/connection selection that occur within the system, with stage 2 (Sect. 5) controlling the evolution of neural architecture in terms of both neurons and connections. In N-XCSF we use mutation exclusively to explore connection weight space; crossover is omitted as experimental evidence thus far suggests that, in neural classifier systems (Howard et al, 2008), sufficient solution space exploration can be obtained via a combination of self-adaptive connection weight and topology mutations (see also (Rocha et al, 2007)). However, we note that a number of suitable neural crossover operators have previously been presented (e.g. by Stanley and Miikkulainen (2002)). A GA is periodically triggered in [A] to evolve fitter classifiers in an environmental niche. We utilise self-adaptive\nmutation rates as in (Bull et al, 2000), to dynamically control the amount of genetic search, or frequency of mutation events, taking place within the niche. This provides stability to areas of the problem space that are already \u201csolved\u201d as the mutation rate for a niche is typically directly proportional to its distance from the goal state during learning; generalization learning, along with the value function learning, occurs faster nearer the goal state. Here, the \u00b5 value (rate of mutation per allele) of each classifier is initialized uniformly randomly in the range [0,1]. During a GA cycle, a parent\u2018s \u00b5 value is modified as in equation 4 - the offspring then adopts this new \u00b5 , with (0 < \u00b5 \u2264 1), mutates itself by this value, and is inserted into the population:\n\u00b5 \u2190 \u00b5 \u2217 eN(0,1) (4)"}, {"heading": "5 Topology Mechanisms for Neural Networks", "text": "A classic problem in neural networks revolves around network topology considerations; how many neurons should a network consist of? How should we configure their topological arrangement and inter-neural connectivity patterns to ensure acceptable performance? In addition to self-adaptive mutation, in this work two evolutionary topology morphology schemes are applied to allow the modification of the spiking networks in two regards: by adding/removing hidden layer neurons; and adding/removing inter-neural connections. This allows each classifier to control its own knowledge representation autonomously in terms of both frequency and range of mutation that takes place in a given niche at a given time (Bull et al, 2000), and by adapting the hidden layer topology of the neural networks to reflect the complexity of the problem sub-space considered by the network (Bull, 2002).\n5.1 Constructivism\nConstructivist learning (e.g., (Quartz and Sejnowski, 1997)) postulates that neural structures are initially small and sparsely connected. Learning acts to add appropriate structure, in the form of neurons and connections, until some satisfactory level of computing power is attained; suitable specialized neural structures emerge as a result of the learners interaction with its environment. The implementation of constructivism in this system is based on the aforementioned work in neural LCS (Bull, 2002). Each rule has a varying number of hidden layer neurons (initially 1, and always > 0), with additional neurons being added or removed from the single hidden layer depending on the constructivism element of the system.\nConstructivism takes place during a GA cycle, after mutation. Two new self-adaptive parameters, \u03c8 (0 < \u03c8 \u2264 1)\nand \u03c9 (0 < \u03c9 \u2264 1), are added. Here, \u03c8 represents the probability of performing a constructivism event and \u03c9 is the probability of adding a neuron, with removal occurring with probability (1\u2212\u03c9). As with self-adaptive mutation, both are initially randomly generated uniformly in the range [0,1], and offspring classifiers have their parents \u03c8 and \u03c9 values modified during reproduction as with \u00b5 . SNN nodes created during constructivism are initially excitatory with 50% probability sampled from a uniform distribution, otherwise they are inhibitory. We have previously shown the utility of this approach in contrast to using fixed-size networks (e.g. Howard et al (2008)).\n5.2 Connection Selection\nFeature selection (FS) is a method of reducing the number of the data inputs to a process by selecting and operating exclusively on a subset of those inputs. A popular FS variant in the machine learning community is automatic FS. Automatic FS includes both wrapper approaches (where feature subsets can be tailored during the running of the algorithm, e.g., Kohavi and John (1997)) and filter approaches (where subset selection is a pre-processing step and subsets are immutable during the running of the algorithm, e.g. Koller and Sahami (1996)). The use of FS in a neural context corresponds to enabling/disabling connections between the input and hidden layer, and brings two major benefits. Firstly, the amount of data being input to a process can be reduced (increasing computational efficiency), secondly noisy connections (or those otherwise inhibitory to the successful performance of the system) can be disabled. The connection structure of artificial neural networks was first evolved by Dolan and Dyer Dolan and Dyer (1987). A comparative summary can be found in Schlessinger et al (2005), where many neuro-evolution methodologies are compared by the authors. Explicit FS within LCS has been investigated by Bull and Adamatzky (2007) and Bacardit et al (2007).\nIn this paper we allow any connection to be individually enabled/disabled, a mechanism termed \u201cConnection Selection\u201d. Connection selection is implemented in our system as follows: During a GA cycle, and based on a new selfadaptive parameter \u03c4 (0 < \u03c4 \u2264 1) (which is initialized and self-adapted in the same manner as the other parameters), an enabled connection can be disabled, or vice versa. If a connection is enabled, its connection weight is randomly initialised uniformly in the range [0, 1]. All connections are initially enabled for new classifiers and classifiers created via cover. During a node addition event, new connections are enabled probabilistically, with P(connection enabled) = 0.5, with connection weight randomly set uniformly in the range [0,1] as before. We previously have shown the utility of this approach for reducing network complexity (e.g., Howard and Bull (2008)).\nFor clarity, we now summarise the steps involved in a GA cycle. First, two offspring networks are selected. The self-adaptive parameters for those networks are altered as in equation 4. Connection weights are altered based on \u00b5 , then node addition/removal takes place based on \u03c8 and \u03c9 . Finally, connections are added or removed based on \u03c4 . These networks are inserted into the population and networks are deleted as required."}, {"heading": "6 Experiments in Continuous State Space", "text": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem. We compare to our earlier work using an MLP-based N-XCSF (see Howard et al (2008); Howard et al (2009) for details). Each experiment was comprised of a number of trials. A trial was defined as starting when the agent is initially positioned randomly in the environment, consisting of a number of [M] and [A] formations as the agent navigated in the environment, and finishing either with the agent reaching the goal state and receiving reward, or the trial timing out after the agent has moved 200 steps (a time-saving measure). Each trial was either in exploration mode (roulette wheel action selection, see e.g. Howard et al (2008) for reasoning) or exploitation mode (deterministic action selection).\n6.1 Continuous Grid World\nIn the Grid World, the agent\u2019s current state, st , is defined as its (x,y) position, each bounded in the range [0,1]; any movement outside of this range takes the agent to the nearest grid boundary. Increasing environmental complexity, and to emulate the sensory noise encountered in the real world, both the perceived x and y position of the agent are subject to noise; +/- [0%-5%] of the actual position. The agent moves a predetermined step size (0.05) in one of four directions (North, East, South, West). The goal state is in the top-right hand corner of the grid where (x+ y > 1.90). The agent is intiallty placed anywhere except the goal, and must navigate to the goal in the fewest possible steps (the average optimum is 18.6 steps), whereupon it receives an immediate reward of 1000 and the next trial begins. All other actions give an immediate reward of 0. The environmental discount rate, \u03b3 , is set to 0.95.\nEach experiment consisted of 20,000 trials, 10,000 explore and 10,000 exploit. Experiments were repeated ten times with the results being the mean average of these 10 runs. At the end of each exploitation trial we performed an additional exploitation trial from an arbitrary fixed location far from the goal state (0.25, 0.25) to determine when the\nsystem reached a stable solution. This location is also subject to noise; +/- [0%-5%] of the actual agent position. We defined the system to be stable if, for 50 consecutive trials, it provided an optimal steps-to-goal value when starting from the selected location. That measure of stability allowed us to perform standard t-tests to compare the respective performances of the two neural representations.\nThe current state of the system was analyzed every 50 trials and used to create the figures. In the \u201csteps-to-goal\u201d figures, the dashed line indicates optimal performance, all averages are averages from [P]. In the following tables, \u201cStability\u201d, is the average time the system takes to reach stability. \u201cConnectivity\u201d is defined as the average percentage of enabled connections per classifier in [P]. \u201cMutation\u201d is the average final self-adaptive \u00b5 parameter in [P]. \u201cNeurons\u201d are the average final connected hidden layer neurons per classifier in [P]. \u201cMacroclassifiers\u201d shows the final number of macroclassifiers contained in [P].\nAction calculation proceeds as follows: the outputs at the two output neurons (not the \u201ddon\u2019t match\u201c node) are mapped to a single discrete movement in one of four compass directions (North, East, South, West). Four possible directions and only two ranges of discrete output are possible: low and high. The combined actions of the neurons translate to a discrete movement according to the two motor output strengths (high, high) = North, (high, low) = East, (low, high) = South, and (low, low) = West.\nSpiking N-XCSF was parameterized as follows: population size N=20000, learning rate \u03b2 =0.2 (0 < \u03b2 \u2264 1), accuracy threshold \u03b50=0.005, GA threshold \u03b8GA=50, deletion threshold \u03b8DEL=50, XCSF constant x0=1, XCSF learning rate \u03b7=0.2 (0 < \u03b7 \u2264 1). All other XCSF parameters follow (Wilson, 2001a). Spiking parameters are a=0.3, b=0.05, c=0, c ini=0.5, mthresh=1.0 and output window size=5. All networks initially have a single hidden layer neuron.\nTable 1 shows t-test results when comparing the two network representations in solving the continuous grid world. The first row shows that time to stability is not statistically significantly affected by network type (p-value 0.13) (although the spiking version does have a lower mean average also compare Figs. 3(a) and 2(a)). The internal problem representation, in terms of both self-adaptive mutation rate (p=8.6\u00d710\u221210) and number of neurons added via constructivism , (p=1.5\u00d710\u22124) is formed in a statistically significantly different manner. As is typical in our constructivist approach, we note context sensitive structures being formed during the learning process, in two main ways (i) where the context is the network type: certain topological arrangements being favoured by either SNN or MLP networks and appearing more frequently in the final solutions (ii) where the context is the spatial position: the evolution of similar \u201cprocessing groups\u201d of neurons at certain locations in the problem space, within solutions of the same network\ntype. Perhaps the most striking result is that the number of macroclassifiers used is significantly lower in the SNN case (p=1.08\u00d710\u22126), indicating that spiking networks are capable generating more compact overall solutions.\nAlthough more nodes are required for a spiking representation (Fig. 3(b) shows 2.01 connected nodes, Fig. 2(b) shows 4.62 connected nodes), the spiking networks are less connected (p=5\u00d710\u22124; Fig. 3(d) shows 85% connectivity, Fig. 2(d) shows 72%). Self-adaptive parameter values are lower in the spiking case (Fig. 3(c) values range between 0.3 and 0.43, Fig. 2(c) values range between 0.1 and 0.32), especially the three parameters concerned with actual rates of mutation (e.g. \u00b5 , \u03c8 , \u03c4). These universally lower mutation rates indicate that a more stable solution is being evolved by the spiking networks, in terms of the classifiers used in the final solution having less chance of mutation, and less allelle variation per mutation event, in the SNN case. The more uniform curvature observed in Figs. 2(b) and 2(c), as opposed to Figs. 3(b) and 3(c), indicates that not only is the final solution more stable, the evolution process itself is made more stable. Spiking performance seems to compare favourably to an interval representation (e.g. (Lanzi et al, 2005a), without noise), especially since the spiking networks produce compact solutions in the presence of sensory noise.\nWe additionally compared spiking N-XCSF to a tabular Q-learner (as in (Lanzi et al, 2005b) for XCSF) with discount rate \u03b3 = 0.99. We performed the optimal spatial discretisation (in terms of Q-learner performance) as given in (Loiacono, 2010) to discretise the continuous space into a 21 \u00d7 21 grid for the x and y coordinates that comprise st , as shown in equation 5. The purpose of this experiment, as well as the experiment presented towards the end of Sect. 8, is to provide an indicator of the performance of our system against a baseline reinforcement learner.\ndisc x = (int)( f loor(cont x\u00d7 1/(step size))) (5)\nQ-learning rapidly achieves optimal performance within 500 trials. This result significantly outperforms our spiking N-XCSF (p=3.2\u00d710\u22123, with an average time to stability of\n8280.5 in the spiking N-XCSF case, compared to 82.6 for the tabular Q-learner). However, Q-learning requires a suitable discretisation of state space to be decided on beforehand. The Q-value learned is identical to the payoff value learned in XCSF, the difference being the use of function approximation in the latter."}, {"heading": "7 Taking Time into Consideration", "text": "Reinforcement learning methods typically assign a value to each possible state-action combination of a given task. When a programmer is prepared or able to define the state space discretisation a priori, this methodology has been proven to work for robot systems (Mahadevan and Connell, 1992). The approach is however labour intensive and becomes less tractable when the state space complexity increases. There are numerous accepted methods by which generalization of state spaces can be achieved, two of the most popular being gradient descent methods and linear approximation (specifically tile coding) (e.g., (Lin, 1991), (Tham, 1995)). Santamaria et al (1998) extended the latter approach by considering continuousduration action spaces. Within LCS, the approach has traditionally been either to predefine the temporal duration of an action (Dorigo and Colombetti, 1994) or to predefine the amount by which a sensor reading must change before a change in state is said to have occurred (Cliff and Ross, 1994).\nMotivation for adding actions of a continuous duration is to more closely bridge the gap between simulation and physical implementation; an agent samples its sensors with low latency, and reacts accordingly. Our goal is to go some way to model these rapid sensory updates by facilitating them in our learning architecture. In this case, we employ a system whereby an action set can control the agent for more than one continuous-duration action, which can be comprised of many discrete actions, updating the computed action for the classifiers in [A] as new environmental states present themselves. The LCS can therefore create high-level continuous macro actions from chains of lower-level actions. As the LCS can search the space of possible macro actions, the need to predefine such actions is removed.\nOur system is based on the Temporal LCS (TCS) which has been used with both ZCS (originally (Wilson, 1994), implemented in (Hurst et al, 2002)) and, more recently, with XCS (Studley and Bull, 2005) and with XCSF and MLPs (Howard et al, 2009). In TCS, the match set [M] and the action set [A] are formed as usual. Subsequent input states are then fed into [A] as the agent traverses the environment, without reforming [M] as in normal LCS. If all classifiers in [A] still match the input, the advocated action is taken and next input state retrieved. If no classifiers in the current [A] match the newly presented input state, or a timeout limit since the [M] formation is reached, the action is dropped (with reinforcement and GA activity) and a new match set\nformed as normal. If only some classifiers match, [A] is split into two new sets, [C] (the continue set) and [D] (the drop set), so that each classifier has dual-set membership; [A] and either [C] (if it still matches) or [D] (if it does not). Roulette wheel selection based on fitness-weighted predicted payoff is then used to pick a classifier from [A], and its membership of either [C] or [D] is used to determine the whether the system continues or drops the current action.\n\u2013 If [C] wins we continue, removing [D] classifiers from [A]. \u2013 If [D] wins we remove [C] classifiers from [A], perform necessary parameter updates, then drop [A] and form a new [M].\nAs we continually calculate actions in [A], some classifiers may advocate different actions to the one originally used to comprise [A] from [M]. In this case, a \u201cwinning\u201d action is picked from [A] based on the action selection policy of the trial (roulette during exploration, deterministic during exploitation). All classifiers that do not advocate the newlyselected action are removed from [A] but not added to the drop set; as the outcome of using their advocated action is not explored, an accurate prediction value cannot be ascertained. Traditionally, reinforcement in LCS is given with the formula in equation 6. Here, r is the immediate reward, \u03b3 is the discount factor and maxP is the maximum of the prediction array. The reinforcement update is altered to consider the amount of time an [A] maintains control of the LCS and the global time taken to achieve reward:"}, {"heading": "P = r+ \u03b3\u00d7maxP (6)", "text": "P = (e\u2212\u03d5t t )r+(e\u2212\u03c1t i )\u00d7maxP (7)\nEquation 7 shows the TCS reinforcement forumula; the first and second reward factors, e\u2212\u03d5t t and e\u2212\u03c1t i , favour efficient overall solutions (in terms of the overall number of discrete actions) and efficient state transitions (between continuousduration actions) respectively, \u03d5 and \u03c1 are experimentallydetermined discounting factors, tt is the total number of steps taken in the trial, and t i is the number of steps taken since the last match set formation."}, {"heading": "8 Experiments in Continuous Time and Space", "text": "In the following experiments we prove the ability of SNN to handle continous time as well as continuous space. We validate our approach on two well-known RL test problems, the Grid World described in Sect. 7 and the \u201cmountain-car\u201d problem. It is important to note that we only reset the network membrane potentials (m) for every node once at the beginning of each trial. In this way, we hoped to exploit\nthe temporal dynamics inherent to spiking neural representations to solve these continuous time, continuous space environments more effectively by preserving network states between action set formations. In contrast to experiments in Sect. 7, the consideration of time classes the problems as semi-MDPs.\n8.1 Continuous Grid World\nIn the Grid World, TCS parameters were set as: \u03d5=0.45, \u03c1=0.005, timeout=20. All other parameters were identical to those in Sect. 7. As with the previous experiments involving the Grid World, we compare our SNN TCS implementation to an MLP-based TCS. Table 2 describes the ttest results for SNN and MLP implementations; showing no significant performance difference between the two neural representations (p=0.57). Fig. 4(a) shows optimal performance after 2000 trials for SNN, compared to 5000 trials in the MLP case, which is shown in Fig. 5(a). No significant differences are found in terms of connected hidden layer nodes (p=0.51). Fig. 4(b) shows 2.4 connected hidden layer nodes, and Fig. 5(b) shows just over 2 connected hidden layer nodes, indicating that the SNN representation requires larger hidden layer sizes on average. In terms of both mutation stability (p=1.5\u00d710\u22124) and number of macroclassifiers (p=1.5\u00d710\u22123) the spiking version held the advantage in a statistically significant manner, attesting to the benefits of a SNN representation over an MLP one. In terms of selfadaptive parameters, Fig. 4(c) values ranged between 0.22 and 0.44 and Fig. 5(c) values ranged from 0.48 to 0.33 - all self-adaptive parameters were lower in the spiking case; again, an indicator of improved stability in terms of less mutation events on average in the evolved SNN classifiers.\nFigs. 4(d) and 5(d) show the differences in connectivity between SNN (86%) and MLP (84%) networks; revealing the spiking to be more densely connected, although not statistically significantly so (p=0.065). It is also interesting to note that although the transition to TCS in the spiking case did not statistically increase solution stability it decreased the average number of neurons required by the networks with a p-value of 0.016, highlighting the ability of a SNN to produce temporally dynamic activity, as fewer processing units were required when the temporally-sensitive SNNs were coupled with a semi-MDP test problem. This indicated that the SNNs were harnessing temporal information contained in the test problem to solve it in a different manner.\nIt was interesting to observe that the spiking networks seemed more predisposed to allow for multiple actions to be selected within a single match set formation, as opposed to the more homogenous action selection evidenced in MLP networks (e.g. (Howard et al, 2008)). Fig. 6 shows heterogeneous action selection in the spiking case allowing a single match set to control the agent all the way to the goal state,\ncontrasting with the MLP solution of more homogenous action selection; first taking the agent to the rightmost border, then progressing up the border to the goal state. In situations where both network types provided heterogeneous actions from the same match set, the spiking networks were more likely to sequentially switch selected action from one step to the next. Fig. 6 shows that, given the actions North, South, East, West in the continuous grid world, the spiking representation gave (N, E, N, E, N, E...) whereas the MLP representation provided (N, N, N... E, E, E...). The more complex discretisations available to the spiking representation gives a clear benefit of using a spiking representation over an MLP representation, when considering the prospective application of the system to more complex environments where highly varied, heterogeneous action selection may be required for optimal performance.\n8.2 Smaller Step Size Environment\nIn preparation for a move to a simulated robotics platform, we decreased the step size tenfold to 0.005. Motivation for this experimentation was seen as testing the scalability of our temporal representation, as a real robot would read sen-\nsors many times per second. The new step size was more akin to the number of readings a real robot may be required to make. It may also be necessary for the agent to perform homogenous action selection in extended regions of the environment, followed by certain highly heterogeneous areas where more complex behavioural policies, such as obstacle avoidance, are required; TCS allows for discretisation of state space based on required actions, as well as potentially altering the action of a given [A] through multiple state transitions in response to the required action transition frequency. Finally, a smaller step size introduced an environment where a TCS classifier system should be able to perform optimally, whereas a traditional Q-learner struggled.\nWe increased the timeout value from 20 to 200, giving an optimal average steps-to-goal value of 1.5. To prove the scalability of the system, all other LCS parameters are identical. Results of comparisons between the spiking TCS-enabled systems within the step size 0.05 and 0.005 environments are presented in Table 3, and Figs. 4 and 7. Both systems solve the task optimally. However, the performance of the system with step size 0.005 is statistically better (p=2.42\u00d710\u22126). A possible explanation for this is that, as the average number of discrete movements an agent is required to make is much greater than in the step size 0.05 case, the SNN networks have more opportunity to use the temporal information in this semi-MDP, resulting in a performance difference. Fig. 7(a) shows the performance of the system in the step size 0.005 environment. Commencing from an average steps-to-goal value of 5.8, the system initially produces fluctuating results until around 2500 trials; stability is thereafter attained. Final solutions show that more macroclassifiers are required in the smaller step size environment in an almost statistically significant manner, p=0.03. This indicates that more network variety is required in a more granular environment. Both step sizes produce solutions with a similar number of connected nodes, although the smaller step size does induce a slight growth in node-wise network complexity (2.4 connected hidden nodes on average in Fig. 4(b), contrasting with 2.5 nodes on average in Fig. 7(b)); p=0.15. Again, the curvatures are similar, but final values differ slightly. A possible explanation for the increased number of hidden nodes is that, as the step size 0.005 environment potentially provides more latent temporal information per trial (as more discrete steps are required on average), more hidden nodes (temporal processing units) are evolved by the networks to usefully process this latent information.\nImmediately obvious were similar parametric trends appearing in both sets of graphs. For example, the line curvatures for self-adaptive parameters described in Figs. 4(c) and 7(c) are similar in shape, and follow an identical descending order (\u03c9 , \u00b5 , \u03c8 , \u03c4) the only difference being that the parameter values in Fig. 4(c) are slightly lower in general (reaching values of 0.44, 0.29, 0.25 and 0.22 respectively\nwith step size 0.05, compared with 0.48, 0.39, 0.36 and 0.31 in the step size 0.005 environment). Differences between the self-adaptive parameter values in Fig. 7(c) can only be seen after approximately 10000 trials. Table 3 reveals that the final average self-adaptive mutation values vary statistically significantly between the different step size environments, p=0.01. Fig. 7(d) shows an average network connectivity of approximately 86%, whereas Fig. 4(d) shows 81%, p=0.36. The number of macroclassifiers required does not vary significantly between the trials (p=0.03). Despite similar trends, differing values again highlight the self-adaptive nature of the learning process, which alters depending on the environment the system is presented with.\nAs in Sect. 6, we compared performance to that of a baseline tabular Q-learner with step size 0.005 and discount rate \u03b3 = 0.99. We performed the optimal performance-giving discretisation as given in equation 8 to discretise the continuous space into a 201\u00d7 201 grid based on this new step size. With a steps-to-goal value always >400 (optimal 181.4, results not shown), Q-learning was unable to solve this more challenging environment within the allotted timeframe. The primary reason for this failure can be explained as too fine a sampling granularity within the environment - the system could not generate an accurate payoff map of the environment as there were too many discount steps in an average trial to successfully utilise Q-learning within a reasonable timeframe. Hence we show the effectiveness of the temporal nature of TCS the ability harness the temporal sensitivity of the SNN classifiers to deal with long action chains (continuous actions) that potentially consist of multiple discrete actions, with no need to pre-discretise the continuous state space, in the presence of sensory noise.\nIt should also be noted that these experiments were also carried out on the spiking non-TCS and MLP TCS versions of our system (results not shown); neither could find the optimal discretisation as evidenced in the spiking TCS version, demonstrating the ability of SNNs to harness temporal information and highlighting the suitability of TCS-style functionality for a simulated robotics environment.\n8.3 Mountain-Car\nTo demonstrate the general learning ability of spiking TCS, we also tested on the mountain-car problem (Sutton, 1996), in which a car must be guided out of a one-dimensional valley. Reaching the goal state is non-trivial as, in some cases, the car must move away from the goal state to attain enough momentum to climb out of the valley. State variables were position [-1.2, 0.6], and velocity [-0.07, 0.07]. Three actions were available: forward (increase velocity), backward (decrease velocity), and no movement. For a complete algorithmic description see (Sutton, 1996). As there were only three actions available, SNN outputs were distretised into actions as: forward = high, high, backward = low, low, and no movement = high, low or low, high. Each experiment consisted of 5000 trials, 2500 explore and 2500 exploit. The agent was initally randomly placed in the environment (except in the goal state), given a random velocity, and had to reach the goal state (where the cars position is > 0.5) in the fewest possible steps (optimal steps-to-goal =1). Population size N=1000; TCS parameters were \u03d5=0.45, \u03c1=0.005, timeout=200. All other parameters were identical to those in Sect. 7.\nFig. 8(a) shows attainment of optimum performance within 100 trials, which appears competitive to XCSF with a tile coding (e.g. (Tham, 1995)) scheme (Lanzi et al, 2006). It\nshould be noted that (Lanzi et al, 2006) allows only two actions. Average neurons per classifier (Fig. 8(b) gradually increases to a final value of 1.65. Self-adaptive parameters decline from their initial values (Fig. 8(c)). Final network connectivity (Fig. 8(d)) steadily declines to a final average value of 84.5%. Action set analysis shows that TCS allows the agent to reach the goal state from any intial position/velocity combination by forming only one match set. Actions are altered from forward to backward as the agent builds momentum; this is achieved by the networks recalculating their actions based on sensory input to alter the system action. The TCS reinforcement formula allows for the generation of shortest-length action chains within these macro actions within 480 trials."}, {"heading": "9 Moving to Robotics Problems", "text": "At the beginning of Sect. 7, justification for the use of a continuous test environment summarised as a desire to more accurately replicate the types of situations a real robot might encounter. Here, we begin with explanation for the transition from the continuous maze to a physical robotics simulation. Although a standard RL test scenario, the continuous grid world is an environment lacking in any real-world complexity, selected mainly to allow a direct comparison to tabular\nQ-learning. Evaluation of our system on a robot simulation suite is therefore a logical step forwards. An overview of current robot simulation platforms can be found in (Craighead et al, 2007). Our chosen development simulator is the Webots robotics platform (Michel, 2004), a test bed chosen due to its popularity in the research community.\n9.1 LCS Robotics research\nThe first LCS to successfully tackle the world of real robot control was the work of Dorigo and Colombetti (1994). The authors used a modified version of Hollands classifier system (Holland and Reitman, 1978), to create a hierarchical LCS in which lower-level LCSs can learn simple behaviours, which high-level LCSs then coordinate to generate complex actions. MONALYSA (Donnart and Meyer, 1996) was a hierarchicial LCS in which the hierarchy itself could be dynamically reconfigured. It was experimentally demonstrated that the ability to hierarchically decompose the required behaviour into sub-behaviours produced better performance, firstly in a simulated environment and later on a physical robot.\nBonarini (1998) presented a fuzzy classifier system that created sets of fuzzy niches which guided the behaviour of the agent, and employed a delayed reinforcement attribution\nscheme similar to Q-learning. The authors reported swift learning compared to the traditional ternary classifier condition representation. Bonarini and Trianni (2001) then extended this system for cooperation amongst a swarm of agents who could explicitly pass messages between themselves within a limited range. Another fuzzy classifier system is introduced by Pipe and Carse (2002) for implementation on a robotics platform. The system was tested on non-trivial maze environments, which were navigated by a physical robot; compact rule sets were reported as a benefit of fuzzy classifier representation.\nLatent learning was realized in a classifier system by Stolzmann (1999), providing a degree of premonition. It was demonstrated that his LCS could build chains of classifiers without waiting for subsequent environmental inputs by creating its own internal representation of the environment.\nKatagami and Yamada (2000) presented a manual approach for inducing certain behavioural patterns as a bootstrapping technique for learning in a real robot. Reinforcement learning was used as normal to decide on the \u201cbest\u201d actions to take from the initially generated set. The operator could also decide to take control in which case system created rules that covered the actions that the operator took, although this is obviously supervised learning. Webb et al (2003) reported mixed success in XCS control over a simulated Khepera in Partially Observable Markov Decision Pro-\ncess (POMDP) maze environments. They attempted to bypass the \u201caliasing states\u201d problem by augmenting each classifier with an internal state register and internal action, which were used to differentiate between aliasing states. The LCS made use of temporal actions with TCS-like functionality. A simple LCS is presented by Cazangi et al (2003), who evolved robot controllers for goal location and object avoidance tasks in unknown environments. The authors reported no significant degradation of performance when switching from simulation to a physical agent and also demonstrated that successful controllers can be evolved entirely on the physical robot. More recently, Butz and Herbort (2008) demonstrated an XCSF-derivative to control a robot arm using a real interval representation. Recent research by Moioli et al (2007) compared attempts at T-maze navigation in both simulated and real robotics tasks, and presented results that reinforce the idea that TCS is a valid method for dealing with long-action chains that are present in many robotic environments. Similarly to Webb et al (2003), the authors added a memory register and tested the system on a non-reactive robotics task. Again, high performance and the ability to disambiguate perceptually aliased states is reported. It should be noted that TCS-based systems have previously been used explicitly for real robot navigation, by Studley and Bull (2005) and Hurst and Bull (2006).\n9.2 Experimentation\nThis final set of experiments demonstrates the performance of the spiking TCS N-XCSF in a robotics environment (Fig. 9(a)). The agent, a simulated Khepera II robot, was initially randomly located within a walled arena which it could not leave with coordinates ranging from [-1,1] in both x and y directions (all units are in metres). A light source was placed at the top-right hand corner of the arena (x=1, y=1, z=1), which the agent must approach in order to receive reward. The light source was modelled on a 15W bulb with realistic attenuation values. Adding to the complexity of the environment, a three-dimensional box was placed centrally in the arena (with vertices on \u201cground level\u201d (z=0.0 ) at (x=-0.4, y=-0.4), (-0.4, 0.4), (0.4,0.4), and (0.4, -0.4), and raised to a height of z=0.15). When the agent reached the reward zone (where x+ y >1.6), an immediate reward of 1000 was returned and the next trial begun. All other movements give an immediate reward of 0. The reward boundary of 1.6 was chosen as the result of calibration experiments, which revealed the agent experienced excessive levels of sensory aliasing when approaching the light. All IR and light sensor lookup tables were modelled on actual sensor performance from the real Khepera robot.\nWe altered the environmental representation used by the agent to calculate action and predict payoff. Contrasting our previous approach of using the agents noisy (x,y) location in\nthe environment as the input state st , we used readings taken from the agents light and distance sensors to model the current environmental state. The agent, a cylinder-shaped robot with height = 0.03 and diameter 0.07, was equipped with with 8 light sensors and 8 IR distance sensors (see Fig. 9(b)), plus two bump sensors, offset to the left and right of the front of the agent. At each step, the agent sampled its light and IR sensors, whose scaled values ranged [0,1]. These values then comprised the input state for the current step. After (Hurst and Bull, 2006), six sensors were used to comprise the input state, three IR and three light sensors at positions 0, 2 and 5 (see Fig. 9(b)). This extended input state was thereafter used to calculate [M] membership/actions and compute prediction as normal.\nIn this experiment we employed our spiking TCS NXCSF to solve a more complex version of the grid environment introduced in Sect. 6.1. This environment was much more challenging than any we have used previously. For example, the agents wheels could slip, sensory noise was more pervasive and more accurately modelled, and the environmental input was three times larger than that used in the continuous grid world experiments. The inclusion of an obstacle further increased this complexity. At the start of each trial the agents initial random position was further constrained so that the obstacle is initially always between the agent and the light source. We constrained the initial starting position the lower left-hand corner of the environment, where the inequality (x+ y <\u22121.5) is satisfied.\nTo demonstrate the problem-independence of the system, parameter settings were largely unchanged from those in Sect. 8, with exceptions. First, N was reduced to 3000. Due to time and processing constraints, each experiment\nwas limited to 500 trials. Secondly, each classifier was initially seeded with 6 hidden layer nodes to offset the lack of trials per experiment. Seeding the networks with one neuron would make it extremely difficult for the classifier to immediately and usefully discriminate certain state elements as it is assumed that providing 6 state elements instead of the normal 2 would require the networks to make more complex partitions in state space. To reduce disruption, self-adaptive parameters were initially constrained to (0< (\u00b5/\u03c8/\u03c4)\u22640.02), with (0< \u03c9 \u22641) as normal. Finally, the six hidden layer nodes had each initial connection enabled with 50% probability. This is intended to increase inter-network variation early in the experiment as certain state variables will initially have no effect on the output action, thus increasing behavioural diversity. Usually, connection selection performed this operation gradually throughout the 20,000 trials. All of these modifications were implementated to aid expediency; as we completed only 500 trials, the new parameterisation allowed the networks to perform useful fucntions immediately. Due to the nature of construcitivism, it is assumed that the system would eventually be able to learn an optimal policy for the given task given enough time when set to its default parameters.\nMovement values and sensory update delays were constrained by accurate modelling of physical Khepera agent. It should be noted that in the earlier experiments, agent orientation was irrelevent; here orientation was preserved through movements and the agent was able to turn continuously to explore the environment. Three actions were possible: forward, and continuous turns to both the left and right (caused by halving the left/right motor outputs respectively). As the agent initially explored the environment, it was likely to bump into obstacles. If either bumper was activated, an interrupt was sent causing the agent to reverse 10cm and form a new [M] (after (Hurst and Bull, 2006)).\nFig. 10(a) shows the steps-to-goal values attained. Starting from 75 steps-to-goal, the system shows swift attainment of near optimal performance in terms of number of match set formations per trial after 300 trials, especially considering the levels of sensory noise. It is demonstrated that the system could, in most cases, evolve networks flexible enough to perform segregations in action space without reforming [M] via the ability of the networks to recalculate actions within an action set due to differences in received states.\nAn initial exploratory phase of action selection involved many collisions, which were progressively penalized as they caused more [M] formations per trial. The responsible classifiers were progressively usurped by classifiers which retained the same initial [M] by avoiding collisions. Action alteration once [M] was formed was usually due to IR sensors activating and perturbing network performance to turn the agent away from an obstacle or towards the light source, although the agent was also observed to display the capabil-\nity to alter action based on light sensor input alone. During a trial, action calculation was seen to be altered in two ways; networks either evolved to activate the \u201cdont match\u201d node so that classifiers advocating certain actions were dropped from [A] at the correct time, or state inputs caused the action advocated by the majority of the classifiers in the current [A] to transition between two states, causing a turn. Networks were observed to use the latter method more frequently than the former (68% of action switches occurred using the latter method), an evolved behaviour to keep more classifiers in [A] and hence retain more classifier variety in the action set. It was interesting to note that once the correct amount of turn was applied to the agent (e.g. in response to IR sensors highly activating, then deactivating once the obstacle was avoided), the action set was observed to re-calculate the \u201ccorrect\u201d action immediately; both methods outlined above were observed to be used by the system. Varying amounts of turn were observed (as more frequent turn actions interspersed within a majority of forward actions) as the agent approached an obstacle.\nThe number of hidden layer nodes are shown in Fig. 10(b), self-adaptive parameters shown in Fig. 10(c), and connectivity shown in Fig. 10(d). All graphs show that the initial parameter values are mainly unaltered, due to the reduction in the number of trials. Performance was seen to compare favourably to other TCS robotics experiments, (e.g. (Hurst and Bull, 2006)). As mentioned previously, by seeding each classifier with 6 hidden layer neurons, and allowing any connection in the network to be initially disabled with 50% probability, we effectively \u201cjumped\u201d the start of constructive neuro-evolution, allowing the networks sufficient topological disparity and neural complexity to begin solving this more complex problem immediately.\nNumerous differences existed between the simulation and traditional grid world experiments. Firstly, variations in terms of state space were seen to present a more difficult experiment for the simulated robot to navigate; the value function in the previous continuous grid world experiments increased smoothly as the agent neared the goal state. The value function also mapped approximately to the sensory readings perceived by the agent so that higher values of x and y gave, in general, higher payoffs. Conversely, in simulation the robot had to deal with less uniform state space due to the short range (0.01) of the IR sensors, which could within a short amount of time drastically alter the state input to the networks; hence the payoff map did not correlate with its\u2019 state as simply. The environmental representation was more complex; the light sensors were easily saturated, and the environmental was mainly well-illuminated; a necessary implementation restriction due to using Webots to ensure that collision detection occurs. It was noted that there was sparse use of high (>0.5) light sensor values that correspond to very dark regions of the environment. Also prevalent was a degree of\nsensory noise surpassing the [+/-5%] used in the continuous grid world environment; IR sensors were [+/-5%] at the extremes of their range, light sensors [+/-10%]."}, {"heading": "10 Conclusions", "text": "In this paper we have shown that a self-adaptive neural LCS employing constructivism can perform optimally in a more complex and noisy version of a standard continuous environment, and a continuous noisy robotic simulation. As the networks can calculate their actions, they have the capability to carry out the correct action in different areas of the problem space, even if that action required is different. Further, using the prediction computation of XCSF, we have observed that one network can accurately predict payoff in several spatially disparate regions of the problem space, even when the payoff values are different.\nThe results of adding TCS showed that when the system was presented with an environment which allowed it to harness its temporal capabilities, it performed in excess of environments where a temporal element does not exist, in other words the system is capable of processing underlying temporal information in a problem. The main strength of the TCS approach was the generation of high-level continuous actions from simple discrete actions, which allowed the\nagent to traverse environments requiring long action-chains. As the LCS can search the space of continuous actions, removing the need to predefine such actions. By adding SNN classifiers, the action advocated at a given timestep could be recalculated based on sensory input, increasing generalisation.\nResults presented in this paper are intended to reinforce the view that the use of self-adaptation and constructivism are a means to achieving increased levels of parameter and problem independence. XCS and XCSF are notoriously heavily parameterised systems; self-adaptation removes the need to set several parameters and constructivism allows the LCS to adapt to the complexity of the problem it is presented with. In the case of the transition to Webots, a much more complex environmental representation is implemented without significant parameter change. The transition to Webots demonstrated the power of the system to create hetergeneous continuous movement sequences from a single match set formation, despite levels of sensory noise in simulation being in excess of the emulated noise used in the continuous maze environment."}], "references": [{"title": "A genetic programming-based classifier system", "author": ["M Ahluwalia", "L Bull"], "venue": "RE (eds) Proceedings of the Genetic and Evolutionary Computation Conference", "citeRegEx": "Ahluwalia and Bull,? \\Q1999\\E", "shortCiteRegEx": "Ahluwalia and Bull", "year": 1999}, {"title": "Automated alphabet reduction method with evolutionary algorithms for protein structure prediction", "author": ["J Bacardit", "M Stout", "JD Hirst", "K Sastry", "X Llor\u00e0", "N Krasnogor"], "venue": "Lipson H (ed) Genetic and Evolutionary Computation Conference,", "citeRegEx": "Bacardit et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bacardit et al\\.", "year": 2007}, {"title": "Reinforcement distribution to fuzzy classifiers", "author": ["A Bonarini"], "venue": "Proceedings of the IEEE World Congress on Computational Intelligence (WCCI) \u2013 Evolutionary Computation,", "citeRegEx": "Bonarini,? \\Q1998\\E", "shortCiteRegEx": "Bonarini", "year": 1998}, {"title": "Learning fuzzy classifier systems for multi-agent coordination", "author": ["A Bonarini", "V Trianni"], "venue": "Information Sciences", "citeRegEx": "Bonarini and Trianni,? \\Q2001\\E", "shortCiteRegEx": "Bonarini and Trianni", "year": 2001}, {"title": "Generalization in reinforcement learning: Safely approximating the value function", "author": ["JA Boyan", "AW Moore"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Boyan and Moore,? \\Q1995\\E", "shortCiteRegEx": "Boyan and Moore", "year": 1995}, {"title": "Radial basis functions: theory and implementations", "author": ["MD Buhmann"], "venue": "Cambridge Monographs on Applied and Computational Mathematics,", "citeRegEx": "Buhmann,? \\Q2003\\E", "shortCiteRegEx": "Buhmann", "year": 2003}, {"title": "On using constructivism in neural classifier systems", "author": ["L Bull"], "venue": "HP (eds) Parallel Problem Solving from Nature - PPSN VII,", "citeRegEx": "Bull,? \\Q2002\\E", "shortCiteRegEx": "Bull", "year": 2002}, {"title": "On dynamical genetic programming: Simple boolean networks in learning classifier systems. International Journal of Parallel, Emergent and Distributed Systems", "author": ["L Bull"], "venue": null, "citeRegEx": "Bull,? \\Q2009\\E", "shortCiteRegEx": "Bull", "year": 2009}, {"title": "A learning classifier system approach to the identification of cellular automata. Cellular Automata", "author": ["L Bull", "A Adamatzky"], "venue": null, "citeRegEx": "Bull and Adamatzky,? \\Q2007\\E", "shortCiteRegEx": "Bull and Adamatzky", "year": 2007}, {"title": "A neural learning classifier system with self-adaptive constructivism", "author": ["L Bull", "J Hurst"], "venue": "Proceedings of the IEEE Congress on Evolutionary Computation,", "citeRegEx": "Bull and Hurst,? \\Q2003\\E", "shortCiteRegEx": "Bull and Hurst", "year": 2003}, {"title": "Accuracy-based neuro and neurofuzzy classifier systems", "author": ["L Bull", "T O\u2019Hara"], "venue": null, "citeRegEx": "Bull and O.Hara,? \\Q2002\\E", "shortCiteRegEx": "Bull and O.Hara", "year": 2002}, {"title": "Self-adaptive mutation in classifier system controllers. In: et al JAM (ed) From Animals to Animats", "author": ["L Bull", "J Hurst", "A Tomlinson"], "venue": "Proceedings of the Sixth International Conference on Simulation of Adaptive Behavior,", "citeRegEx": "Bull et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Bull et al\\.", "year": 2000}, {"title": "Context-dependent predictions and cognitive arm control with XCSF", "author": ["MV Butz", "O Herbort"], "venue": "Genetic and Evolutionary Computation Conference,", "citeRegEx": "Butz and Herbort,? \\Q2008\\E", "shortCiteRegEx": "Butz and Herbort", "year": 2008}, {"title": "Hyper-ellipsoidal conditions in xcs: rotation, linear approximation, and solution structure", "author": ["MV Butz", "PL Lanzi", "SW Wilson"], "venue": "Proceedings of the 8th annual conference on Genetic and evolutionary computation,", "citeRegEx": "Butz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Butz et al\\.", "year": 2006}, {"title": "A classifier system in real applications for robot navigation", "author": ["RR Cazangi", "FJV Zuben", "M Figueiredo"], "venue": "IEEE Congress on Evolutionary Computation, IEEE,", "citeRegEx": "Cazangi et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Cazangi et al\\.", "year": 2003}, {"title": "Adding temporary memory to ZCS. Adaptive Behavior", "author": ["D Cliff", "S Ross"], "venue": null, "citeRegEx": "Cliff and Ross,? \\Q1994\\E", "shortCiteRegEx": "Cliff and Ross", "year": 1994}, {"title": "A survey of commercial & open source unmanned vehicle simulators", "author": ["J Craighead", "RR Murphy", "J Burke", "BF Goldiez"], "venue": "In: International Conference of Robotics and Automation,", "citeRegEx": "Craighead et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Craighead et al\\.", "year": 2007}, {"title": "Toward the evolution of symbols. In: Grefenstette JJ (ed) Genetic Algorithms and their Applications (ICGA\u201987)", "author": ["CP Dolan", "MG Dyer"], "venue": null, "citeRegEx": "Dolan and Dyer,? \\Q1987\\E", "shortCiteRegEx": "Dolan and Dyer", "year": 1987}, {"title": "Learning reactive and planning rules in a motivationally autonomous animat", "author": ["JY Donnart", "JA Meyer"], "venue": "IEEE Transactions on Systems, Man and Cybernetics - Part B: Cybernetics", "citeRegEx": "Donnart and Meyer,? \\Q1996\\E", "shortCiteRegEx": "Donnart and Meyer", "year": 1996}, {"title": "Robot shaping: Developing autonomous agents through learning", "author": ["M Dorigo", "M Colombetti"], "venue": "Artificial Intelligence", "citeRegEx": "Dorigo and Colombetti,? \\Q1994\\E", "shortCiteRegEx": "Dorigo and Colombetti", "year": 1994}, {"title": "Evolution of spiking neural controllers for autonomous vision-based robots", "author": ["D Floreano", "C Mattiussi"], "venue": "Lecture Notes in Computer Science", "citeRegEx": "Floreano and Mattiussi,? \\Q2001\\E", "shortCiteRegEx": "Floreano and Mattiussi", "year": 2001}, {"title": "Neuroevolution: from architectures to learning", "author": ["D Floreano", "P D\u00fcrr", "C Mattiussi"], "venue": "Evolutionary Intelligence 1(1):47\u201362,", "citeRegEx": "Floreano et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Floreano et al\\.", "year": 2008}, {"title": "Spiking Neuron Models - Single Neurons, Populations, Plasticity", "author": ["W Gerstner", "W Kistler"], "venue": null, "citeRegEx": "Gerstner and Kistler,? \\Q2002\\E", "shortCiteRegEx": "Gerstner and Kistler", "year": 2002}, {"title": "Adaptation in Natural and Artificial Systems", "author": ["JH Holland"], "venue": null, "citeRegEx": "Holland,? \\Q1975\\E", "shortCiteRegEx": "Holland", "year": 1975}, {"title": "Cognitive systems based on adaptive algorithms", "author": ["JH Holland", "JS Reitman"], "venue": null, "citeRegEx": "Holland and Reitman,? \\Q1978\\E", "shortCiteRegEx": "Holland and Reitman", "year": 1978}, {"title": "On the effects of node duplication and connection-oriented constructivism in neural XCSF", "author": ["GD Howard", "L Bull"], "venue": "Genetic and Evolutionary Computation Conference,", "citeRegEx": "Howard and Bull,? \\Q2008\\E", "shortCiteRegEx": "Howard and Bull", "year": 2008}, {"title": "Self-adaptive constructivism in neural XCS and XCSF", "author": ["GD Howard", "L Bull", "PL Lanzi"], "venue": "Genetic and Evolutionary Computation Conference,", "citeRegEx": "Howard et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Howard et al\\.", "year": 2008}, {"title": "Towards continuous actions in continuous space and time using self-adaptive constructivism in neural XCSF", "author": ["GD Howard", "L Bull", "PL Lanzi"], "venue": "Proceedings of the 11th Annual conference on Genetic and evolutionary computation,", "citeRegEx": "Howard et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Howard et al\\.", "year": 2009}, {"title": "A neural learning classifier system with self-adaptive constructivism for mobile robot control", "author": ["J Hurst", "L Bull"], "venue": "Artificial Life", "citeRegEx": "Hurst and Bull,? \\Q2006\\E", "shortCiteRegEx": "Hurst and Bull", "year": 2006}, {"title": "TCS learning classifier system controller on a real robot", "author": ["J Hurst", "L Bull", "C Melhuish"], "venue": "Science", "citeRegEx": "Hurst et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Hurst et al\\.", "year": 2002}, {"title": "Interactive classifier system for real robot learning", "author": ["D Katagami", "S Yamada"], "venue": "IEEE International Workshop on Robot-Human Interaction - ROMAN-2000,", "citeRegEx": "Katagami and Yamada,? \\Q2000\\E", "shortCiteRegEx": "Katagami and Yamada", "year": 2000}, {"title": "Wrappers for feature subset selection", "author": ["R Kohavi", "G John"], "venue": "Artificial Intelligence", "citeRegEx": "Kohavi and John,? \\Q1997\\E", "shortCiteRegEx": "Kohavi and John", "year": 1997}, {"title": "Toward optimal feature selection", "author": ["D Koller", "M Sahami"], "venue": "In: International Conference on Machine Learning,", "citeRegEx": "Koller and Sahami,? \\Q1996\\E", "shortCiteRegEx": "Koller and Sahami", "year": 1996}, {"title": "A \u201cspike interval information coding\u201d representation for ATR\u2019s CAMBrain Machine (CBM)", "author": ["M Korkin", "NE Nawa", "H de Garis"], "venue": "Science", "citeRegEx": "Korkin et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Korkin et al\\.", "year": 1998}, {"title": "Extending the representation of classifier conditions part II: From messy coding to Sexpressions", "author": ["PL Lanzi", "A Perrucci"], "venue": "RE (eds) Proceedings of the Genetic and Evolutionary Computation", "citeRegEx": "Lanzi and Perrucci,? \\Q1999\\E", "shortCiteRegEx": "Lanzi and Perrucci", "year": 1999}, {"title": "Using convex hulls to represent classifier conditions", "author": ["PL Lanzi", "SW Wilson"], "venue": "Proceedings of the 8th annual conference on Genetic and evolutionary computation,", "citeRegEx": "Lanzi and Wilson,? \\Q2006\\E", "shortCiteRegEx": "Lanzi and Wilson", "year": 2006}, {"title": "XCS with computed prediction in continuous multistep", "author": ["PL Lanzi", "D Loiacono", "SW Wilson", "DE Goldberg"], "venue": null, "citeRegEx": "Lanzi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lanzi et al\\.", "year": 2005}, {"title": "XCS with computed prediction in multistep environments", "author": ["PL Lanzi", "D Loiacono", "SW Wilson", "DE Goldberg"], "venue": "Beyer HG, O\u2019Reilly UM (eds) Genetic and Evolutionary Computation Conference,", "citeRegEx": "Lanzi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lanzi et al\\.", "year": 2005}, {"title": "Classifier prediction based on tile coding", "author": ["PL Lanzi", "D Loiacono", "SW Wilson", "DE Goldberg"], "venue": "Proceedings of the 8th annual conference on Genetic and evolutionary computation,", "citeRegEx": "Lanzi et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Lanzi et al\\.", "year": 2006}, {"title": "Recherches quantitatifs sur l\u2019excitation electrique des nerfs traite comme une polarisation", "author": ["L Lapicque"], "venue": "Journal of Physiological Pathology, San Francisco, California, USA,", "citeRegEx": "Lapicque,? \\Q1907\\E", "shortCiteRegEx": "Lapicque", "year": 1907}, {"title": "Self-improvement based on reinforcement learning, planning and teaching", "author": ["LJ Lin"], "venue": "Machine Learning,", "citeRegEx": "Lin,? \\Q1991\\E", "shortCiteRegEx": "Lin", "year": 1991}, {"title": "Rule-based evolutionary systems for generalized reinforcement learning", "author": ["D Loiacono"], "venue": "PhD thesis,", "citeRegEx": "Loiacono,? \\Q2010\\E", "shortCiteRegEx": "Loiacono", "year": 2010}, {"title": "Networks of spiking neurons: the third generation of neural network models", "author": ["W Maass"], "venue": null, "citeRegEx": "Maass,? \\Q1997\\E", "shortCiteRegEx": "Maass", "year": 1997}, {"title": "Automatic programming of behavior-based robots using reinforcement learning", "author": ["S Mahadevan", "J Connell"], "venue": "Artificial Intelligence", "citeRegEx": "Mahadevan and Connell,? \\Q1992\\E", "shortCiteRegEx": "Mahadevan and Connell", "year": 1992}, {"title": "WebotsTM: Professional mobile robot simulation", "author": ["O Michel"], "venue": "International Journal of Advanced Robotic Systems", "citeRegEx": "Michel,? \\Q2004\\E", "shortCiteRegEx": "Michel", "year": 2004}, {"title": "Analysing learning classifier systems in reactive and non-reactive robotic tasks", "author": ["RC Moioli", "PA Vargas", "FJV Zuben"], "venue": "K (eds) International Workshop on Learning Classifier Systems IWLCS, Springer,", "citeRegEx": "Moioli et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Moioli et al\\.", "year": 2007}, {"title": "First results from experiments in fuzzy classifier system architectures for mobile robotics", "author": ["AG Pipe", "B Carse"], "venue": "Science", "citeRegEx": "Pipe and Carse,? \\Q2002\\E", "shortCiteRegEx": "Pipe and Carse", "year": 2002}, {"title": "The neural basis of cognitive development: A constructivist manifesto", "author": ["SR Quartz", "TJ Sejnowski"], "venue": "Behavioral and Brain Sciences", "citeRegEx": "Quartz and Sejnowski,? \\Q1997\\E", "shortCiteRegEx": "Quartz and Sejnowski", "year": 1997}, {"title": "Evolution of neural networks for classification and regression", "author": ["M Rocha", "P Cortez", "J Neves"], "venue": null, "citeRegEx": "Rocha et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Rocha et al\\.", "year": 2007}, {"title": "Neural processing of counting in evolved spiking and mccullochpitts agents", "author": ["K Saggie-Wexler", "A Keinan", "E Ruppin"], "venue": "Artificial Life", "citeRegEx": "Saggie.Wexler et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Saggie.Wexler et al\\.", "year": 2006}, {"title": "Experiments with reinforcement learning in problems with continuous state and action spaces", "author": ["JC Santamaria", "RS Sutton", "A Ram"], "venue": "Tech. rep.,", "citeRegEx": "Santamaria et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Santamaria et al\\.", "year": 1998}, {"title": "Analysing the evolvability of neural network agents through structural mutations", "author": ["E Schlessinger", "PJ Bentley", "RB Lotto"], "venue": "J (eds) Advances in Artificial Life,", "citeRegEx": "Schlessinger et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Schlessinger et al\\.", "year": 2005}, {"title": "Evolving neural networks through augmenting topologies", "author": ["KO Stanley", "R Miikkulainen"], "venue": "Evolutionary Computation", "citeRegEx": "Stanley and Miikkulainen,? \\Q2002\\E", "shortCiteRegEx": "Stanley and Miikkulainen", "year": 2002}, {"title": "Latent learning in khepera robots with anticipatory classifier systems", "author": ["W Stolzmann"], "venue": "SW (eds) 2nd International Workshop on Learning Classifier Systems,", "citeRegEx": "Stolzmann,? \\Q1999\\E", "shortCiteRegEx": "Stolzmann", "year": 1999}, {"title": "X-TCS: accuracy-based learning classifier system robotics", "author": ["M Studley", "L Bull"], "venue": "IEEE Congress on Evolutionary Computation,", "citeRegEx": "Studley and Bull,? \\Q2005\\E", "shortCiteRegEx": "Studley and Bull", "year": 2005}, {"title": "Generalization in reinforcement learning: Successful examples using sparse coarse coding", "author": ["RS Sutton"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Sutton,? \\Q1996\\E", "shortCiteRegEx": "Sutton", "year": 1996}, {"title": "Reinforcement Learning: An Introduction", "author": ["RS Sutton", "AG Barto"], "venue": null, "citeRegEx": "Sutton and Barto,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto", "year": 1998}, {"title": "Between mdps and semi-mdps: a framework for temporal abstraction in reinforcement learning", "author": ["RS Sutton", "D Precup", "S Singh"], "venue": "Artificial Intelligence", "citeRegEx": "Sutton et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Sutton et al\\.", "year": 1999}, {"title": "Reinforcement learning of multiple tasks using a hierarchical CMAC architecture. Robotics and Autonomous Systems", "author": ["CK Tham"], "venue": null, "citeRegEx": "Tham,? \\Q1995\\E", "shortCiteRegEx": "Tham", "year": 1995}, {"title": "The fuzzy classifier system: a classifier system for continuously varying variables", "author": ["M Valenzuela-Rend\u00f3n"], "venue": "Booker LB, Belew RK (eds) Proceedings of the 4th International Conference on Genetic Algorithms", "citeRegEx": "Valenzuela.Rend\u00f3n,? \\Q1991\\E", "shortCiteRegEx": "Valenzuela.Rend\u00f3n", "year": 1991}, {"title": "Learning from delayed rewards", "author": ["C Watkins"], "venue": "PhD thesis,", "citeRegEx": "Watkins,? \\Q1989\\E", "shortCiteRegEx": "Watkins", "year": 1989}, {"title": "Controlling a simulated khepera with an XCS classifier system with memory", "author": ["A Webb", "E Hart", "P Ross", "A Lawson"], "venue": "J (eds) Advances in Artificial Life, 7th European Conference,", "citeRegEx": "Webb et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Webb et al\\.", "year": 2003}, {"title": "ZCS: A zeroth level classifier system. Evolutionary Computation", "author": ["SW Wilson"], "venue": null, "citeRegEx": "Wilson,? \\Q1994\\E", "shortCiteRegEx": "Wilson", "year": 1994}, {"title": "Classifier fitness based on accuracy. Evolutionary Computation", "author": ["SW Wilson"], "venue": null, "citeRegEx": "Wilson,? \\Q1995\\E", "shortCiteRegEx": "Wilson", "year": 1995}, {"title": "Get real! xcs with continuous-valued inputs. In: Learning Classifier Systems, From Foundations to Applications, LNAI-1813", "author": ["SW Wilson"], "venue": null, "citeRegEx": "Wilson,? \\Q2000\\E", "shortCiteRegEx": "Wilson", "year": 2000}, {"title": "Function approximation with a classifier system", "author": ["SW Wilson"], "venue": "Proceedings of the Genetic and Evolutionary Computation Conference (GECCO-", "citeRegEx": "Wilson,? \\Q2001\\E", "shortCiteRegEx": "Wilson", "year": 2001}, {"title": "Mining oblique data with XCS", "author": ["SW Wilson"], "venue": "IWLCS", "citeRegEx": "Wilson,? \\Q2001\\E", "shortCiteRegEx": "Wilson", "year": 2001}], "referenceMentions": [{"referenceID": 42, "context": "Maass (1997), Saggie-Wexler et al (2006)).", "startOffset": 0, "endOffset": 13}, {"referenceID": 42, "context": "Maass (1997), Saggie-Wexler et al (2006)).", "startOffset": 0, "endOffset": 41}, {"referenceID": 23, "context": "Our specific approach to temporal machine learning involves the use of a Learning Classifier System, or LCS (Holland, 1976), a form of online evolutionary reinforcement-based learning that evolves a population of (condition, action, prediction) rules using a Genetic Algorithm (GA) (Holland, 1975).", "startOffset": 282, "endOffset": 297}, {"referenceID": 35, "context": "Rule representations have since been extended to handle integer and real-valued states using several representations including intervals (Wilson (2000) and Wilson (2001b) respectively), hyperellipsoids (Butz et al, 2006) and convex hulls (Lanzi and Wilson, 2006), opening LCSs to more varied problem domains.", "startOffset": 238, "endOffset": 262}, {"referenceID": 61, "context": "Rule representations have since been extended to handle integer and real-valued states using several representations including intervals (Wilson (2000) and Wilson (2001b) respectively), hyperellipsoids (Butz et al, 2006) and convex hulls (Lanzi and Wilson, 2006), opening LCSs to more varied problem domains.", "startOffset": 138, "endOffset": 152}, {"referenceID": 61, "context": "Rule representations have since been extended to handle integer and real-valued states using several representations including intervals (Wilson (2000) and Wilson (2001b) respectively), hyperellipsoids (Butz et al, 2006) and convex hulls (Lanzi and Wilson, 2006), opening LCSs to more varied problem domains.", "startOffset": 138, "endOffset": 171}, {"referenceID": 34, "context": "Further extensions enlarged the remit of LCS, including LISP S-expression rule conditions (Lanzi and Perrucci, 1999), computed actions (Ahluwalia and Bull, 1999), and", "startOffset": 90, "endOffset": 116}, {"referenceID": 0, "context": "Further extensions enlarged the remit of LCS, including LISP S-expression rule conditions (Lanzi and Perrucci, 1999), computed actions (Ahluwalia and Bull, 1999), and", "startOffset": 135, "endOffset": 161}, {"referenceID": 59, "context": "fuzzy logic with computed actions (Valenzuela-Rend\u00f3n, 1991).", "startOffset": 34, "endOffset": 59}, {"referenceID": 6, "context": "Artificial neural networks have also been used to the same effect (Bull, 2002).", "startOffset": 66, "endOffset": 78}, {"referenceID": 6, "context": "Artificial neural networks have also been used to the same effect (Bull, 2002). We follow previous work with LCS using neural classifiers, (e.g. Howard et al (2008)), which has shown that it is possible to allow evolution to control both the number of hidden layer nodes (termed Neural Constructivism) and the number of node connections (termed Connection Selection) during the reinforcement learning process, alongside each classifier\u2019s rates of mutation.", "startOffset": 67, "endOffset": 165}, {"referenceID": 7, "context": "To date, only one scheme that can utilise temporal information has been used within LCS; a form of recurrent Boolean logic network (Bull, 2009).", "startOffset": 131, "endOffset": 143}, {"referenceID": 54, "context": "Additionally, we modify our LCS as in (Studley and Bull, 2005) to create a Temporal Classifier System (TCS), which facilitates generalisation in both time and space, thereby enabling more direct use of the temporal behaviour of the neurons for determining actions.", "startOffset": 38, "endOffset": 62}, {"referenceID": 60, "context": "To address these questions, we test our SNN representation against both an MLP representation and a tabular Qlearner (Watkins, 1989), which acts as a benchmark, on a standard Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem (a 2-D grid world).", "startOffset": 117, "endOffset": 132}, {"referenceID": 56, "context": "To address these questions, we test our SNN representation against both an MLP representation and a tabular Qlearner (Watkins, 1989), which acts as a benchmark, on a standard Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem (a 2-D grid world).", "startOffset": 203, "endOffset": 227}, {"referenceID": 6, "context": "The initial work exploring artificial neural networks within LCS used traditional feedforward MLPs to represent the rules (Bull, 2002).", "startOffset": 122, "endOffset": 134}, {"referenceID": 9, "context": "Recurrent MLPs were then shown able to provide memory for a simple maze task (Bull and Hurst, 2003).", "startOffset": 77, "endOffset": 99}, {"referenceID": 28, "context": "Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks.", "startOffset": 46, "endOffset": 68}, {"referenceID": 10, "context": "Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks.", "startOffset": 92, "endOffset": 115}, {"referenceID": 10, "context": "Analysis of the rule sets produced in (Bull and O\u2019Hara, 2002) shows networks evolve that compute different actions that vary depending upon the environmental input, as long as the correct payoff value for those (state,action) combinations is identical.", "startOffset": 38, "endOffset": 61}, {"referenceID": 25, "context": "We have recently extended this vein of research by introducing explicit network-wide feature selection, termed \u201cconnection selection\u201d, which allows each inter-neural connection to be probabilistically enabled or disabled, with the aim of reducing the number of connection weights within the rules (Howard and Bull, 2008).", "startOffset": 297, "endOffset": 320}, {"referenceID": 22, "context": "They are covered in detail in (Gerstner and Kistler, 2002).", "startOffset": 30, "endOffset": 58}, {"referenceID": 5, "context": "Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks.", "startOffset": 0, "endOffset": 15}, {"referenceID": 5, "context": "Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks. Analysis of the rule sets produced in (Bull and O\u2019Hara, 2002) shows networks evolve that compute different actions that vary depending upon the environmental input, as long as the correct payoff value for those (state,action) combinations is identical. The authors hypothesize that it may be possible for the system to function optimally with only a single neural rule per possible payoff value, attesting to the compact rule representation and generalization capabilities of the neural LCS. Both MLP and RBF networks have been shown amenable to a constructionist approach, which can be defined as a method whereby the number of nodes within the hidden layer is under evolutionary control, along with the connection weights (Bull (2002); Hurst and Bull (2006)).", "startOffset": 0, "endOffset": 860}, {"referenceID": 5, "context": "Buhmann (2003)) were later used for both real (Hurst and Bull, 2006) and simulated robotics (Bull and O\u2019Hara, 2002) tasks. Analysis of the rule sets produced in (Bull and O\u2019Hara, 2002) shows networks evolve that compute different actions that vary depending upon the environmental input, as long as the correct payoff value for those (state,action) combinations is identical. The authors hypothesize that it may be possible for the system to function optimally with only a single neural rule per possible payoff value, attesting to the compact rule representation and generalization capabilities of the neural LCS. Both MLP and RBF networks have been shown amenable to a constructionist approach, which can be defined as a method whereby the number of nodes within the hidden layer is under evolutionary control, along with the connection weights (Bull (2002); Hurst and Bull (2006)).", "startOffset": 0, "endOffset": 883}, {"referenceID": 20, "context": "SRM networks were later evolved for vision-based robot navigation (Floreano and Mattiussi, 2001).", "startOffset": 66, "endOffset": 96}, {"referenceID": 63, "context": "That is, classifier prediction is not a constant value as in other LCS, such as XCS (Wilson, 1995).", "startOffset": 84, "endOffset": 98}, {"referenceID": 62, "context": "It is also important to note the distinction between \u201cconnection weight\u201d, which refers to a node-to-node weight within a neural network and \u201cprediction weight\u201d, which is used as in XCSF to calculate classifier prediction linearly (after Wilson (2001a)).", "startOffset": 237, "endOffset": 252}, {"referenceID": 6, "context": "Similarly to Bull (2002), the final output neuron is a dont-match", "startOffset": 13, "endOffset": 25}, {"referenceID": 39, "context": "Mathematical models of the most basic current spiking neuron, the Leaky Integrate and Fire (LIF) neuron, can be traced back to as early as 1907 (Lapicque, 1907).", "startOffset": 144, "endOffset": 160}, {"referenceID": 50, "context": "by Stanley and Miikkulainen (2002)).", "startOffset": 3, "endOffset": 35}, {"referenceID": 6, "context": "This allows each classifier to control its own knowledge representation autonomously in terms of both frequency and range of mutation that takes place in a given niche at a given time (Bull et al, 2000), and by adapting the hidden layer topology of the neural networks to reflect the complexity of the problem sub-space considered by the network (Bull, 2002).", "startOffset": 346, "endOffset": 358}, {"referenceID": 47, "context": ", (Quartz and Sejnowski, 1997)) postulates that neural structures are initially small and sparsely connected.", "startOffset": 2, "endOffset": 30}, {"referenceID": 6, "context": "The implementation of constructivism in this system is based on the aforementioned work in neural LCS (Bull, 2002).", "startOffset": 102, "endOffset": 114}, {"referenceID": 26, "context": ", Kohavi and John (1997)) and filter approaches (where subset selection is a pre-processing step and subsets are immutable during the running of the algorithm, e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 26, "context": ", Kohavi and John (1997)) and filter approaches (where subset selection is a pre-processing step and subsets are immutable during the running of the algorithm, e.g. Koller and Sahami (1996)).", "startOffset": 2, "endOffset": 190}, {"referenceID": 14, "context": "The connection structure of artificial neural networks was first evolved by Dolan and Dyer Dolan and Dyer (1987). A comparative summary can be found in Schlessinger et al (2005), where many neuro-evolution methodologies are compared by the authors.", "startOffset": 76, "endOffset": 113}, {"referenceID": 14, "context": "The connection structure of artificial neural networks was first evolved by Dolan and Dyer Dolan and Dyer (1987). A comparative summary can be found in Schlessinger et al (2005), where many neuro-evolution methodologies are compared by the authors.", "startOffset": 76, "endOffset": 178}, {"referenceID": 6, "context": "Explicit FS within LCS has been investigated by Bull and Adamatzky (2007) and Bacardit et al (2007).", "startOffset": 48, "endOffset": 74}, {"referenceID": 6, "context": "Explicit FS within LCS has been investigated by Bull and Adamatzky (2007) and Bacardit et al (2007). In this paper we allow any connection to be individually enabled/disabled, a mechanism termed \u201cConnection Selection\u201d.", "startOffset": 48, "endOffset": 100}, {"referenceID": 6, "context": "Explicit FS within LCS has been investigated by Bull and Adamatzky (2007) and Bacardit et al (2007). In this paper we allow any connection to be individually enabled/disabled, a mechanism termed \u201cConnection Selection\u201d. Connection selection is implemented in our system as follows: During a GA cycle, and based on a new selfadaptive parameter \u03c4 (0 < \u03c4 \u2264 1) (which is initialized and self-adapted in the same manner as the other parameters), an enabled connection can be disabled, or vice versa. If a connection is enabled, its connection weight is randomly initialised uniformly in the range [0, 1]. All connections are initially enabled for new classifiers and classifiers created via cover. During a node addition event, new connections are enabled probabilistically, with P(connection enabled) = 0.5, with connection weight randomly set uniformly in the range [0,1] as before. We previously have shown the utility of this approach for reducing network complexity (e.g., Howard and Bull (2008)).", "startOffset": 48, "endOffset": 995}, {"referenceID": 4, "context": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem.", "startOffset": 60, "endOffset": 83}, {"referenceID": 56, "context": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem.", "startOffset": 135, "endOffset": 159}, {"referenceID": 4, "context": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem. We compare to our earlier work using an MLP-based N-XCSF (see Howard et al (2008); Howard et al (2009) for details).", "startOffset": 61, "endOffset": 256}, {"referenceID": 4, "context": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem. We compare to our earlier work using an MLP-based N-XCSF (see Howard et al (2008); Howard et al (2009) for details).", "startOffset": 61, "endOffset": 277}, {"referenceID": 4, "context": "Experiments were conducted on the continuous 2-D grid world (Boyan and Moore, 1995), a standard continuous Reinforcement Learning (RL) (Sutton and Barto, 1998) test problem. We compare to our earlier work using an MLP-based N-XCSF (see Howard et al (2008); Howard et al (2009) for details). Each experiment was comprised of a number of trials. A trial was defined as starting when the agent is initially positioned randomly in the environment, consisting of a number of [M] and [A] formations as the agent navigated in the environment, and finishing either with the agent reaching the goal state and receiving reward, or the trial timing out after the agent has moved 200 steps (a time-saving measure). Each trial was either in exploration mode (roulette wheel action selection, see e.g. Howard et al (2008) for reasoning) or exploitation mode (deterministic action selection).", "startOffset": 61, "endOffset": 808}, {"referenceID": 41, "context": "We performed the optimal spatial discretisation (in terms of Q-learner performance) as given in (Loiacono, 2010) to discretise the continuous space into a 21 \u00d7 21 grid for the x and y coordinates that comprise st , as shown in equation 5.", "startOffset": 96, "endOffset": 112}, {"referenceID": 43, "context": "When a programmer is prepared or able to define the state space discretisation a priori, this methodology has been proven to work for robot systems (Mahadevan and Connell, 1992).", "startOffset": 148, "endOffset": 177}, {"referenceID": 40, "context": ", (Lin, 1991), (Tham, 1995)).", "startOffset": 2, "endOffset": 13}, {"referenceID": 58, "context": ", (Lin, 1991), (Tham, 1995)).", "startOffset": 15, "endOffset": 27}, {"referenceID": 19, "context": "Within LCS, the approach has traditionally been either to predefine the temporal duration of an action (Dorigo and Colombetti, 1994) or to predefine the amount by which a sensor reading must change before a change in state is said to have occurred (Cliff and Ross, 1994).", "startOffset": 103, "endOffset": 132}, {"referenceID": 15, "context": "Within LCS, the approach has traditionally been either to predefine the temporal duration of an action (Dorigo and Colombetti, 1994) or to predefine the amount by which a sensor reading must change before a change in state is said to have occurred (Cliff and Ross, 1994).", "startOffset": 248, "endOffset": 270}, {"referenceID": 38, "context": ", (Lin, 1991), (Tham, 1995)). Santamaria et al (1998) extended the latter approach by considering continuousduration action spaces.", "startOffset": 3, "endOffset": 54}, {"referenceID": 62, "context": "Our system is based on the Temporal LCS (TCS) which has been used with both ZCS (originally (Wilson, 1994), implemented in (Hurst et al, 2002)) and, more recently, with XCS (Studley and Bull, 2005) and with XCSF and MLPs (Howard et al, 2009).", "startOffset": 92, "endOffset": 106}, {"referenceID": 54, "context": "Our system is based on the Temporal LCS (TCS) which has been used with both ZCS (originally (Wilson, 1994), implemented in (Hurst et al, 2002)) and, more recently, with XCS (Studley and Bull, 2005) and with XCSF and MLPs (Howard et al, 2009).", "startOffset": 173, "endOffset": 197}, {"referenceID": 55, "context": "To demonstrate the general learning ability of spiking TCS, we also tested on the mountain-car problem (Sutton, 1996), in which a car must be guided out of a one-dimensional valley.", "startOffset": 103, "endOffset": 117}, {"referenceID": 55, "context": "For a complete algorithmic description see (Sutton, 1996).", "startOffset": 43, "endOffset": 57}, {"referenceID": 58, "context": "(Tham, 1995)) scheme (Lanzi et al, 2006).", "startOffset": 0, "endOffset": 12}, {"referenceID": 44, "context": "Our chosen development simulator is the Webots robotics platform (Michel, 2004), a test bed chosen due to its popularity in the research community.", "startOffset": 65, "endOffset": 79}, {"referenceID": 24, "context": "The authors used a modified version of Hollands classifier system (Holland and Reitman, 1978), to create a hierarchical LCS in which lower-level LCSs can learn simple behaviours, which high-level LCSs then coordinate to generate complex actions.", "startOffset": 66, "endOffset": 93}, {"referenceID": 18, "context": "MONALYSA (Donnart and Meyer, 1996) was a hierarchicial LCS in which the hierarchy itself could be dynamically reconfigured.", "startOffset": 9, "endOffset": 34}, {"referenceID": 18, "context": "The first LCS to successfully tackle the world of real robot control was the work of Dorigo and Colombetti (1994). The authors used a modified version of Hollands classifier system (Holland and Reitman, 1978), to create a hierarchical LCS in which lower-level LCSs can learn simple behaviours, which high-level LCSs then coordinate to generate complex actions.", "startOffset": 85, "endOffset": 114}, {"referenceID": 46, "context": "duced by Pipe and Carse (2002) for implementation on a robotics platform.", "startOffset": 9, "endOffset": 31}, {"referenceID": 53, "context": "Latent learning was realized in a classifier system by Stolzmann (1999), providing a degree of premonition.", "startOffset": 55, "endOffset": 72}, {"referenceID": 10, "context": "More recently, Butz and Herbort (2008) demonstrated an XCSF-derivative to control a robot arm using a real interval representation.", "startOffset": 15, "endOffset": 39}, {"referenceID": 10, "context": "More recently, Butz and Herbort (2008) demonstrated an XCSF-derivative to control a robot arm using a real interval representation. Recent research by Moioli et al (2007) compared attempts at T-maze navigation in both simulated and real robotics tasks, and presented results that reinforce the idea that TCS is a valid method for dealing with long-action chains that are present in many robotic environments.", "startOffset": 15, "endOffset": 171}, {"referenceID": 10, "context": "More recently, Butz and Herbort (2008) demonstrated an XCSF-derivative to control a robot arm using a real interval representation. Recent research by Moioli et al (2007) compared attempts at T-maze navigation in both simulated and real robotics tasks, and presented results that reinforce the idea that TCS is a valid method for dealing with long-action chains that are present in many robotic environments. Similarly to Webb et al (2003), the authors added a memory register and tested the system on a non-reactive robotics task.", "startOffset": 15, "endOffset": 440}, {"referenceID": 6, "context": "It should be noted that TCS-based systems have previously been used explicitly for real robot navigation, by Studley and Bull (2005) and Hurst and Bull (2006).", "startOffset": 121, "endOffset": 133}, {"referenceID": 6, "context": "It should be noted that TCS-based systems have previously been used explicitly for real robot navigation, by Studley and Bull (2005) and Hurst and Bull (2006).", "startOffset": 121, "endOffset": 159}, {"referenceID": 28, "context": "After (Hurst and Bull, 2006), six sensors were used to comprise the input state, three IR and three light sensors at positions 0, 2 and 5 (see Fig.", "startOffset": 6, "endOffset": 28}, {"referenceID": 28, "context": "If either bumper was activated, an interrupt was sent causing the agent to reverse 10cm and form a new [M] (after (Hurst and Bull, 2006)).", "startOffset": 114, "endOffset": 136}, {"referenceID": 28, "context": "(Hurst and Bull, 2006)).", "startOffset": 0, "endOffset": 22}], "year": 2012, "abstractText": "Learning Classifier Systems (LCS) are populationbased reinforcement learners used in a wide variety of applications. This paper presents a LCS where each traditional rule is represented by a spiking neural network, a type of network with dynamic internal state. We employ a constructivist model of growth of both neurons and dendrites that realise flexible learning by evolving structures of sufficient complexity to solve a well-known problem involving continuous, real-valued inputs. Additionally, we extend the system to enable temporal state decomposition. By allowing our LCS to chain together sequences of heterogeneous actions into macro-actions, it is shown to perform optimally in a problem where traditional methods can fail to find a solution in a reasonable amount of time. Our final system is tested on a simulated robotics platform.", "creator": "LaTeX with hyperref package"}}}