{"id": "1206.4649", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jun-2012", "title": "Learning Efficient Structured Sparse Models", "abstract": "We present a comprehensive framework for structured sparse encoding and modeling that extends the latest ideas of using learnable fast regressors to approximate exact sparse encodings. To this end, we develop a novel block-coordinate splitting method to iteratively solve hierarchical sparse encoding problems and demonstrate an efficient feed-forward architecture derived from iteration.This architecture approaches the exact structured sparse encodings faithfully to a fraction of the complexity of standard optimization methods.We also demonstrate that learnable sparse encoders can be used more as full-fledged sparse encoders or even modelers by using different training object functions, no longer confined to mere approximations of the exact sparse dictionary of specified sparse codes, as in previous formulations, but can be used more as full-fledged sparse encoders or even modelers. A simple implementation demonstrates several orders of magnitude reduction compared to the scope proposed for large-scale engineering.", "histories": [["v1", "Mon, 18 Jun 2012 15:23:19 GMT  (609kb)", "http://arxiv.org/abs/1206.4649v1", "ICML2012"]], "COMMENTS": "ICML2012", "reviews": [], "SUBJECTS": "cs.LG cs.CV stat.ML", "authors": ["alexander m bronstein", "pablo sprechmann", "guillermo sapiro"], "accepted": true, "id": "1206.4649"}, "pdf": {"name": "1206.4649.pdf", "metadata": {"source": "META", "title": "Learning Efficient Structured Sparse Models", "authors": ["Pablo Sprechmann", "Alex Bronstein"], "emails": ["sprec009@umn.edu", "bron@cs.technion.ac.il", "guille@umn.edu"], "sections": [{"heading": "1. Introduction", "text": "Sparse coding is the problem of representing signals as a sparse linear combination of elementary atoms of a given dictionary. Sparse modeling aims at learning such (non-)parametric dictionaries from the data themselves. In addition to being very attractive at the theoretical level, a large class of signals is well described by this model, as demonstrated by numerous state-of-the-art results in diverse applications.\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nThe main challenge of all optimization-based sparse coding and modeling approaches is their relatively high computational complexity. Consequently, a significant amount of effort has been devoted to developing efficient optimization schemes (Beck & Teboulle, 2009; Li & Osher, 2009; Nesterov, 2007; Xiang et al., 2011). Despite the permanent progress reported in the literature, the state-of-the-art algorithms require tens or hundreds of iterations to converge, making them infeasible for real-time or very large (modern size) applications.\nRecent works have proposed to trade off precision in the sparse representation for computational speedup (Jarrett et al., 2009; Kavukcuoglu et al., 2010), by learning non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time. The insightful work by (Gregor & LeCun, 2010) introduced a novel approach in which the regressors are multi-layer artificial neural networks (NN) with a particular architecture inspired by successful optimization algorithms for solving sparse coding problems. These regressors are trained to minimize the MSE between the predicted and exact codes over a given training set. Unlike previous predictive approaches, the system introduced in (Gregor & LeCun, 2010) has an architecture capable of producing more accurate approximations of the true sparse codes, since it allows an approximate \u201cexplaining away\u201d to take place during inference (see (Gregor & LeCun, 2010) for details). In this paper we propose several extensions of (Gregor & LeCun, 2010), including the consideration of more general sparse coding paradigms (hierarchical and non-overlapping grouped), adding online adaptation of the underlying dictionary/model, thereby extending the applicability of this fast encoding framework. The proposed approach can be used with a predefined dictionary or learn it in an online manner on the very same data vectors fed to it.\nWhile differently motivated, in the case in which the\ndictionary is learned, the framework is related to recent efforts in producing NN based sparse representations, see (Goodfellow et al., 2009; Ranzato et al., 2007) and references therein. It can be interpreted as an online trainable sparse auto-encoder (Goodfellow et al., 2009) with a sophisticated encoder and simple linear decoder. The higher complexity of the proposed architecture in the encoder allows the system to produce accurate estimates of true structured sparse codes.\nIn Section 2 we briefly present the general problem of hierarchical structured sparse coding and in Section 3 discuss the optimization algorithm used to inspire the architecture of the encoders. In Section 4 we present the new sparse encoders and the new objective functions used for their training. Experimental results in real audio and image analysis tasks are presented in Section 5. Finally, conclusions are drawn in Section 6."}, {"heading": "2. Structured Sparse Models", "text": "The underlying assumption of sparse models is that the input vectors can be reconstructed accurately as a linear combination of some (usually learned) basis vectors (factors or dictionary atoms) with a small number of non-zero coefficients. Structured sparse models further assume that the pattern of non-zero coefficients exhibits a specific structure known a priori.\nLet D \u2208 Rm\u00d7p be a dictionary with p m-dimensional atoms. We define groups of atoms through their indexes, G \u2286 {1, . . . , p}. Then, we define a group structure, G, as collection of groups of atoms, G = {G1, . . . , G|G|}. For an input vector x \u2208 Rm, the corresponding structured sparse code, z \u2208 Rp, associated to the group structure G, can be obtained by solving the convex program,\nmin z\u2208Rp\n1 2 \u2016x\u2212Dz\u201622 + \u03c8(z), (1)\n\u03c8(z) = \u2211 r\u2208G \u03bbr \u2016zr\u20162 , (2)\nwhere the vector zr \u2208 R|Gr| contains the coefficients of z belonging to group r, and \u03bbr are scalar weights controlling the sparsity level.\nThe regularizer function \u03c8 in (1) can be seen as a generalization of the `1 regularizer used in standard sparse coding, as the latter arises from the special case of singleton groups G = {{1}, {2}, . . . , {p}} and setting \u03bbr = 1. As such, its effect on the groups of z is a natural generalization of the one obtained with standard sparse coding: it \u201cturns on\u201d and \u201coff\u201d atoms in groups according to the structure imposed by G.\nAlgorithm 1 Forward-backward splitting method.\ninput : Data x, dictionary D, regularizer \u03c8. output: Sparse code z. Define S = I\u2212 1\u03b1D TD, W = 1\u03b1D T, t = 1\u03b1 . Initialize z = 0 and b = Wx. repeat\nz = proxt\u03c8(b) b = b + Sz\nuntil until convergence;\nSeveral important structured sparsity settings can be cast as particular cases of (1): sparse coding, as mentioned above, which is often referred to as Lasso (Tibshirani, 1996) or basis pursuit (Chen et al., 1999; Donoho, 2006); group sparse coding, a generalization of the standard sparse coding to the cases in which the dictionary is sub-divided into groups that are known to be active or inactive simultaneously (Yuan & Lin, 2006), in this case G is a partition of {1, . . . , p}; hierarchical sparse coding, assuming a hierarchical structure of the non-zero coefficients (Zhao et al., 2009; Jenatton et al., 2011; Sprechmann et al., 2011). The groups in G form a hierarchy with respect to the inclusion relation (a tree structure), that is, if two groups overlap, then one is completely included in the other one; and collaborative sparse coding generalizing the concept of structured sparse coding to collections of input vectors by promoting given patterns of non-zero elements in the coefficient matrix (Eldar & Rauhut, 2010; Sprechmann et al., 2011)."}, {"heading": "3. Optimization Algorithms", "text": "State-of-the-art approaches for solving (1) rely on the family of proximal splitting methods (see (Bach et al., 2011) and references therein). Next, we briefly introduce proximal methods and an algorithm for solving hierarchical sparse coding problems (Tseng, 2001) that will be used to construct trainable sparse encoders."}, {"heading": "3.1. Forward-Backward Splitting", "text": "The forward-backward splitting method is designed for solving unconstrained optimization problems in which the cost function can be split as\nmin z\u2208Rm f1(z) + f2(z), (3)\nwhere f1 is convex and differentiable with a 1 \u03b1 - Lipschitz continuous gradient, and f2 is convex extended real valued and possibly non-smooth. Clearly, problem (1) falls in this category by considering f1(z) = 1 2 \u2016x\u2212Dz\u2016 2 2 and f2(z) = \u03c8(z).\nThe forward-backward splitting method with fixed constant step defines a series of iterates,\nzk+1 = prox\u03b1f2(z k \u2212 1\n\u03b1 \u2207f1(zk)), (4)\nwhere proxf2(z) = argmin u\u2208Rm\n||u \u2212 z||22 + f2(u) denotes\nthe proximal operator of f2. The procedure is given in Algorithm 1.\nThe forward-backward method becomes particularly interesting when the proximal operator of \u03c8 can be computed exactly and efficiently, e.g., in standard or group-structured sparse coding. When the groups of G overlap arbitrarily, there is no efficient way of doing so directly. However, there exist important exceptions such as the hierarchical setting with tree-structured groups which is discussed in the sequel. Accelerated versions of proximal methods have been largely studied in the literature to improve their convergence rate (Beck & Teboulle, 2009; Nesterov, 2007). While these variants are the fastest exact solvers available (both in theory and practice), they still require tens or hundreds of iterations to achieve convergence. In the following sections we will elaborate in the standard versions of the algorithm since we are only interested in constructing an architecture for the proposed sparse encoders."}, {"heading": "3.2. Proximal Operators", "text": "To simplify the notation, we will henceforth formulate all the derivations for the case of two-level hierarchical sparse coding, referred as HiLasso (Friedman et al., 2010; Sprechmann et al., 2011). This captures the essence of hierarchical sparse models and the generalization to more layers (Jenatton et al., 2011) or to a collaborative scheme (Sprechmann et al., 2011) is straightforward.\nThe HiLasso model was introduced for simultaneously promoting sparsity at both, group and coefficient level. Given a partition P = {G1, . . . , G|P|}, the group structure G can be expressed as the union of two partitions: P and the set of singletons. Thus, the regularizer \u03c8 becomes\n\u03c8(z) = p\u2211 j=1 \u03bbj \u2016zj\u20161 + |P|\u2211 r=1 \u00b5r \u2016zr\u20162 . (5)\nThe proximal operator of \u03c8 can then be computed in closed form. Given a partition of the group of indexes, P, and a vector of thresholding parameters \u03bb \u2208 R|P|, we define the group separable operator \u03c0\u03bb : Rp \u2192 Rp\nAlgorithm 2 BCoFB algorithm.\ninput : Data x, structured dictionary D, \u03bb, \u00b5. output: Structured sparse code z. Bound Lipschitz constant \u03b1 \u2264 maxr \u2016Dr\u201622 Define S = I \u2212 1\u03b1D TD, W = 1\u03b1D T, s = 1\u03b1\u00b5, and t = 1\u03b1\u03bb. Initialize z = 0 and b = Wx. repeat\ny = \u03c0s,t(b) e = y \u2212 z g = arg maxr \u2016er\u20162 b = b + Sgeg zg = yg\nuntil until convergence; Output z = \u03c0s,t(b)\nfor r = 1, . . . , |P| as\n\u03c0\u03bb(z)r = max{0, \u2016zr\u20162 \u2212 \u03bbr}\n\u2016zr\u20162 zr (6)\nif \u2016zr\u20162 > 0, and 0 otherwise. Note that \u03c0\u03bb applies a vector soft-thresholding to each group in P. The proximal operator of (5) can be expressed as (Jenatton et al., 2011; Sprechmann et al., 2011),\n\u03c0\u03bb,\u00b5(z) = \u03c0\u00b5(\u03c0\u03bb(z)), (7)\na composition of the proximal operators associated to each of the partitions in G: P and the set of singletons.\nThe Lasso problem is a particular case of HiLasso with \u00b5 = 0 and \u03bb = \u03bb1, in which the proximal operator in (7) reduces to the scalar soft-thresholding operator and Algorithm 1 corresponds then to the popular iterative shrinkage and thresholding algorithm (ISTA) (Beck & Teboulle, 2009)."}, {"heading": "3.3. Block-Coordinate Forward-Backward Algorithm", "text": "In Algorithm 1, every iteration requires the update of all the groups of coefficients in the partition P, according to (7). One can choose a block coordinate strategy where only one block is updated at a time (Tseng, 2001). In this paper we will refer to this algorithm as Block-Coordinate Forward-Backward algorithm (BCoFB) (see (Bach et al., 2011) for a review on similar algorithms). The iterates of BCoFB are,\np = \u03c0\u03bb,\u00b5(z k), zk+1 = zk, zk+1g = pg \u2212 1\u03b1D T g (Dgp k g \u2212 xg),\n(8)\nwhere again here 1/\u03b1 is the Lipshitz constant of the fitting term and g is the index of the group in P to\nbe updated at the k-th iteration, according to some selection rule. Inspired by the coordinate descent algorithm (CoD) introduced for standard sparse coding in (Li & Osher, 2009), we propose an heuristic variant of BCoFB algorithm, that updates the group\ng = argmax j ||zk+1j \u2212 z k j ||22.\nIt can be shown that this quantity provides a lower bound in the decrease of the cost function for each possible group update. The procedure is summarized in Algorithm 2.\nIn the case of standard sparsity, Algorithm 2 with \u03b1 = 1 is identical to CoD (Li & Osher, 2009). This algorithm was used in (Gregor & LeCun, 2010) to build trainable sparse encoders."}, {"heading": "4. Fast Structured Sparse Encoders", "text": "In order to make sparse coding feasible in real time settings, it has been recently proposed to learn non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time (Jarrett et al., 2009; Kavukcuoglu et al., 2010). The main idea is to construct a parametric regressor h(x,\u0398), with some set of parameters, collectively denoted as \u0398, that minimizes the loss function\nL(\u0398) = 1 N \u2211 n L(\u0398,xn) (9)\non a training set {x1, . . . ,xN}. Here, L(\u0398,xn) = 1 2\u2016z \u2217 n\u2212zn\u201622, z\u2217n is the exact sparse code of xn obtained by solving the Lasso problem, and zn = h(xn,\u0398) is its approximation. While this setting is very generic, the application of off-the-shelf regressors has been later shown to produce relatively low-quality approximations (Gregor & LeCun, 2010).\n(Gregor & LeCun, 2010) proposed then two particular regressors implemented as a truncated form of ISTA and CoD algorithms. Essentially, these regressors are multi-layer artificial NN\u2019s where each layer implements a single iteration of ISTA or CoD. For example, in the CoD architecture, the learned parameters of the network are the matrices S and W, and the set of element-wise thresholds t.\nNaturally, as an alternative to learning, one could simply set the parameters S, W, and t as prescribed by the CoD algorithm (a particular case of Algorithm 2), terminating it after a small number of iterations. However, it is by no means guaranteed that such a truncated CoD algorithm will produce the best sparse code approximation with the same (small) number of layers; in practice, without the learning, such truncated\napproximations are typically useless. Still, even when learning the parameters, it is hopeless to expect the NN regressor to produce good sparse codes for any input data. Yet, (Gregor & LeCun, 2010) showed that the network does approximate well sparse codes for input vectors coming from the same distribution as the one used in training.\nAnother remarkable property of the ISTA and CoD sparse encoder architectures is that they are continuous and almost everywhere C1 with respect to the parameters and the inputs. Differentiability with respect to the parameters allows the use of (sub)gradient descent methods for training, while differentiability with respect to the inputs allows backpropagation of the gradients and the use of the sparse encoders as modules in bigger globally-trained systems.\nThe minimization of a loss function L(\u0398) with respect to \u0398 requires the computation of the (sub)gradients dL(\u0398,xn)/d\u0398, which is achieved by the backpropagation procedure. Backpropagation starts with differentiating L(\u0398,xn) with respect to the output of the last network layer, and propagating the (sub)gradients down to the input layer, multiplying them by the Jacobian matrices of the traversed layers."}, {"heading": "4.1. Hierarchical Sparse Encoders", "text": "We now extend Gregor&LeCun\u2019s idea to hierarchical (structured) sparse code regressors. We consider a feed-forward architecture based on the BCoFB, where each layer implements a single iteration of the BCoFB proximal method (Algorithm 2). The encoder architecture is depicted in Figure 1. Each layer essentially consists of the nonlinear proximal operator \u03c0s,t followed by a group selector and a linear operation Sg corresponding to that group. The network parameters are initialized as in Algorithm 2. In the particular case of \u03b1 = 1 and s = 0, the CoD architecture is obtained."}, {"heading": "4.2. Alternative Training Objective Functions", "text": "So far, we have followed Gregor&LeCun in considering NN encoders as regressors whose only role is to reproduce as faithfully as possible the ideal sparse codes z\u2217n produced by an iterative sparse coding algorithm (e.g., Lasso or HiLasso). This is achieved by training the networks to minimize the `2 discrepancy between the outputs of the network and the corresponding z\u2217n. We propose to consider the neural network sparse coders (both structured and unstructured) not as regressors approximating an iterative algorithm, but as full-featured sparse encoders (even modelers) in their own right. To achieve this paradigm shift, we abandon the ideal sparse codes and introduce alternative\ntraining objectives as detailed in the sequel.\nA general sparse coding problem can be viewed as a mapping between a data vector x and the corresponding sparse code z minimizing an aggregate of a fitting term and a (possibly, structured) regularizer, f(x, z) = 12 \u2016x\u2212Dz\u2016 2 2 + \u03c8(z). Since the latter objective is trusted as an indication of the code quality, we can train the network to minimize the ensemble average of f on a training set with z = arg min f(x, z) replaced by z = h(x,\u0398), obtaining the objective\nL(\u0398) = 1 N \u2211 n f(xn,h(xn,\u0398)). (10)\nGiven an application, one therefore has to select an objective with an appropriate regularizer \u03c8 corresponding to the problem structure, and a sparse encoder architecture consistent with that structure, and train the latter to minimize the objective on a representative set of data vectors. We found that selecting the sparse encoder with the structure consistent with the training objective and the inherent structure of the problem is crucial for the production of high-quality sparse codes.\nWhile sparse encoders based on NN\u2019s are trained by minimizing a non-convex function on a training set, and are therefore prone to local convergence and overfitting, we can argue that in most practical problems, the dictionary D is also found by solving a non-convex dictionary learning problem based on a representative data distribution. Consequently, unless the dictionary is constructed using some domain knowledge, the use of NN sparse encoders is not conceptually different from using iterative sparse modeling algorithms.\nFurthermore, one can consider the dictionary as another optimization variable in the training, and minimize L with respect to both D and the network parameters \u0398, alternating between network training and dictionary update iterations. This essentially extends the proposed efficient sparse coding framework into full-featured sparse modeling, as detailed next."}, {"heading": "4.3. Online Learning", "text": "Interpreting the NN\u2019s as standalone sparse encoders and removing the reference exact sparse codes makes the training problem completely unsupervised. Consequently, one may train the network (and possibly adapt the dictionary as well) on the very same data vectors fed to it for sparse coding. This allows using the proposed framework in online learning applications. A full online sparse modeling scenario consists of (a) initializing the dictionary (e.g., by a random sample of the initially observed training data vectors); (b) fixing the dictionary in the training objective and\nadapting the network parameters to the newly arriving data using an online learning algorithm (we use an online version of stochastic gradient in small batches as detailed in Section 5); and (c) fixing the sparse codes and adapting the dictionary using an online dictionary learning algorithm (e.g., (Mairal et al., 2009)). Note that all the above stages are completely free of iterative sparse coding, which translates into low latency computational complexity allowing real time applications."}, {"heading": "4.4. Supervised and Discriminative Learning", "text": "The proposed sparse modeling framework allows to naturally incorporate side information about training data vectors, making the learning supervised. Space limitations prevent us from elaborating on this setting; in what follows, we outline several examples leaving the details to the extended version of this paper.\nIn the group or hierarchical Lasso case, one may know for each data vector the desired active groups. Incorporating this information into the training objective is possible by using \u03c8 as in (5) with \u00b5r set separately for each training vector xn to low values to promote the activation of a knowingly active group r, or to high values to discourage the activation of a knowingly inactive group.\nIn other applications, data vectors can come in pairs of knowingly similar or dissimilar vectors, and one may want to minimize some natural distance between sparse codes of the similar vectors, while maximizing the distance on the dissimilar ones. This scenario is of particular interest in retrieval applications, where sparse data representations are desirable due to their amenability to efficient indexing. Incorporating such a similarity preservation term into the training objective is common practice in metric learning (see, e.g., (Weinberger & Saul, 2009)), but is challenging in sparse coding due to the fact that when the sparse codes are produced by an iterative algorithm, one faces the problem of minimizing a training objective L depending on the minimizers of another objective f . When using the NN sparse modelers instead, the training is handled using standard methods.\nFinally, in many applications the data do not have Euclidean structure and supervised learning can be used to construct an optimal discriminative metric. This can be achieved, for example, by replacing the Euclidean fitting term with the Mahalanobis counterpart, \u2016x \u2212 Dx\u20162\nQTQ = \u2016Q(x \u2212 Dx)\u201622, where Q is a\ndiscriminative projection matrix. In such scenarios, it is desirable to combine sparse modeling with metric learning. This problem has not been considered before\nas it is impractical when the sparse codes are obtained by minimization of f . It does become practical, however, when NN encoders are used instead."}, {"heading": "5. Experimental Results", "text": "All NN\u2019s were implemented in Matlab with built-in GPU acceleration and executed on state-of-the-art Intel Xeon E5620 CPU and NVIDIA Tesla C2070 GPU. Even with this by no means optimized code, the propagation of 105 100-dimensional vector through a 10- layer structured network with the proposed BCoFB architecture takes only 3.6 seconds, which is equivalent to 3.6\u00b5sec spent per vector per layer. This is several orders of magnitude faster than the exceptionally optimized multithreaded SPAMS HiLasso code (Jenatton et al., 2011) executed on the CPU. Such benefits of parallelization are possible due to the fixed datapath and complexity of the NN encoder compared to the iterative solver.\nIn all experiments, training was performed using gradient descent safeguarded by Armijo rule. We refer as NN G-L to the NN sparse encoders obtained by minimizing Gregor&LeCun\u2019s objective function, this is, the `2 error with the output of the exact encoder. It will be explicitly stated when NN sparse encoders are trained using a specific objective function (e.g., NN Lasso)."}, {"heading": "5.1. Classification", "text": "In this experiment, we evaluate the performance of unstructured NN sparse encoders in the MNIST digit classification task. The MNIST images were resampled to 17 \u00d7 17 (289-dimensional) patches. A set of ten dictionaries was trained for each class. Classification was performed by encoding a test vector in each of the\ndictionaries and assigning the label corresponding to the smallest value of the full Lasso objective.\nThe following sparse coders were compared: exact sparse codes (Exact Lasso), unstructured NN G-L, and unstructured NN Lasso (a CoD network trained using the Lasso objective). Ten networks were trained, one per each class; all contained T = 5 CoD layers. \u03bb = 0.1 was used in the Lasso objective. Dictionaries with 100 (under-complete) and 289 (complete) atoms were used. Further increase in the dictionary size did not exhibit significant performance improvement.\nTable 1 summarizes the misclassification rates of each of the sparse encoders. Performance of the NN GL sparse encoder decreases with the increase of the dictionary size, while the discrepancy with the exact codes drops. On the other hand, better performance in terms of the Lasso objective consistently correlates with better classification rates, which makes NN Lasso a more favorable choice. Dictionary adaptation in the training of the NN Lasso encoder brings only a small improvement in performance, diminishing with the dictionary size. We attribute this to the relative low complexity of the data."}, {"heading": "5.2. Online Learning", "text": "In this experiment, we evaluate the online learning capabilities of unstructured NN sparse encoders. As the input data we used 30 \u00d7 104 randomly located 8 \u00d7 8 patches from three images from the Brodatz texture dataset (Randen & Husoy, 1999). The patches were ordered in three consecutive blocks of 104 patches from each image. Dictionary size was fixed to 64 atoms. \u03bb = 1 was used in the Lasso objective.\nOnline learning was performed in overlapping windows of 1, 000 vectors with a step of 100 vectors. We com-\npared standard online dictionary learning (Exact Lasso online) with unstructured NN Lasso with dictionary adaptation in a given window (NN Lasso online), initialized by the network parameters from the previous windows. In the latter case, the dictionary was initialized by a random subset of 64 out of the first 1, 000 data vectors (therefore, no iterative sparse coding). As the reference, we also compared the following three offline algorithms trained on a distinct set of 6, 000 patches extracted from the same images: standard dictionary learning (Exact Lasso offline); unstructured NN G-L (NN G-L offline), and unstructured NN Lasso (NN Lasso offline). All NN\u2019s used T = 4 CoD layers.\nPerformance measured in terms of the Lasso objective is reported in Figure 2. Exact offline sparse encoder achieved the best results among all offline encoders. It is, however, outperformed by the exact online encoder due to its ability to adapt the dictionary to a specific class of data. The performance of the NN Lasso online encoder is slightly inferior to the Exact Lasso offline; the online version performs better after the network parameters and the dictionary adapt to the current class of data. Finally, the NN G-L offline encoder has the lowest, significantly inferior performance.\nThis experiment shows that, while the drop in performance compared to the exact encoder is relatively low, the computational complexity of the NN Lasso online encoder is tremendously lower and fixed."}, {"heading": "5.3. Structured Coding", "text": "We first evaluate the performance of the structured sparse encoders in a speaker identification task reproduced from (Sprechmann et al., 2011). In this application the authors use HiLasso to automatically detect the present speakers in a given mixed signal. We repeat this experiments using the proposed efficient structured sparse encoders instead.\nThe dataset consists of recordings of five different radio speakers, two females and three males. 25% of the samples was used for training, and the rest for testing. Within the testing data, two sets of waveforms were created: one containing isolated speakers, and another containing all possible combinations of mixtures of two\nspeakers. Signals are decomposed into a set of overlapping local time frames of 512 samples with 75% overlap, such that the properties of the signal remain stable within each frame. An 80-dimensional feature vector is obtained for each audio frame as its short-time power spectrum envelope (refer to (Sprechmann et al., 2011) for details). Five undercomplete dictionaries with 50 atoms were trained on the single speaker set minimizing the Lasso objective with \u03bb = 0.2 (one dictionary per speaker), and then combined into a single structured dictionary containing 250 atoms. Increasing the dictionary size exhibited negligible performance benefits. Speaker identification was performed by first encoding a test vector in the structured dictionary and measuring the `2 energy of each of the five groups. Energies were sum-pooled over 500 time samples selecting the labels of the highest two.\nThe following structured sparse encoders were compared: exact HiLasso codes with \u00b5 = 0.05 (Exact), unstructured NN G-L trained on the exact HiLasso codes (NN G-L unstructured), structured NN G-L trained on the same codes (NN G-L structured), and a structured network with a discriminative cost function with regularization term in which the weights \u00b5r were set independently for each data vector to \u22121 or 1 to promote or discourage the activation of groups corresponding to knowingly active or silent speakers respectively, (NN discriminative structured). All NN\u2019s used the same single structured dictionary and contained T = 2 layers with the BCoFB architecture.\nTable 2 summarizes the obtained misclassification rates. It is remarkable that using a structured architecture instead of its unstructured counterpart with the same number of layers and the same dictionary increases performance by nearly a factor of two. The use of the discriminative objective further improves performance. Surprisingly, using NN\u2019s with only two layers cedes just about 1% of correct classification rate.\nThe structured architecture showed a crucial roll in producing accurate structured sparse codes. We now show that this observation is also valid in a more general setting. We repeated the same experiment as before but with randomly generated synthetic data that truly has a structure sparse representation under a given dictionary (unknown for the NN\u2019s). Results are summarized in Figure 3."}, {"heading": "6. Conclusion", "text": "Marrying ideas from convex optimization with multilayer neural networks, we have developed in this work a comprehensive framework for modern sparse mod-\neling for real time and large scale applications. The framework includes different objective functions, from reconstruction to classification, allows different sparse coding structures from hierarchical to group similarity, and addresses online learning scenarios. A simple implementation already achieves several order of magnitude speedups when compared to the state-of-the-art, at minimal cost in performance, opening the door for practical algorithms following the demonstrated success of sparse modeling in various applications.\nAn extension of the proposed approach to other structured sparse modeling problems such as robust PCA and non-negative matrix factorization is available at http://www.eng.tau.ac.il/~bron/ publications_conference.html and will be published elsewhere due to lack of space."}, {"heading": "Acknowledgement", "text": "This research was supported in part by ONR, NGA, ARO, NSF, NSSEFF, and BSF."}], "references": [{"title": "Convex optimization with sparsity-inducing norms. In Optimization for Machine Learning", "author": ["F. Bach", "R. Jenatton", "J. Mairal", "G. Obozinski"], "venue": null, "citeRegEx": "Bach et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bach et al\\.", "year": 2011}, {"title": "A fast iterative shrinkagethresholding algorithm for linear inverse problems", "author": ["A. Beck", "M. Teboulle"], "venue": "SIAM J. Img. Sci.,", "citeRegEx": "Beck and Teboulle,? \\Q2009\\E", "shortCiteRegEx": "Beck and Teboulle", "year": 2009}, {"title": "Atomic decomposition by basis pursuit", "author": ["S. Chen", "D. Donoho", "M. Saunders"], "venue": "SIAM J. Scientific Computing,", "citeRegEx": "Chen et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Chen et al\\.", "year": 1999}, {"title": "Compressed sensing", "author": ["D. Donoho"], "venue": "IEEE Trans. on Inf. Theory,", "citeRegEx": "Donoho,? \\Q2006\\E", "shortCiteRegEx": "Donoho", "year": 2006}, {"title": "Average case analysis of multichannel sparse recovery using convex relaxation", "author": ["Y.C. Eldar", "H. Rauhut"], "venue": "IEEE Trans. on Inf. Theory,", "citeRegEx": "Eldar and Rauhut,? \\Q2010\\E", "shortCiteRegEx": "Eldar and Rauhut", "year": 2010}, {"title": "A note on the group lasso and a sparse group", "author": ["J. Friedman", "T. Hastie", "R. Tibshirani"], "venue": "lasso. Preprint,", "citeRegEx": "Friedman et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Friedman et al\\.", "year": 2010}, {"title": "Measuring invariances in deep networks", "author": ["I. Goodfellow", "Q. Le", "A. Saxe", "H. Lee", "A.Y. Ng"], "venue": "In In NIPS,", "citeRegEx": "Goodfellow et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2009}, {"title": "Learning fast approximations of sparse coding", "author": ["K. Gregor", "Y. LeCun"], "venue": "In ICML, pp", "citeRegEx": "Gregor and LeCun,? \\Q2010\\E", "shortCiteRegEx": "Gregor and LeCun", "year": 2010}, {"title": "What is the best multi-stage architecture for object recognition", "author": ["K. Jarrett", "K. Kavukcuoglu", "M.A. Ranzato", "Y. LeCun"], "venue": "In CVPR,", "citeRegEx": "Jarrett et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Jarrett et al\\.", "year": 2009}, {"title": "Proximal methods for hierarchical sparse coding", "author": ["R. Jenatton", "J. Mairal", "G. Obozinski", "F. Bach"], "venue": null, "citeRegEx": "Jenatton et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Jenatton et al\\.", "year": 2011}, {"title": "Fast inference in sparse coding algorithms with applications to object recognition", "author": ["K. Kavukcuoglu", "M.A. Ranzato", "Y. LeCun"], "venue": null, "citeRegEx": "Kavukcuoglu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Kavukcuoglu et al\\.", "year": 2010}, {"title": "Coordinate descent optimization for `1 minimization with application to compressed sensing; a greedy algorithm", "author": ["Y. Li", "S. Osher"], "venue": "Inverse Problems and Imaging,", "citeRegEx": "Li and Osher,? \\Q2009\\E", "shortCiteRegEx": "Li and Osher", "year": 2009}, {"title": "Online dictionary learning for sparse coding", "author": ["J. Mairal", "F. Bach", "J. Ponce", "G. Sapiro"], "venue": "In ICML,", "citeRegEx": "Mairal et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Mairal et al\\.", "year": 2009}, {"title": "Gradient methods for minimizing composite objective function", "author": ["Y. Nesterov"], "venue": "In CORE. Catholic University of Louvain, Louvain-la-Neuve,", "citeRegEx": "Nesterov,? \\Q2007\\E", "shortCiteRegEx": "Nesterov", "year": 2007}, {"title": "Filtering for texture classification: a comparative study", "author": ["T. Randen", "J.H. Husoy"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell.,", "citeRegEx": "Randen and Husoy,? \\Q1999\\E", "shortCiteRegEx": "Randen and Husoy", "year": 1999}, {"title": "Unsupervised learning of invariant feature hierarchies with applications to object recognition", "author": ["M. Ranzato", "F.J. Huang", "Boureau", "Y-L", "Y. LeCun"], "venue": "In CVPR,", "citeRegEx": "Ranzato et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ranzato et al\\.", "year": 2007}, {"title": "C-hilasso: A collaborative hierarchical sparse modeling framework", "author": ["P. Sprechmann", "I. Ram\u0131\u0301rez", "G. Sapiro", "Y.C. Eldar"], "venue": "IEEE Trans. Signal Process.,", "citeRegEx": "Sprechmann et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Sprechmann et al\\.", "year": 2011}, {"title": "Regression shrinkage and selection via the LASSO", "author": ["R. Tibshirani"], "venue": "J. Royal Stat. Society: Series B,", "citeRegEx": "Tibshirani,? \\Q1996\\E", "shortCiteRegEx": "Tibshirani", "year": 1996}, {"title": "Convergence of a block coordinate descent method for nondifferentiable minimization", "author": ["P. Tseng"], "venue": "J. Optim. Theory Appl.,", "citeRegEx": "Tseng,? \\Q2001\\E", "shortCiteRegEx": "Tseng", "year": 2001}, {"title": "Distance metric learning for large margin nearest neighbor classification", "author": ["K.Q. Weinberger", "L.K. Saul"], "venue": "JMLR, 10:207\u2013244,", "citeRegEx": "Weinberger and Saul,? \\Q2009\\E", "shortCiteRegEx": "Weinberger and Saul", "year": 2009}, {"title": "Learning sparse representations of high dimensional data on large scale dictionaries", "author": ["Z.J. Xiang", "H. Xu", "P.J. Ramadge"], "venue": "In NIPS,", "citeRegEx": "Xiang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Xiang et al\\.", "year": 2011}, {"title": "Model selection and estimation in regression with grouped variables", "author": ["M. Yuan", "Y. Lin"], "venue": "J. Royal Stat. Society, Series B,", "citeRegEx": "Yuan and Lin,? \\Q2006\\E", "shortCiteRegEx": "Yuan and Lin", "year": 2006}, {"title": "The composite absolute penalties family for grouped and hierarchical variable selection", "author": ["P. Zhao", "G. Rocha", "B. Yu"], "venue": "Annals of Statistics,", "citeRegEx": "Zhao et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Zhao et al\\.", "year": 2009}], "referenceMentions": [{"referenceID": 13, "context": "Consequently, a significant amount of effort has been devoted to developing efficient optimization schemes (Beck & Teboulle, 2009; Li & Osher, 2009; Nesterov, 2007; Xiang et al., 2011).", "startOffset": 107, "endOffset": 184}, {"referenceID": 20, "context": "Consequently, a significant amount of effort has been devoted to developing efficient optimization schemes (Beck & Teboulle, 2009; Li & Osher, 2009; Nesterov, 2007; Xiang et al., 2011).", "startOffset": 107, "endOffset": 184}, {"referenceID": 8, "context": "Recent works have proposed to trade off precision in the sparse representation for computational speedup (Jarrett et al., 2009; Kavukcuoglu et al., 2010), by learning non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time.", "startOffset": 105, "endOffset": 153}, {"referenceID": 10, "context": "Recent works have proposed to trade off precision in the sparse representation for computational speedup (Jarrett et al., 2009; Kavukcuoglu et al., 2010), by learning non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time.", "startOffset": 105, "endOffset": 153}, {"referenceID": 6, "context": "dictionary is learned, the framework is related to recent efforts in producing NN based sparse representations, see (Goodfellow et al., 2009; Ranzato et al., 2007) and references therein.", "startOffset": 116, "endOffset": 163}, {"referenceID": 15, "context": "dictionary is learned, the framework is related to recent efforts in producing NN based sparse representations, see (Goodfellow et al., 2009; Ranzato et al., 2007) and references therein.", "startOffset": 116, "endOffset": 163}, {"referenceID": 6, "context": "It can be interpreted as an online trainable sparse auto-encoder (Goodfellow et al., 2009) with a sophisticated encoder and simple linear decoder.", "startOffset": 65, "endOffset": 90}, {"referenceID": 17, "context": "Several important structured sparsity settings can be cast as particular cases of (1): sparse coding, as mentioned above, which is often referred to as Lasso (Tibshirani, 1996) or basis pursuit (Chen et al.", "startOffset": 158, "endOffset": 176}, {"referenceID": 2, "context": "Several important structured sparsity settings can be cast as particular cases of (1): sparse coding, as mentioned above, which is often referred to as Lasso (Tibshirani, 1996) or basis pursuit (Chen et al., 1999; Donoho, 2006); group sparse coding, a generalization of the standard sparse coding to the cases in which the dictionary is sub-divided into groups that are known to be active or inactive simultaneously (Yuan & Lin, 2006), in this case G is a partition of {1, .", "startOffset": 194, "endOffset": 227}, {"referenceID": 3, "context": "Several important structured sparsity settings can be cast as particular cases of (1): sparse coding, as mentioned above, which is often referred to as Lasso (Tibshirani, 1996) or basis pursuit (Chen et al., 1999; Donoho, 2006); group sparse coding, a generalization of the standard sparse coding to the cases in which the dictionary is sub-divided into groups that are known to be active or inactive simultaneously (Yuan & Lin, 2006), in this case G is a partition of {1, .", "startOffset": 194, "endOffset": 227}, {"referenceID": 22, "context": ", p}; hierarchical sparse coding, assuming a hierarchical structure of the non-zero coefficients (Zhao et al., 2009; Jenatton et al., 2011; Sprechmann et al., 2011).", "startOffset": 97, "endOffset": 164}, {"referenceID": 9, "context": ", p}; hierarchical sparse coding, assuming a hierarchical structure of the non-zero coefficients (Zhao et al., 2009; Jenatton et al., 2011; Sprechmann et al., 2011).", "startOffset": 97, "endOffset": 164}, {"referenceID": 16, "context": ", p}; hierarchical sparse coding, assuming a hierarchical structure of the non-zero coefficients (Zhao et al., 2009; Jenatton et al., 2011; Sprechmann et al., 2011).", "startOffset": 97, "endOffset": 164}, {"referenceID": 16, "context": "The groups in G form a hierarchy with respect to the inclusion relation (a tree structure), that is, if two groups overlap, then one is completely included in the other one; and collaborative sparse coding generalizing the concept of structured sparse coding to collections of input vectors by promoting given patterns of non-zero elements in the coefficient matrix (Eldar & Rauhut, 2010; Sprechmann et al., 2011).", "startOffset": 366, "endOffset": 413}, {"referenceID": 0, "context": "State-of-the-art approaches for solving (1) rely on the family of proximal splitting methods (see (Bach et al., 2011) and references therein).", "startOffset": 98, "endOffset": 117}, {"referenceID": 18, "context": "Next, we briefly introduce proximal methods and an algorithm for solving hierarchical sparse coding problems (Tseng, 2001) that will be used to construct trainable sparse encoders.", "startOffset": 109, "endOffset": 122}, {"referenceID": 13, "context": "Accelerated versions of proximal methods have been largely studied in the literature to improve their convergence rate (Beck & Teboulle, 2009; Nesterov, 2007).", "startOffset": 119, "endOffset": 158}, {"referenceID": 5, "context": "To simplify the notation, we will henceforth formulate all the derivations for the case of two-level hierarchical sparse coding, referred as HiLasso (Friedman et al., 2010; Sprechmann et al., 2011).", "startOffset": 149, "endOffset": 197}, {"referenceID": 16, "context": "To simplify the notation, we will henceforth formulate all the derivations for the case of two-level hierarchical sparse coding, referred as HiLasso (Friedman et al., 2010; Sprechmann et al., 2011).", "startOffset": 149, "endOffset": 197}, {"referenceID": 9, "context": "This captures the essence of hierarchical sparse models and the generalization to more layers (Jenatton et al., 2011) or to a collaborative scheme (Sprechmann et al.", "startOffset": 94, "endOffset": 117}, {"referenceID": 16, "context": ", 2011) or to a collaborative scheme (Sprechmann et al., 2011) is straightforward.", "startOffset": 37, "endOffset": 62}, {"referenceID": 9, "context": "The proximal operator of (5) can be expressed as (Jenatton et al., 2011; Sprechmann et al., 2011),", "startOffset": 49, "endOffset": 97}, {"referenceID": 16, "context": "The proximal operator of (5) can be expressed as (Jenatton et al., 2011; Sprechmann et al., 2011),", "startOffset": 49, "endOffset": 97}, {"referenceID": 18, "context": "One can choose a block coordinate strategy where only one block is updated at a time (Tseng, 2001).", "startOffset": 85, "endOffset": 98}, {"referenceID": 0, "context": "In this paper we will refer to this algorithm as Block-Coordinate Forward-Backward algorithm (BCoFB) (see (Bach et al., 2011) for a review on similar algorithms).", "startOffset": 106, "endOffset": 125}, {"referenceID": 8, "context": "In order to make sparse coding feasible in real time settings, it has been recently proposed to learn non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time (Jarrett et al., 2009; Kavukcuoglu et al., 2010).", "startOffset": 207, "endOffset": 255}, {"referenceID": 10, "context": "In order to make sparse coding feasible in real time settings, it has been recently proposed to learn non-linear regressors capable of producing good approximations of sparse codes in a fixed amount of time (Jarrett et al., 2009; Kavukcuoglu et al., 2010).", "startOffset": 207, "endOffset": 255}, {"referenceID": 12, "context": ", (Mairal et al., 2009)).", "startOffset": 2, "endOffset": 23}, {"referenceID": 9, "context": "This is several orders of magnitude faster than the exceptionally optimized multithreaded SPAMS HiLasso code (Jenatton et al., 2011) executed on the CPU.", "startOffset": 109, "endOffset": 132}, {"referenceID": 16, "context": "We first evaluate the performance of the structured sparse encoders in a speaker identification task reproduced from (Sprechmann et al., 2011).", "startOffset": 117, "endOffset": 142}, {"referenceID": 16, "context": "An 80-dimensional feature vector is obtained for each audio frame as its short-time power spectrum envelope (refer to (Sprechmann et al., 2011) for details).", "startOffset": 118, "endOffset": 143}], "year": 2012, "abstractText": "We present a comprehensive framework for structured sparse coding and modeling extending the recent ideas of using learnable fast regressors to approximate exact sparse codes. For this purpose, we propose an efficient feed forward architecture derived from the iteration of the block-coordinate algorithm. This architecture approximates the exact structured sparse codes with a fraction of the complexity of the standard optimization methods. We also show that by using different training objective functions, the proposed learnable sparse encoders are not only restricted to be approximants of the exact sparse code for a pre-given dictionary, but can be rather used as full-featured sparse encoders or even modelers. A simple implementation shows several orders of magnitude speedup compared to the state-of-the-art exact optimization algorithms at minimal performance degradation, making the proposed framework suitable for real time and largescale applications.", "creator": "LaTeX with hyperref package"}}}