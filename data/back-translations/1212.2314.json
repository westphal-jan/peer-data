{"id": "1212.2314", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Dec-2012", "title": "Tree Projections and Structural Decomposition Methods: Minimality and Game-Theoretic Characterization", "abstract": "Tree projections provide a mathematical framework that encompasses all the various (purely) structural decomposition methods proposed in the literature to single out classes of near-acyclic (hyper) graphs, such as the tree decomposition method, which is the most powerful decomposition method on graphs, and the (generalized) hypertree decomposition method, which is its natural counterpart on arbitrary hypergraphs. The paper analyzes this framework by focusing in particular on \"minimal\" tree projections, i.e., tree projections without useless redundancies. First, it is shown that minimal tree projections have a number of properties that are normally required for normal mold decompositions in various structural decomposition methods. In particular, they enjoy the same type of connection properties as (minimal) tree decompositions of graphs, with the result being defined in the light of the negative response given to the open question of whether they have a slightly stronger idea of decomposition of the connector, the play composition, and the natural composition of the game.", "histories": [["v1", "Tue, 11 Dec 2012 07:02:31 GMT  (540kb)", "http://arxiv.org/abs/1212.2314v1", null]], "reviews": [], "SUBJECTS": "cs.DM cs.AI", "authors": ["gianluigi greco", "francesco scarcello"], "accepted": false, "id": "1212.2314"}, "pdf": {"name": "1212.2314.pdf", "metadata": {"source": "CRF", "title": "Tree Projections and Structural Decomposition Methods: Minimality and Game-Theoretic Characterization", "authors": ["Gianluigi Greco", "Francesco Scarcello"], "emails": ["ggreco@mat.unical.it,", "scarcello@deis.unical.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n21 2.\n23 14\nv1 [\ncs .D\nM ]\nThe paper analyzes this framework, by focusing in particular on \u201cminimal\u201d tree projections, that is, on tree projections without useless redundancies. First, it is shown that minimal tree projections enjoy a number of properties that are usually required for normal form decompositions in various structural decomposition methods. In particular, they enjoy the same kind of connection properties as (minimal) tree decompositions of graphs, with the result being tight in the light of the negative answer that is provided to the open question about whether they enjoy a slightly stronger notion of connection property, defined to speed-up the computation of hypertree decompositions. Second, it is shown that tree projections admit a natural game-theoretic characterization in terms of the Captain and Robber game. In this game, as for the Robber and Cops game characterizing tree decompositions, the existence of winning strategies implies the existence of monotone ones. As a special case, the Captain and Robber game can be used to characterize the generalized hypertree decomposition method, where such a game-theoretic characterization was missing and asked for. Besides their theoretical interest, these results have immediate algorithmic applications both for the general setting and for structural decomposition methods that can be recast in terms of tree projections."}, {"heading": "1 Introduction", "text": ""}, {"heading": "1.1 Structural Decomposition Methods and Open Questions", "text": "Many NP-hard problems in different application areas, ranging, e.g., from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs. Indeed, on these kinds of instances, solutions can usually be computed via dynamic programming, by incrementally processing the acyclic (hyper)graph, according to some of its topological orderings. However, structures arising from real applications are hardly precisely acyclic. Yet, they are often not very intricate and, in fact, tend to exhibit some limited degree of cyclicity, which suffices to retain most of the nice properties of acyclic ones. Therefore,\nseveral efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions. These methods aim at transforming a given cyclic hypergraph into an acyclic one, by organizing its edges (or its nodes) into a polynomial number of clusters, and by suitably arranging these clusters as a tree, called decomposition tree. The original problem instance can then be evaluated over such a tree of subproblems, with a cost that is exponential in the cardinality of the largest cluster, also called width of the decomposition, and polynomial if this width is bounded by some constant.\nDespite their different technical definitions, there is a simple mathematical framework that encompasses all purely structural decomposition methods, which is the framework of the tree projections [18]. Roughly, given a pair of hypergraphs (H1,H2), a tree projection of H1 w.r.t. H2 is an acyclic hypergraph Ha such that each hyperedge of H1 is contained in some hyperedge of Ha, that is in its turn contained in a hyperedge of H2, which is called the resource hypergraph\u2014see Figure 1 for an illustration.\nTherefore, in the tree projection framework, the resource hypergraph H2 is arbitrary. Whenever it is instead computed with some specific technique from the hypergraph H1, we obtain as special cases the so-called purely structural decomposition methods. Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.g, [13, 22]). Let k be a fixed natural number, and consider any (hyper)graph H1 over a set V of nodes. Let Htk1 be the hypergraph associated whose hyperedges are all possible sets of at most k + 1 variables. Then, a hypergrah H1 has treewidth bounded by k if, and only if, there is a tree projection of H1 w.r.t. Htk1 (see, e.g., [19, 20]). 1\nIn fact, our current understating of structural decompositions for binary (graph) instances is fairly complete. The situation pertaining decompositions methods for arbitrary (hypergraphs) instances is much more muddled instead. In particular, the following two questions have been posed in the literature for the general tree projection framework as well as for structural decomposition methods specifically\n1For the sake of completeness, observe that the only known structural technique that does not fit the general framework of tree projections is the one based on the submodular width [25], which is not purely structural. Indeed, this method, which is specifically tailored to solve constraint satisfaction problem (or conjunctive query) instances, identify a number of decompositions on the basis of both the given constraint hypergraph and the associated constraint relations.\ntailored to deal with classes of queries without a fixed arity bound. Such questions were in particular open for the generalized hypertree decomposition method, which on classes of unbounded-arity queries is a natural counterpart of the tree decomposition method.\n(Q2) Is there a natural notion of normal-form for tree projections? Whenever some tree projection of a pair (H1,H2) exists, in general there are also many tree projections with useless redundancies. Having a suitable notion of minimality may allow us to identify the most desirable tree projections. In fact, for several structural decomposition methods, normal forms have been defined to restrict the search space of decomposition trees, without loosing any useful decomposition.\nSuch a nice feature is however missing for the general case of tree projections. As a consequence, consider for instance the basic problem of deciding whether a tree projection of a hypergraph H1 with respect to a hypergraph H2 exists or not. Because every subset of any hyperedge of H2 may belong to the tree projection Ha we are looking for, this latter hypergraph might in principle consists of an exponential number of hyperedges (w.r.t. to the size of H1 and H2). Therefore, even proving that the existence problem is feasible in NP is not easy, without a notion of minimality that allows us to get rid of redundant hyperedges.\nFurthermore, in the case of tree decompositions, it is known that we can focus, w.l.o.g., on connected ones [11], that is, basically, on tree decompositions such that, for each set of connected vertices, the sub-hypergraph induced by the nodes covered in such vertices is connected in its turn. Again, connected decompositions provide us with a \u201cnormal form\u201d for decomposition trees, which can be exploited to restrict the search space of the possible decompositions and, thus, to speed-up their computation [11]. However, no systematic study about connection properties of tree projections (and of decomposition methods other than tree decomposition) appeared in the literature. Algorithms have been implemented limiting the search space to a kind of connected (generalized) hypertree decompositions [29], but it was left open whether the resulting method is a heuristic one or it does give an exact solution.\n(Q2) Is there a natural game-theoretic characterization for tree projections? Tree decompositions have a nice game-theoretic characterization in terms of the Robber and Cops game [28]: A hypergraph H has treewidth bounded by k if, and only, if k + 1 Cops can capture a Robber that can run at great speed along the hyperedges of H, while being not permitted to run trough a node that is controlled by a Cop. In particular, the Cops can move over the nodes, and while they move, the Robber is fast and can run trough those nodes that are left or not yet occupied before the move is completed. An important property of this game is that there is no restriction on the strategy used by the Cops to capture the Robber. In particular, the Cops are not constrained to play monotone strategies, that is, to shrink the Robber\u2019s escape space in a monotonically decreasing way. More precisely, playing non-monotone strategies gives no more power to the Cops [28]. In many results about treewidth (e.g., [5]), this property turns out to be very useful, because good strategies for the Robber may be easily characterized as those strategies that allow the Robber to run forever.\nHypertree decomposition is an efficiently recognizable structural method [15], which provides a 3- approximation for generalized hypertree decompositions [4]. This method is also known to have a nice game-theoretic characterization, in terms of the (monotone) Robber and Marshals game [15], which can be viewed as a natural generalization of the Robber and Cops games. The game is the same as the one characterizing acyclicity, but with k Marshals acting simultaneously to capture the Robber: A hypergraph H has hypertree width bounded by k if, and only if, k Marshals, each one with the ability of controlling a hyperedge of H, can capture a Robber that can run at great speed along the hyperedges, while being not permitted to run trough a node that belongs to a hyperedge controlled by a Marshal. Note that Marshals are more powerful than the Cops of the Robber and Cops game characterizing\ntreewidth, in that they can move over whole hyperedges. However, Marshals are now required to play monotonically, because non-monotone strategies give some extra-power that does not correspond to valid decompositions [1].\nDespite the similarities between hypertree and generalized hypertree decompositions as they are apparent from the original definitions by Gottlob et al. [15], game theoretic characterizations for generalized hypertree width were still missing. In [1], it is raised the question about whether there is a (natural) game theoretic characterization for generalized hypertree width, where non-monotonicity does not represent a source of additional power. Such a characterization is missing for the tree projection setting, too."}, {"heading": "1.2 Contributions", "text": "In this paper, we provide useful properties and characterizations of tree projections (and structural decomposition methods), by answering the two questions illustrated above. In particular,\n\u25ee We define and investigate minimal tree projections, where the minimal possible subsets of any view are employed. Intuitively, such tree projections typically correspond to more efficient decompositions. We show that some properties required for \u201cnormal form\u201d decompositions in various notions of structural decomposition methods (see, e.g., [14]) are a consequence of minimality. In particular, minimal tree projections enjoy the same kind of connection property as tree decompositions.\n\u25ee We define a normal form for (minimal) tree projections. In particular, it turns out that, given any pair of hypergraphs (H1,H2), there always exists a tree projection of H1 w.r.t. H2 in normal form having polynomial size with respect to the size of the given hypergraphs. An immediate consequence of this result is that checking whether a tree projection exists or not is feasible in NP. In fact, this property has already been exploited in the NP-completeness proof of tree projections [16].\n\u25ee We give a negative answer to the question raised in [29] for (generalized) hypertree decomposition. We observe that the notion of connected decomposition proposed there differs from the one defined for tree decompositions and mentioned above. In particular, we show a hypergraph where this restriction leads to worse tree projections, more precisely, where all such connected (generalized) hypertree decompositions have width higher than the hypertree width of the considered hypergraph. Hence, the algorithm proposed in [29] for connected hypertree decompositions is not complete, as far as the computation of unrestricted decompositions is considered.\n\u25ee We define the Captain and Robber game to be played on pairs of hypergraphs, and we show that in this game the Captain has a winning strategy if, and only if, she has a monotone winning one. Then, we show that tree projections and thus, e.g., generalized hypertree decompositions, may be characterized in terms of the Captain and Robber game. Hence, these notions have now a natural game characterization where monotone and non-monotone strategies have the same power.\nOrganization. The rest of the paper is organized as follows. Section 2 illustrates some basic notions and concepts. The setting of minimal tree projections is discussed in Section 3. The game-theoretic characterization is illustrated in Section 4. A few final remarks and some further results are discussed in Section 5, by exploiting the properties of minimal tree projections and the game-theoretic characterization."}, {"heading": "2 Preliminaries", "text": "Hypergraphs and Acyclicity. A hypergraph H is a pair (V,H), where V is a finite set of nodes and H is a set of hyperedges such that, for each h \u2208 H , h \u2286 V . If |h| = 2 for each (hyper)edge h \u2208 H , then H is a graph. For the sake of simplicity, we always denote V and H by nodes(H) and edges(H), respectively.\nA hypergraph H is acyclic (more precisely, \u03b1-acyclic [10]) if, and only if, it has a join tree [6]. A join tree JT for a hypergraph H is a tree whose vertices are the hyperedges of H such that, whenever a node X \u2208 V occurs in two hyperedges h1 and h2 of H, then h1 and h2 are connected in JT , and X occurs in each vertex on the unique path linking h1 and h2 (see Figure 1 for an illustration). In words, the set of vertices in which X occurs induces a (connected) subtree of JT . We will refer to this condition as the connectedness condition of join trees.\nTree Decompositions. A tree decomposition [26] of a graph G is a pair \u3008T, \u03c7\u3009, where T = (N,E) is a tree, and \u03c7 is a labeling function assigning to each vertex v \u2208 N a set of vertices\u03c7(v) \u2286 nodes(G), such that the following conditions are satisfied: (1) for each node Y \u2208 nodes(G), there exists p \u2208 N such that Y \u2208 \u03c7(p); (2) for each edge {X,Y } \u2208 edges(G), there exists p \u2208 N such that {X,Y } \u2286 \u03c7(p); and (3) for each node Y \u2208 nodes(G), the set {p \u2208 N | Y \u2208 \u03c7(p)} induces a (connected) subtree of T . The width of \u3008T, \u03c7\u3009 is the number maxp\u2208N (|\u03c7(p)| \u2212 1).\nThe Gaifman graph of a hypergraph H is defined over the set nodes(H) of the nodes of H, and contains an edge {X,Y } if, and only if, {X,Y } \u2286 h holds, for some hyperedge h \u2208 edges(H). The treewidth of H is the minimum width over all the tree decompositions of its Gaifman graph. Deciding whether a given hypergraph has treewidth bounded by a fixed natural number k is known to be feasible in linear time [7].\n(Generalized) Hypertree Decompositions. A hypertree for a hypergraphH is a triple \u3008T, \u03c7, \u03bb\u3009, where T = (N,E) is a rooted tree, and \u03c7 and \u03bb are labeling functions which associate each vertex p \u2208 N with two sets \u03c7(p) \u2286 nodes(H) and \u03bb(p) \u2286 edges(H). If T \u2032 = (N \u2032, E\u2032) is a subtree of T , we define \u03c7(T \u2032) = \u22c3\nv\u2208N \u2032 \u03c7(v). In the following, for any rooted tree T , we denote the set of vertices N of T by vertices(T ), and the root of T by root(T ). Moreover, for any p \u2208 N , Tp denotes the subtree of T rooted at p.\nA generalized hypertree decomposition [15] of a hypergraph H is a hypertree HD = \u3008T, \u03c7, \u03bb\u3009 for H such that: (1) for each hyperedge h \u2208 edges(H), there exists p \u2208 vertices(T ) such that h \u2286 \u03c7(p); (2) for each node Y \u2208 nodes(H), the set {p \u2208 vertices(T ) | Y \u2208 \u03c7(p)} induces a (connected) subtree of T ; and (3) for each p \u2208 vertices(T ), \u03c7(p) \u2286 nodes(\u03bb(p)). The width of a generalized hypertree decomposition \u3008T, \u03c7, \u03bb\u3009 is maxp\u2208vertices(T )|\u03bb(p)|. The generalized hypertree width ghw(H) of H is the minimum width over all its generalized hypertree decompositions.\nA hypertree decomposition [14] of H is a generalized hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 where: (4) for each p \u2208 vertices(T ), nodes(\u03bb(p)) \u2229 \u03c7(Tp) \u2286 \u03c7(p). Note that the inclusion in the above condition is actually an equality, because Condition (3) implies the reverse inclusion. The hypertree width hw(H) of H is the minimum width over all its hypertree decompositions. Note that, for any hypergraph H, it is the case that ghw(H) \u2264 hw(H) \u2264 3\u00d7 ghw(H) + 1 [4]. Moreover, for any fixed natural number k > 0, deciding whether hw(H) \u2264 k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) \u2264 k is NP-complete [16].\nTree Projections. For two hypergraphs H1 and H2, we write H1 \u2264 H2 if, and only if, each hyperedge of H1 is contained in at least one hyperedge of H2. Let H1 \u2264 H2; then, a tree projection of H1 with\nrespect to H2 is an acyclic hypergraph Ha such that H1 \u2264 Ha \u2264 H2. Whenever such a hypergraphHa exists, we say that the pair of hypergraphs (H1,H2) has a tree projection.\nNote that the notion of tree projection is more general than the above mentioned (hyper)graph based notions. For instance, consider the generalized hypertree decomposition approach. Given a hypergraph H and a natural number k > 0, let Hk denote the hypergraph over the same set of nodes as H, and whose set of hyperedges is given by all possible unions of k edges in H, i.e., edges(Hk) = {h1\u222ah2\u222a\u00b7 \u00b7 \u00b7\u222ahk | {h1, h2, . . . , hk} \u2286 edges(H)}. Then, it is well known and easy to see that H has generalized hypertree width at most k if, and only if, there is a tree projection for (H,Hk).\nSimilarly, for tree decompositions, let Htk be the hypergraph over the same set of nodes as H, and whose set of hyperedges is given by all possible clusters B \u2286 nodes(H) of nodes such that |B| \u2264 k+1. Then, H has treewidth at most k if, and only if, there is a tree projection for (H,Htk)."}, {"heading": "3 Minimal Tree Projections", "text": "In this section, a partial ordering of tree projections is defined. It is shown that minimal tree projections have nice properties with both theoretical and practical interest.\nLet H and H\u2032 be two hypergraphs. We say that H is contained in H\u2032, denoted by H \u2286 H\u2032, if for each hyperedge h \u2208 edges(H) \u2212 edges(H\u2032), there is a hyperedge h\u2032 \u2208 edges(H\u2032) \u2212 edges(H) with h \u2286 h\u2032 (and hence h \u2282 h\u2032). Moreover, we say that H is properly contained in H\u2032, denoted by H \u2282 H\u2032, if H \u2286 H\u2032 and H 6= H\u2032.\nNote that edges(H) \u2286 edges(H\u2032) entails H \u2286 H\u2032 (and hence edges(H) \u2282 edges(H\u2032) entails H \u2282 H\u2032). Moreover,H \u2286 H\u2032 implies H \u2264 H\u2032, but the converse is not true. For example, if edges(H) = {h1, h2} with h2 \u2282 h1 and edges(H\u2032) = {h1}, then H\u2032 \u2286 H and H\u2032 \u2264 H hold, as edges(H\u2032) \u2282 edges(H). Moreover, H \u2264 H\u2032 holds too, but H is not contained in H\u2032 as there is no hyperedge h\u2032 \u2208 edges(H\u2032)\u2212 edges(H) such that h2 \u2286 h\u2032.\nDefinition 3.1 Let H1 and H2 be two hypergraphs. Then, a tree projection Ha for (H1,H2) is minimal if there is no tree projection H\u2032a of H1 wr.t. H2 with H \u2032 a \u2282 Ha. \u2737"}, {"heading": "3.1 Basic Facts", "text": "We first point out a number of basic important properties of tree projections of a given pair of hypergraphs (H1,H2).\nFact 3.2 The relationship \u2286 of Definition 3.1 induces a partial ordering over the tree projections of H1 w.r.t. H2.\nProof. Observe first that the relation \u2018\u2286\u2019 over hypergraphs is reflexive. We next show that it is antisymmetric, too. Let H1 and H2 be two hypergraphs such that H1 \u2286 H2 and H2 \u2286 H1, and assume by contradiction that H1 6= H2. Thus, edges(H2) 6= edges(H1). Moreover, edges(H2) 6\u2283 edges(H1) holds, for otherwise it is trivially impossible that H2 \u2286 H1. Then, let h1 be the largest hyperedge (with the maximum number of nodes) in edges(H1) \\ edges(H2). Since H1 \u2286 H2, it is the case that there is a hyperedge h2 \u2208 edges(H2) \\ edges(H1) with h1 \u2282 h2. But we also know that H2 \u2286 H1 holds, and hence there is a hyperedge h\u20321 \u2208 edges(H1) \\ edges(H2) with h2 \u2282 h \u2032 1. Thus, h1 \u2282 h2 \u2282 h \u2032\n1, which is impossible due to the maximality of h1.\nEventually, we show that the relation \u2018\u2286\u2019 over hyperedges is transitive. Indeed, assume H1 \u2286 H2 and H2 \u2286 H3. Let h1 be a hyperedge in edges(H1) \\ edges(H3). We distinguish two cases. If h1 \u2208 edges(H2), and hence h1 \u2208 edges(H2) \\ edges(H3), then there is a hyperedge h3 \u2208 edges(H3) \\ edges(H2) such that h1 \u2286 h3. Otherwise, i.e., if h1 6\u2208 edges(H2), and hence h1 \u2208 edges(H1) \\ edges(H2), then there is a hyperedge h2 \u2208 edges(H2) \\ edges(H1) such that h1 \u2286 h2. Then, we have to consider two subcases. If h2 \u2208 edges(H3), then we have that h2 is actually a hyperedge in edges(H3) \\ edges(H1) such that h1 \u2286 h2. Instead, if h2 6\u2208 edges(H3), and hence h2 \u2208 edges(H2) \\ edges(H3), then there is a hyperedge h\u20323 \u2208 edges(H3) \\ edges(H2) with h2 \u2286 h3. It follows that h1 \u2286 h2 \u2286 h\u20323. Putting it all together, we have shown that in all the possible cases, for each hyperedge h1 \u2208 edges(H1) \\ edges(H3) there is a hyperedge h\u2032 \u2208 edges(H3) \\ edges(H1) such that h1 \u2286 h\u2032. It follows that H1 \u2286 H3 holds.\nBy the above properties, \u2018\u2286\u2019 is a partial order, and \u2018\u2282\u2019 is a strict partial order over hypergraphs. \u2737\nHence, minimal tree projections always exist, as long as a tree projection exists.\nFact 3.3 The pair (H1,H2) has a tree projection if, and only if, it has a minimal tree projection.\nA further property (again rather intuitive) is that minimal tree projections are reduced hypergraphs. Recall that a hypergraph Ha is reduced if edges(Ha) does not contain two hyperedges ha and h\u0304a such that ha \u2282 h\u0304a.\nFact 3.4 Every minimal tree projection is reduced.\nProof. Assume for the sake of contradiction that Ha is a minimal tree projection of H1 w.r.t. H2 such that Ha is not reduced. Let ha and h\u0304a be two hyperedges of Ha such that ha \u2282 h\u0304a. Consider the tree projectionH\u2032a 6= Ha obtained by removing ha from Ha, and notice that H \u2032 a \u2264 Ha \u2264 H2 and H1 \u2264 H \u2032\na. Thus, H\u2032a is a tree projection of H1 w.r.t. H2. However, we have that edges(H \u2032\na) \u2282 edges(Ha), which entails that H\u2032a \u2282 Ha holds, thereby contradicting the minimality of Ha. \u2737\nThe last basic fact is rather trivial: minimal tree projections do not contain nodes that do not occur in H1.\nFact 3.5 Let Ha be a minimal tree projection of H1 w.r.t. H2. Then, nodes(Ha) = nodes(H1).\nProof. Let Ha be a minimal tree projection of H1 w.r.t. H2. Of course, nodes(Ha) \u2287 nodes(H1) clearly holds. On the other hand, if nodes(Ha) \u2283 nodes(H1), the hypergraphs H\u2032a obtained by deleting from every hyperedge each node in nodes(Ha) \\ nodes(H1) is still an acyclic hypergraph, and H1 \u2264 H\u2032a \u2264 Ha holds. Moreover, it is straightforward to check that H \u2032\na \u2282 Ha, which contradicts the minimality of Ha. \u2737"}, {"heading": "3.2 Component trees", "text": "We now generalize to the setting of tree projections some properties of join trees that are required for efficiently computable decompositions in various notions of structural decomposition methods (see, e.g., [14]). To formalize these properties, we need to introduce some additional definitions, which will be intensively used in the following.\nAssume that a hypergraph H is given. Let V , W , and {X,Y } be sets of nodes. Then, X is said [V ]-adjacent (in H) to Y if there exists a hyperedge h \u2208 edges(H) such that {X,Y } \u2286 (h \u2212 V ). A\n[V ]-path from X to Y is a sequence X = X0, . . . , X\u2113 = Y of nodes such that Xi is [V ]-adjacent to Xi+1, for each i \u2208 [0...\u2113-1]. We say that X [V ]-touches Y if X is [\u2205]-adjacent to Z \u2208 nodes(H), and there is a [V ]-path from Z to Y ; similarly, X [V ]-touches the set W if X [V ]-touches some node Y \u2208 W . We say that W is [V ]-connected if \u2200X,Y \u2208 W there is a [V ]-path from X to Y . A [V ]-component (of H) is a maximal [V ]-connected non-empty set of nodes W \u2286 (nodes(H) \u2212 V ). For any [V ]-component C, let edges(C) = {h \u2208 edges(H) | h \u2229 C 6= \u2205}, and for a set of hyperedges H \u2286 edges(H), let nodes(H) denote the set of nodes occurring in H , that is nodes(H) = \u22c3\nh\u2208H h. For any component C of H, we denote by Fr(C,H) the frontier of C (in H), i.e., the set nodes(edges(C)).2 Moreover, \u2202(C,H) denote the border of C (in H), i.e., the set Fr(C,H) \\C. Note that C1 \u2286 C2 entails Fr(C1,H) \u2286 Fr(C2,H). We write simply Fr(C) or \u2202C, whenever H is clear from the context.\nWe find often convenient to think at join trees as rooted trees: For each hyperedge h \u2208 edges(H), the tree obtained by rooting JT at vertex h is denoted by JT [h] (if it is necessary to point out its root). Moreover, for each hyperedge h\u2032 \u2208 edges(H) with h\u2032 6= h, let JT [h]h\u2032 denote the subtree of JT [h] rooted at h\u2032, and let nodes(JT [h]h\u2032) be the set of all nodes of H occurring in the vertices of JT [h]h\u2032 .\nDefinition 3.6 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 \u2264 Ha and Ha is acyclic. A join tree JT of Ha, rooted at some vertex root \u2208 edges(Ha), is said an H1-component tree if the following conditions hold for each vertex hr \u2208 edges(Ha) in JT :\nSUBTREES 7\u2192COMPONENTS. For each child hs of hr in JT , there is exactly one [hr]-component of H1, denoted by C\u22a4(hs), such that nodes(JThs) = C\u22a4(hs) \u222a (hs \u2229 hr). Moreover, hs \u2229 C\u22a4(hs) 6= \u2205 and hs \u2286 Fr(C\u22a4(hs),H1) hold.\nCOMPONENTS 7\u2192SUBTREES. For each [hr]-component Cr of H1 such that Cr \u2286 C\u22a4(hr), with C\u22a4(root) being conventionally defined as nodes(H1), there is exactly one child hs of hr in JT such that Cr = C\u22a4(hs). \u2737\nInterestingly, any reduced acyclic hypergraph Ha has such an Ha-component tree (i.e., H1 = Ha, here), as pointed out in the result below.\nTheorem 3.7 Let Ha be a reduced acyclic hypergraph (e.g., any minimal tree projection). For any hyperedge h \u2208 edges(Ha), there exists a join tree JT rooted at h that is an Ha-component tree.\nProof. Let Ha be any reduced acyclic hypergraph and let h \u2208 edges(Ha) be any of its hyperedges, and consider Definition 3.6, with its two parts: SUBTREES 7\u2192COMPONENTS and COMPONENTS 7\u2192SUBTREES.\nSUBTREES 7\u2192COMPONENTS. We first show that there is a join tree JT for Ha such that, for each pair hr, hs \u2208 edges(Ha) where hs is a child of hr in JT [h],\n(1) there is exactly one [hr]-component Cr of Ha, denoted by C\u22a4(hs), such that nodes(JT [h]hs) = C\u22a4(hs) \u222a (hs \u2229 hr);\n(2) hs \u2229 C\u22a4(hs) 6= \u2205;\n(3) hs \u2286 Fr(C\u22a4(hs),Ha).\n2The choice of the term \u201cfrontier\u201d to name the union of a component with its outer border is due to the role that this notion plays in hypergraph games, such as the one described in the subsequent section.\nSince Ha is a reduced acyclic hypergraph, the hypertree width of Ha is 1. In particular, from the results in [14] (in particular, from Theorem 5.4 in [14]) it follows that, for each hyperedge h \u2208 edges(Ha), there is a width-1 hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 for Ha, where T is rooted at a vertex root(T ) such that \u03bb(root(T )) = {h} and, for each vertex r \u2208 vertices(T ) and for each child s of r, the following conditions hold: (1) there is (exactly) one [\u03c7(r)]-component Cr of Ha such that \u03c7(Ts) = Cr \u222a (\u03c7(s) \u2229 \u03c7(r)); (2) \u03c7(s) \u2229 Cr 6= \u2205, where Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1); and (3) hs \u2229Fr(Cr,Ha) 6= \u2205 holds, where {hs} = \u03bb(s) and Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1).\nLet us now denote by hp the unique (as the width is 1) hyperedge contained in \u03bb(p), for each vertex p of T . Recall that h = hroot(T ) is the hyperedge associated with the root of T . Let JT [h] be the tree rooted at h obtained from T by replacing each vertex p with the corresponding hyperedge hp. Then, for each vertex r \u2208 vertices(T ) and for each child s of r, the three conditions above that hold on HD can be rewritten as follows: (1) there is (exactly) one [hr]-component Cr of Ha such that nodes(JT [h]hs) = Cr \u222a (hs \u2229 hr); (2) hs \u2229 Cr 6= \u2205, where Cr is the [hr]-component of Ha satisfying Condition (1); and (3) hs \u2286 Fr(Cr ,Ha), where Cr is the [hr]-component of Ha satisfying Condition (1).\nIt remains to show that JT is actually a join tree for Ha. To this end, we claim that the following two properties hold on HD.\nProperty P1: \u2200p \u2208 vertices(T ), \u03c7(p) = nodes(\u03bb(p)).\nProof. Recall that for each vertex r \u2208 vertices(T ) and for each child s of r, the following conditions hold on the hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 for Ha: (1) there is (exactly) one [\u03c7(r)]-component Cr of Ha such that \u03c7(Ts) = Cr \u222a (\u03c7(s) \u2229 \u03c7(r)); (2) \u03c7(s) \u2229 Cr 6= \u2205, where Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1); and (3) hs \u2229 Fr(Cr) 6= \u2205 holds, where {hs} = \u03bb(s) and Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1). In fact, \u03c7(s) 6\u2286 \u03c7(r) holds, as \u03c7(r) \u2229 Cr = \u2205 while \u03c7(s) \u2229 Cr 6= \u2205. Now, from Condition (4) in the definition of hypertree decompositions it follows that, for each vertex p \u2208 vertices(T ), \u03c7(p) = nodes(\u03bb(p)) \u2229 \u03c7(Tp). Thus, for each node Y \u2208 nodes(Ha), the vertex p\u0304 with Y \u2208 \u03c7(p\u0304) that is the closest to the root of T is such that \u03c7(p\u0304) = nodes(\u03bb(p\u0304)). Indeed, each node X \u2208 hp\u0304, where \u03bb(p\u0304) = {hp\u0304}, must occur in the \u03c7-labeling of some vertex in the subtree rooted at p\u0304 together with Y in order to satisfy Condition (1) in the definition of hypertree decomposition. Thus, X \u2208 \u03c7(Tp\u0304). Hence, for the vertex root(T ), it is trivially the case that \u03c7(root(T )) = nodes(\u03bb(root(T ))). Consider now an arbitrary vertex r \u2208 vertices(T ) and let s be a child of r. Thus, {hs} = \u03bb(s), for some hyperedge hs. Recall that \u03c7(s) 6\u2286 \u03c7(r), and take any node Y \u2208 hs such that Y \u2208 \u03c7(s)\\\u03c7(r). Because of Condition (2) in the definition of hypertree decomposition, Y cannot occur in the \u03c7-labeling of any vertex in path connecting root(T ) and r in T . Thus, s is the vertex closest to the root where Y occurs. Hence, \u03c7(s) = nodes(\u03bb(s)). \u22c4\nProperty P2: \u2200p1, p2 \u2208 vertices(T ), \u03bb(p1) 6= \u03bb(p2).\nProof. Assume for the sake of contradiction that there are two vertices p1 and p2 such that \u03bb(p1) = \u03bb(p2). Because of Property P1, nodes(\u03bb(p1)) = nodes(\u03bb(p2)) = \u03c7(p1) = \u03c7(p2). Then, by Condition (2) in the definition of hypertree decomposition, each vertex p in the path between p1 and p2 is such that nodes(\u03bb(p)) = \u03c7(p) = \u03c7(p1) = \u03c7(p2) (because the hypergraph is reduced). In particular, this property holds for one vertex r \u2208 vertices(T ) and for one child s of r. However, \u03c7(r) = \u03c7(s) is impossible as we have observed in the proof of Property P1. \u22c4\nNow, we show that hyperedges of Ha one-to-one correspond to vertices of JT , and that the connectedness condition holds on JT .\nFor the first property, note that each vertex p of T corresponds to the hyperedge hp, by construction. Moreover, by Property P2, each vertex of JT is mapped to a distinct hyperedge. Thus, it remains to show that for each hyperedge h\u0304 \u2208 edges(Ha), there is a vertex p of T such that h\u0304 = hp. Indeed, note that by Condition (1) of hypertree decompositions, for each hyperedge h\u0304 \u2208 edges(Ha), there is a vertex p in T such that h\u0304 \u2286 \u03c7(p). By Property P1 above, this entails that there is a hyperedge hp \u2208 edges(Ha) such that hp = \u03c7(p) and h\u0304 \u2286 hp. However, since Ha is reduced, h\u0304 = hp holds.\nWe eventually observe that the connectedness condition holds on JT . Indeed, if a node Y \u2208 nodes(Ha) occurs in a vertex hp of JT , i.e., Y \u2208 hp, we have that Y \u2208 \u03c7(p) holds by Property P1. By Condition (2) of hypertree decompositions, the set {p \u2208 vertices(T ) | Y \u2208 \u03c7(p)} induces a (connected) subtree of T . It follows that the set {hp \u2208 edges(Ha) | Y \u2208 hp} induces a connected subtree of JT .\nCOMPONENTS 7\u2192SUBTREES. Let us now complete the proof by showing that the join tree JT also satisfies the part COMPONENTS 7\u2192SUBTREES in Definition 3.6. Recall that C\u22a4(h) is defined as nodes(Ha) for the root h, and that C\u22a4(hs) is the unique [hr]-component with nodes(JT [h]hs) = C\u22a4(hs)\u222a(hs\u2229hr), where hs is a child of hr in JT [h]. In fact, to conclude the proof, we next show that, for each vertex hr in JT [h] and for each [hr]-component Cr of Ha such that Cr \u2286 C\u22a4(hr), there is exactly one child hs of hr such that Cr = C\u22a4(hs).\nLet Cr be an [hr]-component such that Cr \u2286 C\u22a4(hr). Assume, first, that hr is the child of a vertex hp \u2208 edges(Ha) of JT [h], i.e., hr is distinct from the root h of JT [h]. Then, because of the part SUBTREES 7\u2192COMPONENTS above, we have that nodes(JT [h]hr) = C\u22a4(hr) \u222a (hp \u2229 hr). In particular, this entails that nodes(JT [h]hr) \u2287 C\u22a4(hr). Thus, nodes(JT [h]hr) \u2287 Cr. Then, since hr \u2229 Cr = \u2205, we have that for each node X \u2208 Cr, X occurs in some vertex of a subtree of JT [h]hr rooted at a child hs(X) of hr, with X \u2208 hs(X). In particular, because of the connectedness condition of join trees, there is precisely one such subtree, since X 6\u2208 hr. Now, we can apply the part SUBTREES 7\u2192COMPONENTS above on hs(X) to observe that there is exactly one [hr]-component C\u22a4(hs) of Ha such that nodes(JT [h]hs(X)) = C\u22a4(hs) \u222a (hr \u2229 hs(X)). However, since X 6\u2208 hr, X \u2208 C\u22a4(hs) holds. Hence, Cr = C\u22a4(hs).\nFinally, consider now the case where hr is the root of JT [h], i.e., hr = h. Then, let Cr be an [hr]-component and let X \u2208 Cr . Let hX be the hyperedge that is the closest to the root of JT [h] and such that X \u2208 hX . Note that because of the connectedness condition, there is precisely one such hyperedge hX . By using the same line of reasoning as above, it follows that the child hs(X) of h such that X occurs in some vertex of JT [h]hs(X) is the only one satisfying the condition in the statement. \u2737"}, {"heading": "3.3 Preservation of Components", "text": "In the light of Theorem 3.7, the connectivity of an arbitrary tree projection Ha for H1 (with respect to some hypergraph H2) is characterized in terms of its components. We next show that it can be also characterized in terms of the components of the original hypergraph H1. This is formalized in the following two lemmas.\nLemma 3.8 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 \u2264 Ha. Then, for each h \u2208 edges(Ha) and [h]-component C1 in H1, there is an [h]-component Ca of Ha such that C1 \u2286 Ca.\nProof. Since H1 \u2264 Ha, for each hyperedge h\u2032 \u2208 edges(H1), there is a hyperedge ha \u2208 edges(Ha) such that h1 \u2286 ha. Then, for any set of nodes h and any [h]-component C1 of H1, it follows that C1 is also [h]-connected in Ha. Hence, there is an [h]-component Ca of Ha such that C1 \u2286 Ca. \u2737\nLemma 3.9 Let H1 and Ha be two hypergraphs with the same set of nodes such that H1 \u2264 Ha. Then, for each h \u2208 edges(Ha) and [h]-component Ca in Ha, there are C11 , ..., C n 1 [h]-components of H1 such that Ca = \u22c3n i=1 C i 1.\nProof. After Lemma 3.8, the result follows from the fact that H1 and Ha are defined over the same set of nodes. Indeed, let X be a node in Ca. Then, since X 6\u2208 h, X belongs to an [h]-component C(X) of H1, and because of Lemma 3.8, C(X) \u2286 Ca holds. Thus, Ca = \u22c3\nX\u2208Ca C(X). \u2737\nAt a first sight, however, since each hyperedge in H1 is contained in a hyperedge of Ha, one may naturally be inclined at thinking that such a \u201cbigger\u201d hypergraphHa is characterized by a higher connectivity, because some nodes that are not (directly) connected by any edge in H1 may be included together in some edge of Ha. Indeed, in general, for any given set of nodes h, evaluating [h]-components of H1 gives proper subsets of the analogous components evaluated in Ha. Next, we show that this is not the case if minimal tree projections are considered.\nTheorem 3.10 Let Ha be a minimal tree projection of H1 w.r.t. H2. Then, for each hyperedge h \u2208 edges(Ha), C is an [h]-component of Ha \u21d4 C is an [h]-component of H1.\nProof. Let Ha be a minimal tree projection of H1 with respect to H2. Let h be in edges(Ha), and assume, by contradiction, that: C is an [h]-component of Ha 6\u21d4 C is an [h]-component of H1. From Lemma 3.8 and Lemma 3.9, it follows that there is an [h]-component Ca in Ha, and n > 1 [h]-components C11 , ..., C n 1 of H1 such that Ca = \u22c3n i=1 C i 1. See Figure 2, for an illustration.\nLet H be the set of all hyperedges of Ha that intersect Ca, i.e., H = {ha | ha \u2208 edges(Ha) \u2227 ha \u2229 Ca 6= \u2205}, and consider the hypergraph H\u2032a defined over the same set of nodes of Ha and such that:\nedges(H\u2032a) = (edges(Ha)\u2212H) \u222a {ha \u2229 (C i 1 \u222a h) | ha \u2208 H, i \u2208 {1, . . . , n} }.\nNote that, since Ca = \u22c3n i=1 C i 1 with n > 1, there is at least a hyperedge h\u0304a \u2208 edges(Ha) such\nthat h\u0304a \u2229 (Ci1 \u222a h) \u2282 h\u0304a, for some [h]-component C i 1. Thus, H \u2032 a 6= Ha. Let in fact h1 be any hyperedge in edges(H\u2032a) \\ edges(Ha). Then, h1 \u2208 {ha \u2229 (C i 1 \u222a h) | ha \u2208 H, i \u2208 {1, . . . , n} }. That is, h1 = ha\u2229(C i\u03041\u222ah) for some hyperedgeha \u2208 H and [h]-componentC i\u0304 1 of H1. In particular, note that the case where h1 = ha = ha\u2229(C i\u03041\u222ah) is impossible, for otherwise we would have h1 \u2208 edges(Ha). Thus, h1 = ha\u2229(C i\u03041\u222ah) \u2282 ha, which in turn entails that ha\u2229(C i 1\u222ah) \u2282 ha, for each [h]-componentC i 1. This property suffices to show that ha 6\u2208 edges(H\u2032a). Indeed, assume by contradiction that ha \u2208 edges(H \u2032\na). As ha \u2208 H , there is a hyperedgeh\u2032a \u2208 H such that ha = h \u2032 a\u2229(C i 1\u222ah) for some [h]-componentC i 1, and therefore such that ha \u2286 h\u2032a. However, since ha\u2229(C i 1\u222ah) \u2282 ha, we conclude that ha 6= h \u2032\na and, hence, ha \u2282 h\u2032a. This is impossible since Ha is a minimal tree projection, and thus a reduced hypergraph by Fact 3.4. It follows that H\u2032a \u2282 Ha, because for (the generic) hyperedge h1 \u2208 (edges(H \u2032\na) \\ edges(Ha)) there exists ha \u2208 (edges(Ha) \\ edges(H\u2032a)) such that h1 \u2282 ha.\nWe now claim that the following three properties hold on H\u2032a.\nProperty P1: H\u2032a \u2264 H2.\nProof. We have to show that for each hyperedge h\u2032a \u2208 edges(H \u2032 a), there is a hyperedge h2 \u2208 edges(H2) such that h\u2032a \u2286 h2. To this end, observe that for each hyperedge h \u2032 a \u2208 edges(H \u2032\na), there is by definition of edges(H\u2032a) a hyperedge ha \u2208 edges(Ha) such that h \u2032\na \u2286 ha. Then, since Ha is a tree projection of H1 w.r.t. H2, there is in turn a hyperedge h2 \u2208 edges(H2) such that ha \u2286 h2. That is, h\u2032a \u2286 h2, for some h2 \u2208 edges(H2). \u22c4\nProperty P2: H1 \u2264 H\u2032a.\nProof. We have to show that for each hyperedge h1 \u2208 edges(H1), there is a hyperedge h\u2032a \u2208 edges(H\u2032a) such that h1 \u2286 h \u2032\na. Let h1 be a hyperedge of H1. Since Ha is a tree projection of H1, we have that there is a hyperedge ha \u2208 edges(Ha) such that h1 \u2286 ha. In the case where h1 \u2229Ca = \u2205, we distinguish two subcases. Either h1 \u2286 h, or h1 \\ h 6= \u2205. In the former scenario, we have just to observe that h occurs in edges(H\u2032a), as h \u2229 Ca = \u2205, and hence h = ha. In the latter scenario, ha \u2229 Ca must be empty, as ha is [h]-connected in Ha and h1 \u2286 ha. Again, we have that ha occurs in edges(H\u2032a). Consider now the case where h1 \u2229 Ca 6= \u2205, and let X \u2208 h1 \u2229 Ca. Because of Lemma 3.9, X must belong to an [h]-component Ci1 in H1. Then, edges(H\u2032a) contains, by definition, the hyperedge h \u2032 a = ha \u2229 (C i 1 \u222ah). In fact, since h1 \u2286 ha, we also have h1 \u2229 (Ci1 \u222a h) \u2286 h \u2032 a. In order to conclude that h1 \u2286 h \u2032\na, it remains to observe that all the vertices in h1 \\ h are contained in Ci1 since h1 \\ h is [h]-connected in H1 and X \u2208 h1 \u2229C i 1. \u22c4\nProperty P3: H\u2032a is acyclic.\nProof. The proof of this property is rather technical, and hence we find convenient to illustrate its main ideas here, as they shed some light on the connectivity of minimal tree projections. From Theorem 3.7, we know that Ha has an Ha-component tree rooted at h, say JT [h]. For such a join tree, there is a one-to-one correspondence between components of Ha and subtrees of JT [h]. Accordingly, any such a component C, denote by JT [h]C the subtree rooted at the child hs of h such that C = C\u22a4(hs). Then, the line of the proof is to apply a normalization procedure\nover the subtree JT [h]Ca which is in charge of decomposing Ca, in order to build the subtrees JT \u2032[h]C1\n1\n,...,JT \u2032[h]Cn 1 , each one being in charge of decomposing an [h]-component in H1. An illustration is reported in Figure 2. The resulting tree JT \u2032[h] can be shown to be a join tree for H\u2032a, thus witnessing that H \u2032 a is acyclic.\nLet us now prove formally the result. Recall that Ha is reduced because of Fact 3.4. From Theorem 3.7, we know that Ha has an Ha-component tree rooted at h, say JT [h]. For such a join tree, there is a one-to-one correspondence between components of Ha and subtrees of JT [h]. Accordingly, for any such a component C, denote by JT [h]C the subtree rooted at the child hs of h such that C = C\u22a4(hs).\nLet Ca, C1a , ..., C m a be the [h]-components of Ha, where Ca is the component such that Ca = \u22c3n\ni=1 C i 1, with n > 1 and C 1 1 , ..., C n 1 are [h]-components of H1. Based on JT [h], we shall build\na tree JT \u2032[h] whose vertices are the hyperedges of H\u2032a. In particular, JT \u2032[h] is a built as follows:\n\u2013 The root of JT \u2032[h] is the hyperedge h.\n\u2013 Each subtree JT [h]Ci a occurs in JT \u2032[h] as a subtree of h. \u2013 For each [h]-component Ci1 \u2286 Ca in H1, JT \u2032[h] contains, as a subtree of h, the subtree\nJT \u2032[h]Ci 1 that is built from JT [h]Ca by replacing each hyperedge ha with the hyperedge ha \u2229 (Ci1 \u222a h).\n\u2013 No further vertices are in JT \u2032[h].\nNext, we show that JT \u2032[h] is a join tree. Actually, JT \u2032[h] may contain two vertices associated to the same hyperedge of H\u2032a (because of different original hyperedges that may lead to the same intersections). Thus, formally JT \u2032[h] cannot be precisely a join tree, and we shall rather show that it is a hypertree decomposition of width 1 where \u03c7(p) = nodes(\u03bb(p)), for each vertex p, which of course entails the acyclicity of the considered hypergraph. However, for the sake of presentation, we keep the notation of join trees, avoiding the use of the \u03c7 and \u03bb-labelings, and we allow that JT \u2032[h] contains two vertices associated with the same hyperedge of H\u2032a.\n(i) For each vertex h\u2032 in JT \u2032[h], h\u2032 is in edges(H\u2032a). Let h \u2032 be in JT \u2032[h]. In the case where h\u2032 = h, or h\u2032 occurs in a subtree of the form JT \u2032[h]Ci a , then h\u2032 precisely coincides with a hyperedge of Ha such that h\u2032 6\u2208 H . Thus, h\u2032 also belongs to edges(H\u2032a), by definition. If h \u2032 occurs in a subtree of the form JT \u2032[h]Ci 1 , then h\u2032 = ha \u2229 (Ci1 \u222ah), by construction of JT \u2032[h], for some hyperedge ha in JT [h]Ca which is, hence, such that h 6= ha. In particular, because of Theorem 3.7, ha \\ h \u2286 Ca. The case ha \u2286 h (actually, ha \u2282 h) is impossible, since ha and h are both hyperedges of Ha, which is minimal and hence reduced by Fact 3.4. Thus, ha \u2229 Ca 6= \u2205 and hence ha \u2208 H . Then, the hyperedge h\u2032 = ha \u2229 (Ci1 \u222a h) is in edges(H \u2032 a).\n(ii) For each hyperedge h\u2032 in edges(H\u2032a), h \u2032 is in JT \u2032[h]. Let h\u2032 6= h be a hyperedge of H\u2032a; indeed, for h\u2032 = h the property trivially holds. If h\u2032 is also a hyperedge of Ha, then either h\u2032 6\u2208 H , or h\u2032 \u2208 H and there is an [h]-component Ci1 with h\n\u2032 = h\u2032 \u2229 (Ci1 \u222a h), i.e., with h\u2032 \u2286 (Ci1 \u222a h). If h\n\u2032 6\u2208 H , then h\u2032 \u2229 Ca = \u2205. Then, we have that h\u2032 \u2229 Cia 6= \u2205 for some [h]-component Cia 6= Ca. Hence, due to Theorem 3.7, h \u2032 occurs in JT [h]Ci a . The result then follows since JT [h]Ci a\nalso occurs as a subtree of JT \u2032[h]. Consider now the case where h\u2032 \u2208 H and there is an [h]-componentCi1 with h \u2032 = h\u2032\u2229 (Ci1\u222ah), i.e., with h \u2032 \u2286 (Ci1\u222ah). Since h\n\u2032 6\u2286 h, it holds that h\u2032 \u2229Ci1 6= \u2205 and hence, due to Lemma 3.9, h \u2032 \u2229Ca 6= \u2205. Then, h\u2032 occurs in JT [h]Ca\nbecause of Theorem 3.7 and, by construction, h\u2032 occurs in JT \u2032[h]Ci 1 . Finally, assume that h\u2032 is not a hyperedge of Ha. Thus, h\u2032 = ha \u2229 (Ci1 \u222a h), for some hyperedge ha \u2208 edges(Ha) and [h]-component Ci1 with ha \u2229 Ca 6= \u2205 and ha 6\u2286 (C i 1 \u222a h). Due to Theorem 3.7, ha occurs in JT [h]Ca . Then, by construction, h \u2032 occurs in JT \u2032[h]Ci\n1\n.\n(iii) The connectedness condition holds on JT \u2032[h]. Let h\u2032a1 and h \u2032 a2 be two hyperedges in H\u2032a such that h\u2032a2 occurs in the subtree of JT \u2032[h] rooted at h\u2032a1 . Since subtrees of the form JT [h]Cia are not altered in the transformation, we can focus on the case where h\u2032a2 occurs in some subtree of the form JT \u2032[h]Ci\n1\nand where either h\u2032a1 = h or h \u2032 a1 occurs in the same subtree. In fact, h\u2032a2 (resp.,\nh\u2032a1) belonging to JT \u2032[h]Ci\n1\nentails that h\u2032a2 = ha2 \u2229 (C i 1 \u222a h) (resp., h \u2032 a1 = ha1 \u2229 (C i 1 \u222a h)), for\nsome hyperedge ha2 \u2208 edges(Ha) (resp., ha1 \u2208 edges(Ha)). Note that to deal uniformly with the two cases above, if h\u2032a1 = h, then we can just set ha1 = h. Now, let Y be a node in h \u2032 a1 \u2229h\u2032a2 . Then, Y belongs to ha2 \u2229 ha1 . Consider a hyperedge h \u2032 a in the path between h \u2032 a1 and h\u2032a2 . Again, h\u2032a belonging to JT \u2032[h]Ci\n1\nentails that h\u2032a = ha \u2229 (C i 1 \u222a h), where ha is an edge occurring in the\npath between ha1 and ha2 in JT [h]. Since JT [h] is a join tree, Y also occurs in ha, and hence Y is in h\u2032a. \u22c4\nIn the light of the above properties, H\u2032a is a tree projection of H1 w.r.t. H2 such that H \u2032 a \u2282 Ha, thereby contradicting the fact that Ha is a minimal tree projection. \u2737"}, {"heading": "3.4 Connected Tree Projections", "text": "We next present another interesting property of minimal tree projections: they always admit join trees in a desirable form that we call connected. Such a form is based on the well known notion of connected decomposition defined for the treewidth (see, e.g., [11]). Let \u3008T, \u03c7\u3009 be a tree decomposition of a graph G. For any pair of adjacent vertices pr and ps of T , let Tr and Ts be the two connected subtrees obtained from T by removing the edge connecting pr and ps. Then, \u3008T, \u03c7\u3009 is connected if the subgraphs induced by the nodes covered be the \u03c7-labeling in Tr and in Ts, respectively, are connected, for each pair of vertices pr and ps.\nNext, we define a natural extension of this notion to the more general framework of tree projections of hypergraph pairs.\nDefinition 3.11 A tree projection Ha of H1 w.r.t. H2 is connected if it has an H1-connected join tree, i.e., a join tree JT with the following property: For each pair of adjacent vertices hr, hs of JT , the sub-hypergraph of H1 induced by the nodes in nodes(JT [hr]hs) is [\u2205]-connected. \u2737\nNote that the novel notion coincides with the original one whenever we considers the treewidth method, that is, whenever we look for tree projections of pairs of the form (H,Htk), for any fixed natural number k > 0, where Htk is the hypergraph whose hyperedges are all possible sets of at most k + 1 nodes in H.\nExample 3.12 The tree projection Ha of H1 w.r.t. H2 reported in Figure 1 is not connected, because it has no H1-connected join trees.\nFor instance, consider the join tree JTa depicted in the same figure, and let hr = {E,F,G,H, I, J,K} and hs = {A,D,E, F, J,K}. Then, the sub-hypergraph of H1 induced by nodes(JTa[hr]hs) consists of the hyperedges {D,F,E}, {K, J}, {A,B,C}, {C,D}, and {A,F},\nand thus {K, J} is clearly disconnected from the others. On the other hand, note that the join tree JT \u2032a for the minimal tree projection H\u2032a reported in Figure 3 is H1-connected. \u2701\nWe next show that such a connected join tree always exists for any minimal tree projection, as in the special case of the tree decomposition method. In order to establish the result, we shall exploit an algorithm, called make-it-connected, that has been described in [11] and that enjoys the following properties.\nProposition 3.13 (cf. [11]) Let \u3008T, \u03c7\u3009 be a width-k tree decomposition of a graph G. Then, Algorithm make-it-connected builds in polynomial time a connected width-k\u2032 tree decomposition \u3008T \u2032, \u03c7\u2032\u3009 of G, with k\u2032 \u2264 k, such that: (1) for each vertex p\u2032 of T \u2032, there is a vertex p of T such that \u03c7\u2032(p\u2032) \u2286 \u03c7(p); and (2) if \u3008T, \u03c7\u3009 is not connected, then there is a vertex p\u0304 of T such that \u03c7(p\u0304) 6= \u03c7\u2032(p\u2032), for each vertex p\u2032 of T \u2032.\nTheorem 3.14 If Ha is a minimal tree projection of H1 w.r.t. H2, then any join tree JT for Ha is H1-connected.\nProof. Assume that Ha is a minimal tree projection of H1 w.r.t. H2, hence from Fact 3.5 nodes(H1) = nodes(Ha). Let JT be a join tree for Ha, and let \u3008T, \u03c7\u3009 be a labeled tree whose vertices one-to-one correspond with the vertices of JT . In particular, for each hyperedge h \u2208 edges(Ha), T contains the vertex ph, which is moreover such that \u03c7(ph) = h. From the connectedness property of join trees and the fact that H1 \u2264 Ha, it immediately follows that \u3008T, \u03c7\u3009 is a tree decomposition of (the Gaifman graph of) H1. Assume now, for the sake of contradiction, that JT is not H1-connected. Then, \u3008T, \u03c7\u3009 is not connected too. Thus, we can apply algorithm make-it-connected on \u3008T, \u03c7\u3009, which produces the connected tree decomposition \u3008T \u2032, \u03c7\u2032\u3009, with T \u2032 = (N \u2032, E\u2032) of (the Gaifman graph of) H1.\nLet H\u2032a be the acyclic hypergraph such that nodes(H \u2032 a) = nodes(Ha) and edges(H \u2032 a) = {\u03c7 \u2032(p\u2032) |\np\u2032 \u2208 N \u2032}, and let H\u2032\u2032a be the reduced hypergraph obtained from H \u2032 a by removing its hyperedges that are proper subsets of some hyperedge in H\u2032a. Therefore, we have edges(H \u2032\u2032 a) \u2286 edges(H \u2032 a) and H \u2032\na \u2264 H\u2032\u2032a . Of course, H \u2032\u2032 a is acyclic too. Moreover, we claim that H \u2032\u2032\na \u2286 Ha. Indeed, for each hyperedge \u03c7\u2032(p\u2032) \u2208 edges(H\u2032\u2032a) \\ edges(Ha), by Proposition 3.13.(1), there is a hyperedge \u03c7(p) \u2208 edges(Ha) such that \u03c7\u2032(p\u2032) \u2286 \u03c7(p). Moreover, \u03c7(p) cannot occur in edges(H\u2032\u2032a), as H \u2032\u2032 a is reduced. Hence, \u03c7(p) is\nin edges(Ha) \\ edges(H\u2032\u2032a), and we actually have \u03c7 \u2032(p\u2032) \u2282 \u03c7(p). That is, H\u2032\u2032a is an acyclic hypergraph with H\u2032\u2032a \u2286 Ha. Now, observe that since \u3008T \u2032, \u03c7\u2032\u3009 is a tree decomposition of (the Gaifman graph of) H1 and since H\u2032\u2032a \u2286 Ha, we have H1 \u2264 H \u2032 a \u2264 H \u2032\u2032 a \u2264 Ha \u2264 H2. Thus, H \u2032\u2032\na is a tree projection of H1 w.r.t. H2. However, by Proposition 3.13.(2), there is a vertex p\u0304 of T such that \u03c7(p\u0304) 6= \u03c7\u2032(p\u2032), for each vertex p\u2032 of T \u2032. Thus, H\u2032\u2032a 6= Ha. Hence, H \u2032\u2032 a is a tree projection for (H1,H2) such that H \u2032\u2032\na \u2282 Ha, which contradicts the minimality of Ha. \u2737\nEventually, by exploiting Fact 3.3, we get the following corollary.\nCorollary 3.15 (H1,H2) has a tree projection if, and only if, (H1,H2) has a connected tree projection.\nRemark 3.16 A different notion of connected decomposition has been introduced in [29] for the special case of (generalized) hypertree decompositions, in order to speed-up their computation. According to [29], a (generalized) hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 is connected if the root r of T is such that |\u03bb(r)| = 1, and for each pair of nodes p and s, with s child of p in T , and for each h \u2208 \u03bb(s), h \u2229 \u03c7(s) \u2229 \u03c7(p) 6= \u2205. The connected (generalized) hypertree width c(g)hw is the minimum width over all the possible connected (generalized) hypertree decompositions. Whether or not chw(H) = hw(H) for every hypergraph H was an open question [29].\nNext, we give a negative answer to this question by showing that the latter notion of connectedness gives a structural method that is weaker than the unrestricted (generalized) hypertree decomposition, even on graphs. Consider the graph Ghex in Figure 4. As shown in the same figure, there is a hypertree decomposition HDhex = \u3008T, \u03c7, \u03bb\u3009 of this (hyper)graph having width 3, and thus hw(Ghex) \u2264 3. In HDhex, for each vertex p of T , \u03c7(p) = nodes(\u03bb(p)) holds, and thus Figure 4 shows only the \u03bb-labeling of each vertex. Moreover, only the left branch is detailed, showing how to deal with the upper cluster of hexagons. The other subtrees are of the same form, and thus are not reported, for the sake of simplicity. Note that {0} and its child {0, 21, 42} violate the required connectedness property. In fact, it turns out that the only way to attack such hexagons is by using, at some vertex s of the decomposition tree, some nodes that are not directly connected to (the nodes occurring in) the parent vertex of s. Indeed, the reader can check there is neither a hypertree decomposition nor a generalized hypertree decomposition of Ghex that is connected according to [29] and has width 3. Thus, the following holds.\nFact 3.17 There is a graph Ghex such that cghw(Ghex) > hw(Ghex)."}, {"heading": "3.5 Tree Projections in Normal Form", "text": "We next show the main result of this section, where all the above ingredients are exploited together: all minimal tree projections have join trees in a suitable normal form. This normal form is of theoretical interest, since it can be exploited to establish further results on the setting (as its game-theoretic characterization discussed in Section 4). Moreover, it is of practical interest, since it can be used to prune the search space in solution approaches aimed at computing tree projections.\nDefinition 3.18 A join tree of a tree projection of H1 w.r.t. H2 is said in normal form if it is H1connected and it is an H1-component tree. \u2737\nExample 3.19 Consider again the tree projection Ha and its join tree JTa illustrated in Figure 1. Consider the vertices hr = {E,F,G,H, I, J,K} and hs = {A,D,E, F, J,K} in\nJTa[{E,F,G,H, I, J,K}], and note that there is exactly one [hr]-component C\u22a4(hs) = {A,B,C,D} of H1 such that nodes(JT [h]hs) = {A,B,C,D,E, F, J,K} = C\u22a4(hs) \u222a (hs \u2229 hr). However, Fr(C\u22a4(hs),H1) = {A,B,C,D,E, F} and hence hs 6\u2286 Fr(C\u22a4(hs),H1). Thus, one condition in the (SUBTREES 7\u2192COMPONENTS)-part of Theorem 3.20 is violated.\nIndeed, the tree projection Ha is not minimal. This is witnessed by the tree projection H\u2032a for (H1,H2) that is reported on the left of Figure 3 and that is properly contained in Ha. A join tree JT \u2032a for H\u2032a is reported on the right of the same figure. The careful reader may check that JT \u2032\na satisfies all conditions in Theorem 3.20. \u2701\nTheorem 3.20 (Normal Form) Let Ha be a minimal tree projection of H1 w.r.t. H2. For any hyperedge h \u2208 edges(Ha), there is a join tree for Ha in normal form rooted at h.\nProof. Let h \u2208 edges(Ha) be any hyperedge of the tree projection Ha. Since minimal tree projections are reduced, Theorem 3.7 entails that Ha has a join tree JT that is an Ha-component tree rooted at h. Again from minimality and Theorem 3.10, we get that [h\u2032]-components in Ha and [h\u2032]-components in H1 do coincide, for each h\u2032 \u2208 edges(Ha). Thus, JT has the following properties:\nSUBTREES 7\u2192COMPONENTS. For each vertex hr of JT [h] and each child hs of hr, there is exactly one [hr]-component C\u22a4(hs) of H1 such that nodes(JT [h]hs) = C\u22a4(hs) \u222a (hs \u2229 hr). Moreover, hs \u2229 C\u22a4(hs) 6= \u2205 holds.\nCOMPONENTS 7\u2192SUBTREES. For each vertex hr of JT [h] and each [hr]-component Cr of H1 such that Cr \u2286 C\u22a4(hr), there is exactly one child hs of hr such that Cr = C\u22a4(hs).\nHence, in order to prove that JT is an H1-component tree, it remains to show that, for each vertex hr of JT [h] and each child hs of hr, hs \u2286 Fr(C\u22a4(hs),H1) holds. Assume, for the sake of contradiction, that there is a vertex hr and a child hs of hr such that hs \u2286 Fr(C\u22a4(hs),H1) does not hold. From Theorem 3.7, we know that hs \u2286 Fr(C\u22a4(hs),Ha) holds. It follows that there exists a non-empty set W \u2286 hs \\ C\u22a4(hs) of nodes such that X 6\u2208 Fr(C\u22a4(hs),H1), for each X \u2208 W . Moreover, as nodes(JT [h]hs) = C\u22a4(hs) \u222a (hs \u2229 hr), we have that W \u2286 hs \u2229 hr. Consider the hypergraph H \u2032 a obtained from Ha by replacing each hyperedge h\u0304 occurring in JT [h]hs with h\u0304 \\ W , and note that H\u2032a \u2282 Ha. Of course, the tree JT \u2032 obtained from JT by replacing any such h\u0304 with h\u0304 \\ W is a join\ntree for H\u2032a. Finally, H \u2032 a is again a tree projection for (H1,H2) because every hyperedge of H1 is still covered by some vertex in JT \u2032. Indeed, there is no hyperedge h \u2208 edges(H1) such that both h\u2229W 6= \u2205 and h\u2229C\u22a4(hs) 6= \u2205, by construction of W . This contradicts the fact that Ha is a minimal tree projection for (H1,H2).\nFinally, from Theorem 3.14, JT is H1-connected. \u2737"}, {"heading": "4 Game-Theoretic Characterization", "text": "The Robber and Captain game is played on a pair of hypergraphs (H1,H2) by a Robber and a Captain controlling some squads of cops, in charge of the surveillance of a number of strategic targets. The Robber stands on a node and can run at great speed along the edges of H1; however, she is not permitted to run trough a node that is controlled by a cop. Each move of the Captain involves one squad of cops, which is encoded as a hyperedge h \u2208 edges(H2). The Captain may ask any cops in the squad h to run in action, as long as they occupy nodes that are currently reachable by the Robber, thereby blocking an escape path for the Robber. Thus, \u201csecond-lines\u201d cops cannot be activated by the Captain. Note that the Robber is fast and may see cops that are entering in action. Therefore, while cops move, the Robber may run trough those positions that are left by cops or not yet occupied. The goal of the Captain is to place a cop on the node occupied by the Robber, while the Robber tries to avoid her capture.\nFor a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move. Instead, the Captain cannot employ \u201csecond-lines\u201d cops, but only cops whose positions are under possible Robber attacks.\nExample 4.1 Consider the Robber and Captain game played on the pair (H1,H2) of hypergraphs depicted in Figure 1, and the sequences of moves illustrated in Figure 5.\nInitially, the Robber stands on the node K , and each other node is reachable. The Captain selects the squad {E,F,G,H, I, J,K} and uses the three cops blocking E, F , and G. The Robber sees the cops and, while they enter in action, is fast enough to run on A. Note that, when the Robber is on A and nodes E, F , and G are blocked by the Captain, the Robber can move over {A,B,C,D}, while {E,F} are also under possible Robber attacks because they are adjacent to her escape space. All other nodes are no longer reachable by the Robber and no longer depicted. Hence, the Captain might ask cops to occupy some of the nodes in {A,B,C,D,E, F}, provided they are covered by some hyperedge. In fact, the strategy of the Captain is to select the hyperedge/squad {A,D,E, F, J,K}, and then to use those cops in this squad that block nodes A, D, E, and F . During this move of the cops, the potential escape door {E,F} for the Robber is still blocked, and hence its available space shrinks. Indeed, during the move of the Captain, the Robber can just move either on B or on C. Finally, the Captain uses the squad {A,B,C,D,H} and order its cops to move to A, B, C, and D, thereby capturing the Robber, as its potential escape door {A,D} remains blocked by the cops. \u2701\nIn the rest of the section, we formalize and analyze the game. To this end, we intensively use the notions and the notations given in the previous section, by implicitly applying them to the hypergraph H1, unless stated otherwise.\nDefinition 4.2 (R&C Game) Let H1 and H2 be two hypergraphs. The Robber and Captain game on (H1,H2) (short: R&C(H1,H2) game) is formalized as follows. A position for the Captain is a set M\nof vertices where the cops stand such that M \u2286 h2, for some hyperedge (squad) h2 \u2208 edges(H2). A configuration is a pair (M, v), where M is a position for the Captain, and v \u2208 nodes(H1) is the node where the Robber stands. The initial configuration is ({}, v0), where v0 is a node arbitrarily picked by the Robber.\nLet (Mi, vi) be the configuration at step i. This is a capture configuration, where the Captain wins, if vi \u2208 Mi. Otherwise, the Captain activates the cops in a novel position Mi+1 such that: \u2200X \u2208 Mi+1, X [Mi]-touches vi (in H1). Then, the Robber selects some available node vi+1 (if any) such that there is a [Mi \u2229Mi+1]-path from vi to vi+1 (in H1). If the game continues forever, the Robber wins. \u2737\nNote that it does not make sense for the Captain to assume that the Robber is on a particular node, given the ability of the Robber of changing positions before the cops land. Thus, given a configuration (Mi, vi), we may assume w.l.o.g. that the next Captain\u2019s move is only determined by the [Mi]-component (of H1) that contains vi, rather than by vi itself. And, accordingly, positions can equivalently be written as (Mi, Ci), where Ci is an [Mi]-component. In this case, capture configurations have the form (M, {}), and the initial configuration has the form ({}, nodes(H1)).\nIn the following, assume that a R&C(H1,H2) game is given. Moreover recall that, for any component C (of H1), Fr(C,H1) is the frontier of C, i.e., (by omitting hereafter H1, which is understood) the set Fr(C) = nodes(edges(C)) = C \u222a {Z | \u2203X \u2208 C, h \u2208 edges(H1) s.t. {X,Z} \u2286 h}. Then, observe that the moves of the Captain are confined in the frontier of the current component where the Robber stands.\nFact 4.3 Let Mi and Mi+1 be positions for the Captain and let Ci be an [Mi]-component. Then, \u2200X \u2208 Mi+1, X [Mi]-touches Ci if, and only if, Mi+1 \u2286 Fr(Ci).\nProof. In fact, a node X is in Fr(Ci) if, and only if, either X \u2208 Ci, or X \u2208 Mi and there is a node Z \u2208 Ci with {X,Z} \u2286 h, for some edge h in edges(H1). But, this condition precisely coincides with the definition that X [Mi]-touches Ci. \u2737\nDefinition 4.4 (Strategies) A strategy \u03c3 for R&C(H1,H2) is a function that encodes the moves of the Captain, i.e., given a configuration (Mi, Ci), with Ci 6= \u2205, \u03c3 returns a position Mi+1 such that Mi+1 \u2286 Fr(Ci).\nA game-tree for \u03c3 is a rooted tree T (\u03c3) defined over configurations as follows. Its root is the configuration (\u2205, nodes(H1)). Let (Mi, Ci) be a vertex in T (\u03c3) and let Mi+1 = \u03c3(Mi, Ci).3 Then, (Mi, Ci) has exactly one child (Mi+1, Ci+1), for each [Mi+1]-component Ci+1 such that Ci \u222aCi+1 is [Mi \u2229Mi+1]-connected; we call such a Ci+1 an [(Mi, Ci),Mi+1]-option for the Robber. If there is no [(Mi, Ci),Mi+1]-option, then (Mi, Ci) has exactly one child (Mi+1, {}). No further edge or vertex is in T (\u03c3).\nThen, \u03c3 is a winning strategy if T (\u03c3) is a finite tree. Moreover, define a position Mi+1 to be a monotone move of the Captain in (Mi, Ci), if for each [(Mi, Ci),Mi+1]-option Ci+1, Ci+1 \u2286 Ci. We say that \u03c3 is a monotone strategy if, for each edge from (Mi, Ci) to (Mi+1, Ci+1), it holds that Mi+1 is a monotone move in (Mi, Ci). \u2737\nExample 4.5 Consider again the exemplification of the Robber and Captain in Figure 5. In particular, the bottom-right part of the figure depicts a game-tree associated with a winning strategy: The Captain initially moves on {E,F,G}, and there are two connected components available to the Robber, namely {A,B,C,D} and {H, I, J,K}. The left branch of the tree illustrates the strategy when the Robber goes into the component {A,B,C,D}. Note that this branch precisely corresponds to the moves that are discussed in Example 4.1. The right branch addresses the case where the Robber goes into the component {H, I, J,K}. In both cases, the Captain will eventually capture the Robber. Observe that this winning strategy is monotone. \u2701"}, {"heading": "4.1 Monotone vs Non-monotone Strategies", "text": "In this section, we show that there is no incentive for the Captain to play a strategy \u03c3 that is not monotone, since it is always possible to construct and play a monotone strategy \u03c3\u2032 that is equivalent to \u03c3, i.e., such that \u03c3\u2032 is winning if, and only if, \u03c3 is winning. This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].\n3Note the little abuse of notation: \u03c3(Mi, Ci) instead of \u03c3((Mi, Ci)).\nWe point out that the proof below does not apply to the traditional Robber and Cops game, because in our setting cops can be placed just on the positions that are reachable by the Robber. As a matter of fact, our techniques are substantially different from those used to show that non-monotonic moves provide no extra-power in the Robber and Cops game. We start by illustrating some properties of the novel game.\nIn the following, assume that \u03c3 and T (\u03c3) are a strategy and a game tree for it, respectively. Moreover recall that, for any component C (of H1), \u2202(C) denotes the border of C (in H1), i.e., the set Fr(C) \\C. Then, let the escape-door of the Robber in vi = (Mi, Ci) when attacked with Mi+1 be defined as ED(vi,Mi+1) = \u2202(Ci)\\Mi+1. Note that this is equivalent to state that ED(vi,Mi+1) = Mi\u2229Fr(Ci)\\ Mi+1, because Ci is an [Mi]-component. Consider for instance Example 4.1 at the configuration v1 = ({E,F,G}, {A,B,C,D}), when the Robber is attacked by the Captain with the cops {A,D,E, F}. In this case, the frontier is Fr({A,B,C,D}) = {A,B,C,D,E, F}, hence the escape-door is {E,F} \\ {A,D,E, F} = \u2205.\nIn the following lemma, we show that this set precisely characterizes those vertices trough which the Robber may escape from the current component Ci, when the Captain changes her position from Mi to Mi+1.\nLemma 4.6 Let Mi and Mi+1 be positions for the Captain, let Ci be an [Mi]-component, and let vi = (Mi, Ci). Then, Ci+1 is a [vi,Mi+1]-option if, and only if, Ci+1 is an [Mi+1]-component with Ci+1 \u2229 (Ci \u222a ED(vi,Mi+1)) 6= \u2205.\nProof. Recall from Definition 4.4 that Ci+1 is an [(Mi, Ci),Mi+1]-option if Ci+1 is an [Mi+1]-component such that Ci+1 \u222aCi is [Mi+1 \u2229Mi]-connected.\n(if-part) Assume that Ci+1 is an [Mi+1]-component with Ci+1 \u2229 (Ci \u222a ED(vi,Mi+1)) 6= \u2205. Since Ci+1 (resp., Ci) is an [Mi+1]-component (resp., [Mi]-component), we have that Ci+1 (resp., Ci) is contained in an [Mi+1 \u2229Mi]-component, say C\u2032i+1 (resp., C \u2032\ni). Therefore, if Ci+1 \u2229 Ci 6= \u2205, we immediately can conclude that Ci+1 \u222a Ci is [Mi+1 \u2229Mi]-connected, with C\u2032i+1 = C \u2032\ni . Thus, let us consider the case where Ci+1 \u2229 Ci = \u2205 and, hence, Ci+1 \u2229 ED(vi,Mi+1) 6= \u2205. Consider now pi+1 \u2208 Ci+1\u2229ED(vi,Mi+1). By definition of ED(vi,Mi+1), pi+1 belongs in particular to Mi\u2229Fr(Ci)\\Mi+1. Thus, pi+1 6\u2208 Mi+1 \u2229 Mi. However, pi+1 \u2208 Ci+1 and pi+1 \u2208 Fr(Ci). From the latter, we have that there is a node Z \u2208 Ci and a hyperedge h1 \u2208 edges(H1) such that {pi+1, Z} \u2286 h1. It follows that there is an [Mi+1 \u2229Mi]-path from pi+1 \u2208 Ci+1 to Z \u2208 Ci. Thus, Ci+1 \u222a Ci is [Mi+1 \u2229Mi]-connected.\n(only-if-part) Assume that Ci+1 is an [Mi+1]-component such that Ci+1 \u222a Ci is [Mi+1 \u2229Mi]-connected. Consider the case where Ci+1 \u2229 Ci = \u2205. Then, there is a node pi+1 \u2208 Mi \u2229 Fr(Ci) such that pi+1 \u2208 Ci+1. Thus, pi+1 6\u2208 Mi+1. It follows that pi+1 \u2208 Mi \u2229 Fr(Ci) \\Mi+1, and hence Ci+1 \u2229 ED(vi,Mi+1) 6= \u2205. \u2737\nMoreover, we next characterize monotone moves based on escape-doors.\nLemma 4.7 Let Mi and Mi+1 be positions for the Captain, let Ci be an [Mi]-component, and let vi = (Mi, Ci). Then, ED(vi,Mi+1) = \u2205 if, and only if, for each [vi,Mi+1]-option Ci+1, Ci+1 \u2286 Ci.\nProof. (if-part) Assume that \u2200 [vi,Mi+1]-option Ci+1, Ci+1 \u2286 Ci. Moreover, assume for the sake of contradiction that ED(vi,Mi+1) 6= \u2205, and let X \u2208 ED(vi,Mi+1) = Mi \u2229Fr(Ci) \\Mi+1. In particular note that X 6\u2208 Mi+1, from which we conclude that there must be an [Mi+1]-component Ci+1 such that X \u2208 Ci+1. Thus, X \u2208 Ci+1 \u2229ED(r,Mi+1) and hence we can apply Lemma 4.6 to conclude that Ci+1 is a [vi,Mi+1]-option. However, X is not in Ci, since X belongs to Mi (and Ci is an [Mi]-component). Thus, Ci+1 6\u2286 Ci, which is impossible.\n(only-if-part) Assume that ED(vi,Mi+1) = \u2205, and for the sake of contradiction that Ci+1 is a [vi,Mi+1]-option such that Ci+1 6\u2286 Ci. Let Y be a node in Ci+1 \\ Ci, and observe that there must be a node X \u2208 Ci+1 \u2229 Ci, because of Lemma 4.6. Consider now an [Mi+1]-path from Y to X and let Z1, Z2 be two nodes in this path such that Z1 \u2208 Ci+1\u2229Ci, Z2 \u2208 Ci+1 \\Ci, and {Z1, Z2} \u2286 h for some hyperedge h \u2208 edges(H1). Note that these two nodes exist because of the properties of the endpoints Y and X . Now, it must be the case that Z2 is in (Fr(Ci) \\ Ci) \u2229 Ci+1. Since Mi \u2287 Fr(Ci) \\ Ci, the latter entails that Z2 \u2208 Mi \u2229Fr(Ci)\u2229Ci+1. Finally, since Ci+1 is an [Mi+1]-component, we conclude that Z2 \u2208 Mi \u2229 Fr(Ci) \\Mi+1, i.e., Z2 \u2208 ED(vi,Mi+1) which is impossible. \u2737\nThe lemma above easily leads us to characterize monotone strategies as those ones for which there are no escape-doors.\nCorollary 4.8 The strategy \u03c3 is monotone if, and only if, for each vertex vi = (Mi, Ci) in T (\u03c3), and for each child (Mi+1, Ci+1) of vi, ED(vi,Mi+1) = \u2205.\nAssume now that \u03c3 is a non-monotone winning strategy. Armed with the above notions and results, we shall show how \u03c3 can be transformed into a monotone winning strategy, by \u201cremoving\u201d the various escape-doors.\nLet p = (Mp, Cp) be a configuration reached in T (\u03c3) from (\u2205, nodes(H1)) by a (possibly empty) succession of moves \u03c0. Assume that Mr is the move of the Captain in p and that this move is monotone, i.e., for each [p,Mr]-option C, C \u2286 Cp (note that any move in the initial configuration is monotone). Let r = (Mr, Cr) be a child of p in T (\u03c3), and let s = (Ms, Cs) be a child of r such that Cs 6\u2286 Cr, i.e., such that ED(r,Ms) 6= \u2205 (by Corollary 4.8). This witnesses that Ms is a non-monotone move\u2014see Figure 6.\nLet M \u2032r = Mr \\ ED(r,Ms) \u2282 Mr, and consider the function \u03c3 \u2032 built as follows:\n\u03c3\u2032(M,C) =\n{\nM \u2032r if (M,C) = (Mp, Cp) \u03c3(M,C) otherwise.\nIntuitively, we are removing from r the source of non-monotonicity that was suddenly evidenced while moving to s, i.e., the fact that ED(r,Ms) 6= \u2205. Next, we show that this modification does not affect the final outcome of the game.\nLemma 4.9 \u03c3\u2032 is a winning strategy.\nProof. By definition, \u03c3\u2032 leaves unchanged the configurations of \u03c3 encoded in those subtrees of T (\u03c3) that are not rooted below p = (Mp, Cp)\u2014see Figure 6. Therefore, throughout this proof we have only to take care of what happens in the subtree of T (\u03c3) rooted at (Mp, Cp). Indeed, the first crucial difference between \u03c3\u2032 and \u03c3 occurs when the Captain plays \u03c3\u2032(Mp, Cp) = M \u2032r. Beforehand, we note that this is a \u201cvalid\u201d move, since M \u2032r \u2282 Mr \u2286 Fr(Cp) (cf. Fact 4.3).\nLet C\u2032r be the [M \u2032 r]-component with Cr \u222a ED(r,Ms) \u2286 C \u2032 r. Note that such a component exists since ED(r,Ms) \u2286 Fr(Cr) and M \u2032r \u2286 Mr. In addition, we claim that C \u2032 r is a [p,M \u2032\nr]-option. Indeed, Cr is a [p,Mr]-option, for which therefore Cr \u2229 (Cp \u222a ED(p,Mr)) 6= \u2205 holds, by Lemma 4.6. Moreover, since M \u2032r \u2282 Mr, ED(p,Mr) \u2286 ED(p,M \u2032 r) holds. Hence, given that Cr \u2286 C \u2032\nr, it follows that C\u2032r \u2229 (Cp \u222a ED(p,M \u2032 r)) 6= \u2205, and again by Lemma 4.6, that C \u2032 r is a [p,M \u2032\nr]-option. Thus, there is an edge from p to (M \u2032r, C \u2032 r) in T (\u03c3 \u2032). In order to complete the picture, we need the following two properties.\nProperty P1: For each [p,Mr]-option C, either C \u2286 C\u2032r or C is a [p,M \u2032 r]-option.\nProof. We distinguish two cases depending on whether Fr(C) \u2229 ED(r,Ms) is empty or not. In the case where Fr(C) \u2229 ED(r,Ms) = \u2205, then C is an [M \u2032r]-component given that M \u2032\nr = Mr \\ ED(r,Ms). Moreover, by Lemma 4.6, C is an [Mr]-component such that C \u2229 (Cp \u222a ED(p,Mr)) 6= \u2205. Hence, it trivially holds that C\u2229(Cp\u222aED(p,M \u2032r)) 6= \u2205, because ED(p,Mr) \u2286 ED(p,M \u2032r). Thus, by Lemma 4.6, C is a [p,M \u2032\nr]-option. Eventually, consider the case where Fr(C) \u2229 ED(r,Ms) 6= \u2205, and recall that C\u2032r is the [M \u2032 r]-component with Cr \u222a ED(r,Ms) \u2286 C \u2032\nr. Since M \u2032r = Mr \\ ED(r,Ms), we then have that C \u2286 C \u2032 r. \u22c4\nProperty P2: For each [p,M \u2032r]-option C \u2032 6= C\u2032r, C \u2032 is a [p,Mr]-option.\nProof. Let C\u2032 6= C\u2032r be a [p,M \u2032 r]-option, hence in particular an [M \u2032 r]-component. Since ED(r,Ms) \u2286 C\u2032r and C \u2032 r is also an [M \u2032 r]-component, we have that C \u2032 \u2229 ED(r,Ms) = \u2205. Moreover, C\u2032 \u2229 M \u2032r = \u2205, with M \u2032 r = Mr \\ ED(r,Ms). Thus, C \u2032 \u2229 Mr 6= \u2205 and, hence, C\u2032 is also an [Mr]-component. Then, in the light of Lemma 4.6, to conclude the proof, it suffices to show that C\u2032 \u2229 (Cp \u222a ED(p,Mr)) 6= \u2205 holds. In the case where C\u2032 \u2229 Cp 6= \u2205, we have concluded. Therefore, consider the case where C\u2032 \u2229 Cp = \u2205. In this case, as C\u2032 is a [p,M \u2032r]-option and, hence, C\u2032 \u2229 (Cp \u222a ED(p,M \u2032r)) 6= \u2205 because of Lemma 4.6, we have C\n\u2032 \u2229 ED(p,M \u2032r) 6= \u2205. Recall now that ED(p,Mr) = Mp \u2229 Fr(Cp) \\Mr and ED(p,M \u2032r) = Mp \u2229 Fr(Cp) \\M \u2032\nr. Thus, ED(p,M \u2032r) \u2286 (Mr \\M \u2032 r)\u222aED(p,Mr), and then ED(p,M \u2032\nr) \u2286 ED(r,Ms)\u222aED(p,Mr) holds, as M \u2032r = Mr \\ ED(r,Ms) by definition of the strategy \u03c3\n\u2032. Given that C\u2032 \u2229 ED(r,Ms) = \u2205, we immediately can conclude that C\u2032 \u2229 ED(p,M \u2032r) \u2286 C\n\u2032 \u2229 ED(p,Mr). However, ED(p,Mr) \u2286 ED(p,M \u2032r), because M \u2032 r \u2282 Mr, and hence, C \u2032 \u2229 ED(p,M \u2032r) = C\n\u2032 \u2229 ED(p,Mr) actually holds. Given that C\u2032 \u2229 ED(p,M \u2032r) 6= \u2205, we have therefore that C\n\u2032 \u2229 ED(p,Mr) 6= \u2205. Thus, C\u2032 \u2229 (Cp \u222a ED(p,Mr)) 6= \u2205. \u22c4\nNote that in the light of the two results above, the function \u03c3\u2032 encodes a winning strategy when attacking each [p,M \u2032r]-option C \u2032 6= C\u2032r, since these components remain completely unchanged when\nchanging \u03c3 with \u03c3\u2032. Thus, as illustrated in Figure 6, all subtrees of T (\u03c3) rooted at the children of (Mp, Cp) and attacking options outside C\u2032r are preserved in the game-tree T (\u03c3\n\u2032). Hence, we have only to take care of how \u03c3\u2032 attacks the remaining component C\u2032r.\nBy definition of \u03c3\u2032, \u03c3\u2032(M \u2032r, C \u2032 r) = Ms, which is a valid position since Ms \u2286 Fr(C \u2032 r) because of the facts that \u03c3 is a strategy (and, hence, we can apply Fact 4.3 to conclude that Ms \u2286 Fr(Cr)) and C\u2032r \u2287 Cr, so that Fr(Cr) \u2286 Fr(C \u2032\nr). Moreover, the following property holds, which guarantees that the novel move is actually monotone.\nProperty P3: ED(r\u2032,Ms) = \u2205.\nProof. Assume by contradiction that ED(r\u2032,Ms) = \u2202C\u2032r \\ Ms 6= \u2205, and let X \u2208 ED(r \u2032,Ms). From \u2202C\u2032r \u2286 M \u2032\nr = Mr \\ED(r,Ms), we get that X \u2208 Mr \\Fr(Cr). However, this is impossible because Mr \u2286 Fr(Cr), by definition of the Robber and Captain game. \u22c4\nWe next show that applying Ms to C\u2032r leads exactly to the same strategy obtained when attacking Cr with the same move Ms. Let r\u2032 be the position (M \u2032r, C \u2032 r).\nProperty P4: For each [r,Ms]-option C, C is an [r\u2032,Ms]-option.\nProof. Let C be an [r,Ms]-option and, hence, an [Ms]-component such that C \u2229 (Cr \u222a ED(r,Ms)) 6= \u2205, by Lemma 4.6. By definition, Cr \u222a ED(r,Ms) \u2286 C\u2032r. Hence, C \u2229 C \u2032\nr 6= \u2205. Again by Lemma 4.6, we conclude that C is a [r\u2032,Ms]-option. \u22c4\nProperty P5: For each [r\u2032,Ms]-option C, C is an [r,Ms]-option.\nProof. Let C be an [r\u2032,Ms]-option and, hence, an [Ms]-component such that C \u2229 (C\u2032r \u222a ED(r\u2032,Ms)) 6= \u2205, by Lemma 4.6. Our goal is to show that C is also such that C \u2229 (Cr \u222a ED(r,Ms)) 6= \u2205, so that C is also an [r,Ms]-option (again by Lemma 4.6). By Property P3, ED(r\u2032,Ms) = \u2205 and, hence, C \u2229 C\u2032r 6= \u2205. Let Y be any vertex in C \u2229 C \u2032\nr and assume, for the sake of contradiction, that C \u2229 (Cr \u222a ED(r,Ms)) = \u2205. Then, since C is an [Ms]-component, Ms separates Y from the vertices in Cr \u222a ED(r,Ms), i.e., each path connecting Y with some vertex in Cr \u222a ED(r,Ms) must include a vertex belonging to Ms. 5 Let M\u0304s \u2286 Ms be the set of all such vertices blocking the paths from Y to Cr \u222a ED(r,Ms). Then, consider the set {Y }\u222aCr\u222aED(r,Ms) which is contained inC\u2032r. Hence, {Y }\u222aCr\u222aED(r,Ms) is [M \u2032\nr]-connected, because C\u2032r is an [M \u2032 r]-component. Therefore, the separator M\u0304s cannot be included in M \u2032\nr. It follows that there is a node p \u2208 M\u0304s \\ M \u2032r. Recall, now, that M \u2032\nr = Mr \\ ED(r,Ms). Thus, p 6\u2208 Mr \\ ED(r,Ms) holds. In addition, since ED(r,Ms) = Mr \u2229 Fr(Cr) \\ Ms, we have that Ms \u2229 ED(r,Ms) = \u2205. So, given that p \u2208 M\u0304s \u2286 Ms, we have that p 6\u2208 ED(r,Ms). It follows that p 6\u2208 (Mr \\ ED(r,Ms)) \u222a ED(r,Ms) = Mr. Now observe that Ms \u2286 Fr(Cr) (because of Fact 4.3), while Fr(Cr) \\ Cr \u2286 Mr. Then, since p 6\u2208 Mr and p \u2208 Ms, we conclude that p is in Cr. Thus, we can assume w.l.o.g that Y is in Fr(Cr). Since Y 6\u2208 Cr \u222a ED(r,Ms), because of the assumption that C \u2229 (Cr \u222a ED(r,Ms)) = \u2205 and the fact that Y \u2208 C, we conclude that Y \u2208 Fr(Cr) \\ Cr, i.e., Y \u2208 Mr. And, actually, Y \u2208 M \u2032r = Mr \\ ED(r,Ms), given that Y 6\u2208 ED(r,Ms). But, this is impossible, since Y \u2208 C\u2032r and C \u2032 r is an [M \u2032 r]-component. \u22c4\nIt follows that after the move M \u2032r = \u03c3 \u2032(Mp, Cp), the set of options available to the Robber is precisely the set that the Robber would have obtained with the move Mr. Then, because \u03c3\u2032 attacks these options precisely as \u03c3, we conclude that \u03c3\u2032 is still a winning strategy. \u2737\nExample 4.10 For an example application of the above lemma, consider Figure 7. The figure reports two hyperedges H1 and H2, plus the game-tree for a winning strategy \u03c3. In particular, note that \u03c3 is non-monotone, because the Robber is allowed to return on A and G, after that these nodes have been previously occupied by the Captain with the move Mr = {A,C,D,E,G}. In fact, the figure also reports the strategy \u03c3\u2032 that is obtained from \u03c3, by turning the non-monotone move of the Captain (in the left branch of the tree) into a monotone one according to the construction of Lemma 4.9.\nNote that the novel move of the Captain is M \u2032r = {C,D,E,G} = Mr \\ {A}, with {A} = ED(r\u2032, B, C) being the escape door for the Robber. In fact, this novel move does not affect the (winning) strategy of the Captain in the right branch. \u2701\nNow that the transformation from \u03c3 to \u03c3\u2032 has been clarified, we can state the main result of this section, which is based on the fact that minimal winning strategies have to be monotone. For a strategy \u03c3, let ||\u03c3|| be the size of \u03c3 measured as total number of cops used over all the vertices of T (\u03c3), i.e., ||\u03c3|| = \u2211\n(M,C)\u2208T (\u03c3) |M |. Let \u03c31 and \u03c32 be two winning strategies. We write \u03c31 \u227a \u03c32 iff ||\u03c31|| < ||\u03c32||. We say that a winning strategy \u03c3 is minimal, if there is no winning strategy \u03c3\u0304 such that \u03c3\u0304 \u227a \u03c3. Note that the existence of a winning strategy always entails the existence of a minimal winning one.\nTheorem 4.11 On the R&C(H1,H2) game, the existence of a winning strategy implies the existences of a monotone winning strategy.\nProof. We claim that minimal winning strategies must be monotone. Indeed, let \u03c3 be a non-monotone winning strategy and assume, for the sake of contradiction, that \u03c3 is minimal. Consider the transfor-\nmation from \u03c3 to \u03c3\u2032 discussed in the proof of Lemma 4.9, by recalling that \u03c3\u2032 is a winning strategy. Then, by definition of \u03c3\u2032 and the properties pointed out in that proof, we have that \u03c3\u2032 \u227a \u03c3, which is impossible. \u2737\nAs a remark, the transformation in the proof of Lemma 4.9 entails the existence of a constructive method to build a monotone strategy from a non-monotone one."}, {"heading": "4.2 Tree Projections and the R&C Game", "text": "In this section, we prove that the Robber and Captain game precisely characterizes the tree projection problem, in the sense that a winning strategy for R&C(H1,H2) exists if and only if (H1,H2) has a tree projection. Hence, any decomposition technique that can be restated in terms of tree projections is in turn characterized by R&C games. In particular, if we consider pairs of the form (H1,Hk1), we get a game characterization for the notion of k-width generalized hypertree decomposition, for which such a characterization was still missing in the literature.\nFor an exemplification of the results below, the reader may consider the game-tree illustrated in the bottom-right part of Figure 5 and the tree projection in Figure 3.\nTheorem 4.12 If there is a winning strategy in R&C(H1,H2), then (H1,H2) has a tree projection.\nProof. From Theorem 4.11, if there is a winning strategy in R&C(H1,H2), there exists a monotone winning strategy, say \u03c3, for this game. Based on \u03c3 we build a hypergraphHa(\u03c3) where, for each vertex (M,C) in T (\u03c3) with M 6= \u2205, edges(Ha(\u03c3)) contains the hyperedge M ; and, no further hyperedge is in edges(Ha(\u03c3)). Note that, by construction, Ha(\u03c3) \u2264 H2, since each position M is such that M \u2286 h2 for some hyperedge h2 \u2208 edges(H2). Let h1 be a hyperedge in edges(H1). Since \u03c3 is a winning strategy, we trivially conclude that the Captain has necessarily covered in a complete form h1 in some position. Thus, H1 \u2264 Ha(\u03c3). Eventually, in order to show that Ha(\u03c3) is a tree projection, it remains to check that Ha(\u03c3) is acyclic.\nTo this end, we build a tree JT by exploiting the strategy T (\u03c3). JT contains all the hyperedges in edges(Ha) and, for each pair of adjacent configurations (Ms, Cs) and (Mr, Cr) in T (\u03c3), the vertices Ms and Mr of JT are connected with an edge in JT . We claim that JT is a join tree for Ha(\u03c3). In the following, assume (for the sake of exposition) that JT is rooted at the hyperedge encoding the first move of the Captain (e.g., {E,F,G} in the game-tree depicted in Figure 5).\nNote first that by construction of JT and since \u03c3 is monotone, each vertex of JT has exactly one parent, but the root. Thus, JT is in fact an acyclic graph, and we have just to focus on showing that the connectedness condition is satisfied.\nLet h1 and h2 be two distinct vertices in JT and let X \u2208 h1 \u2229 h2. Let h be the vertex in the shortest path between h1 and h2 that is the closest to the root of JT . Assume, w.l.o.g., that h2 6= h and assume that h2 is a child of h\u2032. Because of Fact 4.3, h2 \u2286 Fr(Ch\u2032), where Ch\u2032 is the [h\u2032]-component such that (h,Ch\u2032) is in T (\u03c3) and where \u03c3(h,Ch\u2032) = h2. Thus, X \u2208 Fr(Ch\u2032). Assume, for the sake of contradiction, that X does not occur in a hyperedge in the path between h1 and h2, i.e., that the connectedness condition is violated. In particular, w.l.o.g., we may just focus on the case where X 6\u2208 h\u2032. Then, since h\u2032 \u2287 Fr(Ch\u2032) \\ Ch\u2032 , X \u2208 Fr(Ch\u2032) and X 6\u2208 h\u2032 immediately entail that X is in Ch\u2032 . Then, because of the monotonicity of \u03c3, X also occurs in an [h]-component Ch such that (h,Ch) \u2208 T (\u03c3). Now, observe that the scenario h1 = h is impossible. Indeed, h1 containsX that would be also contained in an [h1]-component, which is impossible by the monotonicity of the strategy. Thus, assume that h1 is the child of an edge h\u0304\u2032. By using the same line of reasoning as above, we conclude\nthat X occurs in an [h]-component C\u0304h such that (h, C\u0304h) \u2208 T (\u03c3). Thus, Ch = C\u0304h. By definition of JT , this means that h2 and h1 occur in a subtree rooted at some child of h, which is impossible since h is in the shortest path between h1 and h2. \u2737\nWe now complete the picture by showing the converse result.\nTheorem 4.13 If (H1,H2) has a tree projection, then there is a winning strategy in R&C(H1,H2).\nProof. Assume that (H1,H2) has a tree projection. From Fact 3.3, it has a minimal tree projection, say Ha. Let JT be a join tree for Ha in normal form (cf. Theorem 3.20), and let h be any hyperedge in edges(Ha).\nBased on JT , we build a strategy \u03c3 as follows. Let h0 = \u2205 and C0 = nodes(H1). The first move of the Captain is h. Recall from Section 3 that C\u22a4(hs) is the unique [hr]-component with nodes(JT [h]hs) = C\u22a4(hs) \u222a (hs \u2229 hr), where hs is a child of hr in JT [h] (with C\u22a4(h) be defined as nodes(Ha)). Given the current position (hp, Cp) and the current move hr, assume that the following inclusion relationship holds: for each [(hp, Cp), hr]-option Cr, Cr \u2286 C\u22a4(hr). Then, \u03c3(hr, Cr) is defined as the hyperedge hs that is the child of hr in JT [h] and that is such that Cr = C\u22a4(hs). It follows that the strategy \u03c3 is well-defined under this assumption, because such a hyperedge exists by Theorem 3.20. Now, note that we can set Cp = C\u22a4(hr) (for the first move, just recall that C\u22a4(h) = nodes(H1)).\nWe now show that the above inclusion relationship actually holds, that is, for each vertex hr of JT [h] and for each child hs of hr, we have C\u22a4(hs) \u2286 C\u22a4(hr). To see this is true, recall again by Theorem 3.20 that nodes(JT [h]hr) = C\u22a4(hr) \u222a (hr \u2229 hp) and nodes(JT [h]hs) = C\u22a4(hs) \u222a (hs \u2229 hr). Assume, for the sake of contradiction, that C\u22a4(hs) 6\u2286 C\u22a4(hr) and let X \u2208 C\u22a4(hs) \\ C\u22a4(hr). Since, nodes(JT [h]hs) \u2286 nodes(JT [h]hr), it follows that X \u2208 hr \u2229 hp. This is impossible, since C\u22a4(hs) is a [hr]-component, with X \u2208 C\u22a4(hs).\nFinally, to complete the proof just notice that the above also entails that \u03c3 is a monotone strategy, eventually covering all the nodes in H1, hence it is a winning strategy. \u2737"}, {"heading": "5 Applications and Conclusion", "text": "In this paper, we have analyzed structural decomposition methods to identify nearly-acyclic hypergraphs by focusing on the general concept of tree projections.\nWe defined and studied a natural notion of minimality for tree-projections of pairs of hypergraphs. It turns out that minimal tree-projections always exist (whenever some tree-projection exists), and that they enjoy some useful properties, such as the existence of join trees in a suitable normal form that is crucial for algorithmic applications. In particular, such join trees have polynomial size with respect to the given pair of hypergraphs. As an immediate consequence of these properties, we get that deciding whether a tree projection of a pair of hypergraphs (H1,H2) exists is an NP-problem. Note that this result is expected but not trivial, because in general a tree projection may employ any subset of every hyperedge of H2. In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].\nMoreover, we provided a natural game-theoretic characterization of tree projections in terms of the Captain and Robber game, which was missing and asked for even in the special case of generalized hypertree decompositions. In this game, monotone strategies have the same power as non-monotone\nstrategies. Even this result is not just of theoretical interest. Indeed, by exploiting the power of nonmonotonicity for some easy-to-compute strategies in the game, called greedy strategies, larger islands of tractability for the homomorphism problem (hence, for the constraint satisfaction problem and for the problem of evaluating conjunctive queries, and so on) have been identified in [21]. In particular, for the special case of generalized hypertree decompositions, these strategies lead to the definition of a new tractable approximation, called greedy hypertree decomposition, which is strictly more powerful than the (standard) notion of hypertree decomposition."}], "references": [{"title": "Marshals, monotone marshals, and hypertree-width", "author": ["I. Adler"], "venue": "Journal of Graph Theory,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Width Functions for Hypertree Decompositions", "author": ["I. Adler"], "venue": "PhD Thesis, University of Freiburg,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "Tree-Related Widths of Graphs and Hypergraphs", "author": ["I. Adler"], "venue": "SIAM Journal Discrete Mathematics,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Hypertree-Width and Related Hypergraph Invariants", "author": ["I. Adler", "G. Gottlob", "M. Grohe"], "venue": "European Journal of Combinatorics,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2007}, {"title": "On the Power of k-Consistency", "author": ["A. Atserias", "A. Bulatov", "V. Dalmau"], "venue": "In Proc. of ICALP\u201907,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "The power of natural semijoins", "author": ["P.A. Bernstein", "N. Goodman"], "venue": "SIAM Journal on Computing,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1981}, {"title": "A Linear-Time Algorithm for Finding Tree-Decompositions of Small Treewidth", "author": ["H.L. Bodlaender", "F.V. Fomin"], "venue": "SIAM Journal on Computing,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1996}, {"title": "A unified theory of structural tractability for constraint satisfaction problems", "author": ["D.A. Cohen", "P. Jeavons", "M. Gyssens"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "Tree clustering for constraint networks", "author": ["R. Dechter", "J. Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1989}, {"title": "Degrees of acyclicity for hypergraphs and relational database schemes", "author": ["R. Fagin"], "venue": "Journal of the ACM,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1983}, {"title": "Connected Treewidth and Connected Graph Searching", "author": ["P. Fraigniaud", "N. Nisse"], "venue": "In Proc. of LATIN\u201906,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2006}, {"title": "Complexity of K-tree structured constraint satisfaction problems", "author": ["E.C. Freuder"], "venue": "In Proc. of the 8th National Conference on Artificial Intelligence,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1990}, {"title": "A Comparison of Structural CSP Decomposition Methods", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "Hypertree decompositions and tractable queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2002}, {"title": "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2003}, {"title": "Generalized hypertree decompositions: NP-hardness and tractable variants", "author": ["G. Gottlob", "Z. Mikl\u00f3s", "T. Schwentick"], "venue": "Journal of the ACM,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Syntactic characterization of tree database schemas", "author": ["N. Goodman", "O. Shmueli"], "venue": "Journal of the ACM,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1983}, {"title": "The tree projection theorem and relational query processing", "author": ["N. Goodman", "O. Shmueli"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1984}, {"title": "Tree Projections: Hypergraph Games and Minimality", "author": ["G. Greco", "F. Scarcello"], "venue": "In Proc. of ICALP\u201908,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2008}, {"title": "Structural Tractability of Enumerating CSP Solutions", "author": ["G. Greco", "F. Scarcello"], "venue": "In Proc. of CP\u201910,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2010}, {"title": "Tree Projections and Structural Decomposition Methods: The Power of Local Consistency and Larger Islands of Tractability", "author": ["G. Greco", "F. Scarcello"], "venue": "CoRR Technical report available at http://arxiv.org/abs/1205.3321,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "The complexity of homomorphism and constraint satisfaction problems seen from the other side", "author": ["M. Grohe"], "venue": "Journal of the ACM,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2007}, {"title": "Constraint solving via fractional edge covers", "author": ["M. Grohe", "D. Marx"], "venue": "In Proc. of SODA", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2006}, {"title": "Acyclic hypergraph projections", "author": ["A. Lustig", "O. Shmueli"], "venue": "Journal of Algorithms,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1999}, {"title": "Tractable Hypergraph Properties for Constraint Satisfaction and Conjunctive Queries", "author": ["D. Marx"], "venue": "In Proc. of STOC\u201910,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2010}, {"title": "Graph minors III: Planar tree-width", "author": ["N. Robertson", "P.D. Seymour"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1984}, {"title": "Solving Queries by Tree Projections", "author": ["Y. Sagiv", "O. Shmueli"], "venue": "ACM Transaction on Database Systems,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1993}, {"title": "Graph searching and a min-max theorem for tree-width", "author": ["P.D. Seymour", "R. Thomas"], "venue": "Journal of Combinatorial Theory, Series B,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1993}, {"title": "Backtracking Procedures for Hypertree, HyperSpread and Connected Hypertree Decomposition of CSPs", "author": ["S. Subbarayan", "H. Reif Andersen"], "venue": "In Proc. of IJCAI\u201907,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}], "referenceMentions": [{"referenceID": 12, "context": ", from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs.", "startOffset": 10, "endOffset": 14}, {"referenceID": 5, "context": ", from AI [13] to Database Theory [6], are known to be efficiently solvable when restricted to instances whose underlying structures can be modeled via acyclic graphs or hypergraphs.", "startOffset": 34, "endOffset": 37}, {"referenceID": 13, "context": "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.", "startOffset": 246, "endOffset": 250}, {"referenceID": 22, "context": "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.", "startOffset": 273, "endOffset": 277}, {"referenceID": 7, "context": "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.", "startOffset": 290, "endOffset": 293}, {"referenceID": 15, "context": "several efforts have been spent to investigate invariants that are best suited to identify nearly-acyclic graph/hypergraphs, leading to the definition of a number of so-called structural decomposition methods, such as the (generalized) hypertree [14], fractional hypertree [23], spread-cut [8], and component hypertree [16] decompositions.", "startOffset": 319, "endOffset": 323}, {"referenceID": 17, "context": "Despite their different technical definitions, there is a simple mathematical framework that encompasses all purely structural decomposition methods, which is the framework of the tree projections [18].", "startOffset": 197, "endOffset": 201}, {"referenceID": 8, "context": "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.", "startOffset": 54, "endOffset": 61}, {"referenceID": 11, "context": "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.", "startOffset": 54, "endOffset": 61}, {"referenceID": 25, "context": "Consider, for instance, the tree decomposition method [9, 12], based on the notion of treewidth [26], which is the most general decomposition method over classes of graphs (see, e.", "startOffset": 96, "endOffset": 100}, {"referenceID": 12, "context": "g, [13, 22]).", "startOffset": 3, "endOffset": 11}, {"referenceID": 21, "context": "g, [13, 22]).", "startOffset": 3, "endOffset": 11}, {"referenceID": 18, "context": ", [19, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 19, "context": ", [19, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 24, "context": "1For the sake of completeness, observe that the only known structural technique that does not fit the general framework of tree projections is the one based on the submodular width [25], which is not purely structural.", "startOffset": 181, "endOffset": 185}, {"referenceID": 10, "context": ", on connected ones [11], that is, basically, on tree decompositions such that, for each set of connected vertices, the sub-hypergraph induced by the nodes covered in such vertices is connected in its turn.", "startOffset": 20, "endOffset": 24}, {"referenceID": 10, "context": "Again, connected decompositions provide us with a \u201cnormal form\u201d for decomposition trees, which can be exploited to restrict the search space of the possible decompositions and, thus, to speed-up their computation [11].", "startOffset": 213, "endOffset": 217}, {"referenceID": 28, "context": "Algorithms have been implemented limiting the search space to a kind of connected (generalized) hypertree decompositions [29], but it was left open whether the resulting method is a heuristic one or it does give an exact solution.", "startOffset": 121, "endOffset": 125}, {"referenceID": 27, "context": "(Q2) Is there a natural game-theoretic characterization for tree projections? Tree decompositions have a nice game-theoretic characterization in terms of the Robber and Cops game [28]: A hypergraph H has treewidth bounded by k if, and only, if k + 1 Cops can capture a Robber that can run at great speed along the hyperedges of H, while being not permitted to run trough a node that is controlled by a Cop.", "startOffset": 179, "endOffset": 183}, {"referenceID": 27, "context": "More precisely, playing non-monotone strategies gives no more power to the Cops [28].", "startOffset": 80, "endOffset": 84}, {"referenceID": 4, "context": ", [5]), this property turns out to be very useful, because good strategies for the Robber may be easily characterized as those strategies that allow the Robber to run forever.", "startOffset": 2, "endOffset": 5}, {"referenceID": 14, "context": "Hypertree decomposition is an efficiently recognizable structural method [15], which provides a 3approximation for generalized hypertree decompositions [4].", "startOffset": 73, "endOffset": 77}, {"referenceID": 3, "context": "Hypertree decomposition is an efficiently recognizable structural method [15], which provides a 3approximation for generalized hypertree decompositions [4].", "startOffset": 152, "endOffset": 155}, {"referenceID": 14, "context": "This method is also known to have a nice game-theoretic characterization, in terms of the (monotone) Robber and Marshals game [15], which can be viewed as a natural generalization of the Robber and Cops games.", "startOffset": 126, "endOffset": 130}, {"referenceID": 0, "context": "However, Marshals are now required to play monotonically, because non-monotone strategies give some extra-power that does not correspond to valid decompositions [1].", "startOffset": 161, "endOffset": 164}, {"referenceID": 14, "context": "[15], game theoretic characterizations for generalized hypertree width were still missing.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "In [1], it is raised the question about whether there is a (natural) game theoretic characterization for generalized hypertree width, where non-monotonicity does not represent a source of additional power.", "startOffset": 3, "endOffset": 6}, {"referenceID": 13, "context": ", [14]) are a consequence of minimality.", "startOffset": 2, "endOffset": 6}, {"referenceID": 15, "context": "In fact, this property has already been exploited in the NP-completeness proof of tree projections [16].", "startOffset": 99, "endOffset": 103}, {"referenceID": 28, "context": "\u25ee We give a negative answer to the question raised in [29] for (generalized) hypertree decomposition.", "startOffset": 54, "endOffset": 58}, {"referenceID": 28, "context": "Hence, the algorithm proposed in [29] for connected hypertree decompositions is not complete, as far as the computation of unrestricted decompositions is considered.", "startOffset": 33, "endOffset": 37}, {"referenceID": 9, "context": "A hypergraph H is acyclic (more precisely, \u03b1-acyclic [10]) if, and only if, it has a join tree [6].", "startOffset": 53, "endOffset": 57}, {"referenceID": 5, "context": "A hypergraph H is acyclic (more precisely, \u03b1-acyclic [10]) if, and only if, it has a join tree [6].", "startOffset": 95, "endOffset": 98}, {"referenceID": 25, "context": "A tree decomposition [26] of a graph G is a pair \u3008T, \u03c7\u3009, where T = (N,E) is a tree, and \u03c7 is a labeling function assigning to each vertex v \u2208 N a set of vertices\u03c7(v) \u2286 nodes(G), such that the following conditions are satisfied: (1) for each node Y \u2208 nodes(G), there exists p \u2208 N such that Y \u2208 \u03c7(p); (2) for each edge {X,Y } \u2208 edges(G), there exists p \u2208 N such that {X,Y } \u2286 \u03c7(p); and (3) for each node Y \u2208 nodes(G), the set {p \u2208 N | Y \u2208 \u03c7(p)} induces a (connected) subtree of T .", "startOffset": 21, "endOffset": 25}, {"referenceID": 6, "context": "Deciding whether a given hypergraph has treewidth bounded by a fixed natural number k is known to be feasible in linear time [7].", "startOffset": 125, "endOffset": 128}, {"referenceID": 14, "context": "A generalized hypertree decomposition [15] of a hypergraph H is a hypertree HD = \u3008T, \u03c7, \u03bb\u3009 for H such that: (1) for each hyperedge h \u2208 edges(H), there exists p \u2208 vertices(T ) such that h \u2286 \u03c7(p); (2) for each node Y \u2208 nodes(H), the set {p \u2208 vertices(T ) | Y \u2208 \u03c7(p)} induces a (connected) subtree of T ; and (3) for each p \u2208 vertices(T ), \u03c7(p) \u2286 nodes(\u03bb(p)).", "startOffset": 38, "endOffset": 42}, {"referenceID": 13, "context": "A hypertree decomposition [14] of H is a generalized hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 where: (4) for each p \u2208 vertices(T ), nodes(\u03bb(p)) \u2229 \u03c7(Tp) \u2286 \u03c7(p).", "startOffset": 26, "endOffset": 30}, {"referenceID": 3, "context": "Note that, for any hypergraph H, it is the case that ghw(H) \u2264 hw(H) \u2264 3\u00d7 ghw(H) + 1 [4].", "startOffset": 84, "endOffset": 87}, {"referenceID": 13, "context": "Moreover, for any fixed natural number k > 0, deciding whether hw(H) \u2264 k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) \u2264 k is NP-complete [16].", "startOffset": 149, "endOffset": 153}, {"referenceID": 15, "context": "Moreover, for any fixed natural number k > 0, deciding whether hw(H) \u2264 k is feasible in polynomial time (and, actually, it is highly-parallelizable) [14], while deciding whether ghw(H) \u2264 k is NP-complete [16].", "startOffset": 204, "endOffset": 208}, {"referenceID": 13, "context": ", [14]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 13, "context": "In particular, from the results in [14] (in particular, from Theorem 5.", "startOffset": 35, "endOffset": 39}, {"referenceID": 13, "context": "4 in [14]) it follows that, for each hyperedge h \u2208 edges(Ha), there is a width-1 hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 for Ha, where T is rooted at a vertex root(T ) such that \u03bb(root(T )) = {h} and, for each vertex r \u2208 vertices(T ) and for each child s of r, the following conditions hold: (1) there is (exactly) one [\u03c7(r)]-component Cr of Ha such that \u03c7(Ts) = Cr \u222a (\u03c7(s) \u2229 \u03c7(r)); (2) \u03c7(s) \u2229 Cr 6= \u2205, where Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1); and (3) hs \u2229Fr(Cr,Ha) 6= \u2205 holds, where {hs} = \u03bb(s) and Cr is the [\u03c7(r)]-component of Ha satisfying Condition (1).", "startOffset": 5, "endOffset": 9}, {"referenceID": 10, "context": ", [11]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 10, "context": "In order to establish the result, we shall exploit an algorithm, called make-it-connected, that has been described in [11] and that enjoys the following properties.", "startOffset": 118, "endOffset": 122}, {"referenceID": 10, "context": "[11]) Let \u3008T, \u03c7\u3009 be a width-k tree decomposition of a graph G.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "16 A different notion of connected decomposition has been introduced in [29] for the special case of (generalized) hypertree decompositions, in order to speed-up their computation.", "startOffset": 72, "endOffset": 76}, {"referenceID": 28, "context": "According to [29], a (generalized) hypertree decomposition HD = \u3008T, \u03c7, \u03bb\u3009 is connected if the root r of T is such that |\u03bb(r)| = 1, and for each pair of nodes p and s, with s child of p in T , and for each h \u2208 \u03bb(s), h \u2229 \u03c7(s) \u2229 \u03c7(p) 6= \u2205.", "startOffset": 13, "endOffset": 17}, {"referenceID": 28, "context": "Whether or not chw(H) = hw(H) for every hypergraph H was an open question [29].", "startOffset": 74, "endOffset": 78}, {"referenceID": 28, "context": "Indeed, the reader can check there is neither a hypertree decomposition nor a generalized hypertree decomposition of Ghex that is connected according to [29] and has width 3.", "startOffset": 153, "endOffset": 157}, {"referenceID": 14, "context": "For a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move.", "startOffset": 106, "endOffset": 110}, {"referenceID": 27, "context": "For a comparison, observe that this game is somehow in the middle between the Robber and Marshals game of [15], where the marshals occupy a full hyperedge at each move, and the Robber and Cops game of [28], where each cop stands on a vertex and thus, if there are enough cops, any subset of any edge can be blocked at each move.", "startOffset": 201, "endOffset": 205}, {"referenceID": 27, "context": "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].", "startOffset": 111, "endOffset": 115}, {"referenceID": 14, "context": "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].", "startOffset": 312, "endOffset": 316}, {"referenceID": 0, "context": "This crucial property conceptually relates our game with the Robber and Cops game characterizing the treewidth [28], and differentiates it from most of the hypergraph-based games in the literature, in particular, from the Robber and Marshals game, whose monotone strategies characterize hypertree decompositions [15], while non-monotone strategies do not correspond to valid decompositions [1].", "startOffset": 390, "endOffset": 393}, {"referenceID": 15, "context": "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].", "startOffset": 90, "endOffset": 94}, {"referenceID": 16, "context": "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].", "startOffset": 287, "endOffset": 303}, {"referenceID": 17, "context": "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].", "startOffset": 287, "endOffset": 303}, {"referenceID": 26, "context": "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].", "startOffset": 287, "endOffset": 303}, {"referenceID": 23, "context": "In fact, the results proved in detail in the present paper have been (explicitly) used by [16] in the membership part of the proof that deciding the existence of a tree projection is an NP-complete problem, which closed the long-standing open question about its computational complexity [17, 18, 27, 24].", "startOffset": 287, "endOffset": 303}, {"referenceID": 20, "context": "Indeed, by exploiting the power of nonmonotonicity for some easy-to-compute strategies in the game, called greedy strategies, larger islands of tractability for the homomorphism problem (hence, for the constraint satisfaction problem and for the problem of evaluating conjunctive queries, and so on) have been identified in [21].", "startOffset": 324, "endOffset": 328}], "year": 2012, "abstractText": "Tree projections provide a mathematical framework that encompasses all the various (purely) structural decomposition methods that have been proposed in the literature to single out classes of nearly-acyclic (hyper)graphs, such as the tree decomposition method, which is the most powerful decomposition method on graphs, and the (generalized) hypertree decomposition method, which is its natural counterpart on arbitrary hypergraphs. The paper analyzes this framework, by focusing in particular on \u201cminimal\u201d tree projections, that is, on tree projections without useless redundancies. First, it is shown that minimal tree projections enjoy a number of properties that are usually required for normal form decompositions in various structural decomposition methods. In particular, they enjoy the same kind of connection properties as (minimal) tree decompositions of graphs, with the result being tight in the light of the negative answer that is provided to the open question about whether they enjoy a slightly stronger notion of connection property, defined to speed-up the computation of hypertree decompositions. Second, it is shown that tree projections admit a natural game-theoretic characterization in terms of the Captain and Robber game. In this game, as for the Robber and Cops game characterizing tree decompositions, the existence of winning strategies implies the existence of monotone ones. As a special case, the Captain and Robber game can be used to characterize the generalized hypertree decomposition method, where such a game-theoretic characterization was missing and asked for. Besides their theoretical interest, these results have immediate algorithmic applications both for the general setting and for structural decomposition methods that can be recast in terms of tree projections.", "creator": "LaTeX with hyperref package"}}}