{"id": "1302.4985", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Feb-2013", "title": "A Polynomial Algorithm for Computing the Optimal Repair Strategy in a System with Independent Component Failures", "abstract": "In a decision-making framework, a good repair strategy has low expected costs. In a general formulation of the problem, the calculation of the optimal (lowest expected cost) repair strategy for a system with multiple failures is insoluble. In this paper, we consider an interesting and natural limitation of the behavior of the system to be diagnosed: (a) the system displays faulty behavior when and only when one or more components are faulty. (b) The faults of the system components are independent. In view of this limitation of system behavior, we develop a polynomic time algorithm to calculate the optimal repair strategy. Then, we introduce a system hierarchy and the presentation of testing (testing) of components prior to repair. We develop a linear time algorithm to calculate an optimal repair strategy for the hierarchical system that includes both repair and inspection.", "histories": [["v1", "Wed, 20 Feb 2013 15:23:48 GMT  (291kb)", "http://arxiv.org/abs/1302.4985v1", "Appears in Proceedings of the Eleventh Conference on Uncertainty in Artificial Intelligence (UAI1995)"]], "COMMENTS": "Appears in Proceedings of the Eleventh Conference on Uncertainty in Artificial Intelligence (UAI1995)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["sampath srinivas"], "accepted": false, "id": "1302.4985"}, "pdf": {"name": "1302.4985.pdf", "metadata": {"source": "CRF", "title": "A polynomial algorithm for computing the optimal repair strategy in a system with independent component failures", "authors": ["Sampath Srinivas"], "emails": ["srinivas@cs.stanford.edu"], "sections": [{"heading": null, "text": "1 INTRODUCTION\nThe goal of doing diagnosis is to recommend good re pair and maintenance actions in response to inferences about the state of the system. A repair strategy is a set of situation-action rules. The situations are the various possible observations and the actions are re pair actions in response to these observations. In a decision theoretic framework, the goal is to compute repair strategies which have low expected cost. The investigation of methods for computing optimal (i.e., lowest cost) repair strategies is thus of great interest. The computation of the optimal repair strategy in a general formulation of the repair problem is intractable (see for example, [Beckerman et al, 1995] for a discus sion). In this paper, we set up an interesting restricted formulation of the repair problem in a system with\nmultiple faults. The primary restriction is an assump tion about how the system behaves - the system is assumed to exhibit faulty behavior if and only if one or more components have failed. Component failures are assumed to be independent. For example, in mod eling a car, it may be reasonable to assume that the car runs normally iff both the fuel delivery subsystem and the ignition subsystem function normally. Further, one might assume that the failures of these subsystems are independent.\nWe analyze this restricted formulation of the repair problem and develop a polynomial time algorithm to compute the optimal repair strategy. At this point in the development, a strategy specifies a sequence in which the subsystems are to be repaired. Thus, the op timal strategy, for example, may specify that the fuel delivery system be repaired before the ignition system.\nWe then introduce a notion of hierarchy into our for mulation and extend the polynomial algorithm men tioned above to compute optimal repair strategies for hierarchical systems. Extending the car example, one could model the fuel delivery subsystem as consisting of the fuel pump and carburetor. Say the fuel sub system works iff both these subcomponents work nor mally. A hierarchical repair strategy specifies, as be fore, the sequence in which the fuel delivery and igni tion subsystems should be repaired. Further, for each subsystem it specifies the order in which its subcom ponents should be inspected and repaired. Thus the strategy may specify that the fuel pump be inspected and repaired before the carburetor.\nThis paper is structured as follows: In the next sec tion, we describe our repair model in more detail. We then derive a condition for a repair strategy to be op timal in the general case where the component failures may be correlated. When the component failures are independent, we show that this optimality condition has a simple form. This simple form allows the opti mal strategy to be computed in polynomial time with a simple sorting procedure.\nUp to this point, the only kind of repair action that is allowed is the replacement of components. We now go on to introduce another class of repair actions, viz,\n516 Srinivas\ncomponent inspections. A component inspection tests whether a component is working or not. Following this, we generalize the notion of a system and intro duce a system hierarchy. The optimality condition mentioned above is then used to develop a linear time algorithm for computing the best hierarchical repair strategy for a hierarchical system. A hierarchical re pair strategy includes both inspection and component replacement actions. We conclude by examining re lated work.\n2 DEFINING THE PROBLEM\nConsider a system with n components C;, 1 $ i $ n, for which we want to develop good repair strategies. Say each component can be either be in an ok state ( ok) or broken state (b) . The state of C; is represented by a mode variable M;. Say we are given some joint distribution P( M1, M2, \u2022 . . , Mn) of the mode variables. In addition, we are given a repair cost c; for each com ponent C;. After a component is repaired we assume that it is in the ok state. The cost c; can also be interpreted as the cost of replacing C;.\nWe assume that the system works normally only if all the components are in the ok state. If any of the com ponents are in the b state the system exhibits a fault. The system status X is assumed to be observable. If X = ok then it means the system is working normally. If X = b it means the system is broken (i.e., exhibiting a fault).\nSay the repair protocol is as follows - we will observe the system status X0 before we choose any fix action. If X0 = ok we stop. If Xo = b, then we choose to fix some component c1 and then observe the system status x1. If x1 = ok we stop. If x1 = b we continue, choosing some other component c2 to fix and so on. We will refer to the action of fixing Cj as fixi. A repair strategy is a sequence in which to examine components in the repair protocol described above.\nConsider a strategy T = (C1, C2, C3, ... , Cn). Say that the first k - 1 components have been repaired accord ing to strategy T and the system is still faulty. We will refer to the sequence of observations and actions up to this point as Sk-1\u00b7 Hence, Sk-1 = (Xo = b, fix1, X1 = b, fix2, X2 = b, ... , fixk-1, Xk-1 =b). After observing Sk-1 the next step is to replace Ck at a cost of Ck 0 Further, if we replace ck and the system is still faulty we replace ck+1 incurring cost Ck+1\u00b7 This event occurs with a probability P(fixk, Xk = biSk-1) \u00b7 We can thus compute the expected cost EC(T) of the strategy T as:\nEC(T) P(So)[c1 + P(fix1, X 1 = biSo )[c2 + P(fix2, X2 = biSt)[c3 +\n(1)\n+P(fixn-1, Xn-1 = biSn-2)cn . .. ] . .. ] ] ]\nWe note from the definition of Sk that Sk (Sk-1, /ixk, Xk =b). Hence we have:\nP(fixk> Xk = biSk-1)P(Sk_t) = P(Sk-1, fixk, Xk =b)= P(Sk)\nUsing this result repeatedly in Equation 1 we find that the expression telescopes to:\n2.1 AN EXPRESSION FOR P(Sk)\n(2)\nLet a world be a state assignment to all the mode variables of the system. Consider the worlds which are inconsistent with the observation Sk = (Xo = b, fix1, X1 = b, fix2, X2 = b, ... , fixk, Xk = b). A world w is inconsistent with sk iff the observation sk could not have occurred if the true state of the system was w.\nWe see that the worlds inconsistent with Sk are exactly those worlds w in which all the components which have not yet been fixed are in the ok state. The reason is as follows. If any of the worlds w had been the true situation, then we know that the broken components are some subset of { C; II $ i $ k}. Hence the re pair sequence (C 1 , C2, ... , Ck) would necessarily have resulted in Xj = ok for some j $ k (when all the broken components were fixed). Since such an obser vation is inconsistent with sk, we conclude that w is inconsistent with sk 0 By a similar line of argument, we can conclude that any world in which at least one of the remaining unfixed components is broken is consistent with sk. The total probability mass of the worlds in which all of Ck+1 , Ck+2, ... , Cn are in the ok state is P(Mk+l = ok, Mk+2 = ok, ... , Mn = ok). Hence P(Sk) = 1-P(Mk+1 = ok, Mk+2 = ok, ... , Mn = ok). We will use the notation M[i,j) = ok as a short form for (M; = ok, Mi+1 = ok, ... ,Mj = ok). Hence, Equa tion 2 simplifies to:\nEC(T) = :El:Sk:Sn Ck X [1- P(M[k,n] = ok)] (3)\n3 THE OPTIMALITY CONDITION\nWe will now derive a condition under which a strategy is optimal (i.e, has the lowest possible expected cost). Consider a strategy Ti = (C1, C2, . . . Cj, Cj+l\u2022 . . . , Cn}. Let Ti+1 be identical to Ti except that the po sitions of the Cj and Cj+l are transposed in t\ufffde se quence. We compare the expected costs of T3 and Ti+1. We have:\nEC(Ti) - EC(Ti+1) = (cj[l- P(M[j,n] = ok)] +\n(4)\nCj+1(1- P(M[j+l,n] = ok)J)\n-(cj+l[1- P(M[i,n] = ok)] + Cj[1- P(Mi = ok, MLi+2,n] = ok)])\nStrategy Ti is less expensive that Ti+1 if EC(Ti) EC(Ti+1) ::; 0. Let us use the notation Rok for the event MLi+2,n] = ok. Simplifying Equation 4 the con dition EC(Ti) - EC(Ti+1 ) ::; 0 simplifies to:\nCj[P(Mi = ok,Rok)P(Mj = ok, Mj+l = ok, Rok)]\n::; Cj+l[P(Mj+l = ok, Rok)P(Mi+l = ok, Mi = ok, Rok)] (5)\nThus, given a distribution P(M1, M2, ... , Mn) and a strategy T, we can check whether the strategy is a (lo cal) optimum by checking whether Equation 5 holds for adjacent components in the strategy. If the con dition does hold for every pair of adjacent compo nents the strategy is a local optimum. That is, ex changing the order of any two adjacent components in the strategy will always lead to a strategy with in creased cost. Note that computation of the probabil ities needed in Equation 5 from the joint distribution P(M1, M2, ... , Mn) can be expensive. We will see, however, that the optimality condition takes a simple form when the failures of the components are indepen dent.\n3.1 A SANITY CHECK: THE SINGLE FAULT CASE\nWe have derived the above condition assuming a gen eral distribution P(M1, M2, ... , Mn) \u00b7 We now show that if we enforce a single fault assumption, Equation 5 reduces to the optimality condition of [Kalagnanam & Henrion, 1988] (see Section 7). They prove that in the case of a single fault, the optimal strategy replaces components in increasing order of the ratio \ufffd where c; is the cost of replacement of C; and Pi is the prior probability that C; is faulty.\nConsider a single fault distribution. There are only n possible worlds. Let these worlds be w1, w2, ... , Wn. w; is the world in which M; is in the b state and all the other Mj (i.e., j =F i) are in the ok state. Let the probability of world w; be p;. That is, the probability that C; is the (only) faulty component is p;. Consider the probability P(Mj = ok, Rok) in Equa tion 5. The worlds consistent with (Mj = ok, Rok) are w1, w2, . . . , Wj-1 and wi+l\u00b7 Hence P(Mi = ok, Rok) = p::;[l\ufffdi\ufffdj-l]Pi)+Pi+l\u00b7 Call the quantity (:E[l\ufffdi\ufffdi-l]Pi) as Pprev. We have:\nP(Mi = ok, Rok) = Pprev + Pi+l\nUsing a similar line of reasoning:\nP(Mj = ok, Mj+l = ok, Rok) = Pprev\nHence the first term of Equation 5 reduces to Cj [(Pprev + Pi+d- Pprev] = CiPi+l\u00b7 Symmetrically, the second term reduces to Cj+lPi. This simplifies Equa tion 5 to the result in [Kalagnanam & Henrion, 1988]:\nCi < Cj+l Pi Pi+l\nIn this special case, a strategy which satisfies the con dition for every pair of adjacent components is globally optimal.\n4 INDEPENDENT FAULTS\nSay that each component C; can fail independently with probability Pi\u00b7 That is, P(Mi = b) = Pi\u00b7 We de rive a simplification of the optimality condition (Equa tion 5) for this case.\nConsider the first term of Equation 5. In this special case of multiple independent faults we have P(Mi = ok, Rok) = P(Mj = ok)P(Ro k) = (1 - Pi )P(Rok) \u00b7 Similarly P(Mi = ok, Mi+l = ok, Rok) = (1- Pi )(1- Pi+dP(Rok) . The first term of Equation 5 hence becomes P(Rok)c;[(1- Pi)Pi+ll\u00b7 Symmetrically, the second term of Equation 5 becomes P(Rok)cHI[(1Pi+l)P;]. Hence Equation 5 reduces to:\n1- Pi 1- Pi+l Cj -- ::; Cj+ 1 _ ___.:.....;._ Pi Pi+l\n(6)\nFrom this result we note that we can compute the glob ally optimal strategy by sorting the components i by the quantity (c; 1;? ) . For an n component system, this can be done in 0( n log n) . We get an expression for the expected cost of any strategy (including the optimal strategy) by simpli fying Equation 3 for the case of multiple independent faults. This gives:\nEC(T) = E19\ufffdn Ck X (1- Ilk\ufffdi\ufffdn(1 - p;)] (7)\n5 INTRODUCING COMPONENT INSPECTION\nIn the discussion so far, we have assumed that the only kind of action that is allowed is the replacement of a component. We now introduce the notion of inspect ing a component. Inspection of a component Ci deter mines what state it is in. Hence, if we inspect Ci and find that it is in the ok state, we do not have to take any further action to to fix the component. Carrying out the inspection of Ci costs di. This cost is speci fied by the user. We note that di ::; c;. If this was not the case there would no incentive to inspect the component - we could always replace it at less cost.\nNow say that Ci has been inspected and found to be broken. In that case, we will assume that it can be repaired incurring cost Hi. This cost is specified by the user. Note that H; ::; c;. If this was not the case,\nwe would always replace the component rather than repair it incurring cost H;. Say we want to find an optimal strategy for repair un der these conditions. A strategy specifies an order in which to repair the components (as before). In addi tion, for each component it also specifies whether the component is to be inspected before repair or not. An optimal strategy is the strategy with least expected cost.\nConsider a strategy Ii'::s = ( [C1, rep], [C2, rep], . .. , [Cm, ins], . . . , [Cn, rep] ). The notation ins says that the associated component is to be inspected. The no tation rep says that the associated component is to be simply replaced without inspection. Note that T;'::s specifies that all components except Cm be replaced without inspection. Cm alone is inspected before it is repaired. We now compute the expected cost of strat egy Ii'::s \u00b7 The cost of 7i'::s can be computed by simply replacing Cm in Equation 1 by dm +P(Mm = bJSm-1)Hm. That is, instead of the replacement cost Cm we have to pay the inspection cost dm. In addition, if component m is indeed broken we have to pay cost H m. The probabil ity that we will find that m is broken after inspection is P(Mm = bJn) where n is the current state of informa tion. n includes all observations up to the replacement of Cm-1 and the subsequent observation that the sys tem is still not functioning (i.e., Xm-1 = b). Hence n = Sm-1\u00b7 Simplifying Equation 1 gives us:\nEC(T;'::,) [\ufffd1\ufffdj<m Cj X P(Sj-1)] (8) +dmP(Sm-d + [\ufffdm<j\ufffdn Cj X P(Sj-1)] +HmP(Mm = b, Sm-1)\nConsider the probability P(Mm = b, Sm-1)\u00b7 We saw before that the worlds inconsistent with Sm-1 are those worlds in which the remaining unrepaired components, Cm, Cm+1, . . . , Cn are all in the ok state. Note that Mm = b is inconsistent with all of these worlds. Hence the set of worlds consistent with Mm = b (call the set W1) is a subset of the set of worlds consistent with Sm-1 (call this set W2). As a result, we have:\nP(Mm = b, Sm-d P(W1 n W2) = P(Wl)\nP(Mm = b)\nHence the trailing term in Equation 8 reduces to HmP(Mm = b). Note that this term is not depen dent on the position of Cm in the repair sequence. In general, if we are given a strategy Tp where some subset P of the components are inspected we can come up with an expression for the cost as follows. Start\nwith the expression for the case where you assume ev ery element in the strategy Tp is replaced without in spection (i.e., start with Equation 2). In this expres sion, replace Cj by dj for each component j which is in P, For each such component j, also add a trailing constant term HjP(Mj =b). We now consider how we might compute an optimal strategy given a subset of components P to be in spected. We will assume that the component failures are independent. We note that given any strategy Tp which inspects just the components in P, the expres sion for the cost consists of two parts. One part is similar to Equation 2. The other part consists of con stant terms of the type HjP(Mj = b) where j E P. The latter part is unaffected by the order in which the components appear in strategy Tp.\nTherefore to find the optimal strategy T}fin we have to only minimize the first part of the cost expression. Since the component failures are independent, we can directly apply Equation 6 to find the optimal sequence in which to repair the components. This sequence sat isfies:\nwhere:\nd 1 -Pi < d 1 - Pi+l c j-- - c j+l Pi Pi+1\ncd\u00b7 = 3 { d\u00b7 J Cj if j E P if j \ufffd p (9)\nGiven the optimal strategy T?in the optimal repair cost can be computed as:\nEC(TPin) = (10) \ufffd19\ufffdn Cdk X [1- llk9\ufffdn(1- p;)] +\ufffdc.EPH;P(M; = b)\nThus, given a subset P of components which are to be inspected, we can compute an optimal strategy and its cost in O(n log n).\n5.1 THE GLOBALLY OPTIMAL STRATEGY\nSay we consider every possible subset P of the set of components and compute T?in. The cheapest of all these strategies is necessarily the globally optimal strategy Topt. Thus, if there are n components we can compute Topt in 0( ( n log n )2n). This, of course, is practical only when n is small. However, our intent is to use this result for computing optimal strategies for hierarchical systems. As we shall see below, in that context, n is indeed small.\n5.2 THE CONDITIONAL EXPECTED COST OF REPAIR\nNote that the expected cost EC in Equation 10 is the overall expected cost. This cost is computed assuming that no observations have been made of the system as yet. In particular, it is not yet known whether the system is faulty.\nConsider instead the expected cost given that that we know the system is faulty. This expected cost esti mate will be needed later when computing optimal hi erarchical repair strategies. For any strategy T, let ECf (T) denote the expected cost of repair given that we know the system is faulty. Note that the obser vation \"System is faulty\" is exactly 50 = (Xo = b) (see Section 2). We see that EC(T) and ECf (T) are related as follows:\nEC(T) = P(Xo =b) x ECf (T) + P(Xo = ok) x 0\nHence:\nECf(T) EC(T)\nP(Xo = b) EC(T) P(So)\nEC(T) 1- P(M[l,n] = ok)\n(11)\nNote that for any strategy T, ECf (T) and EC(T) are related by the constant\nl-P(M\ufffdl,nJ=ok). Thus, the\nstrategy yopt with the lowest possible value of EC is also the strategy with the lowest value of ECf.\n6 HIERARCHY\nHierarchical systems are widely used in engineering practice. Hierarchies serve two purposes - they make modeling easier by separating the system into compos able subsystems. In addition, an algorithm that oper ates on a system model to compute some property of interest can often be modified to exploit the hierarchy to give computational gains. We will first present a generalization of our system repair problem for hier archical systems. We will then develop a hierarchical version of the optimal repair strategy algorithm. The hierarchy is exploited to make the algorithm tractable.\nWe begin by defining a hierarchical model. A hier archical component model consists either of an atomic model or a subcomponent model.\nIf the component C is modeled atomically, we specify a probability of failure of the component p, a cost of replacement c and a cost of inspection d. If the component C is modeled as consisting of sub components, we do the following:\n1. Specify hierarchical models (recursively) for each of the subcomponents c: of C.\n2. Specify a cost of replacement c of C and an in spection cost d.\nWe assume that a component works normally iff all its subcomponents are working normally. In other words, a component is in the ok state iff all its subcompo nents are in the ok state. If any of the subcomponents are in the broken state the component is assumed to be in the broken state. Note that the probability of failure of the component can easily be computed from the subcomponent probabilities. Also, note that the top level component in the hierarchy represents the entire system. A hierarchical system model is simply the hierarchical component model for this top level component. Figure 1 is an example of a hierarchical system model. The tree in the figure represents the hierarchy tree of the system. Each node represents a component. The replacement cost and inspection cost of each component are marked next to it. In addi tion, the prior probability of failure for each of the leaf level components is also specified. Note that the prior probability of failure of the non-leaf components in the hierarchy tree can be computed from the probabilities at the leaves.\nWe now define a hierarchical repair plan. A hierar chical repair plan for a component specifies an action that will repair a component if it has been observed and found to be broken. The action specified is either:\n\u2022 Replacement of the entire component.\nor\n\u2022 A strategy for repair of the subcomponents. As we saw before, a strategy specifies an order in which to repair the subcomponents. In addition, it specifies whether each subcomponent is to be inspected before repair or not.\nIf a strategy specifies that a subcomponent is not to be inspected before repair, it is simply replaced. If a strategy specifies that the subcomponent is to be inspected then the inspection procedure of the sub component is carried out before it is repaired. If the result of the inspection is that the subcomponent is ok then the subcomponent needs no further attention.\nIf the result of the inspection is that the subcompo nent is broken, then the subcomponent is repaired ac cording to a hierarchical repair plan specified for the\nsubcomponent. A hierarchical repair plan for a com ponent thus includes the specification of a hierarchical repair plan for each of the subcomponents that are inspected by the plan.\nFigure 2 is a possible hierarchical repair plan for the system. This plan specifies that if the system A is known to be faulty we first repair E after inspection and then, if A is still faulty, replace B without inspec tion.\nThe repair of E proceeds as follows: If E is found to be faulty after inspection we first repair F after inspec tion and then, if E is still faulty, replace I without inspection. IfF is found to be faulty after inspection we first repair H after inspection and then, ifF is still faulty, replace G without inspection. If H is found to be faulty after inspection it is replaced.\nAn optimal hierarchical repair plan for a component is the hierarchical repair plan with least expected cost. An optimal hierarchical system repair plan is simply the optimal hierarchical component repair plan for the top level component in the hierarchy tree. The repair plan shown in Figure 2 is also the optimal repair plan for the system.\n6.1 COMPUTING THE OPTIMAL HIERARCHICAL PLAN\nWe will now describe a way of computing the op timal hierarchical repair plan for a component from the optimal hierarchical repair plans of its subcompo nents. This procedure can then be used in a bottom-up traversal of the hierarchy tree to compute the optimal hierarchical system repair plan.\nSay component C has k subcomponents Cf, c;, . .. , CA,. The replacement cost of the component is c. Say the optimal hierarchical plan for each subcomponent c: has already been computed and the cost of the plan\nis Hf.\nWe first compute an optimal strategy yopt in which to fix the subcomponents Ci. As we saw in Section 5.1, the optimal strategy yopt and its cost EC(Topt) can be computed in O((k log k)2k). The computation takes into account the optimal hierarchical repair cost Hf, the inspection cost d: and the replacement cost cf for each of the subcomponents Cf.\nThe cost estimate EC(Topt) is the cost estimate for repairing C given no evidence. Consider the situation where C has been inspected and found to be broken. In this case, the cost estimate needs to be conditioned on this knowledge. As we saw in Section 5.2, the con ditional cost estimate ECi (Topt) is given by:\nEC(Topt) 1- P(M[l,n] = ok)\nEC(Topt)\nThe optimal hierarchical plan specifies the optimal re pair action (and accompanying cost) for a component given that it is broken. The two possible actions are: (a) replacement of the component and (b) repair of subcomponents. We can choose the better of the two options by simply comparing the replacement cost c and the optimal cost ECi (T0Pt) of repairing subcom ponents.\nIf c \ufffd ECf(yopt), then the optimal hierarchical repair plan for the component C is to simply replace it if it has been found to be broken. The cost of the optimal hierarchical component repair plan in this case is c. If we find that ECf (Topt) > c then the optimal hierar chical repair plan is to follow strategy yopt. The cost of the hierarchical component repair plan for component C in this case is ECi(T0Pt).\nWe note that we can compute the optimal hierarchical system repair plan by working up from the leaves of the hierarchy tree while computing the optimal compo nent repair plan for each component. Say each compo nent in the system can have at most k subcomponents. Let us suppose the system has n leaf level components in all. A tree with a branching factor of k with n leaf nodes has 0( n) nodes in the tree (including leaf nodes). So the complexity of computing the optimal hierarchical repair plan is O(n(k log k)2k). Hence, for a fixed k, the optimal hierarchical repair plan can be computed in O(n).\nWe have implemented the algorithm in Common Lisp. For testing purposes, we have also have implemented a random system generator that creates a system hier archy with a user specified branching factor and a user specified tree depth. The repair costs, inspection costs and failure probabilities are chosen randomly from user specified intervals. The time taken to compute optimal repair strategies for systems of various sizes are shown in Table 1. The optimal policy for a system with a branching factor of 5 and a tree depth of 5 (i.e., with\n3125 leaf level components) can be computed in about 5 seconds. Thus the algorithm scales well to systems with thousands of components.\n7 DISCUSSION\nIn a general formulation of the repair problem, the pre-computation of an optimal repair strategy is in tractable. The reason is that in a general formula tion, there are no restrictions on the kind of system modeled. Since there is no special structure that we can take advantage of, we are reduced to considering each possible strategy in a combinatorial space of re pair strategies to compute the optimal strategy.\nThere are two classes of approaches used to address this tractability problem. The first is to make some restricted formulation of the repair problem which still applicable in some domain of interest. The properties of the restricted formulation can then be exploited to develop tractable algorithms to compute repair strate gies. The work in this paper falls into this class. In the second class of approaches, the diagnosis/repair prob lem is formulated as an interactive process. At each stage of the process, an action that is to be carried out immediately is chosen with a greedy heuristic or limited lookahead. The chosen action is then carried out and this leads to new information being obtained. This information is used to compute the next action to be carried out.\n[Kalagnanam & Henrion, 1988] derive an optimality condition for the optimal repair strategy in a multi component system which is assumed to have a single fault. The repair protocol is similar to the one de scribed in this paper with the exception that only com ponent replacements are allowed. There is no notion of inspection of components. Our work generalizes their result to the case of multiple independent failures. It also introduces a formulation of component inspection and extends the scope of the algorithm to hierarchical systems.\n[Beckerman et al, 1995] formulate repair as an inter active process. The system is modeled with a Bayesian network and both component replacement and infor mation gathering actions are possible. An action is chosen at each step of the process with a myopic\nheuristic. The heuristic computes the least cost ac tion to take next assuming that the current fault in the system is a single fault. The restricted system be havior we have proposed in this paper corresponds to a restricted form of Bayesian network in their frame work. When no component inspections1 are allowed we have developed a polynomial time algorithm for computing the optimal strategy. This algorithm is thus a tractable solution to a special case of the prob lem attacked by [Beckerman et al, 1995]. The optimality result of Equation 6 is potentially ap plicable within their framework as an improved heuris tic for choosing actions myopically. Instead of assum ing a single fault the improved heuristic would allow for multiple faults.\nThe work in the model-based diagnosis community ([Hamscher et al, 1992]) has also addressed the re pair problem as an interactive process. [deKleer & Williams, 1987] introduce an entropy based method for observation planning. [Friedrich & Nejdl, 1992] develop a set of greedy algorithms for choosing obser vation and repair actions in interactive model-based diagnosis. Their approach explicitly considers down time costs in case of unanticipated failure. Hence their repair scheme implicitly includes a notion of preven tive maintenance. [Poole & Provan, 1991] use repair actions to partition the world into a set of classes. All the worlds in a class result in the same action re sponse. The diagnosis problem now becomes one of determining which class the current state of the sys tem falls into. The action response can then be looked up. [Yuan, 1993] proposes a decision theoretic frame work for modeling interactive model-based diagnosis. At each step of the diagnosis a decision model in the form of an influence diagram is synthesized and solved to compute the next action. The model is successively refined along the system hierarchy using a single fault assumption until the fault is located. Our formulation of repair in this paper is more restricted than in any of these model-based approaches.\n[Srinivas & Horvitz, 1995] develop a formulation of model-based diagnosis in hierarchical systems and de velop a linear time algorithm for pre-computation of an optimal repair strategy. A particular repair protocol is assumed: Repair begins when the system exhibits an anomalous output for some input. The repair pro cess consists of successively repairing components of the system until the output is no longer anomalous for the same input. The hierarchy is exploited to gain tractability when computing the optimal-repair strat egy. The algorithm is tractable if the branching factor of the system hierarchy is small. The hierarchical al gorithm we have developed in this paper addresses a special case of this general formulation. The constant in the linear time algorithm for this special case is far smaller than the constant in the general formulation.\n1Called component observations in their paper.\n522 Srinivas\n7.1 DEPENDENT FAULTS\nThis paper has concentrated on the situation where component failures are independent. Note however that the optimality condition (Equation 5) applies in the general case where the component failures may be dependent.\nConsider the situation where a model for the depen dencies between the failures of the components is avail able in the form of a Bayesian network B. Thus, B is a model for P(M1, M2, ... , Mn)\u00b7 The optimality condition of Equation 5 can be simplified to:\nCj[P(Mj = ok I Rok)P(Mj = ok, Mi+l = ok I Rok)]\n< Cj+l[P(Mj+l = ok I Rok) - P(Mi+l = ok, Mj = ok I Rok)] (12)\nGiven a repair sequence T we can check whether the condition holds at the position j as follows. Declare evidence Rok (i.e., M(.j +2,n] = ok) in the network B. Do a network inference and look up the probabilities P(Mj = ok I Rok) and P(Mi+l = ok I Rok)\u00b7 Sub sequently declare additional evidence Mj = ok and do another network inference to compute P(Mi+l = ok I Mj = ok, Rok)\u00b7 Note that the probability P(Mj = ok, Mj+l = ok I Rok) can now be computed as:\nP(Mj = ok, Mj+l = ok I Rok) = P(Mi+l = ok I Mj = ok, Rok)P(Mj = ok I Rok)\nWe now have the quantities required to check whether the condition holds. Thus the verification of the op timality condition at any point in the sequence T can be accomplished with 2 network inferences.\nIf the optimality condition does not hold at position j, flipping the position of Ci and Cj +l will lead to a better repair sequence. If we consider doing this repeatedly till quiescence is reached then the resulting sequence will be a local optimum. A good starting sequence might the sequence rind computed assuming that the component failures are independent. This can be done by initially doing network inference with no evidence in the network. That gives us the priors Pi = P( M; = b) for every node in the network and thus the sequence sorted by increasing order of c; 1;r\u2022 can be computed. However, certain questions still need to be addressed. Firstly, it is not clear that the sequence produced at quiescence is necessarily the global optimum. The sec ond question is whether the number of network prop agations required is tractable in the worst case.\nWith regard to the second question: the first naive estimate is that the number of propagations is O(n!) since there are only n! sequences. However, we can observe from the structure of Equation 3 that if k components have been fixed then the optimal repair sequence of the remaining n - k components does not depend on the order in which the first k components were fixed. This allows dynamic programming to be\nused to construct a scheme which will compute the optimal strategy with 0( n2n) network propagations. This is still exponential.\nOur speculation is that we cannot do better without more structure (for eg, specific network topologies) in the problem. A promising direction seems to be to adapt an exact algorithm for computation of the op timal strategy in the case of dependent faults to have limited lookahead and anytime characteristics. We plan to look into these topics in the future.\nReferences\n[ deKleer & Williams, 1987] deKleer, J. and Williams, B. (1987) Diagnosing Multiple Faults. Artificial Intelligence, 32:97-130.\n[Friedrich & Nejdl, 1992] Friedich, G. and Nejdl, W. (1992) Choosing observations and actions in model based diagnosis/repair systems. In The third Inter national Workshop on principles of diagnosis, Oc tober 1992.\n[Hamscher et a/, 1992] Hamscher, W., Console, L., and deKleer, J. (1992) Readings in Model-Based Diagnosis. Morgan Kaufmann Publishers, Inc., San Mateo, Calif.\n[Beckerman et a/, 1995] Heckerman, D., Breese, J. and Rommelse, K. (1995) Decision-theoretic Trou bleshooting. In Communications of the ACM (to appear).\n[Kalagnanam & Henrion, 1988] Kalagnanam, J. and Henrion, M. (1988). A comparison of decision analy sis and expert rules for sequential diagnosis. In Pro ceedings of the Fourth Workshop on Uncertainty in Artificial Intelligence, Minneapolis, MN. pages 205- 212. Also in Shachter, R., Levitt, T., Kanal, L., and Lemmer, J ., editors, Uncertainty in Artificial Intel ligence 4, pages 271-281, North-Holland, New York, 1990.\n[Srinivas & Horvitz, 1995] Srinivas, S. and Horvitz, E. (1995) Exploiting system hierarchy to compute re pair plans in probabilistic model-based diagnosis. In Proceedings of the 11th Conf. on Uncertainty in Ar tificial Intelligence.\n[Poole & Provan, 1991] Poole, D. and Provan, G. (1991) Use and granularity in consistency-based di agnosis. In The second International Workshop on principles of diagnosis, September 1991.\n[Yuan, 1993] Yuan, S. (1993) Knowledge-based de cision model construction for hierarchical diagno sis: A preliminary report. In Proceedings of the 9th Conf. on Uncertainty in Artificial Intelligence, pp. 274-281."}], "references": [{"title": "Choosing observations and actions in model\u00ad based diagnosis/repair systems", "author": ["Friedrich", "Nejdl", "G. 1992] Friedich", "W. Nejdl"], "venue": "In The third Inter\u00ad national Workshop on principles of diagnosis,", "citeRegEx": "Friedrich et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Friedrich et al\\.", "year": 1992}, {"title": "Readings in Model-Based Diagnosis", "author": ["W. Hamscher", "L. Console", "J. deKleer"], "venue": "[Hamscher et a/,", "citeRegEx": "Hamscher et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Hamscher et al\\.", "year": 1992}, {"title": "Decision-theoretic Trou\u00ad bleshooting", "author": ["D. Heckerman", "J. Breese", "K. Rommelse"], "venue": "[Beckerman et a/,", "citeRegEx": "Heckerman et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Heckerman et al\\.", "year": 1995}, {"title": "A comparison of decision analy\u00ad sis and expert rules for sequential diagnosis", "author": ["Kalagnanam", "Henrion", "J. 1988] Kalagnanam", "M. Henrion"], "venue": "In Pro\u00ad ceedings of the Fourth Workshop on Uncertainty in Artificial Intelligence,", "citeRegEx": "Kalagnanam et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Kalagnanam et al\\.", "year": 1988}, {"title": "Exploiting system hierarchy to compute re\u00ad pair plans in probabilistic model-based diagnosis", "author": ["Srinivas", "Horvitz", "S. 1995] Srinivas", "E. Horvitz"], "venue": "In Proceedings of the 11th Conf. on Uncertainty in Ar\u00ad tificial Intelligence", "citeRegEx": "Srinivas et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Srinivas et al\\.", "year": 1995}, {"title": "Use and granularity in consistency-based di\u00ad agnosis", "author": ["Poole", "Provan", "D. 1991] Poole", "G. Provan"], "venue": "In The second International Workshop on principles of diagnosis,", "citeRegEx": "Poole et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Poole et al\\.", "year": 1991}], "referenceMentions": [], "year": 2011, "abstractText": "The goal of diagnosis is to compute good re\u00ad pair strategies in response to anomalous sys\u00ad tem behavior. In a decision theoretic frame\u00ad work, a good repair strategy has low expected cost. In a general formulation of the problem, the computation of the optimal (lowest ex\u00ad pected cost) repair strategy for a system with multiple faults is intractable. In this paper, we consider an interesting and natural re\u00ad striction on the behavior of the system being diagnosed: (a) the system exhibits faulty be\u00ad havior if and only if one or more components is malfunctioning. (b) The failures of the sys\u00ad tem components are independent. Given this restriction on system behavior, we develop a polynomial time algorithm for computing the optimal repair strategy. We then go on to in\u00ad troduce a system hierarchy and the notion of inspecting (testing) components before re\u00ad pair. We develop a linear time algorithm for computing an optimal repair strategy for the hierarchical system which includes both re\u00ad pair and inspection.", "creator": "pdftk 1.41 - www.pdftk.com"}}}