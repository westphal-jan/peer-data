{"id": "1306.0514", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Jun-2013", "title": "Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences", "abstract": "We are introducing Persistent Contextual Neural Networks (PCNNs) as a probabilistic model for learning symbolic data sequences aimed at discovering complex algorithmic dependencies in the sequence. PCNNs resemble recurrent neural networks but have an architecture inspired by finite automata and a modified time evolution to better model memory effects. An effective training method is being developed that uses a belt geometry-inspired gradient increase in a metric: this results in an algorithm that is independent of design decisions such as coding parameters and unit activities. This metric gradient increase is designed to have algorithmic costs close to the re-propagation through time for sparsely connected networks.", "histories": [["v1", "Mon, 3 Jun 2013 17:36:14 GMT  (169kb)", "https://arxiv.org/abs/1306.0514v1", "Preliminary version"], ["v2", "Tue, 27 Aug 2013 16:19:13 GMT  (244kb)", "http://arxiv.org/abs/1306.0514v2", "Preliminary version. 2nd version: recurrent tensor-square differential metric added, more thorough experiments, title changed"], ["v3", "Sat, 12 Jul 2014 14:35:22 GMT  (248kb)", "http://arxiv.org/abs/1306.0514v3", "3rd version: minor changes"], ["v4", "Tue, 3 Feb 2015 18:35:36 GMT  (254kb)", "http://arxiv.org/abs/1306.0514v4", "4th version: some changes in notation, more experiments"]], "COMMENTS": "Preliminary version", "reviews": [], "SUBJECTS": "cs.NE cs.LG", "authors": ["yann ollivier"], "accepted": false, "id": "1306.0514"}, "pdf": {"name": "1306.0514.pdf", "metadata": {"source": "CRF", "title": "Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences", "authors": ["Yann Ollivier"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n30 6.\n05 14\nv4 [\ncs .N\nE ]\n3 F\neb 2\nHere we introduce a training procedure using a gradient ascent in a Riemannian metric: this produces an algorithm independent from design choices such as the encoding of parameters and unit activities. This metric gradient ascent is designed to have an algorithmic cost close to backpropagation through time for sparsely connected networks.\nWe use this procedure on gated leaky neural networks (GLNNs), a variant of recurrent neural networks with an architecture inspired by finite automata and an evolution equation inspired by continuous-time networks.\nGLNNs trained with a Riemannian gradient are demonstrated to effectively capture a variety of structures in synthetic problems: basic block nesting as in context-free grammars (an important feature of natural languages, but difficult to learn), intersections of multiple independent Markov-type relations, or long-distance relationships such as the distant-XOR problem.\nThis method does not require adjusting the network structure or initial parameters: the network used is a sparse random graph and the initialization is identical for all problems considered.\nThe problem considered here is to learn a probabilistic model for an observed sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. Such a model can be used for prediction, compression, or generalization.\nHidden Markov models (HMMs) are frequently used in such a setting. However, the kind of algorithmic structures HMMs can represent is limited because of the underlying finite automaton structure. Examples of simple sequential data that cannot be, or cannot conveniently be, represented by HMMs are discussed below; for instance, subsequence insertions, or intersections of multiple independent constraints.\nRecurrent neural networks (RNNs) are an alternative with higher modelling power. However, their training comes with its own limitations; in particular, picking long-distance dependencies remains problematic [BSF94, HS97, Jae02]. Techniques to deal with this problem include long short-term memory (LSTM) networks [HS97] or echo state networks (ESN) [Jae02].\nHere we use a new training procedure which realizes a gradient ascent using a suitable Riemannian metric, instead of backpropagation, at a small computational cost. Moreover, we use gated leaky neural networks (GLNNs), a variation on the RNN architecture. More precisely:\n\u2022 Rather than standard backpropagation through time, for training the model we use a gradient inspired by Riemannian geometry, using metrics for neural networks as introduced in [Oll13], adapted to a recurrent context. This makes learning less sensitive to arbitrary design choices, and provides a substantial improvement in learning speed and quality. An important point is doing so while keeping a scalable algorithm. Here the asymptotic algorithmic complexity is identical to backpropagation through time for sparsely connected networks.\n\u2022 In GLNNs, at each time in the production of a sequence of symbols, the neural network weights depend on the symbol last produced (\u201cgated\u201d units). This is inspired by finite automata in which the next state depends both on the current state and the currently produced symbol, and allows for an easy representation of automaton-like structures. Such \u201cgated\u201d models have already been used, e.g., in [SMH11], and arguably the LSTM architecture.\n\u2022 The dynamics of GLNNs is modified in a way inspired by continuoustime (or \u201cleaky\u201d) neural networks: the connection weights between the units control the variation of the activation levels, rather than directly setting the activation levels at the next step. This provides an integrating effect and is efficient, for instance, at modelling some hierarchical, context-free-grammar\u2013like structures in which an internal state must be held constant while something else is happening.\nMuch of this text is devoted to the derivation of Riemannian metrics for recurrent networks. Indeed, we believe the use of a proper gradient is a major ingredient for an effective learning procedure. The standard gradient ascent update over a parameter \u03b8 can be seen as a way to increase the value of a function f(\u03b8) while changing as least as possible the numerical value \u03b8:\n\u03b8\u2032 = \u03b8 + \u03b7 \u2202f\n\u2202\u03b8 \u21d2 \u03b8\u2032 \u2248 argmax\n\u03b8\u2032\n{\nf(\u03b8\u2032)\u2212 1 2\u03b7 \u2225 \u2225\u03b8 \u2212 \u03b8\u2032 \u2225 \u2225\n2 }\n(1)\nfor small enough learning rates \u03b7 (where \u2248 means \u201cup to O(\u03b72) when \u03b7 \u2192 0\u201d). The norm \u2016\u03b8 \u2212 \u03b8\u2032\u2016 depends on how the parameters are cast as a set of\nreal numbers. If, instead, one uses a measure of distance between \u03b8 and \u03b8\u2032 depending on what the network does, rather than how the numbers in \u03b8 and \u03b8\u2032 differ, the penalty for moving \u03b8 in different directions becomes different and hopefully yields better learning. One possible benefit, for instance, is self-adaptation of the cost of moving \u03b8 in certain directions, depending on the current behavior of the network. Another benefit is invariance of the learning procedure from a number of designing choices, such as using a logistic or tanh activation function, or scaling the values of parameters (choices which affect the conventional gradient ascent).\nThe primary example of an invariant gradient ascent is Amari\u2019s natural gradient, which amounts to replacing \u2016\u03b8 \u2212 \u03b8\u2032\u20162 with the Kullback\u2013Leibler divergence KL(Pr\u03b8 || Pr\u03b8\u2032) between the distributions defined by the network (seen as a probabilistic model of the data). However, the natural gradient comes at a great algorithmic cost. \u201cHessian-free\u201d techniques [Mar10, MS11, MS12] allow to approximate it to some extent and have yielded good results, but are still quite computationally expensive.\nHere we build two metrics for recurrent neural networks having some of the key properties of the natural gradient, but at a computational cost closer to that of backpropagation through time. The resulting algorithm is first presented in Section 2 in its final form. The algorithm might look arbitrary at first sight, but is theoretically well-grounded; in Sections 3.1\u20133.5 we derive it step by step from the principles in [Oll13] adapted to a recurrent setting.\nThis construction builds on the Riemannian geometry framework for neural networks from [Oll13]. The activities of units in the network are assumed to belong to a manifold: intuitively, they represent \u201cabstract quantities\u201d representable by numbers, but no preferred correspondence with R is fixed. This forces us to write only invariant algorithms which do not depend on the chosen numerical representation of the activities. Such algorithms are more impervious to design choices (e.g., changing the activation function from logistic to tanh has no effect); as a consequence, if they work well on one problem, they will tend to work well on rewritings of the same problem using different numerical representations. Thus, such algorithms are more \u201cagnostic\u201d as to physical meaning of the activities of the units (activation levels, activation frequencies, log-frequencies, ...).\nRemark 1. The three changes introduced above with respect to standard RNNs are independent and can be used separately. For instance, the metrics can be used for any network architecture.\nRemark 2. The approach is not specific to symbolic sequences: instead of transition parameters \u03c4ijxt depending on the latest symbol xt, one can use transition weights which depend on the components of the latest input vector xt.\nRemark 3. The gradient update proposed is independent of the training example management scheme (batch, online, small batches, stochastic gradient. . . ).\nRemark 4. The algorithm presented here is quadratic in network connectivity (number of connections per unit), and we have used it with very sparse networks (as few as 3 connections per unit), which apparently perform well. For non-sparse networks, a version with complexity linear in the number of connections, but with fewer invariance properties, is presented at the end of Section 2.\nExamples. Let us present a few examples of data that we have found can be efficiently learned by GLNNs. Other techniques that have been used to deal with such sequences include long short-term memory (LSTM) networks [HS97] (see for instance [Gra13] for a recent application using stacked LSTMs for text modelling) and echo state networks (ESN) [Jae02]. Here we do not have to engineer a particular network structure or to have prior knowledge of the scale of time correlations for initialization: in our experiments the network is a sparse random graph and parameter initialization is the same for all problems.\nExample 1 illustrates a type of operation frequent in natural languages (and artificial programming languages): in the course of a sequence, a subsequence is inserted, then the main sequence resumes back exactly where it was interrupted. This kind of structure is impossible to represent within a Markovian model, and is usually modelled with context-free grammars (the learning of which is still problematic).\nIn this example, the main sequence is the Latin alphabet. Sometimes a subsequence is inserted which spells out the digits from 0 to 9. In this subsequence, sometimes a subsubsequence is inserted containing nine random (to prevent rote learning) capital letters (Example 1).\nabcdefghijklmnopqrs(01[HSATXUEUZ]2[OYNFIWWOR]345[ZYMBOMYBZ]6789)tuvwxyz\nabcde(01234567[FFRLCMKVI]89)fghijklmnopqrstuvwxyz\n...\nExample 1: Inserting subsequences, a simple context-free grammar.\nHere the difficulty, both for HMMs and recurrent neural networks trained by ordinary backpropagation through time, is in starting again at the right point after the interruption caused by the subsequence.\nExample 2 is a pathological synthetic problem traditionally considered among the hardest for recurrent neural networks (although it can be represented by a simple finite automaton): the distant XOR problem. In a random binary sequence, two positions are marked at random (here with the symbol X), and the binary symbol at the end of each line is the logical\nXOR of the two random bits following the X marks. Use of the XOR function prevents detecting a correlation between the XOR result and any one of the two arguments.\n1 1 1 0 0X1 1X1 1 1 1 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1=0\n0X1X0 1 1 0 1 0 1 1 1 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0=1\n...\nExample 2: Long-distance XOR.\nOn this example, apparently the best performance for RNNs is obtained in [MS11]: with 100 random bits on each line, the failure rate is about 75%, where \u201cfailure\u201d means that a run examines more than 50 million examples before reaching an error rate below 1% [MS11, legend of Figure 3].\nExample 3 is synthetic music notation (here in LilyPond format1), meant to illustrate the intersection of several independent constraints. Successive musical bars are separated by a | symbol. Each bar is a succession of notes separated by spaces, where each note is made of a pitch (a, b, c, ...) and value (4 for a quarter note, 2 for a half note, 4. for a dotted quarter note, etc.). In each bar, a hidden variable with three possible values determines a harmony which restricts the possible pitches used in this bar. Harmonies in successive bars follow a specific deterministic pattern. Additionally, in each bar, the successive durations are taken from a finite set of possibilities (rhythms commonly encountered in waltzes). Rhythm is chosen independently from pitch and harmony. The resulting probability distribution is the intersection of all these constraints.\nc2 c4 | f4. a8 c4 | g4 b4 g8 d8 | g4. g8 g4 | e4 c4 c4 | ...\nExample 3: Synthetic music.\nThis example can be represented as a Markov chain, but only using a huge state space. The \u201ccorrect\u201d representation of the constraints is more compact, which allows for efficient learning, whereas a Markov representation would essentially need to see every possible combination of rhythm and pitches to learn the underlying structure.\nExample 4 is the textbook example of sequences that cannot be represented by a finite automaton (thus also excluding an HMM): sequences of the form anbn. The sequence alternates blocks of random length containing only a\u2019s and only b\u2019s, with the constraint that the length of a b-block is equal to the length of the a-block preceding it. The blocks are separated with newlines.\nSeen as a temporal sequence, this exhibits long-term dependencies, especially if the block lengths used in the training sequence are long. GLNNs\n1http://lilypond.org/\naaaaaaa\nbbbbbbb\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbbbbbbbbbbbbbbbb\n...\nExample 4: anbn\nare found to be able to learn this model within minutes with a training set of as few as 10 examples with the block lengths ranging in the thousands.\nExperiments for each of these examples are given in Section 4, both for GLNNs and more traditional RNNs: a GLNN or RNN network is trained on a single (long) training sequence2 and evaluated on an independent validation sequence, for a given computation time. More experiments attempt to isolate the respective contributions of the three changes introduced (leakiness, gatedness, and Riemannian training). Hidden Markov models, LSTMs, and classical text compression methods are included as a baseline.\nThe code for these experiments can be downloaded at http://www.yann-ollivier.org/rech/code/"}, {"heading": "1 Definition of the models", "text": ""}, {"heading": "1.1 Generative models for sequential data", "text": "A generative model for symbolic sequences is a model which produces an infinite random sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. The model depends on a set of internal parameters \u03b8: each \u03b8 defines a probability distribution Pr\u03b8((xt)t=0,1,...) over the set of infinite sequences. Given an actual training sequence (xt), the goal of learning is to find the value of \u03b8 that maximizes the probability of the training sequence (xt):\n\u03b8 = argmax \u03b8 Pr\u03b8((xt)t=0,1,...) = argmax \u03b8 log Pr\u03b8((xt)t=0,1,...) (2)\n= argmax \u03b8\n\u2211\nt\nlog Pr\u03b8(xt|x0x1 . . . xt\u22121) (3)\nwhere the latter sum can usually be computed step by step. This value of \u03b8 is then used for prediction of future observations, generation of new similar sequences, or compression of the training sequence.\n2We chose a single long training sequence rather than several short sequences, first, to avoid giving the algorithms a hint about the time scales at play; second, because in some of the problems presented here, there are no marked cuts (music example), or finding the relevant cuts is part of the game (anbn example); third, because having several training sequences is not always relevant, e.g., if there is a single temporal stream of data.\nThe generative models considered here work in an iterative way. At each time step t, the system has an internal state. This internal state is used to compute a probability distribution \u03c0t over the alphabet. The symbol xt printed at time t is drawn from this distribution \u03c0t. Then the new internal state as time t+1 is a deterministic or random function of the internal state at time t together with the symbol xt just printed.\nComputing the probability of an actual training sequence (xt) can be done iteratively, by computing the probability \u03c00 assigned by the model to the first symbol x0, then revealing the actual value of x0, using this x0 to compute the internal state at time 1, which is used to compute the probabilistic distribution of x1, etc. (forward pass).\nIn a variant of the problem, only some of the symbols in the sequence (xt) have to be predicted, while the others are given \u201cfor free\u201d. For instance, in a classification task the sequence (xt) might be of the form y0z0y1z1y2z2 . . . where for each instance yi we have to predict the corresponding label zi. In this case the problem is to find the \u03b8 maximizing the probability of those symbols to be predicted:\n\u03b8 = argmax \u03b8\n\u2211\nt\n\u03c7t log Pr\u03b8(xt|x0x1 . . . xt\u22121) (4)\nwhere\n\u03c7t =\n{\n1 if xt is to be predicted, 0 otherwise. (5)"}, {"heading": "1.2 Recurrent neural network models", "text": "We now present the recurrent network models discussed in this work. These include ordinary recurrent neural networks (RNNs), gated neural networks (GNNs), and leaky GNNs (GLNNs).\nNeural network\u2013based models use a finite oriented graph N , the network, over a set of units. The internal state is a real-valued function over N (the activities), and edges in the graph indicate which units of the network at time t contribute to the computation of the state of units at time t+ 1.\nAt each time step t, each unit i in the network N has an activation level ati \u2208 R. As is usual for neural networks, we include a special, alwaysactivated unit i = 0 with at0 \u2261 1, used to represent the so-called \u201cbiases\u201d. The activation levels at time t are used to compute the output of the network at time t and the activation levels at time t + 1. This transition function is different for RNNs, GNNs, and GLNNs, as defined below (Sections 1.2.1\u2013 1.2.3).\nFor the output of the network we always use the softmax function: each unit i \u2208 N (including i = 0) has time-independent writing weights wix for each symbol x in the alphabet A. At each time, the network outputs a\nrandom symbol x \u2208 A with probabilities given by the exponential of the writing weights weighted by the activation levels at that time:\n\u03c0t(x) := e \u2211 i at i wix\n\u2211 y\u2208A e \u2211 i at i wiy\n(6)\nwhere \u03c0t(x) is the probability to print x \u2208 A. This allows any active unit to sway the result by using a large enough weight. One effect of this \u201cnonlinear voting\u201d is to easily represent intersections of constraints: If an active unit puts high weight on a subset of the alphabet, and another active unit puts high weight on another subset of the alphabet, only the symbols in the intersection of these subsets will have high probability.\nThus, given the activities (ati)i\u2208N at time t, the network prints a random symbol xt drawn from \u03c0t. Then the network uses its current state and its own output xt to compute the activities at time t + 1: the (a t+1 i ) are a deterministic function of both the (ati)i\u2208N and xt. Given the writing weights wix, the model-specific transition function (depending on model-specific transition parameters \u03c4), and the initial activation levels a0i , the model produces a random sequence of symbols x0, x1, . . . , xt, . . .. Given a training sequence (xt), the goal of training is to find parameters wix, \u03c4 and a0i maximizing the probability to print (xt):\nPr((xt)t=0,...,T\u22121) = T\u22121 \u220f\nt=0\n\u03c0t(xt) (7)\nThe parameters \u03b8 = (w, \u03c4, a0) can be trained by gradient ascent \u03b8 \u2190 \u03b8+ \u03b7 \u2202 log Pr(x)\n\u2202\u03b8 . The gradient of the (log-)probability to print (xt) with respect to\nthe parameters can be computed by the standard backpropagation through time technique [RHW87, Jae02]. Appendix B describes backpropagation through time for the GLNN model (Proposition 11).\nHowever, here we will use gradient ascents in suitable, non-trivial metrics \u2016\u03b8 \u2212 \u03b8\u2032\u2016 given by a symmetric, positive-definite matrix M(\u03b8). The corresponding gradient ascent will take the form \u03b8 \u2190 \u03b8 + \u03b7M(\u03b8)\u22121 \u2202 log Pr(x)\n\u2202\u03b8\n(see Section 3.1). These metrics are built in Sections 3.3\u20133.5 to achieve reparametrization invariance at a reasonable computational cost, based on ideas from [Oll13].\nWe first give the full specification for the three neural network models used."}, {"heading": "1.2.1 Recurrent Neural Networks", "text": "In this article we use the following transition function to compute the RNN activation levels at step t+ 1 (see for instance [Jae02]):\nV t+1j := \u03c1jxt + \u2211\ni\n\u03c4ija t i (8)\nat+1j := s(V t+1 j ), (9)\nwhere s is a fixed activation function, xt \u2208 A is the symbol printed at time t, and the sum runs over all edges ij in the network. The sum also includes the always-activated unit i = 0 to represent \u201cbiases\u201d3.\nThe parameters to be trained are the input parameters \u03c1jxt and the transition parameters \u03c4ij. The parameter \u03c1ixt can equivalently be thought of as a connection weight from an input unit activated when reading xt.\nTwo standard choices for the activation function are the logistic function s(V ) := eV /(1 + eV ) = 1/(1 + e\u2212V ) and the hyperbolic tangent s(V ) := tanh(V ). Actually the two are related: one is obtained from the other by an affine transform of V and a. Traditional learning procedures would yield different results for these two choices. With the training procedures below using an invariant metric, using the tanh function instead of the logistic function would result in the same learning trajectory so that this choice is indifferent. To fix ideas, the experiments were implemented using tanh."}, {"heading": "1.2.2 Gated Neural Networks", "text": "GNNs are an extension of recurrent neural networks, in which the neural network transition function governing the new activations depends on the last symbol written. This is inspired by finite automata. Such models have also been used in [SMH11], the main difference being the non-linear softmax function (6) we use for the output.\nIn GNNs the activation levels at step t+ 1 are given by\nV t+1j := \u2211\ni\nati \u03c4ijxt (10)\nat+1j := s(V t+1 j ), (11)\nwhere s is the same activation function as in RNNs. The sum includes the always-activated unit i = 0.\nIn the above, xt \u2208 A is the symbol printed at step t, and the parameters \u03c4ijx are the transition weights from unit i to unit j given context x \u2208 A: contrary to RNNs, \u03c4ijx depends on the current signal x. This amounts\n3Biases are actually redundant in this case: the bias \u03c40i at unit i has the same effect as adding \u03c40i to all the input weights \u03c1ix for all symbols x, since at any time, one and exactly one symbol is active. Still, since backpropagation is not parametrization-invariant, using or not using these biases has an effect on learning.\nto having an RNN with different parameters \u03c4 for each symbol x in the alphabet. (This is not specific to discrete-valued sequences here: a continuous vector-valued signal xt with components x k t could trigger the use of \u2211\nk x k t \u03c4ijk as transition coefficients at time t.)\nHidden Markov models are GNNs with linear activation function [Bri90]: if we set s(V ) := V and if \u03c4ijx is set to (HMM probability that unit i prints symbol x)\u00d7 (HMM transition probability from i to j), then the GNN transition (10) yields the update equation for the HMM forward probabilities4. If, in addition, we\nreplace the softmax output (6) with a linear output \u03c0t(x) :=\n\u2211\ni at i wix\n\u2211\ni at i\nwhere\nwix is the HMM probability to write x in state i, then the GNN model exactly reduces to the HMM model.5\nGNNs have more parameters than standard recurrent networks, because each edge carries a parameter for each letter in the alphabet. This can be a problem for very large alphabets (e.g., when each symbol represents a word of a natural language): even storing the parameters can become costly. This is discussed in [SMH11], where a factorization technique is applied to alleviate this problem."}, {"heading": "1.2.3 Gated Leaky Neural Networks", "text": "Gated leaky neural networks are a variation over GNNs which allow for better handling of some distant temporal dependencies. They are better understood by a detour through continuous-time models. In GNNs we have V t+1j = \u2211 i \u03c4ijxta t i. One possible way to define a continuous-time analogue is to set dV tj dt = \u2211\ni\n\u03c4ijxta t i (12)\nand set atj = s(V t j ) as before. See [Jae02] for \u201ccontinuous-time\u201d or \u201cleaky\u201d neural networks. This produces an \u201cintegration effect\u201d: units become activated when a certain signal xt occurs, and stay activated until another event occurs. Importantly, the transition coefficient \u03c4iixt from i to i itself provides a feedback control. For this reason, in our applications, loops i \u2192 i are always included in the graph of the network.\nHere, contrary to the models in [Jae02], the differential equation is written over V which results in a slightly different equation for the activity a.6\n4More precisely ati becomes the probability to have emitted y0, . . . , yt\u22121 and be in state i at time t, i.e., the HMM probabilities right before emitting xt but after the t \u2212 1 \u2192 t state transition.\n5Conversely, any system of the form at+1 = F (at, xt) and law(xt+1) = G(a t+1), can be viewed as a Markov process on the infinite continuous space in which (at, xt) take values. 6Making V rather than a the leaky variable comes from looking for the simplest possible nonlinear dynamics in the context of differential geometry for neural networks [Oll13]. In full generality, if the activity unit j is a point aj in a manifold Aj , the continuous-time\nGated leaky neural networks are obtained by the obvious time discretization of this evolution equation. This is summed up in the following definition.\nDefinition 5. A gated leaky neural network (GLNN) is a network as above, subjected to the evolution equation\nV t+1j := V t j +\n\u2211\ni\n\u03c4ijxta t i, a t j := s(V t j ) (13)\n(where the sum includes the always-activated unit i = 0). The probability to output symbol x at time t is given by\n\u03c0t(x) := e \u2211 i at i wix\n\u2211 y\u2208A e \u2211 i at i wiy\n(14)\nAppendix A provides a further discussion of the integrating effect by studying the linearized regime. This is useful to gain an intuition into GLNN behavior and to obtain a sensible parameter initialization."}, {"heading": "2 An algorithm for GLNN training", "text": "In Section 3 we expose theoretical principles along which to build Riemannian algorithms for RNN, GNN and GLNN training. For convenience, we first collect here the explicit form of the final algorithm obtained for GLNNs, and discuss its algorithmic cost.\nThe derivatives of the log-likelihood of the training data with respect to the writing and transition weights, can be computed using backpropagation through time adapted to GLNNs (Appendix B). These derivatives are turned into a parameter update\n\u03b8 \u2190 \u03b8 + \u03b7M(\u03b8)\u22121 \u2202 log Pr(x) \u2202\u03b8\n(15)\nthrough a suitable metric M(\u03b8). We present two algorithmically efficient choices for M : the recurrent backpropagated metric (RBPM) and the recurrent unitwise outer product metric (RUOP metric).\ndynamics will be daj/dt = Fj((ai)i\u2192j , xt) where Fj is a vector field on Aj depending on the activitives of units connected to j and on the current signal xt. Looking for dynamics with a simple form, it makes sense to assume that the vector-field\u2013valued function Fj is the product of a fixed vector field F 0j times a real-valued function of the of the ai, and that the latter decomposes as a sum of the influences of individual units i, namely: Fj((ai)i\u2192j , xt) = ( \u2211\ni fi(ai, xt))F\n0 j . For one-dimensional activitives, if F 0 j does not vanish,\nthere always exists a particular chart of the manifold Aj , unique up to an affine transform, in which F 0j is constant: we call this chart Vj . Further assuming that fi(ai, xt) decomposes as a product of a function of xt and a function of ai, namely fi(ai, xt) = \u03c4i(xt)gi(ai), we can set ai := gi(ai), and we obtain the dynamics (12). Both variables V and a are thus recovered uniquely up to affine transform, respectively, as the variable that makes the time evolution uniform and the variable that makes the contribution of incoming units additive.\nFor the update of the writing weights wix, we use the quasi-diagonal reduction [Oll13, Sect. 2.3] of the Hessian or Fisher information matrix (the two coincide in this case) as the metric. Quasi-diagonal reduction is a process producing an update with algorithmic cost close to using only the diagonal of the matrix, yet has some of the reparametrization invariance properties of the full matrix. The expression for this metric on wix is worked out in Section 3.2.\nThe metricM used for updating the transition weights \u03c4ijx is built in Sections 3.3\u20133.5. First, in Section 3.3 we build a metric on recurrent networks from any metric on feedforward networks. This involves \u201ctime-unfolding\u201d [RHW87, Jae02] the recurrent network to view it as a feedforward network with T times as many units (T being the length of the training data), and then summing the feedforward metric over time (Definition 6). In Sections 3.4 and 3.5 we carry out this procedure explicitly for two feedforward metrics described in [Oll13]: this yields the RUOP metric and the RBPM, respectively.\nBefore starting the gradient ascent, the parameters of the network are initialized so that at startup, the activation of each unit over time is a random linear combination of the symbols xt observed in the recent past. As this latter point provides interesting insight into the behavior of GLNNs, we discuss it in Appendix A.\nAlgorithm description. Training consists in adjusting the writing weights wix, transition weights \u03c4ijx, and starting values V 0 i (used by the network at t = 0), to increase the log-likelihood of the training sequence (xt)t under the model.\nThe variable \u03c7t encodes which symbols in the sequence have to be predicted: it is set to 1 if the symbol xt has to be predicted, and to 0 if xt is given. Namely, the problem to be solved is\nargmax w,\u03c4,V 0\n\u2211\nt\n\u03c7t log \u03c0t(xt) (16)\nwhere \u03c0t is the probability attributed by the network to the next symbol knowing x0, . . . , xt\u22121.\nFor simplicity we work with a single (long) training sequence (xt)t=0,...,T\u22121; the algorithm can be extended in a straightforward manner to cover the case of several training examples, or mini-batches of training sequences (as in a stochastic gradient algorithm), simply by summing the gradients W , G and the metrics h\u0303, M\u0303 below over the training examples.\nThe procedure alternates between a gradient step with respect to the wix, and a gradient step with respect to the \u03c4ijx and V 0 i , with two distinct learning rates \u03b7w and \u03b7\u03c4 . We describe these two steps in turn. It is important to start with an update of wix, otherwise the metric at startup may be singular.\nIn the following expressions, all sums over units i in the network N include the always-activated unit i = 0 with at0 \u2261 1.\nGradient update for the writing weights wix. This is done according to the following steps.\n1. Forward pass: Compute the activations of the network over the training sequence (xt)t=0,...,T\u22121, using the GLNN evolution equations in Definition 5.\n2. Compute the partial derivatives with respect to the writing weights:\nWiy = \u2211\nt\n\u03c7t a t i (1xt=y \u2212 \u03c0t(y)) (17)\n3. Compute the following terms of the Hessian (or Fisher information matrix) of the log-likelihood with respect to w, using\nhyii = \u03b5y + T\u22121 \u2211\nt=0\n\u03c7t (a t i) 2\u03c0t(y)(1\u2212 \u03c0t(y)), i \u2208 N , y \u2208 A (18)\nhy0i = T\u22121 \u2211\nt=0\n\u03c7t a t i \u03c0t(y)(1 \u2212 \u03c0t(y)), i 6= 0, y \u2208 A (19)\nwhere \u03b5y is a dampening term to avoid divisions by 0. We set \u03b5y to the frequency of y in the training sequence plus the machine epsilon.\n4. Update the weights using the quasi-diagonal reduction of the inverse Hessian:\nwiy \u2190wiy + \u03b7w Wiy \u2212W0yhy0i/hy00 hyii \u2212 (h y 0i) 2/hy00 i 6= 0 (20)\nw0y \u2190w0y + \u03b7w\n\n W0y hy00 \u2212 \u2211\ni6=0\nhy0i hy00 Wiy \u2212W0yhy0i/hy00 hyii \u2212 (hy0i)2/hy00\n\n (21)\n(These formulas may look surprising, but they amount to using weighted covariances over time between desired output and activity of unit i, rather than just sums over time [Oll13, Sect. 1.1]; the constant terms are transferred to the always-activated unit.)\nGradient update for the transition weights \u03c4ijx. This goes as follows.\n1. Forward pass: Compute the activations of the network over the training sequence (xt)t=0,...,T\u22121, using the GLNN evolution equations in Definition 5.\n2. Backward pass: Compute the backpropagated values Bti for each unit i 6= 0 using\nBti = B t+1 i + s \u2032(V ti )\n \u03c7t ( wixt \u2212 \u2211 y\u03c0t(y)wiy ) + \u2211\nj\n\u03c4ijxtB t+1 j\n\n (22)\ninitialized with BTj = 0. This is the derivative of data log-likelihood with respect to V ti . Here s \u2032 is the derivative of the activation function.\n3. Compute the following \u201cmodulus\u201d m\u0303ti for each unit i 6= 0 at each time t. In the RUOP variant, simply set\nm\u0303ti = (B t i) 2 (23)\nIn the RBPM variant, set by induction from t+ 1 to t:\nm\u0303ti = s \u2032(V ti ) 2\n \u03c7t ( \u2211 y\u03c0t(y)w 2 iy \u2212 ( \u2211 y\u03c0t(y)wiy) 2 ) + \u2211\nj 6=i\n(\u03c4ijxt) 2 m\u0303t+1j\n\n\n+ (\n1 + \u03c4iixts \u2032(V ti ) )2 m\u0303t+1i\n(24)\ninitialized with m\u0303Ti = 0.\n4. For each unit j 6= 0, for each symbol y \u2208 A, compute the following vector G\n(jy) i and matrix M\u0303 (jy) ii\u2032 indexed by the units i with i \u2192 j in\nthe network N , including i, i\u2032 = 0.\nG (jy) i =\nT\u22121 \u2211\nt=0\n1xt=y a t i B t+1 j (25)\n(this is the derivative of the log-likelihood with respect to \u03c4ijx) and\nM\u0303 (jy) ii\u2032 =\nT\u22121 \u2211\nt=0\n1xt=y a t i a t i\u2032 m\u0303 t+1 j (26)\nDampen the matrix M\u0303 (jy) ii\u2032 by adding \u03b5 to the diagonal (we use \u03b5 = 1 which is small compared to the T terms in the sum making up M\u0303).\n5. Set G(jy) \u2190 (M\u0303 (jy))\u22121G(jy) (27)\nand update the transition weights with\n\u03c4ijy \u2190 \u03c4ijy + \u03b7\u03c4 G(jy)i (28)\nfor each j 6= 0 and y \u2208 A.\n6. Update the starting values V 0j with\nV 0j \u2190 V 0j + \u03b7\u03c4 B0j /(m\u03030j + \u03b5) (29)\n(this is obtained by analogy: this would be the update of \u03c4ijy with i = 0 and y a special dummy symbol read at startup\u2014consistently with the fact that m\u03030j and B 0 j have not been used to update \u03c4).\nInitialization of the parameters. At startup, the network N is chosen as an oriented random graph with d distinct edges from each unit i, always including a loop i \u2192 i. For the tanh activation function, the parameters are set up as follows (see the derivation in Appendix A):\nw0y \u2190 log \u03bdy, wiy \u2190 0 (i 6= 0), (30)\nwhere \u03bdy =\n\u2211\nt \u03c7t 1xt=y \u2211\nt \u03c7t\nis the frequency of symbol y among symbols to be\npredicted in the training data (this way the initial model is an i.i.d. sequence with the correct frequencies). The transition parameters are set so that each unit\u2019s activation reflects a random linear combination of the signal in some time range, as computed in Appendix A from the linearization of the network dynamics, namely\n\u03c4iiy \u2190 \u2212\u03b1, \u03c4ijy \u2190 0 (i 6= j, i 6= 0) (31)\nand \u03c40jy \u2190 \u03b2j +\n\u00b5j 4 (ujy \u2212 \u2211 y\u2032 \u03bd\u0303y\u2032ujy\u2032) (32)\nwhere the ujy are independent random variables uniformly distributed in\n[0; 1], \u03bd\u0303y =\n\u2211\nt 1xt=y\nT is the frequency of symbol y in the data, and where\n\u00b5j = 1/(j + 1), \u03b1 = 1/2, \u03b2j = \u2212 \u221a \u03b1(\u03b1\u2212 \u00b5j) (33)\nfor unit j (j > 1) are adjusted to control the effective memory7 of the integrating effect at unit j (see Appendix A). These values apply to the tanh activation function. The initial activation values are set to V 0j = s\n\u22121(\u03b2j/\u03b1) with s\u22121 the inverse of the activation function.\n7In particular, any foreknowledge of the time scale(s) of dependencies in the sequence may be used to choose relevant values for \u00b5j . With our choice, from Appendix A the time scale for unit j is O(j) at startup, though it may change freely during learning. Multiple time scales for recurrent networks can be found in several places, e.g., [HB95, KGGS14].\nLearning rate control. Gradient ascents come with a guarantee of improvement at each step if the learning rate is small enough. Here we test at each step whether this is the case: If an update of the parameter decreases data log-likelihood, the update is cancelled, the corresponding learning rate (\u03b7w or \u03b7\u03c4 ) is divided by 2, and the update is tried again. On the contrary, if the update improves data log-likelihood, the corresponding learning rate is multiplied by 1.1. This is done separately for the writing weights and transition weights. This is a primitive, less costly form of line search8.\nAt startup the value \u03b7w = \u03b7\u03c4 = 1/N (with N the number of units) seems to work well in practice (based on the idea that if each unit adapts its writing weights by O(1/N) then the total writing probabilities will change by O(1)).\nComputational complexity. If the network connectivity d (number of edges i \u2192 j per unit j) is not too large, the cost of the steps above is comparable to that of ordinary backpropagation through time.\nLet N be the network size (number of units), A the alphabet size, T the length of the training data, and d the maximum number of edges i \u2192 j per unit j in the network.\nThe cost of one forward pass is O(NTd) for computing the activities and O(NTA) for computing the output probabilities. The cost of computing the quantities Wiy is O(NTA) as well, as is the cost of computing the Hessian values hy. Applying the update of w costs O(NA). Thus the cost of the w update is O(NT (d+A)).\nComputing the backpropagated values Btj costs O(NT (d+A)). The cost of computing the backpropagated modulus m\u0303ti is identical.\nThe cost of computing the gradients G (jy) i is O(NTd) (note that each time t contributes for only one value of y, namely y = xt, so that there is no A factor).\nThe costliest operation is filling the matrices M\u0303 (jy) ii\u2032 . For a fixed j and y this matrix is of size d\u00d7 d. Computing the entries takes time O(Td2) for each j, hence a total cost of O(NTd2). (Once more, each time t contributes for only one value of y so that there is no A factor.) Inverting the matrix has a cost of O(Nd3): as this requires no sum over t, this is generally negligible if T \u226b d.\nThus, the overall cost (if T \u226b d) of one gradient step is O(NT (d2 +A)). This suggests using d \u2248 \u221a A. In particular if d = O( \u221a A) the overall cost is the same as backpropagation through time. If network connectivity is large, there is the possibility to use the quasidiagonal reduction of the matrices M\u0303 , as described in [Oll13, Sect. 2.3]. This\n8Experimentally, this leads to some slight oscillating behavior when the learning rate gets past the optimal value (as is clear for a quadratic minimum). This might be overcome by averaging consecutive gradient steps.\nrequires computing only the terms M\u0303 (jy) ii\u2032 with i = i \u2032 or i = 0. This removes the d2 factor and also allows for O(d) inversion, as follows.\nNon-sparse networks: quasi-diagonal reduction. The algorithm above must maintain a matrix of size d\u00d7d for each unit i, where d is the number of units j pointing to i in the network. When d is large this is obviously costly. The quasi-diagonal reduction process [Oll13, Sect. 2.3] provides a procedure linear in d while keeping most invariance properties of the algorithm. This is the procedure already used for the writing weights wiy in (20)\u2013(21). Essentially, at each unit j, the signals received from units i \u2192 j are considered to be mutually orthogonal, except for those coming from the always-activated unit i = 0. Thus only the terms M\u0303ii and M\u03030i of the matrix are used. The update of the transition parameters \u03c4ijy becomes as follows.\n1. For each unit j \u2208 N and each symbol y \u2208 A, compute the vector G(jy) as before. Compute only the terms M\u0303\n(jy) 00 , M\u0303 (jy) ii , and M\u0303 (jy) 0i of the\nmatrix M\u0303 (jy) in (26). Dampen the diagonal terms M\u0303 (jy) 00 and M\u0303 (jy) ii as before.\n2. Update the transition weights \u03c4ijy with\n\u03c4ijy \u2190\u03c4ijy + \u03b7\u03c4 G\n(jy) i \u2212G (jy) 0 M\u0303 (jy) 0i /M\u0303 (jy) 00\nM\u0303 (jy) ii \u2212 (M\u0303 (jy) 0i ) 2/M\u0303 (jy) 00\ni 6= 0 (34)\n\u03c40jy \u2190\u03c40jy + \u03b7\u03c4\n\n\nG (jy) 0 M\u0303 (jy) 00 \u2212 \u2211 i6=0 M\u0303 (jy) 0i M\u0303 (jy) 00 G (jy) i \u2212G (jy) 0 M\u0303 (jy) 0i /M\u0303 (jy) 00 M\u0303 (jy) ii \u2212 (M\u0303 (jy) 0i ) 2/M\u0303 (jy) 00\n\n\n(35)"}, {"heading": "3 Constructing invariant algorithms for recurrent", "text": "networks\nWe now give the main ideas behind the construction of the algorithm above. The approach is not specific to GLNNs and is also valid for classical recurrent networks."}, {"heading": "3.1 Gradients and metrics", "text": "Backpropagation performs a simple gradient ascent over parameter space to train a network. However, for GLNNs (at least), this does not work well. One reason is that gradient ascent trajectories depend on the chosen numerical representation of the parameters. For instance, a non-orthogonal change of basis in parameter space will yield different learning trajectories; yet such changes can result from simple changes in data representation (see the introduction of [Oll13]).\nThis is clear from the following viewpoint. Given a real-valued function f to be maximized depending on a vector-valued parameter \u03b8, the gradient ascent update\n\u03b8\u2032 = \u03b8 + \u03b7 \u2202f\n\u2202\u03b8 (36)\nwith learning rate \u03b7, can be viewed, for small \u03b7, as a maximization of f penalized by the change in \u03b8, namely\n\u03b8\u2032 \u2248 argmax \u03b8\u2032\n{\nf(\u03b8\u2032)\u2212 1 2\u03b7 \u2225 \u2225\u03b8 \u2212 \u03b8\u2032 \u2225 \u2225\n2 }\n(37)\nwhere the equality holds up to an approximation O(\u03b72) for small \u03b7. The term \u2016\u03b8 \u2212 \u03b8\u2032\u20162 defines a \u201ccost\u201d of changing \u03b8.\nClearly, different ways to represent the parameter \u03b8 as a vector will yield different costs \u2016\u03b8 \u2212 \u03b8\u2032\u20162. For instance, a linear change of basis for \u03b8 amounts to replacing \u2016\u03b8 \u2212 \u03b8\u2032\u20162 with (\u03b8\u2212 \u03b8\u2032)\u22a4M(\u03b8\u2212 \u03b8\u2032) with M a symmetric, positivedefinite matrix. The associated gradient update will then be\n\u03b8\u2032 = \u03b8 + \u03b7M\u22121 \u2202f\n\u2202\u03b8 (38)\nwhich is the general form of a gradient ascent when no privileged norm or basis is chosen for the parameter vector \u03b8. Moreover, in general the matrix M may depend on the current value of \u03b8, defining a (Riemannian) metric in which the norm of an infinitesimal change \u03b8 \u2192 \u03b8 + \u03b4\u03b8 of the parameter \u03b8 is\n\u2016\u03b4\u03b8\u20162 = \u03b4\u03b8\u22a4M(\u03b8)\u03b4\u03b8 (39)\nThe gradient ascent update defined by such a metric is thus\n\u03b8\u2032 = \u03b8 + \u03b7M(\u03b8)\u22121 \u2202f\n\u2202\u03b8 (40)\nA suitable choice ofM can greatly improve learning, by changing the cost of moving into various directions. Amari, in particular, advocated the use of the \u201cnatural gradient\u201d for learning of probabilistic models: this is a norm \u2016\u03b8 \u2212 \u03b8\u2032\u20162nat which depends on the behavior of the probability distribution represented by \u03b8, i.e., the output probabilities of the network, rather than on the way \u03b8 is decomposed as a set of numbers. Thus the natural gradient provides invariance with respect to some arbitrary design choices. (As a consequence, learning does not depend on whether a logistic or tanh is used as the activation function, for instance, since one can be changed into the other by a change of variables.)\nIn [Oll13] we introduced several metrics for feedforward neural networks sharing this key feature of the natural gradient, at a lesser computational cost. The main idea is to define the metric according to what the network does, rather than the numerical values of the parameters. We now show how these can be used to build invariant metrics for recurrent networks."}, {"heading": "3.2 The Fisher metric on the output units and writing weights", "text": "Whole-sequence Fisher metric and conditional Fisher metric. Metrics for neural networks first rely on choosing a metric on the output of the network [Oll13]. Here the network\u2019s output is interpreted as a probability distribution on the sequence (xt) printed by the network. Amari\u2019s natural gradient and the metrics we use are both based on the Fisher metric [AN00] on the space of probability distributions. One way to define the Fisher metric is as an infinitesimal Kullback\u2013Leibler divergence between two infinitesimally close probability distributions on the same set.\nFor recurrent neural networks, there is a choice as to which probability distribution should be considered. One can either view the network as defining a probability distribution Pr over all output sequences (x0, . . . , xt, . . .), or equivalently as defining a sequence of conditional probability distributions \u03c0t for the next symbol xt knowing the previous symbols. Thus there are two ways to define a divergence on the parameter \u03b8 based on Kullback\u2013Leibler divergences for finite-length output sequences (xt)06t6T . One is\nD1(\u03b8, \u03b8 \u2032) := KL(Pr\u03b8(x0, . . . , xt, . . .) || Pr\u03b8\u2032(x0, . . . , xt, . . .)) (41)\nwhere Pr\u03b8 is the probability distribution over the set of all sequences (x0, . . . , xt, . . .) defined by the network with parameter \u03b8. The other depends on the actual training sequence x and is\nD2(\u03b8, \u03b8 \u2032) :=\n\u2211\nt\nKL(Pr\u03b8(xt|x0, . . . , xt\u22121) || Pr\u03b8\u2032(xt|x0, . . . , xt\u22121)) (42)\n= \u2211\nt\nKL ( \u03c0t ||\u03c0\u2032t )\n(43)\nwhere \u03c0t (resp. \u03c0 \u2032 t) is the probability distribution on the next symbol xt defined by the network with parameter \u03b8 (resp. \u03b8\u2032) knowing past observations x0, . . . , xt\u22121.\nArguably, D2 is more adapted to prediction or (online) compression, while D1 is better suited for generalization and learning. For instance, if the actual training sequence starts with the letter a, a gradient ascent based on D2 will not care how a change of \u03b8 affects the probability of sequences starting with a b.\nAssuming that the training sequence (xt) has actually been sampled from Pr\u03b8 and is long enough, and under reasonable stationarity and ergodicity assumptions for Pr\u03b8, D2 should be a reasonable approximation of D1. 9\n9Indeed one has D1 = Ex\u223cPr\u03b8 ln Pr\u03b8(x) Pr\n\u03b8\u2032 (x)\n= Ex\u223cPr\u03b8 ln\n\u220f\nt Pr\u03b8(xt|x0...xt\u22121)\n\u220f\nt Pr \u03b8\u2032 (xt|x0...xt\u22121)\n=\n\u2211\nt Ex\u223cPr\u03b8 ln\nPr\u03b8(xt|x0...xt\u22121) Pr \u03b8\u2032 (xt|x0...xt\u22121) = \u2211 t E(x0...xt\u22121)\u223cPr\u03b8Ext\u223cPr\u03b8(xt|x0...xt\u22121) ln Pr\u03b8(xt|x0...xt\u22121) Pr \u03b8\u2032 (xt|x0...xt\u22121) =\n\u2211\nt E(x0...xt\u22121)\u223cPr\u03b8KL(Pr\u03b8(xt|x0 . . . xt\u22121) || Pr\u03b8\u2032(xt|x0 . . . xt\u22121)) so that if averaging over t in the actual training sequence is a good approximation of averaging over t for a Pr\u03b8-random sequence, then D1 and D2 are close.\nHowever, in a learning situation, it may not be reasonable to assume that (xt) is a sample from Pr\u03b8 until the training of \u03b8 is finished. So we do not assume that D1 \u2248 D2.\nAlgorithmically, when an actual training sequence x is given, the conditional divergenceD2 is much easier to work with, because it can be computed in linear time, whereas computing D1 would require summing over all possible sequences, or using a Monte Carlo approximation and sampling a large number of sequences.\nFor these reasons, we will define a metric based on D2, i.e., on the Fisher metric on the successive individual distributions \u03c0t.\nFisher metric on the output units. At each time step, the output of the network is a probability distribution over the alphabet A. The set of these probability distributions is naturally endowed with the Fisher metric: the square distance between two infinitesimally close probability distributions \u03c0 and \u03c0 + \u03b4\u03c0 is\n\u2016\u03b4\u03c0\u20162nat := 2KL(\u03c0 ||\u03c0 + \u03b4\u03c0) (44)\n= \u2211\nx\u2208A\n(\u03b4\u03c0(x))2\n\u03c0(x) = Ex\u223c\u03c0(\u03b4 log \u03c0(x))\n2 (45)\nat second order, where \u03b4 log \u03c0(x) = \u03b4\u03c0(x)/\u03c0(x) is the resulting variation of log \u03c0(x).\nIn the networks we consider, at each step the distribution \u03c0t for the next symbol is given by a softmax output\n\u03c0t(x) = e \u2211 i at i wix\n\u2211 y\u2208A e \u2211 i at i wiy\n(46)\nfor each x in the alphabet A. Let us set Ety := \u2211 i a t iwiy, so that \u03c0t(y) = eE t y/ \u2211 e Et\ny\u2032 . Then the norm \u2016\u03b4\u03c0t\u2016nat of a change \u03b4\u03c0t resulting from a change \u03b4Et in the values of Et is, by standard arguments for exponential families, found to be\n\u2016\u03b4\u03c0t\u20162nat = \u2211\ny\n\u03c0t(y)(\u03b4E t y) 2 \u2212 \u2211\ny,y\u2032\n\u03c0t(y)\u03c0t(y \u2032)\u03b4Ety\u03b4E t y\u2032 (47)\n(see Appendix C). By a property of exponential families, this is also, for any y\u2032\u2032, the Hessian of \u2212 log \u03c0t(y\u2032\u2032) with respect to the variables Et. In particular, in this situation, for the parameters w, the natural gradient with learning rate 1 coincides with the Newton method.\nMetric over the writing coefficients. We can now compute the natural metric over the writing coefficients wix. Let \u03b4wix be an infinitesimal change\nin the parameters wix: this creates a change \u03b4\u03c0t in the distribution \u03c0t, for all t. By the discussion above, we are interested in the quantity\n\u2211\nt\n\u2016\u03b4\u03c0t\u20162nat (48)\nChanging the writing weights wix does not change the activities of units in the network. Consequently, we have \u03b4Ety = \u2211 i a t i\u03b4wiy. Thus the above yields \u2211\nt\n\u2016\u03b4\u03c0t\u20162nat = \u2211\nt\n\u2211\ny,y\u2032\n\u2211\ni,i\u2032\n\u03c0t(y \u2032)(1y\u2032=y\u2032\u2032 \u2212 \u03c0t(y\u2032\u2032))atiati\u2032 \u03b4wiy\u03b4wi\u2032y\u2032 (49)\nso that the metric \u2211 t \u2016\u03b4\u03c0t\u20162nat over the parameters wiy is given by the Fisher matrix\nIwiywi\u2032y\u2032 = \u2211\nt\n\u03c0t(y \u2032)(1y\u2032=y\u2032\u2032 \u2212 \u03c0t(y\u2032\u2032))atiati\u2032 (50)\nwhich is also, up to sign, the Hessian of the log-likelihood of the training sequence with respect to the parameters w.\nThis is a full matrix whose inversion can be costly. The update of the parameters wiy given in Section 2 corresponds to the quasi-diagonal inverse of this metric, whose only non-zero terms correspond to y = y\u2032 and i = i\u2032 or i = 0. By [Oll13, Sect. 2.3], the quasi-diagonal inverse respects invariance under affine reparametrization of the activities of each unit."}, {"heading": "3.3 Invariant metrics for recurrent networks", "text": "The natural gradient arising from the whole-network Fisher metric is algorithmically costly to compute for neural networks (though the \u201cHessianfree\u201d conjugate gradient method introduced in [Mar10, MS11, MS12] approximates it). We now introduce metrics for recurrent networks that enjoy some of the main properties of the Fisher metric (in particular, invariance with respect to a number of transformations of the parameters or of the activities), at a computational cost close to that of backpropagation through time.\nAny invariant metric for feedforward networks can be used to build an invariant metric for recurrent networks, by first \u201ctime-unfolding\u201d the network as in backpropagation through time [RHW87, Jae02], and then by defining the norm of a change of parameters of the recurrent network as a sum over time of the norms of corresponding changes of parameters at each time in the time-unfolded network, as follows.\nA recurrent neural network with n units, working on an input of length T , can be considered as an ordinary feedforward neural network with nT units with shared parameters [RHW87, Jae02]. We will refer to it as the timeunfolded network. In the time-unfolded network, a unit is a pair (i, t) with i a unit in the original network and t a time. The unit (i, t) directly influences\nthe units (j, t+1) where i \u2192 j is an edge of the recurrent network. We also consider the output distribution \u03c0t at time t as a (probability distribution\u2013 valued) output unit of the time-unfolded network, directly influenced by all time-unfolded units (i, t).\nIf all time-unfolded units (i, t) use the same parameters \u03b8i as the corresponding unit i in the recurrent network, then the behaviors of the timeunfolded and recurrent networks coincide. Thus, let us introduce dummy time-dependent parameters \u03b8ti for unit (i, t) of the time-unfolded network, and decide that the original parameter \u03b8i for unit i in the recurrent network is a \u201cmeta-parameter\u201d of the time-unfolded network, which sets all dummy parameters to \u03b8ti = \u03b8i.\nWe are now ready to build a metric on recurrent networks from a metric \u2016\u00b7\u2016 on feedforward networks. A variation \u03b4\u03b8 of the parameters of the recurrent network determines a variation \u03b4\u03b8t of the (dummy) parameters of the time-unfolded network, which is an ordinary feedforward network. Thus we can simply set\n\u2016\u03b4\u03b8\u20162 := \u2211\nt\n\u2225 \u2225 \u2225\u03b4\u03b8t \u2225 \u2225 \u2225 2 (51)\nwhere for each t, \u03b4\u03b8t is a variation of the parameters of an ordinary feedforward network, for which we can use the norm \u2225 \u2225\u03b4\u03b8t \u2225\n\u2225. If the metric used on the time-unfolded network is reparametrizationinvariant, then so will be the metric on the recurrent network (since its definition does not use any choice of coordinates).\nUsing this definition for \u2016\u03b4\u03b8\u2016 is actually the same as making independent gradient updates \u03b4\u03b8t for each \u03b8t based on the metric \u2225 \u2225\u03b4\u03b8t \u2225\n\u2225, then projecting the resulting update onto the subspace where the value of \u03b8t does not depend on t (where the projection is orthogonal in the metric \u2016\u00b7\u2016). Equivalently, this amounts to making independent updates for each \u03b8t and then finding the time-independent update \u03b4\u03b8 minimizing \u2211\nt\n\u2225 \u2225\u03b4\u03b8t \u2212 \u03b4\u03b8 \u2225 \u2225 2 .10\nThus, we can use any of the metrics mentioned in [Oll13] for feedforward networks. Two will be of particular interest here, but other choices are possible; in particular, in case network connectivity is high, quasi-diagonal reduction [Oll13, Sect. 2.3] should be used.\nDefinition 6. Let \u2016\u00b7\u2016ff be a metric for feedforward networks. The recurrent metric associated with \u2016\u00b7\u2016ff is the metric for recurrent network parameters defined by\n\u2016\u03b4\u03b8\u20162rff := \u2211\nt\n\u2225 \u2225 \u2225\u03b4\u03b8t \u2225 \u2225 \u2225 2\nff (52)\n10For these equivalent interpretations, one has to assume that there is more than one training sequence. Indeed, for typical choices of the feedforward network metric \u2225 \u2225\u03b4\u03b8t \u2225 \u2225, with only one training sequence the metric \u2225 \u2225\u03b4\u03b8t \u2225 \u2225 on each individual \u03b8t is only of rank one, hence the corresponding update of \u03b8t is ill-defined. On the other hand, even with only one training sequence, the metric on \u03b4\u03b8 is generally full-rank, being a sum over time of rank-one metrics.\nnamely, by summing over time the metric \u2016\u00b7\u2016ff on the time-unfolded network. The recurrent backpropagated metric (RBPM) is the norm \u2016\u00b7\u2016rbp on a recurrent network associated with the backpropagated metric \u2016\u00b7\u2016bp on the time-unfolded network.\nThe recurrent unitwise outer product metric (RUOP metric) is the norm \u2016\u00b7\u2016ruop associated with the unitwise outer product metric \u2016\u00b7\u2016uop on the timeunfolded network.\nThe latter two metrics are described in more detail below. Both of them are \u201cunitwise\u201d in the sense that the incoming parameters to a unit are orthogonal to the incoming parameters to other units, so that the incoming parameters to different units can be treated independently. (Given a unit k in the network, we call incoming parameters to k the parameters directly influencing the activity of unit k, namely, the weights of edges leading to k and the bias of k.)\nRemark 7. We shall use these metrics only for the transition parameters \u03c4 of recurrent networks and GLNNs. For the writing parameters w, the Hessian, or equivalently the Fisher metric, is easily computed (Section 3.2) and there is no reason not to use it.\nRemark 8 (Multiple training sequences). Definition 6 is given for a single training sequence (xt). In the case of multiple training sequences, one has to first compute the metric for each sequence separately (since the time-unfolded networks are different if the training sequences have different lengths) and then define a metric by averaging the square norm \u2016\u03b4\u03b8\u20162rff over the training dataset, as in [Oll13]. There is a choice to be made as to whether training sequences of different lengths should be given equal weights or weights proportional to their lengths; the relevant choice arguably depends on the situation at hand.\nRemark 9 (Natural metric and recurrent natural metric). The natural metric of a recurrent network is defined in its own right and should not be confused with the recurrent-natural metric obtained by applying Definition 6 to the natural metric of the time-unfolded network. For the natural metric of the recurrent network, the norm of a change of parameter \u03b4\u03b8 is the norm of the change it induces on the network outputs \u03c0t. For the recurrent-natural metric, the square norm of \u03b4\u03b8 is the sum over time t, of the square norm of the change induced on the output by a change \u03b4\u03b8t = \u03b4\u03b8 of the dummy parameter \u03b8t, so that the influence of \u03b4\u03b8 is decomposed as the sum of its influences on each dummy parameter \u03b4\u03b8t considered independently. (Still, the influence of \u03b8t on the output at times t\u2032 > t is taken into account.) Explicitly, if \u03c0t is the network output at time t, then the natural norm is \u2016\u03b4\u03b8\u20162nat = \u2211 t \u2225 \u2225 \u2225 \u2202\u03c0t \u2202\u03b8 \u03b4\u03b8 \u2225 \u2225 \u2225 2 where \u2016\u00b7\u2016 is the norm on the outputs \u03c0t. De-\ncomposing \u2202\u03c0t \u2202\u03b8 = \u2211 t\u20326t \u2202\u03c0t\n\u2202\u03b8t \u2032 this is\n\u2211\nt\n\u2225 \u2225 \u2225 \u2225 ( \u2211 t\u20326t \u2202\u03c0t\n\u2202\u03b8t \u2032\n)\n\u03b4\u03b8\n\u2225 \u2225 \u2225 \u2225 2 . On the other hand\nthe recurrent-natural norm is \u2016\u03b4\u03b8\u20162rnat = \u2211 t\u2032\n\u2225 \u2225 \u2225\u03b4\u03b8t \u2032 \u2225 \u2225 \u2225 2\nnat =\n\u2211 t\u2032 \u2211 t>t\u2032\n\u2225 \u2225 \u2225 \u2225 \u2202\u03c0t\n\u2202\u03b8t \u2032 \u03b4\u03b8\n\u2225 \u2225 \u2225 \u2225 2\nwhich is generally different and accounts for fewer cross-time dependencies.\nWe now turn to obtaining more explicit forms of these metrics for the case of GLNNs. We describe, in turn, the RUOP metric and the RBPM. For simplicity we will assume that all symbols in the sequence have to be predicted (\u03c7t \u2261 1). Section 2 includes the final formulas for the general case."}, {"heading": "3.4 The recurrent unitwise outer product metric", "text": "Let us now describe the recurrent unitwise outer product metric (RUOP metric) in more detail.\nWe briefly recall the definition of the (non-recurrent) unitwise outer product metric. Suppose we have a loss function L depending on a parameter \u03b8, and moreover that L decomposes as a sum or average L = Ex\u2208D\u2113(x) of a loss function \u2113 over individual data samples x in a dataset D. The outer products of the differentials \u2202\u2113(x)\n\u2202\u03b8 , averaged over x, provide a metric on \u03b8,\nnamely, Ex\u2208D \u2202\u2113(x) \u2202\u03b8 \u2297 \u2202\u2113(x) \u2202\u03b8 given by the matrix\nCij = Ex\u2208D \u2202\u2113(x)\n\u2202\u03b8i\n\u2202\u2113(x)\n\u2202\u03b8j (53)\nThis is the outer product (OP) metric on \u03b8. The associated gradient ascent for L, with step size \u03b8, is thus \u03b8 \u2190 \u03b8 + \u03b7C\u22121 \u2202L \u2202\u03b8\n, and this gradient direction is parametrization-invariant. (One must be careful that scaling L by a factor \u03bb will result in scaling this gradient step by 1/\u03bb, which is counter-intuitive, thus step-size for this gradient must be carefully adjusted.)\nWhen the loss function \u2113 is the logarithmic loss \u2113(x) = log Pr\u03b8(y|x) of a probabilistic model Pr\u03b8(y|x), as is the case for feedforward networks with y the desired output for x, then the OP metric Ex\u2208D \u2202 log Pr\u03b8(y|x) \u2202\u03b8 \u2297 \u2202 log Pr\u03b8(y|x) \u2202\u03b8\nis a well-known approximation to the Fisher metric (for the latter, y would be sampled from the output of the network seen as a probability distribution, instead of using only the target value of y). In this context it has been used for a long time [APF00, RMB07]\u2014sometimes under the name \u201cnatural gradient\u201d, though it is in fact distinct from the Fisher metric, see discussion in [PB13] and [Oll13].\nThe OP metric has the following unique property: For a given increment \u03b4L in the value of L, the OP gradient step is the one for which the increment is most uniformly spread over all samples x \u2208 D, in the sense that the variance Varx\u2208D \u03b4\u2113(x) is minimal [Oll13, Prop. 15].\nFor feedforward networks, the OP metric is given by a full matrix on parameter space. This is computationally unacceptable for large networks; a more manageable version is the unitwise OP metric (UOP metric), in which\nthe incoming parameters for each unit are made orthogonal [Oll13]. The unitwise OP metric is still invariant under reparametrization of the activities of each unit. This decomposition is also used in [RMB07] (together with a further low-rank approximation in each block which breaks invariance).\nThe recurrent UOP metric is obtained from the UOP metric by Definition 6, through summing over time in the time-unfolded network. Let i be a unit in the recurrent network, and let \u03b8i be the set of incoming parameters to i. A change \u03b4\u03b8i in \u03b8i results in a change \u03b4\u03b8 t i of all the dummy parameters \u03b8ti of units (i, t) in the time-unfolded network. The square norm of \u03b4\u03b8i in the RUOP metric is, by definition (52), the sum over t of the square norms of \u03b4\u03b8ti in the UOP metric of the time-unfolded network.\nFor each t and each unit i, the unitwise OP metric on the dummy parameter \u03b8ti is given by the outer product square of the associated change of the objective function log Pr\u03b8(x), namely, the outer product square of \u2202 log Pr\u03b8(x)\n\u2202\u03b8t i\n.\nNow \u03b8ti is a dummy parameter of the time-unfolded network, and is used exactly once during computation of the network activities, namely, only at time t to compute the activity V ti and a t i = s(V t i ) of unit i. Thus we have\n\u2202 log Pr\u03b8(x)\n\u2202\u03b8ti =\n\u2202 log Pr\u03b8(x)\n\u2202V ti\n\u2202V ti \u2202\u03b8ti = Bti \u2202V ti \u2202\u03b8ti\n(54)\nwhere the derivatives Bti := \u2202 log Pr\u03b8(x)\n\u2202V t i\nare computed in the usual way by\nbackpropagation through time (Appendix B).\nThe partial derivative \u2202V t i\n\u2202\u03b8t i\nis readily computed from the evolution equa-\ntion defining the network: for instance, for GLNNs, the evolution equation of the time-unfolded network (using dummy parameters) is V ti = V t\u22121 i + \u2211\nj \u03c4 t jixt\u22121 at\u22121j , so that the derivative of V t i w.r.t. the parameter \u03c4 t jiy is\n1y=xt\u22121a t\u22121 j .\nThe unitwise OP metric for the dummy parameter \u03b8ti is given by the\nouter product square of \u2202 logPr\u03b8(x) \u2202\u03b8t\ni\n, which by the above is (Bti) 2 \u2202V\nt i \u2202\u03b8t i \u2297 \u2202V t i \u2202\u03b8t i .\nThis has to be summed over time to find the recurrent UOP metric for the true parameter \u03b8i. So in the end, the RUOP metric for the incoming parameters \u03b8i at unit i is given for each i by the matrix\nM\u0303 (i) kk\u2032 =\n\u2211\nt\n(Bti ) 2 \u2202V\nt i\n\u2202(\u03b8ti)k \u2202V ti \u2202(\u03b8ti)k\u2032\n(55)\nwhere (\u03b8ti)k denotes the k-th component of the parameter \u03b8 t i , and where the derivative is with respect to the dummy parameter \u03b8ti used only at time t. For GLNNs, this results in the expression given in the algorithm of Section 2: In the end, for the GLNN transition parameter \u03b8 = (\u03c4jiy)j,i,y, using that \u2202V ti /\u2202\u03c4 t jiy = 1y=xt\u22121a t\u22121 j , the recurrent UOP metric is\n\u2016\u03b4\u03b8\u20162ruop = \u2211\ni\n\u2211\nj,j\u2032\n\u2211\nt\n(Bt+1i ) 2atja t j\u2032 \u03b4\u03c4 t jixt \u03b4\u03c4 tj\u2032ixt (56)\nThe same expression holds for GNNs (but B has a different expression).\nThe form of the metric. Thus, we find that the RUOP metric on \u03c4 is given by a symmetric matrix with the following properties. These remarks also hold for the other metric we use, the RBPM below.\nFirst, different units i are orthogonal (there are no cross-terms between \u03b4\u03c4jix and \u03b4\u03c4j\u2032i\u2032x\u2032 for i 6= i\u2032).\nSecond, for GNNs and GLNNs, different symbols x are independent: the transition parameters \u03c4ijx and \u03c4ijx\u2032 with x 6= x\u2032 are mutually orthogonal in the RUOP metric, i.e., there are no cross-terms for x 6= x\u2032. This is because, at any given time t, only the parameters \u03c4jixt using the currently read symbol xt contribute to the evolution equation. This results in a separate matrix M\u0303 (ix) for each pair ix in the final algorithm, reducing computational burden.\nOn the other hand, for RNNs with the evolution equation at+1i = s(\u03c1ixt+ \u2211\nj\u03c4jia t j), there is no such block decomposition because the transition parameters \u03c4ij have non-trivial scalar product with all the input parameters \u03c1ix for all x; thus, handling this metric would be quadratic in alphabet size. If alphabet size is large, one solution is to restrict input to a subset of units. Another is to use quasi-diagonal reduction [Oll13, Sect. 2.3] to obtain a more lightweight but still invariant algorithm; this was tested in Section 4.\nThird, different units j and j\u2032 connected to the same unit i are not independent. (In particular, the \u201cbiases\u201d \u03c40ix corresponding to the alwaysactivated unit j = 0, aj \u2261 1 are not orthogonal to the other transition weights.) The cross-term between \u03b4\u03c4jix and \u03b4\u03c4j\u2032ix is\n\u2211\nt\n1xt=xa t ja t j\u2032(B t+1 i ) 2 (57)\nBesides, the derivative of log-likelihood with respect to \u03c4jix is \u2211 t 1xt=xa t jB t+1 i (Proposition 11), and the gradient step is obtained by applying the inverse of the matrix above to this derivative. This problem has an interesting structure. Indeed, vectors obtained as M\u22121G where M is a matrix of the form Mjk = \u2211 t a t ja t kc t, and G of the form Gj = \u2211 t a t jY\nt, are weighted leastsquare regression problems: M\u22121G gives the best way to write the vector Y t/ct, seen as a function of t, as a linear combination of the family atj , seen as functions of t. This is the \u201cbest-fit\u201d interpretation [Oll13, Section 3.3].\nThus, using metrics of this form, each unit i in the network combines the signals from its incoming units j in an optimal way to match a desired change in activity (given by Bti ) over time. The two metrics presented here, RUOP and RBPM, differ by the choice of the weighting ct.\nRemark 10 (UOP metric and recurrent UOP metric). The recurrent unitwise OP metric should not be confused with the unitwise OP metric applied to the recurrent network, which is defined in its own right but unsuitable for several reasons. For instance, with only one training sequence\nx, the OP metric for the recurrent network is simply \u2202 log Pr(x) \u2202\u03b8 \u2297 \u2202 log Pr(x) \u2202\u03b8\n, which is a rank-1 matrix and thus not invertible. On the other hand, on a single training sequence of length T , the recurrent UOP metric is a sum of T matrices of rank 1. Thus for a recurrent network, \u2016\u00b7\u2016ruop 6= \u2016\u00b7\u2016uop in general: one is a time sum of outer product squares, the other is the outer product square of a time sum. (Compare Remark 9.) So the recurrent UOP metric performs an averaging of the metric over time rather than over samples, as is expected in a recurrent setting.\nAnother similar-looking metric would be the OP metric associated with the decomposition log Pr(x) = \u2211\nt log Pr(xt|x0, . . . , xt\u22121) = \u2211\nt log \u03c0t(xt) of the objective function. Such a decomposition gives rise to a metric \u2211\nt( \u2202 log \u03c0x(xt) \u2202\u03b8 )\u22972. This metric is generally full-rank even for a single training\nsequence. The recurrent OP metric, on the other hand, is \u2211 t( \u2202 logPr(x) \u2202\u03b8t )\u22972. So while the recurrent OP is the sum over time of the effect of the dummy time-t parameter \u03b8t on the objective function, the metric just introduced is the sum over time of the effect of the parameter \u03b8 on the t-th component of the objective function. These are generally different. Computing all partial derivatives \u2202 log \u03c0x(xt)\n\u2202\u03b8 for all t and \u03b8 is algorithmically costlier, which is why\nwe did not use this metric."}, {"heading": "3.5 The recurrent backpropagated metric", "text": "We now work out an explicit form for the recurrent backpropagated metric. For a feedforward network, the backpropagated metric (BPM), introduced in [Oll13], is defined as follows. Given a metric on the output units of a network (here the Fisher metric on \u03c0t), one can inductively define a metric on every unit by defining the square norm \u2016\u03b4ai\u20162bp of a change of activity \u03b4ai at unit i, as the sum \u2211\nj, i\u2192j \u2016\u03b4aj\u20162bp of the square norms of the resulting changes in activity at units j directly influenced by i, thus \u201cbackpropagating\u201d the definition of the metric from output units to inner units. The metric \u2016\u03b4aj\u20162bp at unit j is then turned into a metric on the incoming parameters to j, by setting \u2016\u03b4\u03b8j\u20162bp := \u2016\u03b4aj\u2016 2 bp with \u03b4aj the change of aj resulting from the change \u03b4\u03b8j. The recurrent BPM is obtained from the BPM by Definition 6, through summing over time in the time-unfolded network. Let i be a unit in the recurrent network, and let \u03b8i be the set of incoming parameters to i. A change \u03b4\u03b8i in \u03b8i results in a change \u03b4\u03b8 t i of all the dummy parameters \u03b8 t i of units (i, t) in the time-unfolded network. The square norm of \u03b4\u03b8i in the RBPM is, by definition (52), the sum over t of the square norms of \u03b4\u03b8ti in the backpropagated metric metric of the time-unfolded network.\nSo let us work out the backpropagated metric in the time-unfolded network. The time-unfolded unit (i, t) directly influences the time-unfolded units (j, t + 1) for all edges i \u2192 j in the graph of the original network, and\nit also directly influences the distribution \u03c0t at time t. Thus, let \u03b4ati be an infinitesimal change in the activity of time-unfolded unit (i, t). Let \u03b4\u03c0t be the resulting change in the probability distribution \u03c0t, and \u03b4at+1j = \u2202at+1 j\n\u2202at i\n\u03b4ati the resulting change in the activity of time-unfolded\nunit (j, t+ 1). The BPM is obtained by backwards induction over t\n\u2225 \u2225 \u2225\u03b4ati \u2225 \u2225 \u2225 2\nbp := \u2016\u03b4\u03c0t\u20162nat +\n\u2211\nj\n\u2225 \u2225 \u2225\u03b4at+1j \u2225 \u2225 \u2225 2\nbp (58)\nThe term \u2016\u03b4\u03c0t\u20162nat is readily computed from Section 3.2: in the notation above, the change in Ety = \u2211 j wjya t j from a change of activity in a t i is \u03b4Ety = wiy\u03b4a t i, so that (47) yields\n\u2016\u03b4\u03c0t\u20162nat = (\u03b4ati)2 ( \u2211 y\u03c0t(y)w 2 iy \u2212 ( \u2211 y\u03c0t(y)wiy) 2 )\n(59)\ni.e., proportional to the \u03c0t-variance of wiy (in line with the fact that translating weights does not change output).\nSince activities are one-dimensional, the backpropagated metric is simply proportional to (\n\u03b4ati )2 , so that we have\n\u2225 \u2225 \u2225\u03b4ati \u2225 \u2225 \u2225 2\nbp =: mti\n(\n\u03b4ati\n)2 (60)\nfor some positive number mti, the backpropagated modulus [Oll13]. The definition (58) of the backpropagated metric thus translates as\nmti = ( \u2211 y\u03c0t(y)w 2 iy \u2212 ( \u2211 y\u03c0t(y)wiy) 2 ) + \u2211\nj\n(\n\u2202at+1j \u2202ati\n)2\nmt+1j (61)\n(initialized with mTi = 0), in which one recognizes a source term from the output at time t, and a term transmitted from t+ 1 to t.\nIt is advisable to express the backpropagated metric using the variable V ti\nrather than ati (because the expression for \u2202V t+1 j\n\u2202V t i\nis simpler). The variables\nV and a correspond bijectively to each other, and their variations are related by \u03b4ati = s \u2032(V ti )\u03b4V t i so that \u2225 \u2225\u03b4ati \u2225 \u2225 bp = m t i ( \u03b4ati )2 = m\u0303ti ( \u03b4V ti )2 with\nm\u0303ti := m i t s \u2032(V ti ) 2 (62)\nfrom which we derive the induction equation for m\u0303, namely\nm\u0303ti = s \u2032(V ti )\n2 ( \u2211\ny\u03c0t(y)w 2 iy \u2212 ( \u2211 y\u03c0t(y)wiy) 2 ) + \u2211\nj\n(\n\u2202V t+1j \u2202V ti\n)2\nm\u0303t+1j (63)\nin which we can now easily compute the \u2202V t+1 j\n\u2202V t i\nterm from the evolution\nequation defining the recurrent network.\nFor instance, for GLNNs we have V t+1j = V t j + \u2211 i \u03c4ijxts(V t i ) so we find\n\u2202V t+1j \u2202V ti = 1i=j + \u03c4ijxts \u2032(V ti ) (64)\nwhich, plugged into the above, yields the explicit equation (24) given in the algorithm description.\nOnce the backpropagated modulus is known, the backpropagated metric on the dummy parameters \u03b8ti at each unit (i, t) of the time-unfolded network is obtained by \u2225\n\u2225\u03b4\u03b8ti \u2225 \u2225 bp := \u2225 \u2225\u03b4ati \u2225 \u2225 bp where \u03b4a t i =\n\u2202at i \u2202\u03b8t i .\u03b4\u03b8ti is the variation of a t i\nresulting from a variation \u03b4\u03b8ti . Thus\n\u2225 \u2225 \u2225\u03b4\u03b8ti \u2225 \u2225 \u2225 2\nbp = mti\n(\n\u2202ati \u2202\u03b8ti .\u03b4\u03b8ti\n)2\n= m\u0303ti\n(\n\u2202V ti \u2202\u03b8ti .\u03b4\u03b8ti\n)2\n(65)\nwhere, as in the case of the RUOP metric above, the derivative \u2202V t i\n\u2202\u03b8t i\ncan be\nobtained from the evolution equation defining the network. In components, \u2225 \u2225\u03b4\u03b8ti \u2225 \u2225 2 bp is thus given by a matrix whose kk \u2032 entry is\nm\u0303ti \u2202V ti \u2202(\u03b8ti)k \u2202V ti \u2202(\u03b8ti)k\u2032\n(66)\nwhere (\u03b8ti)k denotes the k-th component of the incoming parameter \u03b8 t i to unit i. A parameter \u03b8i of the recurrent network influences all dummy parameters \u03b8ti for all t. The recurrent backpropagated metric is obtained by summing the backpropagated metric over time as in (52). So in the end the recurrent backpropagated metric for the incoming parameter \u03b8i to unit i is given by the matrix\nM\u0303 (i) kk\u2032 =\n\u2211\nt\nm\u0303ti \u2202V ti \u2202(\u03b8ti)k \u2202V ti \u2202(\u03b8ti)k\u2032\n(67)\nwith (\u03b8ti)k the k-th component of \u03b8 t i , and where the derivative is with respect to the dummy parameter \u03b8ti used only at time t. For instance, in GLNNs, the incoming parameter to unit i is \u03b8i = (\u03c4jiy)j,y. The evolution equation V ti = V t\u22121 i + \u2211 j \u03c4 t jixt\u22121 at\u22121j using the dummy parameters yields \u2202V t j\n\u2202\u03c4 t jiy\n= 1xt\u22121=ya t\u22121 j . This results in the expression given in the\nalgorithm of Section 2. In the end, for the GLNN parameter \u03b8 = (\u03c4jiy)j,i,y, the recurrent backpropagated metric is\n\u2016\u03b4\u03b8\u20162rbp = \u2211\ni\n\u2211\nj,j\u2032\n\u2211\nt\nm\u0303t+1i a t ja t j\u2032 \u03b4\u03c4jixt\u03b4\u03c4j\u2032ixt (68)\nThe structure of this metric is the same as for the RUOP metric above, and the same remarks apply (see Section 3.4): incoming parameters to distinct units i are independent; parameters corresponding to distinct symbols\ny 6= y\u2032 are independent for GNNs and GLNNs but not for RNNs; finally, the transition parameters from different units j and j\u2032 incoming to the same unit i are not independent, and the gradient ascent in this metric realizes, at each unit i, a weighted least-square regression on the incoming signals from units j to best match a desired activation profile given by the backpropagation values."}, {"heading": "3.6 Invariance of the algorithms", "text": "Amari [Ama98, AN00] pioneered the use of \u201cinvariant\u201d algorithms for statistical learning that do not depend on a chosen numerical representation (parametrization) of the parameter space of the model. Invariance can often improve performance; for instance, in the standard RNNs in the experiments below, replacing the standard inverse diagonal Hessian with the (invariant) quasi-diagonal inverse brings performance of RNNs closer to that of GLNNs, at very little computational cost.\nThe gradient ascent presented above is invariant by reparametrization of the activities and by reparametrization of the incoming parameters to each unit (but not by reparametrizations mixing incoming parameters to different units, as the natural gradient is).\nThis stems from its construction using a metric which depends only on the behavior of the network. For instance, using tanh instead of sigmoid activation function and following the same procedure would result in an algorithm with identical learning trajectories.\nHowever, in practice three factors limit this invariance.\n1. The invariance holds, in theory, only for the continuous-time gradient trajectories. The actual gradient steps with non-zero learning rate are only approximately invariant when the learning rate is small. Still, the actual gradient steps are exactly invariant under affine reparametrizations of the parameters and activity (such as changing sigmoid into tanh).\n2. Parameter initialization is done by setting numerical values for the parameters in an explicit numerical representation. Changing parametrization obviously means changing the initial values in the same way. If initialization is based on an intended parametrization-independent behavior at startup, as in Section 2, this is not a problem.\n3. The dampening procedure for matrix inversion (the various \u03b5 terms in Section 2) formally breaks invariance. Using a Moore-Penrose pseudoinverse (which is simply the limit \u03b5 \u2192 0) does not solve this problem. It would be nice to have a dampening scheme preserving invariance11.\n11Here is a possibility for defining a matrix for the incoming parameters to a unit i, which could be used as dampening the metric at i in an invariant way: Compute a copy"}, {"heading": "4 Preliminary experiments", "text": "Here we report a comparison of the performance of GLNNs and more traditional RNNs on some synthetic data examples: the \u201calphabet with insertion\u201d (Example 1 from the Introduction), synthetic music (Example 3), the distant XOR problem (Example 2), and finally the anbn problem (Example 4). LSTMs are used as an additional benchmark.\nGLNNs were trained with either the recurrent backpropagated metric or the recurrent unitwise outer product metric, as described in Section 2.\nThe reference RNN was trained using traditional (but not naive) techniques as described below. For the distant XOR example, RNN performance is known to be poor unless the \u201cHessian-free\u201d technique is used [MS11], so we did not test RNN on this example and instead directly compare performance to [MS11].\nReference RNN training. The RNN used as a baseline is described in Section 1.2.1. In particular, both this RNN and GLNNs use a softmax (6) for the probability to produce a symbol x given the internal state of the network.\nRNN training is done via backpropagation through time. As plain backpropagation was too slow, for the parameters wiy the inverse diagonal Hessian (obtained from (18)) is applied to the gradient update, and the learning rate for each \u03c1ix is inversely proportional to the frequency of symbol x in the data (thus compensating for the number of terms making up the corresponding gradient, so that rare symbols learn as fast as frequent symbols12). A method similar to RMSprop or Adagrad [DHS11], in which the learning rate for each transition parameter is divided by the root mean square (RMS) average over time of the gradient magnitude, is also reported in Table 1.\nInitialization of the RNN parameters has been set along the same principles as for GLNNs, namely\nw0y \u2190 log \u03bdy, \u03c4ii \u2190 1\u2212 1/i, \u03c1jy \u2190 1\n2 (ujy \u2212 \u2211 y\u2032 \u03bd\u0303y\u2032ujy\u2032) (69)\nwith u and \u03bd\u0303 as in Section 2, and with all other weights set to 0, where the symbol frequencies \u03bdy and \u03bd\u0303y are as in Section 2, and the ujy are independent random variables uniformly distributed in [0; 1]. This way, at startup the\nof the metric (RUOP or RBPM) but replacing the actual training sequence (xt) with a randomly generated sequence (e.g., uniform, or a perturbation of (xt)). More copies with more random sequences can be used until one gets a non-degenerate metric. The resulting metric can be multiplied by a small number and used as a dampening term. But this does not solve all problems: for instance, if a unit i has no effect whatsoever on the output given the current parameters, the corresponding metric will vanish. It seems difficult to define a non-zero invariant metric in the latter situation.\n12If \u03c1ix is seen as the weight from an input unit activated when symbol x occurs, then this is equivalent to scaling the input unit signals to a given L2 norm over time.\nactivation of each unit is given by a random linear combination of past symbols with weights exponentially decreasing with time, with unit i having a decay time of order i thanks to \u03c4ii.\nMore combinations of models (RNN, GNN, GLNN) and training methods are reported in Table 1.\nLSTMs. LSTMs [HS97] are included as an additional benchmark. For this we have kept the same overall procedure and simply replaced each RNN cell with an LSTM cell following Eqs. (7)\u2013(11) in [Gra13], and modified the gradient accordingly. We kept the softmax output from the other models (also as used in [Gra13]). The weights were initialized to uniform random values in [\u22120.1, 0.1] [Gra12, GSS03]. Network construction, network sizes, and CPU time budget were identical to the other models, as described below. Since plain gradient resulted in slow training, we have also included a variant described above for RNNs: using the diagonal Hessian for the writing parameters w, and frequency-adjusted learning rates for the input symbols (equivalent to rescaling the inputs). Still, training is quite slow and from Table 1 it appears that LSTMs are not competitive in this setup13, at least for the computational time budget used here.\nRegularization. When working with discrete alphabets, the problem arises of having probability 0 for certain symbols in certain situations after training; if the trained model is used on a validation set, validation log-likelihood can thus be very low. In our situation this is especially the case near the beginning of the sequence: since the model is trained on only one training sequence and has parameters for the activities at startup, it can frequently learn to start in a specific configuration to reproduce the first few letters of the training sequence. For this reason, a crude regularization procedure was used: before computing log-likelihood of the validation sequence, the prediction \u03c0t for the next symbol at time t was replaced with (1\u2212 1t+2 )\u03c0t+ 1t+2unifA with unifA the uniform distribution over the alphabet. (This kind of regularization has some backing from information theory.)\nExperimental setup. The same overall procedure (construction of a random graph, learning rate control) has been used for both GLNNs and RNNs as described in Section 2, following nearly identical implementations.\nIn each case, a single14 training sequence (xt) is generated using the exact synthetic model. Another, independent sequence (x\u2032t) is used for validation: we report the log-likelihood (in base 2) of the validation sequence (x\u2032t) using\n13Good performance of LSTMs has been reported for one of the problems we use, the anbn problem [GSS03]. However this involved more samples and small values of n in the training set. With these settings we were able to obtain similar results.\n14see footnote 2\nthe GLNN or RNN trained on (xt). The baseline for performance is the number of random bits used by the exact synthetic model to generate (x\u2032t).\nAs a sanity check, we also report the performance of a well-known, efficient online text prediction method, context tree weighting (CTW): the algorithm is presented with the concatenation of the training and validation sequence, and we report the number of bits used to predict the validation sequence after having read the training sequence.\nThe comparison between GLNNs and RNNs is made for identical computation time on the same machine, for a series of hyper-parameter settings (network size and connectivity). Indeed, as RNNs and GLNNs have different parameter sets, direct comparison for the same network size is difficult. Spanning different network sizes shows the performance each model can attain for a given time budget if the right hyper-parameters are used.\nIn each case, the size of the network was chosen to increase from 4 units to a maximum of 256 or 512 units by increments of a factor \u221a 2. For each network size, we tested both a sparse network with connectivity d = 3 edges per unit (including a loop at each unit), and a \u201csemi-sparse\u201d network with connectivity d = \u221a 2#A for GLNNs and d = #A for RNNs, where #A is the alphabet size; this latter choice balances the various contributions to algorithmic complexity (see Section 2). This way, RNNs can take advantage of their lesser computational sensitivity to connectivity d.\nFor each hyper-parameter setting, the corresponding model was allowed to learn for the same time (10 or 30 minutes depending on the example).\nThe experiments were run on a standard laptop computer with an Intel Core i7-3720QM CPU at 2.60GHz 15, using a straightforward implementation in C++.\nThe code for these experiments can be downloaded at http://www.yann-ollivier.org/rech/code/\nLet us now discuss each example in turn.\nAlphabet with insertions. The synthetic generative model is as follows. The training sequence is the concatenation of 1000 lines, separated by a newline symbol. Each line is obtained by writing the 26 lowercase letters of the Latin alphabet, in the standard order, and then inserting (independently) a sub-block after each letter with probability 1/26 for each letter. A subblock starts with an opening parenthesis, followed by the 10 digits from 0 to 9 (in that order), and ends with a closing parenthesis. After each digit in the sub-block, with probability 1/5 a sub-sub-block is inserted, which consists of an opening square bracket, nine random uppercase letters chosen from A\u2013Z, and a closing bracket. Thus a typical line might look like ab(0123[WZPYCPEEH]456789[HYDVTWATR])cdefghijklmnopqrstuvwxyz\n15For technical reasons the experiments for LSTMs and the RMS variant of RNNs were done on a slightly faster machine; an empirically adjusted scaling factor was applied to the corresponding CPU time.\nThe validation sequence has the same law: the concatenation of 1000 independent such lines. Randomization of the innermost blocks prevents rote learning.\nGLNNs and RNNs with a variety of network sizes ranging from 4 to 512 units, as described above, were run for 30 minutes each on the training sequence. The validation sequence log-likelihood is reported in Figure 1 and Table 1.\nGLNNs come more than ten times closer to the true model log-likelihood than RNNs: the best validation log-likelihood for GLNNs is -89,126 bits while that for RNNs is -96,099 bits, compared to -88,482 bits for the true model. Such a difference of roughly 7,000 bits represents roughly 7 bits per line of the training sequence. Note that the cost of representing a letter in the alphabet is log(26)/ log(2) \u2248 4.7 bits: this would be the log-likelihood difference, for each line of the training sequence, between a model that resumes at the correct place in the alphabet after a sub-block insertion, and one that resumes at a random letter.\nThis is confirmed by visual inspection of the models obtained after training. Indeed, since we train generative models, the trained network can be used to generate new sequences, hopefully similar to the training sequence. Doing so with RNNs and GLNNs reveals qualitative differences in the models learned, in line with the difference in performance: After a sub-block has been inserted, GLNNs resume at the correct letter or sometimes one letter off the correct position in the alphabet; on the other hand, RNNs seldom\nresume at the correct position. The remaining small difference in log-likelihood between GLNNs and the true model can, from visual inspection, be attributed to various factors: residual errors like occasional duplicated or omitted letters, or resuming one letter off after an insertion, as well as arguably good generalizations of the training sequence such as having more than one sub-block between two letters or starting a new line with a sub-block.\nThere is no obvious pattern of dissimilar performance between sparse and semi-sparse networks.\nHowever, GLNNs are apparently quite sensitive to overfitting over time: validation log-likelihood increases at first, then steadily decreases as parameter optimization progresses. This phenomenon is also present to a lesser extent for RNNs, but only after much longer training times. Note that for a given network size, GLNNs have more parameters (because each edge has as many parameters as symbols in the alphabet A).\nThis illustrates the importance of using a validation sequence to stop training of GLNNs.\nOne GLNN run exhibits wild variations of validation log-likelihood, for unknown reasons (perhaps a badly invertible matrix M\u0303 ).\nOn the other hand, surprisingly, GLNNs are less sensitive to overfitting due to a too large network size: while increasing network size past some value results in worse performance for RNNs (lower curves on Figure 1), for GLNNs it seems that the best validation log-likelihood over an optimization trajectory stays the same for a wide range of network sizes.\nRunning RNNs for longer times only partially bridges the gap in performance: RNNs after 4 hours are still seven times farther from the true model than GLNNs are after 30 minutes (with a gain of 2,810 bits of log-likelihood for RNNs). After some time, RNNs slow down considerably or sometimes exhibit the same overfitting phenomenon as GLNNs and their validation performance decreases.\nOverall, the \u201cresume-after-insertion\u201d phenomenon illustrated by this example is well captured by GLNNs.\nSynthetic music. The next example is synthetic music notation, meant to illustrate the intersection of several independent constraints. The training sequence is a succession of musical bars. Successive musical bars are separated by a | symbol and a newline symbol. Each bar is a succession of notes separated by spaces, where each note is made of a pitch (a,b,c,...) and value (4 for a quarter note, 2 for a half note, 4. for a dotted quarter note, etc.). In each bar, a hidden variable determines a harmony with three possible values I, IV, or V. If the harmony is I, every pitch in the bar is taken uniformly at random from the set (\u201cchord\u201d) {c,e,g}; pitches are taken from {c,f,a} if harmony is IV, and from {g,b,d} if harmony is V. Harmonies in\nsuccessive bars follow a specific deterministic pattern: an 8-bar-long cycle I-IV-I-V-I-IV-V-I as encountered in simple tunes. Finally, in each bar, the successive durations are taken from a finite set of 5 rhythmic possibilities (commonly encountered in waltzes), namely: 4-4-4; 2-4; 4.-8-4; 2.; 4-4-8-8. Rhythm is chosen independently from pitch and harmony. See Example 3.\nThe training sequence is made of 2,700 musical bars. The validation sequence is taken independently with the same law.\nGLNNs and RNNs with a variety of network sizes ranging from 4 to 256 units, as described above, were run for 10 minutes each on the training sequence. The validation sequence log-likelihood is reported in Figure 2 and Table 1.\nOnly one RNN run beats the sanity check (CTW). There is a difference of roughly 2,000 bits between the best RNN and best GLNN performance; GLNNs come roughly three times closer to the true model.\nVisual inspection of the output of the networks seen as generative models confirms that this difference is semantically significant: GLNNs correctly learn the rhythmic and harmonic constraints inside each bar, whereas RNNs still display \u201cmistakes\u201d.\nOn the other hand, even GLNNs were not able to learn the underlying 8-bar-long harmonic progression, which was apparently approximated by probabilistic transitions. This is reflected in the remaining gap between the true model and GLNNs.\nRunning an RNN with backpropagation for a longer time (3 hours in-\nstead of 10 minutes) only partially bridged the gap, only bringing RNN an additional 604 bits in log-likelihood. Once more, visual inspection of RNN output revealed a correct learning of the possible set of rhythms, but imperfect learning of the harmonic constraints even inside each musical bar.\nThe pattern of decrease in validation log-likelihood because of overfitting is present but less pronounced than for the alphabet-with-insertions example. Still, on Figure 2 one can notice one GLNN run exhibiting a wild variation of validation log-likelihood at some point. Once more this points out the importance of using validation sets during GLNN training, although using only one training sequence of relatively small size may also play a role here.\nDistant XOR. The setting is taken from [MS11], after [HS97]; here we recast it in a symbolic sequence setting. A parameter T is fixed (T = 100 below), which determines the length of the instances. The training sequence is a concatenation of lines separated by newline symbols. Each line is made of T \u2032 random bits preceded by whitespaces, where T \u2032 is taken at random between T and 1.1T . Two of these random bits are preceded by a special symbol X instead of a whitespace. The positions of these two special symbols are taken at random from the intervals J0;T \u2032/10J and JT \u2032/10;T \u2032/2J respectively. At the end of each line, a symbol = is inserted and is followed by a bit giving the XOR result of the two bits following the two X symbols. Example 2 gives a typical training sequence.\nThe goal is to correctly predict the value of the final bit of each line. So in the gradient computation an error term is included only for the bits to be predicted, as in [HS97]. Namely, in the notation of Section 2, we set \u03c7t = 1 if and only if xt\u22121 is the symbol =.\nFor this problem, we did not run the reference RNN and directly compared to the best performance we found in the literature, in [MS11], using \u201cHessian-free\u201d second-order RNN training. The success rate reported in the latter, for T = 100, is about 25% (proportion of runs achieving a classification error below 1% using at most 50,000 minibatches of 1,000 instances each).\nWe ran eight distinct instances of the problem, each with a different random training and validation sequence. Each such sequence was the concatenation of 10,000 lines as above with T = 100. We used a fully connected network with 10 units. Optimization was run for 1,500 gradient passes over the training sequence (amounting to roughly 12 hours of computation and 750 gradient steps for each of the writing and transition parameters, since we alternate those). We discuss the results for training using the recurrent BPM; the results using the recurrent UOP metric are extremely similar.\nFigure 3 reports two measures of performance on the validation sequence: the log-likelihood score for prediction of the final bit of each line (following the score (4)), and the classification error (equal to 0 if the correct bit value\nis given a probability > 1/2 and to 1 otherwise\u2014this is always bounded by the log-likelihood error) expressed as a percentage.\nThe results are binary: each run either successfully achieves low error rates after enough time, or does not perform better than random prediction.\n4 out of 8 independent runs reached error rates below 1% within less than 1,500 gradient passes over the training set, and 6 out of 8 within 2,000 gradient passes. The sample size is too small to tell for sure that this is better than the success rate in [MS11]. Still, the algorithm is simpler and uses fewer training examples.\nDirect comparison of the algorithmic cost with the approach in [MS11] is difficult, because for each gradient pass the latter can perform up to 300 passes of the conjugate gradient algorithm used in the implicit Hessian computation. For reference, in our approach, each run of the experiment above (1,500 gradient passes on a training sequence of 10,000 lines) takes slightly above 4h of CPU time on an Intel Core i7-3720QM CPU at 2.60GHz using a straightforward C++ implementation (no parallelism, no use of GPUs).\nanbn problem. In this problem, the training sequence is made of lines separated by newlines. The first line is a block of n1 symbols a; the second line is a block of n1 symbols b; the third line contains n2 a, the fourth line contains n2 b, etc. See Example 4.\nIn this experiment, the block lengths n were taken at random in J1024; 2048J\nto build the training and validation sequences. We used training and validation sequences made of only ten anbn blocks. RNNs and GLNNs with sizes ranging from 4 to 64, as described above, were run for 10 minutes each. For each independent run, a new random training sequence and validation sequence was generated. The results are reported in Figure 4 and Table 1.\nThe log-likelihood of a validation sequence under the true model is 10 bits for each block of a (choosing an integer n between 1024 and 2048), after which the length next block of b is known and comes for free. Thus the reference log-likelihood of the whole validation sequence (which contains 10 blocks of each) is 100 bits. However, from only 10 training samples as used here, the exact distribution of the length n cannot reasonably be inferred; a reasonable inference would be, for instance, a geometric law with mean somewhere in this interval. The geometric law with mean 1024+20482 = 1536 has an entropy of about 12 bits instead of 10.\nThus, at best, one can expect a reasonable model to attain an entropy of about 120 bits on the 10-instance-long validation set. On the other hand, a model which would not catch the equality of the sizes of consecutive a and b blocks would require twice as much entropy, i.e., about 240 bits for the validation set. Indeed, the sanity check (CTW) has a log-likelihood of -243.5 bits.\nThe best GLNN log-likelihood value obtained is -129.7 bits, while the best RNN log-likelihood value is -222.4 bits.\nSurprisingly, the best GLNN value was obtained with a network of size 4; a size-23 network came close second at -129.98 bits.\nNot all GLNN runs find the optimum: there is a cluster of runs around -230 bits, presumably corresponding to the model with independent lengths for a and b blocks, and one run (with 64 units) provided aberrant validation log-likelihood after some point because of overfitting.\nVisual inspection of the output of the best trained GLNN runs, used as generative models, shows that consecutive blocks of a and b indeed have the same or very close lengths, with sometimes an error of \u00b11 on the length. This imperfection would likely disappear with more than ten training sequences.\nThe kind of internal representation used by the GLNN to reach this result is unclear, especially given the small network size: does it build a kind of base-2 counter, does it take advantage of the analog nature of the units\u2019 activities, or something in between?\nInfluence of the various choices. The difference in performance between GLNNs and RNNs above results from various factors: choices in model design (leakiness and gatedness) and in the training method (backpropagation or a Riemannian gradient). We now try to isolate these factors, by testing various combinations of models (RNNs, GNNs and GLNNs) and training methods.\nIn particular, it is possible to apply invariant training methods to RNNs. The recurrent BPM and recurrent UOP metric are well-defined for RNNs. However, contrary to GNNs and GLNNs, the parameters corresponding to different symbols in the alphabet are not mutually orthogonal, and thus, using them directly would result in a complexity quadratic in the alphabet size, which we deem unacceptable. Therefore, we used the quasi-diagonal reductions of these metrics, as defined in [Oll13]. This still provides training methods that are invariant under reparametrization of the activity of each unit.\nEach model and training method was tested as described above, spanning various values of the hyperparameters (network size and connectivity). For each method we report the best performance found over the hyperparameters.\nThe performance reported is the cumulative regret with respect to the true generating model, a standard measure used in sequential prediction contexts. It is defined as the difference between the log-likelihood of the validation data sequence under the true model used to generate the data, and the log-likelihood of the validation data sequence under the trained model.\nWe also included three sanity checks for reference. Two are text compressors known for their performance (CTW as mentioned above, and the file compressor bzip2), for which, to incorporate the effect of training, we\nreport the number of bits used to compress the concatenation of the training and validation sequences minus the number of bits used to compress the training sequence alone.\nThe third sanity check is a hidden Markov model (HMM), trained using a variety of network sizes as for the neural networks.16 The comparison with HMMs is especially interesting, since these are a classical tool for modelling sequential data.\nThe \u201cclassical\u201d training method is as described above for RNNs: diagonal inverse Hessian for the writing parameters w, and backpropagation for the transition parameters; for the latter, parameters like \u03c1iy (for RNNs) or \u03c4ijy (for GNNs and GLNNs) related to a given symbol y have a learning rate divided by the frequency of y in the training sequence (\u201cfrequency-adjusted\u201d backpropagation, which compensates for the number of terms making up the corresponding gradient, and, for RNNs, is equivalent to scaling the input signals). Pure backpropagation was tested but is simply too slow.\nThe results are collected in Table 1. From this table it is clear that an invariant method is the first step to improve performance: RNNs trained with an invariant method beat GNNs and GLNNs trained with a non-invariant method.\nStill, the leaky aspect of GLNNs seems to be necessary to bring the best performance in problems with very long dependencies (the alphabet with insertions and the anbn example). On the other hand, on the problem where dependencies are most local (synthetic music), all network models achieve quite comparable results if trained with an invariant method.\nConclusions and perspectives\nThe viability of GLNNs with Riemannian training to capture complex algorithmic dependencies in symbolic data sequences has been established. Metrics inspired by a Riemannian geometric viewpoint, allow us to write invariant algorithms at an algorithmic cost comparable to backpropagation through time for sparsely connected networks.\nThese metrics bring down the necessary number of gradient steps to a few hundreds in the various examples studied. This approach seems to work with small training samples. Better than state-of-the-art performance has been obtained on difficult synthetic problems.\n16Details as follows. Training is done by the expectation-maximization algorithm. The network is obtained, as for the neural networks, by taking an oriented random graph with a given number of edges per node (including loops); this number of edges per node is set to the alphabet size, because this gives an algorithmic complexity similar to that of the neural networks. Initialization of the transition probabilities is by a Dirichlet(1/2, . . . , 1/2) (i.e., Jeffreys) prior on the edges from a node. Initialization of the production probabilities is done by multiplying the actual frequency of each symbol in the sequence to be modelled, by a random uniform([0; 1]) number.\nIn the experiments, the importance of invariance seems to supercede that of model choice: in our tests, any model with an invariant training algorithm did better than any model with a non-invariant one.\nMore experiments are needed to investigate the isolated effect of each feature of this training procedure (memory effect in the definition of GLNNs, gatedness, and the choice of metric). Other issues in need of investigation are the influence of parameter initialization (especially if some expert knowledge on the time scale of dependencies in the data is available) and a better, invariant dampening procedure. It would also be interesting to acquire insight into the dynamical behavior of GLNNs (ergodicity, multiple equilibrium regimes, etc.) and how it is affected by training. Furthermore, the Riemannian approach can in principle be extended to more complex architectures: testing Riemannian methods for LSTMs seems promising.\nFinally, scalable Riemannian training algorithms should be developed for a fully online \u201clifelong learning\u201d setting where there is a single training sequence which grows with time and where it is not possible to fully store the past states and signal, so that backpropagation through time is excluded."}, {"heading": "A Parameter initialization, the linearized regime,", "text": "and integrating effects in GLNNs\nLet us examine the dynamics of a GLNN, and in particular the linearized regime (the regime in which the connection weights are small). This will provide some insight into the time-integrating effect of the model, and also suggest relevant initializations of the parameter values before launching the gradient ascent, as presented in the algorithm above.\nIn the GLNN evolution equation V t+1j = V t j + \u2211 i \u03c4ijxta t i let us isolate the contributions of i = j and of the always-activated unit i = 0. Substituting atj = s(V t j ) and a t 0 \u2261 1 we get\nV t+1j = V t j + \u03c4jjxts(V t j ) + \u03c40jxt +\n\u2211\ni6=0, i6=j\n\u03c4ijxta t i (70)\nSince s(V tj ) is an increasing function of V t j , the contribution i = j provides a feedback loop: if \u03c4jjx is negative for all x, then the feedback will be negative, whereas positive \u03c4jjx would result in perpetual increase of V t j if the other contributions are ignored. Meanwhile, \u03c40jxt provides the reaction of unit j to the signal xt.\nFor instance, if we set \u03c4jjx = \u2212\u03b1 for all x with \u03b1 > 0, \u03c40jx = \u03b2 for all x, and all other weights \u03c4ijx to 0, the dynamics is\nV t+1j = V t j \u2212 \u03b1s(V tj ) + \u03b2 (71)\nwhich has a fixed point at V tj = V\u0304 := s \u22121(\u03b2/\u03b1), i.e., atj = \u03b2/\u03b1 (assuming \u03b2/\u03b1 lies in the range of the activation function s). The linearized dynamics\naround this fixed point (V tj close to V\u0304 ) is\nV t+1j \u2212 V\u0304 \u2248 (1\u2212 \u03b1s\u2032(V\u0304 )) ( V tj \u2212 V\u0304 )\n(72)\nso that if \u2223 \u2223 \u22231\u2212 \u03b1s\u2032(V\u0304 ) \u2223 \u2223 \u2223 < 1 this fixed point is attractive.\nA more interesting choice is to let\n\u03c4jjx = \u2212\u03b1, \u03c40jx = \u03b2 + \u03b5\u03c1x (73)\nwith small \u03b5, where \u03c1x is chosen to that the average of \u03c1 over the data xt is 0. Then, the value of V t as a function of t and the data can be found by induction using the linearized dynamics:\nV tj \u2248 V\u0304 + \u03b5 \u2211\nt\u2032<t\n(1\u2212 \u00b5)t\u2212t\u2032\u03c1xt\u2032 (74)\nwhere \u00b5 := \u03b1s\u2032(V\u0304 ) (75)\nnamely, the activation level V tj is a linear combination of the past values of the signal xt, with weights exponentially decreasing with time at rate (1\u2212 \u00b5).\nThis provides insights into reasonable values of the parameter leading to interesting internal dynamics, to be used at the start of the learning procedure. Indeed, negative values of \u03b1 would lead to unstability, whereas positive values of \u03b1 presumably stabilize the network. However, values of \u03b1 above 1/ sup s\u2032 (= 1 for tanh activation) will provide too much feedback, resulting in non-monotonous V t+1 as a function of V t and an oscillating behavior. Indeed we have found that setting \u03b1 = 1/(2 sup s\u2032), i.e.,\n\u03c4jjx = \u2212\u03b1 = \u22121/2 (76)\n(for tanh) for all j and x at startup, yields a good behavior of the network. With \u03c4jjx and \u03c40jx as above, the value of (1\u2212\u00b5) controls the effective time window of the integrating effect: data much older than t\u2212 t\u2032 \u226b 1 \u00b5 has little weight. Thus 1 \u00b5 presumably gives the order of magnitude of the distances t\u2212t\u2032 for which the model can reasonably be expected to capture correlations in the data (at least at startup, since \u00b5 will change during learning).\nThe value of \u00b5 can be directly controlled through \u03b2 via \u00b5 = \u03b1s\u2032(V\u0304 ) = \u03b1s\u2032(s\u22121(\u03b2/\u03b1)): for the tanh activation function, this yields\n\u03b2 = \u2212 \u221a \u03b1(\u03b1 \u2212 \u00b5) (77)\nwhich is used to set \u03b2 from an arbitrary choice for \u00b5. We have found that using different values of \u00b5 for different units yields good results. We have used\n\u00b5j = 1/(j + 1) (78)\nfor unit number j (starting at j = 1); this yields a characteristic time of order j and seems to perform well.\nFinally, the \u201creading rates\u201d \u03c1x are taken at random independently for each unit j in the following way. The value of \u03b5 must be small enough to ensure that V tj stays close to Vj (otherwise the linear regime assumption is unjustified), namely, that the sum \u03b5 \u2211\nt\u2032<t(1\u2212\u00b5)t\u2212t \u2032 \u03c1xt\u2032 stays small. If each\n\u03c1 is roughly of size 1, the sum is \u03b5/\u00b5 so taking \u03b5 somewhat smaller than \u00b5 is reasonable. We have used\n\u03b5 = \u00b5\n4 (79)\nwhich apparently yields good performance. Finally, \u03c1x is taken at random uniformly in [0; 1] for each symbol x (independently for each unit j), and then shifted by a constant so that the average of \u03c1xt over the training data xt is 0 (namely, the constant \u2211\n\u03bdx\u03c1x is removed from each \u03c1x where \u03bdx is the frequency of symbol x in the training data)17.\nThe other transition weights \u03c4ijx, with i 6= 0, i 6= j, were set to 0 at startup.\nThe explicit initialization values described here are specific to the tanh activation function; however, the reasoning extends to any activation function."}, {"heading": "B Derivative of the log-likelihood: Backpropaga-", "text": "tion through time for GLNNs\nLet (xt)t=0,...,T\u22121 be an observed sequence of T symbols in the alphabet A. Here we compute the derivatives of the log-probability that a GLNN prints (xt) with respect to the GLNN parameters, via the standard backpropagation through time technique.\nGiven a training sequence x = (xt), let Pr(x) be the probability that the model prints (x0, . . . , xT\u22121). Here, for simplicity we assume that all symbols in the sequence have to be predicted (i.e., \u03c7t \u2261 1). The algorithm in Section 2 gives the formulas for the general case.\nProposition 11 (log-likelihood derivative for GLNNs). The derivative of the log-probability of a sequence x = (xt)t=0,...,T\u22121 with respect to the parameters of a gated leaky neural network is given as follows.\nSetting\nBtj := \u2202 log Pr(x)\n\u2202V tj (80)\n17The choice to use a uniform random variable in [0; 1] rather than, e.g., Gaussian random variables, is justified by the feedback mechanism. Indeed since the activation function s ranges in [0; 1], the feedback term \u2212\u03b1s(V tj ) is bounded. If an unbounded signal \u03c1xt can occur at each step, it may take a long time to stabilize. Empirically, using Gaussian rather than bounded random variables seems to decrease performance, confirming this viewpoint.\nwe have the backpropagation relation\nBti = B t+1 i + s \u2032(V ti )\n\nwixt \u2212 \u2211\ny\n\u03c0t(y)wiy + \u2211\nj\n\u03c4ijxtB t+1 j\n\n (81)\n(initialized with BTj := 0). In particular B 0 j gives the derivative with respect to the initial values V 0j at time 0. The derivatives with respect to the writing weights are\n\u2202 log Pr(x)\n\u2202wiy =\n\u2211\nt\nati (1xt=y \u2212 \u03c0t(y)) (82)\nand the derivatives with respect to the transition weights are\n\u2202 log Pr(x)\n\u2202\u03c4ijy =\n\u2211\nt\n1xt=y a t iB t+1 j (83)\nThese relations include the always-activated unit i = 0, ai \u2261 1. The meaning of the partial derivative with respect to V tj is the following:\nif, in the equation V t+1j = V t j + \u2211 j \u03c4ijxta t i defining GLNNs, we artificially introduce a term \u03b5 \u226a 1 at unit j at time t, namely, V t+1j = V tj + \u2211 j \u03c4ijxta t i+\u03b5 for a single unit at a single time, and let the network evolve normally except for this change, then the value of log PT changes by \u03b5B t j +O(\u03b5 2).\nProof. Given a training sequence (xt)t=0,...,T\u22121 of length T , let P0 := 1 and\nPt+1 := \u03c0t(xt)Pt (84)\nso that PT is the probability of printing (x0, . . . , xT\u22121). By definition of \u03c0t we have\nlog Pt+1 = logPi + \u2211\ni\natiwixt \u2212 log ( \u2211\ny\ne \u2211 i at i wiy\n)\n(85)\nLet us compute the infinitesimal variations of these quantities under an infinitesimal variation \u03b4w, \u03b4\u03c4 of the parameters. Ultimately we are interested in the variation of log PT , to perform gradient ascent on the parameters.\nBy a first-order Taylor expansion, the variation of logPt+1 satisfies\n\u03b4 log Pt+1 = \u03b4 log Pt + \u2211\ni\nati\u03b4wixt + \u2211\ni\nwixt \u03b4a t i\n\u2212 \u2211\ny\n\u03c0t(y)\n(\n\u2211\ni\nati\u03b4wiy + \u2211\ni\nwiy\u03b4a t i\n) (86)\nand rearranging and substituting\n\u03b4ati = s \u2032(V ti )\u03b4V t i (87)\nwhere s\u2032 is the derivative of the activation function, this yields\n\u03b4 log Pt+1 = \u03b4 log Pt + \u2211\ni\nati\n(\n\u03b4wixt \u2212 \u2211\ny\n\u03c0t(y)\u03b4wiy\n)\n+ \u2211\ni\n(\nwixt \u2212 \u2211\ny\n\u03c0t(y)wiy\n)\ns\u2032(V ti )\u03b4V t i\n(88)\nConsequently, the variation \u03b4 log Pt of logPt can be expressed in terms of the variation of logPt\u22121, the variations of the parameters w and \u03c4 , and the variations of the values V t\u22121j at time t\u2212 1.\nLet us assume, by backward induction, that we can write the differential of log PT with respect to the parameters, as \u03b4 log PT =: \u03b4 log Pt + \u2211\ni\nBti \u03b4V t i +\n\u2211\ni,y\nCtiy\u03b4wiy + \u2211\ni,j,y\nDtijy\u03b4\u03c4ijy (89)\nFor t = T this is satisfied with BT = CT = DT = 0. Thus Bti represents the backpropagated value at unit i at time t, and C and D will cumulatively compute the gradient of log PT with respect to the parameters w and \u03c4 , namely:\n\u2202 log Pr(x)\n\u2202wiy = C0iy (90)\nand \u2202 log Pr(x)\n\u2202\u03c4ijy = D0ijy (91)\nand moreover B0j will contain the derivatives with respect to the initial levels V 0j .\nUsing the evolution equation V t+1j = V t j + \u2211 i \u03c4ijxta t i we find\n\u03b4V t+1j = \u03b4V t j +\n\u2211\ni\n\u03b4\u03c4ijxta t i +\n\u2211\ni\n\u03c4ijxts \u2032(V ti )\u03b4V t i (92)\nUsing these relations to go from time t + 1 to time t in (89), namely, expressing \u03b4 log Pt+1 in terms of \u03b4 log Pt and expanding V\nt+1 in terms of V t, we find\nCtiy = C t+1 iy + 1xt=y a t i \u2212 \u03c0t(y)ati (93)\nDtijy = D t+1 ijy + 1xt=y a t iB t+1 j (94)\nand\nBti = B t+1 i + s \u2032(V ti )\n\nwixt \u2212 \u2211\ny\n\u03c0t(y)wiy + \u2211\nj\n\u03c4ijxtB t+1 j\n\n (95)\nfrom which the expressions for C0iy and D 0 ijy follow."}, {"heading": "C Fisher metric for the output distribution \u03c0t", "text": "Let us compute the Fisher norm of the variation \u03b4\u03c0 of \u03c0 resulting from a change \u03b4Ety in the values of E t y = \u2211 i a t iwiy. (Such a change in E can result from a change in the writing weights w or the activities a; this will be used to compute the metric on the writing weights and the transition weights, respectively.) The effect of a change \u03b4Et on log \u03c0t is\n\u03b4 log \u03c0t(y) = \u2211\ny\u2032\n\u2202 log \u03c0t(y)\n\u2202Ety\u2032 \u03b4Ety\u2032 (96)\nand the norm of this \u03b4\u03c0t in Fisher metric is\n\u2016\u03b4\u03c0t\u2016nat = Ey\u223c\u03c0t(\u03b4 log \u03c0t(y))2 (97)\n= Ey\u223c\u03c0t\n\n\n\u2211\ny\u2032,y\u2032\u2032\n\u2202 log \u03c0t(y)\n\u2202Ey\u2032\n\u2202 log \u03c0t(y)\n\u2202Ey\u2032\u2032 \u03b4Ety\u2032 \u03b4E t y\u2032\u2032\n\n (98)\nBy a standard formula for exponential families of probability distributions we find:\n\u2202 log \u03c0t(y)\n\u2202Ey\u2032 = 1y=y\u2032 \u2212 \u03c0t(y\u2032) (99)\nso that\nEy\u223c\u03c0t\n[\n\u2202 log \u03c0t(y)\n\u2202Ey\u2032\n\u2202 log \u03c0t(y)\n\u2202Ey\u2032\u2032\n]\n= Ey\u223c\u03c0t [ (1y=y\u2032 \u2212 \u03c0t(y\u2032))(1y=y\u2032\u2032 \u2212 \u03c0t(y\u2032\u2032)) ]\n(100)\n= \u03c0t(y \u2032)(1y\u2032=y\u2032\u2032 \u2212 \u03c0t(y\u2032\u2032)) (101)\n(this is also18 the Hessian of \u2212 log \u03c0t(y) with respect to the values Et). Consequently, the Fisher metric for \u03c0t, expressed in terms of the variations \u03b4E t y, is \u2016\u03b4\u03c0t\u20162nat = \u2211\ny\n\u03c0t(y)(\u03b4E t y) 2 \u2212 \u2211\ny,y\u2032\n\u03c0t(y)\u03c0t(y \u2032)\u03b4Ety\u03b4E t y\u2032 (102)"}], "references": [{"title": "Natural gradient works efficiently in learning", "author": ["Shun-ichi Amari"], "venue": "Neural Comput.,", "citeRegEx": "Amari.,? \\Q1998\\E", "shortCiteRegEx": "Amari.", "year": 1998}, {"title": "Methods of information geometry, volume 191 of Translations of Mathematical Monographs", "author": ["Shun-ichi Amari", "Hiroshi Nagaoka"], "venue": "American Mathematical Society, Providence, RI,", "citeRegEx": "Amari and Nagaoka.,? \\Q2000\\E", "shortCiteRegEx": "Amari and Nagaoka.", "year": 2000}, {"title": "Adaptive method of realizing natural gradient learning for multilayer perceptrons", "author": ["Shun-ichi Amari", "Hyeyoung Park", "Kenji Fukumizu"], "venue": "Neural Computation,", "citeRegEx": "Amari et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Amari et al\\.", "year": 2000}, {"title": "Alpha-nets: A recurrent \u2019neural\u2019 network architecture with a hidden Markov model interpretation", "author": ["John S. Bridle"], "venue": "Speech Communication,", "citeRegEx": "Bridle.,? \\Q1990\\E", "shortCiteRegEx": "Bridle.", "year": 1990}, {"title": "Learning long-term dependencies with gradient descent is difficult", "author": ["Y. Bengio", "P. Simard", "P. Frasconi"], "venue": "Neural Networks, IEEE Transactions on,", "citeRegEx": "Bengio et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 1994}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["John C. Duchi", "Elad Hazan", "Yoram Singer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Duchi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2011}, {"title": "Sequence transduction with recurrent neural networks", "author": ["Alex Graves"], "venue": null, "citeRegEx": "Graves.,? \\Q2012\\E", "shortCiteRegEx": "Graves.", "year": 2012}, {"title": "Generating sequences with recurrent neural networks", "author": ["Alex Graves"], "venue": null, "citeRegEx": "Graves.,? \\Q2013\\E", "shortCiteRegEx": "Graves.", "year": 2013}, {"title": "Learning precise timing with lstm recurrent networks", "author": ["Felix A. Gers", "Nicol N. Schraudolph", "J\u00fcrgen Schmidhuber"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Gers et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Gers et al\\.", "year": 2003}, {"title": "Hierarchical recurrent neural networks for long-term dependencies", "author": ["Salah El Hihi", "Yoshua Bengio"], "venue": "Advances in Neural Information Processing Systems 8,", "citeRegEx": "Hihi and Bengio.,? \\Q1995\\E", "shortCiteRegEx": "Hihi and Bengio.", "year": 1995}, {"title": "Long short-term memory", "author": ["Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural Computation,", "citeRegEx": "Hochreiter and Schmidhuber.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter and Schmidhuber.", "year": 1997}, {"title": "Tutorial on training recurrent neural networks, covering BPTT, RTRL, EKF and the \u2018\u2018echo state network\u2019", "author": ["Herbert Jaeger"], "venue": "Technical Report 159,", "citeRegEx": "Jaeger.,? \\Q2002\\E", "shortCiteRegEx": "Jaeger.", "year": 2002}, {"title": "A clockwork RNN", "author": ["Jan Koutn\u00edk", "Klaus Greff", "Faustino J. Gomez", "J\u00fcrgen Schmidhuber"], "venue": "In Proceedings of the 31th International Conference on Machine Learning,", "citeRegEx": "Koutn\u00edk et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Koutn\u00edk et al\\.", "year": 2014}, {"title": "Deep learning via hessian-free optimization", "author": ["James Martens"], "venue": "Proceedings of the 27th International Conference on Machine Learning", "citeRegEx": "Martens.,? \\Q2010\\E", "shortCiteRegEx": "Martens.", "year": 2010}, {"title": "Training deep and recurrent neural networks with Hessian-free optimization", "author": ["James Martens", "Ilya Sutskever"], "venue": "Neural Networks: Tricks of the Trade,", "citeRegEx": "Martens and Sutskever.,? \\Q2012\\E", "shortCiteRegEx": "Martens and Sutskever.", "year": 2012}, {"title": "Riemannian metrics for neural networks I: feedforward networks", "author": ["Yann Ollivier"], "venue": null, "citeRegEx": "Ollivier.,? \\Q2013\\E", "shortCiteRegEx": "Ollivier.", "year": 2013}, {"title": "Learning internal representations by error propagation", "author": ["D.E. Rumelhart", "G.E. Hinton", "R.J. Williams"], "venue": null, "citeRegEx": "Rumelhart et al\\.,? \\Q1987\\E", "shortCiteRegEx": "Rumelhart et al\\.", "year": 1987}, {"title": "Topmoumoute online natural gradient algorithm", "author": ["Nicolas Le Roux", "Pierre-Antoine Manzagol", "Yoshua Bengio"], "venue": null, "citeRegEx": "Roux et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Roux et al\\.", "year": 2007}], "referenceMentions": [], "year": 2015, "abstractText": "Recurrent neural networks are powerful models for sequential data, able to represent complex dependencies in the sequence that simpler models such as hidden Markov models cannot handle. Yet they are notoriously hard to train. Here we introduce a training procedure using a gradient ascent in a Riemannian metric: this produces an algorithm independent from design choices such as the encoding of parameters and unit activities. This metric gradient ascent is designed to have an algorithmic cost close to backpropagation through time for sparsely connected networks. We use this procedure on gated leaky neural networks (GLNNs), a variant of recurrent neural networks with an architecture inspired by finite automata and an evolution equation inspired by continuous-time networks. GLNNs trained with a Riemannian gradient are demonstrated to effectively capture a variety of structures in synthetic problems: basic block nesting as in context-free grammars (an important feature of natural languages, but difficult to learn), intersections of multiple independent Markov-type relations, or long-distance relationships such as the distant-XOR problem. This method does not require adjusting the network structure or initial parameters: the network used is a sparse random graph and the initialization is identical for all problems considered. The problem considered here is to learn a probabilistic model for an observed sequence of symbols (x0, . . . , xt, . . .) over a finite alphabet A. Such a model can be used for prediction, compression, or generalization. Hidden Markov models (HMMs) are frequently used in such a setting. However, the kind of algorithmic structures HMMs can represent is limited because of the underlying finite automaton structure. Examples of simple sequential data that cannot be, or cannot conveniently be, represented by HMMs are discussed below; for instance, subsequence insertions, or intersections of multiple independent constraints.", "creator": "gnuplot 4.6 patchlevel 3"}}}