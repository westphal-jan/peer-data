{"id": "1310.5715", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Oct-2013", "title": "Stochastic Gradient Descent, Weighted Sampling, and the Randomized Kaczmarz algorithm", "abstract": "We show that the exponential convergence rate of the stochastic gradient descend on smooth, strongly convex objects can be significantly improved by disrupting the line selection rule in the direction of the sampling estimates proportional to the Lipschitz constants of their gradients. That is, we show that a partially distorted sampling rate enables a convergence rate with linear dependence on the average conditional number of the system, compared to the dependence on the average quadratic conditional number for the standard stochastic gradient descend. We assume the regime in which all stochastic estimates share an optimum, and therefore such an exponential rate is possible. We then reconstruct the randomized Kaczmarz algorithm to solve overdetermined linear systems as an example of a preconditioned stochastic gradient descend and apply our results to prove the quadral solution to a problem with an exponential, but not the most exposed, convex.", "histories": [["v1", "Mon, 21 Oct 2013 20:15:44 GMT  (465kb)", "https://arxiv.org/abs/1310.5715v1", "16 pages, 6 figures"], ["v2", "Sat, 15 Feb 2014 01:43:32 GMT  (275kb)", "http://arxiv.org/abs/1310.5715v2", "16 pages, 6 figures"], ["v3", "Thu, 20 Mar 2014 16:51:23 GMT  (278kb)", "http://arxiv.org/abs/1310.5715v3", "16 pages, 6 figures"], ["v4", "Thu, 27 Nov 2014 05:10:09 GMT  (277kb)", "http://arxiv.org/abs/1310.5715v4", "22 pages, 6 figures"], ["v5", "Fri, 16 Jan 2015 17:11:24 GMT  (71kb)", "http://arxiv.org/abs/1310.5715v5", "22 pages, 6 figures"]], "COMMENTS": "16 pages, 6 figures", "reviews": [], "SUBJECTS": "math.NA cs.CV cs.LG math.OC stat.ML", "authors": ["deanna needell", "rachel ward", "nathan srebro"], "accepted": true, "id": "1310.5715"}, "pdf": {"name": "1310.5715.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["(dneedell@cmc.edu).", "(nati@ttic.edu)."], "sections": [{"heading": null, "text": "ar X\niv :1\n31 0.\n57 15\nv5 [\nm at\nh. N\nA ]\n1 6\nJa n\n20 15\nOur results are based on a connection we make between SGD and the randomized Kaczmarz algorithm, which allows us to transfer ideas between the separate bodies of literature studying each of the two methods. In particular, we recast the randomized Kaczmarz algorithm as an instance of SGD, and apply our results to prove its exponential convergence, but to the solution of a weighted least squares problem rather than the original least squares problem. We then present a modified Kaczmarz algorithm with partially biased sampling which does converge to the original least squares solution with the same exponential convergence rate.\nKeywords. distribution reweighting, importance sampling, Kaczmarz method, stochastic gradient descent"}, {"heading": "1. INTRODUCTION", "text": "This paper connects two algorithms which until now have remained remarkably disjoint in the literature: the randomized Kaczmarz algorithm for solving linear systems and the stochastic gradient descent (SGD) method for optimizing a convex objective using unbiased gradient estimates. The connection enables us to make contributions by borrowing from each body of literature to the other. In particular, it helps us highlight the role of weighted sampling for SGD and obtain a tighter guarantee on the linear convergence regime of SGD.\nRecall that stochastic gradient descent is a method for minimizing a convex objective F (x) based on access to unbiased stochastic gradient estimates, i.e. to an estimate g for the gradient at a given point x, such that E[g] = \u2207F (x). Viewing F (x) as an expectation F (x) = Ei[fi(x)], the unbiased gradient estimate can be obtained by drawing i and using its gradient: g = \u2207fi(x). SGD originated as \u201cStochastic Approximation\u201d in the pioneering work of Robbins and Monroe [41], and has recently received renewed attention for confronting very large scale problems, especially in the context of machine learning [4, 42, 31, 2]. Classical analysis of SGD shows a polynomial rate on the sub-optimality of the objective value, F (xk) \u2212 F (x\u22c6), namely 1/ \u221a k for non-smooth objectives, and 1/k for smooth, or non-smooth but strongly convex objectives. Such convergence\nDate: January 19, 2015. DN: Department of Mathematical Sciences, Claremont McKenna College (dneedell@cmc.edu). NS: Toyota Technological Institute at Chicago (nati@ttic.edu). RW: Department of Mathematics, University of Texas at Austin (rward@math.utexas.edu).\n1\ncan be ensured even if the iterates xk do not necessarily converge to a unique optimum x\u22c6, as might be the case if F (x) is not strongly convex. Here we focus on the strongly convex case, where the optimum is unique, and on convergence of the iterates xk to the optimum x\u22c6.\nBach and Moulines [1] recently provided a non-asymptotic bound on the convergence of the iterates in strongly convex SGD, improving on previous results of this kind [26, Section 2.2][3, Section 3.2][43][31]. In particular, they showed that if each fi(x) is smooth and if x\u22c6 is a minimizer of (almost) all fi(x), i.e. Pi(\u2207fi(x\u22c6) = 0) = 1, then E\u2016xk \u2212 x\u22c6\u2016 goes to zero exponentially, rather than polynomially, in k. That is, reaching a desired accuracy of E\u2016xk \u2212 x\u22c6\u20162 \u2264 \u03b5 requires a number of steps that scales only logarithmically in 1/\u03b5. Bach and Moulines\u2019s bound on the required number of iterations further depends on the average squared conditioning number E[(Li/\u00b5)\n2], where Li is the Lipschitz constant of \u2207fi(x) (i.e. fi(x) are \u201cL-smooth\u201d), and F (x) is \u00b5-strongly convex. If x\u22c6 is not an exact minimizer of each fi(x), the bound degrades gracefully as a function of \u03c32 = E\u2016\u2207fi(x\u22c6)\u20162, and includes an unavoidable term that behaves as \u03c32/k.\nIn a seemingly independent line of research, the Kaczmarz method was proposed as an iterative method for solving (usually overdetermined) systems of linear equations [19]. The simplicity of the method makes it useful in a wide array of applications ranging from computer tomography to digital signal processing [16, 27, 18]. Recently, Strohmer and Vershynin [46] proposed a variant of the Kaczmarz method using a random selection method which select rows with probability proportional to their squared norm, and showed that using this selection strategy, a desired accuracy of \u03b5 can be reached in the noiseless setting in a number of steps that scales like log(1/\u03b5) and linearly in the condition number.\n1.1. Importance sampling in stochastic optimization. From a birds-eye perspective, this paper aims to extend the notion of importance sampling from stochastic sampling methods for numerical linear algebra applications, to more general stochastic convex optimization problems. Strohmer and Vershynin\u2019s incorporation of importance sampling into the Kaczmarz setup [46] is just one such example, and most closely related to the SGD set-up. But importance sampling has also been considered in stochastic coordinate-descent methods [33, 40]. There also, the weights are proportional to some power of the Lipschitz constants (of the gradient coordinates).\nImportance sampling has also played a key role in designing sampling-based low-rank matrix approximation algorithms \u2013 both row/column based sampling and entry-wise sampling \u2013 where it goes by the name of leverage score sampling. The resulting sampling methods are again proportional to the squared Euclidean norms of rows and columns of the underlying matrix. See [5, 25, 44, 9], and references therein for applications to the column subset selection problem and matrix completion. See [14, 24, 48] for applications of importance sampling to the Nystro\u0308m Method.\nImportance sampling has also been introduced to the compressive sensing framework, where it translates to sampling rows of an orthonormal matrix proportionally to their squared inner products with the rows of a second orthonormal matrix in which the underlying signal is assumed sparse. See [39, 20] for more details.\n1.2. Contributions. Inspired by the analysis of Strohmer and Vershynin and Bach and Moulines, we prove convergence results for stochastic gradient descent as well as for SGD variants where gradient estimates are chosen based on a weighted sampling distribution, highlighting the role of importance sampling in SGD.\nWe first show (Corollary 2.2 in Section 2) that without perturbing the sampling distribution, we can obtain a linear dependence on the uniform conditioning (supLi/\u00b5), but it is not possible to obtain a linear dependence on the average conditioning E[Li/\u00b5]. This is a quadratic improvement over the previous results [1] in regimes where the components have similar Lipschitz constants.\nWe then turn to importance sampling, using a weighted sampling distribution. We show that weighting components proportionally to their Lipschitz constants Li, as is essentially done by Strohmer and Vershynin, can reduce the dependence on the conditioning to a linear dependence on the average conditioning E[Li/\u00b5]. However, this comes at an increased dependence on the residual \u03c32. But, we show that by only partially biasing the sampling towards Li, we can enjoy the best of both worlds, obtaining a linear dependence on the average conditioning E[Li/\u00b5], without amplifying the dependence on the residual. Thus, using importance sampling, we obtain a guarantee dominating, and improving over the previous best-known results [1] (Corollary 3.1 in Section 2).\nIn Section 4, we consider the benefits of reweighted SGD also in other scenarios and regimes. We show how also for smooth but not-strongly-convex objectives, importance sampling can improve a dependence on a uniform bound over smoothness, (supLi), to a dependence on the average smoothness E[Li]\u2014such an improvement is not possible without importance sampling. For non-smooth objectives, we show that importance sampling can eliminate a dependence on the variance in the Lipschitz constants of the components. In parallel work we recently became aware of, Zhao and Zhang [51] also consider importance sampling for non-smooth objectives, including composite objectives, suggesting the same reweighting as we obtain here.\nFinally, in Section 5, we turn to the Kaczmarz algorithm, explain how it is an instantiation of SGD, and how using partially biased sampling improves known guarantees in this context as well. We show that the randomized Kaczmarz method with uniform i.i.d. row selection can be recast as an instance of preconditioned Stochastic Gradient Descent acting on a re-weighted least squares problem and through this connection, provide exponential convergence rates for this algorithm. We also consider the Kaczmarz algorithm corresponding to SGD with hybrid row selection strategy which shares the exponential convergence rate of Strohmer and Vershynin [46] while also sharing a small error residual term of the SGD algorithm. This presents a clear tradeoff between convergence rate and the convergence residual, not present in other results for the method."}, {"heading": "2. SGD FOR STRONGLY CONVEX SMOOTH OPTIMIZATION", "text": "We consider the problem of minimizing a smooth convex function,\n(2.1) x\u22c6 = argmin x F (x)\nwhere F (x) is of the form F (x) = Ei\u223cDfi(x) for smooth functionals fi : H \u2192 R over H = Rd endowed with the standard Euclidean norm \u2016\u00b7\u20162, or over a Hilbert space H with the norm \u2016\u00b7\u20162. Here i is drawn from some source distribution D over an arbitrary probability space. Throughout this manuscript, unless explicitly specified otherwise, expectations will be with respect to indices drawn from the source distribution D. That is, we write Efi(x) = Ei\u223cDfi(x). We also denote by \u03c32 the \u201cresidual\u201d quantity at the minimum,\n\u03c32 = E\u2016\u2207fi(x\u22c6)\u201622.\nWe will instate the following assumptions on the function F :\n(1) Each fi is continuously differentiable and the gradient function \u2207fi has Lipschitz constant Li; that is, \u2016\u2207fi(x)\u2212\u2207fi(y)\u20162 \u2264 Li\u2016x\u2212 y\u20162 for all vectors x and y.\n(2) F has strong convexity parameter \u00b5; that is, \u3008x\u2212 y,\u2207F (x)\u2212\u2207F (y)\u3009 \u2265 \u00b5\u2016x\u2212 y\u201622 for all vectors x and y.\nWe denote supL the supremum of the support of Li, i.e. the smallest L such that Li \u2264 L a.s., and similarly denote inf L the infimum. We denote the average Lipschitz constant as L = ELi.\nA unbiased gradient estimate for F (x) can be obtained by drawing i \u223c D and using \u2207fi(x) as the estimate. The SGD updates with (fixed) step size \u03b3 based on these gradient estimates are then given by:\n(2.2) xk+1 \u2190 xk \u2212 \u03b3\u2207fik(xk) where {ik} are drawn i.i.d. from D. We are interested in the distance \u2016xk \u2212 x\u22c6\u201622 of the iterates from the unique minimum, and denote the initial distance by \u03b50 = \u2016x0 \u2212 x\u22c6\u201622.\nBach and Moulines [1, Theorem 1] considered this setting1 and established that\n(2.3) k = 2 log(\u03b5/\u03b50) ( EL2i \u00b52 + \u03c32 \u00b52\u03b5 )\nSGD iterations of the form (2.2), with an appropriate step-size, are sufficient to ensureE\u2016xk \u2212 x\u22c6\u201622 \u2264 \u03b5, where the expectations is over the random sampling. As long as \u03c32 = 0, i.e. the same minimizer x\u22c6 minimizes all components fi(x) (though of course it need not be a unique minimizer of any of them), this yields linear convergence to x\u22c6, with a graceful degradation as \u03c32 > 0. However, in the linear convergence regime, the number of required iterations scales with the expected squared conditioning EL2i /\u00b5\n2. In this paper, we reduce this quadratic dependence to a linear dependence. We begin with a guarantee ensuring linear dependence, though with a dependence on supL/\u00b5 rather than ELi/\u00b5:\nTheorem 2.1. Let each fi be convex where \u2207fi has Lipschitz constant Li, with Li \u2264 supL a.s., and let F (x) = Efi(x) be \u00b5-strongly convex. Set \u03c32 = E\u2016\u2207fi(x\u22c6)\u201622, where x\u22c6 = argminx F (x). Suppose that \u03b3 < 1\nsupL . Then the SGD iterates given by (2.2) satisfy:\n(2.4) E\u2016xk \u2212 x\u22c6\u201622 \u2264 [ 1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL) )]k \u2016x0 \u2212 x\u22c6\u201622 + \u03b3\u03c32\n\u00b5 ( 1\u2212 \u03b3 supL ) ,\nwhere the expectation is with respect to the sampling of {ik}.\nIf we are given a desired tolerance, \u2016x\u2212 x\u22c6\u201622 \u2264 \u03b5, and we know the Lipschitz constants and parameters of strong convexity, we may optimize the step-size \u03b3, and obtain:\nCorollary 2.2. For any desired \u03b5, using a step-size of\n\u03b3 = \u00b5\u03b5\n2\u03b5\u00b5 supL+ 2\u03c32\n1Bach and Moulines\u2019s results are somewhat more general. Their Lipschitz requirement is a bit weaker and more complicated, but in terms of Li yields (2.3). They also study the use of polynomial decaying step-sizes, but these do not lead to improved runtime if the target accuracy is known ahead of time.\nwe have that after\n(2.5) k = 2 log(2\u03b50/\u03b5) (supL\n\u00b5 +\n\u03c32\n\u00b52\u03b5\n)\nSGD iterations, E\u2016xk \u2212 x\u22c6\u201622 \u2264 \u03b5, where \u03b50 = \u2016x0 \u2212 x\u22c6\u201622 and where the expectation is with respect to the sampling of {ik}.\nProof. Substituting \u03b3 = \u00b5\u03b5 2\u03b5\u00b5 supL+2\u03c32 into the second term of (2.4) and simplifying gives the bound\n\u03b3\u03c32\n\u00b5 ( 1\u2212 \u03b3 supL ) \u2264 \u03b5/2.\nNow asking that [\n1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL) )]k\n\u03b50 \u2264 \u03b5/2, substituting for \u03b3, and rearranging to solve for k, shows that we need k such that\nk log\n(\n1\u2212 \u00b5 2\u03b5(\u00b5\u03b5 supL+ 2\u03c32)\n2(\u00b5\u03b5 supL+ \u03c32)2\n) \u2264 \u2212 log ( 2\u03b50 \u03b5 ) .\nUtilizing the fact that \u22121/ log(1 \u2212 x) \u2264 1/x for 0 < x \u2264 1 and rearranging again yields the requirement that\nk \u2265 log ( 2\u03b50 \u03b5 ) \u00b7 2(\u00b5\u03b5 supL+ \u03c3 2)2 \u00b52\u03b5(\u00b5\u03b5 supL+ 2\u03c32) .\nNoting that this inequality holds when k \u2265 2 log ( 2\u03b50 \u03b5 ) \u00b7 \u00b5\u03b5 supL+\u03c32 \u00b52\u03b5\nyields the stated number of steps k in (2.5). Since the expression on the right hand side of (2.4) decreases with k, the corollary is proven.\nProof sketch. The crux of the improvement over Bach and Moulines is in a tighter recursive equation. Bach and Moulines rely on the recursion\n\u2016xk+1 \u2212 x\u22c6\u201622 \u2264 ( 1\u2212 2\u03b3\u00b5+ 2\u03b32L2i ) \u2016xk \u2212 x\u22c6\u201622 + 2\u03b32\u03c32, whereas we use the Co-Coercivity Lemma A.1, with which we can obtain the recursion\n\u2016xk+1 \u2212 x\u22c6\u201622 \u2264 ( 1\u2212 2\u03b3\u00b5+ 2\u03b32\u00b5Li ) \u2016xk \u2212 x\u22c6\u201622 + 2\u03b32\u03c32, where Li is the Lipschitz constant of the component used in the current iterate. The significant difference is that one of the factors of Li (an upper bound on the second derivative), in the third term inside the parenthesis, is replaced by \u00b5 (a lower bound on the second derivative of F ). A complete proof can be found in the appendix.\nComparison to results of Bach and Moulines. Our bound (2.5) replaces the dependence on the average square conditioning (EL2i /\u00b5\n2) with a linear dependence on the uniform conditioning (supL/\u00b5). When all Lipschitz constants Li are of similar magnitude, this is a quadratic improvement in the number of required iterations. However, when different components fi have widely different scaling, i.e. Li are highly variable, the supremum might be larger then the average square conditioning.\nTightness. Considering the above, one might hope to obtain a linear dependence on the average conditioning L/\u00b5 = ELi/\u00b5. However, as the following example shows, this is not possible. Consider a uniform source distribution over N + 1 quadratics, with the first quadratic f1 being N 2 (x[1] \u2212 b)2 and all others being 1 2 x[2]2, and b = \u00b11. Any method must examine f1 in order to recover x to within error less then one, but by uniformly sampling indices i, this takes (N + 1) iterations in expectation. It is easy to verify that in this case, supLi = L1 = N , L = 2 NN+1 < 2 EL2i = N, and \u00b5 = N N+1\n. For large N , a linear dependence on L/\u00b5 would mean that a constant number of iterations suffice (as L/\u00b5 = 2), but we just saw that any method that sampled i uniformly must consider at least (N + 1) samples in expectation to get non-trivial error. Note that both supLi/\u00b5 = N + 1 and EL2i /\u00b5\n2 \u2243 N + 1 indeed correspond to the correct number of iterations required by SGD.\nWe therefore see that the choice between a dependence on the average quadratic conditioning EL2i /\u00b5\n2, or a linear dependence on the uniform conditioning supL/\u00b5, is unavoidable. A linear dependence on the average conditioning L/\u00b5 is not possible with any method that samples from the source distributionD. In the next Section, we will show how we can obtain a linear dependence on the average conditioning L/\u00b5, using importance sampling, i.e. by sampling from a modified distribution."}, {"heading": "3. IMPORTANCE SAMPLING", "text": "We will now consider stochastic gradient descent, where gradient estimates are sampled from a weighted distribution.\n3.1. Reweighting a Distribution. For a weight functionw(i) which assigns a non-negative weight w(i) \u2265 0 to each index i, the weighted distribution D(w) is defined as the distribution such that\nPD(w) (I) \u221d Ei\u223cD [1I(i)w(i)] , where I is an event (subset of indices) and 1I(\u00b7) its indicator function. For a discrete distribution D with probability mass function p(i) this corresponds to weighting the probabilities to obtain a new probability mass function: p(w)(i) \u221d w(i)p(i). Similarly, for a continuous distribution, this corresponds to multiplying the density by w(i) and renormalizing.\nOne way to construct the weighted distribution D(w), and sample from it, is through rejection sampling: sample i \u223c D, and accept with probability w(i)/W , for some W \u2265 supi w(i). Otherwise, reject and continue to re-sample until a suggestion i is accepted. The accepted samples are then distributed according to D(w).\nWe use E(w)[\u00b7] = Ei\u223cD(w) [\u00b7] to denote an expectation where indices are sampled from the weighted distribution D(w). An important property of such an expectation is that for any quantity X(i) that depends on i:\n(3.1) E(w) [\n1 w(i)\nX(i) ] = E [X(i)] /E [w(i)] ,\nwhere recall that the expectations on the r.h.s. are with respect to i \u223c D. In particular, when E[w(i)] = 1, we have that E(w) [\n1 w(i)\nX(i) ] = EX(i). In fact, we will consider only weights\ns.t. E[w(i)] = 1, and refer to such weights as normalized.\n3.2. Reweighted SGD. For any normalized weight function w(i), we can weight each component fi, defining:\n(3.2) f (w)i (x) = 1\nw(i) fi(x)\nand obtain\n(3.3) F (x) = E(w)[f (w)i (x)].\nThe representation (3.3) is an equivalent, and equally valid, stochastic representation of the objective F (x), and we can just as well base SGD on this representation. In this case, at each iteration we sample i \u223c D(w) and then use \u2207f (w)i (x) = 1w(i)\u2207fi(x) as an unbiased gradient estimate. SGD iterates based on the representation (3.3), which we will also refer to as w-weighted SGD, are then given by\n(3.4) xk+1 \u2190 xk \u2212 \u03b3\nw(ik) \u2207fik(xk)\nwhere {ik} are drawn i.i.d. from D(w). The important observation here is that all SGD guarantees are equally valid for the w-weighted updates (3.4)\u2013the objective is the same objective F (x), the sub-optimality is the same, and the minimizer x\u22c6 is the same. We do need, however, to calculate the relevant quantities controlling SGD convergence with respect to the modified components f (w)i and the weighted distribution D(w).\n3.3. Strongly Convex Smooth Optimization using Weighted SGD. We now return to the analysis of strongly convex smooth optimization and investigate how re-weighting can yield a better guarantee. To do so, we must analyze the relevant quantities involved.\nThe Lipschitz constant L(w)i of each component f (w) i is now scaled, and we have, L (w) i = 1 w(i)\nLi. The supremum is given by:\n(3.5) supL(w) = sup i\nL (w) i = sup\ni\nLi w(i) .\nIt is easy to verify that (3.5) is minimized by the weights\n(3.6) w(i) = Li\nL ,\nand that with this choice of weights\n(3.7) supL(w) = sup i\nLi\nLi/L = L.\nNote that the average Lipschitz constant L = E[Li] = E(w)[L (w) i ] is invariant under weightings.\nBefore applying Corollary 2.2, we must also calculate:\n\u03c32(w) = E (w)[\u2016\u2207f (w)i (x\u22c6)\u201622] = E(w)[\n1\nw(i)2 \u2016\u2207fi(x\u22c6)\u201622](3.8)\n= E[ 1\nw(i) \u2016\u2207fi(x\u22c6)\u201622] = E[\nL Li \u2016\u2207fi(x\u22c6)\u201622] \u2264 L inf L \u03c32.\nNow, applying Corollary 2.2 to the w-weighted SGD iterates (3.4) with weights (3.6), we have that, with an appropriate stepsize,\nk = 2 log(2\u03b50/\u03b5) (supL(w)\n\u00b5 + \u03c32(w) \u00b52\u03b5 ) (3.9)\n\u2264 2 log(2\u03b50/\u03b5) (L\n\u00b5 +\nL inf L \u00b7 \u03c3\n2\n\u00b52\u03b5\n)\niterations are sufficient for E(w)\u2016xk \u2212 x\u22c6\u201622 \u2264 \u03b5, where x\u22c6, \u00b5 and \u03b50 are exactly as in Corollary 2.2.\n3.4. Partially biased sampling. If \u03c32 = 0, i.e. we are in the \u201crealizable\u201d situation, with true linear convergence, then we also have \u03c32(w) = 0. In this case, we already obtain the desired guarantee: linear convergence with a linear dependence on the average conditioning L/\u00b5, strictly improving over Bach and Moulines. However, the inequality in (3.8) might be tight in the presence of components with very small Li that contribute towards the residual error (as might well be the case for a small component). When \u03c32 > 0, we therefore get a dissatisfying scaling of the second term, relative to Bach and Moulines, by a factor of L/inf L.\nFortunately, we can easily overcome this factor. To do so, consider sampling from a distribution which is a mixture of the original source distribution and its re-weighting using the weights (3.6). That is, sampling using the weights:\n(3.10) w(i) = 1\n2 +\n1 2 \u00b7 Li L .\nWe refer to this as partially biased sampling. Using these weights, we have\n(3.11) supL(w) = sup i 1 1 2 + 1 2 \u00b7 Li\nL\nLi \u2264 2L\nand\n(3.12) \u03c32(w) = E[ 1\n1 2 + 1 2 \u00b7 Li\nL\n\u2016\u2207fi(x\u22c6)\u201622] \u2264 2\u03c32.\nPlugging these into Corollary 2.2 we obtain:\nCorollary 3.1. Let each fi be convex where \u2207fi has Lipschitz constant Li and let F (x) = Ei\u223cD[fi(x)], where F (x) is \u00b5-strongly convex. Set \u03c32 = E\u2016\u2207fi(x\u22c6)\u201622, where x\u22c6 = argminx F (x). For any desired \u03b5, using a stepsize of\n\u03b3 = \u00b5\u03b5\n4(\u03b5\u00b5L+ \u03c32)\nwe have that after\n(3.13) k = 4 log(2\u03b50/\u03b5) (L\n\u00b5 +\n\u03c32\n\u00b52\u03b5\n)\niterations of w-weighted SGD (3.4) with weights specified by (3.10), E(w)\u2016xk \u2212 x\u22c6\u201622 \u2264 \u03b5, where \u03b50 = \u2016x0 \u2212 x\u22c6\u201622 and L = ELi.\nWe now obtain the desired linear scaling on L/\u00b5, without introducing any additional factor to the residual term, except for a constant factor of two. We thus obtain a result which dominates Bach and Moulines (up to a factor of 2) and substantially improves upon it (with a linear rather than quadratic dependence on the conditioning).\nOne might also ask whether the previous best known result (2.3) could be improved using weighted sampling. The relevant quantity to consider is the average square Lipschitz constant for the weighted representation: (3.3):\nL2(w) . =E(w)\n[\n(\nL (w) i\n)2 ] = E(w)[ L2i\nw(i)2 ] = E[ L2i w(i) ].(3.14)\nInterestingly, this quantity is minimized by the same weights as supL(w), given by (3.6), and with these weights we have:\nL2(w) = E[ L2i\nLi/L ] = LELi = L\n2 .(3.15)\nAgain, we can use the partially biased weights give in (3.10), which yields L2(w) \u2264 2L 2 and also ensures \u03c32(w) \u2264 2\u03c32. In any case, we get a dependence on L 2 = (ELi)\n2 \u2264 E[L2i ] instead of L2 = E[L2i ], which is indeed an improvement. Thus, the Bach and Moulines guarantee is also improved by using biased sampling, and in particular the partially biased sampling specified by the weights (3.10). However, relying on Bach and Moulines we still have a quadratic dependence on (L/\u00b5)2, as opposed to the linear dependence we obtain in Corollary 3.1.\n3.5. Implementing Importance Sampling. As discussed above, when the magnitudes of Li are highly variable, importance sampling is necessarily in order to obtain a dependence on the average, rather than worst-case, conditioning. In some applications, especially when the Lipschitz constants are known in advance or easily calculated or bounded, such importance sampling might be possible by directly sampling from D(w). This is the case, for example, in trigonometric approximation problems or linear systems which need to be solved repeatedly, or when the Lipschitz constant is easily computed from the data, and multiple passes over the data are needed anyway. We do acknowledge that in other regimes, when data is presented in an online fashion, or when we only have sampling access to the source distribution D (or the implied distribution over gradient estimates), importance sampling might be difficult.\nOne option that could be considered, in light of the above results, is to use rejection sampling to simulate sampling from D(w). For the weights (3.6), this can be done by accepting samples with probability proportional to Li/ supL. The overall probability of accepting a sample is then L/ supL, introducing an additional factor of supL/L. This results in a sample complexity with a linear dependence on supL, as in Corollary 2.2 (for the weights (3.10), we can first accept with probability 1/2, and then if we do not accept, perform this procedure). Thus, if we are presented samples from D, and the cost of obtaining the sample dominates the cost of taking the gradient step, we do not gain (but do not lose much either) from rejection sampling. We might still gain from rejection sampling if the cost of operating on a sample (calculating the actual gradient and taking a step according to it) dominates the cost of obtaining it and (a bound on) the Lipschitz constant.\n3.6. A Family of Partially Biased Schemes. The choice of weights (3.10) corresponds to an equal mix of uniform and fully biased sampling. More generally, we could consider sampling according to any one of a family of weights which interpolate between uniform and fully biased sampling:\n(3.16) w\u03bb(i) = \u03bb+ (1\u2212 \u03bb)Li L , \u03bb \u2208 [0, 1].\nTo be concrete, we summarize below the a template algorithm for SGD with partially biased sampling:\nAlgorithm 3.1: Stochastic Gradient Descent with Partially Biased Sampling\nInput: \u2022 Initial estimate x0 \u2208 Rd \u2022 Bias parameter \u03bb \u2208 [0, 1] \u2022 Step size \u03b3 > 0 \u2022 Tolerance parameter \u03b4 > 0 \u2022 Access to the source distribution D \u2022 If \u03bb < 1: bounds on the Lipschitz constants Li; the weights w\u03bb(i) derived from them (see eq. 3.16); and access to the weighted distribution D(\u03bb). Output: Estimated solution x\u0302 to the problem minx F (x)\nk \u2190 0 repeat\nk \u2190 k + 1 Draw an index i \u223c D(\u03bb). xk \u2190 xk\u22121 \u2212 \u03b3w\u03bb(i)\u2207fi(xk\u22121)\nuntil \u2207F (x) \u2264 \u03b4 x\u0302 \u2190 xk\nFor arbitrary \u03bb \u2208 [0, 1], we have the bounds\nsupL(w\u03bb) = sup i\nLi\n\u03bb+ (1\u2212 \u03bb)Li L\n\u2264 min ( L 1\u2212 \u03bb, supi Li \u03bb )\nand\n\u03c32(w\u03bb) = E[ 1\n\u03bb + (1\u2212 \u03bb)Li L\n\u2016\u2207fi(x\u22c6)\u201622] \u2264 max ( 1\n\u03bb ,\nL\n(1\u2212 \u03bb) infi Li\n)\n\u03c32\nPlugging these quantities into Corollary 2.2, we obtain:\nCorollary 3.2. Let each fi be convex where \u2207fi has Lipschitz constant Li and let F (x) = Ei\u223cD[fi(x)], where F (x) is \u00b5-strongly convex. Set \u03c32 = E\u2016\u2207fi(x\u22c6)\u201622, where x\u22c6 = argminx F (x). For any desired \u03b5, using a stepsize of\n\u03b3 = \u00b5\u03b5\n2\u03b5\u00b5min (\nL 1\u2212\u03bb , supi Li \u03bb\n) + 2max (\n1 \u03bb , L (1\u2212\u03bb) infi Li\n)\n\u03c32\nwe have that after\nk = 2 log(2\u03b50/\u03b5)\n\n\nmin (\nL 1\u2212\u03bb , supi Li \u03bb\n)\n\u00b5 +\nmax (\n1 \u03bb , L (1\u2212\u03bb) infi Li\n)\n\u03c32\n\u00b52\u03b5\n\n\niterations of w-weighted SGD (3.4) with partially biased weights (3.16), E(w)\u2016xk \u2212 x\u22c6\u201622 \u2264 \u03b5, where \u03b50 = \u2016x0 \u2212 x\u22c6\u201622 and L = ELi.\nIn this corollary, even if \u03bb is close to 1, i.e. we add only a small amount of bias to the sampling, we obtain a bound with a linear dependence on the average conditioning L/\u00b5 (multiplied by a\nfactor of 1 \u03bb\n), since we can bound min (\nL 1\u2212\u03bb , supi Li \u03bb\n)\n\u2264 L 1\u2212\u03bb ."}, {"heading": "4. IMPORTANCE SAMPLING FOR SGD IN OTHER SCENARIOS", "text": "In the previous Section, we considered SGD for smooth and strongly convex objectives, and were particularly interested in the regime where the residual \u03c32 is low, and the linear convergence term is dominant. Weighted SGD could of course be relevant also in other scenarios, and we now briefly survey them, as well as relate them to our main scenario of interest.\n4.1. Smooth, Not Strongly Convex. When each component fi is convex, non-negative, and has an Li-Lipschitz gradient, but the objective F (x) is not necessarily strongly convex, then after\n(4.1) k = O\n(\n(supL)\u2016x\u22c6\u201622 \u03b5 \u00b7 F (x\u22c6) + \u03b5 \u03b5\n)\niterations of SGD with an appropriately chosen step-size we will have F (xk) \u2264 F (x\u22c6) + \u03b5, where xk is an appropriate averaging of the k iterates Srebro et al. [45]. The relevant quantity here determining the iteration complexity is again supL. Furthermore, Srebro et al. [45], relying on an example from Foygel and Srebro [13], point out that the dependence on the supremum is unavoidable and cannot be replaced with the average Lipschitz constant L. That is, if we sample gradients according to the source distribution D, we must have a linear dependence on supL.\nThe only quantity in the bound (4.1) that changes with a re-weighting is supL\u2014all other quantities (\u2016x\u22c6\u201622, F (x\u22c6), and the sub-optimality \u03b5) are invariant to re-weightings. We can therefor replace the dependence on supL with a dependence on supL(w) by using a weighted SGD as in (3.4). As we already calculated, the optimal weights are given by (3.6), and using them we have supL(w) = L. In this case, there is no need for partially biased sampling, and we obtain that with an appropriate step-size,\n(4.2) k = O\n(\nL\u2016x\u22c6\u201622 \u03b5 \u00b7 F (x\u22c6) + \u03b5 \u03b5\n)\niterations of weighed SGD updates (3.4) using the weights (3.6) suffice. We again see that using importance sampling allows us to reduce the dependence on supL, which is unavoidable without biased sampling, to a dependence on L.\n4.2. Non-Smooth Objectives. We now turn to non-smooth objectives, where the components fi might not be smooth, but each component is Gi-Lipschitz. Roughly speaking, Gi is a bound on the first derivative (gradient) of fi, while Li is a bound on the second derivatives of fi. Here, the performance of SGD depends on the second momentG2 = E[G2i ]. The precise iteration complexity depends on whether the objective is strongly convex or whether x\u22c6 is bounded, but in either case depends linearly on G2 (see e.g. [32, 43]).\nBy using weighted SGD we can replace the linear dependence on G2 with a linear dependence\non G2(w) = E (w)\n[\n(G (w) i )\n2 ]\n, where G(w)i is the Lipschitz constant of the scaled f (w) i and is given\nby G(w)i = Gi/w(i). Again, this follows directly from the standard SGD guarantees, where we consider the representation (3.3) and use any subgradient from \u2202f (w)i (x).\nWe can calculate:\n(4.3) G2(w) = E (w)\n[\nG2i w(i)2\n]\n= E\n[\nG2i w(i)\n]\nwhich is minimized by the weights:\n(4.4) w(i) = Gi\nG\nwhere G = EGi. Using these weights we have G2(w) = E[Gi] 2 = G\n2 . Using importance sampling,\nwe can thus reduce the linear dependence on G2 to a linear dependence on G 2 . Its helpful to recall that G2 = G 2 +Var[Gi]. What we save is therefore exactly the variance of the Lipschitz constants Gi. In parallel work, Zhao and Zhang [51] also consider importance sampling for stochastic optimization for non-smooth objectives. Zhao and Zhang consider a more general setting, with a composite objective that is only partially linearized. But also there, the iteration complexity depends on the second moment of the gradient estimates, and the analysis performed above applies (Zhao and Zhang perform a specialized analysis instead).\n4.3. Non-Realizable Regime. Returning to the smooth and strongly convex setting of Sections 2 and 3, let us consider more carefully the residual term \u03c32 = E\u2016\u2207fi(x\u22c6)\u201622. This quantity definitively depends on the weighting, and in the analysis of Section 3.3, we avoided increasing it too much, introducing partial biasing for this purpose. However, if this is the dominant term, we might want to choose weights so as to minimize this term. The optimal weights here would be proportional to \u2016\u2207fi(x\u22c6)\u20162. The problem is that we do not know the minimizer x\u22c6, and so cannot calculate these weights. Approaches which dynamically update the weights based on the current iterates as a surrogate for x\u22c6 are possible, but beyond the scope of this paper.\nAn alternative approach is to bound \u2016\u2207fi(x\u22c6)\u20162 \u2264 Gi and so \u03c32 \u2264 G2. Taking this bound, we are back to the same quantity as in the non-smooth case, and the optimal weights are proportional to Gi. Note that this is a different weighting then using weights proportional to Li, which optimize the linear-convergence term as studied in Section 3.3.\nTo understand how weighting according to Gi and Li are different, consider a generalized linear objective where fi(x) = \u03c6i(\u3008zi, x\u3009), and \u03c6i is a scalar function with |\u03c6\u2032i| \u2264 G\u03c6 and |\u03c6\u2032\u2032i | \u2264 L\u03c6. We have that Gi \u221d \u2016zi\u20162 while Li \u221d \u2016zi\u201622. Weighting according to the Lipschitz constants of the gradients, i.e. the \u201csmoothness\u201d parameters, as in (3.6), versus weighting according to the Lipschitz\nconstants of fi as in (4.4), thus corresponds to weighting according to \u2016zi\u201622 versus \u2016zi\u20162, and are rather different. We can also calculate that weighing by Li \u221d \u2016zi\u201622 (i.e. following (3.6)), yields G2(w) = G 2 > G 2 . That is, weights proportional to Li yield a suboptimal gradient-dependent term (the same dependence as if no weighting at all was used). Conversely, using weights proportional to Gi, i.e. proportional to \u2016zi\u20162 yields supL(w) = (E[ \u221a Li]) \u221a supL \u2013 a suboptimal dependence, though better then no weighting at all. Again, as with partially biased sampling, we can weight by the average, w(i) = 1\n2 \u00b7 Gi G\u0304 + 1 2 \u00b7 Li L\u0304\nand ensure both terms are optimal up to a factor of two."}, {"heading": "5. THE LEAST SQUARES CASE AND THE RANDOMIZED KACZMARZ METHOD", "text": "A special case of interest is the least squares problem, where\n(5.1) F (x) = 1\n2\nn \u2211\ni=1\n(\u3008ai,x\u3009 \u2212 bi)2 = 1\n2 \u2016Ax\u2212 b\u201622\nwith b an n-dimensional vector, A an n\u00d7 d matrix with rows ai, and x\u22c6 = argminx 12\u2016Ax\u2212 b\u201622 is the least-squares solution. Writing the least squares problem (5.1) in the form (2.1), we see that the source distribution D is uniform over {1, 2, . . . , n}, the components are fi = n2 (\u3008ai,x\u3009 \u2212 bi)2, the Lipschitz constants are Li = n\u2016ai\u201622, the average Lipschitz constant is 1n \u2211\ni Li = \u2016A\u20162F , the strong convexity parameter is \u00b5 = 1\n\u2016(ATA)\u22121\u20162 , so that K(A) := L/\u00b5 = \u2016A\u20162F\u2016(ATA)\u22121\u20162, and\nthe residual is \u03c32 = n \u2211 i\u2016ai\u201622| \u3008ai, x\u22c6\u3009 \u2212 bi|2. Note that in the case that A is not full-rank, one can instead replace \u00b5 with the smallest nonzero eigenvalue of A\u2217A as in [23, Equation (3)]. In that case, we instead write K(A) = \u2016A\u20162F\u2016(ATA)\u2020\u20162 as the appropriate condition number.\nThe randomized Kaczmarz method [46, 7, 17, 27, 49, 8, 47, 15, 52, 28] for solving the least squares problem (5.1) begins with an arbitrary estimate x0, and in the kth iteration selects a row i = i(k) i.i.d. at random from the matrix A and iterates by:\n(5.2) xk+1 = xk + c \u00b7 bi \u2212 \u3008ai,xk\u3009\n\u2016ai\u201622 ai,\nwhere the step size c = 1 in the standard method. Strohmer and Vershynin provided the first non-asymptotic convergence rates, showing that drawing rows proportionally to \u2016ai\u201622 leads to provable exponential convergence in expectation for the full-rank case [46]. Their method can easily be extended to the case when the matrix is not full-rank to yield convergence to some solution, see e.g. [23, Equation (3)]. Recent works use acceleration techniques to improve convergence rates [22, 34, 11, 38, 52, 12, 10, 6, 35, 36, 37, 30, 29].\nHowever, one can easily verify that the iterates (5.2) are precisely weighted SGD iterates (3.4) with the fully biased weights (3.6).\nThe reduction of the quadratic dependence on the conditioning to a linear dependence in Theorem 2.1, as well as the use of biased sampling which we investigate here was motivated by Strohmer and Vershynin\u2019s analysis of the randomized Kaczmarz method. Indeed, applying Theorem 2.1 to the weighted SGD iterates (2.2) for (5.1) with the weights (3.6) and a stepsize of \u03b3 = 1 yields precisely the Strohmer and Vershynin [46] guarantee.\nUnderstanding the randomized Kaczmarz method as SGD allows us also to obtain improved methods and results for the randomized Kaczmarz method:\nUsing Step-sizes. As shown by Strohmer and Vershynin [46] and extended by Needell [28], the randomized Kaczmarz method with weighted sampling exhibits exponential convergence, but only to within a radius, or convergence horizon, of the least-squares solution. This is because a stepsize of \u03b3 = 1 is used, and so the second term in (2.4) does not vanish. It has been shown [49, 8, 47, 15, 30] that changing the step size can allow for convergence inside of this convergence horizon, although non-asymptotic results have been difficult to obtain. Our results allow for finiteiteration guarantees with arbitrary step-sizes and can be immediately applied to this setting. Indeed, applying Theorem 2.1 with the weights (3.6) gives\nCorollary 5.1. Let A be an n\u00d7d matrix with rows ai. Set e = Ax\u22c6\u2212b, where x\u22c6 is the minimizer of the problem\nx\u22c6 = argmin x\n1 2 \u2016Ax\u2212 b\u201622.\nSuppose that c < 1. Set a2min = inf i\u2016ai\u201622, a2max = supi\u2016ai\u201622. Then the expected error at the kth iteration of the Kaczmarz method described by (5.2) with row ai selected with probability pi = \u2016ai\u201622/\u2016A\u20162F satisfies\n(5.3) E\u2016xk \u2212 x\u22c6\u201622 \u2264 [ 1\u2212 2c(1\u2212 c) K(A) ]k \u2016x0 \u2212 x\u22c6\u201622 + c 1\u2212 cK(A)r,\nwith r = \u03c3 2\nn\u2016A\u20162 F \u00b7a2min . The expectation is taken with respect to the weighted distribution over the rows.\nWhen e.g. c = 1 2 , we recover the exponential rate of Strohmer and Vershynin [46] up to a factor of 2, and nearly the same convergence horizon. For arbitrary c, Corollary 5.1 implies a tradeoff between a smaller convergence horizon and a slower convergence rate.\nUniform Row Selection. The Kaczmarz variant of Strohmer and Vershynin [46] calls for weighted row sampling, and thus requires pre-computing all the row norms. Although certainly possible in some applications, in other cases this might be better avoided. Understanding the randomized Kaczmarz as SGD allows us to apply Theorem 2.1 also with uniform weights (i.e. to the unbiased SGD), and obtain a randomized Kaczmarz using uniform sampling, which converges to the leastsquares solution and enjoys finite-iteration guarantees:\nCorollary 5.2. Let A be an n \u00d7 d matrix with rows ai. Let D be the diagonal matrix with terms dj,j = \u2016ai\u20162, and consider the composite matrix D\u22121A. Set ew = D\u22121(Axw\u22c6 \u2212 b), where xw\u22c6 is the minimizer of the weighted least squares problem\nxw\u22c6 = argmin x\n1 2 \u2016D\u22121(Ax\u2212 b)\u201622.\nSuppose that c < 1. Then the expected error after k iterations of the Kaczmarz method described by (5.2) with uniform row selection satisfies\nE\u2016xk \u2212 xw\u22c6 \u201622 \u2264 [ 1\u2212 2c(1\u2212 c) K(D\u22121A) ) ]k \u2016x0 \u2212 xw\u22c6 \u201622 + c 1\u2212 cK(D \u22121A)rw,\nwhere rw = \u2016ew\u201622/n.\nNote that the randomized Kaczmarz algorithm with uniform row selection converges exponentially to a weighted least-squares solution, to within arbitrary accuracy by choosing sufficiently small stepsize c. Thus, in general, the randomized Kaczmarz algorithms with uniform and biased row selection converge (up to a convergence horizon) towards different solutions.\nPartially Biased Sampling. As in our SGD analysis, using the partially biased sampling weights is applicable also for the randomized Kaczmarz method. Applying Theorem 2.1 using weights (3.10) gives\nCorollary 5.3 (Randomized Kaczmarz with partially biased sampling). Let A be an n\u00d7 d matrix with rows ai. Set e = Ax\u22c6 \u2212 b, where x\u22c6 is the minimizer of the problem\nx\u22c6 = argmin x\n1 2 \u2016Ax\u2212 b\u201622.\nSuppose c < 1/2. Then the iterate xk of the modified Kaczmarz method described by\n(5.4) xk+1 = xk + 2c \u00b7 bi \u2212 \u3008ai,xk\u3009\n\u2016A\u20162F/n+ \u2016ai\u201622 ai\nwith row ai selected with probability pi = 1 2 \u00b7 \u2016ai\u2016\n2 2 \u2016A\u20162 F + 1 2 \u00b7 1 n satisfies\n(5.5) E\u2016xk \u2212 x\u22c6\u201622 \u2264 [ 1\u2212 2c(1\u2212 2c) K(A) ]k \u2016x0 \u2212 x\u22c6\u201622 + cK(A) 1\u2212 2c \u00b7 2\u03c32\nn\u2016A\u20162F The partially biased randomized Kaczmarz method described above (which does have modified update equation (5.4) compared to the standard update equation (5.2)) yields the same convergence rate as the fully biased randomized Kaczmarz method [46] (up to a factor of 2), but gives a better dependence on the residual error over the fully biased sampling, as the final term in (5.5) is smaller than the final term in (5.3)."}, {"heading": "6. NUMERICAL EXPERIMENTS", "text": "In this section we present some numerical results for the randomized Kaczmarz algorithm with partially biased sampling, that is, applying Algorithm 3.1 to the least squares problem F (x) = 1 2 \u2016Ax \u2212 b\u201622 (so fi(x) = n2 (\u3008ai, x\u3009 \u2212 bi)2) and considering \u03bb \u2208 [0, 1]. Recall that \u03bb = 0 corresponds to the randomized Kaczmarz algorithm of Strohmer and Vershynin with fully weighted sampling [46]. \u03bb = .5 corresponds to the partially biased randomized Kaczmarz algorithm outlined in Corollary 5.3. We demonstrate how the behavior of the algorithm depends on \u03bb, the conditioning of the system, and the residual error at the least squares solution. We focus on exploring the role of \u03bb on the convergence rate of the algorithm for various types of matrices A. We consider five types of systems, described below, each using a 1000\u00d710 matrix A. In each setting, we create a vector x with standard normal entries. For the described matrix A and residual e, we create the system b = Ax + e and run the randomized Kaczmarz method with various choices of \u03bb. Each experiment consists of 100 independent trials and uses the optimal step size as in Corollary 3.2 with \u03b5 = .1; the plots show the average behavior over these trials. The settings below show the various types of behavior the Kazcmarz method can exhibit.\nCase 1: Each row of the matrix A has standard normal entries, except the last row which has normal entries with mean 0 and variance 102. The residual vector e has normal entries with mean 0 and variance 0.12. Case 2: Each row of the matrix A has standard normal entries. The residual vector e has normal entries with mean 0 and variance 0.12. Case 3: The jth row of A has normal entries with mean 0 and variance j. The residual vector e has normal entries with mean 0 and variance 202. Case 4: The jth row of A has normal entries with mean 0 and variance j. The residual vector e has normal entries with mean 0 and variance 102. Case 5: The jth row of A has normal entries with mean 0 and variance j. The residual vector e has normal entries with mean 0 and variance 0.12.\nFigure 1 shows the convergence behavior of the randomized Kaczmarz method in each of these five settings. As expected, when the rows of A are far from normalized, as in Case 1, we see different behavior as \u03bb varies from 0 to 1. Here, weighted sampling (\u03bb = 0) significantly outperforms uniform sampling (\u03bb = 1), and the trend is monotonic in \u03bb. On the other hand, when the rows of A are close to normalized, as in Case 2, the various \u03bb give rise to similar convergence rates, as is expected. Out of the \u03bb tested (we tested increments of 0.1 from 0 to 1), the choice \u03bb = 0.7 gave the worst convergence rate, and again purely weighted sampling gives the best. Still, the worst-case convergence rate was not much worse, as opposed to the situation with uniform sampling in Case 1. Cases 3, 4, and 5 use matrices with varying row norms and cover \u201chigh\u201d, \u201cmedium\u201d, and \u201clow\u201d noise regimes, respectively. In the high noise regime (Case 3), we find that fully weighted sampling, \u03bb = 0, is relatively very slow to converge, as the theory suggests, and hybrid sampling outperforms both weighted and uniform selection. In the medium noise regime (Case 4), hybrid sampling still outperforms both weighted and uniform selection. Again, this is not surprising, since hybrid sampling allows a balance between small convergence horizon (important with large residual norm) and convergence rate. As we decrease the noise level (as in Case 5), we see that again weighted sampling is preferred.\nFigure 2 shows the number of iterations of the randomized Kaczmarz method needed to obtain a fixed approximation error. For the choice \u03bb = 1 for Case 1, we cut off the number of iterations after 50,000, at which point the desired approximation error was still not attained. As seen also from Figure 1, Case 1 exhibits monotonic improvements as we scale \u03bb. For Cases 2 and 5, the optimal choice is pure weighted sampling, whereas Cases 3 and 4 prefer intermediate values of \u03bb."}, {"heading": "7. SUMMARY AND OUTLOOK", "text": "We consider this paper as making three contributions: the improved dependence on the conditioning for smooth and strongly convex SGD, the discussion of importance sampling for SGD, and the connection between SGD and the randomized Kaczmarz method.\nFor simplicity, we only considered SGD iterates with a fixed step-size \u03b3. This is enough for getting the optimal iteration complexity if the target accuracy \u03b5 is known in advance, which was our approach in this paper. It is easy to adapt the analysis, using standard techniques, to incorporate decaying step-sizes, which are appropriate if we don\u2019t know \u03b5 in advance.\nWe suspect that the assumption of strong convexity can be weakened to restricted strong convexity [21, 50] without changing any of the results of this paper; we leave this analysis to future work.\nCase 1: Case 2:\nFinally, our discussion of importance sampling is limited to a static reweighting of the sampling distribution. A more sophisticated approach would be to update the sampling distribution dynamically as the method progresses, and as we gain more information about the relative importance of components. Although such dynamic importance sampling is sometimes attempted heuristically, we are not aware of any rigorous analysis of such a dynamic biasing scheme."}, {"heading": "ACKNOWLEDGEMENTS", "text": "We would like to thank the anonymous reviewers for their useful feedback which significantly improved the manuscript. We would like to thank Chris White for pointing out a simplified proof of Corollary 2.2. DN was partially supported by a Simons Foundation Collaboration grant, NSF CAREER #1348721 and an Alfred P. Sloan Fellowship. NS was partially supported by a Google Research Award. RW was supported in part by ONR Grant N00014-12-1-0743, an AFOSR Young Investigator Program Award, and an NSF CAREER award."}, {"heading": "APPENDIX A. PROOFS", "text": "Our main results utilize an elementary fact about smooth functions with Lipschitz continuous gradient, called the co-coercivity of the gradient. We state the lemma and recall its proof for completeness.\nA.1. The Co-coercivity Lemma.\nLemma A.1 (Co-coercivity). For a smooth function f whose gradient has Lipschitz constant L,\n\u2016\u2207f(x)\u2212\u2207f(y)\u201622 \u2264 L \u3008x\u2212 y,\u2207f(x)\u2212\u2207f(y)\u3009 .\nProof. Since \u2207f has Lipschitz constant L, if x\u22c6 is the minimizer of f , then [see e.g. 32, page 26] (A.1)\n1\n2L \u2016\u2207f(x)\u2212\u2207f(x\u22c6)\u201622 =\n1\n2L \u2016\u2207f(x)\u2212\u2207f(x\u22c6)\u201622 + \u3008x\u2212 x\u22c6,\u2207f(x\u22c6)\u3009 \u2264 f(x)\u2212 f(x\u22c6);\nNow define the convex functions\nG(z) = f(z)\u2212 \u3008\u2207f(x), z\u3009 , and H(z) = f(z)\u2212 \u3008\u2207f(y), z\u3009 ,\nand observe that both have Lipschitz constants L and minimizers x and y, respectively. Applying (A.1) to these functions therefore gives that\nG(x) \u2264 G(y)\u2212 1 2L \u2016\u2207G(y)\u201622, and H(y) \u2264 H(x)\u2212 1 2L \u2016\u2207H(y)\u201622.\nBy their definitions, this implies that\nf(x)\u2212 \u3008\u2207f(x),x\u3009 \u2264 f(y)\u2212 \u3008\u2207f(x),y\u3009 \u2212 1 2L \u2016\u2207f(y)\u2212\u2207f(x)\u201622 f(y)\u2212 \u3008\u2207f(y),y\u3009 \u2264 f(x)\u2212 \u3008\u2207f(y),x\u3009 \u2212 1 2L \u2016\u2207f(x)\u2212\u2207f(y)\u201622.\nAdding these two inequalities and canceling terms yields the desired result.\nA.2. Proof of Theorem 2.1. With the notation of Theorem 2.1, and where i is the random index chosen at iteration k, and w = w\u03bb, we have\n\u2016xk+1 \u2212 x\u22c6\u201622 = \u2016xk \u2212 x\u22c6 \u2212 \u03b3\u2207fi(xk)\u201622 = \u2016(xk \u2212 x\u22c6)\u2212 \u03b3(\u2207fi(xk)\u2212\u2207fi(x\u22c6))\u2212 \u03b3\u2207fi(x\u22c6)\u201622 = \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u3009+ \u03b32\u2016\u2207fi(xk)\u2212\u2207fi(x\u22c6) +\u2207fi(x\u22c6)\u201622 \u2264 \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u3009+ 2\u03b32\u2016\u2207fi(xk)\u2212\u2207fi(x\u22c6)\u201622 + 2\u03b32\u2016\u2207fi(x\u22c6)\u201622 \u2264 \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u3009\n+ 2\u03b32Li \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u2212\u2207fi(x\u22c6)\u3009+ 2\u03b32\u2016\u2207fi(x\u22c6)\u201622,\nwhere we have employed Jensen\u2019s inequality in the first inequality and the co-coercivity Lemma A.1 in the final line. We next take an expectation with respect to the choice of i. By assumption, i \u223c D such that F (x) = Efi(x) and \u03c32 = E\u2016\u2207fi(x\u22c6)\u20162. Then E\u2207fi(x) = \u2207F (x), and we obtain:\nE\u2016xk+1 \u2212 x\u22c6\u201622 \u2264 \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207F (xk)\u3009+ 2\u03b32E [Li \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u2212\u2207fi(x\u22c6)\u3009] + 2\u03b32E\u2016\u2207fi(x\u22c6)\u201622\n\u2264 \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207F (xk)\u3009+ 2\u03b32 sup i LiE \u3008xk \u2212 x\u22c6,\u2207fi(xk)\u2212\u2207fi(x\u22c6)\u3009 + 2\u03b32E\u2016\u2207fi(x\u22c6)\u201622 = \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3 \u3008xk \u2212 x\u22c6,\u2207F (xk)\u3009+ 2\u03b32 supL \u3008xk \u2212 x\u22c6,\u2207F (xk)\u2212\u2207F (x\u22c6)\u3009+ 2\u03b32\u03c32\nWe now utilize the strong convexity of F (x) and obtain that\n\u2264 \u2016xk \u2212 x\u22c6\u201622 \u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL)\u2016xk \u2212 x\u22c6\u201622 + 2\u03b32\u03c32 = (1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL))\u2016xk \u2212 x\u22c6\u201622 + 2\u03b32\u03c32\nwhen \u03b3 \u2264 1 supL . Recursively applying this bound over the first k iterations yields the desired result,\nE\u2016xk \u2212 x\u22c6\u201622 \u2264 ( 1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL) ))k \u2016x0 \u2212 x\u22c6\u201622 + 2 k\u22121 \u2211\nj=0\n( 1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL) ))j \u03b32\u03c32\n\u2264 ( 1\u2212 2\u03b3\u00b5(1\u2212 \u03b3 supL) ))k \u2016x0 \u2212 x\u22c6\u201622 + \u03b3\u03c32\n\u00b5 ( 1\u2212 \u03b3 supL ) ."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "We obtain an improved finite-sample guarantee on the linear convergence of stochastic<lb>gradient descent for smooth and strongly convex objectives, improving from a quadratic dependence<lb>on the conditioning (L/\u03bc) (where L is a bound on the smoothness and \u03bc on the strong convexity)<lb>to a linear dependence on L/\u03bc. Furthermore, we show how reweighting the sampling distribution<lb>(i.e. importance sampling) is necessary in order to further improve convergence, and obtain a linear<lb>dependence in the average smoothness, dominating previous results. We also discuss importance<lb>sampling for SGD more broadly and show how it can improve convergence also in other scenarios.<lb>Our results are based on a connection we make between SGD and the randomized Kaczmarz<lb>algorithm, which allows us to transfer ideas between the separate bodies of literature studying each<lb>of the two methods. In particular, we recast the randomized Kaczmarz algorithm as an instance of<lb>SGD, and apply our results to prove its exponential convergence, but to the solution of a weighted<lb>least squares problem rather than the original least squares problem. We then present a modified<lb>Kaczmarz algorithm with partially biased sampling which does converge to the original least squares<lb>solution with the same exponential convergence rate.<lb>", "creator": "LaTeX with hyperref package"}}}