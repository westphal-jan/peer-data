{"id": "1312.6134", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "An Algebra of Causal Chains", "abstract": "In this work, we propose a multi-value extension of logic programs within the semantics of stable models, in which each true atom in a model is linked to a series of justifications, in a spirit similar to that of a series of evidence trees. The main contribution of this work is that we capture justifications in an algebra of truth values with three internal operations: an addendum \"+,\" which represents alternative justifications for a formula, a commutative product \"*,\" which represents a common interaction of causes and a non-commutative product. \"Following this multi-value semantics, we obtain a one-to-one agreement between the syntactic evidence tree of a standard (non-causal) logic program and the interpretation of each true atom in a model. Furthermore, thanks to this algebraic characterization, we can discern semantic properties such as redundancy and relevance of the justifications obtained.", "histories": [["v1", "Fri, 20 Dec 2013 21:07:19 GMT  (36kb,D)", "http://arxiv.org/abs/1312.6134v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["pedro cabalar", "jorge fandinno"], "accepted": false, "id": "1312.6134"}, "pdf": {"name": "1312.6134.pdf", "metadata": {"source": "CRF", "title": "An Algebra of Causal Chains", "authors": ["Pedro Cabalar", "Jorge Fandinno"], "emails": ["jorge.fandino}@udc.es"], "sections": [{"heading": "1 Introduction", "text": "A frequent informal way of explaining the effect of default negation in an introductory class on semantics in logic programming (LP) is that a literal of the form \u2018not p\u2019 should be read as \u201cthere is no way to derive p.\u201d Although this idea seems quite intuitive, it is actually using a concept outside the discourse of any of the existing LP semantics: the ways to derive p. To explore this idea, [1] introduced the so-called causal logic programs. The semantics was an extension of stable models [2] relying on the idea of \u201cjustification\u201d or \u201cproof\u201d. Any true atom, in a standard (non-causal) stable model needs to be justified. In a causal stable model, the truth value of each true atom captures these possible justifications, called causes. Let us see an example to illustrate this.\nExample 1. Suppose we have a row boat with two rowers, one at each side of the boat, port and starboard. The boat moves forward fwd if both rowers strike at a time. On the other hand, if we have a following wind, the boat moves forward anyway.\n? This research was partially supported by Spanish MEC project TIN2009-14562-C05-04 and Xunta program INCITE 2011.\nar X\niv :1\n31 2.\n61 34\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nSuppose now that we have indeed that both rowers stroke at a time when we additionally had a following wind. A possible encoding for this example could be the set of rules \u03a01:\np : port s : starb w : fwind\nfwd\u2190 port \u2227 starb fwd\u2190 fwind\nIn the only causal stable model of this program, atom fwd was justified by two alternative and independent causes. On the one hand, cause {p, s} representing the joint interaction of port and starb. On the other hand, cause {w} inherited from fwind. We label rules (in the above program only atoms) that we want to be reflected in causes. Unlabelled fwd rules are just ignored when reflecting causal information. For instance, if we decide to keep track of the application of these rules, we would handle instead a program \u03a02 obtained just by labelling these two rules in \u03a01 as follows:\na : fwd\u2190 port \u2227 starb (1) b : fwd\u2190 fwind (2)\nThe two alternative justifications for atom fwd become the pair of causes {p, s} \u00b7 a and {w} \u00b7 b. The informal reading of {p, s} \u00b7 a is that \u201cthe joint interaction of {p} and {s}, the cause {p, s}, is necessary to apply rule a.\u201d From a graphical point of view, we can represent causes as proof trees.\nIn this paper, we show that causes can be embedded in an algebra with three internal operations: an addition \u2018+\u2019 representing alternative justifications for a formula, a commutative product \u2018\u2217\u2019 representing joint interaction of causes (in a similar spirit to the \u2018+\u2019 in [3]) and a non-commutative product \u2018\u00b7\u2019 acting as a concatenation or rule application. Using these operations, we can see that justification for fwd would correspond now to the value ((p \u2217 s) \u00b7 a) + (w \u00b7 b) which means that fwd is justified by the two alternative causes, (p \u2217 s) \u00b7 a and (w \u00b7 b). The former refers to the application of rule a to the join interaction of p and s. Similarly, the later refers to the application of rule b to w. From a graphical point of view, each cause corresponds to one of proof trees in the Figure 1, the right hand side operator of application corresponds to the head whereas the left hand side operator corresponds to the product of its children.\nThe rest of the paper is organised as follows. Section 2 describes the algebra with these three operations and a quite natural ordering relation on causes. The next section studies the semantics for positive logic programs and shows the correspondence between the syntactic proof tree of a standard (non-causal) logic program and the interpretation of each atom in a causal model. Section 4 introduces default negation and stable models. Finally, Section 5 concludes the paper."}, {"heading": "2 Algebra of causal values", "text": "As we have introduced, our set of causal values will constitute an algebra with three internal operations: addition \u2018+\u2019 representing alternative causes, product \u2018\u2217\u2019 representing joint interaction between causes and rule application \u2018\u00b7\u2019. We define now causal terms, the syntactic counterpart of (causal) values, just as combinations of these three operations over labels (events).\nDefinition 1 (Causal term). A causal term, t, over a set of labels Lb is recursively defined as one of the following expressions:\nt ::= l | \u220f ti\u2208S ti | \u2211 ti\u2208S ti | t1 \u00b7 t2\nwhere l is a label l \u2208 Lb, t1, t2 are in their turn causal terms and S is a (possibly empty or possibly infinite) set of causal terms. The set of causal terms over Lb is denoted by TLb.\nAs we can see, infinite products and sums are allowed whereas a term may only contain a finite number of concatenation applications. Constants 0 and 1 will be shorthands for the empty sum \u2211 t\u2208\u2205 t and the empty product \u220f t\u2208\u2205 t, respectively.\nWe adopt the following notation. To avoid an excessive use of parentheses, we assume that \u2018\u00b7\u2019 has the highest priority, followed by \u2018\u2217\u2019 and \u2018+\u2019 as usual, and we further note that the three operations will be associative. When clear from the context, we will sometimes remove \u2018\u00b7\u2019 so that, for instance, the term l1l2 stands for l1 \u00b7 l2. As we will see, two (syntactically) different causal terms may correspond to the same causal value. However, we will impose Unique Names Assumption (UNA) for labels, that is, l 6= l\u2032 for any two (syntactically) different labels l, l\u2032 \u2208 Lb, and similarly l 6= 0 and l 6= 1 for any label l.\nTo fix properties of our algebra we recall that addition \u2018+\u2019 represents a set of alternative causes and product \u2018\u2217\u2019 a set of causes that are jointly used. Thus, since both represent sets, they are associative, commutative and idempotent. Contrary, although associative, application \u2018\u00b7\u2019 is not commutative. Note that the right hand side operator represents the applied rule and left hand one represents a cause that is necessary to apply it, therefore they are clearly not interchangeable. We can note another interesting property: application \u2018\u00b7\u2019 distributes over both addition \u2018+\u2019 and product \u2018\u2217\u2019. To illustrate this idea, consider the following variation of our example. Suppose now that the boat also leaves a wake behind when it moves forward. Let \u03a03 be the set of rules \u03a01 plus the rule k : wake \u2190 fwd reflecting this new assumption. As we saw, fwd is justified by p \u2217 s + w and thus wake will be justified by applying rule k : wake \u2190 fwd to it, i.e.the value (p \u2217 s + w) \u00b7 k. We can also see that there are two alternative causes justifying wake, graphically represented in the Figure 2. The term that corresponds which this graphical representation is (p \u2217 s) \u00b7 k + w \u00b7 k = (p \u2217 s + w) \u00b7 k. Moreover, application \u2018\u00b7\u2019 also distributes over product \u2018\u2217\u2019 and (p \u2217 s) \u00b7 k + w \u00b7 k is equivalent to (p \u00b7k) \u2217 (s \u00b7k)+ (w \u00b7k). Intuitively, if the joint iteration of p and s is necessary to apply k then both p and s are also necessary to apply it, and conversely. Note that each chain of applications , (p \u00b7 k), (s \u00b7 k) and (w \u00b7 k) corresponds to a path in one of the trees in the Figure 2. Causes can be seen as sets (products) of paths (causal chains).\nDefinition 2 (Causal Chain). A causal chain x over a set of labels Lb is a sequence x = l1 \u00b7 l2 \u00b7 . . . \u00b7 ln, or simply l1l2 . . . ln, with length |x| = n > 0 and li \u2208 Lb.\nWe denote XLb to stand for the set of causal chains over Lb and will use letters x, y, z to denote elements from that set. It suffices to have a non-empty set of labels, say Lb = {a}, to get an infinite set of chains XLb = {a, aa, aaa, . . . }, although all of them have a finite length. It is easy to see that, by an exhaustive application of distributivity, we can \u201cshift\u201d inside all occurrences of the application operator so that it only occurs in the scope of other application operators. A causal term obtained in this way is a normal causal term.\nDefinition 3 (Normal causal term). A causal term, t, over a set of labels Lb is recursively defined as one of the following expressions:\nt ::= x | \u220f ti\u2208S ti | \u2211 ti\u2208S ti\nwhere x \u2208 XLb is a causal chain over Lb and S is a (possibly empty or possibly infinite) set of normal causal terms. The set of causal terms over Lb is denoted by ULb.\nProposition 1. Every causal term t can be normalized, i.e. written as an equivalent normal causal term u.\nIn the same way as application \u2018\u00b7\u2019 distributes over addition \u2018+\u2019 and product \u2018\u2217\u2019, the latter, in their turn, also distributes over addition \u2018+\u2019. Consider a new variation of our example to illustrate this fact. Suppose that we have now two port rowers that can strike, encoded as the set of rules \u03a04:\np1 : port1 p2 : port2 s : starb\nport\u2190 port1 port\u2190 port2 fwd\u2190 port \u2227 starb\nWe can see that, in the only causal stable model of this program, atom portwas justified by two alternative, and independent causes, p1 and p2, and after applying unlabelled rules to them, the resulting value assigned to fwd is (p1 + p2) \u2217 s. It is also clear that there are two alternative causes justifying fwd: the result from combining the starboard rower strike with each of the port rower strikes, p1 \u2217 s and p2 \u2217 s. That is, causal terms (p1 + p2) \u2217 s and p1 \u2217 s+ p2 \u2217 s are equivalent.\nFurthermore, as we introduce above, causes can be ordered by a notion of \u201cstrength\u201d of justification. For instance, in our example, fwd is justified by two independent\ncauses, p \u2217 s + w while fwind is only justified by w. If we consider the program \u03a05 obtained by removing the fact w : fwind from \u03a01 then fwd keeps being justified by p \u2217 s but fwind becomes false. That is, fwd is \u201cmore strongly justified\u201d than fwind in \u03a01, written w \u2264 p \u2217 s + w. Similarly, p \u2217 s \u2264 p \u2217 s + w. Note also that, in this program \u03a05, fwd needs the joint interaction of p and s to be justified but port and starb only need p and s, respectively. That is, p is \u201cmore strongly justified\u201d than p \u2217 s, written p \u2217 s \u2264 p. Similarly, p \u2217 s \u2264 s. We can also see that in program \u03a02 which labels rules for fwd, one of the alternative causes for fwd is w \u00b7 b and this is \u201cless strongly justified\u201d than w, i.e. w \u00b7 b \u2264 w since, from a similar reasoning, w \u00b7 b needs the application of b to w when w only requires itself. In general, we will see that a \u00b7b \u2264 a\u2217b \u2264 X \u2264 a+b whereX can be either a or b. We formalize this order relation starting for causal chains. Notice that a causal chain x = l1l2 . . . ln can be alternatively characterized as a partial function from naturals to labels x : N \u2212\u2192 Lb where x(i) = li for all i \u2264 n and undefined for i > n. Using this characterisation, we can define the following partial order among causal chains:\nDefinition 4 (Chain subsumption). Given two causal chains x and y \u2208 XLb, we say that y subsumes x, written x \u2264 y, if and only if there exists a strictly increasing function \u03b4 : N \u2212\u2192 N such that for each i \u2208 N with y(i) defined, x ( \u03b4(i) ) = y(i).\nProposition 2. Given two finite causal chains x, y \u2208 XLb, they are equivalent (i.e. both x \u2264 y and y \u2264 x) if and only if they are syntactically identical.\nInformally speaking, y subsumes x, when we can embed y into x, or alternatively when we can form y by removing (or skipping) some labels from x. For instance, take the causal chains x = abcde and y = ac. Clearly we can form y = ac = a \u00b7 b \u00b7 c \u00b7 d \u00b7 e by removing b, d and e from x. Formally, x \u2264 y because we can take some strictly increasing function with \u03b4(1) = 1 and \u03b4(2) = 3 so that y(1) = x(\u03b4(1)) = x(1) = a and y(2) = x(\u03b4(2)) = x(3) = c.\nAlthough, at a first sight, it may seem counterintuitive the fact that x \u2264 y implies |x| \u2265 |y|, as we mentioned, a fact or formula is \u201cmore strongly justified\u201d when we need to apply less rules to derive it (and so, causal chains contain less labels) respecting their ordering. In this way, chain ac is a \u201cmore strongly justification\u201d than abcde.\nAs we saw above, a cause can be seen as a product of causal chains, that from a graphical point of view correspond to the set of paths in a proof tree. We notice now an interesting property relating causes and the \u201cmore strongly justified\u201d order relation: a joint interaction of comparable causal chains should collapse to the weakest among them. Take, for instance, a set of rules \u03a06:\na : p b : q \u2190 p r \u2190 p \u2227 q\nwhere, in the unique causal stable model, r corresponds to the value a\u2217a \u00b7 b. Informally we can read this as \u201cwe need a and apply rule b to rule a to prove r\u201d. Clearly, we are repeating that we need a. Term a is redundant and then a\u2217a\u00b7b is simply equivalent to a\u00b7b. This idea is quite related to the definition of order filter in order theory. An order filter F of a poset P is a special subset F \u2286 P satisfying1 that for any x \u2208 F and y \u2208 P , x \u2264 y\n1 Order filter is a weaker notion than filter which further satisfies that any pair x, y \u2208 F has a lower bound in F too.\nimplies y \u2208 F . An order filter F is furthermore generated by an element x \u2208 P iff x \u2264 y for all elements y \u2208 F , the order filter generated by x is written ||x||. Considering causes as the union of filters generated by their causal chains, the join interaction of causes just correspond to their union. For instance, if we consider the set of labels Lb = {a, b} and its corresponding set of causal chains XLb = {a, b, ab, ba, . . . }, then ||ab|| and ||a|| respectively correspond to the set of all chains grater than ab and a in the poset P = \u3008XLb,\u2264\u3009. Those are, ||ab|| = {ab, a, b} and ||a|| = {a}. The term a \u2217 ab corresponds just to the union of both sets ||a|| \u222a ||ab|| = ||ab||. We define a cause as follows:\nDefinition 5 (Cause). A cause for a set of labels Lb is any order filter for the poset of chains \u3008XLb,\u2264\u3009. We will write CLb (or simply C when there is no ambiguity) to denote the set of all causes for Lb.\nThis definition captures the notion of cause, or syntactically a product of causal chains. To capture possible alternative causes, that is, additions of products of causal chains, we notice that addition obeys a similar behaviour with respect to redundant causes. Take, for instance, a set of rules \u03a07:\na : p b : p\u2190 p\nIt is clear, that the cause a is sufficient to justify p, but there are also infinitely many other alternative and redundant causes a \u00b7 b, a \u00b7 b \u00b7 b, . . . that justify p, that is a+ a \u00b7 b+ a \u00b7 b \u00b7 b+ . . . . To capture a set of alternative causes we define the idea of causal value, in its turn, as a filter of causes.\nDefinition 6 (Causal Value). Given a set of labels Lb, a causal value is any order filter for the poset \u3008CLb,\u2286\u3009.\nThe causal value ||||a||||, the filter generated by the cause ||a||, is the set containing ||a|| = {a, a+b} and all its supersets. That is, ||||a|||| = {||a||, ||a\u2217b||, ||a \u00b7b||, . . . }. Futhermore, as we will se later, addition can be interpreted as the union of causal values for its respective operands. Thus, a+ a \u00b7 b+ a \u00b7 b \u00b7 b+ . . . just corresponds to the union of the causal values generated by their addend causes, ||||a||||\u222a||||a \u00b7 b||||\u222a||||a \u00b7 b \u00b7 b||||+. . . = ||||a||||.\nThe set of possible causal values formed with labels Lb is denoted as VLb. An element from VLb has the form of a set of sets of causal chains that, intuitively, corresponds to a set of alternative causes (sum of products of chains). From a graphical point of view, it corresponds to a set of alternative proof trees represented as their respective sets of paths. We define now the correspondence between syntactical causal terms and their semantic counterpart, causal values.\nDefinition 7 (Valuation of normal terms). The valuation of a normal term is a mapping : ULb \u2212\u2192 VLb defined as:\n(x) def = |||x||| with x \u2208 XLb, (\u2211 t\u2208S t ) def = \u22c3 t\u2208S (t), (\u220f t\u2208S t ) def = \u22c2 t\u2208S (t)\nNote that any causal term can be normalized and then this definition trivially extends to any causal term. Furthermore, a causal chain x is mapped just to the causal value generated by the cause, in their turn, generated by x, i.e. the set containing all causes which contain x. The aggregate union of an empty set of sets (causal values) corresponds to \u2205. Therefore (0) = \u22c3 t\u2208\u2205 (t) = \u2205, i.e. 0 just corresponds to the absence of justification. Similarly, as causal values range over parts of C, the aggregate intersection of an empty set of causal values corresponds to C, and thus (1) = \u22c2 t\u2208\u2205 (t) = C, i.e. 1 just corresponds to the \u201cmaximal\u201d justification.\nTheorem 1 (From [4]). \u3008VLb,\u222a,\u2229\u3009 is the free completely distributive lattice generated by \u3008XLb,\u2264\u3009, and the restriction of to XLb is an injective homomorphism (or embedding).\nThe above theorem means that causal terms form a complete lattice. The order relation\u2264 between causal terms just corresponds to set inclusion between their corresponding causal values, i.e. x \u2264 y iff (x) \u2286 (y). Furthermore, addition \u2018+\u2019 and product \u2018\u2217\u2019 just respectively correspond to the least upper bound and the greater lower bound of the associated lattice \u3008TLb,\u2264\u3009 or \u3008TLb,+, \u2217\u3009 where:\nt \u2264 u def= (t) \u2286 (u) (\u21d4 t \u2217 u = t \u21d4 t+ u = u )\nfor any normal term t and u. For instance, in our example \u03a02, fwd was associated with the causal term p \u00b7 a \u2217 s \u00b7 a+w \u00b7 b. Thus, the causal value associated with it corresponds to\n(p \u00b7 a \u2217 s \u00b7 a+ w \u00b7 b) = ||||p \u00b7 a|||| \u2229 ||||s \u00b7 a|||| \u222a ||||w \u00b7 b||||\nCausal values are, in general, infinite sets. For instance, as we saw before, simply with Lb = {a} we have the chains XLb = {a, aa, aaa, . . . } and (a) contains all possible causes in C that are supersets of {a}, that is, (a) = {{a}, {aa, a}, {aaa, aa, a}, . . . }. Obviously, writing causal values in this way is infeasible \u2013 it is more convenient to use a representative causal term instead. For this purpose, we define a function \u03b3 that acts as a right inverse morphism for selecting minimal causes, i.e., given a causal value V , it defines a normal term \u03b3(V ) = t such that (t) = V and \u03b3(V ) does not have redundant subterms. The function \u03b3 is defined as a mapping \u03b3 : VLb \u2212\u2192 ULb such that for any causal value V \u2208 VLb, \u03b3(V ) def = \u2211 C\u2208V \u220f x\u2208C x where V = {C \u2208 V |6 \u2203D \u2208 V,D \u2282 C} and C = {x \u2208 C |6 \u2203y \u2208 C, y < x} respectively stand for \u2286-minimal causes of V and \u2264-minimal chains of C. We will use \u03b3(V ) to represent V .\nProposition 3. The mapping \u03b3 is a right inverse morphism of .\nGiven a term t we define its canonical form as \u03b3( (t)). Canonical terms are of the form of sums of products of causal chains. As it can be imagined, not any term in that form is a canonical term. For instance, going back, we easily can check that terms a \u2217 ab = ab and a+ ab+ abb+ \u00b7 \u00b7 \u00b7 = a respectively correspond to the canonical terms \u03b3( (ab \u2217 a)) = \u03b3( (ab)) = ab and \u03b3( (a+ ab+ abb+ . . . )) = \u03b3( (a)) = a. Figure 3 summarizes addition and product properties while Figure 4 is analogous for application properties.\nFor practical purposes, simplification of causal terms can be done by applying the algebraic properties shown in Figures 3 and 4. For instance, the examples from \u03a06 and \u03a07 containing redundant information can now be derived as follows:\na \u2217 a \u00b7 b = (a \u2217 1 \u00b7 a \u00b7 b) identity for \u2018\u00b7\u2019 = 1 \u00b7 a \u00b7 b absorption for \u2018\u00b7\u2019 = a \u00b7 b identity for \u2018\u00b7\u2019\na+ a \u00b7 b+ a \u00b7 b \u00b7 b+ . . . = a+ 1 \u00b7 a \u00b7 b+ a \u00b7 b \u00b7 b+ . . . identity for \u2018\u00b7\u2019 = a+ a \u00b7 b \u00b7 b+ . . . absorption for \u2018\u00b7\u2019 = a+ 1 \u00b7 a \u00b7 b \u00b7 b+ . . . identity for \u2018\u00b7\u2019 . . . . . . = a absorption for \u2018\u00b7\u2019\nLet us see another example involving distributivity. The term ab \u2217 c+ a can be derived as follows:\na \u00b7 b \u2217 c+ a = (a \u00b7 b+ a) \u2217 (c+ a) distributivity = (1 \u00b7 a \u00b7 b+ a) \u2217 (c+ a) identity for \u2018\u00b7\u2019 = (a+ 1 \u00b7 a \u00b7 b) \u2217 (c+ a) commutativity for \u2018+\u2019 = a \u2217 (c+ a) absorption for \u2018\u00b7\u2019 = a absorption for \u2018\u2217\u2019"}, {"heading": "3 Positive programs and minimal models", "text": "Let us describe now how to use the causal algebra to evaluate causal logic programs. A signature is a pair \u3008At, Lb\u3009 of sets that respectively represent the set of atoms (or propositions) and the set of labels. As usual, a literal is defined as an atom p (positive literal) or its negation \u00acp (negative literal). In this paper, we will concentrate on programs without disjunction in the head, leaving the treatment of disjunction for a future study.\nDefinition 8 (Causal logic program). Given a signature \u3008At, Lb\u3009 a (causal) logic program \u03a0 is a set of rules of the form:\nt : L0 \u2190 L1 \u2227 . . . \u2227 Lm \u2227 not Lm+1 \u2227 . . . \u2227 not Ln\nwhere t is a causal term over Lb, L0 is a literal or \u22a5 (the head of the rule) and L1 \u2227 . . .\u2227Lm \u2227 not Lm+1 \u2227 . . . not Ln is a conjunction of literals (the body of the rule). An empty body is represented as >.\nFor any rule \u03c6 of the form t : L0 \u2190 L1\u2227. . .\u2227Lm\u2227not Lm+1\u2227. . . not Ln we define label(\u03c6) = t. Most of the following definitions are standard in logic programming. We denote head(\u03c6) = L0, B+ (resp. B\u2212) to represent the conjunction of all positive (resp. negative) literals L1 \u2227 . . . \u2227 Ln (resp. not Lm+1 \u2227 . . . \u2227 not Ln) that occur in B. A logic program is positive if B\u2212 is empty for all rules (n = m), that is, if it contains no negations. Unlabelled rules are assumed to be labelled with the element 1 which, as we saw, is the identity for application \u2018\u00b7\u2019. > (resp. \u22a5) represent truth (resp. falsity). If n = m = 0 then\u2190 can be dropped.\nGiven a signature \u3008At, Lb\u3009 a causal interpretation is a mapping I : At \u2212\u2192 VLb assigning a causal value to each atom. Partial order \u2264 is extended over interpretations so that given two interpretations I, J we define I \u2264 J def= I(p) \u2264 J(p) for each atom p \u2208 At. There is a\u2264-bottom interpretation 0 (resp. a\u2264-top interpretation 1) that stands for the interpretation mapping each atom p to 0 (resp. 1). The set of interpretations I with the partial order \u2264 forms a poset \u3008I,\u2264\u3009 with supremum \u2018+\u2019 and infimum \u2018\u2217\u2019 that are respectively the sum and product of atom interpretations. As a result, \u3008I,+, \u2217\u3009 also forms a complete lattice.\nObservation 1 When Lb = \u2205 the set of causal values becomes VLb = {0, 1} and interpretations collapse to classical propositional logic interpretations.\nDefinition 9 (Causal model). Given a positive causal logic program \u03a0 and a causal interpretation I over the signature \u3008At, Lb\u3009, I is a causal model, written I |= \u03a0 , if and only if (\nI(L1) \u2217 . . . \u2217 I(Lm) ) \u00b7 t \u2264 I(L0)\nfor each rule \u03d5 \u2208 \u03a0 of the form \u03d5 = L0 \u2190 L1, . . . , Lm.\nFor instance, take rule (1) from Example 1 and let I be an interpretation such that I(port) = p and I(starb) = s. Then I will be a model of (1) when (p \u2217 s) \u00b7 a \u2264\nI(fwd). In particular, this holds when I(fwd) = (p \u2217 s) \u00b7a+w \u00b7 b which was the value we expected for program \u03a02. But it would also hold when, for instance, I(fwd) = a + b or I(fwd) = 1. Note that this is important if we had to accommodate other possible additional facts (a : fwd) or even (1 : fwd) in the program. The fact that any I(fwd) greater than (p \u2217 s) \u00b7 a + w \u00b7 b is also a model clearly points out the need for selecting minimal models. In fact, as happens in the case of non-causal programs, positive programs have a least model (this time, with respect to\u2264 relation among causal interpretations) that can be computed by iterating an extension of the well-known direct consequences operator defined by [5].\nDefinition 10 (Direct consequences). Given a positive logic program \u03a0 for signature \u3008At, Lb\u3009 and a causal interpretation I , the operator of direct consequences is a function T\u03a0 : I \u2212\u2192 I such that, for any atom p \u2208 At:\nT\u03a0(I)(L0) def = \u2211{ ( I(L1) \u2217 . . . \u2217 I(Lm) ) \u00b7 t | (t : L0 \u2190 L1 \u2227 . . . \u2227 Lm) \u2208 \u03a0 } In order to prove some properties of this operator, an important observation should be made: since the set of causal values forms now a lattice, causal logic programs can be translated to Generalized Annotated Logic Programming (GAP). GAP is a general a framework for multivalued logic programming where the set of truth values must to form an upper semilattice and rules (annotated clauses) have the following form:\nL0 : \u03c1\u2190 L1 : \u00b51 & . . . & Lm : \u00b5m (3)\nwhere L0, . . . , Lm are literals, \u03c1 is an annotation (may be just a truth value, an annotation variable or a complex annotation) and \u00b51, . . . , \u00b5m are values or annotation variables. A complex annotation is the result to apply a total continuous function to a tuple of annotations. For instance \u03c1 can be a complex annotation f(\u00b51, . . . , \u00b5m) that applies the function f to a m-tuple (\u00b51, . . . , \u00b5m) of annotation variables in the body of (3). Given a positive program \u03a0 , each rule \u03d5 \u2208 \u03a0 of the form\nt : L0 \u2190 L1 \u2227 . . . \u2227 Lm (4)\nis translated to an annotated clause GAP (\u03d5) of the form of (3) where \u00b51, . . . , \u00b5m are annotation variables that capture the causal values of each body literal. The head complex annotation corresponds to the function \u03c1 def= (\u00b51 \u2217 . . . \u2217\u00b5m) \u00b7 t that forces the head to inherit the causal value obtained by applying the rule label t to the product of the interpretation of body literals \u00b51 \u2217 . . . \u2217 \u00b5m. The translation of a program \u03a0 is simply defined as:\nGAP (\u03a0) def = {GAP (\u03d5) | \u03d5 \u2208 \u03a0}\nA complete description of GAP restricted semantics, denoted as |=r, is out of the scope of this paper (the reader is referred to [6]). For our purposes, it suffices to observe that the following important property is satisfied.\nTheorem 2. A positive causal logic program \u03a0 can be translated to a general annotated logic program GAP (\u03a0) s.t. a causal interpretation I |= \u03a0 if and only if I |=r GAP (\u03a0). Furthermore, T\u03a0(I) = RGAP (\u03a0)(I) for any interpretation I .\nCorollary 1. Given a positive logic program \u03a0 the following properties hold:\n1. Operator T\u03a0 is monotonic. 2. Operator T\u03a0 is continuous. 3. T\u03a0 \u2191 \u03c9 (0) = lfp(T\u03a0) is the least model of \u03a0 . 4. The iterative computation T\u03a0 \u2191 k (0) reaches the least fixpoint in n steps for some\npositive integer n.\nProof. Directly follows from Theorem 2 and Theorems 1, 2 and 3 in [6].\nThe existence of a least model for a positive program and its computation using T\u03a0 is an interesting result, but it does not provide any information on the relation between the causal value it assigns to each atom with respect to its role in the program. As we will see, we can establish a direct relation between this causal value and the idea of proof in the positive program. Let us formalise next the idea of proof tree.\nDefinition 11 (Proof tree). Given a causal logic program \u03a0 , a proof tree is a directed acyclic graph T = \u3008V,E\u3009, where vertices V \u2286 \u03a0 are rules from the program, and E \u2286 V \u00d7 V satisfying:\n(i) There is at exactly one vertex without outgoing edges denoted as sink(T ). (ii) For each rule \u03d5 = (t : L0 \u2190 B) \u2208 V and for each atom Li \u2208 B+ there is exactly\none \u03d5\u2032 with (\u03d5\u2032, \u03d5) \u2208 E and this rule satisfies head(\u03d5\u2032) = Li.\nNotice that condition (ii) forces us to include an incoming edge for each atom in the positive body of a vertex rule. As a result, source vertices must be rules with empty positive body, or just facts in the case of positive programs. Another interesting observation is that, proof tree do not require an unique parent for each vertex. For instance, in Example 1, if both port and starb were obtained as a consequence of some command made by the captain, we could get instead a proof tree, call it T1, of the form:\nc : command\nrr ,,\np : port\u2190 command ++\ns : starb\u2190 command ss\na : fwd\u2190 port \u2227 starb\nDefinition 12 (Proof path). Given a proof tree T = \u3008V,E\u3009 we define a proof path for T as a concatenation of terms t1 . . . tn satisfying:\n1. There exists a rule \u03d5 \u2208 V with label(r) = t1 such that \u03d5 is a source, that is, there is no \u03d5\u2032 s.t. (\u03d5\u2032, \u03d5) \u2208 E.\n2. For each pair of consecutive terms ti, ti+1 in the sequence, there is some edge (\u03d5i, \u03d5i+1) \u2208 E s.t. label(\u03d5i) = ti and label(\u03d5i+1) = ti+1. 3. label(sink(T )) = tn.\nLet us write Paths(T ) to stand for the set of all proof paths for a given proof tree T . We define the cause associated to any tree T = \u3008V,E\u3009 as the causal term cause(T ) def = \u220f t\u2208Paths(T ) t. As an example, cause(T1) = (c \u00b7 p \u00b7 a) \u2217 (c \u00b7 s \u00b7 a). Also (p \u00b7 a) \u2217 (s \u00b7 a) and w \u00b7 b correspond to each tree in Figure 1.\nTheorem 3. Let \u03a0 be a positive program and I be the least model of \u03a0 , then for each atom p:\nI(p) = \u2211\nT\u2208PTp\ncause(T )\nwhere PTp = {T = \u3008V,E\u3009 | head(sink(T )) = p} is a set of proof trees with nodes V \u2286 \u03a0 .\nFrom this result, it may seem that our semantics is just a direct translation of the syntactic idea of proof trees. However, the semantics is actually a more powerful notion that allows detecting redundancies, tautologies and inconsistencies. In fact, the expression\u2211 T\u2208PTp\ncause(T ) may contain redundancies and is not, in the general case, in normal form. As an example, recall the program \u03a06:\na : p b : q \u2190 p r \u2190 p \u2227 q\nthat has only one proof tree for p whose cause would correspond to I(r) = a \u2217 a \u00b7 b. But, by absorption, this is equivalent to I(r) = a \u00b7 b pointing out that the presence of p in rule r \u2190 p \u2227 q is redundant.\nA corollary of Theorem 3 is that we can replace a rule label by a different one, or by 1 (the identity for application \u2018\u00b7\u2019) and we get the same least model, modulo the same replacement in the causal values for all atoms.\nCorollary 2. Let \u03a0 be a positive program, I the least model of \u03a0 , l \u2208 Lb be a label, m \u2208 Lb \u222a {1} and \u03a0 lm (resp. I lm) be the program (resp. interpretation) obtained after replacing each occurrence of l by m in \u03a0 (resp. in the interpretation of each atom in I). Then I lm is the least model of \u03a0 l m.\nIn particular, replacing a label bym = 1 has the effect of removing it from the signature. Suppose we make this replacement for all atoms in Lb and call the resulting program and least model \u03a0Lb1 and I Lb 1 respectively. Then \u03a0 Lb 1 is just the non-causal program resulting from \u03a0 after removing all labels and it is easy to see (Observation 1) that ILb1 coincides with the least classical model of this program2. Moreover, this means that for any positive program \u03a0 , if I is its least model, then the classical interpretation:\nI \u2032(p) def = { 1 if I(p) 6= 0 0 otherwise\nis the least classical model of \u03a0 ignoring its labels.\n2 Note that ILb is Boolean: if assigns either 0 or 1 to any atom in the signature."}, {"heading": "4 Default negation and stable models", "text": "Consider now the addition of negation, so that we deal with arbitrary programs. To illustrate this, we introduce a variation in Example 1 introducing the qualification problem from [7]: actions for moving the boat forward can be disqualified if an abnormal situation occurs (for instance, that the boat is anchored, any of the oars are broken, the sail is full of holes, etc.) . As usual this can be represented using default negation as shown in the set of rules \u03a08:\np : port s : starb\na : fwd\u2190 port \u2227 starb \u2227 not ab a ab a\u2190 anchored ab a\u2190 broken oar1 ab a\u2190 broken oar2\nw : fwind\nb : fwd\u2190 fwind \u2227 not ab b ab b\u2190 anchored ab b\u2190 holed sail\n. . .\nThe causes that justify an atom should not be a list of not occurred abnormal situations. For instance, in program \u03a08 where no abnormal situation occurs, the causal value that justify atom fwd should be (p \u00b7 a \u2217 s \u00b7 a) + (w \u00b7 b) as in the program \u03a02 where abnormal situations are not included. References to the not occurred abnormal situations (not anchored, not broken oar1. . . ) are not mentioned. Default negation does not affect the causes justifying an atom when the default holds. Of course, when the default does not hold, for instance adding the fact anchored to the above program, fwd becomes false. Thus, we introduce the following straightforward rephrasing of the traditional program reduct [2].\nDefinition 13 (Program reduct). The reduct of a program \u03a0 with respect to an interpretation I , written \u03a0I is the result of the following transformations on \u03a0:\n1. Removing all rules s.t. I(B\u2212) = 0 2. Removing all negative literals from the rest of rules.\nA causal interpretation I is a causal stable model of a causal program \u03a0 if I is the least model of \u03a0I . This definition allows us to extend Theorem 3 to normal programs in a direct way:\nTheorem 4 (Main theorem). Let\u03a0 be a causal program and I be causal stable model of \u03a0 , then for each atom p:\nI(p) = \u2211\nT\u2208PTp\ncause(T ) where\nPTp = {T = \u3008V,E\u3009 | head(sink(T )) = p and V \u2286 {(t : q \u2190 B) \u2208 \u03a0 | I(B\u2212) 6= 0}}.\nThat is, the only difference now is that the set of proof trees PTp is formed with rules whose negative body is not false I(B\u2212) 6= 0 (that is, they would generate rules in the reduct).\nCorollary 3. Let \u03a0 be a normal program, I a causal stable model of \u03a0 , l \u2208 Lb be a label, m \u2208 Lb\u222a {1} and \u03a0 lm (resp. I lm) be the program (resp. interpretation) obtained after replacing every occurrence of l bym in\u03a0 (resp. in the interpretation of each atom in I). Then I lm is a causal stable model of \u03a0 l m.\nAs in the case of positive programs, replacing a label by m = 1 has the effect of removing it from the signature. Then, for any normal program \u03a0 , if I is a causal stable model, then the classical interpretation:\nI \u2032(p) def = { 1 if I(p) 6= 0 0 otherwise\nis a classical stable model of \u03a0 ignoring its labels. It is easy to see that not only the above program \u03a08 has an unique causal stable model that corresponds to:\nI(port) = p I(starb) = s I(fwind) = w I(fwd) = (p \u00b7 a \u2217 s \u00b7 a) + (w \u00b7 b)\nI(ab f) = 0 I(anchored) = 0 I(broken oar1) = 0\n. . . = 0\nbut also the program obtained from it ignoring the labels has an unique standard stable model {port, starb, fwind, fwd} that corresponds to the atoms whose interpretations differ from 0 in the former."}, {"heading": "5 Conclusions", "text": "In this paper we have provided a multi-valued semantics for normal logic programs whose truth values form a lattice of causal chains. A causal chain is nothing else but a concatenation of rule labels that reflects some sequence of rule applications. In this way, a model assigns to each true atom a value that contains justifications for its derivation from existing rules. We have further provided three basic operations on the lattice: an addition, that stands for alternative, independent justifications; a product, that represents joint interaction of causes; and a concatenation that acts as a chain constructor. We have shown that this lattice is completely distributive and provided a detailed description of the algebraic properties of its three operations.\nA first important result is that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to [5]. With this, we are able to prove a direct correspondence between the semantic values we obtain and the syntactic idea of proof tree. The main result of the paper generalises this correspondence for the case of stable models for normal programs.\nMany open topics remain for future study. For instance, ongoing work is currently focused on implementation, complexity assessment, extension to disjunctive programs or introduction of strong negation. Regarding expressivity, an interesting topic is the introduction of new syntactic operators for inspecting causal information like checking the influence of a particular event or label in a conclusion, expressing necessary or sufficient causes, or even dealing with counterfactuals. Another interesting topic is removing the syntactic reduct definition in favour of some full logical treatment of default\nnegation, as happens for (non-causal) stable models and their characterisation in terms of Equilibrium Logic [8]. This would surely simplify the quest for a necessary and sufficient condition for strong equivalence, following similar steps to [9]. It may also allow extending the definition of causal stable models to an arbitrary syntax and to the first order case, where the use of variables in labels may also introduce new interesting features.\nThere are also other areas whose relations deserve to be formally studied. For instance, the introduction of a strong negation operator will immediate lead to a connection to Paraconsistency approaches. In particular, one of the main problems in the area of Paraconsistency is deciding which parts of the theory do not propagate or depend on an inconsistency. This decision, we hope, will be easier in the presence of causal justifications for each derived conclusion. A related area for which similar connections can be exploited is Belief Revision. In this case, causal information can help to decide which relevant part of a revised theory must be withdrawn in the presence of new information that would lead to an inconsistency if no changes are made. A third obvious related area is Debugging in Answer Set Programming, where we try to explain discrepancies between an expected result and the obtained stable models. In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare. Finally, as potential applications, our main concern is designing a high level action language on top of causal logic programs with the purpose of modelling some typical scenarios from the literature on causality in Artificial Intelligence."}], "references": [{"title": "Causal logic programming", "author": ["P. Cabalar"], "venue": "In Erdem, E., Lee, J., Lierler, Y., Pearce, D., eds.: Correct Reasoning. Volume 7265 of Lecture Notes in Computer Science., Springer", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In Kowalski, R.A., Bowen, K.A., eds.: Logic Programming: Proc. of the Fifth International Conference and Symposium (Volume 2). MIT Press, Cambridge, MA", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1988}, {"title": "Explicit provability and constructive semantics", "author": ["S.N. Art\u00ebmov"], "venue": "Bulletin of Symbolic Logic 7(1)", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2001}, {"title": "Free distributive completions of partial complete lattices", "author": ["G. Stumme"], "venue": "Order 14", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1997}, {"title": "The semantics of predicate logic as a programming language", "author": ["M.H. van Emden", "R.A. Kowalski"], "venue": "J. ACM 23(4)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1976}, {"title": "Theory of generalized annotated logic programming and its applications", "author": ["M. Kifer", "V.S. Subrahmanian"], "venue": "Journal of Logic Programming 12", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1992}, {"title": "Epistemological problems of artificial intelligence", "author": ["J. McCarthy"], "venue": "In Reddy, R., ed.: IJCAI, William Kaufmann", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1977}, {"title": "Equilibrium logic", "author": ["D. Pearce"], "venue": "Ann. Math. Artif. Intell. 47(1-2)", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2006}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Trans. Comput. Log. 2(4)", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2001}, {"title": "A meta-programming technique for debugging answer-set programs", "author": ["M. Gebser", "J. P\u00fchrer", "T. Schaub", "H. Tompits"], "venue": "In Fox, D., Gomes, C.P., eds.: AAAI, AAAI Press", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2008}, {"title": "Justifications for logic programs under answer set semantics", "author": ["E. Pontelli", "T.C. Son", "O. El-Khatib"], "venue": "TPLP 9(1)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "To explore this idea, [1] introduced the so-called causal logic programs.", "startOffset": 22, "endOffset": 25}, {"referenceID": 1, "context": "The semantics was an extension of stable models [2] relying on the idea of \u201cjustification\u201d or \u201cproof\u201d.", "startOffset": 48, "endOffset": 51}, {"referenceID": 2, "context": "In this paper, we show that causes can be embedded in an algebra with three internal operations: an addition \u2018+\u2019 representing alternative justifications for a formula, a commutative product \u2018\u2217\u2019 representing joint interaction of causes (in a similar spirit to the \u2018+\u2019 in [3]) and a non-commutative product \u2018\u00b7\u2019 acting as a concatenation or rule application.", "startOffset": 270, "endOffset": 273}, {"referenceID": 3, "context": "Theorem 1 (From [4]).", "startOffset": 16, "endOffset": 19}, {"referenceID": 4, "context": "In fact, as happens in the case of non-causal programs, positive programs have a least model (this time, with respect to\u2264 relation among causal interpretations) that can be computed by iterating an extension of the well-known direct consequences operator defined by [5].", "startOffset": 266, "endOffset": 269}, {"referenceID": 5, "context": "GAP (\u03a0) def = {GAP (\u03c6) | \u03c6 \u2208 \u03a0} A complete description of GAP restricted semantics, denoted as |=, is out of the scope of this paper (the reader is referred to [6]).", "startOffset": 160, "endOffset": 163}, {"referenceID": 5, "context": "Directly follows from Theorem 2 and Theorems 1, 2 and 3 in [6].", "startOffset": 59, "endOffset": 62}, {"referenceID": 6, "context": "To illustrate this, we introduce a variation in Example 1 introducing the qualification problem from [7]: actions for moving the boat forward can be disqualified if an abnormal situation occurs (for instance, that the boat is anchored, any of the oars are broken, the sail is full of holes, etc.", "startOffset": 101, "endOffset": 104}, {"referenceID": 1, "context": "Thus, we introduce the following straightforward rephrasing of the traditional program reduct [2].", "startOffset": 94, "endOffset": 97}, {"referenceID": 4, "context": "A first important result is that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to [5].", "startOffset": 171, "endOffset": 174}, {"referenceID": 7, "context": "negation, as happens for (non-causal) stable models and their characterisation in terms of Equilibrium Logic [8].", "startOffset": 109, "endOffset": 112}, {"referenceID": 8, "context": "This would surely simplify the quest for a necessary and sufficient condition for strong equivalence, following similar steps to [9].", "startOffset": 129, "endOffset": 132}, {"referenceID": 9, "context": "In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare.", "startOffset": 58, "endOffset": 65}, {"referenceID": 10, "context": "In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare.", "startOffset": 58, "endOffset": 65}], "year": 2013, "abstractText": "In this work we propose a multi-valued extension of logic programs under the stable models semantics where each true atom in a model is associated with a set of justifications, in a similar spirit than a set of proof trees. The main contribution of this paper is that we capture justifications into an algebra of truth values with three internal operations: an addition \u2018+\u2019 representing alternative justifications for a formula, a commutative product \u2018\u2217\u2019 representing joint interaction of causes and a non-commutative product \u2018\u00b7\u2019 acting as a concatenation or proof constructor. Using this multi-valued semantics, we obtain a one-to-one correspondence between the syntactic proof tree of a standard (non-causal) logic program and the interpretation of each true atom in a model. Furthermore, thanks to this algebraic characterization we can detect semantic properties like redundancy and relevance of the obtained justifications. We also identify a lattice-based characterization of this algebra, defining a direct consequences operator, proving its continuity and that its least fix point can be computed after a finite number of iterations. Finally, we define the concept of causal stable model by introducing an analogous transformation to Gelfond and Lifschitz\u2019s program reduct.", "creator": "LaTeX with hyperref package"}}}