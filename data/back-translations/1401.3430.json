{"id": "1401.3430", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "A Unifying Framework for Structural Properties of CSPs: Definitions, Complexity, Tractability", "abstract": "The literature on constraint satisfaction describes the definition of several structural properties that CSPs can possess, such as (in-) consistency, substitutability, or interchangeability. Current tools for solving constraints typically efficiently detect such properties using incomplete but effective algorithms, and use them to reduce search space and boost search.", "histories": [["v1", "Wed, 15 Jan 2014 04:47:30 GMT  (257kb)", "http://arxiv.org/abs/1401.3430v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["lucas bordeaux", "marco cadoli", "toni mancini"], "accepted": false, "id": "1401.3430"}, "pdf": {"name": "1401.3430.pdf", "metadata": {"source": "CRF", "title": "A Unifying Framework for Structural Properties of CSPs: Definitions, Complexity, Tractability", "authors": ["Lucas Bordeaux", "Marco Cadoli", "Toni Mancini"], "emails": ["lucasb@microsoft.com", "cadoli@dis.uniroma1.it", "tmancini@dis.uniroma1.it"], "sections": [{"heading": "1. Introduction", "text": "Many Constraint Satisfaction Problems (CSPs) which arise in the modelling of real-life applications exhibit \u201cstructural\u201d properties that distinguish them from random instances. Detecting such properties has been widely recognised to be an effective way for improving the solving process. To this end, several of them have already been identified, and different techniques have been developed in order to exploit them, with the goal of reducing the search space to be explored. Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general\nc\u00a92008 AI Access Foundation. All rights reserved.\nforms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007).\nUnfortunately, checking whether such properties hold, is (or is thought to be) often computationally hard. As an example, let us consider interchangeability. Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991). The problem of checking interchangeability is coNP-complete (cf. Proposition 4). Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, Ko\u0308bler, Scho\u0308ning, & Tora\u0301n, 1993).\nTo this end, in order to allow general algorithms to exploit such properties efficiently, different approaches can be followed. First of all, syntactic restrictions on the constraint languages can be enforced, in order to allow the efficient verification of the properties of interest. Alternatively, \u201clocal\u201d versions of such properties can be defined, that can be used to infer their global counterparts, and that can be verified in polynomial time. As an instance of this \u201clocal reasoning\u201d approach, instead of checking whether a value is fully interchangeable for a variable, Freuder (1991) proposes to check whether that value is neighbourhood, or k-interchangeable. This task involves considering only bounded-sized subsets of the constraints, and hence can be performed in polynomial time. Neighbourhood and k-interchangeability are sufficient (but not necessary) conditions for full interchangeability, and have been proven to be highly effective in practice (cf., e.g., Choueiry & Noubir, 1998; Lal, Choueiry, & Freuder, 2005).\nIn this paper we give a formal characterisation of several properties of CSPs which can be exploited in order to save search, and present a unifying framework for them that allows for their semantical connections to emerge. Some of the properties are well-known in the Constraint Programming literature, others have been used in other contexts (as in databases), while some others are, to the best of our knowledge, original, and, in our opinion, play a key role in allowing a deep understanding of the topic. In particular, we reconsider the notions of inconsistency, substitutability and interchangeability, and propose those of fixable, removable, and implied value for a given variable, which are instances of the more general definition of satisfiability-preserving transformation and those of determined, dependent, and irrelevant variable. These properties make it possible to transform a problem into a simpler one. Depending on the case, this transformation is guaranteed to preserve all solutions, or the satisfiability of the problem, i.e., at least a solution, if one exists. In general, each of these properties can be detected either statically, during a preprocessing stage of the input CSP (cf., e.g., Cadoli & Mancini, 2007), or dynamically, during search (since they may arise at any time). Moreover, in some cases we don\u2019t even need to explicitly verify whether some properties hold, because this is guaranteed by the intrinsic characteristics of the problem. For instance, some problems are guaranteed to have a unique solution. Such cases are referred to as \u201cpromise problems\u201d in the literature (Even, Selman, & Yacobi, 1984), meaning that in addition to the problem description we are informed of certain properties it verifies (cf. forthcoming Example 1 for an example).\nThe formal characterisation of the properties and their connections allow us to shed light on the computational complexity of their recognition task in a very elegant way, proving\nthat, in the worst case, the detection of each of them is as complex as the original problem. In particular, as we will see in Section 3.1, detecting each of the proposed properties is a coNP-complete task. This holds also for Freuder\u2019s substitutability and interchangeability (this result is, to the best of our knowledge, original). Hence, in order to be able to practically make the relevant checks during preprocessing and search, we investigate two different approaches for the efficient verification of the proposed properties: additions of suitable restrictions to the constraint language, and exploitation of efficient forms of local reasoning, i.e., by checking them for single constraints.\nThe outline of the paper is as follows: after giving an intuitive example and recalling some preliminaries, in Section 2 we present the properties we are interested in, and discuss their connections. Then, in Section 3 we focus on the complexity of the various propertydetection tasks. In particular, in Section 3.1 we prove that all of them are intractable; hence, in Section 3.2 we focus on relaxations that guarantee tractability of reasoning, investigating the two aforementioned approaches. Finally, in Section 4 we draw conclusions and address future work."}, {"heading": "2. A Hierarchy of Properties", "text": "In this section, we formally define several structural properties of CSPs, discuss the semantical relationships that hold among them, and show how they can be exploited during constraint solving."}, {"heading": "2.1 An Intuitive Example", "text": "In order to allow for a gentle introduction of the main properties investigated in the forthcoming sections, we first introduce the following example.\nExample 1 (Factoring, Lenstra & Lenstra, 1990; Pyha\u0308la\u0308, 2004). This problem is a simplified version of one of the most important problems in public-key cryptography. Given a (large) positive integer Z and the fact that it is a product of two different unknown prime numbers X and Y (different from 1), the goal is to identify these two numbers.\nAn intuitive formulation of any instance of this problem (i.e., for any given Z) as a CSP, adequate for arbitrarily large numbers, amounts to encode the combinatorial circuit of integer multiplication, and is as follows: assuming Z has n digits (in base b) z1, . . . , zn, we consider 2n variables x1, . . . , xn and y1, . . . , yn one for each digit (in base b) of X and Y (x1 and y1 being the least significant ones). The domain for all these variables is [0, b\u2212 1]. In order to maintain information about the carries, n + 1 additional variables c1, . . . , cn+1 must be considered, with domain [0..(b\u2212 1)2n/b].1\nAs for the constraints (cf. Figure 1 for the intuition, where x4, x5, x6, y4, y5, y6 are equal to 0, and are omitted for readability), they are the following:\n1. Constraints on factors:\n1. In this intuitive example, with a little abuse with respect to what will be permitted by forthcoming Definition 1, we allow, to enhance readability, different variables to be defined over different domains. However, we observe that it is easy to recover from this by using standard and well-known techniques (e.g., adding new monadic constraints to model smaller domains).\n7 8 7 \u2217 7 9 7 =\n0 6 13 18 12 4 0\n49 56 49 63 72 63 \u2212 49 56 49 \u2212 \u2212 6 2 7 2 3 9\nx3 x2 x1 \u2217 y3 y2 y1 =\nc7 c6 c5 c4 c3 c2 c1\nx3y1 x2y1 x1y1 x3y2 x2y2 x1y2 \u2212\nx3y3 x2y3 x1y3 \u2212 \u2212 z6 z5 z4 z3 z2 z1\nWhen a guess on the two factors X and Y (i.e., on variables x1, . . . , xn and y1, . . . , yn) has been made, values for variables c1, . . . , cn+1 are completely determined, since they follow from the semantics of the multiplication. This is called a functional dependence among variables.\nFunctional dependencies arise very often in, e.g., problems for which an intermediate state has to be maintained, and their detection and exploitation has been recognized to be of great importance from an efficiency point of view, since it can lead to significant reductions of the search space (cf., e.g., Giunchiglia, Massarotto, & Sebastiani, 1998; Mancini & Cadoli, 2007; Cadoli & Mancini, 2007).\nMoreover, the presence of functional dependencies among variables of a CSP highlights a second interesting problem, i.e., that of computing the values of dependent variables after a choice of the defining ones has been made. This problem, which is always a subproblem of a CSP with dependencies, has exactly one solution, hence, the knowledge of such a promise can be useful to the solver. It is worth noting that there are also problems which intrinsically exhibit promises. This is the case of, e.g., Factoring where we add the symmetry-breaking constraint forcing x1, . . . , xn to be lexicographically less than or equal to y1, . . . , yn. This new formulation is guaranteed to have exactly one solution (since both X and Y are prime).\nThe Factoring problem exhibits also other interesting properties: let us consider an instance such that Z is given in binary notation (i.e., b = 2) and with the least significant digit z1 being equal to 1. This implies that the last digit of both factors X and Y must be 1. Hence, we can say that value 1 is implied for variables x1 and y1, and that 0 is removable for them and, more precisely inconsistent. Moreover, for this problem, which, if the symmetry is broken, has a unique solution, we also know that all variables x1, . . . , xn and y1, . . . , yn\nare determined (cf. forthcoming Definition 2), regardless of the instance, and because of the functional dependence already discussed, we have that variables encoding carries, i.e., ci (i \u2208 [1, n]), are dependent on {x1, . . . , xn, y1, . . . , yn}.\nAs for problems with unique solutions, it is known that, unfortunately, their resolution remains intractable (cf., e.g., Papadimitriou, 1994; Valiant & Vijay V. Vazirani, 1986; Calabro, Impagliazzo, Kabanets, & Paturi, 2003). However, this does not exclude the possibility to find good heuristics for instances with such a promise, or to look for other properties that are implied by the existence of unique solutions, that can be exploited in order to improve the search process. In particular, determined and implied values play an important role in this and other classes of problems. As the Factoring example shows, such problems arise frequently in practice, either as subproblems of other CSPs, as in presence of functional dependencies (cf. also Mancini & Cadoli, 2007; Mancini, Cadoli, Micaletto, & Patrizi, 2008, for more examples), or because of intrinsic characteristics of the problem at hand. In general, if a problem has a unique solution, all variables have a determined value.\nAnother central role is played by the removability property, that characterises precisely the case when a value can be safely removed from the domain of a variable, while preserving satisfiability. This property is of course weaker than inconsistency (since some solutions may be lost), but can be safely used in place of it when we are interested in finding only a solution of a CSP, if one exists, and not all of them."}, {"heading": "2.2 Preliminaries", "text": "Definition 1 (Constraint Satisfaction Problem (CSP), Dechter, 1992). A Constraint Satisfaction Problem is a triple \u3008X,D,C\u3009 where: \u2022 X is a finite set of variables; \u2022 D is a finite set of values, representing the domain for each variable; \u2022 C is a finite set of constraints {c1, . . . c|C|}, with each of them being of the form ci = ri(Vi), where Vi is a list of k \u2264 |X| variables in X (the constraint scope), and ri \u2286 Dk is a k-ary relation over D (the constraint relation). We sometimes will denote the set Vi of variables of constraint ci by var(ci).\nGiven a set of variables V and a domain D, a V -tuple t over D is a mapping which associates a value tx \u2208 D to every x \u2208 V . Such value is called the x-component of t. Given a V -tuple t and a subset U \u2286 V of its variables, we denote by t|U the restriction of t to U , which has the same value as t on the variables of U and is undefined elsewhere. The explicit assignment of the value a \u2208 D to the x-component of a V -tuple t (x \u2208 V ) is written t[x := a].\nGiven a CSP \u3008X,D,C\u3009, an X-tuple t satisfies a constraint ci = ri(Vi) \u2208 C if t|Vi \u2208 ri. We denote by Sol(ci) the set of X-tuples which satisfy ci. The set \u22c2 c\u2208C Sol(c) of X-tuples which satisfy all the constraints is called the solution space, and denoted Sol(C). By solving a CSP we mean to decide whether the set Sol(C) is non-empty and, if so, compute one (or all) the solutions.\nThe set of X-tuples t over D is called the search space and denoted by SD, or simply S if the domain is implicit from the context. The relational operators of selection, projection and complement will be useful: given a V -relation c, a subset U of V and a value a \u2208 D, we denote by \u03c3x=a(ci) (resp. \u03c3x 6=a(ci)) the V -relation which contains the tuples of ci whose value on x is a (resp. is different from a), by \u03c0U (ci) the set of restrictions to U of tuples of ci (i.e., the set of U -tuples {t | \u2203t\u2032 \u2208 ci (t = t\u2032|U )}) and by ci the set of V -tuples {t | t 6\u2208 ci}.\nNote that \u03c3x=a(S) denotes the search space obtained by fixing the value of x to a. For the sake of simplicity, the sets X and C will be considered as globally defined and shall therefore be omitted from the parameters of most definitions; only the search space will be explicitly mentioned.\nExample 2. Consider the CSP \u3008X,D,C\u3009 modeling the 3-coloring problem for the graph in Figure 2. We have that:\n\u2022 X = {x1, . . . , x5} is the set of variables (one for each node),\n\u2022 D = {R,G,B} is the set of colors, and\n\u2022 C is the following finite set of constraints, one for each edge:\nC = {NE(x2, x3), NE(x3, x4), NE(x2, x4), NE(x4, x5)},\nwhere NE (not-equal) is a binary relation defined as\n({R,G,B} \u00d7 {R,G,B}) \\ {\u3008R,R\u3009, \u3008G,G\u3009, \u3008B,B\u3009}."}, {"heading": "2.3 Definitions", "text": "In this section, we formally present the properties already introduced in Section 2.1, and show their applicability on some examples.\nDefinition 2. The following properties are defined for a search space S, variables x and y, values a and b, and for a set of variables V :\nfixable(S, x, a) \u2261 \u2200t \u2208 S (t \u2208 Sol(C) \u2192 t[x := a] \u2208 Sol(C))\nsubstitutable(S, x, a, b) \u2261 \u2200t \u2208 S ( tx = a \u2227 t \u2208 Sol(C) \u2192 t[x := b] \u2208 Sol(C) )\nremovable(S, x, a) \u2261 \u2200t \u2208 S ( tx = a \u2227 t \u2208 Sol(C) \u2192 \u2203b 6= a (t[x := b] \u2208 Sol(C)) )\ninconsistent(S, x, a) \u2261 \u2200t \u2208 S ( t \u2208 Sol(C) \u2192 tx 6= a ) implied(S, x, a) \u2261 \u2200t \u2208 S ( t \u2208 Sol(C) \u2192 tx = a )\ndetermined(S, x) \u2261 \u2200t \u2208 S ( t \u2208 Sol(C) \u2192 \u2200b 6= tx (t[x := b] 6\u2208 Sol(C)) )\ndependent(S, V, y) \u2261 \u2200t, t\u2032 \u2208 S  t \u2208 Sol(C)\u2227t\u2032 \u2208 Sol(C)\u2227\n\u2200x \u2208 V (tx = t\u2032x)\n\u2192 ty = t\u2032y \nirrelevant(S, x) \u2261 \u2200t \u2208 S ( t \u2208 Sol(C) \u2192 \u2200a \u2208 D (t[x := a] \u2208 Sol(C)) )\nAs for interchangeability, it is well-known (Freuder, 1991) that it can be defined in terms of substitutability:\ninterchangeable(S, x, a, b) \u2261 substitutable(S, x, a, b) \u2227 substitutable(S, x, b, a)\nIn the few cases where an ambiguity arises on the considered set of constraints, we will indicate it using subscript (e.g., irrelevantC (S, x)). Note that all the definitions but the last three are value-oriented, in that they are properties of specific values of the domain. On the contrary, determinacy, irrelevance, and dependence are variable-oriented properties which do not directly express results on particular values of the domains but have important relations with the value-oriented notions (cf. forthcoming Section 2.4).\nAs already claimed in Section 1, some of the properties of Definition 2 are already known, as well as their beneficial effects to search. In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP. Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999). To the best of our knowledge, the notions of removable and fixable values (which, as we show in Section 2.4 play a key role in the unifying framework proposed in this paper) have on the contrary not been considered. Determined, irrelevant and dependent variables have been studied in a number of contexts as logic, SAT, and databases, cf., e.g., Beth definability (Chang & Keisler, 1990), don\u2019t care variables in propositional formulae (Thiffault,\nBacchus, & Walsh, 2004; Safarpour, Veneris, Drechsler, & Lee, 2004), and the Audit problem (Jonsson & Krokhin, 2008), but we are aware of little work concerning their application in the context of CSPs.\nThe following examples illustrate some of the properties.\nExample 3 (Example 2 continued). Consider a CSP modeling the coloring problem for the graph in Figure 2. Let \u03a3 denote the search space in which all five variables x1, . . . , x5 have domain {R,G,B}. The following properties hold:\n\u2022 fixable(\u03a3,x1,R), since for every solution t, t[x1 := R] is a solution as well; \u2022 substitutable(\u03a3,x1,R,G), since for every solution t such that tx1 = R, t[x1 := G] is a\nsolution as well;\n\u2022 interchangeable(\u03a3,x1,R,G), from the previous point and the fact that substitutable(\u03a3,x1,G,R) also holds;\n\u2022 removable(\u03a3,x1,G), because for every solution t such that tx1 = G, there exists a different color K \u2208 {R,B} for x1 such that t[x1 := K] is a solution as well; \u2022 irrelevant(\u03a3,x1), because we can actually replace the x1-component of any solution t\nwith any other value, since x1 denotes a disconnected node of the graph.\nThe above properties holding for variable x1 that encodes the disconnected node give some initial suggestions on the relationships that exist among the different notions. As for the other nodes, we have, for example:\n\u2022 removable(\u03a3,x5,G), because for every solution t such that tx5 = G, there exists a different color K \u2208 {R,B} for x5 such that t[x5 := K] is a solution as well. This is due to the fact that node 5 is connected only to node 4.\nAs another, more complex, example, consider the following:\nExample 4. Let a CSP be given over boolean variables x, y, z, w, p, q, r, whose constraints are encoded by the formula below:\nx \u2227 (x\u2192 y) \u2227 ((z \u2228 w)\u2194 p) \u2227 ((z \u2228 y)\u2194 (q \u2227 r)) Denoting as \u039e the search space in which all variables range over {true, false}, we have, among the others:\n\u2022 inconsistent(\u039e,x,false), \u2022 fixable(\u039e,x,true), \u2022 implied(\u039e,x,true), \u2022 implied(\u039e,y,true), \u2022 inconsistent(\u039e,y,false),\n\u2022 determined(\u039e,y), \u2022 dependent(\u039e,{z, w},p), \u2022 dependent(\u039e,{z, y},q), \u2022 dependent(\u039e,{z, y},r), \u2022 fixable(\u039e,q,true),\n\u2022 implied(\u039e,q,true), \u2022 fixable(\u039e,r,true),\n\u2022 implied(\u039e,r,true).\nSome of the definitions of Definition 2 can be used to construct solution-preserving transformations, i.e., mappings which transform solutions into solutions.\nDefinition 3 (solution-preserving transformation). A solution-preserving transformation is a total mapping \u03c4 from S to S such that\n\u2200t \u2208 S (t \u2208 Sol(C)\u2192 \u03c4(t) \u2208 Sol(C))\nTo understand the connection between solution-preserving transformations and the aforementioned properties, consider the following mappings:\n\u03c41(t) = t[x := a]\n\u03c42(t) = { t[x := b] if tx = a t otherwise\n\u03c43(t) =  t[x := b] if tx = a t[x := a] if tx = b t otherwise\nChecking whether value a is fixable for variable x, whether value a is substitutable to value b for variable x, and whether values a and b are interchangeable for variable x amounts to check whether mappings \u03c41, \u03c42 and \u03c43 (respectively) are solution-preserving.\nSolution-preserving transformations are interesting because they allow us to remove values from the search space while preserving the satisfiability of the problem. Moreover, the correspondence between some properties and the existence of particular solution-preserving mappings shows that interesting connections hold among these properties and other concepts, like symmetries. As an example, Mancini and Cadoli (2005) give a logical characterisation of symmetries in problem specifications, which is very similar to, and in fact stronger than, that of Definition 3. In addition, more general forms of solution-preserving transformations could be defined, that, e.g., allow also for the modification of the constraints, i.e., as pairs (\u03c4, \u03c3) such that \u2200t \u2208 S (t \u2208 Sol(C)\u2192 \u03c4(t) \u2208 Sol(\u03c3(t, C))). This interesting topic, that may lead to the definition of further and more general properties of a CSP, is left for future research."}, {"heading": "2.4 Semantical Relationships", "text": "As already observed (cf. also Examples 3 and 4), several semantical relationships exist among the notions presented in Definition 2, some of which appear weaker, while some others stronger. The main connections are clarified by the following theorem.\nTheorem 1. The relationships shown in Figure 3 hold between the properties of Definition 2.\nProof.\nDependence-determinacy. We have dependent(S, {x1, . . . , xi}, y) iff every solution t has a value on y which is given by a function f of the values it assigns to x1 . . . xi, iff in any search\nspace \u03c3x1=a1,...,xi=ai(S) (where all these variables receive a fixed value), all solutions assign the same value f(a1, . . . , an) to y.\nIrrelevance-fixability. t \u2208 Sol(C) \u2192 \u2200a \u2208 D (t[x := a] \u2208 Sol(C)) rewrites to \u2200a \u2208 D (t \u2208 Sol(C)\u2192 t[x := a] \u2208 Sol(C)). Determinacy-implication. If implied(S, x, b) holds for some b, then for each t and a 6= b we have t[x := a] 6\u2208 Sol(C). Implication-fixability. implied(S, x, b) means that every t \u2208 Sol(C) has tx = b. Hence for every t \u2208 Sol(C), we have t[x := b] = t \u2208 Sol(C). Implication-inconsistency. implied(S, x, a) holds iff \u2200t (tx 6= a \u2192 t 6\u2208 Sol(C)), i.e., iff \u2200t \u2200b \u2208 D \\ {a} (tx = b\u2192 t 6\u2208 Sol(C)). This rewrites to \u2200b \u2208 D \\ {a} inconsistent(S, x, b). Fixability-substitutability. Let D = {a1, .., ad}. We have \u2227 i\u22081..d substitutable(S, x, ai, b) iff \u2200t ((tx = a1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 tx = ad) \u2227 t \u2208 Sol(C) \u2192 t[x := b] \u2208 Sol(C)), which rewrites to fixable(S, x, b).\nInconsistency-substitutability. Suppose inconsistent(S, x, a) holds. No solution t with tx = a exists, hence the implication tx = a\u2227 t \u2208 Sol(C)\u2192 t[x := b] \u2208 Sol(C) is true for all choices of b.\nInconsistency-removability. Same argument as for inconsistency-substitutability.\nSubstitutability-removability. Suppose substitutable(S, x, a, b) holds for some value b 6= a. This can be written \u2203b \u2200t (tx = a \u2227 t \u2208 Sol(C) \u2192 t[x := b] \u2208 Sol(C)), which implies \u2200t \u2203b(tx = a \u2227 t \u2208 Sol(C) \u2192 t[x := b] \u2208 Sol(C)). The latter rewrites to \u2200t (tx = a \u2227 t \u2208 Sol(C)\u2192 \u2203b t[x := b] \u2208 Sol(C)).\nNote also that implied values and determined variables are strongly related to problems with a unique solution: if a problem has a unique solution, then all its variables have an implied value (cf. Example 1), hence they are determined."}, {"heading": "2.5 Exploiting Properties in Constraint Solving", "text": "An important reason why the aforementioned properties are interesting is that, when detected, they allow us to reduce the search space by removing values from the active domains of the variables. In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al., 1999), dependence (Mancini & Cadoli, 2007). However, thanks to the unifying framework of Figure 3, we can now show that the wide interest in the aforementioned properties essentially relies in their relations with the two fundamental properties of removability and fixability.\nTheorem 2. Let \u03c0 be a CSP \u3008X,D,C\u3009. If value a is fixable for variable x \u2208 X, then \u03c0 is satisfiable if and only if the CSP \u03c0\u2032 = \u3008X,D,C \u222a {x = a}\u3009 obtained from \u03c0 by instantiating variable x to value a is satisfiable.\nProof. Assume that \u03c0\u2032 is satisfiable. Then there exists a X-tuple t that satisfies all the constraints. Since the constraints of \u03c0\u2032 are a superset of those of \u03c0, t is also a solution of \u03c0.\nAs for the other direction, assume that \u03c0 is satisfiable. Then there exists a solution t. Since value a if fixable for x, it follows that t[x := a] is a solution as well. t[x := a] satisfies also the additional constraint \u201cx = a\u201d of \u03c0\u2032, hence the latter problem is satisfiable as well.\nTheorem 3. Let \u03c0 be a CSP \u3008X,D,C\u3009. If value a is removable for variable x \u2208 X, then \u03c0 is satisfiable if and only if the CSP \u03c0\u2032 = \u3008X,D,C \u222a {x 6= a}\u3009 obtained from \u03c0 by removing value a from the domain of variable x is satisfiable.\nProof. If \u03c0\u2032 is satisfiable, then, by the same arguments of the proof of Theorem 2, \u03c0 is satisfiable as well.\nAs for the other direction, assume that \u03c0 is satisfiable. Then there exists a solution t. If tx 6= a, t is of course also a solution of \u03c0\u2032. On the other hand, if tx = a, since value a is removable for x in \u03c0, it follows that there exists b 6= a such that t[x := b] is a solution as well. t[x := b] satisfies also the additional constraint \u201cx 6= a\u201d of \u03c0\u2032, hence the latter problem is also satisfiable.\nThe above results show the key roles played by fixability and removability. They are the ideal properties that should be checked in order to reduce the domain for a variable. The interest in the other notions essentially relies on their relationships with fixability and removability. As an example, an implied value is of interest essentially because it is fixable, an irrelevant variable is of interest essentially because it is fixable to any value of its domain, a substitutable value is of interest essentially because it is removable, etc.\nAlso the interest in inconsistent values relies on the fact that they are removable. However, inconsistency is much stronger that removability, because removing inconsistent values\nguarantees that all solutions (and not only the satisfiability of the problem) are preserved. Hence removability plays exactly the same role of inconsistency in case we do not want to find all solutions of a problem but simply want to find one. In such situations removability is the ideal property to use.\nAs for the other properties, it is worth noting that, although they may appear very strong and unlikely at a first sight, they can still play a precious role when detected dynamically during search. As an example, Thiffault et al. (2004) show that dynamically detecting variables that become irrelevant during search (called don\u2019t care variables in the paper) can greatly speed-up non-CNF SAT solvers, by actually separating problems into independent components."}, {"heading": "3. Complexity of reasoning", "text": "In this section we show that the problem of checking whether properties of Definition 2 hold is coNP-complete. Hence, in Section 3.2, we try to determine special cases where checking can be done efficiently (i.e., in polynomial time)."}, {"heading": "3.1 Intractability Results", "text": "From now on, we assume that the input is given as a set of constraints C over a set of variables X. We also assume that the problem of checking whether t \u2208 Sol(C) is polynomial in the size of the representation of the input. Such properties hold for propositional logic and for CSPs, in the sense of Dechter (1992).\nWe note that the problem of checking whether properties of Definition 2 hold is in coNP, because, for each of them it is possible to find a counter-example by guessing a tuple in S (two, in case of dependency) in non-deterministic polynomial time, and checking, in polynomial time, whether the negation of the subformula between parentheses holds (as for interchangeability, we note that the logical \u201cand\u201d of two properties in coNP is still in coNP). Alternatively, coNP-membership follows observing that succinct certificates exist proving that the various properties do not hold (as an example, a certificate proving that variable x is not fixable to a is a V -tuple t \u2208 Sol(C) such that t[x := a] 6\u2208 Sol(C)). In the rest of this section, proofs are therefore restricted to the coNP-hardness part.\nTheorem 4 (coNP-completeness of properties of Definition 2). Given a CSP, the following tasks are coNP-complete:\n\u2022 Checking whether value a is fixable, removable, inconsistent, implied, or determined for variable x \u2208 X; \u2022 Checking whether value a \u2208 D is substitutable to, or interchangeable with value b \u2208 D\nfor variable x \u2208 X; \u2022 Checking whether variable y \u2208 X is dependent on variables in a set V \u2286 X; \u2022 Checking whether variable x \u2208 X is irrelevant.\nProof. To prove that checking such properties is hard for coNP, we reduce a coNP-complete problem, i.e., that of checking that an arbitrary CSP is unsatisfiable, to the problem of\nchecking these properties. In particular, the proofs hold even if the domain is boolean, in which case the CSP can be written as a propositional formula \u03c6, e.g., in CNF. Hence, let \u03c6 be an arbitrary propositional formula in CNF over set of variables X, and let x be a variable such that x 6\u2208 X: the unsatisfiability problem of \u03c6 can be reduced into the problem of checking the various properties. Moreover, the semantical relationships defined in Theorem 1 allow to infer in an elegant way hardness results for several properties starting from those of the others.\nIrrelevance. Consider \u03c8 defined as \u03c6 \u2227 x. \u03c8 is unsatisfiable if and only if \u03c6 is unsatisfiable. We now show that \u03c6 is unsatisfiable if and only if x is irrelevant in formula \u03c8. Let us first assume that \u03c6 is unsatisfiable. It follows that x is irrelevant in \u03c8, because \u03c8 has no models. On the other hand, let M be a model of \u03c6. Interpretation M \u222a {x\u2190 true} is a model of \u03c8, while M \u222a {x\u2190 false} is not, implying that x is not irrelevant in \u03c8. Fixability, Substitutability. Results follow from that of irrelevance, combined with the semantical relationships that define irrelevance in terms of fixability, and fixability in terms of substitutability.\nDependence. Consider \u03c8 defined as \u03c6 \u2227 (x \u2228 \u00acx). \u03c8 is unsatisfiable if and only if \u03c6 is unsatisfiable, and that x is dependent on X in \u03c8 if and only if \u03c6 is unsatisfiable.\nDeterminacy. The result follows from that of dependence, combined with the semantical relationship that defines dependence in terms of determinacy.\nImplication. Consider \u03c8 defined as \u03c6 \u2227 x. Value false is implied for x in \u03c8 if and only if \u03c6 is unsatisfiable.\nInconsistency. The result follows from that of implication, combined with the semantical relationship that defines implication in terms of inconsistency.\nRemovability. Consider \u03c8 defined as \u03c6 \u2227 x. Value true is removable for x in \u03c8 if and only if \u03c6 is unsatisfiable.\nFrom the proof of Theorem 4, it can be observed that the intractability of checking each of the properties holds also for binary CSPs (i.e., CSPs in which all constraints relate at most two variables).\nTheorem 5 (coNP-completeness of properties of Definition 2 for binary CSPs). Given a CSP with only binary constraints on a domain of size greater than two, checking the properties of Definition 2 is coNP-complete.\nProof. We give the proof for irrelevance only: the others can be derived similarly. Let \u03a6 = \u3008X,D,C\u3009 be a binary CSP. Consider an arbitrary variable x 6\u2208 X and let a and b be arbitrary distinct values in D. Let \u03a8 denote the CSP \u3008X \u2032, D,C \u2032\u3009 with X \u2032 = X\u222a{x}, and C \u2032 = C \u222a {x = a}. \u03a8 is binary and, similarly to the proof of Theorem 4, \u03a6 is unsatisfiable if and only if variable x is irrelevant for \u03a8.\nFrom the observation that a CSP encoding of the graph 3-colourability problem can be made using only binary constraints, the thesis follows, since checking unsatisfiability of this problem (which is coNP-hard) can be reduced to checking irrelevance in a binary CSP."}, {"heading": "3.2 Tractability Results", "text": "Since detecting any of the properties we are interested in is a computationally hard problem, a natural question is to determine special cases where checking can be done efficiently. To this end, we investigate two approaches: we exhibit syntactical restrictions which make the problem tractable, and we study local relaxations of the definitions which are polynomialtime checkable, and which therefore provide incomplete algorithms for detecting the various properties."}, {"heading": "3.2.1 Tractability for Restricted Constraint Languages", "text": "A number of syntactical restrictions to the constraint satisfaction problem are known which make it tractable. For instance, in the case of boolean constraints, i.e., propositional formulae, the satisfiability problem becomes tractable if the instance is expressed using only Horn clauses, only dual Horn clauses (i.e., clauses with at most one negative literal), only clauses of size at most 2, or only affine constraints (i.e., formulae built using XOR). These are known as the Schaefer\u2019s (1978) classes. It is natural to wonder if all the properties identified in Definition 2 are also easy to determine for these classes of formulae. This is indeed the case for most of them, and we give a more general condition under which tractable classes for the consistency property are also tractable for other properties of our framework. We note that a recent paper (Jonsson & Krokhin, 2004) gives a complete characterisation of tractable cases for a related property.\nIn what follows we are interested in classes of CSPs. To this end, we define a constraint language \u0393D over domain D to be a finite set of relations (of finite arity) with elements in D, and denote by CSP(\u0393D) the set of CSPs of the form \u3008X,D,C\u3009 with every element ci = ri(Vi) \u2208 C being such that Vi \u2286 X and ri \u2208 \u0393D. (We observe that once the constraint language \u0393D is fixed, the domain D for all instances of CSP(\u0393D) is fixed as well.)\nA constraint language \u0393 is said to be closed under instantiation (resp. under complementation) if whenever a constraint ci = ri(Vi) is expressible in the language (i.e., ri \u2208 \u0393), the relation \u03c0X\\{x}(\u03c3x=a(ci)), a \u2208 D (resp. the complementation ci) can be represented by a conjunction of constraints of the language. This means that there exist constraints c\u20321 = r \u2032 1(V \u2032 1), . . . , c \u2032 k = r \u2032 k(V \u2032 k), with V \u2032 j \u2286 X and r\u2032j \u2208 \u0393 for each j, such that \u03c0X\\{x}(\u03c3x=a(ci)) (resp. ci) is equivalent to c\u20321\u2227\u00b7 \u00b7 \u00b7\u2227c\u2032k.2 Well known constraint languages on boolean domains which are closed under instantiation and complementation are those of Horn clauses, dual Horn clauses, 2CNF clauses or affine constraints (since the instantiation or the complement of a Horn /dual Horn/2CNF clause or affine constraint can be expressed as a conjunction of Horn /dual Horn/2CNF clauses or affine constraints).\nTheorem 6. Given a constraint language \u0393, if the satisfiability problem CSP(\u0393) is tractable and if \u0393 is closed under instantiation, then the problem of checking determinacy for CSPs in the class CSP(\u0393) is tractable as well.\n2. Note that we define closure with respect to complementation with a slightly different non-standard meaning, as the negation of the constraint needs be expressible as a conjunction of constraints. Some definitions impose that it be definable as a single constraint of the language.\nProof. Let us consider an arbitrary instance \u3008X,D,C\u3009 \u2208 CSP(\u0393). Variable x \u2208 X is not determined if and only if there exist two different domain values, a and b \u2208 D, such that\n\u03c0X\\{x}(\u03c3x=a(Sol(C))) \u2229 \u03c0X\\{x}(\u03c3x=b(Sol(C)))\nis not empty, i.e., if and only if one of the CSPs \u3008X\u0302,D, C\u0302a,b\u3009, with:\n\u2022 X\u0302 = X \\ {x}, and \u2022 C\u0302a,b = {\u03c0X\\{x}(\u03c3x=a(c)) | c \u2208 C} \u222a {\u03c0X\\{x}(\u03c3x=b(c)) | c \u2208 C},\nis satisfiable. If \u0393 is closed under instantiation, constraints in C\u0302a,b can all be written as conjunctions of constraints in \u0393. Hence, we have reduced the determinacy-testing problem to solving O(|D|2) instances of CSP(\u0393), which is tractable.\nTheorem 7. Given a constraint language \u0393, if the satisfiability problem CSP(\u0393) is tractable and if \u0393 is closed under instantiation and complementation, then the problem of checking any property among fixability, substitutability, interchangeability, inconsistency or irrelevance for CSPs in the class CSP(\u0393) is tractable as well.\nProof. We start with the substitutability property and note that, given an arbitrary instance \u3008X,D,C\u3009 \u2208 CSP(\u0393), value a \u2208 D is substitutable by b \u2208 D for variable x \u2208 X if and only if\n\u03c0X\\{x}(\u03c3x=a(Sol(C))) \u2286 \u03c0X\\{x}(\u03c3x=b(Sol(C))).\nThis inclusion is false, i.e., substitutability does not hold, if and only if the set\n\u03c0X\\{x}(\u03c3x=a(Sol(C))) \u2229 \u03c0X\\{x}(\u03c3x=b(Sol(C))) (1)\nis non-empty. Since \u03c3x=b(Sol(C)) = \u03c3x=b( \u22c2 c\u2208C Sol(c)) = \u22c2 c\u2208C(\u03c3x=b(Sol(c))), we have:\n\u03c0X\\{x}(\u03c3x=b(Sol(C))) = \u03c0X\\{x} ( \u22c2 c\u2208C(\u03c3x=b(Sol(c))) ) .\nAlthough the projection of an intersection of relations is not equal to the intersection of their projections in general, the latter rewrites to:\u22c2\nc\u2208C \u03c0X\\{x}(\u03c3x=b(Sol(c))).\nThis is due to the fact that we select on x before eliminating it by projection. We only prove the inclusion which does not hold in general: suppose we have t \u2208 \u22c2c\u2208C \u03c0X\\{x}(\u03c3x=b(Sol(c))). This means that \u2200c \u2208 C, there exists a tuple tc such that tc|X\\{x} = t and tc \u2208 \u03c3x=b(Sol(c)). It follows that tcx = b and that we have indeed a unique t with tx = b and t\nc|X\\{x} = t which is such that \u2200c \u2208 C (t \u2208 \u03c3x=b(Sol(c))), i.e., t \u2208 \u03c0X\\{x}( \u22c2 c\u2208C(\u03c3x=b(Sol(c)))).\nFormula (1) is therefore equivalent to:\u22c2 c\u2208C \u03c0X\\{x}(\u03c3x=a(Sol(c))) \u2229 \u22c3 c\u2208C \u03c0X\\{x}(\u03c3x=b(Sol(c)))\nA solution exists (and therefore substitutability does not hold) if one of the sets\u22c2 c\u2208C \u03c0X\\{x}(\u03c3x=a(Sol(c))) \u2229 \u03c0X\\{x}(\u03c3x=b(Sol(c)))\nobtained for every c \u2208 C has a solution. If language \u0393 is closed under instantiation and complement, we can express the new constraint \u03c0X\\{x}(\u03c3x=b(Sol(c))) as a conjunction C \u2032 of constraints in \u0393. Each of the sets has a solution iff the CSP \u3008X \\{x}, D, {\u03c0X\\{x}(\u03c3x=a(c)) | c \u2208 C} \u222aC \u2032\u3009 is satisfiable. We have reduced the substitutability testing problem to solving |C| instances of a constraint satisfaction problem whose constraints are all in the language \u0393, which is tractable.\nThe results for fixability, interchangeability and irrelevance follow directly, because of the semantical relationships shown in Figure 3. Consistency of value a for variable x can directly be expressed as the satisfiability of \u03c0X\\{x}(\u03c3x=a(Sol(C))), which can be expressed in \u0393, and the proof for implication follows from this result.\nA slightly different closure property is needed for the removability of value a for variable x since it is expressed as \u03c0X\\{x}(Sol(C)) \u2286 \u03c0X\\{x}(\u03c3x 6=a(Sol(C))).\nNevertheless, since on boolean domains a value v is removable if v is substitutable by \u00acv, and from the remarks on the closure properties of Schaefer\u2019s classes and the previous theorem, we obtain that:\nCorollary 1. Testing fixability, substitutability, interchangeability, inconsistency, determinacy, irrelevance and removability is tractable for a boolean CSP where constraints are either Horn clauses, dual Horn clauses, clauses of size at most two or affine constraints.\nUnfortunately, we don\u2019t have tractability results for dependence.\nTable below summarizes Theorems 6 and 7, and Corollary 1:\nProperty Polynomial if \u0393 is Determinacy Tractable and closed under instantiation Fixability, substitutability, interchangeability, inconsistency, irrelevance Tractable and closed under inst. and compl. Removability Boolean Schaefer\nIt is worth noting that conditions become more restrictive when reading the table top-down. Moreover, in all the cases, it can be observed that tractability of the various propertydetection problems derives from tractability of the constraint language \u0393. This leads to serious concerns about the practical applicability of such results: if CSP(\u0393) is tractable, why worrying for identifying such properties? Actually, preliminary studies show that better results are unlikely to hold: as an example, it can be proven that if the constraint language is intractable, then there is no hope for detecting properties like fixability, irrelevance, substitutability, inconsistency in polynomial time. So these results become of\ninterest, suggesting two main directions of further research: the first is of course that of investigating the practical benefit of detecting such properties in real cases; the second is to exploit sufficient but efficiently evaluable conditions for these properties to hold, that can be regarded as a form of approximate reasoning. One of the most used forms of such kind of reasoning is called local reasoning, which is addressed below."}, {"heading": "3.2.2 Tractability Through Locality", "text": "An important class of incomplete criteria to determine in polynomial time whether a complex property holds are those based on local reasoning. This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf. also Choueiry & Noubir, 1998, where a classification of different local forms of interchangeability are studied and classified). We propose in this section a systematic investigation of whether a local approach can be used for value-based properties.\nVerifying a property P (C) of a set of constraints C locally means that we verify the property on a well-chosen number of sub-problems. We must ensure that this approach is sound for the considered property:\nDefinition 4 (soundness of local reasoning). We say that local reasoning on a property P is sound if, for all subsets of constraints C1 \u2286 C, . . . , Ck \u2286 C such that \u22c3 i\u22081..k Ci = C, we have (depending on the property):( \u2227 i\u22081..k P (Ci)\n) \u2192 P (C) or ( \u2228i\u22081..k P (Ci) ) \u2192 P (C). A typical choice of granularity is to simply consider that each Ci contains one of the constraints of C as is done, for instance, for arc-consistency. On the other extreme, if we take a unique C1 = C, we have a global checking. Between these two extremes, a wide range of intermediate levels can be defined (cf., e.g., Freuder, 1978, 1991).\nExample 5. Consider the CSP \u3008X,D,C\u3009 with X = {x, y, z}, D = {0, 1, 2} and C = {c1, c2, c3}, whose elements are defined as follows:\nx y 0 1 1 2 2 1 2 2\nx z 1 0 1 2 2 0 2 2\ny z 1 1 1 2 2 1 2 2\nc1(x, y) c2(x, z) c3(y, z)\nIt can be observed that value 1 is substitutable to 2 for variable x. In order to check this property locally, we consider a suitable covering C1, . . . , Ck of the set C, and verify it on the induced subproblems. As an example, by taking C1 = {c1}, C2 = {c2}, C3 = {c3}, we have substitutableCi (S, x, 1, 2) for every i \u2208 {1, 2, 3}. Since local reasoning is sound for substitutability (cf. Freuder, 1991), we can infer that the global property substitutableC (S, x, 1, 2) holds.\nReasoning locally is typically tractable if we focus on a moderate number of subsets of C, and under the condition that we can bound the complexity of reasoning on each of these\nsubsets. A typical assumption in CSP is that we can bound the arity of the constraints, and that every constraint is for instance binary. In this case, the cost of determining any property of the constraint is polynomial; and if we choose to reason locally by considering each constraint separately, or by taking groups of constraints of bounded size, then local checking is tractable.\nTheorem 8. Local reasoning is sound for the properties of substitutability, interchangeability, fixability, inconsistency, implication, irrelevance, determinacy, dependence. In particular, for any C1 \u2286 C, . . . , Ck \u2286 C such that \u22c3 i\u22081..k Ci = C:\n\u2022 ( \u2227i\u22081..k substitutableCi (S, x, a, b) )\u2192 substitutableC (S, x, a, b); \u2022 ( \u2227\ni\u22081..k interchangeableCi (S, x, a, b)\n) \u2192 interchangeable\nC (S, x, a, b);\n\u2022 ( \u2227i\u22081..k fixableCi (S, x, b) )\u2192 fixableC (S, x, b); \u2022 ( \u2228i\u22081..k inconsistentCi (S, x, a) )\u2192 inconsistentC (S, x, a); \u2022 ( \u2228\ni\u22081..k impliedCi (S, x, a)\n) \u2192 implied\nC (S, x, a);\n\u2022 ( \u2227i\u22081..k irrelevantCi (S, x) )\u2192 irrelevantC (S, x); \u2022 ( \u2228i\u22081..k determinedCi (S, x) )\u2192 determinedC (S, x); \u2022 ( \u2228\ni\u22081..k dependentCi (S, V, y)\n) \u2192 dependent\nC (S, V, y).\nProof. The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991). Fixability of variable x to value b can be expressed as\n\u2200a 6= b (substitutableC (S, x, a, b)) Therefore, if we have \u2227 i\u22081..k fixableCi (S, x, b) (which is equivalent to \u2227 i \u2227 a6=b\nsubstitutableCi (S, x, a, b) and to \u2227 a6=b \u2227\ni substitutableCi (S, x, a, b)), then we have\u2227 a6=b substitutableC (S, x, a, b), which means fixableC (S, x, b). A similar argument works for irrelevance, which can be analogously defined in terms of fixability (cf. Figure 3). As for implication, if a value a is implied for variable x in any Ci, then all tuples t with tx 6= a violate the constraints of Ci and do a fortiori not belong to Sol(C). Similarly for determinacy: if a variable x is determined in any Ci, then all tuples t \u2208 Sol(Ci) will be such that t[x := b] 6\u2208 Sol(Ci) for any b 6= tx. Hence there cannot be any solution t \u2208 Sol(C) such that t[x := b] \u2208 Sol(C) with b 6= tx. Finally, as for dependence, if there exists a Ci for which dependent\nCi (S, V, y) holds (it is enough to consider sets of constraints Cis such\nthat V \u2229 var(Ci) 6= \u2205 and y \u2208 var(Ci) for which we have dependentCi (S, V \u2229 var(Ci), y)), we have, by definition, that \u2200t, t\u2032 \u2208 Sol(Ci) (\u2200x \u2208 V \u2229 var(Ci) (tx = t\u2032x)) \u2192 ty = t\u2032y, and so dependent\nC (S, V, y) also holds, since any solution of the whole problem must satisfy also\nCi.\nExample 6 (Example 5 continued). Value 2 is fixable for z. This can be inferred by performing local reasoning as follows:\n\u2022 fixableC1 (S, z, 2) holds, since z does not occur in the scope of c1;\n\u2022 fixableC2 (S, z, 2) holds, since for any tuple t that belongs to c2, also t[z := 2] belongs to c2;\n\u2022 fixableC3 (S, z, 2) holds, because of the same argument.\nSince by Theorem 8 local reasoning is sound for fixability, we can infer that fixableC (S, z, 2) holds.\nThere is only one (value-based) property, namely removability, for which the local approach is unfortunately not sound:\nTheorem 9. Local reasoning is not sound for the removability property.\nProof. Take C = C1 \u2227 C2, where C1 is defined as x \u2264 y and C2 as x \u2265 y. Suppose the domain has values {1, 2, 3}. Value 2 for x is removable from both constraints considered independently since, in both cases, we can change the value of any solution which assigns 2 to x to another value. Still, value 2 is not removable for x from their conjunction. To see why, consider the solution with \u3008x, y\u3009 = \u30082, 2\u3009, and observe that neither \u30081, 2\u3009 or \u30083, 2\u3009 are solutions.\nNote that removing values which are shown to be removable only locally can even make a satisfiable problem unsatisfiable: if furthermore we add the constraints C3, defined as x 6= 1 and C4, defined as x 6= 3, then value 2 for x is removable in each constraint, while the only (global) solution actually assigns value 2 to x.\nThis result, although negative, is in fact interesting, because it gives an ex-post justification of the extensive use that has been made in the last decades of stronger notions, like inconsistency or substitutability, both of which imply removability (cf. Figure 3). The main reason why current tools and frameworks for CP try to detect these properties is in order to remove values from the active domain of some variables. This naturally relies on the removability property (cf. Section 2.5). However, the reason why removability is not directly used is because it is intractable. For that reason, stronger notions like consistency or substitutability are the forms of removability that have been more commonly used. Actually, unlike full-fledged removability (cf. Theorem 9), these properties can be detected efficiently, but incompletely, through local reasoning. Hence, this raises an interesting open issue: do there exist new (i.e., other than substitutability and inconsistency) properties for which local reasoning is sound and which imply removability?\nWe end this section by noting that the local version of the fixability property is indeed a generalisation to arbitrary domains of the pure literal rule (Davis & Putnam, 1960) which is well-known in the case of boolean constraints in conjunctive normal form. The pure literal rule exploits the cases where no constraint (clause) of the problem has a positive (resp. negative) occurrence of some variable x. In this case, assigning value 0 (resp. 1) to x preserves the satisfiability of the problem: if a solution t with tx = 1 exists, then t[x := 0] will also be a solution since no clause constrains x to have value 1.\nExample 7. Consider the following propositional formula \u03d5 in CNF:\n(x \u2228 y \u2228 z) \u2227 (x \u2228 \u00acy \u2228 \u00acz) \u2227 (y \u2228 \u00acz)\nSince \u00acx does not occur in any clause, we can assign x to 1, and maintain the satisfiability of the formula: for any solution t of \u03d5, the assignment t[x := 1] is a solution of \u03d5 as well.\nIt is clear that the pure literal rule detects fixability based on a reasoning local to each clause (a variable x is fixable to, say, 1 in a clause iff this clause does not contain the literal \u00acx, and the pure literal rule checks that this condition holds for every constraint).\nNo generalisation of the pure literal rule has, to the best of our knowledge, been proposed for CSP, while a generalisation of the pure literal rule for QBF has been applied to solvers for Quantified CSP under the name pure value rule (Gent, Nightingale, & Stergiou, 2005). It can be observed that such proposal is in fact a local relaxation of the generalisation to quantified constraints of fixability. As will be shortly discussed in Section 4, all the properties presented in this paper can be generalized to Quantified CSP in an elegant way, and many local relaxations remain valid."}, {"heading": "4. Conclusions and Perspectives", "text": "In this paper we reconsidered most of the structural properties of CSPs extensively studied and exploited in order to simplify search. Such properties may be of course useful also in other tasks, e.g., for the classification or update of solutions, or for compacting the solution space, and for supporting explanation and interaction with users.\nWe provided a unifying framework for the properties, that clarifies their semantical relationships and allows new ones to emerge. We argued that some of the new notions, namely fixability and removability play a key role in a deep understanding of the topic, being the ideal characterisations of values that can be fixed or removed preserving the satisfiability of the problem. Known properties, like inconsistency and substitutability are thus suitable specialisations of them.\nWe then tackled the questions related to the automated detection of the different properties and of their exploitation by the solving engine for simplifying problems. In particular, we showed how detecting each of the proposed properties is in general as hard as the original CSP. Hence, in order to find efficient ways for their verification, we investigated, according to the CSP approach, two main lines: addition of suitable restrictions of the constraint language and approximation of the reasoning task by exploiting local versions of the various notions. Moreover, we discussed how in some cases such properties may arise from explicit promises made by users. This is the case of problems with properties such as functional dependencies and unique solutions.\nTwo of the perspectives raised by our work concern the new central properties which have emerged from it. We have identified the removability property as an ideal characterisation of the values which can be removed while preserving satisfiability. Unfortunately, negative results (coNP-completeness of the detection of this property and impossibility of local reasoning) make it impossible to directly use the removability property in practice. This gives an ex-post justification for the extensive use that has been made in the last decades of stronger notions (like inconsistency or substitutability) which imply removability, yet can be\nchecked by tractable means (of course at the price of losing completeness). An interesting problem is thus to determine new cases where removability-checking is tractable.\nAlso, the benefits of fixability have long been known in the boolean case, since this property has been used in the form of the pure literal rule in many SAT solvers. However, no generalisation of this property to CSPs has been considered so far.\nFinally, the proposed framework allows a natural and elegant generalisation to the case of Quantified CSP. In particular, in related work (Bordeaux, Cadoli, & Mancini, 2008) we propose the new notion of outcome as the natural counterpart at the quantified level of the concept of solution of a CSP. With such notion in mind, all the properties studied in this paper can be straightforwardly restated for Quantified CSP, as well as their local relaxations, and new, even more general concepts emerge (the so-called shallow properties, that may have an impact also at the pure existential \u2013CSP\u2013 level). This opens important new horizons, allowing QCSP solvers to perform a smarter reasoning on the input problem, by taking into proper account the quantifiers prefix, that today is usually ignored."}, {"heading": "Acknowledgments", "text": "This paper is an extended and revised version of Bordeaux, Cadoli, and Mancini (2004)."}], "references": [{"title": "Exploiting fixable, substitutable and determined values in constraint satisfaction problems", "author": ["L. Bordeaux", "M. Cadoli", "T. Mancini"], "venue": "Proceedings of the Eleventh International Conference on Logic for Programming and Automated Reasoning (LPAR 2004),", "citeRegEx": "Bordeaux et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Bordeaux et al\\.", "year": 2004}, {"title": "Generalizing consistency and other constraint properties to quantified constraints", "author": ["L. Bordeaux", "M. Cadoli", "T. Mancini"], "venue": "ACM Transactions on Computational Logic. To appear", "citeRegEx": "Bordeaux et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bordeaux et al\\.", "year": 2008}, {"title": "Using a theorem prover for reasoning on constraint problems", "author": ["M. Cadoli", "T. Mancini"], "venue": "Applied Artificial Intelligence,", "citeRegEx": "Cadoli and Mancini,? \\Q2007\\E", "shortCiteRegEx": "Cadoli and Mancini", "year": 2007}, {"title": "The complexity of Unique k-SAT: An isolation lemma for k-CNFs", "author": ["C. Calabro", "R. Impagliazzo", "V. Kabanets", "R. Paturi"], "venue": "In Proceedings of the Eighteenth IEEE Conference on Computational Complexity (CCC 2003),", "citeRegEx": "Calabro et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Calabro et al\\.", "year": 2003}, {"title": "On the computation of local interchangeability in Discrete Constraint Satisfaction Problems", "author": ["B.Y. Choueiry", "G. Noubir"], "venue": "In Proceedings of the Fifteenth National Conference on Artificial Intelligence", "citeRegEx": "Choueiry and Noubir,? \\Q1998\\E", "shortCiteRegEx": "Choueiry and Noubir", "year": 1998}, {"title": "A theoretical analysis of reasoning by symmetry in first-order logic (extended abstract)", "author": ["J.M. Crawford"], "venue": "Proceedings of Workshop on Tractable Reasoning, in conjunction with the Tenth National Conference on Artificial Intelligence (AAAI\u201992), San Jose, CA, USA.", "citeRegEx": "Crawford,? 1992", "shortCiteRegEx": "Crawford", "year": 1992}, {"title": "Symmetry-breaking predicates for search problems", "author": ["J.M. Crawford", "M.L. Ginsberg", "E.M. Luks", "A. Roy"], "venue": "In Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning", "citeRegEx": "Crawford et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Crawford et al\\.", "year": 1996}, {"title": "A computing procedure for Quantification Theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam", "year": 1960}, {"title": "Constraint networks (survey)", "author": ["R. Dechter"], "venue": "Encyclopedia of Artificial Intelligence, 2nd edition, pp. 276\u2013285. John Wiley & Sons.", "citeRegEx": "Dechter,? 1992", "shortCiteRegEx": "Dechter", "year": 1992}, {"title": "The complexity of promise problems with applications to public-key cryptography", "author": ["S. Even", "A. Selman", "Y. Yacobi"], "venue": "Information and Control,", "citeRegEx": "Even et al\\.,? \\Q1984\\E", "shortCiteRegEx": "Even et al\\.", "year": 1984}, {"title": "Synthesizing constraint expressions", "author": ["E.C. Freuder"], "venue": "Communications of the ACM, 21 (11), 958\u2013966.", "citeRegEx": "Freuder,? 1978", "shortCiteRegEx": "Freuder", "year": 1978}, {"title": "Eliminating interchangeable values in Constraint Satisfaction Problems", "author": ["E.C. Freuder"], "venue": "Proceedings of the Ninth National Conference on Artificial Intelligence (AAAI\u201991), pp. 227\u2013233, Anaheim, CA, USA. AAAI Press/The MIT Press.", "citeRegEx": "Freuder,? 1991", "shortCiteRegEx": "Freuder", "year": 1991}, {"title": "Symmetry breaking during search in constraint programming", "author": ["I.P. Gent", "B. Smith"], "venue": "In Proceedings of the Fourteenth European Conference on Artificial Intelligence (ECAI", "citeRegEx": "Gent and Smith,? \\Q2000\\E", "shortCiteRegEx": "Gent and Smith", "year": 2000}, {"title": "QCSP-Solve: A solver for Quantified Constraint Satisfaction Problems", "author": ["I. Gent", "P. Nightingale", "K. Stergiou"], "venue": "In Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Gent et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2005}, {"title": "Act, and the rest will follow: Exploiting determinism in planning as satisfiability", "author": ["E. Giunchiglia", "A. Massarotto", "R. Sebastiani"], "venue": "In Proceedings of the Fifteenth National Conference on Artificial Intelligence", "citeRegEx": "Giunchiglia et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 1998}, {"title": "Recognizing frozen variables in constraint satisfaction problems", "author": ["P. Jonsson", "A. Krokhin"], "venue": "Theoretical Computer Science,", "citeRegEx": "Jonsson and Krokhin,? \\Q2004\\E", "shortCiteRegEx": "Jonsson and Krokhin", "year": 2004}, {"title": "Computational complexity of auditing discrete attributes in statistical databases", "author": ["P. Jonsson", "A. Krokhin"], "venue": "Journal of Computer and System Sciences", "citeRegEx": "Jonsson and Krokhin,? \\Q2008\\E", "shortCiteRegEx": "Jonsson and Krokhin", "year": 2008}, {"title": "The graph isomorphism problem: its computational complexity", "author": ["J. K\u00f6bler", "U. Sch\u00f6ning", "J. Tor\u00e1n"], "venue": null, "citeRegEx": "K\u00f6bler et al\\.,? \\Q1993\\E", "shortCiteRegEx": "K\u00f6bler et al\\.", "year": 1993}, {"title": "Interchangeability and dynamic bundling for non-binary finite CSPs", "author": ["A. Lal", "B. Choueiry", "E.C. Freuder"], "venue": "In Proceedings of the Twentieth National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Lal et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lal et al\\.", "year": 2005}, {"title": "Algorithms in number theory", "author": ["A. Lenstra", "H.W. Lenstra"], "venue": "The Handbook of Theoretical Computer Science,", "citeRegEx": "Lenstra and Lenstra,? \\Q1990\\E", "shortCiteRegEx": "Lenstra and Lenstra", "year": 1990}, {"title": "Integrating equivalency reasoning into Davis-Putnam procedure", "author": ["C.M. Li"], "venue": "Proceedings of the Seventeenth National Conference on Artificial Intelligence (AAAI 2000), pp. 291\u2013296, Austin, TX, USA. AAAI Press/The MIT Press.", "citeRegEx": "Li,? 2000", "shortCiteRegEx": "Li", "year": 2000}, {"title": "Consistency in networks of relations", "author": ["A.K. Mackworth"], "venue": "Artificial Intelligence, 8, 99\u2013118.", "citeRegEx": "Mackworth,? 1977", "shortCiteRegEx": "Mackworth", "year": 1977}, {"title": "Detecting and breaking symmetries by reasoning on problem specifications", "author": ["T. Mancini", "M. Cadoli"], "venue": "In Proceedings of the Sixth International Symposium on Abstraction, Reformulation and Approximation (SARA 2005),", "citeRegEx": "Mancini and Cadoli,? \\Q2005\\E", "shortCiteRegEx": "Mancini and Cadoli", "year": 2005}, {"title": "Exploiting functional dependencies in declarative problem specifications", "author": ["T. Mancini", "M. Cadoli"], "venue": "Artificial Intelligence,", "citeRegEx": "Mancini and Cadoli,? \\Q2007\\E", "shortCiteRegEx": "Mancini and Cadoli", "year": 2007}, {"title": "Evaluating ASP and commercial solvers on the CSPLib", "author": ["T. Mancini", "M. Cadoli", "D. Micaletto", "F. Patrizi"], "venue": null, "citeRegEx": "Mancini et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Mancini et al\\.", "year": 2008}, {"title": "Determining computational complexity from characteristic phase transitions", "author": ["R. Monasson", "R. Zecchina", "S. Kirkpatrick", "B. Selman", "L. Troyansky"], "venue": null, "citeRegEx": "Monasson et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Monasson et al\\.", "year": 1999}, {"title": "Networks of constraints: Fundamental properties and applications to picture processing", "author": ["U. Montanari"], "venue": "Information Sciences, 7 (2), 85\u2013132.", "citeRegEx": "Montanari,? 1974", "shortCiteRegEx": "Montanari", "year": 1974}, {"title": "Computational Complexity", "author": ["C.H. Papadimitriou"], "venue": "Addison Wesley Publishing Company, Reading, Massachussetts, Reading, MA.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "Factoring benchmarks for SAT solvers", "author": ["T. Pyh\u00e4l\u00e4"], "venue": "Tech. rep., Helsinki university of technology.", "citeRegEx": "Pyh\u00e4l\u00e4,? 2004", "shortCiteRegEx": "Pyh\u00e4l\u00e4", "year": 2004}, {"title": "Managing don\u2019t cares in Boolean Satisfiability", "author": ["S. Safarpour", "A. Veneris", "R. Drechsler", "J. Lee"], "venue": "In Proceedings of Design Automation and Test Conference in Europe (DATE", "citeRegEx": "Safarpour et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Safarpour et al\\.", "year": 2004}, {"title": "The complexity of satisfiability problems", "author": ["T.J. Schaefer"], "venue": "Proceedings of the Tenth ACM Symposium on Theory of Computing (STOC\u201978), pp. 216\u2013226, San Diego, CA, USA. ACM Press.", "citeRegEx": "Schaefer,? 1978", "shortCiteRegEx": "Schaefer", "year": 1978}, {"title": "Solving non-clausal formulas with DPLL search", "author": ["C. Thiffault", "F. Bacchus", "T. Walsh"], "venue": "In Proceedings of the Tenth International Conference on Principles and Practice of Constraint Programming (CP 2004),", "citeRegEx": "Thiffault et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Thiffault et al\\.", "year": 2004}, {"title": "NP is as easy as detecting unique solutions", "author": ["L.G. Valiant", "V.V. Vijay V. Vazirani"], "venue": "Theoretical Computer Science,", "citeRegEx": "Valiant and Vazirani,? \\Q1986\\E", "shortCiteRegEx": "Valiant and Vazirani", "year": 1986}], "referenceMentions": [{"referenceID": 20, "context": "Journal of Artificial Intelligence Research 32 (2008) 607\u2013629 Submitted 01/08; published 06/08", "startOffset": 27, "endOffset": 54}, {"referenceID": 21, "context": "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general", "startOffset": 38, "endOffset": 72}, {"referenceID": 26, "context": "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general", "startOffset": 38, "endOffset": 72}, {"referenceID": 11, "context": "Good examples are value inconsistency (Mackworth, 1977; Montanari, 1974), substitutability and interchangeability (Freuder, 1991), more general", "startOffset": 114, "endOffset": 129}, {"referenceID": 20, "context": "forms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007).", "startOffset": 125, "endOffset": 159}, {"referenceID": 11, "context": "Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991).", "startOffset": 161, "endOffset": 176}, {"referenceID": 5, "context": "Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, K\u00f6bler, Sch\u00f6ning, & Tor\u00e1n, 1993).", "startOffset": 94, "endOffset": 110}, {"referenceID": 5, "context": "forms of symmetries (Crawford, Ginsberg, Luks, & Roy, 1996; Gent & Smith, 2000), and functional dependencies among variables (Li, 2000; Mancini & Cadoli, 2007). Unfortunately, checking whether such properties hold, is (or is thought to be) often computationally hard. As an example, let us consider interchangeability. Value a is said to be interchangeable with value b for variable x if every solution which assigns a to x remains a solution if x is changed to b, and vice versa (Freuder, 1991). The problem of checking interchangeability is coNP-complete (cf. Proposition 4). Analogously, detecting some other forms of symmetry reduces to the graph automorphism problem (Crawford, 1992) (for which there is no known polynomial time algorithm, even if there is evidence that it is not NP-complete, K\u00f6bler, Sch\u00f6ning, & Tor\u00e1n, 1993). To this end, in order to allow general algorithms to exploit such properties efficiently, different approaches can be followed. First of all, syntactic restrictions on the constraint languages can be enforced, in order to allow the efficient verification of the properties of interest. Alternatively, \u201clocal\u201d versions of such properties can be defined, that can be used to infer their global counterparts, and that can be verified in polynomial time. As an instance of this \u201clocal reasoning\u201d approach, instead of checking whether a value is fully interchangeable for a variable, Freuder (1991) proposes to check whether that value is neighbourhood, or k-interchangeable.", "startOffset": 21, "endOffset": 1427}, {"referenceID": 28, "context": "Example 1 (Factoring, Lenstra & Lenstra, 1990; Pyh\u00e4l\u00e4, 2004).", "startOffset": 10, "endOffset": 60}, {"referenceID": 11, "context": "As for interchangeability, it is well-known (Freuder, 1991) that it can be defined in terms of substitutability: interchangeable(S, x, a, b) \u2261 substitutable(S, x, a, b) \u2227 substitutable(S, x, b, a)", "startOffset": 44, "endOffset": 59}, {"referenceID": 22, "context": "In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP.", "startOffset": 57, "endOffset": 74}, {"referenceID": 18, "context": "In particular, the notion of consistency was proposed by Montanari (1974) and Mackworth (1977), and is one of the best-studied notions in CSP.", "startOffset": 78, "endOffset": 95}, {"referenceID": 10, "context": "Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999).", "startOffset": 59, "endOffset": 74}, {"referenceID": 10, "context": "Substitutability and interchangeability were introduced by Freuder (1991). Implied values, which are also known in the literature as backbones, were seemingly first studied explicitly by Monasson, Zecchina, Kirkpatrick, Selman, and Troyansky (1999). To the best of our knowledge, the notions of removable and fixable values (which, as we show in Section 2.", "startOffset": 59, "endOffset": 249}, {"referenceID": 20, "context": "Solution-preserving transformations are interesting because they allow us to remove values from the search space while preserving the satisfiability of the problem. Moreover, the correspondence between some properties and the existence of particular solution-preserving mappings shows that interesting connections hold among these properties and other concepts, like symmetries. As an example, Mancini and Cadoli (2005) give a logical characterisation of symmetries in problem specifications, which is very similar to, and in fact stronger than, that of Definition 3.", "startOffset": 144, "endOffset": 420}, {"referenceID": 26, "context": "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.", "startOffset": 104, "endOffset": 138}, {"referenceID": 21, "context": "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.", "startOffset": 104, "endOffset": 138}, {"referenceID": 11, "context": "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al.", "startOffset": 157, "endOffset": 172}, {"referenceID": 31, "context": "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al.", "startOffset": 186, "endOffset": 234}, {"referenceID": 29, "context": "In particular, several properties have successfully been exploited for this purpose, like inconsistency (Montanari, 1974; Mackworth, 1977), substitutability (Freuder, 1991), irrelevance (Thiffault et al., 2004; Safarpour et al., 2004), implication (Monasson et al.", "startOffset": 186, "endOffset": 234}, {"referenceID": 25, "context": ", 2004), implication (Monasson et al., 1999), dependence (Mancini & Cadoli, 2007).", "startOffset": 21, "endOffset": 44}, {"referenceID": 20, "context": "guarantees that all solutions (and not only the satisfiability of the problem) are preserved. Hence removability plays exactly the same role of inconsistency in case we do not want to find all solutions of a problem but simply want to find one. In such situations removability is the ideal property to use. As for the other properties, it is worth noting that, although they may appear very strong and unlikely at a first sight, they can still play a precious role when detected dynamically during search. As an example, Thiffault et al. (2004) show that dynamically detecting variables that become irrelevant during search (called don\u2019t care variables in the paper) can greatly speed-up non-CNF SAT solvers, by actually separating problems into independent components.", "startOffset": 58, "endOffset": 545}, {"referenceID": 8, "context": "Such properties hold for propositional logic and for CSPs, in the sense of Dechter (1992). We note that the problem of checking whether properties of Definition 2 hold is in coNP, because, for each of them it is possible to find a counter-example by guessing a tuple in S (two, in case of dependency) in non-deterministic polynomial time, and checking, in polynomial time, whether the negation of the subformula between parentheses holds (as for interchangeability, we note that the logical \u201cand\u201d of two properties in coNP is still in coNP).", "startOffset": 75, "endOffset": 90}, {"referenceID": 20, "context": ", propositional formulae, the satisfiability problem becomes tractable if the instance is expressed using only Horn clauses, only dual Horn clauses (i.e., clauses with at most one negative literal), only clauses of size at most 2, or only affine constraints (i.e., formulae built using XOR). These are known as the Schaefer\u2019s (1978) classes.", "startOffset": 40, "endOffset": 333}, {"referenceID": 21, "context": "This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf.", "startOffset": 62, "endOffset": 79}, {"referenceID": 11, "context": "This approach has proved extremely successful for consistency (Mackworth, 1977) and interchangeability (Freuder, 1991) (cf.", "startOffset": 103, "endOffset": 118}, {"referenceID": 21, "context": "The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991).", "startOffset": 41, "endOffset": 58}, {"referenceID": 11, "context": "The result is well-known for consistency (Mackworth, 1977), substitutability and interchangeability (Freuder, 1991).", "startOffset": 100, "endOffset": 115}, {"referenceID": 20, "context": "This paper is an extended and revised version of Bordeaux, Cadoli, and Mancini (2004).", "startOffset": 63, "endOffset": 86}], "year": 2008, "abstractText": "Literature on Constraint Satisfaction exhibits the definition of several \u201cstructural\u201d properties that can be possessed by CSPs, like (in)consistency, substitutability or interchangeability. Current tools for constraint solving typically detect such properties efficiently by means of incomplete yet effective algorithms, and use them to reduce the search space and boost search. In this paper, we provide a unifying framework encompassing most of the properties known so far, both in CSP and other fields\u2019 literature, and shed light on the semantical relationships among them. This gives a unified and comprehensive view of the topic, allows new, unknown, properties to emerge, and clarifies the computational complexity of the various detection problems. In particular, among the others, two new concepts, fixability and removability emerge, that come out to be the ideal characterisations of values that may be safely assigned or removed from a variable\u2019s domain, while preserving problem satisfiability. These two notions subsume a large number of known properties, including inconsistency, substitutability and others. Because of the computational intractability of all the property-detection problems, by following the CSP approach we then determine a number of relaxations which provide sufficient conditions for their tractability. In particular, we exploit forms of language restrictions and local reasoning.", "creator": "TeX"}}}