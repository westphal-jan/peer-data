{"id": "1401.3463", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Automated Reasoning in Modal and Description Logics via SAT Encoding: the Case Study of K(m)/ALC-Satisfiability", "abstract": "Over the last two decades, modal and descriptive logic have been applied to numerous areas of computer science, including knowledge representation, formal verification, database theory, distributed computing, and, more recently, semantic web and ontologies. For this reason, the problem of automated thinking in modal and descriptive logic has been studied in depth. In particular, many approaches have been proposed to efficiently manage the satisfaction of the central normal modal logic K (m) and its notation variant, the ALC description logic. Although K (m) / ALC is simple in structure, it is mathematically very difficult to base on it, since its satisfaction is PSPACE-complete.", "histories": [["v1", "Wed, 15 Jan 2014 05:22:19 GMT  (667kb)", "http://arxiv.org/abs/1401.3463v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["roberto sebastiani", "michele vescovi"], "accepted": false, "id": "1401.3463"}, "pdf": {"name": "1401.3463.pdf", "metadata": {"source": "CRF", "title": "Automated Reasoning in Modal and Description Logics via SAT Encoding: the Case Study of Km/ALC-Satisfiability", "authors": ["Roberto Sebastiani", "Michele Vescovi"], "emails": ["roberto.sebastiani@disi.unitn.it", "michele.vescovi@disi.unitn.it"], "sections": [{"heading": null, "text": "In this paper we start exploring the idea of performing automated reasoning tasks in modal and description logics by encoding them into SAT, so that to be handled by stateof-the-art SAT tools; as with most previous approaches, we begin our investigation from the satisfiability in Km. We propose an efficient encoding, and we test it on an extensive set of benchmarks, comparing the approach with the main state-of-the-art tools available. Although the encoding is necessarily worst-case exponential, from our experiments we notice that, in practice, this approach can handle most or all the problems which are at the reach of the other approaches, with performances which are comparable with, or even better than, those of the current state-of-the-art tools."}, {"heading": "1. Motivations and Goals", "text": "In the last two decades, modal and description logics have provided an essential framework for many applications in numerous areas of computer science, including artificial intelligence, formal verification, database theory, distributed computing and, more recently, semantic web and ontologies. For this reason, the problem of automated reasoning in modal and description logics has been thoroughly investigated (e.g., Fitting, 1983; Ladner, 1977; Baader & Hollunder, 1991; Halpern & Moses, 1992; Baader, Franconi, Hollunder, Nebel, & Profitlich, 1994; Massacci, 2000). In particular, the research in modal and description logics has followed two parallel routes until the seminal work of Schild (1991), which proved that the core modal logic Km and the core description logic ALC are one a notational variant of the other. Since then, analogous results have been produced for a bunch of other logics, so that, nowadays the two research lines have mostly merged into one research flow.\nMany approaches have been proposed for efficiently reasoning in modal and description logics, starting from the problem of checking the satisfiability in the core normal modal logic Km and in its notational variant, the description logic ALC (hereafter simply \u201cKm\u201d). We classify them as follows.\nc\u00a92009 AI Access Foundation. All rights reserved.\n\u2022 The \u201cclassic\u201d tableau-based approach (Fitting, 1983; Baader & Hollunder, 1991; Massacci, 2000) is based on the construction of propositional tableau branches, which are recursively expanded on demand by generating successor nodes in a candidate Kripke model. Kris (Baader & Hollunder, 1991; Baader et al., 1994), Crack (Franconi, 1998), LWB (Balsiger, Heuerding, & Schwendimann, 1998) were among the main representative tools of this approach.\n\u2022 The DPLL-based approach (Giunchiglia & Sebastiani, 1996, 2000) differs from the previous one mostly in the fact that a Davis-Putnam-Logemann-Loveland (DPLL) procedure, which treats the modal subformulas as propositions, is used instead of the classic propositional tableaux procedure at each nesting level of the modal operators. KSAT (Giunchiglia & Sebastiani, 1996), ESAT (Giunchiglia, Giunchiglia, & Tacchella, 2002) and *SAT (Tacchella, 1999), are the representative tools of this approach.\nThese two approaches merged into the \u201cmodern\u201d tableaux-based approach, which has been extended to work with more expressive description logics and to provide more sophisticate reasoning functions. Among the tools employing this approach, we recall FaCT/FaCT++ and DLP (Horrocks & Patel-Schneider, 1999), and Racer (Haarslev & Moeller, 2001). 1\n\u2022 In the translational approach (Hustadt & Schmidt, 1999; Areces, Gennari, Heguiabehere, & de Rijke, 2000) the modal formula is encoded into first-order logic (FOL), and the encoded formula can be decided efficiently by a FOL theorem prover (Areces et al., 2000). Mspass (Hustadt, Schmidt, & Weidenbach, 1999) is the most representative tool of this approach.\n\u2022 The CSP-based approach (Brand, Gennari, & de Rijke, 2003) differs from the tableauxbased and DPLL-based ones mostly in the fact that a CSP (Constraint Satisfaction Problem) engine is used instead of tableaux/DPLL. KCSP is the only representative tool of this approach.\n\u2022 In the Inverse-method approach (Voronkov, 1999, 2001), a search procedure is based on the \u201cinverted\u201d version of a sequent calculus (which can be seen as a modalized version of propositional resolution). K K(Voronkov, 1999) is the only representative tool of this approach.\n\u2022 In the Automata-theoretic approach, (a symbolic representation based on BDDs \u2013 Binary Decision Diagrams \u2013 of) a tree automaton accepting all the tree models of the input formula is implicitly built and checked for emptiness (Pan, Sattler, & Vardi, 2002; Pan & Vardi, 2003). KBDD (Pan & Vardi, 2003) is the only representative tool of this approach.\n1. Notice that there is not an universal agreement on the terminology \u201ctableaux-based\u201d and \u201cDPLL-based\u201d. E.g., tools like FaCT, DLP, and Racer are most often called \u201ctableau-based\u201d, although they use a DPLL-like algorithm instead of propositional tableaux for handling the propositional component of reasoning (Horrocks, 1998; Patel-Schneider, 1998; Horrocks & Patel-Schneider, 1999; Haarslev & Moeller, 2001).\n\u2022 Pan and Vardi (2003) presented also an encoding of K-satisfiability into QBF-satisfiability (which is PSpace-complete too), combined with the use of a state-of-the-art QBF (Quantified Boolean Formula) solver. We call this approach QBF-encoding approach.\nTo the best of our knowledge, the last four approaches so far are restricted to the satisfiability in Km only, whilst the translational approach has been applied to numerous modal and description logics (e.g. traditional modal logics like Tm and S4m, and dynamic modal logics) and to the relational calculus.\nA significant amount of benchmarks formulas have been produced for testing the effectiveness of the different techniques (Halpern & Moses, 1992; Giunchiglia, Roveri, & Sebastiani, 1996; Heuerding & Schwendimann, 1996; Horrocks, Patel-Schneider, & Sebastiani, 2000; Massacci, 1999; Patel-Schneider & Sebastiani, 2001, 2003).\nIn the last two decades we have also witnessed an impressive advance in the efficiency of propositional satisfiability techniques (SAT), which has brought large and previouslyintractable problems at the reach of state-of-the-art SAT solvers. Most of the success of SAT technologies is motivated by the impressive efficiency reached by current implementations of the DPLL procedure, (Davis & Putnam, 1960; Davis, Longemann, & Loveland, 1962), in its most-modern variants (Silva & Sakallah, 1996; Moskewicz, Madigan, Zhao, Zhang, & Malik, 2001; Ee\u0301n & So\u0308rensson, 2004). Current implementations can handle formulas in the order of 107 variables and clauses.\nAs a consequence, many hard real-world problems have been successfully solved by encoding into SAT (including, e.g., circuit verification and synthesis, scheduling, planning, model checking, automatic test pattern generation , cryptanalysis, gene mapping). Effective encodings into SAT have been proposed also for the satisfiability problems in quantifier-free FOL theories which are of interest for formal verification (Strichman, Seshia, & Bryant, 2002; Seshia, Lahiri, & Bryant, 2003; Strichman, 2002). Notably, successful SAT encodings include also PSpace-complete problems, like planning (Kautz, McAllester, & Selman, 1996) and model checking (Biere, Cimatti, Clarke, & Zhu, 1999).\nIn this paper we start exploring the idea of performing automated reasoning tasks in modal and description logics by encoding them into SAT, so that to be handled by state-ofthe-art SAT tools; as with most previous approaches, we begin our investigation from the satisfiability in Km.\nIn theory, the task may look hopeless because of worst-case complexity issues: in fact, with few exceptions, the satisfiability problem in most modal and description logics is not in NP, typically being PSpace-complete or even harder \u2014PSpace-complete for Km (Ladner, 1977; Halpern & Moses, 1992)\u2014 so that the encoding is in worst-case non polynomial. 2\nIn practice, however, a few considerations allow for not discarding that this approach may be competitive with the state-of-the-art approaches. First, the non-polynomial bounds above are worst-case bounds, and formulas may have different behaviors from that of the pathological formulas which can be found in textbooks. (E.g., notice that the exponentiality is based on the hypothesis of unboundedness of some parameter like the modal depth; Halpern & Moses, 1992; Halpern, 1995.) Second, some tricks in the encoding may allow for reducing the size of the encoded formula significantly. Third, as the amount of RAM\n2. We implicitly make the assumption NP 6= PSpace.\nmemory in current computers is in the order of the GBytes and current SAT solvers can successfully handle huge formulas, the encoding of many modal formulas (at least of those which are not too hard to solve also for the competitors) may be at the reach of a SAT solver. Finally, even for PSpace-complete logics like Km, also other state-of-the-art approaches are not guaranteed to use polynomial memory.\nIn this paper we show that, at least for the satisfiability Km, by exploiting some smart optimizations in the encoding the SAT-encoding approach becomes competitive in practice with previous approaches. To this extent, the contributions of this paper are manyfold.\n\u2022 We propose a basic encoding of Km formulas into purely-propositional ones, and prove that the encoding is satisfiability-preserving.\n\u2022 We describe some optimizations of the encoding, both in form of preprocessing and of on-the-fly simplification. These techniques allow for significant (and in some cases dramatic) reductions in the size of the resulting Boolean formulas, and in performances of the SAT solver thereafter.\n\u2022 We perform a very extensive empirical comparison against the main state-of-the-art tools available. We show that, despite the NP-vs.-PSpace issue, this approach can handle most or all the problems which are at the reach of the other approaches, with performances which are comparable with, and sometimes even better than, those of the current state-of-the-art tools. In our perspective, this is the most surprising contribution of the paper.\n\u2022 As a byproduct of our work, we obtain an empirical evaluation of current tools for Kmsatisfiability available, which is very extensive in terms of both amount and variety of benchmarks and of number and representativeness of the tools evaluated. We are not aware of any other such evaluation in the recent literature.\nWe also stress the fact that with our approach the encoder can be interfaced with every SAT solver in a plug-and-play manner, so that to benefit for free of every improvement in the technology of SAT solvers which has been or will be made available.\nContent. The paper is structured as follows. In Section 2 we provide the necessary background notions on modal logics and SAT. In Section 3 we describe the basic encoding from Km to SAT. In Section 4 we describe and discuss the main optimizations, and provide many examples. In Section 5 we present the empirical evaluation, and discuss the results. In Section 6 we present some related work and current research trends. In Section 7 we conclude, and describe some possible future evolutions.\nA six-page preliminary version of this paper, containing some of the basic ideas presented here, was presented at SAT\u201906 conference (Sebastiani & Vescovi, 2006). For the readers\u2019 convenience, an online appendix is provided, containing all plots of Section 5 in full size. Moreover, in order to make the results reproducible, the encoder, the benchmarks and the random generators with the seeds used are also available in the online appendix."}, {"heading": "2. Background", "text": "In this section we provide the necessary background on the modal logic Km (Section 2.1) and on SAT and the DPLL procedure (Section 2.2)."}, {"heading": "2.1 The Modal Logic Km", "text": "We recall some basic definitions and properties of Km. Given a non-empty set of primitive propositions A = {A1, A2, . . .}, a set of m modal operators B = {21, . . . , 2m}, and the constants \u201cTrue\u201d and \u201cFalse\u201d (that we denote respectively with \u201c>\u201d and \u201c\u22a5\u201d) the language of Km is the least set of formulas containing A, closed under the set of propositional connectives {\u00ac,\u2227,\u2228,\u2192,\u2194} and the set of modal operators in B\u222a{31, . . . , 3m}. Notationally, we use the Greek letters \u03b1, \u03b2, \u03d5, \u03c8, \u03bd, \u03c0 to denote formulas in the language of Km (Km-formulas hereafter). Notice that we can consider {\u00ac,\u2227} together with B as the group of the primitive connectives/operators, defining the remaining in the standard way, that is: \u201c3r\u03d5\u201d for \u201c\u00ac2r\u00ac\u03d5\u201d, \u201c\u03d51 \u2228 \u03d52\u201d for \u201c\u00ac(\u00ac\u03d51 \u2227 \u00ac\u03d52)\u201d, \u201c\u03d51 \u2192 \u03d52\u201d for \u201c\u00ac(\u03d51 \u2227 \u00ac\u03d52)\u201d, \u201c\u03d51 \u2194 \u03d52\u201d for \u201c\u00ac(\u03d51 \u2227 \u00ac\u03d52) \u2227 \u00ac(\u03d52 \u2227 \u00ac\u03d51)\u201d. (Hereafter formulas like \u00ac\u00ac\u03c8 are implicitly assumed to be simplified into \u03c8, so that, if \u03c8 is \u00ac\u03c6, then by \u201c\u00ac\u03c8\u201d we mean \u201c\u03c6\u201d.) Notationally, we often write \u201c( \u2227 i li) \u2192 \u2228 j lj\u201d for the clause \u201c \u2228 j \u00acli \u2228 \u2228 j lj\u201d, and \u201c( \u2227 i li) \u2192 ( \u2227 j lj)\u201d for the\nconjunction of clauses \u201c \u2227 j( \u2228\ni \u00acli \u2228 lj)\u201d. Further, we often write 2r or 3r meaning one specific/generic modal operator, where it is assumed that r = 1, . . . ,m; and we denote by 2ir the nested application of the 2r operator i times: 2 0 r\u03c8 := \u03c8 and 2 i+1 r \u03c8 := 2r2 i r\u03c8. We call depth of \u03d5, written depth(\u03d5), the maximum number of nested modal operators in \u03d5. We call a propositional atom every primitive proposition in A, and a propositional literal every propositional atom (positive literal) or its negation (negative literal). We call a modal atom every formula which is either in the form 2r\u03d5 or in the form 3r\u03d5.\nIn order to make our presentation more uniform, and to avoid considering the polarity of subformulas, we adopt the traditional representation of Km-formulas (introduced, as far as we know, by Fitting, 1983 and widely used in literature, e.g. Fitting, 1983; Massacci, 2000; Donini & Massacci, 2000) from the following table:\n\u03b1 \u03b11 \u03b12 \u03b2 \u03b21 \u03b22 \u03c0 r \u03c0r0 \u03bd r \u03bdr0 (\u03d51 \u2227 \u03d52) \u03d51 \u03d52 (\u03d51 \u2228 \u03d52) \u03d51 \u03d52 3r\u03d51 \u03d51 2r\u03d51 \u03d51 \u00ac(\u03d51 \u2228 \u03d52) \u00ac\u03d51 \u00ac\u03d52 \u00ac(\u03d51 \u2227 \u03d52) \u00ac\u03d51 \u00ac\u03d52 \u00ac2r\u03d51 \u00ac\u03d51 \u00ac3r\u03d51 \u00ac\u03d51 \u00ac(\u03d51 \u2192 \u03d52) \u03d51 \u00ac\u03d52 (\u03d51 \u2192 \u03d52) \u00ac\u03d51 \u03d52\nin which non-literal Km-formulas are grouped into four categories: \u03b1\u2019s (conjunctive), \u03b2\u2019s (disjunctive), \u03c0\u2019s (existential), \u03bd\u2019s (universal). Importantly, all such formulas occur in the main formula with positive polarity only. This allows for disregarding the issue of polarity of subformulas.\nThe semantic of modal logics is given by means of Kripke structures. A Kripke structure for Km is a tuple M = \u3008U ,L,R1, . . . ,Rm\u3009, where U is a set of states, L is a function L : A\u00d7U 7\u2212\u2192 {True, False}, and each Rr is a binary relation on the states of U . With an abuse of notation we write \u201cu \u2208M\u201d instead of \u201cu \u2208 U\u201d. We call a situation any pair M, u, M being a Kripke structure and u \u2208 M. The binary relation |= between a modal formula\n\u03d5 and a situation M, u is defined as follows:\nM, u |= >; M, u 6|= \u22a5; M, u |= Ai, Ai \u2208 A \u21d0\u21d2 L(Ai, u) = True; M, u |= \u00acAi, Ai \u2208 A \u21d0\u21d2 L(Ai, u) = False; M, u |= \u03b1 \u21d0\u21d2 M, u |= \u03b11 and M, u |= \u03b12; M, u |= \u03b2 \u21d0\u21d2 M, u |= \u03b21 or M, u |= \u03b22; M, u |= \u03c0r \u21d0\u21d2 M, w |= \u03c0r0 for some w \u2208 U s.t. Rr(u,w) holds in M; M, u |= \u03bdr \u21d0\u21d2 M, w |= \u03bdr0 for every w \u2208 U s.t. Rr(u,w) holds in M.\n\u201cM, u |= \u03d5\u201d should be read as \u201cM, u satisfy \u03d5 in Km\u201d (alternatively, \u201cM, u Km-satisfies \u03d5\u201d). We say that a Km-formula \u03d5 is satisfiable in Km (Km-satisfiable henceforth) if and only if there exist M and u \u2208M s.t. M, u |= \u03d5. (When this causes no ambiguity, we sometimes drop the prefix \u201cKm-\u201d.) We say that w is a successor of u through Rr iff Rr(u,w) holds in M.\nThe problem of determining the Km-satisfiability of a Km-formula \u03d5 is decidable and PSPACE-complete (Ladner, 1977; Halpern & Moses, 1992), even restricting the language to a single Boolean atom (i.e., A = {A1}; Halpern, 1995); if we impose a bound on the modal depth of the Km-formulas, the problem reduces to NP-complete (Halpern, 1995). For a more detailed description on Km\u2014 including, e.g., axiomatic characterization, decidability and complexity results \u2014 we refer the reader to the works of Halpern and Moses (1992), and Halpern (1995).\nA Km-formula is said to be in Negative Normal Form (NNF) if it is written in terms of the symbols 2r, 3r, \u2227, \u2228 and propositional literals Ai, \u00acAi (i.e., if all negations occur only before propositional atoms in A). Every Km-formula \u03d5 can be converted into an equivalent one NNF (\u03d5) by recursively applying the rewriting rules: \u00ac2r\u03d5=\u21d23r\u00ac\u03d5, \u00ac3r\u03d5=\u21d22r\u00ac\u03d5, \u00ac(\u03d51 \u2227 \u03d52)=\u21d2(\u00ac\u03d51 \u2228 \u00ac\u03d52), \u00ac(\u03d51 \u2228 \u03d52)=\u21d2(\u00ac\u03d51 \u2227 \u00ac\u03d52), \u00ac\u00ac\u03d5=\u21d2\u03d5.\nA Km-formula is said to be in Box Normal Form (BNF) (Pan et al., 2002; Pan & Vardi, 2003) if it is written in terms of the symbols 2r, \u00ac2r, \u2227, \u2228, and propositional literals Ai, \u00acAi (i.e., if no diamonds are there, and all negations occur only before boxes or before propositional atoms in A). Every Km-formula \u03d5 can be converted into an equivalent one BNF (\u03d5) by recursively applying the rewriting rules: 3r\u03d5=\u21d2\u00ac2r\u00ac\u03d5, \u00ac(\u03d51 \u2227\u03d52)=\u21d2(\u00ac\u03d51 \u2228 \u00ac\u03d52), \u00ac(\u03d51 \u2228 \u03d52)=\u21d2(\u00ac\u03d51 \u2227 \u00ac\u03d52), \u00ac\u00ac\u03d5=\u21d2\u03d5."}, {"heading": "2.2 Propositional Satisfiability with the DPLL Algorithm", "text": "Most state-of-the-art SAT procedures are evolutions of the DPLL procedure (Davis & Putnam, 1960; Davis et al., 1962). A high-level schema of a modern DPLL engine, adapted from the one presented by Zhang and Malik (2002), is reported in Figure 1. The Boolean formula \u03d5 is in CNF (Conjunctive Normal Form); the assignment \u00b5 is initially empty, and it is updated in a stack-based manner.\nIn the main loop, decide next branch(\u03d5, \u00b5) chooses an unassigned literal l from \u03d5 according to some heuristic criterion, and adds it to \u00b5. (This operation is called decision, l is called decision literal and the number of decision literals in \u00b5 after this operation is called the decision level of l.) In the inner loop, deduce(\u03d5, \u00b5) iteratively deduces literals l"}, {"heading": "9. blevel = analyze conflict(\u03d5, \u00b5);", "text": "deriving from the current assignment and updates \u03d5 and \u00b5 accordingly; this step is repeated until either \u00b5 satisfies \u03d5, or \u00b5 falsifies \u03d5, or no more literals can be deduced, returning sat, conflict and unknown respectively. (The iterative application of Boolean deduction steps in deduce is also called Boolean Constraint Propagation, BCP.) In the first case, DPLL returns sat. If the second case, analyze conflict(\u03d5, \u00b5) detects the subset \u03b7 of \u00b5 which caused the conflict (conflict set) and the decision level blevel to backtrack. If blevel == 0, then a conflict exists even without branching, so that DPLL returns unsat. Otherwise, backtrack(blevel, \u03d5, \u00b5) adds the clause \u00ac\u03b7 to \u03d5 (learning) and backtracks up to blevel (backjumping), updating \u03d5 and \u00b5 accordingly. In the third case, DPLL exits the inner loop, looking for the next decision.\nNotably, modern DPLL implementations implement techniques, like the two-watchedliteral scheme, which allow for extremely efficient handling of BCP (Moskewicz et al., 2001; Zhang & Malik, 2002). Old versions of DPLL used to implement also the Pure-Literal Rule (PLR) (Davis et al., 1962): when one proposition occurs only positively (resp. negatively) in the formula, it can be safely assigned to true (resp. false). Modern DPLL implementations, however, often do not implement it anymore due to its computational cost. For a much deeper description of modern DPLL-based SAT solvers, we refer the reader to the literature (e.g., Zhang & Malik, 2002)."}, {"heading": "3. The Basic Encoding", "text": "We borrow some notation from the Single Step Tableau (SST) framework (Massacci, 2000; Donini & Massacci, 2000). We represent uniquely states in M as labels \u03c3, represented as non empty sequences of integers 1.nr11 .n r2 2 . ... .n rk k , s.t. the label 1 represents the root state, and \u03c3.nr represents the n-th Rr-successor of \u03c3 (where r \u2208 {1, . . . , m}). With a little abuse of notation, hereafter we may say \u201ca state \u03c3\u201d meaning \u201ca state labeled by \u03c3\u201d. We call a labeled formula a pair \u3008\u03c3, \u03c8\u3009, such that \u03c3 is a state label and \u03c8 is a Km-formula, and we\ncall labeled subformulas of a labeled formula \u3008\u03c3, \u03c8\u3009 all the labeled formulas \u3008\u03c3, \u03c6\u3009 such that \u03c6 is a subformula of \u03c8.\nLet A\u3008 , \u3009 be an injective function which maps a labeled formula \u3008\u03c3, \u03c8\u3009, s.t. \u03c8 is not in the form \u00ac\u03c6, into a Boolean variable A\u3008\u03c3, \u03c8\u3009. We conventionally assume that A\u3008\u03c3, >\u3009 is > and A\u3008\u03c3, \u22a5\u3009 is \u22a5. Let L\u3008\u03c3, \u03c8\u3009 denote \u00acA\u3008\u03c3, \u03c6\u3009 if \u03c8 is in the form \u00ac\u03c6, A\u3008\u03c3, \u03c8\u3009 otherwise. Given a Km-formula \u03d5, the encoder Km2SAT builds a Boolean CNF formula as follows: 3\nKm2SAT (\u03d5) def= A\u30081, \u03d5\u3009 \u2227Def(1, \u03d5) (1)\nDef(\u03c3, >) def= > (2) Def(\u03c3, \u22a5) def= > (3) Def(\u03c3, Ai)\ndef= > (4) Def(\u03c3, \u00acAi) def= > (5)\nDef(\u03c3, \u03b1) def= (L\u3008\u03c3, \u03b1\u3009 \u2192 (L\u3008\u03c3, \u03b11\u3009 \u2227 L\u3008\u03c3, \u03b12\u3009)) \u2227Def(\u03c3, \u03b11) \u2227Def(\u03c3, \u03b12) (6) Def(\u03c3, \u03b2) def= (L\u3008\u03c3, \u03b2\u3009 \u2192 (L\u3008\u03c3, \u03b21\u3009 \u2228 L\u3008\u03c3, \u03b22\u3009)) \u2227Def(\u03c3, \u03b21) \u2227Def(\u03c3, \u03b22) (7) Def(\u03c3, \u03c0r,j) def= (L\u3008\u03c3, \u03c0r,j\u3009 \u2192 L\u3008\u03c3.j, \u03c0r,j0 \u3009) \u2227Def(\u03c3.j, \u03c0 r,j 0 ) (8)\nDef(\u03c3, \u03bdr) def= \u2227\nfor every \u3008\u03c3,\u03c0r,i\u3009\n( ((L\u3008\u03c3, \u03bdr\u3009 \u2227 L\u3008\u03c3, \u03c0r,i\u3009) \u2192 L\u3008\u03c3.i, \u03bdr0 \u3009) \u2227 Def(\u03c3.i, \u03bdr0) ) . (9)\nHere by \u201c\u03c0r,j\u201d we mean that \u03c0r,j is the j-th distinct \u03c0r formula labeled by \u03c3. Notice that (6) and (7) generalize to the case of n-ary \u2227 and \u2228 in the obvious way: if \u03c6 is \u2297ni=1 \u03c6i s.t. \u2297 \u2208 {\u2227,\u2228}, then Def(\u03c3, \u03c6) def= (L\u3008\u03c3, \u03c6\u3009 \u2192 \u2297n i=1 L\u3008\u03c3, \u03c6i\u3009) \u2227 \u2227n\ni=1 Def(\u03c3, \u03c6i). Although conceptually trivial, this fact has an important practical consequence: in order to encode\u2297n\ni=1 \u03c6i one needs adding only one Boolean variable rather than up to n\u22121, see Section 4.2. Notice also that in rule (9) the literals of the type L\u3008\u03c3, \u03c0r,i\u3009 are strictly necessary; in fact, the SAT problem must consider and encode all the possibly occuring states, but it can be the case, e.g., that a \u03c0r,i formula occurring in a disjunction is assigned to false for a particular state label \u03c3 (which, in SAT, corresponds to assign L\u3008\u03c3, \u03c0r,i\u3009 to false). In this situation all the labeled formulas regarding the state label \u03c3.i are useless, in particular those generated by the expansion of the \u03bd formulas interacting with \u03c0r,i. 4\nWe assume that the Km-formulas are represented as DAGs (Direct Acyclic Graphs), so that to avoid the expansion of the same Def(\u03c3, \u03c8) more than once. Then the various Def(\u03c3, \u03c8) are expanded in a breadth-first manner wrt. the tree of labels, that is, all the possible expansions for the same (newly introduced) \u03c3 are completed before starting the expansions for a different state label \u03c3\u2032, and different state label are expanded in the order they are introduced (thus all the expansions for a given state are always handled before those of any deeper state). Moreover, following what done by Massacci (2000), we assume that, for each \u03c3, the Def(\u03c3, \u03c8)\u2019s are expanded in the order: \u03b1/\u03b2, \u03c0, \u03bd. Thus, each Def(\u03c3, \u03bdr) is expanded after the expansion of all Def(\u03c3, \u03c0r,i)\u2019s, so that Def(\u03c3, \u03bdr) will\n3. We say that the formula is in CNF because we represent clauses as implications, according to the notation described at the beginning of Section 2. 4. Indeed, (9) is a finite conjunction. In fact the number of \u03c0-subformulas is obviously finite and Km benefits of the finite-tree-model property (see, e.g., Pan et al., 2002; Pan & Vardi, 2003).\ngenerate one clause ((L\u3008\u03c3, \u03bdr\u3009 \u2227L\u3008\u03c3, \u03c0r,i\u3009) \u2192 L\u3008\u03c3.i, \u03bdr0 \u3009) and one novel definition Def(\u03c3.i, \u03bdr0) for each Def(\u03c3, \u03c0r,i) expanded. 5\nIntuitively, it is easy to see that Km2SAT (\u03d5) mimics the construction of an SST tableau expansion (Massacci, 2000; Donini & Massacci, 2000). We have the following fact.\nTheorem 1. A Km-formula \u03d5 is Km-satisfiable if and only if the corresponding Boolean formula Km2SAT (\u03d5) is satisfiable.\nThe complete proof of Theorem 1 can be found in Appendix A. Notice that, due to (9), the number of variables and clauses in Km2SAT (\u03d5) may grow exponentially with depth(\u03d5). This is in accordance to what was stated by Halpern and Moses (1992).\nExample 3.1 (NNF). Let \u03d5nnf be (3A1 \u22283(A2 \u2228A3)) \u2227 2\u00acA1 \u2227 2\u00acA2 \u2227 2\u00acA3. 6 It is easy to see that \u03d5nnf is K1-unsatisfiable: the 3-atoms impose that at least one atom Ai is true in at least one successor of the root state, whilst the 2-atoms impose that all atoms Ai are false in all successor states of the root state. Km2SAT (\u03d5nnf ) is: 7\n1. A\u30081, \u03d5nnf \u3009 (1) 2. \u2227 ( A\u30081, \u03d5nnf \u3009 \u2192 (A\u30081, 3A1\u22283(A2\u2228A3)\u3009 \u2227A\u30081, 2\u00acA1\u3009 \u2227A\u30081, 2\u00acA2\u3009 \u2227A\u30081, 2\u00acA3\u3009) ) (6) 3. \u2227 ( A\u30081, 3A1\u22283(A2\u2228A3)\u3009 \u2192 (A\u30081, 3A1\u3009 \u2228A\u30081, 3(A2\u2228A3)\u3009) ) (7) 4. \u2227 ( A\u30081, 3A1\u3009 \u2192 A\u30081.1, A1\u3009 ) (8) 5. \u2227 ( A\u30081, 3(A2\u2228A3)\u3009 \u2192 A\u30081.2, A2\u2228A3\u3009 ) (8) 6. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227A\u30081, 3A1\u3009) \u2192 \u00acA\u30081.1, A1\u3009 ) (9) 7. \u2227 ( (A\u30081, 2\u00acA2\u3009 \u2227A\u30081, 3A1\u3009) \u2192 \u00acA\u30081.1, A2\u3009 ) (9) 8. \u2227 ( (A\u30081, 2\u00acA3\u3009 \u2227A\u30081, 3A1\u3009) \u2192 \u00acA\u30081.1, A3\u3009 ) (9) 9. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227A\u30081, 3(A2\u2228A3)\u3009) \u2192 \u00acA\u30081.2, A1\u3009 ) (9) 10. \u2227 ( (A\u30081, 2\u00acA2\u3009 \u2227A\u30081, 3(A2\u2228A3)\u3009) \u2192 \u00acA\u30081.2, A2\u3009 ) (9) 11. \u2227 ( (A\u30081, 2\u00acA3\u3009 \u2227A\u30081, 3(A2\u2228A3)\u3009) \u2192 \u00acA\u30081.2, A3\u3009 ) (9) 12. \u2227 ( A\u30081.2, A2\u2228A3\u3009 \u2192 (A\u30081.2, A2\u3009 \u2228A\u30081.2, A3\u3009) ) (7)\nAfter a run of Boolean constraint propagation (BCP), 3. reduces to the implicate disjunction. If the first element A\u30081, 3A1\u3009 is assigned to true, then by BCP we have a conflict on 4. and 6. If it is set to false, then the second element A\u30081, 3(A2\u2228A3)\u3009 is assigned to true, and by BCP we have a conflict on 12. Thus Km2SAT (\u03d5nnf ) is unsatisfiable. 3"}, {"heading": "4. Optimizations", "text": "The basic encoding of Section 3 is rather naive, and can be much improved to many extents, in order to reduce the size of the output propositional formula, or to make it easier to solve by DPLL, or both. We distinguish two main kinds of optimizations:\n5. In practice, even if the definition of Km2SAT is recursive, the Def expansions are performed grouped by states. More precisely, all the Def(\u03c3.n, \u03c8) expansions, for any formula \u03c8 and every defined n, are done together (in the \u03b1/\u03b2, \u03c0, \u03bd order above exposed) and necessarily after that all the Def(\u03c3, \u03d5) expansions have been completed. 6. For K1-formulas we omit the box and diamond indexes, i.e., we write 2, 3 for 21, 31. 7. In all examples we report at the very end of each line, i.e. after each clause, the number of the Km2SAT\nencoding rule applied to generate that clause. We also drop the application of the rules (2), (3), (4) and (5).\nPreprocessing steps, which are applied on the input modal formula before the encoding. Among them, we have Pre-conversion into BNF (Section 4.1), Atom Normalization (Section 4.2), Box Lifting (Section 4.3), and Controlled Box Lifting (Section 4.4).\nOn-the-fly simplification steps, which are applied to the Boolean formula under construction. Among them, we have On-the-fly Boolean Simplification and Truth Propagation Through Boolean Operators (Section 4.5) and Truth Propagation Through Modal Operators (Section 4.6), On-the-fly Pure-Literal Reduction (Section 4.7), and On-the-fly Boolean Constraint Propagation (Section 4.8).\nWe analyze these techniques in detail."}, {"heading": "4.1 Pre-conversion into BNF", "text": "Many systems use to pre-convert the input Km-formulas into NNF (e.g., Baader et al., 1994; Massacci, 2000). In our approach, instead, we pre-convert them into BNF (like, e.g., Giunchiglia & Sebastiani, 1996; Pan et al., 2002). For our approach, the advantage of the latter representation is that, when one 2r\u03c8 occurs both positively and negatively (like, e.g., in (2r\u03c8 \u2228 ...) \u2227 (\u00ac2r\u03c8 \u2228 ...) \u2227 ...), then both occurrences of 2r\u03c8 are labeled by the same Boolean atom A\u3008\u03c3, 2r\u03c8\u3009, and hence they are always assigned the same truth value by DPLL. With NNF, instead, the negative occurrence \u00ac2r\u03c8 is rewritten into 3r(nnf(\u00ac\u03c8)), so that two distinct Boolean atoms A\u3008\u03c3, 2r(nnf(\u03c8))\u3009 and A\u3008\u03c3, 3r(nnf(\u00ac\u03c8))\u3009 are generated; DPLL can assign them the same truth value, creating a hidden conflict which may require some extra Boolean search to reveal. 8\nExample 4.1 (BNF). We consider the BNF variant of the \u03d5nnf formula of Example 3.1, \u03d5bnf = (\u00ac2\u00acA1 \u2228 \u00ac2(\u00acA2 \u2227 \u00acA3)) \u2227 2\u00acA1 \u2227 2\u00acA2 \u2227 2\u00acA3. As before, it is easy to see that \u03d5bnf is K1-unsatisfiable. Km2SAT (\u03d5bnf ) is: 9\n1. A\u30081, \u03d5bnf \u3009 (1) 2. \u2227 ( A\u30081, \u03d5bnf \u3009 \u2192 (A\u30081, (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3))\u3009 \u2227A\u30081, 2\u00acA1\u3009 \u2227A\u30081, 2\u00acA2\u3009 \u2227A\u30081, 2\u00acA3\u3009)) (6) 3. \u2227 ( A\u30081, (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3))\u3009 \u2192 (\u00acA\u30081, 2\u00acA1\u3009 \u2228 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) ) (7) 4. \u2227 ( \u00acA\u30081, 2\u00acA1\u3009 \u2192 A\u30081.1, A1\u3009 ) (8) 5. \u2227 ( \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 \u2192 \u00acA\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 ) (8) 6. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227 \u00acA\u30081, 2\u00acA1\u3009) \u2192 \u00acA\u30081.1, A1\u3009 ) (9) 7. \u2227 ( (A\u30081, 2\u00acA2\u3009 \u2227 \u00acA\u30081, 2\u00acA1\u3009) \u2192 \u00acA\u30081.1, A2\u3009 ) (9) 8. \u2227 ( (A\u30081, 2\u00acA3\u3009 \u2227 \u00acA\u30081, 2\u00acA1\u3009) \u2192 \u00acA\u30081.1, A3\u3009 ) (9) 9. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) \u2192 \u00acA\u30081.2, A1\u3009 ) (9) 10. \u2227 ( (A\u30081, 2\u00acA2\u3009 \u2227 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) \u2192 \u00acA\u30081.2, A2\u3009 ) (9) 11. \u2227 ( (A\u30081, 2\u00acA3\u3009 \u2227 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) \u2192 \u00acA\u30081.2, A3\u3009 ) (9) 12. \u2227 ( \u00acA\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 \u2192 (A\u30081.2, A2\u3009 \u2228A\u30081.2, A3\u3009) ) (7) Unlike with the NNF formula \u03d5nnf in Example 3.1, Km2SAT (\u03d5bnf ) is found unsatisfiable directly by BCP. In fact, the unit-propagation of A\u30081, 2\u00acA1\u3009 from 2. causes \u00acA\u30081, 2\u00acA1\u3009 in 8. Notice that this consideration holds for every representation involving both boxes and diamonds; we\nrefer to NNF simply because it is the most popular of these representations. 9. Notice that the valid clause 6. can be dropped. See the explanation in Section 4.5.\n3. to be false, so that one of the two (unsatisfiable) branches induced by the disjunction is cut a priori. With \u03d5nnf , Km2SAT does not recognize 2\u00acA1 and 3A1 to be one the negation of the other, so that two distinct atoms A\u30081, 2\u00acA1\u3009 and A\u30081, 3A1\u3009 are generated. Hence A\u30081, 2\u00acA1\u3009 and A\u30081, 3A1\u3009 cannot be recognized by DPLL to be one the negation of the other, s.t. DPLL may need exploring one Boolean branch more. 3\nIn the following we will assume the formulas are in BNF (although most of the optimizations which follow work also for other representations)."}, {"heading": "4.2 Normalization of Modal Atoms", "text": "One potential source of inefficiency for DPLL-based procedures is the occurrence in the input formula of semantically-equivalent though syntactically-different modal atoms \u03c8\u2032 and \u03c8\u2032\u2032 (e.g., 21(A1 \u2228 A2) and 21(A2 \u2228 A1)), which are not recognized as such by Km2SAT . This causes the introduction of duplicated Boolean atoms A\u3008\u03c3, \u03c8\u2032\u3009 and A\u3008\u03c3, \u03c8\u2032\u2032\u3009 and \u2014much worse\u2014 of duplicated subformulas Def(\u03c3, \u03c8\u2032) and Def(\u03c3, \u03c8\u2032\u2032). This fact can have very negative consequences, in particular when \u03c8\u2032 and \u03c8\u2032\u2032 occur with negative polarity, because this causes the creation of distinct versions of the same successor states, and the duplication of whole parts of the output formula.\nExample 4.2. Consider the Km-formula (\u03c61 \u2228\u00ac21(A2 \u2228A1))\u2227 (\u03c62 \u2228\u00ac21(A1 \u2228A2))\u2227 \u03c63, s.t. \u03c61, \u03c62, \u03c63 are possibly-big Km-formulas. Then Km2SAT creates two distinct atoms A\u30081, \u00ac21(A2\u2228A1)\u3009 and A\u30081, \u00ac21(A1\u2228A2)\u3009 and two distinct formulas Def(1, \u00ac21(A2 \u2228A1)) and Def(1, \u00ac21(A1 \u2228A2)). The latter will cause the creation of two distinct states 1.1 and 1.2. Thus, the recursive expansion of all 21-formulas occurring positively in \u03c61, \u03c62, \u03c63 will be duplicated for these two states. 3\nIn order to cope with this problem, as done by Giunchiglia and Sebastiani (1996), we apply some normalization steps to modal atoms with the intent of rewriting as many as possible syntactically-different but semantically-equivalent modal atoms into syntacticallyidentical ones. This can be achieved by a recursive application of some simple validitypreserving rewriting rules.\nSorting: modal atoms are internally sorted according to some criterion, so that atoms which are identical modulo reordering are rewritten into the same atom (e.g., 2i(\u03d52\u2228 \u03d51) and 2i(\u03d51 \u2228 \u03d52) are both rewritten into 2i(\u03d51 \u2228 \u03d52)).\nFlattening: the associativity of \u2227 and \u2228 is exploited and combinations of \u2227\u2019s or \u2228\u2019s are \u201cflattened\u201d into n-ary \u2227\u2019s or \u2228\u2019s respectively (e.g., 2i(\u03d51 \u2228 (\u03d52 \u2228 \u03d53)) and 2i((\u03d51 \u2228 \u03d52) \u2228 \u03d53) are both rewritten into 2i(\u03d51 \u2228 \u03d52 \u2228 \u03d53)).\nFlattening has also the advantage of reducing the number of novel atoms introduced in the encoding, as a consequence of the fact noticed in Section 3. One possible drawback of this technique is that it can reduce the sharing of subformulas (e.g., with 2i((\u03d51 \u2228 \u03d52) \u2228 \u03d53) and 2i((\u03d51\u2228\u03d52)\u2228\u03d54), the common part is no more shared). However, we have empirically experienced that this drawback is negligible wrt. the advantages of flattening."}, {"heading": "4.3 Box Lifting", "text": "As second preprocessing the Km-formula can also be rewritten by recursively applying the Km-validity-preserving \u201cbox lifting rules\u201d:\n(2r\u03d51 \u22272r\u03d52) =\u21d2 2r(\u03d51 \u2227 \u03d52), (\u00ac2r\u03d51 \u2228 \u00ac2r\u03d52) =\u21d2 \u00ac2r(\u03d51 \u2227 \u03d52). (10)\nThis has the potential benefit of reducing the number of \u03c0r formulas, and hence the number of labels \u03c3.i to take into account in the expansion of the Def(\u03c3, \u03bdr)\u2019s (9). We call lifting this preprocessing.\nExample 4.3 (Box lifting). If we apply the rules (10) to the formula of Example 4.1, then we have \u03d5bnflift = \u00ac2(\u00acA1 \u2227 \u00acA2 \u2227 \u00acA3) \u2227 2(\u00acA1 \u2227 \u00acA2 \u2227 \u00acA3). Consequently, Km2SAT (\u03d5bnflift) is:\n1. A\u30081, \u03d5bnflift\u3009 (1) 2. \u2227 ( A\u30081, \u03d5bnflift\u3009 \u2192 (\u00acA\u30081, 2(\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 \u2227A\u30081, 2(\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009) ) (6) 3. \u2227 ( \u00acA\u30081, 2(\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 \u2192 \u00acA\u30081.1, (\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 ) (8) 4. \u2227 (( A\u30081, 2(\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 \u2227 \u00acA\u30081, 2(\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009) \u2192 A\u30081.1, (\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 ) (9) 5. \u2227 ( \u00acA\u30081.1, (\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 \u2192 (A\u30081.1, A1\u3009 \u2228A\u30081.1, A2\u3009 \u2228A\u30081.1, A3\u3009) ) (7) 6. \u2227 ( A\u30081.1, (\u00acA1\u2227\u00acA2\u2227\u00acA3)\u3009 \u2192 (\u00acA\u30081.1, A1\u3009 \u2227 \u00acA\u30081.1, A2\u3009 \u2227 \u00acA\u30081.1, A3\u3009) ). (6)\nKm2SAT (\u03d5bnflift) is found unsatisfiable directly by BCP on clauses 1. and 2.. Only one successor state (1.1) is considered. Notice that 3., 4., 5. and 6. are redundant, because 1. and 2. alone are unsatisfiable. 10 3"}, {"heading": "4.4 Controlled Box Lifting", "text": "One potential drawback of applying the lifting rules is that, by collapsing the formula (2r\u03d51 \u22272r\u03d52) into 2r(\u03d51 \u2227\u03d52) and (\u00ac2r\u03d51 \u2228\u00ac2r\u03d52) into \u00ac2r(\u03d51 \u2227\u03d52), the possibility of sharing box subformulas in the DAG representation of the input Km-formula is reduced.\nIn order to cope with this problem we provide an alternative policy for applying box lifting, that is, to apply the rules (10) only when neither box subformula occurring in the implicant in (10) has multiple occurrences. We call this policy controlled box lifting.\nExample 4.4 (Controlled Box Lifting). We apply Controlled Box Lifting to the formula of Example 4.1, then we have \u03d5bnfclift = (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3)) \u2227 2\u00acA1\u22272(\u00acA2\u2227\u00acA3) since the rules (10) are applied among all the box subformulas except for 2\u00acA1, which is\n10. In our actual implementation, trivial cases like \u03d5bnflift are found to be unsatisfiable directly during the construction of the DAG representations, so their encoding is never generated.\nshared. It follows that Km2SAT (\u03d5bnfclift) is:\n1. A\u30081, \u03d5bnfclift\u3009 (1) 2. \u2227 ( A\u30081, \u03d5bnfclift\u3009 \u2192 (A\u30081, (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3))\u3009 \u2227A\u30081, 2\u00acA1\u3009 \u2227A\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 ) (6) 3. \u2227 ( A\u30081, (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3))\u3009 \u2192 (\u00acA\u30081, 2\u00acA1\u3009 \u2228 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) ) (7) 4. \u2227 ( \u00acA\u30081, 2\u00acA1\u3009 \u2192 A\u30081.1, A1\u3009 ) (8) 5. \u2227 ( \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 \u2192 \u00acA\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 ) (8) 6. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227 \u00acA\u30081, 2\u00acA1\u3009) \u2192 \u00acA\u30081.1, A1\u3009 ) (9) 7. \u2227 ( (A\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 \u2227 \u00acA\u30081, 2\u00acA1\u3009) \u2192 A\u30081.1, (\u00acA2\u2227\u00acA3)\u3009 ) (9) 8. \u2227 ( (A\u30081, 2\u00acA1\u3009 \u2227 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) \u2192 \u00acA\u30081.2, A1\u3009 ) (9) 9. \u2227 ( (A\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 \u2227 \u00acA\u30081, 2(\u00acA2\u2227\u00acA3)\u3009) \u2192 A\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 ) (9) 10. \u2227 ( A\u30081.1, (\u00acA2\u2227\u00acA3)\u3009 \u2192 (\u00acA\u30081.1, A2\u3009 \u2227 \u00acA\u30081.1, A3\u3009) ) (6) 11. \u2227 ( \u00acA\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 \u2192 (A\u30081.2, A2\u3009 \u2228A\u30081.2, A3\u3009) ) (7) 12. \u2227 ( A\u30081.2, (\u00acA2\u2227\u00acA3)\u3009 \u2192 (\u00acA\u30081.2, A2\u3009 \u2227 \u00acA\u30081.2, A3\u3009) ) (6)\nKm2SAT (\u03d5bnfclift) is found unsatisfiable directly by BCP on clauses 1., 2. and 3.. Notice that the unit propagation of A\u30081, 2\u00acA1\u3009 and A\u30081, 2(\u00acA2\u2227\u00acA3)\u3009 from 2. causes the implicate disjunction in 3. to be false. 3"}, {"heading": "4.5 On-the-fly Boolean Simplification and Truth Propagation", "text": "A first straightforward on-the-fly optimization is that of applying recursively the standard rewriting rules for the Boolean simplification of the formula like, e.g.,\n\u3008\u03c3, \u03d5\u3009 \u2227 \u3008\u03c3, \u03d5\u3009 =\u21d2 \u3008\u03c3, \u03d5\u3009, \u3008\u03c3, \u03d5\u3009 \u2228 \u3008\u03c3, \u03d5\u3009 =\u21d2 \u3008\u03c3, \u03d5\u3009, \u3008\u03c3, \u03d51\u3009 \u2227 \u3008\u03c3, (\u03d51 \u2228 \u03d52)\u3009 =\u21d2 \u3008\u03c3, \u03d51\u3009, \u3008\u03c3, \u03d51\u3009 \u2228 \u3008\u03c3, (\u03d51 \u2227 \u03d52)\u3009 =\u21d2 \u3008\u03c3, \u03d51\u3009, \u3008\u03c3, \u03d5\u3009 \u2227 \u00ac\u3008\u03c3, \u03d5\u3009 =\u21d2 \u3008\u03c3,\u22a5\u3009, \u3008\u03c3, \u03d5\u3009 \u2228 \u00ac\u3008\u03c3, \u03d5\u3009 =\u21d2 \u3008\u03c3,>\u3009, ...,\nand for the propagation of truth/falsehood through Boolean operators like, e.g.,\n\u00ac\u3008\u03c3,\u22a5\u3009 =\u21d2 \u3008\u03c3,>\u3009, \u00ac\u3008\u03c3,>\u3009 =\u21d2 \u3008\u03c3,\u22a5\u3009, \u3008\u03c3, \u03d5\u3009 \u2227 \u3008\u03c3,>\u3009 =\u21d2 \u3008\u03c3, \u03d5\u3009, \u3008\u03c3, \u03d5\u3009 \u2227 \u3008\u03c3,\u22a5\u3009 =\u21d2 \u3008\u03c3,\u22a5\u3009, \u3008\u03c3, \u03d5\u3009 \u2228 \u3008\u03c3,>\u3009 =\u21d2 \u3008\u03c3,>\u3009, \u3008\u03c3, \u03d5\u3009 \u2228 \u3008\u03c3,\u22a5\u3009 =\u21d2 \u3008\u03c3, \u03d5\u3009, ....\nExample 4.5. If we consider the Km-formula \u03d5bnflift = \u00ac2(\u00acA1 \u2227 \u00acA2 \u2227 \u00acA3) \u2227 2(\u00acA1 \u2227 \u00acA2 \u2227 \u00acA3) of Example 4.3 and we apply the Boolean simplification rule \u3008\u03c3, \u03d5\u3009 \u2227 \u00ac\u3008\u03c3, \u03d5\u3009 =\u21d2 \u3008\u03c3,\u22a5\u3009, then \u3008\u03c3, \u03d5bnflift\u3009 is simplified into \u3008\u03c3,\u22a5\u3009. 3\nOne important subcase of on-the-fly Boolean simplification avoids the useless encoding of incompatible \u03c0r and \u03bdr formulas. In BNF, in fact, the same subformula 2r\u03c8 may occur in the same state \u03c3 both positively and negatively (like \u03c0r = \u00ac2r\u03c8 and \u03bdr = 2r\u03c8). If so, Km2SAT labels both those occurrences of 2r\u03c8 with the same Boolean atom A\u3008\u03c3, 2r\u03c8\u3009, and produces recursively two distinct subsets of clauses in the encoding, by applying (8) to \u00ac2r\u03c8 and (9) to 2r\u03c8 respectively. However, the latter step (9) generates a valid clause (A\u3008\u03c3, 2r\u03c8\u3009 \u2227 \u00acA\u3008\u03c3, 2r\u03c8\u3009) \u2192 A\u3008\u03c3.i, \u03c8\u3009, so that we can avoid generating it. Consequently, if\nA\u3008\u03c3.i, \u03c8\u3009 no more occurs in the formula, then Def(\u03c3.i, \u03c8) should not be generated, as there is no more need of defining \u3008\u03c3.i, \u03c8\u3009. 11\nExample 4.6. If we apply this observation in the construction of the formulas of Examples 4.1 and 4.4, we have the following facts:\n\u2022 In the formula Km2SAT (\u03d5bnf ) of Example 4.1, clause 6. is valid and thus it is dropped. \u2022 In the formula Km2SAT (\u03d5bnfclift) of Example 4.4, both valid clauses 6. and 9. are\ndropped, so that 12. is not generated. 3\nHereafter we assume that on-the-fly Boolean simplification is applied also in combination with the techniques described in the next sections."}, {"heading": "4.6 On-the-fly Truth Propagation Through Modal Operators", "text": "Truth and falsehood \u2014which can derive by the application of the techniques in Section 4.5, Section 4.7 and Section 4.8\u2014 may be propagated on-the-fly also though modal operators. First, for every \u03c3, both positive and negative instances of \u3008\u03c3,2r>\u3009 can be safely simplified by applying the rewriting rule \u3008\u03c3,2r>\u3009 =\u21d2 \u3008\u03c3,>\u3009.\nSecond, we notice the following fact. When we have a positive occurrence of \u3008\u03c3,\u00ac2r\u22a5\u3009 for some \u03c3 (we suppose wlog. that we have only that \u03c0r-formula for \u03c3), 12 by definition of (8) and (9) we have\nDef(\u03c3, \u00ac2r\u22a5) = (L\u3008\u03c3, \u00ac2r\u22a5\u3009 \u2192 A\u3008\u03c3.j, >\u3009) \u2227Def(\u03c3.j, >), (11) Def(\u03c3, 2r\u03c8) = ((L\u3008\u03c3, 2r\u03c8\u3009 \u2227 L\u3008\u03c3, \u00ac2r\u22a5\u3009) \u2192 L\u3008\u03c3.j, \u03c8\u3009) \u2227Def(\u03c3.j, \u03c8) (12)\nfor some new label \u03c3.j and for every 2r\u03c8 occurring positively in \u03c3. Def(\u03c3, \u00ac2r\u22a5) reduces to > because both A\u3008\u03c3.j, >\u3009 and Def(\u03c3.j, >) reduce to >. If at least another distinct \u03c0formula \u00ac2r\u03d5 occurs positively in \u03c3, however, there is no need for the \u03c3.j label in (11) and (12) to be a new label, and we can re-use instead the label \u03c3.i introduced in the expansion of Def(\u03c3, \u00ac2r\u03d5), as follows:\nDef(\u03c3, \u00ac2r\u03d5) = (L\u3008\u03c3, \u00ac2r\u03d5\u3009 \u2192 L\u3008\u03c3.i, \u00ac\u03d5\u3009) \u2227Def(\u03c3.i, \u00ac\u03d5). (13)\nThus (11) is dropped and, for every \u3008\u03c3,2r\u03c8\u3009 occurring positively, we write:\nDef(\u03c3, 2r\u03c8) = ((L\u3008\u03c3, 2r\u03c8\u3009 \u2227 L\u3008\u03c3, \u00ac2r\u22a5\u3009) \u2192 L\u3008\u03c3.i, \u03c8\u3009) \u2227Def(\u03c3.i, \u03c8) (14)\ninstead of (12). (Notice the label \u03c3.i introduced in (13) rather than the label \u03c3.j of (11).) This is motivated by the fact that Def(\u03c3, \u00ac2r\u22a5) forces the existence of at least one successor of \u03c3 but imposes no constraints on which formulas should hold there, so that we can use some other already-defined successor state, if any. This fact has the important benefit of eliminating useless successor states from the encoding.\n11. Here the \u201cif\u201d is due to the fact that it may be the case that A\u3008\u03c3.i, \u03c8\u3009 is generated anyway from the expansion of some other subformula, like, e.g., 2r(\u03c8 \u2228 \u03c6). If this is the case, Def(\u03c3.i, \u03c8) must be generated anyway. 12. E.g., \u00ac2r\u22a5 may result from applying the steps of Section 4.1 and of Section 4.5 to \u00ac2r(2rA1\u22273r\u00acA1).\nExample 4.7. Let \u03d5 be the BNF K-formula:\n(\u00acA1 \u2228 \u00ac2A2) \u2227 (A1 \u2228 \u00ac2\u22a5) \u2227 (\u00acA1 \u2228A3) \u2227 (\u00acA1 \u2228 \u00acA3) \u2227 (A1 \u22282\u00acA4) \u22272A4. \u03d5 is K-inconsistent, because the only possible assignment is {\u00acA1,\u00ac2\u22a5, 2\u00acA4,2A4}, which is K-inconsistent. Km2SAT (\u03d5) is encoded as follows:\n1. A\u30081, \u03d5\u3009 (1) 2. \u2227 (A\u30081, \u03d5\u3009 \u2192 (A\u30081, (\u00acA1\u2228\u00ac2A2)\u3009 \u2227A\u30081, (A1\u2228\u00ac2\u22a5)\u3009 \u2227A\u30081, (\u00acA1\u2228A3)\u3009\u2227 A\u30081, (A1\u22282\u00acA4)\u3009 \u2227A\u30081, 2A4\u3009)) (6) 3. \u2227 (A\u30081, (\u00acA1\u2228\u00ac2A2)\u3009 \u2192 (\u00acA\u30081, A1\u3009 \u2228 \u00acA\u30081, 2A2\u3009)) (7) 4. \u2227 (A\u30081, (A1\u2228\u00ac2\u22a5)\u3009 \u2192 (A\u30081, A1\u3009 \u2228 \u00acA\u30081, 2\u22a5\u3009)) (7) 5. \u2227 (A\u30081, (\u00acA1\u2228A3)\u3009 \u2192 (\u00acA\u30081, A1\u3009 \u2228A\u30081, A3\u3009)) (7) 6. \u2227 (A\u30081, (\u00acA1\u2228\u00acA3)\u3009 \u2192 (\u00acA\u30081, A1\u3009 \u2228 \u00acA\u30081, A3\u3009)) (7) 7. \u2227 (A\u30081, (A1\u22282\u00acA4)\u3009 \u2192 (A\u30081, A1\u3009 \u2228A\u30081, 2\u00acA4\u3009)) (7) 8. \u2227 (\u00acA\u30081, 2A2\u3009 \u2192 \u00acA\u30081.1, A2\u3009) (8) 9. \u2227 ((A\u30081, 2\u00acA4\u3009 \u2227 \u00acA\u30081, 2A2\u3009) \u2192 \u00acA\u30081.1, A4\u3009) (9) 10. \u2227 ((A\u30081, 2A4\u3009 \u2227 \u00acA\u30081, 2A2\u3009) \u2192 A\u30081.1, A4\u3009) (9) 11. \u2227 (\u00acA\u30081, 2\u22a5\u3009 \u2192 \u00acA\u30081.1, \u22a5\u3009) (8) 12. \u2227 ((A\u30081, 2\u00acA4\u3009 \u2227 \u00acA\u30081, 2\u22a5\u3009) \u2192 \u00acA\u30081.1, A4\u3009) (9) 13. \u2227 ((A\u30081, 2A4\u3009 \u2227 \u00acA\u30081, 2\u22a5\u3009) \u2192 A\u30081.1, A4\u3009) (9)\nClause 11. is then simplified into>. (In a practical implementation it is not even generated.) Notice that in clauses 11., 12. and 13. it is used the label 1.1 of clauses 8., 9. and 10. rather than a new label 1.2. Thus, only one successor label is generated.\nWhen DPLL is run on Km2SAT (\u03d5), by BCP 1. and 2. are immediately satisfied and the implicants are removed from 3., 4., 5., 6.. Thanks to 5. and 6., A\u30081, A1\u3009 can be assigned only to false, which causes 3. to be satisfied and forces the assignment of the literals \u00acA\u30081, 2\u22a5\u3009, A\u30081, 2\u00acA4\u3009 by BCP on 3. and 7. and hence of \u00acA\u30081.1, \u22a5\u3009, \u00acA\u30081.1, A4\u3009 and A\u30081.1, A4\u3009 by BCP on 12. and 13., causing a contradiction. 3\nIt is worth noticing that (14) is strictly necessary for the correctness of the encoding even when another \u03c0-formula occurs in \u03c3. (E.g., in Example 4.7, without 12. and 13. the formula Km2SAT (\u03d5) would become satisfiable because A\u30081, 2A2\u3009 could be safely be assigned to true by DPLL, which would satisfy 8., 9. and 10..)\nHereafter we assume that this technique is applied also in combination with the techniques described in Section 4.5 and in the next sections."}, {"heading": "4.7 On-the-fly Pure-Literal Reduction", "text": "Another technique, evolved from that proposed by Pan and Vardi (2003), applies PureLiteral Reduction (PLR) on-the-fly during the construction of Km2SAT (\u03d5). When for a label \u03c3 all the clauses containing atoms in the form A\u3008\u03c3, \u03c8\u3009 have been generated, if some of them occurs only positively [resp. negatively], then it can be safely assigned to true [resp. to false], and hence the clauses containing A\u3008\u03c3, \u03c8\u3009 can be dropped. 13 As a consequence,\n13. In our actual implementation this reduction is performed directly within an intermediate data structure, so that these clauses are never generated.\nsome other atom A\u3008\u03c3, \u03c8\u2032\u3009 can become pure, so that the process is repeated until a fixpoint is reached.\nExample 4.8. Consider the formula \u03d5bnf of Example 4.1. During the construction of Km2SAT (\u03d5bnf ), after 1.-8. are generated, no more clause containing atoms in the form A\u30081.1, \u03c8\u3009 is to be generated. Then we notice that A\u30081.1, A2\u3009 and A\u30081.1, A3\u3009 occur only negatively, so that they can be safely assigned to false. Therefore, 7. and 8. can be safely dropped. Same discourse applies lately to A\u30081.2, A1\u3009 and 9.. The resulting formula is found inconsistent by BCP. (In fact, notice from Example 4.1 that the atoms A\u30081.1, A2\u3009, A\u30081.1, A3\u3009, and A\u30081.2, A1\u3009 play no role in the unsatisfiability of Km2SAT (\u03d5bnf ).) 3\nWe remark the differences between PLR and the Pure-Literal Reduction technique proposed by Pan and Vardi (2003). In KBDD (Pan et al., 2002; Pan & Vardi, 2003), the Pure-Literal Reduction is a preprocessing step which is applied to the input modal formula, either at global level (i.e. looking for pure-polarity primitive propositions for the whole formula) or, more effectively, at different modal depths (i.e. looking for pure-polarity primitive propositions for the subformulas at the same nesting level of modal operators).\nOur technique is much more fine-grained, as PLR is applied on-the-fly with a single-state granularity, obtaining a much stronger reduction effect.\nExample 4.9. Consider again the BNF Km-formula \u03d5bnf discussed in Examples 4.1 and 4.8: \u03d5bnf = (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3)) \u2227 2\u00acA1 \u2227 2\u00acA2 \u2227 2\u00acA3. It is immediate to see that all primitive propositions A1, A2, A3 occur at every modal depth with both polarities, so that the technique of Pan and Vardi (2003) produces no effect on this formula. 3"}, {"heading": "4.8 On-the-fly Boolean Constraint Propagation", "text": "One major problem of the basic encoding of Section 3 is that it is \u201cpurely-syntactic\u201d, that is, it does not consider the possible truth values of the subformulas, and the effect of their propagation through the Boolean and modal connectives. In particular, Km2SAT applies (8) [resp. (9)] to every \u03c0-subformula [resp. \u03bd-subformula], regardless the fact that the truth values which can be deterministically assigned to the labeled subformulas of \u30081, \u03d5\u3009 may allow for dropping some labeled \u03c0-/\u03bd-subformulas, and thus prevent the need of encoding them.\nOne solution to this problem is that of applying Boolean Constraint Propagation (BCP) on-the-fly during the construction of Km2SAT (\u03d5), starting from the fact that A\u30081, \u03d5\u3009 must be true. If a contradiction is found, then Km2SAT (\u03d5) is unsatisfiable, so that the formula is not expanded any further, and the encoder returns the formula \u201c\u22a5\u201d. 14 When BCP allows for dropping one implication in (6)-(9) without assigning some of its implicate literals, namely L\u3008\u03c3, \u03c8i\u3009, then \u3008\u03c3, \u03c8i\u3009 needs not to be defined, so that Def(\u03c3, \u03c8i) must not be expanded. 15 Importantly, dropping Def(\u03c3, \u03c0r,j) for some \u03c0-formula \u3008\u03c3, \u03c0r,j\u3009 prevents generating the label \u03c3.j (8) and all its successor labels \u03c3.j.\u03c3\u2032 (corresponding to the subtree of states rooted in \u03c3.j), so that all the corresponding labeled subformulas are not encoded.\n14. For the sake of compatibility with standard SAT solvers, our actual implementation returns the formula A1 \u2227 \u00acA1. 15. Here we make the same consideration as in Footnote 11: if L\u3008\u03c3.j, \u03c8\u3009 is generated also from the expansion of some other subformula, (e.g., 2r(\u03c8 \u2228 \u03c6)), then (another instance of) Def(\u03c3.i, \u03c8) must be generated anyway.\nExample 4.10. Consider Example 4.1, and suppose we apply on-the-fly BCP. During the construction of 1., 2. and 3. in Km2SAT (\u03d5bnf ), the atoms A\u30081, \u03d5bnf \u3009, A\u30081, (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3))\u3009, A\u30081, 2\u00acA1\u3009, A\u30081, 2\u00acA2\u3009 and A\u30081, 2\u00acA3\u3009 are deterministically assigned to true by BCP. This causes the removal from 3. of the first-implied disjunct \u00acA\u30081, 2\u00acA1\u3009, so that there is no need to generate Def(1, \u00ac2\u00acA1), and hence label 1.1. is not defined and 4. is not generated. While building 5., A\u30081.2, (\u00acA2\u2227\u00acA3)\u3009, is unit-propagated. As label 1.1. is not defined, 6., 7. and 8. are not generated. Then during the construction of 5., 9., 10., 11. and 12., by applying BCP a contradiction is found, so that Km2SAT (\u03d5) is \u22a5.\nAn analogous situation happens with \u03d5bnflift in Example 4.3: while building 1. and 2. a contradiction is found by BCP, s.t. Km2SAT returns \u22a5 without expanding the formula any further. Same discourse holds for \u03d5bnfclift in Example 4.4: while building 1., 2. and 3. a contradiction is found by BCP, s.t. Km2SAT returns \u22a5 without expanding the formula any further. 3"}, {"heading": "4.9 A Paradigmatic Example: Halpern & Moses Branching Formulas.", "text": "Among all optimizations described in this Section 4, on-the-fly BCP is by far the most effective. In order to better understand this fact, we consider as a paradigmatic example the branching formulas \u03d5Kh by Halpern and Moses (1992, 1995) (also called \u201ck branch n\u201d in the set of benchmark formulas proposed by Heuerding and Schwendimann, 1996) and their unsatisfiable version (called \u201ck branch p\u201d in the above-mentioned benchmark suite).\nGiven a single modality 2, an integer parameter h, and the primitive propositions D0, . . . , Dh+1, P1, . . . , Ph, the formulas \u03d5Kh are defined as follows: 16\n\u03d5Kh def= D0 \u2227 \u00acD1 \u2227\nh\u2227\ni=0\n2i(depth \u2227 determined \u2227 branching), (15)\ndepth def=\nh+1\u2227\ni=1\n(Di \u2192 Di\u22121), (16)\ndetermined def=\nh\u2227\ni=1\n( Di \u2192 ( ( Pi \u2192 2(Di \u2192 Pi)) \u2227 (\u00acPi \u2192 2(Di \u2192 \u00acPi)) ) ) , (17)\nbranching def=\nh\u22121\u2227\ni=0\n( (Di \u2227 \u00acDi+1) \u2192 ( 3(Di+1 \u2227 \u00acDi+2 \u2227 Pi+1) \u2227 3(Di+1 \u2227 \u00acDi+2 \u2227 \u00acPi+1) ) ) . (18)\nA conjunction of the formulas depth, determined and branching is repeated at every nesting level of modal operators (i.e. at every depth): depth captures the relation between the Di\u2019s at every level; determined states that, if Pi is true [false] in a state at depth \u2265 i, then it is true [false] in all the successor states of depth \u2265 i; branching states that, for every node at depth i, it is possible to find two successor states at depth i + 1 such that Pi+1 is true in one and false in the other. For each value of the parameter h, \u03d5Kh is K-satisfiable, and every Kripke model M that satisfies it has at least 2h+1\u2212 1 states. In fact, \u03d5Kh is build in such a way to force the construction of a binary-tree Kripke model of depth h+1, each of\n16. For the sake of better readability, here we adopt the description given by Halpern and Moses (1992) without converting the formulas into BNF. This fact does not affect the discussion.\nwhose leaves encodes a distinct truth assignment to the primitive propositions P1, . . . , Ph, whilst each Di is true in all and only the states occurring at a depth \u2265 i in the tree (and thus denotes the level of nesting).\nThe unsatisfiable counterpart formulas proposed by Heuerding and Schwendimann (1996) (whose negations are the valid formulas called k branch p in the previously-mentioned benchmark suite, which are exposed in more details in Section 5.1.1) are obtained by conjoining to (15) the formula:\n2hPbh 3 c+1 (19)\n(where bxc is the integer part of x) which forces the atom Pbh 3 c+1 to be true in all depth-h states of the candidate Kripke model, which is incompatible with the fact that the remaining specifications say that it has to be false in half depth-h states. 17\nThese formulas are very pathological for many approaches (Giunchiglia & Sebastiani, 2000; Giunchiglia, Giunchiglia, Sebastiani, & Tacchella, 2000; Horrocks et al., 2000). In particular, before introducing on-the-fly BCP, they used to be the pet hate of our Km2SAT approach, as they caused the generation of huge Boolean formulas. In fact, due to branching (18), \u03d5Kh contains 2h 3-formulas (i.e., \u03c0-formulas) at every depth. Therefore, the Km2SAT encoder of Section 3 has to consider 1 + 2h + (2h)2 + ... + (2h)h+1 = ((2h)h+2\u2212 1)/(2h\u2212 1) distinct labels, which is about hh+1 times the number of those labeling the states which are actually needed. (None of the optimizations of Sections 4.1-4.7 is of any help with these formulas, because neither BNF encoding nor atom normalization causes any sharing of subformulas, the formulas are already in lifted form, and no literal occurs pure. 18)\nThis pathological behavior can be mostly overcome by applying on-the-fly-BCP, because some truth values can be deterministically assigned to some subformulas of \u03d5Kh by on-thefly-BCP, which prevent encoding some or even most 2/3-subformulas.\nIn fact, consider the branching and determined formulas occurring in \u03d5Kh at a generic depth d \u2208 {0...h}, which determine the states at level d in the tree. As in these states D0, ..., Dd are forced to be true and Dd+1, ..., Dh+1 are forced to be false, then all but the d-th conjunct in branching (all conjuncts if d = h) are forced to be true and thus they could be dropped. Therefore, only 2 3-formulas per non-leaf level could be considered instead, causing the generation of 2h+1 \u2212 1 labels overall. Similarly, in all states at level d the last h\u2212d conjuncts in determined are forced to be true and could be dropped, reducing significantly the number of 2-formulas to be considered.\nIt is easy to see that this is exactly what happens by applying on-the-fly-BCP. In fact, suppose that the construction of Km2SAT (\u03d5Kh ) has reached depth d (that is, the point where for every state \u03c3 at level d, the Def(\u03c3, \u03b1)\u2019s and Def(\u03c3, \u03b2)\u2019s are expanded but no Def(\u03c3, \u03c0) and Def(\u03c3, \u03bd) is expanded yet). Then, BCP deterministically assigns true to the literals L\u3008\u03c3, D0\u3009, ..., L\u3008\u03c3, Dd\u3009 and false to L\u3008\u03c3, Dd+1\u3009, ..., L\u3008\u03c3, Dh+1\u3009, which removes all but one conjuncts in branching, so that only two Def(\u03c3, \u03c0)\u2019s out of 2h ones are actually expanded; similarly, the last h \u2212 d conjuncts in determined are removed, so that the corresponding Def(\u03c3, \u03bd)\u2019s are not expanded.\n17. Heuerding and Schwendimann do not explain the choice of the index \u201cbh 3 c + 1\u201d. We understand that\nalso other choices would have done the job. 18. More precisely, only one literal, \u00acDh+1, occurs pure in branching, but assigning it plays no role in\nsimplifying the formula.\nAs far as the unsatisfiable version Km2SAT (\u03d5Kh \u2227 2hPbh 3 c+1) is concerned, when the expansion reaches depth h, thanks to (19), L\u3008\u03c3, Pbh3 c+1\u3009 is generated and deterministically assigned to true by BCP for every depth-h label \u03c3; thanks to determined and branching, BCP assigns all literals L\u3008\u03c3, P1\u3009, ..., L\u3008\u03c3, Ph\u3009 deterministically, so that L\u3008\u03c3, Pbh3 c+1\u3009 is assigned to false for 50% of the depth-h labels \u03c3. This causes a contradiction, so that the encoder stops the expansion and returns \u22a5.\nFigure 2 shows the growth in size and the CPU time required to encode and solve Km2SAT (\u03d5Kh ) (1st row) and Km2SAT (\u03d5 K h \u2227 2hPbh\n3 c+1) (2nd row) wrt. the parameter h,\nfor eight combinations of the following options of the encoder: with and without box-lifting, with and without on-the-fly PLR, with and without on-the-fly BCP. (Notice the log scale of the y axis.) In Figure 2(d) the plots of the four versions \u201c-xxx-bcp\u201d (with on-the-fly BCP) coincide with the line of value 1 (i.e, one variable) and in Figure 2(e) they coincide with an horizontal line of value 2 (i.e, two clauses), corresponding to the fact that the 1-variable/2-clause formula A1 \u2227 \u00acA1 is returned (see Footnote 14).\nWe notice a few facts. First, for both formulas, the eight plots always collapse into two groups of overlapping plots, representing the four variants with and without on-the-fly BCP respectively. This shows that box-lifting and on-the-fly PLR are almost irrelevant in the encoding of these formulas, causing just little variations in the time required by the encoder (Figures 2(c) and 2(f)); notice that enabling on-the-fly PLR alone permits to encode (but not to solve) only one problem more wrt. the versions without both on-the-fly PLR and BCP. Second, the four versions with on-the-fly-BCP always outperform of several orders magnitude these without this option, in terms of both size of encoded formulas and of CPU time required to encode and solve them. In particular, in the case of the unsatisfiable variant (Figure 2, second row) the encoder returns the \u22a5 formula, so that no actual work is required to the SAT solver (the plot of Figure 2(f) refers only to encoding time)."}, {"heading": "5. Empirical Evaluation", "text": "In order to verify empirically the effectiveness of this approach, we have performed a veryextensive empirical test session on about 14,000 Km/ALC formulas. We have implemented the encoder Km2SAT in C++, with some flags corresponding to the optimizations exposed in the previous section: (i) NNF/BNF, performing a pre-conversion into NNF/BNF before the encoding; (ii) lift/ctrl.lift/nolift, performing respectively Box Lifting, Controlled Box Lifting or no Box Lifting before the encoding; (iii) plr if on-the-fly Pure Literal Reduction is performed and (iv) bcp if on-the-fly Boolean Constraint Propagation is performed. The techniques introduced in Section 4.2, Section 4.5 and Section 4.6 are hardwired in the encoder. Moreover, as pre-conversion into BNF almost always produces smaller formulas than NNF, we have set the BNF flag as a default.\nIn combination with Km2SAT we have tried several SAT solvers on our encoded formulas (including Zchaff 2004.11.15, Siege v4, BerkMin 5.6.1, MiniSat v1.13, SATElite v1.0, SAT-Elite GTI 2005 submission 19, MiniSat 2.0 061208 and Rsat 1.03).\n19. In the preliminary evaluation of the available SAT solvers we have also tried SAT-Elite as a preprocessor to reduce the size of the SAT formula generated by Km2SAT without the bcp option before to solve it. However, even if the preprocessing can signinificantly reduce the size of the formula, it has turned out\nAfter a preliminary evaluation and further intensive experiments we have selected Rsat 1.03 (Pipatsrisawat & Darwiche, 2006), because it produced the best overall performances on our benchmark suites (although the performance gaps wrt. other SAT tools, e.g. MiniSat 2.0, were not dramatic).\nWe have downloaded the available versions of the state-of-the-art tools for Km-satisfiability. After an empirical evaluation 20 we have selected Racer 1-7-24 (Haarslev & Moeller, 2001) and *SAT 1.3 (Tacchella, 1999) as the best representatives of the tableaux/DPLL-based tools, Mspass v 1.0.0t.1.3 (Hustadt & Schmidt, 1999; Hustadt et al., 1999) 21 as the best representative of the FOL-encoding approach, KBDD (unique version) (Pan et al., 2002; Pan & Vardi, 2003) 22 as the representative of the automata-theoretic approach. No representative of the CSP-based and of the inverse method approaches could be used. 23 Notice that all these tools but Racer are experimental tools, as far as Km2SAT which is a prototype, and many of them (e.g. *SAT and KBDD) are no longer maintained.\nFinally, as representative of the QBF-encoding approach, we have selected the K-QBF translator (Pan & Vardi, 2003) combined with the sKizzo version 0.8.2 QBF solver (Benedetti, 2005), which turned out to be by far 24 the best QBF solver on our benchmarks among the freely-available QBF solvers from the QBF2006 competition (Narizzano, Pulina, & Tacchella, 2006). (In our evaluation we have considered the tools : 2clsQ, SQBF, preQuantor\u2014i.e. preQuel +Quantor\u2014 Quantor 2.11, and Semprop 010604.)\nAll tests presented in this section have been performed on a two-processor Intel Xeon 3.0GHz computer, with 1 MByte Cache each processor, 4 GByte RAM, with Red Hat Linux 3.0 Enterprise Server, where four processes can run in parallel. When reporting the results for one Km2SAT +Rsat version, the CPU times reported are the sums of both\nthat this preprocessing is too time-expensive and that the overall time spent for preprocessing and then solving the reduced problem is higher than that solving directly the original encoded SAT formula. 20. As we did for the selection of the SAT solver, in order to select the tools to be used in the empirical evaluation, we have performed a preliminary evaluation on the smaller benchmark suites (i.e. the LWB and, sometimes, the TANCS 2000 ones; see later). Importantly, from this preliminary evaluation Racer turned out to be definitely more efficient than FaCT++, being able to solve more problems in less time. Also, in order to meet the reviewers\u2019 suggestions, we repeated this preliminary evaluation with the latest versions of FaCT++ (v1.2.3, March 5th, 2009) and the same version of Racer used in this paper. In this evaluation Racer solves ten more problems than FaCT++ on the LWB benchmark, and over than one hundred of problems more than FaCT++ on the whole TANCS 2000 suite. Also on 2m-CNF random problems Racer outperforms FaCT++. (We include in the online appendix the plots of this comparison between Racer and FaCT++.) 21. We have run Mspass with the options -EMLTranslation=2 -EMLFuncNary=1 -Sorts=0 -CNFOptSkolem=0 -CNFStrSkolem=0 -Select=2 -Split=-1 -DocProof=0 -PProblem=0 -PKept=0\n-PGiven=0, which are suggested for Km-formulas in the Mspass README file. We have also tried other options, but the former gave the best performances. 22. KBDD has been recompiled to be run with an increased internal memory bound of 1 GB. 23. At the moment K Kis not freely available, and we failed in the attempt of obtaining it from the authors.\nKCSP is a prolog piece of software, which is difficult to compare in performances wrt. other optimized tools on a common platform; moreover, KCSP is no more maintained since 2005, and it is not competitive wrt. state-of-the-art tools (Brand, 2008). Other tools like leanK, 2KE, LWB, Kris are not competitive with the ones listed above (Horrocks et al., 2000). KSAT (Giunchiglia & Sebastiani, 1996, 2000; Giunchiglia et al., 2000) has been reimplemented into *SAT. 24. Unlike with the choice of SAT solver, the performance gaps from the best choice and the others were very significant: e.g., in the LWB benchmark (see later), sKizzo was able to solve nearly 90 problems more than its best QBF competitor.\nthe encoding and Rsat solving times. When reporting the results for K-QBF +sKizzo, the CPU times reported are only due to sKizzo because the time spent by the K-QBF converter is negligible.\nWe anticipate that, for all formulas of all benchmark suites, all tools under test \u2014i.e. all the variants of Km2SAT +Rsat and all the state-of-the-art Km-satisfiability solvers\u2014 agreed on the satisfiability/unsatisfiability result when terminating within the timeout.\nRemark 1. Due to the big number of empirical tests performed and to the huge amount of data plotted, and due to limitations in size, and in order to to make the plots clearly distinguishable in the figures, we have limited the number of plots included in the following part of the paper, considering only the most meaningful ones and those regarding the most challenging benchmark problems faced. For the sake of the reader\u2019s convenience, however, full-size versions of all plots and many other plots regarding the not-exposed results (also on the easier problems), are available in the online appendix, together with the files with all data. When discussing the empirical evaluation we may include in our considerations also these results."}, {"heading": "5.1 Test Description", "text": "We have performed our empirical evaluation on three different well-known benchmarks suites of Km/ALC problems: the LWB (Heuerding & Schwendimann, 1996), the random 2m-CNF (Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003) and the TANCS 2000 (Massacci & Donini, 2000) benchmark suites. We are not aware of any other publiclyavailable benchmark suite on Km/ALC-satisfiability from the literature. These three groups of benchmark formulas allow us to test the effectiveness of our approach on a large number of problems of various sizes, depths, hardness and characteristics, for a total amount of about 14,000 formulas.\nIn particular, these benchmark formulas allow us to fairly evaluate the different tools both on the modal component and on the Boolean component of reasoning which are intrinsic in the Km-satisfiability problem, as we discuss later in Section 5.4.\nIn the following we describe these three benchmark suites."}, {"heading": "5.1.1 The LWB Benchmark Suite", "text": "As a first group of benchmark formulas we used the LWB benchmark suite used in a comparison at Tableaux\u201998 (Heuerding & Schwendimann, 1996). It consists of 9 classes of parametrized formulas (each in two versions, provable \u201c p\u201d or not-provable \u201c n\u201d 25), for a total amount of 378 formulas. The parameter allows for creating formulas of increasing size and difficulty.\nThe benchmark methodology is to test formulas from each class, in increasing difficulty, until one formula cannot be solved within a given timeout, 1000 seconds in our tests. 26 The result from this class is the parameter\u2019s value of the largest (and hardest) formula that can be solved within the time limit. The parameter ranges only from 1 to 21 so that, if a\n25. Since all tools check Km-(un)satisfiability, all formulas are negated, so that the negations of the provable formulas are checked to be unsatisfiable, whilst the negation of the other formulas are checked to be satisfiable. 26. We also set a 1 GB file-size limit for the encoding produced by Km2SAT .\nsystem can solve all 21 instances of a class, the result is given as 21. For a discussion on this benchmark suite, we refer the reader to the work of Heuerding and Schwendimann (1996) and of Horrocks et al. (2000).\n5.1.2 The Random 2m-CNF Benchmark Suite\nAs a second group of benchmark formulas, we have selected the random 2m-CNF testbed described by Horrocks et al. (2000), and Patel-Schneider and Sebastiani (2003). This is a generalization of the well-known random k-SAT test methods, and is the final result of a long discussion in the communities of modal and description logics on how to to obtain significant and flawless random benchmarks for modal/description logics (Giunchiglia & Sebastiani, 1996; Hustadt & Schmidt, 1999; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).\nIn the 2m-CNF test methodology, a 2m-CNF formula is randomly generated according to the following parameters:\n\u2022 the (maximum) modal depth d; \u2022 the number of top-level clauses L; \u2022 the number of literal per clause clauses k; \u2022 the number of distinct propositional variables N ; \u2022 the number of distinct box symbols m; \u2022 the percentage p of purely-propositional literals in clauses occurring at depth < d, s.t.\neach clause of length k contains on average p \u00b7 k randomly-picked Boolean literals and k \u2212 p \u00b7 k randomly-generated modal literals 2r\u03c8, \u00ac2r\u03c8. 27\n(We refer the reader to the works of Horrocks et al., 2000, and Patel-Schneider & Sebastiani, 2003 for a more detailed description.)\nA typical problem set is characterized by fixed values of d, k, N , m, and p: L is varied in such a way as to empirically cover the \u201c100% satisfiable / 100% unsatisfiable\u201d transition. In other words, many problems with the same values of d, k, N, m, and p but an increasing number of clauses L are generated, starting from really small, typically satisfiable problems (i.e. with a probability of generating a satisfiable problem near to one) to huge problems, where the increasing interactions among the numerous clauses typically leads to unsatisfiable problems (i.e. it makes the probability of generating satisfiable problems converging to zero). Then, for each tuple of the five values in a problem set, a certain number of 2m-CNF formulas are randomly generated, and the resulting formulas are given in the input to the procedure under test, with a maximum time bound. The fraction of formulas which were solved within a given timeout, and the median/percentile values of CPU times are plotted against the ratio L/N . Also, the fraction of satisfiable/unsatisfiable formulas is plotted for a better understanding.\n27. More precisely, the number of Boolean literals in a clause is bp \u00b7 kc (resp. dp \u00b7 ke) with probability dp \u00b7 ke \u2212 p \u00b7 k (resp. 1 \u2212 (dp \u00b7 ke \u2212 p \u00b7 k)). Notice that typically the smaller is p, the harder is the problem (Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).\nFollowing the methodology proposed by Horrocks et al. (2000), and by Patel-Schneider and Sebastiani (2003), we have fixed m = 1, k = 3 and 100 samples per point in all tests, and we have selected two groups: an \u201ceasier\u201d one, with d = 1, p = 0.5, N = 6, 7, 8, 9, L/N = 10..60, and a \u201charder\u201d one, with d = 2, p = 0.6, 0.5, N = 3, 4, L/N = 30..150 with p = 0.6 and L/N = 50..140 with p = 0.5, varying the L/N ratio in steps of 5, for a total amount of 13,200 formulas.\nIn each test, we imposed a timeout of 500 seconds per sample 28 and we calculated the number of samples which were solved within the timeout, and the 50%th and 90%th percentiles of CPU time. 29 In order to correlate the performances with the (un)satisfiability of the sample formulas, in the background of each plot we also plot the satisfiable/unsatisfiable ratio."}, {"heading": "5.1.3 The TANCS 2000 Benchmark Suite", "text": "Finally, as a third group of benchmark formulas, we used the MODAL PSPACE division benchmark suite used in the comparison at TANCS 2000 (Massacci & Donini, 2000). It contains both satisfiable and unsatisfiable formulas, with scalable hardness. In this benchmark suite, which we call TANCS 2000, the formulas are constructed by translating QBF formulas into K using three translation schemas, namely the Schmidt-Schauss-Smolka translation (240 problems with many different depths, from 19 to 112), the Ladner translation (240 problems, again with depths in the same range 19 \u2013 112), and the Halpern translation (56 problems of depth among: 20, 28, 40, 56, 80 or 112) (Massacci & Donini, 2000). As done by Massacci and Donini, we call these classes easy, medium and hard respectively.\nAll formulas from each class are tested within a timeout of 1000 seconds. 30 For each class, we report the number of solved formulas (X axis) and the total (cumulative) CPU time spent for solving these formulas (Y axes). For each class the results are plotted sorting the solved problems from the easiest one to the hardest one.\n5.2 An Empirical Comparison of the Different Variants of Km2SAT\nWe have first evaluated the various variants of the encoding in combination with Rsat. In order to avoid considering too many combinations of the flags, we have considered the BNF format, and we have grouped plr and bcp into one parameter plr-bcp, restricting thus our investigation to 6 combinations: BNF, lift/ctrl.lift/nolift, and plr-bcp on/off. (We recall that the techniques introduced in Section 4.2, Section 4.5 and Section 4.6 are hardwired in the encoder.) Here we expose and analyze the results wrt. the three different suites of benchmark problems.\n28. With also a 512 MB file-size limit for the encoding produced by Km2SAT . 29. Due to the lack of space and for the sake of clarity we won\u2019t include in the paper the 90%th percentiles\nplots. Further, for the same reasons, we\u2019ll skip to report the plots regarding some of the easiest class of the benchmark suite (e.g. those with d = 1 and lower values of N). All of these plots, however, can be found in the online appendix.\n30. We also set a 1 GB file-size limit for the encoding produced by Km2SAT ."}, {"heading": "5.2.1 Results on the LWB Benchmark Suite", "text": "The results on the LWB benchmark suite are summarized in Table 1 and Figure 3. Table 1(a) reports in the left block the indexes of the hardest formulas encoded within the file-size limit and, in the right block, those of the hardest formulas solved within the timeout by Rsat; Table 1(b) reports the numbers of variables and clauses of Km2SAT (\u03d5), referring to the hardest formulas solved within the timeout by Rsat (i.e., those reported in the right block of Table 1(a)). For instance, the BNF-ctrl.lift-plr-bcp encoding of k dum n(21) contains 11\u00b7106 variables and 14\u00b7106 clauses; it is the hardest k dum n problem solved by Rsat with BNF-ctrl.lift-plr-bcp and it is the first which is not solved with BNF-ctrl.lift.\nLooking at the numbers of cases solved in Table 1(a), we notice that the introduction of the on-the-fly Pure Literal Reduction and Boolean Constraint Propagation optimizations is really effective and produces a consistent performance enhancement (the effect of these optimizations is eye-catching in the branching formulas k branch * \u2013 see Section 4.9 \u2013 and in the k path * formulas). We also notice that lift sometimes introduces some slight further improvement.\nThe view of Tables 1(a) and 1(b) hides the actual CPU times required to encode and solve the problems. Small gaps in the numbers of Table 1(a) may correspond to big gaps in CPU time. In order to analyze also this aspect, in Figure 3 we plotted the total cumulative amount of CPU time spent by all the variants of Km2SAT +Rsat to solve all the problems of the LWB benchmark, sorted by hardness. For this plot, we also considered three more options \u2014BNF, lift/ctrl.lift/nolift, with plr on and bcp off\u2014 so that to evaluate also the effect of plr and bcp separately. We notice that the plots are clearly clustered into three groups of increasing performance: BNF-*, BNF-*-plr, and BNF-*-plr-bcp., \u201c*\u201d representing the three options lift/ctrl.lift/nolift. This highlights the fact that on this suite on-the-fly Pure Literal Reduction significantly improves the performances, that on-the-fly Boolean Constraint Propagation introduces drastic improvements, and that the variations due to Box Lifting are minor wrt. the other two optimizations.\nOverall, the configuration BNF-lift-plr-bcp turns out to be the best performer on this suite, with a tiny advantage wrt. BNF-ctrl.lift-plr-bcp.\n5.2.2 Results on the Random 2m-CNF Benchmark Suite\nThe results on the random 2m-CNF benchmark suite are reported in Figures 4 and 5. In Figure 4 we report the 50%-percentile CPU times required to encode and solve the formulas by the different Km2SAT +Rsat variants for the hardest benchmarks problems. We don\u2019t report the percentage of solved problems since it is always 100%, i.e. Km2SAT +Rsat terminates within the timeout for every problem in the benchmark suite.\nThe tests with depth d = 1 (see the results on the hardest problems of the class in the first row of Figure 4) are simply too easy for Km2SAT +Rsat (but not for its competitors, see Section 5.3) which solved every sample formula in less than 1 second. Although the tests exposed in the second and third row of Figure 4 are more challenging, they are all solved within the timeout as well. We have noticed also that the results are rather regular, since there are no big gaps between 50%- and 90%-percentile values.\nIn general, we do not have relevant performance gaps between the various configurations on this benchmark suite; it seems that in the majority of cases ctrl.lift slightly beats nolift and nolift slightly beats lift. These gaps are even more relevant if we consider the size of the formulas generated (Figure 5). We believe that this may be due to the fact that random 2m-CNF formulas may contain lots of shared subformulas 2r\u03c8, so that lifting may cause a reduction of such sharing (see Section 3). Further, plr-bcp does not seem to introduce relevant improvements here. We believe that this is due to the fact that these random formulas produce pure and unit literals with very low or even zero probability.\nOverall, the configuration BNF-nolift turns out to be the best performer on this suite, with a slight advantage wrt. BNF-ctrl.lift-plr-bcp.\nFinally, from some plots of Figure 4 we notice that for Km2SAT +Rsat the problems tend to be harder within the satisfiability/unsatisfiability transition area. (This fact holds especially for Racer and *SAT, see Section 5.3.) This seems to confirm the fact that the easy-hard-easy pattern of random k-SAT extends also to 2m-CNF, as already observed in literature (Giunchiglia & Sebastiani, 1996, 2000; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003)."}, {"heading": "5.2.3 Results on the TANCS 2000 Benchmark Suite", "text": "The comparison among the Km2SAT variants on the TANCS 2000 benchmark is presented in Figures 6 and 7, where different BNF variants of Km2SAT are compared both enabling or disabling lift/ctrl.lif and plr-bcp.\nIn Figure 6, from top-left to bottom, we present the cumulative CPU times spent by Km2SAT +Rsat on the easy, medium and hard categories respectively (the corresponding plots reporting the non-cumulative CPU times are included in the online appendix). In Figure 7 we present the plots of the number of variables and clauses of the formulas solved for the more challenging cases of the medium and hard problems. 31 We notice that there are only slight differences among the different variants of Km2SAT ; BNF with lift is the best option which allows for solving more problems in the hard class and requiring less CPU time.\nWe remark that, despite the expected exponential growth of the encoded formulas wrt. the modal depth, in this benchmark Km2SAT +Rsat allows for encoding and solving problems of modal depth greater than 100 for the easy class and greater than 50 for the medium and hard classes, producing and solving SAT-encoded formulas with more than 107 variables and 1.4 \u00b7 107 clauses."}, {"heading": "5.3 An Empirical Comparison wrt. the Other Approaches", "text": "We proceed with the comparison of our approach wrt. the current state-of-the-art evaluating Km2SAT +Rsat against the other Km-satisfiability solvers listed above. In more details, we chose to compare the performance of the other solvers against both the best \u201clocal\u201d Km2SAT +Rsat variant for the single benchmark suite and the best \u201cglobal\u201d Km2SAT +Rsat variant among all the benchmark suites, which we have identified in BNF-ctrl.lift-plr-bcp."}, {"heading": "5.3.1 Comparison on the LWB Benchmark Suite", "text": "The results on the LWB benchmark suite are summarized numerically and graphically in Table 2. From Table 2(a) we notice a few facts: Racer and *SAT are the best performers (confirming the analysis done by Horrocks et al., 2000) with a significant gap wrt. the others; then, K-QBF +sKizzo solves a few more problems than Km2SAT +Rsat; then follows KBDD which outperforms Mspass, which is the worst performer. In detail, Km2SAT +Rsat is (one of) the worst performer(s) on k d4 * and k t4 *, the fourth best performer on k path n, the third best performer on k path p and k branch p, and it is (one of) the best performer(s) on k branch n, k dum *, k grz *, k lin *, k ph * and k poly *; it is the absolute best performer on k branch n and k ph p.\nIn Table 2(b) we give a graphical representation of this comparison, plotting the number of solved problems by each approach against the total cumulative amount of CPU time spent. We notice that, even if Km2SAT +Rsat solves a few problems less than K-QBF +sKizzo, Km2SAT +Rsat is mostly faster than K-QBF +sKizzo.\n31. The same plots for the easy problems are included in the online appendix.\n5.3.2 Comparison on the Random 2m-CNF Benchmark Suite\nIn the random 2m-CNF benchmark suite the results are dominated by Km2SAT +Rsat. For the hardest categories among the three groups of problems used in the evaluation, we report in Figure 8 the number of problems solved by each tool within the timeout, and in Figure 9 the median CPU time (i.e. the 50%th percentile).\nLooking at Figure 8 we notice that Km2SAT +Rsat (in both versions) is the only tool which always terminates within the timeout, whilst *SAT and Racer sometimes do not terminate in the hardest problems, K-QBF +sKizzo very often does not terminate, and Mspass and KBDD do not terminate for most values.\nIn Figure 9 we notice that Km2SAT +Rsat is most often the best performer (in particular with the hardest problems), followed by *SAT and Racer. (This is even much more evident if we consider the 90%th percentile of CPU time, whose plots are included in the online appendix.) In all these tests, K-QBF +sKizzo, Mspass and KBDD are drastically outperformed by the others."}, {"heading": "5.3.3 Comparison on the TANCS 2000 Benchmark Suite", "text": "The results of the TANCS 2000 benchmark are summarized in Figure 10, from the easy category (top-left) to the hard category (bottom).\nFrom the plots we notice that the relative performances of the tools under test vary significantly with the category: Racer and *SAT are among the best performers in all categories; K-QBF +sKizzo behaves well on the easy and medium categories but solves very few problems on the hard one; KBDD behaves very well on the easy category, but solves very few problems in the medium and hard ones. Mspass is among the worst performers in all categories: in particular, it does not solve any problem in the hard category; finally, Km2SAT +Rsat is the worst performer on the easy category, it outperforms all competitors but *SAT and Racer on the medium category, and competes head-to-head with both Racer and *SAT for the first position on the hard category: the \u201clocal-best\u201d configuration BNF-lift beats both competitors; the \u201cglobal-best\u201d configuration BNF-ctrl.lift-prl-bcp solves as many problems as Racer, with one-order-magnitude CPU-time performance gap, and two problems less than *SAT.\nNotice that the classification of the benchmark problems in \u201ceasy\u201d, \u201cmedium\u201d and \u201chard\u201d given by Massacci and Donini (2000) is based on the translation schema used to produce every modal problem and refers to its \u201creasoning component\u201d, but it is not necessarily related to other components (like, e.g., the modal depth) which affect the size of our encoding and, hence, the efficiency of our approach. This may explain the fact, e.g., that the \u201ceasy\u201d problems are not so easy for our approach, and viceversa."}, {"heading": "5.4 Discussion", "text": "As highlighted by Giunchiglia et al. (2000), and Horrocks et al. (2000), the satisfiability problem in modal logics like Km is characterized by the alternation of two orthogonal components of reasoning: a Boolean component, performing Boolean reasoning within each state, and a modal component, generating the successor states of each state. The latter must cope with the fact that the candidate models may be up to exponentially big wrt. depth(\u03d5), whilst the former must cope with the fact that there may be up to exponentially\nmany candidate (sub)models to explore. In the Km2SAT +DPLL approach the encoder has to handle the whole modal component (rules (8) and (9)), whilst the handling of the whole Boolean component is delegated to an external SAT solver.\nFrom the results displayed in Section 5.3 we notice that the relative performances of the Km2SAT +DPLL approach wrt. other state-of-the-art tools range from cases where Km2SAT +Rsat is much less efficient than other state-of-the-art approaches (e.g., the k d4 and k t4p formulas) up to formulas where it is much more efficient (e.g., the k ph p or the 2m-CNF formulas with d = 1). In the middle stands a large majority of formulas in which the approach competes well against the other state-of-the art tools; in particular, Km2SAT +Rsat competes very well or even outperforms the other approaches based on translations into different formalisms (the translational approach, the automata-theoretic approach and the QBF-encoding approach).\nA simple explanation of the former fact could be that the Km2SAT +DPLL approach loses on problems with high modal depth, or where the modal component of reasoning dominates (like, e.g., the k d4 and k t4p formulas), and wins on problems where the Boolean component of reasoning dominates (like, e.g., the k ph n or the 2m-CNF formulas with d = 1), and it is competitive for formulas in which both components are relevant.\nWe notice, however, that Km2SAT +Rsat wins in the hard category of TANCS 2000 benchmarks, with modal depths greater than 50, and on k branch n, where the search is dominated by the modal component. 32 In fact, we recall that reducing the Boolean component of reasoning may produce a reduction also of the modal reasoning effort, because it may reduce the number of successor states to analyze (e.g. Sebastiani, 2007, 2007). Thus, e.g., techniques like on-the-fly BCP, although exploiting only purely-Boolean properties, may produce not only a drastic pruning of the Boolean search, but also a drastic reduction in the size of the model investigated, because they cut a priori the amount of successor states to expand."}, {"heading": "6. Related Work and Research Trends", "text": "In the last fifteen years one main research line in description logic has focused on investigating increasingly expressive logics, with the goal of establishing the theoretical boundaries of decidability and of allowing for more expressive power in the languages defined (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). Consequently, very expressive \u2014 though very hard\u2014 description logics have today notable application in the field of Semantic Web. For example, the SHOIN (D) logic (which has NExpTime complexity) captures the sub-language OWL DL of the full OWL (Web Ontology Language) language (Bechhofer, van Harmelen, Hendler, Horrocks, McGuinness, Patel-Schneider, & Stein, 2004), that is the recommended standard language for the semantic web proposed by the W3C consortium.\nIn contrast, the recent quest for tractable description logic-based languages arising from the field of bio-medical ontologies (e.g., Spackman, Campbell, & Cote, 1997; Sioutos, de Coronado, Haber, Hartel, Shaiu, & Wright, 2007; The Gene Ontology Consortium, 2000;\n32. The k branch n formulas are very hard from the perspective of modal reasoning, because they require finding one modelM with 2d+1\u22121 states (Halpern & Moses, 1992), but no Boolean reasoning within each state is really required (Giunchiglia et al., 2000; Horrocks et al., 2000): e.g., *SAT solves k branch n(d) with 2d+1\u22121 calls to its embedded DPLL engine, one for each state of M, each call solved by BCP only.\nRector & Horrocks, 1997) has stimulated the opening of another research line on tractable description logics (also called lightweight description logics), which are suitable for reasoning on these very big bio-medical ontologies. In particular, Baader et al. (2005, 2006, 2007, 2008) have spent a considerable effort in the attempt of defining a small but maximal subset of logical constructors, expressive enough to cover the needs of these practical applications, but whose inference problems must remain tractable. For example, simple and tractable description logics like EL, EL+ and EL++ (Baader et al., 2005) are expressive enough to describe several important bio-medical ontologies such as SNoMed (Spackman et al., 1997), NCI (Sioutos et al., 2007), the Gene Ontology (The Gene Ontology Consortium, 2000) and the majority of Galen (Rector & Horrocks, 1997).\nReasoning on these ontologies represents not only an important application of lightweight description logics, but also a challenge due to the required efficiency and the huge dimensions of the ontologies. In this perspective, it is important to face efficiently not only the basic reasoning services (e.g., satisfiability, subsumption, queries) on logics like EL, EL+ and EL++, but also more sophisticated reasoning problems like e.g., axiom pinpointing (Baader et al., 2007; Baader & Pen\u0303aloza, 2008) and logical difference between terminologies (Konev, Walther, & Wolter, 2008)."}, {"heading": "7. Conclusions and Future Work", "text": "In this paper we have explored the idea of encoding Km/ALC-satisfiability into SAT, so that to be handled by state-of-the-art SAT tools. We have showed that, despite the intrinsic risk of blowup in the size of the encoded formulas, the performances of this approach are comparable with those of current state-of-the-art tools on a rather extensive variety of empirical tests. Furthermore, we remark that our approach allows for directly benefitting \u201cfor free\u201d from current and future enhancements in SAT solver technology.\nWe see many possible directions to explore in order to enhance and extend our approach. An important open research line is to explore the feasibility of SAT encodings for other and more expressive modal and description logics (e.g., whilst for logics like Tm the extension should be straightforward, logics like S4m, or more elaborated description logics than ALC, should be challenging) and for more complex form of reasoning (e.g., including TBoxes and ABoxes).\nOur current investigation, however, focuses on the lightweight logics of Baader et al. (2005). We have investigated (and we are currently enhancing) an encoding of the main reasoning services in EL and EL+ into Horn-SAT, which allows for reasoning efficiently on the (often huge) bio-medical ontologies mentioned in Section 6, and for handling the more sophisticated inference problems mentioned there (e.g., we currently handle axiom pinpointing), by exploiting some of the advanced functionalities which can be implemented on top of a modern SAT solver (Sebastiani & Vescovi, 2009)."}, {"heading": "8. Acknowledgments", "text": "The authors are partly supported by SRC/GRC under Custom Research Project 2009-TJ1880 WOLFLING, and by MIUR under PRIN project 20079E5KM8 002."}, {"heading": "Appendix A. The Proof of Correctness & Completeness", "text": "A.1 Some Further Notation\nLet \u03c8 be a Km-formula. We denote by \u03c8 the representation of \u00ac\u03c8 in the current formalism: in NNF, 3r\u03c8 def= 2r\u03c8, 2r\u03c8 def= 3r\u03c8, \u03c81 \u2227 \u03c82 def= \u03c81 \u2228 \u03c82, \u03c81 \u2228 \u03c82 def= \u03c81 \u2227 \u03c82, Ai def= \u00acAi, \u00acAi def= Ai; in BNF, \u00ac2r\u03c8 def= 2r\u03c8, 2r\u03c8 def= \u00ac2r\u03c8, \u03c81 \u2227 \u03c82 def= \u03c81 \u2228 \u03c82, \u03c81 \u2228 \u03c82 def= \u03c81 \u2227 \u03c82, Ai\ndef= \u00acAi, \u00acAi def= Ai. We represent a truth assignment \u00b5 as a set of literals, with the intended meaning that a positive literal Ai (resp. negative literal \u00acAi) in \u00b5 means that Ai is assigned to true (resp. false). We say that \u00b5 assigns a literal l if either l \u2208 \u00b5 or \u00acl \u2208 \u00b5. We say that a literal l occurs in a Boolean formula \u03c6 iff the atom of l occurs in \u03c6.\nLet M denote a Kripke model, and let \u03c3 be the label of a generic state u\u03c3 in M. We label (and denote) by \u201c1\u201d the root state of M. By \u201c\u3008\u03c3 : \u03c8\u3009 \u2208 M\u201d we mean that u\u03c3 \u2208 M and M, u\u03c3 |= \u03c8. Thus, for every \u03c3 s.t. u\u03c3 \u2208M, either \u3008\u03c3 : \u03c8\u3009 \u2208 M or \u3008\u03c3 : \u03c8\u3009 \u2208 M.\nFor convenience, instead of (9) sometimes we use the equivalent definition:\nDef(\u03c3, \u03bdr) def= (L\u3008\u03c3, \u03bdr\u3009 \u2192 \u2227\nfor every \u3008\u03c3,\u03c0r,i\u3009\n(L\u3008\u03c3, \u03c0r,i\u3009 \u2192 L\u3008\u03c3.i, \u03bdr0 \u3009)) \u2227 \u2227\nfor every \u3008\u03c3,\u03c0r,i\u3009\nDef(\u03c3.i, \u03bdr0). (20)\nNotice that each Def(\u03c3, \u03c8) in (6), (7), (8), (20) is written in the general form\n(L\u3008\u03c3, \u03c8\u3009 \u2192 \u03a6\u3008\u03c3,\u03c8\u3009) \u2227 \u2227\n\u3008\u03c3\u2032,\u03c8\u2032\u3009 Def(\u03c3\u2032, \u03c8\u2032). (21)\nWe call definition implication for Def(\u03c3, \u03c8) the expressions \u201c(L\u3008\u03c3, \u03c8\u3009 \u2192 \u03a6\u3008\u03c3,\u03c8\u3009)\u201d.\nA.2 Soundness and Completeness of Km2SAT\nLet \u03d5 be a Km-formula. We prove the following theorem, which states the soundness and completeness of Km2SAT .\nTheorem 1. A Km-formula \u03d5 is Km-satisfiable if and only if the corresponding Km2SAT (\u03d5) is satisfiable.\nProof. It is a direct consequence of the following Lemmas 2 and 3.\nLemma 2. Given a Km-formula \u03d5, if Km2SAT (\u03d5) is satisfiable, then there exists a Kripke model M s.t. M, 1 |= \u03d5. Proof. Let \u00b5 be a total truth assignment satisfying Km2SAT (\u03d5). We build from \u00b5 a Kripke model M = \u3008U ,L,R1, . . . ,Rm\u3009 as follows:\nU def= {\u03c3 : A\u3008\u03c3, \u03c8\u3009 occurs in Km2SAT (\u03d5) for some \u03c8} (22)\nL(\u03c3,Ai) def= {\nTrue if L\u3008\u03c3, Ai\u3009 \u2208 \u00b5 False if \u00acL\u3008\u03c3, Ai\u3009 \u2208 \u00b5\n(23)\nRr def= {\u3008\u03c3, \u03c3.i\u3009 : L\u3008\u03c3, \u03c0r,i\u3009 \u2208 \u00b5}. (24)\nWe show by induction on the structure of \u03d5 that, for every \u3008\u03c3, \u03c8\u3009 s.t. L\u3008\u03c3, \u03c8\u3009 occurs on Km2SAT (\u03d5), \u3008\u03c3 : \u03c8\u3009 \u2208 M if L\u3008\u03c3, \u03c8\u3009 \u2208 \u00b5. (25) Base\n\u03c8 = Ai or \u03c8 = \u00acAi. Then (25) follows trivially from (23). Step\n\u03c8 = \u03b1. Let L\u3008\u03c3, \u03b1\u3009 \u2208 \u00b5. As \u00b5 satisfies (6), L\u3008\u03c3, \u03b1i\u3009 \u2208 \u00b5 for every i \u2208 {1, 2}. By inductive hypothesis, \u3008\u03c3 : \u03b1i\u3009 \u2208 M for every i \u2208 {1, 2}. Then, by definition, \u3008\u03c3 : \u03b1\u3009 \u2208 M. Thus, \u3008\u03c3 : \u03b1\u3009 \u2208 M if L\u3008\u03c3, \u03b1\u3009 \u2208 \u00b5.\n\u03c8 = \u03b2. Let L\u3008\u03c3, \u03b2\u3009 \u2208 \u00b5. As \u00b5 satisfies (7), L\u3008\u03c3, \u03b2i\u3009 \u2208 \u00b5 for some i \u2208 {1, 2}. By inductive hypothesis, \u3008\u03c3 : \u03b2i\u3009 \u2208 M for some i \u2208 {1, 2}. Then, by definition, \u3008\u03c3 : \u03b2\u3009 \u2208 M. Thus, \u3008\u03c3 : \u03b2\u3009 \u2208 M if L\u3008\u03c3, \u03b2\u3009 \u2208 \u00b5.\n\u03c8 = \u03c0r,j . Let L\u3008\u03c3, \u03c0r,j\u3009 \u2208 \u00b5. As \u00b5 satisfies (8), L\u3008\u03c3.j, \u03c0r,j0 \u3009 \u2208 \u00b5. By inductive hypothesis, \u3008\u03c3.j : \u03c0r,j0 \u3009 \u2208 M. Then, by definition and by (24), \u3008\u03c3 : \u03c0r,j\u3009 \u2208 M. Thus, \u3008\u03c3 : \u03c0r,j\u3009 \u2208 M if L\u3008\u03c3, \u03c0r,j\u3009 \u2208 \u00b5.\n\u03c8 = \u03bdr. Let L\u3008\u03c3, \u03bdr\u3009 \u2208 \u00b5. As \u00b5 satisfies (9), for every \u3008\u03c3, \u03c0r,i\u3009 s.t. L\u3008\u03c3, \u03c0r,i\u3009 \u2208 \u00b5, we have that L\u3008\u03c3.i, \u03bdr0 \u3009 \u2208 \u00b5. By inductive hypothesis, we have that \u3008\u03c3 : \u03c0r,i\u3009 \u2208 M and \u3008\u03c3.i : \u03bdr0\u3009 \u2208 M. Then, by definition and by (24), \u3008\u03c3 : \u03bdr\u3009 \u2208 M. Thus, \u3008\u03c3 : \u03bdr\u3009 \u2208 M if L\u3008\u03c3, \u03bdr\u3009 \u2208 \u00b5.\nIf \u00b5 |= Km2SAT (\u03d5), then A\u30081, \u03d5\u3009 \u2208 \u00b5. Thus, by (25), \u30081 : \u03d5\u3009 \u2208 M, i.e., M, 1 |= \u03d5.\nLemma 3. Given a Km-formula \u03d5, if there exists a Kripke model M s.t. M, 1 |= \u03d5, then Km2SAT (\u03d5) is satisfiable.\nProof. Let M be a Kripke model s.t. M, 1 |= \u03d5. We build from M a truth assignment \u00b5 for Km2SAT (\u03d5) recursively as follows: 33\n\u00b5 def= \u00b5M \u222a \u00b5M (26) \u00b5M def= {L\u3008\u03c3, \u03c8\u3009 \u2208 Km2SAT (\u03d5) : \u3008\u03c3, \u03c8\u3009 \u2208 M} (27) \u222a {\u00acL\u3008\u03c3, \u03c8\u3009 \u2208 Km2SAT (\u03d5) : \u3008\u03c3, \u03c8\u3009 \u2208 M}\n\u00b5M def= \u00b5\u03c0\u03bd \u222a \u00b5\u03b1\u03b2 \u222a \u00b5A (28) \u00b5\u03c0\u03bd def= {\u00acL\u3008\u03c3, \u03c0r,i\u3009 \u2208 Km2SAT (\u03d5) : \u03c3 6\u2208 M} (29) \u222a {L\u3008\u03c3, \u03bdr\u3009 \u2208 Km2SAT (\u03d5) : \u03c3 6\u2208 M}\n\u00b5\u03b1\u03b2 def= {\u00acL\u3008\u03c3, \u03b1\u3009\u2208Km2SAT (\u03d5) : \u03c3 6\u2208M and \u00acL\u3008\u03c3, \u03b1i\u3009\u2208\u00b5M for some i\u2208{1, 2}} (30) \u222a {\u00acL\u3008\u03c3, \u03b2\u3009\u2208Km2SAT (\u03d5) : \u03c3 6\u2208M and \u00acL\u3008\u03c3, \u03b2i\u3009\u2208\u00b5M for every i\u2208{1, 2}}.\nwhere \u00b5A is a consistent truth assignment for the literals L\u3008\u03c3, Ai\u3009 s.t. Ai \u2208 A and \u03c3 6\u2208 M.\nBy construction, for every L\u3008\u03c3, \u03c8\u3009 in Km2SAT (\u03d5), \u00b5 assigns L\u3008\u03c3, \u03c8\u3009 to true iff it assigns L\u3008\u03c3, \u03c8\u3009 to false and vice versa, so that \u00b5 is a consistent truth assignment.\nFirst, we show that \u00b5M satisfies the definition implications of all Def(\u03c3, \u03c8)\u2019s and Def(\u03c3, \u03c8)\u2019 s.t. \u03c3 \u2208M. Let \u03c3 \u2208M. We distinguish four cases.\n\u03c8 = \u03b1. Thus \u03c8 = \u03b2 s.t. \u03b21 = \u03b11 and \u03b22 = \u03b12.\n\u2013 If \u3008\u03c3 : \u03b1\u3009 \u2208 M (and hence \u3008\u03c3 : \u03b2\u3009 6\u2208 M), then for both i\u2019s \u3008\u03c3 : \u03b1i\u3009 \u2208 M and \u3008\u03c3 : \u03b2i\u3009 6\u2208 M. Thus, by (27), {L\u3008\u03c3, \u03b11\u3009, L\u3008\u03c3, \u03b12\u3009,\u00acL\u3008\u03c3, \u03b2\u3009} \u2286 \u00b5M, so that \u00b5M satisfies the definition implications of both Def(\u03c3, \u03b1) and Def(\u03c3, \u03b2).\n\u2013 If \u3008\u03c3 : \u03b1\u3009 6\u2208 M (and hence \u3008\u03c3, \u03b2\u3009 \u2208 M), then for some i \u3008\u03c3 : \u03b1i\u3009 6\u2208 M and \u3008\u03c3 : \u03b2i\u3009 \u2208 M. Thus, by (27), {\u00acL\u3008\u03c3, \u03b1\u3009, L\u3008\u03c3, \u03b2i\u3009} \u2286 \u00b5M, so that \u00b5M satisfies the definition implications of both Def(\u03c3, \u03b1) and Def(\u03c3, \u03b2).\n\u03c8 = \u03b2. Like in the previous case, inverting \u03c8 and \u03c8.\n\u03c8 = \u03c0r,j . Thus \u03c8 = \u03bdr s.t. \u03bdr0 = \u03c0 r,j 0 .\n\u2013 If \u3008\u03c3 : \u03c0r,j\u3009 \u2208 M (and hence \u3008\u03c3 : \u03bdr\u3009 6\u2208 M), then \u3008\u03c3.j : \u03c0r,j0 \u3009 \u2208 M. Thus, by (27), {L\u3008\u03c3.j, \u03c0r,j0 \u3009,\u00acL\u3008\u03c3, \u03bdr\u3009} \u2286 \u00b5M, so that \u00b5M satisfies the definition implications of both Def(\u03c3, \u03c0r,j) and Def(\u03c3, \u03bdr).\n33. We assume that \u00b5M, \u00b5\u03c0\u03bd and \u00b5\u03b1\u03b2 are generated in order, so that \u00b5\u03b1\u03b2 is generated recursively starting from \u00b5\u03c0\u03bd . Intuitively, \u00b5M assigns the literals L\u3008\u03c3, \u03c8\u3009 s.t. \u03c3 \u2208M in such a way to mimic M; \u00b5M assigns the other literals in such a way to mimic the fact that no state outside those in M is generated (i.e., all L\u3008\u03c3, \u03c0\u3009\u2019s are assigned false and the L\u3008\u03c3, \u03bd\u3009\u2019s, L\u3008\u03c3, \u03b1\u3009\u2019s, L\u3008\u03c3, \u03b2\u3009\u2019s are assigned consequently).\n\u2013 If \u3008\u03c3 : \u03c0r,j\u3009 6\u2208 M (and hence \u3008\u03c3 : \u03bdr\u3009 \u2208 M), then by (27) \u00acL\u3008\u03c3, \u03c0r,j\u3009 \u2208 \u00b5M, so that \u00b5M satisfies the definition implications of Def(\u03c3, \u03c0r,j). As far as Def(\u03c3, \u03bdr) is concerned, we partition the clauses in (9):\n((L\u3008\u03c3, \u03bdr\u3009 \u2227 L\u3008\u03c3, \u03c0r,i\u3009) \u2192 L\u3008\u03c3.i, \u03bdr0 \u3009) (31)\ninto two subsets. The first is the set of clauses (31) for which \u3008\u03c3 : \u03c0r,i\u3009 \u2208 M. As \u3008\u03c3 : \u03bdr\u3009 \u2208 M, we have that \u3008\u03c3.i : \u03bdr0\u3009 \u2208 M. Thus, by (27), L\u3008\u03c3.i, \u03bdr0 \u3009 \u2208 \u00b5M, so that \u00b5M satisfies (31). The second is the set of clauses (31) for which \u3008\u03c3 : \u03c0r,i\u3009 6\u2208 M. By (27) we have that \u00acL\u3008\u03c3, \u03c0r,i\u3009 \u2208 \u00b5M, so that \u00b5M satisfies (31). Thus, \u00b5M satisfies the definition implications also of Def(\u03c3, \u03bdr).\n\u03c8 = \u03bdr. Like in the previous case, inverting \u03c8 and \u03c8.\nNotice that, if \u03c3 6\u2208 M, then \u03c3.i 6\u2208 M for every i. Thus, for every Def(\u03c3, \u03c8) s.t. \u03c3 6\u2208 M, all atoms in the implication definition of Def(\u03c3, \u03c8) are not assigned by \u00b5M.\nSecond, we show by induction on the recursive structure of \u00b5M that \u00b5M satisfies the definition implications of all Def(\u03c3, \u03c8)\u2019s and Def(\u03c3, \u03c8)\u2019s s.t. \u03c3 6\u2208 M. Let \u03c3 6\u2208 M.\nAs a base step, by (29), \u00b5\u03c0\u03bd satisfies the definition implications of all Def(\u03c3, \u03c0r,i)\u2019s and Def(\u03c3, \u03bdr)\u2019s because it assigns false to all L\u3008\u03c3, \u03c0r,i\u3009\u2019s. Indeed, \u00b5A assigns every literal of the type L\u3008\u03c3, Ai\u3009 s.t Ai \u2208 A and \u03c3 6\u2208 M (notice that all the Def(\u03c3, Ai)\u2019s definitions are trivially satisfied and don\u2019t contain any definition implications).\nAs inductive step, we show on the inductive structure of \u00b5\u03b1\u03b2 that \u00b5\u03b1\u03b2 satisfies the definition implications of all Def(\u03c3, \u03b1)\u2019s and Def(\u03c3, \u03b2)\u2019s\nLet \u03c8 def= \u03b1 and \u03c8 = \u03b2 s.t. \u03b2i = \u03b1i (or vice versa). Then we have that:\n\u2022 if both L\u3008\u03c3, \u03b1i\u3009\u2019s (respectively at least one L\u3008\u03c3, \u03b2i\u3009) are assigned true by \u00b5M, then the definition implications of Def(\u03c3, \u03b1) (respectively Def(\u03c3, \u03b2)) is already trivially satisfied;\n\u2022 if at least one L\u3008\u03c3, \u03b1i\u3009 (respectively both L\u3008\u03c3, \u03b2i\u3009\u2019s) is assigned false by \u00b5M, then by (30) L\u3008\u03c3, \u03b1\u3009 (respectively L\u3008\u03c3, \u03b2\u3009) is assigned false by \u00b5\u03b1\u03b2 , which satisfies the definition implication of Def(\u03c3, \u03b1) (respectively Def(\u03c3, \u03b2)).\nThus \u00b5M satisfies the definition implications of all the Def(\u03c3, \u03c8)\u2019s and Def(\u03c3, \u03c8)\u2019s s.t. \u03c3 6\u2208 M.\nOn the whole, \u00b5 |= Def(\u03c3, \u03c8) for every Def(\u03c3, \u03c8). By construction, \u00b5M |= A\u30081, \u03d5\u3009 since \u30081 : \u03d5\u3009 \u2208 M. Therefore \u00b5 |= Km2SAT (\u03d5)."}], "references": [{"title": "Tree-based heuristics in modal theorem proving", "author": ["C. Areces", "R. Gennari", "J. Heguiabehere", "M. de Rijke"], "venue": "In Proc. of ECAI\u201900,", "citeRegEx": "Areces et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Areces et al\\.", "year": 2000}, {"title": "An Empirical Analysis of Optimization Techniques for Terminological Representation Systems or: Making KRIS get a move on", "author": ["F. Baader", "E. Franconi", "B. Hollunder", "B. Nebel", "H. Profitlich"], "venue": "Applied Artificial Intelligence. Special Issue on Knowledge Base Management,", "citeRegEx": "Baader et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Baader et al\\.", "year": 1994}, {"title": "A Terminological Knowledge Representation System with Complete Inference Algorithms", "author": ["F. Baader", "B. Hollunder"], "venue": "In Proc. of First International Workshop on Processing Declarative Knowledge,", "citeRegEx": "Baader and Hollunder,? \\Q1991\\E", "shortCiteRegEx": "Baader and Hollunder", "year": 1991}, {"title": "CEL\u2014a polynomial-time reasoner for life science ontologies", "author": ["F. Baader", "C. Lutz", "B. Suntisrivaraporn"], "venue": "In Proc. of IJCAR\u201906,", "citeRegEx": "Baader et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2006}, {"title": "The Description Logic Handbook: Theory, Implementation, and Applications", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2003}, {"title": "Automata-Based Axiom Pinpointing", "author": ["F. Baader", "R. Pe\u00f1aloza"], "venue": "In Proc. of IJCAR\u201908,", "citeRegEx": "Baader and Pe\u00f1aloza,? \\Q2008\\E", "shortCiteRegEx": "Baader and Pe\u00f1aloza", "year": 2008}, {"title": "Pinpointing in the description logic EL+", "author": ["F. Baader", "R. Pe\u00f1aloza", "B. Suntisrivaraporn"], "venue": "In Proc. of KI 2007,", "citeRegEx": "Baader et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2007}, {"title": "Logics workbench 1.0", "author": ["P. Balsiger", "A. Heuerding", "S. Schwendimann"], "venue": "In Proc. of Tableaux\u201998,", "citeRegEx": "Balsiger et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Balsiger et al\\.", "year": 1998}, {"title": "sKizzo: A Suite to Evaluate and Certify QBFs", "author": ["M. Benedetti"], "venue": "Proc. of CADE-20, Vol. 3632 of LNCS, pp. 369\u2013376. Springer.", "citeRegEx": "Benedetti,? 2005", "shortCiteRegEx": "Benedetti", "year": 2005}, {"title": "Symbolic Model Checking without BDDs", "author": ["A. Biere", "A. Cimatti", "E.M. Clarke", "Y. Zhu"], "venue": "In Proc. of TACAS\u201999,", "citeRegEx": "Biere et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Biere et al\\.", "year": 1999}, {"title": "Constraint Programming for Modelling and Solving Modal Satisfability", "author": ["S. Brand", "R. Gennari", "M. de Rijke"], "venue": "In Proc. of CP 2003,", "citeRegEx": "Brand et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Brand et al\\.", "year": 2003}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Longemann", "D. Loveland"], "venue": "Journal of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam", "year": 1960}, {"title": "An Extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "In Proc. of SAT\u201903,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2004\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2004}, {"title": "Proof Methods for Modal and Intuitionistic Logics", "author": ["M. Fitting"], "venue": "D. Reidel Publishing.", "citeRegEx": "Fitting,? 1983", "shortCiteRegEx": "Fitting", "year": 1983}, {"title": "CRACK", "author": ["E. Franconi"], "venue": "Proc. of Description Logics \u201998, Vol. 11 of CEUR Workshop Proceedings. CEUR-WS.org.", "citeRegEx": "Franconi,? 1998", "shortCiteRegEx": "Franconi", "year": 1998}, {"title": "SAT vs. Translation based decision procedures for modal logics: a comparative evaluation", "author": ["E. Giunchiglia", "F. Giunchiglia", "R. Sebastiani", "A. Tacchella"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Giunchiglia et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2000}, {"title": "SAT-Based Decision Procedures for Classical Modal Logics", "author": ["E. Giunchiglia", "F. Giunchiglia", "A. Tacchella"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Giunchiglia et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2002}, {"title": "Building decision procedures for modal logics from propositional decision procedures - the case study of modal K", "author": ["F. Giunchiglia", "R. Sebastiani"], "venue": "In Proc. of CADE-13,", "citeRegEx": "Giunchiglia and Sebastiani,? \\Q1996\\E", "shortCiteRegEx": "Giunchiglia and Sebastiani", "year": 1996}, {"title": "Building decision procedures for modal logics from propositional decision procedures - the case study of modal K(m)", "author": ["F. Giunchiglia", "R. Sebastiani"], "venue": "Information and Computation,", "citeRegEx": "Giunchiglia and Sebastiani,? \\Q2000\\E", "shortCiteRegEx": "Giunchiglia and Sebastiani", "year": 2000}, {"title": "A new method for testing decision procedures in modal and terminological logics", "author": ["F. Giunchiglia", "M. Roveri", "R. Sebastiani"], "venue": "In Proc. of Description Logics \u201996, Vol. WS-96-05 of AAAI Technical Reports,", "citeRegEx": "Giunchiglia et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 1996}, {"title": "RACER System Description", "author": ["V. Haarslev", "R. Moeller"], "venue": "In Proc. of IJCAR\u201901,", "citeRegEx": "Haarslev and Moeller,? \\Q2001\\E", "shortCiteRegEx": "Haarslev and Moeller", "year": 2001}, {"title": "The effect of bounding the number of primitive propositions and the depth of nesting on the complexity of modal logic", "author": ["J.Y. Halpern"], "venue": "Artificial Intelligence, 75 (3), 361\u2013372.", "citeRegEx": "Halpern,? 1995", "shortCiteRegEx": "Halpern", "year": 1995}, {"title": "A guide to the completeness and complexity for modal logics of knowledge and belief", "author": ["J. Halpern", "Y. Moses"], "venue": "Artificial Intelligence,", "citeRegEx": "Halpern and Moses,? \\Q1992\\E", "shortCiteRegEx": "Halpern and Moses", "year": 1992}, {"title": "A benchmark method for the propositional modal logics K, KT, S4", "author": ["A. Heuerding", "S. Schwendimann"], "venue": "Tech. rep. IAM-96-015,", "citeRegEx": "Heuerding and Schwendimann,? \\Q1996\\E", "shortCiteRegEx": "Heuerding and Schwendimann", "year": 1996}, {"title": "Using an expressive description logic: FaCT or fiction", "author": ["I. Horrocks"], "venue": "Proc. of KR\u201998, pp. 636\u2013647. Morgan Kaufmann.", "citeRegEx": "Horrocks,? 1998", "shortCiteRegEx": "Horrocks", "year": 1998}, {"title": "Optimizing Description Logic Subsumption", "author": ["I. Horrocks", "P.F. Patel-Schneider"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Horrocks and Patel.Schneider,? \\Q1999\\E", "shortCiteRegEx": "Horrocks and Patel.Schneider", "year": 1999}, {"title": "An Analysis of Empirical Testing for Modal Decision Procedures", "author": ["I. Horrocks", "P.F. Patel-Schneider", "R. Sebastiani"], "venue": "Logic Journal of the IGPL,", "citeRegEx": "Horrocks et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2000}, {"title": "MSPASS: Subsumption Testing with SPASS", "author": ["U. Hustadt", "R.A. Schmidt", "C. Weidenbach"], "venue": "In Proc. of Description Logics \u201999,", "citeRegEx": "Hustadt et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 1999}, {"title": "An empirical analysis of modal theorem provers", "author": ["U. Hustadt", "R. Schmidt"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Hustadt and Schmidt,? \\Q1999\\E", "shortCiteRegEx": "Hustadt and Schmidt", "year": 1999}, {"title": "Encoding Plans in Propositional Logic", "author": ["H. Kautz", "D. McAllester", "B. Selman"], "venue": "In Proc. of KR\u201996,", "citeRegEx": "Kautz et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Kautz et al\\.", "year": 1996}, {"title": "The Logical Difference Problem for Description Logic Terminologies", "author": ["B. Konev", "D. Walther", "F. Wolter"], "venue": "In Proc. of IJCAR\u201908,", "citeRegEx": "Konev et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Konev et al\\.", "year": 2008}, {"title": "The computational complexity of provability in systems of modal propositional logic", "author": ["R. Ladner"], "venue": "SIAM Journal on Computing, 6 (3), 467\u2013480.", "citeRegEx": "Ladner,? 1977", "shortCiteRegEx": "Ladner", "year": 1977}, {"title": "Design and Results of Tableaux-99 Non-Classical (Modal) System Competition", "author": ["F. Massacci"], "venue": "Proc. of Tableaux\u201999, Vol. 1617 of LNCS, pp. 14\u201318. Springer\u2013Verlang.", "citeRegEx": "Massacci,? 1999", "shortCiteRegEx": "Massacci", "year": 1999}, {"title": "Single Step Tableaux for modal logics: methodology, computations, algorithms", "author": ["F. Massacci"], "venue": "Journal of Automated Reasoning, 24 (3), 319\u2013364.", "citeRegEx": "Massacci,? 2000", "shortCiteRegEx": "Massacci", "year": 2000}, {"title": "Design and results of TANCS-2000, Automated Reasoning with Analytic Tableaux and Related Methods", "author": ["F. Massacci", "F. Donini"], "venue": "In Proc. of Tableaux", "citeRegEx": "Massacci and Donini,? \\Q2000\\E", "shortCiteRegEx": "Massacci and Donini", "year": 2000}, {"title": "Chaff: Engineering an efficient SAT solver", "author": ["M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "In Proc. of DAC\u201901,", "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "The QBFEVAL Web Portal", "author": ["M. Narizzano", "L. Pulina", "A. Tacchella"], "venue": "In Proc. of JELIA\u201906,", "citeRegEx": "Narizzano et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Narizzano et al\\.", "year": 2006}, {"title": "BDD-Based Decision Procedures for K", "author": ["G. Pan", "U. Sattler", "M.Y. Vardi"], "venue": "In Proc. of CADE-18,", "citeRegEx": "Pan et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Pan et al\\.", "year": 2002}, {"title": "Optimizing a BDD-based modal solver", "author": ["G. Pan", "M.Y. Vardi"], "venue": "In Proc. of CADE-19,", "citeRegEx": "Pan and Vardi,? \\Q2003\\E", "shortCiteRegEx": "Pan and Vardi", "year": 2003}, {"title": "DLP system description", "author": ["P.F. Patel-Schneider"], "venue": "Proc. of Tableaux\u201998, pp. 87\u201389.", "citeRegEx": "Patel.Schneider,? 1998", "shortCiteRegEx": "Patel.Schneider", "year": 1998}, {"title": "A new system and methodology for generating random modal formulae", "author": ["P.F. Patel-Schneider", "R. Sebastiani"], "venue": "In Proc. of IJCAR\u201901,", "citeRegEx": "Patel.Schneider and Sebastiani,? \\Q2001\\E", "shortCiteRegEx": "Patel.Schneider and Sebastiani", "year": 2001}, {"title": "A New General Method to Generate Random Modal Formulae for Testing Decision Procedures", "author": ["P.F. Patel-Schneider", "R. Sebastiani"], "venue": "Journal of Artificial Intelligence Research, (JAIR),", "citeRegEx": "Patel.Schneider and Sebastiani,? \\Q2003\\E", "shortCiteRegEx": "Patel.Schneider and Sebastiani", "year": 2003}, {"title": "SAT Solver Description: Rsat", "author": ["T. Pipatsrisawat", "A. Darwiche"], "venue": null, "citeRegEx": "Pipatsrisawat and Darwiche,? \\Q2006\\E", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2006}, {"title": "Experience building a large, re-usable medical ontology using a description logic with transitivity and concept inclusions", "author": ["A. Rector", "I. Horrocks"], "venue": "In Proc. of Workshop on Ontological Engineering, AAAI Spring Symposium", "citeRegEx": "Rector and Horrocks,? \\Q1997\\E", "shortCiteRegEx": "Rector and Horrocks", "year": 1997}, {"title": "A correspondence theory for terminological logics: preliminary report", "author": ["K.D. Schild"], "venue": "Proc. of IJCAI\u201991, pp. 466\u2013471.", "citeRegEx": "Schild,? 1991", "shortCiteRegEx": "Schild", "year": 1991}, {"title": "Lazy Satisfiability Modulo Theories", "author": ["R. Sebastiani"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation (JSAT), 3, 141\u2013224.", "citeRegEx": "Sebastiani,? 2007", "shortCiteRegEx": "Sebastiani", "year": 2007}, {"title": "Encoding the Satisfiability of Modal and Description Logics into SAT: The Case Study of K(m)/ALC", "author": ["R. Sebastiani", "M. Vescovi"], "venue": "In Proc. of SAT\u201906,", "citeRegEx": "Sebastiani and Vescovi,? \\Q2006\\E", "shortCiteRegEx": "Sebastiani and Vescovi", "year": 2006}, {"title": "Axiom Pinpointing in Lightweight Description Logics via Horn-SAT Encoding and Conflict Analysis", "author": ["R. Sebastiani", "M. Vescovi"], "venue": "In Proc. of CADE-22,", "citeRegEx": "Sebastiani and Vescovi,? \\Q2009\\E", "shortCiteRegEx": "Sebastiani and Vescovi", "year": 2009}, {"title": "From KSAT to Delayed Theory Combination: Exploiting DPLL Outside the SAT Domain", "author": ["R. Sebastiani"], "venue": "Proc. of FroCoS\u201907, Vol. 4720 of LNCS, pp. 28\u201346. Springer. Invited talk.", "citeRegEx": "Sebastiani,? 2007", "shortCiteRegEx": "Sebastiani", "year": 2007}, {"title": "A Hybrid SAT-Based Decision Procedure for Separation Logic with Uninterpreted Functions", "author": ["S.A. Seshia", "S.K. Lahiri", "R.E. Bryant"], "venue": "In Proc. of DAC\u201903,", "citeRegEx": "Seshia et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Seshia et al\\.", "year": 2003}, {"title": "GRASP - A new Search Algorithm for Satisfiability", "author": ["J.P.M. Silva", "K.A. Sakallah"], "venue": "In Proc. of ICCAD\u201996,", "citeRegEx": "Silva and Sakallah,? \\Q1996\\E", "shortCiteRegEx": "Silva and Sakallah", "year": 1996}, {"title": "NCI Thesaurus: A semantic model integrating cancer-related clinical and molecular information", "author": ["N. Sioutos", "S. de Coronado", "M.W. Haber", "F.W. Hartel", "W. Shaiu", "L.W. Wright"], "venue": "Journal of Biomedical Informatics,", "citeRegEx": "Sioutos et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Sioutos et al\\.", "year": 2007}, {"title": "SNOMED RT: A reference terminology for healt care", "author": ["K.A. Spackman", "K. Campbell", "R. Cote"], "venue": "Journal of American Medical Informatics Association (Fall Symposium Supplement),", "citeRegEx": "Spackman et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Spackman et al\\.", "year": 1997}, {"title": "On Solving Presburger and Linear Arithmetic with SAT", "author": ["O. Strichman"], "venue": "Proc. of FMCAD\u201902, Vol. 2517 of LNCS, pp. 160\u2013170. Springer\u2013Verlag.", "citeRegEx": "Strichman,? 2002", "shortCiteRegEx": "Strichman", "year": 2002}, {"title": "Deciding separation formulas with SAT", "author": ["O. Strichman", "S. Seshia", "R. Bryant"], "venue": "In Proc. of CAV\u201902,", "citeRegEx": "Strichman et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Strichman et al\\.", "year": 2002}, {"title": "SAT system description", "author": ["A. Tacchella"], "venue": "Proc. of Description Logics \u201999, Vol. 22 of CEUR Workshop Proceedings, pp. 142\u2013144. CEUR-WS.org.", "citeRegEx": "Tacchella,? 1999", "shortCiteRegEx": "Tacchella", "year": 1999}, {"title": "Gene ontology: Tool for the unification of biology", "author": ["The Gene Ontology Consortium"], "venue": "Nature Genetics, 25, 25\u201329.", "citeRegEx": "Consortium,? 2000", "shortCiteRegEx": "Consortium", "year": 2000}, {"title": "How to optimize proof-search in modal logics: new methods of proving redundancy criteria for sequent calculi", "author": ["A. Voronkov"], "venue": "ACM Transactions on Computational Logic, 2 (2), 182\u2013215.", "citeRegEx": "Voronkov,? 2001", "shortCiteRegEx": "Voronkov", "year": 2001}, {"title": "The quest for efficient boolean satisfiability solvers", "author": ["L. Zhang", "S. Malik"], "venue": "In Proc. of CAV\u201902,", "citeRegEx": "Zhang and Malik,? \\Q2002\\E", "shortCiteRegEx": "Zhang and Malik", "year": 2002}], "referenceMentions": [{"referenceID": 32, "context": "For this reason, the problem of automated reasoning in modal and description logics has been thoroughly investigated (e.g., Fitting, 1983; Ladner, 1977; Baader & Hollunder, 1991; Halpern & Moses, 1992; Baader, Franconi, Hollunder, Nebel, & Profitlich, 1994; Massacci, 2000).", "startOffset": 117, "endOffset": 273}, {"referenceID": 34, "context": "For this reason, the problem of automated reasoning in modal and description logics has been thoroughly investigated (e.g., Fitting, 1983; Ladner, 1977; Baader & Hollunder, 1991; Halpern & Moses, 1992; Baader, Franconi, Hollunder, Nebel, & Profitlich, 1994; Massacci, 2000).", "startOffset": 117, "endOffset": 273}, {"referenceID": 14, "context": ", Fitting, 1983; Ladner, 1977; Baader & Hollunder, 1991; Halpern & Moses, 1992; Baader, Franconi, Hollunder, Nebel, & Profitlich, 1994; Massacci, 2000). In particular, the research in modal and description logics has followed two parallel routes until the seminal work of Schild (1991), which proved that the core modal logic Km and the core description logic ALC are one a notational variant of the other.", "startOffset": 2, "endOffset": 286}, {"referenceID": 14, "context": "\u2022 The \u201cclassic\u201d tableau-based approach (Fitting, 1983; Baader & Hollunder, 1991; Massacci, 2000) is based on the construction of propositional tableau branches, which are recursively expanded on demand by generating successor nodes in a candidate Kripke model.", "startOffset": 39, "endOffset": 96}, {"referenceID": 34, "context": "\u2022 The \u201cclassic\u201d tableau-based approach (Fitting, 1983; Baader & Hollunder, 1991; Massacci, 2000) is based on the construction of propositional tableau branches, which are recursively expanded on demand by generating successor nodes in a candidate Kripke model.", "startOffset": 39, "endOffset": 96}, {"referenceID": 1, "context": "Kris (Baader & Hollunder, 1991; Baader et al., 1994), Crack (Franconi, 1998), LWB (Balsiger, Heuerding, & Schwendimann, 1998) were among the main representative tools of this approach.", "startOffset": 5, "endOffset": 52}, {"referenceID": 15, "context": ", 1994), Crack (Franconi, 1998), LWB (Balsiger, Heuerding, & Schwendimann, 1998) were among the main representative tools of this approach.", "startOffset": 15, "endOffset": 31}, {"referenceID": 56, "context": "KSAT (Giunchiglia & Sebastiani, 1996), ESAT (Giunchiglia, Giunchiglia, & Tacchella, 2002) and *SAT (Tacchella, 1999), are the representative tools of this approach.", "startOffset": 99, "endOffset": 116}, {"referenceID": 0, "context": "\u2022 In the translational approach (Hustadt & Schmidt, 1999; Areces, Gennari, Heguiabehere, & de Rijke, 2000) the modal formula is encoded into first-order logic (FOL), and the encoded formula can be decided efficiently by a FOL theorem prover (Areces et al., 2000).", "startOffset": 241, "endOffset": 262}, {"referenceID": 25, "context": ", tools like FaCT, DLP, and Racer are most often called \u201ctableau-based\u201d, although they use a DPLL-like algorithm instead of propositional tableaux for handling the propositional component of reasoning (Horrocks, 1998; Patel-Schneider, 1998; Horrocks & Patel-Schneider, 1999; Haarslev & Moeller, 2001).", "startOffset": 201, "endOffset": 300}, {"referenceID": 40, "context": ", tools like FaCT, DLP, and Racer are most often called \u201ctableau-based\u201d, although they use a DPLL-like algorithm instead of propositional tableaux for handling the propositional component of reasoning (Horrocks, 1998; Patel-Schneider, 1998; Horrocks & Patel-Schneider, 1999; Haarslev & Moeller, 2001).", "startOffset": 201, "endOffset": 300}, {"referenceID": 39, "context": "\u2022 Pan and Vardi (2003) presented also an encoding of K-satisfiability into QBF-satisfiability (which is PSpace-complete too), combined with the use of a state-of-the-art QBF (Quantified Boolean Formula) solver.", "startOffset": 2, "endOffset": 23}, {"referenceID": 33, "context": "A significant amount of benchmarks formulas have been produced for testing the effectiveness of the different techniques (Halpern & Moses, 1992; Giunchiglia, Roveri, & Sebastiani, 1996; Heuerding & Schwendimann, 1996; Horrocks, Patel-Schneider, & Sebastiani, 2000; Massacci, 1999; Patel-Schneider & Sebastiani, 2001, 2003).", "startOffset": 121, "endOffset": 322}, {"referenceID": 54, "context": "Effective encodings into SAT have been proposed also for the satisfiability problems in quantifier-free FOL theories which are of interest for formal verification (Strichman, Seshia, & Bryant, 2002; Seshia, Lahiri, & Bryant, 2003; Strichman, 2002).", "startOffset": 163, "endOffset": 247}, {"referenceID": 32, "context": "In theory, the task may look hopeless because of worst-case complexity issues: in fact, with few exceptions, the satisfiability problem in most modal and description logics is not in NP, typically being PSpace-complete or even harder \u2014PSpace-complete for Km (Ladner, 1977; Halpern & Moses, 1992)\u2014 so that the encoding is in worst-case non polynomial.", "startOffset": 258, "endOffset": 295}, {"referenceID": 34, "context": "In order to make our presentation more uniform, and to avoid considering the polarity of subformulas, we adopt the traditional representation of Km-formulas (introduced, as far as we know, by Fitting, 1983 and widely used in literature, e.g. Fitting, 1983; Massacci, 2000; Donini & Massacci, 2000) from the following table:", "startOffset": 157, "endOffset": 297}, {"referenceID": 32, "context": "The problem of determining the Km-satisfiability of a Km-formula \u03c6 is decidable and PSPACE-complete (Ladner, 1977; Halpern & Moses, 1992), even restricting the language to a single Boolean atom (i.", "startOffset": 100, "endOffset": 137}, {"referenceID": 22, "context": "The problem of determining the Km-satisfiability of a Km-formula \u03c6 is decidable and PSPACE-complete (Ladner, 1977; Halpern & Moses, 1992), even restricting the language to a single Boolean atom (i.e., A = {A1}; Halpern, 1995); if we impose a bound on the modal depth of the Km-formulas, the problem reduces to NP-complete (Halpern, 1995).", "startOffset": 194, "endOffset": 225}, {"referenceID": 22, "context": ", A = {A1}; Halpern, 1995); if we impose a bound on the modal depth of the Km-formulas, the problem reduces to NP-complete (Halpern, 1995).", "startOffset": 123, "endOffset": 138}, {"referenceID": 38, "context": "A Km-formula is said to be in Box Normal Form (BNF) (Pan et al., 2002; Pan & Vardi, 2003) if it is written in terms of the symbols 2r, \u00ac2r, \u2227, \u2228, and propositional literals Ai, \u00acAi (i.", "startOffset": 52, "endOffset": 89}, {"referenceID": 22, "context": "The problem of determining the Km-satisfiability of a Km-formula \u03c6 is decidable and PSPACE-complete (Ladner, 1977; Halpern & Moses, 1992), even restricting the language to a single Boolean atom (i.e., A = {A1}; Halpern, 1995); if we impose a bound on the modal depth of the Km-formulas, the problem reduces to NP-complete (Halpern, 1995). For a more detailed description on Km\u2014 including, e.g., axiomatic characterization, decidability and complexity results \u2014 we refer the reader to the works of Halpern and Moses (1992), and Halpern (1995).", "startOffset": 115, "endOffset": 522}, {"referenceID": 22, "context": "The problem of determining the Km-satisfiability of a Km-formula \u03c6 is decidable and PSPACE-complete (Ladner, 1977; Halpern & Moses, 1992), even restricting the language to a single Boolean atom (i.e., A = {A1}; Halpern, 1995); if we impose a bound on the modal depth of the Km-formulas, the problem reduces to NP-complete (Halpern, 1995). For a more detailed description on Km\u2014 including, e.g., axiomatic characterization, decidability and complexity results \u2014 we refer the reader to the works of Halpern and Moses (1992), and Halpern (1995). A Km-formula is said to be in Negative Normal Form (NNF) if it is written in terms of the symbols 2r, 3r, \u2227, \u2228 and propositional literals Ai, \u00acAi (i.", "startOffset": 115, "endOffset": 542}, {"referenceID": 11, "context": "Most state-of-the-art SAT procedures are evolutions of the DPLL procedure (Davis & Putnam, 1960; Davis et al., 1962).", "startOffset": 74, "endOffset": 116}, {"referenceID": 11, "context": "Most state-of-the-art SAT procedures are evolutions of the DPLL procedure (Davis & Putnam, 1960; Davis et al., 1962). A high-level schema of a modern DPLL engine, adapted from the one presented by Zhang and Malik (2002), is reported in Figure 1.", "startOffset": 97, "endOffset": 220}, {"referenceID": 36, "context": "Notably, modern DPLL implementations implement techniques, like the two-watchedliteral scheme, which allow for extremely efficient handling of BCP (Moskewicz et al., 2001; Zhang & Malik, 2002).", "startOffset": 147, "endOffset": 192}, {"referenceID": 11, "context": "Old versions of DPLL used to implement also the Pure-Literal Rule (PLR) (Davis et al., 1962): when one proposition occurs only positively (resp.", "startOffset": 72, "endOffset": 92}, {"referenceID": 34, "context": "We borrow some notation from the Single Step Tableau (SST) framework (Massacci, 2000; Donini & Massacci, 2000).", "startOffset": 69, "endOffset": 110}, {"referenceID": 33, "context": "Moreover, following what done by Massacci (2000), we assume that, for each \u03c3, the Def(\u03c3, \u03c8)\u2019s are expanded in the order: \u03b1/\u03b2, \u03c0, \u03bd.", "startOffset": 33, "endOffset": 49}, {"referenceID": 34, "context": "5 Intuitively, it is easy to see that Km2SAT (\u03c6) mimics the construction of an SST tableau expansion (Massacci, 2000; Donini & Massacci, 2000).", "startOffset": 101, "endOffset": 142}, {"referenceID": 22, "context": "This is in accordance to what was stated by Halpern and Moses (1992). Example 3.", "startOffset": 44, "endOffset": 69}, {"referenceID": 34, "context": "1 Pre-conversion into BNF Many systems use to pre-convert the input Km-formulas into NNF (e.g., Baader et al., 1994; Massacci, 2000).", "startOffset": 89, "endOffset": 132}, {"referenceID": 38, "context": "In our approach, instead, we pre-convert them into BNF (like, e.g., Giunchiglia & Sebastiani, 1996; Pan et al., 2002).", "startOffset": 55, "endOffset": 117}, {"referenceID": 18, "context": "In order to cope with this problem, as done by Giunchiglia and Sebastiani (1996), we apply some normalization steps to modal atoms with the intent of rewriting as many as possible syntactically-different but semantically-equivalent modal atoms into syntacticallyidentical ones.", "startOffset": 47, "endOffset": 81}, {"referenceID": 39, "context": "7 On-the-fly Pure-Literal Reduction Another technique, evolved from that proposed by Pan and Vardi (2003), applies PureLiteral Reduction (PLR) on-the-fly during the construction of Km2SAT (\u03c6).", "startOffset": 85, "endOffset": 106}, {"referenceID": 38, "context": "In KBDD (Pan et al., 2002; Pan & Vardi, 2003), the Pure-Literal Reduction is a preprocessing step which is applied to the input modal formula, either at global level (i.", "startOffset": 8, "endOffset": 45}, {"referenceID": 38, "context": "We remark the differences between PLR and the Pure-Literal Reduction technique proposed by Pan and Vardi (2003). In KBDD (Pan et al.", "startOffset": 91, "endOffset": 112}, {"referenceID": 38, "context": "In KBDD (Pan et al., 2002; Pan & Vardi, 2003), the Pure-Literal Reduction is a preprocessing step which is applied to the input modal formula, either at global level (i.e. looking for pure-polarity primitive propositions for the whole formula) or, more effectively, at different modal depths (i.e. looking for pure-polarity primitive propositions for the subformulas at the same nesting level of modal operators). Our technique is much more fine-grained, as PLR is applied on-the-fly with a single-state granularity, obtaining a much stronger reduction effect. Example 4.9. Consider again the BNF Km-formula \u03c6bnf discussed in Examples 4.1 and 4.8: \u03c6bnf = (\u00ac2\u00acA1\u2228\u00ac2(\u00acA2\u2227\u00acA3)) \u2227 2\u00acA1 \u2227 2\u00acA2 \u2227 2\u00acA3. It is immediate to see that all primitive propositions A1, A2, A3 occur at every modal depth with both polarities, so that the technique of Pan and Vardi (2003) produces no effect on this formula.", "startOffset": 9, "endOffset": 858}, {"referenceID": 22, "context": "For the sake of better readability, here we adopt the description given by Halpern and Moses (1992) without converting the formulas into BNF.", "startOffset": 75, "endOffset": 100}, {"referenceID": 24, "context": "The unsatisfiable counterpart formulas proposed by Heuerding and Schwendimann (1996) (whose negations are the valid formulas called k branch p in the previously-mentioned benchmark suite, which are exposed in more details in Section 5.", "startOffset": 51, "endOffset": 85}, {"referenceID": 27, "context": "These formulas are very pathological for many approaches (Giunchiglia & Sebastiani, 2000; Giunchiglia, Giunchiglia, Sebastiani, & Tacchella, 2000; Horrocks et al., 2000).", "startOffset": 57, "endOffset": 169}, {"referenceID": 56, "context": "3 (Tacchella, 1999) as the best representatives of the tableaux/DPLL-based tools, Mspass v 1.", "startOffset": 2, "endOffset": 19}, {"referenceID": 28, "context": "3 (Hustadt & Schmidt, 1999; Hustadt et al., 1999) 21 as the best representative of the FOL-encoding approach, KBDD (unique version) (Pan et al.", "startOffset": 2, "endOffset": 49}, {"referenceID": 38, "context": ", 1999) 21 as the best representative of the FOL-encoding approach, KBDD (unique version) (Pan et al., 2002; Pan & Vardi, 2003) 22 as the representative of the automata-theoretic approach.", "startOffset": 90, "endOffset": 127}, {"referenceID": 8, "context": "2 QBF solver (Benedetti, 2005), which turned out to be by far 24 the best QBF solver on our benchmarks among the freely-available QBF solvers from the QBF2006 competition (Narizzano, Pulina, & Tacchella, 2006).", "startOffset": 13, "endOffset": 30}, {"referenceID": 27, "context": "Other tools like leanK, 2KE, LWB, Kris are not competitive with the ones listed above (Horrocks et al., 2000).", "startOffset": 86, "endOffset": 109}, {"referenceID": 16, "context": "KSAT (Giunchiglia & Sebastiani, 1996, 2000; Giunchiglia et al., 2000) has been reimplemented into *SAT.", "startOffset": 5, "endOffset": 69}, {"referenceID": 27, "context": "We have performed our empirical evaluation on three different well-known benchmarks suites of Km/ALC problems: the LWB (Heuerding & Schwendimann, 1996), the random 2m-CNF (Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003) and the TANCS 2000 (Massacci & Donini, 2000) benchmark suites.", "startOffset": 171, "endOffset": 230}, {"referenceID": 24, "context": "For a discussion on this benchmark suite, we refer the reader to the work of Heuerding and Schwendimann (1996) and of Horrocks et al.", "startOffset": 77, "endOffset": 111}, {"referenceID": 24, "context": "For a discussion on this benchmark suite, we refer the reader to the work of Heuerding and Schwendimann (1996) and of Horrocks et al. (2000).", "startOffset": 77, "endOffset": 141}, {"referenceID": 16, "context": "This is a generalization of the well-known random k-SAT test methods, and is the final result of a long discussion in the communities of modal and description logics on how to to obtain significant and flawless random benchmarks for modal/description logics (Giunchiglia & Sebastiani, 1996; Hustadt & Schmidt, 1999; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).", "startOffset": 258, "endOffset": 400}, {"referenceID": 27, "context": "This is a generalization of the well-known random k-SAT test methods, and is the final result of a long discussion in the communities of modal and description logics on how to to obtain significant and flawless random benchmarks for modal/description logics (Giunchiglia & Sebastiani, 1996; Hustadt & Schmidt, 1999; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).", "startOffset": 258, "endOffset": 400}, {"referenceID": 22, "context": "2 The Random 2m-CNF Benchmark Suite As a second group of benchmark formulas, we have selected the random 2m-CNF testbed described by Horrocks et al. (2000), and Patel-Schneider and Sebastiani (2003).", "startOffset": 133, "endOffset": 156}, {"referenceID": 22, "context": "2 The Random 2m-CNF Benchmark Suite As a second group of benchmark formulas, we have selected the random 2m-CNF testbed described by Horrocks et al. (2000), and Patel-Schneider and Sebastiani (2003). This is a generalization of the well-known random k-SAT test methods, and is the final result of a long discussion in the communities of modal and description logics on how to to obtain significant and flawless random benchmarks for modal/description logics (Giunchiglia & Sebastiani, 1996; Hustadt & Schmidt, 1999; Giunchiglia et al.", "startOffset": 133, "endOffset": 199}, {"referenceID": 27, "context": "Notice that typically the smaller is p, the harder is the problem (Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).", "startOffset": 66, "endOffset": 125}, {"referenceID": 25, "context": "Following the methodology proposed by Horrocks et al. (2000), and by Patel-Schneider and Sebastiani (2003), we have fixed m = 1, k = 3 and 100 samples per point in all tests, and we have selected two groups: an \u201ceasier\u201d one, with d = 1, p = 0.", "startOffset": 38, "endOffset": 61}, {"referenceID": 25, "context": "Following the methodology proposed by Horrocks et al. (2000), and by Patel-Schneider and Sebastiani (2003), we have fixed m = 1, k = 3 and 100 samples per point in all tests, and we have selected two groups: an \u201ceasier\u201d one, with d = 1, p = 0.", "startOffset": 38, "endOffset": 107}, {"referenceID": 16, "context": ") This seems to confirm the fact that the easy-hard-easy pattern of random k-SAT extends also to 2m-CNF, as already observed in literature (Giunchiglia & Sebastiani, 1996, 2000; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).", "startOffset": 139, "endOffset": 262}, {"referenceID": 27, "context": ") This seems to confirm the fact that the easy-hard-easy pattern of random k-SAT extends also to 2m-CNF, as already observed in literature (Giunchiglia & Sebastiani, 1996, 2000; Giunchiglia et al., 2000; Horrocks et al., 2000; Patel-Schneider & Sebastiani, 2003).", "startOffset": 139, "endOffset": 262}, {"referenceID": 33, "context": "Notice that the classification of the benchmark problems in \u201ceasy\u201d, \u201cmedium\u201d and \u201chard\u201d given by Massacci and Donini (2000) is based on the translation schema used to produce every modal problem and refers to its \u201creasoning component\u201d, but it is not necessarily related to other components (like, e.", "startOffset": 97, "endOffset": 124}, {"referenceID": 16, "context": "4 Discussion As highlighted by Giunchiglia et al. (2000), and Horrocks et al.", "startOffset": 31, "endOffset": 57}, {"referenceID": 16, "context": "4 Discussion As highlighted by Giunchiglia et al. (2000), and Horrocks et al. (2000), the satisfiability problem in modal logics like Km is characterized by the alternation of two orthogonal components of reasoning: a Boolean component, performing Boolean reasoning within each state, and a modal component, generating the successor states of each state.", "startOffset": 31, "endOffset": 85}, {"referenceID": 16, "context": "The k branch n formulas are very hard from the perspective of modal reasoning, because they require finding one modelM with 2\u22121 states (Halpern & Moses, 1992), but no Boolean reasoning within each state is really required (Giunchiglia et al., 2000; Horrocks et al., 2000): e.", "startOffset": 222, "endOffset": 271}, {"referenceID": 27, "context": "The k branch n formulas are very hard from the perspective of modal reasoning, because they require finding one modelM with 2\u22121 states (Halpern & Moses, 1992), but no Boolean reasoning within each state is really required (Giunchiglia et al., 2000; Horrocks et al., 2000): e.", "startOffset": 222, "endOffset": 271}, {"referenceID": 53, "context": ", 2005) are expressive enough to describe several important bio-medical ontologies such as SNoMed (Spackman et al., 1997), NCI (Sioutos et al.", "startOffset": 98, "endOffset": 121}, {"referenceID": 52, "context": ", 1997), NCI (Sioutos et al., 2007), the Gene Ontology (The Gene Ontology Consortium, 2000) and the majority of Galen (Rector & Horrocks, 1997).", "startOffset": 13, "endOffset": 35}, {"referenceID": 6, "context": ", axiom pinpointing (Baader et al., 2007; Baader & Pe\u00f1aloza, 2008) and logical difference between terminologies (Konev, Walther, & Wolter, 2008).", "startOffset": 20, "endOffset": 66}, {"referenceID": 1, "context": "Our current investigation, however, focuses on the lightweight logics of Baader et al. (2005). We have investigated (and we are currently enhancing) an encoding of the main reasoning services in EL and EL+ into Horn-SAT, which allows for reasoning efficiently on the (often huge) bio-medical ontologies mentioned in Section 6, and for handling the more sophisticated inference problems mentioned there (e.", "startOffset": 73, "endOffset": 94}], "year": 2009, "abstractText": "In the last two decades, modal and description logics have been applied to numerous areas of computer science, including knowledge representation, formal verification, database theory, distributed computing and, more recently, semantic web and ontologies. For this reason, the problem of automated reasoning in modal and description logics has been thoroughly investigated. In particular, many approaches have been proposed for efficiently handling the satisfiability of the core normal modal logic Km, and of its notational variant, the description logic ALC. Although simple in structure, Km/ALC is computationally very hard to reason on, its satisfiability being PSpace-complete. In this paper we start exploring the idea of performing automated reasoning tasks in modal and description logics by encoding them into SAT, so that to be handled by stateof-the-art SAT tools; as with most previous approaches, we begin our investigation from the satisfiability in Km. We propose an efficient encoding, and we test it on an extensive set of benchmarks, comparing the approach with the main state-of-the-art tools available. Although the encoding is necessarily worst-case exponential, from our experiments we notice that, in practice, this approach can handle most or all the problems which are at the reach of the other approaches, with performances which are comparable with, or even better than, those of the current state-of-the-art tools. 1. Motivations and Goals In the last two decades, modal and description logics have provided an essential framework for many applications in numerous areas of computer science, including artificial intelligence, formal verification, database theory, distributed computing and, more recently, semantic web and ontologies. For this reason, the problem of automated reasoning in modal and description logics has been thoroughly investigated (e.g., Fitting, 1983; Ladner, 1977; Baader & Hollunder, 1991; Halpern & Moses, 1992; Baader, Franconi, Hollunder, Nebel, & Profitlich, 1994; Massacci, 2000). In particular, the research in modal and description logics has followed two parallel routes until the seminal work of Schild (1991), which proved that the core modal logic Km and the core description logic ALC are one a notational variant of the other. Since then, analogous results have been produced for a bunch of other logics, so that, nowadays the two research lines have mostly merged into one research flow. Many approaches have been proposed for efficiently reasoning in modal and description logics, starting from the problem of checking the satisfiability in the core normal modal logic Km and in its notational variant, the description logic ALC (hereafter simply \u201cKm\u201d). We classify them as follows. c \u00a92009 AI Access Foundation. All rights reserved. Sebastiani & Vescovi \u2022 The \u201cclassic\u201d tableau-based approach (Fitting, 1983; Baader & Hollunder, 1991; Massacci, 2000) is based on the construction of propositional tableau branches, which are recursively expanded on demand by generating successor nodes in a candidate Kripke model. Kris (Baader & Hollunder, 1991; Baader et al., 1994), Crack (Franconi, 1998), LWB (Balsiger, Heuerding, & Schwendimann, 1998) were among the main representative tools of this approach. \u2022 The DPLL-based approach (Giunchiglia & Sebastiani, 1996, 2000) differs from the previous one mostly in the fact that a Davis-Putnam-Logemann-Loveland (DPLL) procedure, which treats the modal subformulas as propositions, is used instead of the classic propositional tableaux procedure at each nesting level of the modal operators. KSAT (Giunchiglia & Sebastiani, 1996), ESAT (Giunchiglia, Giunchiglia, & Tacchella, 2002) and *SAT (Tacchella, 1999), are the representative tools of this approach. These two approaches merged into the \u201cmodern\u201d tableaux-based approach, which has been extended to work with more expressive description logics and to provide more sophisticate reasoning functions. Among the tools employing this approach, we recall FaCT/FaCT++ and DLP (Horrocks & Patel-Schneider, 1999), and Racer (Haarslev & Moeller, 2001). 1 \u2022 In the translational approach (Hustadt & Schmidt, 1999; Areces, Gennari, Heguiabehere, & de Rijke, 2000) the modal formula is encoded into first-order logic (FOL), and the encoded formula can be decided efficiently by a FOL theorem prover (Areces et al., 2000). Mspass (Hustadt, Schmidt, & Weidenbach, 1999) is the most representative tool of this approach. \u2022 The CSP-based approach (Brand, Gennari, & de Rijke, 2003) differs from the tableauxbased and DPLL-based ones mostly in the fact that a CSP (Constraint Satisfaction Problem) engine is used instead of tableaux/DPLL. KCSP is the only representative tool of this approach. \u2022 In the Inverse-method approach (Voronkov, 1999, 2001), a search procedure is based on the \u201cinverted\u201d version of a sequent calculus (which can be seen as a modalized version of propositional resolution). K K(Voronkov, 1999) is the only representative tool of this approach. \u2022 In the Automata-theoretic approach, (a symbolic representation based on BDDs \u2013 Binary Decision Diagrams \u2013 of) a tree automaton accepting all the tree models of the input formula is implicitly built and checked for emptiness (Pan, Sattler, & Vardi, 2002; Pan & Vardi, 2003). KBDD (Pan & Vardi, 2003) is the only representative tool of this approach. 1. Notice that there is not an universal agreement on the terminology \u201ctableaux-based\u201d and \u201cDPLL-based\u201d. E.g., tools like FaCT, DLP, and Racer are most often called \u201ctableau-based\u201d, although they use a DPLL-like algorithm instead of propositional tableaux for handling the propositional component of reasoning (Horrocks, 1998; Patel-Schneider, 1998; Horrocks & Patel-Schneider, 1999; Haarslev & Moeller, 2001).", "creator": " TeX output 2009.06.22:1519"}}}