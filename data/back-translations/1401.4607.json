{"id": "1401.4607", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Jan-2014", "title": "Reformulating the Situation Calculus and the Event Calculus in the General Theory of Stable Models and in Answer Set Programming", "abstract": "Circulation and logic programs under the semantics of stable models are two well-known non-monotonous formalisms. The former served as the basis of classical logical action formalisms such as situational calculus, event calculus, and temporal action logic; the latter as the basis of a family of action languages such as language A and several of its descendants. Based on the discovery that transcription and stable model semantics agree on a class of canonical formulas, we reformulate situational calculus and event calculus in the general theory of stable models. In addition, we present a translation that further transforms the reformulations into response programs so that efficient solutions can be applied to calculus of situations and event calculus.", "histories": [["v1", "Sat, 18 Jan 2014 21:11:15 GMT  (495kb)", "http://arxiv.org/abs/1401.4607v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["joohyung lee", "ravi palla"], "accepted": false, "id": "1401.4607"}, "pdf": {"name": "1401.4607.pdf", "metadata": {"source": "CRF", "title": "Reformulating the Situation Calculus and the Event Calculus in the General Theory of Stable Models and in Answer Set Programming", "authors": ["Joohyung Lee", "Ravi Palla"], "emails": ["joolee@asu.edu", "Ravi.Palla@asu.edu"], "sections": [{"heading": "1. Introduction", "text": "Circumscription (McCarthy, 1980, 1986) and logic programs under the stable model semantics (Gelfond & Lifschitz, 1988) are two well-known nonmonotonic formalisms. As one of the oldest nonmonotonic formalisms, circumscription has found many applications in commonsense reasoning and model-based diagnoses (e.g., McCarthy, 1986; Shanahan, 1995; Besnard & Cordier, 1994). The stable model semantics is the mathematical basis of Answer Set Programming (ASP) (Marek & Truszczyn\u0301ski, 1999; Niemela\u0308, 1999; Lifschitz, 2008), which is being widely applied thanks to the availability of several efficient implementations, known as answer set solvers.\nWhile the two nonmonotonic formalisms have been applied to overlapping classes of problems, minimal model reasoning ensured by circumscription does not coincide with stable model reasoning. Moreover, these formalisms have different roots. While circumscription is defined in terms of translation into classical (second-order) logic, stable models proposed by Gelfond and Lifschitz (1988) are defined in terms of grounding and fixpoints in the style of Reiter\u2019s default logic (Reiter, 1980). These differences in part account for the fact that the two formalisms have formed rather disparate traditions in knowledge representation research. In particular, in the area of temporal reasoning, the former has served as a basis of classical logic based action calculi, such as the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001), the event calculus (Shanahan, 1995) and temporal action logics (Doherty,\nc\u00a92012 AI Access Foundation. All rights reserved.\nGustafsson, Karlsson, & Kvarnstro\u0308m, 1998), whereas the latter has served as a basis of a family of action languages, such as language A (Gelfond & Lifschitz, 1998) and several of its descendants which can be translated into logic programs under the stable model semantics.\nHowever, a recent generalization of the stable model semantics shed new light on the relationship between circumscription and stable models. The first-order stable model semantics defined by Ferraris, Lee and Lifschitz (2007, 2011) characterizes the stable models of a first-order sentence as the models (in the sense of first-order logic) of the sentence that satisfy the \u201cstability\u201d condition, expressed by a second-order formula that is similar to the one used to define circumscription. Since logic programs are viewed as a special class of first-order sentences under the stable model semantics, this definition extends the stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without limiting attention to Herbrand models. Essentially the same characterization was independently given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992). These definitions are also equivalent to the definition of Quantified Equilibrium Logic given by Pearce and Valverde (2005), which is defined in terms of the logic of Here-and-There (Heyting, 1930).\nThe new definition of a stable model motivates us to investigate the relationship between stable model reasoning and minimal model reasoning. In particular, we focus on their relationship in the area of temporal reasoning. We show how the situation calculus and the event calculus can be reformulated in the first-order stable model semantics, and further in ASP. This is not only theoretically interesting, but also practically useful as it allows us to leverage efficient answer set solvers for computing circumscriptive action theories.\nFor this, we develop two technical results. First, we show that circumscription and the first-order stable model semantics coincide on the class of canonical formulas. This is the largest syntactic class identified so far on which the two semantics coincide, and is general enough to cover several circumscriptive action formalisms, such as the situation calculus, the event calculus, and temporal action logics. The result allows us to reformulate those action formalisms in the first-order stable model semantics. While minimal model reasoning sometimes leads to unintuitive results, those circumscriptive action formalisms are carefully designed to avoid such cases, and our result implies that minimal model reasoning in those action formalisms can also be viewed as stable model reasoning.\nSecond, we identify a class of almost universal formulas, which can be turned into the syntax of a logic program while preserving stable models. It turns out that the reformulations of the situation calculus and the event calculus in the first-order stable model semantics fall into this class of formulas. We introduce system f2lp that turns formulas in this class to logic programs, and, in conjunction with the result on canonical formulas, use the combination of f2lp and answer set solvers to compute the situation calculus and the event calculus.\nOur work makes explicit the relationship between classical logic and logic program traditions in temporal reasoning. Interestingly, the development of the event calculus has spanned over both traditions. The original version of the event calculus (Kowalski & Sergot, 1986) was formulated in logic programs, but not under the stable model semantics (that was the time before the invention of the stable model semantics). More extensive developments have been later carried out on the classical logic foundation via circumscription (e.g., Shanahan, 1995, 1997, 1999; Miller & Shanahan, 1999; Mueller, 2004), but the relation to\nthe logic program formulation remained implicit. Based on the reduction of circumscription to completion, SAT-based event calculus systems were implemented, one by Shanahan and Witkowski (2004) and another by Mueller (2004). The latter system is called the dec reasoner,1 which outperforms the former thanks to a more efficient and general compilation method into propositional logic. While the system handles a large fragment of the event calculus, it still cannot handle recursive and disjunctive axioms since completion cannot be applied to such axioms. Our ASP-based approach on the other hand can handle the full version of the event calculus under the assumption that the domain is given and finite. Thanks to the efficiency of ASP solvers, our experiments indicate that the ASP-based event calculus reasoner is significantly faster than the dec reasoner (Appendix B).\nSimilar to the logic programming tradition of the event calculus, the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001) can be implemented in Prolog, based on the fact that Clark\u2019s completion semantics accounts for definitional axioms. But unlike the event calculus, to the best of our knowledge, efficient propositional solvers have not been applied to directly compute the models of situation calculus theories. In this paper, we reformulate Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001) in the first-order stable model semantics and in ASP. For basic action theories, we also provide an ASP-based encoding method that obtains Reiter\u2019s successor state axioms from the effect axioms and the generic inertia axioms adopted in ASP, the idea of which is close to Reiter\u2019s frame default (1980).\nThe paper is organized as follows. The next section reviews the definitions of circumscription and the first-order stable model semantics, and presents the definition of a canonical formula. Based on this, Sections 3 and 4 reformulate the event calculus and the situation calculus in the first-order stable model semantics. Section 5 shows a translation that turns almost universal formulas into logic programs that can be accepted by ASP solvers. Sections 6 and 7 use this result to turn the reformulations of the event calculus and the situation calculus given in Sections 3 and 4 into the input language of ASP solvers. Complete proofs are given in Appendix C."}, {"heading": "2. Circumscription and First-Order Stable Model Semantics", "text": "We assume the following set of primitive propositional connectives and quantifiers:\n\u22a5 (falsity), \u2227, \u2228, \u2192, \u2200, \u2203 .\nWe understand \u00acF as an abbreviation of F \u2192 \u22a5; symbol > stands for \u22a5 \u2192 \u22a5, and F \u2194 G stands for (F \u2192 G) \u2227 (G\u2192 F )."}, {"heading": "2.1 Review: Circumscription", "text": "Let p be a list of distinct predicate constants p1, . . . , pn, and let u be a list of distinct predicate variables u1, . . . , un. By u \u2264 p we denote the conjunction of the formulas \u2200x(ui(x) \u2192 pi(x)) for all i = 1, . . . n, where x is a list of distinct object variables whose length is the same as the arity of pi. Expression u < p stands for (u \u2264 p) \u2227 \u00ac(p \u2264 u). For\n1. http://decreasoner.sourceforge.net\ninstance, if p and q are unary predicate constants then (u, v) < (p, q) is \u2200x(u(x)\u2192 p(x)) \u2227 \u2200x(v(x)\u2192 q(x)) \u2227 \u00ac ( \u2200x(p(x)\u2192 u(x)) \u2227 \u2200x(q(x)\u2192 v(x)) ) .\nCircumscription is defined in terms of the CIRC operator with minimized predicates. For any first-order formula F , expression CIRC[F ; p] stands for the second-order formula\nF \u2227 \u00ac\u2203u((u < p) \u2227 F (u)),\nwhere F (u) is the formula obtained from F by substituting ui for pi. When F is a sentence (i.e., a formula with no free variables), intuitively, the models of CIRC[F ; p] are the models of F that are \u201cminimal\u201d on p.\nThe definition is straightforwardly extended to the case when F is a many-sorted firstorder formula (Lifschitz, 1994, Section 2.4), which is the language that the event calculus and the situation calculus are based on."}, {"heading": "2.2 Review: First-Order Stable Model Semantics", "text": "This review follows the definition by Ferraris et al. (2011). There, the stable models are defined in terms of the SM operator, whose definition is similar to the CIRC operator in the previous section. For any first-order formula F and any finite list of predicate constants p = (p1, . . . , pn), formula SM[F ; p] is defined as\nF \u2227 \u00ac\u2203u((u < p) \u2227 F \u2217(u)),\nwhere u is defined the same as in CIRC[F ; p], and F \u2217(u) is defined recursively as follows:\n\u2022 pi(t)\u2217 = ui(t) for any list t of terms;\n\u2022 F \u2217 = F for any atomic formula F (including \u22a5 and equality) that does not contain members of p;\n\u2022 (F \u2227G)\u2217 = F \u2217 \u2227G\u2217;\n\u2022 (F \u2228G)\u2217 = F \u2217 \u2228G\u2217;\n\u2022 (F \u2192 G)\u2217 = (F \u2217 \u2192 G\u2217) \u2227 (F \u2192 G);\n\u2022 (\u2200xF )\u2217 = \u2200xF \u2217;\n\u2022 (\u2203xF )\u2217 = \u2203xF \u2217.\nThe predicates in p are called intensional: these are the predicates that we \u201cintend to characterize\u201d by F in terms of non-intensional predicates.2 When F is a sentence, the models of the second-order sentence SM[F ; p] are called the p-stable models of F : they are the models of F that are \u201cstable\u201d on p. We will often simply write SM[F ] in place of SM[F ; p] when p is the list of all predicate constants occurring in F . According to Lee, Lifschitz, and\n2. Intensional predicates are analogous to output predicates in Datalog, and non-intensional predicates are analogous to input predicates in Datalog (Lifschitz, 2011).\nPalla (2008), answer sets are defined as a special class of stable models as follows. By \u03c3(F ) we denote the signature consisting of the object, function and predicate constants occurring in F . If F contains at least one object constant, an Herbrand interpretation of \u03c3(F ) that satisfies SM[F ] is called an answer set of F . The answer sets of a logic program \u03a0 are defined as the answer sets of the FOL-representation of \u03a0 (i.e., the conjunction of the universal closures of implications corresponding to the rules). For example, the FOL-representation of the program\np(a) q(b) r(x)\u2190 p(x),not q(x)\nis p(a) \u2227 q(b) \u2227 \u2200x(p(x) \u2227 \u00acq(x)\u2192 r(x)) (1)\nand SM[F ] is\np(a) \u2227 q(b) \u2227 \u2200x(p(x) \u2227 \u00acq(x)\u2192 r(x)) \u2227\u00ac\u2203uvw(((u, v, w) < (p, q, r)) \u2227 u(a) \u2227 v(b)\n\u2227\u2200x((u(x) \u2227 (\u00acv(x) \u2227 \u00acq(x))\u2192 w(x)) \u2227 (p(x) \u2227 \u00acq(x)\u2192 r(x)))),\nwhich is equivalent to the first-order sentence\n\u2200x(p(x)\u2194 x = a) \u2227 \u2200x(q(x)\u2194 x = b) \u2227 \u2200x(r(x)\u2194 (p(x) \u2227 \u00acq(x))) (2)\n(Ferraris et al., 2007, Example 3). The stable models of F are any first-order models of (2). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}.\nAccording to Ferraris et al. (2011), this definition of an answer set, when applied to the syntax of logic programs, is equivalent to the traditional definition of an answer set that is based on grounding and fixpoints (Gelfond & Lifschitz, 1988).\nNote that the definition of a stable model is more general than the definition of an answer set in the following ways: stable models are not restricted to Herbrand models, the underlying signature can be arbitrary, and the intensional predicates are not fixed to the list of predicate constants occurring in the formula. The last fact is not essential in view of the following proposition. By pr(F ) we denote the list of all predicate constants occurring in F ; by Choice(p) we denote the conjunction of \u201cchoice formulas\u201d \u2200x(p(x) \u2228 \u00acp(x)) for all predicate constants p in p, where x is a list of distinct object variables; by False(p) we denote the conjunction of \u2200x\u00acp(x) for all predicate constants p in p. We sometimes identify a list with the corresponding set when there is no confusion.\nProposition 1 Formula\nSM[F ; p]\u2194 SM[F \u2227 Choice(pr(F )\\p) \u2227 False(p\\pr(F ))] (3)\nis logically valid.\nNotice that the (implicit) intensional predicates on the right-hand side of (3) are those in (pr(F ) \u222a p). The Choice formula makes the predicates in (pr(F ) \\ p) to be exempt from the stability checking. On the other hand, the False formula makes the predicates in (p \\ pr(F )) to be stabilized (i.e., to have empty extents), though they do not occur in F .\nFerraris et al. (2011) incorporate strong negation into the stable model semantics by distinguishing between intensional predicates of two kinds, positive and negative. Each negative intensional predicate has the form \u223cp, where p is a positive intensional predicate and \u2018\u223c \u2019 is a symbol for strong negation. Syntactically \u223c is not a logical connective, as it can appear only as a part of a predicate constant. An interpretation of the underlying signature is coherent if it satisfies the formula\n\u00ac\u2203x(p(x)\u2227 \u223cp(x)), (4)\nwhere x is a list of distinct object variables, for each negative predicate \u223cp. We usually consider coherent interpretations only. Intuitively, \u223cp(t) represents that p(t) is false. This is different from \u00acp(t) which represents that it is not known that p(t) is true. Similarly, \u00ac\u223cp(t) represents that it is not known that p(t) is false, and \u00ac\u00acp(t) represents that it is not known that p(t) is not known to be true. Note that, unlike in first-order logic, \u00ac\u00acp(t) is different from p(t). For instance, formula p(a) has only one answer set {p(a)} but \u00ac\u00acp(a) has no answer sets.\nLike the extension of circumscription to many-sorted first-order sentences, the definition of a stable model is straightforwardly extended to many-sorted first-order sentences."}, {"heading": "2.3 Equivalence of the Stable Model Semantics and Circumscription on Canonical Formulas", "text": "Neither the stable model semantics nor circumscription is stronger than the other. For example,\nCIRC[\u2200x(p(x) \u2228 \u00acp(x)); p] (5)\nis equivalent to \u2200x\u00acp(x), and\nSM[\u2200x(p(x) \u2228 \u00acp(x)); p] (6)\nis equivalent to >, so that (5) is stronger than (6). On the other hand,\nCIRC[\u2200x(\u00acp(x)\u2192 q(x)); p, q] (7)\nis equivalent to \u2200x(\u00acp(x)\u2194 q(x)), and\nSM[\u2200x(\u00acp(x)\u2192 q(x)); p, q] (8)\nis equivalent to \u2200x(\u00acp(x) \u2227 q(x)), so that (8) is stronger than (7). In this section, we show that the two semantics coincide on a class of formulas called canonical formulas, which we define below. We first review the notions of positive, negative, and strictly positive occurrences.\nDefinition 1 We say that an occurrence of a predicate constant, or any other subexpression, in a formula F is positive if the number of implications containing that occurrence in the antecedent is even, and negative otherwise. (Recall that we treat \u00acG as shorthand for G\u2192 \u22a5.) We say that the occurrence is strictly positive if the number of implications in F containing that occurrence in the antecedent is 0.\nFor example, in (1), both occurrences of q are positive, but only the first one is strictly positive.\nDefinition 2 We say that a formula F is canonical relative to a list p of predicate constants if\n\u2022 no occurrence of a predicate constant from p is in the antecedents of more than one implication in F , and\n\u2022 every occurrence of a predicate constant from p that is in the scope of a strictly positive occurrence of \u2203 or \u2228 in F is strictly positive in F .\nExample 1 The formula \u2200x(\u00acp(x)\u2192 q(x)) (9)\nthat is shown above is not canonical relative to {p, q} since it does not satisfy the first clause of the definition (p occurs in the antecedents of two implications as \u00acp(x) is shorthand for p(x)\u2192 \u22a5). On the other hand, the formula is canonical relative to {q}. The formula\n\u2200x(p(x) \u2228 \u00acp(x)) (10)\nis not canonical relative to {p} since it does not satisfy the second clause (the second occurrence of p is in the scope of a strictly positive occurrence of \u2228, but is not strictly positive in (10)); the formula\np(a) \u2227 (\u2203x p(x)\u2192 \u2203x q(x)) (11)\nis canonical relative to {p, q}, while\np(a, a) \u2227 \u2203x(p(x, a)\u2192 p(b, x)) (12)\nis not canonical relative to {p, q} since it does not satisfy the second clause (the second occurrence of p is in the scope of a strictly positive occurrence of \u2203, but is not strictly positive in formula (12)).\nThe following theorem states that, for any canonical formula, circumscription coincides with the stable model semantics.\nTheorem 1 For any canonical formula F relative to p,\nCIRC[F ; p]\u2194 SM[F ; p] (13)\nis logically valid.\nFor instance, for formula (11), which is canonical relative to {p, q}, formulas CIRC[(11); p, q] and SM[(11); p, q] are equivalent to each other. Also, any sentence F is clearly canonical relative to \u2205, so that CIRC[F ; \u2205] is equivalent to SM[F ; \u2205], which in turn is equivalent to F . On the other hand, such equivalence may not necessarily hold for non-canonical formulas. For instance, we observed that, for formula (10) that is not canonical relative to {p}, formulas (5) and (6) are not equivalent to each other. For formula (9) that is not canonical\nrelative to {p, q}, formulas (7) and (8) are not equivalent to each other. We also observe that formula (12) that is not canonical relative to {p, q}, CIRC[(12); p, q] is not equivalent to SM[(12); p, q]: the Herbrand interpretation {p(a, a), p(b, a)} satisfies SM[(12); p, q], but does not satisfy CIRC[(12); p, q].\nNote that non-canonical formulas can often be equivalently rewritten as canonical formulas. Since any equivalent transformation preserves the models of circumscription, Theorem 1 can be applied to such non-canonical formulas, by first rewriting them as canonical formulas. For example, formula (9) is equivalent to\n\u2200x(p(x) \u2228 q(x)), (14)\nwhich is canonical relative to {p, q}, so that CIRC[(9); p, q] is equivalent to SM[(14); p, q]. For another example, formula (10) is equivalent to\n\u2200x(p(x)\u2192 p(x)), (15)\nwhich is canonical relative to {p}, so that CIRC[(10); p] is equivalent to SM[(15); p]. It is clear that this treatment can be applied to any quantifier-free formula (including any propositional formula) because a quantifier-free formula can be equivalently rewritten as a canonical formula by first rewriting it into a clausal normal form and then turning each clause into the form C \u2192 D, where C is a conjunction of atoms and D is a disjunction of atoms.3\nSections 3 and 4 use Theorem 1 to reformulate the event calculus and the situation calculus in the first-order stable model semantics."}, {"heading": "3. Reformulating the Event Calculus in the General Theory of Stable", "text": "Models\nIn this section, we review the syntax of circumscriptive event calculus described in Chapter 2 of the book by Mueller (2006). Based on the observation that the syntax conforms to the condition of canonicality, we present a few reformulations of the event calculus in the general theory of stable models."}, {"heading": "3.1 Review: Circumscriptive Event Calculus", "text": "We assume a many-sorted first-order language, which contains an event sort, a fluent sort, and a timepoint sort. A fluent term is a term whose sort is a fluent; an event term and a timepoint term are defined similarly.\nDefinition 3 A condition is defined recursively as follows:\n\u2022 If \u03c41 and \u03c42 are terms, then comparisons \u03c41 < \u03c42, \u03c41 \u2264 \u03c42, \u03c41 \u2265 \u03c42, \u03c41 > \u03c42, \u03c41 = \u03c42, \u03c41 6= \u03c42 are conditions;\n3. It appears unlikely that knowledge has to be encoded in a non-canonical formula such as (12) that cannot be easily turned into an equivalent canonical formula. c.f. \u201cGuide to Axiomatizing Domains in First-Order Logic\u201d (http://cs.nyu.edu/faculty/davise/guide.html). It is not a surprise that all circumscriptive action theories mentioned in this paper satisfy the canonicality assumption.\n\u2022 If f is a fluent term and t is a timepoint term, then HoldsAt(f, t) and \u00acHoldsAt(f, t) are conditions;\n\u2022 If \u03b31 and \u03b32 are conditions, then \u03b31 \u2227 \u03b32 and \u03b31 \u2228 \u03b32 are conditions;\n\u2022 If v is a variable and \u03b3 is a condition, then \u2203v\u03b3 is a condition.\nWe will use e and ei to denote event terms, f and fi to denote fluent terms, t and ti to denote timepoint terms, and \u03b3 and \u03b3i to denote conditions.\nIn the event calculus, we circumscribe Initiates, Terminates, and Releases to minimize unexpected effects of events, circumscribe Happens to minimize unexpected events, and circumscribe Abi (abnormality predicates) to minimize abnormalities. Formally, an event calculus description is a circumscriptive theory defined as\nCIRC[\u03a3 ; Initiates,Terminates,Releases] \u2227 CIRC[\u2206 ; Happens] \u2227 CIRC[\u0398 ; Ab1, . . . ,Abn] \u2227 \u039e,\n(16)\nwhere\n\u2022 \u03a3 is a conjunction of universal closures of axioms of the form\n\u03b3 \u2192 Initiates(e, f, t) \u03b3 \u2192 Terminates(e, f, t) \u03b3 \u2192 Releases(e, f, t) \u03b3 \u2227 \u03c01(e, f1, t)\u2192 \u03c02(e, f2, t) (\u201ceffect constraint\u201d) \u03b3 \u2227 [\u00ac]Happens(e1, t) \u2227 \u00b7 \u00b7 \u00b7 \u2227 [\u00ac]Happens(en, t)\u2192 Initiates(e, f, t) \u03b3 \u2227 [\u00ac]Happens(e1, t) \u2227 \u00b7 \u00b7 \u00b7 \u2227 [\u00ac]Happens(en, t)\u2192 Terminates(e, f, t),\nwhere each of \u03c01 and \u03c02 is either Initiates or Terminates (\u2018[\u00ac]\u2019 means that \u2018\u00ac\u2019 is optional);\n\u2022 \u2206 is a conjunction of universal closures of temporal ordering formulas (comparisons between timepoint terms) and axioms of the form\n\u03b3 \u2192 Happens(e, t) \u03c3(f, t) \u2227 \u03c01(f1, t) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c0n(fn, t)\u2192 Happens(e, t) (\u201ccausal constraints\u201d) Happens(e, t)\u2192 Happens(e1, t) \u2228 \u00b7 \u00b7 \u00b7 \u2228Happens(en, t) (\u201cdisjunctive event axiom\u201d),\nwhere \u03c3 is Started or Stopped and each \u03c0j (1 \u2264 j \u2264 n) is either Initiated or Terminated ;\n\u2022 \u0398 is a conjunction of universal closures of cancellation axioms of the form\n\u03b3 \u2192 Abi(..., t) ;\n\u2022 \u039e is a conjunction of first-order sentences (outside the scope of CIRC) including unique name axioms, state constraints, event occurrence constraints, and the set of domainindependent axioms in the event calculus, such as EC (for the continuous event calculus) and DEC (for the discrete event calculus) (Mueller, 2006, Chapter 2). It also\nincludes the following definitions of the predicates used in the causal constraints in \u2206:\nStarted(f, t) def\u2194 (HoldsAt(f, t) \u2228 \u2203e(Happens(e, t) \u2227 Initiates(e, f, t))) (CC1) Stopped(f, t) def\u2194 (\u00acHoldsAt(f, t) \u2228 \u2203e(Happens(e, t) \u2227 Terminates(e, f, t))) (CC2) Initiated(f, t) def\u2194 (Started(f, t) \u2227 \u00ac\u2203e(Happens(e, t) \u2227 Terminates(e, f, t))) (CC3) Terminated(f, t) def\u2194 (Stopped(f, t) \u2227 \u00ac\u2203e(Happens(e, t) \u2227 Initiates(e, f, t))) (CC4).\nRemark 1 The following facts are easy to check:\n\u2022 \u03a3 is canonical relative to {Initiates,Terminates,Releases};\n\u2022 \u2206 is canonical relative to {Happens};\n\u2022 \u0398 is canonical relative to {Ab1, . . . ,Abn}.\nThese facts are used in the next section to reformulate the event calculus in the general theory of stable models."}, {"heading": "3.2 Reformulating the Event Calculus in the General Theory of Stable Models", "text": "Following Ferraris, Lee, Lifschitz, and Palla (2009), about a formula F we say that it is negative on a list p of predicate constants if members of p have no strictly positive occurrences in F .4 For example, formula (9) is negative on {p}, but is not negative on {p, q}. A formula of the form \u00acF (shorthand for F \u2192 \u22a5) is negative on any list of predicates.\nWe assume that \u039e was already equivalently rewritten so that \u039e is negative on {Initiates, Terminates, Releases, Happens, Ab1, . . . ,Abn}. This can be easily done by prepending \u00ac\u00ac to strictly positive occurrences of those predicates. The following theorem shows a few equivalent reformulations of circumscriptive event calculus in the general theory of stable models.\nTheorem 2 For any event calculus description (16), the following theories are equivalent to each other:5\n(a) CIRC[\u03a3; I, T,R] \u2227 CIRC[\u2206;H] \u2227 CIRC[\u0398; Ab1, . . . ,Abn] \u2227 \u039e ;\n(b) SM[\u03a3; I, T,R] \u2227 SM[\u2206;H] \u2227 SM[\u0398; Ab1, . . . ,Abn] \u2227 \u039e ;\n(c) SM[\u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e; I, T,R,H,Ab1, . . . ,Abn] ;\n(d) SM[\u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e \u2227 Choice(pr(\u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e) \\ {I, T,R,H,Ab1, . . . ,Abn})] .\nThe equivalence between (a) and (b) is immediate from Theorem 1. The equivalence between (b) and (c) can be shown using the splitting theorem by Ferraris et al. (2009). The assumption that \u039e is negative on the intensional predicates is essential in showing that\n4. Note that we distinguish between a formula being negative (on p) and an occurrence being negative (Section 2.3). 5. For brevity, we abbreviate the names of circumscribed predicates.\nequivalence (For more details, see the proof in Appendix C.4.). The equivalence between (c) and (d) follows from Proposition 1 since\n{I, T,R,H,Ab1, . . . ,Abn} \\ pr(\u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e)\nis the empty set.6"}, {"heading": "4. Reformulating the Situation Calculus in the General Theory of Stable", "text": "Models\nIn this section, we review and reformulate two versions of the situation calculus\u2014Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001)."}, {"heading": "4.1 Review: Lin\u2019s Causal Action Theories", "text": "We assume a many-sorted first-order language which contains a situation sort, an action sort, a fluent sort, a truth value sort and an object sort. We understand expression P (x, s), where P is a fluent name, as shorthand for Holds(P (x), s). We do not consider functional fluents here for simplicity.\nAccording to Lin (1995), a formula \u03c6(s) is called a simple state formula about s if \u03c6(s) does not mention Poss, Caused or any situation term other than possibly the variable s.\nWe assume that a causal action theory D consists of a finite number of the following sets of axioms. We often identify D with the conjunction of the universal closures of all axioms in D. In the following, F , Fi are fluent names, A is an action name, V , Vi are truth values, s, s\u2032 are situation variables, \u03c6(s) is a simple state formula about s, symbols a, a\u2032 are action variables, f is a variable of sort fluent, v is a variable of sort truth value, and x, xi, y, yi are lists of variables.\n\u2022 Dcaused is a conjunction of axioms of the form\nPoss(A(x), s)\u2192 (\u03c6(s)\u2192 Caused(F (y), V, do(A(x), s))\n(direct effect axioms), and\n\u03c6(s) \u2227 Caused(F1(x1), V1, s) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Caused(Fn(xn), Vn, s)\u2192 Caused(F (x), V, s)\n(indirect effect axioms).\n\u2022 Dposs is a conjunction of precondition axioms of the form\nPoss(A(x), s)\u2194 \u03c6(s). (17)\n\u2022 Drest is a conjunction of the following axioms:\n\u2013 The basic axioms:\nCaused(f, true, s)\u2192 Holds(f, s), Caused(f, false, s)\u2192 \u00acHolds(f, s),\ntrue 6= false \u2227 \u2200v(v = true \u2228 v = false). (18)\n6. I, T , R, H occur in the domain independent axioms as part of \u039e.\n\u2013 The unique name assumptions for fluent names:\nFi(x) 6= Fj(y), (i 6= j) Fi(x) = Fi(y)\u2192 x = y.\n(19)\nSimilarly for action names.\n\u2013 The foundational axioms for the discrete situation calculus: 7\ns 6= do(a, s), (20) do(a, s) = do(a\u2032, s\u2032)\u2192 (a = a\u2032 \u2227 s = s\u2032), (21)\n\u2200p ( p(S0) \u2227 \u2200a, s ( p(s)\u2192 p(do(a, s)) ) \u2192 \u2200s p(s) ) . (22)\n\u2013 The frame axiom:\nPoss(a, s)\u2192 (\u00ac\u2203vCaused(f, v, do(a, s)) \u2192 (Holds(f, do(a, s))\u2194 Holds(f, s))).\n\u2013 Axioms for other domain knowledge: \u03c6(s).\nA causal action theory is defined as\nCIRC[Dcaused ; Caused ] \u2227 Dposs \u2227 Drest . (23)\nRemark 2 It is easy to check that Dcaused is canonical relative to Caused.\nThis fact is used in the next section to reformulate causal action theories in the general theory of stable models."}, {"heading": "4.2 Reformulating Causal Action Theories in the General Theory of Stable Models", "text": "Let Dposs\u2192 be the conjunction of axioms \u03c6(s)\u2192 Poss(A(x), s) for each axiom (17) in Dposs . Instead of the second-order axiom (22), we consider the following first-order formula Dsit , which introduces a new intensional predicate constant Sit whose argument sort is situation.8\nSit(S0) \u2227 \u2200a, s(Sit(s)\u2192 Sit(do(a, s))) \u2227 \u00ac\u2203s\u00acSit(s). (24)\nIn the following, D\u2212rest is the theory obtained from Drest by dropping (22).\nTheorem 3 Given a causal action theory (23), the following theories are equivalent to each other when we disregard the auxiliary predicate Sit:\n(a) CIRC[Dcaused ; Caused ] \u2227 Dposs \u2227 Drest ;\n(b) SM[Dcaused ; Caused ] \u2227 Dposs \u2227 D\u2212rest \u2227 SM[Dsit ; Sit ] ;\n(c) SM[Dcaused ; Caused ] \u2227 SM[Dposs\u2192 ; Poss] \u2227 D\u2212rest \u2227 SM[Dsit ; Sit ] ;\n(d) SM[Dcaused \u2227 Dposs\u2192 \u2227 D\u2212rest \u2227 Dsit ; Caused ,Poss,Sit ] .\n7. For simplicity we omit two other axioms regarding the partial-order among situations. 8. Suggested by Vladimir Lifschitz (personal communication)."}, {"heading": "4.3 Review: Reiter\u2019s Basic Action Theories", "text": "As in causal action theories, we understand P (x, s), where P is a fluent name, as shorthand for Holds(P (x), s), and do not consider functional fluents.\nA basic action theory (BAT) is of the form\n\u03a3 \u222a Dss \u222a Dap \u222a Duna \u222a DS0 , (25)\nwhere\n\u2022 \u03a3 is the conjunction of the foundational axioms (Section 4.1); \u2022 Dss is a conjunction of successor state axioms of the form\nF (x, do(a, s))\u2194 \u03a6F (x, a, s),\nwhere \u03a6F (x, a, s) is a formula that is uniform in s 9 and whose free variables are among x, a, s;\n\u2022 Dap is a conjunction of action precondition axioms of the form\nPoss(A(x), s)\u2194 \u03a0A(x, s),\nwhere \u03a0A(x, s) is a formula that is uniform in s and whose free variables are among x, s;\n\u2022 Duna is the conjunction of unique name axioms for fluents and actions; \u2022 DS0 is a conjunction of first-order formulas that are uniform in S0."}, {"heading": "4.4 Reformulating Basic Action Theories in the General Theory of Stable Models", "text": "Note that a BAT is a theory in first-order logic.10 In view of the fact that any first-order logic sentence F is equivalent to SM[F ; \u2205], it is trivial to view a BAT as a first-order theory under the stable model semantics with the list of intensional predicates being empty.\nIn the rest of this section, we consider an alternative encoding of BAT in ASP, in which we do not need to provide explicit successor state axioms Dss. Instead, the successor state axioms are entailed by the effect axioms and the generic inertia axioms adopted in ASP by making intensional both the positive predicate Holds and the negative predicate \u223cHolds (Recall the definitions of positive and negative predicates in Section 2.2). In the following we assume that the underlying signature contains both these predicates.\nAn ASP-style BAT is of the form\n\u03a3 \u222a Deffect \u222a Dprecond \u222a Dinertia \u222a Dexogenous0 \u222a Duna \u222a DS0 , (26)\nwhere\n\u2022 \u03a3, Duna and DS0 are defined as before;\n9. We refer the reader to the book by Reiter (2001) for the definition of a uniform formula. 10. For simplicity we disregard the second-order axiom (22).\n\u2022 Deffect is a conjunction of axioms of the form\n\u03b3+R (x, a, s)\u2192 Holds(R(x), do(a, s)) (27)\nor \u03b3\u2212R (x, a, s)\u2192 \u223cHolds(R(x), do(a, s)), (28) where \u03b3+R (x, a, s) and \u03b3 \u2212 R (x, a, s) are formulas that are uniform in s and whose free variables are among x, a and s;\n\u2022 Dprecond is a conjunction of axioms of the form\n\u03c0A(x, s)\u2192 Poss(A(x), s), (29)\nwhere \u03c0A(x, s) is a formula that is uniform in s and whose free variables are among x, s;\n\u2022 Dinertia is the conjunction of the axioms\nHolds(R(x), s) \u2227 \u00ac\u223cHolds(R(x), do(a, s))\u2192 Holds(R(x), do(a, s)), \u223cHolds(R(x), s) \u2227 \u00acHolds(R(x), do(a, s))\u2192 \u223cHolds(R(x), do(a, s))\nfor all fluent names R;\n\u2022 Dexogenous0 is the conjunction of\nHolds(R(x), S0)\u2228 \u223cHolds(R(x), S0)\nfor all fluent names R.\nNote that axioms in Dinertia are typically used in answer set programming to represent the common sense law of inertia (Lifschitz & Turner, 1999). Similarly, Dexogenous0 is used to represent that the initial value of a fluent is arbitrary.11\nWe will show how this ASP-style BAT is related to Reiter\u2019s BAT. First, since we use strong negation, it is convenient to define the following notions. Given the signature \u03c3 of a BAT, \u03c3Holds is the signature obtained from \u03c3 by adding \u223cHolds to \u03c3. We say that an interpretation I of \u03c3Holds is complete on Holds if it satisfies\n\u2200y(Holds(y)\u2228 \u223cHolds(y)),\nwhere y is a list of distinct variables. Given an interpretation I of \u03c3Holds, expression I|\u03c3 denotes the projection of I on \u03c3.\nLet Dss be the conjunction of successor state axioms\nHolds(R(x), do(a, s)) \u2194 \u0393+R(x, a, s) \u2228 (Holds(R(x), s) \u2227 \u00ac\u0393 \u2212 R(x, a, s)),\nwhere \u0393+R(x, a, s) is the disjunction of \u03b3 + R (x, a, s) for all axioms (27) in Deffect , and \u0393 \u2212 R(x, a, s) is the disjunction of \u03b3\u2212R (x, a, s) for all axioms (28) in Deffect . By Dap we denote the conjunction of axioms Poss(A(x), s)\u2194 \u03a0A(x, s), where \u03a0A(x, s) is the disjunction of \u03c0A(x, s) for all axioms (29) in Dprecond .\n11. The axioms Dinertia and Dexogenous0 are also closely related to the translation of C+ into nonmonotonic causal logic (Giunchiglia, Lee, Lifschitz, McCain, & Turner, 2004).\nTheorem 4 Let T be a theory (26) of signature \u03c3Holds, and I a coherent interpretation of \u03c3Holds that is complete on Holds. If I satisfies\n\u00ac\u2203x a s(\u0393+R(x, a, s) \u2227 \u0393 \u2212 R(x, a, s))\nfor every fluent name R, then I satisfies\nSM[T ; Poss,Holds,\u223cHolds]\niff I|\u03c3 satisfies the BAT \u03a3 \u2227 Dss \u2227 Dap \u2227 Duna \u2227 DS0 ."}, {"heading": "5. Translating Almost Universal Sentences into Logic Programs", "text": "Theorems 2\u20144 present reformulations of the situation calculus and the event calculus in the general theory of stable models, which may contain nested quantifiers and connectives. On the other hand, the input languages of ASP solvers are limited to simple rule forms, which are analogous to clausal normal form in classical logic. Although any first-order formula can be rewritten in clausal normal form while preserving satisfiability, such transformations do not necessarily preserve stable models. This is due to the fact that the notion of equivalence is \u201cstronger\u201d under the stable model semantics (Lifschitz, Pearce, & Valverde, 2001).\nDefinition 4 (Ferraris et al., 2011) A formula F is strongly equivalent to formula G if, for any formula H containing F as a subformula (and possibly containing object, function and predicate constants that do not occur in F , G), and for any list p of distinct predicate constants, SM[H; p] is equivalent to SM[H \u2032; p], where H \u2032 is obtained from H by replacing an occurrence of F by G.\nIn other words, replacing a subformula with another strongly equivalent subformula does not change the stable models of the whole formula. While strongly equivalent theories are classically equivalent (i.e., equivalent under classical logic), the converse does not hold. Consequently, classically equivalent transformations do not necessarily preserve stable models. For instance, consider p and \u00ac\u00acp. When p is intensional, the former has stable models and the latter does not.\nIt is known that every propositional formula can be rewritten as a logic program (Cabalar & Ferraris, 2007; Cabalar, Pearce, & Valverde, 2005; Lee & Palla, 2007), and such translations can be extended to quantifier-free formulas in a straightforward way (Section 5.1). However, the method does not work in the presence of arbitrary quantifiers, because in the target formalism (logic programs), all variables are implicitly universally quantified.\nIn this section, we present a translation that turns a certain class of sentences called \u201calmost universal\u201d sentences into logic programs while preserving stable models. It turns out that the reformulations of the situation calculus and the event calculus in Sections 3 and 4 belong to the class of almost universal sentences, so that we can use ASP solvers for computing them."}, {"heading": "5.1 Translating Quantifier-Free Formulas into Logic Programs", "text": "Cabalar et al. (2005) define the following transformation that turns any propositional formula under the stable model semantics into a logic program.\n\u2022 Left side rules:\n> \u2227 F \u2192 G 7\u2192 {F \u2192 G} (L1) \u22a5 \u2227 F \u2192 G 7\u2192 \u2205 (L2)\n\u00ac\u00acF \u2227G\u2192 H 7\u2192 {G\u2192 \u00acF \u2228H} (L3) (F \u2228G) \u2227H \u2192 K 7\u2192 { F \u2227H \u2192 K G \u2227H \u2192 K } (L4)\n(F \u2192 G) \u2227H \u2192 K 7\u2192  \u00acF \u2227H \u2192 K G \u2227H \u2192 K H \u2192 F \u2228 \u00acG \u2228K  (L5) \u2022 Right side rules:\nF \u2192 \u22a5\u2228G 7\u2192 {F \u2192 G} (R1) F \u2192 >\u2228G 7\u2192 \u2205 (R2)\nF \u2192 \u00ac\u00acG \u2228H 7\u2192 {\u00acG \u2227 F \u2192 H} (R3) F \u2192 (G \u2227H) \u2228K 7\u2192 { F \u2192 G \u2228K F \u2192 H \u2228K } (R4)\nF \u2192 (G\u2192 H) \u2228K 7\u2192 { G \u2227 F \u2192 H \u2228K \u00acH \u2227 F \u2192 \u00acG \u2228K } (R5)\nBefore applying this transformation to each formula on the lefthand side, we assume that the formula is already written in negation normal form, in which negation is applied to literals only, by using the following transformation:\n\u2022 Negation normal form conversion: \u00ac> 7\u2192 \u22a5 \u00ac\u22a5 7\u2192 > \u00ac\u00ac\u00acF 7\u2192 \u00acF \u00ac(F \u2227G) 7\u2192 \u00acF \u2228 \u00acG \u00ac(F \u2228G) 7\u2192 \u00acF \u2227 \u00acG \u00ac(F \u2192 G) 7\u2192 \u00ac\u00acF \u2227 \u00acG\nAccording to Cabalar et al. (2005), successive application of the rewriting rules above turn any propositional formula into a disjunctive logic program. This result can be simply extended to turn any quantifier-free formula into a logic program.\nAs noted by Cabalar et al. (2005), this translation may involve an exponential blowup in size, and Theorem 1 from their paper shows that indeed there is no vocabulary-preserving polynomial time algorithm to convert general propositional theories under the stable model semantics into disjunctive logic programs. Alternatively, one can use another translation from the same paper, which is linear in size but involves auxiliary atoms and is more complex."}, {"heading": "5.2 Quantifier Elimination", "text": "We introduce a quantifier elimination method that distinguishes between two kinds of occurrences of quantifiers: \u201csingular\u201d and \u201cnon-singular.\u201d Any \u201cnon-singular\u201d occurrence of a quantifier is easy to eliminate, while a \u201csingular\u201d occurrence is eliminated under a certain syntactic condition.\nDefinition 5 We say that an occurrence of QxG in F is singular if\n\u2022 Q is \u2203, and the occurrence of QxG is positive in F , or\n\u2022 Q is \u2200, and the occurrence of QxG is negative in F .\nFor example, the occurrence of \u2203x q(x) is singular in (11), but the occurrence of \u2203x p(x) is not.\nNon-singular occurrences of quantifiers can be eliminated in view of the fact that every first-order sentence can be rewritten in prenex form. The prenex form conversion rules given in Section 6.3.1 of Pearce and Valverde (2005) preserve strong equivalence, which leads to the following theorem.12\nTheorem 5 (Lee & Palla, 2007, Proposition 5) Every first-order formula is strongly equivalent to a formula in prenex form.\nThe prenex form conversion turns a non-singular occurrence of a quantifier into an outermost \u2200 while preserving strong equivalence. Consequently, if a sentence contains no singular occurrence of a quantifier, then the above results can be used to turn the sentence into a universal sentence and then into a set of ASP rules. However, in the presence of a singular occurrence of a quantifier, the prenex form conversion turns the occurrence into an outermost \u2203, which is not allowed in logic programs. Below we consider how to handle such occurrences.\nObviously, if the Herbrand universe is finite, and if we are interested in Herbrand stable models (i.e., answer sets) only, quantified formulas can be rewritten as multiple disjunctions and conjunctions. We do not even need to consider turning the formula into prenex form. For example, for a formula\nr \u2227 \u00ac\u2203x(p(x) \u2227 q(x))\u2192 s (30)\noccurring in a theory whose signature contains {1, . . . , n} as the only object constants (and no other function constants), if we replace \u2203x(p(x) \u2227 q(x)) with multiple disjunctions and then turn the resulting program with nested expressions into a usual disjunctive program (Lifschitz, Tang, & Turner, 1999), 2n rules are generated. For instance, if n = 3, the\n12. Pearce and Valverde (2005) show that a sentence in QNc5, the monotonic basis of Quantified Equilibrium Logic, can be turned into prenex form, from which the result follows.\nresulting logic program is\ns\u2190 r,not p(1),not p(2),not p(3) s\u2190 r,not p(1),not p(2),not q(3) s\u2190 r,not p(1),not q(2),not p(3) s\u2190 r,not p(1),not q(2),not q(3) s\u2190 r,not q(1),not p(2),not p(3) s\u2190 r,not q(1),not p(2),not q(3) s\u2190 r,not q(1),not q(2),not p(3) s\u2190 r,not q(1),not q(2),not q(3).\nAlso, the translation is not modular as it depends on the underlying domain; the multiple disjunctions or conjunctions need to be updated when the domain changes. More importantly, this method is not applicable if the theory contains function constants of positive arity, as its Herbrand universe is infinite.\nOne may also consider introducing Skolem constants as in first-order logic, presuming that, for any sentence F and its \u201cSkolem form\u201d F \u2032, SM[F ; p] is satisfiable iff SM[F \u2032; p] is satisfiable. However, this idea does not work.13\nExample 2 For formula\nF = (\u2200x p(x)\u2192 q) \u2227 \u00ac\u00ac\u2203x(q \u2227 \u00acp(x)),\nSM[F ; q] is equivalent to the first-order sentence\n(q \u2194 \u2200x p(x)) \u2227 \u2203x(q \u2227 \u00acp(x)),\nwhich is unsatisfiable (the equivalence can be established using Theorems 3 and 11 from Ferraris et al., 2011). Formula F is strongly equivalent to its prenex form\n\u2203x\u2203y ( (p(x)\u2192 q) \u2227 \u00ac\u00ac(q \u2227 \u00acp(y)) ) , (31)\nHowever, if we introduce new object constants a and b to replace the existentially quantified variables as in\nF \u2032 = (p(a)\u2192 q) \u2227 \u00ac\u00ac(q \u2227 \u00acp(b)),\nformula SM[F \u2032; q] is equivalent to\n(q \u2194 p(a)) \u2227 (q \u2227 \u00acp(b)),\nwhich is satisfiable.\nHere we present a method of eliminating singular occurrences of quantifiers by introducing auxiliary predicates. Our idea is a generalization of the practice in logic programming\n13. Pearce and Valverde (2005) show that Skolemization works with QNc5, the monotonic basis of Quantified Equilibrium Logic, but as our example shows, this does not imply that Skolemization works with Quantified Equilibrium Logic.\nthat simulates negated existential quantification in the body of a rule by introducing auxiliary predicates. For instance, in order to eliminate \u2203 in (30), we will introduce a new predicate constant p\u2032, and turn (30) into\n(r \u2227 \u00acp\u2032 \u2192 s) \u2227 \u2200x(p(x) \u2227 q(x)\u2192 p\u2032), (32)\nwhich corresponds to the logic program\ns \u2190 r,not p\u2032 p\u2032 \u2190 p(x), q(x). (33)\nThe models of SM[(30); p, q, r, s] are the same as the stable models of (33) if we disregard p\u2032. This method does not involve grounding, so that the translation does not depend on the domain and is not restricted to Herbrand models. The method is formally justified by the following proposition.\nRecall that a formula H is negative on p if members of p have no strictly positive occurrences in H. Given a formula F , we say that an occurrence of a subformula G is p-negated in F if it is contained in a subformula H of F that is negative on p.\nProposition 2 Let F be a sentence, let p be a finite list of distinct predicate constants, and let q be a new predicate constant that does not occur in F . Consider any non-strictly positive, p-negated occurrence of \u2203yG(y,x) in F , where x is the list of all free variables of \u2203yG(y,x). Let F \u2032 be the formula obtained from F by replacing that occurrence of \u2203yG(y,x) with q(x). Then\nSM[F ; p] \u2227 \u2200x(q(x)\u2194 \u2203yG(y,x))\nis equivalent to\nSM[F \u2032 \u2227 \u2200xy(G(y,x)\u2192 q(x)); p, q].\nProposition 2 tells us that SM[F ; p] and SM[F \u2032 \u2227 \u2200xy(G(y,x) \u2192 q(x); p, q] have the same models if we disregard the new predicate constant q. Notice that F \u2032 does not retain the occurrence of \u2203y.\nExample 3 In formula (30), \u2203x(p(x) \u2227 q(x)) is contained in a negative formula (relative to any set of intensional predicates). In accordance with Proposition 2, SM[(30); p, q, r, s] has the same models as SM[(32); p, q, r, s, p\u2032] if we disregard p\u2032.\nAny singular, p-negated occurrence of a subformula \u2200yG(y,x) can also be eliminated using Proposition 2 by first rewriting \u2200yG(y,x) as \u00ac\u2203y\u00acG(y,x). Note that \u2200yG(y,x) is not strongly equivalent to \u00ac\u2203y\u00acG(y,x), and in general such a classically equivalent transformation may not necessarily preserve stable models. However, the Theorem on Double Negations (Ferraris et al., 2009, also reviewed in Appendix C) tells us that such a transformation is ensured to preserve p-stable models if the replaced occurrence is p-negated in the given formula.\nNow we are ready to present our quantifier elimination method, which applies to the class of almost universal formulas.\nDefinition 6 We say that a formula F is almost universal relative to p if every singular occurrence of QxG in F is p-negated in F .\nFor example, formula (30) is almost universal relative to any set of predicates because the only singular occurrence of \u2203x(p(x) \u2227 q(x)) in (30) is contained in \u00ac\u2203x(p(x) \u2227 q(x)), which is negative on any list of predicates. Formula F in Example 2 is almost universal relative to {q} because the singular occurrence of \u2200x p(x) is contained in the formula itself, which is negative on {q}, and the singular occurrence of \u2203x(q\u2227\u00acp(x)) is contained in \u00ac\u2203x(q\u2227\u00acp(x)), which is also negative on {q}.\nThe following procedure can be used to eliminate all (possibly nested) quantifiers in any almost universal sentence.\nDefinition 7 (Translation elim-quantifiers) Given a formula F , first prepend \u00ac\u00ac to every maximal strictly positive occurrence of a formula of the form \u2203yH(y,x),14 and then repeat the following process until there are no occurrences of quantifiers remaining: Select a maximal occurrence of a formula of the form QyG(y,x) in F , where Q is \u2200 or \u2203, and x is the list of all free variables in QyG(y,x).\n(a) If the occurrence of QyG(y,x) in F is non-singular in F , then set F to be the formula obtained from F by replacing the occurrence of QyG(y,x) with G(z,x), where z is a new variable.\n(b) Otherwise, if Q is \u2203 and the occurrence of QyG(y,x) in F is positive, then set F to be\nF \u2032 \u2227 (G(y,x)\u2192 pG(x)),\nwhere pG is a new predicate constant and F \u2032 is the formula obtained from F by replacing the occurrence of QyG(y,x) with pG(x).\n(c) Otherwise, if Q is \u2200 and the occurrence of QyG(y,x) in F is negative, then set F to be the formula obtained from F by replacing the occurrence of QyG(y,x) with \u00ac\u2203y\u00acG(y,x).\nWe assume that the new predicate constants introduced by the translation do not belong to the signature of the input formula F . It is clear that this process terminates, and yields a formula that is quantifier-free. Since the number of times step (b) is applied is no more than the number of quantifiers in the input formula, and the new formulas added have the size polynomial to the input formula, it follows that the size of the resulting quantifier-free formula is polynomial in the size of the input formula.\nThe following theorem tells us that any almost universal sentence F can be turned into the form \u2200xG, where G is a quantifier-free formula. For any (second-order) sentences F and G of some signature and any subset \u03c3 of that signature, we say that F is \u03c3-equivalent to G, denoted by F \u21d4\u03c3 G, if the class of models of F restricted to \u03c3 is identical to the class of models of G restricted to \u03c3.\n14. The maximality is understood here in terms of subformula relation. That is, we select a strictly positive occurrence of a subformula of F of the form \u2203yH(y,x) that is not contained in any other subformula of F of the same form.\nTheorem 6 Let F be a sentence of a signature \u03c3, let F \u2032 be the universal closure of the formula obtained from F by applying translation elim-quantifiers, and let q be the list of new predicate constants introduced by the translation. If F is almost universal relative to p, then SM[F ; p] is \u03c3-equivalent to SM[F \u2032; p,q].\nThe statement of the theorem becomes incorrect if we do not require F to be almost universal relative to p. For instance, if elim-quantifiers is applied to \u2203x p(x), it results in \u00ac\u00acq \u2227 (p(x)\u2192q). However, SM[\u2203x p(x); p] is not {p}-equivalent to SM[\u2200x(\u00ac\u00acq \u2227 (p(x)\u2192q)); p, q]. The former is equivalent to saying that p is a singleton. The latter is equivalent to q \u2227 \u2200x\u00acp(x) \u2227 (q \u2194 \u2203xp(x)), which is inconsistent.\n5.3 f2lp: Computing Answer Sets of First-Order Formulas\nUsing translation elim-quantifiers defined in the previous section, we introduce translation f2lp that turns an almost universal formula into a logic program. We assume that the underlying signature contains finitely many predicate constants.\nDefinition 8 (Translation f2lp) 1. Given a formula F and a list of intensional predicates p, apply translation elim-quantifiers (Definition 7) to F ;\n2. Add choice formulas (q(x) \u2228 \u00acq(x)) for all non-intensional predicates q.\n3. Turn the resulting quantifier-free formula into a logic program by applying the translation from Section 3 of the paper by Cabalar et al. (2005), which was also reviewed in Section 5.1.\nAs explained in Section 5.1, due to the third step, this transformation may involve an exponential blowup in size. One can obtain a polynomial translation by replacing Step 3 with an alternative translation given in Section 4 of the paper by Cabalar et al.\nThe following theorem asserts the correctness of the translation.\nTheorem 7 Let F be a sentence of a signature \u03c3, let p be a list of intensional predicates, and let F \u2032 be the FOL representation of the program obtained from F by applying translation f2lp with p as intensional predicates. If F is almost universal relative to p, then SM[F ; p] is \u03c3-equivalent to\nSM[F \u2032 \u2227 False(p \\ pr(F \u2032))].\nExample 4 Consider one of the domain independent axioms in the discrete event calculus (DEC5 axiom):\nHoldsAt(f, t) \u2227 \u00acReleasedAt(f, t+1)\u2227 \u00ac\u2203e(Happens(e, t) \u2227 Terminates(e, f, t))\u2192 HoldsAt(f, t+1). (34)\nStep 1 of translation f2lp introduces the formula\nHappens(e, t) \u2227 Terminates(e, f, t)\u2192 q(f, t),\nand replaces (34) with\nHoldsAt(f, t) \u2227 \u00acReleasedAt(f, t+1) \u2227 \u00acq(f, t)\u2192 HoldsAt(f, t+1).\nStep 3 turns these formulas into rules\nq(f, t)\u2190 Happens(e, t), Terminates(e, f, t) HoldsAt(f, t+1)\u2190 HoldsAt(f, t),not ReleasedAt(f, t+1), not q(f, t).\nTurning the program obtained by applying translation f2lp into the input languages of lparse 15 and gringo 16 requires minor rewriting, such as moving equality and negated atoms in the head to the body 17 and adding domain predicates in the body for all variables occurring in the rule in order to reduce the many-sorted signature into the non-sorted one.18\nSystem f2lp is an implementation of translation f2lp, which turns a first-order formula into the languages of lparse and gringo. The system can be downloaded from its home page\nhttp://reasoning.eas.asu.edu/f2lp .\nFirst-order formulas can be encoded in f2lp using the extended rule form F \u2190 G, where F and G are first-order formulas that do not contain \u2192. The ASCII representation of the quantifiers and connectives are shown in the following table.\nSymbol \u00ac \u223c \u2227 \u2228 \u2190 \u22a5 > \u2200xyz \u2203xyz ASCII not - & | <- false true ![X,Y,Z]: ?[X,Y,Z]:\nFor example, formula (34) can be encoded in the input language of f2lp as\nholdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &\nnot ?[E]:(happens(E,T) & terminates(E,F,T)).\nThe usual lparse and gringo rules (which have the rule arrow \u2018:-\u2019) are also allowed in f2lp. Such rules are simply copied to the output. The program returned by f2lp can be passed to ASP grounders and solvers that accept lparse and gringo languages."}, {"heading": "6. Computing the Event Calculus Using ASP Solvers", "text": "Using translation f2lp, we further turn the event calculus reformulation in Section 3.2 into answer set programs. The following procedure describes the process.\nDefinition 9 (Translation ec2asp) 1. Given an event calculus description (16), rewrite all the definitional axioms of the form\n\u2200x(p(x) def\u2194 G) (35)\nin \u039e as \u2200x(G\u00ac\u00ac \u2192 p(x)), where G\u00ac\u00ac is obtained from G by prepending \u00ac\u00ac to all occurrences of intensional predicates Initiates, Terminates, Releases, Happens, Ab1, . . . ,Abn. Also prepend \u00ac\u00ac to the strictly positive occurrences of the intensional predicates in the remaining axioms of \u039e. Let \u039e\u2032 be the resulting formula obtained from \u039e.\n15. http://www.tcs.hut.fi/Software/smodels 16. http://potassco.sourceforge.net 17. For instance, (X=Y) | -q(X,Y) :- p(X,Y) is turned into :- X!=Y, {not q(X,Y)}0, p(X,Y). 18. Alternatively this can be done by declaring variables using the #domain directive in lparse and gringo\nlanguages.\n2. Apply translation f2lp on \u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e\u2032 with the intensional predicates\n{Initiates,Terminates,Releases,Happens,Ab1, . . . ,Abn} \u222a p,\nwhere p is the set of all predicate constants p in (35) as considered in Step 1.\nThe following theorem states the correctness of the translation.\nTheorem 8 Let T be an event calculus description (16) of signature \u03c3 that contains finitely many predicate constants, let F be the FOL representation of the program obtained from T by applying translation ec2asp. Then T is \u03c3-equivalent to SM[F ].\nIn view of the theorem, system f2lp can be used to compute event calculus descriptions by a simple rewriting as stated in translation ec2asp.19 The system can be used in place of the dec reasoner in many existing applications of the event calculus, such as in robotics, security, video games, and web service composition, as listed in\nhttp://decreasoner.sourceforge.net/csr/decapps.html .\nThe computational mechanism of the dec reasoner is similar to our method as it is based on the reduction of event calculus reasoning to propositional satisfiability and uses efficient SAT solvers for computation. However, our method has some advantages.\nFirst, it is significantly faster due to the efficient grounding mechanisms implemented in ASP systems. This is evidenced in some experiments reported in Appendix B.\nSecond, f2lp allows us to compute the full version of the event calculus, assuming that the domain is given and finite. On the other hand, the reduction implemented in the dec reasoner is based on completion, which is weaker than circumscription. This makes the system unable to handle recursive axioms and disjunctive axioms, such as effect constraints and disjunctive event axioms (Section 3.1). For example, the dec reasoner does not allow the following effect constraints which describe the indirect effects of an agent\u2019s walking on the objects that he is holding:\nHoldsAt(Holding(a, o), t) \u2227 Initiates(e, InRoom(a, r), t) \u2192 Initiates(e, InRoom(o, r), t) HoldsAt(Holding(a, o), t) \u2227 Terminates(e, InRoom(a, r), t) \u2192 Terminates(e, InRoom(o, r), t).\n(36)\nThird, we can enhance the event calculus reasoning by combining ASP rules with the event calculus description. In other words, the event calculus can be viewed as a high level action formalism on top of ASP. We illustrate this using the example from the work of Dog\u0306andag\u0306, Ferraris, and Lifschitz (2004). There are 9 rooms and 12 doors as shown in Figure 1. Initially the robot \u201cRobby\u201d is in the middle room and all the doors are closed. The goal of the robot is to make all rooms accessible from each other. Figure 2 (File robby) shows an encoding of the problem in the language of f2lp. Atom door(x, y) denotes that there is a door between rooms x and y; open(x, y) denotes the event \u201cRobby opening the door\n19. Kim, Lee, and Palla (2009) presented a prototype of f2lp called ecasp that is tailored to the event calculus computation.\nbetween rooms x and y\u201d; goto(x) denotes the event \u201cRobby going to room x\u201d; opened(x, y) denotes that the door between x and y has been opened; inRoom(x) denotes that Robby is in room x; accessible(x, y) denotes that y is accessible from x. Note that the rules defining the relation accessible are not part of event calculus axioms (Section 3.1). This example illustrates an advantage of allowing ASP rules in event calculus descriptions.\nThe minimal number of steps to solve the given problem is 11. We can find such a plan using the combination of f2lp, gringo (grounder) and claspD (solver for disjunctive programs) in the following way. 20\n$ f2lp dec robby | gringo -c maxstep=11 | claspD\nFile dec is an f2lp encoding of the domain independent axioms in the Discrete Event Calculus (The file is listed in Appendix A).21 The following is one of the plans found:\nhappens(open(5,8),0) happens(open(5,2),1) happens(open(5,4),2) happens(goto(4),3) happens(open(4,1),4) happens(open(4,7),5) happens(goto(5),6) happens(open(5,6),7) happens(goto(6),8) happens(open(6,9),9) happens(open(6,3),10)"}, {"heading": "7. Computing the Situation Calculus Using ASP Solvers", "text": "Using translation f2lp, we further turn the situation calculus reformulations in Sections 4.2 and 4.4 into answer set programs."}, {"heading": "7.1 Representing Causal Action Theories by Answer Set Programs", "text": "The following theorem shows how to turn causal action theories into answer set programs.\nTheorem 9 Let D be a finite causal action theory (23) of signature \u03c3 that contains finitely many predicate constants, and let F be the FOL representation of the program obtained by applying translation f2lp on\nDcaused \u2227 Dposs\u2192 \u2227 D\u2212rest \u2227 Dsit (37)\nwith the intensional predicates {Caused ,Poss,Sit}. Then D is \u03c3-equivalent to SM[F ].\n20. One can use clingo instead of gringo and claspD if the output of f2lp is a nondisjunctive program. 21. The file is also available at http://reasoning.eas.asu.edu/f2lp, along with f2lp encodings of the\ndomain independent axioms in other versions of the event calculus.\n% File \u2019robby\u2019\n% objects step(0..maxstep). astep(0..maxstep-1) :- maxstep > 0. room(1..9).\n% variables #domain step(T). #domain room(R). #domain room(R1). #domain room(R2).\n% position of the doors door(R1,R2) <- R1 >= 1 & R2 >=1 & R1 < 4 & R2 < 4 & R2 = R1+1. door(R1,R2) <- R1 >= 4 & R2 >= 4 & R1 < 7 & R2 < 7 & R2 = R1+1. door(R1,R2) <- R1 >= 7 & R2 >= 7 & R1 < 10 & R2 < 10 & R2 = R1+1. door(R1,R2) <- R2 < 10 & R2 = R1+3.\ndoor(R1,R2) <- door(R2,R1).\n% fluents fluent(opened(R,R1)) <- door(R1,R2). fluent(inRoom(R)). % F ranges over the fluents #domain fluent(F).\n% events event(open(R,R1)) <- door(R,R1). event(goto(R)). % E and E1 range over the events #domain event(E). #domain event(E1).\n% effect axioms initiates(open(R,R1),opened(R,R1),T). initiates(open(R,R1),opened(R1,R),T).\ninitiates(goto(R2),inRoom(R2),T)\n<- holdsAt(opened(R1,R2),T) & holdsAt(inRoom(R1),T).\nterminates(E,inRoom(R1),T)\n<- holdsAt(inRoom(R1),T) & initiates(E,inRoom(R2),T).\n% action precondition axioms holdsAt(inRoom(R1),T) <- happens(open(R1,R2),T).\nSimilar to the computation of the event calculus in Section 6, the Herbrand stable models of (37) can be computed using f2lp and answer set solvers. The input to f2lp can be simplified as we limit attention to Herbrand models. We can drop axioms (18)\u2013(21) as they are ensured by Herbrand models. Also, in order to ensure finite grounding, instead of Dsit , we include the following set of rules \u03a0situation in the input to f2lp.\nnesting(0,s0). nesting(L+1,do(A,S)) <- nesting(L,S) & action(A) & L < maxdepth. situation(S) <- nesting(L,S). final(S) <- nesting(maxdepth,S).\n\u03a0situation is used to generate finitely many situation terms whose depth is up to maxdepth, the value that can be given as an option in invoking gringo. Using the splitting theorem (Section C.1), it is not difficult to check that if a program \u03a0 containing these rules has no occurrence of predicate nesting in any other rules and has no occurrence of predicate situation in the head of any other rules, then every answer set of \u03a0 contains atoms situation(do(am, do(am\u22121, do(. . . , do(a1, s0))))) for all possible sequences of actions a1, . . . , am for m = 0, . . . , maxdepth. Though this program does not satisfy syntactic conditions, such as \u03bb-restricted (Gebser, Schaub, & Thiele, 2007), \u03c9-restricted (Syrja\u0308nen, 2004), or finite domain programs (Calimeri, Cozza, Ianni, & Leone, 2008), that answer set solvers usually impose in order to ensure finite grounding, the rules can still be finitely grounded\nby gringo Version 3.x, which does not check such syntactic conditions.22 It is not difficult to see why the program above leads to finite grounding since we provide an explicit upper limit for the nesting depth of function do.\nIn addition to \u03a0situation, we use the following program \u03a0executable in order to represent the set of executable situations (Reiter, 2001):\nexecutable(s0). executable(do(A,S)) <- executable(S) & poss(A,S) & not final(S)\n& situation(S) & action(A).\nFigure 3 shows an encoding of Lin\u2019s suitcase example (1995) in the language of f2lp (h is used to represent Holds), which describes a suitcase that has two locks and a spring loaded mechanism which will open the suitcase when both locks are up. This example illustrates how the ramification problem is handled in causal action theories. Since we fix the domain of situations to be finite, we require that actions not be effective in the final situations. This is done by introducing atom final(S).\nConsider the simple temporal projection problem by Lin (1995). Initially the first lock is down and the second lock is up. What will happen if the first lock is flipped? Intuitively, we expect both locks to be up and the suitcase to be open. We can automate the reasoning by using the combination of f2lp, gringo and claspD. First, we add \u03a0executable and the following rules to the theory in Figure 3. In order to check if the theory entails that flipping the first lock is executable, and that the suitcase is open after the action, we encode the negation of these facts in the last rule.\n% initial situation <- h(up(l1),s0). h(up(l2),s0).\n% query <- executable(do(flip(l1),s0)) & h(open,do(flip(l1),s0)).\nWe check the answer to the temporal projection problem by running the command:\n$ f2lp suitcase | gringo -c maxdepth=1 | claspD\nclaspD returns no answer set as expected. Now, consider a simple planning problem for opening the suitcase when both locks are initially down. We add \u03a0executable and the following rules to the theory in Figure 3. The last rule encodes the goal.\n% initial situation <- h(up(l1),s0). <- h(up(l2),s0). <- h(open,s0).\n% goal <- not ?[S]: (executable(S) & h(open,S)).\nWhen maxdepth is 1, the combined use of f2lp, gringo and claspD results in no answer sets, and when maxdepth is 2, it finds the unique answer set that contains both\n22. Similarly, system dlv-complex allows us to turn off the finite domain checking (option -nofdcheck). That system was used in a conference paper (Lee & Palla, 2010) that this article is based on.\nh(open, do(flip(l2), do(flip(l1), s0))) and h(open, do(flip(l1), do(flip(l2), s0))), each of which encodes a plan. In other words, the single answer set encodes multiple plans in different branches of the situation tree, which allows us to combine information about the different branches in one model. This is an instance of hypothetical reasoning that is elegantly handled in the situation calculus due to its branching time structure. Belleghem, Denecker, and Schreye (1997) note that the linear time structure of the event calculus is limited to handle such hypothetical reasoning allowed in the situation calculus."}, {"heading": "7.2 Representing Basic Action Theories by Answer Set Programs", "text": "Since a BAT T (not including the second-order axiom (22)) can be viewed as a first-order theory under the stable model semantics with the list of intensional predicates being empty, it follows that f2lp can be used to turn T into a logic program. As before, we focus on ASP-style BAT.\nTheorem 10 Let T be a ASP-style BAT (26) of signature \u03c3 that contains finitely many predicate constants, and let F be the FOL representation of the program obtained by applying translation f2lp on T with intensional predicates {Holds,\u223c Holds,Poss}. Then SM[T ; Holds,\u223cHolds,Poss] is \u03c3-equivalent to SM[F ; \u03c3(F ) \u222a {Poss}].\nFigure 4 shows an encoding of the \u201cbroken object\u201d example discussed by Reiter (1991). Consider the simple projection problem of determining if an object o, which is next to bomb b, is broken after the bomb explodes. We add \u03a0executable and the following rules to the theory in Figure 4.\n% initial situation not h(broken(o),s0) & h(fragile(o),s0) & h(nexto(b,o),s0). not h(holding(p,o),s0) & not h(exploded(b),s0).\n% query <- executable(do(explode(b),s0)) & h(broken(o),do(explode(b),s0)).\nThe command\n$ f2lp broken | gringo -c maxdepth=1 | claspD\nreturns no answer set as expected."}, {"heading": "8. Related Work", "text": "Identifying a syntactic class of theories on which different semantics coincide is important in understanding the relationship between them. It is known that, for tight logic programs and tight first-order formulas, the stable model semantics coincides with the completion semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011). This fact helps us understand the relationship between the two semantics, and led to the design of the answer set solver cmodels-1 23 that computes answer sets using completion. Likewise the class of canonical formulas introduced here helps us understand the relationship between the stable model semantics and circumscription. The class of canonical formulas is the largest\n23. http://www.cs.utexas.edu/users/tag/cmodels\nsyntactic class of first-order formulas identified so far on which the stable models coincide with the models of circumscription. In other words, minimal model reasoning and stable model reasoning are indistinguishable on canonical formulas.\nProposition 8 from the work of Lee and Lin (2006) shows an embedding of propositional circumscription in logic programs under the stable model semantics. Our theorem on canonical formulas is a generalization of this result to the first-order case. Janhunen and Oikarinen (2004) showed another embedding of propositional circumscription in logic programs, and implemented the system circ2dlp,24 but their translation appears quite different from the one by Lee and Lin.\nZhang, Zhang, Ying, and Zhou (2011) show an embedding of first-order circumscription in first-order stable model semantics. Theorem 3 from that paper is reproduced as follows.25\nTheorem 11 (Zhang et al., 2011, Thm. 3) Let F be a formula in negation normal form and let p be a finite list of predicate constants. Let F\u00ac\u00ac be the formula obtained from F by replacing every p(t) by \u00ac\u00acp(t), and let F c be the formula obtained from F by replacing every \u00acp(t) by p(t)\u2192 Choice(p), where p is in p and t is a list of terms. Then CIRC[F ; p] is equivalent to SM[F\u00ac\u00ac \u2227 F c; p].\nIn comparison with Theorem 1, this theorem can be applied to characterize circumscription of arbitrary formulas in terms of stable models by first rewriting the formulas into negation normal form. While Theorem 1 is applicable to canonical formulas only, it does not require any transformation, and the characterization is bidirectional in the sense that it can be also viewed as a characterization of stable models in terms of circumscription.\nZhang et al. (2011) also introduce a translation that turns arbitrary first-order formulas into logic programs, but this work is limited to finite structures only. On the other hand, our translation f2lp (Definition 8) works for almost universal formulas only, but is not limited to finite structures.\nThe situation calculus and the event calculus are widely studied action formalisms, and there are several papers that compare and relate them (e.g., Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).\nProlog provides a natural implementation for basic action theories since definitional axioms can be represented by Prolog rules according to the Clark\u2019s theorem (Reiter, 2001, Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules is similar to translation f2lp, but the difference is that the former preserves the completion semantics and the latter preserves the stable model semantics.\nLin and Wang (1999) describe a language that can be used to represent a syntactically restricted form of Lin\u2019s causal situation calculus, called \u201cclausal causal theories,\u201d which does not allow quantifiers. They show how to translate that language into answer set programs with strong negation, the answer sets of which are then used to obtain fully instantiated successor state axioms and action precondition axioms. This is quite different from our approach, which computes the propositional models of the full situation calculus theories directly.\nKautz and Selman (1992) introduce linear encodings that are similar to a propositionalized version of the situation calculus (McCarthy & Hayes, 1969). Lin (2003) introduces\n24. http://www.tcs.hut.fi/Software/circ2dlp 25. This is a bit simpler than the original statement because some redundancy is dropped.\nan action description language and describes a procedure to compile an action domain in that language into a complete set of successor state axioms, from which a STRIPS-like description can be extracted. The soundness of the procedure is shown with respect to a translation from action domain descriptions into Lin\u2019s causal action theories. However, that procedure is based on completion and as such cannot handle recursive axioms unlike our approach.\nDenecker and Ternovska (2007) present an inductive variant of the situation calculus represented in ID-logic (Denecker & Ternovska, 2008)\u2014classical logic extended with inductive definitions. ID-logic and the first-order stable model semantics appear to be closely related, but the precise relationship between them has yet to be shown."}, {"heading": "9. Conclusion", "text": "The first-order stable model semantics is defined similar to circumscription. This paper takes advantage of that definition to identify a class of formulas on which minimal model reasoning and stable model reasoning coincide, and uses this idea to reformulate the situation calculus and the event calculus in the first-order stable model semantics. Together with the translation that turns an almost universal sentence into a logic program, we show that reasoning in the situation calculus and the event calculus can be reduced to computing answer sets. We implemented system f2lp, a front-end to ASP solvers that allows us to compute these circumscriptive action theories. The mathematical tool sets and the system presented in this paper may also be useful in relating other circumscriptive theories to logic programs. Also, the advances in ASP solvers may improve the computation of circumscriptive theories."}, {"heading": "Acknowledgments", "text": "We are grateful to Yuliya Lierler, Vladimir Lifschitz, Erik Mueller, Heng Zhang, Yan Zhang, and the anonymous referees for their useful comments and discussions. The authors were partially supported by the National Science Foundation under Grant IIS-0916116.\nAppendix A. File \u2018dec\u2019 in the Language of f2lp\nFile \u2019dec\u2019 encodes the domain independent axioms in the discrete event calculus. This file is to be used together with event calculus domain descriptions as shown in Section 6.\n% File \u2018dec\u2019\n#domain fluent(F). #domain fluent(F1). #domain fluent(F2). #domain event(E). #domain time(T). #domain time(T1). #domain time(T2).\ntime(0..maxstep).\n% DEC 1 stoppedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & terminates(E,F,T).\n% DEC 2 startedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & initiates(E,F,T).\n% DEC 3 holdsAt(F2,T1+T2) <- happens(E,T1) & initiates(E,F1,T1) & T2>0 &\ntrajectory(F1,T1,F2,T2) & not stoppedIn(T1,F1,T1+T2) & T1+T2<=maxstep.\n% DEC 4 holdsAt(F2,T1+T2) <- happens(E,T1) & terminates(E,F1,T1) & 0<T2 &\nantiTrajectory(F1,T1,F2,T2) & not startedIn(T1,F1,T1+T2) & T1+T2<=maxstep.\n% DEC 5 holdsAt(F,T+1) <- holdsAt(F,T) & not releasedAt(F,T+1) &\nnot ?[E]:(happens(E,T) & terminates(E,F,T)) & T<maxstep.\n% DEC 6 not holdsAt(F,T+1) <- not holdsAt(F,T) & not releasedAt(F,T+1) &\nnot ?[E]:(happens(E,T) & initiates(E,F,T)) & T<maxstep.\n% DEC 7 releasedAt(F,T+1) <-\nreleasedAt(F,T) & not ?[E]:(happens(E,T) & (initiates(E,F,T) | terminates(E,F,T))) & T<maxstep.\n% DEC 8 not releasedAt(F,T+1) <- not releasedAt(F,T) &\nnot ?[E]: (happens(E,T) & releases(E,F,T)) & T<maxstep.\n% DEC 9 holdsAt(F,T+1) <- happens(E,T) & initiates(E,F,T) & T<maxstep.\n% DEC 10 not holdsAt(F,T+1) <- happens(E,T) & terminates(E,F,T) & T<maxstep.\n% DEC 11 releasedAt(F,T+1) <- happens(E,T) & releases(E,F,T) & T<maxstep.\n% DEC 12 not releasedAt(F,T+1) <- happens(E,T) &\n(initiates(E,F,T) | terminates(E,F,T)) & T<maxstep.\n{holdsAt(F,T)}. {releasedAt(F,T)}.\nProblem dec dec f2lp with f2lp with f2lp with f2lp with (max. step) reasoner reasoner (minisat) lparse + cmodels gringo + cmodels gringo + clasp(D) clingo BusRide \u2014 \u2014 0.04s 0.00s 0.01s \u2014 (15) (0.03s + 0.01s) (0.00s + 0.00s) (0.00s + 0.01s)\nA:902/R:7779 A:355/R:555 A:448/R:647 C:0 C:0\nCommuter \u2014 \u2014 77.29s 0.15s 0.2s 0.14s (15) (45.74s + 31.55s) (0.07s + 0.08s) (0.07s + 0.13s)\nA:32861/R:8734019 A:5269/R:24687 A:13174/R:24687 C:0 C:5308\nKitchen 39.0s 38.9s 6.19s 0.44s 0.24s 0.20s Sink (25) (38.9s + 0.1s) (38.9s + 0.00s) (2.99s + 3.20s) (0.19s + 0.25s) (0.18s + 0.06s)\nA:1014/C:12109 A:1014/C:12109 A:121621/R:480187 A:11970/R:61932 A:11970/R:61932 C:0 C:0\nThielscher 6.5s 6.3s 0.42s 0.19s 0.12s 0.1s Circuit (40) (6.3s + 0.2s) (6.3s + 0.0s) (0.27s + 0.15s) (0.09s + 0.1s) (0.09s + 0.03s)\nA:1394/C:42454 A:1394/C:42454 A:9292/R:53719 A:4899/R:35545 A:4899/R:35545 C:0 C:0\nWalking \u2014 \u2014 0.00s 0.00s 0.00s 0.00s Turkey (15) (0.00s + 0.00s) (0.00s + 0.00s) (0.00s + 0.00s)\nA:370/R:518 A:316/R:456 A:316/R:456 C:0 C:0\nFalling w/ 141.8s 141.7s 0.08s 0.04s 0.03s 0.03s AntiTraj (15) (141.4s + 0.4s) (141.7s + 0.00s) (0.05s + 0.03s) (0.02s + 0.02s) (0.03s + 0.00s)\nA:416/C:3056 A:416/C:3056 A:4994/R:9717 A:3702/R:7414 A:3702/R:7414 C:0 C:0\nFalling w/ 59.5s 59.4s 4.95s 0.46s 0.28s 0.22s Events (25) (59.5s + 0.0s) (59.4s + 0.0s) (2.57s + 2.38s) (0.20s + 0.26s) (0.20s + 0.08s)\nA:1092/C:12351 A:1092/C:12351 A:1240/R:388282 A:1219/R:71266 A:13829/R:71266 C:1436 C:1415\nHotAir 32.2s 32.3s 0.01s 0.0s 0.0s 0.01s Baloon (15) (32.2s + 0.0s) (32.3s + 0.0s) (0.01s + 0.00s) (0.0s + 0.0s) (0.0s + 0.0s)\nA:288/C:1163 A:288/C:1163 A:494/R:2451 A:492/R:1835 A:1063/R:1835 C:689 C:681\nTelephone1 9.3s 9.1s 0.22s 0.11s 0.07s 0.07s (40) (9.2s + 0.1s) (9.1s + 0.0s) (0.13s + 0.09s) (0.08s + 0.03s) (0.06s + 0.01s)\nA:5419/C:41590 A:5419/C:41590 A:21414/R:27277 A:9455/R:13140 A:9455/R:13140 C:0 C:0\nA: number of atoms, C: number of clauses, R: number of ground rules\nFigure 5: Comparing the dec reasoner and f2lp with answer set solvers\nAppendix B. Comparing the dec Reasoner with ASP-based Event Calculus Reasoner\nWe compared the performance of the dec reasoner (v 1.0) running relsat (v 2.2) and minisat (v 2.2) with the following:\n\u2022 f2lp (v 1.11) with lparse (v 1.0.17)+cmodels (v 3.79) running minisat (v 2.0 beta),\n\u2022 f2lp (v 1.11) with gringo (v 3.0.3)+cmodels (v 3.79) running minisat (v 2.0 beta),\n\u2022 f2lp (v 1.11) with gringo (v 3.0.3) +clasp (v 2.0.2) (claspD (v 1.1.2) used instead for disjunctive programs), and\n\u2022 f2lp (v 1.11) with clingo (v 3.0.3 (clasp v 1.3.5)).\nf2lp turns an input theory into the languages of lparse and gringo, and lparse and gringo turn the result into a ground ASP program. cmodels turns this ground program into a set of clauses and then invokes a SAT solver to compute answer sets, while clasp computes answer sets using the techniques similar to those used in SAT solvers. clingo is a system that combines gringo and clasp in a monolithic way.\nThe first five examples in Figure 5 are part of the benchmark problems from the work of Shanahan (1997, 1999). The next four are by Mueller (2006). (We increased timepoints\nto see more notable differences.) More examples can be found from the f2lp homepage. All experiments were done on a Pentium machine with 3.06 GHz CPU and 4GB RAM running 64 bit Linux. The reported run times are in seconds and were obtained using the Linux time command (\u201cuser time + sys time\u201d), except for the dec reasoner for which we recorded the times reported by the system. This was for fair comparisons in order to avoid including the time spent by the dec reasoner in producing output in a neat format, which sometimes takes non-negligible time. For the dec reasoner, the times in parentheses are \u201c(SAT encoding time + SAT solving time).\u201d For the others, they are the times spent by each of the grounder and the solver. cmodels time includes the time spent in converting the ground program generated by lparse/gringo into a set of clauses, and calling the SAT solver. The time spent by f2lp in translating an event calculus description into an answer set program (retaining variables) is negligible for these problems. \u2019\u2014\u2019 denotes that the system cannot solve the example due to the limited expressivity. For instance, BusRide includes disjunctive event axioms, which results in a disjunctive program that cannot be handled by clingo. Similarly, the dec reasoner cannot handle BusRide (disjunctive event axioms), Commuter (compound events) and Walking Turkey (effect constraints). As is evident from the experiments, the main reason for the efficiency of the ASP-based approach is the efficient grounding mechanisms implemented in the ASP grounders. Though the dec reasoner and cmodels call the same SAT solver minisat, the number of atoms processed by the dec reasoner is in general much smaller. This is because the dec reasoner adopts an optimized encoding method (that is based on predicate completion) which avoids a large number of ground instances of atoms such as Initiates(e, f, t), Terminates(e, f, t), and Releases(e, f, t) (Mueller, 2004, Section 4.4). On the other hand, in several examples, the number of clauses generated by cmodels is 0, which means that the answer sets were found without calling the SAT solver. This is because for these examples the unique answer set coincides with the well-founded model, which is efficiently computed by cmodels in a preprocessing step before calling SAT solvers. Out of the 14 benchmark examples by Shanahan (1997, 1999), 10 of them belong to this case when lparse is used for grounding.\nIn the experiments in Figure 5, the solving times are negligible for most of the problems. We also experimented with some computationally hard problems, where solving takes more time than grounding. Figure 6 shows runs of a medium-size action domain, the Zoo World (Akman, Erdog\u0306an, Lee, Lifschitz, & Turner, 2004). All the tests shown in the table are planning problems where max. step is the length of a minimal plan. The cut-off time was 2 hours and the dec reasoner did not terminate within that time for any of the problems. In fact, the entire time was spent on SAT encoding and the SAT solver was never called. On the other hand, the ASP grounder gringo took only a few seconds to ground the domain and, unlike in Figure 5, the solvers took much more time than the grounder. As we can see, cmodels with minisat performed better than clasp on two of the problems. To check the time taken by minisat on the encoding generated by the dec reasoner, we ran ZooTest1 to completion. The dec reasoner terminated after 116578.1 seconds (32.38 hours)."}, {"heading": "Appendix C. Proofs", "text": ""}, {"heading": "C.1 Review of Some Useful Theorems", "text": "We review some theorems by Ferraris et al. (2011) and Ferraris et al. (2009) which will be used to prove our main results. In fact, we will provide a version of the splitting theorem which is slightly more general than the one given by Ferraris et al. (2009), in order to facilitate our proof efforts.\nLemma 1 Formula\nu \u2264 p\u2192 ((\u00acF )\u2217(u)\u2194 \u00acF )\nis logically valid.\nTheorem 12 (Ferraris et al., 2011, Thm. 2) For any first-order formula F and any disjoint lists p, q of distinct predicate constants,\nSM[F ; p]\u2194 SM[F \u2227 Choice(q); p \u222a q]\nis logically valid.\nLet F be a first-order formula. A rule of F is an implication that occurs strictly positively in F . The predicate dependency graph of F (relative to p) is the directed graph that\n\u2022 has all members of p as its vertices, and\n\u2022 has an edge from p to q if, for some rule G\u2192 H of F ,\n\u2013 p has a strictly positive occurrence in H, and\n\u2013 q has a positive occurrence in G that does not belong to any subformula of G that is negative on p.\nTheorem 13 (Ferraris et al., 2009, Splitting Thm.) Let F , G be first-order sentences, and let p, q be finite disjoint lists of distinct predicate constants. If\n(a) each strongly connected component of the predicate dependency graph of F \u2227G relative to p, q is either a subset of p or a subset of q,\n(b) F is negative on q, and\n(c) G is negative on p\nthen SM[F \u2227G; p \u222a q]\u2194 SM[F ; p] \u2227 SM[G; q]\nis logically valid.\nThe theorem is slightly more general than the one by Ferraris et al. (2009) in that the notion of a dependency graph above yields less edges than the one given by Ferraris et al. Instead of\n\u2013 q has a positive occurrence in G that does not belong to any subformula of G that is negative on p,\nFerraris et al.\u2019s definition has\n\u2013 q has a positive occurrence in G that does not belong to any subformula of the form \u00acK.\nFor instance, according to Ferraris et al., the dependency graph of\n((p\u2192 q)\u2192 r)\u2192 p (38)\nrelative to p has two edges (from p to r, and from p to p), while the dependency graph according to our definition has no edges.\nOn the other hand, the generalization is not essential in view of the following theorem.\nTheorem 14 (Ferraris et al., 2009, Thm. on Double Negations) Let H be a sentence, F a subformula of H, and H\u00ac\u00ac the sentence obtained from H by inserting \u00ac\u00ac in front of F . If the occurrence of F is p-negated in H, then SM[H; p] is equivalent to SM[H\u00ac\u00ac; p].\nFor instance, SM[(38); p] is equivalent to SM[\u00ac\u00ac((p\u2192 q)\u2192 r)\u2192 p; p]. The dependency graph of \u00ac\u00ac((p\u2192 q)\u2192 r)\u2192 p relative to p according to the definition by Ferraris et al. is identical to the dependency graph of (38) relative to p according to our definition.\nNext, we say that a formula F is in Clark normal form (relative to the list p of intensional predicates) if it is a conjunction of sentences of the form\n\u2200x(G\u2192 p(x)), (39)\none for each intensional predicate p, where x is a list of distinct object variables, and G has no free variables other than those in x. The completion (relative to p) of a formula F in Clark normal form is obtained by replacing each conjunctive term (39) with\n\u2200x(p(x)\u2194 G).\nThe following theorem relates SM to completion. We say that F is tight on p if the predicate dependency graph of F relative to p is acyclic.\nTheorem 15 (Ferraris et al., 2011) For any formula F in Clark normal form that is tight on p, formula SM[F ; p] is equivalent to the completion of F relative to p."}, {"heading": "C.2 Proof of Proposition 1", "text": "Using Theorem 12 and Theorem 13,\nSM[F ; p] \u21d4 SM[F ; p \u2229 pr(F )] \u2227 SM[>; p\\pr(F )] \u21d4 SM[F ; p \u2229 pr(F )] \u2227 False(p\\pr(F )) \u21d4 SM[F \u2227 Choice(pr(F )\\p)] \u2227 False(p\\pr(F )) \u21d4 SM[F \u2227 Choice(pr(F )\\p) \u2227 False(p\\pr(F ))]."}, {"heading": "C.3 Proof of Theorem 1", "text": "In the following, F is a formula, p is a list of distinct predicate constants p1, . . . , pn, and u is a list of distinct predicate variables u1, . . . , un of the same length as p.\nLemma 2 (Ferraris et al., 2011, Lemma 5) Formula\nu \u2264 p\u2192 (F \u2217(u)\u2192 F )\nis logically valid.\nLemma 3 If every occurrence of every predicate constant from p is strictly positive in F ,\n(u \u2264 p)\u2192 (F \u2217(u)\u2194 F (u))\nis logically valid.\nProof. By induction. We will show only the case when F is G\u2192 H. The other cases are straightforward. Consider\nF \u2217(u) = (G\u2217(u)\u2192 H\u2217(u)) \u2227 (G\u2192 H).\nSince every occurrence of predicate constants from p in F is strictly positive, G contains no predicate constants from p, so that G\u2217(u) is equivalent to G(u), which is the same as G. Also, by I.H., H\u2217(u) \u2194 H(u) is logically valid. Therefore it is sufficient to prove that under the assumption u \u2264 p,\n(G\u2192 H(u)) \u2227 (G\u2192 H)\u2194 (G\u2192 H(u))\nis logically valid. From left to right is clear. Assume (u \u2264 p), G \u2192 H(u), and G. We get H(u), which is equivalent to H\u2217(u) by I.H. By Lemma 2, we conclude H.\nThe proof of Theorem 1 is immediate from the following lemma, which can be proved by induction.\nLemma 4 If F is canonical relative to p, then formula\n(u \u2264 p) \u2227 F \u2192 (F \u2217(u)\u2194 F (u))\nis logically valid.\nProof.\n\u2022 F is an atomic formula. Trivial.\n\u2022 F = G \u2227H. Follows from I.H.\n\u2022 F = G \u2228 H. Assume (u \u2264 p) \u2227 (G \u2228 H). Since G \u2228 H is canonical relative to p, every occurrence of every predicate constant from p is strictly positive in G or in H, so that, by Lemma 3, G\u2217(u) is equivalent to G(u), and H\u2217(u) is equivalent to H(u).\n\u2022 F = G\u2192 H. Assume (u \u2264 p) \u2227 (G\u2192 H). It is sufficient to show\n(G\u2217(u)\u2192 H\u2217(u))\u2194 (G(u)\u2192 H(u)). (40)\nSince G\u2192 H is canonical relative to p, every occurrence of every predicate constant from p in G is strictly positive in G, so that, by Lemma 3, G\u2217(u) is equivalent to G(u).\n\u2013 Case 1: \u00acG. By Lemma 2, \u00acG\u2217(u). The claim follows since \u00acG\u2217(u) is equivalent to \u00acG(u). \u2013 Case 2: H. By I.H. H\u2217(u) is equivalent to H(u). The claim follows since G\u2217(u) is equivalent to G(u).\n\u2022 F = \u2200xG. Follows from I.H.\n\u2022 F = \u2203xG. Since every occurrence of every predicate constant from p in G is strictly positive in G, the claim follows from Lemma 3."}, {"heading": "C.4 Proof of Theorem 2", "text": "Proof. Between (a) and (b): Follows immediately from Theorem 1.\nBetween (b) and (c): Note first that \u039e is equivalent to SM[\u039e; \u2205]. Since\n\u2022 every strongly connected component in the dependency graph of \u03a3 \u2227 \u2206 relative to {I, T,R,H} either belongs to {I, T,R} or {H},\n\u2022 \u03a3 is negative on {H}, and\n\u2022 \u2206 is negative on {I, T,R},\nit follows from Theorem 13 that (b) is equivalent to\nSM[\u03a3 \u2227\u2206; I, T,R,H] \u2227 SM[\u0398; Ab1, . . . , Abn] \u2227 SM[\u039e; \u2205]\nSimilarly, applying Theorem 13 repeatedly, we can show that the above formula is equivalent to (c).\nBetween (c) and (d): By Proposition 1."}, {"heading": "C.5 Proof of Theorem 3", "text": "Between (a) and (b): Since Dcaused is canonical relative to Caused , by Theorem 1, (a) is equivalent to\nSM[Dcaused ; Caused ] \u2227 Dposs \u2227 D\u2212rest \u2227 (22). (41)\nConsequently, it is sufficient to prove the claim that, under the assumption \u2200s Sit(s), formula (22) is equivalent to SM[Dsit ; Sit ].\nFirst note that under the assumption, (22) can be equivalently rewritten as \u2200p ( p(S0) \u2227 \u2200a, s(p(s)\u2192 p(do(a, s)))\u2192 p = Sit ) . (42)\nOn the other hand, under \u2200s Sit(s), SM[Dsit ; Sit ] is equivalent to\nSit(S0) \u2227 \u2200a, s(Sit(s)\u2192 Sit(do(a, s))) \u2227 \u2200p ( p < Sit \u2192 \u00ac(p(S0) \u2227 \u2200a, s(p(s)\u2192 p(do(a, s))) \u2227 \u2200a, s(Sit(s)\u2192 Sit(do(a, s)))) ) ,\nwhich, under the assumption \u2200s Sit(s), is equivalent to\n\u2200p ( p(S0) \u2227 \u2200a, s(p(s)\u2192 p(do(a, s)))\u2192 \u00ac(p < Sit) ) and furthermore to (42).\nBetween (b) and (c): Since \u03c6(s) does not contain Poss, the equivalence follows from the equivalence between completion and the stable model semantics.\nBetween (c) and (d): Since Dcaused contains no strictly positive occurrence of Poss and Dposs\u2192 contains no occurrence of Caused , every strongly connected component in the predicate dependency graph of Dcaused \u2227 Dposs\u2192 relative to {Caused ,Poss} either belongs to {Caused} or belongs to {Poss}. By Theorem 13, it follows that (b) is equivalent to\nSM[Dcaused \u2227 Dposs\u2192 ; Caused ,Poss] \u2227 D\u2212rest \u2227 SM[Dsit ; Sit ].\nSimilarly, applying Theorem 13 two more times, we get that the above formula is equivalent to (c)."}, {"heading": "C.6 Proof of Theorem 4", "text": "Theory T is\n\u03a3 \u2227 Deffect \u2227 Dprecond \u2227 DS0 \u2227 Duna \u2227 Dinertia \u2227 Dexogenous0 ,\nand the corresponding BAT is\n\u03a3 \u2227 Dss \u2227 Dap \u2227 DS0 \u2227 Duna.\nWithout loss of generality, we assume that T is already equivalently rewritten so that there are exactly one positive effect axiom and exactly one negative effect axiom for each fluent R, and that there is exactly one action precondition axiom for each action A.\nConsider\nSM[\u03a3 \u2227 Deffect \u2227 Dprecond \u2227 DS0 \u2227 Duna \u2227 Dinertia \u2227 Dexogenous0 ; Poss,Holds,\u223cHolds].\nSince \u03a3 and Duna are negative on the intensional predicates, the formula is equivalent to\nSM[Deffect \u2227 Dprecond \u2227 DS0 \u2227 Dinertia \u2227 Dexogenous0 ; Poss,Holds,\u223cHolds] \u2227 \u03a3 \u2227 Duna. (43)\nSince Poss does not occur in\nDeffect \u2227 DS0 \u2227 Dinertia \u2227 Dexogenous0 ,\nand since Dprecond is negative on {Holds,\u223cHolds}, by Theorem 13, (43) is equivalent to\nSM[Deffect \u2227 DS0 \u2227 Dinertia \u2227 Dexogenous0 ; Holds,\u223cHolds] \u2227 SM[Dprecond ;Poss] \u2227 \u03a3 \u2227 Duna,\n(44)\nwhich is equivalent to\nSM[Deffect \u2227 DS0 \u2227 Dinertia \u2227 Dexogenous0 ; Holds,\u223cHolds] \u2227 Dap \u2227 \u03a3 \u2227 Duna.\nTherefore the statement of the theorem can be proven by showing the following: if\nI |= \u00ac\u2203x a s(\u0393+R(x, a, s) \u2227 \u0393 \u2212 R(x, a, s)) (45)\nfor every fluent R, and\nI |= \u03a3 (46)\nthen I satisfies\nSM[DS0 \u2227 Dexogenous0 \u2227 Deffect \u2227 Dinertia ; Holds,\u223cHolds] (47)\niff I|\u03c3 satisfies DS0 \u2227 Dss.\nFrom Dexogenous0 , it follows that (47) is equivalent to\nSM[D\u00ac\u00acS0 \u2227 Dexogenous0 \u2227 Deffect \u2227 Dinertia ; Holds,\u223cHolds], (48)\nwhere D\u00ac\u00acS0 is the formula obtained from DS0 by prepending \u00ac\u00ac to all occurrences of Holds. Under the assumption (46),\nD\u00ac\u00acS0 \u2227 Dexogenous0 \u2227 Deffect \u2227 Dinertia\nis {Holds}-atomic-tight w.r.t. I, 26 so that by the relationship between completion and SM that is stated in Corollary 11 of (Lee & Meng, 2011), we have that I |= (48) iff I satisfies DS0 , and, for each fluent R,\n26. See Section 7 from the work of Lee and Meng (2011) for the definition.\nHolds(R(x), do(a, s))\u2194 \u0393+R(x, a, s) \u2228 (Holds(R(x, s) \u2227 \u00ac \u223cHolds(R(x), do(a, s))) (49)\nand\n\u223cHolds(R(x), do(a, s))\u2194 \u0393\u2212R(x, a, s) \u2228 (\u223cHolds(R(x), s) \u2227 \u00acHolds(R(x), do(a, s))), (50)\nwhere x, a, s are any (lists of) object names of corresponding sorts. It remains to show that, under the assumption (45), I satisfies (49)\u2227 (50) iff I|\u03c3 satisfies\nHolds(R(x), do(a, s)) \u2194 \u0393+R(x, a, s) \u2228 (Holds(R(x), s) \u2227 \u00ac\u0393 \u2212 R(x, a, s)). (51)\nIn the following we will use the following facts.\n\u2022 I |=\u223cHolds(R(x), s) iff I|\u03c3 6|= Holds(R(x), s).\n\u2022 if F is a ground formula that does not contain \u223c, then I |= F iff I|\u03c3 |= F .\nLeft to Right: Assume I |= (49) \u2227 (50).\n\u2022 Case 1: I|\u03c3 |= Holds(R(x), do(a, s)). Clearly, I |= Holds(R(x), do(a, s)), so that, from (49), there are two subcases to consider.\n\u2013 Subcase 1: I |= \u0393+R(x, a, s). Clearly, I|\u03c3 satisfies both LHS and RHS of (51). \u2013 Subcase 2: I |= Holds(R(x), s). From (50), it follows that I 6|= \u0393\u2212R(x, a, s), and\nconsequently, I|\u03c3 6|= \u0393\u2212R(x, a, s). Clearly, I|\u03c3 satisfies both LHS and RHS of (51).\n\u2022 Case 2: I|\u03c3 6|= Holds(R(x), do(a, s)). It follows from (49) that I 6|= \u0393+R(x, a, s), which is equivalent to saying that I|\u03c3 6|= \u0393+R(x, a, s). Also since I |=\u223cHolds(R(x), do(a, s)), from (50), there are two subcases to consider.\n\u2013 Subcase 1: I |= \u0393\u2212R(x, a, s). Clearly, I|\u03c3 satisfies neither LHS nor RHS of (51). \u2013 Subcase 2: I |= \u223cHolds(R(x), s). This is equivalent to saying that I|\u03c3 6|= Holds(R(x), s). Clearly, I|\u03c3 satisfies neither LHS nor RHS of (51).\nRight to Left: Assume I|\u03c3 |= (51).\n\u2022 Case 1: I |= Holds(R(x), do(a, s)). It follows from (51) that I|\u03c3 satisfies RHS of (51), so that there are two subcases to consider.\n\u2013 Subcase 1: I|\u03c3 |= \u0393+R(x, a, s). Clearly, I satisfies both LHS and RHS of (49). Also from (45), it follows that I 6|= \u0393\u2212R(x, a, s). Consequently, I satisfies neither LHS nor RHS of (50). \u2013 Subcase 2: I|\u03c3 |= Holds(R(x), s)\u2227\u00ac\u0393\u2212R(x, a, s). Clearly, I satisfies both LHS and RHS of (49). Since I 6|= \u0393\u2212R(x, a, s), I satisfies neither LHS nor RHS of (50).\n\u2022 Case 2: I |=\u223cHolds(R(x), do(a, s)). It follows from (51) that I|\u03c3 6|= \u0393+R(x, a, s), and I|\u03c3 6|= (Holds(R(x), s) \u2227 \u00ac\u0393\u2212R(x, a, s)). From the latter, consider the two subcases.\n\u2013 Subcase 1: I|\u03c3 6|= Holds(R(x), s). Clearly, I satisfies neither LHS nor RHS of (49), and satisfies both LHS and RHS of (50). \u2013 Subcase 2: I|\u03c3 6|= \u00ac\u0393\u2212R(x, a, s). Clearly, I satisfies neither LHS nor RHS of (49), and satisfies both LHS and RHS of (50)."}, {"heading": "C.7 Proof of Proposition 2", "text": "Lemma 5 Let F be a formula, let p be a list of distinct predicate constants, let G be a subformula of F and let G\u2032 be any formula that is classically equivalent to G. Let F \u2032 be the formula obtained from F by substituting G\u2032 for G. If the occurrence of G is in a subformula of F that is negative on p and the occurrence of G\u2032 is in a subformula of F \u2032 that is negative on p, then\nSM[F ; p]\u2194 SM[F \u2032; p]\nis logically valid.\nProof. Let F\u00ac\u00ac be the formula obtained from F by prepending \u00ac\u00ac to G, and let (F \u2032)\u00ac\u00ac be the formula obtained from F \u2032 by prepending \u00ac\u00ac to G\u2032. By the Theorem on Double Negations (Theorem 14), the following formulas are logically valid.\nSM[F ; p]\u2194 SM[F\u00ac\u00ac; p], SM[F \u2032; p]\u2194 SM[(F \u2032)\u00ac\u00ac; p].\nFrom Lemma 1, it follows that\n(u \u2264 p \u2227 (G\u2194 G\u2032))\u2192 ((F\u00ac\u00ac)\u2217(u)\u2194 ((F \u2032)\u00ac\u00ac)\u2217(u))\nis logically valid, where u is a list of predicate variables corresponding to p. Consequently,\nSM[F\u00ac\u00ac; p]\u2194 SM[(F \u2032)\u00ac\u00ac; p]\nis logically valid.\nProof of Proposition 2. In formula\nSM[F \u2032 \u2227 \u2200xy(G(y,x)\u2192 q(x)); p, q], (52)\nclearly, F \u2032 is negative on q and \u2200xy(G(y,x) \u2192 q(x)) is negative on p. Let H be any subformula of F that is negative on p and contains the occurrence of \u2203yG(y,x). Consider two cases.\n\u2022 Case 1: the occurrence of \u2203yG(y,x) in H is not strictly positive. Thus the dependency graph of F \u2032 \u2227 \u2200xy(G(y,x)\u2192 q(x)) relative to {p, q} has no incoming edges into q.\n\u2022 Case 2: the occurrence of \u2203yG(y,x) in H is strictly positive. Since H is negative on p, \u2203yG(y,x) is negative on p as well, so that the dependency graph of F \u2032 \u2227 \u2200xy(G(y,x)\u2192 q(x)) relative to {p, q} has no outgoing edges from q.\nTherefore, every strongly connected component in the dependency graph belongs to either p or {q}. Consequently, by Theorem 13, (52) is equivalent to\nSM[F \u2032; p] \u2227 SM[\u2200xy(G(y,x)\u2192 q(x)); q] (53)\nSince \u2203yG(y,x) is negative on q, formula \u2200xy(G(y,x) \u2192 q(x)) is tight on {q}. By Theorem 15, (53) is equivalent to\nSM[F \u2032; p] \u2227 \u2200x(\u2203yG(y,x)\u2194 q(x)). (54)\nBy Lemma 5, it follows that (54) is equivalent to\nSM[F ; p] \u2227 \u2200x(\u2203yG(y,x)\u2194 q(x)).\nConsequently, the claim follows."}, {"heading": "C.8 Proof of Theorem 6", "text": "It is clear that the algorithm terminates and yields a quantifier-free formula K. We will prove that SM[F ; p]\u21d4\u03c3 SM[\u2200xK; p \u222a q], where x is the list of all (free) variables of K.\nLet F\u00ac\u00ac be the formula obtained from the initial formula F by prepending double negations in front of every maximal strictly positive occurrence of formulas of the form \u2203yG(x, y). Since F is almost universal relative to p, such an occurrence is in a subformula of F that is negative on p. Thus by the Theorem on Double Negations (Theorem 14), SM[F ; p] is equivalent to SM[F\u00ac\u00ac; p]. Note that F\u00ac\u00ac contains no strictly positive occurrence of formulas of the form \u2203yG(x, y).\nFor each iteration, let us assume that the formula before the iteration is\nH0 \u2227 \u00b7 \u00b7 \u00b7 \u2227Hn,\nwhere H0 is transformed from F \u00ac\u00ac by the previous iterations, and each Hi (i > 0) is a formula of the form G(x, y) \u2192 pG(x) that is introduced by Step (b). Initially H0 is F\u00ac\u00ac and n = 0. Let r0 be p, and let ri be each pG for Hi (i > 0). By induction we can prove that\n(i) every positive occurrence of formulas of the form \u2203yG(x, y) in Hi is not strictly positive, and is in a subformula of Hi that is negative on ri;\n(ii) every negative occurrence of formulas of the form \u2200yG(x, y) in Hi is in a subformula of Hi that is negative on ri.\nWe will prove that if Step (a) or Step (c) is applied to turn Hk into H \u2032 k, then\nSM[\u2200x0H0; r0] \u2227 \u00b7 \u00b7 \u00b7 \u2227 SM[\u2200xnHn; rn] (55)\nis equivalent to SM[\u2200x\u20320H \u20320; r0] \u2227 \u00b7 \u00b7 \u00b7 \u2227 SM[\u2200x\u2032nH \u2032n; rn], (56) where H \u2032j = Hj for all j different from k, and xi (i \u2265 0) is the list of all free variables of Hi, and x \u2032 i (i \u2265 0) is the list of all free variables of H \u2032i.\nIndeed, Step (a) is a part of prenex form conversion, which preserves strong equivalence (Theorem 5). So it is clear that (55) is equivalent to (56).\nWhen Step (c) is applied to turn (55) into (56), since \u2200yH(x, y) is in a subformula of Hk that is negative on rk, the equivalence between (55) and (56) follows from Lemma 5.\nWhen Step (b) is applied to turn Hk into H \u2032 k and introduces a new conjunctive term\nH \u2032n+1, formula (55) is (\u03c3, r1, . . . , rn)-equivalent to\nSM[\u2200x\u20320H \u20320; r0] \u2227 \u00b7 \u00b7 \u00b7 \u2227 SM[\u2200x\u2032nH \u2032n; rn] \u2227 SM[\u2200x\u2032n+1H \u2032n+1; rn+1] (57)\nby Proposition 2 due to condition (i). Let\nH \u2032\u20320 \u2227 \u00b7 \u00b7 \u00b7 \u2227H \u2032\u2032m (58)\nbe the final quantifier-free formula, where H \u2032\u20320 is transformed from F \u00ac\u00ac. By the induction, it follows that SM[F ; p] is \u03c3-equivalent to\nSM[\u2200x\u2032\u20320H \u2032\u20320 ; r0] \u2227 \u00b7 \u00b7 \u00b7 \u2227 SM[\u2200x\u2032\u2032mH \u2032\u2032m; rm], (59)\nwhere each x\u2032\u2032i (0 \u2264 i \u2264 m) is the list of all free variables of H \u2032\u2032i . Since every non-strictly positive occurrence of new predicate ri (i > 0) in any H \u2032\u2032 j (0 \u2264 j \u2264 m) is positive, there is no incoming edge into ri in the dependency graph of (58) relative to r0, r1, . . . , rm. Consequently, every strongly connected component of the dependency graph belongs to one of ri (i \u2265 0). Moreover, it is clear that each H \u2032\u2032i (i \u2265 0) is negative on every rj for j 6= i. (In the case of H \u2032\u20320 , recall that the occurrence of rj for any j > 0 is not strictly positive since F\u00ac\u00ac, from which H \u2032\u20320 is obtained, contains no strictly positive occurrence of formulas of the form \u2203yG(x, y).) Thus by the splitting theorem (Theorem 13), formula (59) is equivalent to\nSM[\u2200x\u2032\u20320H \u2032\u20320 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u2200x\u2032\u2032mH \u2032\u2032m; r0 \u222a \u00b7 \u00b7 \u00b7 \u222a rm]. (60)"}, {"heading": "C.9 Proof of Theorem 7", "text": "We use the notations introduced in the proof of Theorem 6. By Theorem 6, SM[F ; p] is \u03c3-equivalent to (60) and, by Theorem 12, (60) is equivalent to\nSM[\u2200x\u2032\u20320H \u2032\u20320 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u2200x\u2032\u2032mH \u2032\u2032m \u2227 Choice(\u03c3pred \\ p); \u03c3pred \u222a r1 \u222a \u00b7 \u00b7 \u00b7 \u222a rm] (61)\n(r0 is p), where \u03c3 pred is the set of all predicate constants in signature \u03c3. It follows from Proposition 3 from (Cabalar et al., 2005) that (61) is equivalent to\nSM[\u2200x\u2032\u20320H \u2032\u2032\u20320 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u2200x\u2032\u2032mH \u2032\u2032\u2032m \u2227 Choice(\u03c3pred \\ p); \u03c3pred \u222a r1 \u222a \u00b7 \u00b7 \u00b7 \u222a rm], (62)\nwhere H \u2032\u2032\u2032i is obtained from H \u2032\u2032 i by applying the translation from (Cabalar et al., 2005, Section 3) that turns a quantifier-free formula into a set of rules. It is easy to see that F \u2032 is the same as the formula\n\u2200x\u2032\u20320H \u2032\u2032\u20320 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u2200x\u2032\u2032mH \u2032\u2032\u2032m \u2227 Choice(\u03c3pred \\ p)\nand \u03c3pred \u222a r1 \u222a \u00b7 \u00b7 \u00b7 \u222a rm is the same as p \u222a pr(F \u2032), so that (62) can be written as\nSM[F \u2032; p \u222a pr(F \u2032)],\nwhich is equivalent to\nSM[F \u2032 \u2227 False(p \\ pr(F \u2032))].\nby Proposition 1."}, {"heading": "C.10 Proof of Theorem 8", "text": "Assume that T is\nCIRC[\u03a3; Initiates,Terminates,Releases] \u2227 CIRC[\u2206; Happens] \u2227 CIRC[\u0398; Ab1, . . . ,Abn] \u2227 \u039e,\nwhich is equivalent to\nSM[\u03a3; Initiates,Terminates,Releases] \u2227 SM[\u2206; Happens] \u2227 SM[\u0398; Ab1, . . . ,Abn] \u2227 \u039e\n(63)\nby Theorem 2.\nLet \u039edef be the set of all definitions (35) in \u039e, and let \u039e \u2032 be the formula obtained from \u039e by applying Step 1. By Theorem 15, it follows that each formula (35) in \u039edef is equivalent to\nSM[\u2200x(G\u2032 \u2192 p(x)); p],\nwhere G\u2032 is as described in Step 1. Consequently, (63) is equivalent to\nSM[\u03a3; Initiates,Terminates,Releases] \u2227 SM[\u2206; Happens] \u2227 SM[\u0398; Ab1, . . . ,Abn] \u2227 \u2227 (35)\u2208\u039edef SM[\u2200x(G \u2032 \u2192 p(x)); p] \u2227 \u039e\u2032\u2032, (64)\nwhere \u039e\u2032\u2032 is the conjunction of all the axioms in \u039e\u2032 other than the ones obtained from definitional axioms (35).\nApplying Theorem 13 repeatedly, it follows that (64) is equivalent to\nSM[\u03a3 \u2227\u2206 \u2227\u0398 \u2227 \u039e\u2032\u2032 \u2227 \u2227\n(35)\u2208\u039edef \u2200x(G \u2032 \u2192 p(x));\nInitiates,Terminates,Releases,Happens,Ab1, . . . ,Abn,p] . (65)\nAccording to the syntax of the event calculus reviewed in Section 3.1,\n\u2022 every positive occurrence of a formula of the form \u2203yG(y) in (65) is contained in a subformula that is negative on {Initiates,Terminates,Releases,Happens,Ab1, . . . ,Abn,p}, and\n\u2022 there are no negative occurrences of any formula of the form \u2200yG(y) in (65).\nConsequently, the statement of the theorem follows from Theorem 7."}, {"heading": "C.11 Proof of Theorem 9", "text": "Since (37) is almost universal relative to {Caused ,Poss,Sit}, the result follows from Theorems 7 and 3."}, {"heading": "C.12 Proof of Theorem 10", "text": "From Dexogenous0 , it follows that SM[T ; Holds,\u223cHolds,Poss] is equivalent to SM[T\u00ac\u00ac; Holds,\u223cHolds,Poss], where T\u00ac\u00ac is obtained from T by prepending \u00ac\u00ac to all occurrences of Holds in DS0 . From the definition of a uniform formula (Reiter, 2001), it follows that T\u00ac\u00ac is almost universal relative to {Holds,\u223cHolds,Poss}. The result follows from Theorem 7."}], "references": [{"title": "Representing the Zoo World and the Traffic World in the language of the Causal Calculator", "author": ["V. Akman", "S. Erdo\u011fan", "J. Lee", "V. Lifschitz", "H. Turner"], "venue": "Artificial Intelligence,", "citeRegEx": "Akman et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Akman et al\\.", "year": 2004}, {"title": "Combining situation calculus and event calculus", "author": ["K.V. Belleghem", "M. Denecker", "D.D. Schreye"], "venue": "In Proceedings of International Conference on Logic Programming (ICLP),", "citeRegEx": "Belleghem et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Belleghem et al\\.", "year": 1995}, {"title": "On the relation between situation calculus and event calculus", "author": ["K.V. Belleghem", "M. Denecker", "D.D. Schreye"], "venue": "Journal of Logic Programming,", "citeRegEx": "Belleghem et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Belleghem et al\\.", "year": 1997}, {"title": "Explanatory diagnoses and their characterization by circumscription", "author": ["P. Besnard", "Cordier", "M.-O"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Besnard et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Besnard et al\\.", "year": 1994}, {"title": "Propositional theories are strongly equivalent to logic programs", "author": ["P. Cabalar", "P. Ferraris"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Cabalar and Ferraris,? \\Q2007\\E", "shortCiteRegEx": "Cabalar and Ferraris", "year": 2007}, {"title": "Reducing propositional theories in equilibrium logic to logic programs", "author": ["P. Cabalar", "D. Pearce", "A. Valverde"], "venue": "In Proceedings of Portuguese Conference on Artificial Intelligence (EPIA),", "citeRegEx": "Cabalar et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Cabalar et al\\.", "year": 2005}, {"title": "Computable functions in ASP: theory and implementation", "author": ["F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone"], "venue": "In Proceedings of International Conference on Logic Programming (ICLP),", "citeRegEx": "Calimeri et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2008}, {"title": "Inductive situation calculus", "author": ["M. Denecker", "E. Ternovska"], "venue": "Artificial Intelligence,", "citeRegEx": "Denecker and Ternovska,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Ternovska", "year": 2007}, {"title": "A logic of nonmonotone inductive definitions", "author": ["M. Denecker", "E. Ternovska"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Denecker and Ternovska,? \\Q2008\\E", "shortCiteRegEx": "Denecker and Ternovska", "year": 2008}, {"title": "TAL: Temporal action logics language specification and tutorial. Link\u00f6ping Electronic Articles in Computer and Information", "author": ["P. Doherty", "J. Gustafsson", "L. Karlsson", "J. Kvarnstr\u00f6m"], "venue": "Science ISSN 1401-9841,", "citeRegEx": "Doherty et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Doherty et al\\.", "year": 1998}, {"title": "Almost definite causal theories", "author": ["S. Do\u011fanda\u011f", "P. Ferraris", "V. Lifschitz"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Do\u011fanda\u011f et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Do\u011fanda\u011f et al\\.", "year": 2004}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Erdem and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Erdem and Lifschitz", "year": 2003}, {"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science, 1, 51\u201360.", "citeRegEx": "Fages,? 1994", "shortCiteRegEx": "Fages", "year": 1994}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Ferraris et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2007}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Ferraris et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Ferraris et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2009}, {"title": "Gringo : A new grounder for answer set programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Gebser et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Nonmonotonic causal theories", "author": ["E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner"], "venue": "Artificial Intelligence,", "citeRegEx": "Giunchiglia et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2004}, {"title": "Die formalen Regeln der intuitionistischen Logik", "author": ["A. Heyting"], "venue": "Sitzungsberichte der Preussischen Akademie von Wissenschaften. Physikalisch-mathematische Klasse, 42\u201356.", "citeRegEx": "Heyting,? 1930", "shortCiteRegEx": "Heyting", "year": 1930}, {"title": "Capturing parallel circumscription with disjunctive logic programs", "author": ["T. Janhunen", "E. Oikarinen"], "venue": "In Proc. of 9th European Conference in Logics in Artificial Intelligence", "citeRegEx": "Janhunen and Oikarinen,? \\Q2004\\E", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2004}, {"title": "Planning as satisfiability", "author": ["H. Kautz", "B. Selman"], "venue": "In Proceedings of European Conference on Artificial Intelligence (ECAI),", "citeRegEx": "Kautz and Selman,? \\Q1992\\E", "shortCiteRegEx": "Kautz and Selman", "year": 1992}, {"title": "Circumscriptive event calculus as answer set programming", "author": ["Kim", "T.-W", "J. Lee", "R. Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Kim et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2009}, {"title": "A logic-based calculus of events", "author": ["R. Kowalski", "M. Sergot"], "venue": "New Generation Computing,", "citeRegEx": "Kowalski and Sergot,? \\Q1986\\E", "shortCiteRegEx": "Kowalski and Sergot", "year": 1986}, {"title": "Reconciling the event calculus with the situation calculus", "author": ["R.A. Kowalski", "F. Sadri"], "venue": "Journal of Logic Programming,", "citeRegEx": "Kowalski and Sadri,? \\Q1997\\E", "shortCiteRegEx": "Kowalski and Sadri", "year": 1997}, {"title": "A reductive semantics for counting and choice in answer set programming", "author": ["J. Lee", "V. Lifschitz", "R. Palla"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Lee et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2008}, {"title": "Loop formulas for circumscription", "author": ["J. Lee", "F. Lin"], "venue": "Artificial Intelligence,", "citeRegEx": "Lee and Lin,? \\Q2006\\E", "shortCiteRegEx": "Lee and Lin", "year": 2006}, {"title": "First-order stable model semantics and first-order loop formulas", "author": ["J. Lee", "Y. Meng"], "venue": "Journal of Artificial Inteligence Research (JAIR),", "citeRegEx": "Lee and Meng,? \\Q2011\\E", "shortCiteRegEx": "Lee and Meng", "year": 2011}, {"title": "Yet another proof of the strong equivalence between propositional theories and logic programs", "author": ["J. Lee", "R. Palla"], "venue": "In Working Notes of the Workshop on Correspondence and Equivalence for Nonmonotonic Theories", "citeRegEx": "Lee and Palla,? \\Q2007\\E", "shortCiteRegEx": "Lee and Palla", "year": 2007}, {"title": "Situation calculus as answer set programming", "author": ["J. Lee", "R. Palla"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Lee and Palla,? \\Q2010\\E", "shortCiteRegEx": "Lee and Palla", "year": 2010}, {"title": "Circumscription", "author": ["V. Lifschitz"], "venue": "Gabbay, D., Hogger, C., & Robinson, J. (Eds.), Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298\u2013352. Oxford University Press.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "What is answer set programming", "author": ["V. Lifschitz"], "venue": "Proceedings of the AAAI Conference on Artificial Intelligence, pp. 1594\u20131597. MIT Press.", "citeRegEx": "Lifschitz,? 2008", "shortCiteRegEx": "Lifschitz", "year": 2008}, {"title": "Datalog programs and their stable models", "author": ["V. Lifschitz"], "venue": "de Moor, O., Gottlob, G., Furche, T., & Sellers, A. (Eds.), Datalog Reloaded: First International Workshop, Datalog 2010, Oxford, UK, March 16-19, 2010. Revised Selected Papers. Springer.", "citeRegEx": "Lifschitz,? 2011", "shortCiteRegEx": "Lifschitz", "year": 2011}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "Nested expressions in logic programs", "author": ["V. Lifschitz", "L.R. Tang", "H. Turner"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Lifschitz et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 1999}, {"title": "Representing transition systems by logic programs", "author": ["V. Lifschitz", "H. Turner"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Lifschitz and Turner,? \\Q1999\\E", "shortCiteRegEx": "Lifschitz and Turner", "year": 1999}, {"title": "Embracing causality in specifying the indirect effects of actions", "author": ["F. Lin"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 1985\u2013 1991.", "citeRegEx": "Lin,? 1995", "shortCiteRegEx": "Lin", "year": 1995}, {"title": "Compiling causal theories to successor state axioms and STRIPS-like systems", "author": ["F. Lin"], "venue": "Journal of Artificial Intelligence Research, 19, 279\u2013314.", "citeRegEx": "Lin,? 2003", "shortCiteRegEx": "Lin", "year": 2003}, {"title": "A logic of knowledge and justified assumptions", "author": ["F. Lin", "Y. Shoham"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Shoham,? \\Q1992\\E", "shortCiteRegEx": "Lin and Shoham", "year": 1992}, {"title": "From causal theories to logic programs (sometimes)", "author": ["F. Lin", "K. Wang"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Lin and Wang,? \\Q1999\\E", "shortCiteRegEx": "Lin and Wang", "year": 1999}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhou,? \\Q2011\\E", "shortCiteRegEx": "Lin and Zhou", "year": 2011}, {"title": "Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: a 25-Year Perspective, pp. 375\u2013398", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": null, "citeRegEx": "Marek and Truszczy\u0144ski,? \\Q1999\\E", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Circumscription\u2014a form of non-monotonic reasoning", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 13, 27\u201339,171\u2013172.", "citeRegEx": "McCarthy,? 1980", "shortCiteRegEx": "McCarthy", "year": 1980}, {"title": "Applications of circumscription to formalizing common sense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 26 (3), 89\u2013116.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Some philosophical problems from the standpoint of artificial intelligence", "author": ["J. McCarthy", "P. Hayes"], "venue": "Machine Intelligence,", "citeRegEx": "McCarthy and Hayes,? \\Q1969\\E", "shortCiteRegEx": "McCarthy and Hayes", "year": 1969}, {"title": "The event calculus in classical logic - alternative axiomatisations", "author": ["R. Miller", "M. Shanahan"], "venue": "Electronic Transactions on Artificial Intelligence,", "citeRegEx": "Miller and Shanahan,? \\Q1999\\E", "shortCiteRegEx": "Miller and Shanahan", "year": 1999}, {"title": "Commonsense reasoning", "author": ["E. Mueller"], "venue": "Morgan Kaufmann.", "citeRegEx": "Mueller,? 2006", "shortCiteRegEx": "Mueller", "year": 2006}, {"title": "Event calculus reasoning through satisfiability", "author": ["E.T. Mueller"], "venue": "Journal of Logic and Computation, 14 (5), 703\u2013730.", "citeRegEx": "Mueller,? 2004", "shortCiteRegEx": "Mueller", "year": 2004}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence, 25, 241\u2013273.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "A first order nonmonotonic extension of constructive logic", "author": ["D. Pearce", "A. Valverde"], "venue": "Studia Logica,", "citeRegEx": "Pearce and Valverde,? \\Q2005\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2005}, {"title": "Hypothetical reasoning about actions: From situation calculus to event calculus", "author": ["A. Provetti"], "venue": "Computational Intelligence, 12, 478\u2013498.", "citeRegEx": "Provetti,? 1996", "shortCiteRegEx": "Provetti", "year": 1996}, {"title": "A logic for default reasoning", "author": ["R. Reiter"], "venue": "Artificial Intelligence, 13, 81\u2013132.", "citeRegEx": "Reiter,? 1980", "shortCiteRegEx": "Reiter", "year": 1980}, {"title": "The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression", "author": ["R. Reiter"], "venue": "Lifschitz, V. (Ed.), Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, pp. 359\u2013380. Academic Press.", "citeRegEx": "Reiter,? 1991", "shortCiteRegEx": "Reiter", "year": 1991}, {"title": "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems", "author": ["R. Reiter"], "venue": "MIT Press.", "citeRegEx": "Reiter,? 2001", "shortCiteRegEx": "Reiter", "year": 2001}, {"title": "A circumscriptive calculus of events", "author": ["M. Shanahan"], "venue": "Artif. Intell., 77 (2), 249\u2013284.", "citeRegEx": "Shanahan,? 1995", "shortCiteRegEx": "Shanahan", "year": 1995}, {"title": "Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia", "author": ["M. Shanahan"], "venue": "MIT Press.", "citeRegEx": "Shanahan,? 1997", "shortCiteRegEx": "Shanahan", "year": 1997}, {"title": "The event calculus explained", "author": ["M. Shanahan"], "venue": "Artificial Intelligence Today, LNCS 1600, pp. 409\u2013430. Springer.", "citeRegEx": "Shanahan,? 1999", "shortCiteRegEx": "Shanahan", "year": 1999}, {"title": "Event calculus planning through satisfiability", "author": ["M. Shanahan", "M. Witkowski"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Shanahan and Witkowski,? \\Q2004\\E", "shortCiteRegEx": "Shanahan and Witkowski", "year": 2004}, {"title": "Cardinality constraint programs", "author": ["T. Syrj\u00e4nen"], "venue": "In Proceedings of European Conference on Logics in Artificial Intelligence (JELIA),", "citeRegEx": "Syrj\u00e4nen,? \\Q2004\\E", "shortCiteRegEx": "Syrj\u00e4nen", "year": 2004}, {"title": "Translating first-order theories into logic programs", "author": ["H. Zhang", "Y. Zhang", "M. Ying", "Y. Zhou"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Zhang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 54, "context": "As one of the oldest nonmonotonic formalisms, circumscription has found many applications in commonsense reasoning and model-based diagnoses (e.g., McCarthy, 1986; Shanahan, 1995; Besnard & Cordier, 1994).", "startOffset": 141, "endOffset": 204}, {"referenceID": 48, "context": "The stable model semantics is the mathematical basis of Answer Set Programming (ASP) (Marek & Truszczy\u0144ski, 1999; Niemel\u00e4, 1999; Lifschitz, 2008), which is being widely applied thanks to the availability of several efficient implementations, known as answer set solvers.", "startOffset": 85, "endOffset": 145}, {"referenceID": 31, "context": "The stable model semantics is the mathematical basis of Answer Set Programming (ASP) (Marek & Truszczy\u0144ski, 1999; Niemel\u00e4, 1999; Lifschitz, 2008), which is being widely applied thanks to the availability of several efficient implementations, known as answer set solvers.", "startOffset": 85, "endOffset": 145}, {"referenceID": 51, "context": "While circumscription is defined in terms of translation into classical (second-order) logic, stable models proposed by Gelfond and Lifschitz (1988) are defined in terms of grounding and fixpoints in the style of Reiter\u2019s default logic (Reiter, 1980).", "startOffset": 236, "endOffset": 250}, {"referenceID": 53, "context": "In particular, in the area of temporal reasoning, the former has served as a basis of classical logic based action calculi, such as the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001), the event calculus (Shanahan, 1995) and temporal action logics (Doherty,", "startOffset": 155, "endOffset": 193}, {"referenceID": 54, "context": "In particular, in the area of temporal reasoning, the former has served as a basis of classical logic based action calculi, such as the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001), the event calculus (Shanahan, 1995) and temporal action logics (Doherty,", "startOffset": 214, "endOffset": 230}, {"referenceID": 17, "context": "While circumscription is defined in terms of translation into classical (second-order) logic, stable models proposed by Gelfond and Lifschitz (1988) are defined in terms of grounding and fixpoints in the style of Reiter\u2019s default logic (Reiter, 1980).", "startOffset": 120, "endOffset": 149}, {"referenceID": 19, "context": "These definitions are also equivalent to the definition of Quantified Equilibrium Logic given by Pearce and Valverde (2005), which is defined in terms of the logic of Here-and-There (Heyting, 1930).", "startOffset": 182, "endOffset": 197}, {"referenceID": 47, "context": "More extensive developments have been later carried out on the classical logic foundation via circumscription (e.g., Shanahan, 1995, 1997, 1999; Miller & Shanahan, 1999; Mueller, 2004), but the relation to", "startOffset": 110, "endOffset": 184}, {"referenceID": 17, "context": "Since logic programs are viewed as a special class of first-order sentences under the stable model semantics, this definition extends the stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without limiting attention to Herbrand models.", "startOffset": 164, "endOffset": 193}, {"referenceID": 17, "context": "Since logic programs are viewed as a special class of first-order sentences under the stable model semantics, this definition extends the stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without limiting attention to Herbrand models. Essentially the same characterization was independently given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992).", "startOffset": 164, "endOffset": 355}, {"referenceID": 17, "context": "Since logic programs are viewed as a special class of first-order sentences under the stable model semantics, this definition extends the stable model semantics by Gelfond and Lifschitz (1988) to the full first-order level without limiting attention to Herbrand models. Essentially the same characterization was independently given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992). These definitions are also equivalent to the definition of Quantified Equilibrium Logic given by Pearce and Valverde (2005), which is defined in terms of the logic of Here-and-There (Heyting, 1930).", "startOffset": 164, "endOffset": 550}, {"referenceID": 53, "context": "Similar to the logic programming tradition of the event calculus, the situation calculus (McCarthy & Hayes, 1969; Reiter, 2001) can be implemented in Prolog, based on the fact that Clark\u2019s completion semantics accounts for definitional axioms.", "startOffset": 89, "endOffset": 127}, {"referenceID": 45, "context": "Based on the reduction of circumscription to completion, SAT-based event calculus systems were implemented, one by Shanahan and Witkowski (2004) and another by Mueller (2004).", "startOffset": 115, "endOffset": 145}, {"referenceID": 42, "context": "Based on the reduction of circumscription to completion, SAT-based event calculus systems were implemented, one by Shanahan and Witkowski (2004) and another by Mueller (2004). The latter system is called the dec reasoner,1 which outperforms the former thanks to a more efficient and general compilation method into propositional logic.", "startOffset": 160, "endOffset": 175}, {"referenceID": 36, "context": "In this paper, we reformulate Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001) in the first-order stable model semantics and in ASP.", "startOffset": 30, "endOffset": 66}, {"referenceID": 36, "context": "In this paper, we reformulate Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001) in the first-order stable model semantics and in ASP.", "startOffset": 30, "endOffset": 108}, {"referenceID": 36, "context": "In this paper, we reformulate Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001) in the first-order stable model semantics and in ASP. For basic action theories, we also provide an ASP-based encoding method that obtains Reiter\u2019s successor state axioms from the effect axioms and the generic inertia axioms adopted in ASP, the idea of which is close to Reiter\u2019s frame default (1980). The paper is organized as follows.", "startOffset": 30, "endOffset": 409}, {"referenceID": 13, "context": "2 Review: First-Order Stable Model Semantics This review follows the definition by Ferraris et al. (2011). There, the stable models are defined in terms of the SM operator, whose definition is similar to the CIRC operator in the previous section.", "startOffset": 83, "endOffset": 106}, {"referenceID": 32, "context": "Intensional predicates are analogous to output predicates in Datalog, and non-intensional predicates are analogous to input predicates in Datalog (Lifschitz, 2011).", "startOffset": 146, "endOffset": 163}, {"referenceID": 13, "context": "(Ferraris et al., 2007, Example 3). The stable models of F are any first-order models of (2). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}. According to Ferraris et al. (2011), this definition of an answer set, when applied to the syntax of logic programs, is equivalent to the traditional definition of an answer set that is based on grounding and fixpoints (Gelfond & Lifschitz, 1988).", "startOffset": 1, "endOffset": 197}, {"referenceID": 46, "context": "Reformulating the Event Calculus in the General Theory of Stable Models In this section, we review the syntax of circumscriptive event calculus described in Chapter 2 of the book by Mueller (2006). Based on the observation that the syntax conforms to the condition of canonicality, we present a few reformulations of the event calculus in the general theory of stable models.", "startOffset": 182, "endOffset": 197}, {"referenceID": 30, "context": "2 Reformulating the Event Calculus in the General Theory of Stable Models Following Ferraris, Lee, Lifschitz, and Palla (2009), about a formula F we say that it is negative on a list p of predicate constants if members of p have no strictly positive occurrences in F .", "startOffset": 99, "endOffset": 127}, {"referenceID": 13, "context": "The equivalence between (b) and (c) can be shown using the splitting theorem by Ferraris et al. (2009). The assumption that \u039e is negative on the intensional predicates is essential in showing that", "startOffset": 80, "endOffset": 103}, {"referenceID": 36, "context": "Reformulating the Situation Calculus in the General Theory of Stable Models In this section, we review and reformulate two versions of the situation calculus\u2014Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001).", "startOffset": 158, "endOffset": 194}, {"referenceID": 36, "context": "Reformulating the Situation Calculus in the General Theory of Stable Models In this section, we review and reformulate two versions of the situation calculus\u2014Lin\u2019s causal action theories (1995) and Reiter\u2019s basic action theories (2001).", "startOffset": 158, "endOffset": 236}, {"referenceID": 36, "context": "1 Review: Lin\u2019s Causal Action Theories We assume a many-sorted first-order language which contains a situation sort, an action sort, a fluent sort, a truth value sort and an object sort. We understand expression P (x, s), where P is a fluent name, as shorthand for Holds(P (x), s). We do not consider functional fluents here for simplicity. According to Lin (1995), a formula \u03c6(s) is called a simple state formula about s if \u03c6(s) does not mention Poss, Caused or any situation term other than possibly the variable s.", "startOffset": 10, "endOffset": 365}, {"referenceID": 51, "context": "We refer the reader to the book by Reiter (2001) for the definition of a uniform formula.", "startOffset": 35, "endOffset": 49}, {"referenceID": 14, "context": "Definition 4 (Ferraris et al., 2011) A formula F is strongly equivalent to formula G if, for any formula H containing F as a subformula (and possibly containing object, function and predicate constants that do not occur in F , G), and for any list p of distinct predicate constants, SM[H; p] is equivalent to SM[H \u2032; p], where H \u2032 is obtained from H by replacing an occurrence of F by G.", "startOffset": 13, "endOffset": 36}, {"referenceID": 5, "context": "1 Translating Quantifier-Free Formulas into Logic Programs Cabalar et al. (2005) define the following transformation that turns any propositional formula under the stable model semantics into a logic program.", "startOffset": 59, "endOffset": 81}, {"referenceID": 5, "context": "According to Cabalar et al. (2005), successive application of the rewriting rules above turn any propositional formula into a disjunctive logic program.", "startOffset": 13, "endOffset": 35}, {"referenceID": 5, "context": "According to Cabalar et al. (2005), successive application of the rewriting rules above turn any propositional formula into a disjunctive logic program. This result can be simply extended to turn any quantifier-free formula into a logic program. As noted by Cabalar et al. (2005), this translation may involve an exponential blowup in size, and Theorem 1 from their paper shows that indeed there is no vocabulary-preserving polynomial time algorithm to convert general propositional theories under the stable model semantics into disjunctive logic programs.", "startOffset": 13, "endOffset": 280}, {"referenceID": 49, "context": "1 of Pearce and Valverde (2005) preserve strong equivalence, which leads to the following theorem.", "startOffset": 5, "endOffset": 32}, {"referenceID": 49, "context": "Pearce and Valverde (2005) show that a sentence in QNc5, the monotonic basis of Quantified Equilibrium Logic, can be turned into prenex form, from which the result follows.", "startOffset": 0, "endOffset": 27}, {"referenceID": 49, "context": "Pearce and Valverde (2005) show that Skolemization works with QNc5, the monotonic basis of Quantified Equilibrium Logic, but as our example shows, this does not imply that Skolemization works with Quantified Equilibrium Logic.", "startOffset": 0, "endOffset": 27}, {"referenceID": 5, "context": "Turn the resulting quantifier-free formula into a logic program by applying the translation from Section 3 of the paper by Cabalar et al. (2005), which was also reviewed in Section 5.", "startOffset": 123, "endOffset": 145}, {"referenceID": 30, "context": "We illustrate this using the example from the work of Do\u011fanda\u011f, Ferraris, and Lifschitz (2004). There are 9 rooms and 12 doors as shown in Figure 1.", "startOffset": 78, "endOffset": 95}, {"referenceID": 58, "context": "Though this program does not satisfy syntactic conditions, such as \u03bb-restricted (Gebser, Schaub, & Thiele, 2007), \u03c9-restricted (Syrj\u00e4nen, 2004), or finite domain programs (Calimeri, Cozza, Ianni, & Leone, 2008), that answer set solvers usually impose in order to ensure finite grounding, the rules can still be finitely grounded", "startOffset": 127, "endOffset": 143}, {"referenceID": 53, "context": "In addition to \u03a0situation, we use the following program \u03a0executable in order to represent the set of executable situations (Reiter, 2001): executable(s0).", "startOffset": 123, "endOffset": 137}, {"referenceID": 36, "context": "Figure 3 shows an encoding of Lin\u2019s suitcase example (1995) in the language of f2lp (h is used to represent Holds), which describes a suitcase that has two locks and a spring loaded mechanism which will open the suitcase when both locks are up.", "startOffset": 30, "endOffset": 60}, {"referenceID": 36, "context": "Figure 3 shows an encoding of Lin\u2019s suitcase example (1995) in the language of f2lp (h is used to represent Holds), which describes a suitcase that has two locks and a spring loaded mechanism which will open the suitcase when both locks are up. This example illustrates how the ramification problem is handled in causal action theories. Since we fix the domain of situations to be finite, we require that actions not be effective in the final situations. This is done by introducing atom final(S). Consider the simple temporal projection problem by Lin (1995). Initially the first lock is down and the second lock is up.", "startOffset": 30, "endOffset": 560}, {"referenceID": 51, "context": "Figure 4 shows an encoding of the \u201cbroken object\u201d example discussed by Reiter (1991). Consider the simple projection problem of determining if an object o, which is next to bomb b, is broken after the bomb explodes.", "startOffset": 71, "endOffset": 85}, {"referenceID": 12, "context": "It is known that, for tight logic programs and tight first-order formulas, the stable model semantics coincides with the completion semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011).", "startOffset": 142, "endOffset": 203}, {"referenceID": 14, "context": "It is known that, for tight logic programs and tight first-order formulas, the stable model semantics coincides with the completion semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011).", "startOffset": 142, "endOffset": 203}, {"referenceID": 25, "context": "Proposition 8 from the work of Lee and Lin (2006) shows an embedding of propositional circumscription in logic programs under the stable model semantics.", "startOffset": 31, "endOffset": 50}, {"referenceID": 20, "context": "Janhunen and Oikarinen (2004) showed another embedding of propositional circumscription in logic programs, and implemented the system circ2dlp,24 but their translation appears quite different from the one by Lee and Lin.", "startOffset": 0, "endOffset": 30}, {"referenceID": 20, "context": "Janhunen and Oikarinen (2004) showed another embedding of propositional circumscription in logic programs, and implemented the system circ2dlp,24 but their translation appears quite different from the one by Lee and Lin. Zhang, Zhang, Ying, and Zhou (2011) show an embedding of first-order circumscription in first-order stable model semantics.", "startOffset": 0, "endOffset": 257}, {"referenceID": 50, "context": "The situation calculus and the event calculus are widely studied action formalisms, and there are several papers that compare and relate them (e.g., Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).", "startOffset": 142, "endOffset": 250}, {"referenceID": 2, "context": "The situation calculus and the event calculus are widely studied action formalisms, and there are several papers that compare and relate them (e.g., Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).", "startOffset": 142, "endOffset": 250}, {"referenceID": 47, "context": "Zhang et al. (2011) also introduce a translation that turns arbitrary first-order formulas into logic programs, but this work is limited to finite structures only.", "startOffset": 0, "endOffset": 20}, {"referenceID": 1, "context": ", Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997). Prolog provides a natural implementation for basic action theories since definitional axioms can be represented by Prolog rules according to the Clark\u2019s theorem (Reiter, 2001, Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules is similar to translation f2lp, but the difference is that the former preserves the completion semantics and the latter preserves the stable model semantics. Lin and Wang (1999) describe a language that can be used to represent a syntactically restricted form of Lin\u2019s causal situation calculus, called \u201cclausal causal theories,\u201d which does not allow quantifiers.", "startOffset": 56, "endOffset": 550}, {"referenceID": 1, "context": ", Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997). Prolog provides a natural implementation for basic action theories since definitional axioms can be represented by Prolog rules according to the Clark\u2019s theorem (Reiter, 2001, Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules is similar to translation f2lp, but the difference is that the former preserves the completion semantics and the latter preserves the stable model semantics. Lin and Wang (1999) describe a language that can be used to represent a syntactically restricted form of Lin\u2019s causal situation calculus, called \u201cclausal causal theories,\u201d which does not allow quantifiers. They show how to translate that language into answer set programs with strong negation, the answer sets of which are then used to obtain fully instantiated successor state axioms and action precondition axioms. This is quite different from our approach, which computes the propositional models of the full situation calculus theories directly. Kautz and Selman (1992) introduce linear encodings that are similar to a propositionalized version of the situation calculus (McCarthy & Hayes, 1969).", "startOffset": 56, "endOffset": 1104}, {"referenceID": 1, "context": ", Belleghem, Denecker, & Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997). Prolog provides a natural implementation for basic action theories since definitional axioms can be represented by Prolog rules according to the Clark\u2019s theorem (Reiter, 2001, Chapter 5). The Lloyd-Topor transformation that is used to turn formulas into Prolog rules is similar to translation f2lp, but the difference is that the former preserves the completion semantics and the latter preserves the stable model semantics. Lin and Wang (1999) describe a language that can be used to represent a syntactically restricted form of Lin\u2019s causal situation calculus, called \u201cclausal causal theories,\u201d which does not allow quantifiers. They show how to translate that language into answer set programs with strong negation, the answer sets of which are then used to obtain fully instantiated successor state axioms and action precondition axioms. This is quite different from our approach, which computes the propositional models of the full situation calculus theories directly. Kautz and Selman (1992) introduce linear encodings that are similar to a propositionalized version of the situation calculus (McCarthy & Hayes, 1969). Lin (2003) introduces", "startOffset": 56, "endOffset": 1242}, {"referenceID": 7, "context": "Denecker and Ternovska (2007) present an inductive variant of the situation calculus represented in ID-logic (Denecker & Ternovska, 2008)\u2014classical logic extended with inductive definitions.", "startOffset": 0, "endOffset": 30}, {"referenceID": 36, "context": "clingo is a system that combines gringo and clasp in a monolithic way. The first five examples in Figure 5 are part of the benchmark problems from the work of Shanahan (1997, 1999). The next four are by Mueller (2006). (We increased timepoints", "startOffset": 1, "endOffset": 218}, {"referenceID": 13, "context": "1 Review of Some Useful Theorems We review some theorems by Ferraris et al. (2011) and Ferraris et al.", "startOffset": 60, "endOffset": 83}, {"referenceID": 13, "context": "1 Review of Some Useful Theorems We review some theorems by Ferraris et al. (2011) and Ferraris et al. (2009) which will be used to prove our main results.", "startOffset": 60, "endOffset": 110}, {"referenceID": 13, "context": "1 Review of Some Useful Theorems We review some theorems by Ferraris et al. (2011) and Ferraris et al. (2009) which will be used to prove our main results. In fact, we will provide a version of the splitting theorem which is slightly more general than the one given by Ferraris et al. (2009), in order to facilitate our proof efforts.", "startOffset": 60, "endOffset": 292}, {"referenceID": 14, "context": "Theorem 15 (Ferraris et al., 2011) For any formula F in Clark normal form that is tight on p, formula SM[F ; p] is equivalent to the completion of F relative to p.", "startOffset": 11, "endOffset": 34}, {"referenceID": 13, "context": "The theorem is slightly more general than the one by Ferraris et al. (2009) in that the notion of a dependency graph above yields less edges than the one given by Ferraris et al.", "startOffset": 53, "endOffset": 76}, {"referenceID": 27, "context": "See Section 7 from the work of Lee and Meng (2011) for the definition.", "startOffset": 31, "endOffset": 51}, {"referenceID": 5, "context": "It follows from Proposition 3 from (Cabalar et al., 2005) that (61) is equivalent to SM[\u2200x\u2032\u2032 0H \u2032\u2032\u2032 0 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u2200x\u2032\u2032 mH \u2032\u2032\u2032 m \u2227 Choice(\u03c3 \\ p); \u03c3 \u222a r1 \u222a \u00b7 \u00b7 \u00b7 \u222a rm], (62) where H \u2032\u2032\u2032 i is obtained from H \u2032\u2032 i by applying the translation from (Cabalar et al.", "startOffset": 35, "endOffset": 57}, {"referenceID": 53, "context": "From the definition of a uniform formula (Reiter, 2001), it follows that T\u00ac\u00ac is almost universal relative to {Holds,\u223cHolds,Poss}.", "startOffset": 41, "endOffset": 55}], "year": 2012, "abstractText": "Circumscription and logic programs under the stable model semantics are two wellknown nonmonotonic formalisms. The former has served as a basis of classical logic based action formalisms, such as the situation calculus, the event calculus and temporal action logics; the latter has served as a basis of a family of action languages, such as language A and several of its descendants. Based on the discovery that circumscription and the stable model semantics coincide on a class of canonical formulas, we reformulate the situation calculus and the event calculus in the general theory of stable models. We also present a translation that turns the reformulations further into answer set programs, so that efficient answer set solvers can be applied to compute the situation calculus and the event calculus.", "creator": "TeX"}}}