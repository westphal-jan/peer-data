{"id": "1401.5869", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jan-2014", "title": "An Enhanced Branch-and-bound Algorithm for the Talent Scheduling Problem", "abstract": "The problem of talent planning is a simplified version of the real-life film-shooting problem, which aims to determine a shoot sequence to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we develop a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is improved by several acceleration techniques, including preprocessing, dominance rules, and caching search states. Extensive experiments across two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the effects of different parameter settings are revealed by some additional experiments.", "histories": [["v1", "Thu, 23 Jan 2014 04:09:45 GMT  (42kb)", "http://arxiv.org/abs/1401.5869v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["zizhen zhang", "hu qin", "xiaocong liang", "rew lim"], "accepted": false, "id": "1401.5869"}, "pdf": {"name": "1401.5869.pdf", "metadata": {"source": "CRF", "title": "An Enhanced Branch-and-bound Algorithm for the Talent Scheduling Problem", "authors": ["Zizhen Zhang", "Hu Qin", "Xiaocong Liang", "Andrew Lim"], "emails": ["zhangzizhen@gmail.com", "tigerqin@hust.edu.cn,", "tigerqin1980@gmail.com", "yurilxc@gmail.com", "lim.andrew@cityu.edu.hk"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 1.\n58 69\nv1 [\ncs .A\nI] 2\n3 Ja\nn 20\nThe talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings are disclosed by some additional experiments. Key words: branch and bound; talent scheduling; preprocessing; dynamic programming; dominance rules"}, {"heading": "1. Introduction", "text": "The scenes of a film are not generally shot in the same sequence as they appear in the final version. Finding an optimal sequence in which the scenes are shot motivates the\n\u2217Corresponding author at: School of Management, Huazhong University of Science and Technology, No. 1037, Luoyu Road, Wuhan, China. Tel.: +86 13349921096.\nEmail addresses: zhangzizhen@gmail.com (Zizhen Zhang), tigerqin@hust.edu.cn, tigerqin1980@gmail.com (Hu Qin), yurilxc@gmail.com (Xiaocong Liang), lim.andrew@cityu.edu.hk (Andrew Lim) Preprint submitted to Elsevier January 24, 2014\ninvestigation of the talent scheduling problem, which is formally described as follows. Let S = {s1, s2, . . . , sn} be a set of n scenes and A = {a1, a2, . . . , am} be a set of m actors. All scenes are assumed to be shot on a given location. Each scene sj \u2208 S requires a subset a(sj) \u2286 A of actors and has a duration d(sj) that commonly consists of one or several days. Each actor ai is required by a subset s(ai) \u2286 S of scenes. We denote by \u03a0 the permutation set of the n scenes and define ei(\u03c0) (respectively, li(\u03c0)) as the earliest day (respectively, the latest day) in which actor i is required to be present on location in the permutation \u03c0 \u2208 \u03a0. Each actor ai \u2208 A has a daily wage c(ai) and is paid for each day from ei(\u03c0) to li(\u03c0) regardless of whether they are required in the scenes. The objective of the talent scheduling problem is to find a shooting sequence (i.e., a permutation \u03c0 \u2208 \u03a0) of all scenes that minimizes the total paid wages.\nTable 1 presents an example of the talent scheduling problem, which is reproduced from de la Banda et al. (2011). The information of a(sj) and s(ai) is determined by the m \u00d7 n matrix M shown in Table 1(a), where cell Mi,j is filled with an \u201cX\u201d if actor ai participates in scene sj and with a \u201c\u00b7\u201d otherwise. Obviously, we can obtain a(sj) and s(ai) by a(sj) = {ai|Mi,j = X} and s(ai) = {sj|Mi,j = X}, respectively. The last row gives the duration of each scene and the rightmost column gives the daily cost of each actor. If the shooting sequence is \u03c0 = {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12}, we can get a matrix M(\u03c0) shown in Table 1(b), where in cell Mi,j(\u03c0) a sign \u201cX\u201d indicates that actor ai participates in scene sj and a sign \u201c\u2013\u201d indicates that actor ai is waiting at the filming location. The cost of each scene is presented in the second-to-last row and the total cost is 604. The cost incurred by the waiting status of the actors is called holding cost, which is shown in the last row of Table 1(b). The optimal solution of this instance is \u03c0\u2217 = {s5, s2, s7, s1, s6, s8, s4, s9, s3, s11, s10, s12} whose total cost and holding cost are 434 and 53, respectively.\nThe talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage. They proposed a simple dynamic programming algorithm to solve their problem. Cheng et al. (1993) studied a film scheduling problem in which all scenes\nhave identical duration. They first showed that the problem is NP-hard even if each actor is required by two scenes and the daily wage of each actor is one. Next, they devised a branchand-bound algorithm and a simple greedy hill climbing heuristic to solve their problem. Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.\nThe talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages. However, it is a simplified version of the movie shoot scheduling problem (MSSP) introduced by Bomsdorf and Derigs (2008). In the MSSP, we need to deal with a couple of practical constraints, such as the precedence relations among scenes, the time windows of each scene, the resource availability, and the working time\nwindows of actors and other film crew members.\nIn literature, there exist several meta-heuristics developed for the problem introduced by Cheng et al. (1993). Nordstro\u0308m and Tufekci (1994) provided several hybrid genetic algorithms for this problem and showed that their algorithms outperform the heuristic approach in Cheng et al. (1993) in terms of both solution quality and computation speed. Fink and Vo\u00df (1999) treated this problem as a special application of the general pattern sequencing problem, and implemented a simulated annealing algorithm and several tabu search heuristics to solve it.\nThe talent scheduling problem is a very challenging combinatorial optimization problem. The current best exact approach by de la Banda et al. (2011) can only optimally solve small- and medium-size instances. In this paper, we propose an enhanced branch-and-bound algorithm for the talent scheduling problem, which uses the following two main techniques:\n\u2022 Dominance rules. When a partial solution represented by a node in the search tree\ncan be dominated by another partial solution, this node need not be further explored and can be safely discarded.\n\u2022 Caching search states. The talent scheduling problem can be solved by dynamic pro-\ngramming algorithm (see de la Banda et al. (2011)). It is beneficial to incorporate the dynamic programming states into the branch-and-bound framework by memoization technique. In the branch-and-bound tree, each node is related to a dynamic programming state. If the search process explores a certain node whose already confirmed cost is not smaller than the value of its corresponding cached state, this node can be pruned.\nThere are three main contributions in this paper. Firstly, we formulate the talent scheduling problem as a mixed integer linear programming model so that commercial mathematical programming solvers can be applied to the problem. Secondly, we propose an enhanced branch-and-bound algorithm whose novelties include a new lower bound, caching search states and two problem-specific dominance rules. Thirdly, we achieved the optimal solutions for more benchmark instances by our algorithm. The experimental results show\nthat our branch-and-bound algorithm is superior to the current best exact approach by de la Banda et al. (2011).\nThe remainder of this paper is organized as follows. In Section 2, we present the mixed integer linear programming model for the talent scheduling problem. Next, we describe our branch-and-bound algorithm in Section 3, including the details on a double-ended search strategy, the computation of the lower bound, a preprocessing step, the state caching process and the dominance rules. The computational results are reported in Section 4, where we use our algorithm to solve over 200,000 benchmark instances. Finally, we conclude our study in Section 5 with some closing remarks."}, {"heading": "2. Mathematical Formulation", "text": "The talent scheduling problem is essentially a permutation problem. It tries to find a permutation (i.e., a schedule) \u03c0 = (\u03c0(1), . . . , \u03c0(n)) \u2208 \u03a0, where \u03c0(k) is the k-th scene in permutation \u03c0, such that the total cost C(\u03c0) is minimized. The value of C(\u03c0) is computed as:\nC(\u03c0) =\nm \u2211\ni=1\nc(ai)\u00d7 ( li(\u03c0)\u2212 ei(\u03c0) + 1 )\nWe set the parameter mi,j = 1 if Mi,j = X and mi,j = 0 otherwise. The total holding cost\ncan be easily derived as:\nH(\u03c0) =\nm \u2211\ni=1\nc(ai)\u00d7 ( li(\u03c0)\u2212 ei(\u03c0) + 1\u2212 n \u2211\nj=1\nmi,jd(sj)\n)\nApparently, for this problem minimizing the total cost is equivalent to minimizing the total\nholding cost.\nThe talent scheduling problem can be formulated into an integer linear programming\nformulation using the following decision variables:\nxi,j : a binary variable that equals 1 if scene sj is scheduled immediately after scene si, and\n0 otherwise.\ntj : the starting day for shooting scene sj .\nei: the earliest shooting day that requires actor ai.\nli: the latest shooting day that requires actor ai.\nThe integer programming formulation is given by:\n(IP) min\nm \u2211\ni=1\nc(ai)(li \u2212 ei + 1) (1)\ns.t.\nn \u2211\nj=0,i 6=j\nxi,j = 1, \u2200 0 \u2264 i \u2264 n (2)\nn \u2211\ni=0,i 6=j\nxi,j = 1, \u2200 0 \u2264 j \u2264 n (3)\nn \u2211\nj=0,i 6=j\ntjxi,j = ti + d(si), \u2200 1 \u2264 i \u2264 n (4)\nei \u2264 tj, \u2200 1 \u2264 i \u2264 m, 1 \u2264 j \u2264 n, mi,j = 1 (5)\ntj + d(sj)\u2212 1 \u2264 li, \u2200 1 \u2264 i \u2264 m, 1 \u2264 j \u2264 n, mi,j = 1 (6)\nxi,j \u2208 {0, 1}, \u2200 1 \u2264 i, j \u2264 n (7)\nei, li, tj \u2265 0 and integer, \u2200 1 \u2264 i \u2264 m, 1 \u2264 j \u2264 n (8)\nThe objective (1) is to minimize the total cost, where li \u2212 ei + 1 is the number of days in which actor ai is present on location. Constraints (2) and (3) guarantee that every scene has exactly one immediate successor and one immediate predecessor, respectively. Note that we create a dummy scene s0 which enables us to identify the first and the last scene to be shot. Constraints (4) state that the starting day of scene sj is determined by the starting day of its predecessor scene si. From this set of constraints, we can conclude that the starting day of the dummy scene s0 equals \u2211n j=1 d(sj). Moreover, these constraints prevent sub-tours from occurring. Constraints (5) and (6) ensure that the earliest and the latest shooting days that require actor ai are determined by the starting days of scenes in which he/she is involved.\nObserve that Constraints (4) are nonlinear. To linearize them, we introduce a set of additional variables zi,j(1 \u2264 i \u2264 n, 0 \u2264 j \u2264 n, i 6= j), and set zi,j = tjxi,j. We know that zi,j = tj if xi,j = 1 and zi,j = 0 otherwise. Thus, zi,j can be restricted by the following four\nlinear constraints:\nzi,j \u2265 0 (9)\nzi,j \u2264 tj (10)\nzi,j \u2265 tj + L(xi,j \u2212 1) (11)\nzi,j \u2264 Lxi,j (12)\nwhere L is a sufficiently large positive number, e.g., L = \u2211n\nj=1 d(sj). Accordingly, Con-\nstraints (4) can be rewritten as:\nn \u2211\nj=0,i 6=j\nzi,j = ti + d(si), \u2200 1 \u2264 i \u2264 n (13)\nThe objective (1) and Constraints (2) \u2013 (3), (5) \u2013 (13) constitute an integer linear programming model (ILP) for the talent scheduling problem. This ILP is quite difficult to be optimally solved by commercial integer programming solvers, e.g., ILOG CPLEX. Preliminary experiments revealed that only very small-scale instances, e.g., n = 10 and m = 5, can be optimally solved by CPLEX 12.1 with default settings. This is mainly because the linear relaxation of the ILP model cannot provide a high-quality lower bound for the problem."}, {"heading": "3. An Enhanced Branch-and-bound Approach", "text": "Branch-and-bound is a general technique for optimally solving various combinatorial optimization problems. The basic idea of the branch-and-bound algorithm is to systematically and implicitly enumerate all candidate solutions, where large subsets of fruitless candidates are discarded by using upper and lower bounds, and dominance rules. In this section, we describe the main components of our proposed branch-and-bound algorithm, including a double-ended search strategy, a novel lower bound, the preprocessing stage, the state caching strategy and two dominance rules. For the rest of this discussion, we choose minimizing the total holding cost as the objective of the talent scheduling problem."}, {"heading": "3.1. Double-ended Search", "text": "The solutions of the talent scheduling problem can be easily presented in a branch-andbound search tree. Suppose we aim to find an optimal permutation \u03c0\u2217 = (\u03c0\u2217(1), \u03c0\u2217(2), . . . ,\n\u03c0\u2217(n)). A typical branch-and-bound process first determines the first k scenes to be shot, denoted by a partial permutation (\u03c0\u0302(1), . . . , \u03c0\u0302(k)), at level k of the search tree. Then, it generates n\u2212 k branches, each trying to explore a node by assigning a scene to \u03c0(k+1). At some tree node at level k+1, there is a known partial permutation (\u03c0\u0302(1), \u03c0\u0302(2), . . . , \u03c0\u0302(k+1)) and a set of n\u2212k\u22121 unscheduled scenes. If the lower bound LB to the value of the solutions that contain the partial permutation (\u03c0\u0302(1), \u03c0\u0302(2), . . . , \u03c0\u0302(k + 1)) is not less than the current best solution value (i.e., an upper bound UB), then the branch to the node associated with \u03c0\u0302(k+1) can be safely discarded. Once the search process reaches a node at level n of the tree, a feasible solution is obtained and the current best solution may be updated accordingly.\nThe above search methodology can be called the single-ended search strategy. As did by Cheng et al. (1993) and de la Banda et al. (2011), we can employ a double-ended search strategy that alternatively fixes the first and the last undetermined positions in the permutation. That is to say, the double-ended search determines a scene permutation following the order \u03c0(1), \u03c0(n), \u03c0(2), \u03c0(n\u2212 1) and so on. When using the double-ended search strategy, a node in some level of the search tree corresponds to a partially determined permutation with the form (\u03c0\u0302(1), . . . , \u03c0\u0302(k\u22121), \u03c0(k), . . . , \u03c0(l), \u03c0\u0302(l+1), . . . , \u03c0\u0302(n)), where 1 \u2264 k \u2264 l \u2264 n and the value of \u03c0(h) (k \u2264 h \u2264 l) is undetermined. We denote by B the set of scenes scheduled at the beginning of the permutation, namely B = {\u03c0\u0302(1), \u03c0\u0302(2), . . . , \u03c0\u0302(k \u2212 1)}, and by E the set of scenes scheduled at the end, namely E = {\u03c0\u0302(l + 1), \u03c0\u0302(l + 2), . . . , \u03c0\u0302(n)}. The remaining scenes are put in a set Q, namely Q = S \u2212 B \u2212 E. Moreover, for convenience, we denote by ~B and ~E the partially determined scene sequences at the beginning and at the end of a permutation, i.e., ~B = (\u03c0\u0302(1), . . . , \u03c0\u0302(k \u2212 1)) and ~E = (\u03c0\u0302(l + 1), . . . , \u03c0\u0302(n)).\nThe double-ended search strategy is beneficial to solving the talent scheduling problem. As pointed out by de la Banda et al. (2011), it can help obtain more accurate lower bounds by increasing the number of fixed actors. The actor required by the scenes in both B and E is labeled fixed since the total number of his/her on-location days is fixed and his/her cost in the final schedule already becomes known. We do not need to consider any fixed actor in the later stages of the search process, which certainly reduces the size of the problem. Let a(Q) = \u222as\u2208Qa(s) be the set of actors required by at least one scene in Q \u2286 S. The set of\nfixed actors can be represented by F = a(B) \u2229 a(E).\nA generic double-ended branch-and-bound framework is given in Algorithm 1. The operator \u201c\u25e6\u201d in lines 2 and 13 indicates concatenating two partially determined scene sequences. The function search( ~B,Q, ~E) returns the optimal solution to the talent scheduling problem with known ~B and ~E, denoted by P ( ~B,Q, ~E). The optimal solution of the talent scheduling problem can be achieved by invoking search( ~B,Q, ~E) with B = E = \u2205 and Q = S. The function evaluate(solution) returns the value of solution. The function lower bound( ~B\u25e6s,Q\u2212{s}, ~E) provides a valid lower bound to problem P ( ~B\u25e6s,Q\u2212{s}, ~E), where the set B of scenes is scheduled before scene s and the set S \u2212 B \u2212 {s} of scenes is scheduled after scene s. The branch-and-bound search tries to schedule each remaining scene s immediately after ~B, and then swaps the roles of ~B and ~E to continue building the search tree (see line 13).\nAlgorithm 1: A generic double-ended branch-and-bound search framework.\nFunction: search( ~B,Q, ~E)\n1 if Q = \u2205 then 2 current solution = ~B \u25e6 ~E; 3 z = evaluate(current solution); 4 if z < UB then 5 UB := z; 6 best solution := current solution;\n7 end 8 return;\n9 end\n10 foreach s \u2208 Q do 11 LB := lower bound( ~B \u25e6 s,Q\u2212 {s}, ~E); 12 if LB \u2265 UB then continue; 13 search( ~E,Q\u2212 {s}, ~B \u25e6 s);\n14 end\n3.2. Lower Bound to P ( ~B,Q, ~E)\nThe problem P ( ~B,Q, ~E) corresponds to a node in the search tree. Its lower bound\nlower bound( ~B,Q, ~E) can be expressed as:\nlower bound( ~B,Q, ~E) = cost( ~B, ~E) + lower(B,Q,E),\nwhere cost( ~B, ~E), called past cost, is the cost incurred by the path from the root node to the current node, and lower(B,Q,E) provides a lower bound to future cost, i.e., the holding cost to be incurred by scheduling the scenes in Q. We discuss the past cost cost( ~B, ~E) in this subsection and leave the description of lower(B,Q,E) in Subsection 3.4.\nWhen ~B and ~E have been fixed, a portion of holding cost, namely cost( ~B, ~E), is determined regardless of the schedule of the scenes in Q. The past cost cost( ~B, ~E) is incurred by the holding days that can be confirmed by the following three ways:\n1. For the actor ai \u2208 a(B) \u2229 a(E), the number of his/her holding days in any complete\nschedule can be fixed (Cheng et al., 1993).\n2. For the actor ai \u2208 a(B)\u2229a(Q)\u2212a(E), the number of his/her holding days in the time\nperiod for completing scenes in B can be fixed.\n3. For the actor ai \u2208 a(E)\u2229a(Q)\u2212a(B), the number of his/her holding days in the time\nperiod for completing scenes in E can be fixed.\nFurthermore, we use cost(s, B, E) to represent the newly confirmed holding cost incurred by placing scene s \u2208 Q at the first unscheduled position, namely the position after any scene in B and before any scene in S\u2212B\u2212{s}. Note that cost(s, B, E) is irrelevant to the orders of scenes in B and E. Obviously, we have cost( ~B \u25e6 {s}, ~E) = cost( ~B, ~E) + cost(s, B, E), which implies that the past cost of a tree node is the sum of the past cost of its father node and the newly confirmed holding cost incurred by branching. As a result, the lower bound function can be rewritten as:\nlower bound( ~B \u25e6 s,Q\u2212 {s}, ~E) = cost( ~B, ~E) + cost(s,B,E) + lower(B \u222a {s}, Q\u2212 {s}, E).\nThe value of cost(s, B, E) is incurred by the following two type of actors:\nType 1. If actor ai is included in neither a(B) \u2229 a(E) nor a(s) but is still present on location during the days of shooting scene s (i.e., ai /\u2208 a(B) \u2229 a(E), ai /\u2208 a(s) and ai \u2208 a(B) \u2229 a(Q\u2212 {s})), he/she must be held during the shooting days of scene s.\nType 2. If actor ai is not included in a(B)\u2229 a(E) but is included in a(E), and scene s is his/her first involved scene (i.e., ai /\u2208 a(B) and ai \u2208 a(s) and ai \u2208 a(E)), the shooting days of those scenes in Q\u2212 {s} that do not require actor ai can be confirmed as his/her holding days.\nTo demonstrate the computation of cost( ~B, ~E) and cost(s, B, E), let us consider a partial schedule presented in Table 2, where ~B = (s1, s2), ~E = (s5, s6) and Q = S \u2212 B \u2212 E = {s3, s4}. In the columns \u201ccost( ~B, ~E)\u201d, \u201ccost(s3, B, E)\u201d and \u201ccost(s4, B, E)\u201d, we present the corresponding holding cost associated with each actor. For example, the value of cost( ~B, ~E) can be obtained by summing up the values in all cells of the column \u201ccost( ~B, ~E)\u201d. Since actor a1 is a fixed actor, his/her holding cost must be c(a1)(d(s2)+d(s4)) no matter how the scenes in Q are scheduled. Actor a2 is involved in B and Q but is not involved in E, so we can only say that the holding cost of this actor is at least c(a2)d(s2). Similarly, actor a3 has an already incurred holding cost c(a3)d(s5). For actors a4 and a5, we cannot get any clue on their holding costs from this partial schedule and thus we say their already confirmed holding costs are both zero. Suppose scene s4 is placed at the first unscheduled position. Since actors a2 and a4 must be present on location during the period of shooting scene s4, the newly confirmed holding cost is cost(s4, B, E) = (c(a2) + c(a4))d(s4). If we suppose scene s3 is placed at the first unscheduled position, the newly confirmed holding cost is only related to actor a3, namely, cost(s3, B, E) = c(a3)d(s4).\nDefine o(Q) = a(S \u2212 Q) \u2229 a(Q) as the set of actors required by scenes in both Q and\nS\u2212Q (de la Banda et al., 2011). Then, cost(s, B, E) can be mathematically computed by:\ncost(s,B,E) =d(s)\u00d7 c ( o(B)\u2212 o(E) \u2212 a(s) )\n+ \u2211\ns\u2032\u2208Q\u2212{s}\nd(s\u2032)\u00d7\n(\nc ( ( a(s)\u2212 o(B) ) \u2229 o(E) ) \u2212 c ( ( a(s)\u2212 o(B) ) \u2229 o(E) \u2229 a(s\u2032) )\n)\n,\n(14)\nwhere c(G) is the total daily cost of all actors in G \u2286 A, i.e., c(G) = \u2211\na\u2208G c(a).\nWe use Table 3 to explain Expression (14). All actors can be classified into 16 patterns according to whether they are required by the scenes in sets B, {s}, Q \u2212 {s} and E. If an actor of some pattern is required by at least one scene in some set, the corresponding cell in columns 2 \u2013 5 is filled with a sign \u201cX\u201d; otherwise it is filled with a sign \u201c\u00b7\u201d. In columns 6 \u2013 12, if an actor of some pattern is included in some actor set, the corresponding cell is filled with \u201c1\u201d; otherwise, it is filled with \u201c0\u201d. For example, for patten 2 actors that has (B, {s}, Q\u2212 {s}, E) = (\u00b7,X,X,X), we can derive that all actors of this patten must be included in sets o(E), a(s), a(s) \u2212 o(B) and (a(s) \u2212 o(B)) \u2229 o(E) and cannot exist in sets o(B), o(B)\u2212 o(E) and o(B)\u2212 o(E)\u2212 a(s).\nFrom Table 3, we can observe that set o(B) \u2212 o(E) \u2212 a(s) only contains type 1 actors that have patten (B, {s}, Q\u2212{s}, E) = (X, \u00b7,X, \u00b7). Thus, the first component of Expression (14) corresponds to type 1 actors. Set ( a(s)\u2212 o(B) ) \u2229 o(E) contains type 2 actors that have either pattern (B, {s}, Q\u2212{s}, E) = (\u00b7,X,X,X) or pattern (B, {s}, Q\u2212{s}, E) = (\u00b7,X, \u00b7,X). The second component of Expression (14) is the holding cost of type 2 actors during the shooting days for the scenes in Q\u2212 {s}."}, {"heading": "3.3. Preprocessing", "text": "The holding costs of all fixed actors will not change in the later stages of the search. We use set AN to contain all non-fixed actors, namely AN = {ai \u2208 A : ai /\u2208 a(B) \u2229 a(E)}. When solving problem P ( ~B,Q, ~E), we only need to consider the actors in AN . The problem P ( ~B,Q, ~E) can be further simplified as:\nThe example shown in Table 4 illustrates the preprocessing steps. In the problem given by Table 4(a), actor a4 is fixed and actor a5 is not required by the scenes in Q = {s1, s2, s3, s4}. Therefore, we can remove actors a4 and a5 to make AN = {a1, a2, a3}. Now since a(s2)\u2229AN = a(s3) \u2229 AN = {a1, a2, a3}, we merge scenes s2 and s3. After these preprocessing steps, we can get a new problem as shown in Table 4(b)."}, {"heading": "3.4. Lower Bound to Future Cost", "text": "In de la Banda et al. (2011), the authors proposed a lower bound to the future cost. They generated two lower bounds using (o(B)\u2212 F , Q) and (o(E)\u2212 F , Q) as input information, and claimed that the sum of these two lower bounds is still a lower bound (denoted by L0) to the future cost. The reader is encouraged to refer to de la Banda et al. (2011) for the details of this lower bound.\nIn this subsection, we present a new implementation of lower(B,Q,E). Suppose \u03c3 is an arbitrary permutation of the scenes in Q. We denote by xi the holding cost of actor ai during the period of shooting the scenes in Q with the order specified by permutation \u03c3. If lower(B,Q,E) = min\u03c3{ \u2211\ni\u2208AN xi}, we get the minimum possible future cost. However, it\nis impossible to get the value of min\u03c3{ \u2211\ni\u2208AN xi} unless all \u03c3 are checked. In the following\ncontext, we describe a method for a lower bound to min\u03c3{ \u2211\ni\u2208AN xi}.\nIf an actor ai satisfies ai /\u2208 a(B), ai /\u2208 a(E) and ai \u2208 a(Q), the lowest possible holding cost of this actor during the the period of shooting the scenes in Q may be zero. Therefore, we only consider the actors in set A\u2032N = (o(B) \u2212 F ) \u222a (o(E) \u2212 F ) \u2286 AN . For any two different actors ai, aj \u2208 A \u2032 N , we can derive a constraint xi+xj \u2265 ci,j, where ci,j is a constant computed based on the following four cases:\nCase 1: ai, aj \u2208 o(B) \u2212 F . Let ai(s) = \u201cX\u201d if actor ai is required by scene s and ai(s) = \u201c\u00b7\u201d otherwise. For any scene s \u2208 Q, the tuple (ai(s), aj(s)) must have one of the following four patterns: (X, X), (X, \u00b7), (\u00b7, X), (\u00b7, \u00b7). First, we schedule all scenes with\npattern (X, X) immediately after the scenes in B and schedule all scenes with pattern (\u00b7, \u00b7) immediately before the scenes in E. Second, we group the scenes with (X, \u00b7) and the scenes with (\u00b7, X) into two sets. Third, we schedule these two set of scenes in the middle of the permutation, creating two schedules as shown in Table 5. If only actors ai and aj are considered, the optimal schedule must be either one of these two schedules. The value of ci,j is set to the holding cost of the optimal schedule. For the schedule in Table 5(a), if we define S1 = {s \u2208 Q|(ai(s), aj(s)) = (X, \u00b7)}, then the holding cost is c(aj)\u00d7 d(S1), where d(S1) = \u2211\ns\u2208S1 d(s). Similarly, for the schedule in Table 5(b), we have\na holding cost c(ai)\u00d7 d(S2), where S2 = {s \u2208 Q|(ai(s), aj(s)) = (\u00b7, X)}. Accordingly, we set ci,j = min{c(aj)\u00d7 d(S1), c(ai)\u00d7 d(S2)}.\nCase 2: ai, aj \u2208 o(E)\u2212F . We schedule all scenes with pattern (X, X) immediately before the scenes in E and schedule all scenes with pattern (\u00b7, \u00b7) immediately after the scenes in B. The remaining analysis is similar to that in Case 1.\nCase 3: ai \u2208 o(B) \u2212 F and aj \u2208 o(E) \u2212 F . We schedule all scenes with pattern (X, \u00b7) immediately after the scenes in B and schedule all scenes with pattern (\u00b7, X) immediately before the scenes in E. If there does not exist a scene with pattern (X, X), the holding cost may be zero and thus ci,j is set to zero; otherwise ci,j is set to min{c(ai), c(aj)} \u00d7 d(S0), where S0 = {s \u2208 Q|(ai(s), aj(s)) = (\u00b7, \u00b7) }, which can be observed from Table 6.\nCase 4: ai \u2208 o(E)\u2212 F and aj \u2208 o(B)\u2212 F . This case is the same as Case 3. A valid lower bound to the future cost (i.e., the value of lower(B,Q,E)) can be obtained\nby solving the following linear programming model:\n(LB) zLB =min \u2211\nai\u2208A\u2032N\nxi (15)\ns.t. xi + xj \u2265 ci,j, \u2200 ai, aj \u2208 A \u2032 N , i 6= j (16)\nxi \u2265 0, \u2200 ai \u2208 A \u2032 N (17)\nThe value of zLB must be a valid lower bound to min\u03c3{ \u2211\ni\u2208AN xi}. If the daily holding cost\nof actor ai is an integral number, decision variable xi should be integer. When all variables xi are integers, the model (LB) is an NP-hard problem since it can be easily reduced to the minimum vertex cover problem (Karp, 1972). If all variables xi are treated as real numbers, this model can be solved by a liner programming solver. For some instances, the (LB) model needs to be solved more than two million times. To save computation time, we apply the following two heuristic approaches to rapidly produce two lower bounds, i.e., L1 and L2, to zLB. Obviously, L1 and L2 are also valid lower bounds to the future cost.\nApproach 1: Sum up the left-hand-side and righ-hand-side of Equations (16), generating\n(|A\u2032N | \u2212 1) \u2211\nai\u2208A\u2032N xi \u2265\n\u2211\nai,aj\u2208A\u2032N ,i 6=j ci,j. The valid lower bound L1 is defined as:\nL1 = \u2211\nai,aj\u2208A\u2032N ,i 6=j\nci,j/(|A \u2032 N | \u2212 1).\nApproach 2: Sort ci,j in descending order. If we select a ci,j, we call the corresponding xi and xj marked. Beginning from the largest ci,j, we select all ci,j whose xi and xj are not marked until all xi are marked. The valid lower bound L2 equals the sum of all selected ci,j. This approach was termed the greedy matching algorithm (Drake and Hougardy, 2003). To\ndemonstrate the process of computing L2, we consider the following six constraints:\nx1 + x2 \u2265 2, x1 + x3 \u2265 7, x1 + x4 \u2265 6,\nx2 + x3 \u2265 12, x2 + x4 \u2265 8, x3 + x4 \u2265 5.\nWe first select c2,3 = 12 and mark x2 and x3. Then, we can only select c1,4 = 6 since x1 and x4 have not been marked. Now all xi are marked and the value of L2 equals 18.\nIn our algorithm, we set lower(B, Q, E) = max{L0, L1, L2}."}, {"heading": "3.5. Caching Search States", "text": "In de la Banda et al. (2011), the talent scheduling problem was solved by a double-ended dynamic programming (DP) algorithm, where a DP state is represented by \u3008B,E\u3009. The DP algorithm stores the best value of each examined state, denoted by \u3008B,E\u3009.value, which equals the minimum past cost of all search paths associated with sets B and E.\nWe embed the DP process in the branch-and-bound framework by use of memoization technique (Michie, 1968). More precisely, when the search process reaches a tree node P ( ~B,Q, ~E), it first checks whether the value of cost( ~B, ~E) is less than the current \u3008B,E\u3009.value. If so, it updates \u3008B,E\u3009.value by cost( ~B, ~E); otherwise, the current node must be dominated by some node and therefore can be safely discarded.\nA better state representation for the DP algorithm is \u3008o(B), o(E), Q\u3009, where Q = S \u2212 B\u2212E; this was discussed by de la Banda et al. (2011) as follows. The cost of scheduling the scenes in Q = S \u2212 B \u2212 E depends on o(B) and o(E) rather than B and E. Suppose ~B ~Q~E and ~B\u2032 ~Q ~E \u2032 are two permutations of S, where B, Q, E, B\u2032 and E \u2032 are the corresponding sets of scenes. If o(B) = o(B\u2032) and o(E) = o(E \u2032), then the holding costs incurred by ~Q in these two permutations are equivalent. Moreover, if there are two states \u3008o(B), o(E), Q\u3009 and \u3008o(B\u2032), o(E \u2032), Q\u3009 that have o(B) = o(E \u2032) and o(E) = o(B\u2032), they are equivalent according to the symmetric property of the problem. Thus, we only need to memoize the state \u3008o(B), o(E), Q\u3009 that satisfies o(B) \u2264 o(E). We compare o(B) with o(E) based on the lexicographical order of the actor indices. For example, given o(B) = {a1, a2, a4, a5} and o(E) = {a1, a3, a6, a7}, we have o(B) \u2264 o(E) since the index of a2 is less than that of a3.\nWe also use the memoization technique to prune the search tree node. The process of checking whether a given node associated with problem P ( ~B,Q, ~E) can be pruned is depicted in Algorithm 2. All states are stored in a hash table hashTable. This algorithm first designates a storage slot in the hash table for state \u3008o(B), o(E), Q\u3009 using function hash(o(B), o(E), Q). If the storage slot contains the state and the current value of the state is less than or equal to cost( ~B, ~E), the algorithm returns true, implying that the given node can be pruned (see line 3). Next, it checks whether the state \u3008o(B), o(E), Q \u2212 {s}\u3009 (s \u2208 Q) exists in the hash table and has a value less than or equal to cost( ~B, ~E) (see lines 4 \u2013 7). If such states exist, the given node can also be pruned. The correctness of this pruning condition is guaranteed by Property 1, which was derived from the second theorem in de la Banda et al. (2011).\nAlgorithm 2: The process of checking whether a given search node can be pruned.\nFunction: check( ~B,Q, ~E)\n1 pc = cost( ~B, ~E) ; 2 index := hash(o(B), o(E), Q) ; 3 if hashTable[index].state = \u3008o(B), o(E), Q\u3009 and hashTable[index].value \u2264 pc then\nreturn true ;\n4 foreach s \u2208 Q do 5 index2 := hash(o(B), o(E), Q \u2212 {s}) ; 6 if hashTable[index2].state = \u3008o(B), o(E), Q \u2212 {s}\u3009 and hashTable[index2].value \u2264 pc\nthen return true ;\n7 end 8 if replace(index, pc) then 9 hashTable[index].state := \u3008o(B), o(E), Q\u3009 ;\n10 hashTable[index].value := pc ;\n11 end 12 return false ;\nProperty 1. Suppose ~B ~Q~E and ~B\u2032 ~Q\u2032 ~E \u2032 are two permutations of S, where B, Q, E, B\u2032, Q\u2032\nand E \u2032 are the corresponding sets of scenes. If o(B) = o(B\u2032), o(E) = o(E \u2032), Q \u2286 Q\u2032 and the scenes in ~Q follow the order in which they appear in ~Q\u2032, then the holding cost incurred by ~Q is not greater than that incurred by ~Q\u2032.\nIdeally, the hash function should assign each state to a unique storage slot, i.e., no hash collisions happen. However, this ideal situation is rarely achievable due to the huge number of states and the inadequate storage space. When solving the talent scheduling problem, we do not have sufficient storage space to store the exponential number of search states and therefore different states may be assigned by the hash function to the same storage slot, leading to hash collisions. To resolve this issue, we employ a mechanism called direct mapped caching scheme. Assume the direct mapped cache consists of C slots, each of which can only store one item. If an item is to be stored in a slot that already contains another item (i.e., a hash collision occurs), it may either replace the existing item or be discarded, which is decided by function replace(index, pc). Several previous articles, such as Hilden (1976) and Pugh (1988), have discussed the replacement strategies implemented in replace(index, pc). In this work, we tried latest and greedy caching strategies. The first strategy deals with the hash collisions by simply overwriting the cache slot while the second one stores in the cache slot the item that has smaller value.\nThe direct mapped caching scheme can effectively prune the search nodes using limited storage space. When a state is revisited again but it has been removed from the cache during the previous stages, the search can still continue to explore its corresponding subtree. In Section 4, we experimentally analyze the impact of different values of C and the two replacement strategies on the performance of our branch-and-bound algorithm."}, {"heading": "3.6. Dominance Rules", "text": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kellego\u0308z and Toklu, 2012) and dynamic programming algorithms (Dumas et al., 1995; Mingozzi et al., 1997; Rong and Figueira, 2013) for reducing search space. The purpose of dominance rules is to determine when the partial solution represented by a node in the search tree is dominated by another node; if so, the\nnode need not be further explored and can be safely pruned. In our branch-and-bound algorithm, two dominance rules are employed to reduce the search space."}, {"heading": "3.6.1. Dominance Rule 1", "text": "At a branch-and-bound tree node associated with problem P ( ~B,Q, ~E), we suppose that scene s1 is the scene to be scheduled immediately after B and scene s2 belongs to Q\u2212{s1}. If a(s1) \u222a o(B) \u2287 a(s2) \u222a o(B) and a(s1) \u222a o(E) \u2286 a(s2) \u222a o(E), then the branch associated with scene s1 can be ignored.\nTables 7 \u2013 8 are used to explain this dominance rule. In Table 7, Q = {s1, s2}\u222a\u21261 \u222a\u21262, where \u21261 and \u21262 are two arbitrary subsets of Q \u2212 {s1, s2} and \u21261 \u2229 \u21262 = \u2205. Actors in AN can be classified into twelve patterns according to whether they are required by the scenes in sets B, E, {s1} and {s2}. Since we do not need the information related to \u21261 and \u21262, all cells in columns 4 and 6 remain empty. Similar to Table 3, the numbers 1 and 0 in the right part of Table 7 indicate whether an actor of some pattern is included in the corresponding actor set.\nIn the absence of the information in columns 4 and 6, we cannot directly judge whether patten 4 actors are included in o(B) and whether patten 8 actors are included in o(E). However, we know that all remaining actors are non-fixed and must be required by the scenes in Q. In other words, if some pattern 4 and 8 actors are kept in AN , then they must be required by some scene in \u21261 \u222a \u21262. Therefore, we fill the corresponding cells with \u201c1\u201d (see the numbers in bold in Table 7).\nWe list in the left part of Table 8 all actor patterns that satisfy the conditions a(s1) \u222a o(B) \u2287 a(s2) \u222a o(B) and a(s1) \u222a o(E) \u2286 a(s2) \u222a o(E). Table 8 shows that branching to scene s1 is dominated by branching to scene s2. After exchanging the positions of scenes s1 and s2, the holding costs for pattern 1, 4 \u2013 5, 8 \u2013 9 and 12 actors remain unchanged while the holding costs for pattern 3 and 6 actors are probably reduced. Thus, scheduling scene s2 immediately after B must result in less or equal holding cost than scheduling scene s1 at that position."}, {"heading": "3.6.2. Dominance Rule 2", "text": "At a branch-and-bound tree node associated with problem P ( ~B,Q, ~E), we suppose that s1 is the scene to be scheduled immediately after B and s2 belongs to Q\u2212 {s1}. If a(s1) \u222a o(B) \u2287 a(s2) \u222a o(B) and c((a(s1) \u222a o(B)) \u2229 (a(s2) \u222a o(E)))\u2212 c(a(s2) \u222a o(B)) > 0, then the branch associated with scene s1 can be ignored.\nWe list in the left part of Table 9 all actor patterns that satisfy the conditions a(s1) \u222a o(B) \u2287 a(s2)\u222a o(B). The right part of Table 9 is the result of shifting scene s2 immediately before scene s1 and immediately after B. From Table 9, we can get the following four observations: (1) the holding costs for pattern 9 actors remain unchanged; (2) the holding costs for pattern 1, 3, 8 \u2013 10 and 12 actors are probably reduced; (3) the holding cost of each\nactor ai with pattern 2 or 4 is probably increased by c(ai)d(s2); (4) the holding cost of each patten 6 actor aj is definitely decreased by c(aj)d(s2). If the decreased amount (related to patten 6 actors) is greater than the increased amount (related to pattern 2 and 4 actors), then shifting scene s2 immediately before scene s1 must lead to a cost reduction. Given that a(s1)\u222ao(B) \u2287 a(s2)\u222ao(B) is satisfied, the set a(s1)\u222ao(B))\u2229 (a(s2)\u222ao(E) includes pattern 1, 3, 5 \u2013 6 and 9 actors and the set a(s2)\u222a o(B) includes patterns 1 \u2013 5, and 9 actors. Thus, if a(s1) \u222a o(B) \u2287 a(s2) \u222a o(B) and c((a(s1) \u222a o(B)) \u2229 (a(s2) \u222a o(E)))\u2212 c(a(s2) \u222a o(B)) > 0, scheduling scene s2 immediately after B must result in less or equal holding cost than scheduling scene s1 at that position."}, {"heading": "3.7. The Enhanced Branch-and-bound Algorithm", "text": "Our enhanced branch-and-bound algorithm for the talent scheduling problem is given by Algorithm 3, where the value of past cost z is initialized to zero at the root node. The preprocessing stage is realized by function preprocess(Q,AN) (see line 8, Algorithm 3). The state caching technique is adopted through function check( ~B,Q, ~E) (see line 9, Algorithm 3). The function isDominated( ~B,Q, ~E,AN , z, s) employs the proposed two dominance rules to check whether branching to some scene s is dominated by other branches. The function lower(B \u222a {s}, Q \u2212 {s}, E) returns a valid lower bound to the future cost of the problem at some search node.\nAlgorithm 3: The enhanced double-ended branch-and-bound algorithm for the talent scheduling problem.\nFunction: search( ~B,Q, ~E,AN , z)\n1 if Q = \u2205 then 2 if z < UB then 3 UB := z; 4 best solution := ~B \u25e6 ~E;\n5 end 6 return;\n7 end 8 (Q,AN ) := preprocess(Q,AN ); 9 if check( ~B,Q, ~E) then return;\n10 foreach s \u2208 Q do 11 if isDominated( ~B,Q, ~E,AN , z, s) then continue; 12 LB := z + cost(s,B,E) + lower(B \u222a {s}, Q\u2212 {s}, E); 13 if LB \u2265 UB then continue; 14 search( ~E,Q\u2212 {s}, ~B \u25e6 {s}, AN , z + cost(s,B,E)); 15 end"}, {"heading": "4. Computational Experiments", "text": "Our algorithm was coded in C++ and compiled using the g++ compiler. All experiments were run on a Linux server equipped with an Intel Xeon E5430 CPU clocked at 2.66 GHz and 8 GB RAM. The algorithm only has two parameters, namely the number (C) of cached states and the caching strategy used. After some preliminary experiments, we set C = 225 and chose the greedy caching strategy when solving the benchmark instances. In this section, we first present our results for the benchmark instances and then compare them with the results obtained by the best two existing approaches. Finally, we exhibit by experiments the impacts of the parameters on the overall performance of the algorithm. All computation times reported here are in CPU seconds on this server. All instances and detailed results are available in\nthe online supplement to this paper at: www.computational-logistics.org/orlib/tsp."}, {"heading": "4.1. Results for Benchmark Instances", "text": "In order to evaluate our algorithm, we conducted experiments using two benchmark data sets (Types 1 and 2), downloaded from http://ww2.cs.mu.oz.au/~pjs/talent/. The Type 1 data set was introduced by Cheng et al. (1993) and Smith (2005), including seven instances, namely MobStory, film103, film105, film114, film117, film118 and film119. Since these instances have small sizes, ranging from 18\u00d7 8 (18 scenes by 8 actors) to 28\u00d7 8, they were easily solved to optimality. Table 10 shows the results obtained by our branch-andbound algorithm, the constraint programming approach in Smith (2005) and the dynamic programming algorithm in de la Banda et al. (2011). From this table, we can see that our algorithm reduced the number of subproblems significantly for each instance with much less computational efforts. In our branch-and-bound algorithm, a subproblem corresponds to a search tree node. Note that the results taken from Smith (2005) were produced on a PC with 1.7 GHz Pentium M processor, and the results from de la Banda et al. (2011) were produced on a machine with Xeon Pro 2.4 GHz processors and 2 GB RAM.\nThe Type 2 data set was provided by de la Banda et al. (2011). Following a manner almost identical to that used by Cheng et al. (1993), de la Banda et al. (2011) randomly generated 100 instances for each combination of n \u2208 {16, 18, 20, . . . , 64} and m \u2208 {8, 10, 12, . . . , 22}, for a total of 200 instance groups and 20,000 instances. They tried to solve these instances using their dynamic programming algorithm with a memory bound\nof 2GB. For each instance, if the execution did not run out of memory, they recorded the running time and the number of subproblems generated. They reported the average running time and the average number of subproblems for each Type 2 instance group with more than 80 optimally solved instances; these two average values were computed based on the solved instances.\nWe tried to solve all Type 2 instances using our branch-and-bound algorithm with a time limit of 10 minutes and a memory of 2GB. Our algorithm requires some memory to store the information of the search tree and a limited number of states. The amount of memory available can fully satisfy this requirement and thus the out-of-memory exception did not occur. Table 11 gives the number of instances optimally solved in each Type 2 instance group, where an underline sign (\u201c \u201d) is added to the cell associated with the instance group with less than 80 optimally solved instances. For an instance group, if our algorithm optimally solved 80 or more instances while the dynamic programming algorithm failed to achieve so, the number in its corresponding cell is marked with an asterisk (\u2217). From this table, we can see that our algorithm managed to optimally solve all instances with the number of scenes (n) not greater than 32 or the number of actors (m) not greater than 10. However, the dynamic programming algorithm by de la Banda et al. (2011) only optimally solved more than 80 out of 100 instances for the instance groups with n \u2264 26. Their approach even did not optimally solve all instances with m = 8 and n = 64. In this table, 89 out of 200 instance groups are marked with asterisks, which clearly indicates that more Type 2 benchmark instances were successfully solved to optimality by our branch-and-bound algorithm. Although our machine is more powerful, this cannot account for the dramatic difference in the number of optimally solved instances; it is reasonable to conclude that our branch-and-bound algorithm is more efficient than the dynamic programming algorithm.\nTables 12 \u2013 13 show the average running time and the average number of search nodes, respectively, over all optimally solved instances for each instance group. Like in Table 11, the instance groups with less than 80 optimally solved instances are marked with \u201c \u201d. From Table 13, we can easily find that the average number of search nodes generated for each instance group with \u201c \u201d exceeds 3,000,000.\nTo further compare our results with those reported by de la Banda et al. (2011), we pictorially show in Figure 1 the ratio of the average number of subproblems (i.e., search nodes) generated by our algorithm to that generated by the dynamic programming algorithm. Each point in these curves corresponds to an instance group whose average number of subproblems was reported by de la Banda et al. (2011). On average, the number of subproblems generated by our algorithm is less than 22% of that generated by the dynamic programming algorithm, which should be attributed to the use of the new lower bound and domination rules. Moreover, we can observe some trends from these curves. The ratio decreases as the number of scenes increases at the early stage, which implies that our algorithm can elimi-\nnate more subproblems. Subsequently, the ratio increases with the number of scenes. This is because hash collisions happened more frequently, reducing the opportunities of pruning search nodes and therefore increasing the number of subproblems."}, {"heading": "4.2. Impacts of Parameter Settings", "text": "We taken the value of C from {0, 25, 210, 215, 220, 225}, where C = 0 means that cache is not used. Considering the two caching strategies, we have 12 parameter combinations in total. We tested these 12 parameter combinations using a portion of the Type 2 instances. Specifically, the first 5 instances were selected from each instance group, for a total of 1,000\ninstances. We also imposed a time limit of 10 minutes on each execution of our algorithm. The results of those optimally solved instances were recorded for analysis.\nFigure 2 illustrates the number of optimally solved instances under each parameter setting. This figure shows that more caching states lead to more optimally solved instances under both caching strategies. Under the latest caching strategy, the number of instances optimally solved increases from 854 (C = 0) to 922 (C = 225). Under the greedy caching strategy, this number increases from 854 to 939. When C is relatively small (e.g., C \u2264 215), hash collisions occur frequently and the latest caching strategy leads to slightly better performance than the greedy caching strategy. The greedy caching strategy may store more states associated with the subproblems at the early level of the search tree, which cannot be used to effectively prune the nodes. We conjecture that since the latest caching strategy\nstores the newly encountered states and a certain state is revisited in short period with high probability, the pruning can occur with more opportunities and then the number of subproblems is reduced. When C is large (e.g., C \u2265 220), the greedy caching strategy leads to more optimally solved instances than the latest caching strategy. This may be because a smaller state value in the caching slot is likely to eliminate more subproblems during the search process.\nTo further test the impacts of different parameter settings on the average number of subproblems generated, we selected five Type 2 instance groups, namely 40 \u00d7 18, 46 \u00d7 16,\n52\u00d714, 58\u00d712 and 64\u00d710. All instances in these five groups can be optimally solved using our branch-and-bound algorithm within 10 minutes of running time. We pictorially show the results associated with some parameter settings in Figure 3. We can clearly observe that the average number of subproblems generated decreases as the number of cached states increases. This is in accordance with our intuition since more cache slots store more states, which helps prune more search nodes and therefore reduces the number of subproblems. This figure also reveals that the greedy caching strategy outperforms the latest caching strategy in terms of the average number of subproblems generated when C = 220 or C = 225, while the latest caching strategy generally generates fewer subproblems when C is small, i.e., C = 210 or C = 215. As a result, we adopted the greedy caching strategy and C = 225 in the final implementation of our branch-and-bound algorithm."}, {"heading": "5. Conclusions", "text": "In this paper, we proposed an enhanced branch-and-bound algorithm to solve the talent scheduling problem, which is a very challenging combinatorial optimization problem. This\nalgorithm uses a new lower bound and two new dominance rules to prune the search nodes. In addition, it caches search states for the purpose of eliminating search nodes. The experimental results clearly show that our algorithm outperforms the current best approach and achieved the optimal solutions for considerably more benchmark instances.\nWe present a mixed integer linear programming model for the talent scheduling problem in Section 2. A possible future research direction is to design mathematical programming algorithms for the talent scheduling problem, such as branch-and-cut algorithm and branchand-bound coupled with lagrangian relaxation and sub-gradient methods."}, {"heading": "Acknowledgments", "text": "This research was partially supported by the Fundamental Research Funds for the Central Universities, HUST (Grant No. 2012QN213) and National Natural Science Foundation of China (Grant No. 71201065 and 71131004)."}], "references": [{"title": "A dynamic programming formulation with diverse", "author": ["R.M. Adelson", "J.M. Norman", "G. Laporte"], "venue": null, "citeRegEx": "Adelson et al\\.,? \\Q1976\\E", "shortCiteRegEx": "Adelson et al\\.", "year": 1976}, {"title": "An efficient branch and bound algorithm for assembly line balancing problems", "author": ["T. Kelleg\u00f6z", "B. Toklu"], "venue": null, "citeRegEx": "Kelleg\u00f6z and Toklu,? \\Q2012\\E", "shortCiteRegEx": "Kelleg\u00f6z and Toklu", "year": 2012}, {"title": "Two branch-and-bound algorithms for the robust parallel machine", "author": ["M. Ranjbar", "M. Davari", "R. Leus"], "venue": "conference on LISP and functional programming", "citeRegEx": "Ranjbar et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Ranjbar et al\\.", "year": 2012}, {"title": "Caching search states in permutation problems", "author": ["B.M. APES group. Smith"], "venue": "Lecture Notes in Computer Science", "citeRegEx": "67.2003 and Smith,? \\Q2005\\E", "shortCiteRegEx": "67.2003 and Smith", "year": 2005}, {"title": "The single vehicle routing problem with toll-by-weight", "author": ["Z. Zhang", "H. Qin", "W. Zhu", "A. Lim"], "venue": null, "citeRegEx": "Zhang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al.", "startOffset": 50, "endOffset": 72}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al.", "startOffset": 50, "endOffset": 96}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage.", "startOffset": 50, "endOffset": 119}, {"referenceID": 0, "context": "The talent scheduling problem was originated from Adelson et al. (1976) and Cheng et al. (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage. They proposed a simple dynamic programming algorithm to solve their problem. Cheng et al. (1993) studied a film scheduling problem in which all scenes 2", "startOffset": 50, "endOffset": 391}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al.", "startOffset": 92, "endOffset": 114}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.", "startOffset": 92, "endOffset": 138}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.", "startOffset": 92, "endOffset": 183}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al.", "startOffset": 92, "endOffset": 375}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al.", "startOffset": 92, "endOffset": 461}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages.", "startOffset": 92, "endOffset": 485}, {"referenceID": 0, "context": "Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states. The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages. However, it is a simplified version of the movie shoot scheduling problem (MSSP) introduced by Bomsdorf and Derigs (2008). In the MSSP, we need to deal with a couple of practical constraints, such as the precedence relations among scenes, the time windows of each scene, the resource availability, and the working time", "startOffset": 92, "endOffset": 687}, {"referenceID": 4, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}, {"referenceID": 2, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}, {"referenceID": 1, "context": "Dominance rules are widely used in branch-and-bound algorithms (Zhang et al., 2012; Braune et al., 2012; Ranjbar et al., 2012; Kelleg\u00f6z and Toklu, 2012) and dynamic programming algorithms (Dumas et al.", "startOffset": 63, "endOffset": 152}], "year": 2014, "abstractText": "The talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings are disclosed by some additional experiments.", "creator": "LaTeX with hyperref package"}}}