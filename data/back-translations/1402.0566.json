{"id": "1402.0566", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Incremental Clustering and Expansion for Faster Optimal Planning in Dec-POMDPs", "abstract": "This article presents the state of the art in optimal solution methods for decentralized, partially observable Markov decision-making processes (Dec-POMDPs), which are general models for collaborative multi-agent planning under uncertainty. Building on the generalized multi-agent A * (GMAA *) algorithm, which reduces the problem to a tree of collaborative Bayesian games (CBGs), we describe several advances that significantly expand the spectrum of optimally solvable Dec-POMDPs. First, we introduce lossless incremental clustering of CBGs, solved by GMAA *, which achieves incremental acceleration without sacrificing optimism. Second, we introduce an incremental expansion of the nodes in the GMAA * search tree, which avoids the need to expand all children, the number of which in the worst case is twice exponential in the nodes, the definition of the nodes.", "histories": [["v1", "Tue, 4 Feb 2014 01:35:59 GMT  (7334kb)", "http://arxiv.org/abs/1402.0566v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["frans adriaan oliehoek", "matthijs t j spaan", "christopher amato", "shimon whiteson"], "accepted": false, "id": "1402.0566"}, "pdf": {"name": "1402.0566.pdf", "metadata": {"source": "CRF", "title": "Incremental Clustering and Expansion for Faster Optimal Planning in Decentralized POMDPs", "authors": ["Frans A. Oliehoek", "Christopher Amato", "Shimon Whiteson"], "emails": ["frans.oliehoek@maastrichtuniversity.nl", "m.t.j.spaan@tudelft.nl", "camato@csail.mit.edu", "s.a.whiteson@uva.nl"], "sections": [{"heading": "1. Introduction", "text": "A key goal of artificial intelligence is the development of intelligent agents that interact with their environment in order to solve problems, achieve goals, and maximize utility. While such agents sometimes act alone, researchers are increasingly interested in collaborative multiagent systems, in which teams of agents work together to perform all manner of tasks. Multiagent systems are appealing, not only because they can tackle inherently distributed problems, but because they facilitate the decomposition of problems too complex to be tackled by a single\nc\u00a92013 AI Access Foundation. All rights reserved.\nagent (Huhns, 1987; Sycara, 1998; Panait & Luke, 2005; Vlassis, 2007; Bus\u0327oniu, Babus\u030cka, & De Schutter, 2008).\nOne of the primary challenges of multiagent systems is the presence of uncertainty. Even in single-agent systems, the outcome of an action may be uncertain, e.g., the action may fail with some probability. Furthermore, in many problems the state of the environment may be uncertain due to limited or noisy sensors. However, in multiagent settings these problems are often greatly exacerbated. Since agents have access only to their own sensors, typically a small fraction of those of the complete system, their ability to predict how other agents will act is limited, complicating cooperation. If such uncertainties are not properly addressed, arbitrarily bad performance may result.\nIn principle, agents can use communication to synchronize their beliefs and coordinate their actions. However, due to bandwidth constraints, it is typically infeasible for all agents to broadcast the necessary information to all other agents. In addition, in many realistic scenarios, communication may be unreliable, precluding the possibility of eliminating all uncertainty about other agents\u2019 actions.\nEspecially in recent years, much research has focused on approaches to (collaborative) multiagent systems that deal with uncertainty in a principled way, yielding a wide variety of models and solution methods (Pynadath & Tambe, 2002; Goldman & Zilberstein, 2004; Seuken & Zilberstein, 2008). This article focuses on the decentralized partially observable Markov decision process (Dec-POMDP), a general model for collaborative multiagent planning under uncertainty. Unfortunately, solving a Dec-POMDP, i.e., computing an optimal plan, is generally intractable (NEXP-complete) (Bernstein, Givan, Immerman, & Zilberstein, 2002) and in fact even computing solutions with absolutely bounded error (i.e., \u01eb-approximate solutions) is also NEXP-complete (Rabinovich, Goldman, & Rosenschein, 2003). In particular, the number of joint policies grows exponentially with the number of agents and observations and doubly exponentially with respect to the horizon of the problem.1 Though these complexity results preclude methods that are efficient on all problems, developing better optimal solution methods for Dec-POMDPs is nonetheless an important goal, for several reasons.\nFirst, since the complexity results describe only the worst case, there is still great potential to improve the performance of optimal methods in practice. In fact, there is evidence that many problems can be solved much faster than the worst-case complexity bound indicates (Allen & Zilberstein, 2007). In this article, we present experiments that clearly demonstrate this point: on many problems, the methods we propose scale vastly beyond what would be expected for a doubly-exponential dependence on the horizon.\nSecond, as computer speed and memory capacity increase, a growing set of small and medium-sized problems can be solved optimally. Some of these problems arise naturally while others result from the decomposition of larger problems. For instance, it may be possible to extrapolate optimal solutions of problems with shorter planning horizons, using them as the starting point of policy search for longer-horizon problems as in the work of Eker and Ak\u0131n (2013), or to use such shorter-horizon, no-communication solutions inside problems with communication (Nair, Roth, & Yohoo, 2004; Goldman & Zilberstein, 2008). More generally, optimal policies of smaller problems can potentially be used to find good solutions for larger problems. For instance, transfer planning (Oliehoek, 2010; Oliehoek, Whiteson, & Spaan,\n1. Surprisingly, the number of states in a Dec-POMDP is less important, e.g., brute-force search depends on the number of states only via its policy evaluation routine, which scales linearly in the number of states.\n2013) employs optimal solutions to problems with few agents to better solve problems with many agents. By performing (approximate) influence-based abstraction and influence search (Witwicki, 2011; Oliehoek, Witwicki, & Kaelbling, 2012), optimal solutions of component problems can potentially be used to find (near-)optimal solutions of larger problems.\nThird, optimal methods offer important insights into the nature of specific Dec-POMDP problems and their solutions. For instance, the methods introduced in this article enabled the discovery of certain properties of the BroadcastChannel benchmark problem that make it much easier to solve.\nFourth, optimal methods provide critical inspiration for principled approximation methods. In fact, almost all successful approximate Dec-POMDP methods are based on optimal ones (see, e.g., Seuken & Zilberstein, 2007b, 2007a; Dibangoye, Mouaddib, & Chai-draa, 2009; Amato, Dibangoye, & Zilberstein, 2009; Wu, Zilberstein, & Chen, 2010a; Oliehoek, 2010) or locally optimal ones (Velagapudi, Varakantham, Scerri, & Sycara, 2011)2, and the clustering technique presented in this article forms the basis of a recently introduced approximate clustering technique (Wu, Zilberstein, & Chen, 2011).\nFinally, optimal methods are essential for benchmarking approximate methods. In recent years, there have been huge advances in the approximate solution of Dec-POMDPs, leading to the development of solution methods that can deal with large horizons, hundreds of agents and many states (e.g., Seuken & Zilberstein, 2007b; Amato et al., 2009; Wu et al., 2010a; Oliehoek, 2010; Velagapudi et al., 2011). However, since computing even \u01eb-approximate solutions is NEXP-complete, any method whose complexity is not doubly exponential cannot have any guarantees on the absolute error of the solution (assuming EXP 6=NEXP). As such, existing effective approximate methods have no quality guarantees.3\nConsequently, it is difficult to meaningfully interpret their empirical performance without the upper bounds optimal methods supply. While approximate methods can also be benchmarked against lower bounds (e.g., other approximate methods), such comparisons cannot detect when a method fails to find good solutions. Doing so requires benchmarking against upper bounds and, unfortunately, upper bounds that are easier to compute, such as QMDP and QPOMDP, are too loose to be helpful (Oliehoek, Spaan, & Vlassis, 2008). As such, benchmarking with respect to optimal solutions is an important part of the verification of any approximate algorithm. Since existing optimal methods can only tackle very small problems, scaling optimal solutions to larger problems is a critical goal."}, {"heading": "1.1 Contributions", "text": "This article presents the state-of-the-art in optimal solution methods for Dec-POMDPs. In particular, it describes several advances that greatly expand the horizon to which many DecPOMDPs can be solved optimally. In addition, it proposes and evaluates a complete algorithm that synthesizes these advances. Our approach is based on the generalized multiagent A* (GMAA*) algorithm (Oliehoek, Spaan, & Vlassis, 2008), which makes it possible to reduce the problem to a tree of one-shot collaborative Bayesian games (CBGs). The appeal of this\n2. The method by Velagapudi et al. (2011) repeatedly computes best responses in a way similar to DP-JESP (Nair, Tambe, Yokoo, Pynadath, & Marsella, 2003). The best response computation, however, exploits sparsity of interactions. 3. Note that we refer to methods without quality guarantees as approximate rather than heuristic to avoid confusion with heuristic search, which is used throughout this article and is exact.\napproach is the abstraction layer it introduces, which has led to various insights into DecPOMDPs and, in turn, to the improved solution methods we describe.\nThe specific contributions of this article are:4\n1. We introduce lossless clustering of CBGs, a technique to reduce the size of the CBGs for which GMAA* enumerates all possible solutions, while preserving optimality. This can exponentially reduce the number of child nodes in the GMAA* search tree, leading to huge increases in efficiency. In addition, by applying incremental clustering (IC) to GMAA*, our GMAA*-IC method can avoid clustering exponentially sized CBGs.\n2. We introduce incremental expansion (IE) of nodes in theGMAA* search tree. Although clustering may reduce the number of children of a search node, this number is in the worst case still doubly exponential in the node\u2019s depth. GMAA*-ICE, which applies IE to GMAA*-IC, addresses this problem by creating a next child node only when it is a candidate for further expansion.\n3. We provide theoretical guarantees for both GMAA*-IC and GMAA*-ICE. In particular, we show that, when using a suitable heuristic, both algorithms are both complete and search equivalent.\n4. We introduce an improved heuristic representation. Tight heuristics like those based on the underlying POMDP solution (QPOMDP) or the value function resulting from assuming 1-step-delayed communication (QBG) are essential for heuristic search methods like GMAA* (Oliehoek, Spaan, & Vlassis, 2008). However, the space needed to store these heuristics grows exponentially with the problem horizon. We introduce hybrid representations that are more compact and thereby enable the solution of larger problems.\n5. We present extensive empirical results that show substantial improvements over the current state-of-the-art. Whereas Seuken and Zilberstein (2008) argued that GMAA* can at best optimally solve Dec-POMDPs only one horizon further than brute-force search, our results demonstrate that GMAA*-ICE can do much better. In addition, we provide a comparative overview of the results of competitive optimal solution methods from the literature.\nThe primary aim of the techniques introduced in this article is to improve scalability with respect to the horizon. Our empirical results confirm that these techniques are highly successful in this regard. As an added bonus, our experiments also demonstrate improvement in scalability with respect to the number of agents. In particular, we present the first optimal results on general (non-special case) Dec-POMDPs with more than three agents. Extensions of our techniques to achieve further improvements with respect to the number of agents, as well as promising ways to combine the ideas behind our methods with state-of-the-art approximate approaches, are discussed under future work in Section 7.\n4. This article synthesizes and extends research that was already reported in two conference papers (Oliehoek, Whiteson, & Spaan, 2009; Spaan, Oliehoek, & Amato, 2011)."}, {"heading": "1.2 Organization", "text": "The article is organized as follows. Section 2 provides background on the Dec-POMDP model, the GMAA* heuristic search solution method, as well as suitable heuristics. In Section 3, we introduce lossless clustering of the CBGs and its integration into GMAA*. Section 4 introduces the incremental expansion of search nodes. The empirical evaluation of the proposed techniques is reported in Section 5. We give a treatment of related work in Section 6. Future work is discussed in Section 7 and conclusions are drawn in Section 8."}, {"heading": "2. Background", "text": "In a Dec-POMDP, multiple agents must collaborate to maximize the sum of the common rewards they receive over multiple timesteps. Their actions affect not only their immediate rewards but also the state to which they transition. While the current state is not known to the agents, at each timestep each agent receives a private observation correlated with that state. Definition 1. A Dec-POMDP is a tuple \u2329 D,S,A, T,O, O,R, b0, h \u232a , where\n\u2022 D = {1, . . . ,n} is the finite set of agents. \u2022 S = { s1, . . . ,s|S| } is the finite set of states.\n\u2022 A = \u00d7iAi is the set of joint actions a = \u3008a1, . . . , an\u3009, where Ai is the finite set of actions available to agent i.\n\u2022 T is a transition function specifying the state transition probabilities Pr(s\u2032|s,a).\n\u2022 O = \u00d7iOi is the finite set of joint observations. At every stage one joint observation o = \u3008o1,...,on\u3009 is received. Each agent i observes only its own component oi. \u2022 O is the observation function, which specifies observation probabilities Pr(o|a,s\u2032).\n\u2022 R(s,a) is the immediate reward function mapping (s,a)-pairs to real numbers. \u2022 b0 \u2208 \u2206(S) is the initial state distribution at time t = 0, where \u2206(S) denotes the infinite set of probability distributions over the finite set S.\n\u2022 h is the horizon, i.e., the number of stages. We consider the case where h is finite.\nAt each stage t = 0 . . . h\u2212 1, each agent takes an individual action and receives an individual observation.\nExample 1 (Recycling Robots). To illustrate the Dec-POMDP model, consider a team of robots tasked with removing trash from an office building, depicted in Fig. 1. The robots have sensors to find marked trash cans, motors to move around in order to look for cans, as well as gripper arms to grasp and carry a can. Small trash cans are light and compact enough for a single robot to carry, but large trash cans require multiple robots to carry them out together. Because more people use them, the larger trash cans fill up more quickly. Each robot must also ensure that its battery remains charged by moving to a charging station before it expires. The battery level for a robot degrades due to the distance the robot travels and the weight of the item being carried. Each robot knows its own battery level but not that of the other robots and only the location of other robots within sensor range. The goal of this problem is to remove as much trash as possible in a given time period.\nThis problem can be represented as a Dec-POMDP in a natural way. The states, S, consist of the different locations of each robot, their battery levels and the different amounts of trash in the cans. The actions, Ai, for each robot consist of movements in different directions as well as decisions\nto pick up a trash can or recharge the battery (when in range of a can or a charging station). The observations, Oi, of each robot consist of its own battery level, its own location, the locations of other robots in sensor range and the amount of trash in cans within range. The rewards, R, could consist of a large positive value for a pair of robots emptying a large (full) trash can, a small positive value for a single robot emptying a small trash can and negative values for a robot depleting its battery or a trash can overflowing. An optimal solution is a joint policy that leads to the expected behavior (given that the rewards are properly specified). That is, it ensures that the robots cooperate to empty the large trash cans when appropriate and the small ones individually while considering battery usage.\nFor explanatory purposes, we also consider a much simpler problem, the so-called decentralized tiger problem (Nair et al., 2003).\nExample 2 (Dec-Tiger). The Dec-Tiger problem concerns two agents that find themselves in a hallway with two doors. Behind one door, there is a treasure and behind the other is a tiger. The state describes which door the tiger is behind\u2014left (sl) or right (sr)\u2014each occurring with 0.5 probability (i.e., the initial state distribution b0 is uniform). Each agent can perform three actions: open the left door (aOL), open the right door (aOR) or listen (aLi). Clearly, opening the door to the treasure will yield a reward, but opening the door to the tiger will result in a severe penalty. A greater reward is given for both agents opening the correct door at the same time. As such, a good strategy will probably involve listening first. The listen actions, however, also have a minor cost (negative reward). At every stage the agents get an observation. The agents can either hear the tiger behind the left (oHL) or right (oHR) door, but each agent has a 15% chance of hearing it incorrectly (getting the wrong observation). Moreover, the observation is informative only if both agents listen; if either agent opens a door, both agents receive an uninformative (uniformly drawn) observation and the problem resets to sl or sr with equal probability. At this point the problem just continues, such that the agents may be able to open the door to the treasure multiple times. Also note that, since the only two observations the agents can get are oHL, oHR, the agents have no way of detecting that the problem has been reset: if one agent opens the door while the other listens, the other agent will not be able to tell that the door was opened. For a complete specification, see the discussion by Nair et al. (2003).\nGiven a Dec-POMDP, the agents\u2019 common goal is to maximize the expected cumulative reward or return. The planning task entails finding a joint policy \u03c0 = \u3008\u03c01, . . . ,\u03c0n\u3009 from the space of joint policies \u03a0, that specifies an individual policy \u03c0i for each agent i. Such an\nindividual policy in general specifies an individual action for each action-observation history (AOH) ~\u03b8 ti = (a 0 i ,o 1 i , . . . ,a t\u22121 i ,o t i), e.g., \u03c0i( ~\u03b8 ti ) = a t i. However, it is possible to restrict our attention to deterministic or pure policies, in which case \u03c0i maps each observation history (OH) (o1i , . . . ,o t i) = ~o t i \u2208 ~Oti to an action, e.g., \u03c0i(~o t i ) = a t i. The number of such policies is |Ai| (|Oi| h\u22121)/(|Oi|\u22121) and the number of joint policies is therefore\nO ( |A\u2217| n|O\u2217| h\u22121 |O\u2217|\u22121 ) , (2.1)\nwhere A\u2217 and O\u2217 denote the largest individual action and observation sets. The quality of a particular joint policy is expressed by the expected cumulative reward it induces, also referred to as its value.\nDefinition 2. The value V (\u03c0) of a joint policy \u03c0 is\nV (\u03c0) , E [h\u22121\u2211\nt=0\nR(st,at) \u2223\u2223\u2223\u03c0,b0 ] , (2.2)\nwhere the expectation is over sequences of states, actions and observations.\nThe planning problem for a Dec-POMDP is to find an optimal joint policy \u03c0\u2217, i.e., a joint policy that maximizes the value: \u03c0\u2217 = argmax\u03c0 V (\u03c0).\nBecause an individual policy \u03c0i depends only on the local information ~oi available to an agent, the on-line execution phase is truly decentralized: no communication takes place other than that modeled via actions and observations. The planning itself however, may take place in an off-line phase and be centralized. This is the scenario that we consider in this article. For a more detailed introduction to Dec-POMDPs see, e.g., the work of Seuken and Zilberstein (2008) and Oliehoek (2012)."}, {"heading": "2.1 Heuristic Search Methods", "text": "In recent years, numerous Dec-POMDP solution methods have been proposed. Most of these methods fall into one of two categories: dynamic programming and heuristic search methods. Dynamic programming methods take a backwards or \u2018bottom-up\u2019 perspective by first considering policies for the last time step t = h \u2212 1 and using them to construct policies for stage t = h\u2212 2, etc. In contrast, heuristic search methods take a forward or \u2018top-down\u2019 perspective by first constructing plans for t = 0 and extending them to later stages.\nIn this article, we focus on the heuristic search approach that has shown state-of-the-art results. As we make clear in this section, this method can be interpreted as searching over a tree of collaborative Bayesian games (CBGs). These CBGs provide a convenient abstraction layer that facilitates the explanation of the techniques introduced in this article.\nThis section provides some concise background on heuristic search methods. For a more detailed description, see the work of Oliehoek, Spaan, and Vlassis (2008). For a further description of dynamic programming methods and their relationship to heuristic search methods, see the work of Oliehoek (2012)."}, {"heading": "2.1.1 Multiagent A*", "text": "Szer, Charpillet, and Zilberstein (2005) introduced a heuristically guided policy search method called multiagent A* (MAA*). It performs an A* search over partially specified joint policies,\ni , \u03b3 \u03c4=2 i (introduced in Section 3.1.2).\npruning joint policies that are guaranteed to be worse than the best (fully specified) joint policy found so far. Oliehoek, Spaan, and Vlassis (2008) generalized the algorithm by making explicit the expand and selection operators performed in the heuristic search. The resulting algorithm, generalized MAA* (GMAA*) offers a unified perspective of MAA* and the forward sweep policy computation method (Emery-Montemerlo, 2005), which differ in how they implement GMAA*\u2019s expand operator: forward sweep policy computation solves (i.e., finds the best policy for) collaborative Bayesian games, whileMAA* finds all policies for those collaborative Bayesian games, as we describe in Section 2.1.2.\nThe GMAA* algorithm considers joint policies that are partially specified with respect to time. These partially specified policies can be formalized as follows.\nDefinition 3. A decision rule \u03b4ti for agent i\u2019s decision for stage t is a mapping from actionobservation histories for stage t to actions \u03b4ti : ~\u0398ti \u2192 Ai.\nIn this article, we consider only deterministic policies. Since such policies need to condition their actions only on observation histories, they are made up of decision rules that map lengtht observation histories to actions: \u03b4ti : ~Oti \u2192 Ai. A joint decision rule \u03b4 t = \u3008\u03b4t1, . . . ,\u03b4 t n\u3009 specifies a decision rule for each agent. Fig. 2 illustrates this concept, as well as that of a past policy, which we introduce shortly. As discussed below, decision rules allow partial policies to be defined and play a crucial role in GMAA* and the algorithms developed in this article.\nDefinition 4. A partial or past policy for stage t, \u03d5ti, specifies the part of agent i\u2019s policy that relates to stages t\u2032 < t. That is, it specifies the decision rules for the first t stages: \u03d5ti = (\u03b4 0 i ,\u03b4 1 i , . . . ,\u03b4 t\u22121 i ). A past policy for stage h is just a regular, or fully specified, policy \u03d5hi = \u03c0i. A past joint policy \u03d5 t = (\u03b40,\u03b41, . . . ,\u03b4t\u22121) specifies joint decision rules for the first t stages.\nGMAA* performs a heuristic search over such partial joint policies \u03d5t by constructing a search tree as illustrated in Fig. 3a. Each node q = \u3008\u03d5t, v\u0302\u3009 in the search tree specifies a past joint policy \u03d5t and heuristic value v\u0302. This heuristic value v\u0302 of the node represents an optimistic estimate of the past joint policy V\u0302 (\u03d5t), which can be computed via\nV\u0302 (\u03d5t) = V 0...t\u22121(\u03d5t) +Ht...h\u22121(\u03d5t), (2.3)\nwhere Ht...h\u22121 is a heuristic value for the remaining h\u2212 t stages and V 0...t\u22121(\u03d5t) is the actual expected reward \u03d5t achieves over the first t stages (for its definition, see Appendix A.3). Clearly, when Ht...h\u22121 is an admissible heuristic\u2014a guaranteed overestimation\u2014so is V\u0302 (\u03d5t).5\nAlgorithm 1 illustrates GMAA*. It starts by creating a node q0 for a completely unspecified joint policy \u03d50 and placing it in an open list L. Then, it selects nodes (Algorithm 2) and expands them (Algorithm 3), repeating this process until it is certain that it has found the optimal joint policy.\nThe Select operator returns the highest ranked node, as defined by the following comparison operator.\nDefinition 5. The node comparison operator < is defined for two nodes q = \u3008\u03d5t,v\u0302\u3009, q\u2032 = \u3008\u03d5t\u2032,v\u0302\u2032\u3009 as follows:\nq < q\u2032 =    v\u0302 < v\u0302\u2032 , if v\u0302 6= v\u0302\u2032 depth(q) < depth(q\u2032) , otherwise if depth(q) 6= depth(q\u2032)\n\u03d5t < \u03d5t\u2032 , otherwise.\n(2.4)\nThat is, the comparison operator first compares the heuristic values. If those are equal, it compares the depth of the nodes. Finally, if nodes have equal value and equal depth, it lexically compares the past joint policies. This ranking leads to A* behavior (i.e., selecting the node from the open list with the highest heuristic value) of GMAA*, as well as guaranteeing the same selection order in our incremental expansion technique (introduced in Section 4). Ranking nodes with greater depth higher in case of equal heuristic value helps find tight lower bounds early by first expanding deeper nodes (Szer et al., 2005) and is also useful in incremental expansion.\n5. More formally, H should not underestimate the value. Note that, unlike classical A* applications such as path planning\u2013in which an admissible heuristic should not overestimate\u2013in our setting we maximize reward, rather than minimize cost.\nAlgorithm 1 Generalized multiagent A*. Input: a Dec-POMDP, an admissible heuristic H, an empty open list L Output: an optimal joint policy \u03c0\u2217\n1: vGMAA \u2190 \u2212\u221e 2: q0 \u2190 \u3008\u03d50 = (), v\u0302 = +\u221e\u3009 3: L.insert(q0) 4: repeat 5: q \u2190 Select(L) 6: QExpand \u2190 Expand(q,H) 7: if depth(q) = h\u2212 1 then 8: { QExpand contains fully specified joint policies, we only are interested in the best one } 9: \u3008\u03c0, v\u3009 \u2190 BestJointPolicyAndValue(QExpand)\n10: if v > vGMAA then 11: \u03c0\u2217 \u2190 \u03c0 {found a new best joint policy} 12: vGMAA \u2190 v 13: L.Prune(vGMAA) {(optionally) prune the open list} 14: end if 15: else 16: L.insert( { q\u2032 \u2208 QExpand | q \u2032.v\u0302 > vGMAA } ) {add expanded children to open list} 17: end if 18: PostProcessNode(q,L) 19: until L is empty 20: return \u03c0\u2217\nAlgorithm 2 Select(L): Return the highest ranked node from the open list.\nInput: open list L, total order on nodes < Output: the highest ranked node q\u2217\n1: q\u2217 \u2190 q \u2208 L s.t. \u2200q\u2032\u2208L (q \u2032 6= q =\u21d2 q\u2032 < q) 2: return q\u2217\nThe Expand operator constructs QExpand, the set of all child nodes. That is, given a node that contains partial joint policy \u03d5t = (\u03b40,\u03b41, . . . ,\u03b4t\u22121), it constructs \u03a6t+1, the set of all \u03d5t+1 = (\u03b40,\u03b41, . . . ,\u03b4t\u22121,\u03b4t), by appending all possible joint decision rules \u03b4t for the next time step t. For all these \u03d5t+1, a heuristic value is computed and a node is constructed.\nAfter expansion, the algorithm checks (line 7) if the expansion resulted in fully specified joint policies. If not, all children with sufficient heuristic value are placed in the open list\nAlgorithm 3 Expand(q,H). The expand operator of plain MAA*. Input: q = \u3008\u03d5t, v\u0302\u3009 the search node to expand, H the admissible heuristic. Output: QExpand the set containing all expanded child nodes. 1: QExpand \u2190 {} 2: \u03a6t+1 \u2190 {\u03d5t+1 | \u03d5t+1 = (\u03d5t, \u03b4t)} 3: for \u03d5t+1 \u2208 \u03a6t+1 do 4: V\u0302 (\u03d5t+1) \u2190 V 0...t(\u03d5t+1) +H(\u03d5t+1)\n5: q\u2032 \u2190 \u3008\u03d5t+1, V\u0302 (\u03d5t+1)\u3009 {create child node} 6: QExpand.Insert(q\n\u2032) 7: end for 8: return QExpand\nAlgorithm 4 PostProcessNode(q,L)\nInput: q the expanded parent node, L the open list. Output: the expanded node is removed. 1: L.Pop(q)\n(line 16). If the children are fully specified, BestJointPolicyAndValue returns only the best joint policy (and its value) from QExpand (see Algorithm 12 in Appendix A.1 for details of BestJointPolicyAndValue). GMAA* also maintains a lower bound vGMAA which corresponds to the actual value of the best fully-specified joint policy found so far. If the newly found joint policy has a higher value this lower bound is updated (lines 11 and 12). Also, any nodes for partial joint policies \u03d5t+1 with an upper bound that is lower than the best solution so far, V\u0302 (\u03d5t+1) < vGMAA, can be pruned (line 13). This pruning takes additional time, but can save memory. Finally, PostProcessNode simply removes the parent node from the open list (this procedure is augmented for incremental expansion in Section 4). The search ends when the list becomes empty, at which point an optimal joint policy has been found.\nGMAA* is complete, i.e., it will search until it finds a solution. Therefore, in theory, GMAA* is guaranteed to eventually produce an optimal joint policy (Szer et al., 2005). However, in practice, this is often infeasible for larger problems. A major source of complexity is the full expansion of a search node. The number of joint decision rules for stage t that can form the children of a node at depth t in the search tree6 is\nO ( |A\u2217| n(|O\u2217|t) ) , (2.5)\nwhich is doubly exponential in t. Comparing (2.1) with (2.5), we see that the worst case complexity of expanding a node for the deepest level in the tree t = h \u2212 1 is comparable to that of brute force search for the entire Dec-POMDP. Consequently, Seuken and Zilberstein (2008) conclude that MAA* \u201ccan at best solve problems whose horizon is only 1 greater than those that can already be solved by na\u0308\u0131ve brute force search.\u201d"}, {"heading": "2.1.2 The Bayesian Game Perspective", "text": "GMAA* makes it possible to interpret MAA* as the solution of a collection of collaborative Bayesian games (CBGs). We employ this approach throughout this article, as it facilitates the improvements to GMAA* that we introduce, each of which results in significant advances in the state-of-the-art in Dec-POMDP solutions.\nA Bayesian game (BG) models a one-shot interaction between a number of agents. It is an extension of the well-known strategic game (also known as a normal form game) in which each agent holds some private information (Osborne & Rubinstein, 1994). A CBG is a BG in which the agents receive identical payoffs. In the Bayesian game perspective, each node q in the GMAA* search tree, along with its corresponding partial joint policy \u03d5t, defines a CBG (Oliehoek, Spaan, & Vlassis, 2008). That is, given state distribution b0, for each \u03d5t, it is possible to construct a CBG B(b0,\u03d5t) that represents the decision-making problem for stage t given that \u03d5t was followed for the first t stages starting from b0. When it is clear what b0 is, we simply write B(\u03d5t).\n6. We follow the convention that the root has depth 0.\nDefinition 6. A collaborative Bayesian game (CBG) B(b0,\u03d5t) = \u3008D,A,\u0398,Pr(\u00b7), u\u3009modeling stage t of a Dec-POMDP, given initial state distribution b0 and past joint policy \u03d5t, consists of:\n\u2022 D, the set of agents {1 . . . n},\n\u2022 A, the set of joint actions,\n\u2022 \u0398, the set of their joint types, each of which specifies a type for each agent \u03b8 = \u3008\u03b81, . . . ,\u03b8n\u3009, \u2022 Pr(\u00b7), a probability distribution over joint types,\n\u2022 u, a (heuristic) payoff function mapping joint type and action to a real number: u(\u03b8,a).\nIn any Bayesian game, the type \u03b8i of an agent i represents the private information it holds. For instance, in a Bayesian game modeling of a job recruitment scenario, the type of an agent may indicate whether that agent is a hard worker. In a CBG for a Dec-POMDP, an agent\u2019s private information is its individual AOH. Therefore, the type \u03b8i of an agent i corresponds to ~\u03b8 ti , its history of actions and observations: \u03b8i \u2194 ~\u03b8 ti . Similarly, a joint type corresponds to a joint AOH: \u03b8 \u2194 ~\u03b8t. Consequently, u should provide a (heuristic) estimate for the long-term payoff of each (~\u03b8t,a)-pair. In other words, the payoff function corresponds to a heuristic Q-value: u(\u03b8,a) \u2194 Q\u0302(~\u03b8t,a). We discuss how to compute such heuristics in Section 2.2. Given \u03d5t, b0, and the correspondence of joint types and AOHs, the probability distribution over joint types is:\nPr(\u03b8) , Pr(~\u03b8t|b0,\u03d5t), (2.6)\nwhere the latter probability is the marginal of Pr(s,~\u03b8t|b0,\u03d5t) as defined by (A.2) used in the computation of the value of a partial joint policy V 0...t\u22121(\u03d5t) in Appendix A.3. Note that due to the correspondence between types and AOHs, the size of a CBG B(b0,\u03d5t) for a stage t is exponential in t.\nIn a CBG, each agent uses a Bayesian game policy \u03b2i that maps individual types to actions: \u03b2i(\u03b8i) = ai. Because of the correspondence between types and AOHs, a (joint) policy for the CBG \u03b2 corresponds to a (joint) decision rule: \u03b2 \u2194 \u03b4t. In the remainder of this article, we assume deterministic past joint policies \u03d5t, which implies that only one ~\u03b8t will have non-zero probability given the observation history ~o t. Thus, \u03b2 effectively maps observation histories to actions. The number of such \u03b2 for B(b0,\u03d5t) is given by (2.5). The value of a joint CBG policy \u03b2 for a CBG B(b0,\u03d5t) is:\nV\u0302 (\u03b2) = \u2211\n~\u03b8t\nPr(~\u03b8t|b0,\u03d5t)Q\u0302(~\u03b8t,\u03b2(~\u03b8t)), (2.7)\nwhere \u03b2t(~\u03b8t) = \u3008\u03b2i(~\u03b8 t i )\u3009i=1...n denotes the joint action that results from application of the individual CBG-policies to the individual AOH ~\u03b8 ti specified by ~\u03b8t.\nExample 3. Consider a CBG for Dec-Tiger given the past joint policy \u03d52 that specifies to listen at the first two stages. At stage t = 2, each agent has four possible observation histories: ~O2i = {(oHL,oHL), (oHL,oHR), (oHR,oHL), (oHR,oHR)} that correspond directly to its possible types. The probabilities of these joint types given \u03d52 are listed in Fig. 4a. Since the joint OHs together with \u03d52 determine the joint AOHs, they also correspond to so-called joint beliefs : probability distributions over states (introduced formally in Section 2.2). Fig. 4b shows these joint beliefs, which can serve as the basis for the heuristic payoff function (as further discussed in Section 2.2).\nAlgorithm 5 Expand-CBG(q,H). The expand operator of GMAA* that makes use of CBGs. Input: q = \u3008\u03d5t, v\u0302\u3009 the search node to expand. Input: H the admissible heuristic that is of the form Q\u0302(~\u03b8,a). Output: QExpand the set containing all expanded child nodes.\n1: B(b0,\u03d5t) \u2190 ConstructBG(b0,\u03d5t, Q\u0302) {as explained in Section 2.1.2} 2: QExpand \u2190 GenerateAllChildrenForCBG(B(b\n0,\u03d5t)) 3: return QExpand\nA solution to the CBG is a \u03b2 that maximizes (2.7). A CBG is equivalent to a team decision process and finding a solution is NP-complete (Tsitsiklis & Athans, 1985). However, in the Bayesian game perspective of GMAA*, illustrated in Fig. 3b, the issue of solving a CBG (i.e., finding the highest payoff \u03b2) is not so relevant because we need to expand all \u03b2. That is, the Expand operator enumerates all \u03b2 and appends them to \u03d5t to form the set of extended joint policies\n\u03a6t+1 = { (\u03d5t,\u03b2) | \u03b2 is a joint CBG policy of B(b0,\u03d5t) }\nand uses this set to construct QExpand, the set of child nodes. The heuristic value of such a child node q \u2208 QExpand that specifies \u03d5 t+1 = (\u03d5t,\u03b2) is given by\nV\u0302 (\u03d5t+1) = V 0...t\u22121(\u03d5t) + V\u0302 (\u03b2). (2.8)\nThe Expand operator that makes use of CBGs is summarized in Algorithm 5, which uses the GenerateAllChildrenForCBG subroutine (Algorithm 13 in Appendix A.1). Fig. 3b illustrates the Bayesian game perspective of GMAA*."}, {"heading": "2.2 Heuristics", "text": "To perform heuristic search, GMAA* defines the heuristic value V\u0302 (\u03d5t) using (2.3). In contrast, the Bayesian game perspective uses (2.8). These two formulations are equivalent when the heuristic Q\u0302 faithfully represents the expected immediate reward (Oliehoek, Spaan, & Vlassis, 2008). The consequence is that GMAA* via CBGs is complete (and thus finds optimal solutions) as stated by the following theorem.\nTheorem 1. When using a heuristic of the form\nQ\u0302(~\u03b8t,a) = Est [R(s t,a) | ~\u03b8t] +E~\u03b8t+1 [V\u0302 ( ~\u03b8t+1) | ~\u03b8t,a], (2.9)\nwhere V\u0302 (~\u03b8t+1) \u2265 Q\u03c0\u2217(~\u03b8 t+1,\u03c0\u2217(~\u03b8t+1)) is an overestimation of the value of an optimal joint policy \u03c0\u2217, GMAA* via CBGs is complete.\nProof. See appendix.\nIn this theorem, Q\u03c0(~\u03b8 t,a) is the Q-value, i.e., the expected future cumulative reward of performing a from ~\u03b8t under joint policy \u03c0 (Oliehoek, Spaan, & Vlassis, 2008). The expectation of the immediate reward will also be written as R(~\u03b8t,a) = \u2211 s\u2208S R(s,a) Pr(s| ~\u03b8t,b0). It can be computed using Pr(s|~\u03b8t,b0), a quantity we refer to as the joint belief resulting from ~\u03b8t and that we also denote as b. The joint belief itself can be computed via repeated application of Bayes\u2019 rule (Kaelbling, Littman, & Cassandra, 1998), or as the conditional of (A.2).\nThe rest of this subsection reviews several heuristics that have been used for GMAA*."}, {"heading": "2.2.1 QMDP", "text": "One way to obtain an admissible heuristic Q\u0302(~\u03b8,a) is to solve the underlying MDP, i.e., to assume the joint action is chosen by a single \u2018puppeteer\u2019 agent that can observe the true state. This approach, known as QMDP (Littman, Cassandra, & Kaelbling, 1995), uses the MDP value function Qt,\u2217M (s t,a), which can be computed using standard dynamic programming techniques (Puterman, 1994). In order to transform the Qt,\u2217M (s t,a)-values to Q\u0302M(~\u03b8\nt,a)-values, we compute:\nQ\u0302M(~\u03b8 t,a) =\n\u2211\ns\u2208S\nQt,\u2217M (s,a) Pr(s| ~\u03b8t,b0). (2.10)\nSolving the underlying MDP has time complexity that is linear in h, which makes it, especially compared to the Dec-POMDP, easy to compute. In addition, it is only necessary to store a value for each (s,a)-pair, for each stage t. However, the bound it provides on the optimal Dec-POMDP Q\u2217-value function is loose (Oliehoek & Vlassis, 2007)."}, {"heading": "2.2.2 QPOMDP", "text": "Similar to the underlying MDP, one can define the underlying POMDP of a Dec-POMDP, i.e., assuming the joint action is chosen by a single agent with access to the joint observation.7\n7. Alternatively one can view this POMDP as a multiagent POMDP in which the agents can instantaneously broadcast their private observations.\nThe resulting solution can be used as a heuristic, called QPOMDP (Szer et al., 2005; Roth, Simmons, & Veloso, 2005). The optimal QPOMDP value function satisfies:\nQ\u2217P(b t,a) = R(bt,a) +\n\u2211\not+1\u2208O\nP (ot+1|bt,a)max at+1 Q\u2217P(b t+1,at+1), (2.11)\nwhere bt is the joint belief, R(bt,a) = \u2211\ns\u2208S R(s,a)b t(s) is the immediate reward, and bt+1 is\nthe joint belief resulting from bt by action a and joint observation ot+1. To use QPOMDP, for each ~\u03b8t, we can directly use the value for the induced joint belief: Q\u0302P(~\u03b8 t,a) , QtP(b ~\u03b8t ,a).\nThere are two approaches to computing QPOMDP. One is to construct the \u2018belief MDP tree\u2019 of all joint beliefs, illustrated in Fig. 5 (left). Starting with b0 (corresponding to the empty joint AOH ~\u03b80), for each a and o we compute the resulting ~\u03b81 and corresponding belief b ~\u03b81 and continue recursively. Given this tree, it is possible to compute values for all the nodes by standard dynamic programming.\nAnother possibility is to apply vector-based POMDP techniques (see Fig. 5 (right)). The Q-value function for a stage QtP(b,a) can be represented using a set of vectors for each joint action Vt = {Vt1, . . . ,V t |A|} (Kaelbling et al., 1998). Q t P(b,a) is then defined as the maximum inner product:\nQtP(b,a) , max vt a \u2208Vt a b \u00b7 vta.\nGiven Vh\u22121, the vector representation of the last stage, we can compute Vh\u22122, etc. In order to limit the growth of the number of vectors, dominated vectors can be pruned.\nSince QMDP is an upper bound on the POMDP value function (Hauskrecht, 2000), QPOMDP provides a tighter upper bound to Q\u2217 than QMDP. However, it is also more costly to compute and store: both the tree-based and the vector-based approach may need to store a number of values exponential in h."}, {"heading": "2.2.3 QBG", "text": "A third heuristic, called QBG, assumes that each agent in the team has access only to its individual observation but it can communicate with a 1-step delay.8 We define QBG as\nQ\u2217B( ~\u03b8t,a) = R(~\u03b8t,a) + max\n\u03b2\n\u2211\not+1\u2208O\nPr(ot+1|~\u03b8t,a)Q\u2217B( ~\u03b8t+1,\u03b2(ot+1)), (2.12)\nwhere \u03b2 = \u3008\u03b21(o t+1 1 ),...,\u03b2n(o t+1 n )\u3009 is a tuple of individual policies \u03b2i : Oi \u2192 Ai for the CBG constructed for ~\u03b8t,a. Like QPOMDP, QBG can also be represented using vectors (Varaiya & Walrand, 1978; Hsu & Marcus, 1982; Oliehoek, Spaan, & Vlassis, 2008) and the same two manners of computation (tree and vector based) apply. It yields a tighter heuristic than QPOMDP, but its computation has an additional exponential dependence on the maximum number of individual observations (Oliehoek, Spaan, & Vlassis, 2008), which is particularly troubling for the vector-based computation, since it precludes effective application of incremental pruning (A. Cassandra, Littman, & Zhang, 1997). To overcome this problem, Oliehoek and Spaan (2012) introduce novel tree-based pruning methods."}, {"heading": "3. Clustering", "text": "GMAA* solves Dec-POMDPs by repeatedly constructing CBGs and expanding all the joint BG policies \u03b2 for them. However, the number of such \u03b2 is equal to the number of regular MAA* child nodes given by (2.5) and thus grows doubly exponentially with the horizon h. In this section, we propose a new approach for improving scalability with respect to h by clustering individual AOHs. This reduces the number of \u03b2 and therefore the number of constructed child nodes in the GMAA* search tree.9\nPrevious research has also investigated such clustering: Emery-Montemerlo, Gordon, Schneider, and Thrun (2005) propose clustering types based on the profiles of the payoff functions of the CBGs. However, the resulting method is ad hoc. Even given bounds on the error of clustering two types in a CBG, no guarantees can be made about the quality of the Dec-POMDP solution, as the bound is with respect to a heuristic payoff function.\nIn contrast, we propose to cluster histories based on the probability these histories induce over histories of the other agents and over states. The critical advantage of this criterion, which we call probabilistic equivalence (PE), is that the resulting clustering is lossless: the solution for the clustered CBG can be used to construct the solution for the original CBG and the values of the two CBGs are identical. Thus, the criterion allows for clustering of AOHs in CBGs that represent Dec-POMDPs while preserving optimality.10\nIn Section 3.1, we describe how histories in Dec-POMDPs can be clustered using the notions of probabilistic and best-response equivalence. This allows histories to be clustered\n8. The name QBG stems from the fact that such a 1-step delayed communication scenario can be modeled as a CBG. Note, however, that the CBGs used to compute QBG are of a different form than the B(b\n0,\u03d5t) discussed in Section 2.1.2: in the latter, types correspond to length-t (action-) observation histories; in the former, types correspond to length-1 observation histories. 9. While CBGs are not essential for clustering, they provide a convenient level of abstraction that simplifies exposition of our techniques. Moreover, this level of abstraction makes it possible to employ our results concerning CBGs outside the context of Dec-POMDPs. 10. The probabilistic equivalence criterion and lossless clustering were introduced by Oliehoek et al. (2009). This article presents a new, simpler proof of the optimality of clustering based on PE.\nwhen it is rational to always choose the same action. In Section 3.2, we describe the application of these results to GMAA*. Section 3.3 introduces improved heuristic representations that allow for the computation over longer horizons."}, {"heading": "3.1 Lossless Clustering in Dec-POMDPs", "text": "In this section, we discuss lossless clustering based on the notion of probabilistic equivalence. We show that this clustering is lossless by demonstrating that probabilistic equivalence implies best response equivalence, which describes the conditions that a rational agent will select the same action for two of its types. To prove this implication, we show that the best response depends only on the multiagent belief (i.e., the probability distribution over states and policies of the other agents), which is the same for two probabilistically equivalent histories. Relations to other equivalence notions are discussed in Section 6."}, {"heading": "3.1.1 Probabilistic Equivalence Criterion", "text": "We first introduce the probabilistic equivalence criterion, which can be used to decide whether two individual histories ~\u03b8 ai , ~\u03b8 bi can be clustered without loss in value.\nCriterion 1 (Probabilistic Equivalence). Two AOHs ~\u03b8 ai , ~\u03b8 bi for agent i are probabilistically equivalent (PE), written PE(~\u03b8 ai , ~\u03b8 bi ), when the following holds:\n\u2200~\u03b8 6=i\u2200s Pr(s, ~\u03b8 6=i|~\u03b8 a i ) = Pr(s,~\u03b8 6=i|~\u03b8 b i ). (3.1)\nThese probabilities can be computed as the conditional of Pr(s,~\u03b8t|b0,\u03d5t), defined by (A.2). In subsections 3.1.2\u20133.1.4, we formally prove that PE is a sufficient criterion to guarantee that clustering is lossless. In the remainder of Section 3.1.1 we discuss some key properties of the PE criterion in order to build intuition.\nNote that the criterion can be decomposed into the following two criteria:\n\u2200~\u03b8 6=i Pr( ~\u03b8 6=i|~\u03b8 a i ) = Pr(~\u03b8 6=i| ~\u03b8 bi ), (3.2)\n\u2200~\u03b8 6=i\u2200s Pr(s| ~\u03b8 6=i,~\u03b8 a i ) = Pr(s|~\u03b8 6=i, ~\u03b8 bi ). (3.3)\nThese criteria give a natural interpretation: the first says that the probability distribution over the other agents\u2019 AOHs must be identical for both ~\u03b8 ai and\n~\u03b8 bi . The second demands that the resulting joint beliefs are identical.\nThe above probabilities are not well defined without the initial state distribution b0 and past joint policy \u03d5t. However, since we consider clustering of histories within a particular CBG (for some stage t) constructed for a particular b0,\u03d5t, they are implicitly specified. Therefore we drop these arguments, clarifying the notation.\nExample 4. In Example 3, the types (oHL,oHR) and (oHR,oHL) of each agent are PE. To see this, note that the rows (columns for the second agent) for these histories are identical in both Fig. 4a and Fig. 4b. Thus, they specify the same distribution over histories of the other agents (cf. equation (3.2)) and the induced joint beliefs are the same (cf. equation (3.3)).\nProbabilistic equivalence has a convenient property that our algorithms exploit: if it holds for a particular pair of histories, then it will also hold for all identical extensions of those histories, i.e., it propagates forwards regardless of the policies of the other agents.\nDefinition 7 (Identical extensions). Given two AOHs ~\u03b8 a,ti , ~\u03b8 b,ti , their respective extensions ~\u03b8 a,t+1i = ( ~\u03b8 a,ti ,ai,oi) and ~\u03b8 b,t+1i = ( ~\u03b8 b,ti ,a \u2032 i,o \u2032 i) are called identical extensions if and only if ai = a \u2032 i and oi = o \u2032 i.\nLemma 1 (Propagation of PE). Given ~\u03b8 a,ti , ~\u03b8 b,ti that are PE, regardless of the decision rule the other agents use (\u03b4t6=i), identical extensions are also PE:\n\u2200ati\u2200ot+1i \u2200\u03b4t6=i\u2200st+1\u2200~\u03b8t+16=i\nPr(st+1,~\u03b8 t+1 6=i | ~\u03b8 a,ti ,a t i,o t+1 i ,\u03b4 t 6=i) = Pr(s t+1,~\u03b8 t+1 6=i | ~\u03b8 b,ti ,a t i,o t+1 i ,\u03b4 t 6=i) (3.4)\nProof. The proof is listed in the appendix, but holds intuitively because if the probabilities described above were the same before, they will also be the same after taking the same action and seeing the same observation.\nNote that, while the probabilities defined in (3.1) superficially resemble beliefs used in POMDPs, they are substantially different. In a POMDP, the single agent can compute its individual belief using only its AOH. It can then use this belief to determine the value of any future policy, as it is a sufficient statistic of the history to predict the future rewards (Kaelbling et al., 1998; Bertsekas, 2005). Thus, it is trivial to show equivalence of AOHs that induce the same individual belief in a POMDP. Unfortunately, Dec-POMDPs are more problematic. The next section elaborates on this issue by discussing the relation to multiagent beliefs."}, {"heading": "3.1.2 Sub-Tree Policies, Multiagent Beliefs and Expected Future Value", "text": "To describe the relationship between multiagent beliefs and probabilistic equivalence, we must first discuss the policies an agent may follow and their resulting values. We begin by introducing the concept of sub-tree policies. As illustrated in Fig. 2 (on page 456), a (deterministic) policy \u03c0i can be represented as a tree with nodes labeled using actions and edges labeled using observations: the root node corresponds to the first action taken, other nodes specify the action for the observation history encoded by the path from the root node. As such, it is possible to define sub-tree policies, \u03b3i, which correspond to sub-trees of agent i\u2019s policy \u03c0i (also illustrated in Fig. 2). In particular, we write\n\u03c0i w\n~o ti = \u03b3\u03c4=h\u2212ti (3.5)\nfor the sub-tree policy of \u03c0i corresponding to observation history ~o t i that specifies the actions\nfor the last \u03c4 = h \u2212 t stages. We refer to w as the policy consumption operator, since it \u2018consumes\u2019 the part of the policy corresponding to ~o ti . Similarly we write \u03b3 \u03c4=k i w ~o li\n= \u03b3\u03c4=k\u2212li (note that in (3.5), \u03c0i is just a \u03c4 = h-steps-to-go sub-tree policy) and use similar notation, \u03b3\u03c4=k, for joint sub-tree policies. For a more extensive treatment of these different forms of policy, we refer to the discussion by Oliehoek (2012).\nGiven these concepts, we can define the value of a \u03c4 = k-stages-to-go joint policy starting from state s:\nV (s,\u03b3\u03c4=k) = R(s,a) + \u2211\ns\u2032\n\u2211\no\nPr(s\u2032,o|s,a)V (s\u2032,\u03b3\u03c4=k w\no ). (3.6)\nHere, a is the joint action specified by the roots of the individual sub-tree policies specified by \u03b3\u03c4=k for stage t = h\u2212 k.\nFrom this definition, it follows directly that the probability distribution over states s and sub-tree policies over other agents \u03b3 6=i is sufficient to predict the value of a sub-tree policy \u03b3i. In fact, such a distribution is known as a multiagent belief bi(s,\u03b3 6=i) (Hansen, Bernstein, & Zilberstein, 2004). Its value is given by\nV (bi) = max \u03b3i\n\u2211\ns\n\u2211\n\u03b3 6=i\nbi(s,\u03b3 6=i)V (s,\u3008\u03b3i,\u03b3 6=i\u3009), (3.7)\nand we refer to the maximizing \u03b3i as agent i\u2019s best response for bi. This illustrates that a multiagent belief is a sufficient statistic: it contains sufficient information to predict the value of any sub-tree policy \u03b3i.\nIt is possible to connect action observation histories to multiagent beliefs by fixing the policies of the other agents. Given that the other agents will act according to a profile of policies \u03c0 6=i, agent i has a multiagent belief at the first stage of the Dec-POMDP: bi(s,\u03c0 6=i) = b0(s). Moreover, agent i can maintain such a multiagent belief during execution. As such, given \u03c0 6=i, each history ~\u03b8i induces a multiagent belief, which we will write as bi(s,\u03b3 6=i|~\u03b8i,\u03c0 6=i) to make the dependence on ~\u03b8i,\u03c0 6=i explicit. The multiagent belief for a history is defined as\nbi(s,\u03b3 6=i|~\u03b8i,\u03c0 6=i) , Pr(s,\u03b3 6=i|~\u03b8i, b 0,\u03c0 6=i), (3.8)\nand induces a best response via (3.7):\nBR(~\u03b8i|\u03c0 6=i) , argmax \u03b3i\n\u2211\ns\n\u2211\n\u03b3 6=i\nbi(s,\u03b3 6=i|~\u03b8i,\u03c0 6=i)V (s,\u03b3 6=i,\u03b3i). (3.9)\nFrom this we can conclude that two AOHs ~\u03b8 ai , ~\u03b8 bi can be clustered together if they induce the same multiagent belief. However, this notion of multiagent belief is clearly quite different from the distributions used in our notion of PE. In particular, to establish whether two AOHs induce the same multiagent belief, we need a full specification of \u03c0 6=i. Nevertheless, we show that two AOHs that are PE are also best response equivalent and that we can therefore cluster them. The crux is that we can show that, if Criterion 1 is satisfied, the AOHs will always induce the same multiagent beliefs for any \u03c0 6=i (consistent with the current past joint policy \u03d56=i)."}, {"heading": "3.1.3 Best-Response Equivalence Allows Lossless Clustering of Histories", "text": "We can now relate probabilistic equivalence and the multiagent belief as follows.\nLemma 2 (PE implies multiagent belief equivalence). For any \u03c0 6=i, probabilistic equivalence implies multiagent belief equivalence:\nPE(~\u03b8 ai , ~\u03b8 bi ) \u21d2 \u2200s,\u03b3 6=i ( bi(s,\u03b3 6=i|~\u03b8 a i ,\u03c0 6=i) = bi(s,\u03b3 6=i|~\u03b8 b i ,\u03c0 6=i) ) (3.10)\nProof. See appendix.\nThis lemma shows that if two AOHs are PE, they produce the same multiagent belief. Intuitively, this gives us a justification to cluster such AOHs together: since a multiagent belief is a sufficient statistic we should act the same when we have the same multiagent belief, but since Lemma 2 shows that ~\u03b8 ai ,\n~\u03b8 bi induces the same multiagent beliefs for any \u03c0 6=i when they are PE, we can conclude that we will always act the same in those histories. Formally, we prove that ~\u03b8 ai , ~\u03b8 bi are best-response equivalent if they are PE.\nTheorem 2 (PE implies best-response equivalence). Probabilistic equivalence implies bestresponse equivalence. That is\nPE(~\u03b8 ai , ~\u03b8 bi ) \u21d2 \u2200\u03c0 6=i ( BR(~\u03b8 ai |\u03c0 6=i) = BR(~\u03b8 b i |\u03c0 6=i) )\nProof. Assume any arbitrary \u03c0 6=i, then\nBR(~\u03b8 ai |\u03c0 6=i) = argmax \u03b3i\n\u2211\ns\n\u2211\n\u03b3 6=i\nbi(s,\u03b3 6=i|~\u03b8 a i )V (s,\u03b3 6=i,\u03b3i)\n= argmax \u03b3i\n\u2211\ns\n\u2211\n\u03b3 6=i\nbi(s,\u03b3 6=i|~\u03b8 b i )V (s,\u03b3 6=i,\u03b3i) = BR( ~\u03b8 bi |\u03c0 6=i),\nwhere Lemma 2 is employed to assert the equality of bi(\u00b7|~\u03b8 a i ) and bi(\u00b7| ~\u03b8 bi ).\nThis theorem is key because it demonstrates that when two AOHs ~\u03b8 ai , ~\u03b8 bi of an agent are PE, then that agent need not discriminate between them now or in the future. Thus, when searching the space of joint policies, we can restrict our search to those that assign the same sub-tree policy \u03b3i to ~\u03b8 a i and\n~\u03b8 bi . As such, it directly provides intuition as to why lossless clustering is possible. Formally, we define the clustered joint policy space as follows.\nDefinition 8 (Clustered joint policy space). Let \u03a0C \u2286 \u03a0 be the subset of joint policies that is clustered: i.e., each \u03c0i that is part of a \u03c0 \u2208 \u03a0C assigns the same sub-tree policy to action observation histories that are probabilistically equivalent.\nCorollary 1 (Existence of an optimal clustered joint policy). There exists an optimal joint policy in the clustered joint policy space:\nmax \u03c0\u2208\u03a0C V (\u03c0) = max \u03c0\u2208\u03a0 V (\u03c0) (3.11)\nProof. It is clear that the left hand side of (3.11) is upper bounded by the right hand side, since \u03a0C \u2286 \u03a0. Now suppose that \u03c0\n\u2217 = argmax\u03c0\u2208\u03a0 V (\u03c0) has strictly higher value than the best clustered joint policy. For at least one agent i and one pair of PE histories ~\u03b8 ai , ~\u03b8 bi , \u03c0 \u2217 must assign different sub-tree policies \u03b3ai 6= \u03b3 b i (otherwise \u03c0\n\u2217 would be clustered). Without loss of generality we assume that there is only one such pair. It follows directly from Theorem 2 that from this policy we can construct a clustered policy \u03c0C \u2208 \u03a0C (by assigning either \u03b3 a i or \u03b3 b i to both ~\u03b8 ai , ~\u03b8 bi ) that is guaranteed to have value no less than \u03c0\n\u2217, thereby contradicting the assumption that \u03c0\u2217 has strictly higher value than the best clustered joint policy.\nThis formally proves that we can restrict our search to \u03a0C , the space of clustered joint policies, without sacrificing optimality."}, {"heading": "3.1.4 Clustering with Commitment in CBGs", "text": "Though it is now clear that two AOHs that are PE can be clustered, making this result operational requires an additional step. To this end, we use the abstraction layer provided by Bayesian games. Recall that in the CBG for a stage, the AOHs correspond to types.\nTherefore, we want to cluster these types in the CBG. To accomplish the clustering of two types \u03b8ai ,\u03b8 b i , we introduce a new type \u03b8 c i to replace them, by defining:\n\u2200\u03b8 6=i Pr(\u03b8 c i ,\u03b8 6=i) , Pr(\u03b8 a i ,\u03b8 6=i) + Pr(\u03b8 b i ,\u03b8 6=i) (3.12)\n\u2200j\u2200a u(\u3008\u03b8 c i ,\u03b8 6=i\u3009 ,a) ,\nPr(\u03b8ai ,\u03b8 6=i)u(\u3008\u03b8 a i ,\u03b8 6=i\u3009 ,a) + Pr(\u03b8 b i ,\u03b8 6=i)u( \u2329 \u03b8bi ,\u03b8 6=i \u232a ,a)\nPr(\u03b8ai ,\u03b8 6=i) + Pr(\u03b8 b i ,\u03b8 6=i)\n. (3.13)\nTheorem 3 (Reduction through commitment). Given that agent i in collaborative Bayesian game B is committed to selecting a policy that assigns the same action for two of its types \u03b8ai ,\u03b8 b i , i.e., to selecting a policy \u03b2i such that \u03b2i(\u03b8 a i ) = \u03b2i(\u03b8 b i ), the CBG can be reduced without loss in value for any agents. That is, the result is a new CBG B\u2032 in which agent i employs a policy \u03b2\u2032i that reflects the clustering and whose expected payoff is the same as in the original CBG: V B\n\u2032 (\u03b2\u2032i,\u03b2 6=i) = V B(\u03b2i,\u03b2 6=i).\nProof. See appendix.\nThis theorem shows that, given that agent i is committed to taking the same action for its types \u03b8ai ,\u03b8 b i , we can reduce the collaborative Bayesian game B to a smaller one B\n\u2032 and translate the joint CBG-policy \u03b2\u2032 found for B\u2032 back to a joint CBG-policy \u03b2 in B. This does not necessarily mean that \u03b2 = ( \u03b2i,\u03b2 6=i ) is also a solution for B, because the best-response of agent i against \u03b2 6=i may not select the same action for \u03b8 a i ,\u03b8 b i . Rather \u03b2i is the best-response against \u03b2 6=i given that the same action needs to be taken for \u03b8 a i ,\u03b8 b i . 11\nEven though Theorem 3 only gives a conditional statement that depends on an agent being committed to select the same action for two of its types, the previous subsection discussed when a rational agent can make such a commitment. Combining these results gives the following corollary.\nCorollary 2 (Lossless Clustering with PE). Probabilistically equivalent histories ~\u03b8 ai , ~\u03b8 bi can be clustered without loss in heuristic value by merging them into a single type in a CBG.\nProof. Theorem 3 shows that, given that an agent i is committed to take the same action for two of its types, those types can be clustered without loss in value. Since ~\u03b8 ai ,\n~\u03b8 bi are PE, they are best-response equivalent, which means that the agent is committed to use the same sub-tree policy \u03b3i and hence the same action ai. Therefore we can directly apply clustering without loss in expected payoff, which in a CBG for a stage of a Dec-POMDP means no loss in expected heuristic value as given by (2.7).\nIntuitively, the maximizing action is the same for ~\u03b8 ai and ~\u03b8 bi regardless of what (future) joint policies \u03c0 6=i the other agents will use and hence we can cluster them without loss in heuristic value. Note that this does not depend on which heuristic is used and hence also holds for an optimal heuristic (i.e., when using an optimal Q-value function that gives the true value). This directly relates probabilistic equivalence with equivalence in optimal value.12\n11. Although we focus on CBGs, these results generalize to BGs with individual payoff functions. Thus, they could potentially be exploited by algorithms for general-payoff BGs. Developing methods that do so is an interesting avenue for future work. 12. The proof originally provided by Oliehoek et al. (2009) is based on showing that histories that are PE will induce identical Q-values.\nAlgorithm 6 ClusterCBG(B)\nInput: CBG B Output: Losslessly clustered CBG B 1: for each agent i do 2: for each individual type \u03b8i \u2208 B.\u0398i do 3: if Pr(\u03b8i) = 0 then 4: B.\u0398i \u2190 B.\u0398i\\\u03b8i {Prune \u03b8i from B:} 5: continue 6: end if\n7: for each individual type \u03b8\u2032i \u2208 B.\u0398i do 8: isProbabilisticallyEquivalent \u2190 true 9: for all \u3008s,\u03b8 6=i\u3009 do\n10: if Pr(s,\u03b8 6=i|\u03b8i) 6= Pr(s,\u03b8 6=i|\u03b8 \u2032 i) then 11: isProbabilisticallyEquivalent \u2190 false 12: break 13: end if 14: end for 15: if isProbabilisticallyEquivalent then 16: B.\u0398i \u2190 B.\u0398i\\\u03b8 \u2032 i {Prune \u03b8 \u2032 i from B:} 17: for each a \u2208 A do 18: for all \u03b8 6=i do 19: u(\u03b8i,\u03b8 6=i,a) \u2190 min(u(\u03b8i,\u03b8 6=i,a),u(\u03b8 \u2032 i,\u03b8 6=i,a)) { take the lowest upper bound } 20: Pr(\u03b8i,\u03b8 6=i) \u2190 Pr(\u03b8i,\u03b8 6=i) + Pr(\u03b8 \u2032 i,\u03b8 6=i) 21: Pr(\u03b8\u2032i,\u03b8 6=i) \u2190 0 22: end for 23: end for 24: end if 25: end for 26: end for 27: end for 28: return B\nNote that this result establishes a sufficient, but not necessary condition for lossless clustering. In particular, given policies for the other agents, many types are best-response equivalent and can be clustered. However, as far as we know, the criterion must hold in order to guarantee that two histories have the same best-response against any policy of the other agents."}, {"heading": "3.2 GMAA* with Incremental Clustering", "text": "Knowing which individual histories can be clustered together without loss of value has the potential to speed up many Dec-POMDP methods. In this article, we focus on its application within the GMAA* framework.\nEmery-Montemerlo et al. (2005) showed how clustering can be incorporated at every stage in their algorithm: when the CBG for a stage t is constructed, a clustering of the individual histories (types) is performed first and only afterwards is the (reduced) CBG solved. The same approach can be employed within GMAA* by modifying the Expand procedure (Algorithm 5) to cluster the CBG before calling GenerateAllChildrenForCBG.\nAlgorithm 6 shows the clustering algorithm. It takes as input a CBG and returns the clustered CBG. It performs clustering by performing pairwise comparison of all types of each\nAlgorithm 7 ConstructExtendedBG(B,\u03b2t\u22121, Q\u0302) Input: A CBG B for stage t\u2212 1, and the joint BG policy followed \u03b2t\u22121. Input: An admissible heuristic of the form Q\u0302(~\u03b8,a). Output: CBG B\u2032 for stage t. 1: B\u2032 \u2190 B {make a copy of B that we subsequently alter} 2: for each agent i do 3: B\u2032.\u0398i = ConstructExtendedTypeSet(i) {overwrite the individual type sets} 4: end for\n5: B\u2032.\u0398 \u2190 \u00d7i\u2208D\u0398i {the new joint type set (does not have to be explicitly stored)} 6: for each joint type \u03b8 = (\u03b8t\u22121,at\u22121,ot) \u2208 B\u2032.\u0398 do 7: for each state st \u2208 S do 8: Compute Pr(st|\u03b8) {from Pr(st\u22121|\u03b8t\u22121) via Bayes\u2019 rule } 9: end for\n10: Pr(\u03b8) \u2190 Pr(ot|\u03b8t\u22121,at\u22121) Pr(\u03b8t\u22121) 11: for each a \u2208 A do 12: q \u2190 \u221e 13: for each history ~\u03b8t represented by \u03b8 do 14: q \u2190 min(q,Q\u0302(~\u03b8t,a)) { if Q\u2217 \u2264 Q\u0302 we can take the lowest upper bound } 15: end for 16: B\u2032.u(\u03b8,a) \u2190 q 17: end for 18: end for 19: return B\u2032\nagent to see if they satisfy the criterion, yielding O(|\u0398i| 2) comparisons for each agent i. Each comparison involves looping over all \u3008s,\u03b8 6=i\u3009 (line 9). If there are many states, some efficiency could be gained by first checking (3.2) and then checking (3.3). Rather than taking the average as in (3.13), on line 19 we take the lowest payoff, which can be done if we are using upper bound heuristic values.\nThe following theorem demonstrates that, when incorporating clustering into GMAA*, the resulting algorithm is still guaranteed to find an optimal solution.\nTheorem 4. When using a heuristic of the form (2.9) and clustering the CBGs in GMAA* using the PE criterion, the resulting search method is complete.\nProof. Applying clustering does not alter the computation of lower bound values. Also, heuristic values computed for the expanded nodes are admissible and in fact unaltered as guaranteed by Corollary 2. Therefore, the only difference with regular GMAA* is that the class of considered joint policies is restricted to \u03a0C , the class of clustered joint policies: not all possible child nodes are expanded, because clustering effectively prunes away policies that would specify different actions for AOHs that are PE and thus clustered. However, Corollary 1 guarantees that there exists an optimal joint policy in this restricted class.\nThe modification of the Expand proposed above is rather naive. To construct B(b0,\u03d5t) it must first construct all |Oi|\nt possible AOHs for agent i (given the past policy \u03d5ti). The subsequent clustering involves pairwise comparison of all these exponentially many types. Clearly, this is not tractable for later stages.\nHowever, because PE of AOHs propagates forwards (i.e., identical extensions of PE histories are also PE), a more efficient approach is possible. Instead of clustering this exponentially\nAlgorithm 8 Expand-IC(q,H). The expand operator for GMAA*-IC. Input: q = \u3008\u03d5t, v\u0302\u3009 the search node to expand. Input: H the admissible heuristic that is of the form Q\u0302(~\u03b8,a). Output: QExpand the set containing expanded child nodes.\n1: B(\u03d5t\u22121) \u2190 \u03d5t\u22121.CBG {retrieve previous CBG, note \u03d5t = (\u03d5t\u22121,\u03b2t\u22121)} 2: B(\u03d5t) \u2190 ConstructExtendedBG(B(\u03d5t\u22121),\u03b2t\u22121, Q\u0302) 3: B(\u03d5t) \u2190 ClusterBG(B(\u03d5t)) 4: \u03d5t.CBG \u2190 B(\u03d5t) {store pointer to this CBG} 5: QExpand \u2190 GenerateAllChildrenForCBG(B(\u03d5\nt)) 6: return QExpand\ngrowing set of types, we can simply extend the already clustered types of the previous stage\u2019s CBG, as shown in Algorithm 7. That is, given \u0398i, the set of types of agent i at the previous stage t\u2212 1, and \u03b2t\u22121i the policy agent i took at that stage, the set of types at stage t, \u0398 \u2032 i, can be constructed as\n\u0398\u2032i = { \u03b8\u2032i = (\u03b8i,\u03b2 t\u22121 i (\u03b8i),o t i) | \u03b8i \u2208 \u0398i,o t i \u2208 Oi } . (3.14)\nThis means that the size of this newly constructed set is |\u0398\u2032i| = |\u0398i| \u00b7 |Oi| . If the type set \u0398i at the previous stage t\u22121 was much smaller than the set of all histories |\u0398i| \u226a |Oi|\nt\u22121, then the new type set \u0398\u2032i is also much smaller: |\u0398 \u2032 i| \u226a |Oi|\nt. In this way, we bootstrap the clustering at each stage and spend significantly less time clustering. We refer to the algorithm that implements this type of clustering as GMAA* with Incremental Clustering (GMAA*-IC). This approach is possible only because we perform an exact, value-preserving clustering for which Lemma 1 guarantees that identical extensions will also be clustered without loss in value. When performing the same procedure in a lossy clustering scheme (e.g., as in EmeryMontemerlo et al., 2005), errors might accumulate, and a better option might be to re-cluster from scratch at every stage.\nExpansion of a GMAA*-IC node takes exponential time with respect to both the number of agents and types, as there are O(|A\u2217|\nn|\u0398\u2217|) joint CBG-policies and thus child nodes in the GMAA*-IC search tree (A\u2217 is the largest action set and \u0398\u2217 is the largest type set). Clustering involves a pairwise comparison of all types of each agent and each of these comparisons needs to check O(|\u0398\u2217|\nn\u22121 |S|) numbers for equality to verify (3.1). The total cost of clustering can therefore be written as\nO(n |\u0398\u2217| 2 |\u0398\u2217| n\u22121 |S|),\nwhich is only polynomial in the number of types. When clustering decreases the number of types |\u0398\u2217|, it can therefore significantly reduce the number of child nodes and thereby the overall time needed. However, when no clustering is possible, some overhead will be incurred."}, {"heading": "3.3 Improved Heuristic Representation", "text": "Since clustering can reduce the number of types, GMAA*-IC has the potential to scale to larger horizons. However, doing so has important consequences for the computation of the heuristics. Previous research has shown that the upper bound provided by QMDP is often too loose for effective heuristic search (Oliehoek, Spaan, & Vlassis, 2008). However, the space needed to store tighter heuristics such as QPOMDP or QBG grows exponentially with the horizon. Recall from Section 2.2.2 (see Fig. 5) that there are two approaches to computing\nAlgorithm 9 Compute Hybrid Q\u0302 with minimum size.\n1: Qh\u22121 \u2190 {R1, . . . ,R|A|} {vector representation of last stage} 2: z \u2190 |A| \u00d7 |S| {the size of the |A| vectors} 3: for t = h\u2212 2 to 0 do 4: y \u2190 |~\u0398t| \u00d7 |A| {size of AOH representation} 5: if z < y then 6: V \u2190 VectorBackup(Qt+1) 7: V \u2032 \u2190 Prune(V) 8: Qt \u2190 V \u2032\n9: z \u2190 |V \u2032| \u00d7 |S| 10: end if 11: if z \u2265 y then 12: Qt \u2190 TreeBackup(Qt+1) {From now on z \u2265 y} 13: end if 14: end for\nQPOMDP or QBG. The first constructs a tree of all joint AOHs and their heuristic values, which is simple to implement but requires storing a value for each (~\u03b8t,a)-pair, the number of which grows exponentially with t. The second approach maintains a vector-based representation, as is common for POMDPs. Though pruning can provide leverage, in the worst case, no pruning is possible and the number of maintained vectors grows doubly exponentially with h\u2212 t, the number of stages-to-go. Similarly, the initial belief and subsequently reachable beliefs can be used to reduce the number of vectors retained at each stage, but as the number of reachable beliefs is exponential in the horizon the exponential complexity remains.\nHybrid\nOliehoek, Spaan, and Vlassis (2008) used a tree-based representation for the QPOMDP and QBG heuristics. Since the computational cost of solving the Dec-POMDP was the bottleneck, the inefficiencies in the representation could be overlooked. However, this approach is no longer feasible for the longer horizons made possible by GMAA*-IC.\nTo mitigate this problem, we propose a hybrid representation for the heuristics, as illustrated in Fig. 6. The main insight is that the exponential growth of the two existing representations occurs in opposite directions. Therefore, we can use the low space-complexity side of both representations: the later stages, which have fewer vectors, use a vector-based representation, while the earlier stages, which have fewer histories, use a history-based representation. This is similar to the idea of utilizing reachable beliefs to reduce the size of the vector representation described above but, rather than storing vectors for the appropriate AOHs at each step, only the values are needed when using the tree-based representation.\nAlgorithm 9 shows how, under mild assumptions, a minimally-sized representation can be computed. Starting from the last stage, the algorithm performs vector backups, switching to tree backups when they become the smaller option. For the last time step h\u2212 1, we represent\nQt by the set of immediate reward vectors13, and variable z (initialized on line 2) keeps track of the number of parameters needed to represent Qt as vectors for the time step at hand. Note that z depends on how effective the vector pruning is, i.e., how large the parsimonious representation of the piecewise linear and convex value function is. Since this is problem dependent, z can be updated only after pruning has actually been performed (line 9). By contrast y, the number of parameters in a tree representation, can be computed directly from the Dec-POMDP (line 4). When z > y, the algorithm switches to tree backups.14"}, {"heading": "4. Incremental Expansion", "text": "The clustering technique presented in the previous section has the potential to significantly speed up planning if much clustering is possible. However, if little clustering is possible, the number of children in theGMAA* search tree will still grow super-exponentially. This section presents incremental expansion, a complementary technique to deal with this problem.\nIncremental expansion exploits recent improvements in effectively solving CBGs. First note that during the expansion of the last stage t = h\u2212 1 for a particular \u03d5h\u22121, we are only interested in the best child (\u03d5h\u22121,\u03b4h\u22121,\u2217), which corresponds to the optimal solution of the Bayesian game \u03b4h\u22121,\u2217 \u2194 \u03b2\u2217. As such, for this last stage, we can use new methods for solving CBGs (Kumar & Zilberstein, 2010b; Oliehoek, Spaan, Dibangoye, & Amato, 2010) that can provide speedups of multiple orders of magnitude over brute force search (enumeration).15 Unfortunately, the improvements to GMAA* afforded by this approach are limited: in order to guarantee optimality, it still relies on expansion of all (child nodes corresponding to all) joint CBG-policies \u03b2 for the intermediate stages, thus necessitating a brute-force approach. However, many of the expanded child nodes may have low heuristic values V\u0302 and may therefore never be selected for further expansion.\nIncremental expansion overcomes this problem because it exploits the following key observation: if we can generate the children in decreasing heuristic order using an admissible heuristic, we do not have to expand all the children. As before, an A* search is performed over partially specified policies and each new CBG is constructed by extending the CBG for the parent node. However, rather than fully expanding (i.e., enumerating all the CBG policies of and thereby constructing all children for) each search node, we instantiate an incremental CBG solver for the corresponding CBG. This incremental solver returns only one joint CBG policy at a time, which is then used to construct a single child \u03d5t+1 = (\u03d5t,\u03b2). By revisiting the nodes, only the promising child nodes are expanded incrementally.\nBelow, we describe GMAA*-ICE, an algorithm that combines GMAA*-IC with incremental expansion. We establish theoretical guarantees and describe the modifications to BaGaBaB, the CBG solver that GMAA*-ICE employs, that are necessary to deliver the child nodes in decreasing order.\n13. Only in exceptional cases where a short horizon is combined with large state and action spaces will representing the last time step as vectors not be minimal. In such cases, the algorithm can be trivially adapted. 14. This assumes that the vector representation will not shrink again for earlier stages. Although unlikely in practice, such cases would prevent the algorithm from computing a minimal representation. 15. Kumar and Zilberstein (2010b) tackle a slightly different problem; they introduce a weighted constraint satisfaction approach to solving the point-based backup in dynamic programming for Dec-POMDPs. However, this point-based backup can be interpreted as a collection of CBGs (Oliehoek et al., 2010)."}, {"heading": "4.1 GMAA* with Incremental Clustering and Expansion", "text": "We begin by formalizing incremental expansion and incorporating it into GMAA*-IC, yielding GMAA* with incremental clustering and expansion (GMAA*-ICE). At the core of incremental expansion lies the following lemma:\nLemma 3. Given two joint CBG policies \u03b2,\u03b2\u2032 for a CBG B(b0,\u03d5t), if V\u0302 (\u03b2) \u2265 V\u0302 (\u03b2\u2032), then for the corresponding child nodes V\u0302 (\u03d5t+1) \u2265 V\u0302 (\u03d5t+1\u2032).\nProof. This holds directly by the definition of V\u0302 (\u03d5t) as given by (2.8):\nV\u0302 (\u03d5t+1) = V 0...(t\u22121)(\u03d5t) + V\u0302 (\u03b2)\n\u2265 V 0...(t\u22121)(\u03d5t) + V\u0302 (\u03b2\u2032) = V\u0302 (\u03d5t+1\u2032).\nIt follows directly that, if for B(b0,\u03d5t) we use a CBG solver that can generate a sequence of policies \u03b2,\u03b2\u2032, . . . such that\nV\u0302 (\u03b2) \u2265 V\u0302 (\u03b2\u2032) \u2265 . . .\nthen, for the sequence of corresponding children\nV\u0302 (\u03d5t+1) \u2265 V\u0302 (\u03d5t+1\u2032) \u2265 . . . .\nExploiting this knowledge, we can expand only the first child \u03d5t+1 and compute its heuristic value V\u0302 (\u03d5t+1) using (2.8). Since all the unexpanded siblings will have heuristic values less than or equal to that, we can modify GMAA*-IC to reinsert the node q into the open list L to act as a placeholder for all its non-expanded children.\nDefinition 9. A placeholder is a node for which at least one child has been expanded. A placeholder has a heuristic value equal to its last expanded child.\nThus, after expansion of a search node q\u2019s child, we update q.v\u0302, the heuristic value of the node, to V\u0302 (\u03d5t+1), the value of the expanded child, i.e., we set q.v\u0302 \u2190 V\u0302 (\u03d5t+1). As such, we can reinsert q into L as a placeholder. As mentioned above, this is correct because all the unexpanded siblings (for which the parent node q now is a placeholder) have heuristic values lower than or equal to V\u0302 (\u03d5t+1). Therefore the next sibling q\u2032 represented by the placeholder is always expanded in time: q\u2032 is always created before nodes with lower heuristic value are selected for further expansion. We keep track of whether a node is a previously expanded placeholder or not.\nAs before, GMAA*-ICE performs an A* search over partially specified policies. As in GMAA*-IC, each new CBG is constructed by extending the CBG for the parent node and then applying lossless clustering. However, rather than expanding all children, GMAA*-ICE requests only the next solution \u03b2 of an incremental CBG solver, from which a single child \u03d5t+1 = (\u03d5t,\u03b2) is constructed. In principle GMAA*-ICE can use any CBG solver that is able to incrementally deliver all \u03b2 in descending order of V\u0302 (\u03b2). We propose a modification of the BaGaBaB algorithm (Oliehoek et al., 2010), briefly discussed in Section 4.3.\nFig. 7 illustrates the process of incremental expansion in GMAA*-ICE, with \u03d5t indexed by letters. First, a CBG solver for the root node \u3008a, 7\u3009 is created, and the optimal solution \u03b2\u2217 is computed, with value 6. This results in a child \u3008b, 6\u3009, and the root is replaced by a placeholder node \u3008a, 6\u3009. As per Definition 5 (the node comparison operator), b appears before a in the\nopen list and hence is selected for expansion. Its best child \u3008c, 4\u3009 is added and \u3008b, 6\u3009 is replaced by placeholder \u3008b, 4\u3009. Now the search returns to the root node, and the second best solution \u03b2\u2032 is obtained from the CBG solver, leading to child \u3008d, 5.5\u3009. Placeholder nodes are retained as long as they have unexpanded children; only their values are updated.\nWhen using GMAA*-ICE, we can derive lower and upper bounds for the CBG solution, which can be exploited by the incremental CBG solver. The incremental CBG solver for B(\u03d5t) can be initialized with lower bound\nvCBG = vGMAA \u2212 V 0...(t\u22121)(\u03d5t), (4.1)\nwhere vGMAA is the value of the current best solution, and V 0...(t\u22121)(\u03d5t) is the true expected value of \u03d5t over the first t stages. Therefore, vCBG is the minimum value that a candidate must generate over the remaining h\u2212 t stages in order to beat the current best solution. Note that each time the incremental CBG solver is queried for a solution, vCBG is re-evaluated (using (4.1)), because vGMAA may have changed.\nWhen the used heuristic faitfully represents the immediate reward (i.e., is of the form (2.9)), then, for the last stage t = h\u2212 1, we can also specify an upper bound for the solution of the CBG\nv\u0304CBG = V\u0302 (\u03d5h\u22121)\u2212 V 0...(h\u22122)(\u03d5h\u22121). (4.2)\nIf this upper bound is attained, no further solutions will be required from the CBG solver. The upper bound holds since by (2.8)\nV\u0302 (\u03b2) , V\u0302 (\u03d5h)\u2212 V 0...(h\u22122)(\u03d5h\u22121)\n= V (\u03d5h)\u2212 V 0...(h\u22122)(\u03d5h\u22121)\n\u2264 V\u0302 (\u03d5h\u22121)\u2212 V 0...(h\u22122)(\u03d5h\u22121).\nIn the first step, V\u0302 (\u03d5h) = V (\u03d5h), because \u03d5h is a fully specified policy and the heuristic value given by (2.8) equals the actual value when a heuristic that faithfully represents the expected\nAlgorithm 10 Expand-ICE(q,H). The expand operator for GMAA*-ICE. Input: q = \u3008\u03d5t, v\u0302\u3009 the search node to expand. Input: H the admissible heuristic that is of the form Q\u0302(~\u03b8,a). Output: QExpand the set containing 0 or 1 expanded child nodes. 1: if IsPlaceholder(q) then 2: B(\u03d5t) \u2190 \u03d5t.CBG {reuse stored CBG} 3: else\n4: B(\u03d5t\u22121) \u2190 \u03d5t\u22121.CBG {retrieve previous CBG, note \u03d5t = (\u03d5t\u22121,\u03b2t\u22121)} 5: B(\u03d5t) \u2190 ConstructExtendedBG(B(\u03d5t\u22121),\u03b2t\u22121, Q\u0302) 6: B(\u03d5t) \u2190 ClusterBG(B(\u03d5t)) 7: B(\u03d5t).Solver \u2190 CreateSolver(B(\u03d5t)) 8: \u03d5t.CBG \u2190 B(\u03d5t) {store pointer to this CBG} 9: end if 10: vCBG = vGMAA \u2212 V 0...(t\u22121)(\u03d5t) {set lower bound for CBG solution} 11: if t = h\u2212 1 then 12: v\u0304CBG = V\u0302 (\u03d5h\u22121)\u2212 V 0...(h\u22122)(\u03d5h\u22121) {upper bound only used for last stage CBG} 13: else 14: v\u0304CBG = +\u221e 15: end if 16: \u3008\u03b2t, V\u0302 (\u03b2t)\u3009 \u2190 B(\u03d5t).Solver.NextSolution(vCBG,v\u0304CBG) {compute next CBG solution} 17: if \u03b2t then 18: \u03d5t+1 \u2190 (\u03d5t,\u03b2t) {create partial joint policy} 19: V\u0302 (\u03d5t+1) \u2190 V 0...t\u22121(\u03d5t) + V\u0302 (\u03b2t) {compute heuristic value} 20: q\u2032 \u2190 \u3008\u03d5t+1, V\u0302 (\u03d5t+1)\u3009 {create child node} 21: QExpand \u2190 {q\n\u2032} 22: else 23: QExpand \u2190 \u2205 {fully expanded: exists no solution s.t. V (\u03b2 h\u22121) \u2265 vCBG} 24: end if 25: return QExpand\nAlgorithm 11 PostProcessNode-ICE(q,L): Post processing of a node in GMAA*-ICE.\nInput: q the last expanded node, L the open list. Output: q is either removed or updated. 1: L.Pop(q) 2: if q is fully expanded or depth(q) = h\u2212 1 then 3: Cleanup q {delete the node and the associated CBG and Solver} 4: return\n5: else 6: c \u2190 last expanded child of q 7: q.v\u0302 \u2190 c.v\u0302 {update heuristic value of parent node} 8: IsPlaceholder(q) \u2190 true {remember that q is a placeholder} 9: L.Insert(q) {reinsert at appropriate position}\n10: end if\nimmediate reward is used. This implies that V\u0302 (\u03b2) itself is a lower bound. In the second step V (\u03d5h) \u2264 V\u0302 (\u03d5h\u22121), because V\u0302 (\u03d5h\u22121) is admissible. Therefore, we can stop expanding when we find a \u03b2 with (lower bound) heuristic value equal to the upper bound v\u0304CBG. This applies only to the last stage because only then the first step is valid.\nGMAA*-ICE can be implemented by replacing the Expand and the PostProcessNode procedures of Algorithms 8 and 4 by Algorithms 10 and 11, respectively. Expand-ICE first determines if a placeholder is being used and either reuses the previously constructed incremental CBG solver or constructs a new one. Then, new bounds are calculated and the next CBG solution is obtained. Subsequently, only a single child node is generated (rather than expanding all children as in Algorithm 13). PostProcessNode-ICE removes the last node that was returned by Select only when all its children have been expanded. Otherwise, it updates that node\u2019s heuristic value and reinserts it in the open list. See Appendix A.2 for GMAA*-ICE shown as a single algorithm."}, {"heading": "4.2 Theoretical Guarantees", "text": "In this section, we prove thatGMAA*-IC andGMAA*-ICE are search-equivalent. As a direct result we establish that GMAA*-ICE is complete, which means that integrating incremental expansion preserves the optimality guarantees of GMAA*-IC.\nDefinition 10. We call two GMAA* variants search-equivalent if they select exactly the same sequence of non-placeholder nodes corresponding to past joint policies to expand in the search tree using the Select operator.\nFor GMAA*-IC and GMAA*-ICE we show that the set of selected nodes are the same. However, the set of expanded nodes can be different; in fact, it is precisely these differences that incremental expansion exploits.\nTheorem 5. GMAA*-ICE and GMAA*-IC are search-equivalent.\nProof. Proof is listed in Section A.4 of the appendix.\nNote that Theorem 5 does not imply that the computational and space requirements of GMAA*-ICE and GMAA*-IC are identical. On the contrary, for each expansion, GMAA*-ICE generates only one child node to be stored on the open list. In contrast, GMAA*-IC generates a number of child nodes that is, in the worst case, doubly exponential in the depth of the selected node.16 However, GMAA*-ICE is not guaranteed to be more efficient than GMAA*-IC. For example, in the case where all child nodes still have to be generated, GMAA*-ICE will be slower due to the overhead it incurs.\nCorollary 3. When using a heuristic of the form (2.9) GMAA*-ICE is complete.\nProof. Under the stated conditions, GMAA*-IC is complete (see Theorem 4). Since GMAA*-ICE is search equivalent to GMAA*-IC, it is also complete.\n16. When a problem allows clustering, the number of child nodes grows less dramatically (see Section 3)."}, {"heading": "4.3 Incremental CBG Solvers", "text": "Implementing GMAA*-ICE requires a CBG solver that can incrementally deliver all \u03b2 in descending order of V\u0302 (\u03b2). To this end, we propose to modify the Bayesian game Branch and Bound (BaGaBaB) algorithm (Oliehoek et al., 2010). BaGaBaB performs an A*-search over (partially specified) CBG policies. Thus, when applied within GMAA*-ICE, it performs a second, nested A* search. To expand each node in the GMAA* search tree, a nested A* search computes the next CBG solution.17 This section briefly summarizes the main ideas behind BaGaBaB (for more information, see Oliehoek et al., 2010) and our modifications.\nBaGaBaB works by creating a search tree in which the nodes correspond to partially specified joint CBG policies. In particular, it represents a \u03b2 as a joint action vector, a vector \u3008\u03b2(\u03b81), . . . ,\u03b2(\u03b8|\u0398|)\u3009 of the joint actions that \u03b2 specifies for each joint type. Each node g in the BaGaBaB search tree represents a partially specified vector and thus a partially specified joint CBG policy. For example, a completely unspecified vector \u3008\u00b7, \u00b7 , . . . ,\u00b7\u3009 corresponds to the root node, while an internal node g at depth d (root being at depth 0) specifies joint actions for the first d joint types g = \u2329 \u03b2(\u03b81), . . . ,\u03b2(\u03b8d), \u00b7 , \u00b7 , . . . ,\u00b7 \u232a . The value of a node V (g) is the value of the best joint CBG-policy consistent with it. Since this value is not known in advance, BaGaBaB performs an A* search guided by an optimistic heuristic.\nIn particular, we can compute an upper bound on the value achievable for any such partially specified vector by computing the maximum value of the complete information joint policy that is consistent with it (i.e., a non-admissible joint policy that selects the maximizing joint actions for the remaining joint types). Since this value is a guaranteed upper bound on the maximum value achievable by a consistent joint CBG policy, it is an admissible heuristic.\nWe propose a modification to BaGaBaB to allow solutions to be incrementally delivered. The main idea is to retain the search tree after a first call of BaGaBaB on a particular CBG B(\u03d5t) and update it during subsequent calls, thereby saving computational effort.\nStandard A* search terminates when a single optimal solution has been found. This behavior is the same when incremental BaGaBaB is called for the first time on a B(\u03d5t). However, during standard A*, nodes whose upper bound is lower than the best known lower bound can be safely deleted, as they will never lead to an optimal solution. In contrast, in an incremental setting such nodes cannot be pruned, as they could possibly result in the k-th best solution and therefore might need to be expanded during subsequent calls to BaGaBaB. Only nodes returned as solutions are pruned in order to avoid returning the same solution twice. This modification requires more memory but does not affect the A* search process otherwise.\nWhen asked it for the k-th solution, BaGaBaB resets its internal lower bound to the value of the next-best solution that was previously found but not returned (or to vCBG as defined in (4.1) if no such solution was found). Then it starts an A* search initialized using the search tree resulting from the (k\u2212 1)-th solution. In essence, this method is similar to searching for the best k solutions, where k can be incremented on demand. Recently it was shown that, for fixed k, such a modification preserves all the theoretical guarantees (soundness, completeness,\n17. While GMAA*-ICE could also use any other incremental CGB solver, there are few that avoid enumerating all \u03b2 before providing the first result and thus have the potential to work incrementally. An exception may be the method of Kumar and Zilberstein (2010b), which employs AND/OR branch and bound search with the EDAC heuristic (and is thus limited to the two-agent case). As a heuristic search method, it may be amenable to an incremental implementation though to our knowledge this has not been attempted.\noptimal efficiency) of the A* algorithm (Dechter, Flerova, & Marinescu, 2012), but the results trivially transfer to the setting where k is allowed to increase."}, {"heading": "5. Experiments", "text": "In this section, we empirically test and validate all the proposed techniques: lossless clustering of joint histories, incremental expansion of search nodes, and hybrid heuristic representations. After introducing the experimental setup, we compare the performance of GMAA*-IC and GMAA*-ICE to that of GMAA* on a suite of benchmark problems from the literature. Next, we compare the performance of the proposed methods with state-of-the-art optimal and approximate Dec-POMDP methods, followed by a case study of the scaling behavior with respect to the number of agents. Finally, we compare memory requirements of the hybrid heuristic representation to those of the tree and vector representations."}, {"heading": "5.1 Experimental Setup", "text": "The most well-known Dec-POMDP benchmarks are the Dec-Tiger (Nair et al., 2003) and BroadcastChannel (Hansen et al., 2004) problems. Dec-Tiger was discussed extensively in Section 2. In BroadcastChannel, two agents have to transmit messages over a communication channel, but when both agents transmit at the same time a collision occurs that is noisily observed by the agents. The FireFighting problem models a team of n firefighters that have to extinguish fires in a row of nh houses (Oliehoek, Spaan, & Vlassis, 2008). Each agent can choose to move to any of the houses to fight fires at that location; if two agents are in the same house, they will completely extinguish any fire there. The (negative) reward of the team of firefighters depends on the intensity of the fire at each house; when all fires have been extinguished, reward of zero is received. In the Hotel 1 problem (Spaan & Melo, 2008), travel agents need to assign customers to hotels with limited capacity. They can also send a customer to a resort but this yields lower reward. In addition, we also use the following problems: Recycling Robots (Amato, Bernstein, & Zilberstein, 2007), a scaled-down version of the problem described in Section 2; GridSmall with two observations (Amato, Bernstein, & Zilberstein, 2006) and Cooperative Box Pushing (Seuken & Zilberstein, 2007a), a larger two-robot benchmark. Table 1 summarizes these problems numerically, listing the number of joint policies for different planning horizons.\nExperiments were run on an Intel Core i5 CPU running Linux, andGMAA*, GMAA*-IC, and GMAA*-ICE were implemented in the same code-base using the MADP Toolbox (C++) (Spaan & Oliehoek, 2008). The vector-based QBG representation is computed using a variation of Incremental Pruning (adapted for computing Q-functions instead of regular value functions), corresponding to the NaiveIP method as described by Oliehoek and Spaan (2012). To implement the pruning, we employ Cassandra\u2019s POMDP-solve software (A. R. Cassandra, 1998).\nFor the results in Sections 5.2 and 5.3, we limited each process to 2Gb RAM and a maximum CPU time of 3,600s. Reported CPU times are averaged over 10 independent runs and have a resolution of 0.01s. Timings are given only for the MAA* search processes, since\ncomputation of the heuristic is the same for both methods and can be amortized over multiple runs.18 All problem definitions are available via http://masplan.org."}, {"heading": "5.2 Comparing GMAA*, GMAA*-IC, and GMAA*-ICE", "text": "We compared GMAA*, GMAA*-IC, and GMAA*-ICE using the hybrid QBG representation. While all methods compute an optimal policy, we expectGMAA*-IC to be more efficient than GMAA* when lossless clustering is possible. Furthermore, we expect GMAA*-ICE to provide further improvements in terms of speedup and scaling to longer planning horizons.\nThe results are shown in Table 2. For all entries where we report results, the QBG heuristics could be computed, thanks to the hybrid representation. Consequently, the performance of GMAA*-IC is much better than all previously reported results, including those of Oliehoek et al. (2009), who were often required to resort to QMDP for larger problems and/or horizons. The entries marked by \u2018\u00a7\u2019 show the limits when using QMDP instead of QBG: in most of these problems we can reach longer horizons with QBG. Only for FireFighting can GMAA*-ICE with QMDP compute solutions for higher h than is possible with QBG (hence the missing \u201c\u00a7\u201d, and showing that GMAA*-ICE is more efficient using a loose heuristic than GMAA*-IC). Furthermore, the \u201c\u2020\u201d entries indicate that the horizon to which we can solve a problem with a tree-based QBG representation is often much shorter.\nThese results clearly illustrate that GMAA*-IC leads to a significant improvement in performance. In all problems, GMAA*-IC was able to produce a solution more quickly and to increase the largest solvable horizon over GMAA*. In some cases, GMAA*-IC is able to drastically increase the solvable horizon.\nFurthermore, the results clearly demonstrate that incremental expansion allows for significant additional improvements. In fact, the table demonstrates that GMAA*-ICE significantly outperforms GMAA*-IC, especially in problems where little clustering is possible.\nThe results in Table 2 also illustrate the efficacy of a hybrid representation. For problems like GridSmall, Cooperative Box Pushing, FireFighting and Hotel 1 neither the tree nor vector representation is able to provide a compact QBG heuristic for the longer hori-\n18. The heuristics\u2019 computation time ranges from less than a second to hours (for high h in some difficult problems). Table 4 presents some heuristic computation time results.\nzons. Apart from Dec-Tiger and FireFighting, computing and storing QBG (or another tight heuristic) for longer horizons is the bottleneck to further scalability.\nTogether, these algorithmic improvements lead to the first optimal solutions for many problem horizons. In fact, for the vast majority of problems tested, we provide results for longer horizons than any previous work (the bold entries). These improvements are quite sub-\nstantial, especially given that lengthening the horizon by one increases the problem difficulty exponentially (cf. Table 1)."}, {"heading": "5.2.1 Analysis of Clustering Histories", "text": "Table 3 provides additional details about the performance of GMAA*-IC, by listing the number of joint types in the GMAA*-IC search, |cBGt|, for each stage t. These are averages since the algorithm forms CBGs for different past policies, leading to clusterings of different sizes.19 To see the impact of clustering, the table also lists |BGh\u22121|, the number of joint types in the CBGs constructed for the last stage without clustering, which is constant.\nIn Dec-Tiger, the time needed by GMAA*-IC is more than 3 orders of magnitude less than that of GMAA* for horizon h = 4. For h = 5, this test problem has 3.82e29 joint policies, and no other method has been able to optimally solve it. GMAA*-IC, however, is able to do so in reasonable time. In Dec-Tiger, there are clear symmetries between the\n19. Note that in some problem domains we report smaller clusterings than Oliehoek et al. (2009). Due to an implementation mistake, their clustering was overly conservative, and did not in all cases treat two histories as probabilistically equivalent, when in fact they were.\nobservations that allow for clustering, as demonstrated by Fig. 4. Another key property is that opening the door resets the problem, which may also facilitate clustering.\nIn FireFighting, for short planning horizons no lossless clustering is possible at any stage, and as such, the clustering incurs some overhead. However, GMAA*-IC is still faster than GMAA* because constructing the BGs using bootstrapping from the previous CBG takes less time than constructing a CBG from scratch. Interesting counterintuitive results occur for h = 6, which was solved within memory limits, in contrast to h = 5. In fact, using QMDP we could compute optimal values V\n\u2217 for h > 6, and it turns out that these are equal to that for h = 6. The reason is that the optimal joint policy is guaranteed to extinguish all fires in 6 stages. For subsequent stages, all the rewards will be 0. While this itself does not influence clustering, the further analysis of Table 3 reveals that the CBG instances encountered during the h = 6 search happen to cluster much better than those in h = 5, which is possible because the heuristics vary with the horizon. In fact, \u03c0\u2217 for h = 6 sends both agents to the middle house at t = 0, while for h = 5, agents are dispatched to different houses. When both agents fight fires at the same house, the fire is extinguished completely, and resulting joint observations do not provide any new information. As a result, different joint types lead to the same joint belief, which means they can be clustered. If agents visit different houses, their observations do convey information, leading to different possible joint beliefs (which cannot be clustered).\nHotel 1 allows for a large amount of clustering, and GMAA*-IC outperforms GMAA* by a large margin, with the former reaching h = 9 and the latter h = 2. This problem is transition and observation independent (Becker, Zilberstein, Lesser, & Goldman, 2003; Nair, Varakantham, Tambe, & Yokoo, 2005; Varakantham, Marecki, Yabu, Tambe, & Yokoo, 2007), which facilitates clustering, as we further discuss in Section 5.5. Unlike methods specifically designed to exploit transition and observation independence, GMAA*-IC exploits this structure without requiring a predefined explicit representation of it. Further scalability is limited by the computation of the heuristic.\nFor BroadcastChannel, GMAA*-IC achieves an even more dramatic increase in performance, allowing the solution of up to horizon h = 900. Analysis reveals that the CBGs constructed for all stages are fully clustered: they contain only one type for each agent. The reason is as follows. When constructing a CBG for t = 1, there is only one joint type for the previous CBG so, given \u03b20, the solution for the previous CBG, there is no uncertainty with respect to the previous joint action a0. The crucial property of BroadcastChannel is that the (joint) observation reveals nothing about the new state, but only about what joint action was taken (e.g., \u2018collision\u2019 if both agents chose to \u2018send\u2019). As a result, the different individual histories can be clustered. In a CBG constructed for stage t = 2, there is again only one joint type in the previous game. Therefore, given the past policy, the actions of the other agents can be perfectly predicted. Again the observation conveys no information so this process repeats. Thus, the problem has a special property which could be described as non-observable given the past joint policy. GMAA*-IC automatically exploits this property. Consequently, the time needed to solve each CBG does not grow with the horizon. The solution time, however, still increases super-linearly because of the increased amount of backtracking. As in FireFighting, performance is not monotonic in the planning horizon. In this case however, clustering is clearly not responsible for the difference. Rather, the only explanation is that for certain horizons, there are many near-optimal joint policies, leading to more backtracking and a higher search cost."}, {"heading": "5.2.2 Analysis of Incremental Expansion", "text": "In Dec-Tiger for h = 5, GMAA*-ICE achieves a speedup of three orders of magnitude and can compute a solution for h = 6, unlike GMAA*-IC. For GridSmall, it achieves a large speedup for h = 4 and fast solutions for h = 5 and 6, where GMAA*-IC runs out of memory. Similar positive results are obtained for FireFighting, Cooperative Box Pushing and Recycling Robots. In fact, when using QMDP, GMAA*-ICE is able to compute solutions well beyond h = 1000 for the FireFighting problem, which stands in stark contrast to GMAA*-IC that only computes solutions to h = 3 with this heuristic. Note that BroadcastChannel is the only problem for which GMAA*-IC is (slightly) faster than GMAA*-ICE. Because this problem exhibits clustering to a single joint type, the overhead of incremental expansion does not pay off.\nTo further analyze incremental expansion, we examined its impact on the number of nodes expanded for intermediate stages t = 0, . . . ,h\u22122. Fig. 8 shows the number of nodes expanded in GMAA*-ICE and the number that would be expanded for GMAA*-IC (which can be easily computed since they are search-tree equivalent). There is a clear relationship between the results from Fig. 8 and Table 2, illustrating, e.g., why GMAA*-IC runs out of memory on GridSmall h = 6. The plots confirm our hypothesis that, in practice, only a small number of child nodes are queried."}, {"heading": "5.2.3 Analysis of Hybrid Heuristic Representation", "text": "Fig. 9 illustrates the memory requirements in terms of number of parameters (i.e., real numbers) for the tree, vector, and hybrid representations for QBG, where the latter is computed following Algorithm 9. Results for the vector representation are omitted when those representations grew beyond limits. The effectiveness of the vector pruning depends on the problem and the complexity of the value function, which can increase suddenly, as for instance happens in Fig. 9c. These results show that, for several benchmark Dec-POMDPs, the hybrid representation allows for significant savings in memory, allowing the computation of tight heuristics for longer horizons."}, {"heading": "5.3 Comparing to Other Methods", "text": "In this section, we compare GMAA*-IC and GMAA*-ICE to other methods from the literature. We begin by comparing the runtimes of our methods against the following state-ofthe-art optimal Dec-POMDP methods: MILP20 (Aras & Dutech, 2010) converts the DecPOMDP to a mixed integer linear program, for which numerous solvers are available. We have used MOSEK version 6.0. DP-LPC21 (Boularias & Chaib-draa, 2008) performs dynamic programming with lossless policy compression, with CPLEX 12.4 as the LP solver. DP-IPG (Amato et al., 2009) performs exact dynamic programing with incremental policy\n20. The results reported here deviate from those reported by Aras and Dutech (2010). For a number of problems, Aras et al. employed a solution method that solves the MILP as a series (a tree) of smaller MILPs by branching on the continuous realization weight variables for earlier stages. That is, for each past joint policy \u03d5t for some stage t, they solve a different MILP involving the subset of consistent sequences. Additionally, for FireFighting and GridSmall, we use the benchmark versions standard to the literature (Oliehoek, Spaan, & Vlassis, 2008; Amato et al., 2006), whereas Aras and Dutech (2010) use non-standard versions. This explains the difference between our results and the ones reported in their article (personal communication, Raghav Aras). 21. The goal of Boularias and Chaib-draa (2008) was to find non-dominated joint policies for all initial beliefs. The previously reported results concerned run-time to compute the non-dominated joint policies, without performing pruning on the full-length joint policies. In contrast, we report the time needed to compute the actual optimal Dec-POMDP policy (given b0). This additionally requires the final round of pruning and subsequently computing the value for each of the remaining joint policies for the initial belief. This additional overhead explains the differences in run time between what we report here and what was previously reported (personal communication, Abdeslam Boularias).\ngeneration that exploits known start state and knowledge about what states are reachable in doing the DP backup.\nTable 4, which shows the results of the comparison, demonstrates that, in almost all cases, the total time of GMAA*-ICE (given by the sum of heuristic computation time and the time for the GMAA*-phase) is significantly less than that of any other state-of-the-art methods. Moreover, as demonstrated in Table 2, GMAA*-ICE can compute solutions for longer horizons for all these problems, except for Cooperative Box Pushing and Hotel 1.22 For these problems, it is not possible to compute QBG for longer horizons. Overcoming this problem could enable GMAA*-ICE to scale to further horizons as well.\nThe DP-LPC algorithm proposed by Boularias and Chaib-draa (2008) also improves the efficiency of optimal solutions by a form of compression. The performance of their algorithm, however, is weaker than that of GMAA*-IC. There are two main explanations for the performance difference. First, DP-LPC uses compression to more compactly represent the values for sets of useful sub-tree policies, by using sequence form representation. The policies themselves, however, are not compressed: they still specify actions for every possible observation history (for each policy it needs to select an exponential amount of sequences that make up that policy). Hence, it cannot compute solutions for long horizons. Second, GMAA*-IC can exploit knowledge of the initial state distribution b0.\nOverall, GMAA*-ICE substantially improves the state-of-the-art in optimally solving Dec-POMDPs. Previous methods typically improved the feasible solution horizon by just one (or only provided speed-ups for horizons that could already be solved). By contrast, GMAA*-ICE dramatically extends the feasible solution horizon for many problems.\nWe also consider MBDP-based approaches, the leading family of approximate algorithms. Table 5, which reports the VMBDP values produced by PBIP-IPG (Amato et al., 2009) (with typical \u2018maxTrees\u2019 parameter settingm), demonstrates that the optimal solutions produced by GMAA*-IC or GMAA*-ICE are of higher quality. PBIP-IPG was chosen because all other MBDP algorithms with the same parameters achieve at most the same value. While not exhaustive, this comparison illustrates that even the best approximate Dec-POMDP methods in practice provide inferior joint policies on some problems. Conducting such analysis is possible only if optimal solutions can be computed. Clearly, the more data that becomes available, the more thorough the comparisons that can be made. Therefore, scalable optimal solution methods such as GMAA*-ICE are critical for improving these analyses."}, {"heading": "5.4 Scaling to More Agents", "text": "All of the benchmark problems in our results presented so far were limited to two agents. Here, we present a case study on FireFightingGraph (Oliehoek, Spaan, Whiteson, & Vlassis, 2008), a variation of FireFighting allowing for more agents, in which each agent can only fight fires at two houses, instead of at all of them. Table 6 highlights the size of these problems, including the total number of joint policies for different horizons. We compared GMAA*, GMAA*-IC, GMAA*-ICE (all using a QMDP heuristic), BruteForceSearch, and DP-IPG, with a maximum run-time of 12 hours and running on an Intel Core i7 CPU, averaged over 10 runs. BruteForceSearch is a simple optimal algorithm that enumerates and evaluates all joint policies, and was implemented in the same codebase as the GMAA* variations. DP-IPG results use the original implementation and were run on an Intel Xeon computer. Hence, while the timing results are not directly comparable, the overall trends are apparent. Also, since the DP-IPG implementation is limited to 2 agents, no results are shown for more agents.\nFig. 10 shows the computation times for FireFightingGraph across different numbers of of agents and planning horizons, while Table 7 lists the optimal values obtained. As expected, the baseline BruteForceSearch performs very poorly, only scaling beyond h = 2 for 2 agents, while DP-IPG can only reach h = 4. On the other hand, regular GMAA* performs relatively well, scaling to a maximum of 5 agents. However, GMAA*-IC and GMAA*-ICE improve the efficiency of GMAA* by 1\u20132 orders of magnitude. As such, they substantially outperform the other three methods, and scale up to 6 agents. The benefit of incremental expansion is clear for n = 3,4, whereGMAA*-ICE can reach a higher horizon thanGMAA*-IC. Hence, although this article focuses on scalability in the horizon, these results show that the methods we propose can also improve scalability in the number of agents."}, {"heading": "5.5 Discussion", "text": "Overall, the empirical results demonstrate that incremental clustering and expansion offers dramatic performance gains on a diverse set of problems. In addition, the results on Broad-\n22. In Hotel 1, DP-IPG performs particularly well because the problem structure has limited reachability. That is, each agent can fully observe its local state (but not that of the other agent) and in all local states except one there is one action that dominates all others. As a result, DP-IPG can generate a small number of possibly optimal policies.\ncastChannel illustrate a key advantage of our approach: when a problem possesses a property that makes a large amount of clustering possible, our clustering method exploits this property automatically, without requiring a predefined explicit representation of it.\nOf course, not all problems admit great reductions via clustering. One domain property that allows for clustering is when the past joint policy encountered during GMAA* makes the observations superfluous, as with BroadcastChannel and FireFighting. In Dec-Tiger, we see that certain symmetries can lead to clustering. However clustering can occur even without these properties. In fact, for all problems and nearly all horizons that we tested, the size of the CBGs can be reduced. Moreover, in accordance with the analysis of Section 3.2, the improvements in planning efficiency are huge, even for modest reductions in CBG size.\nOne class of problems where we can say something a priori about the amount of clustering that is possible is the class of Dec-POMDPs with transition and observation independence (Becker et al., 2003). In such problems, the agents have local states and the transitions are independent, which for two agents can be expressed as\nPr(s\u20321, s \u2032 2|s1, s2, a1, a2) = Pr(s \u2032 1|s1, a1) Pr(s \u2032 2|s2, a2). (5.1)\nSimilarly, the observations are assumed to be independent, which means that for each agent the observation probability depends only on its own action and local state: Pr(oi|ai, s \u2032 i). For such problems, the probabilistic equivalence criterion (3.1) factors too. In particular, due to transition and observation independence23, (3.2) holds true for any ~\u03b8 ai , ~\u03b8 bi . Moreover, (3.3) factors as the product Pr(s1, s2|~\u03b81, ~\u03b82) = Pr(s1|~\u03b81) Pr(s2|~\u03b82) and thus holds if Pr(s1|~\u03b8 a 1 ) = Pr(s1|~\u03b8 b 1 ). That is, two histories can be clustered if they induce the same \u2018local belief\u2019. As such, the size of the CBGs directly corresponds to the product of the number of reachable local beliefs. Since the transition and observation independent Hotel 1 problem is also locally fully observable, and the local state spaces consist of four states, there are only four possible local beliefs (which is consistent with the CBG size of 16 from Table 3). Moreover, we see that this maximum size is typically only reached at the end of search. This is because good policies defer sending customers to the hotel and thus do not visit local states where the hotel is filled in the earlier stages.\nIn more general classes of problems, even other weakly coupled models (e.g., Becker, Zilberstein, & Lesser, 2004; Witwicki & Durfee, 2010), the criterion (3.1) does not factor, and hence there is no direct correspondence to the number of local beliefs. As such, only by applying our clustering algorithm can we determine how well such a problem clusters. This is analogous to, e.g., state aggregation in MDPs (e.g., discussed in Givan, Dean, & Greig, 2003) where it is not known how to predict a priori how large a minimized model will be. Fortunately, our empirical results demonstrate that, in domains that admit little or no clustering, the overhead is small.\nAs expected, incremental expansion is most helpful for problems which do not allow for much clustering. However, the results for, e.g., Dec-Tiger illustrate that there is a limit to the amount of scaling that the method can currently provide. The bottleneck is the solution of the large CBGs for the later stages: the CBG solver has to solve these large CBGs when returning the first solution in order to guarantee optimality, but this takes takes a long time. We expect that further improvements to CBG solvers can directly add to the efficacy of incremental expansion.\nOur experiments also clearly demonstrate that the Dec-POMDP complexity results, while important, are only worst-case results. In fact, the scalability demonstrated in our experiments clearly show that in many problems we successfully scale dramatically beyond what would be\n23. This assumes no \u2018external\u2019 state variable s0.\nexpected for a doubly-exponential dependence on the horizon. Even for the smallest problems, a doubly-exponential scaling in the horizon implies that it is impossible to compute solutions beyond h = 4 at all, as indicated by the following simple calculation: let n = 2, |Ai| = 2 actions, |Oi| = 2| observations, then\n|Ai| (n\u2217(|Oi| 5))/|Ai| (n\u2217(|Oi| 4)) = 4.2950e9.\nThus, even in the simplest possible case, we see an increase of a factor 4.2950e09 from h = 4 to h = 5. Similarly, the next increment, from h = 5 to h = 6, increases the size of the search space by a factor 1.8447e19. However, our experiments clearly indicate that in almost all cases, things are not so dire. That is, even though matters look bleak in the light of the complexity results, we are in many cases able to perform substantially better than this worst case."}, {"heading": "6. Related Work", "text": "In this section, we discuss a number of methods that are related to those proposed in this article. Some of these methods have already been discussed in earlier sections. In Section 3, we indicated that our clustering method is closely related to the approach of Emery-Montemerlo et al. (2005) but is also fundamentally different because our method is lossless. In Section 5.3, we discussed connections to the approach of Boularias and Chaib-draa (2008) which clusters policy values. This contrasts with our approach which clusters the histories and thus the policies themselves, leading to greater scalability.\nIn Section 3.1.2, we discussed the relationship between our notion of probabilistic equivalence (PE) and the multiagent belief. However, there is yet another notion of belief, employed in the JESP solution method (Nair et al., 2003), that is superficially more similar to the PE distribution. A \u2018JESP belief\u2019 for an AOH ~\u03b8i is a probability distribution Pr(s,~o 6=i| ~\u03b8i, b 0,\u03c0 6=i) over states and observation histories of other agents given a (deterministic) full policy of all the other agents. It is a sufficient statistic, since it induces a multiagent belief, thus it also allows for the clustering of histories. The crucial difference with, and the utility of, PE lies in the fact that the PE criterion is specified over states and AOHs given only a past joint policy. That is, (3.1) does not induce a multiagent belief.\nOur clustering approach also resembles a number of methods that employ other equivalence notions. First, several approaches exploit the notion of behavioral equivalence (Pynadath & Marsella, 2007; Zeng et al., 2011; Zeng & Doshi, 2012). They consider, from the perspective of a protagonist agent i, the possible models of another agent j. Since j affects i only through its actions, i.e., its behavior, agent i can cluster together all the models of agent j that lead to the same policy \u03c0j for that agent. That is, it can cluster all models of agent j that are behaviorally equivalent. In contrast, we do not cluster models of other agents j, but histories of this agent i if all the other agents, as well as the environment, are guaranteed to behave the same in expectation, thus leading to the same best response of agent i. That is, our method could be seen as clustering histories that are \u2018expected environmental behavior equivalent\u2019.\nThe notion of utility equivalence (Pynadath & Marsella, 2007; Zeng et al., 2011) is closer to PE because it also takes into account the (value of the) best-response of agent i (in particular, it clusters two models mj and m \u2032 j if using BR(mj)\u2014the best response against mj\u2014 achieves the same value against m\u2032j). However, it remains a form of behavior equivalence in that it clusters models of other agents, not histories of the protagonist agent.\nThere are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al., 2003) is a compact representation of the other agents\u2019 policies. Models of the other agents can be clustered if they lead to the same influence on agent i. However, though more fine-grained, this is ultimately still a form of behavioral equivalence.\nA final relation to our equivalence notion is the work by Dekel, Fudenberg, and Morris (2006), which constructs a distance measure and topology on the space of types with the goal of approximating the infinite universal type space (the space of all possible beliefs about beliefs about beliefs, etc.) for one-shot Bayesian games. Our setting, however, considers a simple finite type space where the types directly correspond to the private histories (in the form of AOHs) in a sequential problem. Thus, we do not need to approximate the universal type space; instead we want to know which histories lead to the same future dynamics from the perspective of an agent. Dekel et al.\u2019s topology does not address this question.\nOur incremental expansion technique is related to approaches extending A\u2217 to deal with large branching factors in the context of multiple sequence alignment (Ikeda & Imai, 1999; Yoshizumi, Miura, & Ishida, 2000). However, our approach is different because we do not discard unpromising nodes but rather provide a mechanism to generate only the necessary ones. Also, when proposing MAA*, Szer et al. (2005) developed a superficially similar approach that could be applied only to the last stage. In particular, they proposed generating the child nodes one by one, each time checking if a child is found with value equal to its parent\u2019s heuristic value. Since the value of such a child specifies a full policy, its value is a lower bound and therefore expansion of any remaining child nodes can be skipped. Unfortunately, a number of issues prevent this approach from providing substantial leverage in practice. First, it cannot be applied to intermediate stages 0 \u2264 t < h\u22121 since no lower bound values for the expanded children are available. Second, in many problems it is unlikely that such a child node exists. Third, even if it does, Szer et al. did not specify an efficient way of finding it. Incremental expansion overcomes all of these issues, yielding an approach that, as our experiments demonstrate, significantly increases the size of the Dec-POMDPs that can be solved optimally.\nThis article focuses on optimal solutions for Dec-POMDPs over a finite horizon. As part of our evaluation, we compare against the MILP approach (Aras & Dutech, 2010), DPILP (Boularias & Chaib-draa, 2008) and DP-IPG (Amato et al., 2009), an extension of the exact dynamic programming algorithm (Hansen et al., 2004). Research on finite-horizon DecPOMDPs has considered many other approaches such as bounded approximations (Amato, Carlin, & Zilberstein, 2007), locally optimal solutions (Nair et al., 2003; Varakantham, Nair, Tambe, & Yokoo, 2006) and approximate methods without guarantees (Seuken & Zilberstein, 2007b, 2007a; Carlin & Zilberstein, 2008; Eker & Ak\u0131n, 2010; Oliehoek, Kooi, & Vlassis, 2008; Dibangoye et al., 2009; Kumar & Zilberstein, 2010b; Wu et al., 2010a; Wu, Zilberstein, & Chen, 2010b).\nIn particular, much research has considered the optimal and/or approximate solution of subclasses of Dec-POMDPs. One such subclass contains only Dec-POMDPs in which the agents have local states that other agents cannot influence. The resulting models, such as the TOI-Dec-MDP (Becker et al., 2003; Dibangoye, Amato, Doniec, & Charpillet, 2013) and NDPOMDP (Nair et al., 2005; Varakantham et al., 2007; Marecki, Gupta, Varakantham, Tambe, & Yokoo, 2008; Kumar & Zilberstein, 2009), can be interpreted as independent (PO)MDPs for\neach agent that are coupled through the reward function (and possibly an unaffectable state feature). On the other hand, event-driven interaction models (Becker et al., 2004) consider agents that have individual rewards but can influence each other\u2019s transitions.\nMore recently, models that allow for limited transition and reward dependence have been introduced. Examples are interaction-driven Markov games (Spaan & Melo, 2008), DecMDPs with sparse interactions (Melo & Veloso, 2011), distributed POMDPs with coordination locales (Varakantham et al., 2009; Velagapudi et al., 2011), event-driven interactions with complex rewards (EDI-CR) (Mostafa & Lesser, 2011), and transition decoupled Dec-POMDPs (Witwicki & Durfee, 2010; Witwicki, 2011). While the methods developed for these models often exhibit better scaling behavior than methods for standard Dec-(PO)MDPs, they typically are not suitable when agents have extended interactions, e.g., to collaborate in transporting an item. Also, there have been specialized models that consider the timing of actions whose ordering is already determined (Marecki & Tambe, 2007; Beynier & Mouaddib, 2011).\nAnother body of work addresses infinite-horizon problems (Amato, Bernstein, & Zilberstein, 2010; Amato, Bonet, & Zilberstein, 2010; Bernstein, Amato, Hansen, & Zilberstein, 2009; Kumar & Zilberstein, 2010a; Pajarinen & Peltonen, 2011), in which it is not possible to represent a policy as a tree. These approaches represent policies using finite-state controllers that are then optimized in various ways. Also, since the infinite-horizon case is undecidable (Bernstein et al., 2002), the approaches are approximate or optimal given a particular controller size. While there exists a boundedly optimal approach that can theoretically construct a controller within any \u01eb of optimal, it is only feasible for very small problems or a large \u01eb (Bernstein et al., 2009).\nThere has also been great interest in Dec-POMDPs that explicitly take into account communication. Some approaches try to optimize the meaning of communication actions without semantics (Xuan, Lesser, & Zilberstein, 2001; Goldman & Zilberstein, 2003; Spaan, Gordon, & Vlassis, 2006; Goldman, Allen, & Zilberstein, 2007) while others use fixed semantics (e.g., broadcasting the local observations) (Ooi & Wornell, 1996; Pynadath & Tambe, 2002; Nair et al., 2004; Roth et al., 2005; Oliehoek, Spaan, & Vlassis, 2007; Roth, Simmons, & Veloso, 2007; Spaan, Oliehoek, & Vlassis, 2008; Goldman & Zilberstein, 2008; Becker, Carlin, Lesser, & Zilberstein, 2009; Williamson, Gerding, & Jennings, 2009; Wu et al., 2011). Since models used in the first category (e.g., the Dec-POMDP-Com) can be converted to normal Dec-POMDPs (Seuken & Zilberstein, 2008), the contributions of this article are applicable to those settings.\nFinally, there are numerous models closely related to Dec-POMDPs, such as POSGs (Hansen et al., 2004), interactive POMDPs (I-POMDPs) (Gmytrasiewicz & Doshi, 2005), and their graphical counterparts (Doshi, Zeng, & Chen, 2008). These models are more general in the sense that they consider self-interested settings where each agent has an individual reward function. I-POMDPs are conjectured to also require doubly exponential time (Seuken & Zilberstein, 2008). However, for the I-POMDP there have been a number of recent advances (Doshi & Gmytrasiewicz, 2009). The current paper makes a clear link between best-response equivalence of histories and the notion of best-response equivalence of beliefs in I-POMDPs. In particular, this article demonstrates that two PE action-observation histories (AOHs) induce, given only a past joint policy, a distribution over states and AOHs of other agents, and therefore will induce the same multiagent belief for any future policies of other agents. These induced multiagent beliefs, in turn, can be interpreted as special cases of I-POMDP beliefs where the model of the other agents are sub-intentional models in the form of a fixed policy tree. Rabinovich and Rosenschein (2005) introduced a method that, rather than optimizing\nthe expected value of a joint policy, selects coordinated actions under uncertainty by tracking the dynamics of an environment. This approach, however, requires a model of the ideal system dynamics as input and in many problems, such as those considered in this article, identifying such dynamics is difficult."}, {"heading": "7. Future Work", "text": "Several avenues for future work are made possible by the research presented in this article. Perhaps the most promising is the development of new approximate Dec-POMDP algorithms. While this article focused on optimal methods, GMAA*-ICE can also be seen as a framework for approximate methods. Such methods could be derived by limiting the amount of backtracking, employing approximate CBG solvers (Emery-Montemerlo, Gordon, Schneider, & Thrun, 2004; Kumar & Zilberstein, 2010b; Wu et al., 2010a), integrating GMAA* methods for factored Dec-POMDPs (Oliehoek, Spaan, Whiteson, & Vlassis, 2008; Oliehoek, 2010; Oliehoek et al., 2013), performing lossy clustering (Emery-Montemerlo, 2005; Wu et al., 2011) or using bounded approximations for the heuristics. In particular, it seems promising to combine approximate clustering with approximate factored GMAA* methods.\nLossy clustering could be achieved by generalizing the probabilistic equivalence criterion, which is currently so strict that little or no clustering may be possible in many problems. An obvious approach is to cluster histories for which the distributions over states and histories of other agents are merely similar, as measured by, e.g., Kullback-Leibler divergence. Alternately, histories could be clustered if they induce the same individual belief over states:\nPr(s|~\u03b8i) = \u2211\n~\u03b8 6=i\nPr(s,~\u03b8 6=i|~\u03b8i). (7.1)\nWhile individual beliefs are not sufficient statistics for history, we hypothesize that they constitute effective metrics for approximate clustering. Since the individual belief simply marginalizes out the other agents\u2019 histories from the probabilities used in the probabilistic equivalence criterion, it is an intuitive heuristic metric for approximate clustering.\nWhile this article focuses on increasing scalability with respect to the horizon, developing techniques to deal with larger number of agents is an important direction of future work. We plan to further explore performing GMAA* using factored representations (Oliehoek, Spaan, Whiteson, & Vlassis, 2008). In that previous work, we could only exploit the factorization at the last stage, since earlier stages required full expansions to guarantee optimality. However, for such larger problems, the number of joint BG policies (i.e., number of child nodes) is directly very large (earlier stages are more tightly coupled); therefore incremental expansion is crucial to improving the scalability of optimal solution methods with respect to the number of agents.\nAnother avenue for future work is to further generalize GMAA*-ICE. In particular, it may be possible to flatten the two nested A\u2217 searches into a single A\u2217 search. Doing so could lead to significant savings as it would obviate the need to solve an entire CBG before expanding the next one. In our work, we employed the plain A\u2217 algorithm as a basis, but a promising direction of future work is to investigate what A\u2217 enhancements from the literature (Edelkamp & Schro\u0308dl, 2012) can benefit GMAA* most. In particular, as we described in our experiments, different past joint policies can lead to CBGs of different sizes. One idea\nis to first expand parts of the search tree that lead to small CBGs, by biasing the selection operator (but not the pruning operator, so as to maintain optimality).\nYet another important direction for future work is the development of tighter heuristics. Though few researchers are addressing this topic, the results presented in this article underscore how important such heuristics are for solving larger problems. Currently, the heuristic is the bottleneck in four out of the seven problems we considered. Moreover, two of the problems where this is not the bottleneck can already be solved for long (h > 50) horizons. Therefore, we believe that computing tight heuristics for longer horizons is the single most important research direction for further improving the scalability of optimal Dec-POMDP solution methods with respect to the horizon.\nA different direction is to employ our theoretical results on clustering beyond the DecPOMDP setting to develop new solution methods for CBGs. For instance, a well-known method for computing a local optimum is alternating maximization (AM): starting from an arbitrary joint policy, compute a best response for some agent given that other agents keep their policies fixed and then select another agent\u2019s policy to improve, etc. One idea is to start with a \u2018completely clustered\u2019 CBG, where all agents\u2019 types are clustered together and thus a random joint CBG policy has a simple form: each agent just selects a single action. Only when improving the policy of an agent do we consider all its actual possible types to compute its best response. Subsequently, we cluster together all types for which that agent selects the same action and proceed to the next agent. In addition, since our clustering results are not restricted to the collaborative setting, it may also be possible to employ them, using a similar approach, to develop new solution methods for general-payoff BGs.\nFinally, two of our other contributions can have a significant impact beyond the problem of optimally solving Dec-POMDPs. First, the idea of incrementally expanding nodes introduced in GMAA*-ICE can be applied in other A\u2217 search methods. Incremental expansion is most useful when children can be generated in order of decreasing heuristic value without prohibitive computational effort, and in problems with a large branching factor such as multiple sequence alignment problems in computational biology (Carrillo & Lipman, 1988; Ikeda & Imai, 1999). Second, representing PWLC value functions as a hybrid of a tree and a set of vectors can have wider impact as well, e.g., in online search for POMDPs (Ross, Pineau, Paquet, & Chaib-draa, 2008)."}, {"heading": "8. Conclusions", "text": "This article presented a set of methods that advance the state-of-the-art in optimal solution methods for Dec-POMDPs. In particular, we presented several advances that aim to extend the horizon over which optimal solutions can be found. These advances build off the GMAA* heuristic search approach and include lossless incremental clustering of the CBGs solved by GMAA*, incremental expansion of nodes in the GMAA* search tree, and hybrid heuristic representations. We provided theoretical guarantees that, when a suitable heuristic is used, both incremental clustering and incremental expansion yield algorithms that are both complete and search equivalent. Finally, we presented extensive empirical results demonstrating that GMAA*-ICE can optimally solve Dec-POMDPs of unprecedented size. We significanty increase the planning horizons that can be tackled\u2014in some cases by more than an order of magnitude. Given that an increase of the horizon by one results in an exponentially larger search space, this constitutes a very large improvement. Moreover, our techniques also im-\nprove scalability with respect to the number of agents, leading to the first ever solutions of general Dec-POMDPs with more than three agents. These results also demonstrated how optimal techniques can yield new insights about particular Dec-POMDPs, as incremental clustering revealed properties of BroadcastChannel that make it much easier to solve. In addition to facilitating optimal solutions, we hope these advances will inspire new principled approximation methods, as incremental clustering has already done (Wu et al., 2011), and enable them to be meaningfully benchmarked."}, {"heading": "Acknowledgments", "text": "We thank Raghav Aras and Abdeslam Boularias for making their code available to us. Research supported in part by AFOSR MURI project #FA9550-09-1-0538 and in part by NWO CATCH project #640.005.003. M.S. is funded by the FP7 Marie Curie Actions Individual Fellowship #275217 (FP7-PEOPLE-2010-IEF)."}, {"heading": "Appendix A. Appendix", "text": "A.1 Auxiliary algorithms\nAlgorithm 12 implements the BestJointPolicyAndValue function, which prunes all child nodes that are not fully specified. Algorithm 13 generates all children of a particular CBG.\nAlgorithm 12 BestJointPolicyAndValue(QExpand): Prune fully expanded nodes from a set of nodes QExpand returning only the best one and its value. Input: QExpand a set of nodes for fully specified joint policies. Output: the best full joint policy in the input set and its value. 1: v\u2217 = \u2212\u221e 2: for q \u2208 QExpand do 3: QExpand.Remove(q) 4: \u3008\u03c0, v\u0302\u3009 \u2190 q 5: if v > v\u2217 then 6: v\u2217 \u2190 v 7: \u03c0\u2217 \u2190 \u03c0 8: end if\n9: end for\n10: return \u3008\u03c0\u2217, v\u2217\u3009\nA.2 Detailed GMAA*-ICE algorithm\nThe complete GMAA*-ICE algorithm is shown in Algorithm 14.\nA.3 Computation of V 0...t\u22121(\u03d5t)\nThe quantity V 0...t\u22121(\u03d5t) is defined recursively via:\nV 0...t\u22121(\u03d5t) = V 0...t\u22122(\u03d5t\u22121) +E st\u22121,~\u03b8t\u22121 [R(st\u22121,\u03b4t\u22121(~\u03b8t\u22121)) | b0,\u03d5t]. (A.1)\nAlgorithm 13 GenerateAllChildrenForCBG(B(\u03d5t)). Input: CBG B(\u03d5t). Output: QExpand the set containing all expanded child nodes for this CBG. 1: QExpand \u2190 {} 2: for all joint CBG policies \u03b2 for B do 3: V\u0302 (\u03b2) \u2190 \u2211 \u03b8 Pr(\u03b8)u(\u03b8,\u03b2(\u03b8))\n4: \u03d5t+1 \u2190 (\u03d5t,\u03b2t) {create partial joint policy} 5: V\u0302 (\u03d5t+1) \u2190 V 0...t\u22121(\u03d5t) + V\u0302 (\u03b2t) {compute heuristic value} 6: q\u2032 \u2190 \u3008\u03d5t+1, V\u0302 (\u03d5t+1)\u3009 {create child node} 7: QExpand.Insert(q\n\u2032) 8: end for 9: return QExpand\nThe expectation is taken with respect to the joint probability distribution over states and joint AOHs that is induced by \u03d5t:\nPr(st,~\u03b8t|b0,\u03d5t) = \u2211\nst\u22121\u2208S\nPr(ot|at\u22121,st) Pr(st|st\u22121,at\u22121) Pr(at\u22121|\u03d5t,~\u03b8t\u22121) Pr(st\u22121,~\u03b8t\u22121|b0,\u03d5t).\n(A.2) Here, ~\u03b8t = (~\u03b8t\u22121,at\u22121,ot) and Pr(at\u22121|\u03d5t,~\u03b8t\u22121) is the probability that \u03d5t specifies at\u22121 for AOH ~\u03b8t\u22121 (which is 0 or 1 in case of deterministic past joint policy \u03d5t).\nA.4 Proofs\nProof of Theorem 1\nSubstituting (2.9) in (2.7) yields V\u0302 (\u03b2) = V\u0302 (\u03b4t) = \u2211\n~\u03b8t\nPr(~\u03b8t|b0,\u03d5t)Q\u0302(~\u03b8t,\u03b4t(~\u03b8t))\n= \u2211\n~\u03b8t\nPr(~\u03b8t|b0,\u03d5t) ( Est [R(s t,\u03b4t(~\u03b8t)) | ~\u03b8t] +E~\u03b8t+1 [V\u0302 ( ~\u03b8t+1) | ~\u03b8t, \u03b4t(~\u03b8t)] )\n= E st,~\u03b8t [R(st,\u03b4t(~\u03b8t) | b0,\u03d5t] +E~\u03b8t+1 [V\u0302 ( ~\u03b8t+1) | b0,\u03d5t, \u03b4t]\n\u2265 E st,~\u03b8t [R(st,\u03b4t(~\u03b8t) | b0,\u03d5t] +E~\u03b8t+1 [Q\u03c0\u2217( ~\u03b8t+1,\u03c0\u2217(~\u03b8t+1)) | b0,\u03d5t+1 = (\u03d5t, \u03b4t)]\n= E st,~\u03b8t\n[R(st,\u03b4t(~\u03b8t) | b0,\u03d5t] +H\u2217,t+1...h\u22121(\u03d5t+1),\nwhere H\u2217 is an optimal admissible heuristic. Substituting this into (2.8) we obtain\nV\u0302 (\u03d5t+1 = (\u03d5t, \u03b4t)) = V 0...t\u22121(\u03d5t) +E st,~\u03b8t [R(st,\u03b4t(~\u03b8t) | b0,\u03d5t] +E~\u03b8t+1 [V\u0302 ( ~\u03b8t+1) | b0,\u03d5t, \u03b4t]\n\u2265 V 0...t\u22121(\u03d5t) +E st,~\u03b8t [R(st,\u03b4t(~\u03b8t)) | b0,\u03d5t+1] +H\u2217,t+1...h\u22121(\u03d5t+1)\n{via (A.1)} = V 0...t(\u03d5t+1) +H\u2217,t+1...h\u22121(\u03d5t+1),\nwhich demonstrates that the heuristic value V\u0302 (\u03d5t) used by GMAA* via CBGs using heuristic of a form (2.9) is admissible, as it is lower bounded by the actual value for the first t plus an admissible heuristic. Since it performs heuristic search with this admissible heuristic, this algorithm is also complete.\nAlgorithm 14 GMAA*-ICE\n1: vGMAA \u2190 \u2212\u221e 2: \u03d50 \u2190 () 3: v\u0302 \u2190 +\u221e 4: q0 \u2190 \u3008\u03d50, v\u0302\u3009 5: LIE \u2190 {q0} 6: repeat 7: q \u2190 Select(LIE) {q = \u3008\u03d5t, v\u0302\u3009} 8: LIE.pop(q) 9: if IsPlaceholder(q) then 10: B(\u03d5t) \u2190 \u03d5t.CBG {reuse stored CBG} 11: else 12: {Construct extended BG and solver:} 13: B(\u03d5t\u22121) \u2190 \u03d5t\u22121.CBG {note \u03d5t = (\u03d5t\u22121,\u03b2t\u22121)} 14: B(\u03d5t) \u2190 ConstructExtendedBG(B(\u03d5t\u22121),\u03b2t\u22121) 15: B(\u03d5t) \u2190 ClusterBG(B(\u03d5t)) 16: B(\u03d5t).Solver \u2190 CreateSolver(B(\u03d5t)) 17: \u03d5t.CBG \u2190 B(\u03d5t) 18: end if 19: {Expand a single child:} 20: vCBG = vGMAA \u2212 V 0...(t\u22121)(\u03d5t) 21: v\u0304CBG = +\u221e 22: if last stage t = h\u2212 1 then 23: v\u0304CBG = V\u0302 (\u03d5h\u22121)\u2212 V 0...(h\u22122)(\u03d5h\u22121) 24: end if 25: \u3008\u03b2t, V\u0302 (\u03b2t)\u3009 \u2190 B(\u03d5t).Solver.NextSolution(vCBG,v\u0304CBG) 26: if not \u03b2t then 27: {fully expanded: no solution s.t. V (\u03b2h\u22121) \u2265 vCBG} 28: delete q (and its CBG + solver) 29: continue {(i.e. goto line 8)} 30: end if 31: \u03d5t+1 \u2190 (\u03d5t,\u03b2t) 32: V\u0302 (\u03d5t+1) \u2190 V 0...t\u22121(\u03d5t) + V\u0302 (\u03b2t) 33: if last stage t = h\u2212 1 then 34: {Note that \u03c0 = \u03d5t+1, V (\u03c0) = V\u0302 (\u03d5t+1) } 35: if V (\u03c0) > vGMAA then 36: vGMAA \u2190 V (\u03c0) {found new lower bound} 37: \u03c0\u22c6 \u2190 \u03c0 38: LIE.prune(vGMAA) 39: end if 40: delete q (and its CBG + solver) 41: else 42: q\u2032 \u2190 \u3008\u03d5t+1, V\u0302 (\u03d5t+1)\u3009 43: LIE.insert(q\u2032) 44: q \u2190 \u3008\u03d5t, V\u0302 (\u03d5t+1)\u3009 { Update parent node q, which now is a placeholder } 45: LIE.insert(q) 46: end if 47: until LIE is empty\nProof of Lemma 1\nProof. Assume an arbitrary ati,o t+1 i , \u03b4 t 6=i,s\nt+1 and ~\u03b8 t+1 6=i = (~\u03b8 t 6=i,a t 6=i,o t+1 6=i )). We have that\nPr(st+1,~\u03b8 t+1\n6=i ,o t+1 i | ~\u03b8 a,ti ,a t i,\u03b4 t 6=i)\n= \u2211\nst\nPr(ot+1i ,o t+1 6=i |a t i,a t 6=i,s t+1) Pr(st+1|st,ati,a t 6=i) Pr(a t 6=i|~\u03b8\nt 6=i,\u03b4 t 6=i) Pr(s t,~\u03b8 t 6=i|~\u03b8 a,t i )\n= \u2211\nst\nPr(ot+1i ,o t+1 6=i |a t i,a t 6=i,s t+1) Pr(st+1|st,ati,a t 6=i) Pr(a t 6=i|~\u03b8\nt 6=i,\u03b4 t 6=i) Pr(s t,~\u03b8 t 6=i| ~\u03b8 b,ti )\n= Pr(st+1,~\u03b8 t+1\n6=i ,o t+1 i | ~\u03b8 b,ti ,a t i,\u03b4 t 6=i)\nBecause we assumed an arbitrary st+1,~\u03b8 t+1\n6=i ,o t+1 i , we have that\n\u2200 st+1,~\u03b8 t+1\n6=i ,o t+1 i\nPr(st+1,~\u03b8 t+1\n6=i ,o t+1 i | ~\u03b8 a,ti ,a t i,\u03b4 t 6=i) = Pr(s t+1,~\u03b8 t+1 6=i ,o t+1 i | ~\u03b8 b,ti ,a t i,\u03b4 t 6=i) (A.3)\nIn general we have that\nPr(st+1,~\u03b8 t+1\n6=i |~\u03b8 t i ,a t i,o t+1 i ,\u03b4 t 6=i) =\nPr(st+1,~\u03b8 t+1\n6=i ,o t+1 i | ~\u03b8 ti ,a t i,\u03b4 t 6=i)\nPr(ot+1i | ~\u03b8 ti ,a t i,\u03b4 t 6=i)\n= Pr(st+1,~\u03b8\nt+1 6=i ,o t+1 i | ~\u03b8 ti ,a t i,\u03b4 t 6=i)\n\u2211 st+1,~\u03b8 t+1 6=i Pr(st+1,~\u03b8 t+1 6=i ,o t+1 i | ~\u03b8 ti ,a t i,\u03b4 t 6=i)\nNow, because of (A.3), both the numerator and denominator are the same when substituting ~\u03b8 a,ti , ~\u03b8 b,ti in this equation. Consequently, we can conclude that\nPr(st+1,~\u03b8 t+1 6=i |~\u03b8 a,t i ,a t i,o t+1 i ,\u03b4 t 6=i) = Pr(s t+1,~\u03b8 t+1 6=i |~\u03b8 b,t i ,a t i,o t+1 i ,\u03b4 t 6=i)\nFinally, because ati, o t+1 i , \u03b4 t 6=i,s\nt+1, and ~\u03b8 t+1\n6=i were all arbitrarily chosen, we can conclude that (3.4) holds.\nProof of Lemma 2\nProof. Assume an arbitrary \u03c0 6=i,s and \u03b3 6=i, then we have\nbi(s,\u03b3 6=i|~\u03b8 a i ,\u03c0 6=i) , Pr(s,\u03b3 6=i| ~\u03b8 ai ,\u03c0 6=i,b 0)\n= \u2211\n~\u03b8 6=i\nPr(s,\u03b3 6=i,~\u03b8 6=i|~\u03b8 a i ,\u03c0 6=i,b 0)\n{factoring the joint distribution} = \u2211\n~\u03b8 6=i\nPr(s,~\u03b8 6=i|~\u03b8 a i ,\u03c0 6=i,b 0) Pr(\u03b3 6=i|s,~\u03b8 6=i, ~\u03b8 a i ,\u03c0 6=i,b 0)\n{\u03b3 6=i only depends on ~\u03b8 6=i,\u03c0 6=i} = \u2211\n~\u03b8 6=i\nPr(s,~\u03b8 6=i|~\u03b8 a i ,\u03c0 6=i,b 0) Pr(\u03b3 6=i|~\u03b8 6=i,\u03c0 6=i)\n{ s,~\u03b8 6=i only depend on \u03d56=i } = \u2211\n~\u03b8 6=i\nPr(s,~\u03b8 6=i|~\u03b8 a i ,\u03d56=i,b 0) Pr(\u03b3 6=i|~\u03b8 6=i,\u03c0 6=i)\n{due to PE} = \u2211\n~\u03b8 6=i\nPr(s,~\u03b8 6=i|~\u03b8 b i ,\u03d56=i,b 0) Pr(\u03b3 6=i|~\u03b8 6=i,\u03c0 6=i)\n= [...] = Pr(s,\u03b3 6=i|~\u03b8 b i ,\u03c0 6=i,b 0) = bi(s,\u03b3 6=i|~\u03b8 b i ,\u03c0 6=i)\nWe can conclude this holds for all \u03c0 6=i,s and \u03b3 6=i.\nProof of Theorem 5 (Search Equivalence)\nTo prove search equivalence, we explicitly write a node as a tuple q = \u3008\u03d5t, v\u0302,PH\u3009, where \u03d5t is the past joint policy, v\u0302 the node\u2019s heuristic value, and PH a boolean indicating whether it is a placeholder. We consider the equivalence of the maintained open lists. The open list L maintained by GMAA*-IC contains only non-expanded nodes q. In contrast, the open list LIE of GMAA*-ICE contains both non-expanded nodes q and placeholders (previously expanded nodes), q\u0304. We denote the ordered subset of LIE containing non-expanded nodes with Q and that containing placeholders with Q\u0304. We treat these open lists as ordered sets of heuristic values and their associated nodes.\nDefinition 11. L and LIE are equivalent, L \u2261 LIE if:\n1. Q \u2286 L.\n2. The q\u2019s have the same ordering: L.remove(L \\Q) = Q.24\n3. Nodes q in L but not Q have a placeholder q\u0304 that is the parent of and higher ranked than q:\n\u2200q=\u3008\u03d5t,v\u0302q ,false\u3009\u2208(L\\Q) \u2203q\u0304=\u3008\u03d5t\u22121,v\u0302q\u0304 ,true\u3009\u2208Q\u0304 s.t. (\u03d5 t = (\u03d5t\u22121,\u03b2) \u2227 q < q\u0304).\n4. There are no other placeholders.\nFig. 11 illustrates two equivalent lists in which the past joint policies are indexed with letters. Note that the placeholders in LIE are ranked higher than the nodes in L that they represent.\nLet us write IT-IC(L) and IT-ICE(LIE) for one iteration (i.e., one loop of the main repeat in Algorithm 1) of the respective algorithms. Let IT-ICE* denote the operation that repeats IT-ICE as long as a placeholder was selected (so it ends when a q is expanded).\nLemma 4. If L \u2261 LIE, then executing IT-IC(L) and IT-ICE*(LIE) leads to new open lists that are again equivalent: L \u2032 \u2261 LIE\u2032.\nProof. When IT-ICE* selects a placeholder q\u0304, it generates child q\u2032 that was already present in L (due to properties 3 and 4 of Definition 11) and inserts it. Insertion occurs at the same relative location as IT-IC because both algorithms use the same comparison operator (Definition 5). Together these facts guarantee that the insertion preserves properties 1 and 2.\n24. A.remove(B) removes the elements of B from A without changing A\u2019s ordering.\nIf there are remaining unexpanded children of q\u0304, IT-ICE* reinserts q\u0304 with an updated heuristic value q\u0304.v\u0302 \u2190 q\u2032.v\u0302 that is guaranteed to be an upper bound on the value of unexpanded siblings q\u2032\u2032 since q\u2032.v\u0302 = V\u0302 (q\u2032.\u03d5) \u2265 V\u0302 (q\u2032\u2032.\u03d5) = q\u2032\u2032.v\u0302 (preserving properties 3 and 4).\nWhen IT-ICE* finally selects a non-placeholder q, it is guaranteed to be the same q as selected by IT-IC (due to properties 1 and 2). Expansion in ICE generates one child q\u2032 (again inserted at the same relative location as in IC) and inserts placeholder q\u0304 = \u3008q.\u03d5, q\u2032.v\u0302, true\u3009 for the other siblings q\u2032\u2032 (again preserving properties 3 and 4).\nProof of Theorem 5. The fact that GMAA*-ICE and GMAA*-IC are search-equivalent follows directly from Lemma 4. Search equivalence means that both algorithms select the same non-placeholders q to expand. Since both algorithms begin with identical (and therefore trivially equivalent) open lists, they maintain equivalent open lists throughout search. As such, property 2 of Definition 11 ensures that every time IT-ICE* selects a non-placeholder, IT-IC selects it too."}], "references": [{"title": "Agent influence as a predictor of difficulty for decentralized problem-solving", "author": ["M. Allen", "S. Zilberstein"], "venue": "In Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence", "citeRegEx": "Allen and Zilberstein,? \\Q2007\\E", "shortCiteRegEx": "Allen and Zilberstein", "year": 2007}, {"title": "Optimal fixed-size controllers for decentralized POMDPs", "author": ["C. Amato", "D.S. Bernstein", "S. Zilberstein"], "venue": "In Proc. of the AAMAS Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Amato et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2006}, {"title": "Optimizing memory-bounded controllers for decentralized POMDPs", "author": ["C. Amato", "D.S. Bernstein", "S. Zilberstein"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Amato et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2007}, {"title": "Optimizing fixed-size stochastic controllers for POMDPs and decentralized POMDPs", "author": ["C. Amato", "D.S. Bernstein", "S. Zilberstein"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Amato et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2010}, {"title": "Finite-state controllers based on Mealy machines for centralized and decentralized POMDPs", "author": ["C. Amato", "B. Bonet", "S. Zilberstein"], "venue": "In Proceedings of the TwentyFourth AAAI Conference on Artificial Intelligence", "citeRegEx": "Amato et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2010}, {"title": "Bounded dynamic programming for decentralized POMDPs", "author": ["C. Amato", "A. Carlin", "S. Zilberstein"], "venue": "In Proc. of the AAMAS Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Amato et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2007}, {"title": "Incremental policy generation for finite-horizon DEC-POMDPs", "author": ["C. Amato", "J.S. Dibangoye", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Automated Planning and Scheduling", "citeRegEx": "Amato et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Amato et al\\.", "year": 2009}, {"title": "An investigation into mathematical programming for finite horizon decentralized POMDPs", "author": ["R. Aras", "A. Dutech"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Aras and Dutech,? \\Q2010\\E", "shortCiteRegEx": "Aras and Dutech", "year": 2010}, {"title": "Analyzing myopic approaches for multi-agent communication", "author": ["R. Becker", "A. Carlin", "V. Lesser", "S. Zilberstein"], "venue": "Computational Intelligence,", "citeRegEx": "Becker et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Becker et al\\.", "year": 2009}, {"title": "Decentralized Markov decision processes with event-driven interactions", "author": ["R. Becker", "S. Zilberstein", "V. Lesser"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Becker et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Becker et al\\.", "year": 2004}, {"title": "Transition-independent decentralized Markov decision processes", "author": ["R. Becker", "S. Zilberstein", "V. Lesser", "C.V. Goldman"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Becker et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Becker et al\\.", "year": 2003}, {"title": "Policy iteration for decentralized control of Markov decision processes", "author": ["D.S. Bernstein", "C. Amato", "E.A. Hansen", "S. Zilberstein"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Bernstein et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bernstein et al\\.", "year": 2009}, {"title": "The complexity of decentralized control of Markov decision processes", "author": ["D.S. Bernstein", "R. Givan", "N. Immerman", "S. Zilberstein"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Bernstein et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Bernstein et al\\.", "year": 2002}, {"title": "Dynamic Programming and Optimal Control (3rd ed., Vol. I)", "author": ["D.P. Bertsekas"], "venue": "Athena Scientific", "citeRegEx": "Bertsekas,? \\Q2005\\E", "shortCiteRegEx": "Bertsekas", "year": 2005}, {"title": "Solving efficiently decentralized MDPs with temporal and resource constraints", "author": ["A. Beynier", "Mouaddib", "A.-I"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Beynier et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Beynier et al\\.", "year": 2011}, {"title": "Exact dynamic programming for decentralized POMDPs with lossless policy compression", "author": ["A. Boularias", "B. Chaib-draa"], "venue": "In Proc. of the International Conference on Automated Planning and Scheduling", "citeRegEx": "Boularias and Chaib.draa,? \\Q2008\\E", "shortCiteRegEx": "Boularias and Chaib.draa", "year": 2008}, {"title": "A comprehensive survey of multi-agent reinforcement learning", "author": ["L. Bu\u015foniu", "R. Babu\u0161ka", "B. De Schutter"], "venue": "IEEE Transactions on Systems, Man, and Cybernetics, Part C: Applications and Reviews,", "citeRegEx": "Bu\u015foniu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bu\u015foniu et al\\.", "year": 2008}, {"title": "Value-based observation compression for DEC-POMDPs", "author": ["A. Carlin", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Carlin and Zilberstein,? \\Q2008\\E", "shortCiteRegEx": "Carlin and Zilberstein", "year": 2008}, {"title": "The multiple sequence alignment problem in biology", "author": ["H. Carrillo", "D. Lipman"], "venue": "SIAM Journal on Applied Mathematics,", "citeRegEx": "Carrillo and Lipman,? \\Q1988\\E", "shortCiteRegEx": "Carrillo and Lipman", "year": 1988}, {"title": "Incremental pruning: A simple, fast, exact method for partially observable Markov decision processes", "author": ["A. Cassandra", "M.L. Littman", "N.L. Zhang"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Cassandra et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cassandra et al\\.", "year": 1997}, {"title": "Exact and Approximate Algorithms for Partially Observable Markov Decision Processes", "author": ["A.R. Cassandra"], "venue": "Unpublished doctoral dissertation, Brown University.", "citeRegEx": "Cassandra,? 1998", "shortCiteRegEx": "Cassandra", "year": 1998}, {"title": "Search algorithms for m best solutions for graphical models", "author": ["R. Dechter", "N. Flerova", "R. Marinescu"], "venue": "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence", "citeRegEx": "Dechter et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dechter et al\\.", "year": 2012}, {"title": "Producing efficient errorbounded solutions for transition independent decentralized MDPs", "author": ["J.S. Dibangoye", "C. Amato", "A. Doniec", "F. Charpillet"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems. (Submitted for publication)", "citeRegEx": "Dibangoye et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Dibangoye et al\\.", "year": 2013}, {"title": "Point-based incremental pruning heuristic for solving finite-horizon DEC-POMDPs", "author": ["J.S. Dibangoye", "Mouaddib", "A.-I", "B. Chai-draa"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Dibangoye et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Dibangoye et al\\.", "year": 2009}, {"title": "Monte Carlo sampling methods for approximating interactive POMDPs", "author": ["P. Doshi", "P. Gmytrasiewicz"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Doshi and Gmytrasiewicz,? \\Q2009\\E", "shortCiteRegEx": "Doshi and Gmytrasiewicz", "year": 2009}, {"title": "Graphical models for interactive POMDPs: representations and solutions", "author": ["P. Doshi", "Y. Zeng", "Q. Chen"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Doshi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Doshi et al\\.", "year": 2008}, {"title": "Heuristic search: theory and applications", "author": ["S. Edelkamp", "S. Schr\u00f6dl"], "venue": null, "citeRegEx": "Edelkamp and Schr\u00f6dl,? \\Q2012\\E", "shortCiteRegEx": "Edelkamp and Schr\u00f6dl", "year": 2012}, {"title": "Using evolution strategies to solve DEC-POMDP problems", "author": ["B. Eker", "H.L. Ak\u0131n"], "venue": "Soft Computing\u2014A Fusion of Foundations, Methodologies and Applications,", "citeRegEx": "Eker and Ak\u0131n,? \\Q2010\\E", "shortCiteRegEx": "Eker and Ak\u0131n", "year": 2010}, {"title": "Solving decentralized POMDP problems using genetic algorithms", "author": ["B. Eker", "H.L. Ak\u0131n"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Eker and Ak\u0131n,? \\Q2013\\E", "shortCiteRegEx": "Eker and Ak\u0131n", "year": 2013}, {"title": "Game-Theoretic Control for Robot Teams", "author": ["R. Emery-Montemerlo"], "venue": "Unpublished doctoral dissertation, Carnegie Mellon University.", "citeRegEx": "Emery.Montemerlo,? 2005", "shortCiteRegEx": "Emery.Montemerlo", "year": 2005}, {"title": "Approximate solutions for partially observable stochastic games with common payoffs", "author": ["R. Emery-Montemerlo", "G. Gordon", "J. Schneider", "S. Thrun"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Emery.Montemerlo et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Emery.Montemerlo et al\\.", "year": 2004}, {"title": "Game theoretic control for robot teams", "author": ["R. Emery-Montemerlo", "G. Gordon", "J. Schneider", "S. Thrun"], "venue": "In Proc. of the IEEE International Conference on Robotics and Automation", "citeRegEx": "Emery.Montemerlo et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Emery.Montemerlo et al\\.", "year": 2005}, {"title": "Equivalence notions and model minimization in Markov decision processes", "author": ["R. Givan", "T. Dean", "M. Greig"], "venue": "Artificial Intelligence,", "citeRegEx": "Givan et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Givan et al\\.", "year": 2003}, {"title": "A framework for sequential planning in multi-agent settings", "author": ["P.J. Gmytrasiewicz", "P. Doshi"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Gmytrasiewicz and Doshi,? \\Q2005\\E", "shortCiteRegEx": "Gmytrasiewicz and Doshi", "year": 2005}, {"title": "Learning to communicate in a decentralized environment", "author": ["C.V. Goldman", "M. Allen", "S. Zilberstein"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Goldman et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Goldman et al\\.", "year": 2007}, {"title": "Optimizing information exchange in cooperative multi-agent systems", "author": ["C.V. Goldman", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Goldman and Zilberstein,? \\Q2003\\E", "shortCiteRegEx": "Goldman and Zilberstein", "year": 2003}, {"title": "Decentralized control of cooperative systems: Categorization and complexity analysis", "author": ["C.V. Goldman", "S. Zilberstein"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Goldman and Zilberstein,? \\Q2004\\E", "shortCiteRegEx": "Goldman and Zilberstein", "year": 2004}, {"title": "Communication-based decomposition mechanisms for decentralized MDPs", "author": ["C.V. Goldman", "S. Zilberstein"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Goldman and Zilberstein,? \\Q2008\\E", "shortCiteRegEx": "Goldman and Zilberstein", "year": 2008}, {"title": "Dynamic programming for partially observable stochastic games", "author": ["E.A. Hansen", "D.S. Bernstein", "S. Zilberstein"], "venue": "In Proc. of the National Conference on Artificial Intelligence", "citeRegEx": "Hansen et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Hansen et al\\.", "year": 2004}, {"title": "Value-function approximations for partially observable Markov decision processes", "author": ["M. Hauskrecht"], "venue": "Journal of Artificial Intelligence Research, 13 , 33\u201394.", "citeRegEx": "Hauskrecht,? 2000", "shortCiteRegEx": "Hauskrecht", "year": 2000}, {"title": "Decentralized control of finite state Markov processes", "author": ["K. Hsu", "S. Marcus"], "venue": "IEEE Transactions on Automatic Control ,", "citeRegEx": "Hsu and Marcus,? \\Q1982\\E", "shortCiteRegEx": "Hsu and Marcus", "year": 1982}, {"title": "Distributed Artificial Intelligence", "author": ["Huhns", "M.N. (Ed"], "venue": null, "citeRegEx": "Huhns and .Ed...,? \\Q1987\\E", "shortCiteRegEx": "Huhns and .Ed...", "year": 1987}, {"title": "Enhanced A* algorithms for multiple alignments: optimal alignments for several sequences and k-opt approximate alignments for large cases", "author": ["T. Ikeda", "H. Imai"], "venue": "Theoretical Computer Science,", "citeRegEx": "Ikeda and Imai,? \\Q1999\\E", "shortCiteRegEx": "Ikeda and Imai", "year": 1999}, {"title": "Planning and acting in partially observable stochastic domains", "author": ["L.P. Kaelbling", "M.L. Littman", "A.R. Cassandra"], "venue": "Artificial Intelligence,", "citeRegEx": "Kaelbling et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Kaelbling et al\\.", "year": 1998}, {"title": "Constraint-based dynamic programming for decentralized POMDPs with structured interactions", "author": ["A. Kumar", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Kumar and Zilberstein,? \\Q2009\\E", "shortCiteRegEx": "Kumar and Zilberstein", "year": 2009}, {"title": "Anytime planning for decentralized POMDPs using expectation maximization", "author": ["A. Kumar", "S. Zilberstein"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Kumar and Zilberstein,? \\Q2010\\E", "shortCiteRegEx": "Kumar and Zilberstein", "year": 2010}, {"title": "Point-based backup for decentralized POMDPs: Complexity and new algorithms", "author": ["A. Kumar", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Kumar and Zilberstein,? \\Q2010\\E", "shortCiteRegEx": "Kumar and Zilberstein", "year": 2010}, {"title": "Learning policies for partially observable environments: Scaling up", "author": ["M. Littman", "A. Cassandra", "L. Kaelbling"], "venue": "In Proc. of the International Conference on Machine Learning", "citeRegEx": "Littman et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Littman et al\\.", "year": 1995}, {"title": "Not all agents are equal: scaling up distributed POMDPs for agent networks", "author": ["J. Marecki", "T. Gupta", "P. Varakantham", "M. Tambe", "M. Yokoo"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Marecki et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Marecki et al\\.", "year": 2008}, {"title": "On opportunistic techniques for solving decentralized Markov decision processes with temporal constraints", "author": ["J. Marecki", "M. Tambe"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Marecki and Tambe,? \\Q2007\\E", "shortCiteRegEx": "Marecki and Tambe", "year": 2007}, {"title": "Decentralized MDPs with sparse interactions", "author": ["F.S. Melo", "M. Veloso"], "venue": "Artificial Intelligence,", "citeRegEx": "Melo and Veloso,? \\Q2011\\E", "shortCiteRegEx": "Melo and Veloso", "year": 2011}, {"title": "A compact mathematical formulation for problems with structured agent interactions", "author": ["H. Mostafa", "V. Lesser"], "venue": "In Proc. of the AAMAS Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Mostafa and Lesser,? \\Q2011\\E", "shortCiteRegEx": "Mostafa and Lesser", "year": 2011}, {"title": "Communication for improving policy computation in distributed POMDPs", "author": ["R. Nair", "M. Roth", "M. Yohoo"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Nair et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2004}, {"title": "Taming decentralized POMDPs: Towards efficient policy computation for multiagent settings", "author": ["R. Nair", "M. Tambe", "M. Yokoo", "D.V. Pynadath", "S. Marsella"], "venue": "In Proc. of the International Joint Conference on Artificial Intelligence", "citeRegEx": "Nair et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2003}, {"title": "Networked distributed POMDPs: A synthesis of distributed constraint optimization and POMDPs", "author": ["R. Nair", "P. Varakantham", "M. Tambe", "M. Yokoo"], "venue": "In Proc. of the National Conference on Artificial Intelligence", "citeRegEx": "Nair et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2005}, {"title": "Value-Based Planning for Teams of Agents in Stochastic Partially Observable Environments", "author": ["F.A. Oliehoek"], "venue": "Amsterdam University Press. (Doctoral dissertation, University of Amsterdam)", "citeRegEx": "Oliehoek,? 2010", "shortCiteRegEx": "Oliehoek", "year": 2010}, {"title": "Decentralized POMDPs", "author": ["F.A. Oliehoek"], "venue": "M. Wiering & M. van Otterlo (Eds.), Reinforcement learning: State of the art (Vol. 12). Springer Berlin Heidelberg.", "citeRegEx": "Oliehoek,? 2012", "shortCiteRegEx": "Oliehoek", "year": 2012}, {"title": "The cross-entropy method for policy search in decentralized", "author": ["F.A. Oliehoek", "J.F. Kooi", "N. Vlassis"], "venue": "POMDPs. Informatica,", "citeRegEx": "Oliehoek et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2008}, {"title": "Tree-based solution methods for multiagent POMDPs with delayed communication", "author": ["F.A. Oliehoek", "M.T.J. Spaan"], "venue": "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence", "citeRegEx": "Oliehoek and Spaan,? \\Q2012\\E", "shortCiteRegEx": "Oliehoek and Spaan", "year": 2012}, {"title": "Heuristic search for identical payoff Bayesian games", "author": ["F.A. Oliehoek", "M.T.J. Spaan", "J. Dibangoye", "C. Amato"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Oliehoek et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2010}, {"title": "Dec-POMDPs with delayed communication", "author": ["F.A. Oliehoek", "M.T.J. Spaan", "N. Vlassis"], "venue": "In Proc. of the AAMAS Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Oliehoek et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2007}, {"title": "Optimal and approximate Q-value functions for decentralized POMDPs", "author": ["F.A. Oliehoek", "M.T.J. Spaan", "N. Vlassis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Oliehoek et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2008}, {"title": "Exploiting locality of interaction in factored Dec-POMDPs", "author": ["F.A. Oliehoek", "M.T.J. Spaan", "S. Whiteson", "N. Vlassis"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Oliehoek et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2008}, {"title": "Q-value functions for decentralized POMDPs", "author": ["F.A. Oliehoek", "N. Vlassis"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Oliehoek and Vlassis,? \\Q2007\\E", "shortCiteRegEx": "Oliehoek and Vlassis", "year": 2007}, {"title": "Lossless clustering of histories in decentralized POMDPs", "author": ["F.A. Oliehoek", "S. Whiteson", "M.T.J. Spaan"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Oliehoek et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2009}, {"title": "Approximate solutions for factored Dec-POMDPs with many agents", "author": ["F.A. Oliehoek", "S. Whiteson", "M.T.J. Spaan"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems. (Submitted for publication)", "citeRegEx": "Oliehoek et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2013}, {"title": "Influence-based abstraction for multiagent systems", "author": ["F.A. Oliehoek", "S. Witwicki", "L.P. Kaelbling"], "venue": "In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence", "citeRegEx": "Oliehoek et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Oliehoek et al\\.", "year": 2012}, {"title": "Decentralized control of a multiple access broadcast channel: Performance bounds", "author": ["J.M. Ooi", "G.W. Wornell"], "venue": "In Proc. of the 35th conference on decision and control", "citeRegEx": "Ooi and Wornell,? \\Q1996\\E", "shortCiteRegEx": "Ooi and Wornell", "year": 1996}, {"title": "A course in game theory", "author": ["M.J. Osborne", "A. Rubinstein"], "venue": null, "citeRegEx": "Osborne and Rubinstein,? \\Q1994\\E", "shortCiteRegEx": "Osborne and Rubinstein", "year": 1994}, {"title": "Efficient planning for factored infinite-horizon DECPOMDPs", "author": ["J. Pajarinen", "J. Peltonen"], "venue": "In Proc. of the International Joint Conference on Artificial Intelligence", "citeRegEx": "Pajarinen and Peltonen,? \\Q2011\\E", "shortCiteRegEx": "Pajarinen and Peltonen", "year": 2011}, {"title": "Cooperative multi-agent learning: The state of the art", "author": ["L. Panait", "S. Luke"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Panait and Luke,? \\Q2005\\E", "shortCiteRegEx": "Panait and Luke", "year": 2005}, {"title": "Markov Decision Processes\u2014Discrete Stochastic Dynamic Programming", "author": ["M.L. Puterman"], "venue": "John Wiley & Sons, Inc.", "citeRegEx": "Puterman,? 1994", "shortCiteRegEx": "Puterman", "year": 1994}, {"title": "Minimal mental models", "author": ["D.V. Pynadath", "S.C. Marsella"], "venue": "In Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence", "citeRegEx": "Pynadath and Marsella,? \\Q2007\\E", "shortCiteRegEx": "Pynadath and Marsella", "year": 2007}, {"title": "The communicative multiagent team decision problem: Analyzing teamwork theories and models", "author": ["D.V. Pynadath", "M. Tambe"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Pynadath and Tambe,? \\Q2002\\E", "shortCiteRegEx": "Pynadath and Tambe", "year": 2002}, {"title": "The complexity of multiagent systems: the price of silence", "author": ["Z. Rabinovich", "C.V. Goldman", "J.S. Rosenschein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Rabinovich et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Rabinovich et al\\.", "year": 2003}, {"title": "Multiagent coordination by extended Markov tracking", "author": ["Z. Rabinovich", "J.S. Rosenschein"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Rabinovich and Rosenschein,? \\Q2005\\E", "shortCiteRegEx": "Rabinovich and Rosenschein", "year": 2005}, {"title": "Online planning algorithms for POMDPs", "author": ["S. Ross", "J. Pineau", "S. Paquet", "B. Chaib-draa"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Ross et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ross et al\\.", "year": 2008}, {"title": "Reasoning about joint beliefs for executiontime communication decisions", "author": ["M. Roth", "R. Simmons", "M. Veloso"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Roth et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Roth et al\\.", "year": 2005}, {"title": "Exploiting factored representations for decentralized execution in multi-agent teams", "author": ["M. Roth", "R. Simmons", "M. Veloso"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Roth et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Roth et al\\.", "year": 2007}, {"title": "Improved memory-bounded dynamic programming for decentralized POMDPs", "author": ["S. Seuken", "S. Zilberstein"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Seuken and Zilberstein,? \\Q2007\\E", "shortCiteRegEx": "Seuken and Zilberstein", "year": 2007}, {"title": "Memory-bounded dynamic programming for DECPOMDPs", "author": ["S. Seuken", "S. Zilberstein"], "venue": "In Proc. of the International Joint Conference on Artificial Intelligence", "citeRegEx": "Seuken and Zilberstein,? \\Q2007\\E", "shortCiteRegEx": "Seuken and Zilberstein", "year": 2007}, {"title": "Formal models and algorithms for decentralized decision making under uncertainty", "author": ["S. Seuken", "S. Zilberstein"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Seuken and Zilberstein,? \\Q2008\\E", "shortCiteRegEx": "Seuken and Zilberstein", "year": 2008}, {"title": "Decentralized planning under uncertainty for teams of communicating agents", "author": ["M.T.J. Spaan", "G.J. Gordon", "N. Vlassis"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Spaan et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Spaan et al\\.", "year": 2006}, {"title": "Interaction-driven Markov games for decentralized multiagent planning under uncertainty", "author": ["M.T.J. Spaan", "F.S. Melo"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Spaan and Melo,? \\Q2008\\E", "shortCiteRegEx": "Spaan and Melo", "year": 2008}, {"title": "The MultiAgent Decision Process toolbox: software for decision-theoretic planning in multiagent systems", "author": ["M.T.J. Spaan", "F.A. Oliehoek"], "venue": "In Proc. of the AAMAS Workshop on Multi-Agent Sequential Decision Making in Uncertain Domains", "citeRegEx": "Spaan and Oliehoek,? \\Q2008\\E", "shortCiteRegEx": "Spaan and Oliehoek", "year": 2008}, {"title": "Scaling up optimal heuristic search in Dec-POMDPs via incremental expansion", "author": ["M.T.J. Spaan", "F.A. Oliehoek", "C. Amato"], "venue": "In Proc. of the International Joint Conference on Artificial Intelligence", "citeRegEx": "Spaan et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Spaan et al\\.", "year": 2011}, {"title": "Multiagent planning under uncertainty with stochastic communication delays", "author": ["M.T.J. Spaan", "F.A. Oliehoek", "N. Vlassis"], "venue": "In Proc. of the International Conference on Automated Planning and Scheduling", "citeRegEx": "Spaan et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Spaan et al\\.", "year": 2008}, {"title": "Multiagent systems", "author": ["K.P. Sycara"], "venue": "AI Magazine, 19 (2), 79\u201392.", "citeRegEx": "Sycara,? 1998", "shortCiteRegEx": "Sycara", "year": 1998}, {"title": "MAA*: A heuristic search algorithm for solving decentralized POMDPs", "author": ["D. Szer", "F. Charpillet", "S. Zilberstein"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Szer et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Szer et al\\.", "year": 2005}, {"title": "On the complexity of decentralized decision making and detection problems", "author": ["J. Tsitsiklis", "M. Athans"], "venue": "IEEE Transactions on Automatic Control ,", "citeRegEx": "Tsitsiklis and Athans,? \\Q1985\\E", "shortCiteRegEx": "Tsitsiklis and Athans", "year": 1985}, {"title": "On delayed sharing patterns", "author": ["P. Varaiya", "J. Walrand"], "venue": "IEEE Transactions on Automatic Control ,", "citeRegEx": "Varaiya and Walrand,? \\Q1978\\E", "shortCiteRegEx": "Varaiya and Walrand", "year": 1978}, {"title": "Exploiting coordination locales in distributed POMDPs via social model shaping", "author": ["P. Varakantham", "Kwak", "J. young", "M.E. Taylor", "J. Marecki", "P. Scerri", "M. Tambe"], "venue": "In Proc. of the International Conference on Automated Planning and Scheduling", "citeRegEx": "Varakantham et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Varakantham et al\\.", "year": 2009}, {"title": "Letting loose a SPIDER on a network of POMDPs: Generating quality guaranteed policies", "author": ["P. Varakantham", "J. Marecki", "Y. Yabu", "M. Tambe", "M. Yokoo"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Varakantham et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Varakantham et al\\.", "year": 2007}, {"title": "Winning back the cup for distributed POMDPs: planning over continuous belief spaces", "author": ["P. Varakantham", "R. Nair", "M. Tambe", "M. Yokoo"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Varakantham et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Varakantham et al\\.", "year": 2006}, {"title": "Distributed model shaping for scaling to decentralized POMDPs with hundreds of agents", "author": ["P. Velagapudi", "P. Varakantham", "P. Scerri", "K. Sycara"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Velagapudi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Velagapudi et al\\.", "year": 2011}, {"title": "A Concise Introduction to Multiagent Systems and Distributed Artificial Intelligence", "author": ["N. Vlassis"], "venue": "Morgan & Claypool Publishers.", "citeRegEx": "Vlassis,? 2007", "shortCiteRegEx": "Vlassis", "year": 2007}, {"title": "Reward shaping for valuing communications during multi-agent coordination", "author": ["S.A. Williamson", "E.H. Gerding", "N.R. Jennings"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Williamson et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Williamson et al\\.", "year": 2009}, {"title": "Abstracting Influences for Efficient Multiagent Coordination Under Uncertainty", "author": ["S.J. Witwicki"], "venue": "Unpublished doctoral dissertation, University of Michigan, Ann Arbor, Michigan, USA.", "citeRegEx": "Witwicki,? 2011", "shortCiteRegEx": "Witwicki", "year": 2011}, {"title": "Influence-based policy abstraction for weakly-coupled Dec-POMDPs", "author": ["S.J. Witwicki", "E.H. Durfee"], "venue": "In Proc. of the International Conference on Automated Planning and Scheduling", "citeRegEx": "Witwicki and Durfee,? \\Q2010\\E", "shortCiteRegEx": "Witwicki and Durfee", "year": 2010}, {"title": "Point-based policy generation for decentralized POMDPs", "author": ["F. Wu", "S. Zilberstein", "X. Chen"], "venue": "In Proc. of the International Conference on Autonomous Agents and Multi Agent Systems", "citeRegEx": "Wu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2010}, {"title": "Rollout sampling policy iteration for decentralized POMDPs", "author": ["F. Wu", "S. Zilberstein", "X. Chen"], "venue": "In Proc. of Uncertainty in Artificial Intelligence", "citeRegEx": "Wu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2010}, {"title": "Online planning for multi-agent systems with bounded communication", "author": ["F. Wu", "S. Zilberstein", "X. Chen"], "venue": "Artificial Intelligence,", "citeRegEx": "Wu et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2011}, {"title": "Communication decisions in multi-agent cooperation: Model and experiments", "author": ["P. Xuan", "V. Lesser", "S. Zilberstein"], "venue": "In Proc. of the International Conference on Autonomous Agents", "citeRegEx": "Xuan et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Xuan et al\\.", "year": 2001}, {"title": "A* with partial expansion for large branching factor problems", "author": ["T. Yoshizumi", "T. Miura", "T. Ishida"], "venue": "In Proc. of the National Conference on Artificial Intelligence", "citeRegEx": "Yoshizumi et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Yoshizumi et al\\.", "year": 2000}, {"title": "Exploiting model equivalences for solving interactive dynamic influence diagrams", "author": ["Y. Zeng", "P. Doshi"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Zeng and Doshi,? \\Q2012\\E", "shortCiteRegEx": "Zeng and Doshi", "year": 2012}, {"title": "Utilizing partial policies for identifying equivalence of behavioral models", "author": ["Y. Zeng", "P. Doshi", "Y. Pan", "H. Mao", "M. Chandrasekaran", "J. Luo"], "venue": "In Proceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence", "citeRegEx": "Zeng et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zeng et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 87, "context": "agent (Huhns, 1987; Sycara, 1998; Panait & Luke, 2005; Vlassis, 2007; Bu\u015foniu, Babu\u0161ka, & De Schutter, 2008).", "startOffset": 6, "endOffset": 108}, {"referenceID": 95, "context": "agent (Huhns, 1987; Sycara, 1998; Panait & Luke, 2005; Vlassis, 2007; Bu\u015foniu, Babu\u0161ka, & De Schutter, 2008).", "startOffset": 6, "endOffset": 108}, {"referenceID": 27, "context": "For instance, it may be possible to extrapolate optimal solutions of problems with shorter planning horizons, using them as the starting point of policy search for longer-horizon problems as in the work of Eker and Ak\u0131n (2013), or to use such shorter-horizon, no-communication solutions inside problems with communication (Nair, Roth, & Yohoo, 2004; Goldman & Zilberstein, 2008).", "startOffset": 206, "endOffset": 227}, {"referenceID": 97, "context": "By performing (approximate) influence-based abstraction and influence search (Witwicki, 2011; Oliehoek, Witwicki, & Kaelbling, 2012), optimal solutions of component problems can potentially be used to find (near-)optimal solutions of larger problems.", "startOffset": 77, "endOffset": 132}, {"referenceID": 55, "context": "In fact, almost all successful approximate Dec-POMDP methods are based on optimal ones (see, e.g., Seuken & Zilberstein, 2007b, 2007a; Dibangoye, Mouaddib, & Chai-draa, 2009; Amato, Dibangoye, & Zilberstein, 2009; Wu, Zilberstein, & Chen, 2010a; Oliehoek, 2010) or locally optimal ones (Velagapudi, Varakantham, Scerri, & Sycara, 2011)2, and the clustering technique presented in this article forms the basis of a recently introduced approximate clustering technique (Wu, Zilberstein, & Chen, 2011).", "startOffset": 87, "endOffset": 261}, {"referenceID": 6, "context": "In recent years, there have been huge advances in the approximate solution of Dec-POMDPs, leading to the development of solution methods that can deal with large horizons, hundreds of agents and many states (e.g., Seuken & Zilberstein, 2007b; Amato et al., 2009; Wu et al., 2010a; Oliehoek, 2010; Velagapudi et al., 2011).", "startOffset": 207, "endOffset": 321}, {"referenceID": 55, "context": "In recent years, there have been huge advances in the approximate solution of Dec-POMDPs, leading to the development of solution methods that can deal with large horizons, hundreds of agents and many states (e.g., Seuken & Zilberstein, 2007b; Amato et al., 2009; Wu et al., 2010a; Oliehoek, 2010; Velagapudi et al., 2011).", "startOffset": 207, "endOffset": 321}, {"referenceID": 94, "context": "In recent years, there have been huge advances in the approximate solution of Dec-POMDPs, leading to the development of solution methods that can deal with large horizons, hundreds of agents and many states (e.g., Seuken & Zilberstein, 2007b; Amato et al., 2009; Wu et al., 2010a; Oliehoek, 2010; Velagapudi et al., 2011).", "startOffset": 207, "endOffset": 321}, {"referenceID": 94, "context": "The method by Velagapudi et al. (2011) repeatedly computes best responses in a way similar to DP-JESP (Nair, Tambe, Yokoo, Pynadath, & Marsella, 2003).", "startOffset": 14, "endOffset": 39}, {"referenceID": 79, "context": "Whereas Seuken and Zilberstein (2008) argued that GMAA* can at best optimally solve Dec-POMDPs only one horizon further than brute-force search, our results demonstrate that GMAA*-ICE can do much better.", "startOffset": 8, "endOffset": 38}, {"referenceID": 53, "context": "For explanatory purposes, we also consider a much simpler problem, the so-called decentralized tiger problem (Nair et al., 2003).", "startOffset": 109, "endOffset": 128}, {"referenceID": 52, "context": "For a complete specification, see the discussion by Nair et al. (2003).", "startOffset": 52, "endOffset": 71}, {"referenceID": 77, "context": ", the work of Seuken and Zilberstein (2008) and Oliehoek (2012).", "startOffset": 14, "endOffset": 44}, {"referenceID": 55, "context": ", the work of Seuken and Zilberstein (2008) and Oliehoek (2012).", "startOffset": 48, "endOffset": 64}, {"referenceID": 55, "context": "For a more detailed description, see the work of Oliehoek, Spaan, and Vlassis (2008). For a further description of dynamic programming methods and their relationship to heuristic search methods, see the work of Oliehoek (2012).", "startOffset": 49, "endOffset": 85}, {"referenceID": 55, "context": "For a more detailed description, see the work of Oliehoek, Spaan, and Vlassis (2008). For a further description of dynamic programming methods and their relationship to heuristic search methods, see the work of Oliehoek (2012).", "startOffset": 49, "endOffset": 227}, {"referenceID": 29, "context": "The resulting algorithm, generalized MAA* (GMAA*) offers a unified perspective of MAA* and the forward sweep policy computation method (Emery-Montemerlo, 2005), which differ in how they implement GMAA*\u2019s expand operator: forward sweep policy computation solves (i.", "startOffset": 135, "endOffset": 159}, {"referenceID": 54, "context": "Oliehoek, Spaan, and Vlassis (2008) generalized the algorithm by making explicit the expand and selection operators performed in the heuristic search.", "startOffset": 0, "endOffset": 36}, {"referenceID": 88, "context": "Ranking nodes with greater depth higher in case of equal heuristic value helps find tight lower bounds early by first expanding deeper nodes (Szer et al., 2005) and is also useful in incremental expansion.", "startOffset": 141, "endOffset": 160}, {"referenceID": 88, "context": "Therefore, in theory, GMAA* is guaranteed to eventually produce an optimal joint policy (Szer et al., 2005).", "startOffset": 88, "endOffset": 107}, {"referenceID": 79, "context": "Consequently, Seuken and Zilberstein (2008) conclude that MAA* \u201ccan at best solve problems whose horizon is only 1 greater than those that can already be solved by n\u00e4\u0131ve brute force search.", "startOffset": 14, "endOffset": 44}, {"referenceID": 71, "context": "This approach, known as QMDP (Littman, Cassandra, & Kaelbling, 1995), uses the MDP value function Q M (s t,a), which can be computed using standard dynamic programming techniques (Puterman, 1994).", "startOffset": 179, "endOffset": 195}, {"referenceID": 88, "context": "The resulting solution can be used as a heuristic, called QPOMDP (Szer et al., 2005; Roth, Simmons, & Veloso, 2005).", "startOffset": 65, "endOffset": 115}, {"referenceID": 43, "context": ",V t |A|} (Kaelbling et al., 1998).", "startOffset": 10, "endOffset": 34}, {"referenceID": 39, "context": "Since QMDP is an upper bound on the POMDP value function (Hauskrecht, 2000), QPOMDP provides a tighter upper bound to Q\u2217 than QMDP.", "startOffset": 57, "endOffset": 75}, {"referenceID": 20, "context": "Cassandra, Littman, & Zhang, 1997). To overcome this problem, Oliehoek and Spaan (2012) introduce novel tree-based pruning methods.", "startOffset": 0, "endOffset": 88}, {"referenceID": 29, "context": "9 Previous research has also investigated such clustering: Emery-Montemerlo, Gordon, Schneider, and Thrun (2005) propose clustering types based on the profiles of the payoff functions of the CBGs.", "startOffset": 59, "endOffset": 113}, {"referenceID": 55, "context": "The probabilistic equivalence criterion and lossless clustering were introduced by Oliehoek et al. (2009). This article presents a new, simpler proof of the optimality of clustering based on PE.", "startOffset": 83, "endOffset": 106}, {"referenceID": 43, "context": "It can then use this belief to determine the value of any future policy, as it is a sufficient statistic of the history to predict the future rewards (Kaelbling et al., 1998; Bertsekas, 2005).", "startOffset": 150, "endOffset": 191}, {"referenceID": 13, "context": "It can then use this belief to determine the value of any future policy, as it is a sufficient statistic of the history to predict the future rewards (Kaelbling et al., 1998; Bertsekas, 2005).", "startOffset": 150, "endOffset": 191}, {"referenceID": 55, "context": "For a more extensive treatment of these different forms of policy, we refer to the discussion by Oliehoek (2012). Given these concepts, we can define the value of a \u03c4 = k-stages-to-go joint policy starting from state s: V (s,\u03b3) = R(s,a) + \u2211", "startOffset": 97, "endOffset": 113}, {"referenceID": 55, "context": "The proof originally provided by Oliehoek et al. (2009) is based on showing that histories that are PE will induce identical Q-values.", "startOffset": 33, "endOffset": 56}, {"referenceID": 29, "context": "Emery-Montemerlo et al. (2005) showed how clustering can be incorporated at every stage in their algorithm: when the CBG for a stage t is constructed, a clustering of the individual histories (types) is performed first and only afterwards is the (reduced) CBG solved.", "startOffset": 0, "endOffset": 31}, {"referenceID": 55, "context": "Oliehoek, Spaan, and Vlassis (2008) used a tree-based representation for the QPOMDP and QBG heuristics.", "startOffset": 0, "endOffset": 36}, {"referenceID": 59, "context": "However, this point-based backup can be interpreted as a collection of CBGs (Oliehoek et al., 2010).", "startOffset": 76, "endOffset": 99}, {"referenceID": 44, "context": "Kumar and Zilberstein (2010b) tackle a slightly different problem; they introduce a weighted constraint satisfaction approach to solving the point-based backup in dynamic programming for Dec-POMDPs.", "startOffset": 0, "endOffset": 30}, {"referenceID": 59, "context": "We propose a modification of the BaGaBaB algorithm (Oliehoek et al., 2010), briefly discussed in Section 4.", "startOffset": 51, "endOffset": 74}, {"referenceID": 59, "context": "To this end, we propose to modify the Bayesian game Branch and Bound (BaGaBaB) algorithm (Oliehoek et al., 2010).", "startOffset": 89, "endOffset": 112}, {"referenceID": 44, "context": "An exception may be the method of Kumar and Zilberstein (2010b), which employs AND/OR branch and bound search with the EDAC heuristic (and is thus limited to the two-agent case).", "startOffset": 34, "endOffset": 64}, {"referenceID": 53, "context": "The most well-known Dec-POMDP benchmarks are the Dec-Tiger (Nair et al., 2003) and BroadcastChannel (Hansen et al.", "startOffset": 59, "endOffset": 78}, {"referenceID": 38, "context": ", 2003) and BroadcastChannel (Hansen et al., 2004) problems.", "startOffset": 29, "endOffset": 50}, {"referenceID": 54, "context": "Experiments were run on an Intel Core i5 CPU running Linux, andGMAA*, GMAA*-IC, and GMAA*-ICE were implemented in the same code-base using the MADP Toolbox (C++) (Spaan & Oliehoek, 2008). The vector-based QBG representation is computed using a variation of Incremental Pruning (adapted for computing Q-functions instead of regular value functions), corresponding to the NaiveIP method as described by Oliehoek and Spaan (2012). To implement the pruning, we employ Cassandra\u2019s POMDP-solve software (A.", "startOffset": 171, "endOffset": 427}, {"referenceID": 55, "context": "Consequently, the performance of GMAA*-IC is much better than all previously reported results, including those of Oliehoek et al. (2009), who were often required to resort to QMDP for larger problems and/or horizons.", "startOffset": 114, "endOffset": 137}, {"referenceID": 55, "context": "Note that in some problem domains we report smaller clusterings than Oliehoek et al. (2009). Due to an implementation mistake, their clustering was overly conservative, and did not in all cases treat two histories as probabilistically equivalent, when in fact they were.", "startOffset": 69, "endOffset": 92}, {"referenceID": 6, "context": "DP-IPG (Amato et al., 2009) performs exact dynamic programing with incremental policy", "startOffset": 7, "endOffset": 27}, {"referenceID": 1, "context": "Additionally, for FireFighting and GridSmall, we use the benchmark versions standard to the literature (Oliehoek, Spaan, & Vlassis, 2008; Amato et al., 2006), whereas Aras and Dutech (2010) use non-standard versions.", "startOffset": 103, "endOffset": 157}, {"referenceID": 1, "context": "The results reported here deviate from those reported by Aras and Dutech (2010). For a number of problems, Aras et al.", "startOffset": 57, "endOffset": 80}, {"referenceID": 1, "context": "Additionally, for FireFighting and GridSmall, we use the benchmark versions standard to the literature (Oliehoek, Spaan, & Vlassis, 2008; Amato et al., 2006), whereas Aras and Dutech (2010) use non-standard versions.", "startOffset": 138, "endOffset": 190}, {"referenceID": 1, "context": "Additionally, for FireFighting and GridSmall, we use the benchmark versions standard to the literature (Oliehoek, Spaan, & Vlassis, 2008; Amato et al., 2006), whereas Aras and Dutech (2010) use non-standard versions. This explains the difference between our results and the ones reported in their article (personal communication, Raghav Aras). 21. The goal of Boularias and Chaib-draa (2008) was to find non-dominated joint policies for all initial beliefs.", "startOffset": 138, "endOffset": 392}, {"referenceID": 15, "context": "The DP-LPC algorithm proposed by Boularias and Chaib-draa (2008) also improves the efficiency of optimal solutions by a form of compression.", "startOffset": 33, "endOffset": 65}, {"referenceID": 6, "context": "Table 5, which reports the VMBDP values produced by PBIP-IPG (Amato et al., 2009) (with typical \u2018maxTrees\u2019 parameter settingm), demonstrates that the optimal solutions produced by GMAA*-IC or GMAA*-ICE are of higher quality.", "startOffset": 61, "endOffset": 81}, {"referenceID": 10, "context": "One class of problems where we can say something a priori about the amount of clustering that is possible is the class of Dec-POMDPs with transition and observation independence (Becker et al., 2003).", "startOffset": 178, "endOffset": 199}, {"referenceID": 53, "context": "However, there is yet another notion of belief, employed in the JESP solution method (Nair et al., 2003), that is superficially more similar to the PE distribution.", "startOffset": 85, "endOffset": 104}, {"referenceID": 105, "context": "First, several approaches exploit the notion of behavioral equivalence (Pynadath & Marsella, 2007; Zeng et al., 2011; Zeng & Doshi, 2012).", "startOffset": 71, "endOffset": 137}, {"referenceID": 105, "context": "The notion of utility equivalence (Pynadath & Marsella, 2007; Zeng et al., 2011) is closer to PE because it also takes into account the (value of the) best-response of agent i (in particular, it clusters two models mj and m \u2032 j if using BR(mj)\u2014the best response against mj\u2014 achieves the same value against mj).", "startOffset": 34, "endOffset": 80}, {"referenceID": 28, "context": "In Section 3, we indicated that our clustering method is closely related to the approach of Emery-Montemerlo et al. (2005) but is also fundamentally different because our method is lossless.", "startOffset": 92, "endOffset": 123}, {"referenceID": 15, "context": "3, we discussed connections to the approach of Boularias and Chaib-draa (2008) which clusters policy values.", "startOffset": 47, "endOffset": 79}, {"referenceID": 10, "context": "There are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al.", "startOffset": 78, "endOffset": 163}, {"referenceID": 97, "context": "There are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al.", "startOffset": 78, "endOffset": 163}, {"referenceID": 66, "context": "There are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al.", "startOffset": 78, "endOffset": 163}, {"referenceID": 6, "context": "As part of our evaluation, we compare against the MILP approach (Aras & Dutech, 2010), DPILP (Boularias & Chaib-draa, 2008) and DP-IPG (Amato et al., 2009), an extension of the exact dynamic programming algorithm (Hansen et al.", "startOffset": 135, "endOffset": 155}, {"referenceID": 38, "context": ", 2009), an extension of the exact dynamic programming algorithm (Hansen et al., 2004).", "startOffset": 65, "endOffset": 86}, {"referenceID": 53, "context": "Research on finite-horizon DecPOMDPs has considered many other approaches such as bounded approximations (Amato, Carlin, & Zilberstein, 2007), locally optimal solutions (Nair et al., 2003; Varakantham, Nair, Tambe, & Yokoo, 2006) and approximate methods without guarantees (Seuken & Zilberstein, 2007b, 2007a; Carlin & Zilberstein, 2008; Eker & Ak\u0131n, 2010; Oliehoek, Kooi, & Vlassis, 2008; Dibangoye et al.", "startOffset": 169, "endOffset": 229}, {"referenceID": 23, "context": ", 2003; Varakantham, Nair, Tambe, & Yokoo, 2006) and approximate methods without guarantees (Seuken & Zilberstein, 2007b, 2007a; Carlin & Zilberstein, 2008; Eker & Ak\u0131n, 2010; Oliehoek, Kooi, & Vlassis, 2008; Dibangoye et al., 2009; Kumar & Zilberstein, 2010b; Wu et al., 2010a; Wu, Zilberstein, & Chen, 2010b).", "startOffset": 92, "endOffset": 310}, {"referenceID": 10, "context": "The resulting models, such as the TOI-Dec-MDP (Becker et al., 2003; Dibangoye, Amato, Doniec, & Charpillet, 2013) and NDPOMDP (Nair et al.", "startOffset": 46, "endOffset": 113}, {"referenceID": 54, "context": ", 2003; Dibangoye, Amato, Doniec, & Charpillet, 2013) and NDPOMDP (Nair et al., 2005; Varakantham et al., 2007; Marecki, Gupta, Varakantham, Tambe, & Yokoo, 2008; Kumar & Zilberstein, 2009), can be interpreted as independent (PO)MDPs for", "startOffset": 66, "endOffset": 189}, {"referenceID": 92, "context": ", 2003; Dibangoye, Amato, Doniec, & Charpillet, 2013) and NDPOMDP (Nair et al., 2005; Varakantham et al., 2007; Marecki, Gupta, Varakantham, Tambe, & Yokoo, 2008; Kumar & Zilberstein, 2009), can be interpreted as independent (PO)MDPs for", "startOffset": 66, "endOffset": 189}, {"referenceID": 2, "context": "There are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al., 2003) is a compact representation of the other agents\u2019 policies. Models of the other agents can be clustered if they lead to the same influence on agent i. However, though more fine-grained, this is ultimately still a form of behavioral equivalence. A final relation to our equivalence notion is the work by Dekel, Fudenberg, and Morris (2006), which constructs a distance measure and topology on the space of types with the goal of approximating the infinite universal type space (the space of all possible beliefs about beliefs about beliefs, etc.", "startOffset": 79, "endOffset": 574}, {"referenceID": 2, "context": "There are also connections between PE and work on influence-based abstraction (Becker et al., 2003; Witwicki & Durfee, 2010; Witwicki, 2011; Oliehoek et al., 2012), since the influence (or point in parameter space, Becker et al., 2003) is a compact representation of the other agents\u2019 policies. Models of the other agents can be clustered if they lead to the same influence on agent i. However, though more fine-grained, this is ultimately still a form of behavioral equivalence. A final relation to our equivalence notion is the work by Dekel, Fudenberg, and Morris (2006), which constructs a distance measure and topology on the space of types with the goal of approximating the infinite universal type space (the space of all possible beliefs about beliefs about beliefs, etc.) for one-shot Bayesian games. Our setting, however, considers a simple finite type space where the types directly correspond to the private histories (in the form of AOHs) in a sequential problem. Thus, we do not need to approximate the universal type space; instead we want to know which histories lead to the same future dynamics from the perspective of an agent. Dekel et al.\u2019s topology does not address this question. Our incremental expansion technique is related to approaches extending A\u2217 to deal with large branching factors in the context of multiple sequence alignment (Ikeda & Imai, 1999; Yoshizumi, Miura, & Ishida, 2000). However, our approach is different because we do not discard unpromising nodes but rather provide a mechanism to generate only the necessary ones. Also, when proposing MAA*, Szer et al. (2005) developed a superficially similar approach that could be applied only to the last stage.", "startOffset": 79, "endOffset": 1608}, {"referenceID": 9, "context": "On the other hand, event-driven interaction models (Becker et al., 2004) consider agents that have individual rewards but can influence each other\u2019s transitions.", "startOffset": 51, "endOffset": 72}, {"referenceID": 91, "context": "Examples are interaction-driven Markov games (Spaan & Melo, 2008), DecMDPs with sparse interactions (Melo & Veloso, 2011), distributed POMDPs with coordination locales (Varakantham et al., 2009; Velagapudi et al., 2011), event-driven interactions with complex rewards (EDI-CR) (Mostafa & Lesser, 2011), and transition decoupled Dec-POMDPs (Witwicki & Durfee, 2010; Witwicki, 2011).", "startOffset": 168, "endOffset": 219}, {"referenceID": 94, "context": "Examples are interaction-driven Markov games (Spaan & Melo, 2008), DecMDPs with sparse interactions (Melo & Veloso, 2011), distributed POMDPs with coordination locales (Varakantham et al., 2009; Velagapudi et al., 2011), event-driven interactions with complex rewards (EDI-CR) (Mostafa & Lesser, 2011), and transition decoupled Dec-POMDPs (Witwicki & Durfee, 2010; Witwicki, 2011).", "startOffset": 168, "endOffset": 219}, {"referenceID": 97, "context": ", 2011), event-driven interactions with complex rewards (EDI-CR) (Mostafa & Lesser, 2011), and transition decoupled Dec-POMDPs (Witwicki & Durfee, 2010; Witwicki, 2011).", "startOffset": 127, "endOffset": 168}, {"referenceID": 12, "context": "Also, since the infinite-horizon case is undecidable (Bernstein et al., 2002), the approaches are approximate or optimal given a particular controller size.", "startOffset": 53, "endOffset": 77}, {"referenceID": 11, "context": "While there exists a boundedly optimal approach that can theoretically construct a controller within any \u01eb of optimal, it is only feasible for very small problems or a large \u01eb (Bernstein et al., 2009).", "startOffset": 176, "endOffset": 200}, {"referenceID": 52, "context": ", broadcasting the local observations) (Ooi & Wornell, 1996; Pynadath & Tambe, 2002; Nair et al., 2004; Roth et al., 2005; Oliehoek, Spaan, & Vlassis, 2007; Roth, Simmons, & Veloso, 2007; Spaan, Oliehoek, & Vlassis, 2008; Goldman & Zilberstein, 2008; Becker, Carlin, Lesser, & Zilberstein, 2009; Williamson, Gerding, & Jennings, 2009; Wu et al., 2011).", "startOffset": 39, "endOffset": 351}, {"referenceID": 77, "context": ", broadcasting the local observations) (Ooi & Wornell, 1996; Pynadath & Tambe, 2002; Nair et al., 2004; Roth et al., 2005; Oliehoek, Spaan, & Vlassis, 2007; Roth, Simmons, & Veloso, 2007; Spaan, Oliehoek, & Vlassis, 2008; Goldman & Zilberstein, 2008; Becker, Carlin, Lesser, & Zilberstein, 2009; Williamson, Gerding, & Jennings, 2009; Wu et al., 2011).", "startOffset": 39, "endOffset": 351}, {"referenceID": 101, "context": ", broadcasting the local observations) (Ooi & Wornell, 1996; Pynadath & Tambe, 2002; Nair et al., 2004; Roth et al., 2005; Oliehoek, Spaan, & Vlassis, 2007; Roth, Simmons, & Veloso, 2007; Spaan, Oliehoek, & Vlassis, 2008; Goldman & Zilberstein, 2008; Becker, Carlin, Lesser, & Zilberstein, 2009; Williamson, Gerding, & Jennings, 2009; Wu et al., 2011).", "startOffset": 39, "endOffset": 351}, {"referenceID": 38, "context": "Finally, there are numerous models closely related to Dec-POMDPs, such as POSGs (Hansen et al., 2004), interactive POMDPs (I-POMDPs) (Gmytrasiewicz & Doshi, 2005), and their graphical counterparts (Doshi, Zeng, & Chen, 2008).", "startOffset": 80, "endOffset": 101}, {"referenceID": 8, "context": "On the other hand, event-driven interaction models (Becker et al., 2004) consider agents that have individual rewards but can influence each other\u2019s transitions. More recently, models that allow for limited transition and reward dependence have been introduced. Examples are interaction-driven Markov games (Spaan & Melo, 2008), DecMDPs with sparse interactions (Melo & Veloso, 2011), distributed POMDPs with coordination locales (Varakantham et al., 2009; Velagapudi et al., 2011), event-driven interactions with complex rewards (EDI-CR) (Mostafa & Lesser, 2011), and transition decoupled Dec-POMDPs (Witwicki & Durfee, 2010; Witwicki, 2011). While the methods developed for these models often exhibit better scaling behavior than methods for standard Dec-(PO)MDPs, they typically are not suitable when agents have extended interactions, e.g., to collaborate in transporting an item. Also, there have been specialized models that consider the timing of actions whose ordering is already determined (Marecki & Tambe, 2007; Beynier & Mouaddib, 2011). Another body of work addresses infinite-horizon problems (Amato, Bernstein, & Zilberstein, 2010; Amato, Bonet, & Zilberstein, 2010; Bernstein, Amato, Hansen, & Zilberstein, 2009; Kumar & Zilberstein, 2010a; Pajarinen & Peltonen, 2011), in which it is not possible to represent a policy as a tree. These approaches represent policies using finite-state controllers that are then optimized in various ways. Also, since the infinite-horizon case is undecidable (Bernstein et al., 2002), the approaches are approximate or optimal given a particular controller size. While there exists a boundedly optimal approach that can theoretically construct a controller within any \u01eb of optimal, it is only feasible for very small problems or a large \u01eb (Bernstein et al., 2009). There has also been great interest in Dec-POMDPs that explicitly take into account communication. Some approaches try to optimize the meaning of communication actions without semantics (Xuan, Lesser, & Zilberstein, 2001; Goldman & Zilberstein, 2003; Spaan, Gordon, & Vlassis, 2006; Goldman, Allen, & Zilberstein, 2007) while others use fixed semantics (e.g., broadcasting the local observations) (Ooi & Wornell, 1996; Pynadath & Tambe, 2002; Nair et al., 2004; Roth et al., 2005; Oliehoek, Spaan, & Vlassis, 2007; Roth, Simmons, & Veloso, 2007; Spaan, Oliehoek, & Vlassis, 2008; Goldman & Zilberstein, 2008; Becker, Carlin, Lesser, & Zilberstein, 2009; Williamson, Gerding, & Jennings, 2009; Wu et al., 2011). Since models used in the first category (e.g., the Dec-POMDP-Com) can be converted to normal Dec-POMDPs (Seuken & Zilberstein, 2008), the contributions of this article are applicable to those settings. Finally, there are numerous models closely related to Dec-POMDPs, such as POSGs (Hansen et al., 2004), interactive POMDPs (I-POMDPs) (Gmytrasiewicz & Doshi, 2005), and their graphical counterparts (Doshi, Zeng, & Chen, 2008). These models are more general in the sense that they consider self-interested settings where each agent has an individual reward function. I-POMDPs are conjectured to also require doubly exponential time (Seuken & Zilberstein, 2008). However, for the I-POMDP there have been a number of recent advances (Doshi & Gmytrasiewicz, 2009). The current paper makes a clear link between best-response equivalence of histories and the notion of best-response equivalence of beliefs in I-POMDPs. In particular, this article demonstrates that two PE action-observation histories (AOHs) induce, given only a past joint policy, a distribution over states and AOHs of other agents, and therefore will induce the same multiagent belief for any future policies of other agents. These induced multiagent beliefs, in turn, can be interpreted as special cases of I-POMDP beliefs where the model of the other agents are sub-intentional models in the form of a fixed policy tree. Rabinovich and Rosenschein (2005) introduced a method that, rather than optimizing", "startOffset": 52, "endOffset": 3945}, {"referenceID": 55, "context": ", 2010a), integrating GMAA* methods for factored Dec-POMDPs (Oliehoek, Spaan, Whiteson, & Vlassis, 2008; Oliehoek, 2010; Oliehoek et al., 2013), performing lossy clustering (Emery-Montemerlo, 2005; Wu et al.", "startOffset": 60, "endOffset": 143}, {"referenceID": 65, "context": ", 2010a), integrating GMAA* methods for factored Dec-POMDPs (Oliehoek, Spaan, Whiteson, & Vlassis, 2008; Oliehoek, 2010; Oliehoek et al., 2013), performing lossy clustering (Emery-Montemerlo, 2005; Wu et al.", "startOffset": 60, "endOffset": 143}, {"referenceID": 29, "context": ", 2013), performing lossy clustering (Emery-Montemerlo, 2005; Wu et al., 2011) or using bounded approximations for the heuristics.", "startOffset": 37, "endOffset": 78}, {"referenceID": 101, "context": ", 2013), performing lossy clustering (Emery-Montemerlo, 2005; Wu et al., 2011) or using bounded approximations for the heuristics.", "startOffset": 37, "endOffset": 78}, {"referenceID": 101, "context": "In addition to facilitating optimal solutions, we hope these advances will inspire new principled approximation methods, as incremental clustering has already done (Wu et al., 2011), and enable them to be meaningfully benchmarked.", "startOffset": 164, "endOffset": 181}], "year": 2013, "abstractText": "This article presents the state-of-the-art in optimal solution methods for decentralized partially observable Markov decision processes (Dec-POMDPs), which are general models for collaborative multiagent planning under uncertainty. Building off the generalized multiagent A* (GMAA*) algorithm, which reduces the problem to a tree of one-shot collaborative Bayesian games (CBGs), we describe several advances that greatly expand the range of DecPOMDPs that can be solved optimally. First, we introduce lossless incremental clustering of the CBGs solved by GMAA*, which achieves exponential speedups without sacrificing optimality. Second, we introduce incremental expansion of nodes in the GMAA* search tree, which avoids the need to expand all children, the number of which is in the worst case doubly exponential in the node\u2019s depth. This is particularly beneficial when little clustering is possible. In addition, we introduce new hybrid heuristic representations that are more compact and thereby enable the solution of larger Dec-POMDPs. We provide theoretical guarantees that, when a suitable heuristic is used, both incremental clustering and incremental expansion yield algorithms that are both complete and search equivalent. Finally, we present extensive empirical results demonstrating that GMAA*-ICE, an algorithm that synthesizes these advances, can optimally solve Dec-POMDPs of unprecedented size.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}