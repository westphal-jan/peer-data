{"id": "1402.0568", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Boolean Equi-propagation for Concise and Efficient SAT Encodings of Combinatorial Problems", "abstract": "We present an approach to dispersion-based SAT coding of combinatorial problems, the Boolean equipropagation, in which constraints are modeled as Boolean functions that disseminate information about equality between Boolean literals. This information is then applied to simplify the CNF coding of constraints. A key factor is that taking into account only a small fragment of a constraint model allows us to apply stronger and even complete reasoning to recognize equivalent literals in that fragment. Once recognized, equivalences apply to simplify the entire constraint model and facilitate further reflection on other fragments. The dispersion of the equivalents, combined with partial evaluation and simplification of constraints, form the basis for a powerful approach to SAT-based solution of finite domain constraints. We introduce a tool called BEE (Ben-Gurion Equi coding) that enables us to demonstrate a variety of coding ideas based on these codes, and demonstrate a variety of coding solutions.", "histories": [["v1", "Tue, 4 Feb 2014 01:36:36 GMT  (701kb)", "http://arxiv.org/abs/1402.0568v1", "arXiv admin note: text overlap witharXiv:1206.3883"]], "COMMENTS": "arXiv admin note: text overlap witharXiv:1206.3883", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["amit metodi", "michael codish", "peter james stuckey"], "accepted": false, "id": "1402.0568"}, "pdf": {"name": "1402.0568.pdf", "metadata": {"source": "CRF", "title": "Boolean Equi-propagation for Concise and Efficient SAT Encodings of Combinatorial Problems", "authors": ["Amit Metodi", "Michael Codish", "Peter J. Stuckey"], "emails": ["amit.metodi@gmail.com", "mcodish@cs.bgu.ac.il", "pjs@csse.unimelb.edu.au"], "sections": [{"heading": "1. Introduction", "text": "In recent years, Boolean SAT solving techniques have improved dramatically. Today\u2019s SAT solvers are considerably faster and able to manage larger instances than yesterday\u2019s. Moreover, encoding and modeling techniques are better understood and increasingly innovative. SAT is currently applied to solve a wide variety of hard and practical combinatorial problems, often outperforming dedicated algorithms. The general idea is to encode a (typically, NP) hard problem instance, \u00b5, to a Boolean formula, \u03d5\u00b5, such that the satisfying assignments of \u03d5\u00b5 correspond to the solutions of \u00b5. Given such an encoding, a SAT solver can be applied to solve \u00b5.\nTailgating the success of SAT technology are a variety of tools which can be applied to specify and then compile problem instances to corresponding SAT instances. The general objective of such tools is to facilitate the process of providing high-level descriptions of how the (constraint) problem at hand is to be solved. Typically, a constraint-based modeling language is introduced and used to model instances. Drawing on the analogy to programming languages, given such a description, a compiler can then provide a low-level executable\nc\u00a92013 AI Access Foundation. All rights reserved.\nfor the underlying machine. Namely, in our context, a formula for the underlying SAT or SMT solver.\nFor example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (Ee\u0301n & So\u0308rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010).\nSimplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), Ee\u0301n and Biere (2005), Heule, Ja\u0308rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work. All of these techniques exhibit a clear trade-off between the amount of simplification obtained and the time it requires. Moreover, the stronger techniques become prohibitive when the SAT model involves hundreds of thousands of variables and millions of clauses. So in CNF simplification tools, time limits on simplification techniques are imposed and/or approximations are used.\nThis paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific problem domain. When SAT solving is applied to encode and solve finite domain constraint problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints provides important structural information that can be applied to drive the process of CNF simplification. To be specific, the constraints in a model induce a partitioning of their CNF encoding to a conjunction of sub-formulae which we call \u201cportions\u201d.\nThe novelty in our approach to CNF simplification is that instead of considering the CNF as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the portions and this information may trigger further simplification in other portions.\nBecause portions are typically much smaller than the entire CNF we can effectively apply stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to how unit propagation is about inferring unit clauses which can then be applied to simplify CNF formulae, equi-propagation is about inferring equational consequences between literals (and Boolean constants).\nThere is a wide body of research on CNF simplification that can be applied to implement equi-propagation which is sometimes called equivalent literal substitution, for example by Gelder (2005). Techniques typically involve binary clause based simplifications using, among others, hyper binary resolution and binary implication graphs. See for example, the work of Heule et al. (2011) and the references therein. The guiding principle in all of these works\nis that techniques must be simple and efficient because of the prohibitive size of the CNF to which they must apply.\nOur approach is different and we focus on far richer forms of inference not even related to the CNF structure of a formula. At one extreme we apply complete equi-propagation which detects all equivalences implied by a formula. Clearly complete equi-propagation is NP-hard. However, complete equi-propagators are feasible as we apply them only to small portions of the formula. When complete equi-propagation is too slow we consider ad-hoc techniques. All of these forms of equi-propagation have in common that they are not driven by the CNF structure (e.g. binary clauses) but rather by the underlying constraint structure from which a CNF was, or is being, generated.\nThe rest of this paper is structured as follows. Section 2 introduces a modeling language for finite domain constraints which consists of just 5 constraint constructs and is sufficient to illustrate the contribution of the paper. We argue that the constraints in a model induce a natural partition of their CNF encoding to smaller portions and that this partition can be used to drive the simplification of the CNF encoding. Section 3 presents equi-propagation which is the first ingredient for our contribution. Equi-propagation is about learning information that will apply to simplify CNF encodings. Section 4 describes a practical basis for implementing equi-propagation. Section 5 introduces the second ingredient: partial evaluation. Given the information derived using equi-propagation, partial evaluation applies to simplify the constraints and in particular to remove Boolean variables from their CNF encodings. Section 6 describes a tool, called BEE (Metodi & Codish, 2012) (Ben-Gurion Equi-propagation Encoder) that is based on equi-propagation and partial evaluation. We introduce here our full constraint language which is similar to Sugar and to the subset of FlatZinc relevant for finite domain constraint problems. We also spell out the special treatment of the all-different constraint in BEE. Section 7 demonstrates the application of BEE. Section 8 presents an experimental evaluation. and Finally Section 9 presents our conclusion.\nThis paper extends earlier work presented by Metodi, Codish, Lagoon, and Stuckey (2011), which first introduced equi-propagation, and also the BEE tool paper (Metodi & Codish, 2012). The BEE tool is available for download (Metodi, 2012)."}, {"heading": "2. Constraint Based Boolean Modeling", "text": "This section provides the basis for our contribution: a constraint-based modeling language, together with a Boolean interpretation for each constraint in the language. This enables us to view a constraint model as a conjunction of Boolean formulae and provides a structure which drives the subsequent encoding to CNF.\nWe first introduce a simple and small fragment of a typical finite domain constraint-based modeling language. This serves to illustrate our approach. Later, in Section 6, we show the full language. We then discuss several options for Boolean representation of integers. In this paper we adopt a particular unary representation, called the order encoding. Our contribution is independent of this choice, although equi-propagation works well with it. Finally we finish the section so that each of the constraints in the language fragment can be viewed as a Boolean formula, and a constraint model as their conjunction."}, {"heading": "2.1 Constraint Language Fragment", "text": "We focus on a small fragment of a typical constraint modeling language detailed in Figure 1. This serves to present the main ideas of the paper. Constraint (1) is about declaring finite domain integer variables in the range [c1...c2]. For simplicity in the presentation we will further assume that c1 \u2265 0. Constraints (2\u20133) are about difference of integer variables, and constraints (4\u20135) are about sums of integer variables. As syntactic sugar we also allow writing integer constants in constraints. For example, int neq(I, 5) which is short for new int(I\u2032, 5, 5), int neq(I, I\u2032)."}, {"heading": "2.2 Modeling Kakuro: an Example", "text": "A Kakuro puzzle is an n\u00d7m board of black and white cells. The black cells contain hints and the white cells are to be filled by numbers between 1 and 9 (the bound 9 is often generalized by a larger value r). The hints specify constraints on the sums of the values in blocks of white cells to the right and/or below the hint. The numbers assigned to the white cells in such a block are required to be \u201call different\u201d. Figure 2 illustrates a 4 \u00d7 4 Kakuro puzzle (left) and its solution (right).\nTo model a Kakuro puzzle we view it as a set of blocks (of white cells) where each block B is a set of integer variables and is associated with a corresponding integer value, hint(B). Each block B is associated with two constraints: the integers in B must sum to hint(B) and must be all-different. Figure 3 illustrates the constraints corresponding to the Kakuro instance in Figure 2."}, {"heading": "2.3 Representing Integers", "text": "A fundamental design choice when encoding finite domain constraints concerns the representation of integer variables. Gavanelli (2007) surveys several of the possible choices (the\ndirect-, support- and log- encodings) and introduces the log-support encoding. Given a choice of representation constraints are bit-blasted and interpreted as Boolean formulae. We focus for now on the use a unary representation, the so-called, order-encoding (see, e.g. Crawford & Baker, 1994; Bailleux & Boufkhad, 2003) which has many nice properties when applied to small finite domains.\nIn the order-encoding, an integer variable X in the domain [0, . . . , n] is represented by a bit vector X = [x1, . . . , xn]. Each bit xi is interpreted as X \u2265 i so in particular the bit sequence X constitutes a monotonic non-increasing Boolean sequence. For example, the value 3 in the interval [0, 5] is represented in 5 bits as [1, 1, 1, 0, 0].\nAn important property of a Boolean representation for finite domain integers is the ability to represent changes in the set of values a variable can take. It is well-known that the order-encoding facilitates the propagation of bounds. Consider an integer variable X = [x1, . . . , xn] with values in the interval [0, n]. To restrict X to take values in the range [a, b] (for 1 \u2264 a \u2264 b \u2264 n), it is sufficient to assign xa = 1 and xb+1 = 0 (if b < n). The variables xa\u2032 and xb\u2032 for 0 \u2265 a\u2032 > a and b < b\u2032 \u2264 n are then determined true and false, respectively, by unit propagation. For example, given X = [x1, . . . , x9], assigning x3 = 1 and x6 = 0 propagates to give X = [1, 1, 1, x4, x5, 0, 0, 0, 0], signifying that dom(X) = {3, 4, 5}.\nWe observe an additional property of the order-encoding for X = [x1, . . . , xn]: its ability to specify that a variable cannot take a specific value 0 \u2264 v \u2264 n in its domain by equating two variables: xv = xv+1. This indicates that the order-encoding is well-suited not only to propagate lower and upper bounds, but also to represent integer variables with an arbitrary, finite set, domain. For example, given X = [x1, . . . , x9], equating x2 = x3 imposes that X 6= 2. Likewise x5 = x6 and x7 = x8 impose that X 6= 5 and X 6= 7. Applying these equalities to X gives, X = [x1, x2, x2, x4, x5, x5, x7, x7, x9] (note the repeated literals), signifying that dom(X) = {0, 1, 3, 4, 6, 8, 9}.\nThe order-encoding has many additional nice features that can be exploited to simplify constraints and their encodings to CNF. To illustrate one, consider a constraint of the form A + B = 5 where A and B are integer values in the range between 0 and 5 represented in the order-encoding. At the bit level (in the order encoding) we have: A = [a1, . . . , a5] and B = [b1, . . . , b5]. The constraint is satisfied precisely when B = [\u00aca5, . . . ,\u00aca1]. Instead of encoding the constraint to CNF, we substitute the bits b1, . . . , b5 by the literals \u00aca5, . . . ,\u00aca1, and remove the constraint. In section 3 we formalize this process of discovering equalities between literals implied by a constraint and using them to simplify CNF encodings."}, {"heading": "2.4 Bit Blasting", "text": "Given a constraint model and the decision on how to represent finite domain integer variables at the bit level (we chose the order encoding), \u201cbit-blasting\u201d is the process of instantiating integer variables by corresponding bit vectors and interpreting constraints as Boolean formulae.\nEach integer variable, I, declared by a constraint of the form new int(I, c1, c2) where 0 \u2264 c1 \u2264 c2 is represented as a bit-vector I = [1, . . . , 1, Xc1+1, . . . , Xc2 ]. So, we may view a constraint model as consisting only of Boolean variables and each constraint c corresponds to a Boolean formula denoted as [[c]], the \u201cbit-blasted\u201d version of c. The specific definition of [[\u00b7]] is not important. Just for illustration, note that one could define\n[[new int(I, c1, c2)]] = \u2227\nc1\u2264i<c2\n(xi+1 \u2192 xi)\nwhere I = [1, . . . , 1, Xc1+1, . . . , Xc2 ] as well as\n[[int neq(I1, I2)]] = n\u2228 i=1 (xi xor yi)\nwhere to simplify presentation we assume that I1 = [x1, . . . , xn] and I2 = [y1, . . . , yn] are represented in the same number of bits. The mapping [[\u00b7]] extends in the natural way to apply to conjunctions of constraints. So, given a constraint model such as the one in Figure 3, integer variables are instantiated to unary (order encoding) bit vectors and each constraint is viewed as a Boolean formula. The constraint model takes a Boolean representation as the conjunction of these formulae."}, {"heading": "3. Boolean Equi-propagation", "text": "In this section we present an approach to propagation-based SAT encoding, Boolean equipropagation, which propagates information about equalities between Boolean literals (and constants). We prove that Boolean equi-propagation is stronger than unit propagation as it determines at least as many fixed literals as unit propagation. We demonstrate, with an example, the power of equi-propagation and show that it leads to a considerable reduction in the size of the CNF encoding."}, {"heading": "3.1 Boolean Equi-propagation", "text": "Let B be a set of Boolean variables. A literal is a Boolean variable b \u2208 B or its negation \u00acb. The negation of a literal `, denoted \u00ac`, is defined as \u00acb if ` = b and as b if ` = \u00acb. The Boolean constants 1 and 0 represent true and false, respectively. The set of literals is denoted L and L0,1 = L \u222a {0, 1}. The set of (free) Boolean variables that appear in a Boolean formula \u03d5 is denoted vars(\u03d5). We extend the vars function to sets of formulae in the natural way.\nAn assignment, A, is a partial mapping from Boolean variables to constants, often viewed as the following set of literals: { b \u2223\u2223 A(b) = 1 }\u222a { \u00acb \u2223\u2223 A(b) = 0 }. For a formula \u03d5 and b \u2208 B, we denote by \u03d5[b] (likewise \u03d5[\u00acb]) the formula obtained by substituting all\noccurrences of b \u2208 B in \u03d5 by true (false). This notation extends in the natural way for sets of literals. We say that A satisfies \u03d5 if vars(\u03d5) \u2286 vars(A) and \u03d5[A] evaluates to true. A Boolean Satisfiability (SAT) problem consists of a Boolean formula \u03d5 and determines if there exists an assignment which satisfies \u03d5.\nA Boolean equality is a constraint ` = `\u2032 where `, `\u2032 \u2208 L0,1. An equi-formula E is a set of Boolean equalities understood as a conjunction. The set of Boolean equalities is denoted Leq0,1 and the set of equi-formulae is denoted E .\nExample 1. Suppose B = {x, y, z}. Then L0,1 = {0, 1,\u00acx, x,\u00acy, y,\u00acz, x}. An example assignment is A = {x,\u00acz}, while B = {x, y, z,\u00acy} is not an assignment (since it includes {y,\u00acy}). Given the formula \u03d5 = x \u2194 (y \u2228 \u00acz) then \u03d5[\u00acx] is the formula 0 \u2194 (y \u2228 \u00acz) or equivalently \u00acy\u2227 z. The formula \u03d5[A] = 1\u2194 (y\u2228 1) which is equivalent to true, but A does not satisfy \u03d5 since vars(\u03d5) = {x, y, z} 6\u2286 {x, z} = vars(A). An example equi-formula for B is {x = 0, y = \u00acz} or equivalently \u00acx \u2227 (y \u2194 \u00acz)."}, {"heading": "3.1.1 Equi-propagation", "text": "is a process of inferring equational consequences from a Boolean formula and given equational information. An equi-propagator for a formula \u03d5 is an extensive function \u00b5\u03d5 : E \u2192 E defined such that for all E \u2208 E ,\nE \u2286 \u00b5\u03d5(E) \u2286 { e \u2208 Leq0,1 \u2223\u2223 \u03d5 \u2227 E |= e } That is, a conjunction of equalities, at least as strong as E, made true by \u03d5 \u2227 E. We say that an equi-propagator \u00b5\u03d5 is complete if \u00b5\u03d5(E) = { e \u2208 Leq0,1\n\u2223\u2223 \u03d5 \u2227 E |= e }. We denote a complete equi-propagator for \u03d5 as \u00b5\u0302\u03d5. We assume that equi-propagators are monotonic: E1 \u2286 E2 \u21d2 \u00b5\u03d5(E1) \u2286 \u00b5\u03d5(E2). In particular, this follows, by definition, for complete equi-propagators. In Section 3.3 we discuss several methods to implement complete and incomplete equi-propagators.\nExample 2. Consider the constraint\nC = new int(X, 0, 4) \u2227 new int(Y, 0, 4) \u2227 int neq(X, Y)\nand its corresponding Boolean representation \u03d5 = [[C]] on the bit representation where\nX = [x1, x2, x3, x4] and Y = [y1, y2, y3, y4]\nAssume the setting where E = { y1 = 1, y2 = 1, y3 = 0, y4 = 0 } signifying that Y = 2. Then, \u00b5\u0302\u03d5(E) = E \u222a {x2 = x3} indicating that X 6= 2. This occurs since \u03d5\u2227E is equivalent to (x2 \u2192 x1)\u2227 (x3 \u2192 x2)\u2227 (x4 \u2192 x3)\u2227 (\u00acx1 \u2228\u00acx2 \u2228 x3 \u2228 x4) and \u03d5 \u2227 E |= x2 = x3.\nThe following theorem states that complete equi-propagation is at least as powerful as unit propagation.\nTheorem 3. Let \u00b5\u0302\u03d5 be a complete equi-propagator for a Boolean formula \u03d5. Then, any literal that is made true by unit propagation for any clausal representation of \u03d5 using the equations in E is also determined true by \u00b5\u0302\u03d5(E).\nProof. Let \u03d5 be a Boolean formula, E an equi-formula, and let C\u03d5 and CE be any clausal representations of \u03d5 and of E respectively. Clearly \u03d5 |= C\u03d5 and E |= CE . Let b be a positive literal determined by unit propagation of C\u03d5 \u222a CE . Then by correctness of unit propagation, C\u03d5 \u222a CE |= b. Hence, \u03d5 \u2227 E |= b and thus \u00b5\u0302\u03d5(E) |= b = 1. The case for a negative literal \u00acb is the same, except that we infer b = 0.\nThe following example illustrates that equi-propagation can be more powerful than unit propagation.\nExample 4. Consider \u03d5 = (x1 \u2194 x2) \u2227 (x1 \u2228 x2) \u2227 (\u00acx1 \u2228 \u00acx2 \u2228 \u00acx3). The clausal representation is (x1\u2228\u00acx2)\u2227(\u00acx1\u2228x2)\u2227(x1\u2228x2)\u2227(\u00acx1\u2228\u00acx2\u2228\u00acx3) and no unit propagation is possible, since there are no unit clauses. Equi-propagation (with no additional equational information) gives: \u00b5\u0302\u03d5(\u2205) = {x1 = 1, x2 = 1, x3 = 0}."}, {"heading": "3.1.2 Boolean Unifiers", "text": "It is sometimes convenient to view an equi-formula E in a generic \u201csolved-form\u201d as a Boolean substitution, \u03b8E , which is a (most general) unifier for the equations in E. Boolean substitutions generalize assignments in that variables can be bound also to literals. A Boolean substitution is an idempotent mapping \u03b8 : B \u2192 L0,1 where dom(\u03b8) = { b \u2208 B\n\u2223\u2223 \u03b8(b) 6= b } is finite. Note in particular that idempotence implies that \u03b8(b) 6= \u00acb for every b \u2208 B. Note also that \u03b8 is defined for all B and that its domain, dom(\u03b8), includes those elements for which it is non-identity. A Boolean substitution, \u03b8, is viewed as the set \u03b8 ={ b 7\u2192 \u03b8(b)\n\u2223\u2223 b \u2208 dom(\u03b8) }. We can apply \u03b8 to another substitution \u03b8\u2032, to obtain substitution (\u03b8 \u25e6 \u03b8\u2032) = { b 7\u2192 \u03b8(\u03b8\u2032(b))\n\u2223\u2223 b \u2208 dom(\u03b8) \u222a dom(\u03b8\u2032) }. A unifier for equi-formula E is a substitution \u03b8 such that |= \u03b8(e), for each e \u2208 E. A most-general unifier for E is a substitution \u03b8 such that for any unifier \u03b8\u2032 of E, there exists substitution \u03b3 where \u03b8\u2032 = \u03b3 \u25e6 \u03b8.\nExample 5. Consider the equi-formula E \u2261 {b1 = \u00acb2,\u00acb3 = \u00acb4, b5 = b6, b6 = b4, b7 = 1, b8 = \u00acb7} then a unifier \u03b8 for E is {b2 7\u2192 \u00acb1, b4 7\u2192 b3, b5 7\u2192 b3, b6 7\u2192 b3, b7 7\u2192 1, b8 7\u2192 0}. Note that \u03b8(E) is the trivially true equi-formula {b1 = \u00ac\u00acb1,\u00acb3 = \u00acb3, b3 = b3, b3 = b3, 1 = 1, 0 = \u00ac1}.\nConsider the enumeration L0,1 = {0, 1,\u00acb1, b1,\u00acb2, b2, . . .} and let \u227a be the total (strict) order on L0,1 such that 0 \u227a 1 \u227a \u00acb1 \u227a b1 \u227a \u00acb2 \u227a b2 \u00b7 \u00b7 \u00b7 . We define a canonical most-general unifier unifyE for any satisfiable equi-formula E where:\nunifyE(b) = min { ` \u2208 L0,1 \u2223\u2223 E |= b = ` } That is, the substitution unifyE maps each b to the smallest literal equivalent to b given E. We can compute unifyE in almost linear (amortized) time using a variation of the union-find algorithm (Tarjan, 1975).\nExample 6. For the equi-formula E and substitution \u03b8 from Example 5 we have that unifyE = \u03b8.\nThe following proposition provides the foundation for equi-propagation based Boolean simplification. It allows us to apply equational information to simplify a given formula. In particular, if E is an equi-formula about literals occurring in \u03d5 then unifyE(\u03d5) is smaller than \u03d5 in that it contains fewer variables.\nProposition 1. Let \u03d5 be a Boolean formula and E \u2208 E be a satisfiable equi-formula. Then,\na. \u03d5 \u2227 E \u2194 unifyE(\u03d5) \u2227 E;\nb. \u03d5 \u2227 E is satisfiable if and only if unifyE(\u03d5) is satisfiable; and\nc. if \u03c3 is a satisfying assignment for unifyE(\u03d5) then \u03c3\u25e6unifyE is a satisfying assignment for \u03d5 \u2227 E.\nProof. (a) Let \u03b8 = unifyE and assume that \u03c3 is a satisfying assignment of E, then we can view \u03c3 as a substitution, and as a unifier of E. Hence, since \u03b8 is a most general unifier, there exists a substitution \u03b3 such that \u03c3 = \u03b3\u25e6\u03b8. Clearly \u03b3(b) = \u03c3(b) for all variables b in the range of \u03b8. Hence, \u03c3 and \u03b3 agree on all variables in \u03b8(\u03d5) which implies that \u03c3(\u03b8(\u03d5)) = \u03b3(\u03b8(\u03d5)) meaning that \u03c3(\u03b8(\u03d5)) = \u03c3(\u03d5). So, \u03c3 is a satisfying assignment of \u03b8(\u03d5) \u2227 E if and only if \u03c3 is a satisfying assignment of \u03d5 \u2227 E. (b) The (\u2192) direction follows from (a) and the (\u2190) direction from (c). (c) Assume \u03c3 is a satisfying assignment of unifyE(\u03d5). Clearly \u03c3 \u25e6 unifyE satisfies \u03d5 by construction. Also \u03c3 \u25e6 unifyE satisfies E since unifyE(E) is trivial. Hence \u03c3 \u25e6 unifyE is a satisfying assignment of \u03d5 \u2227 E."}, {"heading": "3.1.3 The Equi-propagation Process", "text": "The equi-propagation process presented now is a central theme in this paper: Let \u03a6 = \u03d51 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d5n be a partitioning of a Boolean formula to n portions, let \u00b5\u03d51 , . . . , \u00b5\u03d5n be corresponding equi-propagators, and take initial E = \u2205. Satisfiability of \u03a6 can be determined as follows:\n1. So long as possible, select \u03d5i such that \u00b5\u03d5i(E) ) E and update E = \u00b5\u03d5i(E).\n2. Finally, when the equi-propagators apply no more, check if unifyE(\u03a6) is satisfiable.\n3. If \u03b7 is a satisfying assignment for unifyE(\u03a6) then unifyE \u25e6\u03b7 is a satisfying assignment for \u03a6.\nWe typically apply this equi-propagation theme to the Boolean representation \u03a6 = \u03d51\u2227 \u00b7 \u00b7 \u00b7\u2227\u03d5n of a constraint model C = C1\u2227 \u00b7 \u00b7 \u00b7\u2227Cn where \u03d5i = [[Ci]]. Here we require that each Ci is a \u201csmall\u201d conjunction of constraints. Typically, the integer variables referred to in each Ci are also declared in Ci (sometimes this requires duplicating the variable declarations). For an individual constraint c we denote by c+ the conjunction of constraints including c and the declarations for integer variables it refers to. The specifics of these declarations will be clear from the context.\nExample 7. Let C be the following constraint model:\nC = ( new int(X, 1, 3) \u2227 new int(Y, 1, 3) \u2227 new int(Z, 1, 3) \u2227 int plus(X, Y, 3) \u2227 int plus(Y, Z, 4) \u2227 int neq(Y, Z) ) We have\n1. int plus+(X, Y, 3) = int plus(X, Y, 3) \u2227 new int(X, 1, 3) \u2227 new int(Y, 1, 3),\n2. int plus+(Y, Z, 4) = int plus(Y, Z, 4) \u2227 new int(Y, 1, 3) \u2227 new int(Z, 1, 3),\n3. int neq+(Y, Z) = int neq(Y, Z) \u2227 new int(Y, 1, 3) \u2227 new int(Z, 1, 3).\nAs a basis for equi-propagation we take \u03a6 = \u03d51 \u2227 \u03d52 \u2227 \u03d53 where \u03d51 = [[int plus+(X, Y, 3)]], \u03d52 = [[int plus +(Y, Z, 4)]], and \u03d53 = [[int neq +(Y, Z)]]. Denoting X = [1, x2, x3], Y = [1, y2, y3], and Z = [1, z2, z3] and applying corresponding complete equi-propagators and starting with E0 = \u2205 we have:\n1. E1 = \u00b5\u0302\u03d51(E0) = E0 \u222a {x3 = 0, y3 = 0, x2 = \u00acy2};\n2. E2 = \u00b5\u0302\u03d52(E1) = E1 \u222a {z2 = 1, y2 = \u00acz3};\n3. E3 = \u00b5\u0302\u03d53(E2) = E2 \u222a {y2 = 0}.\nAt this point equi-propagation applies no more, and unifyE3 = {x2 7\u2192 1, x3 7\u2192 0, y2 7\u2192 0, y3 7\u2192 0, z2 7\u2192 1, z3 7\u2192 1} . Now, unifyE3(\u03a6) is a tautology (all of the Boolean variables are determent by equi-propagation).\nThe following theorem clarifies that the order in which equi-propagators are applied in the equi-propagation process does not influence the final result.\nTheorem 8. The equi-propagation process is confluent.\nProof. Let \u03a6 = \u03d51 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03d5n be a Boolean formula and \u00b5\u03d51 , . . . , \u00b5\u03d5n corresponding equipropagators. Let E1 = \u00b5\u03d5ir (\u00b5\u03d5ir\u22121 (. . . \u00b5\u03d5i1 (\u2205) . . .)) and E2 = \u00b5\u03d5js (\u00b5\u03d5js\u22121 (. . . \u00b5\u03d5j1 (\u2205) . . .)) be two different applications of the equi-propagation process. So by construction, for each of the given equi-propagators, we have a property (?): \u00b5\u03d5i(E1) = E1 and \u00b5\u03d5i(E2) = E2.\nNow assume, in contradiction, that E1 6= E2. Then w.l.o.g. there exists e \u2208 E2 where e not \u2208 E1 (swap the roles of E1 and E2 if E2 \u2282 E1). E1 ( E2. Let us focus on the first step in the equi-propagation process leading to E2 that introduced the equation e \u2208 E2 not introduced to E1: So, there exists an ` < s such that E = \u00b5\u03d5j` (\u00b5\u03d5j`\u22121 (. . . \u00b5\u03d5j1 (\u2205) . . .)) \u2286 E1 and e \u2208 \u00b5\u03d5`+1(E) but e 6\u2208 E1. But, if E \u2286 E1, then by the monotonicity of \u00b5\u03d5`+1 , we have that \u00b5\u03d5`+1(E) \u2286 \u00b5\u03d5`+1(E1) and hence e \u2208 \u00b5\u03d5`+1(E1) in contradiction to the construction with property (?).\nThe following proposition provides an alternative, more efficient to implement, definition for complete equi-propagation.\nProposition 2. Let \u03d5 be a Boolean formula and \u00b5\u0302\u03d5 a complete equi-propagator for \u03d5. Define for E \u2208 E,\n\u00b5\u0304\u03d5(E) = E \u222a { e \u2208 Leq0,1 \u2223\u2223 unifyE(\u03d5) |= e } Then, \u00b5\u0302\u03d5(E) = \u00b5\u0304\u03d5(E). That is, \u00b5\u0304\u03d5 implements a complete equi-propagator for \u03d5.\nProof. For the first direction, (\u21d2): By definition, we have that \u00b5\u0302\u03d5(E)\u2192 E. We also have \u00b5\u0302\u03d5(E) \u2192 { e \u2223\u2223 unifyE(\u03d5) |= e } because by Proposition 1(a) \u03d5 \u2227 E |= unifyE(\u03d5). So, \u00b5\u0302\u03d5(E) \u2192 \u00b5\u0304\u03d5(E). For the other direction, (\u21d0): Let e \u2208 \u00b5\u0304\u03d5(E). If e \u2208 E then the proof is straightforward. Otherwise, let unifyE(\u03d5) |= e and assume in contrary that e 6\u2208 \u00b5\u0302\u03d5(E), or in other words that \u03d5 \u2227 E 6|= e. This means that there exists an assignment \u03c3 that satisfies \u03d5\u2227E but does not satisfy e. By Lemma 1(a), \u03c3 also satisfies unifyE(\u03d5)\u2227E and in particular \u03c3 satisfies unifyE(\u03d5). From our assumption that unifyE(\u03d5) |= e we now have that \u03c3 satisfies e. Contradiction.\nComputing \u00b5\u0304\u03d5 is considerably more efficient than \u00b5\u0302\u03d5 since we can simply examine the formula \u03d5 after the application of unifyE to determine new Boolean equality consequences.\nFinally we comment: Our intention is that the equi-propagation process be applied not only to make a SAT instance smaller but also to obtain an easier to solve representation. However, decreasing the size of the CNF is not the main objective. In fact, often we explicitly introduce redundancies to improve a SAT encoding. For example, consider an \u201cif-thenelse\u201d construct, x\u2194ITE(s,t,f), where propositional variable: s indicates the \u201cselector\u201d, t indicates the \u201ctrue branch\u201d, f indicates the \u201cfalse branch\u201d, and x indicates the result. The corresponding CNF is {{\u00acs,\u00act, x}, {\u00acs, t,\u00acx}, {s,\u00acf, x}, {s, f,\u00acx}}. Ee\u0301n and So\u0308rensson (2006) propose to add redundant clauses, {\u00act,\u00acf, x} and {t, f,\u00acx}. They comment that this improves the encoding and they observe that redundant clauses are often introduced to achieve arc-consistency in the SAT encoding. We show that given a clausal encoding of some formula \u03a6, application of equi-propagation can only strengthen unit propagation.\nTheorem 9. Let C be a set of clauses, and suppose C |= E where E is an equi-formula. Then unit propagation on unifyE(C) is at least as strong as unit propagation on C.\nProof. Unit propagation on C starting from assignment A0 repeatedly chooses a clause c\u222a{l} \u2208 C where {\u00acl\u2032 | l\u2032 \u2208 c} \u2286 Ai and sets Ai+1 := Ai\u222a{l}. Unit propagation terminates with Ak when no such clauses occur. Note that failure is detected when Ak contains both a literal and its negation.\nWe show that using a order of unit propagation on unifyE(C) determined by that which occurs on C starting from assignment B0 = unifyE(A0) we always obtain an assignment Bi where Bi \u2287 unifyE(Ai). The proof is by induction on the unit propagation steps in C. The base case holds by construction.\nAssume c \u222a {l} \u2208 C where {\u00acl\u2032 | l\u2032 \u2208 c} \u2286 Ai. Then by induction Bi \u2287 unifyE(Ai) \u2287 {unifyE(\u00acl\u2032) | l\u2032 \u2208 c}. Either unifyE(l) \u2208 Bi in which case we set Bi+1 = Bi and the induction holds. Or unifyE(l) 6\u2208 Bi. Now since c\u222a {l} \u2208 C we have that {unifyE(l\u2032) | l\u2032 \u2208 c}\u222a{unifyE(l)} \u2286 unifyE(C). Hence by unit propagation on unifyE(C) and Bi we obtain Bi+1 := Bi \u222a {unifyE(l)}. Hence the induction holds.\nGiven that unit propagation reaches a unique fixpoint then any unit propagation order on unifyE(A0) will end up with an assignment B where B \u2287 Bk \u2287 unify(Ak)"}, {"heading": "3.2 The Power of Equi-propagation", "text": "To illustrate the impact of equi-propagation we come back to the Kakuro example from Section 2.2 (recall Figure 2). In fact solving such puzzles via SAT encodings is quite easy, with and without equi-propagation. So the example should only be viewed as illustrating\nthe impact of equi-propagation on the size of the encoding. We compare 3 different models of the problem, which each give different equi-propagation.\nWe consider, as a baseline for this discussion, the following Boolean representation derived from a constraint model where the declarations which are not specified explicitly are of the form new int(I, 1, h) where h is the smallest hint for a block that includes I or the number 9 if that is smaller.\n\u03a61 = \u2227\n{I1, . . . , Ik} \u2208 Blocks 1 \u2264 i < j \u2264 k\n[[int neq+(Ii, Ij)]] \u2227 \u2227\nB \u2208 Blocks\n[[int array sum+(B, hint(B))]]\nNotice that there is one \u201cint neq\u201d conjunct for each pair of white cells in the same block, and one \u201cint array sum\u201d conjunct for each block. Applying the equi-propagation process to \u03a61 with complete equi-propagators determines six integer values as depicted in Figure 4(a).\nFigure 4(b) illustrates the impact of applying the equi-propagation process where the equi-propagators are for allDiff constraints instead of for the individual int neq constraints. This determines seven integer variables and is formalized taking the following Boolean representation of the constraint model (and introducing an equi-propagator for each conjunct).\n\u03a62 = \u2227\nB \u2208 Blocks\n[[allDiff+(B)]] \u2227 \u2227\nB \u2208 Blocks\n[[int array sum+(B, hint(B))]]\nFigure 4(c) illustrates the impact of applying the equi-propagation process where the equipropagators are for pairs, each consisting of an allDiff constraint together with its corresponding sum constraint. This form of equi-propagation is most powerful. It fixes integer values for all of the white cells (in this example). We stress that equi-propagation reasons only about equalities between Boolean literals and constants. Here we take the model as:\n\u03a63 = \u2227\nB \u2208 Blocks\n( [[allDiff+(B)]] \u2227 [[int array sum+(B, hint(B))]] ) To further demonstrate the impact of equi-propagation, Table 1 provides data for 15 additional instances,1 categorized as: \u201ceasy\u201d, \u201cmedium\u201d and \u201chard\u201d. The first two columns in the table indicate the instance category and ID. From the five columns headed \u201cInteger\n1. Instances available from http://4c.ucc.ie/~hcambaza/page1/page7/page7.html (generated by Helmut Simonis).\nVariables\u201d, the first four specify the number of unassigned white cells in the initial stage and after each of the three complete equi-propagation processes described above. From the five columns headed \u201cBoolean variables\u201d, the first four indicate the corresponding information regarding the number of Boolean variables in the bit representations of the integers. So, the smaller the number in the table, the more variables have been removed due to equipropagation. In particular, the \u03a63 model completely solves 9 of the 15 instances. The two columns titled BEE show the corresponding information obtained using a weaker form of equi-propagation that is described in Section 4 below. The last row of the table indicates the average time it takes to perform equi-propagation (in seconds) using each of the three schemes, \u03a61,\u03a62,\u03a63, and the weaker scheme titled BEE. We will come back to discuss this later after detailing how equi-propagation is performed. The results in the table indicate the clear benefit in performing equi-propagation based on coarser portions of the model."}, {"heading": "3.3 Implementing Equi-propagators", "text": "To implement complete equi-propagators we need to infer Boolean equalities implied by a given Boolean formula, \u03d5, and equi-formula, E. Based on Proposition 2, it is sufficient to test for the condition\nunifyE(\u03d5) |= (`1 \u2194 `2) (1)\nWe consider three techniques: using a SAT solver, using BDD\u2019s, and using ad-hoc rules applied to the Boolean representations of individual constraints.\nIt is straightforward to implement a complete equi-propagator using a SAT solver. To test Condition (1) we consider the formula \u03c8 = \u03d5 \u2227 (`1 6\u2194 `2). If \u03c8 is not satisfiable, then Condition (1) holds. In this way, Condition (1) can be checked for all relevant equations\ninvolving variables from unifyE(\u03d5) (and constants 0,1). A major obstacle with this SATbased approach is that testing for a single equivalence, `1 \u2194 `2, is at least as hard as testing for the satisfiability of \u03d5. In fact testing for unsatisfiability is typically more expensive. Hence the importance of our assumption that \u03d5 is only a small fragment of the CNF of interest. In practice SAT-based equi-propagation is surprisingly fast. For illustration, in the last row of Table 1 the average times for SAT-based complete equi-propagation for the different models are indicated in the columns \u03a61, \u03a62, and \u03a63. It is interesting to observe that the strongest technique, using \u03a63, is the fastest. This is because there are fewer (but larger) conjuncts and hence fewer queries to the SAT solver.\nWe can implement a complete equi-propagator using binary decision diagrams (BDDs) as follows. We construct a BDD for formula \u03d5 at the beginning of equi-propagation. When new equational information E\u2032 is added to E we \u201csimplify\u201d the BDD for \u03d5 by conjoining the BDD with a BDD for E\u2032 and then projecting out the variables that no longer appear in unifyE(\u03d5). Note that this \u201csimplification\u201d can increase the size of the BDD. In practice, rather than these two steps, we can use the \u201cRestrict\u201d operation of Coudert and Madre (1990) (\u201cbdd simplify\u201d in Somenzi, 2009) to create the new BDD more efficiently.\nGiven the BDD for unifyE(\u03d5), we can explicitly test Condition (1) using a standard BDD containment test (e.g., \u201cbddLeq\u201d in Somenzi, 2009). Just as in the SAT-based approach, this test is performed for all relevant equations involving variables from unifyE(\u03d5) (and constants 0,1). Alternately we can use the method of Bagnara and Schachte (1998) (extended to extract literal equalities as opposed to just variable equalities) to extract all the fixed literals and equivalent literal consequences of the BDD.\nExample 10. Consider the BDD shown in Figure 5(a) which represents the formula: \u03d5 \u2261 new int(A, 0, 3)\u2227 new int(B, 0, 3)\u2227 int neq(A,B). Figure 5(b) depicts the The BDD for unifyE(\u03d5) where E = {B1 = 1, B2 = 1, B3 = 0 }. Here it is easy to see that equipropagation determines that A2 = A3. Let E\n\u2032 = E \u222a {A2 = A3}. Then Figure 5(c) shows the simplified BDD for unifyE\u2032(\u03d5).\nA major obstacle with this BDD-based approach concerns the size of the formula unifyE(\u03d5). For some constraints, the corresponding BDD is guaranteed to be polynomial (in the size of the constraint). The following result holds for an arbitrary constraint \u03d5, so it also holds for unifyE(\u03d5).\nProposition 3. Let c be a constraint about k integer variables each represented with n bits in the order encoding. Then, the number of nodes in the BDD representing [[c]] is bound by O(nk).\nProof. (Sketch) There are only n + 1 legitimate states for each n bit unary variable, and the BDD cannot have more nodes than possible states.\nConstraints like new int, int neq, and int plus involve at most 3 integer variables and hence their BDD-based complete equi-propagators are polynomially bounded. However, this is not the case for global constraints such as allDiff and int array plus where the arity is not fixed. Moreover, it is well known that the allDiff constraint does not have a polynomial sized BDD (Bessiere, Katsirelos, Narodytska, & Walsh, 2009).\nGiven the potential exponential run-time when performing SAT-based equi-propagation, and the potential exponential size of BDD-based equi-propagators, we consider a third approach where we implement equi-propagation by a collection of ad-hoc transition rules for each type of constraint. While this approach is not complete \u2014 there are equations implied by a constraint that are not detected \u2014 the implementation is fast, and works well in practice. This is the topic of the next section."}, {"heading": "4. Ad-hoc Equi-Propagation", "text": "We consider a rule-based approach to define equi-propagators. The definition is given as a set of ad-hoc rules specified for each type of constraint. The novelty is that the approach is not based on CNF, as in previous works, but rather driven by the bit blasted constraints that are to be encoded to CNF. Our presentation focuses on the case where finite domain integers are represented in the order encoding. For an integer X = [x1, . . . , xn], we often write: X \u2265 i to denote the equation xi = 1, X < i to denote the equation xi = 0, X 6= i to denote the equation xi = xi+1, and X = i to denote the pair of equations xi = 1, xi+1 = 0. Moreover, to simplify notation when specifying the rules below, we view X = [x1, . . . , xn] as a larger vector padded with sentinel cells such that all cells \u201cto the left of\u201d x1 take value 1 and all cells \u201cto the right of\u201d xn take the value 0. Basically this facilitates the specification of the \u201cend cases\u201d in our formalism. We now consider each of the 5 constraints in the language fragment presented in Section 2.\n(1) The two rules in Figure 6(a) derive from the monotonicity in the order encoding representation. These basically correspond to unit propagation, but at the constraint level.\n(2) The first rule in Figure 6(b) considers cases when X is a constant (the symmetric case can be handled by exchanging X and Y ). The other two rules capture templates that commonly arise in the equi-propagation process. To illustrate the justification of the third rule consider all possible truth values for the variables xi and xi+1: (a) If xi = 0 and xi+1 = 1 then both integers in the relation take the form [. . . , 0, 1, . . .] violating their specification as ordered, so this is not possible. (b) If xi = 1 and xi+1 = 0 then both numbers take the form [1, . . . , 1, 0, . . . , 0] and are equal, violating the neq constraint. The only possible bindings for xi and xi+1 are those where xi = xi+1.\n(3) In Figure 7(a) we illustrate a single rule for the allDiff constraint which considers Hall sets of size 2. Here each Zi represents an integer in the order encoding and we focus on the case when Z1 and Z2 are restricted by the equations in E to take only two possible values, i or j. This can be expressed in E because [x1, . . . , xn] \u2208 {i, j} (for i < j) means that xk = 1 for k < i, xk = xk+1 for i \u2264 k < j, and xk = 0 for j < k \u2264 n. Z1 6= Z2 then means adding the single equation xi = \u00acyi (because Z1 and Z2 can take only two values). In addition to this rule, we apply the rules for int neq(Zi, Zj) for each pair of integers Zi and Zj in the constraint.\n(4) The first four rules of Figure 7(b) capture the standard propagation behavior for interval arithmetics. The last two rules apply when one of the integers in the relation is a constant. There are symmetric cases when replacing the role of X and Y .\n(5) There are no special ad-hoc rules for equi-propagation of an int array plus constraint. These are simply viewed as a decomposition to a set of int plus constraints. Then simplification is performed at that level using the rules for int plus. The decomposition of int array plus is explained in Section 6.\nExample 11 (ad-hoc equi-propagation). Consider the following (partial) constraint model, from the context of the Kakuro example of Section 2.2, where we represent variables X, Y and Z as X = [x1, . . . , x9], Y = [y1, . . . , y9] and Z = [z1, . . . , z18] and assume some previous equi-propagation (on other constraints) has determined the current equi-formula E0 to specify that integer variable Z = 4:\nC = ( new int(X, 0, 9) \u2227 new int(Y, 0, 9) \u2227 new int(Z, 0, 18) \u2227 int plus(X, Y, Z) \u2227 int neq(X, Y) ) Figure 8 illustrates, step-by-step, the equi-propagation process on C using the ad-hoc rules defined above. Each step corresponds to the application of one of the above defined ad-hoc equi-propagation rules as indicated by the label on the transition. At each stage we illustrate the derived equations (top part) and their application (as a unifier) to the state variables X,Y and Z (lower part).\nTo summarize, let us come back to Table 1. The numbers presented in the two columns headed \u201cBEE\u201d specify the number of variables remaining after application of ad-hoc equipropagation. We also observe that our definition of ad-hoc equi-propagation is trivially monotonic."}, {"heading": "5. Constraint Model Partial Evaluation", "text": "Partial evaluation, together with equi-propagation, is the second important component in our approach to compile constraint models to CNF. Partial evaluation is about simplifying a given constraint model in view of information that becomes available due to equipropagation. Typically, in the constraint simplification process, we apply alternating steps of equi-propagation and partial evaluation. Examples of partial evaluation include constant elimination and removing constraints which are tautologies. In this section we detail the partial evaluation rules that apply for the five constraint types defined in the language fragment presented in Section 2.\n(1) A new int(I, c1, c2) constraint specifies that an integer I = [x1, . . . , xn] is represented in the order encoding and in particular that the corresponding bit sequence is sorted (not increasing). We denote this as ordered([x1, . . . , xn]). Partial evaluation focuses on this aspect of the constraint and ignores the bounds c1, c2 specified in the constraint. The table in Figure 9 specifies four simplification rules that apply. The first rule identifies tautologies, the second and third rules remove leading ones and trailing zeros, and the fourth removes (one of two) equated bits. In this figure, and in the subsequent, a crossed out element in a sequence, indicates that it has been removed from the sequence.\n(2) The simplification rules for a int neq constraint shown in Figure 10(a) are symmetric when exchanging the role of X and Y . The first two rules identify tautologies. The third rule is about X and Y which have an equal bit at position i. The corresponding bits can be removed from the representation of X and Y , resulting in a shorter list of bits in their representations. The last two rules are about removing leading ones and trailing zeroes and are illustrated by the following example.\nExample 12. Figure 10(b) shows two steps of partial evaluation, for a int neq constraint, first removing leading ones, then removing trailing zeroes.\n(3) Four rules for simplifying allDiff constraints are illustrated in Figure 11. The first, is about detecting tautologies. The second, identifies cases when one of the integers in the constraint (assume Z1) has a domain disjoint from all of the others. This rule also captures the case when Z1 is a constant. The third rule removes a Hall set of size 2 (assume {Z1, Z2}) from the constraint. Note that the corresponding equi-propagation rule detects that the values of Z3, . . . , Zn are different from the values of {Z1, Z2} and then the next fourth rule applies. The fourth rule is for the case when none of the integers in the constraint can take a certain value i. This rule also captures the case when all of the numbers have leading ones or trailing zeroes. The last two rules are illustrated in Example 14.\n(4 & 5) The simplification rules shown in Figure 12 are symmetric when exchanging the role of X and Y . The first two apply where (at least) one of X, Y and Z is a constant. Because we have already applied equi-propagation to the constraint, it is a tautology. See Example 13. The last two rules apply to remove leading ones and trailing zeroes. The\nsimplification rules of an int array plus constraint are straightforward generalizations of the ones for int plus. See Example 15.\nTo summarise the rule based approach to apply equi-propagation and partial evaluation we present the following sequence of three examples which focus on the simplification of the three constraints given as Figure 13 where the integer variables I1, . . . , I8 are defined in the range between 1 and 8 and where K = 14.\nExample 13. Consider equi-propagation of constraint (a) from Figure 13 where E0 specifies that K = 14:\nE0 = { k1=1, . . . , k14=1 k15 = 0, k16 = 0 } I1 = [1, i1,2, . . . , i1,8], I2 = [1, i2,2, . . . , i2,8], K = [1, 1, . . . , 1\ufe38 \ufe37\ufe37 \ufe38\n14\n, 0, 0]\nK=14\u2212\u2212\u2212\u2212\u2212\u2192 int plus\nE1 = E0 \u222a  i1,2=1, . . . , i1,6=1,i2,2=1, . . . , i2,6=1, i1,7=\u00aci2,8, i1,8=\u00aci2,7  I1 = [1, 1, 1, 1, 1, 1, i1,7, i1,8], I2 = [1, 1, 1, 1, 1, 1,\u00aci1,8,\u00aci1,7], K = [1, 1, . . . , 1\ufe38 \ufe37\ufe37 \ufe38\n14\n, 0, 0]\nGiven E1, the constraint is a tautology and removed by partial evaluation: int plus([1, 1, 1, 1, 1, 1, i1,7, i1,8], [1, 1, 1, 1, 1, 1,\u00aci1,8,\u00aci1,7], 14)  P.E\u2212\u2212\u2212\u2212\u2212\u2192 int plus\n[ ] Example 14. Consider equi-propagation of constraint (b) from Figure 13 given E1 from Example 13:\nE1 I1 = [1, 1, 1, 1, 1, 1, i1,7, i1,8], I2 = [1, 1, 1, 1, 1, 1,\u00aci1,8,\u00aci1,7]\ni1,7=\u00aci2,8, i2,7=\u00aci1,8\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 int neq E2 = E1 \u222a {i1,7=i1,8} I1 = [1, 1, 1, 1, 1, 1, i1,7, i1,7], I2 = [1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7]\nGiven E2, the equi-propagation rule for allDiff detects that {I1, I2} is a Hall set (where the two variables take values 6 and 8). and adds to E2 the set of equations, E\n\u2032, that specify that I3, I4, I5, I6, I7, I8 6= 6, 8. The result is E3 = E2 \u222a E\u2032 and the result of this step gives the following bindings (where the impact of E\u2032 is underlined):\nI1 = [1, 1, 1, 1, 1, 1, i1,7, i1,7] I5 = [1, i5,2, i5,3, i5,4, i5,5, i5,7, i5,7, 0] I2 = [1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7] I6 = [1, i6,2, i6,3, i6,4, i6,5, i6,7, i6,7, 0] I3 = [1, i3,2, i3,3, i3,4, i3,5, i3,7, i3,7, 0] I7 = [1, i7,2, i7,3, i7,4, i7,5, i7,7, i7,7, 0] I4 = [1, i4,2, i4,3, i4,4, i4,5, i4,7, i4,7, 0] I8 = [1, i8,2, i8,3, i8,4, i8,5, i8,7, i8,7, 0]\nGiven E3, partial evaluation of the constraint first removes the Hall set:\n[allDiff([I1, I2, I3, I4, I5, I6, I7, I8])] P.E\u2212\u2212\u2212\u2212\u2192\nallDiff [allDiff([I3, I4, I5, I6, I7, I8])]\nand then applies to remove three redundant bits in the underlying representation of each remaining integer (which is not equal to 0, 6, 8): allDiff([ [1, i3,2, i3,3, i3,4, i3,5, i3,7, i3,7, 0], [1, i4,2, i4,3, i4,4, i4,5, i4,7, i4,7, 0], [1, i5,2, i5,3, i5,4, i5,5, i5,7, i5,7, 0], [1, i6,2, i6,3, i6,4, i6,5, i6,7, i6,7, 0], [1, i7,2, i7,3, i7,4, i7,5, i7,7, i7,7, 0], [1, i8,2, i8,3, i8,4, i8,5, i8,7, i8,7, 0]])  P.E\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 allDifferent  allDiff([ [i3,2, i3,3, i3,4, i3,5, i3,7], [i4,2, i4,3, i4,4, i4,5, i4,7], [i5,2, i5,3, i5,4, i5,5, i5,7], [i6,2, i6,3, i6,4, i6,5, i6,7], [i7,2, i7,3, i7,4, i7,5, i7,7], [i8,2, i8,3, i8,4, i8,5, i8,7]])  Example 15. Consider equi-propagation of constraint (c) from Figure 13 given E3 from Example 14. The rules that apply derive from the decomposition of the int array plus constraint to it int plus parts. These dictate that I3, I4, I5 \u2264 5:\nE3 I2 = [1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7], I3 = [1, i3,2, i3,3, i3,4, i3,5, i3,7, i3,7, 0], I4 = [1, i4,2, i4,3, i4,4, i4,5, i4,7, i4,7, 0], I5 = [1, i5,2, i5,3, i5,4, i5,5, i5,7, i5,7, 0] \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 int array plus E4 = E3 \u222a {i3,7=0, i4,7=0, i5,7=0} I2 = [1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7], I3 = [1, i3,2, i3,3, i3,4, i3,5, 0, 0, 0], I4 = [1, i4,2, i4,3, i4,4, i4,5, 0, 0, 0], I5 = [1, i5,2, i5,3, i5,4, i5,5, 0, 0, 0]\nApplying partial evaluation simplifies the constraint as follows: int array plus([\n[1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7], [1, i3,2, i3,3, i3,4, i3,5, 0, 0, 0], [1, i4,2, i4,3, i4,4, i4,5, 0, 0, 0], [1, i5,2, i5,3, i5,4, i5,5, 0, 0, 0]], 14 )\n P.E\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192int array plus \nint array plus([ [\u00aci1,7,\u00aci1,7], [i3,2, i3,3, i3,4, i3,5], [i4,2, i4,3, i4,4, i4,5], [i5,2, i5,3, i5,4, i5,5]], 5 )  To summarize Examples 13\u201315 observe that in the initial constraint model 3 constraints about 8 integers are represented in 56 bits. After constraint simplification 2 constraints remain and the 8 integers are represented using 28 bits:\nI1 = [1, 1, 1, 1, 1, 1, i1,7, i1,7] I5 = [1, i5,2, i5,3, i5,4, i5,5, 0, 0, 0] I2 = [1, 1, 1, 1, 1, 1,\u00aci1,7,\u00aci1,7] I6 = [1, i6,2, i6,3, i6,4, i6,5, i6,7, i6,7, 0] I3 = [1, i3,2, i3,3, i3,4, i3,5, 0, 0, 0] I7 = [1, i7,2, i7,3, i7,4, i7,5, i7,7, i7,7, 0] I4 = [1, i4,2, i4,3, i4,4, i4,5, 0, 0, 0] I8 = [1, i8,2, i8,3, i8,4, i8,5, i8,7, i8,7, 0]\n6. Compiling Constraints with BEE\nBEE (Ben-Gurion Equi-propagation Encoder) is a tool which applies to encode finite domain constraint models to CNF. BEE was first introduced by Metodi and Codish (2012). During the encoding process, BEE performs optimizations based on equi-propagation and partial evaluation to improve the quality of the target CNF. BEE is implemented in (SWI) Prolog and can be applied in conjunction with the CryptoMiniSAT solver (Soos, 2010) through a Prolog interface (Codish, Lagoon, & Stuckey, 2008). CryptoMiniSAT offers direct support for xor clauses, and BEE takes advantage of this feature. BEE can be downloaded (Metodi, 2012) where one can also find the examples from this paper and others.\nThe source language for the BEE compiler is also called BEE. It is a constraint modeling language similar to FlatZinc (Nethercote et al., 2007), but with a focus on a subset of the language relevant for finite domain constraint problems. Five of the constraint constructs in the BEE language are those introduced in Section 2.1. The full language is presented in Table 2.\nIn BEE Boolean constants \u201ctrue\u201d and \u201cfalse\u201d are viewed as (integer) values \u201c1\u201d and \u201c0\u201d. Constraints are represented as (a list of) Prolog terms. Boolean and integer variables are represented as Prolog variables, which may be instantiated when simplifying constraints. in Table 2, X and Xs (possibly with subscripts) denote a literal (a Boolean variable or its negation) and a vector of literals, I (possibly with subscript) denotes an integer variable, and c (possibly with subscript) denotes an integer constant. On the right column of the table are brief explanations regarding the constraints. The table introduces 26 constraint templates.\nConstraints (1-2) are about variable declarations: Booleans and integers. Constraint (3) expresses a Boolean as an integer value. Constraints (4-8) are about Boolean (and reified Boolean) statements. The special cases of Constraint (5) for bool array or([X1, . . . , Xn]) and bool array xor([X1, . . . , Xn]) facilitate the specification of clauses and of xor clauses (supported directly in the CryptoMiniSAT solver by Soos, 2010). Constraint (8) specifies that sorting a bit pair [X1, X2] (decreasing order) results in the pair [X3, X4]. This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by As\u0301\u0131n, Nieuwenhuis, Oliveras, and Rodr\u0301\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010). Constraints (9-14) are about integer relations and operations. Constraints (15-20) are about linear (Boolean, Pseudo Boolean, and integer) operations. Constraints (21-26) are about lexical orderings of Boolean and integer arrays.\nA main design choice of BEE is that all integer variables are represented in the orderencoding. So, BEE is suitable for problems in which the integer variables take small or medium sized values. The compilation of a constraint model to a CNF using BEE goes through three phases.\n1. Unary bit-blasting: integer variables (and constants) are represented as bit vectors in the order-encoding.\n2. Constraint simplification: three types of actions are applied: equi-propagation, partial evaluation, and decomposition of constraints. Simplification is applied repeatedly until no rule is applicable.\n3. CNF encoding: the best suited encoding technique is applied to the simplified constraints.\nBit-blasting and equi-propagation in BEE follow the general descriptions from Sections 2.4 and 3.1. Bit-blasting is implemented through Prolog unification. Each declaration of the form new int(I, c1, c2) triggers a unification I = [1, . . . , 1, Xc1+1, . . . , Xc2 ] (to ease presentation we assume that integer variables are represented in a positive interval starting from 0 but there is no such limitation in practice as BEE also supports negatives integers). BEE applies ad-hoc equi-propagators as described in Section 4. When an equality of the form X = L (between a variable and a literal or a constant) is detected, then equipropagation is implemented by unifying X and L. This unification applies to all occurrences of X and in this sense \u201cpropagates\u201d to other constraints involving X.\nDecomposition is about replacing complex constraints (for example about arrays) with simpler constraints (for example about array elements). Consider, for instance, the constraint int array plus(As, Sum). It is decomposed to a list of int plus constraints applying a straightforward divide and conquer recursive definition. At the base case, if As=[A] then\nthe constraint is replaced by a constraint of the form int eq(A,Sum) which equates the bits of A and Sum, or if As = [A1, A2] then it is replaced by int plus(A1, A2, Sum). In the general case As is split into two halves, then constraints are generated to sum these halves, and then an additional int plus constraint is introduced to sum the two sums.\nAs another example, consider the int plus(A1, A2, A) constraint. One approach, supported by BEE, decomposes the constraint as an odd-even merger (from the context of odd-even sorting networks) (Batcher, 1968). Here, the sorted sequences of bits A1 and A2 are merged to obtain their sum A. This results in a model with O(n log n) comparator constraints (and later in an encoding with O(n log n) clauses). Another approach, also supported in BEE, does not decompose the constraint but encodes it directly to a CNF of size O(n2), as in the context of so-called totalizers (Bailleux & Boufkhad, 2003). A hybrid approach, leaves the choice to BEE, depending on the size of the domains of the variables involved. Finally, we note that the user can configure BEE to fix the way it compiles this constraint (and others).\nCNF encoding is the last phase in the compilation of a constraint model. Each of the remaining simplified (bit-blasted) constraints is encoded directly to a CNF. These encodings are standard and similar to those applied in various tools. The BEE encodings are similar to those applied in Sugar (Tamura et al., 2009).\n6.1 The All-Different Constraint in BEE\nThe all-different constraint specifies that a set of integer variables take all different values from their specified domains. This constraint has received much attention in the literature (see for example the survey in van Hoeve, 2001). BEE provides special treatment for this constraint.\nIn many applications, all-different constraints are applied to model the special case when the constraint is about \u201cpermutation\u201d. Namely, when [I1, . . . , In] are all different but may take precisely n different values. BEE identifies this special case and applies two additional ad-hoc equi-propagation rules for this case. The table of Figure 14 illustrates these rules. We annotate the constraint with a \u201c*\u201d to emphasize that it has been detected that it is about permutation. The first rule is about the case when only one integer (assume Z1) can take the value i. The second rule is about the case where all variables except two, assume Z1, Z2, cannot take two values, assume i, j. Now, because the constraint is about permutation,\nwe can determine that Z1 and Z2 must take the two values i and j. To illustrate the second rule consider the following example.\nExample 16. Consider a constraint allDiff(I1, . . . , I5) on 5 integer variables taking values in the interval [0, 4] (exactly 5 values) where E0 specifies that I3, I4 and I5 cannot take the values 0 and 1. Therefore we introduce equations which restrict I1 and I2 to take the values 0 and 1, and the corresponding ad-hoc rule for permutation applies:\nE0 =  x3,1=1, x4,1=1,x5,1=1, x3,2=1, x4,2=1, x5,2=1  I1 = [x1,1, . . . , x1,4], I2 = [x2,1, . . . , x2,4], I3 = [1, 1, x3,3, x3,4], I4 = [1, 1, x4,3, x4,4], I5 = [1, 1, x5,3, x5,4] dom(Ik) \u2229 {0, 1}=\u2205 k > 2 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 allDiff\u2217 E1 = E0 \u222a  x1,2=0, . . . , x1,4=0,x2,2=0, . . . , x2,4=0 x1,1=\u00acx2,1  I1 = [x1,1, 0, . . . , 0], I2 = [\u00acx1,1, 0, . . . , 0], I3 = [1, 1, x3,3, x3,4], I4 = [1, 1, x4,3, x4,4], I5 = [1, 1, x5,3, x5,4]\nTo facilitate the implementation of ad-hoc equi-propagation of all-different constraints, BEE adopts a dual representation for integer variables occurring in these constraints combining the order encoding and the, so-called, direct encoding. This is essentially the same as the encoding proposed by Gent and Nightingale (2004). When declaring an integer variable I, the bit-blast in the order encoding applies the corresponding unification I = [x1, . . . , xn]. When encountering I in an allDiff constraint, an additional bit-blast introduces I\u2032 = [d0, . . . , dn] in the direct encoding, and a channeling formula channel(I, I\n\u2032) is introduced.\nThe direct encoding is a unary representation I\u2032 = [d0, . . . , dn] where each bit di is true if and only if I\u2032 = i. So, exactly one of the bits takes the value true. For example, the value 3 in the interval [0, 5] is represented in 6 bits as [0, 0, 0, 1, 0, 0]. In the dual representation the following channeling formula captures the relation between the two representations of an integer variable I = [x1, . . . , xn] and I \u2032 = [d0, . . . , dn].\nchannel([x1, . . . , xn], [d0, . . . , dn]) = ( d0 = \u00acx1 \u2227 dn = xn ) \u2227 n\u22121\u2227 i=1 (di \u2194 xi \u2227 \u00acxi+1)\nConsider an allDiff constraint about m integer variables that can take different values between 0 and n. During constraint simplification, the allDiff([I1, . . . , Im]) constraint is viewed through its direct encoding as a bit matrix where each row consists of the bits [di0, . . . , din] for Ii in the direct encoding. The element dij is true iff Ii takes the value j. The jth column specifies which of the Ii take the value j and hence, at most one variable in a column may take the value true. This representation has one main advantage: in the direct encoding we can decompose allDiff([I1, . . . , Im]), to a conjunction of n + 1 constraints, one for each column 0 \u2264 j \u2264 n, of the form bool array sum leq([d1j, . . . , dmj], 1), which is arc-consistent. As soon as di,j = 1 (Ii = j) we have di,j\u2032 = 0 (Ii 6= j\u2032) for all j\u2032 6= j. In contrast in the order encoding alone the decomposition to O(m2) constraints{ int neq(Ii, Ij)\n\u2223\u2223 i < j } is not arc-consistent. We illustrate the advantage of the dual encoding for the allDiff constraint in Section 8.1.\n7. Using BEE\nA typical BEE application has the form depicted as Figure 15 where the predicate solve/2 takes a problem Instance and provides a Solution. The specifics of the application are in the call to encode/3 which given the Instance generates the Constraints that solve it together with a Map relating instance variables with constraint variables. The calls to bCompile/2 and sat/1 compile the constraints to a CNF and solve it applying a SAT solver. If the instance has a solution, the SAT solver binds the constraint variables accordingly. Then, the call to decode/2, using the Map, provides a Solution in terms of the Instance variables. The definitions of encode/3 and decode/2 are application dependent and provided by the user. The predicates bCompile/2 and sat/1 are part of the tool and provide the interface to BEE and the underlying SAT solver.\n7.1 Example BEE Application: Magic Graph Labeling\nWe illustrate the application of BEE using Prolog as a modeling language to solve a graph labeling problem. Graph labeling is about finding an assignment of integers to the vertices and edges of a graph subject to certain conditions. Graph labellings were introduced in the 60\u2019s and hundreds of papers on a wide variety of related problems have been published since then. See for example the survey by Gallian (2011) with more than 1200 references. Graph labellings have many applications. For instance in radars, X-ray crystallography, coding theory, etc.\nWe focus here on the vertex-magic total labeling (VMTL) problem where one should find for the graph G = (V,E) a labeling that is a one-to-one map V \u222aE \u2192 {1, 2, . . . , |V |+ |E|} with the property that the sum of the labels of a vertex and its incident edges is a constant K independent of the choice of vertex. A problem instance takes the form vmtl(G,K) specifying the graph G and a constant K. In the context of Figure 15, the query solve(vmtl(G, K), Solution) poses the question: \u201cDoes there exist a vmtl labeling for G with magic constant K?\u201d It binds Solution to indicate such a labeling if one exists, or to \u201cunsat\u201d otherwise. Figure 16 illustrates an example problem instance together with its solution.\nFigure 17 illustrates a Prolog program that implements the encode/3 predicate for the VMTL problem. The call to predicate declareInts/4 introduces the constraints which declare the integer variables for each vertex and edge in the graph, and generates the map. The call to predicate sumToK/5 introduces the constraints that require the sum of the labels for each vertex with its incident edges to equals K. The auxiliary predicate\ngetVars/3 receives a list of identifiers (vertices and edges) and extracts the corresponding list of integer variables from the map.\nGiven the VMTL instance from Figure 16, the call to predicate encode/3 from Figure 17 generates the map and the constraints detailed in Figure 18.\nSolving the constraints from Figure 18 binds the Map as follows, indicating a solution (in unary order encoding):\nM =  (1, [1, 1, 1, 1, 0, 0, 0, 0]), ((1, 2), [1, 1, 1, 1, 1, 1, 1, 0]),(2, [1, 1, 1, 1, 1, 0, 0, 0]), ((1, 3), [1, 1, 1, 0, 0, 0, 0, 0]),(3, [1, 0, 0, 0, 0, 0, 0, 0]), ((2, 3), [1, 1, 0, 0, 0, 0, 0, 0]), (4, [1, 1, 1, 1, 1, 1, 0, 0]), ((3, 4), [1, 1, 1, 1, 1, 1, 1, 1])  Using BEE to compile the constraints from Figure 18 generates a CNF which contains 301 clauses and 48 Boolean variables. Encoding the same set of constraints without applying simplification rules generates a larger CNF which contains 642 clauses and 97 Boolean variables.\nIn Section 8.3 we report that using BEE enables us to solve interesting instances of the VMTL problem not previously solvable by other techniques.\n7.2 BumbleBEE\nThe BEE distribution includes also a command line solver, which we call BumbleBEE. BumbleBEE enables one to specify a BEE model in an input file where each line contains a single constraint from the model and the last line specifies the type of goal. BumbleBEE reads the input file, compiles the constraint model to CNF, solves the CNF using the embedded CryptoMiniSAT solver (Soos, 2010) and outputs a set of bindings to the declared variables in the model (or a message indicating that the constraints are not satisfiable). Figure 19 contains on the left the BumbleBEE input file for the VMTL instance from Figure 16 and on the right the BumbleBEE output, which is a solution for the constraint model. In the example, the last line of the input file specifies the goal to the solver. The options are:\n1. solve satisfy: solve for a single satisfying assignment to the constraint model;\n2. solve satisfy(c): solve for (at most) c satisfying assignments to the constraint model where c is an integer value. When c \u2264 0 this option will solve for all solutions.\n3. solve minimize(I): solve for a solution which minimizes the value of the integer variable I. The solver outputs the intermediate solutions (with decreasing values of I) encountered during the search for the minimum value of I.\n4. solve maximize(I): similar to minimize, but maximizes.\nFurther details and more examples can be found in the BEE distribution (Metodi & Codish, 2012)."}, {"heading": "8. Experiments", "text": "We report on our experience in applying BEE. To appreciate the ease in its use the reader is encouraged to view the example encodings available with the tool (Metodi & Codish, 2012). All experiments run on an Intel Core 2 Duo E8400 3.00GHz CPU with 4GB memory under Linux (Ubuntu lucid, kernel 2.6.32-24-generic). BEE is written in Prolog and run\nusing SWI Prolog v6.0.2 64-bits. Comparisons with Sugar (v1.15.0) are based on the use of identical constraint models, apply the same SAT solver (CryptoMiniSAT v2.5.1), and run on the same machine. Times are reported in seconds."}, {"heading": "8.1 Quasigroup Completion Problems", "text": "A Quasigroup Completion Problem (QCP) proposed by Gomes, Selman, and Crato (1997) as a constraint satisfaction benchmark, is given as an n \u00d7 n board of integer variables (in the range [1, n]) in which some are assigned integer values. The task is to assign values to all variables, so that no column or row contains the same value twice. The constraint model is a conjunction of allDiff constraints. Anso\u0301tegui, del Val, Dotu\u0301, Ferna\u0301ndez, and Manya\u0300 (2004) argue the advantage of the direct encoding for QCP.\nWe consider 15 instances from the 2008 CSP competition.2 Table 3 considers three settings: BEE with its dual encoding for allDiff constraints, BEE using only the order encoding (equivalent to using int neq constraints instead of allDiff), and Sugar. The table shows: the instance identifier (\u201csat\u201d or \u201cunsat\u201d), compilation time (comp) in seconds, clauses in the encoding (clauses), variables in the encoding (vars), and SAT solving time (SAT) in seconds.\nThe results indicate that: (1) Application of BEE using the dual representation for allDiff is 38 times faster and produces 20 times fewer clauses (in average) than when using the order-encoding alone (despite the need to maintain two encodings); (2) Without the dual representation, solving encodings generated by BEE is only slightly faster than Sugar but BEE still generates CNF encodings 4 times smaller (on average) than those generated by Sugar. Observe that 3 instances are found unsatisfiable by BEE (indicated\n2. http://www.cril.univ-artois.fr/CPAI08/. The competition instances are specified using binary disequalities, but here we use the model with allDiff.\nby a CNF with a single clause and no variables). We comment that Sugar pre-processing times are higher than those of BEE and not indicated in the table."}, {"heading": "8.2 Word Design for DNA", "text": "This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists a set S of n eight-letter words over the alphabet \u03a3 = {A,C,G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {C,G}; (2) Each pair of distinct words in S differ in at least 4 positions; and (3) For every x, y \u2208 S: xR (the reverse of x) and yC (the word obtained by replacing each A by T , each C by G, and vice versa) differ in at least 4 positions.\nMancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques. Their best reported result is a solution with 87 DNA words, obtained in 554 seconds, using an OPL (van Hentenryck, 1999) model with lexicographic order to break symmetry. Frutos, Liu, Thiel, Sanner, Condon, Smith, and Corn (1997) present a strategy to solve this problem where the four letters are modeled by bit-pairs [t,m]. Each eight-letter word can then be viewed as the combination of a \u201ct-part\u201d, [t1, . . . , t8], which is a bit-vector, and a \u201cm-part\u201d, [m1, . . . ,m8], also a bit-vector. The authors report a solution composed from two pairs of (t-part and m-part) sets3 [T1,M1] and [T2,M2] where |T1| = 6, |M1| = 16, |T2| = 2, |M2| = 6. This forms a set S with (6\u00d7 16) + (2\u00d7 6) = 108 DNA words. Marc van Dongen reports a larger solution with 112 words.4\nBuilding on the approach described by Frutos et al. (1997), we pose conditions on sets of \u201ct-parts\u201d and \u201cm-parts\u201d, T and M , so that their Cartesian product S = T \u00d7M will satisfy the requirements of the original problem. From the three conditions below, T is required to satisfy (1\u2032) and (2\u2032), and M is required to satisfy (2\u2032) and (3\u2032). For a set of\n3. Their notions of t-part and m-part are slightly different than ours. 4. See http://www.cs.st-andrews.ac.uk/~ianm/CSPLib/.\nbit-vectors V , the conditions are: (1\u2032) Each bit-vector in V sums to 4; (2\u2032) Each pair of distinct bit-vectors in V differ in at least 4 positions; and (3\u2032) For each pair of bit-vectors (not necessarily distinct) u, v \u2208 V , uR (the reverse of u) and vC (the complement of v) differ in at least 4 positions. This is equivalent to requiring that (uR)C differs from v in at least 4 positions.\nIt is this strategy that we model in our BEE encoding. An instance takes the form dna(n1, n2) signifying the numbers of bit-vectors, n1 and n2 in the sets T and M . Without loss of generality, we impose, to remove symmetries, that T and M are lexicographically ordered. A solution is the Cartesian product S = T \u00d7M .\nUsing BEE, we find, in a fraction of a second, sets of t-parts of size 14 and m-parts of size 8. This provides a solution of size 14 \u00d7 8 = 112 to the DNA word problem. Running Comet (v2.0.1) we find a 112 word solution in about 10 seconds using a model by H\u030aakan Kjellerstrand.5 Using BEE, we also prove that there does not exist a set of 15 t-parts (0.15 seconds), nor a set of 9 m-parts (4.47 seconds). These facts were unknown prior to BEE. Proving that there is no solution to the DNA word problem with more than 112 words, without the restriction to the two part t-m strategy, is still an open problem."}, {"heading": "8.3 Vertex Magic Total Labeling", "text": "MacDougall, Miller, Slamin, and Wallis (2002) conjecture that the n vertex complete graph, Kn, for n \u2265 5 has a vertex magic total labeling with magic constants for a specific range of values of k, determined by n. This conjecture is proved correct for all odd n and verified by brute force for n = 6. We address the cases for n = 8 and n = 10 which involve 15 instances (different values of k) for n = 8, and 23 (different values of k) for n = 10. Starting from the simple constraint model (illustrated by the example in Figure 16), we add additional constraints to exploit the fact that the graphs are symmetric: (1) We assume that the edge with the smallest label is e1,2; (2) We assume that the labels of the edges incident to v1 are ordered and hence introduce constraints e1,2 < e1,3 < \u00b7 \u00b7 \u00b7 < e1,n; (3) We assume that the label of edge e1,3 is smaller than the labels of the edges incident to v2 (except e1,2) and introduce constraints accordingly. In this setting BEE can solve all except 2 instances with a 4 hour timeout and Sugar can solve all except 4.\nTable 4 gives results for the 10 hardest instances for K8 the 20 hardest instances for K10 with a 4 hour time-out. BEE compilation times are on the order of 0.5 sec/instance for K8 and 2.5 sec/instance for K10. Sugar encoding times are slightly larger. The instances are indicated by the magic constant, k; the columns for BEE and Sugar indicate SAT solving times (in seconds). The bottom two lines indicate average encoding sizes (numbers of clauses and variables).\nThe results indicate that the Sugar encodings are (in average) about 60% larger, while the average SAT solving time for the BEE encodings is about 2 times faster (average excluding instances where Sugar times-out).\nTo address the two VMTL instances not solvable using the BEE models described above (K10 with magic labels 259 and 258), we partition the problem fixing the values of e1,2 and e1,3 and maintaining all of the other constraints. Analysis of the symmetry breaking constraints indicates that this results in 198 new instances for each of the two cases. The\n5. See http://www.hakank.org/comet/word_design_dna1.co.\noriginal VMTL instance is solved if any one of of these 198 instances is solved. So, we solve them in parallel. Fixing e1,2 and e1,3 \u201cfuels\u201d the compiler so the encodings are considerably smaller. The instance for k = 259 is solved in 1379.50 seconds where e1,2 = 1 and e1,3 = 6. The compilation time is 2.09 seconds and the encoding consists in just over 1 million clauses and 15 thousand variables.\nTo the best of our knowledge, the hard instances from this suite are beyond the reach of all previous approaches to program the search for magic labels. The SAT based approach presented by Ja\u0308ger (2010) cannot handle these.6 The comparison with Sugar indicates the impact of the compiler."}, {"heading": "8.4 Balanced Incomplete Block Designs", "text": "This is Problem 028 of CSPlib (BIBD) where an instance is defined by a 5-tuple of positive integers [v, b, r, k, \u03bb] and requires to partition v distinct objects into b blocks such that each block contains k different objects, exactly r objects occur in each block, and every two distinct objects occur in exactly \u03bb blocks.\n6. Personal communication (Gerold Ja\u0308ger), March 2012.\nThe naive model for a BIBD instance [v, b, r, k, \u03bb] introduces the following constraints on a v by b Boolean incidence matrix: (1) exactly r ones in each row, (2) exactly k ones in each column, and (3) exactly \u03bb ones in each scalar product of two (different) rows.\nThis model does not contain a sufficient degree of information to trigger the equipropagation process. In order to take advantage of the BEE simplifications we added symmetry breaking as described by Frisch, Jefferson, and Miguel (2004) and illustrated in Figure 20: Each row is viewed as sequence of four parts A . . .D with sizes \u03bb, (r \u2212 \u03bb), (r \u2212 \u03bb), and (b \u2212 2r + \u03bb). The first row is fixed by assigning parts A and B with ones (marked in black) and parts C and D with zeros (marked in white). The second row is fixed by assign parts A and C with ones (marked in black) and parts B and D with zeros (marked in white). For the third and all subsequent rows (marked in gray), the sum constraints are decomposed into summing each part (A . . .D) and then summing the results as follows: A+B = \u03bb, A+C = \u03bb, C +D = r\u2212 \u03bb, and B +D = r\u2212 \u03bb. This ensures that the row contains exactly r ones and that the scalar product with the first (and second) row is \u03bb. We denote this constraint model SymB (for symmetry breaking).\nTable 5 shows results comparing BEE (compilation time, clauses in encoding, and SAT solving time) with Sugar using the SymB model. We also compare BEE with SatELite (Ee\u0301n\n& Biere, 2005), a CNF minimizer, where the input to SatELite is the CNF encoding for the SymB model generated by BEE without applying any simplifications. Here compilation time (comp) indicates the SatELite pre-processing time. The final row indicates the total of compilation and SAT solving time over the entire suite for each approach. In all cases time is measured in seconds.\nThis experiment indicates that BEE generates a significantly smaller CNF than Sugar which affects the SAT solving time. Moreover, the Sugar compilation time is extremely long. When comparing BEE with SatELite we can see that both output a CNF which is similar in size but as SatELite is applied on the entire CNF, for some instances its compilation time is significantly longer than its solving time.\nTable 6 shows results comparing BEE using the SymB model with the Minion constraint solver (Gent, Jefferson, & Miguel, 2006). We consider three different models for Minion: [M\u201906] indicates results using the BIBD model described by Gent et al. (2006), SymB uses the same model we use for the SAT approach, SymB+, is an enhanced symmetry breaking model with all of the tricks applied also in the [M\u201906] model. For the columns with no timeouts we show total times (for BEE this includes compile time and SAT solving). Note that by using a clever modeling of the problem we have improved also the previous run-times for Minion.\nThis experiment indicates that BEE is significantly faster than Minion on its BIBD models ([M\u201906]). Only when tailoring our SymB model, does Minion becomes competitive with ours.\n8.5 Combining BEE with SatELite\nWe now demonstrate the impact of combining BEE and SatELite. We describe experiments involving two of the benchmarks where SatELite is applied to simplify the output of BEE. The idea is to first apply the more powerful, but local, techniques, performed by BEE. This reduces the size of the CNF and is fast. Then we apply SatELite which takes global considerations on the CNF as a whole. We wish to determine if the smaller, simplified,\nCNF is more amenable to further simplification using SatELite. The results indicate that although CNF size is slightly decreased, solving times are most often increased, sometimes drastically.\nTables 7 and 8 show our results. In both tables the four columns under the BEE heading indicate: BEE compilation time, size of the encoding (clauses and variables), and the subsequent SAT solving time. Similarly, the four columns under the \u2206 SatELite heading indicate the application of SatELite to the output of BEE: the SatELite processing time, the size of the resulting CNF (clauses and variables), and the subsequent SAT solving time. Table 7 illustrates the results for the BIBD benchmark of Section 8.4 and Table 8, the results for the 10 hardest VMTL instances for K8 and for K10 described in Section 8.3. Observe that applying SatELite to the output of BEE decreases the CNF size only slightly and does not improve the SAT solving time. In fact, to the contrary, in most cases it renders a CNF which takes more time to solve. In several cases, SAT solving time increases drastically to introduce a timeout.\nOur results demonstrate that the application of SatELite to remove redundancies from a CNF is often non-beneficial. Presumably the difference we see from our application of SatELite to other CNF benchmarks results from the fact that BEE produces highly optimized CNF output, while many CNF benchmarks have significant inefficiency in their original encoding. If BEE removes a variable from the CNF, then it also instantiates that variable, either to a constant or to an equivalent variable, and as such does not remove potential propagations from the encoding, as captured by Theorem 9."}, {"heading": "9. Conclusion", "text": "There is a considerable body of work on CNF simplification techniques with a clear trade-off between amount of reduction achieved and invested time. Most of these approaches determine binary clauses implied by the CNF, which is certainly enough to determine Boolean equalities. The problem is that determining all binary clauses implied by the CNF is prohibitive when the SAT model may involve many (hundreds of) thousands of variables.\nTypically only some of the implied binary clauses are determined, such as those visible by unit propagation. The trade-off is regulated by the choice of the techniques applied to infer binary clauses, considering the power and cost. See for example the work of Ee\u0301n and Biere (2005) and the references therein. There are also approaches (Li, 2003) that detect and use Boolean equalities during run-time, which are complementary to our approach.\nIn our approach, the beast is tamed by introducing a notion of locality. We do not consider the full CNF. Instead, by maintaining the original representation, a conjunction of constraints, each viewed as a Boolean formula, we can apply powerful reasoning techniques to separate parts of the model and maintain efficient pre-processing.\nTo this end, we introduce BEE, a compiler that follows this approach to encode finite domain constraints to CNF. Applying optimizations based on ad-hoc equi-propagation and partial evaluation rules on a high level view of the problem allows us to simplify the problem more aggressively than is possible with a CNF representation. The resulting CNF models can be significantly smaller than those resulting from straight translation.\nIt is well-understood that making a CNF smaller is not the ultimate goal: often smaller CNF\u2019s are harder to solve. Indeed, one often introduces redundancies to improve SAT encodings: so removing them is counterproductive. Our experience is that BEE reduces the size of an encoding in a way that is productive for the subsequent SAT solving. In particular, by removing variables that can be determined \u201cat compile time\u201d to be definitely equal (or definitely different) in any solution.\nBEE uses ad-hoc equi-propagation and partial evaluation rules which keeps compilation times typically small (measured in seconds) even for instances which result in several millions of CNF clauses. And the reduction in SAT solving time can be larger by orders of magnitude. Hence, we believe that Boolean equi-propagation makes an important contribution to the encoding of CSPs to SAT.\nBEE is currently tuned to represent integers in the order encoding. Ongoing work aims to extend BEE for binary and additional number representations such as mixed radix bases as considered by Ee\u0301n and So\u0308rensson (2006) and further by Codish, Fekete, Fuhs, and Schneider-Kamp (2011)."}, {"heading": "Acknowledgments", "text": "We thank Vitaly Lagoon for the many insightful discussions concerning this research. NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence Program."}], "references": [{"title": "Modeling choices in quasigroup completion: SAT vs. CSP", "author": ["C. Ans\u00f3tegui", "A. del Val", "I. Dot\u00fa", "C. Fern\u00e1ndez", "F. Many\u00e0"], "venue": null, "citeRegEx": "Ans\u00f3tegui et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Ans\u00f3tegui et al\\.", "year": 2004}, {"title": "Cardinality networks: a theoretical and empirical study", "author": ["R. A\u015b\u0131n", "R. Nieuwenhuis", "A. Oliveras", "E. Rod\u0155\u0131guez-Carbonell"], "venue": "Constraints,", "citeRegEx": "A\u015b\u0131n et al\\.,? \\Q2011\\E", "shortCiteRegEx": "A\u015b\u0131n et al\\.", "year": 2011}, {"title": "Factorizing equivalent variable pairs in ROBDDbased implementations of Pos", "author": ["R. Bagnara", "P. Schachte"], "venue": "Algebraic Methodology and Software Technology, 7th International Conference,", "citeRegEx": "Bagnara and Schachte,? \\Q1998\\E", "shortCiteRegEx": "Bagnara and Schachte", "year": 1998}, {"title": "Efficient CNF encoding of Boolean cardinality constraints", "author": ["O. Bailleux", "Y. Boufkhad"], "venue": "CP, Vol. 2833 of LNCS,", "citeRegEx": "Bailleux and Boufkhad,? \\Q2003\\E", "shortCiteRegEx": "Bailleux and Boufkhad", "year": 2003}, {"title": "The Satisfiability Modulo Theories Library (SMT-LIB). www.SMT-LIB.org", "author": ["C. Barrett", "A. Stump", "C. Tinelli"], "venue": null, "citeRegEx": "Barrett et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Barrett et al\\.", "year": 2010}, {"title": "Sorting networks and their applications", "author": ["K.E. Batcher"], "venue": "AFIPS Spring Joint Computing Conference, Vol. 32 of AFIPS Conference Proceedings, pp. 307\u2013314, Atlantic City, NJ, USA. Thomson Book Company, Washington D.C.", "citeRegEx": "Batcher,? 1968", "shortCiteRegEx": "Batcher", "year": 1968}, {"title": "Circuit complexity and decompositions of global constraints", "author": ["C. Bessiere", "G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "In Proceedings of IJCAI", "citeRegEx": "Bessiere et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bessiere et al\\.", "year": 2009}, {"title": "Compiling problem specifications into SAT", "author": ["M. Cadoli", "A. Schaerf"], "venue": "Artificial Intelligence,", "citeRegEx": "Cadoli and Schaerf,? \\Q2005\\E", "shortCiteRegEx": "Cadoli and Schaerf", "year": 2005}, {"title": "Optimal base encodings for pseudo-Boolean constraints", "author": ["M. Codish", "Y. Fekete", "C. Fuhs", "P. Schneider-Kamp"], "venue": "TACAS, Vol. 6605 of Lecture Notes in Computer Science,", "citeRegEx": "Codish et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Codish et al\\.", "year": 2011}, {"title": "Pairwise cardinality networks", "author": ["M. Codish", "M. Zazon-Ivry"], "venue": "LPAR (Dakar),", "citeRegEx": "Codish and Zazon.Ivry,? \\Q2010\\E", "shortCiteRegEx": "Codish and Zazon.Ivry", "year": 2010}, {"title": "A unified framework for the formal verification of sequential circuits", "author": ["O. Coudert", "J.C. Madre"], "venue": "In ICCAD,", "citeRegEx": "Coudert and Madre,? \\Q1990\\E", "shortCiteRegEx": "Coudert and Madre", "year": 1990}, {"title": "Experimental results on the application of satisfiability algorithms to scheduling problems", "author": ["J.M. Crawford", "A.B. Baker"], "venue": "AAAI, Vol", "citeRegEx": "Crawford and Baker,? \\Q1994\\E", "shortCiteRegEx": "Crawford and Baker", "year": 1994}, {"title": "Effective preprocessing in SAT through variable and clause elimination", "author": ["N. E\u00e9n", "A. Biere"], "venue": "SAT, Vol. 3569 of Lecture Notes in Computer Science,", "citeRegEx": "E\u00e9n and Biere,? \\Q2005\\E", "shortCiteRegEx": "E\u00e9n and Biere", "year": 2005}, {"title": "An extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "SAT, Vol. 2919 of Lecture Notes in Computer Science,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2003\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2003}, {"title": "Translating pseudo-Boolean constraints into SAT", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "JSAT,", "citeRegEx": "E\u00e9n and S\u00f6rensson,? \\Q2006\\E", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2006}, {"title": "Symmetry breaking as a prelude to implied constraints: A constraint modeling pattern", "author": ["A.M. Frisch", "C. Jefferson", "I. Miguel"], "venue": "In Proc. 16th Euro. Conf. on AI,", "citeRegEx": "Frisch et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Frisch et al\\.", "year": 2004}, {"title": "Demonstration of a word design strategy for DNA computing on surfaces", "author": ["A.G. Frutos", "Q. Liu", "A.J. Thiel", "A.M.W. Sanner", "A.E. Condon", "L.M. Smith", "R.M. Corn"], "venue": "Journal of Nucleic Acids Research,", "citeRegEx": "Frutos et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Frutos et al\\.", "year": 1997}, {"title": "A dynamic survey of graph labeling", "author": ["J.A. Gallian"], "venue": "The Electronic Journal of Combinatorics, 18.", "citeRegEx": "Gallian,? 2011", "shortCiteRegEx": "Gallian", "year": 2011}, {"title": "The log-support encoding of CSP into SAT", "author": ["M. Gavanelli"], "venue": "Bessiere, C. (Ed.), CP, Vol. 4741 of LNCS, pp. 815\u2013822, Providence, RI, USA. Springer.", "citeRegEx": "Gavanelli,? 2007", "shortCiteRegEx": "Gavanelli", "year": 2007}, {"title": "Toward leaner binary-clause reasoning in a satisfiability solver", "author": ["A.V. Gelder"], "venue": "Ann. Math. Artif. Intell., 43 (1), 239\u2013253.", "citeRegEx": "Gelder,? 2005", "shortCiteRegEx": "Gelder", "year": 2005}, {"title": "Minion: A fast scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "ECAI, Vol. 141 of Frontiers in Artificial Intelligence and Applications,", "citeRegEx": "Gent et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2006}, {"title": "A new encoding of alldifferent into SAT. Proceedings of the 3rd International Workshop on Modeling and Reformulating Constraint Satisfaction Problems, http://www-users.cs.york.ac.uk/frisch/Reformulation/04/ proceedings.pdf", "author": ["I.P. Gent", "P. Nightingale"], "venue": null, "citeRegEx": "Gent and Nightingale,? \\Q2004\\E", "shortCiteRegEx": "Gent and Nightingale", "year": 2004}, {"title": "Heavy-tailed distributions in combinatorial search", "author": ["C.P. Gomes", "B. Selman", "N. Crato"], "venue": "Vol. 1330 of LNCS,", "citeRegEx": "Gomes et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Gomes et al\\.", "year": 1997}, {"title": "Efficient CNF simplification based on binary implication graphs", "author": ["M. Heule", "M. J\u00e4rvisalo", "A. Biere"], "venue": "SAT, Vol. 6695 of Lecture Notes in Computer Science,", "citeRegEx": "Heule et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Heule et al\\.", "year": 2011}, {"title": "Universal Booleanization of constraint models", "author": ["J. Huang"], "venue": "CP2008, Vol. 5202 of Lecture Notes in Computer Science, pp. 144\u2013158.", "citeRegEx": "Huang,? 2008", "shortCiteRegEx": "Huang", "year": 2008}, {"title": "An effective SAT encoding for magic labeling", "author": ["G. J\u00e4ger"], "venue": "Faigle, U., Schrader, R., & Herrmann, D. (Eds.), CTW, pp. 97\u2013100.", "citeRegEx": "J\u00e4ger,? 2010", "shortCiteRegEx": "J\u00e4ger", "year": 2010}, {"title": "Equivalent literal propagation in the DLL procedure", "author": ["C. Li"], "venue": "Discrete Applied Mathematics, 130 (2), 251\u2013276.", "citeRegEx": "Li,? 2003", "shortCiteRegEx": "Li", "year": 2003}, {"title": "Vertex-magic total labelings of graphs", "author": ["J. MacDougall", "M. Miller", "M. Slamin", "W. Wallis"], "venue": "Utilitas Mathematica,", "citeRegEx": "MacDougall et al\\.,? \\Q2002\\E", "shortCiteRegEx": "MacDougall et al\\.", "year": 2002}, {"title": "Coprocessor 2.0 - a flexible CNF simplifier - (tool presentation)", "author": ["N. Manthey"], "venue": "SAT, Vol. 7317 of Lecture Notes in Computer Science,", "citeRegEx": "Manthey,? \\Q2012\\E", "shortCiteRegEx": "Manthey", "year": 2012}, {"title": "BEE", "author": ["A. Metodi"], "venue": "http://amit.metodi.me/research/bee/.", "citeRegEx": "Metodi,? 2012", "shortCiteRegEx": "Metodi", "year": 2012}, {"title": "Compiling finite domain constraints to SAT with BEE", "author": ["A. Metodi", "M. Codish"], "venue": "TPLP,", "citeRegEx": "Metodi and Codish,? \\Q2012\\E", "shortCiteRegEx": "Metodi and Codish", "year": 2012}, {"title": "Boolean equi-propagation for optimized SAT encoding", "author": ["A. Metodi", "M. Codish", "V. Lagoon", "P.J. Stuckey"], "venue": "CP, Vol. 6876 of LNCS,", "citeRegEx": "Metodi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Metodi et al\\.", "year": 2011}, {"title": "Minizinc: Towards a standard CP modeling language", "author": ["N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "G.J. Duck", "G. Tack"], "venue": "In Bessiere, C. (Ed.), CP2007,", "citeRegEx": "Nethercote et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nethercote et al\\.", "year": 2007}, {"title": "CUDD: Colorado University Decision Diagram package", "author": ["F. Somenzi"], "venue": "(Online, accessed 13 April 2011). http://vlsi.colorado.edu/~fabio/CUDD/. Soos, M. (2010). CryptoMiniSAT, v2.5.1. http://www.msoos.org/cryptominisat2.", "citeRegEx": "Somenzi,? 2009", "shortCiteRegEx": "Somenzi", "year": 2009}, {"title": "Compiling finite linear CSP", "author": ["N. Tamura", "A. Taga", "S. Kitagawa", "M. Banbara"], "venue": "into SAT. Constraints,", "citeRegEx": "Tamura et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Tamura et al\\.", "year": 2009}, {"title": "Efficiency of a good but not linear set union algorithm", "author": ["R. Tarjan"], "venue": "JACM, 22 (2), 215\u2013225.", "citeRegEx": "Tarjan,? 1975", "shortCiteRegEx": "Tarjan", "year": 1975}, {"title": "The OPL Optimization Programming Language", "author": ["P. van Hentenryck"], "venue": null, "citeRegEx": "Hentenryck,? \\Q1999\\E", "shortCiteRegEx": "Hentenryck", "year": 1999}, {"title": "The alldifferent constraint: A survey.. CoRR:http://arxiv.org/ abs/cs.PL/0105015", "author": ["W.J. van Hoeve"], "venue": null, "citeRegEx": "Hoeve,? \\Q2001\\E", "shortCiteRegEx": "Hoeve", "year": 2001}], "referenceMentions": [{"referenceID": 26, "context": "Journal of Artificial Intelligence Research 46 (2013) 303\u2013341 Submitted 09/12; published 03/13", "startOffset": 27, "endOffset": 54}, {"referenceID": 24, "context": "In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010).", "startOffset": 56, "endOffset": 69}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way.", "startOffset": 13, "endOffset": 39}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1163}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1185}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1221}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work.", "startOffset": 13, "endOffset": 1241}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work. All of these techniques exhibit a clear trade-off between the amount of simplification obtained and the time it requires. Moreover, the stronger techniques become prohibitive when the SAT model involves hundreds of thousands of variables and millions of clauses. So in CNF simplification tools, time limits on simplification techniques are imposed and/or approximations are used. This paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific problem domain. When SAT solving is applied to encode and solve finite domain constraint problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints provides important structural information that can be applied to drive the process of CNF simplification. To be specific, the constraints in a model induce a partitioning of their CNF encoding to a conjunction of sub-formulae which we call \u201cportions\u201d. The novelty in our approach to CNF simplification is that instead of considering the CNF as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the portions and this information may trigger further simplification in other portions. Because portions are typically much smaller than the entire CNF we can effectively apply stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to how unit propagation is about inferring unit clauses which can then be applied to simplify CNF formulae, equi-propagation is about inferring equational consequences between literals (and Boolean constants). There is a wide body of research on CNF simplification that can be applied to implement equi-propagation which is sometimes called equivalent literal substitution, for example by Gelder (2005). Techniques typically involve binary clause based simplifications using, among others, hyper binary resolution and binary implication graphs.", "startOffset": 13, "endOffset": 3386}, {"referenceID": 7, "context": "For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification language which allows specifying combinatorial problems in a declarative way. At the core of this system is a component which translates specifications to CNF formula. Similarly Sugar (Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve a finite domain constraint satisfaction problem it is first modeled in a constraint language (also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT solver (E\u00e9n & S\u00f6rensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, & Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to the low-level target language FlatZinc for which there exist many solvers. In particular, FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010). Simplifying CNF formulae prior to the application of SAT solving is of the utmost importance and there are a wide range of techniques that can be applied to achieve this goal. See for example the work of Li (2003), E\u00e9n and Biere (2005), Heule, J\u00e4rvisalo, and Biere (2011), and Manthey (2012), and the references therein their work. All of these techniques exhibit a clear trade-off between the amount of simplification obtained and the time it requires. Moreover, the stronger techniques become prohibitive when the SAT model involves hundreds of thousands of variables and millions of clauses. So in CNF simplification tools, time limits on simplification techniques are imposed and/or approximations are used. This paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific problem domain. When SAT solving is applied to encode and solve finite domain constraint problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints provides important structural information that can be applied to drive the process of CNF simplification. To be specific, the constraints in a model induce a partitioning of their CNF encoding to a conjunction of sub-formulae which we call \u201cportions\u201d. The novelty in our approach to CNF simplification is that instead of considering the CNF as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the portions and this information may trigger further simplification in other portions. Because portions are typically much smaller than the entire CNF we can effectively apply stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to how unit propagation is about inferring unit clauses which can then be applied to simplify CNF formulae, equi-propagation is about inferring equational consequences between literals (and Boolean constants). There is a wide body of research on CNF simplification that can be applied to implement equi-propagation which is sometimes called equivalent literal substitution, for example by Gelder (2005). Techniques typically involve binary clause based simplifications using, among others, hyper binary resolution and binary implication graphs. See for example, the work of Heule et al. (2011) and the references therein.", "startOffset": 13, "endOffset": 3577}, {"referenceID": 29, "context": "The BEE tool is available for download (Metodi, 2012).", "startOffset": 39, "endOffset": 53}, {"referenceID": 26, "context": "At one extreme we apply complete equi-propagation which detects all equivalences implied by a formula. Clearly complete equi-propagation is NP-hard. However, complete equi-propagators are feasible as we apply them only to small portions of the formula. When complete equi-propagation is too slow we consider ad-hoc techniques. All of these forms of equi-propagation have in common that they are not driven by the CNF structure (e.g. binary clauses) but rather by the underlying constraint structure from which a CNF was, or is being, generated. The rest of this paper is structured as follows. Section 2 introduces a modeling language for finite domain constraints which consists of just 5 constraint constructs and is sufficient to illustrate the contribution of the paper. We argue that the constraints in a model induce a natural partition of their CNF encoding to smaller portions and that this partition can be used to drive the simplification of the CNF encoding. Section 3 presents equi-propagation which is the first ingredient for our contribution. Equi-propagation is about learning information that will apply to simplify CNF encodings. Section 4 describes a practical basis for implementing equi-propagation. Section 5 introduces the second ingredient: partial evaluation. Given the information derived using equi-propagation, partial evaluation applies to simplify the constraints and in particular to remove Boolean variables from their CNF encodings. Section 6 describes a tool, called BEE (Metodi & Codish, 2012) (Ben-Gurion Equi-propagation Encoder) that is based on equi-propagation and partial evaluation. We introduce here our full constraint language which is similar to Sugar and to the subset of FlatZinc relevant for finite domain constraint problems. We also spell out the special treatment of the all-different constraint in BEE. Section 7 demonstrates the application of BEE. Section 8 presents an experimental evaluation. and Finally Section 9 presents our conclusion. This paper extends earlier work presented by Metodi, Codish, Lagoon, and Stuckey (2011), which first introduced equi-propagation, and also the BEE tool paper (Metodi & Codish, 2012).", "startOffset": 84, "endOffset": 2085}, {"referenceID": 18, "context": "Gavanelli (2007) surveys several of the possible choices (the", "startOffset": 0, "endOffset": 17}, {"referenceID": 35, "context": "We can compute unifyE in almost linear (amortized) time using a variation of the union-find algorithm (Tarjan, 1975).", "startOffset": 102, "endOffset": 116}, {"referenceID": 13, "context": "E\u00e9n and S\u00f6rensson (2006) propose to add redundant clauses, {\u00act,\u00acf, x} and {t, f,\u00acx}.", "startOffset": 0, "endOffset": 25}, {"referenceID": 9, "context": "In practice, rather than these two steps, we can use the \u201cRestrict\u201d operation of Coudert and Madre (1990) (\u201cbdd simplify\u201d in Somenzi, 2009) to create the new BDD more efficiently.", "startOffset": 81, "endOffset": 106}, {"referenceID": 2, "context": "Alternately we can use the method of Bagnara and Schachte (1998) (extended to extract literal equalities as opposed to just variable equalities) to extract all the fixed literals and equivalent literal consequences of the BDD.", "startOffset": 37, "endOffset": 65}, {"referenceID": 29, "context": "BEE can be downloaded (Metodi, 2012) where one can also find the examples from this paper and others.", "startOffset": 22, "endOffset": 36}, {"referenceID": 32, "context": "It is a constraint modeling language similar to FlatZinc (Nethercote et al., 2007), but with a focus on a subset of the language relevant for finite domain constraint problems.", "startOffset": 57, "endOffset": 82}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010).", "startOffset": 72, "endOffset": 87}, {"referenceID": 24, "context": "BEE (Ben-Gurion Equi-propagation Encoder) is a tool which applies to encode finite domain constraint models to CNF. BEE was first introduced by Metodi and Codish (2012). During the encoding process, BEE performs optimizations based on equi-propagation and partial evaluation to improve the quality of the target CNF.", "startOffset": 61, "endOffset": 169}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010).", "startOffset": 73, "endOffset": 239}, {"referenceID": 5, "context": "This is a basic building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by A\u015b\u0131n, Nieuwenhuis, Oliveras, and Rod\u0155\u0131guez-Carbonell (2011) and by Codish and Zazon-Ivry (2010). Constraints (9-14) are about integer relations and operations.", "startOffset": 73, "endOffset": 275}, {"referenceID": 5, "context": "One approach, supported by BEE, decomposes the constraint as an odd-even merger (from the context of odd-even sorting networks) (Batcher, 1968).", "startOffset": 128, "endOffset": 143}, {"referenceID": 34, "context": "The BEE encodings are similar to those applied in Sugar (Tamura et al., 2009).", "startOffset": 56, "endOffset": 77}, {"referenceID": 21, "context": "This is essentially the same as the encoding proposed by Gent and Nightingale (2004). When declaring an integer variable I, the bit-blast in the order encoding applies the corresponding unification I = [x1, .", "startOffset": 57, "endOffset": 85}, {"referenceID": 17, "context": "See for example the survey by Gallian (2011) with more than 1200 references.", "startOffset": 30, "endOffset": 45}, {"referenceID": 25, "context": "This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists a set S of n eight-letter words over the alphabet \u03a3 = {A,C,G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {C,G}; (2) Each pair of distinct words in S differ in at least 4 positions; and (3) For every x, y \u2208 S: xR (the reverse of x) and yC (the word obtained by replacing each A by T , each C by G, and vice versa) differ in at least 4 positions. Mancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques.", "startOffset": 26, "endOffset": 519}, {"referenceID": 25, "context": "This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists a set S of n eight-letter words over the alphabet \u03a3 = {A,C,G, T} with the following properties: (1) Each word in S has exactly 4 symbols from {C,G}; (2) Each pair of distinct words in S differ in at least 4 positions; and (3) For every x, y \u2208 S: xR (the reverse of x) and yC (the word obtained by replacing each A by T , each C by G, and vice versa) differ in at least 4 positions. Mancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques. Their best reported result is a solution with 87 DNA words, obtained in 554 seconds, using an OPL (van Hentenryck, 1999) model with lexicographic order to break symmetry. Frutos, Liu, Thiel, Sanner, Condon, Smith, and Corn (1997) present a strategy to solve this problem where the four letters are modeled by bit-pairs [t,m].", "startOffset": 26, "endOffset": 876}, {"referenceID": 16, "context": "4 Building on the approach described by Frutos et al. (1997), we pose conditions on sets of \u201ct-parts\u201d and \u201cm-parts\u201d, T and M , so that their Cartesian product S = T \u00d7M will satisfy the requirements of the original problem.", "startOffset": 40, "endOffset": 61}, {"referenceID": 26, "context": "MacDougall, Miller, Slamin, and Wallis (2002) conjecture that the n vertex complete graph, Kn, for n \u2265 5 has a vertex magic total labeling with magic constants for a specific range of values of k, determined by n.", "startOffset": 35, "endOffset": 46}, {"referenceID": 25, "context": "The SAT based approach presented by J\u00e4ger (2010) cannot handle these.", "startOffset": 36, "endOffset": 49}, {"referenceID": 26, "context": "In order to take advantage of the BEE simplifications we added symmetry breaking as described by Frisch, Jefferson, and Miguel (2004) and illustrated in Figure 20: Each row is viewed as sequence of four parts A .", "startOffset": 42, "endOffset": 134}, {"referenceID": 20, "context": "We consider three different models for Minion: [M\u201906] indicates results using the BIBD model described by Gent et al. (2006), SymB uses the same model we use for the SAT approach, SymB+, is an enhanced symmetry breaking model with all of the tricks applied also in the [M\u201906] model.", "startOffset": 106, "endOffset": 125}, {"referenceID": 26, "context": "There are also approaches (Li, 2003) that detect and use Boolean equalities during run-time, which are complementary to our approach.", "startOffset": 26, "endOffset": 36}, {"referenceID": 12, "context": "See for example the work of E\u00e9n and Biere (2005) and the references therein.", "startOffset": 28, "endOffset": 49}, {"referenceID": 13, "context": "Ongoing work aims to extend BEE for binary and additional number representations such as mixed radix bases as considered by E\u00e9n and S\u00f6rensson (2006) and further by Codish, Fekete, Fuhs, and Schneider-Kamp (2011).", "startOffset": 124, "endOffset": 149}, {"referenceID": 13, "context": "Ongoing work aims to extend BEE for binary and additional number representations such as mixed radix bases as considered by E\u00e9n and S\u00f6rensson (2006) and further by Codish, Fekete, Fuhs, and Schneider-Kamp (2011).", "startOffset": 124, "endOffset": 212}], "year": 2013, "abstractText": "We present an approach to propagation-based SAT encoding of combinatorial problems, Boolean equi-propagation, where constraints are modeled as Boolean functions which propagate information about equalities between Boolean literals. This information is then applied to simplify the CNF encoding of the constraints. A key factor is that considering only a small fragment of a constraint model at one time enables us to apply stronger, and even complete, reasoning to detect equivalent literals in that fragment. Once detected, equivalences apply to simplify the entire constraint model and facilitate further reasoning on other fragments. Equi-propagation in combination with partial evaluation and constraint simplification provide the foundation for a powerful approach to SAT-based finite domain constraint solving. We introduce a tool called BEE (Ben-Gurion Equi-propagation Encoder) based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of CNF encodings and subsequent speed-ups in SAT solving times.", "creator": "TeX"}}}