{"id": "1402.7025", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Feb-2014", "title": "Exploiting the Statistics of Learning and Inference", "abstract": "We propose algorithms that exploit the redundancy of the data relative to a model by substantially evaluating data cases for each update and thinking about the uncertainty that arises in this process. In the context of learning, we propose to test the probability that a stochastically estimated gradient points more than 180 degrees in the wrong direction. In the context of the MCMC sample, we use stochastic gradients to improve the efficiency of MCMC updates, and hypotheses tests based on adaptive mini-stacks to decide whether a proposed parameter update is accepted or rejected. Finally, we argue that in the context of probability-free MCMC, one must store all the information revealed by all simulations, for example, in a Gaussian process. We conclude that Bayesian methods will play a crucial role in the simulation, but only if we overcome a large number of simulations.", "histories": [["v1", "Wed, 26 Feb 2014 10:47:09 GMT  (80kb,D)", "http://arxiv.org/abs/1402.7025v1", "Proceedings of the NIPS workshop on \"Probabilistic Models for Big Data\""], ["v2", "Tue, 4 Mar 2014 21:12:43 GMT  (81kb,D)", "http://arxiv.org/abs/1402.7025v2", "Proceedings of the NIPS workshop on \"Probabilistic Models for Big Data\""]], "COMMENTS": "Proceedings of the NIPS workshop on \"Probabilistic Models for Big Data\"", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["max welling"], "accepted": false, "id": "1402.7025"}, "pdf": {"name": "1402.7025.pdf", "metadata": {"source": "CRF", "title": "Exploiting the Statistics of Learning and Inference", "authors": ["Max Welling"], "emails": ["m.welling@uva.nl"], "sections": [{"heading": "1 Statistical Learning", "text": "When we learn a parametric model from data we extract the useful information from the data and store it in the parameter-values of the model. Naive algorithms learn all decimal places of the model parameters (up to machine precision) by optimizing some cost function (e.g. the log-likelihood). If the model has a large capacity to store information this might lead to overfitting. Regularization typically avoids parameters to become too large, preventing the learning algorithm to store information in the most significant bits of the parameters. Bayesian methods determine a posterior distribution over parameters, where the prior usually prevents the parameters from becoming too large (similar to regularization) and the integration over the parameters weighted by the posterior effectively destroys the information in the insignificant decimal places of the parameter values. More data usually implies that more bits of our parameters are recruited to store information.\nIn the context of big data, there is the general perception that A) learning is computationally more expensive implying that given a fixed amount of computational resources it takes longer to train good predictive models and B) that with more data overfitting is becoming less of a concern. However, both statements need not necessarily be true. To see why A) may not be true, one can simply imagine subsampling the large dataset into\nar X\niv :1\n40 2.\n70 25\nv1 [\ncs .L\nG ]\n2 6\nFe b\n20 14\na smaller dataset and train a model model fast on the smaller dataset. Any algorithm that takes much longer to reach the same predictive power as this naive subsampling approach clearly does something wrong if one cares at all about the amount of learning per unit time. Before the advent of big data one may not have cared much about reaching the optimal possible predictive performance given some fixed amount of time (or more generally any amount of time unknown in advance). However, one can no longer afford this luxury when there is so much data that most algorithms will simply not completely converge within any reasonable amount of time. In other words, we should be interested in algorithms that when interrupted at any arbitrary time should be optimally predictive, and not with algorithms that perform well only after a very long time. A typical example of the former class of algorithms is \u201dstochastic gradient descent\u201d (SGD), while typical examples of the latter are \u201dbatch learning\u201d and standard Markov chain Monte Carlo sampling algorithms (MCMC). SGD can be expected to do as well as possible for any fixed amount of training time (when the annealing schedule for the stepsize is set wisely), while batch learning and MCMC might return disastrous results when the amount of compute time is limited. As an extreme example, for a very large data-set a batch gradient update might not have done a single update while SGD might have already arrived at a reasonable model.\nTo see why B) is not necessarily true we only have to remember that while data volume grows exponentially, Moore\u2019s law also allows us to train models that grow exponentially in their capacity. In the field of deep learning, this is exactly what seems to be happening: Google and Yahoo! currently train models with billions of parameters. At the same time, the amount of predictive information in data grows slower than the amount of Shannon information [5] namely as N\u03b1 with \u03b1 < 1. This law of diminishing returns of data thus implies that our models are increasing their capacity faster than the amount of predictive information that we need to fill them with. The surprising conclusion is thus that regularization to prevent overfitting is increasingly important rather then increasingly irrelevant. We have seen some evidence of this recently when [11] introduced dropout in an attempt to combat overfitting for deep neural networks. It seems that currently our best models are the ones that overfit to some degree and require regularization or bagging to avoid the overfitting. If, in the context of big data, you are training models that do not straddle the boundary between under- and overfitting, then it is likely that by increasing the capacity of your model (assuming that you have the computational resources to do so) you can reach better predictive performance.\nWe thus argue forcefully that computationally efficient Bayesian methods are becoming increasingly relevant in the big data era: they are relevant because our best high capacity models need them as a protection against overfitting and they need to be computationally efficient in order to deal with the large number of data cases involved. There are essentially two classes of big data Bayesian methods and both are based on stochastic minibatch updates: stochastic gradient variational Bayes [12] and stochastic gradient MCMC [18]. I will say more about the latter later in this paper."}, {"heading": "2 Statistical Optimization", "text": "There is an increasing tendency to cast learning as an optimization problem of some loss function. For example, an SVM is often taught as a quadratic program over Lagrange multipliers and neural network training is taught as an exercise in minimizing weights of some loss function defined on the output units of the network. New powerful tools from the\u201cconvex optimization\u201d literature have encouraged this myopic view of learning to the point that some researchers now hold the view that every learning problem should be cast as a (preferably) convex optimization problem. The tendency to view all learning problems as \u201cmere optimization\u201d which can be successfully attacked with the modern blessings of convex optimization ignores some of the unique properties of learning problems. In other words: learning can indeed be formulated as an optimization problem, but a rather special one that has important features which should not be ignored.\nSo what are these special properties of learning problems that distinguish them from plain vanilla optimization? The main difference lies in the loss function being a function of the data and the data being a random draw from some underlying distribution P . It is thus useful to think of the loss function as a random entity itself, i.e. one that fluctuates under resampling of the data-items from P . One aspect of this randomness is well appreciated by most machine learning researchers, namely that it contains the information necessary to avoid overfitting. Most researchers understand that simply fitting a model by minimizing some loss based on the training data alone might lead to overfitting. The fluctuations caused by resampling the training data will cause the optimal parameter-values to fluctuate and hence determine a distribution of parameters rather than a single value (the frequentist equivalent of the posterior distribution).\nIt is less appreciated that taking the statistical properties of optimization into account during the entire learning process (and not just close to the point of convergence) can be very helpful to increase its computational efficiency. Perhaps the point can be made most forcefully by considering the extreme case of an infinite dataset. Any learning procedure that uses all data at every iteration is doomed to not do anything at all! During the initial stages of learning, when we are trying to the determine the most significant digits of our parameters, the information in the data is highly redundant. In other words: most data items agree on how they recommend changing the parameter values and as a result, one only has to query a small subset of them to get reliable information on how to update parameters. In contrast, close to convergence, most data items disagree on how to change the parameters and the update direction will strongly depend on \u201cwho you ask\u201d. Stochastic gradient descent (SGD) exploits precisely this idea, but does not tie it directly to the statistical properties of the optimization problem, implying that the annealing schedule of the stepsize has to be set by hand. In [6,13] we have proposed methods to increase the minibatch size (instead of decreasing the stepsize), based on statistical hypothesis tests that estimate the probability that a proposed update is more than 180 degrees in the wrong direction, leading to a learning procedure that auto-tunes its optimization hyper-parameters. These methods exploit the redundancy in data in relation to a partially trained model."}, {"heading": "3 Data Redundancy", "text": "As discussed in the previous section, our proposed methods [6,13] for speeding up learning algorithms are based on the notion that far away from convergence only few data-cases are needed to determine a reasonably accurate update. For instance, if we want to learn the mean of a one dimensional Normal distribution, and the current mean is still far away from the sample mean, then we only need to query a few data-cases to know the direction of the update. We may say that the information in the data relevant to the parameter update is highly redundant. It is interesting to emphasize that redundancy is not a property of the data, but of the relation between the model and the data. For instance, close to convergence, about half of the data-cases recommend to update the mean of a Normal distribution to go left, while the other half recommend to update it to go right. At the ML estimate, the redundancy is exactly zero.\nWe will try to catch this intuition in a new measure, namely the \u201clearning signalto-noise ratio\u201d (LSNR) that measures how much learning signal there is relative to the noise of resampling the data-items. We will see that in the initial stages of learning this LSNR is large which means that we can use a smaller random subset of the data to estimate the gradient direction of the loss function reliably. As learning proceeds, the LSNR gradually decreases below 1 prompting us to increase the size of our minibatch. Eventually, the LSNR will drop below 1 even when we are using all the data available to us. At this point in the learning process the learning signal is too faint to be useful, i.e. the gradient direction could easily swing 180 degrees if we would have used a different dataset of the same size. More parameter updates on the current dataset would thus lead to overfitting and aversely affect generalization performance. We can avoid this by simply terminating the parameter updates at that point or by switching to more sophisticated methods such as bagging [7]. The proposed metric is inherently frequentist because it reasons about resampling data-sets, however we believe similar metrics can de devised to monitor data redundancy for model parameters in a Bayesian setting.\nDenote with g\u0304 = 1n \u2211n i=1\u2207\u03b8`(xi;\u03b8) where `(\u00b7) is a general objective function, D = {xi} denotes the data and \u03b8 denotes the parameters of the problem. Furthermore, denote with S the sample variance-covariance matrix of the gradients,\nS = 1\nn\u2212 1 n\u2211 i=1 (\u2207\u03b8`(xi;\u03b8)\u2212 g\u0304)(\u2207\u03b8`(xi;\u03b8)\u2212 g\u0304)T (1)\nIf n is large enough, according to the central limit theorem, the covariance matrix of the average gradients is then given as Sg\u0304 \u2248 1nS.\nWe are interested in the value of the signal in the gradient, given by g\u0304 relative to the noise we expect under resampling of the data-items, given by Sg\u0304. We propose the following measure:\nLSNRp = 1\np g\u0304TS\u22121g\u0304 g\u0304 \u2248\nn p g\u0304TS\u22121g\u0304 (2)\nwhere p indicates the number of parameters. A useful property of this metric is that it is invariant under linear transformations of the form gi \u2192 Mgi. In particular, it is therefore independent of the stepsize \u03b7 used in\na gradient descend algorithm. We can determine the sampling distribution1 of LSNRp when n 1.\nLemma: The random variable p\u00d7 LSNRp is asymptotically (n 1) distributed as,\np\u00d7 LSNRp = ng\u0304TS\u22121g\u0304 \u223c \u03c72p(n\u00b5T\u03a3\u22121\u00b5) (4)\nwhere \u03c72p(n\u00b5 T\u03a3\u22121\u00b5) is a non-central \u03c72-distribution with p degrees of freedom and location parameter n\u00b5T\u03a3\u22121\u00b5. To obtain the distribution for LSNRp (as opposed to p\u00d7 LSNRp) we use that X/p \u223c pPX(pX).\nThe behavior of P (LSNRp) is exactly as expected. As we increase n we expect that the mean of this distribution becomes more positive because the variance in the computation of the gradients is expected to decrease as 1/n. Indeed, we see that the mean of the distribution, given by E[LSNRp] = np\u00b5\nT\u03a3\u22121\u00b5 + 1, grows linearly in n. We can also compute the variance, which is given by the expression V[LSNRp] = 2 p2 (p + 2n\u00b5\nT\u03a3\u22121\u00b5). We note that the variance is of the order of the mean implying we should always expect significant fluctuations in the LSNRp under resampling the dataset.\nTwo opposing effects determine the value of the LSNRp during the execution of a learning algorithm. The first effect is the one mentioned in the previous paragraph, namely that with increasing mini-batchsize nt the LSNRp increases because the fluctuations of the gradient are tempered due to central limit tendencies. The second effect is determined by how close to convergence we are in the learning process. If we are far from convergence the average gradient is expected to be large, even for small mini-batches. However, very close to convergence the average gradient is almost zero (actually zero at convergence by definition), meaning that the LSNR is also very small. In fact, for every finite dataset there will always be a point before convergence where the signal is not big enough to overcome the sampling noise.\nHow should we then use this LSNRp metric inside a learning algorithm? We envision a procedure where we compute the LSNRp at every iteration of learning to monitor the signal-to-noise ratio of the learning gradient. This could be useful in batch mode in order to decide when to stop the parameter updates, or this can be computed for a mini-batch Bt to decide when to increase the mini-batch size. To compute the LSNRp one first estimates the mean and covariance from their sample estimators. In other words, we first compute the empirical gradients for every data-case in our current minibatch, gi = \u2207\u03b8`(xi). From this we compute the sample mean and sample\n1 To see why this is true, we first note that the sample mean and covariance converge in probability to their respective population values for large enough n.\ng\u0304 = 1\nn n\u2211 i=1 xi P\u2192 \u00b5, S = 1 n\u2212 1 n\u2211 i=1 (xi \u2212 x\u0304)(xi \u2212 x\u0304)T P\u2192 \u03a3 (3)\nThis means that according to Slutsky\u2019s theorem we can replace S \u2192 \u03a3 in the expression for LSNRp when n 1. We furthermore notice that according the central limit theorem g\u0304 \u223c N [\u00b5, 1\nn \u03a3]. We can then finally transform to \u03bd = n\n1 2\u03a3\u2212 1 2 g\u0304 with \u03bd \u223c N [n 1 2\u03a3\u2212 1 2\u00b5, I] and note that \u03bdT\u03bd = \u2211p\nj=1 \u03bd 2 j \u223c \u03c72p(n\u00b5T\u03a3\u22121\u00b5), which is what we wanted to show.\ncovariance,\n\u00b5 \u2248 \u02c6\u0304g = 1 nt \u2211 i\u2208Bt \u2207\u03b8`(xi;\u03b8) (5) \u03a3 \u2248 S\u0302 = 1 nt \u2212 1 \u2211 i\u2208Bt (\u2207\u03b8`(xi;\u03b8)\u2212 \u02c6\u0304g)(\u2207\u03b8`(xi;\u03b8)\u2212 \u02c6\u0304g)T (6)\nwhere the hatted variables are computed on the actual dataset (e.g. they are not random variables but numbers), and Bt is the minibatch used at iteration t. This mini-batch should not be resampled at every iteration because the LSNRp decreases relative to a fixed mini-batch.\nNext, we use these estimates to compute the non-centrality parameter of the \u03c72 distribution: nt\u00b5T\u03a3\u22121\u00b5 \u2248 nt \u02c6\u0304gT S\u0302\u22121 \u02c6\u0304g. We emphasize that this computation scales with nt, the size of the current mini-batch, and is thus relatively cheap. Using these we can for instance compute a threshold for deciding when the signal to noise ratio is too small to make meaningful updates. We suggest the following criterion,\nP (LSNRp < 1) > \u03b4 \u2194 CDF (LSNRp = 1) > \u03b4 (7)\nwhere \u03b4 = 0.5 seems a reasonable threshold. If this criterion is met one of two things might happen: 1) either we need to increase the size of the minibatch used to determine the gradient along which we are making weight updates, or 2) in case there is no more data available we terminate updating parameters in order to avoid overfitting.\nTo illustrate these ideas, we fit a logistic regression classifier (a.k.a. perception with logistic loss) on 10 features of the spam data dataset. We learn with all 3681 data-items at every iteration. In Figure 1 (left) we show the value of LSNRp as it evolves over time. We clearly see that it starts out large and decays rapidly towards zero. The red dashed line is the value of LSNRp = 1. Figure 1 (right) shows the value the cumulative\ndistribution of LSNRp evaluated at LSNRp = 1. Thus, it represent the cumulative probability mass for the event LSNRp < 1. Our proposed criterion 7 says that we should stop learning when it\u2019s value is larger than 0.5, which is indicated with the red dashed line in the plot. Due to the asymmetry in the \u03c72-distribution this threshold is actually more conservative than LSNRp = 1 which is reached earlier.\nThe plots of Figure 2 show the \u03c72 distribution in the initial phases of learning (left) and close to convergence (right). We also show a histogram of LSNRp values obtained by first subsampling 1000 bootstrap samples of size n = 3681 from the original dataset and then computing the LSNRp value of those bootstrap samples. While bootstrap samples are not IID (independently identically distributed) they are generally accepted as a reasonable measure to assess variation under resampling of the dataset. We see that the fit of the \u03c72 is not perfect, but does provide a very reasonable approximation of the distribution of the LSNRp values obtained through bootstrapping. Note that the LSNRp is much larger on average when the model fit is still bad."}, {"heading": "4 Statistical MCMC Inference", "text": "We now ask the question whether Bayesian posterior inference is ready to face the challenges of big data. Unfortunately, the answer is an unqualified no. Bayesian inference requires (an approximation of) the entire posterior distribution of parameters given data. Almost none of the standard posterior inference methods make use of statistical properties to improve the computational efficiency of inference (with the exception of [12]). Let\u2019s consider the workhorse of Bayesian inference, MCMC sampling. Every MCMC algorithm that samples parameter instances from the posterior distribution p(\u03b8|D) has to consider all data-items at every iteration. Thus, for the imaginary infinite dataset this algorithm comes to a grinding halt even before it starts. Even though for an infinite dataset the posterior consists of a single point (the \u201cmaximum a posteriori\u201d value) the\nMCMC sampler never gets even close. The reason is that every MCMC procedure starts with a \u201cburn in\u201d phase which often looks like a form of noisy optimization. However, standard MCMC procedures enforce detailed balance right from the start, which causes them to spend an unreasonably long time to finish burning in. For very large datasets, this might imply that MCMC procedures are likely not to even finish burning in, rendering them effectively useless in this context.\nBut even close to convergence (after burn-in has finished), one can also benefit from the view proclaimed in the previous sections, namely that one should care about the best possible performance in a given (possibly unknown) amount of compute time. Traditional MCMC procedures assume that their chains can finish burning in and that a sufficient number of samples can be obtained to reduce the sampling variance thereafter. In the context of big data this might simply not be true anymore and it might become beneficial to design samplers that acquire samples faster but from an approximation of the true posterior (at least initially). By sampling faster, one can obtain a larger number of samples in a given amount of time and thus reduce sampling error due to variance.\nThe total error can be expressed as the \u201drisk\u201d (the expected difference between the estimated average value of some function and its true average value). The risk in turn can be decomposed into the sampling error (or variance), which disappears for an infinite number of samples, and the bias, which represents a systematic error that does not go away asymptotically. The traditional view in MCMC has always been that one has enough time to reduce the sampling error to an arbitrary small value. While this view was reasonable at times when the datasets contained a few hundred items, in the era of big data we need to acknowledge that we only have finite computational resources (a.k.a. CPU cycles) to obtain the lowest risk in a fixed amount of time. Under these circumstances and depending on how much compute time one has available, it might be wiser to use a biased sampler in order to generate more samples and thus reduce the error due to variance faster. It should be mentioned that machine learning practitioners have already embraced this view some time ago in the context of posterior inference through biased methods such as variational Bayesian inference [4,3,16]and expectation propagation [15].\nI will briefly discuss two recent attempts by me and my collaborators to negotiate this tradeoff between bias and variance. The first approximate MCMC sampler is based on Langevin dynamics (LD). LD simply boils down to batch gradient descent with a stepsize \u03b5 plus the addition of normally distributed noise with mean equal to 0 and variance equal to \u03b5. The coupling of the noise variance and the stepsize leads to Brownian motion type behavior of this dynamical system in the limit \u03b5 \u2192 0 with an equilibrium distribution equal to the posterior distribution. Instead of using a very small stepsize it is often more efficient to treat one step of Langevin dynamics with finite stepsize as a proposal distribution within an ordinary MCMC algorithm and use a Metropolis Hastings (MH) accept-reject step to sample form the correct distribution asymptotically. A natural thought is thus to replace the full (batch) gradient computation by a stochastic minibatch estimate of it. One can show [18] that when the stepsize \u03b5t is annealed to zero using the same conditions as the ones imposed for stochastic gradient descent in order to guarantee its convergence, namely \u2211 t \u03b5t =\u221e, \u2211 t \u03b5 2 t <\u221e, as T \u2192\u221e this dynamical system samples from the correct distribution. If we also ignore (for the moment)\nthe MH correction then the updates of this \u201cstochastic gradient Langevin dynamics\u201d (SGLD) are O(n) instead of O(N) with n << N the size of the stochastically chosen minibatch. In practice, we do not anneal the stepsize all the way to zero because in this limit the sampler is not mixing anymore. By stopping at a finite value of the stepsize we thus accept a certain bias in the equilibrium distribution at the benefit of being able to sample much faster.\nSGLD has a number of interesting properties that make it an ideal candidate for large scale Bayesian posterior inference. The first observation is that for large stepsizes the noise induced by subsampling dominates the injected Gaussian noise because the subsampling noise has a variance O(\u03b52) while the injected noise has a variance O(\u03b5). For large stepsize, the algorithm thus effectively acts as stochastic gradient descent (SGD). However, when the stepsize gets smaller, the injected noise starts to dominate implying that the algorithm behaves as Langevin dynamics. If the annealing is thus done carefully, the algorithm switches from an efficient optimization algorithm into a posterior sampling algorithm. This effect can be further enhanced by using the empirical inverse Fisher information as a preconditioning matrix turning gradient descent into a form of stochastic Fisher scoring [1].\nA second property, namely that it only needs a small subset of data to generate samples, makes SGLD ideally suited as a distributed sampling algorithm. When a dataset is too large to store on a single server and the data is therefore distributed among multiple servers, traditional MCMC algorithms typically require these servers to communicate information for every sample generated. However, SGLD is able to make multiple parameter updates per server by subsampling the data on a single server without any communication [2]. This flexibility allows one to avoid servers having to sit idle and wait for other servers to finish their computation, even when servers store different amounts of data or have different processing speeds. The trick is to let all servers compute for the same amount of time before communicating their last parameter values to another randomly picked server, but to compensate potential bias due to unequal data volume or processing speed by adapting their relative stepsizes.\nOmitting the MH accept step can result in a strong bias if there are regions where the probability drops very quickly. SGLD can step into these regions without being rejected and then due to a very large gradient get \u201ccatapulted\u201d out. Motivated by this issue we investigated if we can design MCMC algorithms with MH steps that only depend on a small subset of the data. Naturally, without inspecting all the data at every iteration we will need to allow some errors to occur, but the question is if the number of errors can be controlled. To achieve this one can reformulate the MH test as a sequential hypothesis test. Given the uniform random variable u that is used to make the final decision on whether to accept or reject, we are testing the sign of the mean of differences in loglikelihood between two parameter values:\n\u00b5 = 1\nN N\u2211 i=1 ( `(xi;\u03b8 \u2032)\u2212 `(xi;\u03b8t) ) > \u00b50? (8)\nwith \u00b50 some constant that depends on u, the proposal distribution and the prior. Since this is a sum of terms we expect that this quantity is normally distributed when the number of terms in the sum is large enough. We start with an initial test with a small\nminibatch of size n and compute the probability that \u00b5 < \u00b50 or \u00b5 > \u00b50. If we have enough confidence in either of these two possibilities we can accept or reject the new parameter value with a pre-specified confidence level. If neither is the case, we need to increase our minibatch size in order to increase the confidence level. By sampling new data-cases without replacement the standard deviation of distribution for \u00b5 behaves as,\n\u03c3(\u00b5) \u221d 1\u221a n\n\u221a 1\u2212 n\nN (9)\nwhere the first time is the usual 1\u221a n behavior of the standard deviation of an average and the second term results from the fact that we are sampling without replacement. The second term is important in the sense that the standard deviation converges to 0 when n approaches N , implying that in that case an accept or reject decision will be made with 100% confidence, consistent with a normal MH step.\nAn uncertain MH step is yet another way to negotiate the bias-variance tradeoff. Just like the stepsize in SGLD was a knob that traded off the error due to bias with error due to variance, here the confidence threshold for making an accept or reject decision acts as a bias-variance knob. If we make decisions quickly based on small minibatches of data we are bound to make more mistakes (accept moves that should be rejected and vice versa), but can collect more samples in a given amount of time (high bias, small variance). The algorithm reverts back to the standard MH-MCMC algorithm when all bias is eliminated and all error is due to variance.\nWe anticipate that many more algorithms can be developed along these lines. Indeed, [10] have developed a slice sampler variant based on these principles while [8] have developed a minibatch Hamiltonian Monte Carlo algorithm."}, {"heading": "5 Big Simulations", "text": "Leaving the scene of big data we will now discuss the realm of big simulations. Just like the big data setting, Bayesian inference can play a crucial role in this context but is challenged computationally to its very limit. What then do we mean with \u201dbig simulations\u201d?\nOutside of machine learning, where we are happily playing with our graphical models and neural networks, scientists such as astronomers, meteorologists, seismologists, biologists and so on express their expert knowledge in terms of extremely complex simulators. To give an example of how extremely complex these simulations can get: the SCEC \u201cShakeout simulation\u201d of 360 minutes of earthquake simulation along the San Andreas fault in California took 220 teraflops per second for 24 hours on a NCCS Jaguar supercomputer with 223,074 cores [9]. The typical simulator has a number of free parameters to be tuned in order to fit the observations well. Invariably the approach taken is to perform a grid search, systematically scanning through parameter values and comparing the outcome of the simulation with observations. Clearly, for very expensive simulations and high dimensional parameter spaces this is a hopeless endeavor. The recent advances in Bayesian optimization [17] should prove to be a huge help in replacing grid search by a smarter form of parameter exploration However, scientists\nwant and need to know more about their simulator than just a single optimal parameter setting. Questions such as: \u201dDoes my simulator fit the data well because I have captured the true underlying physical process or because my model is so flexible that I am overfitting.\u201d can not be answered by identifying a single optimal parameter setting. Instead, one needs to study the posterior predictive distributions, i.e.\np(X|D) = \u222b d\u03b8P (X|\u03b8)P (\u03b8|D) (10)\nand compare them with the actual observations. For the above expression it should be noted that P (X|\u03b8) is not available as an analytic expression but only indirectly through a simulator. Precisely because of this reason it is also difficult to compute the posterior distribution P (\u03b8|D), for which a special class of likelihood-free MCMC algorithms has been developed generally known as \u201dApproximate Bayesian Computation\u201d (ABC).\nWhile the field of ABC is relatively well matured, we believe it is not ready to face the computational challenges of the very complex simulations that require supercomputers to execute. We like to emphasize the importance of this issue. While Moore\u2019s law allows scientists to design increasingly complex simulations, if they don\u2019t have the statistical tools to reliably verify if their models describe the truth then scientific progress comes to a grinding halt. The challenge for the computational statisticians and the machine learners is to turn this state of affairs around.\nA typical ABC algorithm works as follows. Like in ordinary MCMC we propose a new parameter value from some proposalQ(\u03b8\u2032|\u03b8t). But due to the lack of an expression for the likelihood we cannot directly compute the probability of accepting this proposed parameter value. Instead, we will conduct a number of simulations and compare these simulations with the observations. Then, we accept the new parameter value if the simulations of the new model \u03b8\u2032 are not much worse then the ones generated form the old model \u03b8t using the usual MH mechanism. There are various ways to compare the two collections of simulations but all require one to perform multiple simulations for every proposed new parameter value. For complex simulators, this is simply too expensive to be of use.\nHow can this conundrum be resolved? In our opinion the answer lies in the fact that traditional ABC methods do not make efficient use of the information extracted from every simulation. Imagine our MCMC sampler would, after some detour, arrive back at a parameter value very close to the one where we just did an expensive simulation. Assuming some smoothness in the (unknown) likelihood we should be able to reuse the old simulation in order to make an informed decision about this new parameter value. Thus, we should store the information for all previous simulations and reuse them to make MH accept/reject decisions in the future. By learning a surrogate function of the unknown likelihood surface we can at some point avoid simulations altogether. The situation is somewhat similar to the approximate MH step introduced in the context of big data in that we will need to estimate the uncertainty in MH decisions and request more simulations only when the confidence in the MH decision is too low.\nIn [14] we proposed the following procedure based on the notion of a synthetic likelihood [19]. The \u201cnaive\u201d synthetic likelihood procedure generates a number of samples at every iteration (for every parameter value) and fits a normal distribution through these samples. It then computes the probability (likelihood) of the observations under\nthis Gaussian model inside the MH step. Our Gaussian Process Surrogate (GPS) procedure updates a Gaussian process (GP) instead of recalculating the Gaussian likelihood for every proposed parameter value. In that way, the information of all simulations is stored in the GP and for every pair of old and new parameters (\u03b8t,\u03b8\u2032) we can compute a full probability distribution over all the observed sufficient statistics P (X|\u03b8), including the uncertainty in these distributions. If this uncertainty is too high our accept or reject decisions are are too uncertain triggering a request for more simulations. At what parameter values these new simulations are conducted is entirely at the discretion of the algorithm and need not not coincide with (\u03b8t,\u03b8\u2032). Clearly, the longer we sample, the more we reduce the uncertainties in our GP and the less simulations will be requested in the future.\nThere are a number of additional dimensions along which this process can be further optimized. It would for instance be nice to use a procedure akin to Bayesian optimization to propose new parameter values to be examined. However, guaranteeing that this chain converges to the correct distributions is difficult because detailed balance is lost. Learning the GP\u2019s hyper-parameters and extending the GP to deal with potential heteroscedasticity are also important directions of further refinement."}, {"heading": "6 Conclusions", "text": "Our claim is that in the context of large datasets and complex simulations, it is imperative that we leverage the statistical properties of the learning and inference process. Intuitively, we want to maximize the amount of information that we transfer from data or simulations to parameters per unit of computation. We are thus drawn to the conclusion that computation must be an essential ingredient of the overall objective. The traditional view of learning and inference could be maintained because the datasets of \u201dthe old days\u201d were small enough and the simulations of \u201dthe old days\u201d were simple enough, so that relatively expensive optimization or inference procedures would still converge in a matter of hours. However, when one is faced with 1 billion data-cases or a simulation that runs 24 hours on a supercomputer the equation changes dramatically and one is forced to rethink traditional inference methods such as MCMC. We predict that Bayesian methods will remain to play an important role in an era where data volume and simulation complexity grow exponentially only of we manage to overcome a number of computational challenges."}], "references": [{"title": "Bayesian posterior sampling via stochastic gradient fisher scoring", "author": ["S. Ahn", "A. Korattikara", "M. Welling"], "venue": "In International Conference on Machine Learning,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2012}, {"title": "Distributed stochastic gradient mcmc", "author": ["S. Ahn", "B. Shahbaba", "M. Welling"], "venue": "Technical report, University of California Irvine,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "A Bayesian framework for graphical models", "author": ["H. Attias"], "venue": "In Advances in Neural Information Processing Systems \u2013 NIPS,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2000}, {"title": "The variational Bayesian EM algorithm for incomplete data: with application to scoring graphical model structures", "author": ["M.J. Beal", "Z. Ghahramani"], "venue": "In Bayesian Statistics,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "Predictability, complexity and learning", "author": ["W. Bialek", "I. Nemenman", "N. Tishby"], "venue": "Neural Computation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2001}, {"title": "Statistical tests for optimization efficiency", "author": ["L. Boyles", "A. Korattikara", "D. Ramanan", "M. Welling"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Stochastic gradient hamiltonian monte carlo", "author": ["T. Chen", "E.B. Fox", "C. Guestrin"], "venue": "Technical report, University of Washington,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2014}, {"title": "Approximate slice sampling for bayesian posterior inference", "author": ["C. DuBois", "A. Korattikara", "M. Welling", "P. Smyth"], "venue": "In Artificial Intelligence and Statistics,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2014}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": "Technical Report abs/1207.0580,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Online learning for latent dirichlet allocation", "author": ["M. Hoffman", "D. Blei", "F. Bach"], "venue": "In Neural Information Processing Systems,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Statistical optimization of nonnegative matrix factorization", "author": ["A. Korattikara", "L. Boyles", "M. Welling", "J. Kim", "H. Park"], "venue": "In Artificial Intelligence and Statistics,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2011}, {"title": "Gps-abc: Gaussian process surrogate approximate bayesian computation", "author": ["T. Meeds", "M. Welling"], "venue": "arXiv 1401.2838,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2013}, {"title": "Expectation propagation for approximate Bayesian inference", "author": ["T. Minka"], "venue": "In Proc. of the Conf. on Uncertainty in Artificial Intelligence,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2001}, {"title": "A view of the EM algorithm that justifies incremental, sparse and other variants", "author": ["R.M. Neal", "G.E. Hinton"], "venue": "Learning in Graphical Models,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1999}, {"title": "Practi- cal bayesian optimization of machine learning algorithms", "author": ["J. Snoek", "H. Larochelle", "R.A. Adams"], "venue": "In Neural Information Processing Systems,,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Bayesian learning via stochastic gradient langevin dynamics", "author": ["M. Welling", "Y.W. Teh"], "venue": "In Proceedings of the 28th International Conference on Machine Learning (ICML),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Statistical inference for noisy nonlinear ecological dynamic systems", "author": ["S.N. Wood"], "venue": "Nature, 466(7310):1102\u20131104,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2010}], "referenceMentions": [{"referenceID": 4, "context": "At the same time, the amount of predictive information in data grows slower than the amount of Shannon information [5] namely as N with \u03b1 < 1.", "startOffset": 115, "endOffset": 118}, {"referenceID": 8, "context": "We have seen some evidence of this recently when [11] introduced dropout in an attempt to combat overfitting for deep neural networks.", "startOffset": 49, "endOffset": 53}, {"referenceID": 9, "context": "There are essentially two classes of big data Bayesian methods and both are based on stochastic minibatch updates: stochastic gradient variational Bayes [12] and stochastic gradient MCMC [18].", "startOffset": 153, "endOffset": 157}, {"referenceID": 15, "context": "There are essentially two classes of big data Bayesian methods and both are based on stochastic minibatch updates: stochastic gradient variational Bayes [12] and stochastic gradient MCMC [18].", "startOffset": 187, "endOffset": 191}, {"referenceID": 5, "context": "In [6,13] we have proposed methods to increase the minibatch size (instead of decreasing the stepsize), based on statistical hypothesis tests that estimate the probability that a proposed update is more than 180 degrees in the wrong direction, leading to a learning procedure that auto-tunes its optimization hyper-parameters.", "startOffset": 3, "endOffset": 9}, {"referenceID": 10, "context": "In [6,13] we have proposed methods to increase the minibatch size (instead of decreasing the stepsize), based on statistical hypothesis tests that estimate the probability that a proposed update is more than 180 degrees in the wrong direction, leading to a learning procedure that auto-tunes its optimization hyper-parameters.", "startOffset": 3, "endOffset": 9}, {"referenceID": 5, "context": "As discussed in the previous section, our proposed methods [6,13] for speeding up learning algorithms are based on the notion that far away from convergence only few data-cases are needed to determine a reasonably accurate update.", "startOffset": 59, "endOffset": 65}, {"referenceID": 10, "context": "As discussed in the previous section, our proposed methods [6,13] for speeding up learning algorithms are based on the notion that far away from convergence only few data-cases are needed to determine a reasonably accurate update.", "startOffset": 59, "endOffset": 65}, {"referenceID": 9, "context": "Almost none of the standard posterior inference methods make use of statistical properties to improve the computational efficiency of inference (with the exception of [12]).", "startOffset": 167, "endOffset": 171}, {"referenceID": 3, "context": "It should be mentioned that machine learning practitioners have already embraced this view some time ago in the context of posterior inference through biased methods such as variational Bayesian inference [4,3,16]and expectation propagation [15].", "startOffset": 205, "endOffset": 213}, {"referenceID": 2, "context": "It should be mentioned that machine learning practitioners have already embraced this view some time ago in the context of posterior inference through biased methods such as variational Bayesian inference [4,3,16]and expectation propagation [15].", "startOffset": 205, "endOffset": 213}, {"referenceID": 13, "context": "It should be mentioned that machine learning practitioners have already embraced this view some time ago in the context of posterior inference through biased methods such as variational Bayesian inference [4,3,16]and expectation propagation [15].", "startOffset": 205, "endOffset": 213}, {"referenceID": 12, "context": "It should be mentioned that machine learning practitioners have already embraced this view some time ago in the context of posterior inference through biased methods such as variational Bayesian inference [4,3,16]and expectation propagation [15].", "startOffset": 241, "endOffset": 245}, {"referenceID": 15, "context": "One can show [18] that when the stepsize \u03b5t is annealed to zero using the same conditions as the ones imposed for stochastic gradient descent in order to guarantee its convergence, namely \u2211 t \u03b5t =\u221e, \u2211 t \u03b5 2 t <\u221e, as T \u2192\u221e this dynamical system samples from the correct distribution.", "startOffset": 13, "endOffset": 17}, {"referenceID": 0, "context": "This effect can be further enhanced by using the empirical inverse Fisher information as a preconditioning matrix turning gradient descent into a form of stochastic Fisher scoring [1].", "startOffset": 180, "endOffset": 183}, {"referenceID": 1, "context": "However, SGLD is able to make multiple parameter updates per server by subsampling the data on a single server without any communication [2].", "startOffset": 137, "endOffset": 140}, {"referenceID": 7, "context": "Indeed, [10] have developed a slice sampler variant based on these principles while [8] have developed a minibatch Hamiltonian Monte Carlo algorithm.", "startOffset": 8, "endOffset": 12}, {"referenceID": 6, "context": "Indeed, [10] have developed a slice sampler variant based on these principles while [8] have developed a minibatch Hamiltonian Monte Carlo algorithm.", "startOffset": 84, "endOffset": 87}, {"referenceID": 14, "context": "The recent advances in Bayesian optimization [17] should prove to be a huge help in replacing grid search by a smarter form of parameter exploration However, scientists", "startOffset": 45, "endOffset": 49}, {"referenceID": 11, "context": "In [14] we proposed the following procedure based on the notion of a synthetic likelihood [19].", "startOffset": 3, "endOffset": 7}, {"referenceID": 16, "context": "In [14] we proposed the following procedure based on the notion of a synthetic likelihood [19].", "startOffset": 90, "endOffset": 94}], "year": 2017, "abstractText": "When dealing with datasets containing a billion instances or with simulations that require a supercomputer to execute, computational resources become part of the equation. We can improve the efficiency of learning and inference by exploiting their inherent statistical nature. We propose algorithms that exploit the redundancy of data relative to a model by subsampling data-cases for every update and reasoning about the uncertainty created in this process. In the context of learning we propose to test for the probability that a stochastically estimated gradient points more than 180 degrees in the wrong direction. In the context of MCMC sampling we use stochastic gradients to improve the efficiency of MCMC updates, and hypothesis tests based on adaptive mini-batches to decide whether to accept or reject a proposed parameter update. Finally, we argue that in the context of likelihood free MCMC one needs to store all the information revealed by all simulations, for instance in a Gaussian process. We conclude that Bayesian methods will remain to play a crucial role in the era of big data and big simulations, but only if we overcome a number of computational challenges. 1 Statistical Learning When we learn a parametric model from data we extract the useful information from the data and store it in the parameter-values of the model. Naive algorithms learn all decimal places of the model parameters (up to machine precision) by optimizing some cost function (e.g. the log-likelihood). If the model has a large capacity to store information this might lead to overfitting. Regularization typically avoids parameters to become too large, preventing the learning algorithm to store information in the most significant bits of the parameters. Bayesian methods determine a posterior distribution over parameters, where the prior usually prevents the parameters from becoming too large (similar to regularization) and the integration over the parameters weighted by the posterior effectively destroys the information in the insignificant decimal places of the parameter values. More data usually implies that more bits of our parameters are recruited to store information. In the context of big data, there is the general perception that A) learning is computationally more expensive implying that given a fixed amount of computational resources it takes longer to train good predictive models and B) that with more data overfitting is becoming less of a concern. However, both statements need not necessarily be true. To see why A) may not be true, one can simply imagine subsampling the large dataset into ar X iv :1 40 2. 70 25 v1 [ cs .L G ] 2 6 Fe b 20 14 a smaller dataset and train a model model fast on the smaller dataset. Any algorithm that takes much longer to reach the same predictive power as this naive subsampling approach clearly does something wrong if one cares at all about the amount of learning per unit time. Before the advent of big data one may not have cared much about reaching the optimal possible predictive performance given some fixed amount of time (or more generally any amount of time unknown in advance). However, one can no longer afford this luxury when there is so much data that most algorithms will simply not completely converge within any reasonable amount of time. In other words, we should be interested in algorithms that when interrupted at any arbitrary time should be optimally predictive, and not with algorithms that perform well only after a very long time. A typical example of the former class of algorithms is \u201dstochastic gradient descent\u201d (SGD), while typical examples of the latter are \u201dbatch learning\u201d and standard Markov chain Monte Carlo sampling algorithms (MCMC). SGD can be expected to do as well as possible for any fixed amount of training time (when the annealing schedule for the stepsize is set wisely), while batch learning and MCMC might return disastrous results when the amount of compute time is limited. As an extreme example, for a very large data-set a batch gradient update might not have done a single update while SGD might have already arrived at a reasonable model. To see why B) is not necessarily true we only have to remember that while data volume grows exponentially, Moore\u2019s law also allows us to train models that grow exponentially in their capacity. In the field of deep learning, this is exactly what seems to be happening: Google and Yahoo! currently train models with billions of parameters. At the same time, the amount of predictive information in data grows slower than the amount of Shannon information [5] namely as N with \u03b1 < 1. This law of diminishing returns of data thus implies that our models are increasing their capacity faster than the amount of predictive information that we need to fill them with. The surprising conclusion is thus that regularization to prevent overfitting is increasingly important rather then increasingly irrelevant. We have seen some evidence of this recently when [11] introduced dropout in an attempt to combat overfitting for deep neural networks. It seems that currently our best models are the ones that overfit to some degree and require regularization or bagging to avoid the overfitting. If, in the context of big data, you are training models that do not straddle the boundary between underand overfitting, then it is likely that by increasing the capacity of your model (assuming that you have the computational resources to do so) you can reach better predictive performance. We thus argue forcefully that computationally efficient Bayesian methods are becoming increasingly relevant in the big data era: they are relevant because our best high capacity models need them as a protection against overfitting and they need to be computationally efficient in order to deal with the large number of data cases involved. There are essentially two classes of big data Bayesian methods and both are based on stochastic minibatch updates: stochastic gradient variational Bayes [12] and stochastic gradient MCMC [18]. I will say more about the latter later in this paper. 2 Statistical Optimization There is an increasing tendency to cast learning as an optimization problem of some loss function. For example, an SVM is often taught as a quadratic program over Lagrange multipliers and neural network training is taught as an exercise in minimizing weights of some loss function defined on the output units of the network. New powerful tools from the\u201cconvex optimization\u201d literature have encouraged this myopic view of learning to the point that some researchers now hold the view that every learning problem should be cast as a (preferably) convex optimization problem. The tendency to view all learning problems as \u201cmere optimization\u201d which can be successfully attacked with the modern blessings of convex optimization ignores some of the unique properties of learning problems. In other words: learning can indeed be formulated as an optimization problem, but a rather special one that has important features which should not be ignored. So what are these special properties of learning problems that distinguish them from plain vanilla optimization? The main difference lies in the loss function being a function of the data and the data being a random draw from some underlying distribution P . It is thus useful to think of the loss function as a random entity itself, i.e. one that fluctuates under resampling of the data-items from P . One aspect of this randomness is well appreciated by most machine learning researchers, namely that it contains the information necessary to avoid overfitting. Most researchers understand that simply fitting a model by minimizing some loss based on the training data alone might lead to overfitting. The fluctuations caused by resampling the training data will cause the optimal parameter-values to fluctuate and hence determine a distribution of parameters rather than a single value (the frequentist equivalent of the posterior distribution). It is less appreciated that taking the statistical properties of optimization into account during the entire learning process (and not just close to the point of convergence) can be very helpful to increase its computational efficiency. Perhaps the point can be made most forcefully by considering the extreme case of an infinite dataset. Any learning procedure that uses all data at every iteration is doomed to not do anything at all! During the initial stages of learning, when we are trying to the determine the most significant digits of our parameters, the information in the data is highly redundant. In other words: most data items agree on how they recommend changing the parameter values and as a result, one only has to query a small subset of them to get reliable information on how to update parameters. In contrast, close to convergence, most data items disagree on how to change the parameters and the update direction will strongly depend on \u201cwho you ask\u201d. Stochastic gradient descent (SGD) exploits precisely this idea, but does not tie it directly to the statistical properties of the optimization problem, implying that the annealing schedule of the stepsize has to be set by hand. In [6,13] we have proposed methods to increase the minibatch size (instead of decreasing the stepsize), based on statistical hypothesis tests that estimate the probability that a proposed update is more than 180 degrees in the wrong direction, leading to a learning procedure that auto-tunes its optimization hyper-parameters. These methods exploit the redundancy in data in relation to a partially trained model.", "creator": "LaTeX with hyperref package"}}}