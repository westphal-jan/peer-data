{"id": "1406.1404", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Jun-2014", "title": "On the satisfiability problem for SPARQL patterns", "abstract": "The satisfaction problem of SPARQL patterns is generally undecidable, since the meaningfulness of SPARQL 1.0 is comparable to that of relational algebra. The aim of this paper is to define the limit of the decision-making capacity of satisfaction in terms of the constraints permitted in filter conditions.The classes of constraints considered are bound constraints, negated bound constraints, equities, inequalities, constant-equivalents and constant-inequalities. The main result of the paper can be summarized by the statement that satisfaction, once inconsistent filter conditions can be formed, is undecidable.The most important finding in any case is to find a way to imitate the set difference operation. The indecidability can then be derived from a known indecidability result for the algebra of binary relations with union, composition and set difference. If no font inconsistency conditions can be determined, the oversatisfaction conditions can be formed for simple filter conditions, which are suitable for verification of the algebra binary relationships with union, composition and set difference.", "histories": [["v1", "Thu, 5 Jun 2014 14:48:04 GMT  (14kb)", "http://arxiv.org/abs/1406.1404v1", null], ["v2", "Wed, 1 Jun 2016 21:26:44 GMT  (25kb)", "http://arxiv.org/abs/1406.1404v2", "Major revision, erroneous polynomial-time claims corrected, NP-completeness result added, detailed proofs added, experimental section added"]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["xiaowang zhang", "jan van den bussche", "fran\\c{c}ois picalausa"], "accepted": false, "id": "1406.1404"}, "pdf": {"name": "1406.1404.pdf", "metadata": {"source": "CRF", "title": "On the satisfiability problem for SPARQL patterns", "authors": ["Xiaowang Zhang"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 6.\n14 04\nv1 [\ncs .D\nB ]\nThe satisfiability problem for SPARQL patterns is undecidable in general, since the expressive power of SPARQL 1.0 is comparable with that of the relational algebra. The goal of this paper is to delineate the boundary of decidability of satisfiability in terms of the constraints allowed in filter conditions. The classes of constraints considered are bound-constraints, negated bound-constraints, equalities, nonequalities, constant-equalities, and constant-nonequalities. The main result of the paper can be summarized by saying that, as soon as inconsistent filter conditions can be formed, satisfiability is undecidable. The key insight in each case is to find a way to emulate the set difference operation. Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference. When no inconsistent filter conditions can be formed, satisfiability is efficiently decidable by simple checks on bound variables and on the use of literals. The paper also points out that satisfiability for the so-called \u2018well-designed\u2019 patterns can be decided by a check on bound variables and a check for inconsistent filter conditions."}, {"heading": "1 Introduction", "text": "The Resource Description Framework (RDF) [RDF04] is a popular data model for information in the Web. RDF represents information in the form of directed, labeled graphs. The standard query language for RDF data is SPARQL [SPA13]. The current version 1.1 of SPARQL extends SPARQL 1.0 [SPA08] with important features such as aggregation and regular expressions. Other features, such as negation and subqueries, have also been added, but mainly for efficiency reasons, as they were already expressible, in a more roundabout manner, in version 1.0. Hence, it is still relevant to study the fundamental properties of\n\u2217This work is funded by the project of Research Foundation Flanders (FWO) under grant G.0489.10N.\nSPARQL 1.0. In this paper, we follow the elegant formalization of SPARQL 1.0 by Arenas, Gutierrez and Pe\u0301rez [PAG09, APG09] which is eminently suited for theoretical investigations.\nThe fundamental problem that we investigate is that of satisfiability of SPARQL patterns. A pattern is called satisfiable if there exists an RDF graph under which the pattern evaluates to a nonempty set of mappings. For any query language, satisfiability is clearly one of the essential properties one needs to understand if one wants to do automated reasoning. Since SPARQL patterns can emulate relational algebra expressions [AG08, Pol07, AP11], and satisfiability for relational algebra is undecidable [AHV95], the general satisfiability problem for SPARQL is undecidable as well.\nWhether or not a pattern is satisfiable depends mainly on the filter operations appearing in the pattern. The goal of this paper is to precisely delineate the decidability of SPARQL fragments that are defined in terms of the constraints that can be used as filter conditions. The six basic classes of constraints we consider are bound-constraints; equalities; constant-equalities; and their negations. In this way, fragments of SPARQL can be constructed by specifying which kinds of constraints are allowed as filter conditions. For example, in the fragment SPARQL(bound, 6=, 6=c), filter conditions can only be bound constraints, nonequalities, and constant-nonequalities.\nOur main result states that the only fragments for which satisfiability is decidable are the two fragments SPARQL(bound,=, 6=c) and SPARQL(bound, 6=, 6=c) and their subfragments. Consequently, as soon as either negated boundconstraints, or constant-equalities, or conjunctions of equalities and nonequalities are allowed, the satisfiability problem becomes undecidable. Each undecidable case is established by showing how the set difference operation can be emulated. This was already known using negated bound-constraints [AG08, AP11]; so we show it is also possible using constant-equalities, and using conjunctions of equalities and nonequalities, but in no other way. Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference [TVdBZ14]. In the decidable cases, satisfiability can be efficiently decided by some simple checks on bound variables and the use of literals.\nAt the end of the paper we look at a well-behaved class of patterns known as the \u2018well-designed\u2019 patterns [PAG09]. We observe that satisfiability of welldesigned patterns can be decided by combining the check on bound variables with a check for inconsistent filter conditions.\nThis paper is further organized as follows. In the next section, we introduce syntax and semantics of SPARQL patterns and introduce the different fragments under consideration. Section 3 introduces the satisfiability problem and shows satisfiability checking for the fragments SPARQL(bound,=, 6=c) and SPARQL(bound, 6=, 6=c). Section 4 shows undecidability for the fragments SPARQL(\u00acbound), SPARQL(=c), and SPARQL(=, 6=). Section 5 considers well-designed patterns. We conclude in Section 6."}, {"heading": "2 SPARQL and fragments", "text": "In this section we recall the syntax and semantics of SPARQL patterns, closely following the core SPARQL formalization given by Arenas, Gutierrez and Pe\u0301rez [PAG09, APG09, AP11]. We also define the language fragments defined in terms of allowed filter conditions, which will form the object of this paper."}, {"heading": "2.1 RDF graphs", "text": "Let I, B, and L be infinite sets of IRIs, blank nodes and literals, respectively. These three sets are pairwise disjoint. We denote the union I \u222aB\u222aL by U , and elements of I \u222a L will be referred to as constants.\nA triple (s, p, o) \u2208 (I \u222aB)\u00d7 I\u00d7 (I \u222aB \u222aL) is called an RDF triple. An RDF graph is a finite set of RDF triples."}, {"heading": "2.2 Syntax of SPARQL patterns", "text": "Assume furthermore an infinite set V of variables, disjoint from U . The convention in SPARQL is that variables are written beginning with a question mark, to distinguish them from constants. We will follow this convention in this paper.\nSPARQL patterns are inductively defined as follows.\n\u2022 Any triple from (I \u222a L\u222a V )\u00d7 (I \u222a V )\u00d7 (I \u222aL \u222a V ) is a pattern (called a triple pattern).\n\u2022 If P1 and P2 are patterns, then so are the following:\n\u2013 P1 UNION P2;\n\u2013 P1 AND P2;\n\u2013 P1 OPT P2.\n\u2022 If P is a pattern and C is a constraint (defined next), then P FILTER C is a pattern; we call C the filter condition.\nHere, a constraint can have one of the six following forms:\n1. bound-constraint: bound(?x)\n2. negated bound-constraint: \u00acbound(?x)\n3. equality: ?x = ?y\n4. nonequality: ?x 6= ?y with ?x and ?y distinct variables\n5. constant-equality: ?x = c with c a constant\n6. constant-nonequality: ?x 6= c\nWe do not need to consider conjunctions and disjunctions in filter conditions, since conjunctions can be expressed by repeated application of filter, and disjunctions can be expressed using UNION."}, {"heading": "2.3 Semantics of SPARQL patterns", "text": "The semantics of patterns is defined in terms of sets of so-called mappings, which are simply total functions \u00b5 : S \u2192 U on some finite set S of variables. We denote the domain S of \u00b5 by dom(\u00b5).\nNow given a graph G and a pattern P , we define the semantics of P on G, denoted by JP KG, as a set of mappings, in the following manner.\n\u2022 If P is a triple pattern (x, y, z), then\nJP KG := {\u00b5 : {x, y, z} \u2229 V \u2192 U | (\u00b5(x), \u00b5(y), \u00b5(z)) \u2208 G}.\nHere, for any mapping \u00b5 and any constant c \u2208 I \u222a L, we agree that \u00b5(c) equals c itself. In other words, mappings are extended to constants according to the identity mapping.\n\u2022 If P is of the form P1 UNION P2, then\nJP KG := JP1KG \u222a JP2KG.\n\u2022 If P is of the form P1 AND P2, then\nJP KG := JP1KG \u22ca\u22c9 JP2KG,\nwhere, for any two sets of mappings \u21261 and \u21262, we define\n\u21261 \u22ca\u22c9 \u2126 = {\u00b51 \u222a \u00b52 | \u00b51 \u2208 \u21261 and \u00b52 \u2208 \u21262 and \u00b51 \u223c \u00b52}.\nHere, two mappings \u00b51 and \u00b52 are called compatible, denoted by \u00b51 \u223c \u00b52, if they agree on the intersection of their domains, i.e., if for every variable x \u2208 dom(\u00b51) \u2229 dom(\u00b52), we have \u00b51(x) = \u00b52(x). Note that when \u00b51 and \u00b52 are compatible, their union \u00b51 \u222a \u00b52 is a well-defined mapping; this property is used in the formal definition above.\n\u2022 If P is of the form P1 OPT P2, then\nJP KG := (JP1KG \u22ca\u22c9 JP2KG) \u222a (JP1KG r JP2KG),\nwhere, for any two sets of mappings \u21261 and \u21262, we define\n\u21261 r \u21262 = {\u00b51 \u2208 \u21261 | \u00ac\u2203\u00b52 \u2208 \u21262 : \u00b51 \u223c \u00b52}.\n\u2022 Finally, P is of the form P1 FILTER C, then\nJP KG := {\u00b5 \u2208 JP1KG | \u00b5 |= C}\nwhere the satisfaction of a constraint C by a mapping \u00b5, denoted by \u00b5 |= C, is defined as follows:\n1. \u00b5 |= bound(?x) if ?x \u2208 dom(\u00b5);\n2. \u00b5 |= \u00acbound(?x) if ?x /\u2208 dom(\u00b5);\n3. \u00b5 |= ?x = ?y if ?x, ?y \u2208 dom(\u00b5) and \u00b5(x) = \u00b5(y);\n4. \u00b5 |= ?x 6= ?y if ?x, ?y \u2208 dom(\u00b5) and \u00b5(x) 6= \u00b5(y);\n5. \u00b5 |= ?x = c if ?x \u2208 dom(\u00b5) and \u00b5(x) = c;\n6. \u00b5 |= ?x 6= c if ?x \u2208 dom(\u00b5) and \u00b5(x) 6= c.\nNote that \u00b5 |= ?x 6= ?y is not the same as \u00b5 6|= ?x = ?y, and similarly for \u00b5 |= ?x 6= c. This corresponds to the three-valued logic [APG09] one has to use when allowing arbitrary boolean combinations of constraints as filter conditions (something we have omitted for simplicity)."}, {"heading": "2.4 SPARQL fragments", "text": "We can form fragments of SPARQL by specifying which of the six classes of constraints are allowed as filter conditions. We denote the class of boundconstraints by \u2018bound\u2019, negated bound-constraints by \u2018\u00acbound\u2019, equalities by \u2018=\u2019, nonequalities by \u2018 6=\u2019, constant-equalities by \u2018=c\u2019, and constant-nonequalities by \u2018 6=c\u2019. Then for any subset F of {bound,\u00acbound,=, 6=,=c, 6=c} we can form the fragment SPARQL(F ). For example, in the fragment SPARQL(bound,=, 6=c), filter conditions can only be bound constraints, equalities, and constantnonequalities."}, {"heading": "3 Satisfiability: decidable fragments", "text": "A pattern P is called satisfiable if there exists a graph G such that JP KG is nonempty. In general, checking satisfiability is a very complicated, indeed undecidable, problem. But for the two fragments SPARQL(bound,=, 6=c) and SPARQL(bound, 6=, 6=c), it will turn out that there are essentially only two possible reasons for unsatisfiability.\nThe first possible reason is that the pattern specifies a literal value in the first position of some RDF triple, whereas RDF triples can only have literals in the third position. For example, using the literal 42, the triple pattern (42, ?x, ?y) is unsatisfiable. Note that literals in the middle position of a triple pattern are already disallowed by the definition of triple pattern, so we only need to worry about the first position.\nThe second possible reason for unsatisfiability is that filter conditions require variables to be bound together in a way that cannot be satisfied by the subpattern to which the filter applies. For example, the pattern\n((?x, a, ?y) UNION (?x, b, ?z)) FILTER (bound(?y) \u2227 bound(?z))\nis unsatisfiable. Note that bound constraints are not strictly necessary to illustrate this phenomenon: if in the above example we replace the filter condition by ?y = ?z the resulting pattern is still unsatisfiable.\nWe next show that satisfiability for patterns in SPARQL(bound,=, 6=c) and SPARQL(bound, 6=, 6=c) is efficiently decidable, simply by catching the two possible reasons for unsatisfiability described above. Of course we will need to prove formally that these two reasons are indeed the only possible ones. Note also that the two fragments can not be combined, since satisfiability for SPARQL(=, 6=) is undecidable as we will see in the next Section."}, {"heading": "3.1 Handling of wrong literals", "text": "Literals in the wrong place in triple patterns are easily dealt with in the following manner. We define the wrong-literal reduction of a pattern P , denoted by \u03bb(P ), as a set that is either empty or is a singleton containing a single pattern P \u2032:\n\u2022 If P is a triple pattern (u, v, w) and u is a literal, then \u03bb(P ) := \u2205; else \u03bb(P ) := {P}.\n\u2022 \u03bb(P1 UNION P2) := \u03bb(P1) \u222a \u03bb(P2) if \u03bb(P1) or \u03bb(P2) is empty;\n\u2022 \u03bb(P1 UNION P2) := {P \u20321 UNION P \u2032 2 | P \u2032 1 \u2208 \u03bb(P1) and P \u2032 2 \u2208 \u03bb(P2)} otherwise.\n\u2022 \u03bb(P1 AND P2) := {P \u20321 AND P \u2032 2 | P \u2032 1 \u2208 \u03bb(P1) and P \u2032 2 \u2208 \u03bb(P2)}.\n\u2022 \u03bb(P1 OPT P2) := \u2205 if \u03bb(P1) is empty;\n\u2022 \u03bb(P1 OPT P2) := \u03bb(P1) if \u03bb(P2) is empty but \u03bb(P1) is nonempty;\n\u2022 \u03bb(P1 OPT P2) := {P \u20321 OPT P \u2032 2 | P \u2032 1 \u2208 \u03bb(P1) and P \u2032 2 \u2208 \u03bb(P2)} otherwise.\n\u2022 \u03bb(P1 FILTER C) := {P \u20321 FILTER C | P \u2032 1 \u2208 \u03bb(P1)}.\nThe following is readily verified:\nProposition 1. If \u03bb(P ) is empty then P is unsatisfiable; if \u03bb(P ) = {P \u2032} then P and P \u2032 are equivalent, i.e., JP KG = JP\n\u2032KG for every RDF graph G. Moreover, if \u03bb(P ) = {P \u2032} then P \u2032 does not contain any triple pattern (u, v, w) where u is a literal.\nJustified by the above proposition, we assume from now on that patterns do not contain any triple pattern (u, v, w) where u is a literal."}, {"heading": "3.2 Checking bound variables", "text": "To perform bound checks on variables, we associate to every pattern P a set \u0393(P ) of schemes, where a scheme is simply a set of variables, in the following way.1\n\u2022 If P is a triple pattern (u, v, w), then \u0393(P ) := {{u, v, w} \u2229 V }.\n1We define \u0393(P ) for general patterns, not only for those belonging to the fragments considered in this Section, because we will make another use of \u0393(P ) in Section 5.\n\u2022 \u0393(P1 UNION P2) := \u0393(P1) \u222a \u0393(P2).\n\u2022 \u0393(P1 AND P2) := {S1 \u222a S2 | S1 \u2208 \u0393(P1) and S2 \u2208 \u0393(P2)}.\n\u2022 \u0393(P1 OPT P2) := \u0393(P1 AND P2) \u222a \u0393(P1).\n\u2022 \u0393(P1 FILTER C) := {S \u2208 \u0393(P1) | S |= C}, where S |= C is defined as follows:\n\u2013 If C is of the form bound(?x) or ?x = c or ?x 6= c, then S |= C if ?x \u2208 S;\n\u2013 If C is of the form ?x = ?y or ?x 6= ?y, then S |= C if ?x, ?y \u2208 S;\n\u2013 S |= \u00acbound(?x) if ?x /\u2208 S.\nWe now establish the main result of this Section.\nTheorem 2. Let P be a SPARQL(bound,=, 6=c) or SPARQL(bound, 6=, 6=c) pattern. Then P is satisfiable if and only if \u0393(P ) is nonempty.\nThe only-if direction of Theorem 2 is the easy direction and is given by Lemma 3. The if-direction of Theorem 2 is given by two similar lemmas: Lemma 4 for SPARQL(bound,=, 6=c) and Lemma 5 for SPARQL(bound, 6=, 6=c).\nLemma 3. If \u00b5 \u2208 JP KG then there exists S \u2208 \u0393(P ) such that dom(\u00b5) = S.\nNote that this lemma holds for general patterns; it can be straightforwardly proven by induction on the structure of P .\nIn the following we use var(P ) to denote the set of all variables occurring in a pattern P .\nLemma 4. Let P be a pattern in SPARQL(bound,=, 6=c). Let c \u2208 I be a constant that does not appear in any constant-nonequality filter condition in P . With the constant mapping \u00b5 : var(P ) \u2192 {c}, let G be the RDF graph consisting of all possible triples (\u00b5c(u), \u00b5c(v), \u00b5c(w)) where (u, v, w) is a triple pattern in P .\nThen for every S \u2208 \u0393(P ) there exists S\u2032 \u2287 S such that the restriction \u00b5|S\u2032 of \u00b5 to S\u2032 belongs to JP KG.\nProof. By induction on the structure of P . If P is a triple pattern (u, v, w) then S = {u, v, w} \u2229 V . Since (\u00b5|S(u), \u00b5|S(v), \u00b5|S(w)) = (\u00b5(u), \u00b5(v), \u00b5(w)) \u2208 G, we have \u00b5|S \u2208 JQKG and we can take S\u2032 = S.\nIf P is of the form P1 UNION P2, the claim follows readily by induction. If P is of the form P1 AND P2, we have S = S1 \u222a S2 with Si \u2208 \u0393(Pi) for i = 1, 2. By induction, there exists S\u2032i \u2287 Si such that \u00b5|S\u2032i \u2208 JPiKG. Clearly \u00b5|S\u2032\n1 \u223c \u00b5|S\u2032 2 since they are restrictions of the same mapping. Hence \u00b5|S\u2032 1 \u222a\u00b5|S\u2032 2 =\n\u00b5S\u2032 1 \u222aS\u2032 2 \u2208 JP KG and we can take S\u2032 = S\u20321 \u222a S \u2032 2. If P is of the form P1 OPT P2, there are three possibilities.\n\u2022 If S \u2208 \u0393(P1 AND P2) we can reason as in the previous case.\n\u2022 If S \u2208 \u0393(P1) then by induction there exists S\u20321 \u2287 S so that \u00b5|S\u20321 \u2208 JP1KG. Now there are two further possibilities:\n\u2013 If \u0393(P2) is nonempty then by induction there exists some S \u2032 2 so that \u00b5|S\u2032\n2 \u2208 JP2KG. We can now reason again as in the case P1 AND P2.\n\u2013 Otherwise, by Lemma 3 we know that JP2KG is empty. But then JP KG = JP1KG and we can take S \u2032 = S\u20321.\nFinally if P is of the form P1 FILTER C, we know that S \u2208 \u0393(P1) and S |= C. By induction, there exists S\u2032 \u2287 S such that \u00b5|S\u2032 \u2208 JP1KG. We show that \u00b5|S\u2032 \u2208 JP KG by showing that \u00b5|S\u2032 |= C. There are three possibilities for C.\n\u2022 If C is of the form bound(?x), we know by S |= C that ?x \u2208 S\u2032. Hence \u00b5|S\u2032 |= C.\n\u2022 If C is of the form ?x = ?y, we again know ?x, ?y \u2208 S\u2032, and certainly \u00b5|S\u2032 |= C since \u00b5 maps everything to c.\n\u2022 If C is of the form ?x 6= d, we have d 6= c by the choice of c, so \u00b5|S\u2032 |= C since \u00b5(?x) = c.\nLemma 5. Let P be a pattern in SPARQL(bound, 6=, 6=c). Let W be the set of all constants appearing in a constant-nonequality filter condition in P . Let Z \u2286 I be a finite set of constants of the same cardinality as var(P ), and disjoint from W . With \u00b5 : var(P ) \u2192 Z an arbitrary but fixed injective mapping, let G be the RDF graph consisting of all possible triples (\u00b5(u), \u00b5(v), \u00b5(w)) where (u, v, w) is a triple pattern in P .\nThen for every S \u2208 \u0393(P ) there exists S\u2032 \u2287 S such that the restriction \u00b5|S\u2032 of \u00b5 to S\u2032 belongs to JP KG.\nProof. We prove for every subpattern Q of P that for every S \u2208 \u0393(Q) there exists S\u2032 \u2287 S such that \u00b5|S\u2032 \u2208 JQKG. The proof is by induction on the height of Q. The reasoning is largely the same as in the proof of Lemma 4. The only difference is in the case where Q is of the form Q1 FILTER C. In showing that \u00b5S\u2032 |= C, we now argue as follows for the last two cases:\n\u2022 If C is of the form ?x 6= ?y, then \u00b5|S\u2032 |= C since \u00b5 is injective.\n\u2022 If C is of the form ?x 6= c, then \u00b5|S\u2032 |= C since Z and W are disjoint."}, {"heading": "4 Undecidable fragments", "text": "In this Section we show that the two decidable fragments SPARQL(bound,=, 6=c) and SPARQL(bound, 6=, 6=c) are, in a sense, maximal. Specifically, the three minimal fragments not subsumed by one of these two fragments are SPARQL(\u00acbound), SPARQL(=, 6=), and SPARQL(=c). The main result of this Section is:\nTheorem 6. Satisfiability is undecidable for SPARQL(\u00acbound) patterns, for SPARQL(=, 6=) patterns, and for SPARQL(=c) patterns.\nWe will first present the proof for SPARQL(\u00acbound); after that we explain how the proof can be adapted for the other two fragments."}, {"heading": "4.1 SPARQL(\u00acbound)", "text": "Our approach is to reduce from the satisfiability problem for the algebra of finite binary relations with union, difference, and composition [TVdBZ14]. This algebra is also called the Downward Algebra and denoted by DA. The expressions of DA are defined as follows. Let R be an arbitrary fixed binary relation symbol.\n\u2022 The symbol R is a DA-expression.\n\u2022 If e1 and e2 are DA-expressions, then so are e1 \u222a e2, e1 \u2212 e2, and e1 \u25e6 e2.\nSemantically, DA-expressions represent binary queries on binary relations, i.e., mappings from binary relations to binary relations. Let I be a binary relation. We define the binary relation e(I) inductively as follows:\n\u2022 R(I) = I;\n\u2022 e1 \u222a e2(I) = e1(I) \u222a e2(I);\n\u2022 e1 \u2212 e2(I) = e1(I)\u2212 e2(I) (set difference);\n\u2022 e1 \u25e6 e2(I) = {(x, z) | \u2203y : (x, y) \u2208 e1(I) and (y, z) \u2208 e2(I)}.\nA DA-expression is called satisfiable if there exists a finite binary relation I such that e(I) is nonempty. We recall the following result:\nTheorem 7 ([TVdBZ14]). The satisfiability problem for DA-expressions is undecidable.\nWe are now ready to formulate the reduction from the satisfiability problem for DA to the satisfiability problem for SPARQL(\u00acbound).\nLemma 8. Let r \u2208 I be an arbitrary fixed constant. For any binary relation I, let GI be the RDF graph {(x, r, y) | (x, y) \u2208 I}. Then for every DA-expression e there exists a SPARQL(\u00acbound) pattern Pe with the following properties:\n1. for every RDF graph G and every \u00b5 \u2208 JPeKG, the two variables ?x and ?y belong to dom(\u00b5);\n2. for every binary relation I, we have\ne(I) = {(\u00b5(?x), \u00b5(?y)) | \u00b5 \u2208 JPeKGI};\n3. for every RDF graph G, we have JPeKG = JPeKGr , where G r := {(u, v, w) \u2208\nG | v = r}.\nProof. By induction on the structure of e. If e is R then Pe is the triple pattern (?x, r, ?y).\nIf e is of the form e1 \u222a e2, then Pe is Pe1 UNION Pe2 . If e is of the form e1 \u25e6 e2, then Pe is P \u2032e1 AND P \u2032 e2 , where P \u2032e1 and P \u2032 e2 are obtained as follows. First, by renaming variables, we may assume without loss of generality that Pe1 and Pe2 have no variables in common other than ?x and ?y. Let ?z be a fresh variable. Now in Pe1 , rename ?y to ?z, yielding P \u2032 e1 , and in Pe2 , rename ?x to ?z, yielding P \u2032 e2 .\nFinally, if e is of the form e1 \u2212 e2, we use a known idea [AP11]. As before we may assume without loss of generality that Pe1 and Pe2 have no variables in common other than ?x and ?y. Let ?u and ?w be two fresh variables. Then Pe equals\n( Pe1 OPT (Pe2 AND (?u, r, ?w)) ) FILTER \u00acbound(?u).\nThe above lemma provides us with a reduction from satisfiability for DA to satisfiability for SPARQL(\u00acbound), thus showing undecidability of the latter problem. Indeed, if e is satisfiable, then clearly Pe is satisfiable as well, by property 2 of the lemma. Conversely, if Pe is satisfiable by some RDF graph G, then, by property 3 of the lemma, JPeKGr is nonempty. Now define the binary relation I = {(u,w) | (u, r, w) \u2208 G}. Then GI = Gr, so by property 2 of the lemma we obtain the nonemptiness of e(I) as desired.\n4.2 SPARQL(=, 6=)\nWe now consider a minor variant of satisfiability for DA-expressions where we restrict attention to binary relations over at least two elements. Formally, the active domain of a binary relation I is the set of all entries in pairs belonging to I, so adom(I) := {x | \u2203y : (x, y) \u2208 I or (y, x) \u2208 I}. Then a DA-expression e is called two-satisfiable if e(I) is nonempty for some I such that adom(I) has at least two distinct elements.\nClearly, two-satisfiability is undecidable as well, for if it were decidable, then satisfiability would be decidable too. Indeed, e is satisfiable if and only if it is two-satisfiable, or satisfiable by a binary relation I over a single element. Up to isomorphism there is only one such I (the singleton {(x, x)}), and DAexpressions commute with isomorphisms.\nLemma 8 can now be adapted as follows. Property 2 of the lemma is only claimed for every binary relations I over at least two distinct elements. In the proof for the case where e is e1 \u2212 e2, we use six fresh variables ?u, ?u\n\u2032, ?v, ?v\u2032, ?w, and ?w\u2032. We use the abbreviation adom?u for (?u, r, ?w) UNION (?v, r, ?u) and similarly for adom?u\u2032 . We now use the following pattern for Pe:\n(\n( Pe1 OPT (Pe2 AND adom?u AND adom?u\u2032) FILTER ?u 6= ?u \u2032 )\nAND adom?u AND adom?u\u2032 ) FILTER ?u = ?u\u2032.\nUsing the adapted lemma, we can now reduce two-satisfiability for DA to satisfiability for SPARQL(=, 6=). Indeed, a DA-expression e is two-satisfiable if and only if the pattern\nPe AND ((adom?u AND adom?u\u2032) FILTER ?u 6= ?u \u2032)\nis satisfiable, where all variables used in adom?u and adom?u\u2032 are distinct and disjoint from those used in Pe.\n4.3 SPARQL(=c)\nWe consider a further variant of two-satisfiability, called ab-satisfiability, for two arbitrary fixed constants a, b \u2208 I that are distinct from the constant r already used for Lemma 8. A DA-expression is called ab-satisfiable if e(I) is nonempty for some binary relation I where a, b \u2208 adom(I).\nSince DA-expressions do not distinguish between isomorphic binary relations, ab-satisfiability is equivalent to two-satisfiability, and thus still undecidable.\nWe now again adapt Lemma 8, as follows. Property 2 is only claimed for every binary relation I such that a, b \u2208 adom(I). In the proof for the case e = e1 \u2212 e2, we now use the following pattern for Pe:\n(\n( Pe1 OPT (Pe2 AND adom?u) FILTER ?u = a ) AND adom?u\n)\nFILTER ?u = b.\nWe then obtain that e is ab-satisfiable if and only if\nPe AND (adom?u AND adom?u\u2032) FILTER ?u = a FILTER ?u \u2032 = b\nis satisfiable, establishing a reduction from ab-satisfiability for DA to satisfiability for SPARQL(=c)."}, {"heading": "5 Satisfiability of well-designed patterns", "text": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, with properties similar to the conjunctive queries for relational databases [AHV95]. Standard conjunctive queries are always satisfiable, and conjunctive queries extended with equality and nonequality constraints, possibly involving constants, can only be unsatisfiable if the constraints are inconsistent. An analogous behavior is present in what we call AF-patterns : patterns that only use the AND and FILTER operators. We will formalize this in Proposition 9. We will then show in Theorem 11 that a well-designed pattern is satisfiable if and only if its reduction to an AF-pattern is satisfiable. In other words, as far as satisfiability is concerned, well-designed patterns can be treated like AF-patterns."}, {"heading": "5.1 Satisfiability of AF-patterns", "text": "In Section 3.2 we have associated a set of schemes \u0393(P ) to every pattern P . When \u0393(P ) is empty, P is unsatisfiable (Lemma 3).\nNow when P is an AF-pattern and \u0393(P ) is nonempty, the satisfiability of P will turn out to depend solely on the equalities, nonequalities, constantequalities, and constant-nonequalities occurring as filter conditions in P . We will denote the set of these constraints by C(P ).\nAny set \u03a3 of constraints is called consistent if there exists a mapping that satisfies every constraint in \u03a3. When \u03a3 is a set of (constant-) (non)equalities, like C(P ), consistency can be efficiently decided [KS08].\nWe establish:\nProposition 9. An AF-pattern P is satisfiable if and only if \u0393(P ) is nonempty and C(F ) is consistent.\nProof. The only-if direction of this proposition is given by Lemma 3 together with the observation that if \u00b5 \u2208 JP KG, then \u00b5 satisfies every constraint in C(P ). Since P is satisfiable, such G and \u00b5 exist, so C(P ) is consistent.\nFor the if-direction, since P does not have the UNION and OPT operators, \u0393(P ) is a singleton {S}. Since C(F ) is consistent, there exists a mapping \u00b5 : S \u2192 U satisfying every constraint in C(P ). Let G be the graph consisting of all triples (\u00b5(u), \u00b5(v), \u00b5(w)) where (u, v, w) is a triple pattern in P . It is straightforward to show by induction on the height of Q that for every subpattern Q of P , we have \u00b5|S\u2032 \u2208 JQKG, where \u0393(Q) = {S\u2032}. Hence \u00b5 \u2208 JP KG and P is satisfiable."}, {"heading": "5.2 AF-reduction of well-designed patterns", "text": "A well-designed pattern is defined as a union of union-free well-designed patterns. Since a union is satisfiable if and only if one of its terms is, we will focus on union-free patterns in what follows. Formally, a union-free pattern P is called well-designed if\n1. for every subpattern of P of the formQ FILTERC, all variables mentioned in C also occur in Q; and\n2. for every subpattern Q of P of the form Q1 OPT Q2, and every ?x \u2208 var(Q2), if ?x also occurs in P outside of Q, then ?x \u2208 var(Q1).\nWe associate to every union-free pattern P an AF-pattern \u03c1(P ) defined as follows:\n\u2022 If P is a triple pattern, then \u03c1(P ) equals P .\n\u2022 If P is of the form P1 AND P2, then \u03c1(P ) = \u03c1(P1) AND \u03c1(P2).\n\u2022 If P is of the form P1 FILTER C, then \u03c1(P ) = \u03c1(P1) FILTER C.\n\u2022 If P is of the form P1 OPT P2, then \u03c1(P ) = \u03c1(P1).\nFor further use we note that \u0393(P ) and \u0393(\u03c1(P )) are related in the following way. The proof by induction is straightforward.\nLemma 10. Let S \u2208 \u0393(P ) and let S\u2032 \u2208 \u0393(\u03c1(P )). Then S\u2032 \u2286 S.\nThe announced result is now given by the following theorem. The if-direction of this theorem is already known from a result by Pe\u0301rez et al. [PAG09, Lemma 4.3].\nTheorem 11. Let P be a union-free well-designed pattern. Then P is satisfiable if and only if \u03c1(P ) is.\nWe prove the only-if direction. We begin by introducing two auxiliary notations.\n1. For any pattern P and subpattern Q of P , we denote by varP (Q) the set of variables from var(Q) that also occur in P outside of Q.\n2. When P is an AF-pattern with nonempty \u0393(P ), it is readily seen that \u0393(P ) in that case consists of a single scheme. We denote the unique scheme in \u0393(P ) by S(P ).\nThe following lemma connects the above two notations:\nLemma 12. Let P be a union-free well-designed pattern, and let Q be a subpattern of P such that \u0393(Q) is nonempty. Then \u0393(\u03c1(Q)) is nonempty as well, and varP (Q) \u2286 S(\u03c1(Q)).\nProof. By induction on the height of Q. If Q is a triple pattern, we have Q = \u03c1(Q) and varP (Q) \u2286 var(Q) = {u, v, w} \u2229 V = S(Q) = S(\u03c1(Q)) as desired.\nIf Q is of the form Q1 ANDQ2, the definition of \u0393(Q) immediately implies that \u0393(Q1) and \u0393(Q2) must both be nonempty. Since \u03c1(Q) = \u03c1(Q1)AND\u03c1(Q2) we then obtain S(\u03c1(Q)) = S(\u03c1(Q1)) \u222a S(\u03c1(Q2)). Any ?x \u2208 varP (Q) belongs to varP (Q1) or var\nP (Q2); we assume the former case as the latter case is analogous. By induction, we then have ?x \u2208 S(\u03c1(Q1)) \u2286 S(\u03c1(Q)) as desired.\nIf Q is of the form Q1 OPT Q2, then \u03c1(Q) = \u03c1(Q1). Recall that \u0393(Q) = \u0393(Q1) \u222a \u0393(Q1 AND Q2). If \u0393(Q1) is nonempty we obtain by induction that \u0393(\u03c1(Q1)) = \u0393(\u03c1(Q)) is nonempty; if \u0393(Q1 AND Q2) is nonempty we obtain \u0393(\u03c1(Q1)) nonempty as in the case for AND. So, S(\u03c1(Q)) exists and is equal to S(\u03c1(Q1)). Now let ?x \u2208 varP (Q). If ?x \u2208 varP (Q1) then ?x \u2208 S(\u03c1(Q1)) by induction. But if ?x \u2208 varP (Q2), then also ?x \u2208 varP (Q1) since P is welldesigned. Hence we are done with this case.\nFinally, let Q be of the form Q1 FILTERC. Since \u0393(Q) is nonempty, \u0393(Q1) is nonempty as well. To show that \u0393(\u03c1(Q)) is nonempty we must show that S(\u03c1(Q1)) |= C. Thereto, consider a variable ?x mentioned in C. Since P is well-designed, ?x \u2208 var(Q1) and thus ?x \u2208 varP (Q1). By induction we obtain ?x \u2208 S(\u03c1(Q1)). By Lemma 10, then also ?x \u2208 S for every S \u2208 \u0393(Q1). In other words, S 6|= \u00acbound(?x) for every S \u2208 \u0393(Q1). This rules out the possibility that C is a negated bound-constraint, since we are given that \u0393(Q) is nonempty. On the other hand, this argument also shows that S(\u03c1(Q1)) |= C in the other cases, where C is a bound-constraint or an (constant) (non)equality, as desired.\nIt remains to show that varP (Q) \u2286 S(\u03c1(Q)) = S(\u03c1(Q1)). Let ?x \u2208 varP (Q). If ?x \u2208 var(Q1) the result follows by induction. If ?x occurs in C then, because P is well-designed, also ?x \u2208 var(Q1) and thus we are done.\nWe mention in passing an interesting corollary of the reasoning in the above proof, to the effect that well-designedness rules out any nontrivial use of negated bound-constraints:\nCorollary 13. If P is a union-free well-designed pattern and Q is a subpattern of P of the form Q1 FILTER\u00acbound(?x), then \u0393(Q) is empty, in particular, Q is unsatisfiable.\nWe are now ready to make the final step in the proof of Theorem 11:\nLemma 14. Let P be a union-free well-designed pattern. If \u00b5 \u2208 JP KG and \u0393(\u03c1(P )) is nonempty, then \u00b5|S(\u03c1(P )) \u2208 J\u03c1(P )KG.\nProof. By induction on the structure of P . If P is a triple pattern, the claim is trivial.\nSo let P be of the form P1 AND P2. Since \u0393(\u03c1(P )) is nonempty and \u03c1(P ) = \u03c1(P1) AND \u03c1(P2), also \u0393(\u03c1(Pi)) is nonempty for i = 1, 2. Then by induction, \u00b5|S(\u03c1(Pi)) \u2208 J\u03c1(Pi)KG. Since they are restrictions of the same mapping \u00b5, we also have \u00b5|S(\u03c1(P1)) \u223c \u00b5|S(\u03c1(P2)), so the mapping \u00b5|S(\u03c1(P1)) \u222a \u00b5|S(\u03c1(P2)) belongs to J\u03c1(P )KG. Since S(\u03c1(P )) = S(\u03c1(P1))\u222aS(\u03c1(P2)), we obtain \u00b5|S(\u03c1(P )) \u2208 J\u03c1(P )KG as desired.\nIf P is of the form P1 OPT P2, we have \u03c1(P ) = \u03c1(P1), so we are given that \u0393(\u03c1(P1)) is nonempty. By induction, \u00b5|S(\u03c1(P1)) \u2208 J\u03c1(P1)KG = J\u03c1(P )KG as desired.\nFinally, if P is of the form P1 FILTER C then by the nonemptiness of \u0393(\u03c1(P )) we know that S(\u03c1(P1)) |= C and S(\u03c1(P )) = S(\u03c1(P1)). Hence, by induction, \u00b5|S(\u03c1(P1)) \u2208 J\u03c1(P1)KG. It remains to show that \u00b5|S(\u03c1(P1)) |= C, but this follows immediately because \u00b5 |= C and S(\u03c1(P1)) |= C.\nWith the above lemmas in hand, the only-if direction of Theorem 11 can now be argued as follows. Since P is satisfiable, \u0393(P ) is nonempty by Lemma 3. By Lemma 12 applied to Q = P , also \u0393(\u03c1(P )) is nonempty. Since P is satisfiable, there exist G and \u00b5 such that \u00b5 \u2208 JP KG. Now applying Lemma 14 yields that J\u03c1(P )KG is nonempty. We conclude that \u03c1(P ) is satisfiable."}, {"heading": "6 Conclusion", "text": "The results of this paper may be summarized by saying that, as long as the kinds of constraints allowed in filter conditions cannot be combined to yield inconsistent sets of constraints, satisfiability for SPARQL patterns is decidable; otherwise, the problem is undecidable. Moreover, for well-designed patterns, satisfiability is decidable as well. All our positive results yield straightforward bottom-up syntactic checks that can implemented efficiently.\nWe thus have attempted to paint a rather complete picture of the satisfiability problem for SPARQL. Of course, satisfiability is only the most basic automated reasoning task. One may now move on to more complex tasks such as equivalence, implication, containment, or query answering over ontologies. Indeed, investigations along this line for limited fragments of SPARQL are already happening [LPPS13, WEGL12, KG13, CGMSH12] and we hope that our work may serve to provide some additional grounding to these investigations.\nWe also note that in query optimization it is standard to check for satisfiability of subexpressions, to avoid executing useless code. Some specific works on SPARQL query optimization [SM13, GGK09] do mention that inconsistent constraints can cause unsatisfiability, but they have not provided sound and complete characterizations of satisfiability, like we have offered in this paper. Thus, our results will be useful in this direction as well."}], "references": [{"title": "The expressive power of SPARQL", "author": ["R. Angles", "C. Gutierrez"], "venue": "A. Sheth, S. Staab, et al., editors, Proceedings 7th International Semantic Web Conference, volume 5318 of Lecture Notes in Computer Science, pages 114\u2013129. Springer", "citeRegEx": "AG08", "shortCiteRegEx": null, "year": 2008}, {"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley", "citeRegEx": "AHV95", "shortCiteRegEx": null, "year": 1995}, {"title": "Querying semantic web data with SPARQL", "author": ["M. Arenas", "J. P\u00e9rez"], "venue": "Proceedings 30st ACM Symposium on Principles of Databases, pages 305\u2013316. ACM", "citeRegEx": "AP11", "shortCiteRegEx": null, "year": 2011}, {"title": "On the semantics of SPARQL", "author": ["M. Arenas", "J. P\u00e9rez", "C. Gutierrez"], "venue": "R. De Virgilio, F. Giunchiglia, and L. Tanca, editors, Semantic Web Information Management\u2014A Model-Based Perspective, pages 281\u2013307. Springer", "citeRegEx": "APG09", "shortCiteRegEx": null, "year": 2009}, {"title": "Completeness guarantees for incomplete ontology reasoners: Theory and practice", "author": ["B. Cuenca Grau", "B. Motik", "G. Stoilos", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research, 43:419\u2013476", "citeRegEx": "CGMSH12", "shortCiteRegEx": null, "year": 2012}, {"title": "Optimization of SPARQL by using coreSPARQL", "author": ["J. Groppe", "S. Groppe", "J. Kolbaum"], "venue": "J. Cordeiro and J. Filipe, editors, Proceedings 11th International Conference on Enterprise Information Systems, pages 107\u2013112", "citeRegEx": "GGK09", "shortCiteRegEx": null, "year": 2009}, {"title": "Journal of Artificial Intelligence Research", "author": ["I. Kollia", "B. Glimm. Optimizing SPARQL query answering over OWL ontologies"], "venue": "48:253\u2013303,", "citeRegEx": "KG13", "shortCiteRegEx": null, "year": 2013}, {"title": "Decision Procedures", "author": ["D. Kroening", "O. Strichman"], "venue": "Springer", "citeRegEx": "KS08", "shortCiteRegEx": null, "year": 2008}, {"title": "Static analysis and optimization of semantic web queries", "author": ["A. Letelier", "J. P\u00e9rez", "R. Pichler", "S. Skritek"], "venue": "ACM Transactions on Database Systems, 38(4):article 25", "citeRegEx": "LPPS13", "shortCiteRegEx": null, "year": 2013}, {"title": "Semantics and complexity of SPARQL", "author": ["J. P\u00e9rez", "M. Arenas", "C. Gutierrez"], "venue": "ACM Transactions on Database Systems, 34(3):article 16", "citeRegEx": "PAG09", "shortCiteRegEx": null, "year": 2009}, {"title": "From SPARQL to rules (and back)", "author": ["A. Polleres"], "venue": "C.L. Williamson, M.E. Zurko, et al., editors, Proceedings 16th World Wide Web Conference, pages 787\u2013796. ACM", "citeRegEx": "Pol07", "shortCiteRegEx": null, "year": 2007}, {"title": "W3C Recommendation", "author": ["RDF primer"], "venue": "February", "citeRegEx": "RDF04", "shortCiteRegEx": null, "year": 2004}, {"title": "Ultrawrap: SPARQL execution on relational data", "author": ["J.F. Sequeda", "D.P. Miranker"], "venue": "Web Semantics, 22:19\u201339", "citeRegEx": "SM13", "shortCiteRegEx": null, "year": 2013}, {"title": "W3C Recommendation", "author": ["RDF SPARQL query language for"], "venue": "January", "citeRegEx": "SPA08", "shortCiteRegEx": null, "year": 2008}, {"title": "J", "author": ["T. Tan"], "venue": "Van den Bussche, and X. Zhang. Undecidability of satisfiability in the algebra of finite binary relations with union, composition, and difference. arXiv:1406.0349", "citeRegEx": "TVdBZ14", "shortCiteRegEx": null, "year": 2014}, {"title": "SPARQL query containment under SHI axioms", "author": ["M. Wudage", "J. Euzenat", "P. Genev\u00e8s", "N. Lay\u00e4\u0131da"], "venue": "Proceedings 26th AAAI Conference, pages 10\u201316", "citeRegEx": "WEGL12", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 11, "context": "The Resource Description Framework (RDF) [RDF04] is a popular data model for information in the Web.", "startOffset": 41, "endOffset": 48}, {"referenceID": 13, "context": "0 [SPA08] with important features such as aggregation and regular expressions.", "startOffset": 2, "endOffset": 9}, {"referenceID": 1, "context": "Since SPARQL patterns can emulate relational algebra expressions [AG08, Pol07, AP11], and satisfiability for relational algebra is undecidable [AHV95], the general satisfiability problem for SPARQL is undecidable as well.", "startOffset": 143, "endOffset": 150}, {"referenceID": 14, "context": "Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference [TVdBZ14].", "startOffset": 151, "endOffset": 160}, {"referenceID": 9, "context": "At the end of the paper we look at a well-behaved class of patterns known as the \u2018well-designed\u2019 patterns [PAG09].", "startOffset": 106, "endOffset": 113}, {"referenceID": 3, "context": "This corresponds to the three-valued logic [APG09] one has to use when allowing arbitrary boolean combinations of constraints as filter conditions (something we have omitted for simplicity).", "startOffset": 43, "endOffset": 50}, {"referenceID": 14, "context": "1 SPARQL(\u00acbound) Our approach is to reduce from the satisfiability problem for the algebra of finite binary relations with union, difference, and composition [TVdBZ14].", "startOffset": 158, "endOffset": 167}, {"referenceID": 14, "context": "Theorem 7 ([TVdBZ14]).", "startOffset": 11, "endOffset": 20}, {"referenceID": 2, "context": "Finally, if e is of the form e1 \u2212 e2, we use a known idea [AP11].", "startOffset": 58, "endOffset": 64}, {"referenceID": 9, "context": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, with properties similar to the conjunctive queries for relational databases [AHV95].", "startOffset": 27, "endOffset": 34}, {"referenceID": 1, "context": "The well-designed patterns [PAG09] have been identified as a well-behaved class of SPARQL patterns, with properties similar to the conjunctive queries for relational databases [AHV95].", "startOffset": 176, "endOffset": 183}, {"referenceID": 7, "context": "When \u03a3 is a set of (constant-) (non)equalities, like C(P ), consistency can be efficiently decided [KS08].", "startOffset": 99, "endOffset": 105}], "year": 2017, "abstractText": "The satisfiability problem for SPARQL patterns is undecidable in general, since the expressive power of SPARQL 1.0 is comparable with that of the relational algebra. The goal of this paper is to delineate the boundary of decidability of satisfiability in terms of the constraints allowed in filter conditions. The classes of constraints considered are bound-constraints, negated bound-constraints, equalities, nonequalities, constant-equalities, and constant-nonequalities. The main result of the paper can be summarized by saying that, as soon as inconsistent filter conditions can be formed, satisfiability is undecidable. The key insight in each case is to find a way to emulate the set difference operation. Undecidability can then be obtained from a known undecidability result for the algebra of binary relations with union, composition, and set difference. When no inconsistent filter conditions can be formed, satisfiability is efficiently decidable by simple checks on bound variables and on the use of literals. The paper also points out that satisfiability for the so-called \u2018well-designed\u2019 patterns can be decided by a check on bound variables and a check for inconsistent filter conditions.", "creator": "LaTeX with hyperref package"}}}