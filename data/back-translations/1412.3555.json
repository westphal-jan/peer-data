{"id": "1412.3555", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Dec-2014", "title": "Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling", "abstract": "In this paper, we compare different types of recursive units in recursive neural networks. In particular, we focus on more complex units that implement a gating mechanism, such as long-term short-term memory (LSTM) and a recently proposed gated recurrent unit (GRU). We evaluate these recursive units based on the tasks of polyphonic music modelling and speech signal modelling. Our experiments have shown that these advanced recursive units are actually better than more conventional recursive units such as tanh units. We also found that GRU is comparable to LSTM.", "histories": [["v1", "Thu, 11 Dec 2014 06:46:53 GMT  (856kb,D)", "http://arxiv.org/abs/1412.3555v1", "Presented in NIPS 2014 Deep Learning and Representation Learning Workshop"]], "COMMENTS": "Presented in NIPS 2014 Deep Learning and Representation Learning Workshop", "reviews": [], "SUBJECTS": "cs.NE cs.LG", "authors": ["junyoung chung", "caglar gulcehre", "kyunghyun cho", "yoshua bengio"], "accepted": false, "id": "1412.3555"}, "pdf": {"name": "1412.3555.pdf", "metadata": {"source": "CRF", "title": "Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling", "authors": ["Junyoung Chung", "Caglar Gulcehre", "KyungHyun Cho", "Yoshua Bengio"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Recurrent neural networks have recently shown promising results in many machine learning tasks, especially when input and/or output are of variable length [see, e.g., Graves, 2012]. More recently, Sutskever et al. [2014] and Bahdanau et al. [2014] reported that recurrent neural networks are able to perform as well as the existing, well-developed systems on a challenging task of machine translation.\nOne interesting observation, we make from these recent successes is that almost none of these successes were achieved with a vanilla recurrent neural network. Rather, it was a recurrent neural network with sophisticated recurrent hidden units, such as long short-term memory units [Hochreiter and Schmidhuber, 1997], that was used in those successful applications.\nAmong those sophisticated recurrent units, in this paper, we are interested in evaluating two closely related variants. One is a long short-term memory (LSTM) unit, and the other is a gated recurrent unit (GRU) proposed more recently by Cho et al. [2014]. It is well established in the field that the LSTM unit works well on sequence-based tasks with long-term dependencies, but the latter has only recently been introduced and used in the context of machine translation.\nIn this paper, we evaluate these two units and a more traditional tanh unit on the task of sequence modeling. We consider three polyphonic music datasets [see, e.g., Boulanger-Lewandowski et al., 2012] as well as two internal datasets provided by Ubisoft in which each sample is a raw speech representation.\nBased on our experiments, we concluded that by using fixed number of parameters for all models on some datasets GRU, can outperform LSTM units both in terms of convergence in CPU time and in terms of parameter updates and generalization."}, {"heading": "2 Background: Recurrent Neural Network", "text": "A recurrent neural network (RNN) is an extension of a conventional feedforward neural network, which is able to handle a variable-length sequence input. The RNN handles the variable-length\nar X\niv :1\n41 2.\n35 55\nv1 [\ncs .N\nE ]\n1 1\nD ec\nsequence by having a recurrent hidden state whose activation at each time is dependent on that of the previous time.\nMore formally, given a sequence x = (x1,x2, \u00b7 \u00b7 \u00b7 ,xT ), the RNN updates its recurrent hidden state ht by\nht =\n{ 0, t = 0\n\u03c6 (ht\u22121,xt) , otherwise (1)\nwhere \u03c6 is a nonlinear function such as composition of a logistic sigmoid with an affine transformation. Optionally, the RNN may have an output y = (y1, y2, . . . , yT ) which may again be of variable length.\nTraditionally, the update of the recurrent hidden state in Eq. (1) is implemented as\nht = g (Wxt + Uht\u22121) , (2)\nwhere g is a smooth, bounded function such as a logistic sigmoid function or a hyperbolic tangent function.\nA generative RNN outputs a probability distribution over the next element of the sequence, given its current state ht, and this generative model can capture a distribution over sequences of variable length by using a special output symbol to represent the end of the sequence. The sequence probability can be decomposed into\np(x1, . . . , xT ) = p(x1)p(x2 | x1)p(x3 | x1, x2) \u00b7 \u00b7 \u00b7 p(xT | x1, . . . , xT\u22121), (3)\nwhere the last element is a special end-of-sequence value. We model each conditional probability distribution with\np(xt | x1, . . . , xt\u22121) =g(ht),\nwhere ht is from Eq. (1). Such generative RNNs are the subject of this paper.\nUnfortunately, it has been observed by, e.g., Bengio et al. [1994] that it is difficult to train RNNs to capture long-term dependencies because the gradients tend to either vanish (most of the time) or explode (rarely, but with severe effects). This makes gradient-based optimization method struggle, not just because of the variations in gradient magnitudes but because of the effect of long-term dependencies is hidden (being exponentially smaller with respect to sequence length) by the effect of short-term dependencies. There have been two dominant approaches by which many researchers have tried to reduce the negative impacts of this issue. One such approach is to devise a better learning algorithm than a simple stochastic gradient descent [see, e.g., Bengio et al., 2013, Pascanu et al., 2013, Martens and Sutskever, 2011], for example using the very simple clipped gradient, by which the norm of the gradient vector is clipped, or using second-order methods which may be less sensitive to the issue if the second derivatives follow the same growth pattern as the first derivatives (which is not guaranteed to be the case).\nThe other approach, in which we are more interested in this paper, is to design a more sophisticated activation function than a usual activation function, consisting of affine transformation followed by a simple element-wise nonlinearity by using gating units. The earliest attempt in this direction resulted in an activation function, or a recurrent unit, called a long short-term memory (LSTM) unit [Hochreiter and Schmidhuber, 1997]. More recently, another type of recurrent unit, to which we refer as a gated recurrent unit (GRU), was proposed by Cho et al. [2014]. RNNs employing either of these recurrent units have been shown to perform well in tasks that require capturing long-term dependencies. Those tasks include, but are not limited to, speech recognition [see, e.g., Graves et al., 2013] and machine translation [see, e.g., Sutskever et al., 2014, Bahdanau et al., 2014]."}, {"heading": "3 Gated Recurrent Neural Networks", "text": "In this paper, we are interested in evaluating the performance of those recently proposed recurrent units (LSTM unit and GRU) on sequence modeling. Before the empirical evaluation, we first describe each of those recurrent units in this section."}, {"heading": "3.1 Long Short-Term Memory Unit", "text": "The Long Short-Term Memory (LSTM) unit was initially proposed by Hochreiter and Schmidhuber [1997]. Since then, a number of minor modifications to the original LSTM unit have been made. We follow the implementation of LSTM as used in Graves [2013].\nUnlike to the recurrent unit which simply computes a weighted sum of the input signal and applies a nonlinear function, each j-th LSTM unit maintains a memory cjt at time t. The output h j t , or the activation, of the LSTM unit is then\nhjt = o j t tanh ( cjt ) ,\nwhere ojt is an output gate that modulates the amount of memory content exposure. The output gate is computed by\nojt = \u03c3 (Woxt + Uoht\u22121 + Voct) j ,\nwhere \u03c3 is a logistic sigmoid function. Vo is a diagonal matrix.\nThe memory cell cjt is updated by partially forgetting the existing memory and adding a new memory content c\u0303jt :\ncjt = f j t c j t\u22121 + i j t c\u0303 j t , (4)\nwhere the new memory content is\nc\u0303jt = tanh (Wcxt + Ucht\u22121) j .\nThe extent to which the existing memory is forgotten is modulated by a forget gate f jt , and the degree to which the new memory content is added to the memory cell is modulated by an input gate ijt . Gates are computed by\nf jt =\u03c3 (Wfxt + Ufht\u22121 + Vfct\u22121) j ,\nijt =\u03c3 (Wixt + Uiht\u22121 + Vict\u22121) j .\nNote that Vf and Vi are diagonal matrices.\nUnlike to the traditional recurrent unit which overwrites its content at each time-step (see Eq. (2)), an LSTM unit is able to decide whether to keep the existing memory via the introduced gates. Intuitively, if the LSTM unit detects an important feature from an input sequence at early stage, it easily carries this information (the existence of the feature) over a long distance, hence, capturing potential long-distance dependencies.\nSee Fig. 1 (a) for the graphical illustration."}, {"heading": "3.2 Gated Recurrent Unit", "text": "A gated recurrent unit (GRU) was proposed by Cho et al. [2014] to make each recurrent unit to adaptively capture dependencies of different time scales. Similarly to the LSTM unit, the GRU has gating units that modulate the flow of information inside the unit, however, without having a separate memory cells.\nThe activation hjt of the GRU at time t is a linear interpolation between the previous activation h j t\u22121 and the candidate activation h\u0303jt :\nhjt = (1\u2212 z j t )h j t\u22121 + z j t h\u0303 j t , (5)\nwhere an update gate zjt decides how much the unit updates its activation, or content. The update gate is computed by\nzjt = \u03c3 (Wzxt + Uzht\u22121) j .\nThis procedure of taking a linear sum between the existing state and the newly computed state is similar to the LSTM unit. The GRU, however, does not have any mechanism to control the degree to which its state is exposed, but exposes the whole state each time.\nThe candidate activation h\u0303jt is computed similarly to that of the traditional recurrent unit (see Eq. (2)) and as in [Bahdanau et al., 2014],\nh\u0303jt = tanh (Wxt + U (rt ht\u22121)) j ,\nwhere rt is a set of reset gates and is an element-wise multiplication. 1 When off (rjt close to 0), the reset gate effectively makes the unit act as if it is reading the first symbol of an input sequence, allowing it to forget the previously computed state.\nThe reset gate rjt is computed similarly to the update gate:\nrjt = \u03c3 (Wrxt + Urht\u22121) j .\nSee Fig. 1 (b) for the graphical illustration of the GRU."}, {"heading": "3.3 Discussion", "text": "It is easy to notice similarities between the LSTM unit and the GRU from Fig. 1.\nThe most prominent feature shared between these units is the additive component of their update from t to t + 1, which is lacking in the traditional recurrent unit. The traditional recurrent unit always replaces the activation, or the content of a unit with a new value computed from the current input and the previous hidden state. On the other hand, both LSTM unit and GRU keep the existing content and add the new content on top of it (see Eqs. (4) and (5)).\n1 Note that we use the reset gate in a slightly different way from the original GRU proposed in Cho et al. [2014]. Originally, the candidate activation was computed by\nh\u0303jt = tanh (Wxt + rt (Uht\u22121)) j ,\nwhere rjt is a reset gate. We found in our preliminary experiments that both of these formulations performed as well as each other.\nThis additive nature has two advantages. First, it is easy for each unit to remember the existence of a specific feature in the input stream for a long series of steps. Any important feature, decided by either the forget gate of the LSTM unit or the update gate of the GRU, will not be overwritten but be maintained as it is.\nSecond, and perhaps more importantly, this addition effectively creates shortcut paths that bypass multiple temporal steps. These shortcuts allow the error to be back-propagated easily without too quickly vanishing (if the gating unit is nearly saturated at 1) as a result of passing through multiple, bounded nonlinearities, thus reducing the difficulty due to vanishing gradients [Hochreiter, 1991, Bengio et al., 1994].\nThese two units however have a number of differences as well. One feature of the LSTM unit that is missing from the GRU is the controlled exposure of the memory content. In the LSTM unit, the amount of the memory content that is seen, or used by other units in the network is controlled by the output gate. On the other hand the GRU exposes its full content without any control.\nAnother difference is in the location of the input gate, or the corresponding reset gate. The LSTM unit computes the new memory content without any separate control of the amount of information flowing from the previous time step. Rather, the LSTM unit controls the amount of the new memory content being added to the memory cell independently from the forget gate. On the other hand, the GRU controls the information flow from the previous activation when computing the new, candidate activation, but does not independently control the amount of the candidate activation being added (the control is tied via the update gate).\nFrom these similarities and differences alone, it is difficult to conclude which types of gating units would perform better in general. Although Bahdanau et al. [2014] reported that these two units performed comparably to each other according to their preliminary experiments on machine translation, it is unclear whether this applies as well to tasks other than machine translation. This motivates us to conduct more thorough empirical comparison between the LSTM unit and the GRU in this paper."}, {"heading": "4 Experiments Setting", "text": ""}, {"heading": "4.1 Tasks and Datasets", "text": "We compare the LSTM unit, GRU and tanh unit in the task of sequence modeling. Sequence modeling aims at learning a probability distribution over sequences, as in Eq. (3), by maximizing the log-likelihood of a model given a set of training sequences:\nmax \u03b8\n1\nN N\u2211 n=1 Tn\u2211 t=1 log p ( xnt | xn1 , . . . , xnt\u22121;\u03b8 ) ,\nwhere \u03b8 is a set of model parameters. More specifically, we evaluate these units in the tasks of polyphonic music modeling and speech signal modeling.\nFor the polyphonic music modeling, we use three polyphonic music datasets from [BoulangerLewandowski et al., 2012]: Nottingham, JSB Chorales, MuseData and Piano-midi. These datasets contain sequences of which each symbol is respectively a 93-, 96-, 105-, and 108-dimensional binary vector. We use logistic sigmoid function as output units.\nWe use two internal datasets provided by Ubisoft2 for speech signal modeling. Each sequence is an one-dimensional raw audio signal, and at each time step, we design a recurrent neural network to look at 20 consecutive samples to predict the following 10 consecutive samples. We have used two different versions of the dataset: One with sequences of length 500 (Ubisoft A) and the other with sequences of length 8, 000 (Ubisoft B). Ubisoft A and Ubisoft B have 7, 230 and 800 sequences each. We use mixture of Gaussians with 20 components as output layer. 3\n2 http://www.ubi.com/ 3Our implementation is available at https://github.com/jych/librnn.git"}, {"heading": "4.2 Models", "text": "For each task, we train three different recurrent neural networks, each having either LSTM units (LSTM-RNN, see Sec. 3.1), GRUs (GRU-RNN, see Sec. 3.2) or tanh units (tanh-RNN, see Eq. (2)). As the primary objective of these experiments is to compare all three units fairly, we choose the size of each model so that each model has approximately the same number of parameters. We intentionally made the models to be small enough in order to avoid overfitting which can easily distract the comparison. This approach of comparing different types of hidden units in neural networks has been done before, for instance, by Gulcehre et al. [2014]. See Table 1 for the details of the model sizes.\nWe train each model with RMSProp [see, e.g., Hinton, 2012] and use weight noise with standard deviation fixed to 0.075 [Graves, 2011]. At every update, we rescale the norm of the gradient to 1, if it is larger than 1 [Pascanu et al., 2013] to prevent exploding gradients. We select a learning rate (scalar multiplier in RMSProp) to maximize the validation performance, out of 10 randomly chosen log-uniform candidates sampled from U(\u221212,\u22126) [Bergstra and Bengio, 2012]. The validation set is used for early-stop training as well."}, {"heading": "5 Results and Analysis", "text": "Table 2 lists all the results from our experiments. In the case of the polyphonic music datasets, the GRU-RNN outperformed all the others (LSTM-RNN and tanh-RNN) on all the datasets except for the Nottingham. However, we can see that on these music datasets, all the three models performed closely to each other.\nOn the other hand, the RNNs with the gating units (GRU-RNN and LSTM-RNN) clearly outperformed the more traditional tanh-RNN on both of the Ubisoft datasets. The LSTM-RNN was best with the Ubisoft A, and with the Ubisoft B, the GRU-RNN performed best.\nIn Figs. 2\u20133, we show the learning curves of the best validation runs. In the case of the music datasets (Fig. 2), we see that the GRU-RNN makes faster progress in terms of both the number of\nupdates and actual CPU time. If we consider the Ubisoft datasets (Fig. 3), it is clear that although the computational requirement for each update in the tanh-RNN is much smaller than the other models, it did not make much progress each update and eventually stopped making any progress at much worse level.\nThese results clearly indicate the advantages of the gating units over the more traditional recurrent units. Convergence is often faster, and the final solutions tend to be better. However, our results are not conclusive in comparing the LSTM and the GRU, which suggests that the choice of the type of gated recurrent unit may depend heavily on the dataset and corresponding task."}, {"heading": "6 Conclusion", "text": "In this paper we empirically evaluated recurrent neural networks (RNN) with three widely used recurrent units; (1) a traditional tanh unit, (2) a long short-term memory (LSTM) unit and (3) a recently proposed gated recurrent unit (GRU). Our evaluation focused on the task of sequence modeling on a number of datasets including polyphonic music data and raw speech signal data.\nThe evaluation clearly demonstrated the superiority of the gated units; both the LSTM unit and GRU, over the traditional tanh unit. This was more evident with the more challenging task of raw speech signal modeling. However, we could not make concrete conclusion on which of the two gating units was better.\nWe consider the experiments in this paper as preliminary. In order to understand better how a gated unit helps learning and to separate out the contribution of each component, for instance gating units in the LSTM unit or the GRU, of the gating units, more thorough experiments will be required in the future."}, {"heading": "Acknowledgments", "text": "The authors would like to thank Ubisoft for providing the datasets and for the support. The authors would like to thank the developers of Theano [Bergstra et al., 2010, Bastien et al., 2012] and Pylearn2 [Goodfellow et al., 2013]. We acknowledge the support of the following agencies for research funding and computing support: NSERC, Calcul Que\u0301bec, Compute Canada, the Canada Research Chairs and CIFAR."}], "references": [], "referenceMentions": [], "year": 2014, "abstractText": "In this paper we compare different types of recurrent units in recurrent neural networks (RNNs). Especially, we focus on more sophisticated units that implement a gating mechanism, such as a long short-term memory (LSTM) unit and a recently proposed gated recurrent unit (GRU). We evaluate these recurrent units on the tasks of polyphonic music modeling and speech signal modeling. Our experiments revealed that these advanced recurrent units are indeed better than more traditional recurrent units such as tanh units. Also, we found GRU to be comparable to LSTM.", "creator": "LaTeX with hyperref package"}}}