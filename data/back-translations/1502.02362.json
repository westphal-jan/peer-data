{"id": "1502.02362", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Feb-2015", "title": "Counterfactual Risk Minimization: Learning from Logged Bandit Feedback", "abstract": "We develop a learning principle and an efficient algorithm for batch learning from logged bandit feedback. This learning environment is ubiquitous in online systems (e.g. ad placement, web search, recommendation) where an algorithm makes a prediction (e.g. ad ranking) for a given input (e.g. query) and takes into account the feedback from bandits (e.g. clicks on presented ads). We first address the counterfactual nature of the learning problem through inclination assessment. Next, we demonstrate generalizing error limits that take into account the variance of the bias-weighted empirical risk estimator. These constructive limits lead to the principle of counterfactual risk minimization (CRM). We show how CRM can be used to draw on a new learning method - the so-called Policy Optimizer for Exponential Models (POEM) - for learning stochastic linear rules for structured output predictions.", "histories": [["v1", "Mon, 9 Feb 2015 05:09:25 GMT  (52kb)", "http://arxiv.org/abs/1502.02362v1", "9 pages"], ["v2", "Wed, 20 May 2015 23:29:49 GMT  (54kb)", "http://arxiv.org/abs/1502.02362v2", "10 pages"]], "COMMENTS": "9 pages", "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["adith swaminathan", "thorsten joachims"], "accepted": true, "id": "1502.02362"}, "pdf": {"name": "1502.02362.pdf", "metadata": {"source": "META", "title": "Counterfactual Risk Minimization: Learning from Logged Bandit Feedback", "authors": ["Adith Swaminathan"], "emails": ["ADITH@CS.CORNELL.EDU", "TJ@CS.CORNELL.EDU"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 2.\n02 36\n2v 1\n[ cs\n.L G\n] 9\nF eb\n2 01"}, {"heading": "1. Introduction", "text": "Log data is one of the most ubiquitous forms of data available, as it can be recorded from a variety of systems (e.g., search engines, recommender systems, ad placement) at little cost. The interaction logs of such systems typically contain a record of the input to the system (e.g. features describing the user), the prediction made by the system (e.g. a recommended list of news articles) and the feedback\n(e.g. number of ranked articles the user read). The feedback, however, provides only partial information \u2013 \u201cbandit feedback\u201d\u2013 limited to the particular prediction shown by the system. The feedback for all the other predictions the system could have made is typically not known. This makes learning from log data fundamentally different from supervised learning, where \u201ccorrect\u201d predictions (e.g. the best ranking of news articles for that user) together with a loss function provide full-information feedback.\nIn this paper, we address the problem of batch learning from logged bandit feedback. Unlike online learning with bandit feedback, batch learning does not require interactive experimental control over the system. Furthermore, it enables the reuse of existing data and offline cross-validation techniques for model selection (e.g., \u201cshould we perform feature selection?\u201d, \u201cwhich learning algorithm should we use?\u201d, etc.).\nTo solve this batch-learning problem, we first need a counterfactual estimator (Bottou et al., 2013) of a system\u2019s performance, so that we can estimate how other systems would have performed if they had been in control of choosing predictions. Such estimators have been developed recently for the off-policy evaluation problem (Langford et al., 2011), (Li et al., 2011), (Li et al., 2014a), where data collected from the interaction logs of one bandit algorithm is used to evaluate another system.\nOur approach to batch learning from bandit feedback centers around the insight that, to perform robust learning, it is not sufficient to have just an unbiased estimator of the offpolicy system\u2019s performance. We must also reason about how the variances of these estimators differ across the hypothesis space, and pick the hypothesis that has the best possible guarantee (tightest conservative bound) for its performance. We first prove generalization error bounds analogous to structural risk minimization (Vapnik, 1998) for a stochastic hypothesis family. The constructive nature of these bounds suggests a general principle \u2013 Counterfactual Risk Minimization (CRM) \u2013 for designing methods for batch learning from bandit feedback.\nUsing the CRM principle, we derive a new learning algorithm \u2013 Policy Optimizer for Exponential Models (POEM) \u2013 for structured output prediction. The training objective is decomposed using repeated variance linearization, and optimizing it using stochastic gradient descent yields a fast and effective algorithm. We evaluate POEM on several multi-label classification problems, verify that its empirical performance supports the theory, and demonstrate substantial improvement in generalization performance over the state-of-the-art.\nWe review existing approaches in Section 2. The learning setting is detailed in Section 3, and contrasted with supervised learning. In Section 4, we derive the Counterfactual Risk Minimization learning principle and provide a rule of thumb for setting hyper-parameters. In Section 5, we instantiate the CRM principle for structured output prediction using exponential models and construct an efficient decomposition of the objective for stochastic optimization. Empirical evaluations are reported in Section 6 and we conclude with future directions and discussion in Section 7."}, {"heading": "2. Related Work", "text": "Existing approaches for batch learning from logged bandit feedback fall into two categories. The first approach is to reduce the problem to supervised learning. In principle, since the logs give us an incomplete view of the feedback for different predictions, one could first use regression to estimate a feedback oracle for unseen predictions, and then use any supervised learning algorithm using this feedback oracle. Such a two-stage approach is known to not generalize well (Beygelzimer & Langford, 2009). More sophisticated techniques using a cost weighted classification (Zadrozny et al., 2003) or the Offset Tree algorithm (Beygelzimer & Langford, 2009) allow us to perform batch learning when the space of possible predictions is small. In contrast, our approach generalizes structured output prediction, with exponential-sized prediction spaces.\nThe second approach to batch learning from bandit feedback uses propensity scoring (Rosenbaum & Rubin, 1983) (Bottou et al., 2013) to derive unbiased estimators from the interaction logs. These estimators are used for a small set of candidate policies, and the best estimated candidate is picked via exhaustive search. In contrast, our approach can be optimized via gradient descent, over hypothesis families (of infinite size) that are equally as expressive as those used in supervised learning.\nOur approach builds on counterfactual estimators that have been developed for off-policy evaluation. The inverse propensity scoring estimator can be optimal when we have a good model of the historical algorithm (Li et al., 2014a), (Li et al., 2014b), and doubly robust estimators are even\nmore efficient when we additionally have a good model of the feedback (Langford et al., 2011). In our work, we focus on the inverse propensity scoring estimator, the results we derive hold equally for the doubly robust estimators.\nIn the current work, we concentrate on the case where the historical algorithm was a stationary, stochastic policy. Techniques like exploration scavenging (Langford et al., 2008) and bootstrapping (Mary et al., 2014) allow us to perform counterfactual evaluation even when the historical algorithm was deterministic or adaptive.\nBeyond the problem of batch learning from bandit feedback, our approach can have implications for several applications that require learning from logged bandit feedback data: warm-starting multi-armed bandits (Shivaswamy & Joachims, 2012), pre-selecting retrieval functions for search engines (Hofmann et al., 2013), and policy evaluation for contextual bandits (Li et al., 2011), to name a few."}, {"heading": "3. Learning Setting: Batch Learning with Logged Bandit Feedback", "text": "Consider a structured output prediction problem that takes as input x \u2208 X and outputs a prediction y \u2208 Y . For example, in multi-label document classification, x could be a news article and y a bitvector indicating the labels assigned to this article. The inputs are assumed drawn from a fixed but unknown distribution Pr(X ), x i.i.d.\u223c Pr(X ). Consider the hypothesis space H of stochastic policies. A hypothesis h(Y | x) \u2208 H defines a probability distribution over the output space Y , and the hypothesis makes predictions by sampling, y \u223c h(Y | x). Note that this definition of a hypothesis space also includes deterministic hypotheses, where the distributions assign probability 1 to a single y. For notational convenience, denote h(Y | x) by h(x), and the probability assigned by h(x) to y as h(y | x). In interactive learning systems, we only observe feedback \u03b4(x, y) for the y sampled from h(x). In this work, feedback \u03b4 : X\u00d7Y 7\u2192 R is a cardinal loss that is only observed at the sampled data points. Small values for \u03b4(x, y) indicate user satisfaction with y for x, while large values indicate dissatisfaction. The expected loss \u2013 called risk \u2013 of a hypothesis R(h) is defined as,\nR(h) = Ex\u223cPr(X )Ey\u223ch(x) [\u03b4(x, y)] . (1)\nThe goal of the system is to minimize risk, or equivalently, maximize expected user satisfaction. The aim of learning is to find a hypothesis h \u2208 H that has minimum risk. We wish to re-use the interaction logs of these systems for batch learning. Assume that its historical algorithm acted according to a stationary policy h0(x) (also called logging\npolicy). The data collected from this system is\nD = {(x1, y1, \u03b41), . . . , (xn, yn, \u03b4n)}, (2)\nwhere yi \u223c h0(xi) and \u03b4i \u2261 \u03b4(xi, yi).\nSampling bias. D cannot be used to estimate R(h) for a new hypothesis h using the estimator typically used in supervised learning. We ideally need either full information about \u03b4(xi, \u00b7) (which reduces to a trivial learning problem) or need samples y \u223c h(xi) to directly estimate R(h). This explains why, in practice, model selection over a small set of candidate systems is typically done via A/B tests, where the candidates are deployed to collect new data sampled according to y \u223c h(x) for each hypothesis h. A relative comparison of the assumptions, hypotheses, and principles used in supervised learning vs. our learning setting is outlined in Table 1. Fundamentally, batch learning with bandit feedback is hard because D is both biased (predictions favored by the historical algorithm will be over-represented) and incomplete (feedback for other predictions will not be available) for learning."}, {"heading": "4. Learning Principle: Counterfactual Risk Minimization", "text": "The distribution mismatch between h0 and any hypothesis h \u2208 H can be addressed using importance sampling, which corrects the sampling bias as:\nR(h) = Ex\u223cPr(X )Ey\u223ch(x) [\u03b4(x, y)]\n= Ex\u223cPr(X )Ey\u223ch0(x)\n[ \u03b4(x, y) h(y | x) h0(y | x) ] .\nThis motivates the propensity scoring approach. During the operation of the logging policy, we keep track of the propensity, h0(y | x) of the historical system to generate y for x. From these propensity-augmented logs\nD={(x1,y1,\u03b41,p1), . . . , (xn,yn,\u03b4n,pn)}, (3)\nwhere pi\u2261h0(yi | xi), we can derive an unbiased estimate of R(h) via Monte Carlo approximation,\nR\u0302(h) = 1\nn\nn \u2211\ni=1\n\u03b4i h(yi | xi)\npi . (4)\nAt first thought, one may think that directly estimating R\u0302(h) over h \u2208 H and picking the empirical minimizer is a valid learning strategy. Unfortunately, there are several potential pitfalls.\nFirst, this strategy is not invariant to additive transformations of the loss and will give degenerate results if the loss is not appropriately scaled. In Section 4.1, we develop intuition for why this is so, and derive the optimal scaling of \u03b4. For now, assume that \u2200x, \u2200y, \u03b4(x, y) \u2208 [\u22121, 0].\nSecond, this estimator has unbounded variance, since pi \u2243 0 in D can cause ED [ R\u0302(h) ] to be arbitrarily far away from\nthe true risk R(h). This problem can be fixed by \u201cclipping\u201d the importance sampling weights (Ionides, 2008)\nRM (h) = ExEy\u223ch0(x)\n[\n\u03b4(x, y)min\n{ M, h(y |x) h0(y |x) }] ,\nR\u0302M (h) = 1\nn\nn \u2211\ni=1\n\u03b4imin\n{ M, h(yi | xi)\npi\n}\n. (5)\nM > 0 is a hyper-parameter chosen to trade-off bias and variance in the estimate, where smaller values of M induce larger bias in the estimate. Optimizing R\u0302M (h) through exhaustive enumeration over H yields the Inverse Propensity Scoring (IPS) training objective (Bottou et al., 2013)\nh\u0302IPS = argmin h\u2208H\n{ R\u0302M (h) } . (6)\nThird, importance sampling typically estimates R\u0302M (h) of different hypotheses h \u2208 H with vastly different variances. Consider two hypotheses h1 and h2, where h1 is similar to h0, but where h2 samples predictions that were not well explored by h0. Importance sampling gives us low-variance estimates for R\u0302M (h1), but highly variable estimates for R\u0302M (h2). Intuitively, if we can develop variance-sensitive confidence bounds over the hypothesis space, optimizing a conservative confidence bound should find a h whose R(h) will not be much worse, with high probability.\nGeneralization error bound. To develop a generalization error bound, we first need a concept of capacity for stochastic hypothesis classes. For any stochastic class H, define an auxiliary function class FH = {fh : X \u00d7Y 7\u2192 [0, 1]}. Each h \u2208 H corresponds to a function fh \u2208 FH,\nfh(x, y) = 1 + \u03b4(x, y)\nM min\n{ M, h(y | x) h0(y | x) } . (7)\nfh is a deterministic, bounded function, and satisfies\nExEy\u223ch0(x) [fh(x, y)] = 1 +R M (h)/M. (8)\nHence, we can use classic notions of capacity for FH to reason about the convergence of R\u0302M (h) \u2192 RM (h). Recall the covering number N\u221e(\u01eb,F , n) for a function class F (Maurer & Pontil, 2009). Define an \u01eb\u2212cover N (\u01eb, A, \u2016\u00b7\u2016\u221e) for a set A \u2286 Rn to be the size of the smallest cardinality subset A0 \u2286 A such that A is contained in the union of balls of radius \u01eb centered at points in A0, in the metric induced by \u2016 \u00b7 \u2016\u221e. The covering number is,\nN\u221e(\u01eb,F , n) = sup (xi,yi)\u2208(X\u00d7Y)n N (\u01eb,F({(xi, yi)}), \u2016\u00b7\u2016\u221e),\nwhere F({(xi, yi)}) is the function class conditioned on sample {(xi, yi)},\nF({(xi, yi)}) = {(f(x1, y1), . . . , f(xn, yn)) : f \u2208 F}.\nOur measure for the capacity of our stochastic class H to \u201cfit\u201d a sample of size n shall be N\u221e( 1n ,FH, 2n). Theorem 1. For a compact notation, define\nuh i \u2261 \u03b4i min{M,h(yi | xi)/pi}, (9)\nV arh(u) \u2261 1\nn(n\u2212 1)\nn \u2211\ni,j=1\n(uh i \u2212 uhj)2 2 ,\nQH(n, \u03b3) \u2261 log(10 \u00b7 N\u221e( 1\nn ,FH, 2n)/\u03b3), 0 < \u03b3 < 1.\nWith probability at least 1 \u2212 \u03b3 in the random vector (x1, y1) \u00b7 \u00b7 \u00b7 (xn, yn), with xi i.i.d.\u223c Pr(X ) and yi \u223c h0(xi), and observed losses \u03b41, . . . , \u03b4n, for n \u2265 16 and a hypothesis space H with capacity N\u221e( 1n ,FH, 2n),\n\u2200h \u2208 H : R(h) \u2264 R\u0302M (h) + \u221a 18V arh(u)QH(n, \u03b3)/n +M \u00b7 15Q(n, \u03b3)/(n\u2212 1).\nProof. Follow the proof of Theorem 6 of (Maurer & Pontil, 2009) with the function class as FH. Use Equations (7),(8) to translate from fh(x, y) to RM (h). R\u0302M (h) = M \u00b7 f\u0302h\u22121, RM (h) = M \u00b7 fh \u2212 1, and M2V arh(u) = V arfh(u). Finally, since \u2200x, \u2200y, \u03b4(x,y) \u2264 0, hence R(h) \u2264 RM (h).\nCRM Principle. This generalization error bound is constructive, and it motivates a general principle for designing machine learning methods for batch learning from bandit feedback. In particular, a learning algorithm following this principle should jointly optimize the estimate R\u0302M (h) as well as its empirical standard deviation, where the latter serves as a data-dependent regularizer.\nh\u0302CRM = argmin h\u2208H\n{\nR\u0302M (h) + \u03bb\n\u221a\nV arh(u)\nn\n}\n. (10)\nM > 0 and \u03bb \u2265 0 are regularization hyper-parameters. When \u03bb = 0, we recover the Inverse Propensity Scoring objective of Equation (6). In analogy to Structural Risk\nMinimization (Vapnik, 1998), we call this principle Counterfactual Risk Minimization, since both pick the hypothesis with the tightest upper bound on the true risk R(h)."}, {"heading": "4.1. Optimal Loss Scaling", "text": "When performing supervised learning with true labels y\u2217 and a loss function \u2206(y\u2217, \u00b7), empirical risk minimization using the standard estimator is invariant to additive translation and multiplicative scaling of \u2206. The risk estimators R\u0302(h) and R\u0302M (h) in bandit learning, however, crucially require \u03b4(\u00b7, \u00b7) \u2208 [\u22121, 0]. Consider, for example, the case of \u03b4(\u00b7, \u00b7) \u2265 0. The training objectives in Equation (6) (IPS) and Equation (10) (CRM) become degenerate! A hypothesis h \u2208 H that completely avoids the sample D (i.e. \u2200i = 1, . . . , n, h(yi | xi) = 0) trivially achieves the best possible R\u0302M (h) (= 0) with 0 variance. This degeneracy arises because when \u03b4(\u00b7, \u00b7) \u2265 0, the optimization objectives are a lower bound on the true risk, whereas what we need is an upper bound on R(h).\nFor any bounded loss \u03b4(\u00b7, \u00b7) \u2208 [\u25bd,\u25b3], we have, \u2200x\nEy\u223ch(x)[\u03b4(x, y)]\u2264\u25b3+Ey\u223ch0(x) [ (\u03b4(x, y)\u2212\u25b3) h(y | x) h0(y | x) ] .\nWe assert that this is the tightest possible upper bound possible without additional assumptions. Since the optimization objectives in Equations (6),(10) are unaffected by a constant scale factor (e.g. \u25b3 \u2212 \u25bd), we should transform \u03b4 7\u2192 \u03b4\u2032 to derive a conservative training objective w.r.t. \u03b4\u2032,\n\u03b4\u2032 \u2261 {\u03b4 \u2212\u25b3}/{\u25b3\u2212\u25bd}."}, {"heading": "4.2. Selecting hyper-parameters", "text": "We propose selecting the hyper-parameters M > 0 and \u03bb \u2265 0 via validation. However, we must be careful not to set \u03bb too big. The estimated risk R\u0302M (h) \u2208 [\u2212M, 0] while the variance penalty \u221a\nV arh(u) n\n\u2208 [\n0, M 2 \u221a n\n]\n. If \u03bb \u226b 0, a hypothesis h \u2208 H that completely avoids D achieves a training objective of 0. As a rule of thumb, we can calibrate \u03bb \u2264 \u03bb\u2217 so that the objective is negative for some h \u2208 H. When h0 \u2208 H, { R\u0302M (h0) + \u03bb \u221a V arh0 (u)\nn\n}\n< 0 is a nat-\nural choice. This way, minimization over H is guaranteed to avoid returning degenerate h."}, {"heading": "5. Learning Algorithm: POEM", "text": "We now derive an efficient algorithm for structured output prediction using linear rules from the CRM principle. Classic linear models in supervised learning predict using\nhsupw (x) = argmax y\u2208Y {w \u00b7 \u03c6(x, y)} , (11)\nwhere w is a d\u2212dimensional weight vector, and \u03c6(x, y) is a d\u2212dimensional linear feature map. For example, in multilabel document classification, for a news article x and a possible assignment of labels y represented as a bitvector, \u03c6(x, y) could simply be a concatenation of the bag-ofwords features of the document (x), one copy for each of the assigned labels in y, x \u2297 y. Several efficient inference algorithms have been developed to solve Equation (11).\nConsider the following stochastic family Hlin, parametrized by w. A hypothesis hw(x) \u2208 Hlin samples y from the distribution\nhw(y | x) = exp(w \u00b7 \u03c6(x, y))/Z(x), (12)\nZ(x) = \u2211 y\u2032\u2208Y exp(w \u00b7 \u03c6(x, y\u2032)) is the partition function. This can be thought of as the \u201csoft-max\u201d variant of the \u201chard-max\u201d rules from Equation (11). Additionally, for a temperature multiplier \u03b1 > 1, w 7\u2192 \u03b1w induces a more \u201cpeaked\u201d distribution h\u03b1w that preserves the modes of hw, and intuitively, is a \u201cmore deterministic\u201d variant of hw.\nhw lies in the exponential family of distributions, and has a simple gradient,\n\u2207hw(y |x)=hw(y |x) { \u03c6(x,y)\u2212Ey\u2032\u223chw(x)[\u03c6(x,y\u2032)] } . (13)\nConsider a bandit-feedback structured-output dataset D = {(x1, y1, \u03b41, p1), . . . , (xn, yn, \u03b4n, pn)}. In multi-label document classification, this data could be collected from an interactive labeling system, each y indicating the labels predicted by the system for a document x, receiving as feedback \u03b4(x, y) how many labels (but not which ones) were correct. To perform learning, first we scale the losses as outlined in Section 4.1. Next, instantiating the CRM principle (Equation (10)) for Hlin, (using notation analogous to that in Theorem 1, adapted for Hlin), yields the POEM training objective.\nPOEM Training Objective:\nw\u2217 = argmin w\u2208Rd uw + \u03bb\n\u221a\nV arw(u)\nn + \u00b5\u2016w\u20162, (14)\nwhere\nuw i \u2261 \u03b4i min{M, exp(w \u00b7 \u03c6(xi, yi)) pi \u00b7 Z(xi) },\nuw \u2261 n \u2211\ni=1\nuw i/n,\nV arw(u) \u2261 n \u2211\ni=1\n(uw i \u2212 uw)2/(n\u2212 1).\nWhile the objective in Equation (14) is not convex in w (even for \u03bb = 0), we find that batch gradient descent (e.g. L-BFGS) and the stochastic gradient approach introduced below find local optima that have good generalization error.\nSoftware implementing POEM is available at http://www.cs.cornell.edu/\u02dcadith/CRM/poem.html for download, as is all the code and data needed to run each of the experiments reported in Section 6."}, {"heading": "5.1. Iterated Variance Majorization", "text": "The POEM training objective in Equation (14), specifically the variance term \u221a\nV arw(u), resists stochastic gradient optimization in the presented form. To remove this obstacle, we now develop a Majorization-Minimization scheme that can be shown to converge to a local optimum of the POEM training objective. In particular, we will show how to decompose \u221a\nV arw(u) as a sum of differentiable functions (e.g. \u2211\ni uw i or\n\u2211\ni{uwi}2) so that we can optimize the overall training objective at scale using stochastic gradient descent.\nProposition 1. For any w0,\n\u221a V arw(u) \u2264 Aw0 n \u2211\ni=1\nuw i +Bw0\nn \u2211\ni=1\n{uwi}2 + Cw0\n= Q(w;w0).\nAw0 \u2261 \u2212uw0/{(n\u2212 1) \u221a V arw0(u)}, Bw0 \u2261 1/{2(n\u2212 1) \u221a V arw0(u)}, Cw0 \u2261 n{uw0}2\n2(n\u2212 1) \u221a V arw0(u) +\n\u221a\nV arw0(u)\n2 .\nProof. Consider a first order Taylor approximation of \u221a\nV arw(u) around w0, \u221a\u00b7 is concave. Again Taylor ap-\nproximate \u2212{uw}2, noting that \u2212{\u00b7}2 is concave.\nIteratively minimizingwt+1 = argminw Q(w;w t) ensures that the sequence of iterates w1, . . . , wt+1 are successive minimizers of \u221a\nV arw(u). Hence, during an epoch t, POEM proceeds by sampling uniformly i \u223c D, comput-\ning uwi,\u2207uwi and, for learning rate \u03b7, updating\nw \u2190 w\u2212 \u03b7{\u2207uwi + \u03bb\u221a n (Awt\u2207uwi + 2Bwtuwi\u2207uwi)}.\nAfter each epoch, wt+1 \u2190 w, and iterated minimization proceeds until convergence."}, {"heading": "6. Experiments", "text": "We now empirically evaluate the prediction performance and computational efficiency of POEM. Consider multilabel classification with input x \u2208 Rp and prediction y \u2208 {0, 1}q. Popular supervised algorithms that solve this problem include Structured SVMs and Conditional Random Fields. In the simplest case, CRF essentially performs logistic regression for each of the q labels independently. As outlined in Section 5, we use a linear feature map: \u03c6(x, y) = x \u2297 y. We conducted experiments on different multi-label datasets collected from the LibSVM repository, with different ranges for p (features), q (labels) and n (samples) represented as summarized in Table 2.\nExperiment methodology. We employ the Supervised 7\u2192 Bandit conversion (Agarwal et al., 2014) method. Here, we take a supervised dataset D = {(x1, y\u22171) . . . (xn, y\u2217n)} and simulate a bandit feedback dataset from a logging policy h0 by sampling yi \u223c h0(xi) and collecting feedback \u2206(y\u2217i , yi). In all the multi-label experiments, \u2206(y\n\u2217(x), y) is the Hamming loss between the supervised label y\u2217 vs. the sampled label y for input x. Hamming loss is just the number of incorrectly assigned labels (both false positives and false negatives). We can explore different learning strategies (e.g. IPS, CRM, etc.) on D = {(xi, yi, \u03b4i \u2261 \u2206(y\u2217i , yi), pi \u2261 h0(yi | xi))} and obtain learnt weight vectors wips, wcrm, etc. On the test set, we then report the expected loss per instance R(w) = 1\nn\n\u2211 i Ey\u223chw(xi)\u2206(y \u2217 i , y)\nand compare the generalization performance of these learning strategies.\nExperiment setup. For all datasets, we kept aside 25% of ntrain as validation set and treat the rest as the training\nset. For all methods, when optimizing any objective over w, we always begin the optimization fromw = 0 (\u21d2 hw = uniform(Y)). SGD learning rates follow a 1\u221a\n1+t schedule.\nThe bandit learning methods do not get access to the labeled training set, but merely to labels y sampled from h0. In principle, we could use any arbitrary stochastic policy as h0. We choose a CRF trained on 10% of the training set as h0 using default hyper-parameters (C = 1), since they provide probability distributions amenable to sampling.\nTo create D = {(x1, y1, \u03b41, p1), . . . , (xn, yn, \u03b4n, pn)}, we take two passes through the training set and sample labels from h0. Note that each supervised label is worth \u2243 |Y| = 2q bandit feedback labels.\nWe use the validation set for hyper-parameter selection. For CRFs, C \u2208 [0.001, . . . , 100], while for the bandit learning approaches, M \u2208 [1, . . . , 1000] , \u00b5 \u2208 [\n10\u22128, . . . , 1 ] , c \u2208 [ 10\u22124, . . . , 1 ]\nin multiples of 10. c denotes the scaling for the variance penalty, \u03bb = c\u03bb\u2217, where \u03bb\u2217 is the calibration factor from Section 4.2.\nFinally, the entire experiment set-up is run 10 times (i.e. h0 trained on randomly chosen 10% subsets, D re-created, and test set performance of different approaches collected) and we report the averaged test set expected error across runs. The expected Hamming loss of h0 is the baseline to beat. Lower loss is better. The IPS objective represents the stateof-the-art for counterfactual learning. We optimize it using L-BFGS and report its test set expected loss. POEM uses our Iterative-Majorization SGD, as outlined in Section 5.1. Finally, we report results from supervised CRF trained on the entire training set as a skyline, despite its unfair advantage of having access to the full-information examples."}, {"heading": "6.1. Does variance regularization improve generalization?", "text": "Results are reported in Table 3. We statistically test the performance of POEM against IPS using a one-tailed paired difference t-test at significance level of 0.05 across 10 runs of the experiment, and find POEM to be significantly better than IPS on each dataset. Furthermore, on all datasets POEM learns a hypothesis that substantially improves over the prediction performance of h0. IPS actually fails on the Media dataset, where it returns a hypothesis that is worse than h0. This suggests that the CRM principle is practically useful for designing learning algorithms, and that the variance regularizer indeed provides practical benefit."}, {"heading": "6.2. How computationally efficient is POEM?", "text": "To evaluate the efficiency of training POEM, we implemented two versions of the algorithm. For POEM(S) we train the objective using the iterative-majorization\nStochastic gradient method described in Section 5.1. For POEM(B) we optimize the POEM objective via L-BFGS, a Batch gradient method. L-BFGS was also use for training the IPS(B) method. Table 4 shows the time taken (in CPU seconds) to run each method on each dataset, averaged over different validation runs when performing hyper-parameter grid search. Some of the timing results are skewed by outliers, e.g. when under very weak l2\u2212regularization, CRFs tend to take a lot longer to converge. However, in aggregate, it is clear that POEM(S) is able to recover good parameter settings in a fraction of the time of batch L-BFGS optimization, and this is even more pronounced when the number of labels and number of samples grows (the runtime cost is dominated by the computation of Z(x) for each sample). Interestingly, we also find that the optima found by the SGD optimizer tend to generalize better than the optima found by L-BFGS."}, {"heading": "6.3. Can MAP predictions derived from stochastic policies perform well?", "text": "For the policies learnt by POEM as shown in Table 3, Table 5 reports the averaged performance of the deterministic predictor derived from them. For a learnt weight vector w, this simply amounts to applying Equation (11). In practice, this method of generating predictions can be substantially faster than sampling since computing the argmax does not require computation of the partition function Z(x) which can be expensive in structured output prediction. From Table 5, we see that the loss of the deterministic predic-\ntor is typically not far from the loss of the stochastic policy, but often slightly better. This suggests that POEM tends to find parameters w that behave almost deterministically (i.e. \u2016w\u2016 is large), which we verified to be true. Moreover, we can also assert that, for any stochastic policy hw, there exists a corresponding deterministic function that has risk no greater than R(w) (and similarly for empirical risk), and hence techniques like variance regularization and l2\u2212regularization become crucial in this setting."}, {"heading": "6.4. How does generalization improve with size of D?", "text": "As we collect more data under h0, our generalization error bound indicates that prediction performance should eventually approach that of the optimal hypothesis in the hypothesis space. We can simulate n \u2192 \u221e by replaying the training data multiple times, collecting samples y \u223c h0(x). In the limit, we would observe every possible y in the bandit feedback dataset, since h0(x) has non-zero probability of exploring each prediction y. However, the learning rate may be slow, since the exponential model family has very thin tails, and hence may not be an ideal logging distribution to learn from.\nTo ensure that we do not have confounding effects from stochastic optimization and early termination, here we study the L-BFGS variant of POEM(B). Holding all other details of the experiment setup fixed, we vary the number of times we replayed the training set (ReplayCount) to collect samples from h0, and report the performance of a single run of POEM(B) on the Yeast dataset in Figure 1."}, {"heading": "6.5. How does quality of h0 affect learning?", "text": "In this experiment, we change the fraction of the training set f \u00b7 ntrain that was used to train the logging policy; as f is increased, the quality of h0 improves. Intuitively, there\u2019s a trade-off: better h0 probably samples correct predictions more often and so produces a higher quality D to learn from, but it should also be harder to beat h0. We vary f from 10% to 100% while keeping all other conditions identical to the original experiment setup, and again focus on the L-BFGS variant of POEM(B). We report the performance of h0 and POEM(B) for a single experiment run in Figure 2, and find that POEM(B) is able to consistently find a hypothesis at least as good as h0. Moreover, the performance of POEM(B) plateaus with increasing f , in contrast with its behavior in Figure 1, where it consis-\ntently improves with increasing n."}, {"heading": "6.6. How does stochasticity of h0 affect learning?", "text": "Finally, the theory suggests that counterfactual learning is only possible when h0 is sufficiently stochastic (the generalization bounds hold with high probability in the samples drawn from h0). Does CRM degrade gracefully when this assumption is violated? We test this by introducing the temperature multiplier w 7\u2192 \u03b1w, \u03b1 > 0 (as discussed in Section 5) into the logging policy. For h0 = hw0 , we scale w0 7\u2192 \u03b1w0, to derive a \u201cmore deterministic\u201d variant of h0, and generate D \u223c h\u03b1w0 . Holding all other experiment conditions fixed, we report the performance of a single run of POEM(B) in Figure 3 as we change \u03b1 \u2208 [0.5, . . . , 32], compared against h0, and the deter-\nministic predictor \u2013 h0 map \u2013 derived from h0. So long as there is some minimum amount of stochasticity in h0 (\u03b1 \u2264 22), POEM(B) is still able to find a w that marginally improves upon h0. The margin of improvement is more when h0 is more stochastic. Even when h0 is too deterministic (\u03b1 \u2265 23), performance of POEM(B) does not degrade too much, suggesting that the CRM principle indeed achieves robust learning."}, {"heading": "6.7. Can warm-starting the parameter search help?", "text": "We na\u0131\u0308vely started our parameter search from w = 0 in all experiments reported so far. However, since our logging policy h0(w0) \u2208 Hlin, we can perhaps reach better local minima by warm-starting the search with w = w0. The\ngeneralization performance of POEM(B) with and without warm-starting is shown in Table 6. Warm-starting consistently helps find marginally better optima, suggesting there is further avenue for improvement using clever optimization techniques to solve these non-convex objectives."}, {"heading": "7. Conclusion", "text": "Counterfactual risk minimization serves as a robust principle to design algorithms that can learn from a batch of bandit feedback interactions. The key insight for CRM is to expand the classical notion of a hypothesis class to include stochastic policies, reason about variance in the risk\nestimator, and derive a generalization error bound over this hypothesis space. The practical take-away is a simple, datadependent regularizer that guarantees robust learning. We also developed POEM that uses CRM for structured output prediction. POEM can optimize over rich policy families (exponential models corresponding to linear rules in supervised learning), and deal with massive output spaces as efficiently as classical supervised methods. POEM efficiently decomposes the CRM training objective using repeated variance linearization, and optimizes at scale using stochastic gradient descent.\nCRM can more generally apply to supervised learning with non-differentiable losses, since the objective does not require the gradient of the loss function. We also foresee extensions of this work that relax some of the assumptions, e.g., to handle noisy \u03b4(\u00b7, \u00b7), to extend to ordinal or co-active feedback, to learn from adaptive or deterministic h0, etc."}, {"heading": "Acknowledgement", "text": "This research was funded in part through NSF Awards IIS1247637 and IIS-1217686, and JTCII Cornell-Technion Research Fund, and a gift from Bloomberg."}], "references": [{"title": "Taming the monster: A fast and simple algorithm for contextual bandits", "author": ["Agarwal", "Alekh", "Hsu", "Daniel", "Kale", "Satyen", "Langford", "John", "Li", "Lihong", "Schapire", "Robert"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "Agarwal et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Agarwal et al\\.", "year": 2014}, {"title": "The offset tree for learning with partial labels", "author": ["Beygelzimer", "Alina", "Langford", "John"], "venue": "In Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,", "citeRegEx": "Beygelzimer et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Beygelzimer et al\\.", "year": 2009}, {"title": "Reusing historical interaction data for faster online learning to rank for IR", "author": ["Hofmann", "Katja", "Schuth", "Anne", "Whiteson", "Shimon", "de Rijke", "Maarten"], "venue": "In Sixth ACM International Conference on Web Search and Data Mining,", "citeRegEx": "Hofmann et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hofmann et al\\.", "year": 2013}, {"title": "Truncated importance sampling", "author": ["Ionides", "Edward L"], "venue": "Journal of Computational and Graphical Statistics,", "citeRegEx": "Ionides and L.,? \\Q2008\\E", "shortCiteRegEx": "Ionides and L.", "year": 2008}, {"title": "Exploration scavenging", "author": ["Langford", "John", "Strehl", "Alexander", "Wortman", "Jennifer"], "venue": "In Proceedings of the 25th International Conference on Machine Learning,", "citeRegEx": "Langford et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Langford et al\\.", "year": 2008}, {"title": "Doubly robust policy evaluation and learning", "author": ["Langford", "John", "Li", "Lihong", "Dudk", "Miroslav"], "venue": "In Proceedings of the 28th International Conference on Machine Learning", "citeRegEx": "Langford et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Langford et al\\.", "year": 2011}, {"title": "Counterfactual estimation and optimization of click metrics for search", "author": ["Li", "Lihong", "Chen", "Shunbao", "Kleban", "Jim", "Gupta", "Ankur"], "venue": "engines. CoRR,", "citeRegEx": "Li et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "On minimax optimal offline policy evaluation", "author": ["Li", "Lihong", "Munos", "R\u00e9mi", "Szepesv\u00e1ri", "Csaba"], "venue": "CoRR, abs/1409.3653,", "citeRegEx": "Li et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "Improving offline evaluation of contextual bandit algorithms via bootstrapping techniques", "author": ["Mary", "J\u00e9r\u00e9mie", "Preux", "Philippe", "Nicol", "Olivier"], "venue": "In Proceedings of the 31th International Conference on Machine Learning, ICML 2014, Beijing,", "citeRegEx": "Mary et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Mary et al\\.", "year": 2014}, {"title": "Empirical bernstein bounds and sample-variance penalization", "author": ["Maurer", "Andreas", "Pontil", "Massimiliano"], "venue": "In COLT 2009 - The 22nd Conference on Learning Theory,", "citeRegEx": "Maurer et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Maurer et al\\.", "year": 2009}, {"title": "The central role of the propensity score in observational studies for causal effects", "author": ["Rosenbaum", "Paul R", "Rubin", "Donald B"], "venue": null, "citeRegEx": "Rosenbaum et al\\.,? \\Q1983\\E", "shortCiteRegEx": "Rosenbaum et al\\.", "year": 1983}, {"title": "Multi-armed bandit problems with history", "author": ["Shivaswamy", "Pannagadatta K", "Joachims", "Thorsten"], "venue": "In Proceedings of the Fifteenth International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Shivaswamy et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Shivaswamy et al\\.", "year": 2012}, {"title": "Statistical Learning Theory", "author": ["V. Vapnik"], "venue": null, "citeRegEx": "Vapnik,? \\Q1998\\E", "shortCiteRegEx": "Vapnik", "year": 1998}, {"title": "Costsensitive learning by cost-proportionate example weighting", "author": ["Zadrozny", "Bianca", "Langford", "John", "Abe", "Naoki"], "venue": "In Proceedings of the Third IEEE International Conference on Data Mining,", "citeRegEx": "Zadrozny et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Zadrozny et al\\.", "year": 2003}], "referenceMentions": [{"referenceID": 5, "context": "Such estimators have been developed recently for the off-policy evaluation problem (Langford et al., 2011), (Li et al.", "startOffset": 83, "endOffset": 106}, {"referenceID": 12, "context": "We first prove generalization error bounds analogous to structural risk minimization (Vapnik, 1998) for a stochastic hypothesis family.", "startOffset": 85, "endOffset": 99}, {"referenceID": 13, "context": "More sophisticated techniques using a cost weighted classification (Zadrozny et al., 2003) or the Offset Tree algorithm (Beygelzimer & Langford, 2009) allow us to perform batch learning when the space of possible predictions is small.", "startOffset": 67, "endOffset": 90}, {"referenceID": 5, "context": ", 2014b), and doubly robust estimators are even more efficient when we additionally have a good model of the feedback (Langford et al., 2011).", "startOffset": 118, "endOffset": 141}, {"referenceID": 4, "context": "Techniques like exploration scavenging (Langford et al., 2008) and bootstrapping (Mary et al.", "startOffset": 39, "endOffset": 62}, {"referenceID": 8, "context": ", 2008) and bootstrapping (Mary et al., 2014) allow us to perform counterfactual evaluation even when the historical algorithm was deterministic or adaptive.", "startOffset": 26, "endOffset": 45}, {"referenceID": 2, "context": "Beyond the problem of batch learning from bandit feedback, our approach can have implications for several applications that require learning from logged bandit feedback data: warm-starting multi-armed bandits (Shivaswamy & Joachims, 2012), pre-selecting retrieval functions for search engines (Hofmann et al., 2013), and policy evaluation for contextual bandits (Li et al.", "startOffset": 293, "endOffset": 315}, {"referenceID": 12, "context": "In analogy to Structural Risk Minimization (Vapnik, 1998), we call this principle Counterfactual Risk Minimization, since both pick the hypothesis with the tightest upper bound on the true risk R(h).", "startOffset": 43, "endOffset": 57}, {"referenceID": 0, "context": "We employ the Supervised 7\u2192 Bandit conversion (Agarwal et al., 2014) method.", "startOffset": 46, "endOffset": 68}], "year": 2017, "abstractText": "We develop a learning principle and an efficient algorithm for batch learning from logged bandit feedback. This learning setting is ubiquitous in online systems (e.g., ad placement, web search, recommendation), where an algorithm makes a prediction (e.g., ad ranking) for a given input (e.g., query) and observes bandit feedback (e.g., user clicks on presented ads). We first address the counterfactual nature of the learning problem through propensity scoring. Next, we prove generalization error bounds that account for the variance of the propensity-weighted empirical risk estimator. These constructive bounds give rise to the Counterfactual Risk Minimization (CRM) principle. We show how CRM can be used to derive a new learning method \u2013 called Policy Optimizer for Exponential Models (POEM) \u2013 for learning stochastic linear rules for structured output prediction. We present a decomposition of the POEM objective that enables efficient stochastic gradient optimization. POEM is evaluated on several multi-label classification problems showing substantially improved robustness and generalization performance compared to the state-of-the-art.", "creator": "LaTeX with hyperref package"}}}