{"id": "1502.06464", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Feb-2015", "title": "Rectified Factor Networks", "abstract": "We propose rectified factor networks (RFNs) as generative, unsupervised models that learn robust, very sparse and non-linear codes with many units of code. RFN learning is an algorithm for maximizing variation (EM) with an unknown history that includes (i) rectified posterior means, (ii) normalized signals from hidden units and (iii) dropouts. As factor analysis, RFNs explain the variance of data by their parameters. In pre-training deep networks on MNIST, rectangular data, convex shapes, NORB and CIFAR, RFNs were superior to limited Boltzmann machines (RBMs) and denossing autoencoders. In CIFAR-10 and CIFAR-100, improved RFN pre-training always showed the results of deep networks for different architectures such as AlexNet, Deeply Monitored Network (DSN) and a simple \"guaranteed\" success. \"", "histories": [["v1", "Mon, 23 Feb 2015 15:44:37 GMT  (1237kb,D)", "https://arxiv.org/abs/1502.06464v1", "10 pages + 30 pages supplement"], ["v2", "Thu, 11 Jun 2015 21:27:53 GMT  (3345kb,D)", "http://arxiv.org/abs/1502.06464v2", "9 pages + 49 pages supplement"]], "COMMENTS": "10 pages + 30 pages supplement", "reviews": [], "SUBJECTS": "cs.LG cs.CV cs.NE stat.ML", "authors": ["djork-arn\u00e9 clevert", "andreas mayr", "thomas unterthiner", "sepp hochreiter"], "accepted": true, "id": "1502.06464"}, "pdf": {"name": "1502.06464.pdf", "metadata": {"source": "CRF", "title": "Rectified Factor Networks", "authors": ["Djork-Arn\u00e9 Clevert", "Andreas Mayr", "Thomas Unterthiner"], "emails": ["okko@bioinf.jku.at", "mayr@bioinf.jku.at", "unterthiner@bioinf.jku.at", "hochreit@bioinf.jku.at"], "sections": [{"heading": "1 Introduction", "text": "The success of deep learning is to a large part based on advanced and efficient input representations [1, 2, 3, 4]. These representations are sparse and hierarchical. Sparse representations of the input are in general obtained by rectified linear units (ReLU) [5, 6] and dropout [7]. The key advantage of sparse representations is that dependencies between coding units are easy to model and to interpret. Most importantly, distinct concepts are much less likely to interfere in sparse representations. Using sparse representations, similarities of samples often break down to co-occurrences of features in these samples. In bioinformatics sparse codes excelled in biclustering of gene expression data [8] and in finding DNA sharing patterns between humans and Neanderthals [9].\nRepresentations learned by ReLUs are not only sparse but also non-negative. Non-negative representations do not code the degree of absence of events or objects in the input. As the vast majority of events is supposed to be absent, to code for their degree of absence would introduce a high level of random fluctuations. We also aim for non-linear input representations to stack models for constructing hierarchical representations. Finally, the representations are supposed to have a large number of coding units to allow coding of rare and small events in the input. Rare events are only observed in few samples like seldom side effects in drug design, rare genotypes in genetics, or small customer groups in e-commerce. Small events affect only few input components like pathways with few genes in biology, few relevant mutations in oncology, or a pattern of few products in e-commerce. In summary, our goal is to construct input representations that (1) are sparse, (2) are non-negative, (3) are non-linear, (4) use many code units, and (5) model structures in the input data (see next paragraph).\nCurrent unsupervised deep learning approaches like autoencoders or restricted Boltzmann machines (RBMs) do not model specific structures in the data. On the other hand, generative models explain structures in the data but their codes cannot be enforced to be sparse and non-negative. The input\nar X\niv :1\n50 2.\n06 46\n4v 2\n[ cs\n.L G\n] 1\n1 Ju\nn 20\n15\nrepresentation of a generative model is its posterior\u2019s mean, median, or mode, which depends on the data. Therefore sparseness and non-negativity cannot be guaranteed independent of the data. For example, generative models with rectified priors, like rectified factor analysis, have zero posterior probability for negative values, therefore their means are positive and not sparse [10, 11]. Sparse priors do not guarantee sparse posteriors as seen in the experiments with factor analysis with Laplacian and Jeffrey\u2019s prior on the factors (see Tab. 1). To address the data dependence of the code, we employ the posterior regularization method [12]. This method separates model characteristics from data dependent characteristics that are enforced by constraints on the model\u2019s posterior.\nWe aim at representations that are feasible for many code units and massive datasets, therefore the computational complexity of generating a code is essential in our approach. For non-Gaussian priors, the computation of the posterior mean of a new input requires either to numerically solve an integral or to iteratively update variational parameters [13]. In contrast, for Gaussian priors the posterior mean is the product between the input and a matrix that is independent of the input. Still the posterior regularization method leads to a quadratic (in the number of coding units) constrained optimization problem in each E-step (see Eq. (3) below). To speed up computation, we do not solve the quadratic problem but perform a gradient step. To allow for stochastic gradients and fast GPU implementations, also the M-step is a gradient step. These E-step and M-step modifications of the posterior regularization method result in a generalized alternating minimization (GAM) algorithm [12]. We will show that the GAM algorithm used for RFN learning (i) converges and (ii) is correct. Correctness means that the RFN codes are non-negative, sparse, have a low reconstruction error, and explain the covariance structure of the data."}, {"heading": "2 Rectified Factor Network", "text": "Our goal is to construct representations of the input that (1) are sparse, (2) are non-negative, (3) are non-linear, (4) use many code units, and (5) model structures in the input. Structures in the input are identified by a generative model, where the model assumptions determine which input structures to explain by the model. We want to model the covariance structure of the input, therefore we choose maximum likelihood factor analysis as model. The constraints on the input representation are enforced by the posterior regularization method [12]. Non-negative constraints lead to sparse and non-linear codes, while normalization constraints scale the signal part of each hidden (code) unit. Normalizing constraints avoid that generative models explain away rare and small signals by noise. Explaining away becomes a serious problem for models with many coding units since their capacities are not utilized. Normalizing ensures that all hidden units are used but at the cost of coding also random and spurious signals. Spurious and true signals must be separated in a subsequent step either by supervised techniques, by evaluating coding units via additional data, or by domain experts.\nA generative model with hidden units h and data v is defined by its prior p(h) and its likelihood p(v | h). The full model distribution p(h,v) = p(v | h)p(h) can be expressed by the model\u2019s posterior p(h | v) and its evidence (marginal likelihood) p(v): p(h,v) = p(h | v)p(v). The representation of input v is the posterior\u2019s mean, median, or mode. The posterior regularization method introduces a variational distribution Q(h | v) \u2208 Q from a family Q, which approximates the posterior p(h | v). We choose Q to constrain the posterior means to be non-negative and normalized. The full model distribution p(h,v) contains all model assumptions and, thereby, defines which structures of the data are modeled. Q(h | v) contains data dependent constraints on the posterior, therefore on the code.\nFor data {v} = {v1, . . . ,vn}, the posterior regularization method maximizes the objective F [12]:\nF = 1 n n\u2211 i=1 log p(vi) \u2212 1 n n\u2211 i=1 DKL(Q(hi | vi) \u2016 p(hi | vi)) (1)\n= 1\nn n\u2211 i=1 \u222b Q(hi | vi) log p(vi | hi) dhi \u2212 1 n n\u2211 i=1 DKL(Q(hi | vi) \u2016 p(hi)) ,\nwhereDKL is the Kullback-Leibler distance. Maximizing F achieves two goals simultaneously: (1) extracting desired structures and information from the data as imposed by the generative model and (2) ensuring desired code properties via Q \u2208 Q.\nThe factor analysis model v = Wh + extracts the covariance structure of the data. The prior h \u223c N (0, I) of the hidden units (factors) h \u2208 Rl and the noise \u223c N (0,\u03a8) of visible units (observations) v \u2208 Rm are independent. The model parameters are the weight (loading) matrixW \u2208 Rm\u00d7l and the noise covariance matrix \u03a8 \u2208 Rm\u00d7m. We assume diagonal \u03a8 to explain correlations between input components by the hidden units and not by correlated noise. The factor analysis model is depicted in Fig. 1. Given the mean-centered data {v} = {v1, . . . ,vn}, the posterior p(hi | vi) is Gaussian with mean vector (\u00b5p)i and covariance matrix \u03a3p:\n(\u00b5p)i = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi ,\n\u03a3p = ( I + W T\u03a8\u22121W )\u22121 . (2)\nA rectified factor network (RFN) consists of a single or stacked factor analysis model(s) with constraints on the posterior. To incorporate the posterior constraints into the factor analysis model, we use the posterior regularization method that maximizes the objective F given in Eq. (1) [12]. Like the expectation-maximization (EM) algorithm, the posterior regularization method alternates between an E-step and an M-step. Minimizing the first DKL of Eq. (1) with respect to Q leads to a constrained optimization problem. For Gaussian distributions, the solution with (\u00b5p)i and\u03a3p from Eq. (2) is Q(hi | vi) \u223c N (\u00b5i,\u03a3) with \u03a3 = \u03a3p and the quadratic problem:\nmin \u00b5i\n1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T \u03a3\u22121p (\u00b5i \u2212 (\u00b5p)i) , s.t. \u2200i : \u00b5i \u2265 0 , \u2200j : 1 n n\u2211 i=1 \u00b52ij = 1 , (3)\nwhere \u201c\u2265\u201d is component-wise. This is a constraint non-convex quadratic optimization problem in the number of hidden units which is too complex to be solved in each EM iteration. Therefore, we perform a step of the gradient projection algorithm [14, 15], which performs first a gradient step and then projects the result to the feasible set. We start by a step of the projected Newton method, then we try the gradient projection algorithm, thereafter the scaled gradient projection algorithm with reduced matrix [16] (see also [15]). If these methods fail to decrease the objective in Eq. (3), we use the generalized reduced method [17]. It solves each equality constraint for one variable and inserts it into the objective while ensuring convex constraints. Alternatively, we use Rosen\u2019s gradient projection method [18] or its improvement [19]. These methods guarantee a decrease of the E-step objective.\nSince the projection P by Eq. (6) is very fast, the projected Newton and projected gradient update is very fast, too. A projected Newton step requires O(nl) steps (see Eq. (7) and P defined in Theorem 1), a projected gradient step requires O(min{nlm, nl2}) steps, and a scaled gradient projection step requires O(nl3) steps. The RFN complexity per iteration is O(n(m2 + l2)) (see Alg. 1). In contrast, a quadratic program solver typically requires for the (nl) variables (the means of the hidden units for all samples) O(n4l4) steps to find the minimum [20]. We exemplify these values on our benchmark datasets MNIST (n = 50k, l = 1024,m = 784) and CIFAR (n = 50k, l = 2048,m = 1024). The speedup with projected Newton or projected gradient in contrast to a quadratic solver is O(n3l2) = O(n4l4)/O(nl2), which gives speedup ratios of 1.3 \u00b7 1020 for MNIST and 5.2 \u00b7 1020 for CIFAR. These speedup ratios show that efficient E-step updates are essential for RFN learning. Furthermore, on our computers, RAM restrictions limited quadratic program solvers to problems with nl \u2264 20k. The M-step decreases the expected reconstruction error\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi | vi) log (p(vi | hi)) dhi (4)\n= 1\n2\n( m log (2\u03c0) + log |\u03a8| + Tr ( \u03a8\u22121C ) \u2212 2 Tr ( \u03a8\u22121WUT ) + Tr ( W T\u03a8\u22121WS ) ) .\nfrom Eq. (1) with respect to the model parameters W and \u03a8. Definitions of C, U and S are given in Alg. 1. The M-step performs a gradient step in the Newton direction, since we want to\nAlgorithm 1 Rectified Factor Network.\n1: C = 1 n \u2211n i=1 viv T i 2: while STOP=false do 3: \u2014\u2014E-step1\u2014\u2014 4: for all 1 \u2264 i \u2264 n do 5: (\u00b5p)i = ( I +W T\u03a8\u22121W )\u22121 W T\u03a8\u22121vi 6: end for 7: \u03a3 = \u03a3p = ( I + W T\u03a8\u22121W\n)\u22121 8: \u2014\u2014Constraint Posterior\u2014\u2014 9: (1) projected Newton, (2) projected gradient,\n(3) scaled gradient projection, (4) generalized reduced method, (5) Rosen\u2019s gradient project.\n10: \u2014\u2014E-step2\u2014\u2014 11: U = 1\nn \u2211n i=1 vi \u00b5 T i\n12: S = 1 n \u2211n i=1 \u00b5i \u00b5 T i + \u03a3 13: \u2014\u2014M-step\u2014\u2014 14: E = C \u2212 U W T \u2212 W U + W SW T 15: W = W + \u03b7 ( U S\u22121 \u2212 W\n) 16: for all 1 \u2264 k \u2264 m do 17: \u03a8kk = \u03a8kk + \u03b7 (Ekk \u2212 \u03a8kk) 18: end for 19: if stopping criterion is met: STOP=true 20: end while\nComplexity: objective F : O(min{nlm, nl2} + l3); E-step1: O(min{m2(m + l), l2(m + l)} + nlm); projected Newton: O(nl); projected gradient: O(min{nlm, nl2}); scaled gradient projection: O(nl3); Estep2: O(nl(m+l)); M-step: O(ml(m+l)); overall complexity with projected Newton / gradient for (l+m) < n: O(n(m2 + l2)).\nallow stochastic gradients, fast GPU implementation, and dropout regularization. The Newton step is derived in the supplementary which gives further details, too. Also in the E-step, RFN learning performs a gradient step using projected Newton or gradient projection methods. These projection methods require the Euclidean projection P of the posterior means {(\u00b5p)i} onto the non-convex feasible set:\nmin \u00b5i\n1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T (\u00b5i \u2212 (\u00b5p)i) , s.t. \u00b5i \u2265 0 , 1 n n\u2211 i=1 \u00b52ij = 1 . (5)\nThe following Theorem 1 gives the Euclidean projection P as solution to Eq. (5).\nTheorem 1 (Euclidean Projection). If at least one (\u00b5p)ij is positive for 1 \u2264 j \u2264 l, then the solution to optimization problem Eq. (5) is\n\u00b5ij = [P((\u00b5p)i)]j = \u00b5\u0302ij\u221a\n1 n \u2211n i=1 \u00b5\u0302 2 ij , \u00b5\u0302ij =\n{ 0 for (\u00b5p)ij \u2264 0 (\u00b5p)ij for (\u00b5p)ij > 0 . (6)\nIf all (\u00b5p)ij are non-positive for 1 \u2264 j \u2264 l, then the optimization problem Eq. (5) has the solution \u00b5ij = \u221a n for j = arg maxj\u0302{(\u00b5p)ij\u0302} and \u00b5ij = 0 otherwise.\nProof. See supplementary material.\nUsing the projection P defined in Eq. (6), the E-step updates for the posterior means \u00b5i are: \u00b5newi = P ( \u00b5oldi + \u03b3 ( d \u2212 \u00b5oldi )) , d = P ( \u00b5oldi + \u03bbH \u22121 \u03a3\u22121p ((\u00b5p)i \u2212 \u00b5oldi ) ) (7)\nwhere we set for the projected Newton method H\u22121 = \u03a3p (thus H\u22121\u03a3\u22121p = I), and for the projected gradient method H\u22121 = I . For the scaled gradient projection algorithm with reduced matrix, the -active set for i consists of all j with \u00b5ij \u2264 . The reduced matrix H is the Hessian \u03a3\u22121p with -active columns and rows j fixed to unit vectors ej . The resulting algorithm is a posterior regularization method with a gradient based E- and M-step, leading to a generalized alternating minimization (GAM) algorithm [21]. The RFN learning algorithm is given in Alg. 1. Dropout regularization can be included before E-step2 by randomly setting code units \u00b5ij to zero with a predefined dropout rate (note that convergence results will no longer hold)."}, {"heading": "3 Convergence and Correctness of RFN Learning", "text": "Convergence of RFN Learning. Theorem 2 states that Alg. 1 converges to a maximum of F . Theorem 2 (RFN Convergence). The rectified factor network (RFN) learning algorithm given in Alg. 1 is a \u201cgeneralized alternating minimization\u201d (GAM) algorithm and converges to a solution that maximizes the objective F .\nProof. We present a sketch of the proof which is given in detail in the supplement. For convergence, we show that Alg. 1 is a GAM algorithm which convergences according to Proposition 5 in [21].\nAlg. 1 ensures to decrease the M-step objective which is convex in W and \u03a8\u22121. The update with \u03b7 = 1 leads to the minimum of the objective. Convexity of the objective guarantees a decrease in the M-step for 0 < \u03b7 \u2264 1 if not in a minimum. Alg. 1 ensures to decrease the E-step objective by using gradient projection methods. All other requirements for GAM convergence are also fulfilled.\nProposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, thus updates of the RFN algorithm are viewed as point-to-set mappings [22]. Therefore the numerical precision, the choice of the methods in the E-step, and GPU implementations are covered by the proof.\nCorrectness of RFN Learning. The goal of the RFN algorithm is to explain the data and its covariance structure. The expected approximation errorE is defined in line 14 of Alg. 1. Theorem 3 states that the RFN algorithm is correct, that is, it explains the data (low reconstruction error) and captures the covariance structure as good as possible. Theorem 3 (RFN Correctness). The fixed point W of Alg. 1 minimizes Tr (\u03a8) given \u00b5i and \u03a3 by ridge regression with\nTr (\u03a8) = 1\nn n\u2211 i=1 \u2016 i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F , (8)\nwhere i = vi \u2212W\u00b5i. The model explains the data covariance matrix by C = \u03a8 + W S W T (9)\nup to an error, which is quadratic in \u03a8 for \u03a8 WW T . The reconstruction error 1n \u2211n i=1 \u2016 i\u2016 2 2 is quadratic in \u03a8 for \u03a8 WW T .\nProof. The fixed point equation for theW update is \u2206W = US\u22121 \u2212W = 0 \u21d2 W = US\u22121. Using the definition of U and S, we haveW = ( 1 n \u2211n i=1 vi \u00b5 T i ) ( 1 n \u2211n i=1 \u00b5i \u00b5 T i + \u03a3 )\u22121 . W is the ridge regression solution of\n1\nn n\u2211 i=1 \u2016vi \u2212 W \u00b5i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F = Tr ( 1 n n\u2211 i=1 i T i + W \u03a3W T ) , (10)\nwhere Tr is the trace. After multiplying out all i Ti in 1/n \u2211n i=1 i T i , we obtain:\nE = 1\nn n\u2211 i=1 i T i + W \u03a3W T . (11)\nFor the fixed point of \u03a8, the update rule gives: diag (\u03a8) = diag (\n1 n \u2211n i=1 i T i +W\u03a3W T ) .\nThus, W minimizes Tr (\u03a8) given \u00b5i and \u03a3. Multiplying the Woodbury identity for( WW T + \u03a8 )\u22121 from left and right by \u03a8 gives\nW\u03a3W T = \u03a8\u2212\u03a8 ( W W T + \u03a8 )\u22121 \u03a8. (12)\nInserting this into the expression for diag (\u03a8) and taking the trace gives\nTr\n( 1\nn n\u2211 i=1 i T i\n) = Tr ( \u03a8 ( WW T + \u03a8 )\u22121 \u03a8 ) \u2264 Tr (( WW T + \u03a8 )\u22121) Tr (\u03a8) 2 . (13)\nTherefore for \u03a8 WW T the error is quadratic in \u03a8. WUT = WSW T = UW T follows from fixed point equation U = WS. Using this and Eq. (12), Eq. (11) is\n1\nn n\u2211 i=1 i T i \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8 = C \u2212 \u03a8 \u2212 W S W T . (14)\nUsing the trace norm (nuclear norm or Ky-Fan n-norm) on matrices, Eq. (13) states that the left hand side of Eq. (14) is quadratic in \u03a8 for \u03a8 WW T . The trace norm of a positive semi-definite matrix is its trace and bounds the Frobenius norm [23]. Thus, for \u03a8 WW T , the covariance is approximated up to a quadratic error in \u03a8 according to Eq. (9). The diagonal is exactly modeled.\nSince the minimization of the expected reconstruction error Tr (\u03a8) is based on \u00b5i, the quality of reconstruction depends on the correlation between \u00b5i and vi. We ensure maximal information in \u00b5i on vi by the I-projection (the minimal Kullback-Leibler distance) of the posterior onto the family of rectified and normalized Gaussian distributions."}, {"heading": "4 Experiments", "text": "RFNs vs. Other Unsupervised Methods. We assess the performance of rectified factor networks (RFNs) as unsupervised methods for data representation. We compare (1) RFN: rectified factor networks, (2) RFNn: RFNs without normalization, (3) DAE: denoising autoencoders with ReLUs, (4) RBM: restricted Boltzmann machines with Gaussian visible units, (5) FAsp: factor analysis with Jeffrey\u2019s prior (p(z) \u221d 1/z) on the hidden units which is sparser than a Laplace prior, (6) FAlap: factor analysis with Laplace prior on the hidden units, (7) ICA: independent component analysis by FastICA [24], (8) SFA: sparse factor analysis with a Laplace prior on the parameters, (9) FA: standard factor analysis, (10) PCA: principal component analysis. The number of components are fixed to 50, 100 and 150 for each method. We generated nine different benchmark datasets (D1 to D9), where each dataset consists of 100 instances. Each instance has 100 samples and 100 features resulting in a 100\u00d7100 matrix. Into these matrices, biclusters are implanted [8]. A bicluster is a pattern of particular features which is found in particular samples like a pathway activated in some samples. An optimal representation will only code the biclusters that are present in a sample. The datasets have different noise levels and different bicluster sizes. Large biclusters have 20\u201330 samples and 20\u201330 features, while small biclusters 3\u20138 samples and 3\u20138 features. The pattern\u2019s signal strength in a particular sample was randomly chosen according to the Gaussian N (1, 1). Finally, to each matrix, zero-mean Gaussian background noise was added with standard deviation 1, 5, or 10. The datasets are characterized by Dx=(\u03c3, n1, n2) with background noise \u03c3, number of large biclusters n1, and the number of small biclusters n2: D1=(1,10,10), D2=(5,10,10), D3=(10,10,10), D4=(1,15,5), D5=(5,15,5), D6=(10,15,5), D7=(1,5,15), D8=(5,5,15), D9=(10,5,15). We evaluated the methods according to the (1) sparseness of the components, the (2) input reconstruction error from the code, and the (3) covariance reconstruction error for generative models. For RFNs sparseness is the percentage of the components that are exactly 0, while for others methods it is the percentage of components with an absolute value smaller than 0.01. The reconstruction error is the sum of the squared errors across samples. The covariance reconstruction error is the Frobenius norm of the difference between model and data covariance. See supplement for more details on the data and for information on hyperparameter selection for the different methods. Tab. 1 gives averaged results for models with 50 (undercomplete), 100 (complete) and 150 (overcomplete) coding units. Results are the mean of 900 instances consisting of 100 instances for each dataset D1 to D9. In the supplement, we separately tabulate the results for D1 to D9 and confirm them with different noise levels. FAlap did not yield sparse codes since the variational parameter did not push the\nabsolute representations below the threshold of 0.01. The variational approximation to the Laplacian is a Gaussian distribution [13]. RFNs had the sparsest code, the lowest reconstruction error, and the lowest covariance approximation error of all methods that yielded sparse representations (SP>10%).\nRFN Pretraining for Deep Nets. We assess the performance of rectified factor networks (RFNs) if used for pretraining of deep networks. Stacked RFNs are obtained by first training a single layer RFN and then passing on the resulting representation as input for training the next RFN. The deep network architectures use a RFN pretrained first layer (RFN-1) or stacks of 3 RFNs giving a 3- hidden layer network. The classification performance of deep networks with RFN pretrained layers was compared to (i) support vector machines, (ii) deep networks pretrained by stacking denoising autoencoders (SDAE), (iii) stacking regular autoencoders (SAE), (iv) restricted Boltzmann machines (RBM), and (v) stacking restricted Boltzmann machines (DBN). The benchmark datasets and results are taken from previous publications [25, 26, 27, 28] and contain: (i) MNIST (original MNIST), (ii) basic (a smaller subset of MNIST for training), (iii) bg-rand (MNIST with random noise background), (iv) bg-img (MNIST with random image background), (v) rect (discrimination between tall and wide rectangles), (vi) rect-img (discrimination between tall and wide rectangular images overlayed on random background images), (vii) convex (discrimination between convex and concave shapes), (viii) CIFAR-10 (60k color images in 10 classes), and (ix) NORB (29,160 stereo image pairs of 5 generic categories). For each dataset its size of training, validation and test set is given in the second column of Tab. 2. As preprocessing we only performed median centering. Model selection is based on the validation set performance [26]. The RFNs hyperparameters are (i) the number of units per layer from {1024, 2048, 4096} and (ii) the dropout rate from {0.0, 0.25, 0.5, 0.75}. The learning rate was fixed to its default value of \u03b7 = 0.01. For supervised fine-tuning with stochastic gradient descent, we selected the learning rate from {0.1, 0.01, 0.001},\nthe masking noise from {0.0, 0.25}, and the number of layers from {1, 3}. Fine-tuning was stopped based on the validation set performance, following [26]. The test error rates together with the 95% confidence interval (computed according to [26]) for deep network pretraining by RFNs and other methods are given in Tab. 2. Fig. 2 shows learned filters. The result of the best performing method is given in bold, as well as the result of those methods for which confidence intervals overlap. RFNs were only once significantly worse than the best method but still the second best. In six out of the nine experiments RFNs performed best, where in four cases it was significantly the best.\nRFNs in Drug Discovery. Using RFNs we analyzed gene expression datasets of two projects in the lead optimization phase of a big pharmaceutical company [29]. The first project aimed at finding novel antipsychotics that target PDE10A. The second project was an oncology study that focused on compounds inhibiting the FGF receptor. In both projects, the expression data was summarized by FARMS [30] and standardized. RFNs were trained with 500 hidden units, no masking noise, and a learning rate of \u03b7 = 0.01. The identified transcriptional modules are shown in Fig. 3. Panels A and B illustrate that RFNs found rare and small events in the input. In panel A only a few drugs are genotoxic (rare event) by downregulating the expression of a small number of tubulin genes (small event). The genotoxic effect stems from the formation of micronuclei (panel C and D) since the mitotic spindle apparatus is impaired. Also in panel B, RFN identified a rare and small event which is a transcriptional module that has a negative feedback to the MAPK signaling pathway. Rare events are unexpectedly inactive drugs (black dots), which do not inhibit the FGF receptor. Both findings were not detected by other unsupervised methods, while they were highly relevant and supported decision-making in both projects [29]."}, {"heading": "5 Conclusion", "text": "We have introduced rectified factor networks (RFNs) for constructing very sparse and non-linear input representations with many coding units in a generative framework. Like factor analysis, RFN learning explains the data variance by its model parameters. The RFN learning algorithm is a posterior regularization method which enforces non-negative and normalized posterior means. We have shown that RFN learning is a generalized alternating minimization method which can be proved to converge and to be correct. RFNs had the sparsest code, the lowest reconstruction error, and the lowest covariance approximation error of all methods that yielded sparse representations (SP>10%). RFNs have shown that they improve performance if used for pretraining of deep networks. In two pharmaceutical drug discovery studies, RFNs detected small and rare gene modules that were so far missed by other unsupervised methods. These gene modules were highly relevant and supported the decision-making in both studies. RFNs are geared to large datasets, sparse coding, and many representational units, therefore they have high potential as unsupervised deep learning techniques.\nAcknowledgment. The Tesla K40 used for this research was donated by the NVIDIA Corporation."}, {"heading": "Supplementary Material", "text": "S1 Introduction 5"}, {"heading": "S2 Rectified Factor Network (RFN) Algorithms 5", "text": ""}, {"heading": "S3 Convergence Proof for the RFN Learning Algorithm 9", "text": ""}, {"heading": "S4 Correctness Proofs for the RFN Learning Algorithms 11", "text": "S4.1 Diagonal Noise Covariance Update . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nS4.2 Full Noise Covariance Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14"}, {"heading": "S5 Maximum Likelihood Factor Analysis 15", "text": ""}, {"heading": "S6 The RFN Objective 18", "text": ""}, {"heading": "S7 Generalized Alternating Minimization 20", "text": ""}, {"heading": "S8 Gradient-based M-step 22", "text": "S8.1 Gradient Ascent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nS8.2 Newton Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nS8.2.1 Newton Update of the Loading Matrix . . . . . . . . . . . . . . . . . . . . 24\nS8.2.2 Newton Update of the Noise Covariance . . . . . . . . . . . . . . . . . . . 24"}, {"heading": "S9 Gradient-based E-Step 26", "text": "S9.1 Motivation for Rectifying and Normalization Constraints . . . . . . . . . . . . . . 26\nS9.2 The Full E-step Objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nS9.3 E-step for Mean with Rectifying Constraints . . . . . . . . . . . . . . . . . . . . . 28\nS9.3.1 The E-Step Minimization Problem . . . . . . . . . . . . . . . . . . . . . . 28\nS9.3.2 The Projection onto the Feasible Set . . . . . . . . . . . . . . . . . . . . . 29\nS9.4 E-step for Mean with Rectifying and Normalizing Constraints . . . . . . . . . . . 30\nS9.4.1 The E-Step Minimization Problem . . . . . . . . . . . . . . . . . . . . . . 30\nS9.4.2 The Projection onto the Feasible Set . . . . . . . . . . . . . . . . . . . . . 30\nS9.5 Gradient and Scaled Gradient Projection and Projected Newton . . . . . . . . . . . 33\nS9.5.1 Gradient Projection Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 33\nS9.5.2 Scaled Gradient Projection and Projected Newton Method . . . . . . . . . 34\nS9.5.3 Combined Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35"}, {"heading": "S10 Alternative Gaussian Prior 36", "text": ""}, {"heading": "S11 Hyperparameters Selected for Method Assessment 38", "text": "S12 Data Set I 39"}, {"heading": "S13 Data Set II 43", "text": "S14 RFN Pretraining for Convolution Nets 47"}, {"heading": "List of Theorems", "text": "1 Theorem (Euclidean Projection) . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n2 Theorem (RFN Convergence) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n3 Theorem (RFN Correctness) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n4 Theorem (RFN Convergence) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n5 Theorem (RFN Correctness: Diagonal Noise Covariance Update) . . . . . . . . . . 12\n6 Theorem (RFN Correctness: Full Noise Covariance Update) . . . . . . . . . . . . 14\n7 Theorem (GAM Convergence Theorem) . . . . . . . . . . . . . . . . . . . . . . . 20\n8 Theorem (Newton Update for Loading Matrix) . . . . . . . . . . . . . . . . . . . 24\n9 Theorem (Newton Update for Noise Covariance) . . . . . . . . . . . . . . . . . . 24\n10 Theorem (Newton Update for Inverse Noise Covariance) . . . . . . . . . . . . . . 25\n11 Theorem (Projection: Rectifying) . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n12 Theorem (Projection: Rectifying and Normalizing) . . . . . . . . . . . . . . . . . 31\n13 Theorem (Theorem 5.4.5 in [15]) . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n14 Theorem (Lemma 5.5.1 in [15]) . . . . . . . . . . . . . . . . . . . . . . . . . . . 35"}, {"heading": "List of Algorithms", "text": "1 Rectified Factor Network. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 S2 Rectified Factor Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 S3 Projection with E-Step Improvement . . . . . . . . . . . . . . . . . . . . . . . . . 7 S4 Simple Projection: Rectifying . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 S5 Simple Projection: Rectifying and Normalization . . . . . . . . . . . . . . . . . . 8 S6 Scaled Newton Projection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 S7 Scaled Projection With Reduced Matrix . . . . . . . . . . . . . . . . . . . . . . . 8 S8 Weight Decay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 S9 Dropout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nS1 Introduction\nThis supplement contains additional information complementing the main manuscript and is structured as follows: First, the rectified factor network (RFN) learning algorithm with E- and M-step updates, weight decay and dropout regularization is given in Section S2. In Section S3, we proof that the (RFN) learning algorithm is a \u201cgeneralized alternating minimization\u201d (GAM) algorithm and converges to a solution that maximizes the RFN objective. The correctness of the RFN algorithm is proofed in Section S4. Section S5 describes the maximum likelihood factor analysis model and the model selection by the EM-algorithm. The RFN objective, which has to be maximized, is described in Section S6. Next, RFN\u2019s GAM algorithm via gradient descent both in the M-step and the E-step is reported in the Section S7. The following sections S8 and S9 describe the gradient-based M- and E-step, respectively. In Section S10, we describe how the RFNs sparseness can be controlled by a Gaussian prior. Additional information on the selected hyperparameters of the benchmark methods is given in Section S11. The sections S12 and S13 describe the data generation of the benchmark datasets and report the results for three different experimental settings, namely for extracting 50 (undercomplete), 100 (complete) or 150 (overcomplete) factors / hidden units. Finally, Section S14 describes experiments, that we have done to assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [31, 32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-InNetwork (5C-NIN)."}, {"heading": "S2 Rectified Factor Network (RFN) Algorithms", "text": "Algorithm S2 is the rectified factor network (RFN) learning algorithm. The RFN algorithm calls Algorithm S3 to project the posterior probability pi onto the family of rectified and normalized variational distributions Qi. Algorithm S3 guarantees an improvement of the E-step objective O = 1 n \u2211n i=1DKL(Qi \u2016 pi). Projection Algorithm S3 relies on different projections, where a more complicated projection is tried if a simpler one failed to improve the E-step objective. If all following Newton-based gradient projection methods fail to decrease the E-step objective, then projection Algorithm S3 falls back to gradient projection methods. First the equality constraints are solved and inserted into the objective. Thereafter, the constraints are convex and gradient projection methods are applied. This approach is called \u201cgeneralized reduced gradient method\u201d [17], which is our preferred alternative method. If this method fails, then Rosen\u2019s gradient projection method [18] is used. Finally, the method of Haug and Arora [19] is used.\nFirst we consider Newton-based projection methods, which are used by Algorithm S3. Algorithm S5 performs a simple projection, which is the projected Newton method with learning rate set to one. This projection is very fast and ideally suited to be performed on GPUs for RFNs with many coding units. Algorithm S4 is the fast and simple projection without normalization even simpler than Algorithm S5. Algorithm S6 generalizes Algorithm S5 by introducing step sizes \u03bb and \u03b3. The step size \u03bb scales the gradient step, while \u03b3 scales the difference between to old projection and the new projection. For both \u03bb and \u03b3 annealing steps, that is, learning rate decay is used to find an appropriate update.\nIf these Newton-based update rules do not work, then Algorithm S7 is used. Algorithm S7 performs a scaled projection with a reduced Hessian matrixH instead of the full Hessian \u03a3\u22121p . For computing H an -active set is determined, which consists of all j with \u00b5j \u2264 . The reduced matrix H is the Hessian \u03a3\u22121p with -active columns and rows j fixed to unit vector ej .\nThe RFN algorithm allows regularization of the parameters W and \u03a8 (off-diagonal elements) by weight decay. Priors on the parameters can be introduced. If the priors are convex functions, then convergence of the RFN algorithm is still ensured. The weight decay Algorithm S8 can optionally be used after the M-step of Algorithm S2. Coding units can be regularized by dropout. However dropout is not covered by the convergence proof for the RFN algorithm. The dropout Algorithm S9 is applied during the projection between rectifying and normalization. Methods like mini-batches or other stochastic gradient methods are not covered by the convergence proof for the RFN algorithm. However, in [21] it is shown how to generalize the GAM convergence proof to mini-batches as it is shown for the incremental EM algorithm. Dropout and other stochastic gradient methods can be show to converge similar to mini-batches.\nAlgorithm S2 Rectified Factor Network"}, {"heading": "Input", "text": "for 1 \u2264 i \u2264 n: vi \u2208 Rm, number of coding units l Hyper-Parameters \u03a8min, Wmax, \u03b7\u03a8, \u03b7W , \u03c1, \u03c4 , 1 < \u03b7 \u2264 1 Initialization \u03a8 = \u03c4I ,W element-wise random in [\u2212\u03c1, \u03c1], C = 1n \u2211n k=1 vk v T k , STOP=false Main while STOP=false do\n\u2014\u2014E-step1\u2014\u2014 for all 1 \u2264 i \u2264 n do\n(\u00b5p)i = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi\nend for \u03a3 = ( I + W T\u03a8\u22121W )\u22121 \u2014\u2014Projection\u2014\u2014 perform projection of (\u00b5p)i onto the feasible set by Algorithm S3 giving \u00b5i \u2014\u2014E-step2\u2014\u2014 U = 1n \u2211n i=1 vi \u00b5 T i\nS = 1n \u2211n i=1 \u00b5i \u00b5 T i + \u03a3 \u2014\u2014M-step\u2014\u2014 \u03b7W = \u03b7\u03a8 = \u03b7 E = C \u2212 U W T \u2212 W U + W S W T \u2014\u2013W update\u2014\u2014 W = W + \u03b7W ( U S\u22121 \u2212 W\n) \u2014\u2013diagonal \u03a8 update\u2014\u2014 for all 1 \u2264 k \u2264 m do\n\u03a8kk = \u03a8kk + \u03b7\u03a8 (Ekk \u2212 \u03a8kk) end for \u2014\u2013full \u03a8 update\u2014\u2014 \u03a8 = \u03a8 + \u03b7\u03a8 (E \u2212\u03a8) \u2014\u2013bound parameters\u2014\u2014 W = median{\u2212Wmax , W , Wmax} \u03a8 = median{\u03a8min , \u03a8 , max{C}} if stopping criterion is met: STOP=true\nend while\nAlgorithm S3 Projection with E-Step Improvement"}, {"heading": "Goal", "text": "obtain \u00b5newi = \u00b5i that decrease the E-step objective Input \u03a3new = \u03a3p, \u03a3old = \u03a3oldp for 1 \u2264 i \u2264 n: (\u00b5p)i, \u00b5oldi , pi = N ((\u00b5p)i,\u03a3p) simple projection P (rectified or rectified & normalized), E-step objective: O = 1n \u2211n i=1DKL(Qi \u2016 pi)\n\u03b3min, \u03bbmin, \u03c1\u03b3 , \u03c1\u03bb, (for -active set) Main\n\u2014\u2013Simple Projection\u2014\u2014 perform Newton Projection by Algorithm S5 or Algorithm S4 \u2014\u2013Scaled Projection\u2014\u2014 if 0 \u2264 \u2206O then\nfollowing loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Newton Projection by Algorithm S6\nend while end if \u2014\u2013Scaled Projection With Reduced Matrix\u2014\u2014 if 0 \u2264 \u2206O then\ndetermine -active set as all j with \u00b5j \u2264 setH to \u03a3\u22121p with -active columns and rows j fixed to ej following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Projection With Reduced Matrix by Algorithm S7\nend while end if \u2014\u2013General Gradient Projection\u2014\u2014 while 0 \u2264 \u2206O do\nuse generalized reduced gradient [17] OR use Rosen\u2019s gradient projection [18] OR use method of Haug and Arora [19]\nend while\nAlgorithm S4 Simple Projection: Rectifying"}, {"heading": "Goal", "text": "for 1 \u2264 i \u2264 n: project (\u00b5p)i onto feasible set giving \u00b5i Input (\u00b5p)i Main for all 1 \u2264 j \u2264 l do \u00b5ij = max { 0, [(\u00b5p)i]j\n} end for\nAlgorithm S5 Simple Projection: Rectifying and Normalization"}, {"heading": "Goal", "text": "for 1 \u2264 i \u2264 n: project (\u00b5p)i onto feasible set giving \u00b5i Input for 1 \u2264 i \u2264 n: (\u00b5p)i Rectifier for all 1 \u2264 i \u2264 n do\nfor all 1 \u2264 j \u2264 l do \u00b5\u0302ij = max { 0, [(\u00b5p)i]j } end for\nend for Normalizer\nfor all 1 \u2264 i \u2264 n do if at least one \u00b5\u0302ij > 0 then\nfor all 1 \u2264 j \u2264 l do \u00b5ij =\n\u00b5\u0302ij\u221a 1 n \u2211n s=1 \u00b5\u0302 2 sj\nend for else\nfor all 1 \u2264 j \u2264 l do\n\u00b5ij =\n{ \u221a n for j = arg maxj\u0302{[(\u00b5p)i]j\u0302}\n0 otherwise end for\nend if end for\nAlgorithm S6 Scaled Newton Projection"}, {"heading": "Goal", "text": "perform a scaled Newton step with subsequent projection Input for 1 \u2264 i \u2264 n: (\u00b5p)i for 1 \u2264 i \u2264 n: \u00b5oldi simple projection P (rectified or rectified & normalized), \u03bb (gradient step size), \u03b3 (projection difference) Main d = P ( \u00b5oldi + \u03bb ((\u00b5p)i \u2212 \u00b5oldi )\n) \u00b5newi = P ( \u00b5oldi + \u03b3 ( d \u2212 \u00b5oldi ))\nAlgorithm S7 Scaled Projection With Reduced Matrix"}, {"heading": "Goal", "text": "perform a scaled projection step with reduced matrix Input for 1 \u2264 i \u2264 n: (\u00b5p)i for 1 \u2264 i \u2264 n: \u00b5oldi simple projection P (rectified or rectified & normalized), \u03bb, \u03b3,H , \u03a3\u22121p Main d = P ( \u00b5oldi + \u03bbH \u22121 \u03a3\u22121p ((\u00b5p)i \u2212 \u00b5oldi ) )\n\u00b5newi = P ( \u00b5oldi + \u03b3 ( d \u2212 \u00b5oldi ))\nAlgorithm S8 Weight Decay"}, {"heading": "Input", "text": "ParametersW Weight decay factors \u03b3G (Gaussian) and \u03b3L (Laplacian) Gaussian W = W \u2212 \u03b3GW Laplacian W\u0302 = median{\u2212\u03b3L , W , \u03b3L} W = W \u2212 W\u0302\nAlgorithm S9 Dropout"}, {"heading": "Input", "text": "for 1 \u2264 i \u2264 n: \u00b5i dropout probability d Main for all 1 \u2264 i \u2264 n do\nfor all 1 \u2264 j \u2264 l do Pr(\u03b4 = 0) = d \u00b5ij = \u03b4 \u00b5ij\nend for end for"}, {"heading": "S3 Convergence Proof for the RFN Learning Algorithm", "text": "Theorem 4 (RFN Convergence). The rectified factor network (RFN) learning algorithm given in Algorithm S2 is a \u201cgeneralized alternating minimization\u201d (GAM) algorithm and converges to a solution that maximizes the objective F .\nProof. The factor analysis EM algorithm is given by Eq. (81) and Eq. (82) in Section S5. Algorithm S2 is the factor analysis EM algorithm with modified the E-step and the M-step. The E-step is modified by constraining the variational distribution Q to non-negative means and by normalizing its means across the samples. The M-step is modified to a Newton direction gradient step.\nLike EM factor analysis, Algorithm S2 aims at maximizing the negative free energy F , which is\nF = 1 n n\u2211 i=1 log p(vi) \u2212 1 n n\u2211 i=1 DKL(Q(hi) \u2016 p(hi | vi)) (15)\n= 1\nn n\u2211 i=1 \u222b Q(hi) log p(vi) dhi \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi | vi) dhi\n= \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi,vi) dhi\n= \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi) dhi + 1 n n\u2211 i=1 \u222b Q(hi) log p(vi | hi) dhi\n= 1\nn n\u2211 i=1 \u222b Q(hi) log p(vi | hi) dhi \u2212 1 n n\u2211 i=1 DKL(Q(hi) \u2016 p(hi)) .\nDKL denotes the Kullback-Leibler (KL) divergence [34], which is larger than or equal to zero. Algorithm S2 decreases 1n \u2211n i=1DKL(Q(hi) \u2016 p(hi | vi)) (the E-step objective) in its E-step under constraints for non-negative means and normalization. The constraint optimization problem from\nSection S9.2 for the E-step is\nmin Q(hi)\n1\nn n\u2211 i=1 DKL(Q(hi) \u2016 p(hi | vi)) (16)\ns.t. \u2200i : \u00b5i \u2265 0 ,\n\u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 .\nThe M-step of Algorithm S2 aims at decreasing\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi) log (p(vi | hi)) dhi . (17)\nAlgorithm S2 performs one gradient descent step in the Newton direction to decrease E , while EM factor analysis minimizes E . From the modification of the E-step and the M-step follows that Algorithm S2 is a Generalized Alternating Minimization (GAM) algorithm according to [21]. GAM is an EM algorithm that increases F in the E-step and increases F in the M-step (see also Section S7). The most important requirements for the convergence of the GAM algorithm according to Theorem 7 (Proposition 5 in [21]) are the increase of the objective F in both the E-step and the M-step. Therefore we first show these two decreases before showing that all requirements of convergence Theorem 7 are met.\nAlgorithm S2 ensures to decrease the M-step objective. The M-step objective E is convex in W and \u03a8\u22121 according to Theorem 8 and Theorem 10. The update with \u03b7W = \u03b7\u03a8 = \u03b7 = 1 leads to the minimum of E according to Theorem 8 and Theorem 10. The convexity of E guarantees that each update with 0 < \u03b7W = \u03b7\u03a8 = \u03b7 \u2264 1 decreases the M-step objective E , except the current W and \u03a8\u22121 are already the minimizers.\nAlgorithm S2 ensures to decrease the E-step objective. The E-step decrease of Algorithm S2 is performed by Algorithm S3. According to Theorem 14 the scaled projection with reduced matrix ensures a decrease of the E-step objective for rectifying constraints (convex feasible set). According to Theorem 13 also gradient projection methods ensure a decrease of the E-step objective for rectifying constraints. For rectifying constraints and normalization, the feasible set is not convex because of the equality constraints. To optimize such problems, the generalized reduced gradient method [17] solves each equality constraint for one variable and inserts it into the objective. For our problem Eq. (160) gives the solution and Eq. (161) the resulting convex constraints. Now scaled projection and gradient projection methods can be applied. For rectifying and normalizing constraints, also Rosen\u2019s [18] and Haug & Arora\u2019s [19] gradient projection method ensures a decrease of the E-step objective since they can be applied to non-convex problems.\nWe show that the requirements as given in Section S7 for GAM convergence according to Theorem 7 (Proposition 5 in [21]) are fulfilled:\n1. the learning rules, that is, the E-step and the M-step, are closed maps \u2212\u2192 ensured by continuous and continuous differentiable maps,\n2. the parameter set is compact \u2212\u2192 ensured by bounding \u03a8 andW ,\n3. the family of variational distributions is compact (often described by the feasible set of parameters of the variational distributions) \u2212\u2192 ensured by continuous and continuous differentiable functions for the constraints and by the bounds on the variational parameters \u00b5 and \u03a3 determined by bounds on the parameters and the data,\n4. the support of the density models does not depend on the parameter \u2212\u2192 ensured by Gaussian models with full-rank covariance matrix,\n5. the density models are continuous in the parameters \u2212\u2192 ensured by Gaussian models\n6. the E-step has a unique maximizer \u2212\u2192 ensured by the convex, continuous, and continuous differentiable function that is minimized [35, 36] together with compact feasible set for the\nvariational parameters, the maximum may be local for non-convex feasible sets stemming from normalization,\n7. the E-step increases the objective if not at the maximizer \u2212\u2192 ensured as shown above,\n8. the M-step has a unique maximizer (this is not required) \u2212\u2192 ensured by minimizing a convex, continuous and continuous differentiable function in the model parameter and a convex feasible set, the maximum is a global maximum,\n9. the M-step increases the objective if not at the maximizer \u2212\u2192 ensured as shown above.\nSince this Proposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, updates of the RFN algorithm are viewed as point-to-set mappings [22]. Therefore the numerical precision, the choice of the methods in the E-step, and GPU implementations are covered by the proof. That the M-step has a unique maximizer is not required to proof Theorem 4 by Theorem 7. However we obtain an alternative proof by exchanging the variational distributionQ and the parameters (W ,\u03a8), that is, exchanging the E-step and the M-step. A theorem analog to Theorem 7 but with E-step and M-step conditions exchanged can be derived from Zangwill\u2019s generalized convergence theorem [22].\nThe resulting model from the GAM procedure is at a local maximum of the objective given the model family and the family of variational distributions. The solution minimizes the KL-distance between the family of full variational distributions and full model family. \u201cFull\u201d means that both the observed and the hidden variables are taken into account, where for the variational distributions the probability of the observations is set to 1. The desired family is defined as the set of all probability distributions that assign probability one to the observation. In our case the family of variational distributions is not the desired family since some distributions are excluded by the constraints. Therefore the solution of the GAM optimization does not guarantee stationary points in likelihood [21]. This means that we do not maximize the likelihood but minimize\n\u2212 F \u2248 DKL(Q(h,v) \u2016 p(h,v)) + c (18)\naccording to Eq. (87), where c is a constant independent of Q and independent of the model parameters."}, {"heading": "S4 Correctness Proofs for the RFN Learning Algorithms", "text": "The RFN algorithm is correct if it has a low reconstruction error and explains the data covariance matrix by its parameters like factor analysis. We show in Theorem 5 and Theorem 6 that the RFN algorithm\n1. minimizes the reconstruction error given \u00b5i and \u03a3 (the error is quadratic in \u03a8);\n2. explains the covariance matrix by its parameters W and \u03a8 plus an estimate of the second moment of the coding units S.\nSince the minimization of the reconstruction error is based on \u00b5i, the quality of reconstruction and covariance explanation depends on the correlation between \u00b5i and vi. The larger the correlation between \u00b5i and vi, the lower the reconstruction error and the better the explanation of the data covariance. We ensure maximal information in \u00b5i on vi by the I-projection (the minimal KullbackLeibler distance) of the posterior onto the family of rectified and normalized Gaussian distributions.\nThe reconstruction error for given mean values \u00b5i is\n1\nn n\u2211 i=1 \u2016 i\u201622 , (19)\nwhere\ni = vi \u2212 W \u00b5i . (20)\nThe reconstruction error for using the whole variational distribution Q(hi) instead of its means is \u03a8. Below we will derive Eq. (31), which is\n\u03a8 = diag\n( 1\nn n\u2211 i=1 i T i + W \u03a3W T\n) . (21)\nTherefore \u03a8 is the reconstruction error for given mean values plus the varianceW\u03a3W T introduced by the hidden variables."}, {"heading": "S4.1 Diagonal Noise Covariance Update", "text": "Theorem 5 (RFN Correctness: Diagonal Noise Covariance Update). The fixed point W minimizes Tr (\u03a8) given \u00b5i and \u03a3 by ridge regression with\nTr (\u03a8) = 1\nn n\u2211 i=1 \u2016 i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F , (22)\nwhere we used the error\ni = vi \u2212 W \u00b5i (23)\nThe model explains the data covariance matrix by\nC = \u03a8 + W S W T (24)\nup to an error, which is quadratic in \u03a8 for \u03a8 WW T . The reconstruction error\n1\nn n\u2211 i=1 \u2016 i\u201622 (25)\nis quadratic in \u03a8 for \u03a8 WW T .\nProof. The fixed point equation for theW update is\n\u2206W = U S\u22121 \u2212 W = 0 \u21d2 W = U S\u22121 . (26)\nUsing the definition of U and S, the fixed point equation Eq. (26) gives\nW =\n( 1\nn n\u2211 i=1 vi \u00b5 T i\n) ( 1\nn n\u2211 i=1 \u00b5i \u00b5 T i + \u03a3\n)\u22121 (27)\nTherefore W is a ridge regression estimate, also called generalized Tikhonov regularization estimate, which minimizes\n1\nn n\u2211 i=1 \u2016vi \u2212 W \u00b5i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F (28)\n= 1\nn n\u2211 i=1 \u2016 i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F\n= 1\nn n\u2211 i=1 Ti i + Tr ( W \u03a31/2 \u03a31/2W T ) = Tr ( 1\nn n\u2211 i=1 i T i + W \u03a3W T\n) ,\nwhere we used the reconstruction error\ni = vi \u2212 W \u00b5i . (29)\nWe obtain with this definition of the error\n1\nn n\u2211 i=1 i T i + W \u03a3W T (30)\n= 1\nn n\u2211 i=1 vi v T i \u2212 1 n n\u2211 i=1 vi \u00b5 T i W T \u2212 1 n n\u2211 i=1 W \u00b5i v T i\n+ 1\nn n\u2211 i=1 W \u00b5i \u00b5 T i W T + W \u03a3W T\n= C \u2212 U W T \u2212 W UT + W S W T .\nTherefore from the fixed point equation for \u03a8 with the diagonal update rule follows\n\u03a8 = diag\n( 1\nn n\u2211 i=1 i T i + W \u03a3W T\n) , (31)\nwhere \u201cdiag \u201d projects a matrix to a diagonal matrix. From this follows that\nTr (\u03a8) = Tr\n( 1\nn n\u2211 i=1 i T i + W \u03a3W T\n) . (32)\nConsequently, the fixed pointW minimizes Tr (\u03a8) given \u00b5i and \u03a3. After convergence of the algorithm \u03a3 = ( I +W T\u03a8\u22121W )\u22121 holds. The Woodbury identity (matrix inversion lemma) states( W W T + \u03a8 )\u22121 = \u03a8\u22121 \u2212 \u03a8\u22121W ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 (33)\nfrom which follows by multiplying the equation from right and left by \u03a8 that W \u03a3W T = W ( I + W T\u03a8\u22121W )\u22121 W T (34)\n= \u03a8 \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8\nInserting this equation Eq. (34) into Eq. (31) gives\n\u03a8 = diag\n( 1\nn n\u2211 i=1 i T i + \u03a8 \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8\n) (35)\n= \u03a8 + diag\n( 1\nn n\u2211 i=1 i T i \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8\n) .\nTherefore we have\ndiag\n( 1\nn n\u2211 i=1 i T i \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8\n) = 0 . (36)\nIt follows that\nTr\n( 1\nn n\u2211 i=1 i T i\n) = Tr ( \u03a8 ( W W T + \u03a8 )\u22121 \u03a8 )\n\u2264 Tr (( W W T + \u03a8 )\u22121) Tr (\u03a8) 2 . (37)\nThe inequality uses the fact that for positive definite matrices A and B inequality Tr(AB) \u2264 Tr(A)Tr(B) holds [37]. Thus, for \u03a8 WW T the error Tr ( 1 n \u2211n i=1 i T i ) = 1n \u2211n i=1 T i i is quadratic in \u03a8.\nMultiplying the fixed point equation Eq. (26) by S gives U = WS. Therefore we have:\nW UT = W S W T = U W T . (38)\nInserting Eq. (34) into the first line of Eq. (30) and Eq. (38) for simplifying the last line of Eq. (30) gives\n1\nn n\u2211 i=1 i T i \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8 = C \u2212 \u03a8 \u2212 W S W T . (39)\nUsing the trace norm (nuclear norm or Ky-Fan n-norm) on matrices, Eq. (37) states that the left hand side is quadratic in \u03a8 for \u03a8 WW T . The trace norm of a positive semi-definite matrix is its trace and bounds the Frobenius norm [23]. Furthermore, Eq. (36) states that the left hand side of this equation has zero diagonal entries. Therfore it follows that\nC = \u03a8 + W S W T (40)\nholds except an error, which is quadratic in \u03a8 for \u03a8 WW T . The diagonal is exactly modeled according to Eq. (36).\nTherefore the model corresponding to the fixed point explains the empirical matrix of second moments C by a noise part \u03a8 and a signal part WSW T . Like factor analysis the data variance is explained by the model via the parameters \u03a8 (noise) andW (signal)."}, {"heading": "S4.2 Full Noise Covariance Update", "text": "Theorem 6 (RFN Correctness: Full Noise Covariance Update). The fixed point W minimizes Tr (\u03a8) given \u00b5i and \u03a3 by ridge regression with\nTr (\u03a8) = 1\nn n\u2211 i=1 \u2016 i\u201622 + \u2225\u2225\u2225W \u03a31/2\u2225\u2225\u22252 F , (41)\nwhere we used the error\ni = vi \u2212 W \u00b5i (42) The model explains the data covariance matrix by\nC = \u03a8 + W S W T . (43)\nThe reconstruction error\n1\nn n\u2211 i=1 \u2016 i\u201622 (44)\nis quadratic in \u03a8 for \u03a8 WW T .\nProof. The first part follows from previous Theorem 5. The fixed point equation for the \u03a8 update is\n\u03a8 = C \u2212 U W T \u2212 W UT + W S W T , (45) using Eq. (38) this leads to\nC = \u03a8 + W S W T . (46)\nFrom Eq. (30) follows for the fixed point of \u03a8 with the full update rule:\n\u03a8 = 1\nn n\u2211 i=1 i T i + W \u03a3W T . (47)\nInserting Eq. (34) into Eq. (47) gives\n\u03a8 = 1\nn n\u2211 i=1 i T i + \u03a8 \u2212 \u03a8 ( W W T + \u03a8 )\u22121 \u03a8 , (48)\nfrom which follows\n1\nn n\u2211 i=1 i T i = \u03a8 ( W W T + \u03a8 )\u22121 \u03a8 . (49)\nThus, the error Tr (\n1 n \u2211n i=1 i T i ) = 1n \u2211n i=1 T i i is quadratic in \u03a8, for \u03a8 WW T ."}, {"heading": "S5 Maximum Likelihood Factor Analysis", "text": "We are given the data {v} = {v1, . . . ,vn} which is assumed to be centered. Centering can be done by subtracting the mean \u00b5 from the data. The model is\nv = Wh + , (50) where\nh \u223c N (0, I) and \u223c N (0,\u03a8) . (51) The model includes the observations v \u2208 Rm, the noise \u2208 Rm, the factors h \u2208 Rl, the factor loading matrix W \u2208 Rm\u00d7l, and the noise covariance matrix \u03a8 \u2208 Rm\u00d7m. Typically we assume that \u03a8 is a diagonal matrix to explain data covariance by signal and not by noise. The data variance is explained through a signal part Wh and through a noise part . The parameters of the model are W and \u03a8. From the model assumption it follows that if h is given, then only the noise is a random variable and we have\nv | h \u223c N (Wh,\u03a8) . (52)\nWe want to derive the likelihood of the data under the model, that is, the likelihood that the model has produced the data. Let E denote the expectation of the data including the prior distribution of the factors and the noise distribution. We obtain for the first two moments and the variance:\nE(v) = E(Wh + ) = WE(h) + E( ) = 0 , (53) E ( v vT ) = E ( (Wh + )(Wh + )T ) =\nWE ( h hT ) W T + WE (h) E ( T )\n+ E ( ) E ( hT ) W T + E ( T ) =\nW W T + \u03a8 var(v) = E ( v vT ) \u2212 (E(v))2 = W W T + \u03a8 . (54)\nThe observations are Gaussian distributed since their distribution is the product of two Gaussian densities divided by a normalizing constant. Therefore, the marginal distribution for v is\nv \u223c N ( 0 , WW T + \u03a8 ) . (55)\nThe log-likelihood log \u220fn i=1 p(vi) of the data {v} under the model (W ,\u03a8) is\nlog n\u220f i=1 p(vi) = log n\u220f i=1 (2\u03c0) \u2212m/2 \u2223\u2223WW T + \u03a8\u2223\u2223\u22121/2 (56)\nexp ( \u22121\n2\n( vTi ( WW T + \u03a8 )\u22121 vi )) = \u2212 n m\n2 log (2\u03c0)\u2212 n 2 log \u2223\u2223WW T + \u03a8\u2223\u2223\n\u2212 1 2 n\u2211 i=1 vTi ( WW T + \u03a8 )\u22121 vi ,\nwhere |.| denotes the absolute value of the determinant of a matrix. To maximize the likelihood is difficult since a closed form for the maximum does not exists. Therefore, typically the expectation maximization (EM) algorithm is used to maximize the likelihood. For the EM algorithm a variational distribution Q is required which estimates the factors given the observations.\nWe consider a single data vector vi. The posterior is also Gaussian with mean (\u00b5p)i and covariance matrix \u03a3p:\nhi | vi \u223c N ((\u00b5p)i,\u03a3p) (57) (\u00b5p)i = W T ( W W T + \u03a8 )\u22121 vi\n\u03a3p = I \u2212 W T ( W W T + \u03a8 )\u22121 W ,\nwhere we used the fact that\na \u223c N (\u00b5a,\u03a3aa) , u \u223c N (\u00b5u,\u03a3uu) , (58) \u03a3ua = Cov(u,a) and \u03a3au = Cov(a,u) :\na | u \u223c N ( \u00b5a + \u03a3au\u03a3 \u22121 uu (u \u2212 \u00b5u) , \u03a3aa \u2212 \u03a3au\u03a3\u22121uu\u03a3ua ) and\nE(hv) = W E(h hT ) = W . (59)\nThe EM algorithm sets Q to the posterior distribution for data vector vi:\nQi(hi) = p (hi | vi;W ,\u03a8) = N ((\u00b5p)i,\u03a3p) , (60) therefore we obtain for standared EM\n\u00b5i = (\u00b5q)i = (\u00b5p)i (61) \u03a3 = \u03a3q = \u03a3p . (62)\nThe matrix inversion lemma (Woodbury identiy) can be used to compute \u00b5i and \u03a3:( W W T + \u03a8 )\u22121 = \u03a8\u22121 \u2212 \u03a8\u22121W ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 . (63)\nUsing this identity, the mean and the covariance matrix can be computed as: \u00b5i = W T ( W W T + \u03a8 )\u22121 vi = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi , (64)\n\u03a3 = I \u2212 W T ( W W T + \u03a8 )\u22121 W = ( I + W T\u03a8\u22121W )\u22121 .\nThe EM algorithm maximizes a lower bound F on the log-likelihood: F = log p(vi) \u2212 DKL(Q(hi) \u2016 p(hi | vi)) (65)\n= \u222b Q(hi) log p(vi) dhi \u2212 \u222b Q(hi) log Q(hi)\np(hi | vi) dhi = \u2212 \u222b Q(hi) log Q(hi)\np(hi,vi) dhi = \u2212 \u222b Q(hi) log Q(hi)\np(hi) dhi +\n\u222b Q(hi) log p(vi | hi) dhi\n= \u222b Q(hi) log p(vi | hi) dhi \u2212 DKL(Q(hi) \u2016 p(hi)) .\nDKL denotes the Kullback-Leibler (KL) divergence [34] which is larger than zero.\nF is the EM objective which has to be maximized in order to maximize the likelihood. The Estep maximizes F with respect to the variational distribution Q, therefore the E-step minimizes DKL(Q(hi) \u2016 p(hi | vi)). After the standard unconstrained E-step, the variational distribution is equal to the posterior, i.e. Q(hi) = p(hi | vi). Therefore the KL divergence\nDKL(Q(hi) \u2016 p(hi | vi)) = 0 (66) is zero, thus F is equal to the log-likelihood log p(vi) (F = log p(vi)). The M-step maximizes F with respect to the parameters (W ,\u03a8), therefore the M-step maximizes \u222b Q(hi) log p(vi | hi)dhi.\nWe next consider again all n samples {v} = {v1, . . . ,vn}. The expected reconstruction error E for these n data samples is\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi) log (p(vi | hi)) dhi = 1 n n\u2211 i=1 EQ (log (p(vi | hi))) (67)\nand objective to maximize becomes\nF = \u2212 E \u2212 1 n n\u2211 i=1 DKL(Q(hi) \u2016 p(hi)) . (68)\nThe M-step requires to minimize E :\nE = m 2 log (2\u03c0) + 1 2 log |\u03a8| + (69)\n1\n2 n n\u2211 i=1 EQ ( (vi \u2212 Whi)T \u03a8\u22121 (vi \u2212 Whi) ) = m\n2 log (2\u03c0) +\n1 2 log |\u03a8| + (70)\n1\n2 n n\u2211 i=1 EQ ( vTi \u03a8 \u22121vi \u2212 2 vTi \u03a8\u22121Whi + hTi W T\u03a8\u22121Whi )\n= m\n2 log (2\u03c0) +\n1 2 log |\u03a8| + 1 2 n n\u2211 i=1 vTi \u03a8 \u22121vi (71)\n\u2212 Tr ( \u03a8\u22121W\nn\u2211 i=1 EQ (hi)v T i\n) + 1\n2 Tr\n( W T\u03a8\u22121W\nn\u2211 i=1 EQ ( hih T i\n))\n= m\n2 log (2\u03c0) +\n1 2 log |\u03a8| + 1 2 Tr\n( \u03a8\u22121 1\nn n\u2211 i=1 viv T i\n) (72)\n\u2212 Tr ( \u03a8\u22121W 1\nn n\u2211 i=1 \u00b5iv T i\n) + 1\n2 Tr\n( W T\u03a8\u22121W 1\nn n\u2211 i=1 ( \u03a3 + \u00b5i\u00b5 T i\n))\n= 1\n2\n( m log (2\u03c0) + log |\u03a8| + Tr ( \u03a8\u22121C ) (73)\n\u2212 2 Tr ( \u03a8\u22121WUT ) + Tr ( W T\u03a8\u22121WS )) ,\nwhere Tr gives the trace of a matrix.\nThe derivatives with respect to the parameters are set to zero for the optimal parameters:\n\u2207W E = \u2212 1\n2 n n\u2211 i=1 \u03a8\u22121 W EQ ( hi h T i ) + 1 2 n n\u2211 i=1 \u03a8\u22121 vi E T Q (hi) = 0 (74)\nand\n\u2207\u03a8E = \u2212 1\n2 \u03a8\u22121 + (75)\n1\n2 n n\u2211 i=1 EQ ( \u03a8\u22121 (vi \u2212 Whi) (vi \u2212 Whi)T \u03a8\u22121 ) = 0 .\nSolving above equations gives:\nW new =\n( 1\nn n\u2211 i=1 vi E T hi|vi (hi)\n) ( 1\nn n\u2211 i=1 EQ ( hi h T i\n))\u22121 (76)\nand\n\u03a8new = 1\nn n\u2211 i=1 EQ ( (vi \u2212 W newhi) (vi \u2212 W newhi)T ) = (77)\n1\nn n\u2211 i=1 vi v T i \u2212 1 n n\u2211 i=1 viE T Q (hi) (W new) T \u2212\n1\nn n\u2211 i=1 W newEQ (hi)v T i + W new 1 n n\u2211 i=1 EQ ( hi h T i ) (W new) T .\nWe obtain the following EM updates:\nE-step: (78) \u00b5i = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi ,\n\u03a3 = ( I + W T\u03a8\u22121W )\u22121 ,\nEQ (hi) = \u00b5i EQ ( hi h T i ) = \u00b5i \u00b5 T i + \u03a3\nM-step: (79)\nW new =\n( 1\nn n\u2211 i=1 vi E T hi|vi (hi)\n) ( 1\nn n\u2211 i=1 EQ ( hi h T i\n))\u22121\n\u03a8new = 1\nn n\u2211 i=1 vi v T i \u2212 1 n n\u2211 i=1 viE T Q (hi) (W new) T \u2212 (80)\n1\nn n\u2211 i=1 W newEQ (hi)v T i + W new 1 n n\u2211 i=1 EQ ( hi h T i ) (W new) T .\nThe EM algorithms can be reformulated as:\nE-step: (81) \u00b5i = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi ,\n\u03a3 = ( I + W T\u03a8\u22121W )\u22121 ,\nEQ (hi) = \u00b5i EQ ( hi h T i ) = \u00b5i \u00b5 T i + \u03a3\nM-step: (82)\nC = 1\nn n\u2211 i=1 vi v T i\nU = 1\nn n\u2211 i=1 vi E T Q (hi) (83)\nS = 1\nn n\u2211 i=1 EQ ( hi h T i ) (84)\nW new = U S\u22121 (85)\n\u03a8new = C \u2212 UW T \u2212 WUT + WSW T . (86)"}, {"heading": "S6 The RFN Objective", "text": "Our goal is to find a sparse, non-negative representation of the input which extracts structure from the input. A sparse, non-negative representation is desired to code only events or objects that have caused the input. We assume that only few events or objects caused the input, therefore, we aim at sparseness. Furthermore, we do not want to code the degree of absence of events or objects. As the vast majority of events and objects is supposed to be absent, to code for their degree of absence would introduce a high level of random fluctuations.\nWe aim at extracting structures from the input, therefore generative models are use as they explicitly model input structures. For example factor analysis models the covariance structure of the data. However a generative model cannot enforce sparse, non-negative representation of the input. The\ninput representation of a generative model is the posterior\u2019s mean, median, or mode. Generative models with rectified priors (zero probability for negative values) lead to rectified posteriors. However these posteriors do not have sparse means (they must be positive), that is, they do not yield sparse codes [10]. For example, rectified factor analysis, which rectifies Gaussian priors and selects models using a variational Bayesian learning procedure, does not yield posteriors with sparse means [38, 11]. A generative model with hidden units h and data v is defined by its prior p(h) and its likelihood p(v | h). The posterior p(h | v) supplies the input representation of a model by the posterior\u2019s mean, median, or mode. However, the posterior depends on the data v, therefore sparseness and non-negativity of its means cannot be guaranteed independent of the data. Problem at coding the input by generative models is the data-dependency of the posterior means.\nTherefore we use the posterior regularization method (posterior constraint method) [12, 39, 40]. The posterior regularization framework separates model characteristics from data dependent characteristics like the likelihood or posterior constraints. Posterior regularization incorporates datadependent characteristics as constraints on model posteriors given the observed data, which are difficult to encode via model parameters by Bayesian priors.\nA generative model with prior p(h) and likelihood p(v | h) has the full model distribution p(h,v) = p(v | h)p(h). It can be written as p(h,v) = p(h | v)p(v), where p(h | v) is the model posterior of the hidden variables and p(v) is the evidence, that is, the likelihood of the data to be produced by the model. The model family and its parametrization determines which structures are extracted from the data. Typically the model parameters enter the likelihood p(v | h) and are adjusted to the observed data. For the posterior regularization method, a familyQ of allowed posterior distributions is introduced. Q is defined by the expectations of constraint features. In our case the posterior means have to be non-negative. DistributionsQ \u2208 Q are called variational distributions (see later for using this term). The full variational distribution is Q(h,v) = Q(h | v)pv(v) with Q(h | v) \u2208 Q. The distribution pv(v) is the unknown distribution of observations as determined by the world or the data generation process. This distribution is approximated by samples drawn from the world, namely the training samples. p(h,v) contains all model assumptions like the structures used to model the data, while Q(h,v) contains all data dependent characteristics including data dependent constraints on the posterior.\nThe goal is to achieve Q(h,v) = p(h,v), to obtain (1) a desired structure that is extracted from the data and (2) desired code properties. However in general it is to achieve this identity, therefore we want to minimize the distance between these distributions. We use the Kullback-Leibler (KL) divergence [34] DKL to measure the distance between these distributions. Therefore our objective is DKL(Q(h,v) \u2016 p(h,v)). Minimizing this KL divergence (1) extracts the desired structure from the data by increasing the likelihood, that is, pv(v) \u2248 p(v), and (2) enforces desired code properties by Q(h | v) \u2248 p(h | v). Thus, the code derived from Q(h | v) has the desired properties and t extracts the desired input data structures.\nWe now approximate the KL divergence by approximating the expectation over pv(v) by the empirical mean of samples {v} = {v1, . . . ,vn} drawn from pv(v):\nDKL(Q(h,v) \u2016 p(h,v)) = \u222b Q(h,v) log Q(h,v)\np(h,v) dh dv (87)\n= \u222b V pv(v) \u222b H Q(h | v) log Q(h,v) p(h,v) dh dv\n\u2248 1 n n\u2211 i=1 \u222b H Q(h | vi) log Q(h,vi) p(h,vi) dh\n= 1\nn n\u2211 i=1 \u222b H Q(h | vi) log Q(h | vi) p(h,vi) dh + 1 n n\u2211 i=1 log pv(vi) .\nThe last term 1n \u2211n i=1 log pv(vi) neither depends on Q nor on the model, therefore we will neglect it. In the following, we often abbreviate Q(h | vi) by Q(hi) or write Q(hi | vi), since the hidden variable is based on the observation vi. Similarly we often write p(hi,vi) instead of p(h,vi) and even more often p(hi | vi) instead of p(h | vi).\nWe obtain the objective F (to be maximized) of the posterior constraint method [12, 39, 40]:\nF = 1 n n\u2211 i=1 log p(vi) \u2212 1 n n\u2211 i=1 DKL(Q(hi) \u2016 p(hi | vi)) (88)\n= 1\nn n\u2211 i=1 \u222b Q(hi) log p(vi) dhi \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi | vi) dhi\n= \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi,vi) dhi\nnonumber = \u2212 1 n n\u2211 i=1 \u222b Q(hi) log Q(hi) p(hi) dhi + 1 n n\u2211 i=1 \u222b Q(hi) log p(vi | hi) dhi (89)\n= 1\nn n\u2211 i=1 \u222b Q(hi) log p(vi | hi) dhi \u2212 1 n n\u2211 i=1 DKL(Q(hi) \u2016 p(hi)) .\nThe first line is the negative objective of the posterior constraint method while the third line is the negative Eq. (87) without the term 1n \u2211n i=1 log pv(vi).\nF is the objective in our framework which has to be maximized. MaximizingF (1) increases the model likelihood 1n \u2211n i=1 log p(vi), (2) finds a proper input representation by small DKL(Q(hi) \u2016 p(hi | vi)). Thus, the data representation (1) extracts structures from the data as imposed by the generative model while (2) ensuring desired code properties via Q \u2208 Q. In the variational framework,Q is the variational distribution andF is called the negative free energy [41]. This physical term is used since variational methods were introduced for quantum physics by Richard Feynman [42]. The hidden variables can be considered as the fictive causes or explanations of environmental fluctuations [43].\nIf p(h | v) \u2208 Q, then Q(h | v) = p(h | v) and we obtain the classical EM algorithm. The EM algorithm maximizes the lower bound F on the log-likelihood as seen at the first line of Eq. (88) and ensures in its E-step Q(h | v) = p(h | v)."}, {"heading": "S7 Generalized Alternating Minimization", "text": "Instead of the EM algorithm we use the Generalized Alternating Minimization (GAM) algorithm [21] to allow for gradient descent both in the M-step and the E-step. The representation of an input by a generative model is the vector of the mean values of the posterior, that is, the most likely hidden variables that produced the observed data. We have to modify the E-step to enforce variational distributions which lead to sparse codes via zero values of the components of its mean vector. Sparse codes, that is, many components of the mean vector are zero, are obtained by enforcing non-negative means. This rectification is analog to rectified linear units for neural networks, which have enabled sparse codes for neural networks. Therefore the variational distributions are restricted to stem from a family with non-negative constraints on the means. To impose constraints on the posterior is known as the posterior constraint method [12, 39, 40]. The posterior constraint method maximizes the objective both in the E-step and the M-step. The posterior constraint method is computationally infeasible for our approach, since we assume a large number of hidden units. For models with many hidden units, the maximization in the E-step would take too much time. The posterior constraint method does not support fast implementations on GPUs and stochastic gradients, which we want to allow in order to use mini-batches and dropout regularization.\nTherefore we perform only one gradient descent step both in the E-step and in the M-step. Unfortunately, the convergence proofs of the EM algorithm are no longer valid. However we show that our algorithm is a generalized alternating minimization (GAM) method. Gunawardana and Byrne showed that the GAM converges [21] (see also [44]).\nThe following GAM convergence Theorem 7 is Proposition 5 in [21] and proves the convergence of the GAM algorithm to a solution that minimizes \u2212F .\nTheorem 7 (GAM Convergence Theorem). Let the point-to-set map FB the composition B \u25e6 F of point-to-set maps F : D \u00d7\u0398 \u2192 D \u00d7\u0398 and B : D \u00d7\u0398 \u2192 D \u00d7\u0398. Suppose that the point-to-set maps F and B are defined so that\n(1) F and B are closed on D\u2032 \u00d7\u0398\n(2) F (D\u2032 \u00d7\u0398) \u2286 D \u00d7\u0398 and B(D\u2032 \u00d7\u0398) \u2286 D \u00d7\u0398\nSuppose also that F is such that all (Q\u2032X ,\u03b8 \u2032) \u2208 F(QX ,\u03b8) have \u03b8\u2032 = \u03b8 and satisfy\n(GAM.F): DKL(Q\u2032X \u2016 pX;\u03b8) \u2264 DKL(QX \u2016 pX;\u03b8)\nwith equality only if\n(EQ.F): QX = arg min Q\u2032\u2032X\u2208D\nDKL(Q \u2032\u2032 X \u2016 pX;\u03b8) ,\nwith QX being the unique minimizer. Suppose also that the point-to-set map B is such that all (Q\u2032X ,\u03b8 \u2032) \u2208 B(QX ,\u03b8) have Q\u2032X = QX and satisfy\n(GAM.B): DKL(QX \u2016 pX;\u03b8\u2032) \u2264 DKL(QX \u2016 pX;\u03b8)\nwith equality only if\n(EQ.B): \u03b8 \u2208 arg min \u03be\u2208\u0398 DKL(QX \u2016 pX;\u03be) ."}, {"heading": "Then,", "text": "(1) the point-to-set map FB is closed on D\u2032 \u00d7\u0398\n(2) FB(D\u2032 \u00d7\u0398) \u2286 D \u00d7\u0398\nand FB satisfies the GAM and EQ conditions of the GAM convergence theorem, that is, Theorem 3 in [21].\nProof. See Proposition 5 in [21].\nThe point-to-set mappings allow extended E-step and M-steps without unique iterates. Therefore, Theorem 7 holds for different implementations, different hardware, different precisions of the algorithm under consideration.\nFor a GAM method to converge, we have to ensure that the objective increases in both the E-step and the M-step. Q is from a constrained family of variational distributions, while the posterior and the full distribution (observation and hidden units) are both derived from a model family. The model family is a parametrized family. For our models (i) the support of the density models does not depend on the parameter and (ii) the density models are continuous in their parameters. GAM convergence requires both (i) and (ii). Furthermore, both the E-step and the M-step must have unique maximizers and they increase the objective if they are not at a maximum point.\nThe learning rules, that is, the E-step and the M-step are closed maps as they are continuous functions. The objective for the E-step is strict convex in all its parameters for the variational distributions, simultaneously [35, 36]. It is quadratic for the mean vectors on which constraints are imposed. The objective for the M-step is convex in both parameters W and \u03a8\u22121 (we sometimes estimate \u03a8 instead of \u03a8\u22121). The objective is quadratic in the loading matrix W . For rectifying only, we guarantee unique global maximizers by convex and compact sets for both the family of desired distributions and the set of possible parameters. For this convex optimization problem with one global maximum. For rectifying and normalizing, the family of desired distributions is not convex due to equality constraints introduced by the normalization. However we can guarantee local unique maximizers.\nSummary of the requirements for GAM convergence Theorem 7:\n1. the learning rules, that is, the E-step and the M-step, are closed maps, 2. the parameter set is compact,\n3. the family of variational distributions is compact (often described by the feasible set of parameters of the variational distributions),\n4. the support of the density models does not depend on the parameter,\n5. the density models are continuous in the parameters,\n6. the E-step has a unique maximizer,\n7. the E-step increases the objective if not at the maximizer,\n8. the M-step has a unique maximizer (not required by Theorem 7),\n9. the M-step increases the objective if not at the maximizer.\nThe resulting model from the GAM procedure is at a local maximum of the objective given the model family and the family of variational distributions. The solution minimizes the KL-distance between the family of full variational distributions and full model family. \u201cFull\u201d means that both the observed and the hidden variables are taken into account, where for the variational distributions the probability of the observations is set to 1. The desired family is defined as the set of all probability distributions that assign probability one to the observation. In our case the family of variational distributions is not the desired family since some distributions are excluded by the constraints. Therefore the solution of the GAM optimization does not guarantee stationary points in likelihood [21]. This means that we do not maximize the likelihood but minimize the KL-distance between variational distributions and model."}, {"heading": "S8 Gradient-based M-step", "text": ""}, {"heading": "S8.1 Gradient Ascent", "text": "The gradients in the M-step are:\n\u2207W E = 1\n2 n n\u2211 i=1 \u03a8\u22121 vi E T Q (hi) \u2212 1 2 n n\u2211 i=1 \u03a8\u22121 W EQ ( hi h T i ) and\n\u2207\u03a8E = \u2212 1\n2 \u03a8\u22121 +\n1\n2 n n\u2211 i=1 EQ ( \u03a8\u22121 (vi \u2212 Whi) (vi \u2212 Whi)T \u03a8\u22121 ) . (90)\nAlternatively, we can estimate \u03a8\u22121 which leads to the derivatives:\n\u2207\u03a8\u22121E = 1 2 \u03a8 \u2212 1 2 n n\u2211 i=1 EQ ( (vi \u2212 Whi) (vi \u2212 Whi)T ) . (91)\nScaling the gradients leads to:\n2 \u2207W E = \u03a8\u22121 1\nn n\u2211 i=1 vi E T Q (hi) \u2212 \u03a8\u22121 W 1 n n\u2211 i=1 EQ ( hi h T i ) (92)\nand\n2 \u2207\u03a8E = (93) \u2212 \u03a8\u22121 + \u03a8\u22121 ( 1\nn n\u2211 i=1 vi v T i \u2212 1 n n\u2211 i=1 vi E T Q (hi) W T\n\u2212 1 n n\u2211 i=1 W EQ (hi) v T i + W 1 n n\u2211 i=1 EQ ( hi h T i ) W T\n) \u03a8\u22121 .\nor 2 \u2207\u03a8\u22121E = (94)\n\u03a8 \u2212\n( 1\nn n\u2211 i=1 vi v T i \u2212 1 n n\u2211 i=1 vi E T Q (hi) W T\n\u2212 1 n n\u2211 i=1 W EQ (hi) v T i + W 1 n n\u2211 i=1 EQ ( hi h T i ) W T\n) .\nOnly the sums\nU = 1\nn n\u2211 i=1 viE T Q (hi) (95)\nand\nS = 1\nn n\u2211 i=1 EQ ( hi h T i ) (96)\nmust be computed for both gradients.\nC = 1\nn n\u2211 i=1 vi v T i (97)\nis the estimated covariance matrix (matrix of second moments for zero mean).\nThe generalized EM algorithm update rules are:\nC = 1\nn n\u2211 i=1 vi v T i (98)\nE-step: \u00b5i = W T ( W W T + \u03a8 )\u22121 vi = ( I + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 vi ,\n\u03a3 = I \u2212 W T ( W W T + \u03a8 )\u22121 W = ( I + W T\u03a8\u22121W )\u22121 ,\nEQ (hi) = \u00b5i EQ ( hi h T i ) = \u00b5i \u00b5 T i + \u03a3\nU = 1\nn n\u2211 i=1 viE T Q (hi)\nS = 1\nn n\u2211 i=1 EQ ( hi h T i ) M-step: (99)\n\u2206W = \u03a8\u22121 U \u2212 \u03a8\u22121 W S \u2206\u03a8 = \u2212\u03a8\u22121 + \u03a8\u22121 ( C \u2212 U W T \u2212 W U + W S W T ) \u03a8\u22121 ."}, {"heading": "S8.2 Newton Update", "text": "Instead of gradient ascent, we now consider a Newton update step. The Newton update for finding the roots of \u2202f\u2202v is vn+1 = vn \u2212 \u03b7H\u22121 \u2207vf(vn) , (100) where \u03b7 is a small step size andH is the Hessian of f with respect to v evaluated at vn. We denote the update direction by\n\u2206v = \u2212H\u22121 \u2207vf(vn) . (101)"}, {"heading": "S8.2.1 Newton Update of the Loading Matrix", "text": "Theorem 8 (Newton Update for Loading Matrix). The M-step objective E is quadratic in W , thus convex inW . The Newton update direction forW in the M-step is\n\u2206W = U S\u22121 \u2212 W . (102)\nProof. The M-step objective is the expected reconstruction error E , which is according to Eq. (69)\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi) log (p(vi | hi)) dhi = 1 2 ( m log (2\u03c0) + log |\u03a8| (103)\n+ Tr ( \u03a8\u22121C ) \u2212 2 Tr ( \u03a8\u22121WUT ) + Tr ( W T\u03a8\u22121WS ) ) ,\nwhere Tr gives the trace of a matrix. This is a quadratic function inW , as stated in the theorem.\nThe HessianHW of (2E) with respect toW as a vector is:\nHW = \u2202vec (2\u2207W E) \u2202vec(W )T = \u2202vec\n( \u2212\u03a8\u22121 U + \u03a8\u22121 W S ) \u2202vec(W )T\n(104)\n= S \u2297 \u03a8\u22121 , where \u2297 is the Kronecker product of matrices. HW is positive definite, thus the problem is convex inW . The inverse ofHW is\nH\u22121W = S \u22121 \u2297 \u03a8 . (105)\nFor the product of the inverse Hessian with the gradient we have: H\u22121W vec ( \u2212\u03a8\u22121 U + \u03a8\u22121 W S ) = vec ( \u03a8 ( \u2212\u03a8\u22121 U + \u03a8\u22121 W S ) S\u22121 ) (106)\n= vec ( \u2212 U S\u22121 + W ) .\nIf we apply a Newton update, then the update direction forW in the M-step is\n\u2206W = U S\u22121 \u2212 W . (107)\nThis is the exact EM update if the step-size \u03b7 is 1. Since the objective is a quadratic function inW , one Newton update would lead to the exact solution."}, {"heading": "S8.2.2 Newton Update of the Noise Covariance", "text": "We define the expected approximation error by\nE = C \u2212 U W T \u2212 W U + W S W T (108)\n= 1\nn n\u2211 i=1 EQ ( (vi \u2212 Whi) (vi \u2212 Whi)T ) ."}, {"heading": "\u03a8 as parameter.", "text": "Theorem 9 (Newton Update for Noise Covariance). The Newton update direction for \u03a8 as parameter in the M-step is\n\u2206\u03a8 = E \u2212 \u03a8 . (109)"}, {"heading": "An update with \u2206\u03a8 (\u03b7 = 1) leads to the minimum of the M-step objective E .", "text": "Proof. The M-step objective is the expected reconstruction error E , which is according to Eq. (69)\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi) log (p(vi | hi)) dhi = 1 2 ( m log (2\u03c0) + log |\u03a8| (110)\n+ Tr ( \u03a8\u22121C ) \u2212 2 Tr ( \u03a8\u22121WUT ) + Tr ( W T\u03a8\u22121WS ) ) ,\nwhere Tr gives the trace of a matrix.\nSince\n2 \u2207\u03a8E = \u03a8\u22121 \u2212 \u03a8\u22121E\u03a8\u22121 , (111)\nis\n\u03a8 = E (112)\nthe minimum of E with respect to \u03a8. Therefore an update with \u2206\u03a8 = E\u2212\u03a8 leads to the minimum. The HessianH\u03a8 of (2E) with respect to \u03a8 as a vector is:\nH\u03a8 = \u2202vec (2\u2207\u03a8E) \u2202vec(\u03a8)T = \u2202vec\n( \u03a8\u22121 \u2212 \u03a8\u22121E\u03a8\u22121 ) \u2202vec(\u03a8)T\n(113)\n= \u2212\u03a8\u22121 \u2297 \u03a8\u22121 + \u03a8\u22121 \u2297 ( \u03a8\u22121E\u03a8\u22121 ) + ( \u03a8\u22121E\u03a8\u22121 ) \u2297 \u03a8\u22121 .\nThe expected approximation error E is a sample estimate for \u03a8, therefore we have \u03a8 \u2248 E. The Hessian may not be positive definite for some values of E, like for small values of E. In order to guarantee a positive definite Hessian, more precisely an approximation to it, for minmization, we set\nE = \u03a8 (114)\nand obtain\nH\u03a8 = \u03a8 \u22121 \u2297 \u03a8\u22121 . (115)\nWe derive an approximate Newton update that is very close to the Newton update.\nThe inverse of the approximatedH\u03a8 is\nH\u22121\u03a8 = \u03a8 \u2297 \u03a8 . (116)\nFor the product of the inverse Hessian with the gradient we have: H\u22121\u03a8 vec ( \u03a8\u22121 \u2212 \u03a8\u22121E\u03a8\u22121 ) = vec ( \u03a8 ( \u03a8\u22121 \u2212 \u03a8\u22121E\u03a8\u22121 ) \u03a8 )\n(117)\n= vec (\u03a8 \u2212 E) .\nIf we apply a Newton update, then the update direction for \u03a8 in the M-step is\n\u2206\u03a8 = E \u2212 \u03a8 . (118)\nThis is the exact EM update if the step-size \u03b7 is 1."}, {"heading": "\u03a8\u22121 as parameter.", "text": "Theorem 10 (Newton Update for Inverse Noise Covariance). The M-step objective E is convex in \u03a8\u22121. The Newton update direction for \u03a8\u22121 as parameter in the M-step is\n\u2206\u03a8\u22121 = \u03a8\u22121 \u2212 \u03a8\u22121 E \u03a8\u22121 . (119)"}, {"heading": "A first order approximation of this Newton direction for \u03a8 in the M-step is", "text": "\u2206\u03a8 = E \u2212 \u03a8 . (120)"}, {"heading": "An update with \u2206\u03a8 (\u03b7 = 1) leads to the minimum of the M-step objective E .", "text": "Proof. The M-step objective is the expected reconstruction error E , which is according to Eq. (69)\nE = \u2212 1 n n\u2211 i=1 \u222b Rl Q(hi) log (p(vi | hi)) dhi = 1 2 ( m log (2\u03c0) + log |\u03a8| (121)\n+ Tr ( \u03a8\u22121C ) \u2212 2 Tr ( \u03a8\u22121WUT ) + Tr ( W T\u03a8\u22121WS ) ) ,\nwhere Tr gives the trace of a matrix.\nSince\n2 \u2207\u03a8\u22121E = \u2212\u03a8 + E (122)\nis\n\u03a8 = E (123)\nthe minimum of E with respect to \u03a8\u22121. Therefore an update with \u2206\u03a8 = E \u2212 \u03a8 leads to the minimum.\nThe HessianH\u03a8\u22121 of (2E) with respect to \u03a8\u22121 as a vector is:\nH\u03a8\u22121 = \u2202vec (2\u2207\u03a8\u22121E) \u2202vec(\u03a8\u22121)T = \u2202vec (\u2212\u03a8 + E) \u2202vec(\u03a8\u22121)T = \u03a8 \u2297 \u03a8 . (124)\nSince the Hessian is positive definite, the E-step objective E is convex in \u03a8\u22121, which is the first statement of the theorem.\nThe inverse ofH\u03a8\u22121 is\nH\u22121\u03a8\u22121 = \u03a8 \u22121 \u2297 \u03a8\u22121 . (125)\nFor the product of the inverse Hessian with the gradient we have: H\u22121\u03a8\u22121 vec (\u2212\u03a8 + E) = vec ( \u03a8\u22121 (\u2212\u03a8 + E) \u03a8\u22121 ) (126)\n= vec ( \u2212\u03a8\u22121 + \u03a8\u22121 E \u03a8\u22121 ) .\nIf we apply a Newton update, then the update direction for \u03a8\u22121 in the M-step is\n\u2206\u03a8\u22121 = \u03a8\u22121 \u2212 \u03a8\u22121 E \u03a8\u22121 . (127)\nWe now can approximate the update for \u03a8 by the first terms of the Taylor expansion: \u03a8 + \u2206\u03a8 = ( \u03a8\u22121 + \u2206\u03a8\u22121 )\u22121 \u2248 \u03a8 \u2212 \u03a8 \u2206\u03a8\u22121 \u03a8 . (128) We obtain for the update of \u03a8\n\u2206\u03a8 = \u2212\u03a8 \u2206\u03a8\u22121 \u03a8 = E \u2212 \u03a8 . (129)\nThis is the exact EM update if the step-size \u03b7 is 1.\nThe Newton update derived from \u03a8\u22121 as parameter is the Newton update for \u03a8. Consequently, the Newton direction for both \u03a8 and \u03a8\u22121 is in the M-step\n\u2206\u03a8 = E \u2212 \u03a8 . (130)"}, {"heading": "S9 Gradient-based E-Step", "text": ""}, {"heading": "S9.1 Motivation for Rectifying and Normalization Constraints", "text": "The representation of data vector v by the model is the variational mean vector\u00b5q . In order to obtain sparse codes we want to have non-negative \u00b5q . We enforce non-negative mean values by constraints and optimize by projected Newton methods and by gradient projection methods. Non-negative constraints correspond to rectifying in the neural network field. Therefore we aim to construct sparse codes in analogy to the rectified linear units used for neural networks.\nWe constrain the variational distributions to the family of normal distributions with non-negative mean components. Consequently we introduce non-negative or rectifying constraints:\n\u00b5 \u2265 0 , (131)\nwhere the inequality \u201c\u2265\u201d holds component-wise.\nHowever generative models with many coding units face a problem. They tend to explain away small and rare signals by noise. For many coding units, model selection algorithms prefer models with coding units which do not have variation and, therefore, are removed from the model. Other coding units hardly contribute to explain the observations. The likelihood is larger if small and rare signals are explained by noise, than the likelihood if coding units are use to explain such signals. Coding units without variance are kept on their default values, where they have maximal contribution to the likelihood. If they are used for coding, they deviate from their maximal values for each sample. In accumulation these deviations decrease the likelihood more than it is increased by explaining small or rare signals. For our RFN models the problem can become severe, since we aim at models with up to several tens of thousands of coding units. To avoid the explaining away problem, we enforce the selected models to use all their coding units on an equal level. We do that by keeping the variation of each noise-free coding unit across the training set at one. Consequently, we introduce a normalization constraint for each coding unit 1 \u2264 j \u2264 l:\n1\nn n\u2211 i=1 \u00b52ij = 1 . (132)\nThis constraint means that the noise-free part of each coding unit has variance one across samples.\nWe will derive methods to increase the objective in the E-step both for only rectifying constraints and for rectifying and normalization constraints. These methods ensure to reduce the objective in the E-step to guarantee convergence via the GAM theory. The resulting model from the GAM procedure is at a local maximum of the objective given the model family and the family of variational distributions. The solution minimizes the KL-distance between the family of full variational distributions and full model family. \u201cFull\u201d means that both the observed and the hidden variables are taken into account."}, {"heading": "S9.2 The Full E-step Objective", "text": "The E-step maximizes F with respect to the variational distribution Q, therefore the E-step minimizes the Kullback-Leibler divergence (KL-divergence) [34] DKL(Q(h) \u2016 p(h | v)). The KLdivergence between Q and p is\nDKL(Q \u2016 p) = \u222b Q(h) log Q(h)\np(h | v) dh . (133)\nRectifying constraints introduce non-negative constraints. The minimization with respect to Q(hi) gives the constraint minimization problem:\nmin Q(hi)\n1\nn n\u2211 i=1 DKL(Q(hi) \u2016 p(hi | vi)) (134)\ns.t. \u2200i : \u00b5i \u2265 0 , where \u00b5i is the mean vector of Q(hi).\nRectifying and normalizing constraints introduce non-negative constraints and equality constraints. The minimization with respect to Q(hi) gives the constraint minimization problem:\nmin Q(hi)\n1\nn n\u2211 i=1 DKL(Q(hi) \u2016 p(hi | vi)) (135)\ns.t. \u2200i : \u00b5i \u2265 0 ,\n\u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 ,\nwhere \u00b5i is the mean vector of Q(hi).\nFirst we consider the families from which the model and from which the variational distributions stem. The posterior of the model with Gaussian prior p(h) is Gaussian (see Section S5):\np(h | v) \u223c (2\u03c0)\u2212 l2 |\u03a3p|\u2212 1 2 exp ( \u2212 1\n2 (h \u2212 \u00b5p)T \u03a3\u22121p (h \u2212 \u00b5p)\n) . (136)\nTo be as close as possible to the posterior distribution, we restrict Q to be from a Gaussian family:\nQ(h) \u223c (2\u03c0)\u2212 l2 |\u03a3q|\u2212 1 2 exp ( \u2212 1\n2 (h \u2212 \u00b5q)T \u03a3\u22121q (h \u2212 \u00b5q)\n) . (137)\nFor Gaussians, the Kullback-Leibler divergence between Q and p is\nDKL(Q \u2016 p) = (138) 1\n2\n{ Tr ( \u03a3\u22121p \u03a3q ) + (\u00b5p \u2212 \u00b5q)T \u03a3\u22121p (\u00b5p \u2212 \u00b5q) \u2212 l \u2212 ln\n|\u03a3q| |\u03a3p|\n} .\nThis Kullback-Leibler divergence is convex in the mean vector \u00b5q and the covariance matrix \u03a3q of Q, simultaneously [35, 36].\nWe now minimize Eq. (138) with respect to Q. For the moment we do not care about the constraints introduced by non-negativity and by normalization. Eq. (138) has a quadratic form in \u00b5q , where \u03a3q does not enter, and terms in \u03a3q , where \u00b5q does not enter. Therefore we can separately minimize for \u03a3q and for \u00b5q .\nFor the minimization with respect to \u03a3q , we require\n\u2202 \u2202\u03a3q Tr ( \u03a3\u22121p \u03a3q ) = \u03a3\u2212Tp (139)\nand \u2202\n\u2202\u03a3q ln |\u03a3q| = \u03a3\u2212Tq . (140)\nFor optimality the derivative of the objective DKL(Q \u2016 p) with respect to \u03a3q must be zero: \u2202\n\u2202\u03a3q DKL(Q \u2016 p) =\n1 2 \u03a3\u2212Tp \u2212 1 2 \u03a3\u2212Tq = 0 . (141)\nThis gives\n\u03a3 = \u03a3q = \u03a3p . (142)\nWe often drop the index q since for 1 \u2264 i \u2264 n all covariance matrices \u03a3q are equal to \u03a3p. The mean vector \u00b5q of Q is the solution of the minimization problem:\nmin \u00b5\n1 2 (\u00b5p \u2212 \u00b5)T \u03a3\u22121p (\u00b5p \u2212 \u00b5) (143)\nwhich is equivalent to\nmin \u00b5\n1 2 \u00b5T\u03a3\u22121p \u00b5 \u2212 \u00b5Tp \u03a3\u22121p \u00b5 . (144)\nThe derivative and the Hessian of this objective is:\n\u2202\n\u2202\u00b5 DKL(Q \u2016 p) = \u03a3\u22121p (\u00b5 \u2212 \u00b5p) , (145)\n\u22022\n\u22022\u00b5 DKL(Q \u2016 p) = \u03a3\u22121p . (146)"}, {"heading": "S9.3 E-step for Mean with Rectifying Constraints", "text": ""}, {"heading": "S9.3.1 The E-Step Minimization Problem", "text": "Rectifying is realized by non-negative constraints. The mean vector \u00b5q of Q is the solution of the minimization problem:\nmin \u00b5\n1 2 (\u00b5 \u2212 \u00b5p)T \u03a3\u22121p (\u00b5 \u2212 \u00b5p) (147)\ns.t. \u00b5 \u2265 0 .\nThis is a convex quadratic minimization problem with non-negativity constraints (convex feasible set).\nIf \u03bb is the Lagrange multiplier for the constraints, then the dual is\nmin \u03bb\n1 2 \u03bbT\u03a3p\u03bb + \u00b5 T p \u03bb (148)\ns.t. \u03bb \u2265 0 .\nThe Karush-Kuhn-Tucker conditions require for the optimal solution for each component 1 \u2264 j \u2264 l:\n\u03bbj \u00b5j = 0 . (149)\nFurther the derivative of the Lagrangian with respect to \u00b5 gives\n\u03a3\u22121p \u00b5 \u2212 \u03a3\u22121p \u00b5p \u2212 \u03bb = 0 (150)\nwhich can be written as\n\u00b5 \u2212 \u00b5p \u2212 \u03a3p \u03bb = 0 . (151)\nThis minimization problem cannot be solved directly. Therefore we perform a gradient projection or projected Newton step to decrease the objective."}, {"heading": "S9.3.2 The Projection onto the Feasible Set", "text": "To decrease the objective, we perform a gradient projection or a projected Newton step. We will base our algorithms on Euclidean least distance projections. If projected onto convex sets, these projections do not increase distances. The Euclidean projection onto the feasible set is denoted by P, that is, the map that takes \u00b5p to its nearest point \u00b5 (in the L2-norm) in the feasible set.\nFor rectifying constraints, the projection P (Euclidean least distance projection) of \u00b5p onto the convex feasible set is given by the solution of the convex optimization problem:\nmin \u00b5\n1 2 (\u00b5 \u2212 \u00b5p)T (\u00b5 \u2212 \u00b5p) (152)\ns.t. \u00b5 \u2265 0 .\nThe following Theorem 11 shows that update Eq. (153) is the projection P defined by optimization problem Eq. (152). Theorem 11 (Projection: Rectifying). The solution to optimization problem Eq. (152), which defines the Euclidean least distance projection, is\n\u00b5j = [P(\u00b5p)]j = { 0 for (\u00b5p)j \u2264 0 (\u00b5p)j for (\u00b5p)j > 0\n(153)\nProof. For the projection we have the minimization problem:\nmin \u00b5\n1 2 (\u00b5 \u2212 \u00b5p)T (\u00b5 \u2212 \u00b5p) (154)\ns.t. \u00b5 \u2265 0 .\nThe Lagrangian L with multiplier \u03bb \u2265 0 is\nL = 1\n2 (\u00b5 \u2212 \u00b5p)T (\u00b5 \u2212 \u00b5p) \u2212 \u03bbT \u00b5 . (155)\nThe derivative with respect to \u00b5 is\n\u2202L \u2202\u00b5 = \u00b5 \u2212 \u00b5p \u2212 \u03bb = 0 . (156)\nThe Karush-Kuhn-Tucker (KKT) conditions require for the optimal solution that for each constraint j:\n\u03bbj \u00b5j = 0 . (157)\nIf 0 < (\u00b5p)j then Eq. (156) requires 0 < \u00b5j because the Lagrangian \u03bbj is larger than or equal to zero: 0 \u2264 \u03bbj . From the KKT conditions Eq. (157) follows that \u03bbj = 0 and, therefore, 0 < \u00b5j = (\u00b5p)j . If (\u00b5p)j < 0 then 0 < \u00b5j \u2212 (\u00b5p)j , because the constraints of the primal problem require 0 \u2264 \u00b5j . From Eq. (156) follows that 0 < \u03bbj . From the KKT conditions Eq. (157) follows that (\u00b5p)j = 0 and 0 < \u03bbj = \u2212(\u00b5p)j . If (\u00b5p)j = 0, then Eq. (156) and the KKT conditions Eq. (157) lead to (\u00b5p)j = \u00b5j = \u03bbj = 0.\nTherefore the solution of problem Eq. (152) is\n\u00b5j = { (\u00b5p)j for (\u00b5p)j > 0 and \u03bbj = 0 0 for (\u00b5p)j \u2264 0 and \u03bbj = \u2212(\u00b5p)j . (158)\nThis finishes the proof."}, {"heading": "S9.4 E-step for Mean with Rectifying and Normalizing Constraints", "text": ""}, {"heading": "S9.4.1 The E-Step Minimization Problem", "text": "If we also consider normalizing constraints, then we have to minimize all KL-divergences simultaneously. The normalizing constraints connect the single optimization problems for each sample vi. For the E-step, we obtain the minimization problem:\nmin \u00b5i\n1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T \u03a3\u22121p (\u00b5i \u2212 (\u00b5p)i) (159)\ns.t. \u2200i : \u00b5i \u2265 0 , \u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 .\nThe \u201c\u2265\u201d-sign is meant component-wise. The l equality constraints lead to non-convex feasible sets. The solution to this optimization problem are the means vectors \u00b5i of Q(hi).\nGeneralized Reduced Gradient. The equality constraints can be solved for one variable which is then inserted into the objective. The equality constraint gives for each 1 \u2264 j \u2264 l:\n\u00b521j = n \u2212 n\u2211 i=2 \u00b52ij or \u00b51j = \u221a\u221a\u221a\u221an \u2212 n\u2211 i=2 \u00b52ij . (160)\nThese equations can be inserted into the objective and, thereby, we remove the variables \u00b51j . We have to ensure that the \u00b51j exist by\nn\u2211 i=2 \u00b52ij \u2264 n . (161)\nThese constraints define a convex set feasible set. To solve the each equality constraints for a variable and insert it into the objective is called generalized reduced gradient method [17]. For solving the reduced problem, we can use methods for constraint optimization were we now ensure a convex feasible set. These methods solve the original problem Eq. (159). We only require an improvement of the objective with a feasible value. For the reduced problem, we perform one step of a gradient projection method.\nGradient Projection Methods. Also for the original problem Eq. (159), gradient projection methods can be used. The gradient projection method has been generalized by Rosen to non-linear constraints [18] and was later improved by [19]. The gradient projection algorithm of Rosen works for non-convex feasible sets. The idea is to linearize the nonlinear constraints and solve the problem. Subsequently a restoration move brings the solution back to the constraint boundaries."}, {"heading": "S9.4.2 The Projection onto the Feasible Set", "text": "To decrease the objective, we perform a gradient projection, a projected Newton step, or a step of the generalized reduced method. We will base our algorithms on Euclidean least distance projections.\nIf projected onto convex sets, these projections do not increase distances. The Euclidean projection onto the feasible set is denoted by P, that is, the map that simultaneously takes {(\u00b5p)i} to the nearest points {\u00b5i} (in the L2-norm) in the feasible set. For rectifying and normalizing constraints the projection (Euclidean least distance projection) of {(\u00b5p)i} onto the non-convex feasible set leads to the optimization problem\nmin \u00b5i\n1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T (\u00b5i \u2212 (\u00b5p)i) (162)\ns.t. \u2200i : \u00b5i \u2265 0 ,\n\u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 .\nBy using (\u00b5i \u2212 (\u00b5p)i)T (\u00b5i \u2212 (\u00b5p)i) = \u00b5Ti \u00b5i\u22122\u00b5Ti (\u00b5p)i+(\u00b5p)Ti (\u00b5p)i, we see that the objective contains the sum \u2211 ij \u00b5 2 ij . The constraints enforce this sum to be constant. Therefore inserting the equality constraints into the objective, optimization problem Eq. (162) is equivalent to\nmin \u00b5i \u2212 1 n n\u2211 i=1 \u00b5Ti (\u00b5p)i (163)\ns.t. \u2200i : \u00b5i \u2265 0 ,\n\u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 .\nThe following Theorem 12 shows that updates Eq. (164) and Eq. (165) form the projection defined by optimization problem Eq. (162). Theorem 12 (Projection: Rectifying and Normalizing). If at least one (\u00b5p)ij is positive for 1 \u2264 j \u2264 l, then the solution to optimization problem Eq. (162), which defines the Euclidean least distance projection, is\n\u00b5\u0302ij = { 0 for (\u00b5p)ij \u2264 0 (\u00b5p)ij for (\u00b5p)ij > 0\n(164)\n\u00b5ij = [P((\u00b5p)i)]j = \u00b5\u0302ij\u221a\n1 n \u2211n i=1 \u00b5\u0302 2 ij .\nIf all (\u00b5p)ij are non-positive for 1 \u2264 j \u2264 l, then the optimization problem Eq. (162) has the solution\n\u00b5ij =\n{ \u221a n for j = arg maxj\u0302{(\u00b5p)ij\u0302}\n0 otherwise . (165)\nProof. In the following we show that updates Eq. (164) and Eq. (164) are the projection onto the feasible set. For the projection of {(\u00b5p)i} onto the feasible set, we have the minimization problem:\nmin \u00b5i\n1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T (\u00b5i \u2212 (\u00b5p)i) (166)\ns.t. \u2200i : \u00b5i \u2265 0 ,\n\u2200j : 1\nn n\u2211 i=1 \u00b52ij = 1 .\nThe feasible set is non-convex because of the quadratic equality constraint. The Lagrangian with multiplier \u03bb \u2265 0 is\nL = 1\nn n\u2211 i=1 (\u00b5i \u2212 (\u00b5p)i)T (\u00b5i \u2212 (\u00b5p)i) \u2212 n\u2211 i=1 \u03bbTi \u00b5i (167)\n+ \u2211 j \u03c4j\n( 1\nn n\u2211 i=1 \u00b52ij \u2212 1\n) .\nThe Karush-Kuhn-Tucker (KKT) conditions require for the optimal solution:\n\u03bbij \u00b5ij = 0 and \u03c4j\n( 1\nn n\u2211 i=1 \u00b52ij \u2212 1\n) = 0 . (168)\nThe derivative of L with respect to \u00b5ij is\n\u2202L\n\u2202\u00b5ij =\n2 n (\u00b5ij \u2212 (\u00b5p)ij) \u2212 \u03bbij + 2 n \u03c4j \u00b5ij = 0 . (169)\nWe multiply this equation by \u00b5ij and obtain:\n2 n (\u00b52ij \u2212 (\u00b5p)ij \u00b5ij) \u2212 \u03bbij \u00b5ij + 2 n \u03c4j \u00b5 2 ij = 0 . (170)\nThe KKT conditions give \u03bbij\u00b5ij = 0, therefore this term can be removed from the equation. Next we sum over i:\n2\nn n\u2211 i=1 ( \u00b52ij \u2212 (\u00b5p)ij \u00b5ij ) + 2 n n\u2211 i=1 \u03c4j \u00b5 2 ij = 0 . (171)\nUsing the equality constraint 1/n \u2211n i=1 \u00b5 2 ij = 1 and dividing by 2 and gives:\n1 \u2212 1 n n\u2211 i=1 (\u00b5p)ij \u00b5ij + \u03c4j = 0 . (172)\nSolving for \u03c4j leads to:\n\u03c4j = 1\nn n\u2211 i=1 (\u00b5p)ij \u00b5ij \u2212 1 . (173)\nWe insert \u03c4j into Eq. (169)\n\u2212 (\u00b5p)ij \u2212 n\n2 \u03bbij +\n( 1\nn n\u2211 s=1 (\u00b5p)sj \u00b5sj\n) \u00b5ij = 0 . (174)\nWe immediately see, that if \u00b5ij = 0 then (\u00b5p)ij = \u2212n2\u03bbij < 0. Therefore we can assume \u00b5ij > 0. Multiplying Eq. (174) with \u00b5ij and using the KKT conditions gives\n\u2212 (\u00b5p)ij \u00b5ij +\n( 1\nn n\u2211 s=1 (\u00b5p)sj \u00b5sj ) \u00b52ij = 0 . (175)\nTherefore (\u00b5p)ij\u00b5ij and 1n \u2211n s=1(\u00b5p)sj\u00b5sj have the same sign or \u00b5ij = 0. Since 0 \u2264 \u00b5ij , we de-\nduce that (\u00b5p)ij and 1n \u2211n s=1(\u00b5p)sj\u00b5sj have the same sign or \u00b5ij = 0. Since the sum is independent of i, all (\u00b5p)ij with \u00b5ij > 0 have the same sign for 1 \u2264 i \u2264 n. Solving Eq. (174) for \u00b5ij gives\n\u00b5ij = (\u00b5p)ij +\nn 2\u03bbij\n1 n \u2211n s=1(\u00b5p)sj \u00b5sj . (176)\nI. If all (\u00b5p)ij are non-positive for 1 \u2264 j \u2264 l, then the sum 1n \u2211n s=1(\u00b5p)sj\u00b5sj is negative. From the first order derivative of the Lagrangian in Eq. (169), we can compute the second order derivative\n\u22022L\n\u2202\u00b5ij\u2202\u00b5ij =\n2 n + 2 n \u03c4j = 2 n\u2211 i=1 (\u00b5p)ij \u00b5ij < 0 . (177)\nWe inserted the expression of Eq. (173) for \u03c4j . Since all mixed second order derivatives are zero, the (projected) Hessian of the Lagrangian is diagonal with negative entries. Therefore it is strict negative definite. Thus, the second order necessary conditions cannot be fulfilled. The minimum is a border point of the constraints.\nFor each j for which all (\u00b5p)ij are non-positive for 1 \u2264 j \u2264 l, optimization problem Eq. (163) defines a plane that has a normal vector in the positive orthant (hyperoctant). For such a j the corresponding equality constraint defines a hypersphere. Minimization means that the plane containing the solution is parallel to the original plane and should be as close to the origin as possible. If we move the plane parallel from the origin into the positive orthant, then the first intersection with the hypersphere is\n\u00b5ij =\n{ \u221a n for j = arg maxj\u0302{(\u00b5p)ij\u0302}\n0 otherwise . (178)\nThis is the solution for \u00b5ij with 1 \u2264 j \u2264 l to our minimization problem. II. If one (\u00b5p)ij is positive, then from Eq. (174) with this (\u00b5p)ij follows that 1n \u2211n s=1(\u00b5p)sj\u00b5sj is positive, otherwise Eq. (174) has only negative terms on the left hand side. In particular, the second order necessary conditions are always fulfilled as Eq. (177) is positive. For (\u00b5p)ij < 0 it follows from Eq. (174) that \u03bbij > 0 and from the KKT conditions that \u00b5ij = 0. For (\u00b5p)ij > 0 it follows from Eq. (174) that \u00b5ij > 0 and from the KKT conditions that \u03bbij = 0. Therefore we define:\n\u00b5\u0302ij = { 0 for (\u00b5p)ij \u2264 0 (\u00b5p)ij for (\u00b5p)ij > 0 , (179)\nWe write the solution as\n\u00b5ij = \u00b5\u0302ij\n1 n \u2211n s=1(\u00b5p)sj \u00b5sj = \u03b1j \u00b5\u0302ij . (180)\nWe now use the equality constraint:\n1\nn n\u2211 i=1 \u00b52ij = \u03b1 2 j 1 n n\u2211 i=1 \u00b5\u03022ij = 1 . (181)\nSolving for \u03b1j gives:\n\u03b1j = 1\u221a\n1 n \u2211n i=1 \u00b5\u0302 2 ij . (182)\nTherefore the solution is\n\u00b5ij = \u00b5\u0302ij\u221a\n1 n \u2211n i=1 \u00b5\u0302 2 ij . (183)\nThis finishes the proof."}, {"heading": "S9.5 Gradient and Scaled Gradient Projection and Projected Newton", "text": ""}, {"heading": "S9.5.1 Gradient Projection Algorithm", "text": "The projected gradient descent or gradient projection algorithm [14, 15] performs first a gradient step and then projects the result to the feasible set. The projection onto the feasible set is denoted by P, that is, the map that takes \u00b5 into the nearest point (in the L2-norm) in the feasible set to \u00b5. The feasible set must be convex, however later we will introduce gradient projection methods for non-convex feasible sets.\nThe gradient projection method is in our case \u00b5k+1 = P ( \u00b5k + \u03bb \u03a3 \u22121 p (\u00b5p \u2212 \u00b5k) ) . (184)\nThe Lipschitz constant for the gradient is \u2016\u03a3\u22121p \u2016s = emax(\u03a3\u22121p ), the largest eigenvalue of \u03a3\u22121p . The following statement is Theorem 5.4.5 in [15].\nTheorem 13 (Theorem 5.4.5 in [15]). The sufficient decrease condition\nDKL(Q(\u00b5k+1) \u2016 p) \u2212 DKL(Q(\u00b5k) \u2016 p) \u2264 \u2212\u03b1 \u03bb \u2016\u00b5k \u2212 \u00b5k+1\u20162 (185)\n(e.g. with \u03b1 = 10\u22124) holds for all \u03bb such that\n0 < \u03bb \u2264 2 (1\u2212 \u03b1) emax(\u03a3 \u22121 p ) . (186)\nProof. See [15].\nTheorem 13 guarantees that we can increase the objective by gradient projection in the E-step, except the case where we already reached the maximum.\nFor a fast upper bound on the maximal eigenvalue we use\nemax(\u03a3 \u22121 p ) \u2264 Tr(\u03a3\u22121p ) (187)\nand\nemax(\u03a3 \u22121 p ) \u2264 \u2016W \u20162s \u2016\u03a8\u22121\u2016s \u2212 1 , (188)\nwhere the latter follows from\n\u03a3\u22121p = I + W T\u03a8\u22121W . (189)\nImproved methods for finding an appropriate \u03bb by line search methods have been proposed [45, 46]. We use a search with \u03bb = \u03b2t with t = 0, 1, 2, . . . and \u03b2 = 2\u22121 or \u03b2 = 10\u22121.\nA special version of the gradient projection method is the generalized reduced method [17]. This method is able to solve our optimization problem with equality constraints. The gradient projection method has been generalized by Rosen to non-linear constraints [18]. The gradient projection algorithm of Rosen can also be used for a region which is not convex. The idea is to linearize the nonlinear constraints and solve the problem. Subsequently a restoration move brings the solution back to the constraint boundaries. Rosen\u2019s gradient projection method was improved by [19]. These methods guarantee that we can increase the objective in the E-step for non-convex feasible sets, except the case where we already reached the maximum. These algorithms for non-convex feasible sets will only give a local maximum. Also the GAM algorithm will only find a local maximum."}, {"heading": "S9.5.2 Scaled Gradient Projection and Projected Newton Method", "text": "Both the scaled gradient projection algorithm and the projected Newton method were proposed in [16]. We follow [15].\nThe idea is to use a Newton update instead of the a gradient update: \u00b5k+1 = P ( \u00b5k + \u03bbH \u22121 \u03a3\u22121p (\u00b5p \u2212 \u00b5k) ) . (190)\nH\u22121 can be an arbitrary strict positive definite matrix. If we setH\u22121 = \u03a3p, then we have a Newton update of the projected Newton method [16]. For \u03bb = 1 we obtain\n\u00b5k+1 = P (\u00b5p) . (191)\notherwise\n\u00b5k+1 = P ((1 \u2212 \u03bb)\u00b5k + \u03bb\u00b5p) . (192)\nThe search direction for the unconstrained problem can be rotated by H\u22121 to be orthogonal to the direction of decrease in the inactive directions for the constrained problem.\nTo escape this possible problem, an -active set is introduced which contains all j with \u00b5j \u2264 . All columns and rows of the Hessian having an index in the -active set are fixed to ej . After sorting the indices of the -active set together, they form a block which is the sub-identity matrix. H is set to the Hessian \u03a3p where the -active set columns and rows are replaced by unit vectors.\nThe following Theorem 14 is Lemma 5.5.1 in [15]. Theorem 14 states that the objective decreases using the reduced Hessian in the projected Newton method for convex feasible sets.\nTheorem 14 (Lemma 5.5.1 in [15]). The sufficient decrease condition\nDKL(Q(\u00b5k+1) \u2016 p) \u2212 DKL(Q(\u00b5k) \u2016 p) \u2264 \u2212 \u03b1 (\u00b5k \u2212 \u00b5p)T\u03a3\u22121p (\u00b5k \u2212 \u00b5k+1) (193)\nholds for all \u03bb smaller than a bound depending onH and .\nProof. See [15].\nIn practical applications, a proper \u03bb is found by line search. The projected Newton method uses \u03bb = 1 to set [16]:\n= \u2016\u00b5k \u2212 P (\u00b5p) \u2016 . (194)"}, {"heading": "S9.5.3 Combined Method", "text": "Following [47, 46] we use the following very general update rule, which includes the gradient projection algorithm, the scaled gradient projection algorithm, and the projected Newton method.\nWe use following update for the E-step: dk+1 = P ( \u00b5k + \u03bbH \u22121 \u03a3\u22121p (\u00b5p \u2212 \u00b5k) ) , (195)\n\u00b5k+1 = P (\u00b5k + \u03b3 (dk+1 \u2212 \u00b5k)) .\nWe have to project twice since the equality constraint produces a manifold in the parameter space.\nWe iterate this update until we see a decrease of the objective in the E-step:\nDKL(Qk+1 \u2016 p) \u2212 DKL(Qk \u2016 p) < 0 . (196)\nFor the constraints we have only to optimize the mean vector \u00b5 to ensure\nDKL(Q(\u00b5k+1) \u2016 p) \u2212 DKL(Q(\u00b5k) \u2016 p) < 0 . (197)\nEven\nDKL(Q(\u00b5k+1) \u2016 p) = DKL(Q(\u00b5k) \u2016 p) (198)\ncan be sufficient if minimizing \u03a3k+1 = \u03a3p ensures\nDKL(Qk+1 \u2016 p) < DKL(Qk \u2016 p) . (199)\nWe use following schedule:\n1. \u2022 H\u22121 = \u03a3p \u2022 \u03bb = 1 \u2022 \u03b3 = 1\nThat is\n\u00b5k+1 = P (\u00b5p) . (200)\n2. \u2022 H\u22121 = \u03a3p \u2022 \u03bb = 1 \u2022 \u03b3 \u2208 (0, 1]\nThat is\n\u00b5k+1 = P ((1 \u2212 \u03b3) \u00b5k + \u03b3 P (\u00b5p)) . (201)\n3. \u2022 H\u22121 = \u03a3p \u2022 \u03bb \u2208 (0, 1] \u2022 \u03b3 = 1\nThat is\n\u00b5k+1 = P ((1 \u2212 \u03bb)\u00b5k + \u03bb\u00b5p) . (202)\n4. \u2022 H\u22121 = \u03a3p\n\u2022 \u03bb \u2208 (0, 1] \u2022 \u03b3 =\u2208 (0, 1]\nThat is\n\u00b5k+1 = P ((1 \u2212 \u03b3) \u00b5k + \u03b3 P ((1 \u2212 \u03bb)\u00b5k + \u03bb\u00b5p)) . (203)\n5. \u2022 H\u22121 = R(\u03a3p) \u2022 \u03bb \u2208 (0, 1] \u2022 \u03b3 =\u2208 (0, 1]\nR(\u03a3p) denotes the reduced matrix (Hessian or a positive definite) according to the projected Newton method or the scaled gradient projection algorithm. For convex feasible sets we can guarantee at this level already an increase of the objective at the E-step.\n6. \u2022 H\u22121 = I \u2022 \u03bb \u2208 (0, 1] \u2022 \u03b3 =\u2208 (0, 1]\nThis is the gradient projection algorithm. In particular we include the generalized reduced method and Rosen\u2019s gradient projection method. At this step we guarantee an increase of the objective at the E-step even for non-convex feasible sets because we also use complex methods for constraint optimization.\nStep 5. ensures an improvement if only using rectifying constraints according to the theory of projected Newton methods [15]. Step 6. ensures an improvement if using both rectifying constraints and normalizing constraints, because we use known methods for constraint optimization. To set \u00b5k+1 = \u00b5k is sufficient to increase the objective at the E-step if \u03a3k+1 = \u03a3p decreases the KL divergence. However we will not always set \u00b5k+1 = \u00b5k to avoid accumulation points outside the solution set."}, {"heading": "S10 Alternative Gaussian Prior", "text": "We assume h is Gaussian with covarianceM and mean \u03be\nh \u223c N (\u03be,M) . (204)\nWe derive the posterior for this prior.\nThe likelihood is Gaussian since a affine transformation of a Gaussian random variable is again a Gaussian random variable and the convolution of two Gaussians is Gaussian, too. Thus, v = Wh+ is Gaussian if h and are both Gaussian. For the prior moments we have\nE(h) = \u03be , (205)\nE(hhT ) = M + \u03be \u03beT , (206) var(h) = M (207)\nand for the likelihood of v we obtain the moments\nE(v) = W\u03be , (208)\nE(vvT ) = W E(hhT )W T + \u03a8 (209)\n= W M W T + \u03a8 + W \u03be \u03beT W T ,\nvar(v) = W M W T + \u03a8 . (210)\nWe need some algebraic identities to derive the posterior. The Woodbury matrix identity gives\nM \u2212 M W T ( W M W T + \u03a8 )\u22121 W M = ( M\u22121 + W T\u03a8\u22121W )\u22121 . (211)\nMultiplying this equation from the left hand side with \u03a8\u22121W gives \u03a8\u22121 W ( M\u22121 + W T\u03a8\u22121W )\u22121 (212)\n= \u03a8\u22121 W M \u2212 \u03a8\u22121 W M W T ( W M W T + \u03a8 )\u22121 W M\n= \u03a8\u22121 ( W M W T + \u03a8 ) ( W M W T + \u03a8 )\u22121 W M \u2212\n\u03a8\u22121 W M W T ( W M W T + \u03a8 )\u22121 W M\n= ( \u03a8\u22121 ( W M W T + \u03a8 ) \u2212 \u03a8\u22121 W M W T ) ( W M W T + \u03a8 )\u22121 W M\n= ( W M W T + \u03a8 )\u22121 W M .\nIt follows that M W T ( W W T + \u03a8 )\u22121 a = ( M\u22121 + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 a . (213)\nThe posterior p(h | v) is derived from Gaussian conditioning because both the likelihood p(v) and the prior p(h) are Gaussian distributed. The conditional distribution p(a | b) of two random variables a and b that both follow a Gaussian distribution is a Gaussian:\na \u223c N (\u00b5a,\u03a3aa) , (214) b \u223c N (\u00b5b,\u03a3bb) , (215)\n\u03a3ba = Cov(b,a) , (216) \u03a3ab = Cov(a, b) , (217)\na | b \u223c N ( \u00b5a + \u03a3ab\u03a3 \u22121 bb (b \u2212 \u00b5b) , \u03a3aa \u2212 \u03a3ab\u03a3 \u22121 bb \u03a3ba ) . (218)\nTherefore we need the second moments between v and h:\nE(vhT ) = E(WhhT ) + E( hT ) = W (M + \u03be \u03beT ) . (219)\nThe covariances between v and h are\nCov(v,h) = E(vhT ) \u2212 E(v)E(hT ) (220) = W M + W\u03be \u03beT \u2212 W\u03be \u03beT = W M ,\nCov(h,v) = E(hvT ) \u2212 E(h)E(vT ) = M W T . (221)\nThus, the mean of p(h | v) is \u00b5h|v = \u03be + M W T (W M W T + \u03a8)\u22121(v \u2212 W\u03be) (222)\n= \u03be + ( M\u22121 + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 (v + W\u03be)\n= ( M\u22121 + W T\u03a8\u22121W )\u22121 ( M\u22121 + W T\u03a8\u22121W ) \u03be\n+ ( M\u22121 + W T\u03a8\u22121W )\u22121 W T\u03a8\u22121 (v \u2212 W\u03be)\n= ( M\u22121 + W T\u03a8\u22121W )\u22121( M\u22121 \u03be + W T\u03a8\u22121W \u03be + W T\u03a8\u22121 v \u2212 W T\u03a8\u22121W\u03be\n) = ( M\u22121 + W T\u03a8\u22121W )\u22121 ( W T\u03a8\u22121 v + M\u22121 \u03be ) .\nThe covariance matrix of p(h | v) is \u03a3h|v = M \u2212 M W T ( W M W T + \u03a8 )\u22121 W M (223)\n= ( M\u22121 + W T\u03a8\u22121W )\u22121 .\nIn particular, the variable \u03be may be used to enforce more sparseness by setting its components to negative values. Since the covariance matrix \u03a3h|v is positive semi-definite, we ensure that\n\u03beT ( M\u22121 + W T\u03a8\u22121W )\u22121 \u03be \u2265 0 . (224)\nIf \u03be = \u2212\u03c11 (1 is the vector with all components being one), then the largest absolute components of \u03a3h|v\u03be must be negative. Thus, \u03be = \u2212\u03c11 leads to sparser solutions."}, {"heading": "S11 Hyperparameters Selected for Method Assessment", "text": "The performance of rectified factor networks (RFNs) as unsupervised methods for data representation was compared with: (1) RFN: rectified factor networks, (2) RFNn: RFNs without normalization, (3) DAE: denoising autoencoders with rectified linear units, (4) RBM: restricted Boltzmann machines with Gaussian visible units and hidden binary units, (5) FAsp: factor analysis with Jeffrey\u2019s prior (p(z) \u221d 1/z) on the hidden units which is sparser than a Laplace prior, (6) FAlap: factor analysis with Laplace prior on the hidden units, (7) ICA: independent component analysis by FastICA [24], (8) SFA: sparse factor analysis with a Laplace prior on the parameters, (9) FA: standard factor analysis, (10) PCA: principal component analysis. The number of components are fixed to 50, 100, or 150 for each method. The used hyperparameters are listed in Tab. S3.\nTable S3: Hyperparameters of all methods that were used to assess the performance of rectified factor networks (RFNs) as unsupervised methods for data representation.\nMethod Used hyperparameters RFN {learning rate=0.1, iterations=1000} RFNn {learning rate=0.1, iterations=1000} DAE {corruption level=0.2, learning rate=1e-04, iterations=1000} RBM {learning rate=0.01, iterations=1000} FAsp {iterations=500} FAlap {iterations=500} SFA {Laplace weight decay factor=5e-05, iterations=500}"}, {"heading": "S12 Data Set I", "text": "The number of components are fixed to 50, 100 or 150.\nWe generated nine different benchmark data sets (D1 to D9), where each data set consists of 100 instances for averaging the results. Each instance consists of 100 samples and 100 features resulting in a 100\u00d7100 data matrix. Into these data matrices, structures are implanted as biclusters [8]. A bicluster is a pattern consisting of a particular number of features which is found in a particular number of samples. The size of the bicluster is given by the number of features that form the pattern and by the number of samples in which the pattern is found. The data sets had different noise levels and different bicluster sizes. We considered large and small bicluster sizes, where large biclusters have 20\u201330 samples and 20\u201330 features, while small biclusters have 3\u20138 samples and 3\u20138 features. The signal strength (scaling factor) of a pattern in a sample was randomly chosen according to the Gaussian N (1, 1). Finally, to each data matrix background noise was added, where the noise is distributed according to a zero-mean Gaussian with standard deviation 1, 5, or 10. The data sets are described in Tab. S4. The remaining components of the spanning outer product vectors were drawn by N (0, 0.01).\nTable S4: Overview over the datasets. Shown is the background noise (\u201cnoise\u201d), the number of large biclusters (n1), and the number of small biclusters (n2).\nD1 D2 D3 D4 D5 D6 D7 D8 D9\nnoise 1 5 10 1 5 10 1 5 10 n1 10 10 10 15 15 15 5 5 5 n2 10 10 10 5 5 5 15 15 15\nTa bl\ne S5\n: C\nom pa\nri so\nn fo\nr 50\nfa ct\nor s\n/h id\nde n\nun its\nex tr\nac te\nd by\nR FN\n,R FN\nw ith\nou tn\nor m\nal iz\nat io\nn (R\nFN n)\n,d en\noi si\nng au\nto en\nco de\nr (D\nA E\n), re\nst ri\nct ed\nB ol\ntz m\nan n\nm ac\nhi ne\ns (R\nB M\n), fa\nct or\nan al\nys is\nw ith\na ve\nry sp\nar se\npr io\nr( FA\nsp ),\nfa ct\nor an\nal ys\nis w\nith a\nL ap\nla ce\npr io\nr( FA\nla p)\n,i nd\nep en\nde nt\nco m\npo ne\nnt an\nal ys\nis (I\nC A\n), sp\nar se\nfa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e co di ng un its (S P) ,r ec on st ru ct io n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O . R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 74 \u00b1 0 58 \u00b1 1 5\u00b1 0 75 \u00b1 0 23 3\u00b1 3 66 \u00b1 1 75 \u00b1 0 45 6\u00b1 5 25 3\u00b1 6 74 \u00b1 0 63 \u00b1 1 6\u00b1 1 75 \u00b1 0 23 6\u00b1 3 68 \u00b1 2 R FN n 73 \u00b1 0 85 \u00b1 3 13 \u00b1 2 75 \u00b1 0 27 2\u00b1 3 85 \u00b1 2 75 \u00b1 0 53 1\u00b1 6 32 1\u00b1 7 72 \u00b1 0 95 \u00b1 4 17 \u00b1 2 74 \u00b1 0 27 6\u00b1 4 89 \u00b1 3 D A E 65 \u00b1 0 65 \u00b1 2 \u2014 66 \u00b1 0 23 3\u00b1 2 \u2014 66 \u00b1 0 45 6\u00b1 4 \u2014 65 \u00b1 1 71 \u00b1 2 \u2014 66 \u00b1 0 23 7\u00b1 2 \u2014 R B M 25 \u00b1 2 86 \u00b1 3 \u2014 11 \u00b1 1 28 7\u00b1 3 \u2014 10 \u00b1 1 55 8\u00b1 5 \u2014 25 \u00b1 2 94 \u00b1 3 \u2014 11 \u00b1 1 29 2\u00b1 3 \u2014 FA sp 39 \u00b1 1 23 2\u00b1 31 65 4\u00b1 99 40 \u00b1 1 99 9\u00b1 41 99 9\u00b1 99 41 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 38 \u00b1 1 31 8\u00b1 33 99 9\u00b1 99 40 \u00b1 1 99 9\u00b1 48 99 9\u00b1 99 FA la p 4\u00b1 0 53 \u00b1 2 14 4\u00b1 36 4\u00b1 0 22 4\u00b1 5 18 5\u00b1 5 5\u00b1 0 43 9\u00b1 9 69 2\u00b1 16 4\u00b1 0 55 \u00b1 2 18 0\u00b1 39 4\u00b1 0 22 6\u00b1 5 19 2\u00b1 6 IC A 2\u00b1 0 34 \u00b1 0 \u2014 2\u00b1 0 16 4\u00b1 2 \u2014 2\u00b1 0 32 4\u00b1 4 \u2014 2\u00b1 0 35 \u00b1 0 \u2014 2\u00b1 0 16 6\u00b1 2 \u2014 SF A 1\u00b1 0 42 \u00b1 1 11 \u00b1 2 1\u00b1 0 20 6\u00b1 4 56 \u00b1 2 1\u00b1 0 40 6\u00b1 9 21 5\u00b1 7 1\u00b1 0 42 \u00b1 1 13 \u00b1 2 1\u00b1 0 20 8\u00b1 4 58 \u00b1 2 FA 1\u00b1 0 42 \u00b1 1 6\u00b1 1 1\u00b1 0 20 6\u00b1 4 54 \u00b1 2 1\u00b1 0 40 7\u00b1 8 21 0\u00b1 6 1\u00b1 0 42 \u00b1 1 8\u00b1 1 1\u00b1 0 20 8\u00b1 4 56 \u00b1 2 PC A 1\u00b1 0 34 \u00b1 0 \u2014 0\u00b1 0 16 4\u00b1 2 \u2014 0\u00b1 0 32 4\u00b1 4 \u2014 1\u00b1 0 35 \u00b1 0 \u2014 0\u00b1 0 16 6\u00b1 2 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 75 \u00b1 0 45 8\u00b1 5 25 6\u00b1 6 75 \u00b1 0 53 \u00b1 1 4\u00b1 1 75 \u00b1 0 23 0\u00b1 3 64 \u00b1 1 75 \u00b1 0 45 4\u00b1 5 25 1\u00b1 5 75 \u00b1 0 24 9\u00b1 3 10 8\u00b1 3 R FN n 75 \u00b1 0 53 2\u00b1 6 32 3\u00b1 7 73 \u00b1 0 73 \u00b1 3 10 \u00b1 2 75 \u00b1 0 26 8\u00b1 3 82 \u00b1 2 75 \u00b1 0 52 8\u00b1 6 31 7\u00b1 7 74 \u00b1 0 29 5\u00b1 4 14 0\u00b1 4 D A E 66 \u00b1 0 45 8\u00b1 4 \u2014 65 \u00b1 0 58 \u00b1 1 \u2014 66 \u00b1 0 23 0\u00b1 2 \u2014 66 \u00b1 0 45 3\u00b1 5 \u2014 66 \u00b1 0 25 1\u00b1 3 \u2014 R B M 10 \u00b1 1 56 1\u00b1 5 \u2014 23 \u00b1 2 76 \u00b1 2 \u2014 11 \u00b1 1 28 2\u00b1 3 \u2014 10 \u00b1 1 55 5\u00b1 5 \u2014 15 \u00b1 1 31 0\u00b1 4 \u2014 FA sp 40 \u00b1 2 99 9\u00b1 99 99 9\u00b1 99 39 \u00b1 1 15 2\u00b1 26 34 5\u00b1 99 40 \u00b1 1 99 9\u00b1 31 99 9\u00b1 99 41 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 40 \u00b1 1 99 9\u00b1 63 99 9\u00b1 99 FA la p 5\u00b1 0 44 3\u00b1 9 70 1\u00b1 15 4\u00b1 0 50 \u00b1 2 11 0\u00b1 37 4\u00b1 0 22 1\u00b1 5 17 7\u00b1 4 5\u00b1 0 43 9\u00b1 10 68 6\u00b1 15 4\u00b1 0 23 9\u00b1 6 34 1\u00b1 19 IC A 2\u00b1 0 32 5\u00b1 4 \u2014 2\u00b1 0 34 \u00b1 0 \u2014 2\u00b1 0 16 3\u00b1 2 \u2014 2\u00b1 0 32 2\u00b1 4 \u2014 2\u00b1 0 17 4\u00b1 2 \u2014 SF A 1\u00b1 0 40 8\u00b1 9 21 7\u00b1 7 1\u00b1 0 42 \u00b1 1 8\u00b1 2 1\u00b1 0 20 4\u00b1 4 54 \u00b1 2 1\u00b1 0 40 5\u00b1 9 21 3\u00b1 7 1\u00b1 0 21 8\u00b1 5 94 \u00b1 3 FA 1\u00b1 0 40 9\u00b1 9 21 2\u00b1 7 1\u00b1 0 42 \u00b1 1 4\u00b1 1 1\u00b1 0 20 5\u00b1 4 53 \u00b1 2 1\u00b1 0 40 5\u00b1 8 20 8\u00b1 6 1\u00b1 0 21 8\u00b1 4 90 \u00b1 3 PC A 0\u00b1 0 32 5\u00b1 4 \u2014 1\u00b1 0 34 \u00b1 0 \u2014 0\u00b1 0 16 3\u00b1 2 \u2014 0\u00b1 0 32 2\u00b1 4 \u2014 0\u00b1 0 17 4\u00b1 2 \u2014\nTa bl\ne S6\n: C\nom pa\nri so\nn fo\nr 10\n0 fa\nct or\ns /h\nid de\nn un\nits ex\ntr ac\nte d\nby R\nFN ,R\nFN w\nith ou\ntn or\nm al\niz at\nio n\n(R FN\nn) ,d\nen oi\nsi ng\nau to\nen co\nde r\n(D A\nE ),\nre st\nri ct\ned B\nol tz\nm an n m ac hi ne s (R B M ), fa ct or an al ys is w ith a ve ry sp ar se pr io r( FA sp ), fa ct or an al ys is w ith a L ap la ce pr io r( FA la p) ,i nd ep en de nt co m po ne nt an al ys is (I C A ), sp ar se fa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e co di ng un its (S P) ,r ec on st ru ct io n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O . R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 79 \u00b1 1 23 \u00b1 3 2\u00b1 0 82 \u00b1 1 63 \u00b1 9 16 \u00b1 3 82 \u00b1 1 12 0\u00b1 17 61 \u00b1 15 78 \u00b1 1 27 \u00b1 3 2\u00b1 1 82 \u00b1 1 62 \u00b1 7 16 \u00b1 3 R FN n 77 \u00b1 0 61 \u00b1 4 6\u00b1 1 80 \u00b1 0 16 9\u00b1 4 36 \u00b1 2 80 \u00b1 0 32 6\u00b1 8 13 5\u00b1 6 76 \u00b1 1 73 \u00b1 4 9\u00b1 2 79 \u00b1 0 17 1\u00b1 5 37 \u00b1 2 D A E 67 \u00b1 0 48 \u00b1 2 \u2014 70 \u00b1 0 13 4\u00b1 1 \u2014 70 \u00b1 0 26 0\u00b1 2 \u2014 67 \u00b1 0 54 \u00b1 2 \u2014 70 \u00b1 0 13 7\u00b1 1 \u2014 R B M 14 \u00b1 1 81 \u00b1 3 \u2014 4\u00b1 0 26 6\u00b1 3 \u2014 4\u00b1 0 51 4\u00b1 6 \u2014 15 \u00b1 1 88 \u00b1 2 \u2014 4\u00b1 0 27 0\u00b1 3 \u2014 FA sp 72 \u00b1 0 23 3\u00b1 32 49 9\u00b1 99 62 \u00b1 0 99 9\u00b1 43 99 9\u00b1 99 56 \u00b1 0 99 9\u00b1 99 99 9\u00b1 99 71 \u00b1 0 32 0\u00b1 34 87 8\u00b1 99 62 \u00b1 0 99 9\u00b1 49 99 9\u00b1 99 FA la p 6\u00b1 0 27 \u00b1 3 20 2\u00b1 17 6\u00b1 0 38 \u00b1 3 75 6\u00b1 33 6\u00b1 0 74 \u00b1 5 99 9\u00b1 83 6\u00b1 0 31 \u00b1 3 27 4\u00b1 23 6\u00b1 0 39 \u00b1 3 77 8\u00b1 34 IC A 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 6\u00b1 0 30 \u00b1 5 1\u00b1 0 14 \u00b1 0 68 \u00b1 3 1\u00b1 0 28 \u00b1 1 24 3\u00b1 8 1\u00b1 0 8\u00b1 0 38 \u00b1 5 1\u00b1 0 15 \u00b1 0 72 \u00b1 3 FA 1\u00b1 0 6\u00b1 0 18 \u00b1 3 1\u00b1 0 14 \u00b1 0 50 \u00b1 2 1\u00b1 0 28 \u00b1 1 18 2\u00b1 7 1\u00b1 0 8\u00b1 0 24 \u00b1 4 1\u00b1 0 15 \u00b1 0 52 \u00b1 2 PC A 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 82 \u00b1 1 12 0\u00b1 16 60 \u00b1 13 80 \u00b1 1 18 \u00b1 2 1\u00b1 0 82 \u00b1 1 61 \u00b1 7 15 \u00b1 3 82 \u00b1 1 12 2\u00b1 13 60 \u00b1 11 81 \u00b1 1 68 \u00b1 9 26 \u00b1 6 R FN n 80 \u00b1 0 32 9\u00b1 7 13 7\u00b1 6 78 \u00b1 0 49 \u00b1 3 4\u00b1 1 80 \u00b1 0 16 5\u00b1 4 34 \u00b1 1 80 \u00b1 0 32 5\u00b1 7 13 4\u00b1 6 79 \u00b1 0 18 5\u00b1 5 59 \u00b1 3 D A E 70 \u00b1 0 26 1\u00b1 2 \u2014 68 \u00b1 0 39 \u00b1 2 \u2014 70 \u00b1 0 13 2\u00b1 1 \u2014 70 \u00b1 0 25 9\u00b1 2 \u2014 69 \u00b1 0 14 7\u00b1 2 \u2014 R B M 4\u00b1 0 51 7\u00b1 6 \u2014 12 \u00b1 1 71 \u00b1 2 \u2014 4\u00b1 0 26 1\u00b1 3 \u2014 4\u00b1 0 51 2\u00b1 5 \u2014 7\u00b1 1 28 7\u00b1 4 \u2014 FA sp 56 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 73 \u00b1 0 14 9\u00b1 28 23 7\u00b1 62 62 \u00b1 0 99 9\u00b1 34 99 9\u00b1 99 56 \u00b1 0 99 9\u00b1 99 99 9\u00b1 99 63 \u00b1 0 99 9\u00b1 65 99 9\u00b1 99 FA la p 6\u00b1 0 74 \u00b1 6 99 9\u00b1 91 6\u00b1 0 22 \u00b1 3 13 4\u00b1 14 6\u00b1 0 37 \u00b1 2 73 3\u00b1 28 6\u00b1 0 73 \u00b1 6 99 9\u00b1 84 6\u00b1 0 46 \u00b1 4 98 5\u00b1 45 IC A 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 28 \u00b1 1 24 7\u00b1 8 1\u00b1 0 5\u00b1 0 21 \u00b1 5 1\u00b1 0 14 \u00b1 0 64 \u00b1 2 1\u00b1 0 27 \u00b1 1 24 0\u00b1 7 1\u00b1 0 16 \u00b1 1 11 4\u00b1 5 FA 1\u00b1 0 28 \u00b1 1 18 4\u00b1 8 1\u00b1 0 5\u00b1 0 11 \u00b1 3 1\u00b1 0 14 \u00b1 0 47 \u00b1 2 1\u00b1 0 27 \u00b1 1 17 9\u00b1 7 1\u00b1 0 16 \u00b1 1 83 \u00b1 4 PC A 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014\nTa bl\ne S7\n: C\nom pa\nri so\nn fo\nr 15\n0 fa\nct or\ns /h\nid de\nn un\nits ex\ntr ac\nte d\nby R\nFN ,R\nFN w\nith ou\ntn or\nm al\niz at\nio n\n(R FN\nn) ,d\nen oi\nsi ng\nau to\nen co\nde r\n(D A\nE ),\nre st\nri ct\ned B\nol tz\nm an n m ac hi ne s (R B M ), fa ct or an al ys is w ith a ve ry sp ar se pr io r( FA sp ), fa ct or an al ys is w ith a L ap la ce pr io r( FA la p) ,i nd ep en de nt co m po ne nt an al ys is (I C A ), sp ar se fa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e co di ng un its (S P) ,r ec on st ru ct io n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O . T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP ,E R an d C O .R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 83 \u00b1 1 7\u00b1 2 0\u00b1 1 86 \u00b1 0 15 \u00b1 1 3\u00b1 1 86 \u00b1 2 33 \u00b1 20 18 \u00b1 23 83 \u00b1 1 9\u00b1 2 1\u00b1 0 86 \u00b1 1 15 \u00b1 3 4\u00b1 1 R FN n 79 \u00b1 0 48 \u00b1 3 4\u00b1 1 81 \u00b1 0 12 9\u00b1 3 21 \u00b1 1 81 \u00b1 0 25 0\u00b1 7 80 \u00b1 4 78 \u00b1 0 60 \u00b1 4 6\u00b1 1 81 \u00b1 0 13 1\u00b1 3 22 \u00b1 1 D A E 68 \u00b1 0 44 \u00b1 2 \u2014 72 \u00b1 0 11 8\u00b1 1 \u2014 72 \u00b1 0 22 9\u00b1 2 \u2014 68 \u00b1 0 50 \u00b1 2 \u2014 72 \u00b1 0 12 0\u00b1 2 \u2014 R B M 10 \u00b1 1 81 \u00b1 3 \u2014 3\u00b1 0 26 5\u00b1 3 \u2014 3\u00b1 0 51 4\u00b1 6 \u2014 10 \u00b1 1 88 \u00b1 2 \u2014 3\u00b1 0 27 0\u00b1 4 \u2014 FA sp 83 \u00b1 1 23 3\u00b1 32 34 0\u00b1 71 79 \u00b1 0 99 9\u00b1 43 99 9\u00b1 99 77 \u00b1 0 99 9\u00b1 99 99 9\u00b1 99 81 \u00b1 1 32 0\u00b1 34 57 4\u00b1 99 79 \u00b1 1 99 9\u00b1 49 99 9\u00b1 99 FA la p 4\u00b1 0 27 \u00b1 3 29 5\u00b1 25 4\u00b1 0 38 \u00b1 3 79 1\u00b1 41 3\u00b1 0 74 \u00b1 5 99 9\u00b1 91 4\u00b1 0 31 \u00b1 3 39 4\u00b1 31 4\u00b1 0 39 \u00b1 3 81 7\u00b1 39 IC A 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 6\u00b1 0 49 \u00b1 7 1\u00b1 0 14 \u00b1 0 17 3\u00b1 4 1\u00b1 0 28 \u00b1 1 63 2\u00b1 10 1\u00b1 0 8\u00b1 0 61 \u00b1 7 1\u00b1 0 15 \u00b1 0 18 1\u00b1 5 FA 1\u00b1 0 6\u00b1 0 40 \u00b1 5 1\u00b1 0 14 \u00b1 0 16 0\u00b1 4 1\u00b1 0 28 \u00b1 1 59 0\u00b1 10 1\u00b1 0 8\u00b1 0 51 \u00b1 6 1\u00b1 0 15 \u00b1 0 16 8\u00b1 4 PC A 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 86 \u00b1 1 30 \u00b1 13 15 \u00b1 16 84 \u00b1 2 5\u00b1 3 0\u00b1 1 86 \u00b1 0 14 \u00b1 1 3\u00b1 1 86 \u00b1 1 30 \u00b1 8 15 \u00b1 9 85 \u00b1 1 17 \u00b1 6 7\u00b1 6 R FN n 81 \u00b1 0 25 1\u00b1 6 81 \u00b1 3 80 \u00b1 0 37 \u00b1 3 2\u00b1 0 81 \u00b1 0 12 6\u00b1 3 20 \u00b1 1 81 \u00b1 0 24 8\u00b1 6 79 \u00b1 3 80 \u00b1 0 14 2\u00b1 4 35 \u00b1 2 D A E 72 \u00b1 0 23 0\u00b1 2 \u2014 70 \u00b1 0 36 \u00b1 2 \u2014 72 \u00b1 0 11 6\u00b1 1 \u2014 72 \u00b1 0 22 7\u00b1 2 \u2014 71 \u00b1 0 13 0\u00b1 2 \u2014 R B M 3\u00b1 0 51 6\u00b1 6 \u2014 8\u00b1 1 71 \u00b1 2 \u2014 3\u00b1 0 26 0\u00b1 4 \u2014 3\u00b1 0 51 1\u00b1 5 \u2014 5\u00b1 0 28 6\u00b1 4 \u2014 FA sp 77 \u00b1 0 99 9\u00b1 99 99 9\u00b1 99 84 \u00b1 0 14 9\u00b1 28 16 8\u00b1 55 80 \u00b1 0 99 9\u00b1 34 99 9\u00b1 99 77 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 80 \u00b1 0 99 9\u00b1 65 99 9\u00b1 99 FA la p 3\u00b1 0 74 \u00b1 6 99 9\u00b1 97 4\u00b1 0 22 \u00b1 3 19 8\u00b1 17 4\u00b1 0 37 \u00b1 2 76 8\u00b1 40 3\u00b1 0 73 \u00b1 6 99 9\u00b1 93 4\u00b1 0 46 \u00b1 4 97 6\u00b1 53 IC A 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 28 \u00b1 1 64 0\u00b1 11 1\u00b1 0 5\u00b1 0 34 \u00b1 6 1\u00b1 0 14 \u00b1 0 16 4\u00b1 3 1\u00b1 0 27 \u00b1 1 62 5\u00b1 9 1\u00b1 0 16 \u00b1 1 28 5\u00b1 7 FA 1\u00b1 0 28 \u00b1 1 59 6\u00b1 10 1\u00b1 0 5\u00b1 0 27 \u00b1 5 1\u00b1 0 14 \u00b1 0 15 3\u00b1 3 1\u00b1 0 27 \u00b1 1 58 3\u00b1 9 1\u00b1 0 16 \u00b1 1 26 3\u00b1 6 PC A 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014"}, {"heading": "S13 Data Set II", "text": "This data sets was generate as described in Section S12, but instead of drawing the remaining components of the spanning outer product vectors fromN (0, 0.01), they were now drawn fromN (0, 0.5).\nTa bl\ne S8\n: C\nom pa\nri so\nn fo\nr 50\nfa ct\nor s\n/h id\nde n\nun its\nex tr\nac te\nd by\nR FN\n,R FN\nw ith\nou tn\nor m\nal iz\nat io\nn (R\nFN n)\n,d en\noi si\nng au\nto en\nco de\nr (D\nA E\n), re\nst ri\nct ed\nB ol\ntz m\nan n\nm ac\nhi ne\ns (R\nB M\n), fa\nct or\nan al\nys is\nw ith\na ve\nry sp\nar se\npr io\nr( FA\nsp ),\nfa ct\nor an\nal ys\nis w\nith a\nL ap\nla ce\npr io\nr( FA\nla p)\n,i nd\nep en\nde nt\nco m\npo ne\nnt an\nal ys\nis (I\nC A\n), sp\nar se\nfa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e co di ng un its (S P) ,r ec on st ru ct io n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O . R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 72 \u00b1 1 74 \u00b1 2 11 \u00b1 1 75 \u00b1 0 24 0\u00b1 3 72 \u00b1 2 75 \u00b1 0 46 2\u00b1 5 26 0\u00b1 6 72 \u00b1 1 79 \u00b1 2 12 \u00b1 1 75 \u00b1 0 24 4\u00b1 3 75 \u00b1 2 R FN n 68 \u00b1 1 12 2\u00b1 5 32 \u00b1 4 74 \u00b1 0 28 5\u00b1 4 97 \u00b1 3 74 \u00b1 0 53 7\u00b1 7 33 1\u00b1 8 65 \u00b1 1 14 4\u00b1 6 48 \u00b1 6 74 \u00b1 0 29 0\u00b1 4 10 2\u00b1 4 D A E 61 \u00b1 0 82 \u00b1 2 \u2014 66 \u00b1 0 24 3\u00b1 2 \u2014 66 \u00b1 0 46 1\u00b1 4 \u2014 60 \u00b1 0 88 \u00b1 2 \u2014 66 \u00b1 0 24 7\u00b1 3 \u2014 R B M 22 \u00b1 1 10 6\u00b1 3 \u2014 11 \u00b1 1 30 1\u00b1 3 \u2014 10 \u00b1 1 56 6\u00b1 6 \u2014 22 \u00b1 1 11 3\u00b1 3 \u2014 11 \u00b1 1 30 8\u00b1 4 \u2014 FA sp 37 \u00b1 1 46 9\u00b1 38 99 9\u00b1 99 40 \u00b1 1 99 9\u00b1 50 99 9\u00b1 99 40 \u00b1 2 99 9\u00b1 99 99 9\u00b1 99 37 \u00b1 1 61 0\u00b1 44 99 9\u00b1 99 40 \u00b1 1 99 9\u00b1 58 99 9\u00b1 99 FA la p 4\u00b1 0 50 \u00b1 1 39 2\u00b1 66 4\u00b1 0 22 8\u00b1 5 13 5\u00b1 13 5\u00b1 0 44 3\u00b1 9 40 6\u00b1 18 4\u00b1 0 51 \u00b1 1 47 7\u00b1 63 4\u00b1 0 23 0\u00b1 6 14 7\u00b1 18 IC A 2\u00b1 0 35 \u00b1 0 \u2014 2\u00b1 0 16 8\u00b1 2 \u2014 2\u00b1 0 32 7\u00b1 4 \u2014 2\u00b1 0 35 \u00b1 0 \u2014 2\u00b1 0 17 0\u00b1 2 \u2014 SF A 1\u00b1 0 42 \u00b1 1 26 \u00b1 3 1\u00b1 0 21 0\u00b1 5 61 \u00b1 2 1\u00b1 0 40 9\u00b1 8 22 0\u00b1 6 1\u00b1 0 41 \u00b1 1 32 \u00b1 4 1\u00b1 0 21 1\u00b1 5 63 \u00b1 2 FA 1\u00b1 0 42 \u00b1 1 13 \u00b1 2 1\u00b1 0 21 0\u00b1 4 58 \u00b1 2 1\u00b1 0 40 9\u00b1 8 21 4\u00b1 6 1\u00b1 0 41 \u00b1 1 17 \u00b1 2 1\u00b1 0 21 2\u00b1 5 60 \u00b1 2 PC A 0\u00b1 0 35 \u00b1 0 \u2014 0\u00b1 0 16 8\u00b1 2 \u2014 0\u00b1 0 32 7\u00b1 4 \u2014 0\u00b1 0 35 \u00b1 0 \u2014 0\u00b1 0 17 0\u00b1 2 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 75 \u00b1 0 46 4\u00b1 5 26 4\u00b1 6 73 \u00b1 0 68 \u00b1 2 9\u00b1 1 75 \u00b1 0 23 7\u00b1 3 69 \u00b1 1 75 \u00b1 0 45 9\u00b1 5 25 7\u00b1 6 74 \u00b1 0 25 9\u00b1 3 11 4\u00b1 3 R FN n 74 \u00b1 0 54 1\u00b1 6 33 6\u00b1 8 71 \u00b1 1 10 6\u00b1 4 23 \u00b1 3 74 \u00b1 0 27 9\u00b1 3 91 \u00b1 2 75 \u00b1 0 53 3\u00b1 6 32 5\u00b1 8 72 \u00b1 1 31 5\u00b1 5 15 4\u00b1 5 D A E 66 \u00b1 0 46 5\u00b1 4 \u2014 62 \u00b1 0 75 \u00b1 2 \u2014 66 \u00b1 0 23 8\u00b1 2 \u2014 66 \u00b1 0 45 8\u00b1 4 \u2014 64 \u00b1 0 26 2\u00b1 3 \u2014 R B M 10 \u00b1 1 57 0\u00b1 6 \u2014 20 \u00b1 1 97 \u00b1 3 \u2014 11 \u00b1 1 29 4\u00b1 3 \u2014 10 \u00b1 1 56 2\u00b1 5 \u2014 14 \u00b1 1 32 4\u00b1 4 \u2014 FA sp 41 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 38 \u00b1 1 33 5\u00b1 32 99 9\u00b1 99 41 \u00b1 1 99 9\u00b1 40 99 9\u00b1 99 41 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 39 \u00b1 1 99 9\u00b1 69 99 9\u00b1 99 FA la p 5\u00b1 0 44 7\u00b1 9 41 3\u00b1 19 4\u00b1 0 49 \u00b1 1 29 2\u00b1 57 4\u00b1 0 22 7\u00b1 5 12 3\u00b1 11 5\u00b1 0 44 3\u00b1 9 40 1\u00b1 17 4\u00b1 0 24 1\u00b1 5 31 0\u00b1 31 IC A 2\u00b1 0 32 9\u00b1 4 \u2014 2\u00b1 0 35 \u00b1 0 \u2014 2\u00b1 0 16 7\u00b1 2 \u2014 2\u00b1 0 32 5\u00b1 4 \u2014 2\u00b1 0 17 7\u00b1 2 \u2014 SF A 1\u00b1 0 41 2\u00b1 8 22 3\u00b1 7 1\u00b1 0 42 \u00b1 1 19 \u00b1 3 1\u00b1 0 20 9\u00b1 4 59 \u00b1 2 1\u00b1 0 40 8\u00b1 9 21 8\u00b1 7 1\u00b1 0 22 1\u00b1 5 10 2\u00b1 4 FA 1\u00b1 0 41 2\u00b1 8 21 7\u00b1 7 1\u00b1 0 42 \u00b1 1 10 \u00b1 1 1\u00b1 0 20 9\u00b1 4 57 \u00b1 2 1\u00b1 0 40 9\u00b1 9 21 3\u00b1 7 1\u00b1 0 22 1\u00b1 5 95 \u00b1 3 PC A 0\u00b1 0 32 9\u00b1 4 \u2014 0\u00b1 0 35 \u00b1 0 \u2014 0\u00b1 0 16 7\u00b1 2 \u2014 0\u00b1 0 32 5\u00b1 4 \u2014 0\u00b1 0 17 7\u00b1 2 \u2014\nTa bl\ne S9\n: C\nom pa\nri so\nn fo\nr 10\n0 fa\nct or\ns /h\nid de\nn un\nits ex\ntr ac\nte d\nby R\nFN ,R\nFN w\nith ou\ntn or\nm al\niz at\nio n\n(R FN\nn) ,d\nen oi\nsi ng\nau to\nen co\nde r\n(D A\nE ),\nre st\nri ct\ned B\nol tz\nm an n m ac hi ne s (R B M ), fa ct or an al ys is w ith a ve ry sp ar se pr io r( FA sp ), fa ct or an al ys is w ith a L ap la ce pr io r( FA la p) ,i nd ep en de nt co m po ne nt an al ys is (I C A ), sp ar se fa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e co di ng un its (S P) ,r ec on st ru ct io n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O . R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 76 \u00b1 1 34 \u00b1 3 4\u00b1 1 82 \u00b1 1 67 \u00b1 8 18 \u00b1 3 82 \u00b1 1 12 4\u00b1 16 63 \u00b1 12 75 \u00b1 1 38 \u00b1 3 5\u00b1 1 82 \u00b1 1 69 \u00b1 10 19 \u00b1 5 R FN n 71 \u00b1 1 11 0\u00b1 7 25 \u00b1 4 79 \u00b1 0 18 0\u00b1 5 42 \u00b1 2 80 \u00b1 0 33 1\u00b1 8 13 9\u00b1 7 65 \u00b1 2 14 3\u00b1 9 47 \u00b1 8 79 \u00b1 0 18 5\u00b1 5 45 \u00b1 3 D A E 63 \u00b1 0 66 \u00b1 2 \u2014 70 \u00b1 0 14 2\u00b1 2 \u2014 70 \u00b1 0 26 4\u00b1 3 \u2014 62 \u00b1 0 73 \u00b1 2 \u2014 70 \u00b1 0 14 6\u00b1 2 \u2014 R B M 12 \u00b1 1 10 0\u00b1 3 \u2014 5\u00b1 0 28 2\u00b1 4 \u2014 4\u00b1 0 52 2\u00b1 6 \u2014 12 \u00b1 1 10 6\u00b1 3 \u2014 5\u00b1 1 28 8\u00b1 4 \u2014 FA sp 71 \u00b1 0 47 4\u00b1 38 99 9\u00b1 99 62 \u00b1 0 99 9\u00b1 53 99 9\u00b1 99 56 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 70 \u00b1 0 61 6\u00b1 44 99 9\u00b1 99 62 \u00b1 0 99 9\u00b1 60 99 9\u00b1 99 FA la p 6\u00b1 0 21 \u00b1 2 42 5\u00b1 28 6\u00b1 0 40 \u00b1 2 82 7\u00b1 35 6\u00b1 0 75 \u00b1 6 99 9\u00b1 99 6\u00b1 0 23 \u00b1 2 52 3\u00b1 32 6\u00b1 0 42 \u00b1 3 86 5\u00b1 43 IC A 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 10 \u00b1 0 71 \u00b1 7 1\u00b1 0 15 \u00b1 0 84 \u00b1 4 1\u00b1 0 28 \u00b1 1 25 4\u00b1 8 1\u00b1 0 12 \u00b1 0 87 \u00b1 8 1\u00b1 0 16 \u00b1 0 92 \u00b1 5 FA 1\u00b1 0 10 \u00b1 0 48 \u00b1 5 1\u00b1 0 15 \u00b1 0 59 \u00b1 3 1\u00b1 0 28 \u00b1 1 18 9\u00b1 7 1\u00b1 0 12 \u00b1 1 61 \u00b1 6 1\u00b1 0 16 \u00b1 0 64 \u00b1 3 PC A 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 3\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 82 \u00b1 1 12 7\u00b1 17 65 \u00b1 14 77 \u00b1 1 30 \u00b1 3 3\u00b1 1 82 \u00b1 1 64 \u00b1 8 17 \u00b1 4 82 \u00b1 1 12 3\u00b1 15 62 \u00b1 13 80 \u00b1 1 75 \u00b1 9 28 \u00b1 6 R FN n 80 \u00b1 0 33 4\u00b1 8 14 1\u00b1 7 74 \u00b1 1 86 \u00b1 4 14 \u00b1 2 79 \u00b1 0 17 4\u00b1 4 39 \u00b1 2 80 \u00b1 0 32 9\u00b1 7 13 7\u00b1 6 76 \u00b1 1 20 8\u00b1 6 70 \u00b1 5 D A E 70 \u00b1 0 26 6\u00b1 2 \u2014 64 \u00b1 0 57 \u00b1 2 \u2014 70 \u00b1 0 13 8\u00b1 1 \u2014 70 \u00b1 0 26 2\u00b1 2 \u2014 68 \u00b1 0 15 7\u00b1 2 \u2014 R B M 4\u00b1 0 52 7\u00b1 6 \u2014 11 \u00b1 1 92 \u00b1 2 \u2014 4\u00b1 0 27 4\u00b1 4 \u2014 4\u00b1 0 51 8\u00b1 6 \u2014 7\u00b1 1 30 1\u00b1 4 \u2014 FA sp 56 \u00b1 0 99 9\u00b1 99 99 9\u00b1 99 71 \u00b1 0 33 8\u00b1 33 99 9\u00b1 99 62 \u00b1 1 99 9\u00b1 42 99 9\u00b1 99 56 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 63 \u00b1 0 99 9\u00b1 74 99 9\u00b1 99 FA la p 6\u00b1 0 75 \u00b1 6 99 9\u00b1 89 6\u00b1 0 18 \u00b1 2 33 7\u00b1 24 6\u00b1 0 40 \u00b1 3 79 3\u00b1 37 6\u00b1 0 74 \u00b1 6 99 9\u00b1 89 6\u00b1 0 45 \u00b1 3 99 9\u00b1 53 IC A 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 28 \u00b1 1 26 0\u00b1 9 1\u00b1 0 8\u00b1 0 52 \u00b1 7 1\u00b1 0 15 \u00b1 0 76 \u00b1 3 1\u00b1 0 28 \u00b1 1 24 8\u00b1 7 1\u00b1 0 18 \u00b1 1 13 6\u00b1 6 FA 1\u00b1 0 28 \u00b1 1 19 3\u00b1 8 1\u00b1 0 8\u00b1 0 33 \u00b1 5 1\u00b1 0 15 \u00b1 0 54 \u00b1 2 1\u00b1 0 28 \u00b1 1 18 5\u00b1 6 1\u00b1 0 18 \u00b1 1 99 \u00b1 5 PC A 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014\nTa bl\ne S1\n0: C\nom pa\nri so\nn fo\nr1 50\nfa ct\nor s\n/h id\nde n\nun its\nex tr\nac te\nd by\nR FN\n,R FN\nw ith\nou tn\nor m\nal iz\nat io\nn (R\nFN n)\n,d en\noi si\nng au\nto en\nco de\nr( D\nA E\n), re\nst ri\nct ed\nB ol\ntz m\nan n\nm ac\nhi ne\ns (R\nB M\n), fa\nct or\nan al\nys is\nw ith\na ve\nry sp\nar se\npr io\nr (F\nA sp\n), fa\nct or\nan al\nys is\nw ith\na L\nap la\nce pr\nio r\n(F A\nla p)\n, in\nde pe\nnd en\nt co\nm po\nne nt\nan al\nys is\n(I C\nA ),\nsp ar se fa ct or an al ys is (S FA ), fa ct or an al ys is (F A ), an d pr in ci pa lc om po ne nt an al ys is (P C A ) on ni ne da ta se ts . C ri te ri a ar e: sp ar se ne ss of th e fa ct or s (S P) re po rt ed in % , re co ns tr uc tio n er ro r( E R ), an d th e di ff er en ce be tw ee n th e em pi ri ca la nd th e m od el co va ri an ce m at ri x (C O ). T he lo w er ri gh tc ol um n bl oc k gi ve s th e av er ag e SP (% ), E R an d C O .R es ul ts re po rt ed he re ,a re th e m ea n to ge th er w ith th e st an da rd de vi at io n of 10 0 in st an ce s. T he m ax im al va lu e in th e ta bl e an d th e m ax im al st an da rd de vi at io n w as se tt o 99 9 an d to 99 ,r es pe ct iv el y. D 1 D 2 D 3 D 4 D 5 SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 81 \u00b1 1 12 \u00b1 2 1\u00b1 1 86 \u00b1 0 16 \u00b1 1 4\u00b1 1 86 \u00b1 0 29 \u00b1 4 15 \u00b1 5 80 \u00b1 1 15 \u00b1 5 2\u00b1 2 86 \u00b1 1 17 \u00b1 5 5\u00b1 3 R FN n 72 \u00b1 1 10 0\u00b1 8 19 \u00b1 4 80 \u00b1 0 13 7\u00b1 4 24 \u00b1 1 81 \u00b1 0 25 4\u00b1 6 83 \u00b1 4 66 \u00b1 0 11 3\u00b1 3 52 \u00b1 5 80 \u00b1 0 14 1\u00b1 4 26 \u00b1 2 D A E 64 \u00b1 0 62 \u00b1 2 \u2014 71 \u00b1 0 12 5\u00b1 2 \u2014 72 \u00b1 0 23 2\u00b1 2 \u2014 63 \u00b1 0 69 \u00b1 2 \u2014 71 \u00b1 0 12 9\u00b1 2 \u2014 R B M 8\u00b1 0 10 1\u00b1 3 \u2014 4\u00b1 0 28 2\u00b1 4 \u2014 3\u00b1 0 52 1\u00b1 6 \u2014 8\u00b1 0 10 6\u00b1 3 \u2014 4\u00b1 0 28 9\u00b1 4 \u2014 FA sp 81 \u00b1 1 47 4\u00b1 38 99 9\u00b1 99 79 \u00b1 0 99 9\u00b1 53 99 9\u00b1 99 77 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 80 \u00b1 1 61 6\u00b1 44 99 9\u00b1 99 79 \u00b1 1 99 9\u00b1 60 99 9\u00b1 99 FA la p 4\u00b1 0 21 \u00b1 2 60 7\u00b1 34 4\u00b1 0 40 \u00b1 2 87 9\u00b1 40 3\u00b1 0 75 \u00b1 6 99 9\u00b1 96 4\u00b1 0 23 \u00b1 2 74 9\u00b1 42 4\u00b1 0 42 \u00b1 3 92 6\u00b1 45 IC A 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 2 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 10 \u00b1 0 10 3\u00b1 9 1\u00b1 0 15 \u00b1 0 20 4\u00b1 7 1\u00b1 0 28 \u00b1 1 65 6\u00b1 12 1\u00b1 0 12 \u00b1 0 12 6\u00b1 10 1\u00b1 0 16 \u00b1 0 22 0\u00b1 8 FA 1\u00b1 0 10 \u00b1 0 87 \u00b1 8 1\u00b1 0 15 \u00b1 0 18 7\u00b1 5 1\u00b1 0 28 \u00b1 1 61 1\u00b1 11 1\u00b1 0 12 \u00b1 1 10 8\u00b1 9 1\u00b1 0 16 \u00b1 0 20 0\u00b1 6 PC A 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 3\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 D 6 D 7 D 8 D 9 av er ag e SP E R C O SP E R C O SP E R C O SP E R C O SP E R C O R FN 86 \u00b1 1 29 \u00b1 7 15 \u00b1 6 82 \u00b1 1 10 \u00b1 3 1\u00b1 1 86 \u00b1 1 17 \u00b1 10 5\u00b1 9 86 \u00b1 1 31 \u00b1 19 16 \u00b1 13 84 \u00b1 1 20 \u00b1 6 7\u00b1 4 R FN n 81 \u00b1 0 25 5\u00b1 6 84 \u00b1 3 76 \u00b1 1 74 \u00b1 5 9\u00b1 2 81 \u00b1 0 13 3\u00b1 3 23 \u00b1 1 81 \u00b1 0 25 0\u00b1 7 81 \u00b1 4 77 \u00b1 0 16 2\u00b1 5 45 \u00b1 3 D A E 72 \u00b1 0 23 4\u00b1 2 \u2014 65 \u00b1 0 53 \u00b1 2 \u2014 72 \u00b1 0 12 2\u00b1 1 \u2014 72 \u00b1 0 23 0\u00b1 2 \u2014 69 \u00b1 0 14 0\u00b1 2 \u2014 R B M 3\u00b1 0 52 5\u00b1 6 \u2014 8\u00b1 0 93 \u00b1 3 \u2014 3\u00b1 0 27 3\u00b1 4 \u2014 3\u00b1 0 51 7\u00b1 6 \u2014 5\u00b1 0 30 1\u00b1 4 \u2014 FA sp 77 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 81 \u00b1 1 33 8\u00b1 33 67 3\u00b1 99 79 \u00b1 0 99 9\u00b1 42 99 9\u00b1 99 77 \u00b1 1 99 9\u00b1 99 99 9\u00b1 99 79 \u00b1 1 99 9\u00b1 74 99 9\u00b1 99 FA la p 3\u00b1 0 75 \u00b1 6 99 9\u00b1 94 4\u00b1 0 18 \u00b1 2 47 9\u00b1 31 4\u00b1 0 40 \u00b1 3 83 1\u00b1 43 3\u00b1 0 74 \u00b1 6 99 9\u00b1 95 4\u00b1 0 45 \u00b1 3 99 9\u00b1 58 IC A 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 3\u00b1 1 0\u00b1 0 \u2014 SF A 1\u00b1 0 28 \u00b1 1 66 8\u00b1 12 1\u00b1 0 8\u00b1 0 78 \u00b1 8 1\u00b1 0 15 \u00b1 0 18 8\u00b1 5 1\u00b1 0 28 \u00b1 1 64 4\u00b1 9 1\u00b1 0 18 \u00b1 1 32 1\u00b1 9 FA 1\u00b1 0 28 \u00b1 1 62 2\u00b1 11 1\u00b1 0 8\u00b1 0 64 \u00b1 7 1\u00b1 0 15 \u00b1 0 17 3\u00b1 4 1\u00b1 0 28 \u00b1 1 59 9\u00b1 9 1\u00b1 0 18 \u00b1 1 29 4\u00b1 8 PC A 1\u00b1 0 0\u00b1 0 \u2014 4\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014 1\u00b1 0 0\u00b1 0 \u2014 2\u00b1 0 0\u00b1 0 \u2014"}, {"heading": "S14 RFN Pretraining for Convolution Nets", "text": "We assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-In-Network (5C-NIN).\nBoth CIFAR datasets contain 60k 32x32 RGB-color images, which were divided into 50k train and 10k test sets, split between 10 (CIFAR10) and 100 (CIFAR100) categories. Both datasets are preprocessed by global contrast normalization and ZCA whitening [48]. Additionally, the datasets were augmented by padding the images with four zero pixels at all borders. For data augmentation, at the beginning of every epoch, images in the training set were distorted by random translation and random flipping in horizontal and vertical directions. For the AlexNet, we neither preprocessed nor augmented the datasets.\nInspired by the Network In Network approach [49], we constructed a 5-Convolution-Network-InNetwork (5C-NIN) architecture with five convolutional layers, each followed by a 2x2 max-pooling layer (stride 1) and a multilayer perceptron (MLP) convolutional layer. ReLUs were used for the convolutional layers and dropout for regularization. For weight initialization, learning rates, and learning policies we used same strategy as in the AlexNet [28]. The networks were trained using mini-batches of size 100 and 128 for 5C-NIN and AlexNet, respectively.\nFor RFN pretraining, we randomly extracted 5x5 patches from the training data to construct 192 filters for DSN and 5C-NIN while 32 for AlexNet. These filters constitute the first convolutional layer of each network which is then trained using default setting. For assessing the improvement by RFNs, we repeated training with randomly initialized weights in the first layer. The results are presented in Tab. S11. For comparison, the lower panel of the table reports the performance of the currently top performing networks: Network In Network (NIN, [49]), Maxout Networks (MN, [48]) and DeepCNiN [50]. In all cases pretraining with RFNs decreases the test error rate.\nTable S11: The upper panel shows results of convolutional deep networks with first layer pretrained by RFN (\u201cRFN\u201d) and with first layer randomly initialized (\u201corg\u201d). The first column gives the network architecture, namely, AlexNet, Deeply Supervised Networks (DSN), and our 5-ConvolutionNetwork-In-Network (5C-NIN). The test error rates are reported (for CIFAR-100 DSN model was missing). Currently best performing networks Network In Network (NIN), Maxout Networks (MN), and DeepCNiN are reported in the lower panel. In all cases pretraining with RFNs decreased the test error rate.\nDataset CIFAR-10 CIFAR-100 org RFN org RFN augmented\nAlexNet 18.21 18.04 46.18 45.80 DSN 7.97 7.74 34.57 -\n\u221a\n5C-NIN 7.81 7.63 29.96 29.75 \u221a NIN 8.81 - 35.68 - \u221a MN 9.38 - 38.57 - \u221a DeepCNiN 6.28 - 24.30 - \u221a"}], "references": [{"title": "Reducing the dimensionality of data with neural networks", "author": ["G.E. Hinton", "R. Salakhutdinov"], "venue": "Science, 313(5786):504\u2013507", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2006}, {"title": "Greedy layer-wise training of deep networks", "author": ["Y. Bengio", "P. Lamblin", "D. Popovici", "H. Larochelle"], "venue": "B. Sch\u00f6lkopf, J. C. Platt, and T. Hoffman, editors, NIPS, pages 153\u2013160. MIT Press", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Deep learning in neural networks: An overview", "author": ["J. Schmidhuber"], "venue": "Neural Networks, 61:85\u2013117", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Deep learning", "author": ["Y. LeCun", "Y. Bengio", "G. Hinton"], "venue": "Nature, 521(7553):436\u2013444", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2015}, {"title": "Rectified linear units improve restricted Boltzmann machines", "author": ["V. Nair", "G.E. Hinton"], "venue": "ICML, pages 807\u2013814. Omnipress 2010, ISBN 978-1-60558-907-7", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Deep sparse rectifier neural networks", "author": ["X. Glorot", "A. Bordes", "Y. Bengio"], "venue": "AISTATS, volume 15, pages 315\u2013323", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["N. Srivastava", "G. Hinton", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": "Journal of Machine Learning Research, 15:1929\u20131958", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "et al", "author": ["S. Hochreiter", "U. Bodenhofer"], "venue": "FABIA: factor analysis for bicluster acquisition. Bioinformatics, 26(12):1520\u20131527", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "HapFABIA: Identification of very short segments of identity by descent characterized by rare variants in large sequencing data", "author": ["S. Hochreiter"], "venue": "Nucleic Acids Res., 41(22):e202", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Variational learning in nonlinear Gaussian belief networks", "author": ["B.J. Frey", "G.E. Hinton"], "venue": "Neural Computation, 11(1):193\u2013214", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1999}, {"title": "Variational learning for rectified factor analysis", "author": ["M. Harva", "A. Kaban"], "venue": "Signal Processing, 87(3):509\u2013 527", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2007}, {"title": "Posterior regularization for structured latent variable models", "author": ["K. Ganchev", "J. Graca", "J. Gillenwater", "B. Taskar"], "venue": "Journal of Machine Learning Research, 11:2001\u20132049", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Variational EM algorithms for non-Gaussian latent variable models", "author": ["J. Palmer", "D. Wipf", "K. Kreutz-Delgado", "B. Rao"], "venue": "NIPS, volume 18, pages 1059\u20131066", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "On the Goldstein-Levitin-Polyak gradient projection method", "author": ["D.P. Bertsekas"], "venue": "IEEE Trans. Automat. Control, 21:174\u2013184", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1976}, {"title": "Iterative Methods for Optimization", "author": ["C.T. Kelley"], "venue": "Society for Industrial and Applied Mathematics (SIAM), Philadelphia", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "Projected Newton methods for optimization problems with simple constraints", "author": ["D.P. Bertsekas"], "venue": "SIAM J. Control Optim., 20:221\u2013246", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1982}, {"title": "Optimization", "author": ["J. Abadie", "J. Carpentier"], "venue": "chapter Generalization of the Wolfe Reduced Gradient Method to the Case of Nonlinear Constraints. Academic Press", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1969}, {"title": "The gradient projection method for nonlinear programming", "author": ["J.B. Rosen"], "venue": "part ii. nonlinear constraints. Journal of the Society for Industrial and Applied Mathematics, 9(4):514\u2013532", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1961}, {"title": "Applied optimal design", "author": ["E.J. Haug", "J.S. Arora"], "venue": "J. Wiley & Sons, New York", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1979}, {"title": "Interior Point Polynomial Time Methods for Linear Programming", "author": ["A. Ben-Tal", "A. Nemirovski"], "venue": "Conic Quadratic Programming, and Semidefinite Programming, chapter 6, pages 377\u2013442. Society for Industrial and Applied Mathematics", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2001}, {"title": "Convergence theorems for generalized alternating minimization procedures", "author": ["A. Gunawardana", "W. Byrne"], "venue": "Journal of Machine Learning Research, 6:2049\u20132073", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2005}, {"title": "Nonlinear Programming: A Unified Approach", "author": ["W.I. Zangwill"], "venue": "Prentice Hall, Englewood Cliffs, N.J.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1969}, {"title": "Learning with Matrix Factorizations", "author": ["N. Srebro"], "venue": "PhD thesis, Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "A fast fixed-point algorithm for independent component analysis", "author": ["A. Hyv\u00e4rinen", "E. Oja"], "venue": "Neural Comput., 9(7):1483\u20131492", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1999}, {"title": "Learning methods for generic object recognition with invariance to pose and lighting", "author": ["Y. LeCun", "F.-J. Huang", "L. Bottou"], "venue": "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). IEEE Press", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2004}, {"title": "et al", "author": ["P. Vincent", "H. Larochelle"], "venue": "Stacked denoising autoencoders: Learning useful representations in a deep network with a local denoising criterion. JMLR, 11:3371\u20133408", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2010}, {"title": "et al", "author": ["H. Larochelle", "D. Erhan"], "venue": "An empirical evaluation of deep architectures on problems with many factors of variation. In ICML, pages 473\u2013480", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2007}, {"title": "Learning multiple layers of features from tiny images", "author": ["A. Krizhevsky"], "venue": "Master\u2019s thesis, Deptartment of Computer Science, University of Toronto", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2009}, {"title": "et al", "author": ["B. Verbist", "G. Klambauer"], "venue": "Using transcriptomics to guide lead optimization in drug discovery projects: Lessons learned from the {QSTAR} project. Drug Discovery Today, 20(5):505 \u2013 513", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2015}, {"title": "A new summarization method for Affymetrix probe level data", "author": ["S. Hochreiter", "D.-A. Clevert", "K. Obermayer"], "venue": "Bioinformatics, 22(8):943\u2013949", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2006}, {"title": "Multi-column deep neural networks for image classification", "author": ["D.C. Ciresan", "U. Meier", "J. Schmidhuber"], "venue": "IEEE Conference on Computer Vision and Pattern Recognition CVPR 2012", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2012}, {"title": "ImageNet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "F. Pereira, C. J. C. Burges, L. Bottou, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 25, pages 1097\u20131105. Curran Associates, Inc.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2012}, {"title": "Deeply-Supervised Nets", "author": ["C.-Y. Lee", "S. Xie", "P. Gallagher", "Z. Zhang", "Z. Tu"], "venue": "ArXiv e-prints", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2014}, {"title": "On information and sufficiency", "author": ["S. Kullback", "R.A. Leibler"], "venue": "Annals of Mathematical Statistics, 22:79\u2013 86", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1951}, {"title": "Confidence-weighted linear classification", "author": ["M. Dredze", "K. Crammer", "F. Pereira"], "venue": "Proceedings of the 25th international conference on Machine learning (ICML08), volume 25, pages 264\u2013271. ACM New York", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2008}, {"title": "Confidence-weighted linear classification for text categorization", "author": ["M. Dredze", "K. Crammer", "F. Pereira"], "venue": "Journal of Machine Learning Research, 13(1):1891\u20131926", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2012}, {"title": "Trace inequalities involving hermitian matrices", "author": ["R. Patel", "M. Toda"], "venue": "Linear Algebra and its Applications, 23:13\u201320", "citeRegEx": "37", "shortCiteRegEx": null, "year": 1979}, {"title": "A variational bayesian method for rectified factor analysis", "author": ["M. Harva", "A. Kaban"], "venue": "Proc. Int. Joint Conf. on Neural Networks (IJCNN\u201905), pages 185\u2013190", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2005}, {"title": "Posterior vs. parameter sparsity in latent variable models", "author": ["J.V. Graca", "K. Ganchev", "B. Taskar", "F. Pereira"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2009}, {"title": "Expectation maximization and posterior constraints", "author": ["J.V. Graca", "K. Ganchev", "B. Taskar"], "venue": "Advances in Neural Information Processing Systems,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2007}, {"title": "A view of the EM algorithm that justifies incremental", "author": ["R. Neal", "G.E. Hinton"], "venue": "sparse, and other variants. In M. I. Jordan, editor, Learning in Graphical Models, pages 355\u2013368. MIT Press, Cambridge, MA", "citeRegEx": "41", "shortCiteRegEx": null, "year": 1998}, {"title": "Statistical Mechanics", "author": ["R.P. Feynman"], "venue": "Benjamin, Reading, MA", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1972}, {"title": "A free energy principle for biological systems", "author": ["K. Friston"], "venue": "Entropy, 14:2100\u20132121", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2012}, {"title": "On the convergence properties of the EM algorithm", "author": ["C.F.J. Wu"], "venue": "Annals of Statistics, 11(1):95\u2013103", "citeRegEx": "44", "shortCiteRegEx": null, "year": 1983}, {"title": "J", "author": ["E.G. Birgin"], "venue": "M. Mart\u0131\u0301nez, and M. Raydan. Nonmonotone spectral projected gradient methods on convex sets. Siam Journal on Optimization, 10(4):1196\u20131211", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2000}, {"title": "Gradient projection methods for quadratic programs and applications in training support vector machines", "author": ["T. Serafini", "G. Zanghirati", "L. Zanni"], "venue": "Optimization Methods and Software, 20(2-3):353\u2013378", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2005}, {"title": "A new projected quasi-Newton approach for the nonnegative least squares problem", "author": ["D. Kim", "S. Sra", "I.S. Dhillon"], "venue": "Technical Report TR-06-54, Department of Computer Sciences, University of Texas at Austin", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2006}, {"title": "Maxout networks", "author": ["I.J. Goodfellow", "D. Warde-Farley", "M. Mirza", "A. Courville", "Y. Bengio"], "venue": "ArXiv e-prints", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2013}, {"title": "Fractional max-pooling", "author": ["Benjamin Graham"], "venue": "CoRR, abs/1412.6071,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2014}], "referenceMentions": [{"referenceID": 0, "context": "1 Introduction The success of deep learning is to a large part based on advanced and efficient input representations [1, 2, 3, 4].", "startOffset": 117, "endOffset": 129}, {"referenceID": 1, "context": "1 Introduction The success of deep learning is to a large part based on advanced and efficient input representations [1, 2, 3, 4].", "startOffset": 117, "endOffset": 129}, {"referenceID": 2, "context": "1 Introduction The success of deep learning is to a large part based on advanced and efficient input representations [1, 2, 3, 4].", "startOffset": 117, "endOffset": 129}, {"referenceID": 3, "context": "1 Introduction The success of deep learning is to a large part based on advanced and efficient input representations [1, 2, 3, 4].", "startOffset": 117, "endOffset": 129}, {"referenceID": 4, "context": "Sparse representations of the input are in general obtained by rectified linear units (ReLU) [5, 6] and dropout [7].", "startOffset": 93, "endOffset": 99}, {"referenceID": 5, "context": "Sparse representations of the input are in general obtained by rectified linear units (ReLU) [5, 6] and dropout [7].", "startOffset": 93, "endOffset": 99}, {"referenceID": 6, "context": "Sparse representations of the input are in general obtained by rectified linear units (ReLU) [5, 6] and dropout [7].", "startOffset": 112, "endOffset": 115}, {"referenceID": 7, "context": "In bioinformatics sparse codes excelled in biclustering of gene expression data [8] and in finding DNA sharing patterns between humans and Neanderthals [9].", "startOffset": 80, "endOffset": 83}, {"referenceID": 8, "context": "In bioinformatics sparse codes excelled in biclustering of gene expression data [8] and in finding DNA sharing patterns between humans and Neanderthals [9].", "startOffset": 152, "endOffset": 155}, {"referenceID": 9, "context": "For example, generative models with rectified priors, like rectified factor analysis, have zero posterior probability for negative values, therefore their means are positive and not sparse [10, 11].", "startOffset": 189, "endOffset": 197}, {"referenceID": 10, "context": "For example, generative models with rectified priors, like rectified factor analysis, have zero posterior probability for negative values, therefore their means are positive and not sparse [10, 11].", "startOffset": 189, "endOffset": 197}, {"referenceID": 11, "context": "To address the data dependence of the code, we employ the posterior regularization method [12].", "startOffset": 90, "endOffset": 94}, {"referenceID": 12, "context": "For non-Gaussian priors, the computation of the posterior mean of a new input requires either to numerically solve an integral or to iteratively update variational parameters [13].", "startOffset": 175, "endOffset": 179}, {"referenceID": 11, "context": "These E-step and M-step modifications of the posterior regularization method result in a generalized alternating minimization (GAM) algorithm [12].", "startOffset": 142, "endOffset": 146}, {"referenceID": 11, "context": "The constraints on the input representation are enforced by the posterior regularization method [12].", "startOffset": 96, "endOffset": 100}, {"referenceID": 11, "context": ",vn}, the posterior regularization method maximizes the objective F [12]: F = 1 n n \u2211", "startOffset": 68, "endOffset": 72}, {"referenceID": 11, "context": "(1) [12].", "startOffset": 4, "endOffset": 8}, {"referenceID": 13, "context": "Therefore, we perform a step of the gradient projection algorithm [14, 15], which performs first a gradient step and then projects the result to the feasible set.", "startOffset": 66, "endOffset": 74}, {"referenceID": 14, "context": "Therefore, we perform a step of the gradient projection algorithm [14, 15], which performs first a gradient step and then projects the result to the feasible set.", "startOffset": 66, "endOffset": 74}, {"referenceID": 15, "context": "We start by a step of the projected Newton method, then we try the gradient projection algorithm, thereafter the scaled gradient projection algorithm with reduced matrix [16] (see also [15]).", "startOffset": 170, "endOffset": 174}, {"referenceID": 14, "context": "We start by a step of the projected Newton method, then we try the gradient projection algorithm, thereafter the scaled gradient projection algorithm with reduced matrix [16] (see also [15]).", "startOffset": 185, "endOffset": 189}, {"referenceID": 16, "context": "(3), we use the generalized reduced method [17].", "startOffset": 43, "endOffset": 47}, {"referenceID": 17, "context": "Alternatively, we use Rosen\u2019s gradient projection method [18] or its improvement [19].", "startOffset": 57, "endOffset": 61}, {"referenceID": 18, "context": "Alternatively, we use Rosen\u2019s gradient projection method [18] or its improvement [19].", "startOffset": 81, "endOffset": 85}, {"referenceID": 19, "context": "In contrast, a quadratic program solver typically requires for the (nl) variables (the means of the hidden units for all samples) O(nl) steps to find the minimum [20].", "startOffset": 162, "endOffset": 166}, {"referenceID": 20, "context": "The resulting algorithm is a posterior regularization method with a gradient based E- and M-step, leading to a generalized alternating minimization (GAM) algorithm [21].", "startOffset": 164, "endOffset": 168}, {"referenceID": 20, "context": "1 is a GAM algorithm which convergences according to Proposition 5 in [21].", "startOffset": 70, "endOffset": 74}, {"referenceID": 20, "context": "Proposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, thus updates of the RFN algorithm are viewed as point-to-set mappings [22].", "startOffset": 17, "endOffset": 21}, {"referenceID": 21, "context": "Proposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, thus updates of the RFN algorithm are viewed as point-to-set mappings [22].", "startOffset": 148, "endOffset": 152}, {"referenceID": 22, "context": "The trace norm of a positive semi-definite matrix is its trace and bounds the Frobenius norm [23].", "startOffset": 93, "endOffset": 97}, {"referenceID": 23, "context": "We compare (1) RFN: rectified factor networks, (2) RFNn: RFNs without normalization, (3) DAE: denoising autoencoders with ReLUs, (4) RBM: restricted Boltzmann machines with Gaussian visible units, (5) FAsp: factor analysis with Jeffrey\u2019s prior (p(z) \u221d 1/z) on the hidden units which is sparser than a Laplace prior, (6) FAlap: factor analysis with Laplace prior on the hidden units, (7) ICA: independent component analysis by FastICA [24], (8) SFA: sparse factor analysis with a Laplace prior on the parameters, (9) FA: standard factor analysis, (10) PCA: principal component analysis.", "startOffset": 434, "endOffset": 438}, {"referenceID": 7, "context": "Into these matrices, biclusters are implanted [8].", "startOffset": 46, "endOffset": 49}, {"referenceID": 12, "context": "The variational approximation to the Laplacian is a Gaussian distribution [13].", "startOffset": 74, "endOffset": 78}, {"referenceID": 24, "context": "The benchmark datasets and results are taken from previous publications [25, 26, 27, 28] and contain: (i) MNIST (original MNIST), (ii) basic (a smaller subset of MNIST for training), (iii) bg-rand (MNIST with random noise background), (iv) bg-img (MNIST with random image background), (v) rect (discrimination between tall and wide rectangles), (vi) rect-img (discrimination between tall and wide rectangular images overlayed on random background images), (vii) convex (discrimination between convex and concave shapes), (viii) CIFAR-10 (60k color images in 10 classes), and (ix) NORB (29,160 stereo image pairs of 5 generic categories).", "startOffset": 72, "endOffset": 88}, {"referenceID": 25, "context": "The benchmark datasets and results are taken from previous publications [25, 26, 27, 28] and contain: (i) MNIST (original MNIST), (ii) basic (a smaller subset of MNIST for training), (iii) bg-rand (MNIST with random noise background), (iv) bg-img (MNIST with random image background), (v) rect (discrimination between tall and wide rectangles), (vi) rect-img (discrimination between tall and wide rectangular images overlayed on random background images), (vii) convex (discrimination between convex and concave shapes), (viii) CIFAR-10 (60k color images in 10 classes), and (ix) NORB (29,160 stereo image pairs of 5 generic categories).", "startOffset": 72, "endOffset": 88}, {"referenceID": 26, "context": "The benchmark datasets and results are taken from previous publications [25, 26, 27, 28] and contain: (i) MNIST (original MNIST), (ii) basic (a smaller subset of MNIST for training), (iii) bg-rand (MNIST with random noise background), (iv) bg-img (MNIST with random image background), (v) rect (discrimination between tall and wide rectangles), (vi) rect-img (discrimination between tall and wide rectangular images overlayed on random background images), (vii) convex (discrimination between convex and concave shapes), (viii) CIFAR-10 (60k color images in 10 classes), and (ix) NORB (29,160 stereo image pairs of 5 generic categories).", "startOffset": 72, "endOffset": 88}, {"referenceID": 27, "context": "The benchmark datasets and results are taken from previous publications [25, 26, 27, 28] and contain: (i) MNIST (original MNIST), (ii) basic (a smaller subset of MNIST for training), (iii) bg-rand (MNIST with random noise background), (iv) bg-img (MNIST with random image background), (v) rect (discrimination between tall and wide rectangles), (vi) rect-img (discrimination between tall and wide rectangular images overlayed on random background images), (vii) convex (discrimination between convex and concave shapes), (viii) CIFAR-10 (60k color images in 10 classes), and (ix) NORB (29,160 stereo image pairs of 5 generic categories).", "startOffset": 72, "endOffset": 88}, {"referenceID": 25, "context": "Model selection is based on the validation set performance [26].", "startOffset": 59, "endOffset": 63}, {"referenceID": 24, "context": "001}, Table 2: Results of deep networks pretrained by RFNs and other models (taken from [25, 26, 27, 28]).", "startOffset": 88, "endOffset": 104}, {"referenceID": 25, "context": "001}, Table 2: Results of deep networks pretrained by RFNs and other models (taken from [25, 26, 27, 28]).", "startOffset": 88, "endOffset": 104}, {"referenceID": 26, "context": "001}, Table 2: Results of deep networks pretrained by RFNs and other models (taken from [25, 26, 27, 28]).", "startOffset": 88, "endOffset": 104}, {"referenceID": 27, "context": "001}, Table 2: Results of deep networks pretrained by RFNs and other models (taken from [25, 26, 27, 28]).", "startOffset": 88, "endOffset": 104}, {"referenceID": 25, "context": "Fine-tuning was stopped based on the validation set performance, following [26].", "startOffset": 75, "endOffset": 79}, {"referenceID": 25, "context": "The test error rates together with the 95% confidence interval (computed according to [26]) for deep network pretraining by RFNs and other methods are given in Tab.", "startOffset": 86, "endOffset": 90}, {"referenceID": 28, "context": "Using RFNs we analyzed gene expression datasets of two projects in the lead optimization phase of a big pharmaceutical company [29].", "startOffset": 127, "endOffset": 131}, {"referenceID": 29, "context": "In both projects, the expression data was summarized by FARMS [30] and standardized.", "startOffset": 62, "endOffset": 66}, {"referenceID": 28, "context": "Both findings were not detected by other unsupervised methods, while they were highly relevant and supported decision-making in both projects [29].", "startOffset": 142, "endOffset": 146}, {"referenceID": 0, "context": "References [1] G.", "startOffset": 11, "endOffset": 14}, {"referenceID": 1, "context": "[2] Y.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] J.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4] Y.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5] V.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6] X.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7] N.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] S.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9] S.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[10] B.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] M.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] K.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[14] D.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15] C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] D.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[17] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19] E.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[20] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[22] W.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[23] N.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[24] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[25] Y.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[26] P.", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "[27] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "[28] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "[29] B.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "[30] S.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "5 in [15]) .", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "1 in [15]) .", "startOffset": 5, "endOffset": 9}, {"referenceID": 30, "context": "Finally, Section S14 describes experiments, that we have done to assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [31, 32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-InNetwork (5C-NIN).", "startOffset": 213, "endOffset": 221}, {"referenceID": 31, "context": "Finally, Section S14 describes experiments, that we have done to assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [31, 32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-InNetwork (5C-NIN).", "startOffset": 213, "endOffset": 221}, {"referenceID": 32, "context": "Finally, Section S14 describes experiments, that we have done to assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [31, 32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-InNetwork (5C-NIN).", "startOffset": 261, "endOffset": 265}, {"referenceID": 16, "context": "This approach is called \u201cgeneralized reduced gradient method\u201d [17], which is our preferred alternative method.", "startOffset": 62, "endOffset": 66}, {"referenceID": 17, "context": "If this method fails, then Rosen\u2019s gradient projection method [18] is used.", "startOffset": 62, "endOffset": 66}, {"referenceID": 18, "context": "Finally, the method of Haug and Arora [19] is used.", "startOffset": 38, "endOffset": 42}, {"referenceID": 20, "context": "However, in [21] it is shown how to generalize the GAM convergence proof to mini-batches as it is shown for the incremental EM algorithm.", "startOffset": 12, "endOffset": 16}, {"referenceID": 16, "context": "Algorithm S3 Projection with E-Step Improvement Goal obtain \u03bc i = \u03bci that decrease the E-step objective Input \u03a3 = \u03a3p, \u03a3 = \u03a3 p for 1 \u2264 i \u2264 n: (\u03bcp)i, \u03bc i , pi = N ((\u03bcp)i,\u03a3p) simple projection P (rectified or rectified & normalized), E-step objective: O = 1 n \u2211n i=1DKL(Qi \u2016 pi) \u03b3min, \u03bbmin, \u03c1\u03b3 , \u03c1\u03bb, (for -active set) Main \u2014\u2013Simple Projection\u2014\u2014 perform Newton Projection by Algorithm S5 or Algorithm S4 \u2014\u2013Scaled Projection\u2014\u2014 if 0 \u2264 \u2206O then following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Newton Projection by Algorithm S6 end while end if \u2014\u2013Scaled Projection With Reduced Matrix\u2014\u2014 if 0 \u2264 \u2206O then determine -active set as all j with \u03bcj \u2264 setH to \u03a3\u22121 p with -active columns and rows j fixed to ej following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Projection With Reduced Matrix by Algorithm S7 end while end if \u2014\u2013General Gradient Projection\u2014\u2014 while 0 \u2264 \u2206O do use generalized reduced gradient [17] OR use Rosen\u2019s gradient projection [18] OR use method of Haug and Arora [19] end while", "startOffset": 1181, "endOffset": 1185}, {"referenceID": 17, "context": "Algorithm S3 Projection with E-Step Improvement Goal obtain \u03bc i = \u03bci that decrease the E-step objective Input \u03a3 = \u03a3p, \u03a3 = \u03a3 p for 1 \u2264 i \u2264 n: (\u03bcp)i, \u03bc i , pi = N ((\u03bcp)i,\u03a3p) simple projection P (rectified or rectified & normalized), E-step objective: O = 1 n \u2211n i=1DKL(Qi \u2016 pi) \u03b3min, \u03bbmin, \u03c1\u03b3 , \u03c1\u03bb, (for -active set) Main \u2014\u2013Simple Projection\u2014\u2014 perform Newton Projection by Algorithm S5 or Algorithm S4 \u2014\u2013Scaled Projection\u2014\u2014 if 0 \u2264 \u2206O then following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Newton Projection by Algorithm S6 end while end if \u2014\u2013Scaled Projection With Reduced Matrix\u2014\u2014 if 0 \u2264 \u2206O then determine -active set as all j with \u03bcj \u2264 setH to \u03a3\u22121 p with -active columns and rows j fixed to ej following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Projection With Reduced Matrix by Algorithm S7 end while end if \u2014\u2013General Gradient Projection\u2014\u2014 while 0 \u2264 \u2206O do use generalized reduced gradient [17] OR use Rosen\u2019s gradient projection [18] OR use method of Haug and Arora [19] end while", "startOffset": 1221, "endOffset": 1225}, {"referenceID": 18, "context": "Algorithm S3 Projection with E-Step Improvement Goal obtain \u03bc i = \u03bci that decrease the E-step objective Input \u03a3 = \u03a3p, \u03a3 = \u03a3 p for 1 \u2264 i \u2264 n: (\u03bcp)i, \u03bc i , pi = N ((\u03bcp)i,\u03a3p) simple projection P (rectified or rectified & normalized), E-step objective: O = 1 n \u2211n i=1DKL(Qi \u2016 pi) \u03b3min, \u03bbmin, \u03c1\u03b3 , \u03c1\u03bb, (for -active set) Main \u2014\u2013Simple Projection\u2014\u2014 perform Newton Projection by Algorithm S5 or Algorithm S4 \u2014\u2013Scaled Projection\u2014\u2014 if 0 \u2264 \u2206O then following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Newton Projection by Algorithm S6 end while end if \u2014\u2013Scaled Projection With Reduced Matrix\u2014\u2014 if 0 \u2264 \u2206O then determine -active set as all j with \u03bcj \u2264 setH to \u03a3\u22121 p with -active columns and rows j fixed to ej following loop for: (1) \u03b3, (2) \u03bb, or (3) \u03b3 and \u03bb annealing \u03b3 = \u03bb = 1 while 0 \u2264 \u2206O and \u03bb > \u03bbmin and \u03b3 > \u03b3min do \u03b3 = \u03c1\u03b3 \u03b3 (skipped for \u03bb annealing) \u03bb = \u03c1\u03bb \u03bb (skipped for \u03b3 annealing) perform Scaled Projection With Reduced Matrix by Algorithm S7 end while end if \u2014\u2013General Gradient Projection\u2014\u2014 while 0 \u2264 \u2206O do use generalized reduced gradient [17] OR use Rosen\u2019s gradient projection [18] OR use method of Haug and Arora [19] end while", "startOffset": 1258, "endOffset": 1262}, {"referenceID": 33, "context": "DKL denotes the Kullback-Leibler (KL) divergence [34], which is larger than or equal to zero.", "startOffset": 49, "endOffset": 53}, {"referenceID": 20, "context": "From the modification of the E-step and the M-step follows that Algorithm S2 is a Generalized Alternating Minimization (GAM) algorithm according to [21].", "startOffset": 148, "endOffset": 152}, {"referenceID": 20, "context": "The most important requirements for the convergence of the GAM algorithm according to Theorem 7 (Proposition 5 in [21]) are the increase of the objective F in both the E-step and the M-step.", "startOffset": 114, "endOffset": 118}, {"referenceID": 16, "context": "To optimize such problems, the generalized reduced gradient method [17] solves each equality constraint for one variable and inserts it into the objective.", "startOffset": 67, "endOffset": 71}, {"referenceID": 17, "context": "For rectifying and normalizing constraints, also Rosen\u2019s [18] and Haug & Arora\u2019s [19] gradient projection method ensures a decrease of the E-step objective since they can be applied to non-convex problems.", "startOffset": 57, "endOffset": 61}, {"referenceID": 18, "context": "For rectifying and normalizing constraints, also Rosen\u2019s [18] and Haug & Arora\u2019s [19] gradient projection method ensures a decrease of the E-step objective since they can be applied to non-convex problems.", "startOffset": 81, "endOffset": 85}, {"referenceID": 20, "context": "We show that the requirements as given in Section S7 for GAM convergence according to Theorem 7 (Proposition 5 in [21]) are fulfilled: 1.", "startOffset": 114, "endOffset": 118}, {"referenceID": 34, "context": "the E-step has a unique maximizer \u2212\u2192 ensured by the convex, continuous, and continuous differentiable function that is minimized [35, 36] together with compact feasible set for the", "startOffset": 129, "endOffset": 137}, {"referenceID": 35, "context": "the E-step has a unique maximizer \u2212\u2192 ensured by the convex, continuous, and continuous differentiable function that is minimized [35, 36] together with compact feasible set for the", "startOffset": 129, "endOffset": 137}, {"referenceID": 20, "context": "Since this Proposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, updates of the RFN algorithm are viewed as point-to-set mappings [22].", "startOffset": 28, "endOffset": 32}, {"referenceID": 21, "context": "Since this Proposition 5 in [21] is based on Zangwill\u2019s generalized convergence theorem, updates of the RFN algorithm are viewed as point-to-set mappings [22].", "startOffset": 154, "endOffset": 158}, {"referenceID": 21, "context": "A theorem analog to Theorem 7 but with E-step and M-step conditions exchanged can be derived from Zangwill\u2019s generalized convergence theorem [22].", "startOffset": 141, "endOffset": 145}, {"referenceID": 20, "context": "Therefore the solution of the GAM optimization does not guarantee stationary points in likelihood [21].", "startOffset": 98, "endOffset": 102}, {"referenceID": 36, "context": "(37) The inequality uses the fact that for positive definite matrices A and B inequality Tr(AB) \u2264 Tr(A)Tr(B) holds [37].", "startOffset": 115, "endOffset": 119}, {"referenceID": 22, "context": "The trace norm of a positive semi-definite matrix is its trace and bounds the Frobenius norm [23].", "startOffset": 93, "endOffset": 97}, {"referenceID": 33, "context": "DKL denotes the Kullback-Leibler (KL) divergence [34] which is larger than zero.", "startOffset": 49, "endOffset": 53}, {"referenceID": 9, "context": "However these posteriors do not have sparse means (they must be positive), that is, they do not yield sparse codes [10].", "startOffset": 115, "endOffset": 119}, {"referenceID": 37, "context": "For example, rectified factor analysis, which rectifies Gaussian priors and selects models using a variational Bayesian learning procedure, does not yield posteriors with sparse means [38, 11].", "startOffset": 184, "endOffset": 192}, {"referenceID": 10, "context": "For example, rectified factor analysis, which rectifies Gaussian priors and selects models using a variational Bayesian learning procedure, does not yield posteriors with sparse means [38, 11].", "startOffset": 184, "endOffset": 192}, {"referenceID": 11, "context": "Therefore we use the posterior regularization method (posterior constraint method) [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 38, "context": "Therefore we use the posterior regularization method (posterior constraint method) [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 39, "context": "Therefore we use the posterior regularization method (posterior constraint method) [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 33, "context": "We use the Kullback-Leibler (KL) divergence [34] DKL to measure the distance between these distributions.", "startOffset": 44, "endOffset": 48}, {"referenceID": 11, "context": "We obtain the objective F (to be maximized) of the posterior constraint method [12, 39, 40]:", "startOffset": 79, "endOffset": 91}, {"referenceID": 38, "context": "We obtain the objective F (to be maximized) of the posterior constraint method [12, 39, 40]:", "startOffset": 79, "endOffset": 91}, {"referenceID": 39, "context": "We obtain the objective F (to be maximized) of the posterior constraint method [12, 39, 40]:", "startOffset": 79, "endOffset": 91}, {"referenceID": 40, "context": "In the variational framework,Q is the variational distribution andF is called the negative free energy [41].", "startOffset": 103, "endOffset": 107}, {"referenceID": 41, "context": "This physical term is used since variational methods were introduced for quantum physics by Richard Feynman [42].", "startOffset": 108, "endOffset": 112}, {"referenceID": 42, "context": "The hidden variables can be considered as the fictive causes or explanations of environmental fluctuations [43].", "startOffset": 107, "endOffset": 111}, {"referenceID": 20, "context": "Instead of the EM algorithm we use the Generalized Alternating Minimization (GAM) algorithm [21] to allow for gradient descent both in the M-step and the E-step.", "startOffset": 92, "endOffset": 96}, {"referenceID": 11, "context": "To impose constraints on the posterior is known as the posterior constraint method [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 38, "context": "To impose constraints on the posterior is known as the posterior constraint method [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 39, "context": "To impose constraints on the posterior is known as the posterior constraint method [12, 39, 40].", "startOffset": 83, "endOffset": 95}, {"referenceID": 20, "context": "Gunawardana and Byrne showed that the GAM converges [21] (see also [44]).", "startOffset": 52, "endOffset": 56}, {"referenceID": 43, "context": "Gunawardana and Byrne showed that the GAM converges [21] (see also [44]).", "startOffset": 67, "endOffset": 71}, {"referenceID": 20, "context": "The following GAM convergence Theorem 7 is Proposition 5 in [21] and proves the convergence of the GAM algorithm to a solution that minimizes \u2212F .", "startOffset": 60, "endOffset": 64}, {"referenceID": 20, "context": "Then, (1) the point-to-set map FB is closed on D\u2032 \u00d7\u0398 (2) FB(D\u2032 \u00d7\u0398) \u2286 D \u00d7\u0398 and FB satisfies the GAM and EQ conditions of the GAM convergence theorem, that is, Theorem 3 in [21].", "startOffset": 171, "endOffset": 175}, {"referenceID": 20, "context": "See Proposition 5 in [21].", "startOffset": 21, "endOffset": 25}, {"referenceID": 34, "context": "The objective for the E-step is strict convex in all its parameters for the variational distributions, simultaneously [35, 36].", "startOffset": 118, "endOffset": 126}, {"referenceID": 35, "context": "The objective for the E-step is strict convex in all its parameters for the variational distributions, simultaneously [35, 36].", "startOffset": 118, "endOffset": 126}, {"referenceID": 20, "context": "Therefore the solution of the GAM optimization does not guarantee stationary points in likelihood [21].", "startOffset": 98, "endOffset": 102}, {"referenceID": 33, "context": "2 The Full E-step Objective The E-step maximizes F with respect to the variational distribution Q, therefore the E-step minimizes the Kullback-Leibler divergence (KL-divergence) [34] DKL(Q(h) \u2016 p(h | v)).", "startOffset": 178, "endOffset": 182}, {"referenceID": 34, "context": "This Kullback-Leibler divergence is convex in the mean vector \u03bcq and the covariance matrix \u03a3q of Q, simultaneously [35, 36].", "startOffset": 115, "endOffset": 123}, {"referenceID": 35, "context": "This Kullback-Leibler divergence is convex in the mean vector \u03bcq and the covariance matrix \u03a3q of Q, simultaneously [35, 36].", "startOffset": 115, "endOffset": 123}, {"referenceID": 16, "context": "To solve the each equality constraints for a variable and insert it into the objective is called generalized reduced gradient method [17].", "startOffset": 133, "endOffset": 137}, {"referenceID": 17, "context": "The gradient projection method has been generalized by Rosen to non-linear constraints [18] and was later improved by [19].", "startOffset": 87, "endOffset": 91}, {"referenceID": 18, "context": "The gradient projection method has been generalized by Rosen to non-linear constraints [18] and was later improved by [19].", "startOffset": 118, "endOffset": 122}, {"referenceID": 13, "context": "1 Gradient Projection Algorithm The projected gradient descent or gradient projection algorithm [14, 15] performs first a gradient step and then projects the result to the feasible set.", "startOffset": 96, "endOffset": 104}, {"referenceID": 14, "context": "1 Gradient Projection Algorithm The projected gradient descent or gradient projection algorithm [14, 15] performs first a gradient step and then projects the result to the feasible set.", "startOffset": 96, "endOffset": 104}, {"referenceID": 14, "context": "5 in [15].", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "5 in [15]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "See [15].", "startOffset": 4, "endOffset": 8}, {"referenceID": 44, "context": "(189) Improved methods for finding an appropriate \u03bb by line search methods have been proposed [45, 46].", "startOffset": 94, "endOffset": 102}, {"referenceID": 45, "context": "(189) Improved methods for finding an appropriate \u03bb by line search methods have been proposed [45, 46].", "startOffset": 94, "endOffset": 102}, {"referenceID": 16, "context": "A special version of the gradient projection method is the generalized reduced method [17].", "startOffset": 86, "endOffset": 90}, {"referenceID": 17, "context": "The gradient projection method has been generalized by Rosen to non-linear constraints [18].", "startOffset": 87, "endOffset": 91}, {"referenceID": 18, "context": "Rosen\u2019s gradient projection method was improved by [19].", "startOffset": 51, "endOffset": 55}, {"referenceID": 15, "context": "2 Scaled Gradient Projection and Projected Newton Method Both the scaled gradient projection algorithm and the projected Newton method were proposed in [16].", "startOffset": 152, "endOffset": 156}, {"referenceID": 14, "context": "We follow [15].", "startOffset": 10, "endOffset": 14}, {"referenceID": 15, "context": "If we setH\u22121 = \u03a3p, then we have a Newton update of the projected Newton method [16].", "startOffset": 79, "endOffset": 83}, {"referenceID": 14, "context": "1 in [15].", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "1 in [15]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "See [15].", "startOffset": 4, "endOffset": 8}, {"referenceID": 15, "context": "The projected Newton method uses \u03bb = 1 to set [16]: = \u2016\u03bck \u2212 P (\u03bcp) \u2016 .", "startOffset": 46, "endOffset": 50}, {"referenceID": 46, "context": "3 Combined Method Following [47, 46] we use the following very general update rule, which includes the gradient projection algorithm, the scaled gradient projection algorithm, and the projected Newton method.", "startOffset": 28, "endOffset": 36}, {"referenceID": 45, "context": "3 Combined Method Following [47, 46] we use the following very general update rule, which includes the gradient projection algorithm, the scaled gradient projection algorithm, and the projected Newton method.", "startOffset": 28, "endOffset": 36}, {"referenceID": 14, "context": "ensures an improvement if only using rectifying constraints according to the theory of projected Newton methods [15].", "startOffset": 112, "endOffset": 116}, {"referenceID": 23, "context": "S11 Hyperparameters Selected for Method Assessment The performance of rectified factor networks (RFNs) as unsupervised methods for data representation was compared with: (1) RFN: rectified factor networks, (2) RFNn: RFNs without normalization, (3) DAE: denoising autoencoders with rectified linear units, (4) RBM: restricted Boltzmann machines with Gaussian visible units and hidden binary units, (5) FAsp: factor analysis with Jeffrey\u2019s prior (p(z) \u221d 1/z) on the hidden units which is sparser than a Laplace prior, (6) FAlap: factor analysis with Laplace prior on the hidden units, (7) ICA: independent component analysis by FastICA [24], (8) SFA: sparse factor analysis with a Laplace prior on the parameters, (9) FA: standard factor analysis, (10) PCA: principal component analysis.", "startOffset": 634, "endOffset": 638}, {"referenceID": 7, "context": "Into these data matrices, structures are implanted as biclusters [8].", "startOffset": 65, "endOffset": 68}, {"referenceID": 31, "context": "S14 RFN Pretraining for Convolution Nets We assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-In-Network (5C-NIN).", "startOffset": 192, "endOffset": 196}, {"referenceID": 32, "context": "S14 RFN Pretraining for Convolution Nets We assess the performance of RFN first layer pretraining on CIFAR-10 and CIFAR-100 for three deep convolutional network architectures: (i) the AlexNet [32], (ii) Deeply Supervised Networks (DSN) [33], and (iii) our 5-Convolution-Network-In-Network (5C-NIN).", "startOffset": 236, "endOffset": 240}, {"referenceID": 47, "context": "Both datasets are preprocessed by global contrast normalization and ZCA whitening [48].", "startOffset": 82, "endOffset": 86}, {"referenceID": 27, "context": "For weight initialization, learning rates, and learning policies we used same strategy as in the AlexNet [28].", "startOffset": 105, "endOffset": 109}, {"referenceID": 47, "context": "For comparison, the lower panel of the table reports the performance of the currently top performing networks: Network In Network (NIN, [49]), Maxout Networks (MN, [48]) and DeepCNiN [50].", "startOffset": 164, "endOffset": 168}, {"referenceID": 48, "context": "For comparison, the lower panel of the table reports the performance of the currently top performing networks: Network In Network (NIN, [49]), Maxout Networks (MN, [48]) and DeepCNiN [50].", "startOffset": 183, "endOffset": 187}], "year": 2015, "abstractText": "We propose rectified factor networks (RFNs) to efficiently construct very sparse, non-linear, high-dimensional representations of the input. RFN models identify rare and small events in the input, have a low interference between code units, have a small reconstruction error, and explain the data covariance structure. RFN learning is a generalized alternating minimization algorithm derived from the posterior regularization method which enforces non-negative and normalized posterior means. We proof convergence and correctness of the RFN learning algorithm. On benchmarks, RFNs are compared to other unsupervised methods like autoencoders, RBMs, factor analysis, ICA, and PCA. In contrast to previous sparse coding methods, RFNs yield sparser codes, capture the data\u2019s covariance structure more precisely, and have a significantly smaller reconstruction error. We test RFNs as pretraining technique for deep networks on different vision datasets, where RFNs were superior to RBMs and autoencoders. On gene expression data from two pharmaceutical drug discovery studies, RFNs detected small and rare gene modules that revealed highly relevant new biological insights which were so far missed by other unsupervised methods.", "creator": "LaTeX with hyperref package"}}}