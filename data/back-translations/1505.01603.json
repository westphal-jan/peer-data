{"id": "1505.01603", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-May-2015", "title": "Best-First and Depth-First Minimax Search in Practice", "abstract": "Most practitioners use a variant of the Alpha Beta Algorithm, a simple \"depth first\" approach to searching Minimax trees. SSS *, with its best search strategy, reportedly offers the potential for a more efficient search. However, the complex formulation of the algorithm and its alleged excessive storage requirements preclude its use in practice. For two decades, the search efficiency of the \"smart\" Best-First-SSS * has cast doubt on the effectiveness of the \"stupid\" Alpha Beta Initial Search. This paper provides a simple framework for invoking Alpha Beta that allows us to develop a variety of algorithms, including SSS * and DUAL *. In reality, we are formulating a best-first algorithm using depth search. Expressed within this framework, SSS * is just a special case of Alpha Beta where all the perceived disadvantages of the algorithm are resolved. In practice, Alpha Beta Beta Beta variants typically rate this beta node as SMD *.", "histories": [["v1", "Thu, 7 May 2015 06:54:26 GMT  (357kb)", "http://arxiv.org/abs/1505.01603v1", "Computer Science in the Netherlands 1995. arXiv admin note: text overlap witharXiv:1404.1515"]], "COMMENTS": "Computer Science in the Netherlands 1995. arXiv admin note: text overlap witharXiv:1404.1515", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["aske plaat", "jonathan schaeffer", "wim pijls", "arie de bruin"], "accepted": false, "id": "1505.01603"}, "pdf": {"name": "1505.01603.pdf", "metadata": {"source": "CRF", "title": "Best-First and Depth-First Minimax Search in Practice", "authors": ["Aske Plaat", "Wim Pijls", "Arie de Bruin"], "emails": ["plaat@theory.lcs.mit.edu", "jonathan@cs.ualberta.ca", "whlmp@cs.few.eur.nl", "arie@cs.few.eur.nl"], "sections": [{"heading": null, "text": "This paper presents a simple framework for calling Alpha-Beta that allows us to create a variety of algorithms, including SSS* and DUAL*. In effect, we formulate a best-first algorithm using depth-first search. Expressed in this framework SSS* is just a special case of Alpha-Beta, solving all of the perceived drawbacks of the algorithm. In practice, Alpha-Beta variants typically evaluate less nodes than SSS*. A new instance of this framework, MTD(\u0192), out-performs SSS* and NegaScout, the Alpha-Beta variant of choice by practitioners."}, {"heading": "1 Introduction", "text": "Game playing is one of the classic problems of artificial intelligence. Searching for the best move in a zero-sum game is known as minimax search. The study of minimax search algorithms has created ideas that have proved useful in many search domains. For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14]. Although two-agent search has many more application areas, the best-known is undoubtedly game playing, the application that we shall be using in this paper.\nOver the last thirty years, most practitioners used depth-first search algorithms based on Alpha-Beta [10] for their game-playing programs. There is an exponential gap in the size of trees built by best-case and worst-case Alpha-Beta. This led to numerous enhancements to the basic algorithm, including iterative deepening, transposition tables, the history heuristic and narrow search windows (see for example [31] for an assessment). Although best-first approaches have been successful in other search domains, minimax search in practice has been almost exclusively based on depth-first strategies. Best-first approaches were more complex and\nreportedly required more memory, both being serious impediments to their general acceptance. SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33]. Despite the potential, the algorithm remains largely ignored in practice.\nThis paper presents the surprising result that best-first SSS* can be reformulated as a special case of depth-first Alpha-Beta. Consequently, SSS* is now easily implemented in existing Alpha-Beta-based game-playing programs, solving all of the perceived drawbacks of the algorithm. Experiments conducted with three tournament-quality game-playing programs show that in practice SSS* requires as much memory as Alpha-Beta. When given identical memory resources, SSS* does not evaluate significantly less nodes than Alpha-Beta. It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice. In effect the reasons for ignoring SSS* have been eliminated, but the reasons for using it are gone too!\nThe ideas at the basis of the SSS* reformulation are generalized to create a framework for best-first fixed-depth minimax search that is based on depth-first null-window Alpha-Beta calls. A number of other algorithms in the literature, including DUAL* and C*, are just special cases of this framework. A new instance of this framework, MTD(\u0192), out-performs all other minimax search algorithms.\nIn the new framework, SSS* is equivalent to a special case of Alpha-Beta and it is outperformed by other Alpha-Beta variants (both best-first and depth-first). In light of this, we believe that SSS* should now become a footnote in the history of game-tree search."}, {"heading": "2 Null-Window Search and Memory", "text": "In the Alpha-Beta procedure, a node is searched with a search window. It is well-known that the narrower the search window, the more nodes can be cutoff [16]. The narrowest window possible is the null window, where = 1 (assuming integer-valued leaves). Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30]. The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26]. A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].\nKnuth and Moore have shown that the return value g of an Alpha-Beta search with window , can be one of three things [10]:\n1. < g < . g is equal to the minimax value \u0192 of the game tree G.\n2. g (failing low). g is an upper bound on the minimax value \u0192 of G, or \u0192 g.\n3. g (failing high). g is a lower bound on the minimax value \u0192 of G, or \u0192 g.\nKnuth and Moore have shown that the essential part of the search tree that proves the minimax value is the minimal tree [10]. For a minimax tree of uniform width w and depth d, it has w d/2 + w d/2 1 leaves, or, its size is O(w d/2 ). If Alpha-Beta returns an upper bound, then its value is defined by a max solution tree, in a sense one half of a minimal tree, of size O(w d/2 ). If Alpha-Beta returns a lower bound, then its value is defined by a min solution tree, the other half of a minimal tree, of size O(w d/2 ). The theoretical background for these statements can be found in [7, 13, 25, 33].\nA single null-window search will never return the true minimax value \u0192, but only a bound on it (which may happen to coincide with \u0192, but this cannot be inferred from the result of the nullwindow call). A fail low results in an upper bound, denoted by \u0192+. A fail high returns a lower\nbound, denoted by \u0192 . Algorithms like C* and Alpha Bounding use multiple null-window calls to generate bounds to home in on the minimax value. A potential problem with these repetitive calls is that they re-expand previously searched nodes. For NegaScout it appears that the gains of the tighter bounds out-weigh the costs of re-expansions, compared to a single wide-window Alpha-Beta call [21].\nAn idea to prevent the re-expansion of previously searched nodes is to store them in memory. It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29]. For game-playing programs an obvious choice is to use a transposition table for storage [31]. Originally the transposition table was introduced to prevent the search of transpositions in the search space. A transposition is a node with more than one parent, a position that can be reached via several move sequences. Today, transposition tables are often used in combination with iterative deepening [16]. The main benefit of this combination is to improve the quality of move ordering [15].\nStoring information from previous searches is another use of the transposition table. The only difference with preventing the search of transpositions is that now the table entries are nodes from a previous search pass; there is no difference as far as the table itself is concerned. The basic idea is that it is possible to store the search tree in the transposition table. Some background explaining in greater detail why the transposition table is a suitable structure for storing search or solution trees, and why it gives correct results in algorithms doing repetitive null-window searches, can be found in [7, 25].\nSince recursive null-window Alpha-Beta calls return only bounds, storing the previous search results comes down to storing a max or a min solution tree. We have shown in [25] that although the search information that must be stored is indeed of exponential size, it is much less than what is often assumed. For the search depths typically reached by tournamentquality game-playing programs, the search information fits comfortably in today\u2019s memories. Projections of tomorrow\u2019s search depths and memory sizes show that this situation will persist in the foreseeable future."}, {"heading": "3 A Framework for Best-First Search", "text": "The concept of null-window Alpha-Beta search was introduced by Pearl with his proof-procedure Test [20]. Since we use memory to store intermediate search information, we have named our framework Memory-enhanced Test, or MT. As proof procedure we use a standard null-window Alpha-Beta procedure for use with transposition tables. The code can be found in figure 1.\nSo far, we have discussed the following two mechanisms to be used in building efficient algorithms: (1) null-window searches cutoff more nodes than wide search windows, and (2) transposition tables can be used to glue multiple Alpha-Beta passes together. We can use these building blocks to construct a number of different algorithms. An option is to construct drivers that repeatedly call Alpha-Beta at the root of the game tree. Three of these drivers are shown in the figures 2 and 3. The drivers differ in the way the null window is chosen (denoted by in the figures)."}, {"heading": "3.1 SSS*", "text": "The driver to the left in figure 2 constructs an algorithm that starts with an upper bound of + . From Alpha-Beta\u2019s postcondition we see that this call will fail low, yielding an upper bound. By feeding this upper bound \u0192+ again to a null-window Alpha-Beta call, we will get a sequence of fail lows. In the end, if g = , we will have a fail high with g = \u0192 = = \u0192+, which means the\nminimax value \u0192 has been found. This driver expands the same leaf nodes in the same order as Stockman\u2019s SSS* [33]. (A full proof of this claim can be found in [22] and an outline of the proof in [25].) In this sense, we have constructed an equivalent formulation of SSS*, constructing a best-first algorithm using depth-first, memory-enhanced, search. The reformulation is called AB-SSS*.\nMany researchers have conjectured that best-first algorithms such as SSS* would need too much memory to be practical alternatives for depth-first algorithms like Alpha-Beta. The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33]. The new formulation has a number of practical advantages over the old Stockman formulation. The biggest advantage is that this formulation is readily implementable in a regular Alpha-Betabased game-playing program. This enables us to easily test the performance of SSS* These tests confirm that SSS* does not need too much memory [25].\nWe think that our reformulation as a sequence of null-window Alpha-Beta calls is easy to understand. SSS*\u2019s slow OPEN list operations are traded in for hash table lookups that are as fast as for Alpha-Beta [16], and the experiments show that AB-SSS* does not need too much memory. We conclude that the drawbacks of SSS* are solved in the new formulation."}, {"heading": "3.2 DUAL*", "text": ""}, {"heading": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at", "text": "instead of + [17, 26]. The power of the framework is demonstrated by the reformulation called AB-DUAL* in figure 2. The only difference with AB-SSS* is the initialization of the bound to , and a change in the way Alpha-Beta is called. This reformulation focuses attention on one item only: the bound starts at the bottom of the scale, implying that the only fundamental difference between SSS* and DUAL* is that upper bounds are replaced by lower bounds (which implies that the max solution tree that is refined by AB-SSS* has become a min solution tree in AB-DUAL*). All other differences are apparently insubstantial, since nothing else has to be changed."}, {"heading": "3.3 Other Options for the choice of Start Value", "text": "AB-SSS* starts the sequence of Alpha-Beta searches at + , the high end of the scale. ABDUAL* starts at , the low end of the scale. An intuitively appealing option is to choose another start value, closer to the expected outcome. One option is to keep bisecting the interval between the upper and lower bound, to reduce the number of Alpha-Beta calls. This idea is used in C* [6, 23, 34]. Another idea is to use a heuristic guess as the start value. In an iterative deepening framework it is natural to use the score from the previous iteration for this purpose, since it is expected to be a close approximation of the score for the current depth. We have called this driver MTD(\u0192) and its pseudo code is shown in figure 3. The first call acts to decide which way the search will go. If it is a fail high, MTD(\u0192) will behave like AB-DUAL*, and keep increasing the lower bound returned by Alpha-Beta. If the first call fails low, MTD(\u0192) will,\nlike AB-SSS*, decrease the upper bound until the minimax value is reached. AB-SSS* starts off optimistic, AB-DUAL* starts off pessimistic, and MTD(\u0192) starts off in the middle, possibly realistic.\nOne of the drawbacks of AB-SSS* and AB-DUAL* is the potentially high number of calls to Alpha-Beta needed until the search converges to the minimax value. Most of the AlphaBeta calls make small improvements to the bound. By starting closer to the minimax value, many intermediate Alpha-Beta calls are skipped. MTD(\u0192) takes one big leap to come close to the minimax value, dramatically reducing the number of intermediate Alpha-Beta calls. The lower number of calls has the advantage that MTD(\u0192) performs relatively better in constrained memory than SSS*, since there are fewer re-expansions. Measurements confirm that AlphaBeta typically gets called 3 to 6 times in MTD(\u0192). In contrast, the AB-SSS* and AB-DUAL* results are poor compared to NegaScout when all nodes in the search tree are considered. Each of these algorithms performs dozens and often even hundreds of Alpha-Beta searches. The wider the range of leaf values, the smaller the steps with which they converge, and the more re-searches they need."}, {"heading": "4 Performance", "text": "To assess the performance of the proposed algorithms in practice, a series of experiments was conducted. We present data for the comparison of Alpha-Beta, NegaScout, AB-SSS*, AB-DUAL*, and MTD(\u0192)."}, {"heading": "4.1 Experiment Design", "text": "We will assess the performance of the algorithms by counting leaf nodes and total nodes. For two algorithms we also provide data for execution time. This metric may vary considerably for different programs. It is nevertheless included, to give evidence of the potential of MTD(\u0192).\nWe have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers. Chess has a branching factor of about 35, Othello of about 10 and checkers of about 3. Thus we cover the range from a wide to a narrow branching factor. This paper presents results for chess; the results for the other games (which are similar and confirm the chess results) can be found in [25]. All algorithms used iterative deepening. They are repeatedly called with successively deeper search depths. All three algorithms use a standard transposition table with a maximum of 221 entries; tests showing that the solution trees could comfortably fit in tables of this size, without any risk of noise due to collisions [25]. For our experiments we used the original program author\u2019s transposition table data structures and code without modification. At an interior node, the move suggested by the transposition table is always searched first (if known), and the remaining moves are ordered before being searched. Phoenix uses dynamic ordering based on the history heuristic [31].\nConventional test sets in the literature proved to be inadequate to model real-life conditions. Positions in test sets are usually selected to test a particular characteristic or property of the game (such as tactical combinations in chess) and are not necessarily indicative of typical game conditions. For our experiments, the algorithms were tested using a set of 20 positions that corresponded to move sequences from tournament games. By selecting move sequences rather than isolated positions, we are attempting to create a test set that is representative of real game search properties (including positions with obvious moves, hard moves, positional moves, tactical moves, different game phases, etc.). A number of test runs was performed on a bigger test set and to a higher search depth to check that the 20 positions did not contain anomalies.\nMany papers in the literature use Alpha-Beta as the base-line for comparing the performance of other algorithms (for example, [5, 15]). The implication is that this is the standard data point which everyone is trying to beat. However, game-playing programs have evolved beyond simple Alpha-Beta algorithms. Most use Alpha-Beta enhanced with null-window search (NegaScout), iterative deepening, transposition tables, move ordering and an initial aspiration window. Since this is the typical search algorithm used in high-performance programs (such as Phoenix), it seems more reasonable to use this as our base-line. The worse the base-line comparison algorithm chosen, the better other algorithms appear to be. By choosing NegaScout enhanced with aspiration searching [2] (Aspiration NegaScout) as our performance metric, and giving it a transposition table big enough to contain all re-search information, we are emphasizing that it is possible to do better than the \u201cbest\u201d methods currently practiced and that, contrary to published simulation results, some methods\u2014notably SSS*\u2014will turn out to be inferior.\nSince we implemented the algorithms (like AB-SSS* and AB-DUAL*) using Alpha-Beta we were able to compare a number of algorithms that were previously seen as very different. By using Alpha-Beta as a common procedure, every algorithm benefited from the same enhancements concerning iterative deepening, transposition tables and move ordering code. To our knowledge this is the first comparison of depth-first and best-first minimax search algorithms where all the algorithms are given identical resources."}, {"heading": "4.2 Results", "text": "Figure 4 shows the performance of Phoenix using the number of leaf evaluations (NBP or Number of Bottom Positions) as the performance metric. Figure 5 shows the performance of the algorithms using the number of nodes in the search tree (interior and leaf, including nodes that caused transposition cutoffs) as the metric. The graphs show the cumulative number of nodes over all previous iterations for a certain depth (which is realistic since iterative deepening is used) relative to Aspiration NegaScout. Note the different vertical scales."}, {"heading": "4.2.1 Aspiration NegaScout and MTD(\u0192)", "text": "The results show that Aspiration NegaScout is better than Alpha-Beta. This result is consistent with [31] which showed Aspiration NegaScout to be a small improvement over Alpha-Beta\nwhen transposition tables and iterative deepening were used. MTD(\u0192) is a best-first algorithm that consists solely of null-window searches. In each pass, the previous one is used to guide the search towards selecting the best node. The majority of the searches in NegaScout is also performed with a null window. An important difference is with which value this null-window search is performed. NegaScout derives it from the tree itself, whereas MTD(\u0192) relies for the first guess on information from outside the tree. (In our experiments the minimax value from a previous iterative deepening iteration was used for this purpose.)\nThe best results are from MTD(\u0192), although the current algorithm of choice by the game programming community, Aspiration NegaScout, performs very well too. The averaged MTD(\u0192) leaf node counts are consistently better than for Aspiration NegaScout, averaging around a 10% improvement for Phoenix. More surprisingly is that MTD(\u0192) outperforms Aspiration NegaScout on the total node measure as well. Since each iteration requires repeated calls to Alpha-Beta (at least two and possibly many more), one might expect MTD(\u0192) to perform badly by this measure\nbecause of the repeated traversals of the tree. This suggests that MTD(\u0192), on average, is calling Alpha-Beta close to the minimum number of times. A deeper analysis of MTD(\u0192) can be found in [25]."}, {"heading": "4.2.2 SSS* and DUAL*", "text": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small. Since game-playing programs use many search enhancements, the benefits of a best-first search are greatly reduced. We conclude that in practice, AB-SSS* is a small improvement on Alpha-Beta for leaf nodes only (depending on the branching factor). Claims that SSS* and DUAL* evaluate significantly fewer leaf nodes than Alpha-Beta are based on simplifying assumptions that have little relation with what is used in practice. Aspiration NegaScout regularly out-performs SSS* on leaf count and greatly out-performs it on total nodes."}, {"heading": "4.3 Execution time", "text": "The bottom line for practitioners is execution time. We only show execution time graphs for iterative deepening (ID) MTD(\u0192) and ID Aspiration NegaScout (figure 6). Comparing results for the same machines we found that MTD(\u0192) is consistently the fastest algorithm. The run shown is a typical example run on a Sun SPARC. We did experience different timings when running on different machines. It may well be that cache size plays an important role, and that tuning of the program can have a considerable impact.\nIn our experiments we found that for Phoenix MTD(\u0192) was about 9\u201313% faster in execution time than Aspiration NegaScout. For other programs and other machines these results will obviously differ, depending in part on the quality of the score of the previous iteration, and on the test positions used. Also, since the tested algorithms perform quite close together, the relative differences are quite sensitive to variations in input parameters. In generalizing these results, one should keep this sensitivity in mind. Using these numbers as absolute predictors for other situations would not do justice to the complexities of real life game trees. The experimental data is better suited to provide insight on, or guide and verify hypotheses about these complexities."}, {"heading": "4.4 Artificial versus Real Trees", "text": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33]. They typically found SSS* to out-perform Alpha-Beta significantly. Our experiments were performed with practical programs, that enhance the basic minimax algorithms with techniques like iterative deepening and transposition tables. The result is that in practice SSS* does not out-perform Alpha-Beta significantly. It is often out-performed by depth-first Alpha-Beta variants such as NegaScout.\nSimulations are usually performed when it is too difficult or too expensive to construct the proper experimental environment. For game-tree searching, the case for simulations is weak. There is no need to do simulations when there are quality game-playing programs available for obtaining actual data. Further, simulation parameters can be incorrect, resulting in large errors in the results that lead to misleading conclusions."}, {"heading": "5 Conclusions", "text": "Null-window search, enhanced with storage, can be used to construct best-first minimax algorithms. For storage a conventional transposition table can be used. The null-window calls\ngenerate a sequence of bounds on the minimax value. The storage contains the part of the search tree that establishes these bounds, to be refined in subsequent passes.\nA framework has been presented for algorithms that generate sequences of bounds in different ways. Interestingly, certain instances of this framework expand the same leaf nodes in the same order as SSS* and DUAL*. These algorithms, called AB-SSS* and AB-DUAL*, solve the perceived problems of SSS* and DUAL*. They are much simpler and practical, consisting of a single loop of Alpha-Beta calls.\nWe used tournament game-playing programs for our tests. Using the Alpha-Beta-based framework, both depth-first and best-first algorithms are given the same storage, in contrast to previous comparisons. The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].\nWe tested instances of the framework against the depth-first algorithm implemented in our programs, Aspiration NegaScout, representing the current choice of the game programming community. One instance, MTD(\u0192), out-performs NegaScout on leaf node count, total node count and execution time, by a wider margin than NegaScout\u2019s gain over Alpha-Beta. The results reported in this paper are for chess, a game with a relatively high branching factor. We have conducted experiments for two other games as well. The results for checkers and Othello, games with a narrow and medium branching factor, confirm these results [25].\nInterestingly, all the tested algorithms perform relatively close together, much closer than previous simulation results have indicated. We conclude that, a) artificially-generated game trees often do not capture all the essential aspects of real trees, and b) often more gains are obtained from the so-called Alpha-Beta enhancements, than from the underlying algorithms.\nIn the past, much research effort has been devoted to understanding how SSS* works, and finding out what the pros and cons of SSS*\u2019s best-first approach are for minimax search. In the new framework, SSS* is equivalent to a special case of Alpha-Beta and it is out-performed by other Alpha-Beta variants (both best-first and depth-first). In light of this, we believe that SSS* should now become a footnote in the history of game-tree search.\nHaving seen these results for minimax search, it is an interesting question to find out whether formulating best-first search using depth-first procedures is possible in single-agent search as well."}, {"heading": "Acknowledgements", "text": "Some of these results were originally published in [24]. This work has benefited from discussions with Mark Brockington, Yngvi Bjornsson and Andreas Junghanns. The support of Jaap van den Herik, and the financial support of the Netherlands Organization for Scientific Research (NWO), the Tinbergen Institute, the Natural Sciences and Engineering Research Council of Canada (NSERC grant OGP-5183) and the University of Alberta Central Research Fund are gratefully acknowledged."}], "references": [{"title": "The Design and Analysis of Algorithms for Asynchronous Multiprocessors", "author": ["G\u00e9rard M. Baudet"], "venue": "PhD thesis,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1978}, {"title": "Asynchronous Parallel Game-Tree Search", "author": ["Mark Brockington"], "venue": "PhD thesis,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1994}, {"title": "Algorithms for the parallel search of game trees", "author": ["Murray Campbell"], "venue": "Master\u2019s thesis,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1981}, {"title": "A comparison of minimax tree search algorithms", "author": ["Murray S. Campbell", "T. Anthony Marsland"], "venue": "Artificial Intelligence,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1983}, {"title": "A special-purpose machine for an improved search algorithm for deep chess combinations", "author": ["K. Coplan"], "venue": "Advances in Computer Chess", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1981}, {"title": "Solution trees as a basis for game-tree search", "author": ["Arie de Bruin", "Wim Pijls", "Aske Plaat"], "venue": "ICCA Journal,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1994}, {"title": "Analysis of Speedup in Distributed Algorithms", "author": ["John P. Fishburn"], "venue": "PhD thesis,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1981}, {"title": "Minimax search algorithms with and without aspiration windows", "author": ["Hermann Kaindl", "Reza Shams", "Helmut Horacek"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1991}, {"title": "An analysis of alpha-beta pruning", "author": ["Donald E. Knuth", "Ronald W. Moore"], "venue": "Artificial Intelligence,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1975}, {"title": "Iterative deepening: An optimal admissible tree search", "author": ["Richard E. Korf"], "venue": "Artificial Intelligence,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1985}, {"title": "Real-time heuristic search", "author": ["Richard E. Korf"], "venue": "Artificial Intelligence,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1990}, {"title": "A general branch and bound formulation for and/or graph and game tree search", "author": ["Vipin Kumar", "Laveen N. Kanal"], "venue": "In Search in Artificial Intelligence. Springer Verlag,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1988}, {"title": "BS*: An admissible bidirectional staged heuristic search algorithm", "author": ["J.B.H. Kwa"], "venue": "Artificial Intelligence,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1989}, {"title": "A review of game-tree pruning", "author": ["T. Anthony Marsland"], "venue": "ICCA Journal,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1986}, {"title": "Parallel search of strongly ordered game trees", "author": ["T. Anthony Marsland", "Murray S. Campbell"], "venue": "Computing Surveys,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1982}, {"title": "Low overhead alternatives to SSS", "author": ["T. Anthony Marsland", "Alexander Reinefeld", "Jonathan Schaeffer"], "venue": "Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1987}, {"title": "An empirical comparison of pruning strategies in game trees", "author": ["Agata Muszycka", "Rajjan Shinghal"], "venue": "IEEE Transactions on Systems, Man and Cybernetics,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1985}, {"title": "Asymptotical properties of minimax trees and game searching procedures", "author": ["Judea Pearl"], "venue": "Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1980}, {"title": "The solution for the branching factor of the alpha-beta pruning algorithm and its optimality", "author": ["Judea Pearl"], "venue": "Communications of the ACM,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1982}, {"title": "Heuristics \u2013 Intelligent Search Strategies for Computer Problem Solving", "author": ["Judea Pearl"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1984}, {"title": "Solution trees as a unifying concept for game tree algorithms", "author": ["Wim Pijls", "Arie de Bruin", "Aske Plaat"], "venue": "Technical Report EUR-CS-95-01, Erasmus University, Department of Computer Science, P.O. Box 1738,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1995}, {"title": "A new paradigm for minimax search", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "Technical Report TR-CS-94-18,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1994}, {"title": "Best-first fixed-depth game-tree search in practice", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-95),", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1995}, {"title": "A minimax algorithm better than Alpha-Beta? no and yes", "author": ["Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin"], "venue": "Technical Report 95-15,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1995}, {"title": "Spielbaum Suchverfahren", "author": ["Alexander Reinefeld"], "venue": "Informatik-Fachberichte 200. Springer Verlag,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1989}, {"title": "Time-efficient state space search", "author": ["Alexander Reinefeld", "Peter Ridinger"], "venue": "Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1994}, {"title": "Information acquisition in minimal window search", "author": ["Alexander Reinefeld", "Jonathan Schaeffer", "T. Anthony Marsland"], "venue": "In Proceeding of the International Joint Conference on Artificial Intelligence (IJCAI-85),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1985}, {"title": "A minimax algorithm better than alpha-beta", "author": ["Igor Roizen", "Judea Pearl"], "venue": "Yes and no. Artificial Intelligence,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1983}, {"title": "Experiments in Search and Knowledge", "author": ["Jonathan Schaeffer"], "venue": "PhD thesis, Department of Computing Science, University of Waterloo, Canada,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1986}, {"title": "The history heuristic and alpha-beta search enhancements in practice", "author": ["Jonathan Schaeffer"], "venue": "IEEE Transactions on Pattern Analysis and Machine Intelligence,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1989}, {"title": "A world championship caliber checkers program", "author": ["Jonathan Schaeffer", "Joseph Culberson", "Norman Treloar", "Brent Knight", "Paul Lu", "Duane Szafron"], "venue": "Artificial Intelligence,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1992}, {"title": "A minimax algorithm better than alpha-beta", "author": ["George C. Stockman"], "venue": "Artificial Intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1979}, {"title": "The NegaC* search", "author": ["Jean-Christophe Weill"], "venue": "ICCA Journal,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1992}], "referenceMentions": [{"referenceID": 9, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 94, "endOffset": 98}, {"referenceID": 10, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 124, "endOffset": 128}, {"referenceID": 12, "context": "For example, this research extends to single-agent search, such as iterative deepening (IDA*) [11], real-time search (RTA*) [12] and bidirectional search [14].", "startOffset": 154, "endOffset": 158}, {"referenceID": 8, "context": "Over the last thirty years, most practitioners used depth-first search algorithms based on Alpha-Beta [10] for their game-playing programs.", "startOffset": 102, "endOffset": 106}, {"referenceID": 29, "context": "This led to numerous enhancements to the basic algorithm, including iterative deepening, transposition tables, the history heuristic and narrow search windows (see for example [31] for an assessment).", "startOffset": 176, "endOffset": 180}, {"referenceID": 2, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 7, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 14, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 24, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 31, "context": "SSS*, a best-first algorithm, will provably never build larger trees than Alpha-Beta and generally builds significantly smaller trees [4, 9, 16, 26, 33].", "startOffset": 134, "endOffset": 152}, {"referenceID": 6, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 26, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 24, "context": "It is typically out-performed by NegaScout [8, 28, 26], the current depth-first Alpha-Beta variant of choice.", "startOffset": 43, "endOffset": 54}, {"referenceID": 14, "context": "It is well-known that the narrower the search window, the more nodes can be cutoff [16].", "startOffset": 83, "endOffset": 87}, {"referenceID": 3, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 4, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 6, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 17, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 28, "context": "Many people have noted that null-window search has a great potential for creating efficient search algorithms [1, 5, 6, 8, 19, 30].", "startOffset": 110, "endOffset": 130}, {"referenceID": 6, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 18, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 24, "context": "The widely used NegaScout algorithm derives its superiority over AlphaBeta from null-window search [8, 20, 26].", "startOffset": 99, "endOffset": 110}, {"referenceID": 4, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 98, "endOffset": 105}, {"referenceID": 32, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 98, "endOffset": 105}, {"referenceID": 28, "context": "A number of algorithms have been proposed that are solely based on null-window search, such as C* [6, 34] and Alpha Bounding [30].", "startOffset": 125, "endOffset": 129}, {"referenceID": 8, "context": "Knuth and Moore have shown that the return value g of an Alpha-Beta search with window , can be one of three things [10]:", "startOffset": 116, "endOffset": 120}, {"referenceID": 8, "context": "Knuth and Moore have shown that the essential part of the search tree that proves the minimax value is the minimal tree [10].", "startOffset": 120, "endOffset": 124}, {"referenceID": 5, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 11, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 23, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 31, "context": "The theoretical background for these statements can be found in [7, 13, 25, 33].", "startOffset": 64, "endOffset": 79}, {"referenceID": 19, "context": "For NegaScout it appears that the gains of the tighter bounds out-weigh the costs of re-expansions, compared to a single wide-window Alpha-Beta call [21].", "startOffset": 149, "endOffset": 153}, {"referenceID": 7, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 16, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 27, "context": "It is often said that since minimax trees are of exponential size, this approach is infeasible since it needs exponentially growing amounts of memory [9, 18, 29].", "startOffset": 150, "endOffset": 161}, {"referenceID": 29, "context": "For game-playing programs an obvious choice is to use a transposition table for storage [31].", "startOffset": 88, "endOffset": 92}, {"referenceID": 14, "context": "Today, transposition tables are often used in combination with iterative deepening [16].", "startOffset": 83, "endOffset": 87}, {"referenceID": 13, "context": "The main benefit of this combination is to improve the quality of move ordering [15].", "startOffset": 80, "endOffset": 84}, {"referenceID": 5, "context": "Some background explaining in greater detail why the transposition table is a suitable structure for storing search or solution trees, and why it gives correct results in algorithms doing repetitive null-window searches, can be found in [7, 25].", "startOffset": 237, "endOffset": 244}, {"referenceID": 23, "context": "Some background explaining in greater detail why the transposition table is a suitable structure for storing search or solution trees, and why it gives correct results in algorithms doing repetitive null-window searches, can be found in [7, 25].", "startOffset": 237, "endOffset": 244}, {"referenceID": 23, "context": "We have shown in [25] that although the search information that must be stored is indeed of exponential size, it is much less than what is often assumed.", "startOffset": 17, "endOffset": 21}, {"referenceID": 18, "context": "The concept of null-window Alpha-Beta search was introduced by Pearl with his proof-procedure Test [20].", "startOffset": 99, "endOffset": 103}, {"referenceID": 31, "context": "This driver expands the same leaf nodes in the same order as Stockman\u2019s SSS* [33].", "startOffset": 77, "endOffset": 81}, {"referenceID": 20, "context": "(A full proof of this claim can be found in [22] and an outline of the proof in [25].", "startOffset": 44, "endOffset": 48}, {"referenceID": 23, "context": "(A full proof of this claim can be found in [22] and an outline of the proof in [25].", "startOffset": 80, "endOffset": 84}, {"referenceID": 7, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 15, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 16, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 24, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 27, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 31, "context": "The literature cites three main drawbacks of SSS*: it is hard to understand, it performs operations on a sorted list that are slow, and it uses too much memory to be practical [9, 17, 18, 26, 29, 33].", "startOffset": 176, "endOffset": 199}, {"referenceID": 23, "context": "This enables us to easily test the performance of SSS* These tests confirm that SSS* does not need too much memory [25].", "startOffset": 115, "endOffset": 119}, {"referenceID": 14, "context": "SSS*\u2019s slow OPEN list operations are traded in for hash table lookups that are as fast as for Alpha-Beta [16], and the experiments show that AB-SSS* does not need too much memory.", "startOffset": 105, "endOffset": 109}, {"referenceID": 15, "context": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at instead of + [17, 26].", "startOffset": 199, "endOffset": 207}, {"referenceID": 24, "context": "A dual version of SSS*, aptly named DUAL*, can be created by inverting SSS*\u2019s operations: use an ascendingly sorted list instead of descending, swap max and min operations, and start at instead of + [17, 26].", "startOffset": 199, "endOffset": 207}, {"referenceID": 4, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 21, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 32, "context": "This idea is used in C* [6, 23, 34].", "startOffset": 24, "endOffset": 35}, {"referenceID": 28, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 178, "endOffset": 182}, {"referenceID": 1, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 201, "endOffset": 204}, {"referenceID": 30, "context": "We have tried to come as close to real-life applications of our algorithms as possible by conducting the experiments with three tournament-quality game-playing programs, Phoenix [30] for chess, Keyano [3] for Othello and Chinook [32] for checkers.", "startOffset": 229, "endOffset": 233}, {"referenceID": 23, "context": "This paper presents results for chess; the results for the other games (which are similar and confirm the chess results) can be found in [25].", "startOffset": 137, "endOffset": 141}, {"referenceID": 23, "context": "All three algorithms use a standard transposition table with a maximum of 221 entries; tests showing that the solution trees could comfortably fit in tables of this size, without any risk of noise due to collisions [25].", "startOffset": 215, "endOffset": 219}, {"referenceID": 29, "context": "Phoenix uses dynamic ordering based on the history heuristic [31].", "startOffset": 61, "endOffset": 65}, {"referenceID": 3, "context": "Many papers in the literature use Alpha-Beta as the base-line for comparing the performance of other algorithms (for example, [5, 15]).", "startOffset": 126, "endOffset": 133}, {"referenceID": 13, "context": "Many papers in the literature use Alpha-Beta as the base-line for comparing the performance of other algorithms (for example, [5, 15]).", "startOffset": 126, "endOffset": 133}, {"referenceID": 0, "context": "By choosing NegaScout enhanced with aspiration searching [2] (Aspiration NegaScout) as our performance metric, and giving it a transposition table big enough to contain all re-search information, we are emphasizing that it is possible to do better than the \u201cbest\u201d methods currently practiced and that, contrary to published simulation results, some methods\u2014notably SSS*\u2014will turn out to be inferior.", "startOffset": 57, "endOffset": 60}, {"referenceID": 29, "context": "This result is consistent with [31] which showed Aspiration NegaScout to be a small improvement over Alpha-Beta", "startOffset": 31, "endOffset": 35}, {"referenceID": 23, "context": "A deeper analysis of MTD(\u0192) can be found in [25].", "startOffset": 44, "endOffset": 48}, {"referenceID": 2, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 7, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 15, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 16, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 24, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 25, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 27, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 31, "context": "Contrary to many simulations [4, 9, 17, 18, 26, 27, 29, 33], our results show that the difference in the number of leaves expanded by SSS* and Alpha-Beta is relatively small.", "startOffset": 29, "endOffset": 59}, {"referenceID": 2, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 7, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 15, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 16, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 24, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 25, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 27, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 31, "context": "Previously, performance assessments of SSS* and Alpha-Beta have mainly been based on simulations [4, 9, 17, 18, 26, 27, 29, 33].", "startOffset": 97, "endOffset": 127}, {"referenceID": 7, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 15, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 27, "context": "The results confirm that AB-SSS* and AB-DUAL* are practical algorithms, contradicting previous publications [9, 17, 29].", "startOffset": 108, "endOffset": 119}, {"referenceID": 23, "context": "The results for checkers and Othello, games with a narrow and medium branching factor, confirm these results [25].", "startOffset": 109, "endOffset": 113}, {"referenceID": 22, "context": "Some of these results were originally published in [24].", "startOffset": 51, "endOffset": 55}], "year": 1998, "abstractText": "Most practitioners use a variant of the Alpha-Beta algorithm, a simple depth-first procedure, for searching minimax trees. SSS*, with its best-first search strategy, reportedly offers the potential for more efficient search. However, the complex formulation of the algorithm and its alleged excessive memory requirements preclude its use in practice. For two decades, the search efficiency of \u201csmart\u201d best-first SSS* has cast doubt on the effectiveness of \u201cdumb\u201d depth-first Alpha-Beta. This paper presents a simple framework for calling Alpha-Beta that allows us to create a variety of algorithms, including SSS* and DUAL*. In effect, we formulate a best-first algorithm using depth-first search. Expressed in this framework SSS* is just a special case of Alpha-Beta, solving all of the perceived drawbacks of the algorithm. In practice, Alpha-Beta variants typically evaluate less nodes than SSS*. A new instance of this framework, MTD(\u0192), out-performs SSS* and NegaScout, the Alpha-Beta variant of choice by practitioners.", "creator": null}}}