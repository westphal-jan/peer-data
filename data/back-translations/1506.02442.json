{"id": "1506.02442", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2015", "title": "NP-hardness of sortedness constraints", "abstract": "In constraint programming, global constraints allow modeling and solving many combinatorial problems. Among these constraints, several sort constraints have been defined for which propagation algorithms are available, but for which tractability is not clarified. We show that the sort constraint (U, V, P) is insoluble for integer variables whose domains are not limited to intervals. Consequently, the similar result applies to the sort constraint (U, V, P) (Zhou, 1996). Furthermore, intractability holds even under the stability condition that exists in the recently introduced key sorting (U, V, Keys, P) (Carlsson et al., 2014), and requires that the order of variables with the same value in the U list be maintained in List V. Thus, the key sorting (U, V, Keys, P) is also insoluble.", "histories": [["v1", "Mon, 8 Jun 2015 11:24:06 GMT  (38kb,D)", "http://arxiv.org/abs/1506.02442v1", "15 pages, 4 figures"]], "COMMENTS": "15 pages, 4 figures", "reviews": [], "SUBJECTS": "cs.CC cs.AI cs.DM", "authors": ["irena rusu"], "accepted": false, "id": "1506.02442"}, "pdf": {"name": "1506.02442.pdf", "metadata": {"source": "CRF", "title": "NP-hardness of sortedness constraints", "authors": ["Irena Rusu"], "emails": [], "sections": [{"heading": null, "text": "problems. Among these constraints, several sortedness constraints have been defined, for which propagation algorithms are available, but for which the tractability is not settled. We show that the sort(U, V ) constraint (Older et. al, 1995) is intractable (assuming P 6=NP) for integer variables whose domains are not limited to intervals. As a consequence, the similar result holds for the sort(U, V, P ) constraint (Zhou, 1996). Moreover, the intractability holds even under the stability condition present in the recently introduced keysorting(U, V,Keys, P ) constraint (Carlsson et al., 2014), and requiring that the order of the variables with the same value in the list U be preserved in the list V . Therefore, keysorting(U, V,Keys, P ) is intractable as well.\nKeywords: sortedness constraints; NP-hardness; graph matching"}, {"heading": "1 Introduction", "text": "Constraint programming systems support an increasing number of global constraints, i.e. constraints for which the number of variables is arbitrary. Such constraints define an important search space, that may be pruned using constraint propagation algorithms. Implementing a certain notion of consistency, a propagation algorithm removes infeasible values from the domains of the variables, and its efficiency is evaluated both with regard to its ability to limit the search space, and with regard to its running time. Dealing with global constraints in general, that is, without fixing a constraint (or a set of constraints), is intractable [1]. However, each constraint has its own complexity, which may range from tractability at all levels of consistency, as for the alldifferent constraint [15], to intractability at relatively low levels of consistency, as for linear equations [11].\nThe tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2]. Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.\nIn this paper we show that the intuitively simplest of these sortedness constraints, namely sort(U, V ), is intractable (unless P = NP ) even in the case where the domains of the variables in U are disjoint, and this leads to the intractability of sort(U, V, P ) and of keysorting(U, V,Keys, P ).\nThe organisation of the paper is as follows. In Section 2, we give the terminology and notations used in the paper. In Section 3, we transform, using ideas from [7], the search for a support of sort(U, V ) into a graph matching problem that we call SortSupport, and we show how to associate with each instance of the NP-complete problem Not-All-Equal 3SAT an instance of SortSupport. The next section is devoted to the proof that our construction is a polynomial transformation [4], implying the NP-completeness of SortSupport. In Section 5, we deduce hardness results about the three sortedness problems. Section 6 is the conclusion.\nar X\niv :1\n50 6.\n02 44\n2v 1\n[ cs\n.C C\n] 8\nJ un\n2 01\n5"}, {"heading": "2 Constraints and consistency", "text": "In this paper, we deal with constraints over integer domains. Given a variable w, we denote Dom(w) its domain, which is assumed to be a finite set of integers. When Dom(w) is written as an interval [l..r] (with integer l, r such that l \u2264 r) or a union of intervals, we understand that it contains only the integers in the (union of) interval(s), i.e. [l..r] is defined as [l..r] := {d \u2208 Z | l \u2264 d \u2264 r}.\nA constraint C is a couple (W,R), where W = {w1, w2, . . . , wt} is a set of variables with associated domains Dom(wi), and R is a t-ary relation over Z (equivalently, a subset of Zt). The constraint C = (W,R) is satisfied by a t-tuple \u03b4 = (\u03b41, \u03b42, . . . , \u03b4t) assigning the value \u03b4i to variable wi, 1 \u2264 i \u2264 t, if \u03b4 \u2208 R. Denote D := Dom(w1) \u00d7Dom(w2) \u00d7 . . . \u00d7Dom(wt). If C is satisfied by a t-tuple \u03b4 \u2208 D, then \u03b4 is a support of C.\nA constraint satisfaction problem (or CSP) is defined as a set of variables with their associated domains, and a set of constraints defined on subsets of the variable set. A solution of a CSP is an assignement of values from the associated domains to the variables that satisfies all the constraints. In order to solve a CSP, constraints are successively used to prune the search space, with the help of propagation algorithms that often seek to enforce various consistency properties, defined below (following [3]). A domain D is said domain consistent for the constraint C = (W,R) if, for each variable wi, 1 \u2264 i \u2264 t, and for each value \u03b4i \u2208 Dom(wi), there is a support of C assigning the value \u03b4i to wi. Domain consistency is a strong requirement, for which the following variants of bounds consistency are progressively weaker, but often very useful, alternatives.\nDenote infD(wi) and supD(wi) respectively the minimum and maximum value in Dom(wi). We say that a domain D is bounds(D) consistent for C if for each variable wi and for each value \u03b4i \u2208 {infD(wi), supD(wi)} there exist integers \u03b4j with \u03b4j \u2208 Dom(wj), 1 \u2264 j \u2264 t and j 6= i, such that (\u03b41, \u03b42, . . . , \u03b4t) satisfies C. We say that a domain D is bounds(Z) consistent for C if for each variable wi and for each value \u03b4i \u2208 {infD(wi), supD(wi)} there exist integers \u03b4j with infD(wj) \u2264 \u03b4j \u2264 infD(wj), 1 \u2264 j \u2264 t and j 6= i, such that (\u03b41, \u03b42, . . . , \u03b4t) satisfies C. Finally, we say that a domain D is bounds(R) consistent for C if for each variable wi and for each value \u03b4i \u2208 {infD(wi), supD(wi)} there exist real numbers \u03b4j with infD(wj) \u2264 \u03b4j \u2264 infD(wj), 1 \u2264 j \u2264 t and j 6= i, such that (\u03b41, \u03b42, . . . , \u03b4t) satisfies C.\nWe now define the sortedness constraints:\n\u2022 the sort(U, V ) constraint, defined in [9], has variable set U\u222aV , where U = {u1, u2, . . . , un} and V = {v1, v2, . . . , vn}, and is satisfied by a 2n-tuple of values assigned to the variables if and only if the variables in V are the sorted list of the variables in U . The correspondence between the variables in U and those in V is therefore a permutation. Propagation algorithms achieving bounds(Z)-consistency have been proposed in [5] and [7].\n\u2022 the sort(U, V, P ) constraint, defined in [16], generalizes the sort(U, V ) constraint by adding a set P of n variables with domains included in {1, 2, . . . , n} in order to bring the permutation into the variable set of the constraint. This constraint thus has variable set U \u222a V \u222aP and is satisfied by a 3n-tuple of values if and only if (a) the variables in V are the sorted list of the variables in U , (b) the variables in P are all distinct, and (c) the permutation associating the variables from U and V is the one defined by the variables in P . The propagation algorithms for the sort(U, V ) constraint are able to reduce the domains of the variables in U \u222aV similarly, but achieve bound(Z)-consistency only on the V -domains, and not on the U and P -domains [14].\n\u2022 the keysorting(U, V,Keys, P ) constraint (where Keys is a positive integer), defined in [2], allows to add two features with respect to sort(U, V, P ) : (a) each variable is a h-tuple (h \u2265 1 and integer, common to all variables), whose first Keys elements form the sorting key of the variable, using lexicographic ordering; and (b) the sorting has to be stable, i.e.\nany pair of variables with the same key value must have the same order in U and in V . The domain Dom(z) of any variable z from U \u222a V is thus a h-tuple of domains. When Keys = 1, the lexicographic order of the keys is the classical order between integers, and thus keysorting(U, V, 1, P ) is similar to sort(U, V, P ), except that it requires the stability of the sorting.\nGiven two non-empty sets of integers D and E, we write D \u2264lex E whenever there exist values d \u2208 D and e \u2208 E such that d \u2264 e. This is not (and is not intended to be) an order on sets, but allows to compare the domains of the variables with respect to the possibility to have a given order between the assigned values."}, {"heading": "3 Links between sortedness, graph matching and 3SAT", "text": "Consider two sets of variables U = {ui | 1 \u2264 i \u2264 n} and V = {vi | 1 \u2264 i \u2264 n}, with finite integer domains Dom(ui) and Dom(vi), for all i, 1 \u2264 i \u2264 n. Following [7], we define the intersection graph \u0393(U, V ) of U and V as the bipartite graph with vertex set U \u222a V and edge set {(ui, vj) |Dom(ui) \u2229 Dom(vj) 6= \u2205}. A matching of \u0393(U, V ) is an injective function \u03c3 : V \u2032 \u2286 V \u2192 U such that (\u03c3(v), v) is an edge of \u0393 for each v \u2208 V \u2032. We also use the notation M = {(\u03c3(v), v), v \u2208 V \u2032} to designate the same matching. A matching M saturates a vertex x if there exists an edge in M with endpoint x. We say that M is a perfect matching if it saturates all the vertices in \u0393(U, V ).\nDenote Qi = Dom(\u03c3(vi)) \u2229 Dom(vi), for each vi for which \u03c3(vi) is defined. Then testing whether sort(U, V ) has a support is equivalent to solving the following problem:\nSortSupport Instance: Two sets of variables U = {ui | 1 \u2264 i \u2264 n} and V = {vi | 1 \u2264 i \u2264 n}, with finite integer domains Dom(ui) and Dom(vi), for all i, 1 \u2264 i \u2264 n. Question: Is there a perfect matching \u03c3 : V \u2192 U of \u0393(U, V ) such that Qi 6= \u2205 for all i with\n1 \u2264 i \u2264 n and Q1 \u2264lex Q2 \u2264lex . . . \u2264lex Qn?\nWe show that SortSupport is NP-complete, and this even in the case where the domains Dom(ui), 1 \u2264 i \u2264 n, are disjoint. To this end, given \u0393(U, V ), a matching fulfilling the required conditions is called a sort-matching. Note that the order v1, v2, . . . , vn of the elements in V is important, since it defines the sort-matching.\nWe adapt the graph construction in [10], and therefore use the same notations. The reduction is from the NP-complete problem Not-All-Equal 3SAT [4], the variant of 3SAT in which each clause is required to have at least one true and at least one false literal.\nLet H = H1\u2227H2\u2227 . . .\u2227Hk be an instance of Not-All-Equal 3SAT, where each clause Hi, i = 1, 2, . . . , k, contains three literals from the set x1, x1, x2, x2, . . . , xp, xp. We assume that, for each j = 1, 2, . . . , p, the literal xj occurs in the instance H as many times as xj (otherwise, add to H an appropriate number of clauses (xj \u2228xj \u2228xj) or (xj \u2228xj \u2228xj)). We note occ(j) the total number of occurrences of xj in a clause, either as a positive occurrence (i.e. as xj) or as a negative occurrence (i.e. as xj).\nWe wish to build an instance U, V of SortSupport such that \u0393(U, V ) consists of:\n\u2022 a unit graph Gij (see Figure 1), for each positive or negative occurrence of a literal xj in a clause Hi. The vertices of Gij are the variables aij , bij , cij from U and (aij)\u2032, (bij)\u2032, (cij)\u2032 from V joined by the four edges (aij , (bij)\u2032), (bij , (cij)\u2032) (called up-edges), (bij , (aij)\u2032) and (cij , (bij)\u2032) (called down-edges). Unit graphs are positive or negative depending on the occurrence of xj they represent.\n\u2022 a consistency component CCj (see Figure 2) for each literal xj , connecting all unit graphs associated with positive and negative occurrences of xj . The unit graphs are arbitrarily ordered such that they correspond alternately to a positive and to a negative occurrence, the first unit graph being associated with a positive occurrence of xj . Up-linking edges join the aij vertex of a negative unit graph to the (crj)\u2032 vertex of the positive unit graph following it, in a circular way. Down-linking edges join the cij vertex of a positive unit graph to the (arj)\u2032 vertex of the negative unit graph following it.\n\u2022 a truth component Di (see Figure 3) for each clause Hi, connecting the three unit graphs associated with the literals in Hi. Note that the negative unit graphs are drawn with up-edges down, and vice versa. Four vertices di, ei (defined to be in U) and d\u2032i, e\u2032i (defined to be in V ) are added, the former ones joined to the (cij)\u2032 vertex of every negative unit graph and to the (aij)\u2032 vertex of every positive unit graph, whereas the latter ones are joined to the cij vertex of every negative unit graph and to the aij vertex of every positive unit graph. These edges are called lateral edges.\n\u2022 a completion component E providing, for each i with 1 \u2264 i \u2264 k, an edge between ei and each e\u2032j such that i 6= j.\nThe truth components allow to locally give truth values to the literals, whereas the consistency components guarantee that the locally given truth values are globally correct, that is, each literal is either true or false but not both. The completion component ensures the existence of a perfect matching in the graph. Notice that, if a clause Hi contains two (or more) occurrences\nof the same literal xj , then notations G i,1 j and G i,2 j should be used to identify the unit graph associated with each occurrence. We do not enter into such details in our presentation, in order to keep it as simple as possible.\nTo define the required order on the elements in V , we assume that in each unit graph the elements (aij)\u2032, (bij)\u2032, (cij)\u2032 are ranged in this order, and in each consistency component CCj unit graphs are ordered according to the alternate arbitrary order chosen to build CCj (recall that the first unit graph in CCj is positive). Then, the global order on V is built by considering the CC1, CC2, . . . , CCp consistency components in this order, and by adding vertices d\u20321, d\u20322, . . . , d\u2032k, e\u20321, e \u2032 2, . . . , e \u2032 k in this order at the end.\nExample. Let H = H1\u2227H2 with H1 : x1\u2228x2\u2228x3 and H2 : x1\u2228x2\u2228x3. Then the consistency component CC1 contains the unit graphs G21 (positive) and G11 (negative), in this order; CC2 contains G12 (positive) and G22 (negative), in this order; and CC3 contains G13 (positive) and G23 (negative), in this order. There are two truth componentsD1 andD2 corresponding respectively to H1 and H2. By definition, D1 includes the unit graphs G11, G12 and G13, whereas D2 contains the unit graphs G21, G22 and G23. The completion component has only two edges, (e2, e\u20321) and (e1, e \u2032 2). The order of the variables in V is (a21)\u2032, (b21)\u2032, (c21)\u2032, (a11)\u2032, (b11)\u2032, (c11)\u2032, (a12)\u2032, (b12)\u2032, (c12)\u2032, (a22) \u2032, (b22)\u2032, (c22)\u2032, (a13)\u2032, (b13)\u2032, (c13)\u2032, (a23)\u2032, (b23)\u2032, (c23)\u2032, d\u20321, d\u20322, e\u20321, e\u20322.\nTo finish our construction, we have to define the domains of the vertices in U and in V that exactly define the sought intersection graph \u0393(U, V ). To simplify the notations, the domain of a vertex is denoted similarly to the vertex, but with an upper case instead of a lower case, (e.g. Dom(aij) is denoted Aij), except for the vertices di, d\u2032i, ei, e\u2032i.\nRemark 1 Note that in the sequel we do not seek to minimize the sizes of the domains we define, as this is not important for the proof of NP-completeness. In particular, we avoid domains that are singletons, in order to allow a better illustration of the domains and their intersections in Figure 4.\nEach unit graph (see Figure 4) is defined by domains included into an interval of Z, of t = 24 consecutive integers (that we call a block), so that each consistency component CCj is defined on t \u2217 occ(j) consecutive integers, and all the consistency components are represented on the interval [1..t \u2217 \u03a3pj=1occ(j)]. Noticing that \u03a3 p j=1occ(j) = 3k, where k is the number of clauses, and defining m = 3kt, we define first the domains for the variables d\u2032i, 1 \u2264 i \u2264 k, used in the truth components, as follows:\nDom(d\u2032i) = [m+ 2i\u2212 1..m+ 2i]\nThis interval is devoted to creating the lateral edges in Di. Note that the last integer used by an interval in Dom(d\u2032k) is m+ 2k, that we denote q. For each i, we define:\nDom(e\u2032i) = [q + 2i\u2212 1..q + 2i].\nThis interval is dedicated both to the lateral edges in Di and to the edges in E. Now, each unit graph Gij is defined by domains inside the block [ht + 1..(h + 1)t] (with little exceptions), where h is the number of unit graphs before Gij in the global order, i.e.\nh = \u03a3q<jocc(q) + r \u2212 1, where r is the position of Gij in the alternate order of CCj . The domains of aij , bij , cij , (aij)\u2032, (bij)\u2032, (cij)\u2032 are respectively defined as (see Figure 4):\nAij = [ht+ 3..ht+ 6] \u222aXij Bij = [ht+ 9..ht+ 12] Cij = [ht+ 15..ht+ 18] \u222a T ij (Aij)\n\u2032 = [ht+ 7..ht+ 10] \u222a Y ij (Bij)\n\u2032 = [ht+ 5..ht+ 8] \u222a [ht+ 13..ht+ 16] (Cij)\n\u2032 = [ht+ 11..ht+ 14] \u222a Zij where\nXij =  Dom(d\u2032i) \u222aDom(e\u2032i), ifGij is a positive unit graph [(h+ 1)t+ 21..(h+ 1)t+ 22)] , ifGij is a negative unit graph and, moreover, Gij is not the last unit graph inCCj [(h+ 1\u2212 occ(j))t+ 21..\n..(h+ 1\u2212 occ(j))t+ 22] , otherwise\nT ij = { \u2205 ifGij is a positive unit graph Dom(d\u2032i) \u222aDom(e\u2032i), ifGij is a negative unit graph\nY ij = { [ht+ 1..ht+ 2] , ifGij is a positive unit graph [ht\u2212 7..ht\u2212 4] , ifGij is a negative unit graph\nZij = { [ht+ 21..ht+ 22] , ifGij is a positive unit graph [ht+ 23..ht+ 24] , ifGij is a negative unit graph\nThe part of each domain defined by Xij , T ij , Y ij or Zij before is called the secondary domain of respectively aij , cij , (aij)\u2032, (cij)\u2032. The remaining part of the domain, i.e. the one explicitly stated in the definitions of Aij , Bij , Cij , (Aij)\u2032, (Bij)\u2032, (Cij)\u2032 above, is called the main domain of the corresponding variables. Intuitively, the main domains allow to build the unit graphs and the down-linking edges of the consistency components. For a unit graph Gij , the main domains of its variables belong to its block [ht + 1..(h + 1)t]. The secondary domains are devoted to the connections with other unit graphs or with the other vertices of the truth components.\nIt remains to give the domains of di and ei for each i. Recalling that a unit graph Gij exists if and only if xj has a positive or egative occurrence in Hi, we define:\nDom(di) = \u222aGij is positiveY i j \u222a \u222aGij is negativeZ i j Dom(ei) = \u222aGij is positiveY i j \u222a \u222aGij is negativeZ i j \u222a \u222as6=iDom(e\u2032i)\nThen, Dom(di) contains intervals from the domains of the V -variables in Di, whereas Dom(ei) contains in addition the domains of all e\u2032s with s 6= i.\nThe construction before, obviously polynomial, yields a bipartite graph with n = 11k vertices in each part of the bipartition. Among these vertices 3k \u2217 6 (3k \u2217 3 in each part) are in some consistency component and 4k (2k in each part) are in some truth component (but not in a consistency component). We show now that the intersection graph of the variables we defined is indeed the graph we wished to build.\nClaim 1 The edges built using the domains defined above for the variables in U and V are exactly those of the unit graphs Gij, consistency components CCj, truth components Di and completion component E, for all i and j such that xj has a positive or negative occurrence in Di.\nProof. We consider each variable and the edges it belongs to. It is easy to notice that the main domain of a variable among aij , bij , (aij)\u2032, (bij)\u2032 or (cij)\u2032 can have non-empty intersections only with the main domains of the same set of variables, The only exception to this rule is cij (see below and Figure 4). Moreover, the secondary domains of aij , cij , (aij)\u2032, (cij)\u2032 are specially defined to guarantee intersections with domains of other variables (according to the desired edges in CCj and Di), and thus have only empty intersections with the other domains in the block of Gij .\nVariable aij. The main domain of aij has non-empty intersection only with (Bij)\u2032 resulting into the edge (aij , (bij)\u2032). The secondary domain of aij contains the domains of d\u2032i and e\u2032i, if Gij is a positive unit graph, meaning that Aij \u2229Dom(d\u2032i) 6= \u2205 and Aij \u2229Dom(e\u2032i) 6= \u2205 and thus that the edges (aij , d\u2032i), (aij , e\u2032i) exist. It is easy to see that no other edge with endpoint aij exists in this case. If Gij is a negative unit graph, then we have two sub-cases. If it is not the last unit graph in CCj , then Xij = [(h+ 1)t+ 21..(h+ 1)t+ 22] and it has non-empty intersection only with the secondary domain Zrj = [(h + 1)t + 21..(h + 1)t + 22] of the variable (crj)\u2032 in the positive unit graph Grj immediately following it in CCj . Then we have the up-linking edge between Gij and Grj . If Gij is the last unit graph in CCj , then Xij = [(h+1\u2212occ(j))t+21..(h+1\u2212occ(j))t+22] and Xij is included in the block of the first positive unit graph of CCj , denoted G i1 j . Then X i j has non-empty intersection only with the interval Zi1j in the domain of the variable (c i1 j )\n\u2032 of the first unit graph, and thus we have again the up-linking edge between the two unit graphs.\nVariable bij. Obviously, Bij has non-empty intersections with the main domains of (Aij)\u2032 and (Cij)\u2032, defining the edges (bij , (aij)\u2032) and (bij , (cij)\u2032) of the unit graph. No other non-empty intersections exist with Bij .\nVariable cij. Again, we have an obvious intersection of Cij with (Bij)\u2032, implying the edge (cij , (b i j)\n\u2032), and no other intersection with main domains. However, the main domain [ht + 15..ht+ 18] of cij also has non-empty intersection with the secondary domain Y rj = [(h+ 1)t\u2212 7..(h + 1)t \u2212 4] of the variable (arj)\u2032 in the unit graph following the current one, if this latter graph is negative. We are therefore in the case where the two unit graphs are joined by the down-linking edge (cij , (arj))\u2032. Analyzing now the intersections of the secondary domain of cij , we have again two sub-cases. In the case Gij is negative, then its intersections with Dom(d\u2032i) and Dom(e\u2032i) are non-empty and we have the desired lateral edges in the truth component for the clause Hi. In the case Gij is positive, there is no secondary domain for cij .\nVariable (aij)\u2032. On the main domain, (Aij)\u2032 has non-empty intersection with Bij , yielding the edge (bij , (aij)\u2032), and also with (Bij)\u2032, yielding no edge since both variables are in V . Consider now the secondary domain of (aij)\u2032. When Gij is positive, Y ij is included into Dom(di) and Dom(ei) and we have the sought lateral edges in Di. When Gij is negative, we have Y ij = [ht\u2212 7..ht\u2212 4] which is the same as [(h \u2212 1)t + 17..(h \u2212 1)t + 20], and thus has non-empty intersection with the main domain of the vertex csj in the unit graph immediately preceding Gij in CCj . This confirms the down-linking edge already found for the variable csj .\nVariable (bij)\u2032. Non-empty intersections with domains of variables from U are found only for variables aij and cij , confirming the edges already found above.\nVariable (cij)\u2032. The edge (bij , (cij)\u2032) is confirmed by the non-empty intersection of (Cij)\u2032 with Bij . No other intersection is found with the main domain of (cij)\u2032. For its second domain, we have the intersection with Dom(di) and Dom(ei) yielding the corresponding lateral edges, in the case where Gij is negative. In the contrary case, Zij = [ht + 21..ht + 22] and the only\npossible intersection is with some Xsj defined for another unit graph Gsj , which must be negative according to the definition ofXsj . WithXsj = (h\u2032+1)t+21, (h\u2032+1)t+22], we must have h\u2032 = h\u22121, meaning that Gsj is the negative unit graph immediately preceding Gij in CCj , and thus we have the up-linking edge (asj , (cij)\u2032). With Xsj = [(h\u2032 + 1\u2212 occ(j))t+ 21..(h\u2032 + 1\u2212 occ(j))t+ 22], we have that Xsj is the secondary domain of the asj vertex in the last unit graph Gsj in CCj . We also have that Xsj is included in the block of the first unit graph G i1 j in CCj . Thus X s j has non-empty intersection with Zij if and only if Zij also concerns G i1 j , that is if (c i j) \u2032 = (ci1j ) \u2032. The resulting edge is then (asj , (c i1 j )\n\u2032), which is the up-linking edge closing the circuit of unit graphs in CCj .\nVariable di. By definition, Dom(di) is made of the three secondary domains of variables of type (aij)\u2032 and (cij)\u2032, according to the positive or negative occurrence of xj in Di, for which the edges have also been confirmed above. We notice that all the other intersections with domains of variables from V are empty.\nVariable d\u2032i. By definition, Dom(d\u2032i) has non-empty intersection only with Xij (when Gij is positive) and with T ij (when Gij is negative) and this yields the expected lateral edges.\nVariable ei. Again by definition, Dom(ei) is, as Dom(di), made of three secondary domains of variables of type (aij)\u2032 and (cij)\u2032 allowing to build the expected lateral edges, but also of k\u22121 domains of variables e\u2032i allowing to build the edges from E incident with ei.\nVariable e\u2032i. As all the edges and non-edges with vertices from U have already been verified, there is nothing more to check here.\nAll the edges in the unit graphs, consistency components, truth components and completion component are correctly built, and no undesirable edge is added. The claim is proved."}, {"heading": "4 The proposed construction is a polynomial transformation", "text": "In this section, we show that there is a truth assignment satisfying H with at least one true and one false literal in each clause if and only if \u0393(U, V ) has a sort-matching. To this end, we first prove that:\nClaim 2 Let Gij be an arbitrary unit graph. Then no sort-matching M can contain simultaneously the edges (aij , (bij)\u2032) and (bij , (aij)\u2032), nor simultaneously the edges (cij , (bij)\u2032) and (bij , (cij)\u2032).\nProof. We have that Aij \u2229 (Bij)\u2032 = [ht+ 5..ht+ 6], whereas Bij \u2229 (Aij)\u2032 = [ht+ 9..ht+ 10]. Since (aij)\u2032 precedes (bij)\u2032 in the order on V , if a sort-matching contained both edges (aij , (bij)\u2032) and (bij , (aij)\u2032) then we should have Bij \u2229 (Aij)\u2032 \u2264lex Aij \u2229 (Bij)\u2032, and this is obviously false.\nSimilarly, Cij \u2229 (Bij)\u2032 = [ht+ 15..ht+ 16], whereas Bij \u2229 (Cij)\u2032 = [ht+ 11..ht+ 12], which does not satisfy Cij \u2229 (Bij)\u2032 \u2264lex Bij \u2229 (Cij)\u2032.\nClaim 3 Let CCj be an arbitrary consistency component. Then any sort-matching M satisfies the following property:\na) either all the up-edges and all the down-linking edges in CCj belong to M ; b) or all the down-edges and all the up-linking edges in CCj belong to M .\nProof. Given a unit graph Gij from CCj , M must contain exactly one edge among (aij , (bij)\u2032) and (cij , (bij)\u2032), so that (bij)\u2032 is saturated, and similarly exactly one edge among (bij , (aij)\u2032) and (bij , (c i j)\n\u2032). By Claim 2, it results that M contains either (aij , (bij)\u2032) and (bij , (cij)\u2032) (that is, the up-edges in Gij) or (cij , (bij)\u2032) and (bij , (aij)\u2032) (that is, the down-edges in Gij).\nIn the former case, cij (if Gij is positive) or (aij)\u2032 (if Gij is negative) can only be saturated by the down-linking edge with one endpoint in Gij (see Figure 2), implying that the next (previous, respectively) unit graph Gsj in CCj , in a circular way, also has its up-edges in M . The same deduction may be done for the unit graph Grj following (respectively preceding) Gsj , as follows. Since the up-linking edge is not used by M (the up-edges are already in M), the vertex of Grj incident with this edge must be saturated locally, and this can only be done by an up-edge of Grj . Thus, the property of a unit graph to have its up-edges and its incident down-linking edge in M is propagated to all the consistency component CCj .\nThe reasoning is similar in the latter case.\nNow we are ready to prove the main result. For a truth component Di and a unit graph Gij in it, we call d\u2032i-close the up-edges of Gij if Gij is positive, and the down-edges of Gij if Gij is negative. The other edges in Gij are called di-close. In other words, given that in the definition of Di the negative unit graphs are drawn upside down (see Figure 3), the d\u2032i-close edges of Gij are the pairs of up- or down-edges one of whose endpoints is joined to d\u2032i (and similarly for di).\nClaim 4 There is a truth assignment satisfying H with at least one true and one false literal in each clause if and only if \u0393(U, V ) admits a sort-matching.\nProof. To prove the Only if part, assume that x1, x2, . . . , xp have been assigned boolean values satisfying H as required. BuildM , initially empty, as follows. For each clause Hi, assume it contains the literals xj , xl, xf , with either a positive or a negative occurrence each. Assume without loss of generality, that the (positive or negative) occurrence of xj is true and that the (positive or negative) occurrence of xl is false.\nThen add toM : the edges of Gij close to d\u2032i; the edges of Gil close to di; the edges of G i f close to d\u2032i or respectively to di depending whether the occurrence of xf is true or respectively false; the lateral edge joining d\u2032i to Gil and the lateral edge joining di to G i j . Moreover, add to M the up- or down-linking edges that are needed to saturate three of the four remaining unsaturated vertices of Gij , Gil and G i f . The remaining unsaturated vertex belonging to a unit graph of Di is a vertex y of Gif . If the occurrence of xf in Hi is false, then this vertex is either a i f (when the occurrence is positive) or cif (when the occurrence is negative), and is always adjacent to e\u2032i. If, on the contrary, the occurrence of xf in Hi is true, then this vertex is either (aif )\n\u2032 (when the occurrence is positive) or (cif )\n\u2032 (when the occurrence is negative), and is always adjacent to ei. Then add (y, e\u2032i) to M if (y, e\u2032i) is an edge, and add (ei, y) to M in the contrary case, leaving thus ei unsaturated when the occurrence of xf is false in Hi, and e\u2032i unsaturated when the occurrence of xf is true in Hi. Equivalently, ei (respectively e\u2032i) remains unsaturated when Hi is oversupplied of (respectively true) literals.\nNow, as each consistency component has the same number of positive and negative occurrences of its corresponding literal, it results that there are 3k/2 true literals and 3k/2 false literals in H. Therefore, the number of clauses that are oversupplied of true literals is the same as the number of clauses that are oversupplied of positive literals, namely k/2 clauses in each case. Consequently, in the completion component E the unsaturated vertices induce a k/2regular bipartite graph. By Hall\u2019s theorem [6], this graph has a perfect matching M \u2032, that we add to M . The construction of the matching is now complete.\nWe first have to show that M is correctly built. The construction implies that in every unit graph either both up-edges or both down-edges are in M . Inside any consistency component, all unit graphs are in the same case among these two cases. To see this, let Gij and Glj be two neighboring unit graphs and assume without loss of generality that Gij is positive and Glj is negative, and also that xj is true, implying that xj is false (the other cases are similar). Then in Di the up-edges of Gij are put into M since they are d\u2032i-close, whereas in Dl the up-edges of Glj are put into M since they are di-close. Thus in CCj either all the up-edges or all the\ndown-edges are in M , together with the down-, respectively up-, linking edges by the definition of M . Moreover, in each Di and in E the matching is correctly built by definition. Thus M is correctly built.\nObviously, M is a perfect matching. Recall that we associate with it a bijective function \u03c3 : V \u2192 U such that \u03c3(v) = u if and only if (u, v) \u2208M . In order to show the inclusion property between sets Q(v) := Dom(\u03c3(v))\u2229Dom(v) required by a sort-matching, we show that for each pair v, w \u2208 V such that v precedes w in the order on V we have Q(v) \u2264lex Q(w).\nThis deduction is based on the following seven affirmations:\nA1. for each unit graph Gij , Q((aij)\u2032) \u2264lex Q((bij)\u2032) \u2264lex Q((cij)\u2032).\nIndeed, as shown above, we have two cases. In the case where the up-edges of Gij belong to M , we have that \u03c3((bij)\u2032) = aij , \u03c3((cij)\u2032) = bij . Moreover, \u03c3((aij)\u2032) \u2208 {di, ei} if Gij is positive, and \u03c3((aij)\u2032) = csj where Gsj precedes Gij in CCj , if Gij is negative. Then, Q((aij)\u2032) = Y ij = [ht + 1..ht + 2] and respectively Q((aij)\u2032) = [(h \u2212 1)t + 17..(h \u2212 1)t + 18] (where h defines the block of Gij). See Figure 4. As Q((bij)\u2032) = [ht + 5..ht + 6] and Q((cij)\u2032) = [ht + 11..ht + 12], the affirmation follows. In the case where the down-edges of Gij belong to M , we have that \u03c3((bij)\n\u2032) = cij , \u03c3((aij)\u2032) = bij . Moreover, \u03c3((cij)\u2032) = asj where Gsj (circularly) precedes Gij in CCj , if Gij is positive, and \u03c3((cij)\u2032) \u2208 {di, ei}, if Gij is negative. We deduce that Q((cij)\u2032) = Zij = [ht+21..ht+22] and respectively Q((cij)\u2032) = Zij = [ht+23..ht+24]. As Q((aij)\u2032) = [ht+9..ht+10] and Q((bij)\u2032) = [ht+ 15..ht+ 16], the affirmation follows.\nA2. for each pair of consecutive unit graphs Gij , Grj (in this order) in the same consistency component CCj , Q((cij)\u2032) \u2264lex Q((arj)\u2032).\nAs before, consider first the case where the up-edges of Gij belong to M and deduce in the same way that Q((cij)\u2032) = [ht+11..ht+12] (where h defines the block of Gij). Then, the up-edges of Grj also belong to M , therefore Q((arj)\u2032) = Y rj = [(h+ 1)t+ 1..(h+ 1)t+ 2], if Grj is positive, and respectively Q((arj)\u2032) = [ht+ 17..ht+ 18], if Grj is negative. The affirmation is then proved. Consider now the case where the down-edges of Gij belong to M and deduce as before that Q((cij)\n\u2032) = [ht+ 21..ht+ 22] and respectively Q((cij)\u2032) = [ht+ 23..ht+ 24] when Gij is positive, respectively negative. We also have in this case that Q((arj)\u2032) = [(h + 1)t + 9..(h + 1)t + 10], proving the affirmation.\nA3. for each pair of consecutive unit graphs Gij , Grj+1 (in this order) in two consecutive consistency components, Q((cij)\u2032) \u2264lex Q((arj+1)\u2032).\nNotice that in this case Gij is negative and Grj+1 is positive, therefore as before we have either Q((cij)\u2032) = [ht+ 11..ht+ 12] or Q((cij)\u2032) = [ht+ 23..ht+ 24], depending whether the upor the down-edges of Gij belong to M . Similarly, we also have Q((arj+1)\u2032) = Y rj = [(h + 1)t + 1..(h + 1)t + 2] or Q((arj+1)\u2032) = [(h + 1)t + 9..(h + 1)t + 10]. In all four possible cases, the affirmation holds.\nA4. for the last unit graph Gip in the last consistency component CCp, we have Q((cip)\u2032) \u2264lex Q(d\u20321).\nWith the same deductions as above and since Gip is negative, we have that either Q(cip) = [ht+ 11..ht+ 12] or Q(cip) = [ht+ 23..ht+ 24], where h defines the block of Gip, i.e. ht+ 24 = m = 3kt (with t = 24) since we have 3k literals in the k clauses and thus 3k blocks, of which Gip uses the last one. Now, Q(d\u20321) = [m + 1..m + 2] since Dom(d\u20321) = [m + 1..m + 2] and it is included in the domains of the three variables yielding vertices adjacent to d\u20321 in D1, and the affirmation follows.\nA5. for each i with 1 \u2264 i < k, we have Q(d\u2032i) \u2264lex Q(d\u2032i+1).\nThis is obvious by the definition of the domains and the observation that Q(d\u2032s) = Dom(d\u2032s) for all s with 1 \u2264 s \u2264 k.\nA6. we have Q(d\u2032k) \u2264lex Q(e\u20321).\nAgain, Q(d\u2032k) = Dom(d \u2032 k) = [m + 2k \u2212 1..m + 2k] and similarly Q(e\u20321) = Dom(e\u20321) =\n[q + 1..q + 2] where q = m+ 2k. The affirmation is proved.\nA7. for each i with 1 \u2264 i < k, we have Q(e\u2032i) \u2264lex Q(e\u2032i+1).\nThis is obvious by the definition of the domains and the observation that Q(e\u2032s) = Dom(e\u2032s) for all s with 1 \u2264 s \u2264 k.\nAffirmations A1-A7 allow to deduce that M is a sort-matching.\nWe consider now the If part of the theorem. Assume therefore that a sort-matching exists in \u0393(U, V ). By Claim 3, such a matching must contain, for each unit graph, either both its low-edges or both its up-edges. Given that the matching is perfect, we deduce that all vertices di and d\u2032i are saturated, and therefore that in each Di there is a unit graph Gij whose d\u2032i-close edges are in M (the unit graph containing the vertex y such that (di, y) \u2208M) and a unit graph Gil whose di-close edges are inM (the unit graph containing the vertex z such that (z, d \u2032 i) \u2208M). Call Gif the third unit graph in Di. Define, locally to Di, the (positive or negative) occurrence of xj in Di to be true, that of xl to be false, and that of xf to be true if M contains the edges of Gif close to d \u2032 i, respectively false if M contains the edges of Gif close to di. Deduce a local truth assignment for each literal xj , xl and xf . Notice that:\nA8. The local truth assignment of the literal xr, for each r \u2208 {j, l, f}, is true if and only if the up-edges of Gir belong to M .\nIndeed, we have that xr is true if and only if exactly one of the two following cases occurs: either xr has a positive occurrence in Di, in which case this occurrence has been assigned the true value, so the d\u2032i-close edges of Gir belong to M ; or xr has a negative occurrence in Di, in which case xr has been assigned a true value if and only if its negative occurrence has been assigned a false value, and this happens only if M contains the di-close edges of Gir. In the former case, the d\u2032i-close edges are the up-edges of Gir. In the latter case, due to the upside-down position of negative unit graphs in Di, the di-close edges are also the up-edges of Gir. And we are done.\nDue to the affirmato A8 and to Claim 3, we deduce that all the local truth assignments are coherent. Moreover, each clause Hi has at least one true literal and one false literal, namely the occurrences of xj and of xl (with the notations above)."}, {"heading": "5 Hardness of sortedness constraints", "text": "The construction in the preceding section allows us to deduce the NP-completeness of SortSupport in general, but also in a particular case of it, as follows.\nClaim 5 SortSupport is NP-complete.\nProof. Obviously SortSupport belongs to NP. To show it is NP-complete, apply Claim 4.\nWith a slight modification of the domains we defined for the variables, we also have that:\nClaim 6 SortSupport is NP-complete, even in the case where the domains Dom(ui), 1 \u2264 i \u2264 n, are pairwise disjoint.\nProof. In order to have pairwise disjoint domains, the idea is: (a) to extend the intervals of Z that are used by several sets Dom(u) with u \u2208 U (thus shifting to right all the other intervals so as to avoid unwished overlaps); (b) to cut them into a sufficiently large number of subintervals; and (c) to use a specific sub-interval for each Dom(u), thus insuring the disjointness without modifying the relative positions on the real line of the intervals defining the sets Q(v).\nThe shared intervals are as follows: Y ij = [ht+ 1..ht+ 2] (shared by Dom(di) and Dom(ei), when Gij is positive), Zij = [ht + 23..ht + 24] (shared by Dom(di) and Dom(ei), when Gij is negative), Dom(d\u2032i) = [m+ 2i\u2212 1..m+ 2i] (shared by Xij when Gij is positive, and by T ij when Gij is negative) and Dom(e\u2032i) = [q + 2i \u2212 1..q + 2i] (shared by Xij when Gij is positive, by T ij when Gij is negative and by Dom(es) with s 6= i). As an example, consider Y ij in the case of a positive unit graph Gij . As Y ij is shared by Dom(di) and Dom(ei), it should be extended to an interval of length three (e.g. [ht + 1..ht + 4] instead of [ht + 1..ht + 2] as it is now), in which case Dom(di) and Dom(ei) would be affected a sub-interval each (e.g. [ht + 1..ht + 2] and [ht + 3..ht + 4] respectively). Of course, in this case, the domain Aij of aij should start at ht + 5 instead of ht + 3 (and similarly for the other domains), so as to avoid overlaps. This would result into an augmentation of the size t of each block.\nThe proof of the correctness is very similar to the one above. The main difference is that some intersections between domains are slightly shifted.\nTheorem 1 Testing whether sort(U, V ), sort(U, V, P ) or keysorting(U, V,Keys, P ) has a support is NP-complete, even in the case where the variables in U have pairwise disjoint domains.\nProof. For sort(U, V ), the affirmation follows immediately by the equivalence to SortSupport noticed in Section 3, and by Claim 6. Furthermore, sort(U, V ) is the variant of sort(U, V, P ) where each variable in P has the domain {1, 2, . . . , n}. As testing whether sort(U, V, P ) has a support is obviously in NP, the previous remark allows to deduce the NP-completeness of the problem. Finally, sort(U, V, P ) and keysorting(U, V, 1, P ) are equivalent when the domains of the variables in U are pairwise disjoint, since the stability of the sorting is trivially satisfied by any assignment of values to the variables.\nGiven a constraint C defined as in Section 2, enforcing domain consistency requires to test whether for a given variable wi and a given value \u03b4i \u2208 Dom(wi), a support of C exists assigning the value \u03b4i to wi. We can easily deduce that:\nCorollary 1 Enforcing domain consistency for each of the constraints sort(U, V ), sort(U, V, P ) and keysorting(U, V,Keys, P ) is intractable, even in the case where the variables in U have pairwise disjoint domains.\nProof. By contradiction and for each of the three constraints, assume a polynomial algorithm A exists for testing the existence of a support with a given value for a given variable. Recall that, by Claim 4, an instance H of Not-All-Equal 3SAT is satisfiable if and only if \u0393(U, V ) admits a sort-matching, and this latter affirmation holds if and only if sort(U, V ) has a support. By applying A to all the four values in Bij for an arbitrarily chosen variable bij , we test in polynomial time whether sort(U, V ) has a support. Then we have a polynomial algorithm for solving Not-All-Equal 3SAT, a contradiction. The results for sort(U, V, P ) and keysorting(U, V,Keys, P ) easily follow.\nFocusing now on enforcing bounds consistency, we need to test whether for a given variable wi and a given value \u03b4i \u2208 {infD(wi), supD(wi)}, a t-tuple (\u03b41, \u03b42, . . . , \u03b4t) satifsfying C exists whose values \u03b4j , j 6= i are more or less constrained. More precisely, \u03b4j must belong\nto Dom(wj), respectively to [infD(wj).. supD(wj)], and respectively to [infD(wi), supD(wi)] to allow bounds(D), respectively bounds(Z) and respectively bounds(R) consistency. We are able to show that:\nTheorem 2 Enforcing bounds(D) consistency for each of the constraints sort(U, V ), sort(U, V, P ) and keysorting(U, V,Keys, P ) is NP-complete.\nProof. It is easy to notice that these problems are in NP. We show that the reduction from Not-All-Equal 3SAT to SortSupport in Section 3 allows to deduce the result for sort(U, V ). Then the other results follow.\nIn the instance of SortSupport built in Section 3, the variable d\u2032i has the domainDom(d\u2032i) = [m+ 2i\u2212 1..m+ 2i], so that infD(d\u2032i) = m+ 2i\u2212 1 and supD(d\u2032i) = m+ 2i. Let y = m+ 2i\u2212 1 and let us notice that \u0393(U, V ) has a sort-matching if and only if it has a sort-matching such that y \u2208 Q(d\u2032i). This is an easy consequence of the observation that Dom(d\u2032i) has non-empty intersection with another domain if and only if it is included in it, i.e. if and only if y belongs to the intersection. Then by Claim 4, we deduce the NP-completeness of testing whether there is a support of sort(U, V ) assigning to d\u2032i the value y.\nNotice that the previous result is not proved for pairwise disjoint domains of variables in U . The reason is that in this variant the domain of d\u2032i strictly overlaps the domains of other variables and the proof of Theorem 2 is no longer valid."}, {"heading": "6 Conclusion", "text": "In this paper we have shown that the three sortedness constraints defined up to now are intractable, even in the particular case where the variables to sort have pairwise disjoint domains, and even if we do not seek domain consistency but only enforcing bounds(D) consistency. The tractability of the lower levels of bounds consistency, i.e. bounds(Z) and bounds(R) consistency, is shown for sort(U, V ) [5, 7], but is still open for sort(U, V, P ) and keysorting(U, V,Keys, P )."}], "references": [{"title": "The complexity of global constraints", "author": ["Christian Bessiere", "Emmanuel Hebrard", "Brahim Hnich", "Toby Walsh"], "venue": "In AAAI,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Sicstus prolog user?s manual", "author": ["Mats et al. Carlsson"], "venue": "(release 4.3.1),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Finite domain bounds consistency revisited", "author": ["Chiu Wo Choi", "Warwick Harvey", "Jimmy Ho-Man Lee", "Peter J Stuckey"], "venue": "In AI 2006: Advances in Artificial Intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2006}, {"title": "Computers and intractability: A Guide to the Theory of NP-Completeness", "author": ["Michael R Garey", "David S Johnson"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1979}, {"title": "Narrowing a 2n-block of sortings in o (n logn)", "author": ["Noelle Bleuzen Guernalec", "Alain Colmerauer"], "venue": "In Principles and Practice of Constraint Programming-CP97,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1997}, {"title": "On representatives of subsets", "author": ["Philip Hall"], "venue": "J. London Math. Soc,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1935}, {"title": "Faster algorithms for bound-consistency of the sortedness and the alldifferent constraint", "author": ["Kurt Mehlhorn", "Sven Thiel"], "venue": "In Principles and Practice of Constraint Programming\u2013CP", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "Minizinc: Towards a standard cp modelling language", "author": ["Nicholas Nethercote", "Peter J Stuckey", "Ralph Becket", "Sebastian Brand", "Gregory J Duck", "Guido Tack"], "venue": "In Principles and Practice of Constraint Programming\u2013CP", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2007}, {"title": "Getting to the real problem: Experience with bnr prolog in or", "author": ["WJ Older", "GM Swinkels", "MH Van Emden"], "venue": "Proceedings of the Third International Conference on the Practical Applications of Prolog (PAP?95). Alinmead Software Ltd, page 28", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1995}, {"title": "Maximum weight edge-constrained matchings", "author": ["Irena Rusu"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "When do bounds and domain propagation lead to the same search space", "author": ["Christian Schulte", "Peter J Stuckey"], "venue": "ACM Transactions on Programming Languages and Systems (TOPLAS),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2005}, {"title": "Modeling and programming with Gecode", "author": ["Christian Schulte", "Guido Tack", "Mikael Z. Lagerkvist"], "venue": "http://www.gecode.org/doc-latest/MPG.pdf,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "Choco documentation", "author": ["CHOCO Team"], "venue": "http://choco.emn.fr", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2010}, {"title": "Efficient algorithms for constraint propagation and for processing tree descriptions", "author": ["Sven Thiel"], "venue": "PhD thesis, Universita\u0308tsbibliothek,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2004}, {"title": "The alldifferent constraint: A survey", "author": ["Willem-Jan van Hoeve"], "venue": "arXiv preprint cs/0105015,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2001}, {"title": "A constraint program for solving the job-shop problem", "author": ["Jianyang Zhou"], "venue": "In Principles and Practice of Constraint Programming?CP96,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1996}], "referenceMentions": [{"referenceID": 0, "context": "Dealing with global constraints in general, that is, without fixing a constraint (or a set of constraints), is intractable [1].", "startOffset": 123, "endOffset": 126}, {"referenceID": 14, "context": "However, each constraint has its own complexity, which may range from tractability at all levels of consistency, as for the alldifferent constraint [15], to intractability at relatively low levels of consistency, as for linear equations [11].", "startOffset": 148, "endOffset": 152}, {"referenceID": 10, "context": "However, each constraint has its own complexity, which may range from tractability at all levels of consistency, as for the alldifferent constraint [15], to intractability at relatively low levels of consistency, as for linear equations [11].", "startOffset": 237, "endOffset": 241}, {"referenceID": 8, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 162, "endOffset": 165}, {"referenceID": 15, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 182, "endOffset": 186}, {"referenceID": 1, "context": "The tractability of a particular constraint is not always settled when the constraint is defined, and this is the case for the sortedness constraints sort(U, V ) [9], sort(U, V, P ) [16] and keysorting(U, V,Keys, P ) [2].", "startOffset": 217, "endOffset": 220}, {"referenceID": 1, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 103, "endOffset": 106}, {"referenceID": 11, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 115, "endOffset": 119}, {"referenceID": 12, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 130, "endOffset": 134}, {"referenceID": 7, "context": "Although one or several of these constraints are implemented in well-known systems like SICStus Prolog [2], Gecode [12] and Choco [13], as well as in the constraint modelling language MiniZinc [8], their hardness is unknown.", "startOffset": 193, "endOffset": 196}, {"referenceID": 6, "context": "In Section 3, we transform, using ideas from [7], the search for a support of sort(U, V ) into a graph matching problem that we call SortSupport, and we show how to associate with each instance of the NP-complete problem Not-All-Equal 3SAT an instance of SortSupport.", "startOffset": 45, "endOffset": 48}, {"referenceID": 3, "context": "The next section is devoted to the proof that our construction is a polynomial transformation [4], implying the NP-completeness of SortSupport.", "startOffset": 94, "endOffset": 97}, {"referenceID": 2, "context": "In order to solve a CSP, constraints are successively used to prune the search space, with the help of propagation algorithms that often seek to enforce various consistency properties, defined below (following [3]).", "startOffset": 210, "endOffset": 213}, {"referenceID": 8, "context": "We now define the sortedness constraints: \u2022 the sort(U, V ) constraint, defined in [9], has variable set U\u222aV , where U = {u1, u2, .", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "Propagation algorithms achieving bounds(Z)-consistency have been proposed in [5] and [7].", "startOffset": 77, "endOffset": 80}, {"referenceID": 6, "context": "Propagation algorithms achieving bounds(Z)-consistency have been proposed in [5] and [7].", "startOffset": 85, "endOffset": 88}, {"referenceID": 15, "context": "\u2022 the sort(U, V, P ) constraint, defined in [16], generalizes the sort(U, V ) constraint by adding a set P of n variables with domains included in {1, 2, .", "startOffset": 44, "endOffset": 48}, {"referenceID": 13, "context": "The propagation algorithms for the sort(U, V ) constraint are able to reduce the domains of the variables in U \u222aV similarly, but achieve bound(Z)-consistency only on the V -domains, and not on the U and P -domains [14].", "startOffset": 214, "endOffset": 218}, {"referenceID": 1, "context": "\u2022 the keysorting(U, V,Keys, P ) constraint (where Keys is a positive integer), defined in [2], allows to add two features with respect to sort(U, V, P ) : (a) each variable is a h-tuple (h \u2265 1 and integer, common to all variables), whose first Keys elements form the sorting key of the variable, using lexicographic ordering; and (b) the sorting has to be stable, i.", "startOffset": 90, "endOffset": 93}, {"referenceID": 6, "context": "Following [7], we define the intersection graph \u0393(U, V ) of U and V as the bipartite graph with vertex set U \u222a V and edge set {(ui, vj) |Dom(ui) \u2229 Dom(vj) 6= \u2205}.", "startOffset": 10, "endOffset": 13}, {"referenceID": 9, "context": "We adapt the graph construction in [10], and therefore use the same notations.", "startOffset": 35, "endOffset": 39}, {"referenceID": 3, "context": "The reduction is from the NP-complete problem Not-All-Equal 3SAT [4], the variant of 3SAT in which each clause is required to have at least one true and at least one false literal.", "startOffset": 65, "endOffset": 68}, {"referenceID": 5, "context": "By Hall\u2019s theorem [6], this graph has a perfect matching M \u2032, that we add to M .", "startOffset": 18, "endOffset": 21}, {"referenceID": 4, "context": "bounds(Z) and bounds(R) consistency, is shown for sort(U, V ) [5, 7], but is still open for sort(U, V, P ) and keysorting(U, V,Keys, P ).", "startOffset": 62, "endOffset": 68}, {"referenceID": 6, "context": "bounds(Z) and bounds(R) consistency, is shown for sort(U, V ) [5, 7], but is still open for sort(U, V, P ) and keysorting(U, V,Keys, P ).", "startOffset": 62, "endOffset": 68}], "year": 2015, "abstractText": "In Constraint Programming, global constraints allow to model and solve many combinatorial problems. Among these constraints, several sortedness constraints have been defined, for which propagation algorithms are available, but for which the tractability is not settled. We show that the sort(U, V ) constraint (Older et. al, 1995) is intractable (assuming P 6=NP) for integer variables whose domains are not limited to intervals. As a consequence, the similar result holds for the sort(U, V, P ) constraint (Zhou, 1996). Moreover, the intractability holds even under the stability condition present in the recently introduced keysorting(U, V,Keys, P ) constraint (Carlsson et al., 2014), and requiring that the order of the variables with the same value in the list U be preserved in the list V . Therefore, keysorting(U, V,Keys, P ) is intractable as well.", "creator": "LaTeX with hyperref package"}}}