{"id": "1510.00726", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Oct-2015", "title": "A Primer on Neural Network Models for Natural Language Processing", "abstract": "In recent years, neural networks have again evolved into powerful machine learning models that are state-of-the-art in areas such as image recognition and language processing. More recently, neural network models have also begun to be applied to natural textual speech signals, also with promising results. This tutorial examines neural network models from the perspective of natural language research to bring researchers up to date with neural techniques in natural language. It covers input coding for natural language tasks, feed networks, twisting networks, recursive networks and recursive networks, as well as abstraction of computational curves for automatic gradient calculation.", "histories": [["v1", "Fri, 2 Oct 2015 20:17:33 GMT  (586kb,D)", "http://arxiv.org/abs/1510.00726v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["yoav goldberg"], "accepted": false, "id": "1510.00726"}, "pdf": {"name": "1510.00726.pdf", "metadata": {"source": "CRF", "title": "A Primer on Neural Network Models for Natural Language Processing", "authors": ["Yoav Goldberg"], "emails": ["first.last@gmail"], "sections": [{"heading": "1. Introduction", "text": "For a long time, core NLP techniques were dominated by machine-learning approaches that used linear models such as support vector machines or logistic regression, trained over very high dimensional yet very sparse feature vectors.\nRecently, the field has seen some success in switching from such linear models over sparse inputs to non-linear neural-network models over dense inputs. While most of the neural network techniques are easy to apply, sometimes as almost drop-in replacements of the old linear classifiers, there is in many cases a strong barrier of entry. In this tutorial I attempt to provide NLP practitioners (as well as newcomers) with the basic background, jargon, tools and methodology that will allow them to understand the principles behind the neural network models and apply them to their own work. This tutorial is expected to be self-contained, while presenting the different approaches under a unified notation and framework. It repeats a lot of material which is available elsewhere. It also points to external sources for more advanced topics when appropriate.\nThis primer is not intended as a comprehensive resource for those that will go on and develop the next advances in neural-network machinery (though it may serve as a good entry point). Rather, it is aimed at those readers who are interested in taking the existing, useful technology and applying it in useful and creative ways to their favourite NLP problems. For more in-depth, general discussion of neural networks, the theory behind them, advanced\nar X\niv :1\n51 0.\n00 72\n6v 1\n[ cs\n.C L\n] 2\noptimization methods and other advanced topics, the reader is referred to other existing resources. In particular, the book by Bengio et al (2015) is highly recommended.\nScope The focus is on applications of neural networks to language processing tasks. However, some subareas of language processing with neural networks were decidedly left out of scope of this tutorial. These include the vast literature of language modeling and acoustic modeling, the use of neural networks for machine translation, and multi-modal applications combining language and other signals such as images and videos (e.g. caption generation). Caching methods for efficient runtime performance, methods for efficient training with large output vocabularies and attention models are also not discussed. Word embeddings are discussed only to the extent that is needed to understand in order to use them as inputs for other models. Other unsupervised approaches, including autoencoders and recursive autoencoders, also fall out of scope. While some applications of neural networks for language modeling and machine translation are mentioned in the text, their treatment is by no means comprehensive.\nA Note on Terminology The word \u201cfeature\u201d is used to refer to a concrete, linguistic input such as a word, a suffix, or a part-of-speech tag. For example, in a first-order partof-speech tagger, the features might be \u201ccurrent word, previous word, next word, previous part of speech\u201d. The term \u201cinput vector\u201d is used to refer to the actual input that is fed to the neural-network classifier. Similarly, \u201cinput vector entry\u201d refers to a specific value of the input. This is in contrast to a lot of the neural networks literature in which the word \u201cfeature\u201d is overloaded between the two uses, and is used primarily to refer to an input-vector entry.\nMathematical Notation I use bold upper case letters to represent matrices (X, Y, Z), and bold lower-case letters to represent vectors (b). When there are series of related matrices and vectors (for example, where each matrix corresponds to a different layer in the network), superscript indices are used (W1, W2). For the rare cases in which we want indicate the power of a matrix or a vector, a pair of brackets is added around the item to be exponentiated: (W)2, (W3)2. Unless otherwise stated, vectors are assumed to be row vectors. We use [v1; v2] to denote vector concatenation."}, {"heading": "2. Neural Network Architectures", "text": "Neural networks are powerful learning models. We will discuss two kinds of neural network architectures, that can be mixed and matched \u2013 feed-forward networks and Recurrent / Recursive networks. Feed-forward networks include networks with fully connected layers, such as the multi-layer perceptron, as well as networks with convolutional and pooling layers. All of the networks act as classifiers, but each with different strengths.\nFully connected feed-forward neural networks (Section 4) are non-linear learners that can, for the most part, be used as a drop-in replacement wherever a linear learner is used. This includes binary and multiclass classification problems, as well as more complex structured prediction problems (Section 8). The non-linearity of the network, as well as the ability to easily integrate pre-trained word embeddings, often lead to superior classification accuracy. A series of works (Chen & Manning, 2014; Weiss, Alberti, Collins, & Petrov, 2015; Pei, Ge, & Chang, 2015; Durrett & Klein, 2015) managed to obtain improved syntactic parsing results by simply replacing the linear model of a parser with a fully connected feed-forward network. Straight-forward applications of a feed-forward network as a classifier replacement (usually coupled with the use of pre-trained word vectors) provide benefits also for CCG supertagging (Lewis & Steedman, 2014), dialog state tracking (Henderson, Thomson, & Young, 2013), pre-ordering for statistical machine translation (de Gispert, Iglesias, & Byrne, 2015) and language modeling (Bengio, Ducharme, Vincent, & Janvin, 2003; Vaswani, Zhao, Fossum, & Chiang, 2013). Iyyer et al (2015) demonstrate that multilayer feed-forward networks can provide competitive results on sentiment classification and factoid question answering.\nNetworks with convolutional and pooling layers (Section 9) are useful for classification tasks in which we expect to find strong local clues regarding class membership, but these clues can appear in different places in the input. For example, in a document classification task, a single key phrase (or an ngram) can help in determining the topic of the document (Johnson & Zhang, 2015). We would like to learn that certain sequences of words are good indicators of the topic, and do not necessarily care where they appear in the document. Convolutional and pooling layers allow the model to learn to find such local indicators, regardless of their position. Convolutional and pooling architecture show promising results on many tasks, including document classification (Johnson & Zhang, 2015), short-text categorization (Wang, Xu, Xu, Liu, Zhang, Wang, & Hao, 2015a), sentiment classification (Kalchbrenner, Grefenstette, & Blunsom, 2014; Kim, 2014), relation type classification between entities (Zeng, Liu, Lai, Zhou, & Zhao, 2014; dos Santos, Xiang, & Zhou, 2015), event detection (Chen, Xu, Liu, Zeng, & Zhao, 2015; Nguyen & Grishman, 2015), paraphrase identification (Yin & Schu\u0308tze, 2015) semantic role labeling (Collobert, Weston, Bottou, Karlen, Kavukcuoglu, & Kuksa, 2011), question answering (Dong, Wei, Zhou, & Xu, 2015), predicting box-office revenues of movies based on critic reviews (Bitvai & Cohn, 2015) modeling text interestingness (Gao, Pantel, Gamon, He, & Deng, 2014), and modeling the relation between character-sequences and part-of-speech tags (Santos & Zadrozny, 2014).\nIn natural language we often work with structured data of arbitrary sizes, such as sequences and trees. We would like to be able to capture regularities in such structures, or to model similarities between such structures. In many cases, this means encoding the structure as a fixed width vector, which we can then pass on to another statistical\nlearner for further processing. While convolutional and pooling architectures allow us to encode arbitrary large items as fixed size vectors capturing their most salient features, they do so by sacrificing most of the structural information. Recurrent (Section 10) and recursive (Section 12) architectures, on the other hand, allow us to work with sequences and trees while preserving a lot of the structural information. Recurrent networks (Elman, 1990) are designed to model sequences, while recursive networks (Goller & Ku\u0308chler, 1996) are generalizations of recurrent networks that can handle trees. We will also discuss an extension of recurrent networks that allow them to model stacks (Dyer, Ballesteros, Ling, Matthews, & Smith, 2015; Watanabe & Sumita, 2015).\nRecurrent models have been shown to produce very strong results for language modeling, including (Mikolov, Karafia\u0301t, Burget, Cernocky, & Khudanpur, 2010; Mikolov, Kombrink, Luka\u0301s\u030c Burget, C\u030cernocky, & Khudanpur, 2011; Mikolov, 2012; Duh, Neubig, Sudoh, & Tsukada, 2013; Adel, Vu, & Schultz, 2013; Auli, Galley, Quirk, & Zweig, 2013; Auli & Gao, 2014); as well as for sequence tagging (Irsoy & Cardie, 2014; Xu, Auli, & Clark, 2015; Ling, Dyer, Black, Trancoso, Fermandez, Amir, Marujo, & Luis, 2015b), machine translation (Sundermeyer, Alkhouli, Wuebker, & Ney, 2014; Tamura, Watanabe, & Sumita, 2014; Sutskever, Vinyals, & Le, 2014; Cho, van Merrienboer, Gulcehre, Bahdanau, Bougares, Schwenk, & Bengio, 2014b), dependency parsing (Dyer et al., 2015; Watanabe & Sumita, 2015), sentiment analysis (Wang, Liu, SUN, Wang, & Wang, 2015b), noisy text normalization (Chrupala, 2014), dialog state tracking (Mrks\u030cic\u0301, O\u0301 Se\u0301aghdha, Thomson, Gasic, Su, Vandyke, Wen, & Young, 2015), response generation (Sordoni, Galley, Auli, Brockett, Ji, Mitchell, Nie, Gao, & Dolan, 2015), and modeling the relation between character sequences and part-of-speech tags (Ling et al., 2015b).\nRecursive models were shown to produce state-of-the-art or near state-of-the-art results for constituency (Socher, Bauer, Manning, & Andrew Y., 2013) and dependency (Le & Zuidema, 2014; Zhu, Qiu, Chen, & Huang, 2015a) parse re-ranking, discourse parsing (Li, Li, & Hovy, 2014), semantic relation classification (Hashimoto, Miwa, Tsuruoka, & Chikayama, 2013; Liu, Wei, Li, Ji, Zhou, & WANG, 2015), political ideology detection based on parse trees (Iyyer, Enns, Boyd-Graber, & Resnik, 2014b), sentiment classification (Socher, Perelygin, Wu, Chuang, Manning, Ng, & Potts, 2013; Hermann & Blunsom, 2013), target-dependent sentiment classification (Dong, Wei, Tan, Tang, Zhou, & Xu, 2014) and question answering (Iyyer, Boyd-Graber, Claudino, Socher, & Daume\u0301 III, 2014a)."}, {"heading": "3. Feature Representation", "text": "Before discussing the network structure in more depth, it is important to pay attention to how features are represented. For now, we can think of a feed-forward neural network as a function NN(x) that takes as input a din dimensional vector x and produces a dout dimensional output vector. The function is often used as a classifier, assigning the input x a degree of membership in one or more of dout classes. The function can be complex, and is almost always non-linear. Common structures of this function will be discussed in Section 4. Here, we focus on the input, x. When dealing with natural language, the input x encodes features such as words, part-of-speech tags or other linguistic information. Perhaps the biggest jump when moving from sparse-input linear models to neural-network based models is to stop representing each feature as a unique dimension (the so called one-hot representation) and representing them instead as dense vectors. That is, each core feature is embedded into a d dimensional space, and represented as a vector in that space.1 The embeddings (the vector representation of each core feature) can then be trained like the other parameter of the function NN . Figure 1 shows the two approaches to feature representation.\nThe feature embeddings (the values of the vector entries for each feature) are treated as model parameters that need to be trained together with the other components of the network. Methods of training (or obtaining) the feature embeddings will be discussed later. For now, consider the feature embeddings as given.\nThe general structure for an NLP classification system based on a feed-forward neural network is thus:\n1. Extract a set of core linguistic features f1, . . . , fk that are relevant for predicting the output class.\n2. For each feature fi of interest, retrieve the corresponding vector v(fi).\n3. Combine the vectors (either by concatenation, summation or a combination of both) into an input vector x.\n4. Feed x into a non-linear classifier (feed-forward neural network).\nThe biggest change in the input, then, is the move from sparse representations in which each feature is its own dimension, to a dense representation in which each feature is mapped to a vector. Another difference is that we extract only core features and not feature combinations. We will elaborate on both these changes briefly.\nDense Vectors vs. One-hot Representations What are the benefits of representing our features as vectors instead of as unique IDs? Should we always represent features as dense vectors? Let\u2019s consider the two kinds of representations:\nOne Hot Each feature is its own dimension.\n\u2022 Dimensionality of one-hot vector is same as number of distinct features. 1. Different feature types may be embedded into different spaces. For example, one may represent word\nfeatures using 100 dimensions, and part-of-speech features using 20 dimensions.\n\u2022 Features are completely independent from one another. The feature \u201cword is \u2018dog\u2019 \u201d is as dis-similar to \u201cword is \u2018thinking\u2019 \u201d than it is to \u201cword is \u2018cat\u2019 \u201d.\nDense Each feature is a d-dimensional vector.\n\u2022 Dimensionality of vector is d. \u2022 Similar features will have similar vectors \u2013 information is shared between similar\nfeatures.\nOne benefit of using dense and low-dimensional vectors is computational: the majority of neural network toolkits do not play well with very high-dimensional, sparse vectors. However, this is just a technical obstacle, which can be resolved with some engineering effort.\nThe main benefit of the dense representations is in generalization power: if we believe some features may provide similar clues, it is worthwhile to provide a representation that is able to capture these similarities. For example, assume we have observed the word \u2018dog\u2019 many times during training, but only observed the word \u2018cat\u2019 a handful of times, or not at\nall. If each of the words is associated with its own dimension, occurrences of \u2018dog\u2019 will not tell us anything about the occurrences of \u2018cat\u2019. However, in the dense vectors representation the learned vector for \u2018dog\u2019 may be similar to the learned vector from \u2018cat\u2019, allowing the model to share statistical strength between the two events. This argument assumes that \u201cgood\u201d vectors are somehow given to us. Section 5 describes ways of obtaining such vector representations.\nIn cases where we have relatively few distinct features in the category, and we believe there are no correlations between the different features, we may use the one-hot representation. However, if we believe there are going to be correlations between the different features in the group (for example, for part-of-speech tags, we may believe that the different verb inflections VB and VBZ may behave similarly as far as our task is concerned) it may be worthwhile to let the network figure out the correlations and gain some statistical strength by sharing the parameters. It may be the case that under some circumstances, when the feature space is relatively small and the training data is plentiful, or when we do not wish to share statistical information between distinct words, there are gains to be made from using the one-hot representations. However, this is still an open research question, and there are no strong evidence to either side. The majority of work (pioneered by (Collobert & Weston, 2008; Collobert et al., 2011; Chen & Manning, 2014)) advocate the use of dense, trainable embedding vectors for all features. For work using neural network architecture with sparse vector encodings see (Johnson & Zhang, 2015).\nFinally, it is important to note that representing features as dense vectors is an integral part of the neural network framework, and that consequentially the differences between using sparse and dense feature representations are subtler than they may appear at first. In fact, using sparse, one-hot vectors as input when training a neural network amounts to dedicating the first layer of the network to learning a dense embedding vector for each feature based on the training data. We touch on this in Section 4.4.\nVariable Number of Features: Continuous Bag of Words Feed-forward networks assume a fixed dimensional input. This can easily accommodate the case of a featureextraction function that extracts a fixed number of features: each feature is represented as a vector, and the vectors are concatenated. This way, each region of the resulting input vector corresponds to a different feature. However, in some cases the number of features is not known in advance (for example, in document classification it is common that each word in the sentence is a feature). We thus need to represent an unbounded number of features using a fixed size vector. One way of achieving this is through a socalled continuous bag of words (CBOW) representation (Mikolov, Chen, Corrado, & Dean, 2013). The CBOW is very similar to the traditional bag-of-words representation in which we discard order information, and works by either summing or averaging the embedding vectors of the corresponding features:2\n2. Note that if the v(fi)s were one-hot vectors rather than dense feature representations, the CBOW and WCBOW equations above would reduce to the traditional (weighted) bag-of-words representations, which is in turn equivalent to a sparse feature-vector representation in which each binary indicator feature corresponds to a unique \u201cword\u201d.\nCBOW (f1, ..., fk) = 1\nk k\u2211 i=1 v(fi)\nA simple variation on the CBOW representation is weighted CBOW, in which different vectors receive different weights:\nWCBOW (f1, ..., fk) = 1\u2211k i=1 ai k\u2211 i=1 aiv(fi)\nHere, each feature fi has an associated weight ai, indicating the relative importance of the feature. For example, in a document classification task, a feature fi may correspond to a word in the document, and the associated weight ai could be the word\u2019s TF-IDF score.\nDistance and Position Features The linear distance in between two words in a sentence may serve as an informative feature. For example, in an event extraction task3 we may be given a trigger word and a candidate argument word, and asked to predict if the argument word is indeed an argument of the trigger. The distance (or relative position) between the trigger and the argument is a strong signal for this prediction task. In the \u201ctraditional\u201d NLP setup, distances are usually encoded by binning the distances into several groups (i.e. 1, 2, 3, 4, 5\u201310, 10+) and associating each bin with a one-hot vector. In a neural architecture, where the input vector is not composed of binary indicator features, it may seem natural to allocate a single input vector entry to the distance feature, where the numeric value of that entry is the distance. However, this approach is not taken in practice. Instead, distance features are encoded similarly to the other feature types: each bin is associated with a d-dimensional vector, and these distance-embedding vectors are then trained as regular parameters in the network (Zeng et al., 2014; dos Santos et al., 2015; Zhu et al., 2015a; Nguyen & Grishman, 2015).\nFeature Combinations Note that the feature extraction stage in the neural-network settings deals only with extraction of core features. This is in contrast to the traditional linear-model-based NLP systems in which the feature designer had to manually specify not only the core features of interests but also interactions between them (e.g., introducing not only a feature stating \u201cword is X\u201d and a feature stating \u201ctag is Y\u201d but also combined feature stating \u201cword is X and tag is Y\u201d or sometimes even \u201cword is X, tag is Y and previous word is Z\u201d). The combination features are crucial in linear models because they introduce more dimensions to the input, transforming it into a space where the data-points are closer to being linearly separable. On the other hand, the space of possible combinations is very large, and the feature designer has to spend a lot of time coming up with an effective set of feature combinations. One of the promises of the non-linear neural network models is that one needs to define only the core features. The non-linearity of the classifier, as defined by the network structure, is expected to take care of finding the indicative feature combinations, alleviating the need for feature combination engineering.\n3. The event extraction task involves identification of events from a predefined set of event types. For example identification of \u201cpurchase\u201d events or \u201cterror-attack\u201d events. Each event type can be triggered by various triggering words (commonly verbs), and has several slots (arguments) that needs to be filled (i.e. who purchased? what was purchased? at what amount?).\nKernel methods (Shawe-Taylor & Cristianini, 2004), and in particular polynomial kernels (Kudo & Matsumoto, 2003), also allow the feature designer to specify only core features, leaving the feature combination aspect to the learning algorithm. In contrast to neuralnetwork models, kernels methods are convex, admitting exact solutions to the optimization problem. However, the classification efficiency in kernel methods scales linearly with the size of the training data, making them too slow for most practical purposes, and not suitable for training with large datasets. On the other hand, neural network classification efficiency scales linearly with the size of the network, regardless of the training data size.\nDimensionality How many dimensions should we allocate for each feature? Unfortunately, there are no theoretical bounds or even established best-practices in this space. Clearly, the dimensionality should grow with the number of the members in the class (you probably want to assign more dimensions to word embeddings than to part-of-speech embeddings) but how much is enough? In current research, the dimensionality of word-embedding vectors range between about 50 to a few hundreds, and, in some extreme cases, thousands. Since the dimensionality of the vectors has a direct effect on memory requirements and processing time, a good rule of thumb would be to experiment with a few different sizes, and choose a good trade-off between speed and task accuracy.\nVector Sharing Consider a case where you have a few features that share the same vocabulary. For example, when assigning a part-of-speech to a given word, we may have a set of features considering the previous word, and a set of features considering the next word. When building the input to the classifier, we will concatenate the vector representation of the previous word to the vector representation of the next word. The classifier will then be able to distinguish the two different indicators, and treat them differently. But should the two features share the same vectors? Should the vector for \u201cdog:previous-word\u201d be the same as the vector of \u201cdog:next-word\u201d? Or should we assign them two distinct vectors? This, again, is mostly an empirical question. If you believe words behave differently when they appear in different positions (e.g., word X behaves like word Y when in the previous position, but X behaves like Z when in the next position) then it may be a good idea to use two different vocabularies and assign a different set of vectors for each feature type. However, if you believe the words behave similarly in both locations, then something may be gained by using a shared vocabulary for both feature types.\nNetwork\u2019s Output For multi-class classification problems with k classes, the network\u2019s output is a k-dimensional vector in which every dimension represents the strength of a particular output class. That is, the output remains as in the traditional linear models \u2013 scalar scores to items in a discrete set. However, as we will see in Section 4, there is a d\u00d7 k matrix associated with the output layer. The columns of this matrix can be thought of as d dimensional embeddings of the output classes. The vector similarities between the vector representations of the k classes indicate the model\u2019s learned similarities between the output classes.\nHistorical Note Representing words as dense vectors for input to a neural network was introduced by Bengio et al (Bengio et al., 2003) in the context of neural language modeling. It was introduced to NLP tasks in the pioneering work of Collobert, Weston and colleagues\n(2008, 2011). Using embeddings for representing not only words but arbitrary features was popularized following Chen and Manning (2014)."}, {"heading": "4. Feed-forward Neural Networks", "text": "A Brain-inspired metaphor As the name suggest, neural-networks are inspired by the brain\u2019s computation mechanism, which consists of computation units called neurons. In the metaphor, a neuron is a computational unit that has scalar inputs and outputs. Each input has an associated weight. The neuron multiplies each input by its weight, and then sums4 them, applies a non-linear function to the result, and passes it to its output. The neurons are connected to each other, forming a network: the output of a neuron may feed into the inputs of one or more neurons. Such networks were shown to be very capable computational devices. If the weights are set correctly, a neural network with enough neurons and a nonlinear activation function can approximate a very wide range of mathematical functions (we will be more precise about this later).\nA typical feed-forward neural network may be drawn as in Figure 2. Each circle is a neuron, with incoming arrows being the neuron\u2019s inputs and outgoing arrows being the neuron\u2019s outputs. Each arrow carries a weight, reflecting its importance (not shown). Neurons are arranged in layers, reflecting the flow of information. The bottom layer has no incoming arrows, and is the input to the network. The top-most layer has no outgoing arrows, and is the output of the network. The other layers are considered \u201chidden\u201d. The sigmoid shape inside the neurons in the middle layers represent a non-linear function (typically a 1/(1 + e\u2212x)) that is applied to the neuron\u2019s value before passing it to the output. In the figure, each neuron is connected to all of the neurons in the next layer \u2013 this is called a fully-connected layer or an affine layer.\n4. While summing is the most common operation, other functions, such as a max, are also possible\nWhile the brain metaphor is sexy and intriguing, it is also distracting and cumbersome to manipulate mathematically. We therefore switch to using more concise mathematic notation. The values of each row of neurons in the network can be thought of as a vector. In Figure 2 the input layer is a 4 dimensional vector (x), and the layer above it is a 6 dimensional vector (h1). The fully connected layer can be thought of as a linear transformation from 4 dimensions to 6 dimensions. A fully-connected layer implements a vector-matrix multiplication, h = xW where the weight of the connection from the ith neuron in the input row to the jth neuron in the output row is Wij .\n5 The values of h are then transformed by a non-linear function g that is applied to each value before being passed on to the next input. The whole computation from input to output can be written as: (g(xW1))W2 where W1 are the weights of the first layer and W2 are the weights of the second one.\nIn Mathematical Notation From this point on, we will abandon the brain metaphor and describe networks exclusively in terms of vector-matrix operations. The simplest neural network is the perceptron, which is a linear function of its inputs:\nNNPerceptron(x) = xW + b\nx \u2208 Rdin , W \u2208 Rdin\u00d7dout , b \u2208 Rdout\nW is the weight matrix, and b is a bias term.6 In order to go beyond linear functions, we introduce a non-linear hidden layer (the network in Figure 2 has two such layers), resulting in the 1-layer Multi Layer Perceptron (MLP1). A one-layer feed-forward neural network has the form:\nNNMLP1(x) = g(xW 1 + b1)W2 + b2\nx \u2208 Rdin , W1 \u2208 Rdin\u00d7d1 , b1 \u2208 Rd1 , W2 \u2208 Rd1\u00d7d2 , b2 \u2208 Rd2\nHere W1 and b1 are a matrix and a bias term for the first linear transformation of the input, g is a non-linear function that is applied element-wise (also called a non-linearity or an activation function), and W2 and b2 are the matrix and bias term for a second linear transform.\nBreaking it down, xW1+b1 is a linear transformation of the input x from din dimensions to d1 dimensions. g is then applied to each of the d1 dimensions, and the matrix W\n2 together with bias vector b2 are then used to transform the result into the d2 dimensional output vector. The non-linear activation function g has a crucial role in the network\u2019s ability to represent complex functions. Without the non-linearity in g, the neural network can only represent linear transformations of the input.7\nWe can add additional linear-transformations and non-linearities, resulting in a 2-layer MLP (the network in Figure 2 is of this form):\nNNMLP2(x) = (g 2(g1(xW1 + b1)W2 + b2))W3\n5. To see why this is the case, denote the weight of the ith input of the jth neuron in h as wij . The value of hj is then hj = \u22114 i=1 xi \u00b7 wij . 6. The network in figure 2 does not include bias terms. A bias term can be added to a layer by adding to it an additional neuron that does not have any incoming connections, whose value is always 1. 7. To see why, consider that a sequence of linear transformations is still a linear transformation.\nIt is perhaps clearer to write deeper networks like this using intermediary variables:\nNNMLP2(x) =y\nh1 =g1(xW1 + b1)\nh2 =g2(h1W2 + b2)\ny =h2W3\nThe vector resulting from each linear transform is referred to as a layer. The outer-most linear transform results in the output layer and the other linear transforms result in hidden layers. Each hidden layer is followed by a non-linear activation. In some cases, such as in the last layer of our example, the bias vectors are forced to 0 (\u201cdropped\u201d).\nLayers resulting from linear transformations are often referred to as fully connected, or affine. Other types of architectures exist. In particular, image recognition problems benefit from convolutional and pooling layers. Such layers have uses also in language processing, and will be discussed in Section 9. Networks with more than one hidden layer are said to be deep networks, hence the name deep learning.\nWhen describing a neural network, one should specify the dimensions of the layers and the input. A layer will expect a din dimensional vector as its input, and transform it into a dout dimensional vector. The dimensionality of the layer is taken to be the dimensionality of its output. For a fully connected layer l(x) = xW + b with input dimensionality din and output dimensionality dout, the dimensions of x is 1 \u00d7 din, of W is din \u00d7 dout and of b is 1\u00d7 dout.\nThe output of the network is a dout dimensional vector. In case dout = 1, the network\u2019s output is a scalar. Such networks can be used for regression (or scoring) by considering the value of the output, or for binary classification by consulting the sign of the output. Networks with dout = k > 1 can be used for k-class classification, by associating each dimension with a class, and looking for the dimension with maximal value. Similarly, if the output vector entries are positive and sum to one, the output can be interpreted as a distribution over class assignments (such output normalization is typically achieved by applying a softmax transformation on the output layer, see Section 4.3).\nThe matrices and the bias terms that define the linear transformations are the parameters of the network. It is common to refer to the collection of all parameters as \u03b8. Together with the input, the parameters determine the network\u2019s output. The training algorithm is responsible for setting their values such that the network\u2019s predictions are correct. Training is discussed in Section 6."}, {"heading": "4.1 Representation Power", "text": "In terms of representation power, it was shown by (Hornik, Stinchcombe, & White, 1989; Cybenko, 1989) that MLP1 is a universal approximator \u2013 it can approximate with any desired non-zero amount of error a family of functions8 that include all continuous functions\n8. Specifically, a feed-forward network with linear output layer and at least one hidden layer with a \u201csquashing\u201d activation function can approximate any Borel measurable function from one finite dimensional space to another.\non a closed and bounded subset of Rn, and any function mapping from any finite dimensional discrete space to another. This may suggest there is no reason to go beyond MLP1 to more complex architectures. However, the theoretical result does not state how large the hidden layer should be, nor does it say anything about the learnability of the neural network (it states that a representation exists, but does not say how easy or hard it is to set the parameters based on training data and a specific learning algorithm). It also does not guarantee that a training algorithm will find the correct function generating our training data. Since in practice we train neural networks on relatively small amounts of data, using a combination of the backpropagation algorithm and variants of stochastic gradient descent, and use hidden layers of relatively modest sizes (up to several thousands), there is benefit to be had in trying out more complex architectures than MLP1. In many cases, however, MLP1 does indeed provide very strong results. For further discussion on the representation power of feed-forward neural networks, see (Bengio et al., 2015, Section 6.5)."}, {"heading": "4.2 Common Non-linearities", "text": "The non-linearity g can take many forms. There is currently no good theory as to which non-linearity to apply in which conditions, and choosing the correct non-linearity for a given task is for the most part an empirical question. I will now go over the common nonlinearities from the literature: the sigmoid, tanh, hard tanh and the rectified linear unit (ReLU). Some NLP researchers also experimented with other forms of non-linearities such as cube and tanh-cube.\nSigmoid The sigmoid activation function \u03c3(x) = 1/(1 + e\u2212x) is an S-shaped function, transforming each value x into the range [0, 1].\nHyperbolic tangent (tanh) The hyperbolic tangent tanh(x) = e 2x\u22121 e2x+1\nactivation function is an S-shaped function, transforming the values x into the range [\u22121, 1].\nHard tanh The hard-tanh activation function is an approximation of the tanh function which is faster to compute and take derivatives of:\nhardtanh(x) =  \u22121 x < \u22121 1 x > 1\nx otherwise\nRectifier (ReLU) The Rectifier activation function (Glorot, Bordes, & Bengio, 2011), also known as the rectified linear unit is a very simple activation function that is easy to work with and was shown many times to produce excellent results.9 The ReLU unit clips each value x < 0 at 0. Despite its simplicity, it performs well for many tasks, especially when combined with the dropout regularization technique (see Section 6.4).\n9. The technical advantages of the ReLU over the sigmoid and tanh activation functions is that it does not involve expensive-to-compute functions, and more importantly that it does not saturate. The sigmoid and tanh activation are capped at 1, and the gradients at this region of the functions are near zero, driving the entire gradient near zero. The ReLU activation does not have this problem, making it especially suitable for networks with multiple layers, which are susceptible to the vanishing gradients problem when trained with the saturating units.\nReLU(x) = max(0, x) =\n{ 0 x < 0\nx otherwise\nAs a rule of thumb, ReLU units work better than tanh, and tanh works better than sigmoid.10"}, {"heading": "4.3 Output Transformations", "text": "In many cases, the output layer vector is also transformed. A common transformation is the softmax :\nx =x1, . . . , xk\nsoftmax(xi) = exi\u2211k j=1 e xj\nThe result is a vector of non-negative real numbers that sum to one, making it a discrete probability distribution over k possible outcomes.\nThe softmax output transformation is used when we are interested in modeling a probability distribution over the possible output classes. To be effective, it should be used in conjunction with a probabilistic training objective such as cross-entropy (see Section 4.5 below).\nWhen the softmax transformation is applied to the output of a network without a hidden layer, the result is the well known multinomial logistic regression model, also known as a maximum-entropy classifier."}, {"heading": "4.4 Embedding Layers", "text": "Up until now, the discussion ignored the source of x, treating it as an arbitrary vector. In an NLP application, x is usually composed of various embeddings vectors. We can be explicit about the source of x, and include it in the network\u2019s definition. We introduce c(\u00b7), a function from core features to an input vector.\nIt is common for c to extract the embedding vector associated with each feature, and concatenate them:\n10. In addition to these activation functions, recent works from the NLP community experiment with and reported success with other forms of non-linearities. The Cube activation function, g(x) = (x)3, was suggested by (Chen & Manning, 2014), who found it to be more effective than other non-linearities in a feed-forward network that was used to predict the actions in a greedy transition-based dependency parser. The tanh cube activation function g(x) = tanh((x)3 + x) was proposed by (Pei et al., 2015), who found it to be more effective than other non-linearities in a feed-forward network that was used as a component in a structured-prediction graph-based dependency parser.\nThe cube and tanh-cube activation functions are motivated by the desire to better capture interactions between different features. While these activation functions are reported to improve performance in certain situations, their general applicability is still to be determined.\nx = c(f1, f2, f3) =[v(f1); v(f2); v(f3)]\nNNMLP1(x) =NNMLP1(c(f1, f2, f3))\n=NNMLP1([v(f1); v(f2); v(f3)]) =(g([v(f1); v(f2); v(f3)]W 1 + b1))W2 + b2\nAnother common choice is for c to sum the embedding vectors (this assumes the embedding vectors all share the same dimensionality):\nx = c(f1, f2, f3) =v(f1) + v(f2) + v(f3)\nNNMLP1(x) =NNMLP1(c(f1, f2, f3))\n=NNMLP1(v(f1) + v(f2) + v(f3)) =(g((v(f1) + v(f2) + v(f3))W 1 + b1))W2 + b2\nThe form of c is an essential part of the network\u2019s design. In many papers, it is common to refer to c as part of the network, and likewise treat the word embeddings v(fi) as resulting from an \u201cembedding layer\u201d or \u201clookup layer\u201d. Consider a vocabulary of |V | words, each embedded as a d dimensional vector. The collection of vectors can then be thought of as a |V | \u00d7 d embedding matrix E in which each row corresponds to an embedded feature. Let fi be a |V |-dimensional vector, which is all zeros except from one index, corresponding to the value of the ith feature, in which the value is 1 (this is called a one-hot vector). The multiplication fiE will then \u201cselect\u201d the corresponding row of E. Thus, v(fi) can be defined in terms of E and fi:\nv(fi) = fiE\nAnd similarly:\nCBOW (f1, ..., fk) = k\u2211 i=1 (fiE) = ( k\u2211 i=1 fi)E\nThe input to the network is then considered to be a collection of one-hot vectors. While this is elegant and well defined mathematically, an efficient implementation typically involves a hash-based data structure mapping features to their corresponding embedding vectors, without going through the one-hot representation.\nIn this tutorial, we take c to be separate from the network architecture: the network\u2019s inputs are always dense real-valued input vectors, and c is applied before the input is passed the network, similar to a \u201cfeature function\u201d in the familiar linear-models terminology. However, when training a network, the input vector x does remember how it was constructed, and can propagate error gradients back to its component embedding vectors, as appropriate.\nA note on notation When describing network layers that get concatenated vectors x, y and z as input, some authors use explicit concatenation ([x; y; z]W + b) while others use an affine transformation (xU + yV + zW + b). If the weight matrices U, V, W in the affine transformation are different than one another, the two notations are equivalent.\nA note on sparse vs. dense features Consider a network which uses a \u201ctraditional\u201d sparse representation for its input vectors, and no embedding layer. Assuming the set of all available features is V and we have k \u201con\u201d features f1, . . . , fk, fi \u2208 V , the network\u2019s input is:\nx = k\u2211 i=1 fi x \u2208 N|V |+\nand so the first layer (ignoring the non-linear activation) is:\nxW + b = ( k\u2211 i=1 fi)W\nW \u2208 R|V |\u00d7d, b \u2208 Rd\nThis layer selects rows of W corresponding to the input features in x and sums them, then adding a bias term. This is very similar to an embedding layer that produces a CBOW representation over the features, where the matrix W acts as the embedding matrix. The main difference is the introduction of the bias vector b, and the fact that the embedding layer typically does not undergo a non-linear activation but rather passed on directly to the first layer. Another difference is that this scenario forces each feature to receive a separate vector (row in W) while the embedding layer provides more flexibility, allowing for example for the features \u201cnext word is dog\u201d and \u201cprevious word is dog\u201d to share the same vector. However, these differences are small and subtle. When it comes to multi-layer feed-forward networks, the difference between dense and sparse inputs is smaller than it may seem at first sight."}, {"heading": "4.5 Loss Functions", "text": "When training a neural network (more on training in Section 6 below), much like when training a linear classifier, one defines a loss function L(y\u0302,y), stating the loss of predicting y\u0302 when the true output is y. The training objective is then to minimize the loss across the different training examples. The loss L(y\u0302,y) assigns a numerical score (a scalar) for the network\u2019s output y\u0302 given the true expected output y.11 The loss is always positive, and should be zero only for cases where the network\u2019s output is correct.\nThe parameters of the network (the matrices Wi, the biases bi and commonly the embeddings E) are then set in order to minimize the loss L over the training examples (usually, it is the sum of the losses over the different training examples that is being minimized).\nThe loss can be an arbitrary function mapping two vectors to a scalar. For practical purposes of optimization, we restrict ourselves to functions for which we can easily compute gradients (or sub-gradients). In most cases, it is sufficient and advisable to rely on a common loss function rather than defining your own. For a detailed discussion on loss functions for neural networks see (LeCun, Chopra, Hadsell, Ranzato, & Huang, 2006; LeCun & Huang, 2005; Bengio et al., 2015). We now discuss some loss functions that are commonly used in neural networks for NLP.\n11. In our notation, both the model\u2019s output and the expected output are vectors, while in many cases it is more natural to think of the expected output as a scalar (class assignment). In such cases, y is simply the corresponding one-hot vector.\nHinge (binary) For binary classification problems, the network\u2019s output is a single scalar y\u0302 and the intended output y is in {+1,\u22121}. The classification rule is sign(y\u0302), and a classification is considered correct if y \u00b7 y\u0302 > 0, meaning that y and y\u0302 share the same sign. The hinge loss, also known as margin loss or SVM loss, is defined as:\nLhinge(binary)(y\u0302, y) = max(0, 1\u2212 y \u00b7 y\u0302)\nThe loss is 0 when y and y\u0302 share the same sign and |y\u0302| \u2265 1. Otherwise, the loss is linear. In other words, the binary hinge loss attempts to achieve a correct classification, with a margin of at least 1.\nHinge (multiclass) The hinge loss was extended to the multiclass setting by Crammer and Singer (2002). Let y\u0302 = y\u03021, . . . , y\u0302n be the network\u2019s output vector, and y be the one-hot vector for the correct output class.\nThe classification rule is defined as selecting the class with the highest score:\nprediction = arg max i y\u0302i\n, Denote by t = arg maxi yi the correct class, and by k = arg maxi 6=t y\u0302i the highest scoring class such that k 6= t. The multiclass hinge loss is defined as:\nLhinge(multiclass)(y\u0302,y) = max(0, 1\u2212 (y\u0302t \u2212 y\u0302k))\nThe multiclass hinge loss attempts to score the correct class above all other classes with a margin of at least 1.\nBoth the binary and multiclass hinge losses are intended to be used with a linear output layer. The hinge losses are useful whenever we require a hard decision rule, and do not attempt to model class membership probability.\nLog loss The log loss is a common variation of the hinge loss, which can be seen as a \u201csoft\u201d version of the hinge loss with an infinite margin (LeCun et al., 2006).\nLlog(y\u0302,y) = log(1 + exp(\u2212(y\u0302t \u2212 y\u0302k))\nCategorical cross-entropy loss The categorical cross-entropy loss (also referred to as negative log likelihood) is used when a probabilistic interpretation of the scores is desired.\nLet y = y1, . . . , yn be a vector representing the true multinomial distribution over the labels 1, . . . , n, and let y\u0302 = y\u03021, . . . , y\u0302n be the network\u2019s output, which was transformed by the softmax activation function, and represent the class membership conditional distribution y\u0302i = P (y = i|x). The categorical cross entropy loss measures the dissimilarity between the true label distribution y and the predicted label distribution y\u0302, and is defined as cross entropy:\nLcross\u2212entropy(y\u0302,y) = \u2212 \u2211 i yi log(y\u0302i)\nFor hard classification problems in which each training example has a single correct class assignment, y is a one-hot vector representing the true class. In such cases, the cross entropy can be simplified to:\nLcross\u2212entropy(hard classification)(y\u0302,y) = \u2212 log(y\u0302t)\nwhere t is the correct class assignment. This attempts to set the probability mass assigned to the correct class t to 1. Because the scores y\u0302 have been transformed using the softmax function and represent a conditional distribution, increasing the mass assigned to the correct class means decreasing the mass assigned to all the other classes.\nThe cross-entropy loss is very common in the neural networks literature, and produces a multi-class classifier which does not only predict the one-best class label but but also predicts a distribution over the possible labels. When using the cross-entropy loss, it is assumed that the network\u2019s output is transformed using the softmax transformation.\nRanking losses In some settings, we are not given supervision in term of labels, but rather as pairs of correct and incorrect items x and x\u2032, and our goal is to score correct items above incorrect ones. Such training situations arise when we have only positive examples, and generate negative examples by corrupting a positive example. A useful loss in such scenarios is the margin-based ranking loss, defined for a pair of correct and incorrect examples:\nLranking(margin)(x,x \u2032) = max(0, 1\u2212 (NN(x)\u2212NN(x\u2032)))\nwhere NN(x) is the score assigned by the network for input vector x. The objective is to score (rank) correct inputs over incorrect ones with a margin of at least 1.\nA common variation is to use the log version of the ranking loss:\nLranking(log)(x,x \u2032) = log(1 + exp(\u2212(NN(x)\u2212NN(x\u2032))))\nExamples using the ranking hinge loss in language tasks include training with the auxiliary tasks used for deriving pre-trained word embeddings (see section 5), in which we are given a correct word sequence and a corrupted word sequence, and our goal is to score the correct sequence above the corrupt one (Collobert & Weston, 2008). Similarly, Van de Cruys (2014) used the ranking loss in a selectional-preferences task, in which the network was trained to rank correct verb-object pairs above incorrect, automatically derived ones, and (Weston, Bordes, Yakhnenko, & Usunier, 2013) trained a model to score correct (head,relation,trail) triplets above corrupted ones in an information-extraction setting. An example of using the ranking log loss can be found in (Gao et al., 2014). A variation of the ranking log loss allowing for a different margin for the negative and positive class is given in (dos Santos et al., 2015)."}, {"heading": "5. Word Embeddings", "text": "A main component of the neural-network approach is the use of embeddings \u2013 representing each feature as a vector in a low dimensional space. But where do the vectors come from? This section will survey the common approaches."}, {"heading": "5.1 Random Initialization", "text": "When enough supervised training data is available, one can just treat the feature embeddings the same as the other model parameters: initialize the embedding vectors to random values, and let the network-training procedure tune them into \u201cgood\u201d vectors.\nSome care has to be taken in the way the random initialization is performed. The method used by the effective word2vec implementation (Mikolov et al., 2013; Mikolov, Sutskever, Chen, Corrado, & Dean, 2013) is to initialize the word vectors to uniformly sampled random numbers in the range [\u2212 12d , 12d ] where d is the number of dimensions. Another option is to use xavier initialization (see Section 6.3) and initialize with uniformly sampled values from[ \u2212 \u221a\n6\u221a d , \u221a 6\u221a d\n] .\nIn practice, one will often use the random initialization approach to initialize the embedding vectors of commonly occurring features, such as part-of-speech tags or individual letters, while using some form of supervised or unsupervised pre-training to initialize the potentially rare features, such as features for individual words. The pre-trained vectors can then either be treated as fixed during the network training process, or, more commonly, treated like the randomly-initialized vectors and further tuned to the task at hand."}, {"heading": "5.2 Supervised Task-specific Pre-training", "text": "If we are interested in task A, for which we only have a limited amount of labeled data (for example, syntactic parsing), but there is an auxiliary task B (say, part-of-speech tagging) for which we have much more labeled data, we may want to pre-train our word vectors so that they perform well as predictors for task B, and then use the trained vectors for training task A. In this way, we can utilize the larger amounts of labeled data we have for task B. When training task A we can either treat the pre-trained vectors as fixed, or tune them further for task A. Another option is to train jointly for both objectives, see Section 7 for more details."}, {"heading": "5.3 Unsupervised Pre-training", "text": "The common case is that we do not have an auxiliary task with large enough amounts of annotated data (or maybe we want to help bootstrap the auxiliary task training with better vectors). In such cases, we resort to \u201cunsupervised\u201d methods, which can be trained on huge amounts of unannotated text.\nThe techniques for training the word vectors are essentially those of supervised learning, but instead of supervision for the task that we care about, we instead create practically\nunlimited number of supervised training instances from raw text, hoping that the tasks that we created will match (or be close enough to) the final task we care about.12\nThe key idea behind the unsupervised approaches is that one would like the embedding vectors of \u201csimilar\u201d words to have similar vectors. While word similarity is hard to define and is usually very task-dependent, the current approaches derive from the distributional hypothesis (Harris, 1954), stating that words are similar if they appear in similar contexts. The different methods all create supervised training instances in which the goal is to either predict the word from its context, or predict the context from the word.\nAn important benefit of training word embeddings on large amounts of unannotated data is that it provides vector representations for words that do not appear in the supervised training set. Ideally, the representations for these words will be similar to those of related words that do appear in the training set, allowing the model to generalize better on unseen events. It is thus desired that the similarity between word vectors learned by the unsupervised algorithm captures the same aspects of similarity that are useful for performing the intended task of the network.\nCommon unsupervised word-embedding algorithms include word2vec 13 (Mikolov et al., 2013, 2013), GloVe (Pennington, Socher, & Manning, 2014) and the Collobert and Weston (2008, 2011) embeddings algorithm. These models are inspired by neural networks and are based on stochastic gradient training. However, they are deeply connected to another family of algorithms which evolved in the NLP and IR communities, and that are based on matrix factorization (see (Levy & Goldberg, 2014b; Levy et al., 2015) for a discussion).\nArguably, the choice of auxiliary problem (what is being predicted, based on what kind of context) affects the resulting vectors much more than the learning method that is being used to train them. We thus focus on the different choices of auxiliary problems that are available, and only skim over the details of the training methods. Several software packages for deriving word vectors are available, including word2vec14 and Gensim15 implementing the word2vec models with word-windows based contexts, word2vecf16 which is a modified version of word2vec allowing the use of arbitrary contexts, and GloVe17 implementing the GloVe model. Many pre-trained word vectors are also available for download on the web.\nWhile beyond the scope of this tutorial, it is worth noting that the word embeddings derived by unsupervised training algorithms have a wide range of applications in NLP beyond using them for initializing the word-embeddings layer of a neural-network model."}, {"heading": "5.4 Training Objectives", "text": "Given a word w and its context c, different algorithms formulate different auxiliary tasks. In all cases, each word is represented as a d-dimensional vector which is initialized to a random value. Training the model to perform the auxiliary tasks well will result in good\n12. The interpretation of creating auxiliary problems from raw text is inspired by Ando and Zhang (Ando & Zhang, 2005a, 2005b). 13. While often treated as a single algorithm, word2vec is actually a software package including various training objectives, optimization methods and other hyperparameters. See (Rong, 2014; Levy, Goldberg, & Dagan, 2015) for a discussion. 14. https://code.google.com/p/word2vec/ 15. https://radimrehurek.com/gensim/ 16. https://bitbucket.org/yoavgo/word2vecf 17. http://nlp.stanford.edu/projects/glove/\nword embeddings for relating the words to the contexts, which in turn will result in the embedding vectors for similar words to be similar to each other.\nLanguage-modeling inspired approaches such as those taken by (Mikolov et al., 2013; Mnih & Kavukcuoglu, 2013) as well as GloVe (Pennington et al., 2014) use auxiliary tasks in which the goal is to predict the word given its context. This is posed in a probabilistic setup, trying to model the conditional probability P (w|c).\nOther approaches reduce the problem to that of binary classification. In addition to the set D of observed word-context pairs, a set D\u0304 is created from random words and context pairings. The binary classification problem is then: does the given (w, c) pair come from D or not? The approaches differ in how the set D\u0304 is constructed, what is the structure of the classifier, and what is the objective being optimized. Collobert and Weston (2008, 2011) take a margin-based binary ranking approach, training a feed-forward neural network to score correct (w, c) pairs over incorrect ones. Mikolov et al (2013, 2014) take instead a probabilistic version, training a log-bilinear model to predict the probability P ((w, c) \u2208 D|w, c) that the pair come from the corpus rather than the random sample."}, {"heading": "5.5 The Choice of Contexts", "text": "In most cases, the contexts of a word are taken to be other words that appear in its surrounding, either in a short window around it, or within the same sentence, paragraph or document. In some cases the text is automatically parsed by a syntactic parser, and the contexts are derived from the syntactic neighbourhood induced by the automatic parse trees. Sometimes, the definitions of words and context change to include also parts of words, such as prefixes or suffixes.\nNeural word embeddings originated from the world of language modeling, in which a network is trained to predict the next word based on a sequence of preceding words (Bengio et al., 2003). There, the text is used to create auxiliary tasks in which the aim is to predict a word based on a context the k previous words. While training for the language modeling auxiliary prediction problems indeed produce useful embeddings, this approach is needlessly restricted by the constraints of the language modeling task, in which one is allowed to look only at the previous words. If we do not care about language modeling but only about the resulting embeddings, we may do better by ignoring this constraint and taking the context to be a symmetric window around the focus word."}, {"heading": "5.5.1 Window Approach", "text": "The most common approach is a sliding window approach, in which auxiliary tasks are created by looking at a sequence of 2k+ 1 words. The middle word is callled the focus word and the k words to each side are the contexts. Then, either a single task is created in which the goal is to predict the focus word based on all of the context words (represented either using CBOW (Mikolov et al., 2013) or vector concatenation (Collobert & Weston, 2008)), or 2k distinct tasks are created, each pairing the focus word with a different context word. The 2k tasks approach, popularized by (Mikolov et al., 2013) is referred to as a skip-gram model. Skip-gram based approaches are shown to be robust and efficient to train (Mikolov et al., 2013; Pennington et al., 2014), and often produce state of the art results.\nEffect of Window Size The size of the sliding window has a strong effect on the resulting vector similarities. Larger windows tend to produce more topical similarities (i.e. \u201cdog\u201d, \u201cbark\u201d and \u201cleash\u201d will be grouped together, as well as \u201cwalked\u201d, \u201crun\u201d and \u201cwalking\u201d), while smaller windows tend to produce more functional and syntactic similarities (i.e. \u201cPoodle\u201d, \u201cPitbull\u201d, \u201cRottweiler\u201d, or \u201cwalking\u201d,\u201crunning\u201d,\u201capproaching\u201d).\nPositional Windows When using the CBOW or skip-gram context representations, all the different context words within the window are treated equally. There is no distinction between context words that are close to the focus words and those that are farther from it, and likewise there is no distinction between context words that appear before the focus words to context words that appear after it. Such information can easily be factored in by using positional contexts: indicating for each context word also its relative position to the focus words (i.e. instead of the context word being \u201cthe\u201d it becomes \u201cthe:+2\u201d, indicating the word appears two positions to the right of the focus word). The use of positional context together with smaller windows tend to produce similarities that are more syntactic, with a strong tendency of grouping together words that share a part of speech, as well as being functionally similar in terms of their semantics. Positional vectors were shown by (Ling, Dyer, Black, & Trancoso, 2015a) to be more effective than window-based vectors when used to initialize networks for part-of-speech tagging and syntactic dependency parsing.\nVariants Many variants on the window approach are possible. One may lemmatize words before learning, apply text normalization, filter too short or too long sentences, or remove capitalization (see, e.g., the pre-processing steps described in (dos Santos & Gatti, 2014). One may sub-sample part of the corpus, skipping with some probability the creation of tasks from windows that have too common or too rare focus words. The window size may be dynamic, using a different window size at each turn. One may weigh the different positions in the window differently, focusing more on trying to predict correctly close word-context pairs than further away ones. Each of these choices will effect the resulting vectors. Some of these hyperparameters (and others) are discussed in (Levy et al., 2015)."}, {"heading": "5.5.2 Sentences, Paragraphs or Documents", "text": "Using a skip-grams (or CBOW) approach, one can consider the contexts of a word to be all the other words that appear with it in the same sentence, paragraph or document. This is equivalent to using very large window sizes, and is expected to result in word vectors that capture topical similarity (words from the same topic, i.e. words that one would expect to appear in the same document, are likely to receive similar vectors)."}, {"heading": "5.5.3 Syntactic Window", "text": "Some work replace the linear context within a sentence with a syntactic one (Levy & Goldberg, 2014a; Bansal, Gimpel, & Livescu, 2014). The text is automatically parsed using a dependency parser, and the context of a word is taken to be the words that are in its proximity in the parse tree, together with the syntactic relation by which they are connected. Such approaches produce highly functional similarities, grouping together words than can fill the same role in a sentence (e.g. colors, names of schools, verbs of movement).\nThe grouping is also syntactic, grouping together words that share an inflection (Levy & Goldberg, 2014a)."}, {"heading": "5.5.4 Multilingual", "text": "Another option is using multilingual, translation based contexts (Hermann & Blunsom, 2014; Faruqui & Dyer, 2014). For example, given a large amount of sentence-aligned parallel text, one can run a bilingual alignment model such as the IBM model 1 or model 2 (i.e. using the GIZA++ software), and then use the produced alignments to derive word contexts. Here, the context of a word instance are the foreign language words that are aligned to it. Such alignments tend to result in synonym words receiving similar vectors. Some authors work instead on the sentence alignment level, without relying on word alignments. An appealing method is to mix a monolingual window-based approach with a multilingual approach, creating both kinds of auxiliary tasks. This is likely to produce vectors that are similar to the window-based approach, but reducing the somewhat undesired effect of the window-based approach in which antonyms (e.g. hot and cold, high and low) tend to receive similar vectors (Faruqui & Dyer, 2014)."}, {"heading": "5.5.5 Character-based and Sub-word Representations", "text": "An interesting line of work attempts to derive the vector representation of a word from the characters that compose it. Such approaches are likely to be particularly useful for tasks which are syntactic in nature, as the character patterns within words are strongly related to their syntactic function. These approaches also have the benefit of producing very small model sizes (only one vector for each character in the alphabet together with a handful of small matrices needs to be stored), and being able to provide an embedding vector for every word that may be encountered. dos Santos and Gatti (2014) and dos Santos and Zadrozny (2014) model the embedding of a word using a convolutional network (see Section 9) over the characters. Ling et al (2015b) model the embedding of a word using the concatenation of the final states of two RNN (LSTM) encoders (Section 10), one reading the characters from left to right, and the other from right to left. Both produce very strong results for part-of-speech tagging. The work of Ballesteros et al (2015) show that the two-LSTMs encoding of (Ling et al., 2015b) is beneficial also for representing words in dependency parsing of morphologically rich languages.\nDeriving representations of words from the representations of their characters is motivated by the unknown words problem \u2013 what do you do when you encounter a word for which you do not have an embedding vector? Working on the level of characters alleviates this problem to a large extent, as the vocabulary of possible characters is much smaller than the vocabulary of possible words. However, working on the character level is very challenging, as the relationship between form (characters) and function (syntax, semantics) in language is quite loose. Restricting oneself to stay on the character level may be an unnecessarily hard constraint. Some researchers propose a middle-ground, in which a word is represented as a combination of a vector for the word itself with vectors of sub-word units that comprise it. The sub-word embeddings then help in sharing information between different words with similar forms, as well as allowing back-off to the subword level when the word is not observed. At the same time, the models are not forced to rely solely on\nform when enough observations of the word are available. Botha and Blunsom (2014) suggest to model the embedding vector of a word as a sum of the word-specific vector if such vector is available, with vectors for the different morphological components that comprise it (the components are derived using Morfessor (Creutz & Lagus, 2007), an unsupervised morphological segmentation method). Gao et al (Gao et al., 2014) suggest using as core features not only the word form itself but also a unique feature (hence a unique embedding vector) for each of the letter-trigrams in the word."}, {"heading": "6. Neural Network Training", "text": "Neural network training is done by trying to minimize a loss function over a training set, using a gradient-based method. Roughly speaking, all training methods work by repeatedly computing an estimate of the error over the dataset, computing the gradient with respect to the error, and then moving the parameters in the direction of the gradient. Models differ in how the error estimate is computed, and how \u201cmoving in the direction of the gradient\u201d is defined. We describe the basic algorithm, stochastic gradient descent (SGD), and then briefly mention the other approaches with pointers for further reading. Gradient calculation is central to the approach. Gradients can be efficiently and automatically computed using reverse mode differentiation on a computation graph \u2013 a general algorithmic framework for automatically computing the gradient of any network and loss function."}, {"heading": "6.1 Stochastic Gradient Training", "text": "The common approach for training neural networks is using the stochastic gradient descent (SGD) algorithm (Bottou, 2012; LeCun, Bottou, Orr, & Muller, 1998a) or a variant of it. SGD is a general optimization algorithm. It receives a function f parameterized by \u03b8, a loss function, and desired input and output pairs. It then attempts to set the parameters \u03b8 such that the loss of f with respect to the training examples is small. The algorithm works as follows:\nAlgorithm 1 Online Stochastic Gradient Descent Training\n1: Input: Function f(x; \u03b8) parameterized with parameters \u03b8. 2: Input: Training set of inputs x1, . . . ,xn and outputs y1, . . . ,yn. 3: Input: Loss function L. 4: while stopping criteria not met do 5: Sample a training example xi,yi 6: Compute the loss L(f(xi; \u03b8),yi) 7: g\u0302\u2190 gradients of L(f(xi; \u03b8),yi) w.r.t \u03b8 8: \u03b8 \u2190 \u03b8 + \u03b7kg\u0302 9: return \u03b8\nThe goal of the algorithm is to set the parameters \u03b8 so as to minimize the total loss\u2211n i=1 L(f(xi; \u03b8),yi) over the training set. It works by repeatedly sampling a training example and computing the gradient of the error on the example with respect to the parameters \u03b8 (line 7) \u2013 the input and expected output are assumed to be fixed, and the loss is treated as a function of the parameters \u03b8. The parameters \u03b8 are then updated in the direction of the gradient, scaled by a learning rate \u03b7k (line 8). For further discussion on setting the learning rate, see Section 6.3.\nNote that the error calculated in line 6 is based on a single training example, and is thus just a rough estimate of the corpus-wide loss that we are aiming to minimize. The noise in the loss computation may result in inaccurate gradients. A common way of reducing this noise is to estimate the error and the gradients based on a sample of m examples. This gives rise to the minibatch SGD algorithm:\nAlgorithm 2 Minibatch Stochastic Gradient Descent Training\n1: Input: Function f(x; \u03b8) parameterized with parameters \u03b8. 2: Input: Training set of inputs x1, . . . ,xn and outputs y1, . . . ,yn. 3: Input: Loss function L. 4: while stopping criteria not met do 5: Sample a minibatch of m examples {(x1,y1), . . . , (xm,ym)} 6: g\u0302\u2190 0 7: for i = 1 to m do 8: Compute the loss L(f(xi; \u03b8),yi) 9: g\u0302\u2190 g\u0302 + gradients of 1mL(f(xi; \u03b8),yi) w.r.t \u03b8\n10: \u03b8 \u2190 \u03b8 + \u03b7kg\u0302 11: return \u03b8\nIn lines 6 \u2013 9 the algorithm estimates the gradient of the corpus loss based on the minibatch. After the loop, g\u0302 contains the gradient estimate, and the parameters \u03b8 are updated toward g\u0302. The minibatch size can vary in size from m = 1 to m = n. Higher values provide better estimates of the corpus-wide gradients, while smaller values allow more updates and in turn faster convergence. Besides the improved accuracy of the gradients estimation, the minibatch algorithm provides opportunities for improved training efficiency. For modest sizes of m, some computing architectures (i.e. GPUs) allow an efficient parallel implementation of the computation in lines 6\u20139. With a small enough learning rate, SGD is guaranteed to converge to a global optimum if the function is convex. However, it can also be used to optimize non-convex functions such as neural-network. While there are no longer guarantees of finding a global optimum, the algorithm proved to be robust and performs well in practice.\nWhen training a neural network, the parameterized function f is the neural network, and the parameters \u03b8 are the layer-transfer matrices, bias terms, embedding matrices and so on. The gradient computation is a key step in the SGD algorithm, as well as in all other neural network training algorithms. The question is, then, how to compute the gradients of the network\u2019s error with respect to the parameters. Fortunately, there is an easy solution in the form of the backpropagation algorithm (Rumelhart, Hinton, & Williams, 1986; Lecun, Bottou, Bengio, & Haffner, 1998b). The backpropagation algorithm is a fancy name for methodologically computing the derivatives of a complex expression using the chainrule, while caching intermediary results. More generally, the backpropagation algorithm is a special case of the reverse-mode automatic differentiation algorithm (Neidinger, 2010, Section 7), (Baydin, Pearlmutter, Radul, & Siskind, 2015; Bengio, 2012).The following section describes reverse mode automatic differentiation in the context of the computation graph abstraction.\nBeyond SGD While the SGD algorithm can and often does produce good results, more advanced algorithms are also available. The SGD+Momentum (Polyak, 1964) and Nesterov Momentum (Sutskever, Martens, Dahl, & Hinton, 2013) algorithms are variants of SGD in which previous gradients are accumulated and affect the current update. Adaptive learning rate algorithms including AdaGrad (Duchi, Hazan, & Singer, 2011), AdaDelta (Zeiler, 2012),\nRMSProp (Tieleman & Hinton, 2012) and Adam (Kingma & Ba, 2014) are designed to select the learning rate for each minibatch, sometimes on a per-coordinate basis, potentially alleviating the need of fiddling with learning rate scheduling. For details of these algorithms, see the original papers or (Bengio et al., 2015, Sections 8.3, 8.4). As many neural-network software frameworks provide implementations of these algorithms, it is easy and sometimes worthwhile to try out different variants."}, {"heading": "6.2 The Computation Graph Abstraction", "text": "While one can compute the gradients of the various parameters of a network by hand and implement them in code, this procedure is cumbersome and error prone. For most purposes, it is preferable to use automatic tools for gradient computation (Bengio, 2012). The computation-graph abstraction allows us to easily construct arbitrary networks, evaluate their predictions for given inputs (forward pass), and compute gradients for their parameters with respect to arbitrary scalar losses (backward pass).\nA computation graph is a representation of an arbitrary mathematical computation as a graph. It is a directed acyclic graph (DAG) in which nodes correspond to mathematical operations or (bound) variables and edges correspond to the flow of intermediary values between the nodes. The graph structure defines the order of the computation in terms of the dependencies between the different components. The graph is a DAG and not a tree, as the result of one operation can be the input of several continuations. Consider for example a graph for the computation of (a \u2217 b+ 1) \u2217 (a \u2217 b+ 2):\na b1 2\n* ++\n*\nThe computation of a\u2217b is shared. We restrict ourselves to the case where the computation graph is connected.\nSince a neural network is essentially a mathematical expression, it can be represented as a computation graph.\nFor example, Figure 3a presents the computation graph for a 1-layer MLP with a softmax output transformation. In our notation, oval nodes represent mathematical operations or functions, and shaded rectangle nodes represent parameters (bound variables). Network inputs are treated as constants, and drawn without a surrounding node. Input and parameter nodes have no incoming arcs, and output nodes have no outgoing arcs. The output of each node is a matrix, the dimensionality of which is indicated above the node.\nThis graph is incomplete: without specifying the inputs, we cannot compute an output. Figure 3b shows a complete graph for an MLP that takes three words as inputs, and predicts the distribution over part-of-speech tags for the third word. This graph can be used for prediction, but not for training, as the output is a vector (not a scalar) and the graph does not take into account the correct answer or the loss term. Finally, the graph in 3c shows the computation graph for a specific training example, in which the inputs are the (embeddings\nof) the words \u201cthe\u201d, \u201cblack\u201d, \u201cdog\u201d, and the expected output is \u201cNOUN\u201d (whose index is 5).\nOnce the graph is built, it is straightforward to run either a forward computation (compute the result of the computation) or a backward computation (computing the gradients), as we show below. Constructing the graphs may look daunting, but is actually very easy using dedicated software libraries and APIs.\nForward Computation The forward pass computes the outputs of the nodes in the graph. Since each node\u2019s output depends only on itself and on its incoming edges, it is trivial to compute the outputs of all nodes by traversing the nodes in a topological order and computing the output of each node given the already computed outputs of its predecessors.\nMore formally, in a graph of N nodes, we associate each node with an index i according to their topological ordering. Let fi be the function computed by node i (e.g. multiplication. addition, . . . ). Let \u03c0(i) be the parent nodes of node i, and \u03c0\u22121(i) = {j | i \u2208 \u03c0(j)} the children nodes of node i (these are the arguments of fi). Denote by v(i) the output of node\ni, that is, the application of fi to the output values of its arguments \u03c0 \u22121(i). For variable and input nodes, fi is a constant function and \u03c0 \u22121(i) is empty. The Forward algorithm computes the values v(i) for all i \u2208 [1, N ].\nAlgorithm 3 Computation Graph Forward Pass\n1: for i = 1 to N do 2: Let a1, . . . , am = \u03c0\n\u22121(i) 3: v(i)\u2190 fi(v(a1), . . . , v(am))\nBackward Computation (Derivatives, Backprop) The backward pass begins by designating a node N with scalar (1\u00d7 1) output as a loss-node, and running forward computation up to that node. The backward computation will computes the gradients with respect to that node\u2019s value. Denote by d(i) the quantity \u2202N\n\u2202i . The backpropagation algorithm is\nused to compute the values d(i) for all nodes i. The backward pass fills a table d(i) as follows:\nAlgorithm 4 Computation Graph Backward Pass (Backpropagation)\n1: d(N)\u2190 1 2: for i = N-1 to 1 do\n3: d(i)\u2190\u2211j\u2208\u03c0(i) d(j) \u00b7 \u2202fj\u2202i The quantity\n\u2202fj \u2202i is the partial derivative of fj(\u03c0 \u22121(j)) w.r.t the argument i \u2208 \u03c0\u22121(j).\nThis value depends on the function fj and the values v(a1), . . . , v(am) (where a1, . . . , am = \u03c0\u22121(j)) of its arguments, which were computed in the forward pass.\nThus, in order to define a new kind of node, one need to define two methods: one for calculating the forward value v(i) based on the nodes inputs, and the another for calculating \u2202fi \u2202x\nfor each x \u2208 \u03c0\u22121(i). For further information on automatic differentiation see (Neidinger, 2010, Section 7), (Baydin et al., 2015). For more in depth discussion of the backpropagation algorithm and computation graphs (also called flow graphs) see (Bengio et al., 2015, Section 6.4), (Lecun et al., 1998b; Bengio, 2012). For a popular yet technical presentation, see Chris Olah\u2019s description at http://colah.github.io/posts/2015-08-Backprop/.\nSoftware Several software packages implement the computation-graph model, including Theano18, Chainer19, penne20 and CNN/pyCNN21. All these packages support all the essential components (node types) for defining a wide range of neural network architectures, covering the structures described in this tutorial and more. Graph creation is made almost transparent by use of operator overloading. The framework defines a type for representing graph nodes (commonly called expressions), methods for constructing nodes for inputs and\n18. http://deeplearning.net/software/theano/ 19. http://chainer.org 20. https://bitbucket.org/ndnlp/penne 21. https://github.com/clab/cnn\nparameters, and a set of functions and mathematical operations that take expressions as input and result in more complex expressions. For example, the python code for creating the computation graph from Figure (3c) using the pyCNN framework is:\nfrom pycnn import * # model initialization. model = Model() model.add_parameters(\"W1\", (20,150)) model.add_parameters(\"b1\", 20) model.add_parameters(\"W2\", (17,20)) model.add_parameters(\"b2\", 17) model.add_lookup_parameters(\"words\", (100, 50))\n# Building the computation graph: renew_cg() # create a new graph. # Wrap the model parameters as graph-nodes. W1 = parameter(model[\"W1\"]) b1 = parameter(model[\"b1\"]) W2 = parameter(model[\"W2\"]) b2 = parameter(model[\"b2\"]) def get_index(x): return 1 # Generate the embeddings layer. vthe = lookup(model[\"words\"], get_index(\"the\")) vblack = lookup(model[\"words\"], get_index(\"black\")) vdog = lookup(model[\"words\"], get_index(\"dog\"))\n# Connect the leaf nodes into a complete graph. x = concatenate([vthe, vblack, vdog]) output = softmax(W2*(tanh(W1*x)+b1)+b2) loss = -log(pick(output, 5))\nloss_value = loss.forward() loss.backward() # the gradient is computed\n# and stored in the corresponding # parameters.\nMost of the code involves various initializations: the first block defines model parameters that are be shared between different computation graphs (recall that each graph corresponds to a specific training example). The second block turns the model parameters into the graphnode (Expression) types. The third block retrieves the Expressions for the embeddings of the input words. Finally, the fourth block is where the graph is created. Note how transparent the graph creation is \u2013 there is an almost a one-to-one correspondence between creating the graph and describing it mathematically. The last block shows a forward and backward pass. The other software frameworks follow similar patterns.\nTheano involves an optimizing compiler for computation graphs, which is both a blessing and a curse. On the one hand, once compiled, large graphs can be run efficiently on either the CPU or a GPU, making it ideal for large graphs with a fixed structure, where only the inputs change between instances. However, the compilation step itself can be costly, and it makes the interface a bit cumbersome to work with. In contrast, the other packages focus on building large and dynamic computation graphs and executing them \u201con the fly\u201d without a compilation step. While the execution speed may suffer with respect to Theano\u2019s optimized version, these packages are especially convenient when working with the recurrent and\nrecursive networks described in Sections 10, 12 as well as in structured prediction settings as described in Section 8.\nImplementation Recipe Using the computation graph abstraction, the pseudo-code for a network training algorithm is given in Algorithm 5.\nAlgorithm 5 Neural Network Training with Computation Graph Abstraction (using minibatches of size 1)\n1: Define network parameters. 2: for iteration = 1 to N do 3: for Training example xi,yi in dataset do 4: loss node \u2190 build computation graph(xi, yi, parameters) 5: loss node.forward() 6: gradients \u2190 loss node().backward() 7: parameters \u2190 update parameters(parameters, gradients) 8: return parameters.\nHere, build computation graph is a user-defined function that builds the computation graph for the given input, output and network structure, returning a single loss node. update parameters is an optimizer specific update rule. The recipe specifies that a new graph is created for each training example. This accommodates cases in which the network structure varies between training example, such as recurrent and recursive neural networks, to be discussed in Sections 10 \u2013 12. For networks with fixed structures, such as an MLPs, it may be more efficient to create one base computation graph and vary only the inputs and expected outputs between examples.\nNetwork Composition As long as the network\u2019s output is a vector (1 \u00d7 k matrix), it is trivial to compose networks by making the output of one network the input of another, creating arbitrary networks. The computation graph abstractions makes this ability explicit: a node in the computation graph can itself be a computation graph with a designated output node. One can then design arbitrarily deep and complex networks, and be able to easily evaluate and train them thanks to automatic forward and gradient computation. This makes it easy to define and train networks for structured outputs and multi-objective training, as we discuss in Section 7, as well as complex recurrent and recursive networks, as discussed in Sections 10\u201312."}, {"heading": "6.3 Optimization Issues", "text": "Once the gradient computation is taken care of, the network is trained using SGD or another gradient-based optimization algorithm. The function being optimized is not convex, and for a long time training of neural networks was considered a \u201cblack art\u201d which can only be done by selected few. Indeed, many parameters affect the optimization process, and care has to be taken to tune these parameters. While this tutorial is not intended as a comprehensive guide to successfully training neural networks, we do list here a few of the prominent issues. For further discussion on optimization techniques and algorithms for neural networks, refer to (Bengio et al., 2015, Chapter 8). For some theoretical discussion and analysis, refer\nto (Glorot & Bengio, 2010). For various practical tips and recommendations, see (LeCun et al., 1998a; Bottou, 2012).\nInitialization The non-convexity of the loss function means the optimization procedure may get stuck in a local minimum or a saddle point, and that starting from different initial points (e.g. different random values for the parameters) may result in different results. Thus, it is advised to run several restarts of the training starting at different random initializations, and choosing the best one based on a development set.22 The amount of variance in the results is different for different network formulations and datasets, and cannot be predicted in advance.\nThe magnitude of the random values has an important effect on the success of training. An effective scheme due to Glorot and Bengio (2010), called xavier initialization after Glorot\u2019s first name, suggests initializing a weight matrix W \u2208 Rdin\u00d7dout as:\nW \u223c U [ \u2212 \u221a 6\u221a\ndin + dout ,+\n\u221a 6\u221a\ndin + dout\n]\nwhere U [a, b] is a uniformly sampled random value in the range [a, b]. This advice works well on many occasions, and is the preferred default initialization method by many.\nAnalysis by He et al (2015) suggests that when using ReLU non-linearities, the weights should be initialized by sampling from a zero-mean Gaussian distribution whose standard deviation is \u221a\n2 din . This initialization was found by He et al to work better than xavier\ninitialization in an image classification task, especially when deep networks were involved.\nVanishing and Exploding Gradients In deep networks, it is common for the error gradients to either vanish (become exceedingly close to 0) or explode (become exceedingly high) as they propagate back through the computation graph. The problem becomes more severe in deeper networks, and especially so in recursive and recurrent networks (Pascanu, Mikolov, & Bengio, 2012). Dealing with the vanishing gradients problem is still an open research question. Solutions include making the networks shallower, step-wise training (first train the first layers based on some auxiliary output signal, then fix them and train the upper layers of the complete network based on the real task signal), or specialized architectures that are designed to assist in gradient flow (e.g., the LSTM and GRU architectures for recurrent networks, discussed in Section 11). Dealing with the exploding gradients has a simple but very effective solution: clipping the gradients if their norm exceeds a given threshold. Let g\u0302 be the gradients of all parameters in the network, and \u2016g\u0302\u2016 be their L2 norm. Pascanu et al (2012) suggest to set: g\u0302\u2190 threshold\u2016g\u0302\u2016 g\u0302 if \u2016g\u0302\u2016 > threshold. Saturation and Dead Neurons Layers with tanh and sigmoid activations can become saturated \u2013 resulting in output values for that layer that are all close to one, the upperlimit of the activation function. Saturated neurons have very small gradients, and should be avoided. Layers with the ReLU activation cannot be saturated, but can \u201cdie\u201d \u2013 most or all values are negative and thus clipped at zero for all inputs, resulting in a gradient of zero for that layer. If your network does not train well, it is advisable to monitor the network for saturated or dead layers. Saturated neurons are caused by too large values\n22. When debugging, and for reproducibility of results, it is advised to used a fixed random seed.\nentering the layer. This may be controlled for by changing the initialization, scaling the range of the input values, or changing the learning rate. Dead neurons are caused by all weights entering the layer being negative (for example this can happen after a large gradient update). Reducing the learning rate will help in this situation. For saturated layers, another option is to normalize the values in the saturated layer after the activation, i.e. instead of g(h) = tanh(h) using g(h) = tanh(h)\u2016tanh(h)\u2016 . Layer normalization is an effective measure for countering saturation, but is also expensive in terms of gradient computation.\nShuffling The order in which the training examples are presented to the network is important. The SGD formulation above specifies selecting a random example in each turn. In practice, most implementations go over the training example in order. It is advised to shuffle the training examples before each pass through the data.\nLearning Rate Selection of the learning rate is important. Too large learning rates will prevent the network from converging on an effective solution. Too small learning rates will take very long time to converge. As a rule of thumb, one should experiment with a range of initial learning rates in range [0, 1], e.g. 0.001, 0.01, 0.1, 1. Monitor the network\u2019s loss over time, and decrease the learning rate once the network seem to be stuck in a fixed region. Learning rate scheduling decrease the rate as a function of the number of observed minibatches. A common schedule is dividing the initial learning rate by the iteration number. Le\u0301on Bottou (2012) recommends using a learning rate of the form \u03b7t = \u03b70(1 + \u03b70\u03bbt)\n\u22121 where \u03b70 is the initial learning rate, \u03b7t is the learning rate to use on the tth training example, and \u03bb is an additional hyperparameter. He further recommends determining a good value of \u03b70 based on a small sample of the data prior to running on the entire dataset.\nMinibatches Parameter updates occur either every training example (minibatches of size 1) or every k training examples. Some problems benefit from training with larger minibatch sizes. In terms of the computation graph abstraction, one can create a computation graph for each of the k training examples, and then connecting the k loss nodes under an averaging node, whose output will be the loss of the minibatch. Large minibatched training can also be beneficial in terms of computation efficiency on specialized computing architectures such as GPUs. This is beyond the scope of this tutorial."}, {"heading": "6.4 Regularization", "text": "Neural network models have many parameters, and overfitting can easily occur. Overfitting can be alleviated to some extent by regularization. A common regularization method is L2 regularization, placing a squared penalty on parameters with large values by adding an additive \u03bb2\u2016\u03b8\u20162 term to the objective function to be minimized, where \u03b8 is the set of model parameters, \u2016 \u00b7 \u20162 is the squared L2 norm (sum of squares of the values), and \u03bb is a hyperparameter controlling the amount of regularization.\nA recently proposed alternative regularization method is dropout (Hinton, Srivastava, Krizhevsky, Sutskever, & Salakhutdinov, 2012). The dropout method is designed to prevent the network from learning to rely on specific weights. It works by randomly dropping (setting to 0) half of the neurons in the network (or in a specific layer) in each training example. Work by Wager et al (2013) establishes a strong connection between the dropout method\nand L2 regularization. Gal and Gharamani (2015) show that a multi-layer perceptron with dropout applied at every layer can be interpreted as Bayesian model averaging.\nThe dropout technique is one of the key factors contributing to very strong results of neural-network methods on image classification tasks (Krizhevsky, Sutskever, & Hinton, 2012), especially when combined with ReLU activation units (Dahl, Sainath, & Hinton, 2013). The dropout technique is effective also in NLP applications of neural networks."}, {"heading": "7. Cascading and Multi-task Learning", "text": "The combination of online training methods with automatic gradient computations using the computation graph abstraction allows for an easy implementation of model cascading, parameter sharing and multi-task learning.\nModel cascading is a powerful technique in which large networks are built by composing them out of smaller component networks. For example, we may have a feed-forward network for predicting the part of speech of a word based on its neighbouring words and/or the characters that compose it. In a pipeline approach, we would use this network for predicting parts of speech, and then feed the predictions as input features to neural network that does syntactic chunking or parsing. Instead, we could think of the hidden layers of this network as an encoding that captures the relevant information for predicting the part of speech. In a cascading approach, we take the hidden layers of this network and connect them (and not the part of speech prediction themselves) as the inputs for the syntactic network. We now have a larger network that takes as input sequences of words and characters, and outputs a syntactic structure. The computation graph abstraction allows us to easily propagate the error gradients from the syntactic task loss all the way back to the characters.\nTo combat the vanishing gradient problem of deep networks, as well as to make better use of available training material, the individual component network\u2019s parameters can be bootstrapped by training them separately on a relevant task, before plugging them in to the larger network for further tuning. For example, the part-of-speech predicting network can be trained to accurately predict parts-of-speech on a relatively large annotated corpus, before plugging its hidden layer into the syntactic parsing network for which less training data is available. In case the training data provide direct supervision for both tasks, we can make use of it during training by creating a network with two outputs, one for each task, computing a separate loss for each output, and then summing the losses into a single node from which we backpropagate the error gradients.\nModel cascading is very common when using convolutional, recursive and recurrent neural networks, where, for example, a recurrent network is used to encode a sentence into a fixed sized vector, which is then used as the input of another network. The supervision signal of the recurrent network comes primarily from the upper network that consumes the recurrent network\u2019s output as it inputs.\nMulti-task learning is used when we have related prediction tasks that do not necessarily feed into one another, but we do believe that information that is useful for one type of prediction can be useful also to some of the other tasks. For example, chunking, named entity recognition (NER) and language modeling are examples of synergistic tasks. Information for predicting chunk boundaries, named-entity boundaries and the next word in the sentence all rely on some shared underlying syntactic-semantic representation. Instead of training a separate network for each task, we can create a single network with several outputs. A common approach is to have a multi-layer feed-forward network, whose final hidden layer (or a concatenation of all hidden layers) is then passed to different output layers. This way, most of the parameters of the network are shared between the different tasks. Useful information learned from one task can then help to disambiguate other tasks. Again, the computation graph abstraction makes it very easy to construct such networks and compute\nthe gradients for them, by computing a separate loss for each available supervision signal, and then summing the losses into a single loss that is used for computing the gradients. In case we have several corpora, each with different kind of supervision signal (e.g. we have one corpus for NER and another for chunking), the training procedure will shuffle all of the available training example, performing gradient computation and updates with respect to a different loss in every turn. Multi-task learning in the context of language-processing is introduced and discussed in (Collobert et al., 2011)."}, {"heading": "8. Structured Output Prediction", "text": "Many problems in NLP involve structured outputs: cases where the desired output is not a class label or distribution over class labels, but a structured object such as a sequence, a tree or a graph. Canonical examples are sequence tagging (e.g. part-of-speech tagging) sequence segmentation (chunking, NER), and syntactic parsing. In this section, we discuss how feed-forward neural network models can be used for structured tasks. In later sections we discuss specialized neural network models for dealing with sequences (Section 10) and trees (Section 12)."}, {"heading": "8.1 Greedy Structured Prediction", "text": "The greedy approach to structured prediction is to decompose the structure prediction problem into a sequence of local prediction problems and training a classifier to perform each local decision. At test time, the trained classifier is used in a greedy manner. Examples of this approach are left-to-right tagging models (Gime\u0301nez & Ma\u0300rquez, 2004) and greedy transition-based parsing (Nivre, 2008). Such approaches are easily adapted to use neural networks by simply replacing the local classifier from a linear classifier such as an SVM or a logistic regression model to a neural network, as demonstrated in (Chen & Manning, 2014; Lewis & Steedman, 2014).\nThe greedy approaches suffer from error propagation, where mistakes in early decisions carry over and influence later decisions. The overall higher accuracy achievable with nonlinear neural network classifiers helps in offsetting this problem to some extent. In addition, training techniques were proposed for mitigating the error propagation problem by either attempting to take easier predictions before harder ones (the easy-first approach (Goldberg & Elhadad, 2010)) or making training conditions more similar to testing conditions by exposing the training procedure to inputs that result from likely mistakes (Hal Daume\u0301 III, Langford, & Marcu, 2009; Goldberg & Nivre, 2013). These are effective also for training greedy neural network models, as demonstrated by Ma et al (Ma, Zhang, & Zhu, 2014) (easy-first tagger) and (?) (dynamic oracle training for greedy dependency parsing)."}, {"heading": "8.2 Search Based Structured Prediction", "text": "The common approach to predicting natural language structures is search based. For indepth discussion of search-based structure prediction in NLP, see the book by Smith (Smith, 2011). The techniques can easily be adapted to use a neural-network. In the neural-networks literature, such models were discussed under the framework of energy based learning (LeCun et al., 2006, Section 7). They are presented here using setup and terminology familiar to the NLP community.\nSearch-based structured prediction is formulated as a search problem over possible structures:\npredict(x) = arg max y\u2208Y(x) score(x, y)\nwhere x is an input structure, y is an output over x (in a typical example x is a sentence and y is a tag-assignment or a parse-tree over the sentence), Y(x) is the set of all valid\nstructures over x, and we are looking for an output y that will maximize the score of the x, y pair.\nThe scoring function is defined as a linear model:\nscore(x, y) = \u03a6(x, y) \u00b7w\nwhere \u03a6 is a feature extraction function and w is a weight vector. In order to make the search for the optimal y tractable, the structure y is decomposed into parts, and the feature function is defined in terms of the parts, where \u03c6(p) is a part-local feature extraction function:\n\u03a6(x, y) = \u2211\np\u2208parts(x,y) \u03c6(p)\nEach part is scored separately, and the structure score is the sum of the component parts scores:\nscore(x, y) =w \u00b7 \u03a6(x, y) = w \u00b7 \u2211 p\u2208y \u03c6(p) = \u2211 p\u2208y w \u00b7 \u03c6(p) = \u2211 p\u2208y score(p)\nwhere p \u2208 y is a shorthand for p \u2208 parts(x, y). The decomposition of y into parts is such that there exists an inference algorithm that allows for efficient search for the best scoring structure given the scores of the individual parts.\nOne can now trivially replace the linear scoring function over parts with a neuralnetwork:\nscore(x, y) = \u2211 p\u2208y score(p) = \u2211 p\u2208y NN(c(p))\nwhere c(p) maps the part p into a din dimensional vector. In case of a one hidden-layer feed-forward network:\nscore(x, y) = \u2211 p\u2208y NNMLP1(c(p)) = \u2211 p\u2208y (g(c(p)W1 + b1))w\nc(p) \u2208 Rdin , W1 \u2208 Rdin\u00d7d1 , b1 \u2208 Rd1 , w \u2208 Rd1 . A common objective in structured prediction is making the gold structure y score higher than any other structure y\u2032, leading to the following (generalized perceptron) loss:\nmax y\u2032\nscore(x, y\u2032)\u2212 score(x, y)\nIn terms of implementation, this means: create a computation graph CGp for each of the possible parts, and calculate its score. Then, run inference over the scored parts to find the best scoring structure y\u2032. Connect the output nodes of the computation graphs corresponding to parts in the gold (predicted) structure y (y\u2032) into a summing node CGy (CG\u2032y). Connect CGy and CG \u2032 y using a \u201cminus\u201d node, CGl, and compute the gradients.\nAs argued in (LeCun et al., 2006, Section 5), the generalized perceptron loss may not be a good loss function when training structured prediction neural networks as it does not have a margin, and a margin-based hinge loss is preferred:\nmax(0,m+ score(x, y)\u2212max y\u2032 6=y\nscore(x, y\u2032))\nIt is trivial to modify the implementation above to work with the hinge loss.\nNote that in both cases we lose the nice properties of the linear model. In particular, the model is no longer convex. This is to be expected, as even the simplest non-linear neural network is already non-convex. Nonetheless, we could still use standard neural-network optimization techniques to train the structured model.\nTraining and inference is slower, as we have to evaluate the neural network (and take gradients) |parts(x, y)| times.\nStructured prediction is a vast field and is beyond the scope of this tutorial, but loss functions, regularizers and methods described in, e.g., (Smith, 2011), such as cost-augmented decoding, can be easily applied or adapted to the neural-network framework.23\nProbabilistic objective (CRF) In a probabilistic framework (\u201cCRF\u201d), we treat each of the parts scores as a clique potential (see (Smith, 2011)) and define the score of each structure y to be:\nscoreCRF (x, y) = P (y|x) = \u2211 p\u2208y e score(p)\u2211\ny\u2032\u2208Y(x) \u2211 p\u2208y\u2032 e score(p) =\n\u2211 p\u2208y e\nNN(c(p))\u2211 y\u2032\u2208Y(x) \u2211 p\u2208y\u2032 e NN(c(p))\nThe scoring function defines a conditional distribution P (y|x), and we wish to set the parameters of the network such that corpus conditional log likelihood \u2211 (xi,yi)\u2208training logP (yi|xi) is maximized.\nThe loss for a given training example (x, y) is then: \u2212 log scoreCRF (x, y). Taking the gradient with respect to the loss is as involved as building the associated computation graph. The tricky part is the denominator (the partition function) which requires summing over the potentially exponentially many structures in Y. However, for some problems, a dynamic programming algorithm exists for efficiently solving the summation in polynomial time. When such an algorithm exists, it can be adapted to also create a polynomial-size computation graph.\nWhen an efficient enough algorithm for computing the partition function is not available, approximate methods can be used. For example, one may use beam search for inference, and for the partition function sum over the structures remaining in the beam instead of over the exponentially large Y(x).\nA hinge based approached was used by Pei et al (2015) for arc-factored dependency parsing, and the probabilistic approach by Durrett and Klein (Durrett & Klein, 2015) for a CRF constituency parser. The approximate beam-based partition function was effectively used by Zhou et al (2015) in a transition based parser.\nReranking When searching over all possible structures is intractable, inefficient or hard to integrate into a model, reranking methods are often used. In the reranking framework (Charniak & Johnson, 2005; Collins & Koo, 2005) a base model is used to produce a\n23. One should keep in mind that the resulting objectives are no longer convex, and so lack the formal guarantees and bounds associated with convex optimization problems. Similarly, the theory, learning bounds and guarantees associated with the algorithms do not automatically transfer to the neural versions.\nlist of the k-best scoring structures. A more complex model is then trained to score the candidates in the k-best list such that the best structure with respect to the gold one is scored highest. As the search is now performed over k items rather than over an exponential space, the complex model can condition on (extract features from) arbitrary aspects of the scored structure. Reranking methods are natural candidates for structured prediction using neural-network models, as they allow the modeler to focus on the feature extraction and network structure, while removing the need to integrate the neural network scoring into a decoder. Indeed, reranking methods are often used for experimenting with neural models that are not straightforward to integrate into a decoder, such as convolutional, recurrent and recursive networks, which will be discussed in later sections. Works using the reranking approach include (Socher et al., 2013; Auli et al., 2013; Le & Zuidema, 2014; Zhu et al., 2015a)\nMEMM and hybrid approaches Other formulations are, of course, also possible. For example, an MEMM (McCallum, Freitag, & Pereira, 2000) can be trivially adapted to the neural network world by replacing the logistic regression (\u201cMaximum Entropy\u201d) component with an MLP.\nHybrid approaches between neural networks and linear models are also explored. In particular, Weiss et al (Weiss et al., 2015) report strong results for transition-based dependency parsing in a two-stage model. In the first stage, a static feed-forward neural network (MLP2) is trained to perform well on each of the individual decisions of the structured problem in isolation. In the second stage, the neural network model is held fixed, and the different layers (output as well as hidden layer vectors) for each input are then concatenated and used as the input features of a linear structured perceptron model (Collins, 2002) that is trained to perform beam-search for the best resulting structure. While it is not clear that such training regime is more effective than training a single structured-prediction neural network, the use of two simpler, isolated models allowed the researchers to perform a much more extensive hyper-parameter search (e.g. tuning layer sizes, activation functions, learning rates and so on) for each model than is feasible with more complicated networks."}, {"heading": "9. Convolutional Layers", "text": "Sometimes we are interested in making predictions based on ordered sets of items (e.g. the sequence of words in a sentence, the sequence of sentences in a document and so on). Consider for example predicting the sentiment (positive, negative or neutral) of a sentence. Some of the sentence words are very informative of the sentiment, other words are less informative, and to a good approximation, an informative clue is informative regardless of its position in the sentence. We would like to feed all of the sentence words into a learner, and let the training process figure out the important clues. One possible solution is feeding a CBOW representation into a fully connected network such as an MLP. However, a downside of the CBOW approach is that it ignores the ordering information completely, assigning the sentences \u201cit was not good, it was actually quite bad\u201d and \u201cit was not bad, it was actually quite good\u201d the exact same representation. While the global position of the indicators \u201cnot good\u201d and \u201cnot bad\u201d does not matter for the classification task, the local ordering of the words (that the word \u201cnot\u201d appears right before the word \u201cbad\u201d) is very important. A naive approach would suggest embedding word-pairs (bi-grams) rather than words, and building a CBOW over the embedded bigrams. While such architecture could be effective, it will result in huge embedding matrices, will not scale for longer n-grams, and will suffer from data sparsity problems as it does not share statistical strength between different n-grams (the embedding of \u201cquite good\u201d and \u201cvery good\u201d are completely independent of one another, so if the learner saw only one of them during training, it will not be able to deduce anything about the other based on its component words). The convolution-andpooling (also called convolutional neural networks, or CNNs) architecture is an elegant and robust solution to the this modeling problem. A convolutional neural network is designed to identify indicative local predictors in a large structure, and combine them to produce a fixed size vector representation of the structure, capturing these local aspects that are most informative for the prediction task at hand.\nConvolution-and-pooling architectures (LeCun & Bengio, 1995) evolved in the neural networks vision community, where they showed great success as object detectors \u2013 recognizing an object from a predefined category (\u201ccat\u201d, \u201cbicycles\u201d) regardless of its position in the image (Krizhevsky et al., 2012). When applied to images, the architecture is using 2- dimensional (grid) convolutions. When applied to text, NLP we are mainly concerned with 1-d (sequence) convolutions. Convolutional networks were introduced to the NLP community in the pioneering work of Collobert, Weston and Colleagues (2011) who used them for semantic-role labeling, and later by Kalchbrenner et al (2014) and Kim (Kim, 2014) who used them for sentiment and question-type classification."}, {"heading": "9.1 Basic Convolution + Pooling", "text": "The main idea behind a convolution and pooling architecture for language tasks is to apply a non-linear (learned) function over each instantiation of a k-word sliding window over the sentence. This function (also called \u201cfilter\u201d) transforms a window of k words into a d dimensional vector that captures important properties of the words in the window (each dimension is sometimes referred to in the literature as a \u201cchannel\u201d). Then, a \u201cpooling\u201d operation is used combine the vectors resulting from the different windows into a single d-dimensional vector, by taking the max or the average value observed in each of the d\nchannels over the different windows. The intention is to focus on the most important \u201cfeatures\u201d in the sentence, regardless of their location. The d-dimensional vector is then fed further into a network that is used for prediction. The gradients that are propagated back from the network\u2019s loss during the training process are used to tune the parameters of the filter function to highlight the aspects of the data that are important for the task the network is trained for. Intuitively, when the sliding window is run over a sequence, the filter function learns to identify informative k-grams.\nMore formally, consider a sequence of words x = x1, . . . , xn, each with their corresponding demb dimensional word embedding v(xi). A 1d convolution layer\n24 of width k works by moving a sliding window of size k over the sentence, and applying the same \u201cfilter\u201d to each window in the sequence (v(xi); v(xi+1), . . . ; v(xi+k\u22121). The filter function is usually a linear transformation followed by a non-linear activation function.\nLet the concatenated vector of the ith window be wi = v(xi); v(xi+1); v(xi+k\u22121), wi \u2208 Rkdemb . Depending on whether we pad the sentence with k \u2212 1 words to each side, we may get either m = n\u2212k+1 (narrow convolution) or m = n+k+1 windows (wide convolution) (Kalchbrenner et al., 2014). The result of the convolution layer is m vectors p1, . . . ,pm, pi \u2208 Rdconv where:\npi = g(wiW + b)\n.\ng is a non-linear activation function that is applied element-wise, W \u2208 Rk\u00b7demb\u00d7dconv and b \u2208 Rdconv are parameters of the network. Each pi is a dconv dimensional vector, encoding the information in wi. Ideally, each dimension captures a different kind of indicative information. The m vectors are then combined using a max pooling layer, resulting in a single dconv dimensional vector c.\ncj = max 1<i\u2264m pi[j]\npi[j] denotes the jth component of pi. The effect of the max-pooling operation is to get the most salient information across window positions. Ideally, each dimension will \u201cspecialize\u201d in a particular sort of predictors, and max operation will pick on the most important predictor of each type.\nFigure 4 provides an illustration of the process.\nThe resulting vector c is a representation of the sentence in which each dimension reflects the most salient information with respect to some prediction task. c is then fed into a downstream network layers, perhaps in parallel to other vectors, culminating in an output layer which is used for prediction. The training procedure of the network calculates the loss with respect to the prediction task, and the error gradients are propagated all the way back through the pooling and convolution layers, as well as the embedding layers. 25\n24. 1d here refers to a convolution operating over 1-dimensional inputs such as sequences, as opposed to 2d convolutions which are applied to images. 25. Besides being useful for prediction, a by-product of the training procedure is a set of parameters W, B and embeddings v() that can be used in a convolution and pooling architecture to encode arbitrary length sentences into fixed-size vectors, such that sentences that share the same kind of predictive information will be close to each other.\nWhile max-pooling is the most common pooling operation in text applications, other pooling operations are also possible, the second most common operation being average pooling, taking the average value of each index instead of the max."}, {"heading": "9.2 Dynamic, Hierarchical and k-max Pooling", "text": "Rather than performing a single pooling operation over the entire sequence, we may want to retain some positional information based on our domain understanding of the prediction problem at hand. To this end, we can split the vectors pi into ` distinct groups, apply the pooling separately on each group, and then concatenate the ` resulting dconv vectors c1, . . . , c`. The division of the pis into groups is performed based on domain knowledge. For example, we may conjecture that words appearing early in the sentence are more indicative than words appearing late. We can then split the sequence into ` equally sized regions, applying a separate max-pooling to each region. For example, Johnson and Zhang (Johnson & Zhang, 2014) found that when classifying documents into topics, it is useful to have 20 average-pooling regions, clearly separating the initial sentences (where the topic is usually introduced) from later ones, while for a sentiment classification task a single max-pooling operation over the entire sentence was optimal (suggesting that one or two very strong signals are enough to determine the sentiment, regardless of the position in the sentence).\nSimilarly, in a relation extraction kind of task we may be given two words and asked to determine the relation between them. We could argue that the words before the first word, the words after the second word, and the words between them provide three different kinds of information (Chen et al., 2015). We can thus split the pi vectors accordingly, pooling separately the windows resulting from each group.\nAnother variation is performing hierarchical pooling, in which we have a succession of convolution and pooling layers, where each stage applies a convolution to a sequence, pools every k neighboring vectors, performs a convolution on the resulting pooled sequence, applies another convolution and so on. This architecture allows sensitivity to increasingly larger structures.\nFinally, (Kalchbrenner et al., 2014) introduced a k-max pooling operation, in which the top k values in each dimension are retained instead of only the best one, while preserving the order in which they appeared in the text. For example a, consider the following matrix:\n1 2 3 9 6 5 2 3 1 7 8 1 3 4 1  A 1-max pooling over the column vectors will result in [ 9 8 5 ] , while a 2-max pooling\nwill result in the following matrix: [ 9 6 3 7 8 5 ] whose rows will then be concatenated to[\n9 6 3 7 8 5 ]\nThe k-max pooling operation makes it possible to pool the k most active indicators that may be a number of positions apart; it preserves the order of the features, but is insensitive to their specific positions. It can also discern more finely the number of times the feature is highly activated (Kalchbrenner et al., 2014)."}, {"heading": "9.3 Variations", "text": "Rather than a single convolutional layer, several convolutional layers may be applied in parallel. For example, we may have four different convolutional layers, each with a different window size in the range 2\u20135, capturing n-gram sequences of varying lengths. The result of each convolutional layer will then be pooled, and the resulting vectors concatenated and fed to further processing (Kim, 2014).\nThe convolutional architecture need not be restricted into the linear ordering of a sentence. For example, Ma et al (2015) generalize the convolution operation to work over syntactic dependency trees. There, each window is around a node in the syntactic tree, and the pooling is performed over the different nodes. Similarly, Liu et al (2015) apply a convolutional architecture on top of dependency paths extracted from dependency trees. Le and Zuidema (2015) propose to perform max pooling over vectors representing the different derivations leading to the same chart item in a chart parser."}, {"heading": "10. Recurrent Neural Networks \u2013 Modeling Sequences and Stacks", "text": "When dealing with language data, it is very common to work with sequences, such as words (sequences of letters), sentences (sequences of words) and documents. We saw how feedforward networks can accommodate arbitrary feature functions over sequences through the use of vector concatenation and vector addition (CBOW). In particular, the CBOW representations allows to encode arbitrary length sequences as fixed sized vectors. However, the CBOW representation is quite limited, and forces one to disregard the order of features. The convolutional networks also allow encoding a sequence into a fixed size vector. While representations derived from convolutional networks are an improvement above the CBOW representation as they offer some sensitivity to word order, their order sensitivity is restricted to mostly local patterns, and disregards the order of patterns that are far apart in the sequence.\nRecurrent neural networks (RNNs) (Elman, 1990) allow representing arbitrarily sized structured inputs in a fixed-size vector, while paying attention to the structured properties of the input."}, {"heading": "10.1 The RNN Abstraction", "text": "We use xi:j to denote the sequence of vectors xi, . . . ,xj. The RNN abstraction takes as input an ordered list of input vectors x1, ...,xn together with an initial state vector s0, and returns an ordered list of state vectors s1, ..., sn, as well as an ordered list of output vectors y1, ...,yn. An output vector yi is a function of the corresponding state vector si. The input vectors xi are presented to the RNN in a sequential fashion, and the state vector si and output vector yi represent the state of the RNN after observing the inputs x1:i. The output vector yi is then used for further prediction. For example, a model for predicting the conditional probability of an event e given the sequence m1:i can be defined as p(e = j|x1:i) = softmax(yiW + b)[j]. The RNN model provides a framework for conditioning on the entire history x1, . . . ,xi without resorting to the Markov assumption which is traditionally used for modeling sequences. Indeed, RNN-based language models result in very good perplexity scores when compared to n-gram based models.\nMathematically, we have a recursively defined function R that takes as input a state vector si and an input vector xi+1, and results in a new state vector si+1. An additional function O is used to map a state vector si to an output vector yi. When constructing an RNN, much like when constructing a feed-forward network, one has to specify the dimension of the inputs xi as well as the dimensions of the outputs yi. The dimensions of the states si are a function of the output dimension. 26\n26. While RNN architectures in which the state dimension is independent of the output dimension are possible, the current popular architectures, including the Simple RNN, the LSTM and the GRU do not follow this flexibility.\nRNN(s0,x1:n) =s1:n, y1:n\nsi = R(si\u22121,xi)\nyi = O(si)\nxi \u2208 Rdin , yi \u2208 Rdout , si \u2208 Rf(dout)\nThe functions R and O are the same across the sequence positions, but the RNN keeps track of the states of computation through the state vector that is kept and being passed between invocations of R.\nGraphically, the RNN has been traditionally presented as in Figure 5.\nThis presentation follows the recursive definition, and is correct for arbitrary long sequences. However, for a finite sized input sequence (and all input sequences we deal with are finite) one can unroll the recursion, resulting in the structure in Figure 6.\nWhile not usually shown in the visualization, we include here the parameters \u03b8 in order to highlight the fact that the same parameters are shared across all time steps. Different\ninstantiations of R and O will result in different network structures, and will exhibit different properties in terms of their running times and their ability to be trained effectively using gradient-based methods. However, they all adhere to the same abstract interface. We will provide details of concrete instantiations of R and O \u2013 the Simple RNN, the LSTM and the GRU \u2013 in Section 11. Before that, let\u2019s consider modeling with the RNN abstraction.\nFirst, we note that the value of si is based on the entire input x1, ...,xi. For example, by expanding the recursion for i = 4 we get:\ns4 =R(s3,x4)\n=R( s3\ufe37 \ufe38\ufe38 \ufe37 R(s2,x3),x4)\n=R(R( s2\ufe37 \ufe38\ufe38 \ufe37 R(s1,x2),x3),x4)\n=R(R(R( s1\ufe37 \ufe38\ufe38 \ufe37 R(s0,x1),x2),x3),x4)\nThus, sn (as well as yn) could be thought of as encoding the entire input sequence. 27 Is the encoding useful? This depends on our definition of usefulness. The job of the network training is to set the parameters of R and O such that the state conveys useful information for the task we are tying to solve."}, {"heading": "10.2 RNN Training", "text": "Viewed as in Figure 6 it is easy to see that an unrolled RNN is just a very deep neural network (or rather, a very large computation graph with somewhat complex nodes), in which the same parameters are shared across many parts of the computation. To train an RNN network, then, all we need to do is to create the unrolled computation graph for a given input sequence, add a loss node to the unrolled graph, and then use the backward (backpropagation) algorithm to compute the gradients with respect to that loss. This procedure is referred to in the RNN literature as backpropagation through time, or BPTT (Werbos, 1990).28 There are various ways in which the supervision signal can be applied.\nAcceptor One option is to base the supervision signal only on the final output vector, yn. Viewed this way, the RNN is an acceptor. We observe the final state, and then decide\n27. Note that, unless R is specifically designed against this, it is likely that the later elements of the input sequence have stronger effect on sn than earlier ones. 28. Variants of the BPTT algorithm include unrolling the RNN only for a fixed number of input symbols at each time: first unroll the RNN for inputs x1:k, resulting in s1:k. Compute a loss, and backpropagate the error through the network (k steps back). Then, unroll the inputs xk+1:2k, this time using sk as the initial state, and again backpropagate the error for k steps, and so on. This strategy is based on the observations that for the Simple-RNN variant, the gradients after k steps tend to vanish (for large enough k), and so omitting them is negligible. This procedure allows training of arbitrarily long sequences. For RNN variants such as the LSTM or the GRU that are designed specifically to mitigate the vanishing gradients problem, this fixed size unrolling is less motivated, yet it is still being used, for example when doing language modeling over a book without breaking it into sentences.\non an outcome.29 For example, consider training an RNN to read the characters of a word one by one and then use the final state to predict the part-of-speech of that word (this is inspired by (Ling et al., 2015b)), an RNN that reads in a sentence and, based on the final state decides if it conveys positive or negative sentiment (this is inspired by (Wang et al., 2015b)) or an RNN that reads in a sequence of words and decides whether it is a valid noun-phrase. The loss in such cases is defined in terms of a function of yn = O(sn), and the error gradients will backpropagate through the rest of the sequence (see Figure 7).30 The loss can take any familiar form \u2013 cross entropy, hinge, margin, etc.\nEncoder Similar to the acceptor case, an encoder supervision uses only the final output vector, yn. However, unlike the acceptor, where a prediction is made solely on the basis of the final vector, here the final vector is treated as an encoding of the information in the sequence, and is used as additional information together with other signals. For example, an extractive document summarization system may first run over the document with an RNN, resulting in a vector yn summarizing the entire document. Then, yn will be used together with with other features in order to select the sentences to be included in the summarization.\nTransducer Another option is to treat the RNN as a transducer, producing an output for each input it reads in. Modeled this way, we can compute a local loss signal Llocal(y\u0302i,yi) for each of the outputs y\u0302i based on a true label yi. The loss for unrolled sequence will then be: L( \u02c6y1:n,y1:n) = \u2211n i=1 Llocal(y\u0302i,yi), or using another combination rather than a sum such as an average or a weighted average (see Figure 8). One example for such a transducer is a sequence tagger, in which we take xi:n to be feature representations for the n words of a sentence, and yi as an input for predicting the tag assignment of word i based on words 1:i. A CCG super-tagger based on such an architecture provides state-of-the art CCG super-tagging results (Xu et al., 2015).\nA very natural use-case of the transduction setup is for language modeling, in which the sequence of words x1:i is used to predict a distribution over the i+ 1th word. RNN based\n29. The terminology is borrowed from Finite-State Acceptors. However, the RNN has a potentially infinite number of states, making it necessary to rely on a function other than a lookup table for mapping states to decisions. 30. This kind of supervision signal may be hard to train for long sequences, especially so with the SimpleRNN, because of the vanishing gradients problem. It is also a generally hard learning task, as we do not tell the process on which parts of the input to focus.\nlanguage models are shown to provide much better perplexities than traditional language models (Mikolov et al., 2010; Sundermeyer, Schlu\u0308ter, & Ney, 2012; Mikolov, 2012).\nUsing RNNs as transducers allows us to relax the Markov assumption that is traditionally taken in language models and HMM taggers, and condition on the entire prediction history. The power of the ability to condition on arbitrarily long histories is demonstrated in generative character-level RNN models, in which a text is generated character by character, each character conditioning on the previous ones (Sutskever, Martens, & Hinton, 2011). The generated texts show sensitivity to properties that are not captured by n-gram language models, including line lengths and nested parenthesis balancing. For a good demonstration and analysis of the properties of RNN-based character level language models, see (Karpathy, Johnson, & Li, 2015).\nEncoder - Decoder Finally, an important special case of the encoder scenario is the Encoder-Decoder framework (Cho, van Merrienboer, Bahdanau, & Bengio, 2014a; Sutskever et al., 2014). The RNN is used to encode the sequence into a vector representation yn, and this vector representation is then used as auxiliary input to another RNN that is used as a decoder. For example, in a machine-translation setup the first RNN encodes the source sentence into a vector representation yn, and then this state vector is fed into a separate (decoder) RNN that is trained to predict (using a transducer-like language modeling objective) the words of the target language sentence based on the previously predicted words as well as yn. The supervision happens only for the decoder RNN, but the gradients are propagated all the way back to the encoder RNN (see Figure 9).\nSuch an approach was shown to be surprisingly effective for Machine Translation (Sutskever et al., 2014) using LSTM RNNs. In order for this technique to work, Sutskever et al found it effective to input the source sentence in reverse, such that xn corresponds to the first word of the sentence. In this way, it is easier for the second RNN to establish the relation between the first word of the source sentence to the first word of the target sentence. Another use-case of the encoder-decoder framework is for sequence transduction. Here, in order to generate tags t1, . . . , tn, an encoder RNN is first used to encode the sentence x1:n into fixed sized vector. This vector is then fed as the initial state vector of another (transducer) RNN, which is used together with x1:n to predict the label ti at each position i. This approach\nwas used in (Filippova, Alfonseca, Colmenares, Kaiser, & Vinyals, 2015) to model sentence compression by deletion."}, {"heading": "10.3 Multi-layer (stacked) RNNs", "text": "RNNs can be stacked in layers, forming a grid (Hihi & Bengio, 1996). Consider k RNNs, RNN1, . . . , RNNk, where the jth RNN has states s j 1:n and outputs y j 1:n. The input for the first RNN are x1:n, while the input of the jth RNN (j \u2265 2) are the outputs of the RNN below it, yj\u221211:n . The output of the entire formation is the output of the last RNN, y k 1:n. Such layered architectures are often called deep RNNs. A visual representation of a 3-layer RNN is given in Figure 10.\nWhile it is not theoretically clear what is the additional power gained by the deeper architecture, it was observed empirically that deep RNNs work better than shallower ones on some tasks. In particular, Sutskever et al (2014) report that a 4-layers deep architecture was crucial in achieving good machine-translation performance in an encoder-decoder framework. Irsoy and Cardie (2014) also report improved results from moving from a onelayer BI-RNN to an architecture with several layers. Many other works report result using layered RNN architectures, but do not explicitly compare to 1-layer RNNs."}, {"heading": "10.4 BI-RNN", "text": "A useful elaboration of an RNN is a bidirectional-RNN (BI-RNN) (Schuster & Paliwal, 1997; Graves, 2008).31 Consider the task of sequence tagging over a sentence x1, . . . , xn. An RNN allows us to compute a function of the ith word xi based on the past \u2013 the words x1:i up to and including it. However, the following words xi:n may also be useful for prediction, as is evident by the common sliding-window approach in which the focus word is categorized based on a window of k words surrounding it. Much like the RNN relaxes the Markov assumption and allows looking arbitrarily back into the past, the BI-RNN relaxes the fixed window size assumption, allowing to look arbitrarily far at both the past and the future.\nConsider an input sequence x1:n. The BI-RNN works by maintaining two separate states, sfi and s b i for each input position i. The forward state s f i is based on x1,x2, . . . ,xi, while the backward state sbi is based on xn,xn\u22121, . . . ,xi. The forward and backward states are generated by two different RNNs. The first RNN (Rf , Of ) is fed the input sequence x1:n as is, while the second RNN (R\nb, Ob) is fed the input sequence in reverse. The state representation si is then composed of both the forward and backward states.\nThe output at position i is based on the concatenation of the two output vectors yi = [y f i ; y b i ] = [O f (sfi );O b(sbi )], taking into account both the past and the future. The vector yi can then be used directly for prediction, or fed as part of the input to a more complex network. While the two RNNs are run independently of each other, the error gradients at position i will flow both forward and backward through the two RNNs. A visual representation of the BI-RNN architecture is given in Figure 11.\nThe use of BI-RNNs for sequence tagging was introduced to the NLP community by Irsoy and Cardie (2014)."}, {"heading": "10.5 RNNs for Representing Stacks", "text": "Some algorithms in language processing, including those for transition-based parsing (Nivre, 2008), require performing feature extraction over a stack. Instead of being confined to\n31. When used with a specific RNN architecture such as an LSTM, the model is called BI-LSTM.\nlooking at the k top-most elements of the stack, the RNN framework can be used to provide a fixed-sized vector encoding of the entire stack.\nThe main intuition is that a stack is essentially a sequence, and so the stack state can be represented by taking the stack elements and feeding them in order into an RNN, resulting in a final encoding of the entire stack. In order to do this computation efficiently (without performing an O(n) stack encoding operation each time the stack changes), the RNN state is maintained together with the stack state. If the stack was push-only, this would be trivial: whenever a new element x is pushed into the stack, the corresponding vector x will be used together with the RNN state si in order to obtain a new state si+1. Dealing with pop operation is more challenging, but can be solved by using the persistent-stack data-structure (Okasaki, 1999; Goldberg, Zhao, & Huang, 2013). Persistent, or immutable, data-structures keep old versions of themselves intact when modified. The persistent stack construction represents a stack as a pointer to the head of a linked list. An empty stack is the empty list. The push operation appends an element to the list, returning the new head. The pop operation then returns the parent of the head, but keeping the original list intact. From the point of view of someone who held a pointer to the previous head, the stack did not change. A subsequent push operation will add a new child to the same node. Applying this procedure throughout the lifetime of the stack results in a tree, where the root is an empty stack and each path from a node to the root represents an intermediary stack state. Figure 12 provides an example of such a tree. The same process can be applied in the computation graph construction, creating an RNN with a tree structure instead of a chain structure. Backpropagating the error from a given node will then affect all the elements that participated in the stack when the node was created, in order. Figure 13 shows the computation graph for the stack-RNN corresponding to the last state in Figure 12. This modeling approach was proposed independently by Dyer et al and Watanabe et al (Dyer et al., 2015; Watanabe & Sumita, 2015) for transition-based dependency parsing.\n\u22a5 a\nhead\n(1) push a\n\u22a5 a b\nhead\n(2) push b\n\u22a5 a b c\nhead\n(3) push c\n\u22a5 a b\nhead\nc\n(4) pop\n\u22a5 a b c\nd\nhead\n(5) push d"}, {"heading": "11. Concrete RNN Architectures", "text": "We now turn to present three different instantiations of the abstract RNN architecture discussed in the previous section, providing concrete definitions of the functions R and O. These are the Simple RNN (SRNN), the Long Short-Term Memory (LSTM) and the Gated Recurrent Unit (GRU)."}, {"heading": "11.1 Simple RNN", "text": "The simplest RNN formulation, known as an Elman Network or Simple-RNN (S-RNN), was proposed by Elman (1990) and explored for use in language modeling by Mikolov (2012). The S-RNN takes the following form:\nsi =RSRNN (si\u22121,xi) = g(xiW x + si\u22121W s + b)\nyi =OSRNN (si) = si\nsi,yi \u2208 Rds , xi \u2208 Rdx , Wx \u2208 Rdx\u00d7ds , Ws \u2208 Rds\u00d7ds , b \u2208 Rds\nThat is, the state at position i is a linear combination of the input at position i and the previous state, passed through a non-linear activation (commonly tanh or ReLU). The output at position i is the same as the hidden state in that position.32\nIn spite of its simplicity, the Simple RNN provides strong results for sequence tagging (Xu et al., 2015) as well as language modeling. For comprehensive discussion on using Simple RNNs for language modeling, see the PhD thesis by Mikolov (2012)."}, {"heading": "11.2 LSTM", "text": "The S-RNN is hard to train effectively because of the vanishing gradients problem. Error signals (gradients) in later steps in the sequence diminish in quickly in the back-propagation process, and do not reach earlier input signals, making it hard for the S-RNN to capture long-range dependencies. The Long Short-Term Memory (LSTM) architecture (Hochreiter & Schmidhuber, 1997) was designed to solve the vanishing gradients problem. The main idea behind the LSTM is to introduce as part of the state representation also \u201cmemory cells\u201d (a vector) that can preserve gradients across time. Access to the memory cells is controlled by gating components \u2013 smooth mathematical functions that simulate logical gates. At each input state, a gate is used to decide how much of the new input should be written to the memory cell, and how much of the current content of the memory cell should be forgotten. Concretely, a gate g \u2208 [0, 1]n is a vector of values in the range [0, 1] that is multiplied component-wise with another vector v \u2208 Rn, and the result is then added to another vector. The values of g are designed to be close to either 0 or 1, i.e. by using a sigmoid function. Indices in v corresponding to near-one values in g are allowed to pass, while those corresponding to near-zero values are blocked.\n32. Some authors treat the output at position i as a more complicated function of the state. In our presentation, such further transformation of the output are not considered part of the RNN, but as separate computations that are applied to the RNNs output. The distinction between the state and the output are needed for the LSTM architecture, in which not all of the state is observed outside of the RNN.\nMathematically, the LSTM architecture is defined as:33\nsj = RLSTM (sj\u22121,xj) =[cj; hj]\ncj =cj\u22121 f + g i hj = tanh(cj) o i =\u03c3(xjW xi + hj\u22121W hi)\nf =\u03c3(xjW xf + hj\u22121W hf ) o =\u03c3(xjW xo + hj\u22121W ho) g = tanh(xjW xg + hj\u22121W hg)\nyj = OLSTM (sj) =hj\nsj \u2208 R2\u00b7dh , xi \u2208 Rdx , cj,hj, i, f ,o,g \u2208 Rdh , Wx\u25e6 \u2208 Rdx\u00d7dh , Wh\u25e6 \u2208 Rdh\u00d7dh ,\nThe symbol is used to denote component-wise product. The state at time j is composed of two vectors, cj and hj, where cj is the memory component and hj is the output, or state, component. There are three gates, i, f and o, controlling for input, forget and output. The gate values are computed based on linear combinations of the current input xj and the previous state hj\u22121, passed through a sigmoid activation function. An update candidate g is computed as a linear combination of xj and hj\u22121, passed through a tanh activation function. The memory cj is then updated: the forget gate controls how much of the previous memory to keep (cj\u22121 f), and the input gate controls how much of the proposed update to keep (g i). Finally, the value of hj (which is also the output yj) is determined based on the content of the memory cj, passed through a tanh non-linearity and controlled by the output gate. The gating mechanisms allow for gradients related to the memory part cj to stay high across very long time ranges.\nFor further discussion on the LSTM architecture see the PhD thesis by Alex Graves (2008), as well as Chris Olah\u2019s description.34 For an analysis of the behavior of an LSTM when used as a character-level language model, see (Karpathy et al., 2015).\nLSTMs are currently the most successful type of RNN architecture, and they are responsible for many state-of-the-art sequence modeling results. The main competitor of the LSTM-RNN is the GRU, to be discussed next.\nPractical Considerations When training LSTM networks, Jozefowicz et al (2015) strongly recommend to always initialize the bias term of the forget gate to be close to one. When applying dropout to an RNN with an LSTM, Zaremba et al (2014) found out that it is\n33. There are many variants on the LSTM architecture presented here. For example, forget gates were not part of the original proposal in (Hochreiter & Schmidhuber, 1997), but are shown to be an important part of the architecture. Other variants include peephole connections and gate-tying. For an overview and comprehensive empirical comparison of various LSTM architectures see (Greff, Srivastava, Koutn\u0301\u0131k, Steunebrink, & Schmidhuber, 2015). 34. http://colah.github.io/posts/2015-08-Understanding-LSTMs/\ncrucial to apply dropout only on the non-recurrent connection, i.e. only to apply it between layers and not between sequence positions."}, {"heading": "11.3 GRU", "text": "The LSTM architecture is very effective, but also quite complicated. The complexity of the system makes it hard to analyze, and also computationally expensive to work with. The gated recurrent unit (GRU) was recently introduced by Cho et al (2014b) as an alternative to the LSTM. It was subsequently shown by Chung et al (2014) to perform comparably to the LSTM on several (non textual) datasets.\nLike the LSTM, the GRU is also based on a gating mechanism, but with substantially fewer gates and without a separate memory component.\nsj = RGRU (sj\u22121,xj) =(1\u2212 z) sj\u22121 + z h z =\u03c3(xjW xz + hj\u22121W hz)\nr =\u03c3(xjW xr + hj\u22121W hr) h = tanh(xjW xh + (hj\u22121 r)Whg)\nyj = OLSTM (sj) =sj\nsj \u2208 Rdh , xi \u2208 Rdx , z, r,h \u2208 Rdh , Wx\u25e6 \u2208 Rdx\u00d7dh , Wh\u25e6 \u2208 Rdh\u00d7dh , One gate (r) is used to control access to the previous state sj\u22121 and compute a proposed update h. The updated state sj (which also serves as the output yj) is then determined based on an interpolation of the previous state sj\u22121 and the proposal h, where the proportions of the interpolation are controlled using the gate z.\nThe GRU was shown to be effective in language modeling and machine translation. However, the jury between the GRU, the LSTM and possible alternative RNN architectures is still out, and the subject is actively researched. For an empirical exploration of the GRU and the LSTM architectures, see (Jozefowicz et al., 2015)."}, {"heading": "11.4 Other Variants", "text": "The gated architectures of the LSTM and the GRU help in alleviating the vanishing gradients problem of the Simple RNN, and allow these RNNs to capture dependencies that span long time ranges. Some researchers explore simpler architectures than the LSTM and the GRU for achieving similar benefits.\nMikolov et al (2014) observed that the matrix multiplication si\u22121Ws coupled with the nonlinearity g in the update rule R of the Simple RNN causes the state vector si to undergo large changes at each time step, prohibiting it from remembering information over long time periods. They propose to split the state vector si into a slow changing component ci (\u201ccontext units\u201d) and a fast changing component hi. 35 The slow changing component ci is\n35. We depart from the notation in (Mikolov et al., 2014) and reuse the symbols used in the LSTM description.\nupdated according to a linear interpolation of the input and the previous component: ci = (1\u2212 \u03b1)xiWx1 + \u03b1ci\u22121, where \u03b1 \u2208 (0, 1). This update allows ci to accumulate the previous inputs. The fast changing component hi is updated similarly to the Simple RNN update rule, but changed to take ci into account as well: 36 hi = \u03c3(xiW x2 + hi\u22121Wh + ciWc). Finally, the output yi is the concatenation of the slow and the fast changing parts of the state: yi = [ci; hi]. Mikolov et al demonstrate that this architecture provides competitive perplexities to the much more complex LSTM on language modeling tasks.\nThe approach of Mikolov et al can be interpreted as constraining the block of the matrix Ws in the S-RNN corresponding to ci to be a multiply of the identity matrix (see Mikolov et al (2014) for the details). Le et al (Le, Jaitly, & Hinton, 2015) propose an even simpler approach: set the activation function of the S-RNN to a ReLU, and initialize the biases b as zeroes and the matrix Ws as the identify matrix. This causes an untrained RNN to copy the previous state to the current state, add the effect of the current input xi and set the negative values to zero. After setting this initial bias towards state copying, the training procedure allows Ws to change freely. Le et al demonstrate that this simple modification makes the S-RNN comparable to an LSTM with the same number of parameters on several tasks, including language modeling.\n36. The update rule diverges from the S-RNN update rule also by fixing the non-linearity to be a sigmoid function, and by not using a bias term. However, these changes are not discussed as central to the proposal."}, {"heading": "12. Modeling Trees \u2013 Recursive Neural Networks", "text": "The RNN is very useful for modeling sequences. In language processing, it is often natural and desirable to work with tree structures. The trees can be syntactic trees, discourse trees, or even trees representing the sentiment expressed by various parts of a sentence (Socher et al., 2013). We may want to predict values based on specific tree nodes, predict values based on the root nodes, or assign a quality score to a complete tree or part of a tree. In other cases, we may not care about the tree structure directly but rather reason about spans in the sentence. In such cases, the tree is merely used as a backbone structure which help guide the encoding process of the sequence into a fixed size vector.\nThe recursive neural network (RecNN) abstraction (Pollack, 1990), popularized in NLP by Richard Socher and colleagues (Socher, Manning, & Ng, 2010; Socher, Lin, Ng, & Manning, 2011; Socher et al., 2013; Socher, 2014) is a generalization of the RNN from sequences to (binary) trees.37\nMuch like the RNN encodes each sentence prefix as a state vector, the RecNN encodes each tree-node as a state vector in Rd. We can then use these state vectors either to predict values of the corresponding nodes, assign quality values to each node, or as a semantic representation of the spans rooted at the nodes.\nThe main intuition behind the recursive neural networks is that each subtree is represented as a d dimensional vector, and the representation of a node p with children c1 and c2 is a function of the representation of the nodes: vec(p) = f(vec(c1), vec(c2)), where f is a composition function taking two d-dimensional vectors and returning a single d-dimensional vector. Much like the RNN state si is used to encode the entire sequence x1 : i, the RecNN state associated with a tree node p encodes the entire subtree rooted at p. See Figure 14 for an illustration."}, {"heading": "12.1 Formal Definition", "text": "Consider a binary parse tree T over an n-word sentence. As a reminder, an ordered, unlabeled tree over a string x1, . . . , xn can be represented as a unique set of triplets (i, k, j), s.t. i \u2264 k \u2264 j. Each such triplet indicates that a node spanning words xi:j is parent of the nodes spanning xi:k and xk+1:j . Triplets of the form (i, i, i) correspond to terminal symbols at the tree leaves (the words xi). Moving from the unlabeled case to the labeled one, we can represent a tree as a set of 6-tuples (A\u2192 B,C, i, k, j), whereas i, k and j indicate the spans as before, and A, B and C are the node labels of of the nodes spanning xi:j , xi:k and xk+1:j respectively. Here, leaf nodes have the form (A \u2192 A,A, i, i, i), where A is a pre-terminal symbol. We refer to such tuples as production rules. For an example, consider the syntactic tree for the sentence \u201cthe boy saw her duck\u201d.\n37. While presented in terms of binary parse trees, the concepts easily transfer to general recursively-defined data structures, with the major technical challenge is the definition of an effective form for R, the combination function.\nS\nVP\nNP\nNoun\nduck\nDet\nher\nVerb\nsaw\nNP\nNoun\nboy\nDet\nthe\nIts corresponding unlabeled and labeled representations are :\nUnlabeled Labeled Corresponding Span\n(1,1,1) (Det, Det, Det, 1, 1, 1) x1:1 the (2,2,2) (Noun, Noun, Noun, 2, 2, 2) x2:2 boy (3,3,3) (Verb, Verb, Verb, 3, 3, 3) saw (4,4,4) (Det, Det, Det, 4, 4, 4) her (5,5,5) (Noun, Noun, Noun, 5, 5, 5) duck (4,4,5) (NP, Det, Noun, 4, 4, 5) her duck (3,3,5) (VP, Verb, NP, 3, 3, 5) saw her duck (1,1,2) (NP, Det, Noun, 1, 1, 2) the boy (1,2,5) (S, NP, VP, 1, 2, 5) the boy saw her duck\nThe set of production rules above can be uniquely converted to a set tree nodes qAi:j (indicating a node with symbol A over the span xi:j) by simply ignoring the elements\n(B,C, k) in each production rule. We are now in position to define the Recursive Neural Network.\nA Recursive Neural Network (RecNN) is a function that takes as input a parse tree over an n-word sentence x1, . . . , xn. Each of the sentence\u2019s words is represented as a ddimensional vector xi, and the tree is represented as a set T of production rules (A \u2192 B,C, i, j, k). Denote the nodes of T by qAi:j . The RecNN returns as output a corresponding set of inside state vectors sAi:j, where each inside state vector s A i:j \u2208 Rd represents the corresponding tree node qAi:j , and encodes the entire structure rooted at that node. Like the sequence RNN, the tree shaped RecNN is defined recursively using a function R, where the inside vector of a given node is defined as a function of the inside vectors of its direct children.38 Formally:\nRecNN(x1, . . . , xn, T ) ={sAi:j \u2208 Rd | qAi:j \u2208 T } sAi:i =v(xi)\nsAi:j =R(A,B,C, s B i:k, s C k+1:j) q B i:k \u2208 T , qCk+1:j \u2208 T\nThe function R usually takes the form of a simple linear transformation, which may or may not be followed by a non-linear activation function g:\nR(A,B,C, sBi:k, s C k+1:j) = g([s B i:k; s C k+1:j]W)\nThis formulation of R ignores the tree labels, using the same matrix W \u2208 R2d\u00d7d for all combinations. This may be a useful formulation in case the node labels do not exist (e.g. when the tree does not represent a syntactic structure with clearly defined labels) or when they are unreliable. However, if the labels are available, it is generally useful to include them in the composition function. One approach would be to introduce label embeddings v(A) mapping each non-terminal symbol to a dnt dimensional vector, and change R to include the embedded symbols in the combination function:\nR(A,B,C, sBi:k, s C k+1:j) = g([s B i:k; s C k+1:j; v(A); v(B)]W)\n(here, W \u2208 R2d+2dnt\u00d7d). Such approach is taken by (Qian, Tian, Huang, Liu, Zhu, & Zhu, 2015). An alternative approach, due to (Socher et al., 2013) is to untie the weights according to the non-terminals, using a different composition matrix for each B,C pair of symbols:39\nR(A,B,C, sBi:k, s C k+1:j) = g([s B i:k; s C k+1:j]W BC)\n38. Le and Zuidema (2014) extend the RecNN definition such that each node has, in addition to its inside state vector, also an outside state vector representing the entire structure around the subtree rooted at that node. Their formulation is based on the recursive computation of the classic inside-outside algorithm, and can be thought of as the BI-RNN counterpart of the tree RecNN. For details, see (Le & Zuidema, 2014). 39. While not explored in the literature, a trivial extension would condition the transformation matrix also on A.\nThis formulation is useful when the number of non-terminal symbols (or the number of possible symbol combinations) is relatively small, as is usually the case with phrase-structure parse trees. A similar model was also used by (Hashimoto et al., 2013) to encode subtrees in semantic-relation classification task."}, {"heading": "12.2 Extensions and Variations", "text": "As all of the definitions of R above suffer from the vanishing gradients problem of the Simple RNN, several authors sought to replace it with functions inspired by the Long ShortTerm Memory (LSTM) gated architecture, resulting in Tree-shaped LSTMs (Tai, Socher, & Manning, 2015; Zhu, Sobhani, & Guo, 2015b). The question of optimal tree representation is still very much an open research question, and the vast space of possible combination functions R is yet to be explored. Other proposed variants on tree-structured RNNs includes a recursive matrix-vector model (Socher, Huval, Manning, & Ng, 2012) and recursive neural tensor network (Socher et al., 2013). In the first variant, each word is represented as a combination of a vector and a matrix, where the vector defines the word\u2019s static semantic content as before, while the matrix acts as a learned \u201coperator\u201d for the word, allowing more subtle semantic compositions than the addition and weighted averaging implied by the concatenation followed by linear transformation function. In the second variant, words are associated with vectors as usual, but the composition function becomes more expressive by basing it on tensor instead of matrix operations."}, {"heading": "12.3 Training Recursive Neural Networks", "text": "The training procedure for a recursive neural network follows the same recipe as training other forms of networks: define a loss, spell out the computation graph, compute gradients using backpropagation40, and train the parameters using SGD.\nWith regard to the loss function, similar to the sequence RNN one can associate a loss either with the root of the tree, with any given node, or with a set of nodes, in which case the individual node\u2019s losses are combined, usually by summation. The loss function is based on the labeled training data which associates a label or other quantity with different tree nodes.\nAdditionally, one can treat the RecNN as an Encoder, whereas the inside-vector associated with a node is taken to be an encoding of the tree rooted at that node. The encoding can potentially be sensitive to arbitrary properties of the structure. The vector is then passed as input to another network.\nFor further discussion on recursive neural networks and their use in natural language tasks, refer to the PhD thesis of Richard Socher (2014).\n40. Before the introduction of the computation graph abstraction, the specific backpropagation procedure for computing the gradients in a RecNN as defined above was referred to as the Back-propagation trough Structure (BPTS) algorithm (Goller & Ku\u0308chler, 1996)."}, {"heading": "13. Conclusions", "text": "Neural networks are powerful learners, providing opportunities ranging from non-linear classification to non-Markovian modeling of sequences and trees. We hope that this exposition help NLP researchers to incorporate neural network models in their work and take advantage of their power."}], "references": [{"title": "Combination of Recurrent Neural Networks and Factored Language Models for Code-Switching Language Modeling", "author": ["H. Adel", "N.T. Vu", "T. Schultz"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers),", "citeRegEx": "Adel et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Adel et al\\.", "year": 2013}, {"title": "A High-Performance Semi-Supervised Learning Method for Text Chunking", "author": ["R. Ando", "T. Zhang"], "venue": "In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL\u201905),", "citeRegEx": "Ando and Zhang,? \\Q2005\\E", "shortCiteRegEx": "Ando and Zhang", "year": 2005}, {"title": "A framework for learning predictive structures from multiple tasks and unlabeled data", "author": ["R.K. Ando", "T. Zhang"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Ando and Zhang,? \\Q2005\\E", "shortCiteRegEx": "Ando and Zhang", "year": 2005}, {"title": "Joint Language and Translation Modeling with Recurrent Neural Networks", "author": ["M. Auli", "M. Galley", "C. Quirk", "G. Zweig"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Auli et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Auli et al\\.", "year": 2013}, {"title": "Decoder Integration and Expected BLEU Training for Recurrent Neural Network Language Models. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers)", "author": ["M. Auli", "J. Gao"], "venue": null, "citeRegEx": "Auli and Gao,? \\Q2014\\E", "shortCiteRegEx": "Auli and Gao", "year": 2014}, {"title": "Improved Transition-based Parsing by Modeling Characters instead of Words with LSTMs", "author": ["M. Ballesteros", "C. Dyer", "N.A. Smith"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Ballesteros et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ballesteros et al\\.", "year": 2015}, {"title": "Tailoring Continuous Word Representations for Dependency Parsing", "author": ["M. Bansal", "K. Gimpel", "K. Livescu"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Bansal et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Bansal et al\\.", "year": 2014}, {"title": "Automatic differentiation in machine learning: a survey", "author": ["A.G. Baydin", "B.A. Pearlmutter", "A.A. Radul", "J.M. Siskind"], "venue": null, "citeRegEx": "Baydin et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Baydin et al\\.", "year": 2015}, {"title": "Practical recommendations for gradient-based training of deep architectures", "author": ["Y. Bengio"], "venue": "arXiv:1206.5533 [cs].", "citeRegEx": "Bengio,? 2012", "shortCiteRegEx": "Bengio", "year": 2012}, {"title": "Deep Learning. Book in preparation for", "author": ["Y. Bengio", "I.J. Goodfellow", "A. Courville"], "venue": null, "citeRegEx": "Bengio et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 2015}, {"title": "Non-Linear Text Regression with a Deep Convolutional Neural Network", "author": ["Z. Bitvai", "T. Cohn"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Bitvai and Cohn,? \\Q2015\\E", "shortCiteRegEx": "Bitvai and Cohn", "year": 2015}, {"title": "Compositional Morphology for Word Representations and Language Modelling", "author": ["J.A. Botha", "P. Blunsom"], "venue": "In Proceedings of the 31st International Conference on Machine Learning (ICML),", "citeRegEx": "Botha and Blunsom,? \\Q2014\\E", "shortCiteRegEx": "Botha and Blunsom", "year": 2014}, {"title": "Stochastic gradient descent tricks", "author": ["L. Bottou"], "venue": "Neural Networks: Tricks of the Trade, pp. 421\u2013436. Springer.", "citeRegEx": "Bottou,? 2012", "shortCiteRegEx": "Bottou", "year": 2012}, {"title": "Coarse-to-Fine n-Best Parsing and MaxEnt Discriminative Reranking", "author": ["E. Charniak", "M. Johnson"], "venue": "In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Charniak and Johnson,? \\Q2005\\E", "shortCiteRegEx": "Charniak and Johnson", "year": 2005}, {"title": "A Fast and Accurate Dependency Parser using Neural Networks", "author": ["D. Chen", "C. Manning"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Chen and Manning,? \\Q2014\\E", "shortCiteRegEx": "Chen and Manning", "year": 2014}, {"title": "Event Extraction via Dynamic Multi-Pooling Convolutional Neural Networks", "author": ["Y. Chen", "L. Xu", "K. Liu", "D. Zeng", "J. Zhao"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Chen et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2015}, {"title": "On the Properties of Neural Machine Translation: Encoder\u2013Decoder Approaches", "author": ["K. Cho", "B. van Merrienboer", "D. Bahdanau", "Y. Bengio"], "venue": "In Proceedings of SSST8, Eighth Workshop on Syntax, Semantics and Structure in Statistical Translation,", "citeRegEx": "Cho et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cho et al\\.", "year": 2014}, {"title": "Learning Phrase Representations using RNN Encoder\u2013Decoder for Statistical Machine Translation", "author": ["K. Cho", "B. van Merrienboer", "C. Gulcehre", "D. Bahdanau", "F. Bougares", "H. Schwenk", "Y. Bengio"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Cho et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cho et al\\.", "year": 2014}, {"title": "Normalizing tweets with edit scripts and recurrent neural embeddings", "author": ["G. Chrupala"], "venue": "Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pp. 680\u2013686, Baltimore, Maryland. Association for Computational Linguistics.", "citeRegEx": "Chrupala,? 2014", "shortCiteRegEx": "Chrupala", "year": 2014}, {"title": "Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling", "author": ["J. Chung", "C. Gulcehre", "K. Cho", "Y. Bengio"], "venue": null, "citeRegEx": "Chung et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Chung et al\\.", "year": 2014}, {"title": "Discriminative Training Methods for Hidden Markov Models: Theory and Experiments with Perceptron Algorithms", "author": ["M. Collins"], "venue": "Proceedings of the 2002 Confer-", "citeRegEx": "Collins,? 2002", "shortCiteRegEx": "Collins", "year": 2002}, {"title": "Discriminative Reranking for Natural Language Parsing", "author": ["M. Collins", "T. Koo"], "venue": "Computational Linguistics,", "citeRegEx": "Collins and Koo,? \\Q2005\\E", "shortCiteRegEx": "Collins and Koo", "year": 2005}, {"title": "A unified architecture for natural language processing: Deep neural networks with multitask learning", "author": ["R. Collobert", "J. Weston"], "venue": "In Proceedings of the 25th international conference on Machine learning,", "citeRegEx": "Collobert and Weston,? \\Q2008\\E", "shortCiteRegEx": "Collobert and Weston", "year": 2008}, {"title": "Natural language processing (almost) from scratch", "author": ["R. Collobert", "J. Weston", "L. Bottou", "M. Karlen", "K. Kavukcuoglu", "P. Kuksa"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Collobert et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2011}, {"title": "On the algorithmic implementation of multiclass kernelbased vector machines", "author": ["K. Crammer", "Y. Singer"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Crammer and Singer,? \\Q2002\\E", "shortCiteRegEx": "Crammer and Singer", "year": 2002}, {"title": "Unsupervised Models for Morpheme Segmentation and Morphology Learning", "author": ["M. Creutz", "K. Lagus"], "venue": "ACM Trans. Speech Lang. Process.,", "citeRegEx": "Creutz and Lagus,? \\Q2007\\E", "shortCiteRegEx": "Creutz and Lagus", "year": 2007}, {"title": "Approximation by superpositions of a sigmoidal function", "author": ["G. Cybenko"], "venue": "Mathematics of Control, Signals and Systems, 2 (4), 303\u2013314.", "citeRegEx": "Cybenko,? 1989", "shortCiteRegEx": "Cybenko", "year": 1989}, {"title": "Improving deep neural networks for LVCSR using rectified linear units and dropout", "author": ["G. Dahl", "T. Sainath", "G. Hinton"], "venue": "IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP),", "citeRegEx": "Dahl et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Dahl et al\\.", "year": 2013}, {"title": "Fast and Accurate Preordering for SMT using Neural Networks", "author": ["A. de Gispert", "G. Iglesias", "B. Byrne"], "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Gispert et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Gispert et al\\.", "year": 2015}, {"title": "Adaptive Recursive Neural Network for Target-dependent Twitter Sentiment Classification", "author": ["L. Dong", "F. Wei", "C. Tan", "D. Tang", "M. Zhou", "K. Xu"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers),", "citeRegEx": "Dong et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Dong et al\\.", "year": 2014}, {"title": "Question Answering over Freebase with Multi-Column Convolutional Neural Networks", "author": ["L. Dong", "F. Wei", "M. Zhou", "K. Xu"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Dong et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dong et al\\.", "year": 2015}, {"title": "Deep Convolutional Neural Networks for Sentiment Analysis of Short Texts", "author": ["C. dos Santos", "M. Gatti"], "venue": "In Proceedings of COLING 2014, the 25th International Conference on Computational Linguistics: Technical Papers,", "citeRegEx": "Santos and Gatti,? \\Q2014\\E", "shortCiteRegEx": "Santos and Gatti", "year": 2014}, {"title": "Classifying Relations by Ranking with Convolutional Neural Networks", "author": ["C. dos Santos", "B. Xiang", "B. Zhou"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Santos et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Santos et al\\.", "year": 2015}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["J. Duchi", "E. Hazan", "Y. Singer"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Duchi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2011}, {"title": "Adaptation Data Selection using Neural Language Models: Experiments in Machine Translation", "author": ["K. Duh", "G. Neubig", "K. Sudoh", "H. Tsukada"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers),", "citeRegEx": "Duh et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Duh et al\\.", "year": 2013}, {"title": "Neural CRF Parsing. In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)", "author": ["G. Durrett", "D. Klein"], "venue": null, "citeRegEx": "Durrett and Klein,? \\Q2015\\E", "shortCiteRegEx": "Durrett and Klein", "year": 2015}, {"title": "TransitionBased Dependency Parsing with Stack Long Short-Term Memory", "author": ["C. Dyer", "M. Ballesteros", "W. Ling", "A. Matthews", "N.A. Smith"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Dyer et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dyer et al\\.", "year": 2015}, {"title": "Finding Structure in Time", "author": ["J.L. Elman"], "venue": "Cognitive Science, 14 (2), 179\u2013211.", "citeRegEx": "Elman,? 1990", "shortCiteRegEx": "Elman", "year": 1990}, {"title": "Improving Vector Space Word Representations Using Multilingual Correlation", "author": ["M. Faruqui", "C. Dyer"], "venue": "In Proceedings of the 14th Conference of the European Chapter of the Association for Computational Linguistics,", "citeRegEx": "Faruqui and Dyer,? \\Q2014\\E", "shortCiteRegEx": "Faruqui and Dyer", "year": 2014}, {"title": "Sentence Compression by Deletion with LSTMs", "author": ["K. Filippova", "E. Alfonseca", "C.A. Colmenares", "L. Kaiser", "O. Vinyals"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Filippova et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Filippova et al\\.", "year": 2015}, {"title": "Dropout as a Bayesian Approximation: Representing Model Uncertainty in Deep Learning", "author": ["Y. Gal", "Z. Ghahramani"], "venue": null, "citeRegEx": "Gal and Ghahramani,? \\Q2015\\E", "shortCiteRegEx": "Gal and Ghahramani", "year": 2015}, {"title": "Modeling Interestingness with Deep Neural Networks", "author": ["J. Gao", "P. Pantel", "M. Gamon", "X. He", "L. Deng"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Gao et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Gao et al\\.", "year": 2014}, {"title": "SVMTool: A general POS tagger generator based on Support Vector Machines", "author": ["J. Gim\u00e9nez", "L. M\u00e0rquez"], "venue": "In Proceedings of the 4th LREC,", "citeRegEx": "Gim\u00e9nez and M\u00e0rquez,? \\Q2004\\E", "shortCiteRegEx": "Gim\u00e9nez and M\u00e0rquez", "year": 2004}, {"title": "Understanding the difficulty of training deep feedforward neural networks", "author": ["X. Glorot", "Y. Bengio"], "venue": "In International conference on artificial intelligence and statistics,", "citeRegEx": "Glorot and Bengio,? \\Q2010\\E", "shortCiteRegEx": "Glorot and Bengio", "year": 2010}, {"title": "Deep sparse rectifier neural networks", "author": ["X. Glorot", "A. Bordes", "Y. Bengio"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Glorot et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Glorot et al\\.", "year": 2011}, {"title": "An Efficient Algorithm for Easy-First Non-Directional Dependency Parsing", "author": ["Y. Goldberg", "M. Elhadad"], "venue": "In Human Language Technologies: The 2010 Annual Conference", "citeRegEx": "Goldberg and Elhadad,? \\Q2010\\E", "shortCiteRegEx": "Goldberg and Elhadad", "year": 2010}, {"title": "word2vec Explained: deriving Mikolov et al.\u2019s negativesampling word-embedding method", "author": ["Y. Goldberg", "O. Levy"], "venue": null, "citeRegEx": "Goldberg and Levy,? \\Q2014\\E", "shortCiteRegEx": "Goldberg and Levy", "year": 2014}, {"title": "Training Deterministic Parsers with Non-Deterministic Oracles", "author": ["Y. Goldberg", "J. Nivre"], "venue": "Transactions of the Association for Computational Linguistics,", "citeRegEx": "Goldberg and Nivre,? \\Q2013\\E", "shortCiteRegEx": "Goldberg and Nivre", "year": 2013}, {"title": "Efficient Implementation of Beam-Search Incremental Parsers", "author": ["Y. Goldberg", "K. Zhao", "L. Huang"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Goldberg et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Goldberg et al\\.", "year": 2013}, {"title": "Learning Task-Dependent Distributed Representations by Backpropagation Through Structure", "author": ["C. Goller", "A. K\u00fcchler"], "venue": "In In Proc. of the ICNN-96,", "citeRegEx": "Goller and K\u00fcchler,? \\Q1996\\E", "shortCiteRegEx": "Goller and K\u00fcchler", "year": 1996}, {"title": "Supervised sequence labelling with recurrent neural networks", "author": ["A. Graves"], "venue": "Ph.D. thesis, Technische Universit\u00e4t M\u00fcnchen.", "citeRegEx": "Graves,? 2008", "shortCiteRegEx": "Graves", "year": 2008}, {"title": "LSTM: A Search Space Odyssey", "author": ["K. Greff", "R.K. Srivastava", "J. Kout\u0144\u0131k", "B.R. Steunebrink", "J. Schmidhuber"], "venue": null, "citeRegEx": "Greff et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Greff et al\\.", "year": 2015}, {"title": "Search-based Structured Prediction. Machine Learning Journal (MLJ)", "author": ["Hal Daum\u00e9 III", "J. Langford", "D. Marcu"], "venue": null, "citeRegEx": "III et al\\.,? \\Q2009\\E", "shortCiteRegEx": "III et al\\.", "year": 2009}, {"title": "Distributional Structure", "author": ["Z. Harris"], "venue": "Word, 10 (23), 146\u2013162.", "citeRegEx": "Harris,? 1954", "shortCiteRegEx": "Harris", "year": 1954}, {"title": "Simple Customization of Recursive Neural Networks for Semantic Relation Classification", "author": ["K. Hashimoto", "M. Miwa", "Y. Tsuruoka", "T. Chikayama"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Hashimoto et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Hashimoto et al\\.", "year": 2013}, {"title": "Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": null, "citeRegEx": "He et al\\.,? \\Q2015\\E", "shortCiteRegEx": "He et al\\.", "year": 2015}, {"title": "Deep Neural Network Approach for the Dialog State Tracking Challenge", "author": ["M. Henderson", "B. Thomson", "S. Young"], "venue": "In Proceedings of the SIGDIAL 2013 Conference,", "citeRegEx": "Henderson et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Henderson et al\\.", "year": 2013}, {"title": "The Role of Syntax in Vector Space Models of Compositional Semantics. In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["K.M. Hermann", "P. Blunsom"], "venue": null, "citeRegEx": "Hermann and Blunsom,? \\Q2013\\E", "shortCiteRegEx": "Hermann and Blunsom", "year": 2013}, {"title": "Multilingual Models for Compositional Distributed Semantics. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["K.M. Hermann", "P. Blunsom"], "venue": null, "citeRegEx": "Hermann and Blunsom,? \\Q2014\\E", "shortCiteRegEx": "Hermann and Blunsom", "year": 2014}, {"title": "Hierarchical Recurrent Neural Networks for Long-Term Dependencies", "author": ["S.E. Hihi", "Y. Bengio"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Hihi and Bengio,? \\Q1996\\E", "shortCiteRegEx": "Hihi and Bengio", "year": 1996}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov"], "venue": null, "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "Long short-term memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural computation,", "citeRegEx": "Hochreiter and Schmidhuber,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter and Schmidhuber", "year": 1997}, {"title": "Multilayer feedforward networks are universal approximators", "author": ["K. Hornik", "M. Stinchcombe", "H. White"], "venue": "Neural Networks,", "citeRegEx": "Hornik et al\\.,? \\Q1989\\E", "shortCiteRegEx": "Hornik et al\\.", "year": 1989}, {"title": "Opinion Mining with Deep Recurrent Neural Networks", "author": ["O. Irsoy", "C. Cardie"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Irsoy and Cardie,? \\Q2014\\E", "shortCiteRegEx": "Irsoy and Cardie", "year": 2014}, {"title": "A Neural Network for Factoid Question Answering over Paragraphs", "author": ["M. Iyyer", "J. Boyd-Graber", "L. Claudino", "R. Socher", "H. Daum\u00e9 III"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Iyyer et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Iyyer et al\\.", "year": 2014}, {"title": "Political Ideology Detection Using Recursive Neural Networks. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["M. Iyyer", "P. Enns", "J. Boyd-Graber", "P. Resnik"], "venue": null, "citeRegEx": "Iyyer et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Iyyer et al\\.", "year": 2014}, {"title": "Deep Unordered Composition Rivals Syntactic Methods for Text Classification", "author": ["M. Iyyer", "V. Manjunatha", "J. Boyd-Graber", "H. Daum\u00e9 III"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Iyyer et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Iyyer et al\\.", "year": 2015}, {"title": "Effective Use of Word Order for Text Categorization with Convolutional Neural Networks", "author": ["R. Johnson", "T. Zhang"], "venue": null, "citeRegEx": "Johnson and Zhang,? \\Q2014\\E", "shortCiteRegEx": "Johnson and Zhang", "year": 2014}, {"title": "Effective Use of Word Order for Text Categorization with Convolutional Neural Networks", "author": ["R. Johnson", "T. Zhang"], "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Johnson and Zhang,? \\Q2015\\E", "shortCiteRegEx": "Johnson and Zhang", "year": 2015}, {"title": "An Empirical Exploration of Recurrent Network Architectures", "author": ["R. Jozefowicz", "W. Zaremba", "I. Sutskever"], "venue": "In Proceedings of the 32nd International Conference on Machine Learning", "citeRegEx": "Jozefowicz et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Jozefowicz et al\\.", "year": 2015}, {"title": "A Convolutional Neural Network for Modelling Sentences", "author": ["N. Kalchbrenner", "E. Grefenstette", "P. Blunsom"], "venue": null, "citeRegEx": "Kalchbrenner et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kalchbrenner et al\\.", "year": 2014}, {"title": "Visualizing and Understanding Recurrent Networks. arXiv:1506.02078 [cs", "author": ["A. Karpathy", "J. Johnson", "Li", "F.-F"], "venue": null, "citeRegEx": "Karpathy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Karpathy et al\\.", "year": 2015}, {"title": "Convolutional Neural Networks for Sentence Classification", "author": ["Y. Kim"], "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 1746\u20131751, Doha, Qatar. Association for Computational Linguistics.", "citeRegEx": "Kim,? 2014", "shortCiteRegEx": "Kim", "year": 2014}, {"title": "Adam: A Method for Stochastic Optimization", "author": ["D. Kingma", "J. Ba"], "venue": null, "citeRegEx": "Kingma and Ba,? \\Q2014\\E", "shortCiteRegEx": "Kingma and Ba", "year": 2014}, {"title": "ImageNet Classification with Deep Convolutional Neural Networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Fast Methods for Kernel-based Text Analysis", "author": ["T. Kudo", "Y. Matsumoto"], "venue": "In Proceedings of the 41st Annual Meeting on Association for Computational Linguistics Volume 1,", "citeRegEx": "Kudo and Matsumoto,? \\Q2003\\E", "shortCiteRegEx": "Kudo and Matsumoto", "year": 2003}, {"title": "The Inside-Outside Recursive Neural Network model for Dependency Parsing", "author": ["P. Le", "W. Zuidema"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Le and Zuidema,? \\Q2014\\E", "shortCiteRegEx": "Le and Zuidema", "year": 2014}, {"title": "The Forest Convolutional Network: Compositional Distributional Semantics with a Neural Chart and without Binarization", "author": ["P. Le", "W. Zuidema"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Le and Zuidema,? \\Q2015\\E", "shortCiteRegEx": "Le and Zuidema", "year": 2015}, {"title": "A Simple Way to Initialize Recurrent Networks of Rectified Linear Units", "author": ["Q.V. Le", "N. Jaitly", "G.E. Hinton"], "venue": null, "citeRegEx": "Le et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Le et al\\.", "year": 2015}, {"title": "Convolutional Networks for Images, Speech, and TimeSeries", "author": ["Y. LeCun", "Y. Bengio"], "venue": "The Handbook of Brain Theory and Neural Networks", "citeRegEx": "LeCun and Bengio,? \\Q1995\\E", "shortCiteRegEx": "LeCun and Bengio", "year": 1995}, {"title": "Efficient BackProp", "author": ["Y. LeCun", "L. Bottou", "G. Orr", "K. Muller"], "venue": "Neural Networks: Tricks of the trade. Springer", "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Gradient Based Learning Applied to Pattern Recognition", "author": ["Y. Lecun", "L. Bottou", "Y. Bengio", "P. Haffner"], "venue": null, "citeRegEx": "Lecun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Lecun et al\\.", "year": 1998}, {"title": "A tutorial on energybased learning", "author": ["Y. LeCun", "S. Chopra", "R. Hadsell", "M. Ranzato", "F. Huang"], "venue": "Predicting structured data,", "citeRegEx": "LeCun et al\\.,? \\Q2006\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 2006}, {"title": "Loss functions for discriminative training of energybased models", "author": ["Y. LeCun", "F. Huang"], "venue": null, "citeRegEx": "LeCun and Huang,? \\Q2005\\E", "shortCiteRegEx": "LeCun and Huang", "year": 2005}, {"title": "Dependency-Based Word Embeddings", "author": ["O. Levy", "Y. Goldberg"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Levy and Goldberg,? \\Q2014\\E", "shortCiteRegEx": "Levy and Goldberg", "year": 2014}, {"title": "Neural Word Embedding as Implicit Matrix Factorization", "author": ["O. Levy", "Y. Goldberg"], "venue": null, "citeRegEx": "Levy and Goldberg,? \\Q2014\\E", "shortCiteRegEx": "Levy and Goldberg", "year": 2014}, {"title": "Improving Distributional Similarity with Lessons Learned from Word Embeddings", "author": ["O. Levy", "Y. Goldberg", "I. Dagan"], "venue": "Transactions of the Association for Computational Linguistics,", "citeRegEx": "Levy et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Levy et al\\.", "year": 2015}, {"title": "Improved CCG Parsing with Semi-supervised Supertagging", "author": ["M. Lewis", "M. Steedman"], "venue": "Transactions of the Association for Computational Linguistics,", "citeRegEx": "Lewis and Steedman,? \\Q2014\\E", "shortCiteRegEx": "Lewis and Steedman", "year": 2014}, {"title": "Recursive Deep Models for Discourse Parsing", "author": ["J. Li", "R. Li", "E. Hovy"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Li et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Li et al\\.", "year": 2014}, {"title": "Two/Too Simple Adaptations of Word2Vec for Syntax Problems", "author": ["W. Ling", "C. Dyer", "A.W. Black", "I. Trancoso"], "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Ling et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ling et al\\.", "year": 2015}, {"title": "Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation", "author": ["W. Ling", "C. Dyer", "A.W. Black", "I. Trancoso", "R. Fermandez", "S. Amir", "L. Marujo", "T. Luis"], "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Ling et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ling et al\\.", "year": 2015}, {"title": "A Dependency-Based Neural Network for Relation Classification", "author": ["Y. Liu", "F. Wei", "S. Li", "H. Ji", "M. Zhou", "H. WANG"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Liu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2015}, {"title": "Tagging The Web: Building A Robust Web Tagger with Neural Network", "author": ["J. Ma", "Y. Zhang", "J. Zhu"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),", "citeRegEx": "Ma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2014}, {"title": "Dependency-based Convolutional Neural Networks for Sentence Embedding", "author": ["M. Ma", "L. Huang", "B. Zhou", "B. Xiang"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Ma et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2015}, {"title": "Maximum Entropy Markov Models for Information Extraction and Segmentation", "author": ["A. McCallum", "D. Freitag", "F.C. Pereira"], "venue": "In ICML,", "citeRegEx": "McCallum et al\\.,? \\Q2000\\E", "shortCiteRegEx": "McCallum et al\\.", "year": 2000}, {"title": "Efficient Estimation of Word Representations in Vector Space", "author": ["T. Mikolov", "K. Chen", "G. Corrado", "J. Dean"], "venue": null, "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Learning Longer Memory in Recurrent Neural Networks", "author": ["T. Mikolov", "A. Joulin", "S. Chopra", "M. Mathieu", "M. Ranzato"], "venue": null, "citeRegEx": "Mikolov et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2014}, {"title": "Recurrent neural network based language model", "author": ["T. Mikolov", "M. Karafi\u00e1t", "L. Burget", "J. Cernocky", "S. Khudanpur"], "venue": "In INTERSPEECH 2010, 11th Annual Conference of the International Speech Communication Association,", "citeRegEx": "Mikolov et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2010}, {"title": "Extensions of recurrent neural network language model", "author": ["T. Mikolov", "S. Kombrink", "Luk\u00e1\u0161 Burget", "J.H. \u010cernocky", "S. Khudanpur"], "venue": "In Acoustics, Speech and Signal Processing (ICASSP),", "citeRegEx": "Mikolov et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2011}, {"title": "Distributed Representations of Words and Phrases and their Compositionality", "author": ["T. Mikolov", "I. Sutskever", "K. Chen", "G.S. Corrado", "J. Dean"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Mikolov et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Mikolov et al\\.", "year": 2013}, {"title": "Statistical language models based on neural networks", "author": ["T. Mikolov"], "venue": "Ph.D. thesis, Ph. D. thesis, Brno University of Technology.", "citeRegEx": "Mikolov,? 2012", "shortCiteRegEx": "Mikolov", "year": 2012}, {"title": "Learning word embeddings efficiently with noisecontrastive estimation", "author": ["A. Mnih", "K. Kavukcuoglu"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Mnih and Kavukcuoglu,? \\Q2013\\E", "shortCiteRegEx": "Mnih and Kavukcuoglu", "year": 2013}, {"title": "Multi-domain Dialog State Tracking using Recurrent Neural Networks", "author": ["N. Mrk\u0161i\u0107", "D. \u00d3 S\u00e9aghdha", "B. Thomson", "M. Gasic", "Su", "P.-H", "D. Vandyke", "Wen", "T.-H", "S. Young"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume", "citeRegEx": "Mrk\u0161i\u0107 et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mrk\u0161i\u0107 et al\\.", "year": 2015}, {"title": "Introduction to Automatic Differentiation and MATLAB ObjectOriented Programming", "author": ["R. Neidinger"], "venue": "SIAM Review, 52 (3), 545\u2013563.", "citeRegEx": "Neidinger,? 2010", "shortCiteRegEx": "Neidinger", "year": 2010}, {"title": "Event Detection and Domain Adaptation with Convolutional Neural Networks", "author": ["T.H. Nguyen", "R. Grishman"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Nguyen and Grishman,? \\Q2015\\E", "shortCiteRegEx": "Nguyen and Grishman", "year": 2015}, {"title": "Algorithms for Deterministic Incremental Dependency Parsing", "author": ["J. Nivre"], "venue": "Computational Linguistics, 34 (4), 513\u2013553.", "citeRegEx": "Nivre,? 2008", "shortCiteRegEx": "Nivre", "year": 2008}, {"title": "Purely Functional Data Structures", "author": ["C. Okasaki"], "venue": "Cambridge University Press, Cambridge, U.K.; New York.", "citeRegEx": "Okasaki,? 1999", "shortCiteRegEx": "Okasaki", "year": 1999}, {"title": "On the difficulty of training Recurrent Neural Networks", "author": ["R. Pascanu", "T. Mikolov", "Y. Bengio"], "venue": null, "citeRegEx": "Pascanu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Pascanu et al\\.", "year": 2012}, {"title": "An Effective Neural Network Model for Graph-based Dependency Parsing", "author": ["W. Pei", "T. Ge", "B. Chang"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Pei et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Pei et al\\.", "year": 2015}, {"title": "Glove: Global Vectors for Word Representation", "author": ["J. Pennington", "R. Socher", "C. Manning"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Pennington et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Pennington et al\\.", "year": 2014}, {"title": "Recursive Distributed Representations", "author": ["J.B. Pollack"], "venue": "Artificial Intelligence, 46, 77\u2013105.", "citeRegEx": "Pollack,? 1990", "shortCiteRegEx": "Pollack", "year": 1990}, {"title": "Some methods of speeding up the convergence of iteration methods", "author": ["B.T. Polyak"], "venue": "USSR Computational Mathematics and Mathematical Physics, 4 (5), 1 \u2013 17.", "citeRegEx": "Polyak,? 1964", "shortCiteRegEx": "Polyak", "year": 1964}, {"title": "Learning Tag Embeddings and Tag-specific Composition Functions in Recursive Neural Network", "author": ["Q. Qian", "B. Tian", "M. Huang", "Y. Liu", "X. Zhu"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Qian et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Qian et al\\.", "year": 2015}, {"title": "word2vec Parameter Learning Explained", "author": ["X. Rong"], "venue": "arXiv:1411.2738 [cs].", "citeRegEx": "Rong,? 2014", "shortCiteRegEx": "Rong", "year": 2014}, {"title": "Learning representations by back-propagating", "author": ["D.E. Rumelhart", "G.E. Hinton", "R.J. Williams"], "venue": "errors. Nature,", "citeRegEx": "Rumelhart et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Rumelhart et al\\.", "year": 1986}, {"title": "Learning Character-level Representations for Partof-Speech Tagging", "author": ["C.D. Santos", "B. Zadrozny"], "venue": null, "citeRegEx": "Santos and Zadrozny,? \\Q2014\\E", "shortCiteRegEx": "Santos and Zadrozny", "year": 2014}, {"title": "Bidirectional recurrent neural networks", "author": ["M. Schuster", "K.K. Paliwal"], "venue": "IEEE Transactions on Signal Processing,", "citeRegEx": "Schuster and Paliwal,? \\Q1997\\E", "shortCiteRegEx": "Schuster and Paliwal", "year": 1997}, {"title": "Kernel Methods for Pattern Analysis", "author": ["J. Shawe-Taylor", "N. Cristianini"], "venue": null, "citeRegEx": "Shawe.Taylor and Cristianini,? \\Q2004\\E", "shortCiteRegEx": "Shawe.Taylor and Cristianini", "year": 2004}, {"title": "Linguistic Structure Prediction", "author": ["N.A. Smith"], "venue": "Synthesis Lectures on Human Language Technologies. Morgan and Claypool.", "citeRegEx": "Smith,? 2011", "shortCiteRegEx": "Smith", "year": 2011}, {"title": "Recursive Deep Learning For Natural Language Processing and Computer Vision", "author": ["R. Socher"], "venue": "Ph.D. thesis, Stanford University.", "citeRegEx": "Socher,? 2014", "shortCiteRegEx": "Socher", "year": 2014}, {"title": "Parsing with Compositional Vector Grammars", "author": ["R. Socher", "J. Bauer", "C.D. Manning", "N. Andrew Y"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),", "citeRegEx": "Socher et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2013}, {"title": "Semantic Compositionality through Recursive Matrix-Vector Spaces", "author": ["R. Socher", "B. Huval", "C.D. Manning", "A.Y. Ng"], "venue": "In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,", "citeRegEx": "Socher et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2012}, {"title": "Parsing Natural Scenes and Natural Language with Recursive Neural Networks", "author": ["R. Socher", "Lin", "C.C.-Y", "A.Y. Ng", "C.D. Manning"], "venue": "Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "Socher et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2011}, {"title": "Learning Continuous Phrase Representations and Syntactic Parsing with Recursive Neural Networks", "author": ["R. Socher", "C. Manning", "A. Ng"], "venue": "In Proceedings of the Deep Learning and Unsupervised Feature Learning Workshop of {NIPS}", "citeRegEx": "Socher et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2010}, {"title": "Recursive Deep Models for Semantic Compositionality Over a Sentiment Treebank", "author": ["R. Socher", "A. Perelygin", "J. Wu", "J. Chuang", "C.D. Manning", "A. Ng", "C. Potts"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Socher et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Socher et al\\.", "year": 2013}, {"title": "A Neural Network Approach to Context-Sensitive Generation of Conversational Responses", "author": ["A. Sordoni", "M. Galley", "M. Auli", "C. Brockett", "Y. Ji", "M. Mitchell", "Nie", "J.-Y", "J. Gao", "B. Dolan"], "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Sordoni et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Sordoni et al\\.", "year": 2015}, {"title": "Translation Modeling with Bidirectional Recurrent Neural Networks", "author": ["M. Sundermeyer", "T. Alkhouli", "J. Wuebker", "H. Ney"], "venue": "In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP),", "citeRegEx": "Sundermeyer et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sundermeyer et al\\.", "year": 2014}, {"title": "LSTM Neural Networks for Language Modeling", "author": ["M. Sundermeyer", "R. Schl\u00fcter", "H. Ney"], "venue": "In INTERSPEECH", "citeRegEx": "Sundermeyer et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Sundermeyer et al\\.", "year": 2012}, {"title": "On the importance of initialization and momentum in deep learning", "author": ["I. Sutskever", "J. Martens", "G. Dahl", "G. Hinton"], "venue": "In Proceedings of the 30th international conference on machine learning", "citeRegEx": "Sutskever et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2013}, {"title": "Generating text with recurrent neural networks", "author": ["I. Sutskever", "J. Martens", "G.E. Hinton"], "venue": "In Proceedings of the 28th International Conference on Machine Learning", "citeRegEx": "Sutskever et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2011}, {"title": "Sequence to Sequence Learning with Neural Networks", "author": ["I. Sutskever", "O. Vinyals", "Q.V.V. Le"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Sutskever et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Sutskever et al\\.", "year": 2014}, {"title": "Improved Semantic Representations From Tree-Structured Long Short-Term Memory Networks", "author": ["K.S. Tai", "R. Socher", "C.D. Manning"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Tai et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Tai et al\\.", "year": 2015}, {"title": "Recurrent Neural Networks for Word Alignment Model. In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["A. Tamura", "T. Watanabe", "E. Sumita"], "venue": null, "citeRegEx": "Tamura et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Tamura et al\\.", "year": 2014}, {"title": "Lecture 6.5\u2014RmsProp: Divide the gradient by a running average of its recent magnitude. COURSERA: Neural Networks for Machine Learning", "author": ["T. Tieleman", "G. Hinton"], "venue": null, "citeRegEx": "Tieleman and Hinton,? \\Q2012\\E", "shortCiteRegEx": "Tieleman and Hinton", "year": 2012}, {"title": "A Neural Network Approach to Selectional Preference Acquisition", "author": ["T. Van de Cruys"], "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pp. 26\u201335, Doha, Qatar. Association for Computational Linguistics.", "citeRegEx": "Cruys,? 2014", "shortCiteRegEx": "Cruys", "year": 2014}, {"title": "Decoding with Large-Scale Neural Language Models Improves Translation", "author": ["A. Vaswani", "Y. Zhao", "V. Fossum", "D. Chiang"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Vaswani et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Vaswani et al\\.", "year": 2013}, {"title": "Dropout Training as Adaptive Regularization", "author": ["S. Wager", "S. Wang", "P.S. Liang"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "Wager et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Wager et al\\.", "year": 2013}, {"title": "Semantic Clustering and Convolutional Neural Network for Short Text Categorization", "author": ["P. Wang", "J. Xu", "B. Xu", "C. Liu", "H. Zhang", "F. Wang", "H. Hao"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Wang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2015}, {"title": "Predicting Polarities of Tweets by Composing Word Embeddings with Long Short-Term Memory", "author": ["X. Wang", "Y. Liu", "C. SUN", "B. Wang"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Wang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2015}, {"title": "Transition-based Neural Constituent Parsing", "author": ["T. Watanabe", "E. Sumita"], "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Watanabe and Sumita,? \\Q2015\\E", "shortCiteRegEx": "Watanabe and Sumita", "year": 2015}, {"title": "Structured Training for Neural Network Transition-Based Parsing", "author": ["D. Weiss", "C. Alberti", "M. Collins", "S. Petrov"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Weiss et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Weiss et al\\.", "year": 2015}, {"title": "Backpropagation through time: What it does and how to do it", "author": ["P.J. Werbos"], "venue": "Proceedings of the IEEE,", "citeRegEx": "Werbos,? \\Q1990\\E", "shortCiteRegEx": "Werbos", "year": 1990}, {"title": "Connecting Language and Knowledge Bases with Embedding Models for Relation Extraction", "author": ["J. Weston", "A. Bordes", "O. Yakhnenko", "N. Usunier"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Weston et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Weston et al\\.", "year": 2013}, {"title": "CCG Supertagging with a Recurrent Neural Network", "author": ["W. Xu", "M. Auli", "S. Clark"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 2: Short Papers),", "citeRegEx": "Xu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Xu et al\\.", "year": 2015}, {"title": "Convolutional Neural Network for Paraphrase Identification", "author": ["W. Yin", "H. Sch\u00fctze"], "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Yin and Sch\u00fctze,? \\Q2015\\E", "shortCiteRegEx": "Yin and Sch\u00fctze", "year": 2015}, {"title": "Recurrent Neural Network Regularization", "author": ["W. Zaremba", "I. Sutskever", "O. Vinyals"], "venue": null, "citeRegEx": "Zaremba et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zaremba et al\\.", "year": 2014}, {"title": "ADADELTA: An Adaptive Learning Rate Method", "author": ["M.D. Zeiler"], "venue": "arXiv:1212.5701", "citeRegEx": "Zeiler,? 2012", "shortCiteRegEx": "Zeiler", "year": 2012}, {"title": "Relation Classification via Convolutional Deep Neural Network", "author": ["D. Zeng", "K. Liu", "S. Lai", "G. Zhou", "J. Zhao"], "venue": "In Proceedings of COLING 2014, the 25th International Conference on Computational Linguistics: Technical Papers,", "citeRegEx": "Zeng et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zeng et al\\.", "year": 2014}, {"title": "A Neural Probabilistic StructuredPrediction Model for Transition-Based Dependency Parsing", "author": ["H. Zhou", "Y. Zhang", "S. Huang", "J. Chen"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Zhou et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zhou et al\\.", "year": 2015}, {"title": "A Re-ranking Model for Dependency Parser with Recursive Convolutional Neural Network", "author": ["C. Zhu", "X. Qiu", "X. Chen", "X. Huang"], "venue": "In Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers),", "citeRegEx": "Zhu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zhu et al\\.", "year": 2015}, {"title": "Long Short-Term Memory Over Tree Structures", "author": ["X. Zhu", "P. Sobhani", "H. Guo"], "venue": null, "citeRegEx": "Zhu et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zhu et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 8, "context": "In particular, the book by Bengio et al (2015) is highly recommended.", "startOffset": 27, "endOffset": 47}, {"referenceID": 72, "context": "Convolutional and pooling architecture show promising results on many tasks, including document classification (Johnson & Zhang, 2015), short-text categorization (Wang, Xu, Xu, Liu, Zhang, Wang, & Hao, 2015a), sentiment classification (Kalchbrenner, Grefenstette, & Blunsom, 2014; Kim, 2014), relation type classification between entities (Zeng, Liu, Lai, Zhou, & Zhao, 2014; dos Santos, Xiang, & Zhou, 2015), event detection (Chen, Xu, Liu, Zeng, & Zhao, 2015; Nguyen & Grishman, 2015), paraphrase identification (Yin & Sch\u00fctze, 2015) semantic role labeling (Collobert, Weston, Bottou, Karlen, Kavukcuoglu, & Kuksa, 2011), question answering (Dong, Wei, Zhou, & Xu, 2015), predicting box-office revenues of movies based on critic reviews (Bitvai & Cohn, 2015) modeling text interestingness (Gao, Pantel, Gamon, He, & Deng, 2014), and modeling the relation between character-sequences and part-of-speech tags (Santos & Zadrozny, 2014).", "startOffset": 235, "endOffset": 291}, {"referenceID": 8, "context": "Straight-forward applications of a feed-forward network as a classifier replacement (usually coupled with the use of pre-trained word vectors) provide benefits also for CCG supertagging (Lewis & Steedman, 2014), dialog state tracking (Henderson, Thomson, & Young, 2013), pre-ordering for statistical machine translation (de Gispert, Iglesias, & Byrne, 2015) and language modeling (Bengio, Ducharme, Vincent, & Janvin, 2003; Vaswani, Zhao, Fossum, & Chiang, 2013). Iyyer et al (2015) demonstrate that multilayer feed-forward networks can provide competitive results on sentiment classification and factoid question answering.", "startOffset": 381, "endOffset": 483}, {"referenceID": 37, "context": "Recurrent networks (Elman, 1990) are designed to model sequences, while recursive networks (Goller & K\u00fcchler, 1996) are generalizations of recurrent networks that can handle trees.", "startOffset": 19, "endOffset": 32}, {"referenceID": 100, "context": "Recurrent models have been shown to produce very strong results for language modeling, including (Mikolov, Karafi\u00e1t, Burget, Cernocky, & Khudanpur, 2010; Mikolov, Kombrink, Luk\u00e1\u0161 Burget, \u010cernocky, & Khudanpur, 2011; Mikolov, 2012; Duh, Neubig, Sudoh, & Tsukada, 2013; Adel, Vu, & Schultz, 2013; Auli, Galley, Quirk, & Zweig, 2013; Auli & Gao, 2014); as well as for sequence tagging (Irsoy & Cardie, 2014; Xu, Auli, & Clark, 2015; Ling, Dyer, Black, Trancoso, Fermandez, Amir, Marujo, & Luis, 2015b), machine translation (Sundermeyer, Alkhouli, Wuebker, & Ney, 2014; Tamura, Watanabe, & Sumita, 2014; Sutskever, Vinyals, & Le, 2014; Cho, van Merrienboer, Gulcehre, Bahdanau, Bougares, Schwenk, & Bengio, 2014b), dependency parsing (Dyer et al.", "startOffset": 97, "endOffset": 348}, {"referenceID": 36, "context": "Recurrent models have been shown to produce very strong results for language modeling, including (Mikolov, Karafi\u00e1t, Burget, Cernocky, & Khudanpur, 2010; Mikolov, Kombrink, Luk\u00e1\u0161 Burget, \u010cernocky, & Khudanpur, 2011; Mikolov, 2012; Duh, Neubig, Sudoh, & Tsukada, 2013; Adel, Vu, & Schultz, 2013; Auli, Galley, Quirk, & Zweig, 2013; Auli & Gao, 2014); as well as for sequence tagging (Irsoy & Cardie, 2014; Xu, Auli, & Clark, 2015; Ling, Dyer, Black, Trancoso, Fermandez, Amir, Marujo, & Luis, 2015b), machine translation (Sundermeyer, Alkhouli, Wuebker, & Ney, 2014; Tamura, Watanabe, & Sumita, 2014; Sutskever, Vinyals, & Le, 2014; Cho, van Merrienboer, Gulcehre, Bahdanau, Bougares, Schwenk, & Bengio, 2014b), dependency parsing (Dyer et al., 2015; Watanabe & Sumita, 2015), sentiment analysis (Wang, Liu, SUN, Wang, & Wang, 2015b), noisy text normalization (Chrupala, 2014), dialog state tracking (Mrk\u0161i\u0107, \u00d3 S\u00e9aghdha, Thomson, Gasic, Su, Vandyke, Wen, & Young, 2015), response generation (Sordoni, Galley, Auli, Brockett, Ji, Mitchell, Nie, Gao, & Dolan, 2015), and modeling the relation between character sequences and part-of-speech tags (Ling et al.", "startOffset": 730, "endOffset": 774}, {"referenceID": 18, "context": ", 2015; Watanabe & Sumita, 2015), sentiment analysis (Wang, Liu, SUN, Wang, & Wang, 2015b), noisy text normalization (Chrupala, 2014), dialog state tracking (Mrk\u0161i\u0107, \u00d3 S\u00e9aghdha, Thomson, Gasic, Su, Vandyke, Wen, & Young, 2015), response generation (Sordoni, Galley, Auli, Brockett, Ji, Mitchell, Nie, Gao, & Dolan, 2015), and modeling the relation between character sequences and part-of-speech tags (Ling et al.", "startOffset": 117, "endOffset": 133}, {"referenceID": 23, "context": "The majority of work (pioneered by (Collobert & Weston, 2008; Collobert et al., 2011; Chen & Manning, 2014)) advocate the use of dense, trainable embedding vectors for all features.", "startOffset": 35, "endOffset": 107}, {"referenceID": 147, "context": "Instead, distance features are encoded similarly to the other feature types: each bin is associated with a d-dimensional vector, and these distance-embedding vectors are then trained as regular parameters in the network (Zeng et al., 2014; dos Santos et al., 2015; Zhu et al., 2015a; Nguyen & Grishman, 2015).", "startOffset": 220, "endOffset": 308}, {"referenceID": 14, "context": "Using embeddings for representing not only words but arbitrary features was popularized following Chen and Manning (2014).", "startOffset": 98, "endOffset": 122}, {"referenceID": 26, "context": "In terms of representation power, it was shown by (Hornik, Stinchcombe, & White, 1989; Cybenko, 1989) that MLP1 is a universal approximator \u2013 it can approximate with any desired non-zero amount of error a family of functions8 that include all continuous functions", "startOffset": 50, "endOffset": 101}, {"referenceID": 108, "context": "The tanh cube activation function g(x) = tanh((x) + x) was proposed by (Pei et al., 2015), who found it to be more effective than other non-linearities in a feed-forward network that was used as a component in a structured-prediction graph-based dependency parser.", "startOffset": 71, "endOffset": 89}, {"referenceID": 9, "context": "For a detailed discussion on loss functions for neural networks see (LeCun, Chopra, Hadsell, Ranzato, & Huang, 2006; LeCun & Huang, 2005; Bengio et al., 2015).", "startOffset": 68, "endOffset": 158}, {"referenceID": 24, "context": "Hinge (multiclass) The hinge loss was extended to the multiclass setting by Crammer and Singer (2002). Let \u0177 = \u01771, .", "startOffset": 76, "endOffset": 102}, {"referenceID": 82, "context": "Log loss The log loss is a common variation of the hinge loss, which can be seen as a \u201csoft\u201d version of the hinge loss with an infinite margin (LeCun et al., 2006).", "startOffset": 143, "endOffset": 163}, {"referenceID": 41, "context": "An example of using the ranking log loss can be found in (Gao et al., 2014).", "startOffset": 57, "endOffset": 75}, {"referenceID": 132, "context": "Similarly, Van de Cruys (2014) used the ranking loss in a selectional-preferences task, in which the network was trained to rank correct verb-object pairs above incorrect, automatically derived ones, and (Weston, Bordes, Yakhnenko, & Usunier, 2013) trained a model to score correct (head,relation,trail) triplets above corrupted ones in an information-extraction setting.", "startOffset": 18, "endOffset": 31}, {"referenceID": 95, "context": "The method used by the effective word2vec implementation (Mikolov et al., 2013; Mikolov, Sutskever, Chen, Corrado, & Dean, 2013) is to initialize the word vectors to uniformly sampled random numbers in the range [\u2212 1 2d , 1 2d ] where d is the number of dimensions.", "startOffset": 57, "endOffset": 128}, {"referenceID": 53, "context": "While word similarity is hard to define and is usually very task-dependent, the current approaches derive from the distributional hypothesis (Harris, 1954), stating that words are similar if they appear in similar contexts.", "startOffset": 141, "endOffset": 155}, {"referenceID": 86, "context": "However, they are deeply connected to another family of algorithms which evolved in the NLP and IR communities, and that are based on matrix factorization (see (Levy & Goldberg, 2014b; Levy et al., 2015) for a discussion).", "startOffset": 160, "endOffset": 203}, {"referenceID": 113, "context": "See (Rong, 2014; Levy, Goldberg, & Dagan, 2015) for a discussion.", "startOffset": 4, "endOffset": 47}, {"referenceID": 95, "context": "Language-modeling inspired approaches such as those taken by (Mikolov et al., 2013; Mnih & Kavukcuoglu, 2013) as well as GloVe (Pennington et al.", "startOffset": 61, "endOffset": 109}, {"referenceID": 109, "context": ", 2013; Mnih & Kavukcuoglu, 2013) as well as GloVe (Pennington et al., 2014) use auxiliary tasks in which the goal is to predict the word given its context.", "startOffset": 51, "endOffset": 76}, {"referenceID": 95, "context": "Then, either a single task is created in which the goal is to predict the focus word based on all of the context words (represented either using CBOW (Mikolov et al., 2013) or vector concatenation (Collobert & Weston, 2008)), or 2k distinct tasks are created, each pairing the focus word with a different context word.", "startOffset": 150, "endOffset": 172}, {"referenceID": 95, "context": "The 2k tasks approach, popularized by (Mikolov et al., 2013) is referred to as a skip-gram model.", "startOffset": 38, "endOffset": 60}, {"referenceID": 95, "context": "Skip-gram based approaches are shown to be robust and efficient to train (Mikolov et al., 2013; Pennington et al., 2014), and often produce state of the art results.", "startOffset": 73, "endOffset": 120}, {"referenceID": 109, "context": "Skip-gram based approaches are shown to be robust and efficient to train (Mikolov et al., 2013; Pennington et al., 2014), and often produce state of the art results.", "startOffset": 73, "endOffset": 120}, {"referenceID": 86, "context": "Some of these hyperparameters (and others) are discussed in (Levy et al., 2015).", "startOffset": 60, "endOffset": 79}, {"referenceID": 31, "context": "dos Santos and Gatti (2014) and dos Santos and Zadrozny (2014) model the embedding of a word using a convolutional network (see Section 9) over the characters.", "startOffset": 4, "endOffset": 28}, {"referenceID": 31, "context": "dos Santos and Gatti (2014) and dos Santos and Zadrozny (2014) model the embedding of a word using a convolutional network (see Section 9) over the characters.", "startOffset": 4, "endOffset": 63}, {"referenceID": 31, "context": "dos Santos and Gatti (2014) and dos Santos and Zadrozny (2014) model the embedding of a word using a convolutional network (see Section 9) over the characters. Ling et al (2015b) model the embedding of a word using the concatenation of the final states of two RNN (LSTM) encoders (Section 10), one reading the characters from left to right, and the other from right to left.", "startOffset": 4, "endOffset": 179}, {"referenceID": 31, "context": "dos Santos and Gatti (2014) and dos Santos and Zadrozny (2014) model the embedding of a word using a convolutional network (see Section 9) over the characters. Ling et al (2015b) model the embedding of a word using the concatenation of the final states of two RNN (LSTM) encoders (Section 10), one reading the characters from left to right, and the other from right to left. Both produce very strong results for part-of-speech tagging. The work of Ballesteros et al (2015) show that the two-LSTMs encoding of (Ling et al.", "startOffset": 4, "endOffset": 473}, {"referenceID": 41, "context": "Gao et al (Gao et al., 2014) suggest using as core features not only the word form itself but also a unique feature (hence a unique embedding vector) for each of the letter-trigrams in the word.", "startOffset": 10, "endOffset": 28}, {"referenceID": 11, "context": "Botha and Blunsom (2014) suggest to model the embedding vector of a word as a sum of the word-specific vector if such vector is available, with vectors for the different morphological components that comprise it (the components are derived using Morfessor (Creutz & Lagus, 2007), an unsupervised morphological segmentation method).", "startOffset": 0, "endOffset": 25}, {"referenceID": 12, "context": "The common approach for training neural networks is using the stochastic gradient descent (SGD) algorithm (Bottou, 2012; LeCun, Bottou, Orr, & Muller, 1998a) or a variant of it.", "startOffset": 106, "endOffset": 157}, {"referenceID": 8, "context": "More generally, the backpropagation algorithm is a special case of the reverse-mode automatic differentiation algorithm (Neidinger, 2010, Section 7), (Baydin, Pearlmutter, Radul, & Siskind, 2015; Bengio, 2012).", "startOffset": 150, "endOffset": 209}, {"referenceID": 111, "context": "The SGD+Momentum (Polyak, 1964) and Nesterov Momentum (Sutskever, Martens, Dahl, & Hinton, 2013) algorithms are variants of SGD in which previous gradients are accumulated and affect the current update.", "startOffset": 17, "endOffset": 31}, {"referenceID": 146, "context": "Adaptive learning rate algorithms including AdaGrad (Duchi, Hazan, & Singer, 2011), AdaDelta (Zeiler, 2012),", "startOffset": 93, "endOffset": 107}, {"referenceID": 8, "context": "For most purposes, it is preferable to use automatic tools for gradient computation (Bengio, 2012).", "startOffset": 84, "endOffset": 98}, {"referenceID": 7, "context": "For further information on automatic differentiation see (Neidinger, 2010, Section 7), (Baydin et al., 2015).", "startOffset": 87, "endOffset": 108}, {"referenceID": 8, "context": "4), (Lecun et al., 1998b; Bengio, 2012).", "startOffset": 4, "endOffset": 39}, {"referenceID": 12, "context": "For various practical tips and recommendations, see (LeCun et al., 1998a; Bottou, 2012).", "startOffset": 52, "endOffset": 87}, {"referenceID": 8, "context": "An effective scheme due to Glorot and Bengio (2010), called xavier initialization after Glorot\u2019s first name, suggests initializing a weight matrix W \u2208 Rdin\u00d7dout as:", "startOffset": 38, "endOffset": 52}, {"referenceID": 8, "context": "The problem becomes more severe in deeper networks, and especially so in recursive and recurrent networks (Pascanu, Mikolov, & Bengio, 2012). Dealing with the vanishing gradients problem is still an open research question. Solutions include making the networks shallower, step-wise training (first train the first layers based on some auxiliary output signal, then fix them and train the upper layers of the complete network based on the real task signal), or specialized architectures that are designed to assist in gradient flow (e.g., the LSTM and GRU architectures for recurrent networks, discussed in Section 11). Dealing with the exploding gradients has a simple but very effective solution: clipping the gradients if their norm exceeds a given threshold. Let \u011d be the gradients of all parameters in the network, and \u2016\u011d\u2016 be their L2 norm. Pascanu et al (2012) suggest to set: \u011d\u2190 threshold \u2016\u011d\u2016 \u011d if \u2016\u011d\u2016 > threshold.", "startOffset": 127, "endOffset": 866}, {"referenceID": 12, "context": "L\u00e9on Bottou (2012) recommends using a learning rate of the form \u03b7t = \u03b70(1 + \u03b70\u03bbt) \u22121 where \u03b70 is the initial learning rate, \u03b7t is the learning rate to use on the tth training example, and \u03bb is an additional hyperparameter.", "startOffset": 5, "endOffset": 19}, {"referenceID": 23, "context": "Multi-task learning in the context of language-processing is introduced and discussed in (Collobert et al., 2011).", "startOffset": 89, "endOffset": 113}, {"referenceID": 105, "context": "Examples of this approach are left-to-right tagging models (Gim\u00e9nez & M\u00e0rquez, 2004) and greedy transition-based parsing (Nivre, 2008).", "startOffset": 121, "endOffset": 134}, {"referenceID": 118, "context": "For indepth discussion of search-based structure prediction in NLP, see the book by Smith (Smith, 2011).", "startOffset": 90, "endOffset": 103}, {"referenceID": 118, "context": ", (Smith, 2011), such as cost-augmented decoding, can be easily applied or adapted to the neural-network framework.", "startOffset": 2, "endOffset": 15}, {"referenceID": 118, "context": "Probabilistic objective (CRF) In a probabilistic framework (\u201cCRF\u201d), we treat each of the parts scores as a clique potential (see (Smith, 2011)) and define the score of each structure y to be:", "startOffset": 129, "endOffset": 142}, {"referenceID": 35, "context": "A hinge based approached was used by Pei et al (2015) for arc-factored dependency parsing, and the probabilistic approach by Durrett and Klein (Durrett & Klein, 2015) for a CRF constituency parser. The approximate beam-based partition function was effectively used by Zhou et al (2015) in a transition based parser.", "startOffset": 125, "endOffset": 286}, {"referenceID": 120, "context": "Works using the reranking approach include (Socher et al., 2013; Auli et al., 2013; Le & Zuidema, 2014; Zhu et al., 2015a)", "startOffset": 43, "endOffset": 122}, {"referenceID": 3, "context": "Works using the reranking approach include (Socher et al., 2013; Auli et al., 2013; Le & Zuidema, 2014; Zhu et al., 2015a)", "startOffset": 43, "endOffset": 122}, {"referenceID": 140, "context": "In particular, Weiss et al (Weiss et al., 2015) report strong results for transition-based dependency parsing in a two-stage model.", "startOffset": 27, "endOffset": 47}, {"referenceID": 20, "context": "In the second stage, the neural network model is held fixed, and the different layers (output as well as hidden layer vectors) for each input are then concatenated and used as the input features of a linear structured perceptron model (Collins, 2002) that is trained to perform beam-search for the best resulting structure.", "startOffset": 235, "endOffset": 250}, {"referenceID": 74, "context": "Convolution-and-pooling architectures (LeCun & Bengio, 1995) evolved in the neural networks vision community, where they showed great success as object detectors \u2013 recognizing an object from a predefined category (\u201ccat\u201d, \u201cbicycles\u201d) regardless of its position in the image (Krizhevsky et al., 2012).", "startOffset": 273, "endOffset": 298}, {"referenceID": 72, "context": "Convolutional networks were introduced to the NLP community in the pioneering work of Collobert, Weston and Colleagues (2011) who used them for semantic-role labeling, and later by Kalchbrenner et al (2014) and Kim (Kim, 2014) who used them for sentiment and question-type classification.", "startOffset": 215, "endOffset": 226}, {"referenceID": 8, "context": "Convolution-and-pooling architectures (LeCun & Bengio, 1995) evolved in the neural networks vision community, where they showed great success as object detectors \u2013 recognizing an object from a predefined category (\u201ccat\u201d, \u201cbicycles\u201d) regardless of its position in the image (Krizhevsky et al., 2012). When applied to images, the architecture is using 2dimensional (grid) convolutions. When applied to text, NLP we are mainly concerned with 1-d (sequence) convolutions. Convolutional networks were introduced to the NLP community in the pioneering work of Collobert, Weston and Colleagues (2011) who used them for semantic-role labeling, and later by Kalchbrenner et al (2014) and Kim (Kim, 2014) who used them for sentiment and question-type classification.", "startOffset": 47, "endOffset": 594}, {"referenceID": 8, "context": "Convolution-and-pooling architectures (LeCun & Bengio, 1995) evolved in the neural networks vision community, where they showed great success as object detectors \u2013 recognizing an object from a predefined category (\u201ccat\u201d, \u201cbicycles\u201d) regardless of its position in the image (Krizhevsky et al., 2012). When applied to images, the architecture is using 2dimensional (grid) convolutions. When applied to text, NLP we are mainly concerned with 1-d (sequence) convolutions. Convolutional networks were introduced to the NLP community in the pioneering work of Collobert, Weston and Colleagues (2011) who used them for semantic-role labeling, and later by Kalchbrenner et al (2014) and Kim (Kim, 2014) who used them for sentiment and question-type classification.", "startOffset": 47, "endOffset": 675}, {"referenceID": 70, "context": "Depending on whether we pad the sentence with k \u2212 1 words to each side, we may get either m = n\u2212k+1 (narrow convolution) or m = n+k+1 windows (wide convolution) (Kalchbrenner et al., 2014).", "startOffset": 161, "endOffset": 188}, {"referenceID": 15, "context": "We could argue that the words before the first word, the words after the second word, and the words between them provide three different kinds of information (Chen et al., 2015).", "startOffset": 158, "endOffset": 177}, {"referenceID": 70, "context": "Finally, (Kalchbrenner et al., 2014) introduced a k-max pooling operation, in which the top k values in each dimension are retained instead of only the best one, while preserving the order in which they appeared in the text.", "startOffset": 9, "endOffset": 36}, {"referenceID": 70, "context": "It can also discern more finely the number of times the feature is highly activated (Kalchbrenner et al., 2014).", "startOffset": 84, "endOffset": 111}, {"referenceID": 72, "context": "The result of each convolutional layer will then be pooled, and the resulting vectors concatenated and fed to further processing (Kim, 2014).", "startOffset": 129, "endOffset": 140}, {"referenceID": 72, "context": "The result of each convolutional layer will then be pooled, and the resulting vectors concatenated and fed to further processing (Kim, 2014). The convolutional architecture need not be restricted into the linear ordering of a sentence. For example, Ma et al (2015) generalize the convolution operation to work over syntactic dependency trees.", "startOffset": 130, "endOffset": 265}, {"referenceID": 72, "context": "The result of each convolutional layer will then be pooled, and the resulting vectors concatenated and fed to further processing (Kim, 2014). The convolutional architecture need not be restricted into the linear ordering of a sentence. For example, Ma et al (2015) generalize the convolution operation to work over syntactic dependency trees. There, each window is around a node in the syntactic tree, and the pooling is performed over the different nodes. Similarly, Liu et al (2015) apply a convolutional architecture on top of dependency paths extracted from dependency trees.", "startOffset": 130, "endOffset": 485}, {"referenceID": 72, "context": "The result of each convolutional layer will then be pooled, and the resulting vectors concatenated and fed to further processing (Kim, 2014). The convolutional architecture need not be restricted into the linear ordering of a sentence. For example, Ma et al (2015) generalize the convolution operation to work over syntactic dependency trees. There, each window is around a node in the syntactic tree, and the pooling is performed over the different nodes. Similarly, Liu et al (2015) apply a convolutional architecture on top of dependency paths extracted from dependency trees. Le and Zuidema (2015) propose to perform max pooling over vectors representing the different derivations leading to the same chart item in a chart parser.", "startOffset": 130, "endOffset": 602}, {"referenceID": 37, "context": "Recurrent neural networks (RNNs) (Elman, 1990) allow representing arbitrarily sized structured inputs in a fixed-size vector, while paying attention to the structured properties of the input.", "startOffset": 33, "endOffset": 46}, {"referenceID": 141, "context": "This procedure is referred to in the RNN literature as backpropagation through time, or BPTT (Werbos, 1990).", "startOffset": 93, "endOffset": 107}, {"referenceID": 143, "context": "A CCG super-tagger based on such an architecture provides state-of-the art CCG super-tagging results (Xu et al., 2015).", "startOffset": 101, "endOffset": 118}, {"referenceID": 97, "context": "language models are shown to provide much better perplexities than traditional language models (Mikolov et al., 2010; Sundermeyer, Schl\u00fcter, & Ney, 2012; Mikolov, 2012).", "startOffset": 95, "endOffset": 168}, {"referenceID": 100, "context": "language models are shown to provide much better perplexities than traditional language models (Mikolov et al., 2010; Sundermeyer, Schl\u00fcter, & Ney, 2012; Mikolov, 2012).", "startOffset": 95, "endOffset": 168}, {"referenceID": 130, "context": "Encoder - Decoder Finally, an important special case of the encoder scenario is the Encoder-Decoder framework (Cho, van Merrienboer, Bahdanau, & Bengio, 2014a; Sutskever et al., 2014).", "startOffset": 110, "endOffset": 183}, {"referenceID": 130, "context": "Such an approach was shown to be surprisingly effective for Machine Translation (Sutskever et al., 2014) using LSTM RNNs.", "startOffset": 80, "endOffset": 104}, {"referenceID": 63, "context": "Irsoy and Cardie (2014) also report improved results from moving from a onelayer BI-RNN to an architecture with several layers.", "startOffset": 0, "endOffset": 24}, {"referenceID": 50, "context": "A useful elaboration of an RNN is a bidirectional-RNN (BI-RNN) (Schuster & Paliwal, 1997; Graves, 2008).", "startOffset": 63, "endOffset": 103}, {"referenceID": 50, "context": "A useful elaboration of an RNN is a bidirectional-RNN (BI-RNN) (Schuster & Paliwal, 1997; Graves, 2008).31 Consider the task of sequence tagging over a sentence x1, . . . , xn. An RNN allows us to compute a function of the ith word xi based on the past \u2013 the words x1:i up to and including it. However, the following words xi:n may also be useful for prediction, as is evident by the common sliding-window approach in which the focus word is categorized based on a window of k words surrounding it. Much like the RNN relaxes the Markov assumption and allows looking arbitrarily back into the past, the BI-RNN relaxes the fixed window size assumption, allowing to look arbitrarily far at both the past and the future. Consider an input sequence x1:n. The BI-RNN works by maintaining two separate states, si and s b i for each input position i. The forward state s f i is based on x1,x2, . . . ,xi, while the backward state si is based on xn,xn\u22121, . . . ,xi. The forward and backward states are generated by two different RNNs. The first RNN (Rf , Of ) is fed the input sequence x1:n as is, while the second RNN (R b, Ob) is fed the input sequence in reverse. The state representation si is then composed of both the forward and backward states. The output at position i is based on the concatenation of the two output vectors yi = [y f i ; y b i ] = [O f (si );O (si )], taking into account both the past and the future. The vector yi can then be used directly for prediction, or fed as part of the input to a more complex network. While the two RNNs are run independently of each other, the error gradients at position i will flow both forward and backward through the two RNNs. A visual representation of the BI-RNN architecture is given in Figure 11. The use of BI-RNNs for sequence tagging was introduced to the NLP community by Irsoy and Cardie (2014).", "startOffset": 90, "endOffset": 1856}, {"referenceID": 105, "context": "Some algorithms in language processing, including those for transition-based parsing (Nivre, 2008), require performing feature extraction over a stack.", "startOffset": 85, "endOffset": 98}, {"referenceID": 106, "context": "Dealing with pop operation is more challenging, but can be solved by using the persistent-stack data-structure (Okasaki, 1999; Goldberg, Zhao, & Huang, 2013).", "startOffset": 111, "endOffset": 157}, {"referenceID": 36, "context": "This modeling approach was proposed independently by Dyer et al and Watanabe et al (Dyer et al., 2015; Watanabe & Sumita, 2015) for transition-based dependency parsing.", "startOffset": 83, "endOffset": 127}, {"referenceID": 37, "context": "The simplest RNN formulation, known as an Elman Network or Simple-RNN (S-RNN), was proposed by Elman (1990) and explored for use in language modeling by Mikolov (2012).", "startOffset": 42, "endOffset": 108}, {"referenceID": 37, "context": "The simplest RNN formulation, known as an Elman Network or Simple-RNN (S-RNN), was proposed by Elman (1990) and explored for use in language modeling by Mikolov (2012). The S-RNN takes the following form:", "startOffset": 42, "endOffset": 168}, {"referenceID": 143, "context": "32 In spite of its simplicity, the Simple RNN provides strong results for sequence tagging (Xu et al., 2015) as well as language modeling.", "startOffset": 91, "endOffset": 108}, {"referenceID": 100, "context": "For comprehensive discussion on using Simple RNNs for language modeling, see the PhD thesis by Mikolov (2012).", "startOffset": 95, "endOffset": 110}, {"referenceID": 71, "context": "34 For an analysis of the behavior of an LSTM when used as a character-level language model, see (Karpathy et al., 2015).", "startOffset": 97, "endOffset": 120}, {"referenceID": 50, "context": "For further discussion on the LSTM architecture see the PhD thesis by Alex Graves (2008), as well as Chris Olah\u2019s description.", "startOffset": 75, "endOffset": 89}, {"referenceID": 113, "context": "Practical Considerations When training LSTM networks, Jozefowicz et al (2015) strongly recommend to always initialize the bias term of the forget gate to be close to one. When applying dropout to an RNN with an LSTM, Zaremba et al (2014) found out that it is", "startOffset": 80, "endOffset": 238}, {"referenceID": 69, "context": "For an empirical exploration of the GRU and the LSTM architectures, see (Jozefowicz et al., 2015).", "startOffset": 72, "endOffset": 97}, {"referenceID": 100, "context": "Mikolov et al (2014) observed that the matrix multiplication si\u22121W coupled with the nonlinearity g in the update rule R of the Simple RNN causes the state vector si to undergo large changes at each time step, prohibiting it from remembering information over long time periods.", "startOffset": 0, "endOffset": 21}, {"referenceID": 96, "context": "We depart from the notation in (Mikolov et al., 2014) and reuse the symbols used in the LSTM description.", "startOffset": 31, "endOffset": 53}, {"referenceID": 100, "context": "Mikolov et al demonstrate that this architecture provides competitive perplexities to the much more complex LSTM on language modeling tasks. The approach of Mikolov et al can be interpreted as constraining the block of the matrix Ws in the S-RNN corresponding to ci to be a multiply of the identity matrix (see Mikolov et al (2014) for the details).", "startOffset": 0, "endOffset": 332}, {"referenceID": 120, "context": "The trees can be syntactic trees, discourse trees, or even trees representing the sentiment expressed by various parts of a sentence (Socher et al., 2013).", "startOffset": 133, "endOffset": 154}, {"referenceID": 110, "context": "The recursive neural network (RecNN) abstraction (Pollack, 1990), popularized in NLP by Richard Socher and colleagues (Socher, Manning, & Ng, 2010; Socher, Lin, Ng, & Manning, 2011; Socher et al.", "startOffset": 49, "endOffset": 64}, {"referenceID": 120, "context": "The recursive neural network (RecNN) abstraction (Pollack, 1990), popularized in NLP by Richard Socher and colleagues (Socher, Manning, & Ng, 2010; Socher, Lin, Ng, & Manning, 2011; Socher et al., 2013; Socher, 2014) is a generalization of the RNN from sequences to (binary) trees.", "startOffset": 118, "endOffset": 216}, {"referenceID": 119, "context": "The recursive neural network (RecNN) abstraction (Pollack, 1990), popularized in NLP by Richard Socher and colleagues (Socher, Manning, & Ng, 2010; Socher, Lin, Ng, & Manning, 2011; Socher et al., 2013; Socher, 2014) is a generalization of the RNN from sequences to (binary) trees.", "startOffset": 118, "endOffset": 216}, {"referenceID": 120, "context": "An alternative approach, due to (Socher et al., 2013) is to untie the weights according to the non-terminals, using a different composition matrix for each B,C pair of symbols:39", "startOffset": 32, "endOffset": 53}, {"referenceID": 76, "context": "Le and Zuidema (2014) extend the RecNN definition such that each node has, in addition to its inside state vector, also an outside state vector representing the entire structure around the subtree rooted at that node.", "startOffset": 0, "endOffset": 22}, {"referenceID": 54, "context": "A similar model was also used by (Hashimoto et al., 2013) to encode subtrees in semantic-relation classification task.", "startOffset": 33, "endOffset": 57}, {"referenceID": 120, "context": "Other proposed variants on tree-structured RNNs includes a recursive matrix-vector model (Socher, Huval, Manning, & Ng, 2012) and recursive neural tensor network (Socher et al., 2013).", "startOffset": 162, "endOffset": 183}, {"referenceID": 119, "context": "For further discussion on recursive neural networks and their use in natural language tasks, refer to the PhD thesis of Richard Socher (2014).", "startOffset": 128, "endOffset": 142}], "year": 2015, "abstractText": "Over the past few years, neural networks have re-emerged as powerful machine-learning models, yielding state-of-the-art results in fields such as image recognition and speech processing. More recently, neural network models started to be applied also to textual natural language signals, again with very promising results. This tutorial surveys neural network models from the perspective of natural language processing research, in an attempt to bring natural-language researchers up to speed with the neural techniques. The tutorial covers input encoding for natural language tasks, feed-forward networks, convolutional networks, recurrent networks and recursive networks, as well as the computation graph abstraction for automatic gradient computation.", "creator": "TeX"}}}