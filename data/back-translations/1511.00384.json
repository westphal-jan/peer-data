{"id": "1511.00384", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "2-Nov-2015", "title": "Z Specification for the W3C Editor's Draft Core SHACL Semantics", "abstract": "This article provides a formalization of the W3C Draft Core SHACL semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the design and found that the recursive definitions in the design are well founded. Further formal validation of the design requires the use of executable specification technology.", "histories": [["v1", "Mon, 2 Nov 2015 05:31:42 GMT  (35kb)", "http://arxiv.org/abs/1511.00384v1", "57 pages, Invited Expert contribution to the W3C RDF Data Shapes Working Group"]], "COMMENTS": "57 pages, Invited Expert contribution to the W3C RDF Data Shapes Working Group", "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["arthur ryman"], "accepted": false, "id": "1511.00384"}, "pdf": {"name": "1511.00384.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["arthur.ryman@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n51 1.\n00 38\n4v 1\n[ cs\n.D B\n] 2\nThis article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology."}, {"heading": "1 Introduction", "text": "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF graphs. A semantics for Core SHACL has been proposed [2], hereafter referred to as the semantics draft. The proposed semantics includes an abstract syntax, inference rules, and a definition of typing which allows for certain kinds of recursion. The semantics draft uses precise mathematical language, but is informal in the sense that it is not written in a formal specification language and therefore cannot benefit from tools such as type-checkers.\nThis document provides a formal translation of the semantics draft into Z Notation [6]. The LATEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.\nOur motive for formalizing and type-checking the semantics draft is to help to improve its quality and the ultimate design of SHACL."}, {"heading": "1.1 Organization of this Article", "text": "The remainder of this article is organized as follows.\n\u2022 Section 2 formalizes some basic RDF concepts.\n\u2022 Section 3 translates the abstract syntax of SHACL into Z notation.\n\u2022 Section 4 formalizes the evaluation semantics of SHACL.\n\u2022 Section 5 formalizes the declarative semantics of shape expression schemas.\n\u2022 Section 6 summarizes the quality issues found in the draft.\n\u2022 Section 7 concludes with some remarks about the benefits of the formalization exercise and possible next steps."}, {"heading": "2 Basic RDF Concepts", "text": "This section formalizes some basic RDF concepts. We reuse some formal definitions given in [5], modifying the identifiers to match those used in the semantics draft.\n2.1 TERM\nLet TERM be the set of all RDF terms.\n[TERM ]\n2.2 Iri , Blank , and Lit\nThe set of all RDF terms is partitioned into IRIs, blank nodes, and literals.\nIri ,Blank ,Lit : TERM\n\u3008Iri ,Blank ,Lit\u3009 partition TERM\n2.3 IRI\nThe semantics draft introduces the term Iri , but it uses the term IRI in the definitions of the abstract syntax. We treat IRI as a synonym for Iri .\nIRI == Iri\n2.4 Triple\nAn RDF triple is an ordered triple of RDF terms referred to as the subject, predicate, and object.\nTriple == { s , p, o : TERM | s /\u2208 Lit \u2227 p \u2208 IRI }\n\u2022 The subject is not a literal.\n\u2022 The predicate is an IRI.\n2.5 subject, predicate, and object\nIt is convenient to define generic functions that select the first, second, or third component of a Cartesian product of three sets.\nfst [X ,Y ,Z ] == (\u03bb x : X ; y : Y ; z : Z \u2022 x )\nsnd [X ,Y ,Z ] == (\u03bb x : X ; y : Y ; z : Z \u2022 y )\ntrd [X ,Y ,Z ] == (\u03bb x : X ; y : Y ; z : Z \u2022 z )\nThe subject, predicate, and object of an RDF triple are the terms that appear in the corresponding positions.\nsubject == (\u03bb t : Triple \u2022 fst(t) )\npredicate == (\u03bb t : Triple \u2022 snd(t) )\nobject == (\u03bb t : Triple \u2022 trd(t) )\n2.6 Graph\nAn RDF graph is a finite set of RDF triples.\nGraph == Triple\n2.7 subjects, predicates, and objects\nThe subjects, predicates, and objects of a graph are the sets of RDF terms that appear in the corresponding positions of its triples.\nsubjects == (\u03bb g : Graph \u2022 { t : g \u2022 subject(t) } )\npredicates == (\u03bb g : Graph \u2022 { t : g \u2022 predicate(t) } )\nobjects == (\u03bb g : Graph \u2022 { t : g \u2022 object(t) } )\n2.8 nodes\nThe nodes of an RDF are its subjects and objects.\nnodes == (\u03bb g : Graph \u2022 subjects(g) \u222a objects(g) )\n2.9 PointedGraph\nA pointed graph is a graph and a distinguished node in the graph. The distinguished node is variously referred to as the start, base, or focus node of the pointed graph, depending on the context.\nPointedGraph == { g : Graph; n : TERM | n \u2208 nodes(g) }"}, {"heading": "3 Abstract Syntax", "text": "This section contains a translation of the abstract syntax of SHACL into Z. The semantics draft defines the abstract syntax using an informal Extended Backus-Naur Form (EBNF).\nThe approach used here is to interpret each term or expression that appears in the abstract syntax as a mathematical set that is isomorphic to the set of abstract syntax tree fragments denoted by the corresponding term or expression. Care has been taken to preserve the exact spelling and case of each abstract syntax term so that there is a direct correspondence between the abstract syntax and Z. For example, the term Schema is interpreted as the set Schema.\nWe give a Z definition for each abstract syntax term that appears on the left-hand side of the EBNF definition operator (::=). The order in which these terms appear in the semantics draft has been preserved in this document. If a Z term has a corresponding EBNF rule, we include it here for easy reference. Refer to [2] for the complete definition of the abstract syntax.\nA sequence of two or more abstract syntax terms is interpreted as the Cartesian product of the corresponding sets, i.e. A B is interpreted as A\u00d7 B .\nThe abstract syntax Kleene star (*) and plus (+) operators are interpreted as sequence (seq) and non-empty sequence (seq1) operators on the corresponding sets, i.e. A+ is interpreted as seq1 A.\nThe abstract syntax optional operator (?) is interpreted as taking the union of the set of singletons and the empty set of the corresponding set using the generic function OPTIONAL (defined below), i.e. A? is interpreted as OPTIONAL[A].\nAbstract syntax terms that are defined as alternations (|) of two or more expressions are translated into either free types or unions of sets. A side effect of this process is that constructors may be required for each branch of the alternation. In some cases the name of the constructors can be derived from a corresponding element of the abstract syntax. For example, in ShapeDefinition, open and close are mapped to the constructors open and close. In the cases where there is no convenient element of the abstract syntax, we mint new constructor names.\nWe also introduce new Z identifiers when an element of the abstract syntax does not map to a valid alphanumeric Z identifier. For example the the shape label negation operator (!) is mapped to negate.\n3.1 OPTIONAL\nAn optional value is represented by a singleton set, if the value is present, or the empty set, if the value is absent.\nOPTIONAL[X ] == { v : X \u2022 {v} } \u222a { }\n3.2 Schema\nSchema ::= Rule+\nA schema is a sequence of one or more rules.\nSchema == seq1 Rule\n3.3 Rule"}, {"heading": "Rule ::= ShapeLabel ShapeDefinition ExtensionCondition*", "text": "A rule consists of a shape label, a shape definition, and a sequence of zero or more extension conditions.\nRule == ShapeLabel \u00d7 ShapeDefinition \u00d7 seqExtensionCondition\nIt is convenient to introduce functions that select the components of a rule.\nshapeLabel == (\u03bb r : Rule \u2022 fst(r) ) shapeDef == (\u03bb r : Rule \u2022 snd(r) ) extConds == (\u03bb r : Rule \u2022 trd(r) )\n3.4 ShapeLabel"}, {"heading": "ShapeLabel ::= an identifier", "text": "A shape label is an identifier drawn from some given set.\n[ShapeLabel ]\n3.5 ShapeDefinition"}, {"heading": "ShapeDefinition ::= ClosedShape | OpenShape", "text": "A shape definition is either a closed shape or an open shape.\nShapeDefinition ::= close ShapeExpr | open OPTIONAL[InclPropSet ]\u00d7 ShapeExpr\nNote that abstract syntax terms that are defined using alternation are naturally represented as free types in Z Notation.\n\u2022 close is the constructor for closed shapes.A closed shape consists of a shape expression.\n\u2022 open is the constructor for open shapes. An open shape consists of an optional included properties set and a shape expression. Given a shape definition d , let shapeExpr(d) be its shape expression.\nshapeExpr : ShapeDefinition\" ShapeExpr\n\u2200 x : ShapeExpr \u2022 shapeExpr(close(x )) = x\n\u2200 o : OPTIONAL[InclPropSet ]; x : ShapeExpr \u2022 shapeExpr(open(o, x )) = x\n3.6 ClosedShape"}, {"heading": "ClosedShape ::= \u2019close\u2019 ShapeExpr", "text": "The set of closed shapes is the range of the close shape definition constructor.\nClosedShape == ran close\n3.7 OpenShape"}, {"heading": "OpenShape ::= \u2019open\u2019 InclPropSet? ShapeExpr", "text": "The set of open shapes is the range of the open shape definition constructor.\nOpenShape == ran open\n3.8 InclPropSet"}, {"heading": "InclPropSet ::= PropertiesSet", "text": "An included properties set is a properties set.\nInclPropSet == PropertiesSet\nNote that there seems little motivation to introduce the term InclPropSet since it is identical to PropertiesSet .\n3.9 PropertiesSet"}, {"heading": "PropertiesSet ::= set of IRI", "text": "A properties set is a set of IRIs.\nPropertiesSet == IRI\n3.10 ShapeExpr\nShapeExpr ::= EmptyShape | TripleConstraint Cardinality | InverseTripleConstraint Cardinality | NegatedTripleConstraint | NegatedInverseTripleConstraint | SomeOfShape | OneOfShape | GroupShape | RepetitionShape\nA shape expression defines constraints on RDF graphs.\nShapeExpr ::= emptyshape | triple DirectedTripleConstraint \u00d7 Cardinality | someOf seq1 ShapeExpr | oneOf seq1 ShapeExpr | group seq1 ShapeExpr | repetition ShapeExpr \u00d7 Cardinality\n\u2022 emptyshape is the empty shape expression.\n\u2022 triple is the constructor for triple constraint shape expressions. A triple constraint shape expression consists of a directed triple constraint and a cardinality.\n\u2022 someOf is the constructor for some-of shape expressions. A some-of shape expression consists of a sequence of one or more shape expressions.\n\u2022 oneOf is the constructor for one-of shape expressions. A one-of shape expression consists of a sequence of one or more shape expressions.\n\u2022 group is the constructor for grouping shape expressions. A grouping shape expression consists of a sequence of one or more shape expressions.\n\u2022 repetition is the constructor for repetition shape expressions. A repetition shape expression consists of a shape expression and a cardinality.\n3.11 EmptyShape"}, {"heading": "EmptyShape ::= \u2019emptyshape\u2019", "text": "The set of empty shape expressions is the singleton set that contains the empty shape.\nEmptyShape == {emptyshape}\n3.12 DirectedPredicate\nA directed predicate is an IRI with a direction that indicates its usage in a triple. nop indicates the normal direction, namely the predicate relates the subject node to the object node. inv indicates the inverse direction, namely the predicate relates the object node to the subject node.\nDirectedPredicate ::= nop IRI | inv IRI\nThe semantics draft uses the notation ^p for inv(p).\nLet predDF (dp) denote the predicate of a directed predicate dp.\npredDP : DirectedPredicate\" IRI\n\u2200 p : IRI \u2022 predDP(nop(p)) = predDP(inv(p)) = p\n3.13 DirectedTripleConstraint\nA directed triple constraint consists of a directed predicate and a constraint. The constraint is a value or shape constraint on the object of a triple if the direction is normal, or a shape constraint on the subject of a triple if the direction is inverted.\nDirectedTripleConstraint == { dp : DirectedPredicate; C : Constraint |\ndp \u2208 ran inv \u21d2 C \u2208 ShapeConstr }\nThe semantics draft uses the notation p::C for (nop(p),C ) and ^p::C for (inv(p),C ).\nLet predDTC (dtc) denote the predicate of the directed triple constraint dtc.\npredDTC : DirectedTripleConstraint \" IRI\n\u2200 dp : DirectedPredicate; C : Constraint | (dp,C ) \u2208 DirectedTripleConstraint \u2022\npredDTC (dp,C ) = predDP(dp)\nLet constrDTC (dtc) denote the constraint of the directed triple constraint dtc.\nconstrDTC : DirectedTripleConstraint \" Constraint\n\u2200 dp : DirectedPredicate; C : Constraint | (dp,C ) \u2208 DirectedTripleConstraint \u2022\nconstrDTC (dp,C ) = C\n3.14 TripleConstraint"}, {"heading": "TripleConstraint ::= IRI ValueConstr | IRI ShapeConstr", "text": "A triple constraint places conditions on triples whose subject is a given focus node and whose predicate is a given IRI.\nTripleConstraint : DirectedTripleConstraint\nTripleConstraint = { p : IRI ; C : Constraint \u2022 (nop(p),C ) }\n3.15 InverseTripleConstraint"}, {"heading": "InverseTripleConstraint ::= \u2019^\u2019 IRI ShapeConstr", "text": "An inverse triple constraint places conditions on triples whose object is a given focus node and whose predicate is a given IRI.\nInverseTripleConstraint : DirectedTripleConstraint\nInverseTripleConstraint = { p : IRI ; C : ShapeConstr \u2022 (inv(p),C ) }\n3.16 Constraint\nA constraint is a condition on the object node of a triple for normal predicates or the subject node of a triple for inverse predicates.\nConstraint ::= valueSet (Lit \u222a IRI ) | datatype LiteralDatatype \u00d7OPTIONAL[XSFacet ] | kind NodeKind | or seq1 ShapeLabel | and seq1 ShapeLabel | nor seq1 ShapeLabel | nand seq1 ShapeLabel\n\u2022 valueSet is the constructor for value set value constraints. A value set value constraint consists of a set of literals and IRIs.\n\u2022 datatype is the constructor for literal datatype value constraints. A literal datatype value constraint consists of a literal datatype and an optional XML Schema facet.\n\u2022 kind is the constructor for node kind value constraints. A node kind value constraint consists of a specification for a subset of RDF terms.\n\u2022 or is the constructor for disjunction shape constraints. A node must satisfy at least one of the shapes.\n\u2022 and is the constructor for conjunction shape constraints. A node must satisfy all of the shapes.\n\u2022 nor is the constructor for negated disjunction shape constraints. A node must not satisfy any of the shapes.\n\u2022 nand is the constructor for negated conjunction shape constraints. A node must not satisfy all of the shapes.\n3.17 Cardinality"}, {"heading": "Cardinality ::= \u2019[\u2019 MinCardinality \u2019;\u2019 MaxCardinality \u2019]\u2019", "text": "Cardinality defines a range for the number of elements in a set.\nCardinality == MinCardinality \u00d7MaxCardinality\n\u2022 A cardinality consists of a minimum cardinality and a maximum cardinality.\n3.18 MinCardinality"}, {"heading": "MinCardinality ::= a natural number", "text": "Minimum cardinality is the minimum number of elements required to be in a set.\nMinCardinality ==\n3.19 MaxCardinality"}, {"heading": "MaxCardinality ::= a natural number | \u2019unbound\u2019", "text": "Maximum cardinality is the maximum number of elements required to be in a set.\nMaxCardinality ::= maxCard | unbound\n\u2022 maxCard is the constructor for finite maximum cardinalities. A finite maximum cardinality is a natural number. Note that a maximum cardinality of 0 means that the set must be empty.\n\u2022 unbound indicates that the maximum number of elements in a set is unbounded.\n3.20 inBounds\nA natural number k is said to be in bounds of a cardinality when k is between the minimum and maximum limits of the cardinality.\ninBounds : # Cardinality\n\u2200 k , n : \u2022 k inBounds (n, unbound) \u21d4 n \u2264 k\n\u2200 k , n,m : \u2022 k inBounds (n,maxCard(m)) \u21d4 n \u2264 k \u2264 m"}, {"heading": "3.21 Notation", "text": "Let a be an IRI, let C be a value or shape constraint, let n and m be nonnegative integers. The semantics draft uses the notation listed in Table 1 for some shape expressions.\n\u2022 If the cardinality is [1;1] it may be omitted.\n\u2022 The negated shape expressions are semantically equivalent to the corresponding non-negated shape expressions with cardinality [0;0].\n3.22 none, one\nIt is convenient to define some common cardinalities.\nnone == (0,maxCard(0))\none == (1,maxCard(1))\n\u2022 A cardinality of none = [0;0] is used to indicate a negated triple or inverse triple constraint.\n\u2022 A cardinality of one = [1;1] is the default cardinality of a triple or inverse triple constraint when no cardinality is explicitly given in the notations a::C and ^a::C.\n3.23 NegatedTripleConstraint"}, {"heading": "NegatedTripleConstraint ::= \u2019!\u2019 TripleConstraint", "text": "A negated triple constraint shape expression is a triple constraint shape expression that has a cardinality of none.\nNegatedTripleConstraint == { tc : TripleConstraint \u2022 triple(tc, none) }\n3.24 NegatedInverseTripleConstraint"}, {"heading": "NegatedInverseTripleConstraint ::= \u2019!\u2019 InverseTripleConstraint", "text": "A negated inverse triple constraint shape expression is an inverse triple constraint shape expression that has a cardinality of none.\nNegatedInverseTripleConstraint == { itc : InverseTripleConstraint \u2022 triple(itc, none) }\n3.25 ValueConstr"}, {"heading": "ValueConstr ::= ValueSet | LiteralDatatype XSFacet? | NodeKind", "text": "A value constraint places conditions on the object nodes of triples for normal predicates and on the subject nodes of triples for inverse predicates.\nValueConstr == ran valueSet \u222a ran datatype \u222a ran kind\n3.26 ValueSet"}, {"heading": "ValueSet ::= set of literals and IRI", "text": "The set of value set value constraints is the range of the valueSet constructor.\nValueSet == ran valueSet\n3.27 LiteralDatatype"}, {"heading": "LiteralDatatype ::= an RDF literal datatype", "text": "A literal datatype is an IRI that identifies a set of literal RDF terms. We assume that this subset of IRIs is given.\nLiteralDatatype : IRI\nWe also assume that we are given an interpretation of each literal datatype as a set of literals.\nliteralsOfDatatype : LiteralDatatype\" Lit\n3.28 NodeKind"}, {"heading": "NodeKind ::= \u2019iri\u2019 | \u2019blank\u2019 | \u2019literal\u2019 | \u2019nonliteral\u2019", "text": "A node kind identifies a subset of RDF terms.\nNodeKind ::= iri | blank | literal | nonliteral\n\u2022 iri identifies the set of IRIs.\n\u2022 blank identifies the set of blank nodes.\n\u2022 literal identifies the set of literals.\n\u2022 nonliteral identifies the complement of the set of literals, i.e. the union of IRIs and blank nodes.\nEach node kind corresponds to a set of RDF terms.\ntermsOfKind : NodeKind\" TERM\ntermsOfKind(iri) = IRI\ntermsOfKind(blank) = Blank\ntermsOfKind(literal) = Lit\ntermsOfKind(nonliteral) = TERM \\ Lit\n3.29 XSFacet"}, {"heading": "XSFacet ::= an XSD restriction", "text": "An XML Schema facet places restrictions on literals. We assume this is a given set.\n[XSFacet ]\nWe also assume that we are given an interpretation of facets as sets of literals.\nliteralsOfFacet : LiteralDatatype \u00d7XSFacet\" Lit\n\u2200 d : LiteralDatatype; f : XSFacet \u2022 literalsOfFacet(d , f ) \u2286 literalsOfDatatype(d)\n\u2022 The literals that correspond to a facet of a datatype are a subset of the literals that correspond to the datatype.\n3.30 ShapeConstr"}, {"heading": "ShapeConstr ::= (\u2019!\u2019)? DisjShapeConstr | ConjShapeConstraint", "text": "A shape constraint requires that a node satisfy logical combinations of one or more other shapes which are identified by their shape labels.\nShapeConstr == ran or \u222a ran and \u222a rannor \u222a rannand\n3.31 DisjShapeConstr"}, {"heading": "DisjShapeConstr ::= ShapeLabel (\u2019or\u2019 ShapeLabel)*", "text": "The set of all disjunctive shape constraints is the range of the or constructor.\nDisjShapeConstr == ran or\n3.32 ConjShapeConstraint"}, {"heading": "ConjShapeConstraint ::= ShapeLabel (\u2019and\u2019 ShapeLabel)*", "text": "The set of all conjunctive shape constraints is the range of the and constructor.\nConjShapeConstraint == ran and\n3.33 SomeOfShape"}, {"heading": "SomeOfShape ::= ShapeExpr (\u2019|\u2019 ShapeExpr)*", "text": "The set of some-of shape expressions is the range of someOf .\nSomeOfShape == ran someOf\n3.34 OneOfShape"}, {"heading": "OneOfShape ::= ShapeExpr (\u2019@\u2019 ShapeExpr)*", "text": "The set of one-of shape expressions is the range of oneOf .\nOneOfShape == ran oneOf\n3.35 GroupShape"}, {"heading": "GroupShape ::= ShapeExpr (\u2019,\u2019 ShapeExpr)*", "text": "The set of grouping shape expressions is the range of group.\nGroupShape == ran group\n3.36 RepetitionShape"}, {"heading": "RepetitionShape ::= ShapeExpr Cardinality", "text": "The set of repetition shape expressions is the range of repetition.\nRepetitionShape == ran repetition\n3.37 ExtensionCondition"}, {"heading": "ExtensionCondition ::= ExtLangName ExtDefinition", "text": "An extension condition is the definition of a constraint written in an extension language\nExtensionCondition == ExtLangName \u00d7 ExtDefinition\n3.38 ExtLangName"}, {"heading": "ExtLangName ::= an identifier", "text": "An extension language name is an identifier for an extension language, such as JavaScript. We assume this is a given set.\n[ExtLangName]\n3.39 ExtDefinition"}, {"heading": "ExtDefinition ::= a string", "text": "An extension definition is a program written in some extension language that implements a constraint check. We assume this is a given set.\n[ExtDefinition]\nAn extension condition represents a function that takes as input a pointed graph, and returns as output a boolean with the value true if the constraint is violated and false is satisfied. We assume we are given a mapping that associates each extension condition with the set of pointed graphs that violate it.\nviolatedBy : ExtensionCondition\" PointedGraph\n3.40 ShapeLabel Definitions\nGiven a schema S , let defs(S ) be the set of all shape labels defined in S .\ndefs == (\u03bb S : Schema \u2022 { r : ranS \u2022 shapeLabel(r) } )\nEach rule in a schema must be identified by a unique shape label.\nSchemaUL == { S : Schema | #S = #(defs(S )) }\n\u2022 In a schema with unique rule labels there are as many rules as labels.\n3.41 rule\nGiven a schema S with unique rule labels, and a label T defined in S , let rule(T , S ) be the corresponding rule.\nrule : ShapeLabel \u00d7 SchemaUL Rule\ndom rule = {T : ShapeLabel ; S : SchemaUL | T \u2208 defs(S ) }\n\u2200S : SchemaUL \u2022 \u2200 r : ran(S ) \u2022\nlet T == shapeLabel(r) \u2022 rule(T , S ) = r\n3.42 ShapeLabel References\nGiven a schema S , let refs(S ) be the set of shape labels referenced in S .\nrefs == (\u03bbS : Schema \u2022 \u22c3 { r : ranS \u2022 refsRule(r) } )\n\u2022 The set of references in a schema is the union of the sets of references in its rules.\nGiven a rule r , let refsRule(r) be the set of shape labels referenced in r .\nrefsRule == (\u03bb r : Rule \u2022 refsShapeDefinition(shapeDef (r)) )\n\u2022 The set of references in a rule is the set of references in its shape definition.\nGiven a shape definition d , let refsShapeDefinition(d) be the set of shape labels referenced in d .\nrefsShapeDefinition : ShapeDefinition\" ShapeLabel\n\u2200 d : ShapeDefinition \u2022 refsShapeDefinition(d) = refsShapeExpr(shapeExpr(d))\n\u2022 The set of references in a shape definition is the set of references in its shape expression.\nGiven a shape expression x , let refsShapeExpr(x ) be the set of shape labels referenced in x .\nrefsShapeExpr : ShapeExpr \" ShapeLabel\nrefsShapeExpr(emptyshape) =\n\u2200 dtc : DirectedTripleConstraint ; c : Cardinality \u2022 refsShapeExpr(triple(dtc, c)) =\nrefsDirectedTripleConstraint(dtc)\n\u2200 xs : seq1 ShapeExpr \u2022 refsShapeExpr(someOf (xs)) = refsShapeExpr(oneOf (xs)) = refsShapeExpr(group(xs)) =\u22c3\n{ x : ran xs \u2022 refsShapeExpr(x ) }\n\u2200 x : ShapeExpr ; c : Cardinality \u2022 refsShapeExpr(repetition(x , c)) =\nrefsShapeExpr(x )\n\u2022 The empty shape expression references no labels.\n\u2022 A directed triple constraint shape expression references the labels referenced in the directed triple constraint.\n\u2022 A some-of or one-of or group shape expression references the union of the labels referenced in each component shape expression.\n\u2022 A repetition shape expression references the labels referenced in its unrepeated shape expression.\nGiven a directed triple constraint dtc, let refsDirectedTripleConstraint(dtc) be the set of shape labels referenced in dtc.\nrefsDirectedTripleConstraint : DirectedTripleConstraint\" ShapeLabel\n\u2200 a : IRI ; C : ValueConstr \u2022 refsDirectedTripleConstraint((nop(a),C )) =\n\u2200 a : IRI ; C : ShapeConstr \u2022 refsDirectedTripleConstraint((nop(a),C )) = refsDirectedTripleConstraint((inv(a),C )) =\nrefsShapeConstr(C )\n\u2022 A value triple constraint references no labels.\n\u2022 A shape triple constraint references the labels in its shape constraint.\nGiven a shape constraint C , let refsShapeConstr(C ) be the set of shape labels referenced in C .\nrefsShapeConstr : ShapeConstr\" ShapeLabel\n\u2200 ls : seq1 ShapeLabel \u2022 refsShapeConstr(or(ls)) = refsShapeConstr(and(ls)) = refsShapeConstr(nor(ls)) = refsShapeConstr(nand(ls)) =\nran ls\n\u2022 A shape constraint references the range of its sequence of shape labels. Every shape label referenced in a schema must be defined in the schema.\nSchemaRD == { s : Schema | refs(s) \u2286 defs(s) }\nA schema is well-formed if its rules have unique labels and all referenced shape labels are defined.\nSchemaWF == SchemaUL \u2229 SchemaRD"}, {"heading": "4 Evaluation", "text": "This section defines the interpretation of shapes as constraints on RDF graphs. All functions that are defined in the semantics draft are given formal definitions here. We assume that from this point on whenever the semantics draft refers to schemas they are well-formed.\n4.1 shapes\nGiven a well-formed schema S , let shapes(S ) be the set of shape labels that appear in S .\nshapes == (\u03bbS : SchemaWF \u2022 defs(S ) )\n4.2 expr\nGiven a shape label T and a well-formed schema S , let expr(T , S ) be the shape expression in the rule with label T in S .\nexpr : ShapeLabel \u00d7 SchemaWF ShapeExpr\ndom expr = {T : ShapeLabel ; S : SchemaWF | T \u2208 shapes(S ) }\n\u2200T : ShapeLabel ; S : SchemaWF | T \u2208 shapes(S ) \u2022 let r == rule(T , S ) \u2022\nexpr(T , S ) = shapeExpr(shapeDef (r))\n\u2022 The shape expression for a shape label T is the shape expression in the shape definition of the rule r that has shape label T .\n4.3 incl\nGiven a shape label T defined in a well-formed schema S , let incl(T , S ) be the, possibly empty, set of included properties.\nincl : ShapeLabel \u00d7 SchemaWF InclPropSet\ndom incl = {T : ShapeLabel ; S : SchemaWF | T \u2208 shapes(S ) }\n\u2200T : ShapeLabel ; S : SchemaWF | T \u2208 shapes(S ) \u2022 \u2203 1 r : ranS | T = shapeLabel(r) \u2022 incl(T , S ) = inclShapeDefinition(shapeDef (r))\n\u2022 The included properties set for a shape label T is the included properties set in the shape definition of the rule r that has shape label T .\nGiven a shape definition d , let inclShapeDefinition(d) be its included properties set.\ninclShapeDefinition : ShapeDefinition\" InclPropSet\n\u2200 x : ShapeExpr \u2022 inclShapeDefinition(close(x )) = inclShapeDefinition(open({ }, x ))\n=\n\u2200 ips : InclPropSet ; x : ShapeExpr \u2022 inclShapeDefinition(open({ips}, x )) = ips\n\u2022 The included property set of a closed shape definition or an open definition with no included property set is the empty set.\n\u2022 The included property set of an open shape definition with an included property set is that included property set.\n4.4 properties\nGiven a shape expression x , let properties(x ) be the set of properties that appear in some triple constraint in x .\nproperties : ShapeExpr\" PropertiesSet\nproperties(emptyshape) =\n\u2200 tc : TripleConstraint ; c : Cardinality \u2022 properties(triple(tc, c)) =\npropertiesTripleConstraint(tc)\n\u2200 itc : InverseTripleConstraint ; c : Cardinality \u2022 properties(triple(itc, c)) =\n\u2200 xs : seq1 ShapeExpr \u2022 properties(someOf (xs)) = properties(oneOf (xs)) = properties(group(xs)) =\u22c3\n{ x : ran xs \u2022 properties(x ) }\n\u2200 x : ShapeExpr ; c : Cardinality \u2022 properties(repetition(x , c)) = properties(x )\n\u2022 An empty shape expression has no properties.\n\u2022 The properties of a triple constraint shape expression are the properties of its triple constraint.\n\u2022 Inverse triple constraint shape expressions have no properties.\n\u2022 The properties of a some-of, one-of, or grouping shape expression are the union of the properties of their component shape expressions.\n\u2022 The properties of a repetition shape expression are the properties of the shape expression being repeated.\nGiven a triple constraint tc, let propertiesTripleConstraint(tc) be its set of properties.\npropertiesTripleConstraint : TripleConstraint \" PropertiesSet\n\u2200 a : IRI ; C : Constraint \u2022 propertiesTripleConstraint((nop(a),C )) = {a}\n\u2022 The properties of a triple constraint is the singleton set that contains its IRI.\n4.5 invproperties\nGiven a shape expression x , let invproperties(x ) be the set of properties that appear in some inverse triple constraint in x .\ninvproperties : ShapeExpr \" PropertiesSet\ninvproperties(emptyshape) =\n\u2200 tc : TripleConstraint ; c : Cardinality \u2022 invproperties(triple(tc, c)) =\n\u2200 itc : InverseTripleConstraint ; c : Cardinality \u2022 invproperties(triple(itc, c)) =\ninvpropertiesInverseTripleConstraint(itc)\n\u2200 xs : seq1 ShapeExpr \u2022 invproperties(someOf (xs)) = invproperties(oneOf (xs)) = invproperties(group(xs)) =\u22c3\n{ x : ran xs \u2022 invproperties(x ) }\n\u2200 x : ShapeExpr ; c : Cardinality \u2022 invproperties(repetition(x , c)) = invproperties(x )\n\u2022 An empty shape expression has no inverse properties.\n\u2022 A triple constraint shape expression has no inverse properties.\n\u2022 The inverse properties of an inverse triple constraint shape expression are the inverse properties in its inverse triple constraint.\n\u2022 The inverse properties of a some-of, one-of, or grouping shape expression is the union of the inverse properties of their component shape expressions.\n\u2022 The inverse properties of a repetition shape expression are the inverse properties of the shape expression being repeated.\nGiven an inverse triple constraint itc, let invpropertiesInverseTripleConstraint(tc) be its set of inverse properties.\ninvpropertiesInverseTripleConstraint : InverseTripleConstraint \" PropertiesSet\n\u2200 a : IRI ; C : ShapeConstr \u2022 invpropertiesInverseTripleConstraint((inv(a),C )) = {a}\n\u2022 The inverse properties of an inverse triple constraint is the singleton set that contains its IRI.\n4.6 dep graph\n4.6.1 DiGraph\nA directed graph consists of a set of nodes and a set of directed edges that connect the nodes.\nDiGraph[X ] nodes : X edges : X #X\nedges \u2208 nodes# nodes\n\u2022 Each edge connects a pair of nodes in the graph.\n4.6.2 DepGraph\nGiven a well-formed schema S , let the shapes dependency graph be the directed graph whose nodes are the shape labels in S and whose edges connect label T1 to label T2 when the shape expression that defines T1 refers to T2.\nDepGraph S : SchemaWF DiGraph[ShapeLabel ]\nnodes = shapes(S )\nedges = {T1,T2 : nodes | T2 \u2208 refsShapeExpr(expr(T1, S )) }\n\u2022 The nodes are the shapes of the schema.\n\u2022 There is an edge from T1 to T2 when the definition of T1 refers to T2.\n4.6.3 dep graph\nLet dep graph(S ) be the dependency graph of S .\ndep graph : SchemaWF \"DiGraph[ShapeLabel ]\ndep graph = {DepGraph \u2022 S 7\u2192 \u03b8DiGraph }\n4.7 dep subgraph\n4.7.1 reachable\nGiven a directed graph g and a node T in g, a node U is reachable from T if there is a directed path of one or more edges that connects T to U .\n[X ] reachable : DiGraph[X ] \u00d7X \" X\n\u2200 g : DiGraph[X ]; T : X \u2022 let edges == g.edges \u2022\nreachable(g,T ) = {U : X | T 7\u2192 U \u2208 edges+ }\n4.7.2 DepSubgraph\nGiven a well-formed schema S and a shape label T in S , the shapes dependency graph is the subgraph induced by the nodes that are reachable from T .\nDepSubgraph S : SchemaWF T : ShapeLabel DiGraph[ShapeLabel ]\nT \u2208 shapes(S )\nlet g == dep graph(S ) \u2022 nodes = reachable(g,T ) \u2227 edges = g.edges \u2229 (nodes \u00d7 nodes)\n\u2022 The nodes of the subgraph consist of all the nodes reachable from T .\n\u2022 The edges of the subgraph consist of all edges of the graph whose nodes are in the subgraph.\nNote that the above formal definition of the dependency subgraph is a literal translation of the text in the semantics draft. In particular, this literal translation does not explicitly include the label T as a node. Therefore T will not be in the subgraph unless it is in a directed cycle of edges.\n4.7.3 dep subgraph\nLet dep subgraph(T , S ) be the dependency subgraph of T in S .\ndep subgraph : ShapeLabel \u00d7 SchemaWF DiGraph[ShapeLabel ]\ndep subgraph = {DepSubgraph \u2022 (T , S ) 7\u2192 \u03b8DiGraph }\n4.8 negshapes\nThe definition of negshapes makes use of several auxilliary definitions. In the following we assume that S is a well-formed schema and that T is a shape label in S .\n4.8.1 inNeg\nLet inNeg(S ) be the set of labels that appear in some negated shape constraint.\ninNeg : SchemaWF \" ShapeLabel\n\u2200S : SchemaWF \u2022 inNeg(S ) = \u22c3 {T : shapes(S ) \u2022 inNegExpr(expr(T , S )) }\nGiven a shape expression x , let inNegExpr(x ) be the set of labels that appear in some negated shape constraint in x .\ninNegExpr : ShapeExpr \" ShapeLabel\ninNegExpr(emptyshape) =\n\u2200 tc : TripleConstraint ; c : Cardinality \u2022 inNegExpr(triple(tc, c)) =\ninNegTripleConstraint(tc)\n\u2200 itc : InverseTripleConstraint ; c : Cardinality \u2022 inNegExpr(triple(itc, c)) =\ninNegInverseTripleConstraint(itc)\n\u2200 xs : seq1 ShapeExpr \u2022 inNegExpr(someOf (xs)) = inNegExpr(oneOf (xs)) = inNegExpr(group(xs)) =\u22c3\n{ x : ran xs \u2022 inNegExpr(x ) }\n\u2200 x : ShapeExpr ; c : Cardinality \u2022 inNegExpr(repetition(x , c)) = inNegExpr(x )\nGiven a triple constraint tc, let inNegTripleConstraint(tc) be the set of labels that appear in some negated shape constraint in tc.\ninNegTripleConstraint : TripleConstraint \" ShapeLabel\n\u2200 a : IRI ; C : ValueConstr \u2022 inNegTripleConstraint((nop(a),C )) =\n\u2200 a : IRI ; C : ShapeConstr \u2022 inNegTripleConstraint((nop(a),C )) = inNegShapeConstr(C )\nGiven an inverse triple constraint itc, let inNegInverseTripleConstraint(tc) be the set of labels that appear in some negated shape constraint in itc.\ninNegInverseTripleConstraint : InverseTripleConstraint \" ShapeLabel\n\u2200 a : IRI ; C : ShapeConstr \u2022 inNegInverseTripleConstraint((inv(a),C )) = inNegShapeConstr(C )\nGiven a shape constraint C , let inNegShapeConstr(C ) be the set of labels that appear in C when it is negated, or the empty set otherwise.\ninNegShapeConstr : ShapeConstr\" ShapeLabel\n\u2200Ts : seq1 ShapeLabel \u2022 inNegShapeConstr(or(Ts)) = inNegShapeConstr(and(Ts)) =\n\u2200Ts : seq1 ShapeLabel \u2022 inNegShapeConstr(nor(Ts)) = inNegShapeConstr(nand(Ts)) =\nranTs\n4.8.2 underOneOf\nLet underOneOf (S ) be the set of labels that appear in some triple constraint or inverse triple constraint under a one-of constraint in S .\nunderOneOf : SchemaWF \" ShapeLabel\n\u2200S : SchemaWF \u2022 underOneOf (S ) =\u22c3\n{T : shapes(S ) \u2022 underOneOfExpr(expr(T , S )) }\nGiven a shape expression x , let underOneOfExpr(x ) be the set of labels that appear in some triple constraint or inverse triple constraint under a one-of constraint in x .\nunderOneOfExpr : ShapeExpr\" ShapeLabel\n\u2200 x : ShapeExpr \u2022 underOneOfExpr(x ) =\nif x \u2208 ran someOf then refsShapeExpr(x ) else\n4.8.3 inTripleConstr\nLet inTripleConstr(S ) be the set of labels T such that there is a shape label T1 and a triple constraint p::C or an inverse shape triple constraint ^p::C in expr(T1, S ), and T appears in C .\nNote that this definition looks wrong since it does not involve negation of shapes. Nevertheless, a literal translation is given here. The only difference between inTripleConstr(S ) and refs(S ) seems to be that the cardinality on the triple and inverse triple constraints is [1,1] since it is not explicitly included in the notations p::C and ^p::C.\ninTripleConstr : SchemaWF \" ShapeLabel\n\u2200S : SchemaWF \u2022 inTripleConstr(S ) =\u22c3\n{T1 : shapes(S ) \u2022 inTripleConstrExpr(expr(T1, S )) }\nGiven a shape expression x , let inTripleConstrExpr(x ) be the set of labels T such that x contains a triple constraint p::C or an inverse shape triple constraint ^p::C and T appears in x .\ninTripleConstrExpr : ShapeExpr\" ShapeLabel\ninTripleConstrExpr(emptyshape) =\n\u2200 dtc : DirectedTripleConstraint ; c : Cardinality \u2022 inTripleConstrExpr(triple(dtc, c)) =\nif c = one then refsDirectedTripleConstraint(dtc) else\n\u2200 xs : seq1 ShapeExpr \u2022 inTripleConstrExpr(someOf (xs)) = inTripleConstrExpr(oneOf (xs)) = inTripleConstrExpr(group(xs)) =\u22c3\n{ x : ran xs \u2022 inTripleConstrExpr(x ) }\n\u2200 x : ShapeExpr ; c : Cardinality \u2022 inTripleConstrExpr(repetition(x , c)) = inTripleConstrExpr(x )\n4.8.4 negshapes\nThe semantics draft makes the following statement.\nIntuitively, negshapes(S) is the set of shapes labels for which one needs to check whether some nodes in a graph do not satisfy these shapes, in order to validate the graph against the schema S.\nLet negshapes(S ) be the set of negated shape labels that appear in S .\nnegshapes : SchemaWF \" ShapeLabel\n\u2200S : SchemaWF \u2022 negshapes(S ) = inNeg(S ) \u222a underOneOf (S ) \u222a inTripleConstr(S )\n\u2022 A negated shape label is a shape label that appears in a negated shape constraint, or in a triple or inverse triple constraint under a one-of shape expression, or in a triple or inverse triple constraint that has cardinality [1,1].\nNote that, as remarked above, the definition of inTripleConstr seems wrong.\n4.9 ShapeVerdict\nThe semantics draft defines the notation !T for shape labels T to indicate that T is negated. The semantics of a schema involves assigning sets of shape labels and negated shape labels to the nodes of a graph, which indicates which shapes must be satisfied or violated at each node.\nA shape verdict indicates if a shape must be satisfied or violated. An asserted label must be satisfied. A negated label must be violated.\nShapeVerdict ::= assert ShapeLabel | negate ShapeLabel\nThe notation !T corresponds to negate(T ).\n4.10 allowed\nGiven a value constraint V , let allowed(V ) be the set of all allowed values defined by V .\nallowed : ValueConstr\" (Lit \u222a IRI )\n\u2200 vs : (Lit \u222a IRI ) \u2022 allowed(valueSet(vs)) = vs\n\u2200 dt : LiteralDatatype \u2022 allowed(datatype(dt , )) = literalsOfDatatype(dt)\n\u2200 dt : LiteralDatatype; f : XSFacet \u2022 allowed(datatype(dt , {f })) = literalsOfFacet(dt , f )\n\u2200 k : NodeKind \u2022 allowed(kind(k)) = termsOfKind(k)"}, {"heading": "4.10.1 DAG", "text": "A directed, acyclic graph is a directed graph in which no node is reachable from itself.\nDAG[X ] DiGraph[X ]\nlet g == \u03b8DiGraph \u2022 \u2200T : nodes \u2022 T /\u2208 reachable(g,T )\n4.11 ReplaceShape\nThe semantics draft introduces the notation Sri for a reduced schema where S is a schema, r is a rule-of-one node in a proof tree, and i corresponds to a premise of r . The reduced schema is constructed by replacing a shape with one\nin which the corresponding one-of component is eliminated. This replacement operation is described here. The full definition of Sri is given below following the definition of proof trees.\nGiven a schema S , a shape label T defined in S , and a shape expression Expr \u2032, the schema replaceShape(S ,T ,Expr \u2032) is the schema S \u2032 that is the same as S except that expr(T , S \u2032) = Expr \u2032.\nReplaceShape S , S \u2032 : SchemaWD T : ShapeLabel Expr \u2032 : ShapeExpr l : 1 d , d \u2032 : ShapeDefinition ecs : seqExtensionCondition\nl \u2208 domS\nS (l) = (T , d , ecs)\n\u2200 o : OPTIONAL[InclPropSet ]; Expr : ShapeExpr | d = open(o,Expr) \u2022\nd \u2032 = open(o,Expr \u2032)\n\u2200Expr : ShapeExpr | d = close(Expr) \u2022\nd \u2032 = close(Expr \u2032)\nS \u2032 = S \u2295 {l 7\u2192 (T , d \u2032, ecs)}\nreplaceShape : SchemaWF \u00d7 ShapeLabel \u00d7 ShapeExpr SchemaWF\nreplaceShape = {ReplaceShape \u2022 (S ,T ,Expr \u2032) 7\u2192 S \u2032 }\n4.12 SchemaWD\nGiven a well-formed schema S , it is said to be well-defined if for each negated label T in negshapes(T ), the dependency subgraph dep subgraph(T , S ) is a directed, acyclic graph.\nSchemaWD == { S : SchemaWF |\n\u2200T : negshapes(S ) \u2022 dep subgraph(T , S ) \u2208 DAG[ShapeLabel ] }\nThe semantics of shape expression schemas is sound only for well-defined schemas. Only well-defined schemas will be considered from this point forward."}, {"heading": "5 Declarative semantics of shape expression schemas", "text": "Recall that negated triple and inverse triple shape expressions are represented by the corresponding non-negated expressions with cardinality none = [0;0].\n5.1 LabelledTriple\nA labelled triple is either an incoming or outgoing edge in an RDF graph.\nLabelledTriple ::= out Triple | inc Triple\nSometimes labelled triples are referred to simply as triples.\n5.2 matches\nA labelled triple matches a directed triple constraint when they have the same direction and predicate.\nmatches : LabelledTriple#DirectedTripleConstraint\nmatches = matches out \u222amatches inc\n5.2.1 matches out\nmatches out matches outgoing triples to triple constraints.\nmatches out == { s , p, o : TERM ; C : Constraint |\n(s , p, o) \u2208 Triple \u2022 out(s , p, o) 7\u2192 (nop(p),C ) }\nNote that this definition ignores any value constraints defined in C . The absence of restrictions imposed by value constraints makes matching weaker than it could be. This may be an error in the semantics draft.\nThe semantics drafts contains the following text.\nThe following definition introduces the notion of satisfiability of a shape constraint by a set of triples. Such satisfiability is going to be used for checking that the neighbourhood of a node satisfies locally the constraints defined by a shape expression, without taking into account whether the shapes required by the triple constraints and inverse triple constraints are satisfied.\nRead literally, only shape constraints should be ignored, so unless value constraints are handled elsewhere, the semantics draft has an error in the definition of matches .\n5.2.2 matches inc\nmatches inc matches incoming triples to inverse triple constraints.\nmatches inc == { s , p, o : TERM ; C : ShapeConstr |\n(s , p, o) \u2208 Triple \u2022 inc(s , p, o) 7\u2192 (inv(p),C ) }\n5.3 satifies\nA set of labelled triples Neigh is said to satisfy a shape expression Expr if the constraints, other than shape constraints, defined in Expr are satisfied.\nNote that the definition of matches ignores both value and shape constraints.\nsatisfies : LabelledTriple# ShapeExpr\nThis relation is defined recursively by inference rules for each type of shape expression.\nsatisfies = rule empty\u222a rule triple constraint\u222a rule inverse triple constraint\u222a rule some of \u222a rule one of \u222a rule group\u222a rule repeat\n5.3.1 InfRule\nAn inference rule defines a relation between a set of labelled triples and a shape expression. It is convenient to define a base schema for the inference rules.\nInfRule Neigh : LabelledTriple Expr : ShapeExpr\n5.3.2 rule empty\nAn empty set of triples satisfies the empty shape expression.\nRuleEmpty InfRule\nExpr = emptyshape\nNeigh =\nrule empty : LabelledTriple# ShapeExpr\nrule empty = {RuleEmpty \u2022 Neigh 7\u2192 Expr }\n5.3.3 rule triple constraint\nA set of triples satisfies a triple constraint shape expression when each triple matches the constraint and the total number of constraints is within the bounds of the cardinality.\nRuleTripleConstraint InfRule k : p : IRI C : Constraint c : Cardinality\nExpr = triple((nop(p),C ), c)\nk = #Neigh\nk inBounds c\n\u2200 t : Neigh \u2022 t matches (nop(p),C )\nrule triple constraint : LabelledTriple# ShapeExpr\nrule triple constraint = {RuleTripleConstraint \u2022 Neigh 7\u2192 Expr }\n5.3.4 rule inverse triple constraint\nA set of triples satisfies an inverse triple constraint shape expression when each triple matches the constraint and the total number of constraints is within the bounds of the cardinality.\nRuleInverseTripleConstraint InfRule k : p : IRI C : Constraint c : Cardinality\nExpr = triple((inv(p),C ), c)\nk = #Neigh\nk inBounds c\n\u2200 t : Neigh \u2022 t matches (inv(p),C )\nrule inverse triple constraint : LabelledTriple# ShapeExpr\nrule triple constraint = {RuleInverseTripleConstraint \u2022 Neigh 7\u2192 Expr }\n5.3.5 rule some of\nA set of triples satisfies a some-of shape expression when the set of triples satisfies one of the component shape expressions.\nRuleSomeOf InfRule Exprs : seq1 ShapeExpr i :\nExpr = someOf (Exprs)\ni \u2208 domExprs\nNeigh satisfies Exprs(i)\nrule some of : LabelledTriple# ShapeExpr\nrule some of = {RuleSomeOf \u2022 Neigh 7\u2192 Expr }\n5.3.6 rule one of\nA set of triples satisfies a one-of shape expression when the set of triples satisfies one of the component shape expressions.\nRuleOneOf InfRule Exprs : seq1 ShapeExpr i :\nExpr = oneOf (Exprs)\ni \u2208 domExprs\nNeigh satisfies Exprs(i)\nrule one of : LabelledTriple# ShapeExpr\nrule one of = {RuleOneOf \u2022 Neigh 7\u2192 Expr }\nThe semantics draft contains the following text.\nNote that the conditions for some-of and one-of shapes are identical. The distinction between both will be made by taking into account also the non-local, shape constraints.\n5.3.7 rule group\nA set of triples satisfies a group shape expression when the set of triples can be partitioned into a sequence of subsets whose length is the same as the sequence of component shape expressions, and each subset satisfies the corresponding component shape expression.\nRuleGroup InfRule Neighs : seq1( LabelledTriple) Exprs : seq1 ShapeExpr Expr = group(Exprs)\nNeighs partition Neigh\n#Neighs = #Exprs\n\u2200 j : domNeighs \u2022 Neighs(j ) satisfies Exprs(j )\nrule group : LabelledTriple# ShapeExpr\nrule group = {RuleGroup \u2022 Neigh 7\u2192 Expr }\n5.3.8 rule repeat\nA set of triples satisfies a repetition shape expression when the set of triples can be partitioned into a sequence of subsets whose length is in the bounds of the cardinality, and each subset satisfies the component shape expression of the repetition shape expression.\nRuleRepeat InfRule Expr1 : ShapeExpr Neighs : seq1( LabelledTriple) k : c : Cardinality\nExpr = repetition(Expr1, c)\nk = #Neighs\nk inBounds c\nNeighs partition Neigh\n\u2200 j : domNeighs \u2022 Neighs(j ) satisfies Expr1\nrule repeat : LabelledTriple# ShapeExpr\nrule repeat = {RuleRepeat \u2022 Neigh 7\u2192 Expr }"}, {"heading": "5.4 Proof Trees", "text": "The preceding definition of satisfies is based on the existence of certain characteristics of the set of triples. For example, a set of triples satisfies one of a sequence of shape expressions when it satisfies exactly one of the them, but the satisfies relation forgets the actual shape expression that the set of triples satisfies. We can remember this type of information in a proof tree.\n5.4.1 RuleTree\nA rule tree is a tree of inference rules and optional child rule trees. Child rule trees occur in cases where the inference rule depends on other inference rules.\nRuleTree ::= ruleEmpty RuleEmpty | ruleTripleConstraint RuleTripleConstraint | ruleInverseTripleConstraint RuleInverseTripleConstraint | ruleSomeOf RuleSomeOf \u00d7 RuleTree | ruleOneOf RuleOneOf \u00d7 RuleTree | ruleGroup RuleGroup \u00d7 seq1 RuleTree | ruleRepeat RuleRepeat \u00d7 seq1 RuleTree\n5.4.2 baseRule\nEach node in a rule tree contains an inference rule and, therefore, a base inference rule.\nbaseRule : RuleTree\" InfRule\n\u2200RuleEmpty \u2022 let rule == \u03b8RuleEmpty;\nbase == \u03b8InfRule \u2022 baseRule(ruleEmpty(rule)) = base\n\u2200RuleTripleConstraint \u2022 let rule == \u03b8RuleTripleConstraint ;\nbase == \u03b8InfRule \u2022 baseRule(ruleTripleConstraint(rule)) = base\n\u2200RuleInverseTripleConstraint \u2022 let rule == \u03b8RuleInverseTripleConstraint ;\nbase == \u03b8InfRule \u2022 baseRule(ruleInverseTripleConstraint(rule)) = base\n\u2200RuleSomeOf ; tree : RuleTree \u2022 let rule == \u03b8RuleSomeOf ;\nbase == \u03b8InfRule \u2022 baseRule(ruleSomeOf (rule, tree)) = base\n\u2200RuleOneOf ; tree : RuleTree \u2022 let rule == \u03b8RuleOneOf ;\nbase == \u03b8InfRule \u2022 baseRule(ruleOneOf (rule, tree)) = base\n\u2200RuleGroup; trees : seq1 RuleTree \u2022 let rule == \u03b8RuleGroup;\nbase == \u03b8InfRule \u2022 baseRule(ruleGroup(rule, trees)) = base\n\u2200RuleRepeat ; trees : seq1 RuleTree \u2022 let rule == \u03b8RuleRepeat ;\nbase == \u03b8InfRule \u2022 baseRule(ruleRepeat(rule, trees)) = base\n5.4.3 baseNeigh\nEach node in a rule tree has a base set of labelled triples.\nbaseNeigh : RuleTree\" LabelledTriple\n\u2200 tree : RuleTree \u2022 baseNeigh(tree) = (baseRule(tree)).Neigh\n5.4.4 baseExpr\nEach node in a rule tree has a base shape expression.\nbaseExpr : RuleTree\" ShapeExpr\n\u2200 tree : RuleTree \u2022 baseExpr(tree) = (baseRule(tree)).Expr\n5.4.5 ProofTree\nA proof tree is a rule tree in which the child trees prove subgoals of their parent nodes.\nProofTree : RuleTree\nThe definition of proof tree is recursive so it is given by a set of constraints, one for each type of node.\nAny rule tree whose root node contains an empty shape expression is a proof tree since it has no subgoals.\nran ruleEmpty \u2282 ProofTree\nAny rule tree whose root node node contains a triple constraint shape expression is a proof tree since it has no subgoals.\nran ruleTripleConstraint \u2282 ProofTree\nAny rule tree whose root node node contains an inverse triple constraint shape expression is a proof tree since it has no subgoals.\nran ruleInverseTripleConstraint \u2282 ProofTree\nA rule tree whose root node contains a some-of shape expression is a proof tree if and only if its child rule tree correspond to the distinguished shape expression at index i and it is a proof tree.\n\u2200RuleSomeOf ; tree : RuleTree \u2022 ruleSomeOf (\u03b8RuleSomeOf , tree) \u2208 ProofTree \u21d4\nbaseNeigh(tree) = Neigh \u2227 baseExpr(tree) = Exprs(i) \u2227 tree \u2208 ProofTree\nA rule tree whose root node contains a one-of shape expression is a proof tree if and only if its child rule tree correspond to the distinguished shape expression at index i and it is a proof tree.\n\u2200RuleOneOf ; tree : RuleTree \u2022 ruleOneOf (\u03b8RuleOneOf , tree) \u2208 ProofTree \u21d4\nbaseNeigh(tree) = Neigh \u2227 baseExpr(tree) = Exprs(i) \u2227 tree \u2208 ProofTree\nA rule tree whose root node contains a group shape expression is a proof tree if and only if its sequence of child rule trees correspond to its sequence of component neighbourhood and shape expressions and each child rule tree is a proof tree.\n\u2200RuleGroup; trees : seq1 RuleTree \u2022 ruleGroup(\u03b8RuleGroup, trees) \u2208 ProofTree \u21d4\n#Exprs = #trees \u2227 (\u2200 i : dom trees \u2022\nbaseNeigh(trees(i)) = Neighs(i) \u2227 baseExpr(trees(i)) = Exprs(i) \u2227 trees(i) \u2208 ProofTree)\nA rule tree whose root node contains a repetition shape expression is a proof tree if and only if its sequence of child rule trees correspond to its sequence of component neighbourhoods and each child rule tree is a proof tree.\n\u2200RuleRepeat ; trees : seq1 RuleTree \u2022 ruleRepeat(\u03b8RuleRepeat , trees) \u2208 ProofTree \u21d4\n#Neighs = #trees \u2227 (\u2200 i : dom trees \u2022\nbaseNeigh(trees(i)) = Neighs(i) \u2227 baseExpr(trees(i)) = Expr1 \u2227 trees(i) \u2208 ProofTree)\nWe have the following relation between proof trees and the satisfies relation.\n\u22a2 satisfies = { tree : ProofTree \u2022 baseNeigh(tree) 7\u2192 baseExpr(tree) }"}, {"heading": "5.5 Reduced Schema for rule-one-of", "text": "As mentioned above, inference rules and proof trees treat rule-one-of exactly the same as rule-some-of. The difference between these rules appears when considering valid typings, which are described in detail later.\nLet t be a valid typing of graph G under schema S . Let n be a node in G and let T be a shape label in t(n). Let Expr = expr(T , S ) be the shape expression for T . Let tree be a proof tree that the neighbourhood of n satisfies Expr . Let r be a node of the proof tree that contains an application of rule-one-of and let i be the index of the component expression used in the application of the rule. The intention of the one-of shape expression is that the triples match exactly one of the component expressions. Therefore, if the matched shape expression is removed from the one-of expression then there must not be any valid typings of G under the reduced schema Sri .\nNote that a one-of shape expression may have one or more components. The number of components is denoted by k in the inference rule. However, if it contains exactly one component then there no further semantic conditions\nthat must hold and there is no corresponding reduced schema. Therefore, the definition of the reduced schema only applies to the case where the number of components is greater than one, i.e. k > 1.\nRule trees are ordered trees. A child tree can be specified by giving its index among all the children. The maximum index of a child depends on the type of rule. For leaf trees, the maximum child index is 0.\nmaxChild : RuleTree\"\n\u2200 tree : ran ruleEmpty \u2022 maxChild(tree) = 0\n\u2200 tree : ran ruleTripleConstraint \u2022 maxChild(tree) = 0\n\u2200 tree : ran ruleInverseTripleConstraint \u2022 maxChild(tree) = 0\n\u2200 tree : ran ruleSomeOf \u2022 maxChild(tree) = 1\n\u2200 tree : ran ruleOneOf \u2022 maxChild(tree) = 1\n\u2200 r : RuleGroup; trees : seq1 RuleTree \u2022 maxChild(ruleGroup(r , trees)) = #trees\n\u2200 r : RuleRepeat ; trees : seq1 RuleTree \u2022 maxChild(ruleRepeat(r , trees)) = #trees\nGiven a tree tree and a valid child index j , the child tree at the index is childAt(tree, j ).\nchildAt : RuleTree \u00d7 1 RuleTree dom childAt = { tree : RuleTree; ci : 1 | ci \u2264 maxChild(tree) } \u2200 r : RuleSomeOf ; tree : RuleTree \u2022 childAt(ruleSomeOf (r , tree), 1) = tree\n\u2200 r : RuleOneOf ; tree : RuleTree \u2022 childAt(ruleOneOf (r , tree), 1) = tree\n\u2200 r : RuleGroup; trees : seq1 RuleTree \u2022 let tree == ruleGroup(r , trees) \u2022\n\u2200 ci : 1 . .maxChild(tree) \u2022 childAt(tree, ci) = trees(ci)\n\u2200 r : RuleRepeat ; trees : seq1 RuleTree \u2022 let tree == ruleRepeat(r , trees) \u2022\n\u2200 ci : 1 . .maxChild(tree) \u2022 childAt(tree, ci) = trees(ci)\nThe location of a node within a rule tree can be specified by giving a sequence of positive integers that specify the index of each child tree. The root of the tree is specified by the empty sequence. Such a sequence of integers is referred\nto as a rule path. Given a rule tree tree, the set of all of its rule paths is rulePaths(tree).\nrulePaths : RuleTree\" (seq 1) \u2200 tree : RuleTree | maxChild(tree) = 0 \u2022 rulePaths(tree) = {\u3008\u3009}\n\u2200 tree : RuleTree | maxChild(tree) > 0 \u2022 rulePaths(tree) =\u22c3\n{ ci : 1 . .maxChild(tree) \u2022 { path : rulePaths(childAt(tree, ci)) \u2022 \u3008ci\u3009 path } }\nGiven a rule tree tree and a rule path path, the tree node specified by the path is treeAt(tree, path),\ntreeAt : RuleTree \u00d7 seq 1 RuleTree dom treeAt = { tree : RuleTree; path : seq 1 | path \u2208 rulePaths(tree) } \u2200 tree : RuleTree \u2022 treeAt(tree, \u3008\u3009) = tree\n\u2200 tree : RuleTree; ci : 1; path : seq 1 | \u3008ci\u3009 path \u2208 rulePaths(tree) \u2022\ntreeAt(tree, \u3008ci\u3009 path) = treeAt(childAt(tree, ci), path)\nGiven a one-of shape expression Expr that has more than one component, and an index i of one component, elimExpr(Expr , i) is the reduced expression in which component i is eliminated.\nElimExpr Expr ,Expr \u2032 : ShapeExpr Exprs ,ExprsL,ExprsR : seq1 ShapeExpr i :\nExpr = oneOf (Exprs)\n#Exprs > 1\ni \u2208 domExprs\nExprs = ExprsL \u3008Exprs(i)\u3009 ExprsR Expr \u2032 = oneOf (ExprsL ExprsR)\nelimExpr : ShapeExpr \u00d7 ShapeExpr\nelimExpr = {ElimExpr \u2022 (Expr , i) 7\u2192 Expr \u2032 }\nGiven a proof tree tree with the shape expression Expr as its base, and a path path to some application r of rule-one-of in tree in which the rule-of expression has more than one component,\nRuleOneOfApplication tree : ProofTree path : seq 1 r , rChild : ProofTree R : RuleOneOf\npath \u2208 rulePaths(tree)\nr = treeAt(tree, path) = ruleOneOf (R, rChild)\n#R.Exprs > 1\n\u2022 The path is a valid rule path in the proof tree.\n\u2022 The tree at the path is an application of rule-one-of.\n\u2022 There are more than one components in the one-of shape expression.\nreduceExpr(tree, path) is the reduced base shape expression with the corresponding one-of expression in Expr replaced by the reduced one-of expression.\nreduceExpr : ProofTree \u00d7 seq 1 ShapeExpr dom reduceExpr = {RuleOneOfApplication \u2022 (tree, path) }\n\u2200RuleOneOfApplication | path = \u3008\u3009 \u2227 tree = r \u2022\nreduceExpr(r , \u3008\u3009) = elimExpr(R.Expr ,R.i)\n\u2022 The domain of this function requires that the path be a valid rule path in the proof tree.\n\u2022 In the case of an empty path, the tree must be a one-of tree and the branch taken is eliminated.\n\u2022 When the path is not empty, this function is defined recursively by additional constraints which follow. There are four possible cases in which the proof tree has children. These cases correspond to applications of rulesome-of, rule-one-of, rule-group, and rule-repeat. Each case is defined by a schema below.\nReduceSomeOf RuleOneOfApplication RuleSomeOf child : ProofTree tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr \u2032 : ShapeExpr\ntree = ruleSomeOf (\u03b8RuleSomeOf , child)\npath = \u30081\u3009 tail\nExprs = ExprsL \u3008Exprs(i)\u3009 ExprsR\nExpr \u2032 = someOf (ExprsL \u3008reduceExpr(child , tail)\u3009 ExprsL)\n\u2200ReduceSomeOf \u2022 reduceExpr(tree, path) = Expr \u2032\nReduceOneOf RuleOneOfApplication RuleOneOf child : ProofTree tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr \u2032 : ShapeExpr\ntree = ruleOneOf (\u03b8RuleOneOf , child)\npath = \u30081\u3009 tail\nExprs = ExprsL \u3008Exprs(i)\u3009 ExprsR\nExpr \u2032 = oneOf (ExprsL \u3008reduceExpr(child , tail)\u3009 ExprsL)\n\u2200ReduceOneOf \u2022 reduceExpr(tree, path) = Expr \u2032\nReduceGroup RuleOneOfApplication RuleGroup children : seq1 ProofTree ci : 1 tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr \u2032 : ShapeExpr\ntree = ruleGroup(\u03b8RuleGroup, children)\npath = \u3008ci\u3009 tail\nExprs = ExprsL \u3008Exprs(ci)\u3009 ExprsR Expr \u2032 = group(ExprsL \u3008reduceExpr(children(ci), tail)\u3009 ExprsL)\n\u2200ReduceGroup \u2022 reduceExpr(tree, path) = Expr \u2032\nReduceRepeat RuleOneOfApplication RuleRepeat children : seq1 ProofTree ci : 1 tail : seq 1 Expr \u2032 : ShapeExpr\ntree = ruleRepeat(\u03b8RuleRepeat , children)\npath = \u3008ci\u3009 tail Expr \u2032 = repetition(reduceExpr(children(ci), tail), c)\n\u2200ReduceRepeat \u2022 reduceExpr(tree, path) = Expr \u2032\n\u2022 Something looks wrong here because if a repetition expression has a one-of expression as a child then there is no way to associate the reduced one-of expression with just the path taken in the proof tree since all the children of a repetition expression share the same shape expression. However, a rule-repeat node in the proof tree has many children and there is no requirement that all children would use the same branch of the one-of expression. To make progress, I\u2019ll assume that all children of the repeat will eliminate the same branch of the one-of. I will report this to the mailing list later, along with the observation that the reduction should only one done when a one-of expression has more than one component."}, {"heading": "5.6 Witness Mappings", "text": "Given a set of labelled triples Neigh, a shape expression Expr and a proof tree tree that proves Neigh satisfies Expr , each labelled triple triple appears in a unique leaf node of the proof tree whose rule matches triple with a directed triple constraint dtc. This association of triple with dtc is called a witness mapping, wm(triple) = dtc.\n5.7 WitnessMapping\nWitnessMapping == LabelledTriple DirectedTripleConstraint\n5.7.1 witness\nwitness : ProofTree\"WitnessMapping\n\u2200 r : RuleEmpty \u2022 let tree == ruleEmpty(r) \u2022\nwitness(tree) =\n\u2200 r : RuleTripleConstraint ; dtc : DirectedTripleConstraint ; c : Cardinality | r .Expr = triple(dtc, c) \u2022\nlet tree == ruleTripleConstraint(r) \u2022 witness(tree) = baseNeigh(tree) \u00d7 {dtc}\n\u2200 r : RuleInverseTripleConstraint ; dtc : DirectedTripleConstraint ; c : Cardinality | r .Expr = triple(dtc, c) \u2022\nlet tree == ruleInverseTripleConstraint(r) \u2022 witness(tree) = baseNeigh(tree) \u00d7 {dtc}\n\u2200 r : RuleSomeOf ; subtree : ProofTree \u2022 let tree == ruleSomeOf (r , subtree) \u2022\ntree \u2208 ProofTree \u21d2 witness(tree) = witness(subtree)\n\u2200 r : RuleOneOf ; subtree : ProofTree \u2022 let tree == ruleOneOf (r , subtree) \u2022\ntree \u2208 ProofTree \u21d2 witness(tree) = witness(subtree)\n\u2200 r : RuleGroup; subtrees : seq1 ProofTree \u2022 let tree == ruleGroup(r , subtrees) \u2022\ntree \u2208 ProofTree \u21d2 witness(tree) = \u22c3 { subtree : ran subtrees \u2022 witness(subtree) }\n\u2200 r : RuleRepeat ; subtrees : seq1 ProofTree \u2022 let tree == ruleRepeat(r , subtrees) \u2022\ntree \u2208 ProofTree \u21d2 witness(tree) = \u22c3 { subtree : ran subtrees \u2022 witness(subtree) }\n5.8 outNeigh\nThe outgoing neighbourhood of a node n in an RDF graph G is the set of outgoing labelled triples that correspond to triples in G with subject n.\noutNeigh : Graph \u00d7 TERM \" LabelledTriple\n\u2200G : Graph; n : TERM \u2022 outNeigh(G, n) = { p, o : TERM | (n, p, o) \u2208 G \u2022 out(n, p, o) }\n5.9 incNeigh\nThe ingoing neighbourhood of a node n in an RDF graph G is the set of ingoing labelled triples that correspond to triples in G with object n.\nincNeigh : Graph \u00d7 TERM \" LabelledTriple\n\u2200G : Graph; n : TERM \u2022 incNeigh(G, n) = { p, s : TERM | (s , p, n) \u2208 G \u2022 inc(n, p, s) }\n5.10 Typing\nGiven a schema S and a graph G, a typing t is a map that associates to each node n of G a, possibly empty, set t(n) of shape labels and negated shape labels such that if T is a negated shape label then either T or !T is in t(n). Here I infer that T and !T are mutually exclusive.\nA typing map associates a finite, possibly empty, set of shape verdicts to nodes.\nTyping == TERM ShapeVerdict\nTypingMap G : Graph S : SchemaWD t : Typing\ndom t = nodes(G)\n\u2200n : nodes(G); T : ShapeLabel | assert(T ) \u2208 t(n) \u2022 T \u2208 shapes(S )\n\u2200n : nodes(G); T : ShapeLabel | negate(T ) \u2208 t(n) \u2022 T \u2208 negshapes(S )\n\u2200n : nodes(G); T : negshapes(S ) \u2022 assert(T ) \u2208 t(n) \u2228 negate(T ) \u2208 t(n)\n\u2200n : nodes(G); T : shapes(S ) \u2022 assert(T ) /\u2208 t(n) \u2228 negate(T ) /\u2208 t(n)\n\u2022 The typing associates a set of shape verdicts to each node in the graph.\n\u2022 If a node is required to satisfy T then T must be a shape label of the schema.\n\u2022 If a node is required to violate T then T must be a negated shape label of the schema.\n\u2022 If T is a negated shape label of the schema then each node must be required to either satisfy or violate it.\n\u2022 No node must be required to both satisfy and violate the same shape.\ntypings : Graph \u00d7 SchemaWD\" Typing\n\u2200G : Graph; S : SchemaWD \u2022 typings(G, S ) = {m : TypingMap | m.G = G \u2227 m.S = S \u2022 m.t }\n5.11 TypingSatisfies\nGiven a typing t , a node u, and a shape constraint C , the typing satisfies the constraint at the node if the boolean conditions implied by the shape constraint hold.\nTypingSatisfies TypingMap u : TERM C : ShapeConstr Ts : seq1 ShapeLabel u \u2208 nodes(G)\nC = and(Ts) \u21d2 (\u2200T : ranTs \u2022 assert(T ) \u2208 t(u))\nC = or(Ts) \u21d2 (\u2203T : ranTs \u2022 assert(T ) \u2208 t(u))\nC = nand(Ts) \u21d2 (\u2203T : ranTs \u2022 negate(T ) \u2208 t(u))\nC = nor(Ts) \u21d2 (\u2200T : ranTs \u2022 negate(T ) \u2208 t(u))\n\u2022 The node is in the graph.\n\u2022 The node is required to satisfy every shape in an and shape constraint.\n\u2022 The node is required to satisfy some shape in an or shape constraint.\n\u2022 The node is required to violate some shape in a nand shape constraint.\n\u2022 The node is required to violate every shape in a nor shape constraint.\ntypingSatisfies : Typing \u00d7 TERM # ShapeConstr\ntypingSatisfies = {TypingSatisfies \u2022 (t , u) 7\u2192 C }\n5.12 Matching\nGiven a node n in graph G, a typing t , and a directed triple constraint X , let Matching(G, n, t ,X ) be the set of triples in the graph with focus node n that match X under t .\nMatchingTriples TypingMap n, p : TERM X : DirectedTripleConstraint C : Constraint triples : LabelledTriple\nC \u2208 ValueConstr \u2227 X = (nop(p),C ) \u21d2 triples = { u : TERM | (n, p, u) \u2208 G \u2227\nu \u2208 allowed(C ) \u2022 out(n, p, u) }\nC \u2208 ShapeConstr \u2227 X = (nop(p),C ) \u21d2 triples = { u : TERM | (n, p, u) \u2208 G \u2227\n(t , u) typingSatisfies C \u2022 out(n, p, u) }\nC \u2208 ShapeConstr \u2227 X = (inv(p),C ) \u21d2 triples = { u : TERM | (u, p, n) \u2208 G \u2227\n(t , u) typingSatisfies C \u2022 inc(u, p, n) }\n\u2022 An outgoing triple matches a value constraint if its object is an allowed value.\n\u2022 An outgoing triple matches a shape constraint if the typing of its object satisfies the constraint.\n\u2022 An incoming triple matches a shape constraint if the typing of its subject satisfies the constraint.\nMatching : Graph \u00d7 TERM \u00d7 Typing \u00d7DirectedTripleConstraint\" LabelledTriple\nMatching = {MatchingTriples \u2022 (G, n, t ,X ) 7\u2192 triples }\n5.13 validTypings\nThe definition of what it means for a graph to satisfy a shape schema is given in terms of the existence of a valid typing. Given a graph G and a schema S , a valid typing of G by S is a typing that satisfies certain additional conditions at each node n in G.\nvalidTypings : Graph \u00d7 SchemaWD\" Typing\n\u2200G : Graph; S : SchemaWD \u2022 validTypings(G, S ) \u2286 typings(G, S )\n5.13.1 ValidTypingNodeLabel\nThe definition of a valid typing is given in terms of a series of conditions that must hold at each node and for each shape verdict at that node. It is convenient to introduce the following base schema for conditions.\nValidTypingNodeLabel TypingMap n : TERM T : ShapeLabel ruleT : Rule defT : ShapeDefinition Expr : ShapeExpr Xs : DirectedTripleConstraint\nt \u2208 validTypings(G, S )\nn \u2208 nodes(G)\nassert(T ) \u2208 t(n) \u2228 negate(T ) \u2208 t(n)\nruleT = rule(T , S ) defT = shapeDef (ruleT )\nExpr = expr(T , S ) Xs = tripleConstraints(Expr)\n5.13.2 tripleConstraints\nGiven a shape expression Expr let tripleConstraints(Expr) be the set of all triple or inverse triple constraints contained in it.\ntripleConstraints : ShapeExpr \" DirectedTripleConstraint\ntripleConstraints(emptyshape) =\n\u2200 dtc : DirectedTripleConstraint ; c : Cardinality \u2022 tripleConstraints(triple(dtc, c)) = {dtc}\n\u2200Exprs : seq1 ShapeExpr \u2022 tripleConstraints(someOf (Exprs)) = tripleConstraints(oneOf (Exprs)) = tripleConstraints(group(Exprs)) =\u22c3\n{Expr : ranExprs \u2022 tripleConstraints(Expr) }\n\u2200Expr : ShapeExpr ; c : Cardinality \u2022 tripleConstraints(repetition(Expr , c)) = tripleConstraints(Expr)\n5.13.3 NegatedShapeLabel\nThe semantics draft states:\nfor all negated shape label !T, if !T \u2208 t(n), then t1 is not a valid typing, where t1 is the typing that agrees with t everywhere, except for T \u2208 t1(n)\nNegatedShapeLabel ValidTypingNodeLabel\nnegate(T ) \u2208 t(n)\n\u2022 The shape T is negated at node n.\n5.13.4 AssertShape\nAssertShape NegatedShapeLabel t1 : Typing\nt1 = t \u2295 {n 7\u2192 (t(n) \\ {negate(T )} \u222a {assert(T )})}\n\u2022 The typing t1 is the same as t except that at node n the shape label T is asserted instead of negated.\nIn a valid typing if any node has a negated shape, then the related typing with this shape asserted is invalid.\n\u2200AssertShape \u2022 t1 /\u2208 validTypings(G, S )\nAlthough this condition on t(n) is recursive in terms of the definition of validTypings , it is well-founded since t1(n) has one fewer negated shapes than t(n). Therefore it remains to define the meaning of validTypings for typings that contain no negated shapes.\n5.13.5 assertShape\nGiven a typing t , node n, and shape label T such that negate(T ) \u2208 t(n), define assertShape(t , n,T ) to be the typing t1 that is the same as t except that assert(T ) \u2208 t1(n).\nassertShape : Typing \u00d7 TERM \u00d7 ShapeLabel Typing\nassertShape = {AssertShape \u2022\n(t , n,T ) 7\u2192 t1 }\n5.13.6 AssertedShapeLabel\nThe semantics draft defines the meaning of valid typings t by imposing several conditions that must hold for all nodes n and all asserted shape labels assert(T ) \u2208 t(n).\nAssertedShapeLabel ValidTypingNodeLabel\nassert(T ) \u2208 t(n)\n\u2022 The shape label T is asserted at node n.\nThe semantics draft states that the following conditions must hold for all valid typings t and all nodes n such that T is asserted at n:\nfor all shape label T , if T \u2208 t(n), then there exist three mutually disjoint sets Matching,OpenProp,Rest such that\n1. out(G, n) \u222a inc(G, n) = Matching \u222aOpenProp \u222aRest , and 2. Rest = Restout \u222aRestinc , where\n\u2022 Restout = {(out , n, p, u) \u2208 out(G, n) | p /\u2208 properties(expr(T , S ))}, and \u2022 Restinc = {(inc, u, p, n) \u2208 inc(G, n) | p /\u2208 invproperties(expr(T , S ))}, and\n3. Matching is the union of the sets Matching(n, t ,X ) for all triple constraint or inverse triple constraint X that appears in expr(T , S ), and 4. if T is a closed shape, then Restout = and OpenProp = 5. if T is an open shape, then OpenProp \u2286 {(out , n, p, u) \u2208 out(G, n) | p \u2208 incl(T , S )} 6. there exists a proof tree with corresponding witness mapping wm for the fact that Matching satisfies expr(T , S ), and s.t.\n\u2022 for all outgoing triple (out , n, p, u), it holds (out , n, p, u) \u2208 Matching(n, t ,wm((out , n, p, u))), and moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S )s .t .(out , n, p, u) \u2208 Matching(n, t , p :: C ), and \u2022 for all incoming triple (inc, u, p, n) \u2208 G, it holds (inc, u, p, n) \u2208 Matching(n, t ,wm((inc, u, p, n))), and \u2022 for all node r that corresponds to an application of ruleone-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T \u2208 t1(n), and\n7. for all extension condition (lang, cond), associated with the type T , flang (G, n, cond) returns true or undefined.\n5.13.7 MatchingOpenRest\nfor all shape label T , if T \u2208 t(n), then there exist three mutually disjoint sets Matching,OpenProp,Rest\nMatchingOpenRest AssertedShapeLabel MatchingNeigh,OpenProp,Rest : LabelledTriple\ndisjoint \u3008MatchingNeigh,OpenProp,Rest\u3009\n\u2022 There are three mutually disjoint sets of labelled triples.\n\u2022 Note that the name MatchingNeigh is used to avoid conflict with the previously defined Matching function.\n\u2200AssertedShapeLabel \u2022 \u2203MatchingNeigh,OpenProp,Rest : LabelledTriple \u2022\nMatchingOpenRest\n5.13.8 PartitionNeigh\nout(G, n) \u222a inc(G, n) = Matching \u222aOpenProp \u222a Rest\nPartitionNeigh MatchingOpenRest\n\u3008MatchingNeigh,OpenProp,Rest\u3009 partition outNeigh(G, n) \u222a incNeigh(G, n)\n\u2200AssertedShapeLabel \u2022 \u2203MatchingNeigh,OpenProp,Rest : LabelledTriple \u2022\nPartitionNeigh\n5.13.9 RestDef\nRest = Restout \u222a Restinc, where\n\u2022 Restout = {(out , n, p, u) \u2208 out(G, n) | p /\u2208 properties(expr(T , S ))}, and \u2022 Restinc = {(inc, u, p, n) \u2208 inc(G, n) | p /\u2208 invproperties(expr(T , S ))}, and\nRestDef MatchingOpenRest Rest out ,Rest inc : LabelledTriple\nRest = Rest out \u222aRest inc\nRest out = { p, u : TERM |\nout(n, p, u) \u2208 outNeigh(G, n) \u2227 p /\u2208 properties(expr(T , S )) \u2022\nout(n, p, u) }\nRest inc = { p, u : TERM |\ninc(u, p, n) \u2208 incNeigh(G, n) \u2227 p /\u2208 invproperties(expr(T , S )) \u2022\ninc(u, p, n) }\n\u2200MatchingOpenRest \u2022 \u2203 1 Rest out ,Rest inc : LabelledTriple \u2022 RestDef\n5.13.10 MatchingDef\nMatching is the union of the sets Matching(n, t ,X ) for all triple constraint or inverse triple constraint X that appears in expr(T , S )\nMatchingDef MatchingOpenRest\nMatchingNeigh =\u22c3 {X : Xs \u2022 Matching(G, n, t ,X ) }\n\u2200MatchingOpenRest \u2022 MatchingDef\n5.13.11 ClosedShapes\nif T is a closed shape, then Restout = and OpenProp =\nClosedShapes RestDef\ndefT \u2208 ran close \u21d2 Rest out = \u2227 OpenProp =\n\u2200RestDef \u2022 ClosedShapes\n5.13.12 OpenShapes\nif T is an open shape, then\nOpenProp \u2286 {(out , n, p, u) \u2208 out(G, n) | p \u2208 incl(T , S )}\nOpenShapes MatchingOpenRest\ndefT \u2208 ran open \u21d2 OpenProp \u2286\n{ p, u : TERM | out(n, p, u) \u2208 outNeigh(G, n) \u2227 p \u2208 incl(T , S ) \u2022\nout(n, p, u) }\n\u2200MatchingOpenRest \u2022 OpenShapes\n5.13.13 ProofWitness\nthere exists a proof tree with corresponding witness mapping wm for the fact that Matching satisfies expr(T , S ), and s.t.\n\u2022 for all outgoing triple (out , n, p, u), it holds (out , n, p, u) \u2208 Matching(n, t ,wm((out , n, p, u))), and moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S )s .t .(out , n, p, u) \u2208 Matching(n, t , p :: C ), and \u2022 for all incoming triple (inc, u, p, n) \u2208 G, it holds (inc, u, p, n) \u2208 Matching(n, t ,wm((inc, u, p, n))), and\n\u2022 for all node r that corresponds to an application of rule-one-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T \u2208 t1(n), and\nProofWitness MatchingDef tree : ProofTree wm : WitnessMapping\nbaseNeigh(tree) = MatchingNeigh baseExpr(tree) = Expr\nwm = witness(tree)\n\u2200MatchingDef \u2022 \u2203 tree : ProofTree; wm : WitnessMapping \u2022\nProofWitness\n5.13.14 OutgoingTriples\nfor all outgoing triple (out , n, p, u), it holds\n(out , n, p, u) \u2208 Matching(n, t ,wm((out , n, p, u))),\nand moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S ) s.t.\n(out , n, p, u) \u2208 Matching(n, t , p :: C )\nOutgoingTriples ProofWitness\n\u2200 triple : outNeigh(G, n); p, u : TERM | triple = out(n, p, u) \u2022\nlet X == wm(triple) \u2022 triple \u2208 Matching(G, n, t ,X ) \u2227 (constrDTC (X ) \u2208 ShapeConstr \u21d2\n\u00ac (\u2203C : ValueConstr | (nop(p),C ) \u2208 Xs \u2022 triple \u2208 Matching(G, n, t , (nop(p),C ))))\n\u2200ProofWitness \u2022 OutgoingTriples\n5.13.15 IncomingTriples\nfor all incoming triple (inc, u, p, n) \u2208 G, it holds\n(inc, u, p, n) \u2208 Matching(n, t ,wm((inc, u, p, n)))\nIncomingTriples ProofWitness\n\u2200 triple : incNeigh(G, n) \u2022 let X == wm(triple) \u2022\ntriple \u2208 Matching(G, n, t ,X )\n\u2200ProofWitness \u2022 IncomingTriples\n5.13.16 OneOfNodes\nfor all node r that corresponds to an application of rule-one-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T \u2208 t1(n)\nLet OneOfNodes describe the situation where we are given a graph G, a schema S , a typing t of G under S , a node n in G, a shape label T in t(n), a proof tree tree for the triples MatchNeigh and the expression Expr = expr(T , S ) and an application of rule-one-of r in the proof tree.\nOneOfNodes ProofWitness RuleOneOfApplication Expr ri : ShapeExpr S ri : SchemaWD\nExpr ri = reduceExpr(tree, path)\nS ri = replaceShape(S ,T ,Expr ri)\nWhenever rule-one-of is applied in the proof tree, there must not be any valid typings t1 for the reduced schema S ri in which the selected component of the one-of shape expression is eliminated.\n\u2200OneOfNodes \u2022 \u00ac (\u2203 t1 : validTypings(G, S ri) \u2022\nassert(T ) \u2208 t1(n))\n5.13.17 ExtensionConditions\nfor all extension condition (lang, cond), associated with the type T , flang (G, n, cond) returns true or undefined\nThe semantics of an extension condition is given by a language oracle function that evaluates the extension condition cond on a pointed graph (G, n) and returns a code indicating whether the pointed graph satisfies the extension condition, or if an error condition holds, or if the extension condition is undefined.\nf : ExtLangName \u00d7Graph \u00d7 TERM \u00d7 ExtDefinition\"ReturnCode\n\u2200G : Graph; n : TERM | (G, n) \u2208 PointedGraph \u2022 \u2200 lang : ExtLangName; cond : ExtDefinition \u2022\nlet returnCode == f (lang,G, n, cond) \u2022 returnCode = trueRC \u21d2 (G, n) /\u2208 violatedBy(lang, cond) \u2227 returnCode = falseRC \u21d2 (G, n) \u2208 violatedBy(lang, cond)\n\u2022 If the oracle returns true then the pointed graph satisfies the extension condition.\n\u2022 If the oracle returns false then the pointed graph violates the extension condition.\nLet the return codes for the language oracles be ReturnCode.\nReturnCode ::= trueRC | falseRC | errorRC | undefinedRC\n\u2022 true means the extension condition is satisfied.\n\u2022 false means the extension condition is violated.\n\u2022 error means an error occurred.\n\u2022 undefined means the extension condition is undefined.\nExtensionConditions MatchingOpenRest lang : ExtLangName cond : ExtDefinition\nlet ecs == extConds(ruleT ) \u2022 (lang, cond) \u2208 ran ecs\n\u2022 (lang, cond) is an extension condition for T .\n\u2200ExtensionConditions \u2022 f (lang,G, n, cond) \u2208 {trueRC , undefinedRC}"}, {"heading": "6 Issues", "text": "Some areas of the semantics draft have multiple interpretations or appear to be wrong and therefore require further clarification. These areas are discussed below.\n6.1 dep-subgraph(T,S)\nIn the definition of dep-subgraph(T,S), is the shape T considered to be reachable from itself?\n6.2 negshapes(S)\nIn the definition of negshapes(S), the third bullet states:\nthere is a shape label T1 and a shape triple constraint p::C, or an inverse shape triple constraints ^p::C in expr(T1, S), and T appears in C.\nThis statement looks wrong because it omits mention of negation. If there is no negation involved, why would T be in negshapes(S)?\nDoes this definition only select directed triple constraints that have cardinality [1,1] because that is the default? If not then negshapes(S) is the set of all labels that are referenced in any shape definition (refs(S )), which seems wrong."}, {"heading": "6.3 Triple matches constraint", "text": "The definition of matching p:C and ^p:C omits consideration of C. The explanation is as follows.\nThe following definition introduces the notion of satisfiability of a shape constraint by a set of triples. Such satisfiability is going to be used for checking that the neighborhood of a node satisfies locally the constraints defined by a shape expression, without taking into account whether the shapes required by the triple constraints and inverse triple constraints are satisfied.\nThis statement implies that only shape constraints should be ignored here. However, the definition ignores the value set constraints too. This looks wrong.\n6.4 rule-triple-constraint\nAdd the condition that all the outgoing triples must be distinct.\n6.5 rule-inverse-triple-constraint\nAdd the condition that all the incoming triples must be distinct.\n6.6 rule-group\nAdd the condition that i and j must be different.\n6.7 rule-repeat\nAdd the condition that i and j must be different.\n6.8 Reduced Schema for rule-one-of\nThis is an edge case. It only makes sense to reduce the schema if there are more than one components. Applying rule-one-of to a sequence of one shape is equivalent to requiring that shape. Add this condition to the definition.\n6.9 Reduced Schema for rule-one-of under a repetition\nexpression\nSomething looks wrong here because if a repetition expression has a one-of expression as a child then there is no way to associate the reduced one-of expression with just the path taken in the proof tree since all the children of a repetition expression share the same shape expression. However, a rule-repeat node in the proof tree has many children and there is no requirement that all children would use the same branch of the one-of expression."}, {"heading": "7 Conclusion", "text": "The exercise of formalizing the semantics draft has resulted in a considerable expansion in the size of the document. The result has been the identification of a number of quality issues. This exercise has also established that the recursive definitions in the semantics draft are well-founded. However, it is not clear that these definitions produce results that agree with our intuition, or that they can be computed efficiently.\nOne possible way to further validate the semantics draft is to translate it into an executable formal specification system such as Coq [1] and test it on a set of examples, including both typical documents and corner cases."}], "references": [{"title": "RDF Data Shapes", "author": ["A. Le Hors"], "venue": "Working Group. wiki page, World Wide Web Consortium,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "agryman/z-core-shacl-semantics. source code repository, GitHub", "author": ["A. Ryman"], "venue": "https://github.com/agryman/z-core-shacl-semantics", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Recursion in RDF Data Shape Languages. Article", "author": ["A. Ryman"], "venue": "World Wide Web Consortium,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "The Z Notation: a reference manual", "author": ["M. Spivey"], "venue": "https://spivey.oriel.ox.ac.uk/mike/zrm/index.html", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "The fuzz type-checker for Z. web", "author": ["M. Spivey"], "venue": "page, Oxford University,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF graphs.", "startOffset": 38, "endOffset": 41}, {"referenceID": 3, "context": "This document provides a formal translation of the semantics draft into Z Notation [6].", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.", "startOffset": 83, "endOffset": 86}, {"referenceID": 1, "context": "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.", "startOffset": 129, "endOffset": 132}, {"referenceID": 2, "context": "We reuse some formal definitions given in [5], modifying the identifiers to match those used in the semantics draft.", "startOffset": 42, "endOffset": 45}], "year": 2015, "abstractText": "This article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}