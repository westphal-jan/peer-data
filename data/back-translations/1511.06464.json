{"id": "1511.06464", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Nov-2015", "title": "Unitary Evolution Recurrent Neural Networks", "abstract": "If the eigenvalues of the hidden weight matrix deviate from the absolute value 1, optimization becomes difficult due to the well-studied problem of disappearing and exploding gradients, especially when trying to learn long-term dependencies. To get around this problem, we propose a new architecture that learns a uniform weight matrix after each weight update, with eigenvalues of the absolute value exactly 1. The challenge we face is to parameterize uniform matrices in a way that does not require expensive compositions (such as self-decomposition). We construct an expressive uniform weight matrix by assembling several structured matrices that function as building blocks with parameters to be learned. Optimization with this parameterization can only be carried out taking into account hidden states in the complex area.", "histories": [["v1", "Fri, 20 Nov 2015 00:37:33 GMT  (802kb,D)", "http://arxiv.org/abs/1511.06464v1", null], ["v2", "Sat, 28 Nov 2015 18:42:08 GMT  (854kb,D)", "http://arxiv.org/abs/1511.06464v2", null], ["v3", "Thu, 18 Feb 2016 00:52:28 GMT  (914kb,D)", "http://arxiv.org/abs/1511.06464v3", null], ["v4", "Wed, 25 May 2016 23:34:38 GMT  (919kb,D)", "http://arxiv.org/abs/1511.06464v4", null]], "reviews": [], "SUBJECTS": "cs.LG cs.NE stat.ML", "authors": ["mart\u00edn arjovsky", "amar shah", "yoshua bengio"], "accepted": true, "id": "1511.06464"}, "pdf": {"name": "1511.06464.pdf", "metadata": {"source": "CRF", "title": "UNITARY EVOLUTION RECURRENT NEURAL NETWORKS", "authors": ["Martin Arjovsky", "Amar Shah", "Yoshua Bengio"], "emails": ["marjovsky@dc.uba.ar", "as793@cam.ac.uk"], "sections": [{"heading": null, "text": "Recurrent neural networks (RNNs) are notoriously difficult to train. When the eigenvalues of the hidden to hidden weight matrix deviate from absolute value 1, optimization becomes difficult due to the well studied issue of vanishing and exploding gradients, especially when trying to learn long-term dependencies. To circumvent this problem, we propose a new architecture that learns a unitary weight matrix, with eigenvalues of absolute value exactly 1. The challenge we address is that of parametrizing unitary matrices in a way that does not require expensive computations (such as eigendecomposition) after each weight update. We construct an expressive unitary weight matrix by composing several structured matrices that act as building blocks with parameters to be learned. Optimization with this parameterization becomes feasible only when considering hidden states in the complex domain. We demonstrate the potential of this architecture by achieving state of the art results in several hard tasks involving very long-term dependencies."}, {"heading": "1 INTRODUCTION", "text": "Deep Neural Networks have shown remarkably good performance on a wide range of complex data problems including speech recognition (Hinton et al., 2012), image recognition (Krizhevsky et al., 2012) and natural language processing (Collobert et al., 2011). However, training very deep models remains a difficult task. The main issue surrounding the training of deep networks is the vanishing and exploding gradients problems introduced by Hochreiter (1991) and shown by Bengio et al. (1994) to be necessarily arising when trying to learn to reliably store bits of information in any parametrized dynamical system. If gradients propagated back through a network vanish, the credit assignment role of backpropagation is lost, as information about small changes in states in the far past has no influence on future states. If gradients explode, gradient-based optimization algorithms struggle to traverse down a cost surface, because gradient-based optimization assumes small changes in parameters yield small changes in the objective function. As the number of time steps considered in the sequence of states grows, the shrinking or expanding effects associated with the state-to-state transformation at individual time steps can grow exponentially, yielding respectively vanishing or exploding gradients. See Pascanu et al. (2010) for a review.\nAlthough the long-term dependencies problem appears intractable in the absolute (Bengio et al., 1994) for parametrized dynamical systems, several heuristics have recently been found to help reduce its effect, such as the use of self-loops and gating units in the LSTM (Hochreiter & Schmidhuber, 1994) and GRU (Cho et al., 2014) recurrent architectures. Recent work also supports the idea of using orthogonal weight matrices to assist optimization (Saxe et al., 2014; Le et al., 2015).\nIn this paper, we explore the use of orthogonal and unitary matrices in recurrent neural networks. We start in Section 2 by showing a novel bound on the propagated gradients in recurrent nets when the recurrent matrix is orthogonal. Section 3 discusses the difficulties of parameterizing real valued orthogonal matrices and how they can be alleviated by moving to the complex domain.\n\u2217Indicates first authors. Ordering determined by coin flip.\nar X\niv :1\n51 1.\n06 46\n4v 1\n[ cs\n.L G\n] 2\n0 N\nov 2\n01 5\nWe discuss a novel approach to constructing expressive unitary matrices as the composition of simple unitary matrices which require at most O(n log n) computation and O(n) memory, when the state vector has dimension n. These are unlike general matrices, which require O(n2) computation and memory. Complex valued representations have been considered for neural networks in the past, but with limited success and adoption (Hirose, 2003; Zimmermann et al., 2011). We hope our findings will change this.\nWhilst our model uses complex valued matrices and parameters, all implementation and optimization is possible with real numbers and has been done in Theano (Bergstra et al., 2010). This along with other implementation details are discussed in Section 4, and the code used for the experiments is available online. The potential of the developed model for learning long term dependencies with relatively few parameters is explored in Section 5. We find that the proposed architecture generally outperforms LSTMs and previous approaches based on orthogonal initialization."}, {"heading": "2 ORTHOGONAL WEIGHTS AND BOUNDING THE LONG-TERM GRADIENT", "text": "A matrix, W, is orthogonal if W>W = WW> = I. Orthogonal matrices have the property that they preserve norm (i.e. \u2016Wh\u20162 = \u2016h\u20162) and hence repeated iterative multiplication of a vector by an orthogonal matrix leaves the norm of the vector unchanged.\nLet hT and ht be the hidden unit vectors for hidden layers T and t of a neural network with T hidden layers and T t. If C is the objective we are trying to minimize, then the vanishing and exploding gradient problems refer to the decay or growth of \u2202C\u2202ht as the number of layers, T , grows. Let \u03c3 be a pointwise nonlinearity function, and\nzt+1 = Wtht + Vtxt+1 ht+1 = \u03c3(zt+1) (1)\nthen by the chain rule\n\u2202C \u2202ht = \u2202C \u2202hT \u2202hT \u2202ht = \u2202C \u2202hT T\u22121\u220f k=t \u2202hk+1 \u2202hk = \u2202C \u2202hT T\u22121\u220f k=t Dk+1W T k , (2)\nwhere Dk+1 = diag(\u03c3\u2032(zk+1)) is the Jacobian matrix of the pointwise nonlinearity.\nIn the following we define to the norm of a matrix to refer to the spectral radius norm (or operator 2-norm) and the norm of a vector to mean L2-norm. By definition of the operator norms, for any matrices A,B and vector v we have \u2016Av\u2016 \u2264 \u2016A\u2016 \u2016v\u2016 and \u2016AB\u2016 \u2264 \u2016A\u2016 \u2016B\u2016. If the weight matrices Wk are norm preserving (i.e. orthogonal), then we prove\u2225\u2225\u2225\u2225 \u2202C\u2202ht \u2225\u2225\u2225\u2225 = \u2225\u2225\u2225\u2225\u2225 \u2202C\u2202hT T\u22121\u220f k=t Dk+1W T k \u2225\u2225\u2225\u2225\u2225 \u2264 \u2225\u2225\u2225\u2225 \u2202C\u2202hT \u2225\u2225\u2225\u2225 T\u22121\u220f k=t \u2225\u2225Dk+1WTk \u2225\u2225 = \u2225\u2225\u2225\u2225 \u2202C\u2202hT \u2225\u2225\u2225\u2225 T\u22121\u220f k=t \u2016Dk+1\u2016 . (3)\nSince Dk is diagonal, \u2016Dk\u2016 = maxj=1,...,n |\u03c3\u2032(z(j)k )|, with z (j) k the j-th pre-activation of the kth hidden layer. If the absolute value of the derivative \u03c3\u2032 can take some value \u03c4 > 1, then this bound is useless, since \u2225\u2225\u2225 \u2202C\u2202ht \u2225\u2225\u2225 \u2264 \u2225\u2225\u2225 \u2202C\u2202hT \u2225\u2225\u2225 \u03c4T\u2212t which grows exponentially in T . We therefore cannot effectively bound \u2202C\u2202ht for deep networks, resulting potentially in exploding gradients.\nIn the case |\u03c3\u2032| < \u03c4 < 1, equation 3 proves that that \u2202C\u2202ht tends to 0 exponentially fast as T grows, resulting in guaranteed vanishing gradients. This argument makes the rectified linear unit (ReLU) nonlinearity an attractive choice (Glorot et al., 2011; Nair & Hinton, 2010). Unless all the activations are killed at one layer, the maximum entry of Dk is 1, resulting in \u2016Dk\u2016 = 1 for all layers k. With ReLU nonlinearities, we thus have\u2225\u2225\u2225\u2225 \u2202C\u2202ht \u2225\u2225\u2225\u2225 \u2264 \u2225\u2225\u2225\u2225 \u2202C\u2202hT \u2225\u2225\u2225\u2225 T\u22121\u220f\nk=t\n\u2016Dk+1\u2016 = \u2225\u2225\u2225\u2225 \u2202C\u2202hT \u2225\u2225\u2225\u2225 (4) Most notably, this result holds for a network of arbitrary depth and renders engineering tricks like gradient clipping unnecessary (Pascanu et al., 2010).\nTo the best of our knowledge, this analysis is a novel contribution and the first time a neural network architecture has been mathematically proven to avoid exploding gradients."}, {"heading": "3 UNITARY EVOLUTION RNNS", "text": "Unitary matrices generalize orthogonal matrices to the complex domain. A complex valued, norm preserving matrix, U, is called a unitary matrix and is such that U\u2217U = UU\u2217 = I, where U\u2217 is the conjugate transpose of U. Directly parametrizing the set of unitary matrices in such a way that gradient-based optimization can be applied is not straightforward because a gradient step will typically yield a matrix that is not unitary, and projecting on the set of unitary matrices (e.g., by performing an eigendecomposition) generally costs O(n3) computation when U is n\u00d7 n. The most important feature of unitary and orthogonal matrices for our purpose is that they have eigenvalues \u03bbj with absolute value 1. The following lemma, proved in Hoffman & Kunze (1971), may shed light on a method which can be used to efficiently span a large set of unitary matrices. Lemma 1. A complex square matrix W is unitary if and only if it has an eigendecomposition of the form W = VDV\u2217, where \u2217 denotes the conjugate transpose. Here, V,D \u2208 Cn\u00d7n are complex matrices, where V is unitary, and D is a diagonal such that |Dj,j | = 1. Furthermore, W is a real orthogonal matrix if and only if for every eigenvalue Dj,j = \u03bbj with eigenvector vj , there is also a complex conjugate eigenvalue \u03bbk = \u03bbj with corresponding eigenvector vk = vj .\nWriting \u03bbj = eiwj with wj \u2208 R, a naive method to learn a unitary matrix would be to fix a basis of eigenvectors V \u2208 Cn\u00d7n and set\nW = VDV\u2217, (5)\nwhere D is a diagonal such that Dj,j = \u03bbj .\nLemma 1 informs us how to construct a real orthogonal matrix, W. We must (i) ensure the columns of V come in complex conjugate pairs, vk = vj , and (ii) tie weights wk = \u2212wj in order to achieve eiwj = eiwk . Most neural network objective functions are differentiable with respect to the weight matrices, and consequently wj may be learned by gradient descent. Unfortunately the above approach has undesirable properties. Fixing V and learning w requires O ( n2 )\nmemory, which is unacceptable given that the number of learned parameters is O(n). Further note that calculating Vu for an arbitrary vector u requires O(n2) computation. Setting V to the identity would satisfy the conditions of the lemma, whilst reducing memory and computation requirements to O(n), however, W would remain diagonal, and have poor representation capacity. We propose an alternative strategy to parameterize unitary matrices. Since the product of unitary matrices is itself a unitary matrix, we compose several simple, parameteric, unitary matrices to construct a single, expressive unitary matrix. The four unitary building blocks considered are\n\u2022 D, a diagonal matrix with Dj,j = eiwj , with parameters wj \u2208 R,\n\u2022 R = I\u2212 2 vv \u2217\n\u2016v\u20162 , a reflection matrix in the complex vector v \u2208 C n,\n\u2022 \u03a0, a fixed random index permutation matrix, and \u2022 F and F\u22121, the Fourier and inverse Fourier transforms.\nAppealingly, D, R and \u03a0 all permitO(n) storage andO(n) computation for matrix vector products. F and F\u22121 require no storage and O(n log n) matrix vector multiplication using the Fast Fourier Transform algorithm. A major advantage of composing unitary matrices of the form listed above, is that the number of parameters, memory and computational cost increase almost linearly in the size of the hidden layer. With such a weight matrix, immensely large hidden layers are feasible to train, whilst being impossible in traditional neural networks.\nWith this in mind, in this work we choose to consider recurrent neural networks with unitary hidden to hidden weight matrices. Our claim is that the ability to have large hidden layers where hidden states norms are preserved provides a powerful tool for modeling long term dependencies in sequence data. Bengio et al. (1994) suggest that having a large memory may be crucial for solving difficult tasks with long ranging dependencies: the smaller the state dimension, the more information necessarily has to be eliminated when mapping a long sequence to a fixed-dimension state.\nWe call any RNN architecture which uses a unitary hidden to hidden matrix a unitary evolution RNN (uRNN). After experimenting with several structures, we settled on the following composition\nW = D3R2F\u22121D2\u03a0R1FD1. (6) Whilst each but the permutation matrix is complex, we parameterize and represent them with real\nnumbers for implementation purposes. When the final cost is real and differentiable, we may perform gradient descent optimization to learn the parameters. Yang et al. (2015) construct a real valued, non-orthogonal matrix using a similar parameterization with the motivation of parameter reduction by an order of magnitude on an industrial sized network. This combined with earlier work (Le et al., 2010) suggests that it is possible to create highly expressive matrices by composing simple matrices with few parameters. In the following section, we explain details on how to implement our model and illustrate how we bypass the potential difficulties of working in the complex domain."}, {"heading": "4 ARCHITECTURE DETAILS", "text": "In this section, we describe the nonlinearity we used, how we incorporate real valued inputs with complex valued hidden units and map from complex hidden states to real outputs."}, {"heading": "4.1 COMPLEX HIDDEN UNITS", "text": "Our implementation represents all complex numbers using real values in terms of their real and imaginary parts. Under this framework, we sidestep the lack of support for complex numbers by most deep learning frameworks. Consider multiplying the complex weight matrix W = A + iB by the complex hidden vector h = x + iy, where A,B, x, y are real. It is trivially true that Wh = (Ax \u2212 By) + i(Ay + Bx). When we represent v \u2208 Cn as ( Re(v)>, Im(v)>\n)> \u2208 R2n , we compute complex matrix vector products with real numbers as follows(\nRe(Wh) Im(Wh)\n) = ( A \u2212B B A )( Re(h) Im(h) ) . (7)\nMore generally, let f : Cn \u2192 Cn be any complex function and z = x + iy any complex vector. We may write f(z) = \u03b1(x, y) + i\u03b2(x, y) where \u03b1, \u03b2 : Rn \u2192 Rn. This allows us to implement everything using real valued operations, compatible with any any deep learning framework with automatic differentiation such as Theano."}, {"heading": "4.2 INPUT TO HIDDEN, NONLINEARITY, HIDDEN TO OUTPUT", "text": "As is the case with most recurrent networks, our uRNN follows the same hidden to hidden mapping as equation 1 with Vt = V and Wt = W. Denote the size of the complex valued hidden states as nh. The input to hidden matrix is complex valued, V \u2208 Cnh\u00d7nin . We learn the initial hidden state h0 \u2208 Cnh as a parameter of the model. Choosing an appropriate nonlinearity is not trivial in the complex domain. As discussed in the introduction, using a ReLU is a natural choice in combination with a norm preserving weight matrix. We first experimented with placing separate ReLU activations on the real and imaginary parts of the hidden states. However, we found that such a nonlinearity usually performed poorly. Our intuition is that applying separate ReLU nonlinearities to the real and imaginary parts brutally impacts the phase of a complex number, making it difficult to learn structure.\nWe speculate that maintaining the phase of hidden states may be important for storing information across a large number of time steps, and our experiments supported this claim. A variation of the ReLU that we name modReLU, is what we finally chose. It is a pointwise nonlinearity, \u03c3modReLU(z) : C\u2192 C, which affects only the absolute value of a complex number, defined as\n\u03c3modReLU(z) = { (|z|+ b|) z|z| if |z|+ b \u2265 0 0 if |z|+ b < 0 (8)\nwhere b \u2208 R is a bias parameter of the nonlinearity. For a nh dimensional hidden space we learn nh nonlinearity bias parameters, one per dimension. Note that the modReLU is similar to the ReLU in spirit, in fact more concretely \u03c3modReLU(z) = \u03c3ReLU(|z|+ b) z|z| .\nTo map hidden states to output, we define a matrix U \u2208 Rno\u00d72nh , where no is the output dimension. We calculate a linear output as\not = U ( Re(ht) Im(ht) ) + bo, (9)\nwhere bo \u2208 Rno is the output bias. The linear output is real valued (ot \u2208 Rno ) and can be used for prediction and loss function calculation akin to typical neural networks (e.g. it may be passed through a softmax which is used for cross entropy calculation for classification tasks)."}, {"heading": "4.3 INITIALIZATION", "text": "Due to the stability of the norm preserving operations of our network, we found that performance was not very sensitive to initialization of parameters. For full disclosure and reproducibility, we explain our initialization strategy for each parameter below.\n\u2022 We initialize V and U (the input and output matrices) as in Glorot & Bengio (2010), with weights sampled independently from uniforms, U [ \u2212 \u221a 6\u221a\nnin+nout ,\n\u221a 6\u221a\nnin+nout\n] .\n\u2022 The biases, b and bo are initialized to 0. This implies that at initialization, the network is linear with unitary weights, which seems to help early optimization (Saxe et al., 2014).\n\u2022 The reflection vectors for R1 and R2 are initialized coordinate-wise from a uniform U [\u22121, 1]. Note that the reflection matrices are invariant to scalar multiplication of the parameter vector, hence the width of the uniform initialization is unimportant.\n\u2022 The diagonal weights for D1,D2 and D3 are sampled from a uniform, U [\u2212\u03c0, \u03c0]. This ensures that the diagonal entries Dj,j are sampled uniformly over the complex unit circle.\n\u2022 We initialize h0 with a uniform, U [ \u2212 \u221a\n3 2nh\n, \u221a\n3 2nh\n] , which results in E [ \u2016h0\u20162 ] = 1.\nSince the norm of the hidden units are roughly preserved through unitary evolution and inputs are typically whitened to have norm 1, we have hidden states, inputs and linear outputs of the same order of magnitude, which seems to help optimization."}, {"heading": "5 EXPERIMENTS", "text": "In this section we explore the performance of our uRNN in relation to (a) RNN with tanh activations, (b) IRNN (Le et al., 2015), that is an RNN with ReLU activations and with the recurrent weight matrix initialized to the identity, and (c) LSTM (Hochreiter & Schmidhuber, 1994) models. We show that the uRNN shines quantitatively when it comes to modeling long term dependencies and exhibits qualitatively different learning properties to the other models.\nWe chose a handful of tasks to evaluate the performance of the various models. The tasks were especially created to be be pathologically hard, and have been used as benchmarks for testing the ability of a model to capture long-term memory (Hochreiter & Schmidhuber, 1994; Le et al., 2015; Graves et al., 2014; Martens & Sutskever, 2011)\nOf the handful of optimization algorithms we tried on the various models, RMSProp (Tieleman & Hinton, 2012) lead to fastest convergence and is what we stuck to for all experiments here on in. However, we found the IRNN to be particularly unstable; it only ran without blowing up with incredibly low learning rates and gradient clipping. Since the performance was so poor relative to other models we compare against, we do not show IRNN curves in the figures. In each experiment we use a learning rate of 10\u22123 and a decay rate of 0.9. For the LSTM and RNN models, we had to clip gradients at 1 to avoid exploding gradients. Gradient clipping was unnecessary for the uRNN."}, {"heading": "5.1 COPYING MEMORY PROBLEM", "text": "Recurrent networks have been known to have trouble remembering information about inputs seen many time steps previously (Bengio et al., 1994; Pascanu et al., 2010). We therefore want to test the uRNN\u2019s ability to recall exactly data seen a long time ago.\nFollowing a similar setup to Hochreiter & Schmidhuber (1994), we outline the copy memory task. Consider 10 categories, {ai}9i=0. The input takes the form of a T + 20 length vector of categories,\nwhere we test over a range of values of T . The first 10 entries are sampled uniformly, independently and with replacement from {ai}7i=0, and represent the sequence which will need to be remembered. The next T \u2212 1 entries are set to a8, which can be thought of as the \u2019blank\u2019 category. The next single entry is a9, which represents a delimiter, which should indicate to the algorithm that it is now required to reproduce the initial 10 categories in the output. The remaining 10 entries are set to a8. The required output sequence consists of T + 10 repeated entries of a8, followed by the first 10 categories of the input sequence in exactly the same order. The goal is to minimize the average cross entropy of category predictions at each time step of the sequence. The task amounts to having to remember a categorical sequence of length 10, for T time steps.\nA simple baseline can be established by considering an optimal strategy when no memory is available, which we deem the memoryless strategy. The memoryless strategy would be to predict a8 for T + 10 entries and then predict each of the final 10 categories from the set {ai}7i=0 independently and uniformly at random. The categorical cross entropy of this strategy is 10 log(8)T+20 .\nWe ran experiments where the RNN with tanh activations, IRNN, LSTM and uRNN had hidden layers of size 80, 80, 40 and 128 respectively. This equates to roughly 6500 parameters per model. In Figure 1, we see that aside from the simplest case, both the RNN with tanh and more surprisingly the LSTMs get almost exactly the same cost as the memoryless strategy. This behaviour is consistent with the results of Graves et al. (2014), in which poor performance is reported for the LSTM for a very similar long term memory problem.\nThe uRNN consistently achieves perfect performance in relatively few iterations, even when having to recall sequences after 500 time steps. What is remarkable is that the uRNN does not get stuck at the baseline at all, whilst the LSTM and RNN do. This behaviour suggests that the representations learned by the uRNN have qualitatively different properties from both the LSTM and classical RNNs."}, {"heading": "5.2 ADDING PROBLEM", "text": "We closely follow the adding problem defined in Hochreiter & Schmidhuber (1994) to explain the task at hand. Each input consists of two sequences of length T . The first sequence, which we denote x, consists of numbers sampled uniformly at random U [0, 1]. The second sequence is an indicator sequence consisting of exactly two entries of 1 and remaining entries 0. The first 1 entry is located uniformly at random in the first half of the sequence, whilst the second 1 entry is located uniformly at random in the second half. The output is the sum of the two entries of the first sequence, corresponding to where the 1 entries are located in the second sequence. A naive strategy of predicting 1 as the output regardless of the input sequence gives an expected mean squared error of 0.167, the variance of the sum of two independent uniform distributions. This is our baseline to beat.\nWe chose to use 128 hidden units for the RNN with tanh, IRNN and LSTM and 512 for the uRNN. This equates to roughly 16K parameters for the RNN with tanh and IRNN, 60K for the LSTM and almost 9K for the uRNN. All models were trained using batch sizes of 20 and 50 with the best results being reported. Our results are shown in Figure 2.\nThe LSTM and uRNN models are able to convincingly beat the baseline up to T = 400 time steps. Both models do well when T = 750, but the mean squared error does not reach close to 0. The uRNN achieves lower test error, but with more noise at testing. Despite having vastly more parameters, we monitored the LSTM performance to ensure no overfitting.\nThe RNN with tanh and IRNN were not able to beat the baseline for any number of time steps. Le et al. (2015) report that their RNN solve the problem for T = 150 and the IRNN for T = 300, but they require over a million iterations before they start learning. Neither of the two models came close to either the uRNN or the LSTM in performance. The stark difference in our findings are best\nexplained by our use of RMSprop with significantly higher learning rates (10\u22123 as opposed to 10\u22128) than Le et al. (2015) use for SGD with momentum."}, {"heading": "5.3 PIXEL-BY-PIXEL MNIST", "text": "In this task, suggested by Le et al. (2015), algorithms are fed pixels of MNIST (LeCun et al., 1998) sequentially and required to output a class label at the end. We consider two tasks: one where pixels are read in order (from left to right, bottom to top) and one where the pixels are all randomly permuted using the same randomly generated permutation matrix. The same model architectures as for the adding problem were used for this task, except we now use a softmax for category classification. We ran the optimization algorithms until convergence of the mean categorical cross entropy on test data, and plot test accuracy in Figure 3.\nBoth the uRNN and LSTM perform applaudably well here. On the correct unpermutted MNIST pixels, the LSTM performs better, achieving 98.2 % test accurracy versus 95.1% for the uRNN. However, when we permute the ordering of the pixels, the uRNN dominates with 91.4% of accuracy in contrast to the 88% of the LSTM, despite having less than a quarter of the parameters. This result is state of the art on this task, beating the IRNN (Le et al., 2015), which reaches close to 82% after 1 million training iterations. Notice that uRNN reaches convergence in less than 20 thousand iterations, while it takes the LSTM from 5 to 10 times as many to finish learning.\nPermuting the pixels of MNIST images creates many longer term dependencies across pixels than in the original pixel ordering, where a lot of structure is local. This makes it necessary for a network to learn and remember more complicated dependencies across varying time scales. The results suggest that the uRNN is better able to deal with such structure over the data, where the LSTM is better suited to more local sequence structure tasks."}, {"heading": "5.4 EXPLORATORY EXPERIMENTS", "text": "Norms of hidden state gradients. As discussed in Section 2, key to being able to learn long term dependencies is in controlling \u2202C\u2202ht . With this in mind, we explored how each model propagated\ngradients, by examining \u2225\u2225\u2225 \u2202C\u2202ht \u2225\u2225\u2225 as a function of t. Gradient norms were computed at the beginning of training and again after 100 iterations of training on the adding problem. The curves are plotted in Figure 4. It is clear that at first, the uRNN propogates gradients perfectly, while each other model has exponentially vanishing gradients. After 100 iterations of training, each model experiences vanishing gradients, but the uRNN is best able to propagate information, having much less decay.\nHidden state saturation. We claim that typical recurrent architectures saturate, in the sense that after they acquire some information, it becomes much more difficult to acquire further information pertaining to longer dependencies. We took the uRNN and LSTM models trained on the adding\nFigure 4: From left to right. Norms of the gradients with respect to hidden states i.e.\n\u2225\u2225\u2225 \u2202C\u2202ht \u2225\u2225\u2225 at (i)\nbeginning of training, (ii) after 100 iterations. (iii) Norms of the hidden states and (iv) L2 distance between hidden states and final hidden state. The gradient norms of uRNNs do not decay as fast as for other models as training progresses. uRNN hidden state norms stay much more consistent over time than the LSTM. LSTM hidden states stay almost the same after a number of time steps, suggesting that it is not able to use new input information.\nproblem with T = 200, and computed a forward pass with newly generated data for the adding problem with T = 1000. In order to show saturation effects, we plot the norms of the hidden states and the L2 distance between each state and the last in Figure 4.\nIn our experiments, it is clear that the uRNN does not suffer as much as other models do. Notice that whilst the norms of hidden states in the uRNN grow very steadily over time, in the LSTM they grow very fast, and then stay constant after about 500 time steps. This behaviour may suggest that the LSTM hidden states saturate in their ability to incorporate new information, which is vital for modeling long complicated sequences. It is interesting to see that the LSTM hidden state at t = 500, is close to that of t = 1000, whilst this is far from the case in the uRNN. Again, this suggests that the LSTM\u2019s capacity to use new information to alter its hidden state severly degrades with sequence length. The uRNN does not suffer from this difficulty nearly as badly.\nA clear example of this phenomenon was observed in the adding problem with T = 750. We found that the Pearson correlation between the LSTM output prediction and the first of the two uniform samples (whose sum is the target output) was \u03c1 = 0.991. This suggests that the LSTM learnt to simply find and store the first sample, as it was unable to incorporate any more information by the time it reached the second, due to saturation of the hidden states."}, {"heading": "6 DISCUSSION", "text": "There are a plethora of further ideas that may be explored from our findings, both with regards to learning representation and efficient implementation. For example, one hurdle of modeling long sequences with recurrent networks is the requirement of storing all hidden state values for the purpose of gradient backpropagation. This can be prohibitive, since GPU memory is typically a limiting factor of neural network optimization. However, since our weight matrix is unitary, its inverse is its conjugate transpose, which is just as easy to operate with. If further we were to use an invertible nonlinearity function, we would no longer need to store hidden states, since they can be recomputed in the backward pass. This could have potentially huge implications, as we would be able to reduce memory usage by an order of T , the number of time steps. This would make having immensely large hidden layers possible, perhaps enabling vast memory representations.\nIn this paper we demonstrate state of the art performance on hard problems requiring long term reasoning and memory. These results are based on a novel parameterization of unitary matrices which permit efficient matrix computations and parameter optimization. Whilst complex domain modeling has been widely succesful in the signal processing community (e.g. Fourier transforms, wavelets), we have yet to exploit the power of complex valued representation in the deep learning community. Our hope is that this work will be a step forward in this direction. We motivate the idea of unitary evolution as a novel way to mitigate the problems of vanishing and exploding gradients. Empirical evidence suggests that our uRNN is better able to pass gradient information through long sequences and does not suffer from saturating hidden states as much as LSTMs, typical RNNs, or RNNs initialized with the identity weight matrix (IRNNs).\nAcknowledgments: We thank the developers of Theano Bergstra et al. (2010) for their great work. We thank NSERC, Compute Canada, Canada Research Chairs and CIFAR for their support."}], "references": [{"title": "Learning long-term dependencies with gradient descent is difficult", "author": ["Bengio", "Yoshua", "Simard", "Patrice", "Frasconi", "Paolo"], "venue": "IEE Transactions on Neural Networks,", "citeRegEx": "Bengio et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 1994}, {"title": "Theano: a CPU and GPU math expression compiler", "author": ["Bergstra", "James", "Breuleux", "Olivier", "Bastien", "Fr\u00e9d\u00e9ric", "Lamblin", "Pascal", "Pascanu", "Razvan", "Desjardins", "Guillaume", "Turian", "Joseph", "Warde-Farley", "David", "Bengio", "Yoshua"], "venue": "Proceedings of the Python for Scientific Computing Conference (SciPy),", "citeRegEx": "Bergstra et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bergstra et al\\.", "year": 2010}, {"title": "On the properties of neural machine translation: Encoder\u2013Decoder approaches", "author": ["Cho", "Kyunghyun", "van Merri\u00ebnboer", "Bart", "Bahdanau", "Dzmitry", "Bengio", "Yoshua"], "venue": "In Eighth Workshop on Syntax, Semantics and Structure in Statistical Translation,", "citeRegEx": "Cho et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cho et al\\.", "year": 2014}, {"title": "Natural language processing (almost) from scratch", "author": ["Collobert", "Ronan", "Weston", "Jason", "Bottou", "L\u00e9on", "Karlen", "Michael", "Kavukcuoglu", "Koray", "Kuksa", "Pavel"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Collobert et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2011}, {"title": "Understanding the difficulty of training deep feedforward neural networks", "author": ["Glorot", "Xavier", "Bengio", "Yoshua"], "venue": "International Conference on Artificial Intelligence and Statistics (AISTATS),", "citeRegEx": "Glorot et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Glorot et al\\.", "year": 2010}, {"title": "Deep sparse rectifier neural networks", "author": ["Glorot", "Xavier", "Bordes", "Antoine", "Bengio", "Yoshua"], "venue": "International Conference on Artificial Intelligence and Statistics (AISTATS),", "citeRegEx": "Glorot et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Glorot et al\\.", "year": 2011}, {"title": "Neural turing machines", "author": ["Graves", "Alex", "Wayne", "Greg", "Danihelka", "Ivo"], "venue": "arXiv preprint arXiv:1410.5401,", "citeRegEx": "Graves et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Graves et al\\.", "year": 2014}, {"title": "Deep neural networks for acoustic modeling in speech recognition", "author": ["Hinton", "Geoffrey", "Deng", "Li", "Yu", "Dong", "Dahl", "George", "Mohamed", "Abdel-rahman", "Jaitly", "Navdeep", "Senior", "Andrew", "Vanhoucke", "Vincent", "Nguyen", "Patrick", "Sainath", "Tara", "Kingsbury", "Brian"], "venue": "Signal Processing Magazine,", "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "Complex-valued neural networks: theories and applications, volume 5", "author": ["Hirose", "Akira"], "venue": "World Scientific Publishing Company Incorporated,", "citeRegEx": "Hirose and Akira.,? \\Q2003\\E", "shortCiteRegEx": "Hirose and Akira.", "year": 2003}, {"title": "Untersuchungen zu dynamischen neuronalen Netzen", "author": ["S. Hochreiter"], "venue": "Diploma thesis, T.U. Mu\u0308nich,", "citeRegEx": "Hochreiter,? \\Q1991\\E", "shortCiteRegEx": "Hochreiter", "year": 1991}, {"title": "Long short-term memory", "author": ["Hochreiter", "Sepp", "Schmidhuber", "J\u00fcrgen"], "venue": "Neural Computation,", "citeRegEx": "Hochreiter et al\\.,? \\Q1994\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 1994}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["Krizhevsky", "Alex", "Sutskever", "Ilya", "Hinton", "Geoffrey E"], "venue": "Neural Information Processing Systems,", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Fastfood - approximating kernel expansions in loglinear time", "author": ["Le", "Quoc", "Sarl\u00f3s", "Tam\u00e1s", "Smola", "Alex"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Le et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Le et al\\.", "year": 2010}, {"title": "A simple way to initialize recurrent networks of rectified linear units", "author": ["Le", "Quoc V", "Navdeep", "Jaitly", "Hinton", "Geoffrey E"], "venue": "arXiv preprint arXiv:1504.00941,", "citeRegEx": "Le et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Le et al\\.", "year": 2015}, {"title": "Gradient-based learning applied to document recognition", "author": ["LeCun", "Yann", "Bottou", "L\u00e9on", "Bengio", "Yoshua", "Haffner", "Patrick"], "venue": "Proceedings of the IEEE,", "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Learning recurrent neural networks with hessian-free optimization", "author": ["Martens", "James", "Sutskever", "Ilya"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Martens et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Martens et al\\.", "year": 2011}, {"title": "Rectified linear units improve restricted boltzmann machines", "author": ["Nair", "Vinod", "Hinton", "Geoffrey E"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Nair et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2010}, {"title": "On the difficulty of training recurrent neural networks", "author": ["Pascanu", "Razvan", "Mikolov", "Tomas", "Bengio", "Yoshua"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Pascanu et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Pascanu et al\\.", "year": 2010}, {"title": "Exact solutions to the nonlinear dynamics of learning in deep linear neural networks", "author": ["Saxe", "Andrew M", "McLelland", "James L", "Ganguli", "Surya"], "venue": "International Conference in Learning Representations,", "citeRegEx": "Saxe et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Saxe et al\\.", "year": 2014}, {"title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude", "author": ["Tieleman", "Tijmen", "Hinton", "Geoffrey"], "venue": "Coursera: Neural Networks for Machine Learning,", "citeRegEx": "Tieleman et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Tieleman et al\\.", "year": 2012}, {"title": "Deep fried convnets", "author": ["Yang", "Zichao", "Moczulski", "Marcin", "Denil", "Misha", "de Freitas", "Nando", "Smola", "Alex", "Song", "Le", "Wang", "Ziyu"], "venue": "International Conference on Computer Vision (ICCV),", "citeRegEx": "Yang et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Yang et al\\.", "year": 2015}, {"title": "Comparison of the complex valued and real valued neural networks trained with gradient descent and random search algorithms", "author": ["Zimmermann", "Hans-Georg", "Minin", "Alexey", "Kusherbaeva", "Victoria"], "venue": "ESANN,", "citeRegEx": "Zimmermann et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zimmermann et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 7, "context": "Deep Neural Networks have shown remarkably good performance on a wide range of complex data problems including speech recognition (Hinton et al., 2012), image recognition (Krizhevsky et al.", "startOffset": 130, "endOffset": 151}, {"referenceID": 11, "context": ", 2012), image recognition (Krizhevsky et al., 2012) and natural language processing (Collobert et al.", "startOffset": 27, "endOffset": 52}, {"referenceID": 3, "context": ", 2012) and natural language processing (Collobert et al., 2011).", "startOffset": 40, "endOffset": 64}, {"referenceID": 0, "context": "Although the long-term dependencies problem appears intractable in the absolute (Bengio et al., 1994) for parametrized dynamical systems, several heuristics have recently been found to help reduce its effect, such as the use of self-loops and gating units in the LSTM (Hochreiter & Schmidhuber, 1994) and GRU (Cho et al.", "startOffset": 80, "endOffset": 101}, {"referenceID": 2, "context": ", 1994) for parametrized dynamical systems, several heuristics have recently been found to help reduce its effect, such as the use of self-loops and gating units in the LSTM (Hochreiter & Schmidhuber, 1994) and GRU (Cho et al., 2014) recurrent architectures.", "startOffset": 215, "endOffset": 233}, {"referenceID": 18, "context": "Recent work also supports the idea of using orthogonal weight matrices to assist optimization (Saxe et al., 2014; Le et al., 2015).", "startOffset": 94, "endOffset": 130}, {"referenceID": 13, "context": "Recent work also supports the idea of using orthogonal weight matrices to assist optimization (Saxe et al., 2014; Le et al., 2015).", "startOffset": 94, "endOffset": 130}, {"referenceID": 1, "context": ", 2012) and natural language processing (Collobert et al., 2011). However, training very deep models remains a difficult task. The main issue surrounding the training of deep networks is the vanishing and exploding gradients problems introduced by Hochreiter (1991) and shown by Bengio et al.", "startOffset": 41, "endOffset": 266}, {"referenceID": 0, "context": "The main issue surrounding the training of deep networks is the vanishing and exploding gradients problems introduced by Hochreiter (1991) and shown by Bengio et al. (1994) to be necessarily arising when trying to learn to reliably store bits of information in any parametrized dynamical system.", "startOffset": 152, "endOffset": 173}, {"referenceID": 0, "context": "The main issue surrounding the training of deep networks is the vanishing and exploding gradients problems introduced by Hochreiter (1991) and shown by Bengio et al. (1994) to be necessarily arising when trying to learn to reliably store bits of information in any parametrized dynamical system. If gradients propagated back through a network vanish, the credit assignment role of backpropagation is lost, as information about small changes in states in the far past has no influence on future states. If gradients explode, gradient-based optimization algorithms struggle to traverse down a cost surface, because gradient-based optimization assumes small changes in parameters yield small changes in the objective function. As the number of time steps considered in the sequence of states grows, the shrinking or expanding effects associated with the state-to-state transformation at individual time steps can grow exponentially, yielding respectively vanishing or exploding gradients. See Pascanu et al. (2010) for a review.", "startOffset": 152, "endOffset": 1012}, {"referenceID": 21, "context": "Complex valued representations have been considered for neural networks in the past, but with limited success and adoption (Hirose, 2003; Zimmermann et al., 2011).", "startOffset": 123, "endOffset": 162}, {"referenceID": 1, "context": "Whilst our model uses complex valued matrices and parameters, all implementation and optimization is possible with real numbers and has been done in Theano (Bergstra et al., 2010).", "startOffset": 156, "endOffset": 179}, {"referenceID": 5, "context": "This argument makes the rectified linear unit (ReLU) nonlinearity an attractive choice (Glorot et al., 2011; Nair & Hinton, 2010).", "startOffset": 87, "endOffset": 129}, {"referenceID": 17, "context": "Most notably, this result holds for a network of arbitrary depth and renders engineering tricks like gradient clipping unnecessary (Pascanu et al., 2010).", "startOffset": 131, "endOffset": 153}, {"referenceID": 0, "context": "Bengio et al. (1994) suggest that having a large memory may be crucial for solving difficult tasks with long ranging dependencies: the smaller the state dimension, the more information necessarily has to be eliminated when mapping a long sequence to a fixed-dimension state.", "startOffset": 0, "endOffset": 21}, {"referenceID": 12, "context": "This combined with earlier work (Le et al., 2010) suggests that it is possible to create highly expressive matrices by composing simple matrices with few parameters.", "startOffset": 32, "endOffset": 49}, {"referenceID": 18, "context": "Yang et al. (2015) construct a real valued, non-orthogonal matrix using a similar parameterization with the motivation of parameter reduction by an order of magnitude on an industrial sized network.", "startOffset": 0, "endOffset": 19}, {"referenceID": 18, "context": "This implies that at initialization, the network is linear with unitary weights, which seems to help early optimization (Saxe et al., 2014).", "startOffset": 120, "endOffset": 139}, {"referenceID": 13, "context": "In this section we explore the performance of our uRNN in relation to (a) RNN with tanh activations, (b) IRNN (Le et al., 2015), that is an RNN with ReLU activations and with the recurrent weight matrix initialized to the identity, and (c) LSTM (Hochreiter & Schmidhuber, 1994) models.", "startOffset": 110, "endOffset": 127}, {"referenceID": 13, "context": "The tasks were especially created to be be pathologically hard, and have been used as benchmarks for testing the ability of a model to capture long-term memory (Hochreiter & Schmidhuber, 1994; Le et al., 2015; Graves et al., 2014; Martens & Sutskever, 2011) Of the handful of optimization algorithms we tried on the various models, RMSProp (Tieleman & Hinton, 2012) lead to fastest convergence and is what we stuck to for all experiments here on in.", "startOffset": 160, "endOffset": 257}, {"referenceID": 6, "context": "The tasks were especially created to be be pathologically hard, and have been used as benchmarks for testing the ability of a model to capture long-term memory (Hochreiter & Schmidhuber, 1994; Le et al., 2015; Graves et al., 2014; Martens & Sutskever, 2011) Of the handful of optimization algorithms we tried on the various models, RMSProp (Tieleman & Hinton, 2012) lead to fastest convergence and is what we stuck to for all experiments here on in.", "startOffset": 160, "endOffset": 257}, {"referenceID": 0, "context": "Recurrent networks have been known to have trouble remembering information about inputs seen many time steps previously (Bengio et al., 1994; Pascanu et al., 2010).", "startOffset": 120, "endOffset": 163}, {"referenceID": 17, "context": "Recurrent networks have been known to have trouble remembering information about inputs seen many time steps previously (Bengio et al., 1994; Pascanu et al., 2010).", "startOffset": 120, "endOffset": 163}, {"referenceID": 0, "context": "Recurrent networks have been known to have trouble remembering information about inputs seen many time steps previously (Bengio et al., 1994; Pascanu et al., 2010). We therefore want to test the uRNN\u2019s ability to recall exactly data seen a long time ago. Following a similar setup to Hochreiter & Schmidhuber (1994), we outline the copy memory task.", "startOffset": 121, "endOffset": 316}, {"referenceID": 6, "context": "This behaviour is consistent with the results of Graves et al. (2014), in which poor performance is reported for the LSTM for a very similar long term memory problem.", "startOffset": 49, "endOffset": 70}, {"referenceID": 9, "context": "We closely follow the adding problem defined in Hochreiter & Schmidhuber (1994) to explain the task at hand.", "startOffset": 48, "endOffset": 80}, {"referenceID": 9, "context": "We closely follow the adding problem defined in Hochreiter & Schmidhuber (1994) to explain the task at hand. Each input consists of two sequences of length T . The first sequence, which we denote x, consists of numbers sampled uniformly at random U [0, 1]. The second sequence is an indicator sequence consisting of exactly two entries of 1 and remaining entries 0. The first 1 entry is located uniformly at random in the first half of the sequence, whilst the second 1 entry is located uniformly at random in the second half. The output is the sum of the two entries of the first sequence, corresponding to where the 1 entries are located in the second sequence. A naive strategy of predicting 1 as the output regardless of the input sequence gives an expected mean squared error of 0.167, the variance of the sum of two independent uniform distributions. This is our baseline to beat. We chose to use 128 hidden units for the RNN with tanh, IRNN and LSTM and 512 for the uRNN. This equates to roughly 16K parameters for the RNN with tanh and IRNN, 60K for the LSTM and almost 9K for the uRNN. All models were trained using batch sizes of 20 and 50 with the best results being reported. Our results are shown in Figure 2. The LSTM and uRNN models are able to convincingly beat the baseline up to T = 400 time steps. Both models do well when T = 750, but the mean squared error does not reach close to 0. The uRNN achieves lower test error, but with more noise at testing. Despite having vastly more parameters, we monitored the LSTM performance to ensure no overfitting. The RNN with tanh and IRNN were not able to beat the baseline for any number of time steps. Le et al. (2015) report that their RNN solve the problem for T = 150 and the IRNN for T = 300, but they require over a million iterations before they start learning.", "startOffset": 48, "endOffset": 1681}, {"referenceID": 12, "context": "explained by our use of RMSprop with significantly higher learning rates (10\u22123 as opposed to 10\u22128) than Le et al. (2015) use for SGD with momentum.", "startOffset": 104, "endOffset": 121}, {"referenceID": 14, "context": "(2015), algorithms are fed pixels of MNIST (LeCun et al., 1998) sequentially and required to output a class label at the end.", "startOffset": 43, "endOffset": 63}, {"referenceID": 13, "context": "This result is state of the art on this task, beating the IRNN (Le et al., 2015), which reaches close to 82% after 1 million training iterations.", "startOffset": 63, "endOffset": 80}, {"referenceID": 12, "context": "In this task, suggested by Le et al. (2015), algorithms are fed pixels of MNIST (LeCun et al.", "startOffset": 27, "endOffset": 44}, {"referenceID": 1, "context": "Acknowledgments: We thank the developers of Theano Bergstra et al. (2010) for their great work.", "startOffset": 51, "endOffset": 74}], "year": 2015, "abstractText": "Recurrent neural networks (RNNs) are notoriously difficult to train. When the eigenvalues of the hidden to hidden weight matrix deviate from absolute value 1, optimization becomes difficult due to the well studied issue of vanishing and exploding gradients, especially when trying to learn long-term dependencies. To circumvent this problem, we propose a new architecture that learns a unitary weight matrix, with eigenvalues of absolute value exactly 1. The challenge we address is that of parametrizing unitary matrices in a way that does not require expensive computations (such as eigendecomposition) after each weight update. We construct an expressive unitary weight matrix by composing several structured matrices that act as building blocks with parameters to be learned. Optimization with this parameterization becomes feasible only when considering hidden states in the complex domain. We demonstrate the potential of this architecture by achieving state of the art results in several hard tasks involving very long-term dependencies.", "creator": "LaTeX with hyperref package"}}}