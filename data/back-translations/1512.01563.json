{"id": "1512.01563", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Dec-2015", "title": "State of the Art Control of Atari Games Using Shallow Reinforcement Learning", "abstract": "The recently introduced Deep Q-Networks (DQN) algorithm has gained attention as one of the first successful combinations of Deep Q-Networks and reinforcement learning, and its promise was demonstrated in the Arcade Learning Environment (ALE), a challenging framework of dozens of Atari 2600 games designed to evaluate general artificial intelligence skills. It achieved dramatically better results than previous approaches and shows that its ability to learn good representations is fairly robust and general. This paper seeks to understand the principles underlying DQN's impressive performance and better contextualize its success. We systematically evaluate the importance of important representative distortions encoded by the DQN network by proposing simple linear representations that use these concepts. By incorporating these features, we get a computational set of functionality that delivers competitive performance for DQN in ALE.", "histories": [["v1", "Fri, 4 Dec 2015 21:06:04 GMT  (632kb,D)", "http://arxiv.org/abs/1512.01563v1", null], ["v2", "Thu, 21 Apr 2016 21:55:54 GMT  (384kb,D)", "http://arxiv.org/abs/1512.01563v2", "A shorter version of this paper appears in the Proceedings of the 15th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2016)"]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["yitao liang", "marlos c machado", "erik talvitie", "michael bowling"], "accepted": false, "id": "1512.01563"}, "pdf": {"name": "1512.01563.pdf", "metadata": {"source": "CRF", "title": "State of the Art Control of Atari Games Using Shallow Reinforcement Learning", "authors": ["Yitao Liang", "Marlos C. Machado", "Erik Talvitie", "Michael Bowling"], "emails": ["erik.talvitie}@fandm.edu", "mbowling}@ualberta.ca"], "sections": [{"heading": null, "text": "Categories and Subject Descriptors I.2.6 [Learning]: Miscellaneous\nGeneral Terms Algorithms, Performance\nKeywords Reinforcement Learning, Function Approximation, DQN, Representation Learning, Arcade Learning Environment"}, {"heading": "1. INTRODUCTION", "text": "In the reinforcement learning (RL) problem an agent autonomously learns a behavior policy from experience in order to maximize a provided reward signal. Most successful RL approaches have relied upon the engineering of problemspecific state representations, diminishing the agent as fully autonomous and reducing its flexibility. The recent Deep Q-Network (DQN) algorithm [19] aims to tackle this problem, presenting one of the first successful combinations of\nSubmitted to the 15th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2016), John Thangarajah, Karl Tuyls, Stacy Marsella, Catholijn Jonker (eds.), May 9\u201313, 2016, Singapore.\nRL and deep convolutional neural-networks (CNN) [14, 13], which are proving to be a powerful approach to representation learning in many areas. DQN is based upon the well-known Q-learning algorithm [29] and uses a CNN to simultaneously learn a problem-specific representation and estimate a value function.\nGames have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26]. DQN follows this tradition, demonstrating its success by achieving human-level performance in the majority of games within the Arcade Learning Environment (ALE) [2]. The ALE is a platform composed of dozens of qualitatively diverse Atari 2600 games. As pictured in Figure 1, the games in this suite include first-person perspective shooting games (e.g. Battle Zone), platforming puzzle games (e.g. Montezuma\u2019s Revenge), sports games (e.g. Ice Hockey), and many other genres. Because of this diversity, successful approaches in the ALE necessarily exhibit a degree of robustness and generality. Further, because it is based on problems designed by humans for humans, the ALE inherently encodes some of the biases that allow humans to successfully navigate the world, making it a potential stepping-stone to other, more complex decisionmaking problems, especially those with visual input.\nDQN\u2019s success in the ALE rightfully attracted a great deal of attention. It achieved by far the best results at the time in this challenging domain, demonstrating generality across many diverse problems. It also demonstrated a successful large scale integration of deep neural networks and RL, surely an important step toward more flexible agents. That said, problematic aspects of DQN\u2019s evaluation make it difficult to fully interpret the results. As will be discussed in more detail in Section 6, the DQN experiments exploit nonstandard game-specific prior information performance and also report only one independent trial per game, making it difficult to reproduce these results or to make principled comparisons to other methods. In fact, early follow-up work already indicates that researchers may be unable to robustly match the single trial performance reported in the DQN paper [12]. Furthermore, the comparisons that Mnih et al. did present were to benchmarks using far less training data. Without an adequate baseline for what is achievable using simpler techniques, it is difficult to evaluate the cost-benefit ratios of more complex methods like DQN.\nIn addition to these methodological concerns, the evaluation of a complicated method such as DQN often leaves open the question of which of its properties were most important to its success. While it is tempting to assume that\nar X\niv :1\n51 2.\n01 56\n3v 1\n[ cs\n.L G\n] 4\nD ec\n2 01\n5\nthe neural network must be discovering insightful tailored representations for each game, there is also a considerable amount of domain knowledge embedded in the very structure of the network. We can identify three key structural biases in DQN\u2019s representation. First, CNNs provide a form of spatial invariance not exploited in earlier work using linear function approximation. DQN also made use of multiple frames of input allowing for the representation of short-range non-Markovian value functions. Finally, small-sized convolutions are quite well suited to detecting small patterns of pixels that commonly represent objects in early video game graphics. These biases were not fully explored in earlier work in the ALE, so a natural question is whether non-linear deep network representations are key to strong performance in ALE or whether the general principles implicit in DQN\u2019s network architecture might be captured more simply.\nThe primary goal of this paper is to systematically investigate the sources of DQN\u2019s success in the ALE. Obtaining a deeper understanding of the core principles influencing DQN\u2019s performance and placing its impressive results in perspective should aid practitioners aiming to apply or extend it (whether in the ALE or in other domains). It should also reveal representational issues that are key to success in the ALE itself, potentially inspiring new directions of research.\nWe perform our investigation by elaborating upon a simple linear representation that was one of DQN\u2019s main comparison points, progressively incorporating the representational biases identified above and evaluating the impact of each one. This process ultimately yields a fixed, generic feature representation able to obtain performance competitive to DQN in the ALE, suggesting that the general form of the representations learned by DQN may in many cases be more important than the specific features it learns. Further, this feature set offers a simple and computationally practical alternative to DQN as a platform for future research, especially when the focus is not on representation learning. Finally, we are able provide an alternative state-of-the-art benchmark that is more methodologically sound, easing reproducibility and comparison to future work."}, {"heading": "2. BACKGROUND", "text": "In this section we introduce the reinforcement learning problem setting and describe existing results in the ALE."}, {"heading": "2.1 Reinforcement Learning", "text": "In the reinforcement learning (RL) problem [24, 25] an agent interacts with an unknown environment and attempts to maximize a \u201creward\u201d signal. The environment is commonly formalized as a Markov decision process (MDP) M defined as a 5-tuple M = \u3008S,A,R, P, \u03b3\u3009. At time t the agent is in the state st \u2208 S where it takes an action at \u2208 A that leads to the next state st+1 \u2208 S according to the transition probability kernel P , which encodes Pr(st+1|st, at).\nThe agent also observes a reward rt+1 \u223c R(st, at, st+1). The agent\u2019s goal is to learn the optimal policy, a conditional distribution \u03c0(a|s) that maximizes the state value function V \u03c0(s) . = E\u03c0 [\u2211\u221e k=0 \u03b3 krt+k+1|st = s ]\nfor all s \u2208 S, where \u03b3 \u2208 [0, 1) is known as the discount factor.\nAs a critical step toward improving a given policy \u03c0, it is common for reinforcement learning algorithms to learn its state-action value function, denoted:\nQ\u03c0(s, a) . = E\u03c0 [ R(st, at, st+1) + \u03b3V \u03c0(st+1) \u2223\u2223st=s, at=a]. However, in large problems it may be infeasible to learn a value for each state-action pair. To tackle this issue agents often learn an approximate value function: Q\u03c0(s, a; \u03b8) \u2248 Q\u03c0(s, a). A common approach uses linear function approximation (LFA) where Q\u03c0(s, a; \u03b8) = \u03b8>\u03c6(s, a), in which \u03b8 denotes the vector of weights and \u03c6(s, a) denotes a static feature representation of the state s when taking action a. However, this can also be done through non-linear function approximation methods, including neural networks.\nOne of the most popular reinforcement learning algorithms is Sarsa(\u03bb) [20]. It consists of learning an approximate action-value function while following a continually improving policy \u03c0. As the states are visited, and rewards are observed, the action-value function is updated and consequently the policy is improved since each update improves the estimative of the agent\u2019s expected return from state s, taking action a, and then following policy \u03c0 afterwards, i.e. Q\u03c0(s, a). The Sarsa(\u03bb) update equations, when using function approximation, are:\n\u03b4t = rt+1 + \u03b3Q(st+1, at+1; ~\u03b8t)\u2212Q(st, at; ~\u03b8t) ~et = \u03b3\u03bb~et\u22121 +\u2207Q(st, at; ~\u03b8t)\n~\u03b8t+1 = ~\u03b8t + \u03b1\u03b4t~et,\nwhere \u03b1 denotes the step-size, the elements of ~et are known as the eligibility traces, and \u03b4t is the temporal difference error. Theoretical results suggest that, as an on-policy method, Sarsa(\u03bb) may be more stable in the linear function approximation case than off-policy methods such as Q-learning, which are known to risk divergence [1, 10, 17]. These theoretical insights are confirmed in practice; Sarsa(\u03bb) seems to be far less likely to diverge in the ALE than Q-learning and other off-policy methods [7]."}, {"heading": "2.2 Arcade Learning Environment", "text": "In the Arcade Learning Environment agents have access only to sensory information (160 pixels wide by 210 pixels high images) and aim to maximize the score of the game being played using the 18 actions on a standard joystick without game-specific prior information. Note that in most games a single screen does not constitute Markovian state. That said, Atari 2600 games are deterministic, so the entire history of interaction fully determines the next screen. It is most common for ALE agents to base their decisions on only the most recent few screens.\n2.2.1 Linear Value Function Approximation Early work in the ALE focused on developing new generic\nfeature representations to be used with linear RL methods. Along with introducing the ALE itself, Bellemare et al. [2] presented an RL benchmark using four different feature sets obtained from the game screen. Basic features tile the screen and check if each of the available colours in the Atari 2600\nare active in each tile. BASS features add pairwise combinations of Basic features. DISCO features attempt to detect and classify objects on the screen in order to infer their positions and velocities. LSH simply applies Locally Sensitive Hashing [9] to raw Atari 2600 screens. Bellemare, Veness, and Bowling proposed an extension to the Basic feature set which involved identifying which parts of the screen were under the agents\u2019 direct control. This additional information is known as contingency awareness [3].\nThese feature sets were, for some time, the standard representations for Atari 2600 games, being directly used in other work [7, 15, 16] or serving as the base for more elaborate feature sets [4]. The feature representations presented in this paper follow the spirit of this early work. We use Basic features (formally described below) as a starting point, and attempt to capture pairwise spatial relationships between objects on the screen.\nBasic Features: To obtain Basic features we first divide the Atari 2600 screen into 16\u00d714 tiles of size 10\u00d715 pixels. For every tile (c, r) and color k, where c \u2208 {1, . . . , 16}, r \u2208 {1, . . . , 14}, and k \u2208 {1, . . . , 128}, we check whether color k is present within the tile (c, r), generating the binary feature \u03c6c,r,k. Intuitively, Basic features encode information like \u201cthere is a yellow pixel within the tile in the upper-right corner of the screen\u201d. There are 16 \u00d7 14 \u00d7 128 = 28,672 Basic features in total.\nIt can be computationally demanding to work directly with 160 \u00d7 210 pixel screens with a 128 color palette. To make the screen more sparse, following previous work (e.g. [2, 3]) we subtract the background from the screen at each frame before processing it. The background is precomputed using 18,000 samples obtained from random trajectories.\n2.2.2 Non-Linear Value Function Approximation The use of non-linear function approximation in the ALE\nis more recent. Veness et al. [28], for example, propose the use of compression techniques as a policy evaluation approach in RL, evaluating their method in the ALE. Soon after, the research landscape changed due to the success of using deep learning techniques to approximate the actionvalue functions, introduced by the DQN algorithm [18, 19]. DQN achieved 75% of a human player\u2019s score in the majority of games and this inspired much more work in the ALE using deep learning (e.g. [11, 22, 23]).\nDQN employs a deep convolutional neural network to represent the state-action value function Q. A deep convolutional network uses weight sharing to make it practical to learn a function of high-dimensional image input. Specifically, when processing the image a small network focused on a small region of the screen called a filter is applied at multiple positions on the screen. Its output at each position forms a new (smaller) image, which can then be processed by another filter, and so on. Multiple layers of convolution allow the network to detect patterns and relationships at progressively higher levels of abstraction. DQN\u2019s network uses three layers of convolution with multiple filters at each layer. The final result of those convolutions is then processed via a more standard fully connected feed-forward network. The convolutional aspect of the network allows the network to detect relationships like \u201cA bullet is near an alien here,\u201d where \u201cbullet\u201d and \u201calien\u201d can be position invariant concepts. The non-linear global layers allow it to\nrepresent whole-screen concepts such as \u201cA bullet is near an alien somewhere.\u201d This is the inspiration of our spatially invariant features (Section 3). Further, Mnih et al. actually provide the four most recent images as input to their network, allowing it to detect relationships through time (such as movement). This motivates our short-order-Markov features (Section 4). Finally, note that Basic features are essentially a simple convolution where the filters simply detect the presence of each color in their range. DQN\u2019s more sophisticated filters motivate our improvement of object detection for base features (Section 5)."}, {"heading": "3. SPATIAL INVARIANCE", "text": "Recall that Basic features detect the presence of each color in various regions of the screen. As discussed above, this can be seen as analogous to a single convolution with a crude filter. The BASS feature set, which was amongst the best performing representations before DQN\u2019s introduction encodes pairwise relationships between Basic features, still anchored at specific positions, so it is somewhat analogous to a second convolutional layer. But in many games the absolute positions of objects are not as important as their relative positions to each other. To investigate the effect of ignoring absolute position we impose a non-linearity over BASS (analogous to DQN\u2019s fully connected layers), specifically taking the max of BASS features over absolute position.\nWe call the resulting feature set Basic Pairwise Relative Offsets in Space (B-PROS) because it captures pairwise relative distances between objects in a single screen. More specifically, a B-PROS feature checks if there is a pair of Basic features with colors k1, k2 \u2208 {1, . . . , 128} separated by an offset (i, j), where \u221213 \u2264 i \u2264 13 and \u221215 \u2264 j \u2264 15. If so, \u03c6k1,k2,(i,j) is set to 1, meaning that a pixel of color k1 is contained within some block (c, r) and a pixel of color k2 is contained within the block (c + i, r + j). Intuitively, B-PROS features encode information like \u201cthere is a yellow pixel three tiles below a red pixel\u201d. The computational complexity of generating B-PROS features is similar to that of BASS, though ultimately fewer features are generated. Note that, as described, B-PROS contains redundant features (e.g. \u03c61,2,(4,0) and \u03c62,1,(\u22124,0)), but it is straightforward to eliminate them. The complete feature set is composed of the Basic features and the B-PROS features. After redundancy is eliminated, the B-PROS feature set has 6,885,440 features in total (28,672 + ((31\u00d7 27\u00d7 1282\u2212 128)/2 + 128)).\nNote that there have been other attempts to represent pairwise spatial relationships between objects, for instance DISCO [2] and contingency awareness features [3]. However, these existing attempts are complicated to implement, demanding to compute, and ultimately less effective (as will be seen below), most likely due to unreliable estimates of object positions."}, {"heading": "3.1 Empirical Evaluation", "text": "Our first set of experiments compares B-PROS to the previous state of the art in linear representations for the Atari 2600 [2, 3] in order to evaluate the impact of the nonlinearity applied to BASS. For the sake of comparison we follow Bellemare et al.\u2019s methodology [2]. Specifically, in 24 independent trials the agent was trained for 5000 episodes. After the learning phase we froze the weights and evaluated the learned policy by recording its average performance over 499 episodes. We report the average evaluation score\nacross the 24 trials. Following Bellemare et al., we defined a maximum length for each episode: 18,000 frames, i.e. five minutes of real-time play. Also, we used a frame-skipping technique, in which the agent selects actions and updates its value function every x frames, repeating the selected action for the next x \u2212 1 frames. This allows the agent to play approximately x times faster. Following Bellemare et al. we use x = 5 (DQN also uses a similar procedure).\nWe used Sarsa(\u03bb) with replacing traces and an -greedy policy. We performed a parameter sweep over nine games, which we call \u201ctraining\u201d games. The reported results use a decay rate \u03b3 = 0.99, an exploration rate = 0.01, a step-size \u03b1 = 0.5 and eligibility decay rate \u03bb = 0.9.\nTable 1 compares our agent to existing linear agents in our set of training games (note that Breakout, Enduro, Pong, and Q*Bert were not training games for the earlier methods). \u201cBest Linear\u201d denotes the best performance obtained among four different feature sets: Basic, BASS, DISCO and LSH [2]. For reference, in the \u201cCAF\u201d column we also include results obtained by contingency awareness features [3], as reported by Mnih et al. [19]. Note, that these results are not directly comparable because their agent was given 10,000 episodes of training (rather than 5000).\nB-PROS\u2019 performance surpasses the original benchmarks by a large margin and, except in one game, even surpasses the performance of CAF, despite being far simpler and training with half as much data. Further, some of the improvements represent qualitative breakthroughs. For instance, in Pong, B-PROS allows the agent to win the game with a score of 20-15 on average, while previous methods rarely scored more than a few points. In Enduro, the earlier methods seem to be stymied by a sudden change in dynamics after approximately 120 points, while B-PROS is consistently able to continue beyond that point.\nWhen comparing these features sets for all 53 games BPROS performs better on average than all of Basic, BASS, DISCO, and LSH in 77% (41/53) of the games. Again with less training data, B-PROS performs better on average than CAF in 77% (38/49) of the games in which CAF results were reported1. The dramatic improvement yielded by B-PROS clearly indicates that focusing on relative spatial relationships rather than absolute positions is vital to success in the ALE (and likely in other visual domains as well)."}, {"heading": "4. NON-MARKOVIAN FEATURES", "text": "B-PROS is capable of encoding relative distances between objects but it fails to encode movement, which can be a very\n1For reference, the full results with 53 games are available in Table 3 in the Appendix.\nimportant aspect of Atari games. For instance, the agent may need to know whether the ball is moving toward or away from the paddle in Pong. Previous linear representations similarly relied mainly on the most recent screen. In constrast, Mnih et al. use the four most recent screens as input, allowing DQN to represent short-order-Markov features of the game screens. In this section we present an extension to B-PROS that takes a similar approach, extracting information from the two most recent screens.\nBasic Pairwise Relative Offsets in Time (B-PROT) features represent pairwise relative offsets between Basic features obtained from the screen five frames in the past and Basic features from the current screen (i.e. PROT features). More specifically, for every pair of colors k1, k2 \u2208 {1, . . . , 128} and every offset (i, j), where \u221213 \u2264 i \u2264 13 and \u221215 \u2264 j \u2264 15, a binary B-PROT feature \u03c6k1,k2,(i,j) is 1 if a pixel of color k1 is contained within some block (c+ i, r+ j) on the screen five frames ago and a pixel of color k2 is contained within the block (c, r) in the current screen.\nThe B-PROST feature set contains Basic, B-PROS, and B-PROT features. Note that there are roughly twice as many B-PROT features as B-PROS because there are no redundant offsets. As such, B-PROST has a total of 20,598,848 sparse, binary features (6,885,440 + 31\u00d7 27\u00d7 1282)."}, {"heading": "4.1 Empirical Evaluation", "text": "In these experiments, we adopted an evaluation protocol similar to Mnih et al.\u2019s for the sake of comparison to DQN (see Section 6). Each agent was trained for 200,000,000 frames (equivalent to 40,000,000 decisions) over 24 independent trials. The learned policy in each trial was evaluated by recording its average performance in 499 episodes with no learning. We report the average evaluation score over the 24 trials. In an effort to make our results comparable to DQN\u2019s we also started each episode with a random number of \u201cno-op\u201d actions and restricted the agent to the minimal set of actions that have a unique effect in each game.\nThe first two columns of Table 2 present results using B-PROS and B-PROST in the training games. B-PROST outperforms B-PROS in all but one of the training games. One particularly dramatic improvement occurs in Pong; BPROS wins with a score of 20-9, on average, while B-PROST rarely allows the opponent to score at all. Another result worth noting is in Enduro. The randomized initial conditions seem to have significantly harmed the performance of B-PROS in this game, but B-PROST seems to be robust to this effect. When evaluated over all 49 games evaluated by Mnih et al. the average score using B-PROST is higher than that using B-PROS in 82% of the games (40/49)2. This clearly indicates the critical importance of non-Markov features to success in the ALE.\nBefore making a final comparison with DQN, we will make one more improvement to our representation."}, {"heading": "5. OBJECT DETECTION", "text": "Because Basic features encode the positions of individual pixels on the screen, both B-PROS and B-PROST features struggle to represent which pixels are part of the same object. On the other hand, DQN\u2019s network is capable of learning far more subtle filters. In order to measure the impact of improved low-level object detection, we consider a\n2The full results are available in Table 4 in the Appendix.\nsimple extension to Basic that exploits the fact that Atari screens often contain several contiguous regions of pixels of the same color. We call such groups of pixels\u201cblobs\u201d. Rather than directly represent the coarsened positions of pixels, we first process the screen to find a list of blobs. Blob features then represent the coarsened positions of blobs on the screen. Changing the \u201cprimitive\u201d features from Basic to Blob yields the Blob-PROST feature set.\nNote that blobs are a simplification; in many Atari games, as would be true in more natural images, objects consist of multiple close but separate blobs. Grouping only strictly contiguous pixels into each blob may generate redundant blobs that all represent a single object. As a simple means to address this we add a tolerance to the contiguity condition, i.e. we consider pixels that are in the same s\u00d7 s pixel square to be contiguous. This approach has an inherent trade-off. On the one hand, with sufficiently large s we may successfully represent each object with few blobs. Also, by reducing the number of blobs, we substantially decrease the number of primitive features, making Blob-PROS and BlobPROT features easier to compute. On the other hand, if s is too high then multiple distinct objects may be grouped together. In our experiments we set s to be 6 after an informal search using the set of training games. It is very likely that with a more systematic selection of s one can obtain better results than those reported here.\nWe define the position of a blob as the centroid of the blob\u2019s smallest bounding box. To generate the features, we first generate Blob features that are analogous to Basic features: we divide the screen into tiles of 4\u00d77 pixels and then for every color k and block (c, r), where c \u2208 {1, . . . , 40}, r \u2208 {1, . . . , 30} and k \u2208 {1, . . . , 128}, the Blob feature \u03c6c,r,k is 1 if the block (c, r) contains the centroid for some blob of color k. Note that we use a finer resolution than Basic. This is feasible only because of the extreme sparsity of blobs on the screen. The number of blobs in one frame ranged from 6 (Pong) to 412 (Battle Zone). This sparsity also makes the background subtraction step unnecessary; the background typically reduces to a handful of blobs itself.\nThe Blob-PROST feature set is then constructed from these primitive features in the same manner as B-PROST. There are 153,600 Blob features (40\u00d7 30\u00d7 128), 38,182,976 Blob-PROS features ((79 \u00d7 59 \u00d7 1282 \u2212 128)/2 + 128), and 76,365,824 Blob-PROT features (79\u00d759\u00d71282). This yields a total of 114,702,400 Blob-PROST features. Though the number of possible features is very large, most would never be generated due to the sparsity of blobs."}, {"heading": "5.1 Empirical Evaluation", "text": "The last column of Table 2 presents results using BlobPROST in the training games. In all but one of the training games, Blob-PROST outperformed both B-PROS and B-PROST on average. In 6 of the 9, Blob-PROST\u2019s average performance was statistically significantly better than B-PROST (using Welch\u2019s t-test with p < 0.05). Asterix is a game in which Blob-PROST notably fails; perhaps blob detection lumps together distinct objects in a harmful way. Q*Bert is a notable success; the scores of B-PROS and B-PROST indicate that they rarely complete the first level, while Blob-PROST\u2019s score indicates that it consistently clears the first level. Out of the 49 games evaluated by Mnih et al., Blob-PROST\u2019s average performance was higher than that of both B-PROS and B-PROST in 59% (29/49) of the games. Its performance was statistically significantly higher than that of B-PROST in 47% (23/49) of the games, showing the clear contribution of even simple improvements in object detection3. Though object detection itself is not a feature, it make all features based upon it carry more meaningful information that helps our agents better \u201cinterpret\u201d the screen."}, {"heading": "6. COMPARISON WITH DQN", "text": "The next set of experiments compare Blob-PROST to DQN, the current state of the art, showing that the three enhancements investigated above largely explain the performance gap between DQN and earlier LFA approaches. In performing this comparison, we must necessarily confront some problematic aspects of the original DQN evaluation (some of which we adopt for comparison\u2019s sake). In Section 7 we present a more methodologically sound ALE benchmark for comparison to future work."}, {"heading": "6.1 DQN Evaluation Methodology", "text": "In each game, Mnih et al. trained a DQN agent once for 200,000,000 frames. Rather than evaluating the learned policy after the whole learning phase completed (as in earlier work), they evaluated their agent\u2019s performance every 4,000,000 frames and selected the best performing weights. They reported the average and standard deviation of the scores of this best learned policy in 30 evaluation episodes.\nMnih et al. also restricted their agent to the minimal set of actions that have a unique effect in each game, game-specific prior information not exploited by earlier work in the ALE. Since in most games the minimal action set contains fewer actions than the full action set, agents with access to the minimal set may benefit from a faster effective learning rate (this is discussed further in Section 7).\nTo avoid overfitting to the Atari\u2019s determinism, DQN added a random number of\u201cno-op\u201dactions to the beginning of each training and evaluation episode: the number of \u201cno-ops\u201d was uniformly randomly selected from {1, . . . , 30}, before a new episode officially began.\nMnih et al. also modified when episodes ended. In many Atari games the player has a number of \u201clives\u201d and the game ends when they are exhausted. DQN employed the same episode termination criteria as Bellemare et al. [2], i.e. the end of the game or expiration of the 5 minute time limit, but during training also terminated episodes when the agent lost a life (another form of game-specific prior information). In games that use this mechanism (e.g. Breakout, Space\n3The full results are available in Table 4 in the Appendix.\nInvaders) this modification could have considerable impact. Since many games continue without other penalties when a life is lost, agents often struggle to develop an \u201cavoid death\u201d policy. This termination scheme made DQN more sensitive to\u201cdeath\u201dand thus increased its chances of learning to retain lives, and thereby gain more chances to obtain reward.\nThe DQN experimental methodology possesses three main problematic flaws. First, one cannot make statistical comparisons from a single trial. While Mnih et al. report a standard deviation, this only represents the amount of variation observed when executing the one chosen policy, and not variation observed over different independent executions of the inherently stochastic algorithm. DQN\u2019s consistently high performance across games suggests it does indeed regularly perform well, but the reported performance numbers on any particular game may not be representative of their expected performance. Second, selecting the best performing parameterization over the whole learning period is a significant deviation from typical RL methodology. Such a choice may be masking instability issues where learning performance is initially strong but later goes awry. This effect can occur even using comparatively stable linear function approximators. For example, Figure 2 shows 24 independent learning trials from the game Up \u2019n Down using our linear BlobPROST agent. Many learning trials in this game exhibit an agent steadily improving its performance before a sudden plummet from which it does not recover. General competency should include consistent and stable improvement over time, best measured by an agent\u2019s performance at the end of tranning. Third, using the minimal action set and termination on \u201cdeath\u201d amounts to the use of game-specific prior knowledge, which is against the spirit of ALE. Deviation from the established standard (without evaluation of the impact of the changes) hampers comparisons and the establishing of repeatable benchmarks, which we will return to in Section 7."}, {"heading": "6.2 Comparing Blob-PROST and DQN", "text": "As discussed in Section 4, for comparison\u2019s sake, we adopted a similar methodology. We did use the minimal action set, and did add random \u201cno-ops\u201d to the beginning of episodes, but we opted not to utilise the game-specific information about the life counter.\n6.2.1 Computational Cost We found that Blob-PROST is far more computationally\npractical than DQN. We compared the algorithms\u2019 resource\nneeds on 3.2GHz Intel Core i7-4790S CPUs. We ran them for 24 hours (to allow resource usage to stabilize), then measured their runtime and memory use.\nThe computational cost of our implementation of BlobPROST can vary from game to game. The runtime of our implementation ranged from 56 decisions per second (Alien) to 300 decisions per second (Star Gunner), that is 280- 1500 frames per second (many times real time speed). The memory utilization of our implementation ranged from 50MB (Pong) to 9GB (Battle Zone). Note that Battle Zone was an outlier; the next most memory intensive game (Star Gunner) used only 3.7GB of memory. Furthermore, the memory utilization of Blob-PROST can likely be effectively controlled by simplifying the color palette or through the use of feature hashing (e.g. [4]).\nIn contrast, we found DQN\u2019s computational cost to be quite consistent across games, running at a speed of approximately 5 decisions per second (i.e. 20 frames per second, 3 times slower than real time), and requiring approximately 9.8GB of memory. DQN already uses a reduced color palette and is not immediately amenable to feature hashing to control memory usage. On the other hand, it is amenable to GPU acceleration to improve runtime. Mnih et al. do not report DQN\u2019s runtime, accelerated or otherwise, but in recent follow-up work the GPU accelerated speed has been reported to be approximately 330 frames per second [27], still slower than the Blob-PROST agent in most games. Further note that obtaining enough GPUs to support multiple independent trials in all the games (necessary for statistical comparisons) is, in itself, a prohibitive cost.\n6.2.2 ALE Performance Because only one trial of DQN was reported in each game,\nand because of the prohibitively high computational cost of independently re-evaluating DQN, a principled comparison between our method and DQN is essentially impossible. Instead, we used a number of ad hoc measures aimed at forming an intuitive understanding of the relative capabilities of the two algorithms, based on available evidence.\nFirst, for each game we record how many trials of BlobPROST obtained evaluation scores greater than DQN\u2019s single trial. If we were to compare an algorithm to itself in this way, we would expect roughly 50% of the trials to have greater performance. In Table 5 (available in the Appendix), the column marked \u201c% trials > DQN\u201d reports the results. The average percentage of trials better than DQN, across all games, was 41%. That is, if you select a game uniformly randomly and run Blob-PROST, there is an estimated 41% chance that it will surpass DQN\u2019s reported score.\nSecond, in each game we compared Blob-PROST\u2019s middle trial (12th best) to the single reported DQN trial. If BlobPROST\u2019s evaluation score compares favorably to DQN in this trial then this suggests that scores like DQN\u2019s are typical for Blob-PROST. Again, if this method were used to compare an algorithm to itself, one would expect the middle trial to be better in roughly half of the games. In Table 5 the column marked \u201cMiddle trial\u201d reports the results. Blob-PROST\u2019s middle trial evaluation score was better than DQN\u2019s in 43% (21/49) of the games. In 3 of the games in which it performed worse, Blob-PROST\u2019s score was not stastically significantly different than DQN\u2019s. So in 49% of the games Blob-PROST\u2019s middle trial was either not different from or better than DQN\u2019s single reported trial.\nThird, in each game we compared Blob-PROST\u2019s best trial to the single DQN trial. Since it is possible that some of DQN\u2019s trials are high-performing outliers, this is intended to give a sense of the level of performance Blob-PROST is capable of reaching, regardless of whether it can do so consistently. In 65% (32/49) of the games, Blob-PROST\u2019s best trial\u2019s performance exceeded that of the DQN trial. Again, in three games in which Blob-PROST did worse, the difference was not statistically significant. So in 71% of the games Blob-PROST\u2019s best trial was either not different from or better than DQN\u2019s single reported trial.\nFinally, DQN\u2019s main result was achieving at least 75% of a human\u2019s performance in over half of the games (29/49). The best trial of Blob-PROST crossed this threshold in 34/49 games. The middle trial did so in only 20/49 games.\nThe Blob-PROST representation was generated using simple and natural enhancements to BASS (one of DQN\u2019s main comparison points) aimed at incorporating the same structual biases encoded by DQN\u2019s designer-provided network architecutre. All told, these results seem to indicate that this fixed representation is of comparable quality to DQN\u2019s learned representation across many games in the ALE."}, {"heading": "7. ALE BENCHMARK", "text": "As discussed above, besides better understanding the core issues underlying DQN\u2019s success in the ALE, it is important to present a reproducible benchmark without the problematic flaws discussed in Section 6 (i.e. one that reports more than one trial, evaluates the final set of weights, and eschews game-specific prior knowledge). Moreover, establishing this benchmark is important for the ALE\u2019s continued use as an evaluation platform. The principled evaluation of complicated approaches depends upon the existence of a sound baseline for what can be achieved with simple approaches.\nTo provide a benchmark free of game-specific information we also present the performance of Blob-PROST using the full action set, something Mnih et al. did not do. Our agents\u2019 average performance after 24 trials using the full action set is reported in the last column of Table 4 in the Appendix. We recommend that future comparisons to BlobPROST use these results. Surprisingly, we found that when using the full action set Blob-PROST performed slightly better in comparison to DQN using the measures described above than when using the minimal action set. It is not entirely clear why this would be; one possible explanation is that the presence of redundant actions may have a positive impact on exploration in some games. Nevertheless, a thorough understanding of this effect bears further investigation in the future."}, {"heading": "8. CONCLUSIONS AND FUTURE WORK", "text": "While it is difficult to draw firm conclusions, the results indicate the Blob-PROST\u2019s performance in the ALE is competitive to DQN\u2019s, albeit likely slightly worse overall. Most importantly, these results indicate we may have been able to capture some of the key features of DQN in a practical, fixed linear representation. We saw progressive and dramatic improvements by respectively incorporating relative distances between objects, non-Markov features, and more sophisticated object detection. This illuminates some important representational issues that likely underly DQN\u2019s success. It also suggests that the general properties of the\nrepresentations learned by DQN may be more important to its success in ALE than the specific features it learns in each game. This deeper understanding of the specific strengths of DQN should aid practitioners in determining when its benefits are likely to outweigh its costs.\nIt is important to note that we do not intend to diminish the importance of DQN as a seemingly stable combination of deep neural networks and RL. This is a promising and exciting research direction with potential applications in many domains. That said, taking into account the fact that DQN\u2019s performance may be inflated to an unknown degree as a result of evaluating the best performing set of weights, the fact of DQN\u2019s extreme computational cost, and the methodological issues underlying the reported DQN results, we conclude that Blob-PROST is a strong alternative candidate to DQN both as an ALE performance benchmark and as a platform on which to build future ALE agents when representation learning is not the topic being studied. Our results also suggest in general that fixed representations inspired by the principles underlying convolutional networks may yield competitive, lighter-weight alternatives.\nAs future work, it may be interesting to investigate the remaining discrepancies between our results and DQN\u2019s. In some games like Gravitar, Frostbite and Krull BlobPROST\u2019s performance was several times higher than DQN\u2019s, while the opposite was true in games such as Star Gunner, Breakout and Atlantis. In general, DQN seems to excel in shooting games (a large part of the games supported by the ALE), maybe because it is able to easily encode object velocities and to predict objects\u2019 future positions. DQN also excels on games that require a more holistic view of the whole screen (e.g. Breakout, Space Invaders), something pairwise features struggle with. On the other hand, some of the games in which Blob-PROST surpasses DQN are games where it is fairly easy to die, maybe because DQN interrupts the learning process after the agent loses a life. Other games Blob-PROST succeeds in are games where the return is very sparse (e.g. Tennis, Montezuma\u2019s Revenge). These games may generate very small gradients for the network, making it harder for an algorithm to learn both the representation and a good policy (or DQN\u2019s process of sampling from the experience memory may not be effective to draw the \u201cinteresting\u201d samples).\nThe conjectures above also suggest directions for future work. Adaptive representation methods may potentially benefit from these insights by building in stronger bias toward the types of features we have investigated here. This would allow them to quickly perform well, and then focus energy on learning exceptions to the rule. In the realm of linear methods, these results suggest that there may still be simple, generic enhancements that yield dramatic improvements. More sophisticated object detection schemes may be beneficial, as might features that encode more holistic views of the entire screen."}, {"heading": "Acknowledgements", "text": "This research was supported by Alberta Innovates Technology Futures and the Alberta Innovates Centre for Machine Learning. Computing resources were provided by Compute Canada through CalculQue\u0301bec.\nAPPENDIX"}, {"heading": "A. FULL RESULTS", "text": "The following tables report the complete results discussed in the paper. Table 3 reports the data used to compare B-PROS results to other linear feature representations\u2019 reported results (see Section 3). Table 4 presents the results of the three feature sets introduced in this paper (B-PROS, BPROST and Blob-PROST) as well as the results using BlobPROST with the full action set, which we recommend to be used as benchmark in the future (see Sections 4, 5 and 7). Finally, Table 5 reports the data used to compare BlobPROST to DQN\u2019s reported results (see Section 6)."}], "references": [{"title": "Residual Algorithms: Reinforcement Learning with Function Approximation", "author": ["III L.C. Baird"], "venue": "Proceedings of the International Conference on Machine Learning (ICML), pages 30\u201337", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "The Arcade Learning Environment: An Evaluation Platform for General Agents", "author": ["M.G. Bellemare", "Y. Naddaf", "J. Veness", "M. Bowling"], "venue": "Journal of Artificial Intelligence Research, 47:253\u2013279,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Investigating Contingency Awareness using Atari 2600 Games", "author": ["M.G. Bellemare", "J. Veness", "M. Bowling"], "venue": "Proceedings of the Twenty-Sixth Conference on Artificial Intelligence (AAAI), pages 864\u2013871", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Sketch-Based Linear Value Function Approximation", "author": ["M.G. Bellemare", "J. Veness", "M. Bowling"], "venue": "Proceedings of the Advances in Neural Information Processing Systems (NIPS), pages 2222\u20132230", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Heads-up Limit Hold\u2019em Poker is Solved", "author": ["M. Bowling", "N. Burch", "M. Johanson", "O. Tammelin"], "venue": "Science,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "A", "author": ["M. Campbell"], "venue": "J. H. Jr., and F.-H. Hsu. Deep Blue. Artificial Intelligence, 134(1\u00e2\u0102\u015e2):57 \u2013 83", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2002}, {"title": "A Comparison of Learning Algorithms on the Arcade Learning Environment", "author": ["A. Defazio", "T. Graepel"], "venue": "CoRR, abs/1410.8620", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Building Watson: An Overview of the DeepQA Project", "author": ["D.A. Ferrucci", "E.W. Brown", "J. Chu-Carroll", "J. Fan", "D. Gondek", "A. Kalyanpur", "A. Lally", "J.W. Murdock", "E. Nyberg", "J.M. Prager", "N. Schlaefer", "C.A. Welty"], "venue": "AI Magazine, 31(3):59\u201379", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Similarity Search in High Dimensions via Hashing", "author": ["A. Gionis", "P. Indyk", "R. Motwani"], "venue": "Proceedings of International Conference on Very Large Data Bases (VLDB), pages 518\u2013529", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1999}, {"title": "Reinforcement Learning with Function Approximation Converges to a Region", "author": ["G.J. Gordon"], "venue": "Proceedings of the Advances in Neural Information Processing Systems (NIPS), pages 1040\u20131046", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2000}, {"title": "Deep Learning for Real-Time Atari Game Play Using Offline Monte-Carlo Tree Search Planning", "author": ["X. Guo", "S.P. Singh", "H. Lee", "R.L. Lewis", "X. Wang"], "venue": "Proceedings of the Advances in Neural Information Processing Systems (NIPS), pages 3338\u20133346", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Deep Recurrent Q-Learning for Partially Observable MDPs", "author": ["M.J. Hausknecht", "P. Stone"], "venue": "CoRR, abs/1507.06527", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "ImageNet Classification with Deep Convolutional Neural Networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "Proceedings of the Advances in Neural Information Processing Systems (NIPS), pages 1106\u20131114", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Gradient-Based Learning Applied to Document Recognition", "author": ["Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner"], "venue": "Proceedings of the IEEE, 86(11):2278\u20132324", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1998}, {"title": "Classical Planning with Simulators: Results on the Atari Video Games", "author": ["N. Lipovetzky", "M. Ramirez", "H. Geffner"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI)", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Domain-Independent Optimistic Initialization for  Reinforcement Learning", "author": ["M.C. Machado", "S. Srinivasan", "M. Bowling"], "venue": "AAAI Workshop on Learning for General Competency in Video Games", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "An Analysis of Reinforcement Learning with Function Approximation", "author": ["F.S. Melo", "S.P. Meyn", "M.I. Ribeiro"], "venue": "Proceedings of the International Conference on Machine Learning (ICML), pages 664\u2013671", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2008}, {"title": "Playing Atari With Deep Reinforcement Learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A. Graves", "I. Antonoglou", "D. Wierstra", "M. Riedmiller"], "venue": "NIPS Deep Learning Workshop", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Human-level Control through Deep Reinforcement Learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski", "S. Petersen", "C. Beattie", "A. Sadik", "I. Antonoglou", "H. King", "D. Kumaran", "D. Wierstra", "S. Legg", "D. Hassabis"], "venue": "Nature, 518(7540):529\u2013533,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "On-line Q-Learning using Connectionist Systems", "author": ["G.A. Rummery", "M. Niranjan"], "venue": "CUED/F-INFENG/TR 166,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1994}, {"title": "Checkers is Solved", "author": ["J. Schaeffer", "N. Burch", "Y. Bj\u00f6rnsson", "A. Kishimoto", "M. M\u00fcller", "R. Lake", "P. Lu", "S. Sutphen"], "venue": "Science, 317(5844):1518\u20131522", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2007}, {"title": "Trust Region Policy Optimization", "author": ["J. Schulman", "S. Levine", "P. Abbeel", "M.I. Jordan", "P. Moritz"], "venue": "Proceedings of the International Conference on Machine Learning (ICML), pages 1889\u20131897", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Parameter Selection for the Deep Q-learning Algorithm ((Extended Abstract))", "author": ["N. Sprague"], "venue": "Proceedings of the Multidisciplinary Conference on Reinforcement Learning and Decision Making (RLDM)", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2015}, {"title": "Reinforcement Learning: An Introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": "MIT Press", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1998}, {"title": "Algorithms for Reinforcement Learning", "author": ["C. Szepesv\u00e1ri"], "venue": "Synthesis lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "Temporal Difference Learning and TD-Gammon", "author": ["G. Tesauro"], "venue": "Communications of the ACM,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1995}, {"title": "Deep Reinforcement Learning with Double Q-learning", "author": ["H. van Hasselt", "A. Guez", "D. Silver"], "venue": "CoRR, abs/1509.06461,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}, {"title": "Compress and Control", "author": ["J. Veness", "M.G. Bellemare", "M. Hutter", "A. Chua", "G. Desjardins"], "venue": "Proceedings of the Conference on Artificial Intelligence (AAAI)", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2015}, {"title": "Technical Note: Q-Learning", "author": ["C.J.C.H. Watkins", "P. Dayan"], "venue": "Machine Learning,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1992}], "referenceMentions": [{"referenceID": 18, "context": "The recent Deep Q-Network (DQN) algorithm [19] aims to tackle this problem, presenting one of the first successful combinations of", "startOffset": 42, "endOffset": 46}, {"referenceID": 13, "context": "RL and deep convolutional neural-networks (CNN) [14, 13], which are proving to be a powerful approach to representation learning in many areas.", "startOffset": 48, "endOffset": 56}, {"referenceID": 12, "context": "RL and deep convolutional neural-networks (CNN) [14, 13], which are proving to be a powerful approach to representation learning in many areas.", "startOffset": 48, "endOffset": 56}, {"referenceID": 28, "context": "DQN is based upon the well-known Q-learning algorithm [29] and uses a CNN to simultaneously learn a problem-specific representation and estimate a value function.", "startOffset": 54, "endOffset": 58}, {"referenceID": 4, "context": "Games have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26].", "startOffset": 122, "endOffset": 139}, {"referenceID": 5, "context": "Games have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26].", "startOffset": 122, "endOffset": 139}, {"referenceID": 7, "context": "Games have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26].", "startOffset": 122, "endOffset": 139}, {"referenceID": 20, "context": "Games have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26].", "startOffset": 122, "endOffset": 139}, {"referenceID": 25, "context": "Games have always been an important testbed for AI, frequently being used to demonstrate major contributions to the field [5, 6, 8, 21, 26].", "startOffset": 122, "endOffset": 139}, {"referenceID": 1, "context": "DQN follows this tradition, demonstrating its success by achieving human-level performance in the majority of games within the Arcade Learning Environment (ALE) [2].", "startOffset": 161, "endOffset": 164}, {"referenceID": 11, "context": "In fact, early follow-up work already indicates that researchers may be unable to robustly match the single trial performance reported in the DQN paper [12].", "startOffset": 152, "endOffset": 156}, {"referenceID": 23, "context": "In the reinforcement learning (RL) problem [24, 25] an agent interacts with an unknown environment and attempts to maximize a \u201creward\u201d signal.", "startOffset": 43, "endOffset": 51}, {"referenceID": 24, "context": "In the reinforcement learning (RL) problem [24, 25] an agent interacts with an unknown environment and attempts to maximize a \u201creward\u201d signal.", "startOffset": 43, "endOffset": 51}, {"referenceID": 19, "context": "One of the most popular reinforcement learning algorithms is Sarsa(\u03bb) [20].", "startOffset": 70, "endOffset": 74}, {"referenceID": 0, "context": "Theoretical results suggest that, as an on-policy method, Sarsa(\u03bb) may be more stable in the linear function approximation case than off-policy methods such as Q-learning, which are known to risk divergence [1, 10, 17].", "startOffset": 207, "endOffset": 218}, {"referenceID": 9, "context": "Theoretical results suggest that, as an on-policy method, Sarsa(\u03bb) may be more stable in the linear function approximation case than off-policy methods such as Q-learning, which are known to risk divergence [1, 10, 17].", "startOffset": 207, "endOffset": 218}, {"referenceID": 16, "context": "Theoretical results suggest that, as an on-policy method, Sarsa(\u03bb) may be more stable in the linear function approximation case than off-policy methods such as Q-learning, which are known to risk divergence [1, 10, 17].", "startOffset": 207, "endOffset": 218}, {"referenceID": 6, "context": "These theoretical insights are confirmed in practice; Sarsa(\u03bb) seems to be far less likely to diverge in the ALE than Q-learning and other off-policy methods [7].", "startOffset": 158, "endOffset": 161}, {"referenceID": 1, "context": "[2] presented an RL benchmark using four different feature sets obtained from the game screen.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "LSH simply applies Locally Sensitive Hashing [9] to raw Atari 2600 screens.", "startOffset": 45, "endOffset": 48}, {"referenceID": 2, "context": "This additional information is known as contingency awareness [3].", "startOffset": 62, "endOffset": 65}, {"referenceID": 6, "context": "These feature sets were, for some time, the standard representations for Atari 2600 games, being directly used in other work [7, 15, 16] or serving as the base for more elaborate feature sets [4].", "startOffset": 125, "endOffset": 136}, {"referenceID": 14, "context": "These feature sets were, for some time, the standard representations for Atari 2600 games, being directly used in other work [7, 15, 16] or serving as the base for more elaborate feature sets [4].", "startOffset": 125, "endOffset": 136}, {"referenceID": 15, "context": "These feature sets were, for some time, the standard representations for Atari 2600 games, being directly used in other work [7, 15, 16] or serving as the base for more elaborate feature sets [4].", "startOffset": 125, "endOffset": 136}, {"referenceID": 3, "context": "These feature sets were, for some time, the standard representations for Atari 2600 games, being directly used in other work [7, 15, 16] or serving as the base for more elaborate feature sets [4].", "startOffset": 192, "endOffset": 195}, {"referenceID": 1, "context": "[2, 3]) we subtract the background from the screen at each frame before processing it.", "startOffset": 0, "endOffset": 6}, {"referenceID": 2, "context": "[2, 3]) we subtract the background from the screen at each frame before processing it.", "startOffset": 0, "endOffset": 6}, {"referenceID": 27, "context": "[28], for example, propose the use of compression techniques as a policy evaluation approach in RL, evaluating their method in the ALE.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "Soon after, the research landscape changed due to the success of using deep learning techniques to approximate the actionvalue functions, introduced by the DQN algorithm [18, 19].", "startOffset": 170, "endOffset": 178}, {"referenceID": 18, "context": "Soon after, the research landscape changed due to the success of using deep learning techniques to approximate the actionvalue functions, introduced by the DQN algorithm [18, 19].", "startOffset": 170, "endOffset": 178}, {"referenceID": 10, "context": "[11, 22, 23]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 21, "context": "[11, 22, 23]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 22, "context": "[11, 22, 23]).", "startOffset": 0, "endOffset": 12}, {"referenceID": 1, "context": "Note that there have been other attempts to represent pairwise spatial relationships between objects, for instance DISCO [2] and contingency awareness features [3].", "startOffset": 121, "endOffset": 124}, {"referenceID": 2, "context": "Note that there have been other attempts to represent pairwise spatial relationships between objects, for instance DISCO [2] and contingency awareness features [3].", "startOffset": 160, "endOffset": 163}, {"referenceID": 1, "context": "Our first set of experiments compares B-PROS to the previous state of the art in linear representations for the Atari 2600 [2, 3] in order to evaluate the impact of the nonlinearity applied to BASS.", "startOffset": 123, "endOffset": 129}, {"referenceID": 2, "context": "Our first set of experiments compares B-PROS to the previous state of the art in linear representations for the Atari 2600 [2, 3] in order to evaluate the impact of the nonlinearity applied to BASS.", "startOffset": 123, "endOffset": 129}, {"referenceID": 1, "context": "\u2019s methodology [2].", "startOffset": 15, "endOffset": 18}, {"referenceID": 1, "context": "Bold denotes the largest value between B-PROS and Best Linear [2].", "startOffset": 62, "endOffset": 65}, {"referenceID": 1, "context": "\u201cBest Linear\u201d denotes the best performance obtained among four different feature sets: Basic, BASS, DISCO and LSH [2].", "startOffset": 114, "endOffset": 117}, {"referenceID": 2, "context": "For reference, in the \u201cCAF\u201d column we also include results obtained by contingency awareness features [3], as reported by Mnih et al.", "startOffset": 102, "endOffset": 105}, {"referenceID": 18, "context": "[19].", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "[2], i.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 26, "context": "do not report DQN\u2019s runtime, accelerated or otherwise, but in recent follow-up work the GPU accelerated speed has been reported to be approximately 330 frames per second [27], still slower than the Blob-PROST agent in most games.", "startOffset": 170, "endOffset": 174}, {"referenceID": 1, "context": "Bold indicates the best mean score in the first five columns, which were obtained using all the 18 actions available, after learning for 5,000 episodes and evaluating for 500 episodes [2].", "startOffset": 184, "endOffset": 187}, {"referenceID": 2, "context": "CAF denotes contingency awareness features [3].", "startOffset": 43, "endOffset": 46}], "year": 2017, "abstractText": "The recently introduced Deep Q-Networks (DQN) algorithm has gained attention as one of the first successful combinations of deep neural networks and reinforcement learning. Its promise was demonstrated in the Arcade Learning Environment (ALE), a challenging framework composed of dozens of Atari 2600 games used to evaluate general competency in AI. It achieved dramatically better results than earlier approaches, showing that its ability to learn good representations is quite robust and general. This paper attempts to understand the principles that underly DQN\u2019s impressive performance and to better contextualize its success. We systematically evaluate the importance of key representational biases encoded by DQN\u2019s network by proposing simple linear representations that make use of these concepts. Incorporating these characteristics, we obtain a computationally practical feature set that achieves competitive performance to DQN in the ALE. Besides offering insight into the strengths and weaknesses of DQN, we provide a generic representation for the ALE, significantly reducing the burden of learning a representation for each game. Moreover, we also provide a simple, reproducible benchmark for the sake of comparison to future work in the ALE.", "creator": "LaTeX with hyperref package"}}}