{"id": "1512.04097", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Dec-2015", "title": "Using Linear Constraints for Logic Program Termination Analysis", "abstract": "It is widely acknowledged that functional symbols are an important feature in programming response sentences, as they facilitate modeling, enhance meaningfulness, and allow us to deal with infinite areas. The main problem with their introduction is that the evaluation of a program may not end and whether or not it ends. To solve this problem, several classes of logical programs have been proposed that limit the use of functional symbols but guarantee the completion of program evaluation. Despite the extensive work in this area, current approaches do not include many simple practical programs whose evaluation ends. In this paper, we present the novel classes of rule and cycle-related programs that overcome different limitations of current approaches by performing a more comprehensive analysis of how terms are disseminated from the body to the head of the rules. Results on the correctness, complexity, and meaningfulness of the proposed approach are provided.", "histories": [["v1", "Sun, 13 Dec 2015 18:36:54 GMT  (56kb,D)", "https://arxiv.org/abs/1512.04097v1", "To appear in Theory and Practice of Logic Programming"], ["v2", "Tue, 15 Dec 2015 13:15:04 GMT  (56kb,D)", "http://arxiv.org/abs/1512.04097v2", "Under consideration in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "To appear in Theory and Practice of Logic Programming", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["marco calautti", "sergio greco", "cristian molinaro", "irina trubitsyna"], "accepted": false, "id": "1512.04097"}, "pdf": {"name": "1512.04097.pdf", "metadata": {"source": "CRF", "title": "Using Linear Constraints for Logic Program Termination Analysis", "authors": ["MARCO CALAUTTI", "SERGIO GRECO", "CRISTIAN MOLINARO", "IRINA TRUBITSYNA"], "emails": ["calautti@dimes.unical.it", "greco@dimes.unical.it", "cmolinaro@dimes.unical.it", "trubitsyna@dimes.unical.it"], "sections": [{"heading": null, "text": "KEYWORDS: Answer set programming, function symbols, bottom-up evaluation, program evaluation termination, stable models"}, {"heading": "1 Introduction", "text": "Enriching answer set programming with function symbols has recently seen a surge\nin interest. Function symbols make modeling easier, increase the expressive power,\nand allow us to deal with infinite domains. At the same time, this comes at a cost:\ncommon inference tasks (e.g., cautious and brave reasoning) become undecidable.\nRecent research has focused on identifying classes of logic programs that im-\npose some limitations on the use of function symbols but guarantee decidability\nof common inference tasks. Efforts in this direction are the class of finitely-ground\nprograms (Calimeri et al. 2008) and the more general class of bounded term-size\nprograms (Riguzzi and Swift 2013). Finitely-ground programs have a finite number\nof stable models, each of finite size, whereas bounded term-size (normal) programs\nhave a finite well-founded model. Unfortunately, checking if a logic program is\nbounded term-size or even finitely-ground is semi-decidable.\nar X\niv :1\n51 2.\n04 09\n7v 2\n[ cs\n.A I]\nConsidering the stable model semantics, decidable subclasses of finitely-ground\nprograms have been proposed. These include the classes of \u03c9-restricted programs (Syr-\njanen 2001), \u03bb-restricted programs (Gebser et al. 2007), finite domain programs (Cal-\nimeri et al. 2008), argument-restricted programs (Lierler and Lifschitz 2009), safe\nand \u0393-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted\nprograms (Calautti et al. 2013), and bounded programs (Greco et al. 2013a). The\nabove techniques, that we call termination criteria, provide (decidable) sufficient\nconditions for a program to be finitely-ground.\nDespite the significant body of work in this area, there are still many simple\npractical programs whose evaluation terminates but this is not detected by any of\nthe current termination criteria. Below is an example.\nExample 1\nConsider the following program P1 implementing the bubble sort algorithm:\nr0 : bub(L, [ ], [ ])\u2190 input(L). r1 : bub([Y|T], [X|Cur], Sol)\u2190 bub([X|[Y|T]], Cur, Sol), X \u2264 Y. r2 : bub([X|T], [Y|Cur], Sol)\u2190 bub([X|[Y|T]], Cur, Sol), Y < X. r3 : bub(Cur, [ ], [X|Sol])\u2190 bub([X|[ ]], Cur, Sol).\nThe list to be sorted is given by means of a fact of the form input([a1, ..., an]). The bottom-up evaluation of this program always terminates for any input list. The\nordered list Sol can be obtained from the atom bub([ ], [ ], Sol) in the program\u2019s\nminimal model. 2\nAlthough the bottom-up evaluation of P1 always terminates for any input list, none of the termination criteria in the literature is able to realize it. One problem\nwith them is that when they analyze how terms are propagated from the body to\nthe head of rules, they look at arguments individually. For instance, in rule r1 above, the simple fact that the second argument of bub has a size in the head greater than\nthe one in the body prevents several techniques from realizing termination of the bottom-up evaluation of P1. More general classes such as mapping-restricted and bounded programs are able to do a more complex (yet limited) analysis of how\nsome groups of arguments affect each other. Still, all current termination criteria are not able to realize that in every rule of P1 the overall size of the terms in the head does not increase w.r.t. the overall size of the terms in the body. One of the\nnovelties of the technique proposed in this paper is the capability of doing this kind\nof analysis, thereby identifying programs (whose evaluation terminates) that none\nof the current techniques include.\nThe technique proposed in this paper easily realizes that the bottom-up evaluation of P1 always terminates for any input list. In particular, this is done using linear constraints which measure the size of terms and atoms in order to check if\nthe rules\u2019 head sizes are bounded by the size of some body atom when propagation\noccurs. Thus, our technique can understand that, in every rule, the overall size\nof the terms in the body does not increase during their propagation to the head,\nas there is only a simple redistribution of terms. Many practical programs dealing\nwith lists and tree-like structures satisfy this property\u2014below are two examples.\nHowever, our technique is not limited only to this kind of programs.\nExample 2 Consider the program P2 below, performing a depth-first traversal of an input tree:\nr0 : visit(Tree, [ ], [ ])\u2190 input(Tree). r1 : visit(Left, [Root|Visited], [Right|ToVisit])\u2190\nvisit(tree(Root, Left, Right), Visited, ToVisit).\nr2 : visit(Next, Visited, ToVisit)\u2190 visit(null, Visited, [Next|ToVisit]).\nThe input tree is given by means of a fact of the form input(tree(value, left, right))\nwhere tree is a ternary function symbol used to represent tree structures. The\nprogram visits the nodes of the tree and puts them in a list following a depth-first\nsearch. The list L of visited elements can be obtained from the atom visit(null, L, [ ])\nin the program\u2019s minimal model. For instance, if the input tree is\ninput(tree(a, tree(c, null, tree(d, null, null)), tree(b, null, null))).\nthe program produces the list [b, d, c, a] containing the nodes of the tree in opposite\norder w.r.t. the traversal. 2\nAlso in the case above, even if the program evaluation terminates for every input\ntree, none of the currently known techniques is able to detect it, while the technique\nproposed in this paper does.\nExample 3 Consider the following program P3 computing the concatenation of two lists:\nr0 : reverse(L1, [ ]) \u2190 input1(L1). r1 : reverse(L1, [X|L2]) \u2190 reverse([X|L1], L2). r2 : append(L1, L2) \u2190 reverse([ ], L1), input2(L2). r3 : append(L1, [X|L2]) \u2190 append([X|L1], L2).\nHere input1 and input2 are used to store the lists L1 and L2 to be concatenated. The result list L can be retrieved from the atom append([ ], L) in the minimal model of P3. Clearly, the bottom-up evaluation of the program always terminates. 2\nWe point out that the problem of detecting decidable classes of programs is rel-\nevant not only from a theoretical point of view, as real applications make use of\nstructured data and functions symbols (e.g., lists, sets, bags, arithmetic). Classical\napplications need the use of structured data such as bill of materials consisting\nin the description of all items that compose a product, down to the lowest level\nof detail (Ceri et al. 1990), management of strings in bioinformatics applications,\nmanaging and querying ontological data using logic languages (Cali et al. 2010;\nChaudhri et al. 2013), as well as applications based on greedy and dynamic pro-\ngramming algorithms (Greco et al. 1992; Greco 1999).\nContribution. We propose novel techniques for checking if the evaluation of a\nlogic program terminates (clearly, we define sufficient conditions). Our techniques\novercome several limitations of current approaches being able to perform a more\nglobal analysis of how terms are propagated from the body to the head of rules.\nTo this end, we use linear constraints to measure and relate the size of head and\nbody atoms. We first introduce the class of rule-bounded programs, which looks\nat individual rules, and then propose the class of cycle-bounded programs, which\nrelies on the analysis of groups of rules. We show the correctness of the proposed\ntechniques and provide upper bounds on their complexity. We also study the rela-\ntionship between the proposed classes and current termination criteria.\nOrganization. Section 2 reports preliminaries on logic programs with function\nsymbols. Sections 3 introduces the class of rule-bounded programs, whereas Sec-\ntion 4 presents several theoretical results on its correctness and expressivity. Sec-\ntion 5 introduces the class of cycle-bounded programs along with results on its\ncorrectness and expressivity. The complexity analysis is addressed in Section 6.\nRelated work and conclusions are reported in Sections 7 and 8, respectively."}, {"heading": "2 Preliminaries", "text": "This section recalls syntax and the stable model semantics of logic programs with\nfunction symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).\nSyntax. We assume to have (pairwise disjoint) infinite sets of logical variables,\npredicate symbols, and function symbols. Each predicate and function symbol g is\nassociated with an arity, denoted arity(g), which is a non-negative integer. Function\nsymbols of arity 0 are called constants. Variables appearing in logic programs are\ncalled \u201clogical variables\u201d and will be denoted by upper-case letters in order to\ndistinguish them from variables appearing in linear constraints, which are called\n\u201cinteger variables\u201d and will be denoted by lower-case letters. A term is either a\nlogical variable, or an expression of the form f(t1, ..., tm), where f is a function symbol of arity m \u2265 0 and t1, ..., tm are terms. An atom is of the form p(t1, ..., tn), where p is a predicate symbol of arity n \u2265 0 and t1, ..., tn are terms. A literal is an atom A (positive literal) or its negation \u00acA (negative literal).\nA rule r is of the form A1 \u2228 ... \u2228 Am \u2190 B1, ..., Bk,\u00acC1, ...,\u00acCn, where m > 0, k \u2265 0, n \u2265 0, and A1, ..., Am, B1, ..., Bk, C1, ..., Cn are atoms. The disjunction A1 \u2228 ... \u2228 Am is called the head of r and is denoted by head(r). The conjunction B1, ..., Bk,\u00acC1, ...,\u00acCn is called the body of r and is denoted by body(r). With a slight abuse of notation, we sometimes use body(r) (resp. head(r)) to also denote\nthe set of literals appearing in the body (resp. head) of r. If m = 1, then r is\nnormal; in this case, head(r) denotes the head atom. If n = 0, then r is positive.\nA program is a finite set of rules. A program is normal (resp. positive) if every rule\nin it is normal (resp. positive). We assume that programs are range restricted, i.e.,\nfor every rule, every logical variable appears in some positive body literal. W.l.o.g.,\nwe also assume that different rules do not share logical variables.\nA term (resp. atom, literal, rule, program) is ground if no logical variables occur\nin it. A ground normal rule with an empty body is also called a fact. A predicate\nsymbol p is defined by a rule r if p appears in the head of r.\nA substitution \u03b8 is of the form {X1/t1, ..., Xn/tn}, where X1, ..., Xn are distinct logical variables and t1, ..., tn are terms. The result of applying \u03b8 to an atom (or term) A, denoted A\u03b8, is the atom (or term) obtained from A by simultaneously\nreplacing each occurrence of a logical variable Xi in A with ti if Xi/ti belongs to \u03b8. Two atoms A1 and A2 unify if there exists a substitution \u03b8, called a unifier of A1 and A2, such that A1\u03b8 = A2\u03b8. The composition of two substitutions \u03b8 = {X1/t1, ..., Xn/tn} and \u03d1 = {Y1/u1, ..., Ym/um}, denoted \u03b8 \u25e6 \u03d1, is the substitution obtained from the set {X1/t1\u03d1, ...,Xn/tn\u03d1, Y1/u1, ..., Ym/um} by removing every Xi/ti\u03d1 such that Xi = ti\u03d1 and every Yj/uj such that Yj \u2208 {X1, ..., Xn}. A substitution \u03b8 is more general than a substitution \u03d1 if there exists a substitution \u03b7 such that \u03d1 = \u03b8 \u25e6 \u03b7. A unifier \u03b8 of A1 and A2 is called a most general unifier (mgu) of A1 and A2 if it is more general than any other unifier of A1 and A2 (indeed, the mgu is unique modulo renaming of logical variables).\nSemantics. Consider a program P. The Herbrand universe HP of P is the possibly infinite set of ground terms constructible using function symbols (and thus, also constants) appearing in P. The Herbrand base BP of P is the set of ground atoms constructible using predicate symbols appearing in P and ground terms of HP .\nA rule (resp. atom) r\u2032 is a ground instance of a rule (resp. atom) r in P if r\u2032 can be obtained from r by substituting every logical variable in r with some ground\nterm in HP . We use ground(r) to denote the set of all ground instances of r and define ground(P) to denote the set of all ground instances of the rules in P, i.e., ground(P) = \u222ar\u2208Pground(r).\nAn interpretation of P is any subset I of BP . The truth value of a ground atom A w.r.t. I, denoted valueI(A), is true if A \u2208 I, false otherwise. The truth value of \u00acA w.r.t. I, denoted valueI(\u00acA), is true if A 6\u2208 I, false otherwise. A ground rule r is satisfied by I, denoted I |= r, if there is a ground literal L in body(r) s.t. valueI(L) = false or there is a ground atom A in head(r) s.t. valueI(A) = true. Thus, if the body of r is empty, r is satisfied by I if there is an atom A in head(r) s.t. valueI(A) = true. An interpretation of P is a model of P if it satisfies every ground rule in ground(P). A model M of P is minimal if no proper subset of M is a model of P. The set of minimal models of P is denoted by MM(P).\nGiven an interpretation I of P, let PI denote the ground positive program derived from ground(P) by (i) removing every rule containing a negative literal \u00acA in the body with A \u2208 I, and (ii) removing all negative literals from the remaining rules. An interpretation I is a stable model of P if I \u2208MM(PI). The set of stable models of P is denoted by SM(P). It is well known that stable models are minimal models (i.e., SM(P) \u2286MM(P)), and SM(P) =MM(P) for positive programs.\nA positive normal program P has a unique minimal model, which, with a slight abuse of notation, we denote as MM(P). The immediate consequence operator of P is a function TP : 2BP \u2192 2BP defined as follows: for every interpretation I, TP(I) = {A | A \u2190 B1, ..., Bn \u2208 ground(P) and {B1, ..., Bn} \u2286 I}. The i-th iteration of TP (i \u2265 1) w.r.t. an interpretation I is defined as follows: T 1P(I) =\nTP(I) and T i P(I) = TP(T i\u22121 P (I)) for i > 1. The minimal model of P coincides with T\u221eP (\u2205). Finite programs. A program P is said to be finite under stable model semantics if, for every finite set of facts D, the program P\u222aD admits a finite number of stable models and each is of finite size, that is, |SM(P \u222a D)| is finite and every stable model M \u2208 SM(P \u222aD) is finite.\nEquivalently, a positive normal program P is finite if for every finite set of facts D, there is a finite natural number n such that TnP\u222aD(\u2205) = T\u221eP\u222aD(\u2205). We call such programs terminating. In this paper we study new conditions under which a positive normal program P is terminating. It is worth mentioning that such conditions can be easily extended to general programs. This will be shown in the next section."}, {"heading": "3 Rule-bounded Programs", "text": "In this section, we present rule-bounded programs, a class of programs whose evalua-\ntion always terminates and for which checking membership in the class is decidable.\nTheir definition relies on a novel technique which uses linear inequalities to mea-\nsure terms and atoms\u2019 sizes and checks if the size of the head of a rule is always\nbounded by the size of a mutually recursive body atom (we will formally define\nwhat \u201cmutually recursive\u201d means in Definition 2 below).\nFor ease of presentation, we restrict our attention to positive normal programs. However, our technique can be applied to an arbitrary program P with disjunction in the head and negation in the body by considering a positive normal program st(P) derived from P as follows. Every rule A1 \u2228 ... \u2228 Am \u2190 body in P is replaced with m positive normal rules of the form Ai \u2190 body+ (1 \u2264 i \u2264 m) where body+ is obtained from body by deleting all negative literals. In fact, the minimal model of st(P) contains every stable model of P (Greco et al. 2012)\u2014whence, the termination of st(P), which implies finiteness and computability of the minimal model will also imply that P has a finite number of stable models, each of finite size, which can be computed. In the rest of the paper, a program is understood to be positive and\nnormal. We start by introducing some preliminary notions.\nDefinition 1 (Firing graph) The firing graph of a program P, denoted \u2126(P), is a directed graph whose nodes are the rules in P and such that there is an edge \u3008r, r\u2032\u3009 if there exist two (not necessarily distinct) rules r, r\u2032 \u2208 P s.t. head(r) and an atom in body(r\u2032) unify. 2\nIntuitively, an edge \u3008r, r\u2032\u3009 of \u2126(P) means that rule r may cause rule r\u2032 to \u201cfire\u201d. The firing graph of program P1 of Example 1 is depicted in Figure 1. In the definition above, when r = r\u2032 we assume that r and r\u2032 are two \u201ccopies\u201d that do not share any\nlogical variable.\nWe say that a rule r depends on a rule r\u2032 if r can be reached from r\u2032 through the edges of \u2126(P). A strongly connected component (SCC) of a directed graph G is a maximal set C of nodes of G s.t. every node of C can be reached from every node of C (through the edges in G). We say that an SCC C is non-trivial if there exists at least one edge in G between two not necessarily distinct nodes of C. For instance,\nthe firing graph in Figure 1 has two SCCs, C1 = {r0} and C2 = {r1, r2, r3}, but only C2 is non-trivial. Given a program P and an SCC C of \u2126(P), pred(C) denotes the set of predicate symbols defined by the rules in C. We now define when the head atom and a body atom of a rule are mutually recursive.\nDefinition 2 (Mutually recursive atoms) Let P be a program and r a rule in P. The head atom A = head(r) and an atom B \u2208 body(r) are mutually recursive if there is an SCC C of \u2126(P) s.t.:\n1. C contains r, and 2. C contains a rule r\u2032 (possibly equal to r) s.t. head(r\u2032) and B unify. 2\nIn the previous definition, when r = r\u2032 we assume that r and r\u2032 are two \u201ccopies\u201d\nthat do not share any logical variable. Intuitively, the head atom A of a rule r\nand an atom B in the body of r are mutually recursive when there might be an\nactual propagation of terms from A to B (through the application of a sequence\nof rules). As a very simple example, if we have an SCC consisting only of the rule p(f(X)) \u2190 p(X), p(g(X)), the first body atom is mutually recursive with the head, while the second one is not as it does not unify with the head atom.\nGiven a rule r, we use rbody(r) to denote the set of atoms in body(r) which are\nmutually recursive with head(r). Moreover, we define sbody(r) as the set consisting\nof every atom in body(r) that contains all logical variables appearing in head(r), and define srbody(r) = rbody(r) \u2229 sbody(r). We say that a rule r in a program P is relevant if it is not a fact and the set of atoms body(r) \\ rbody(r) does not contain all logical variables in head(r). Roughly speaking, a non-relevant rule will be ignored because either it cannot propagate\nterms or its head size is bounded by body atoms which are not mutually recursive\nwith the head. We illustrate the notions introduced so far in the following example.\nExample 4 Consider the following program P4:\nr1 : s(f(X), Y)\ufe38 \ufe37\ufe37 \ufe38 A \u2190 q(X, f(Y))\ufe38 \ufe37\ufe37 \ufe38 B , s(Z, f(Y))\ufe38 \ufe37\ufe37 \ufe38 C . r2 : q(f(U), V)\ufe38 \ufe37\ufe37 \ufe38 D \u2190 s(U, f(V))\ufe38 \ufe37\ufe37 \ufe38 E .\nThe firing graph consists of the edges \u3008r1, r1\u3009, \u3008r1, r2\u3009, \u3008r2, r1\u3009. Thus, there is only one SCC C = {r1, r2}, which is non-trivial, and pred(C) = {q, s}. Atoms A and B (resp. A and C, D and E) are mutually recursive. Moreover, rbody(r1) = {B,C}, srbody(r1) = {B}, rbody(r2) = srbody(r2) = {E}. Both r1 and r2 are relevant. 2\nWe use N to denote the set of natural numbers {1, 2, 3, ...} and N0 to denote the set of natural numbers including the zero. Moreover, Nk = {(v1, ..., vk) | vi \u2208 N for 1 \u2264 i \u2264 k} and Nk0 = {(v1, ..., vk) | vi \u2208 N0 for 1 \u2264 i \u2264 k}. Given a k-vector v = (v1, ..., vk) in Nk0 , we use v[i] to refer to vi, for 1 \u2264 i \u2264 k. Given two k-vectors v = (v1, ..., vk) and w = (w1, ..., wk) in Nk0 , we use v \u00b7w to denote the classical scalar product, i.e., v \u00b7 w = \u2211k i=1 vi \u00b7 wi.\nAs mentioned earlier, the basic idea of the proposed technique is to measure the\nsize of terms and atoms in order to check if the rules\u2019 head sizes are bounded when\npropagation occurs. Thus, we introduce the notions of term and atom size.\nDefinition 3 Let t be a term. The size of t is recursively defined as follows:\nsize(t) = x if t is a logical variable X;m+ m\u2211 i=1 size(ti) if t = f(t1, ..., tm).\nwhere x is an integer variable. The size of an atom A = p(t1, ..., pn), denoted size(A), is the n-vector (size(t1), ..., size(tn)). 2\nIn the definition above, an integer variable x intuitively represents the possible\nsizes that the logical variable X can have during the bottom-up evaluation. The\nsize of a term of the form f(t1, ..., tm) is defined by summing up the size of its terms ti\u2019s plus the arity m of f . Note that from the definition above, the size of every constant is 0.\nExample 5 Consider rule r1 of program P1 (see Example 1). Using lc to denote the list constructor operator \u201c|\u201d, the rule can be rewritten as follows:\nbub(lc(Y, T), lc(X, Cur), Sol)\u2190 bub(lc(X, lc(Y, T)), Cur, Sol), X \u2264 Y.\nLet A (resp. B) be the atom in the head (resp. the first atom in the body). Then,\nsize(A) = (2 + y + t, 2 + x+ cur, sol)\nsize(B) = (2 + [x+ (2 + y + t)], cur, sol) 2\nWe are now ready to define rule-bounded programs.\nDefinition 4 (Rule-bounded programs) Let P be a program, C a non-trivial SCC of \u2126(P), and pred(C) = {p1, ..., pk}. We say that C is rule-bounded if there exist k vectors \u03b1ph \u2208 Narity(ph), 1 \u2264 h \u2264 k, such that for every relevant rule r \u2208 C with A = head(r) = pi(t1, ..., tn), there exists an atom B = pj(u1, ..., um) in srbody(r) s.t. the following inequality is satisfied\n\u03b1pj \u00b7 size(B)\u2212 \u03b1pi \u00b7 size(A) \u2265 0\nfor every non-negative value of the integer variables in size(B) and size(A).\nWe say that P is rule-bounded if every non-trivial SCC of \u2126(P) is rule-bounded. 2\nIntuitively, for every relevant rule of a non-trivial SCC of \u2126(P), Definition 4 checks if the size of the head atom is bounded by the size of a mutually recursive\nbody atom for all possible sizes the terms can assume.\nExample 6 Consider again program P4 of Example 4. Recall that the only non-trivial SCC of \u2126(P4) is C = {r1, r2}, and both r1 and r2 are relevant. To determine if the program is rule-bounded we need to check if C is rule-bounded. Thus, we need to find \u03b1q, \u03b1s \u2208 N2 such that there is an atom in srbody(r1) and an atom in srbody(r2) which satisfy the two inequalities derived from r1 and r2 for all non-negative values of the integer variables therein. Since both srbody(r1) and srbody(r2) contain only one element, we have only one choice, namely the one where B is selected for r1 and E is selected for r2. Thus, we need to check if there exist \u03b1q, \u03b1s \u2208 N2 s.t. the following linear constraints are satisfied for all non-negative values of the integer variables appearing in them:{\n\u03b1q \u00b7 size(B)\u2212 \u03b1s \u00b7 size(A) \u2265 0 \u03b1s \u00b7 size(E)\u2212 \u03b1q \u00b7 size(D) \u2265 0 \u21d2 { \u03b1q \u00b7 (x, 1 + y)\u2212 \u03b1s \u00b7 (1 + x, y) \u2265 0 \u03b1s \u00b7 (u, 1 + v)\u2212 \u03b1q \u00b7 (1 + u, v) \u2265 0\nBy expanding the scalar products and isolating every integer variable we obtain:{ (\u03b1q[1]\u2212 \u03b1s[1]) \u00b7 x+ (\u03b1q[2]\u2212 \u03b1s[2]) \u00b7 y + (\u03b1q[2]\u2212 \u03b1s[1]) \u2265 0 (\u03b1s[1]\u2212 \u03b1q[1]) \u00b7 u+ (\u03b1s[2]\u2212 \u03b1q[2]) \u00b7 v + (\u03b1s[2]\u2212 \u03b1q[1]) \u2265 0\nThe previous inequalities must hold for all x, y, u, v \u2208 N0; it is easy to see that this is the case iff the following system admits a solution:{\n\u03b1q[1]\u2212 \u03b1s[1] \u2265 0, \u03b1q[2]\u2212 \u03b1s[2] \u2265 0, \u03b1q[2]\u2212 \u03b1s[1] \u2265 0, \u03b1s[1]\u2212 \u03b1q[1] \u2265 0, \u03b1s[2]\u2212 \u03b1q[2] \u2265 0, \u03b1s[2]\u2212 \u03b1q[1] \u2265 0\nSince a solution does exist, e.g. \u03b1s[1] = \u03b1s[2] = \u03b1q[1] = \u03b1q[2] = 1 (recall that every \u03b1[i] must be greater than 0), the SCC C is rule-bounded, and so is the program. 2\nThe method in the previous example to find vectors \u03b1p for all p \u2208 pred(C) can always be applied. That is, we can always isolate the integer variables in the original\ninequalities and then derive one inequality for each expression that multiplies an in-\nteger variable plus the one for the constant term, imposing that all such expressions\nmust be greater than or equal to 0\u2014we precisely state this property in Lemma 5.\nIt is worth noting that the proposed technique can easily recognize many termi-\nnating practical programs where terms are simply exchanged from the body to the\nhead of rules (e.g., see Examples 1, 2, and 3).\nExample 7 Consider program P1 of Example 1. Recall that the only non-trivial SCC of \u2126(P1) is {r1, r2, r3} (see Figure 1) and all rules in it are relevant. Since |srbody(ri)| = 1 for every ri in the SCC, we have only one set of inequalities, which is the following one after isolating integer variables(we assume that the empty list is represented by a simple constant): (\u03b1b[1]\u2212 \u03b1b[2]) \u00b7 x1 + (2\u03b1b[1]\u2212 2\u03b1b[2]) \u2265 0 (\u03b1b[1]\u2212 \u03b1b[2]) \u00b7 y2 + (2\u03b1b[1]\u2212 2\u03b1b[2]) \u2265 0 (\u03b1b[1]\u2212 \u03b1b[3]) \u00b7 x3 + (\u03b1b[2]\u2212 \u03b1b[1]) \u00b7 cur3 + (2\u03b1b[1]\u2212 2\u03b1b[3]) \u2265 0\nwhere subscript b stands for predicate symbol bub, whereas subscripts associated\nwith integer variables are used to refer to the occurrences of logical variables in\ndifferent rules (e.g., y2 is the integer variable associated to the logical variable Y in rule r2). A possible solution is \u03b1b = (1, 1, 1) and thus P1 is rule-bounded. Considering program P2 of Example 2, we obtain the following constraints:{ (\u03b1v[1]\u2212 \u03b1v[2]) \u00b7 root1 + (\u03b1v[1]\u2212 \u03b1v[3]) \u00b7 right1 + (3\u03b1v[1]\u2212 2\u03b1v[2]\u2212 2\u03b1v[3]) \u2265 0 (\u03b1v[3]\u2212 \u03b1v[1]) \u00b7 next2 + 2\u03b1v[3] \u2265 0\nwhere subscript v stands for predicate symbol visit. By setting \u03b1v = (2, 1, 2), we get positive integer values of \u03b1v[1], \u03b1v[2], \u03b1v[3] s.t. the inequalities above are satisfied for all root1, right1, next2 \u2208 N0. Thus, P2 is rule-bounded. The firing graph of program P3 of Example 3 has two non-trivial SCCs C1 = {r1} and C2 = {r3}. The constraints for C1 are:{ (\u03b1r[1]\u2212 \u03b1r[2]) \u00b7 x1 + (2\u03b1r[1]\u2212 2\u03b1r[2]) \u2265 0\nwhere subscript r stands for predicate symbol reverse. It is easy to see that by choosing any (positive integer) values of \u03b1r[1] and \u03b1r[2] such that \u03b1r[1] \u2265 \u03b1r[2], the inequality above holds for all x1 \u2208 N0. Likewise, the constraints for C2 are{\n(\u03b1a[1]\u2212 \u03b1a[2]) \u00b7 x3 + (2\u03b1a[1]\u2212 2\u03b1a[2]) \u2265 0\nwhere subscript a stands for predicate symbol append. By choosing any (positive integer) values of \u03b1a[1] and \u03b1a[2] such that \u03b1a[1] \u2265 \u03b1a[2], the inequality above holds for all x3 \u2208 N0. Thus, P3 is rule-bounded. 2"}, {"heading": "4 Correctness and expressiveness", "text": "In this section, we show that every rule-bounded program is terminating and provide\nresults on the relative expressiveness of rule-bounded programs and other criteria.\nNote that every program P can be partitioned into an ordered sequence of subprograms P1, ...,Pn, called stratification, such that, for every 1 \u2264 i \u2264 n, every rule r in Pi depends only on rules belonging to some sub-program Pj with 1 \u2264 j \u2264 i. Recall that a rule r depends on a rule r\u2032 if r can be reached from r\u2032 through the\nedges of the firing graph. Moreover, there always exists a stratification where every sub-program Pi is either a non-trivial SCC or a set of trivial SCCs. Given a set of facts D, it is well known thatMM(P \u222aD) can be defined in terms of the minimal model of the Pi\u2019s following the order of the partition as follows: if M0 = D and Mi =MM(Pi \u222aMi\u22121) for 1 \u2264 i \u2264 n, then Mn =MM(P \u222aD).\nLemma 1 A program P is terminating iff every non-trivial SCC of \u2126(P) is terminating."}, {"heading": "Proof", "text": "(\u21d2) Clearly, if there is an SCC which is not terminating, then P is not terminating. (\u21d0) Assume now that P does not terminate and all its non-trivial SCCs terminates. This means that there is a set of facts D such that the fixpoint of P\u222aD is not finite.\nSince P \u222a D can be partitioned into (P1, ...,Pn), there must be a non-trivial (i.e. recursive) SCC Pi such that Pi \u222aMi\u22121 does not terminate. This contradicts the hypothesis that all non-trivial SCCs terminate. Indeed if Pi terminates, then for every set of facts D\u2032 including the facts in Mi\u22121, the fixpoint of Pi \u222aD\u2032 terminates and, therefore, the fixpoint of Pi \u222aMi\u22121 terminates as well.\nWe now refine the previous lemma by showing that to see if a program P is terminating it is not necessary to analyze every non-trivial SCC entirely, but we can focus on its relevant rules. Henceforth, for every set of rules C, we use Rel(C) to denote the set of relevant rules of C.\nLemma 2 Let P be a program and let C be an SCC of \u2126(P). Then, C is terminating iff Rel(C) is terminating."}, {"heading": "Proof", "text": "It follows from the fact that we can derive only a finite number of ground atoms using the rules in ground(C) \\ ground(Rel(C)) starting from a finite set of facts\u2014 recall that, by definition, every non-relevant rule has a set of atoms in the body that\nare not mutually recursive with the head and contain all variables in the head.\nTo show the correctness of our approach, we first show that every rule-bounded\nprogram can be rewritten into an \u201cequivalent\u201d program belonging to a simpler class\nof programs, called size-bounded. Then, we prove that size-bounded programs are\nterminating and this entails that rule-bounded programs are terminating as well.\nDefinition 5 (Program expansion) Let P be a program and let \u03c9 = {\u03c9p1 , ..., \u03c9pn} be a set of vectors such that \u03c9pi \u2208 Narity(pi) and pi \u2208 pred(P) for 1 \u2264 i \u2264 n. For any atom A = p(t1, ..., tm) occurring in P, we define A\u03c9 = A, if p 6\u2208 pred(P), otherwise A\u03c9 = p(t1, ..., tm), where each tj is the sequence tj , ..., tj of length \u03c9p[j]. Finally, P\u03c9 denotes the program derived from P by replacing every atom A with A\u03c9. 2\nIntuitively, the expansion of a program is obtained from the original program by\nincreasing the arity of each predicate symbol according to \u03c9. Below is an example.\nExample 8 Consider program P4 of Example 4 and the set of vectors \u03c9 = {\u03c9s, \u03c9q} where \u03c9s = (2, 3) and \u03c9q = (2, 1). The program P \u03c9 4 is as follows:\nr1 : s(f(X), f(X), Y, Y, Y) \u2190 q(X, X, f(Y)), s(Z, Z, f(Y), f(Y), f(Y)). r2 : q(f(U), f(U), V) \u2190 s(U, U, f(V), f(V), f(V)). 2\nWe now show that for every program P and every set of vectors \u03c9, P is terminating iff P\u03c9 is terminating. In the following, for every program P, we define \u03c9(P) = { {\u03c9p1 , ..., \u03c9pn} | pi \u2208 pred(P) \u2227 \u03c9pi \u2208 Narity(pi)}.\nLemma 3 For every program P and every \u03c9 \u2208 \u03c9(P), P is terminating iff P\u03c9 is terminating."}, {"heading": "Proof", "text": "For every atom A\u03c9 occurring in P\u03c9 let A be the corresponding atom in P. The claim follows from the observation that whenever there is a instance D such that T\u221eP\u222aD(\u2205) is infinite, it is always possible to construct the instance D\u03c9 which guarantees that T\u221eP\u03c9\u222aD\u03c9 (\u2205) is infinite as well. Conversely, for every instance D\u03c9 of P\u03c9, if T\u221eP\u03c9\u222aD\u03c9 (\u2205) is infinite, then we can always construct the instance D guaranteeing that T\u221eP\u222aD(\u2205) is infinite as well.\nWe now introduce the class of size-bounded programs and show that such pro-\ngrams are terminating. To this aim, we define the total size of an atom A = p(t1, ..., tn) as tsize(A) = n\u2211 i=1 size(ti).\nDefinition 6 (Size-bounded program) A program P is said to be size-bounded if for every rule r \u2208 P which is not a fact, there is an atom B in sbody(r) such that tsize(B) \u2265 tsize(head(r)) for every non-negative value of the integer variables occurring in tsize(B) and tsize(head(r)).\nTheorem 1\nEvery size-bounded program is terminating."}, {"heading": "Proof", "text": "Let P be a size-bounded program and D a finite set of facts, we consider only rules in P having a non-empty body. Given an atom A and a ground instance A\u2032 of A, let \u03b8 be the mgu of A and A\u2032. Notice that \u03b8 is of the form {X1/t1, ..., Xn/tn} where the Xi\u2019s are exactly the logical variables occurring in A and all the tj \u2019s are ground terms. It can be easily verified that tsize(A\u2032) can be obtained from tsize(A) by\nreplacing every integer variable xi in tsize(A) with size(ti).\nWe now show that for every ground rule r\u2032 \u2208 ground(P) there is an atom B\u2032 \u2208 body(r\u2032) such that tsize(B\u2032) \u2265 tsize(head(r\u2032)). Consider a rule r in P of the form A\u2190 B1, ..., Bk and a ground rule r\u2032 \u2208 ground(r) of the form A\u2032 \u2190 B\u20321, ..., B\u2032k. Since P is size-bounded, there exists an atom Bj in sbody(r) such that tsize(Bj) \u2265 tsize(A) for every non-negative value of the integer variables occurring in the in-\nequality. Notice every logical variable in A appears also in Bj by definition of sbody. Let {X1/t1, ..., Xn/tn} be the mgu of Bj and B\u2032j . As tsize(Bj) \u2265 tsize(A) holds for all non-negative value of its integer variables, it also holds when every integer variable xi is replaced with size(ti), for 1 \u2264 i \u2264 n. Thus, tsize(B\u2032j) \u2265 tsize(A\u2032). Let us denote T iP\u222aD(\u2205) as Mi for every i \u2265 1 and let tsizemax = max{tsize(B) | B \u2190 is a fact in P \u222aD}. We show that for every i \u2265 1 and every ground atom A in Mi the following holds tsizemax \u2265 tsize(A). The proof is by induction on i. \u2022 Base case (i=1). It follows from the fact that M1={B | B\u2190 is a fact in P \u222a D}. \u2022 Inductive step (i \u2192 i + 1). Let r\u2032 be a ground rule in ground(P) such that body(r\u2032) \u2286 Mi. Then, as shown above, there is an atom B in body(r\u2032) such that tsize(B) \u2265 tsize(head(r\u2032)). By the induction hypothesis, tsizemax \u2265 tsize(B) and thus tsizemax \u2265 tsize(head(r\u2032)).\nThus, for every i \u2265 1 and every ground atom A in Mi, we have that tsize(A)\nis bounded by tsizemax. Since programs are range-restricted, atoms in \u222ai\u22651Mi are built from constants and function symbols appearing in P \u222aD, which are finitely many. These observations and the definition of tsize imply that we can have only finitely many ground atoms in \u222ai\u22651Mi. Hence, P is terminating. We are now ready to show the correctness of the rule-bounded technique.\nTheorem 2 Every rule-bounded program is terminating."}, {"heading": "Proof", "text": "Let P be a rule-bounded program and C a non-trivial SCC of \u2126(P). Since P is rule-bounded, then there exists \u03c9 \u2208 \u03c9(C) which satisfies the condition of Definition 4, that is, C is rule-bounded. This implies that Rel(C)\u03c9 is size-bounded. Thus, Rel(C)\u03c9 is terminating by Theorem 1. Lemma 3 implies that Rel(C) is terminating and Lemma 2 in turn implies that C is terminating. Finally, by Lemma 1, we can conclude that P is terminating.\nThe class of rule-bounded programs is incomparable with different termination\ncriteria in the literature, including the most general ones.\nTheorem 3 Rule-bounded programs are incomparable with argument-restricted, mapping-re-\nstricted, and bounded programs."}, {"heading": "Proof", "text": "Recall that both bounded and mapping-restricted programs include argument-\nrestricted programs. To prove the claim we show that (i) there is a program which\nis rule-bounded but is neither mapping-restricted nor bounded, and (ii) there is a\nprogram which is argument-restricted but not rule-bounded. (i) As already shown, program P1 of Example 1 is rule-bounded; however, it can be easily verified that P1 is neither mapping-restricted nor bounded. (ii) Consider the program consisting of the rules p(f(X))\u2190 q(X) and q(Y)\u2190 p(f(Y)). This program is argument-restricted (and thus also mapping-restricted and bounded) but is not rule-bounded.\nRegarding the termination criteria mentioned in Theorem 3, we recall that map-\nping restriction (MR) and bounded programs (BP ) are incomparable and both\nextend argument restriction (AR). Concerning the computational complexity, while\nAR is polynomial time, both MR and BP are exponential. As a remark, it is inte-\nresting to note that the above result highlights the fact that our technique analyzes\nlogic programs from a radically different point of view w.r.t. previously defined\napproaches, which analyze how complex terms are propagated among arguments."}, {"heading": "5 Cycle-bounded Programs", "text": "As saw in the previous section, to determine if a program is rule-bounded we check\nthrough linear constraints if the size of the head atom is bounded by the size of\na body atom for every relevant rule in a non-trivial SCC of the firing graph (cf.\nDefinition 4). Looking at each rule individually has its limitations, as shown by the\nfollowing example.\nExample 9 Consider the following simple program P9:\nr1 : p(X, Y) \u2190 q(f(X), Y). r2 : q(W, f(Z)) \u2190 p(W, Z).\nIt is easy to see that the program above is terminating, but it is not rule-bounded. The linear inequalities for the program are (cf. Definition 4):{ (\u03b1q[1]\u2212 \u03b1p[1]) \u00b7 x+ (\u03b1q[2]\u2212 \u03b1p[2]) \u00b7 y + \u03b1q[1] \u2265 0 (\u03b1p[1]\u2212 \u03b1q[1]) \u00b7 w + (\u03b1p[2]\u2212 \u03b1q[2]) \u00b7 z \u2212 \u03b1q[2] \u2265 0\nIt can be easily verified that there are no positive integer values for \u03b1p[1], \u03b1p[2], \u03b1q[1], \u03b1q[2] such that the inequalities hold for all x, y, w, z \u2208 N0. The reason is the presence of the expression \u2212\u03b1q[2] in the second inequality. Intuitively, this is because the size of the head atom increases w.r.t. the size of the body atom in r2. However, notice that the cycle involving r1 and r2 does not increase the overall size of propagated terms. This suggests we can check if an entire cycle (rather than\neach individual rule) propagates terms of bounded size. 2\nTo deal with programs like the one shown in the previous example, we introduce\nthe class of cycle-bounded programs, which is able to perform an analysis of how\nterms propagate through a group of rules, rather than looking at rules individually\nas done by the rule-bounded criterion.\nGiven a program P, a cyclic path \u03c0 of \u2126(P) is a sequence of edges \u3008r1, r2\u3009, \u3008r2, r3\u3009, ..., \u3008rn, r1\u3009. Moreover a cyclic path \u03c0 is basic if every edge \u03c0 does not occur more than once. We say that \u03c0 is relevant if every ri is relevant, for 1 \u2264 i \u2264 n.\nIn the following, we first present the cycle-bounded criterion for linear programs\nand then show how it can be applied to non-linear ones.\nDealing with linear programs. A program P is linear if every rule in P is linear. A rule r is linear if |rbody(r)| \u2264 1. Notice that rbody(r) contains exactly one atom B for every linear rule r in a non-trivial SCC of the firing graph; thus, with a slight\nabuse of notation, we use rbody(r) to refer to B.\nDefinition 7 (Cycle constraints) Let P be a linear program and let \u03c0 = \u3008r1, r2\u3009, ..., \u3008rn, r1\u3009 be a basic cyclic path of \u2126(P). For every mgu \u03b8i of head(ri) and rbody(ri+1) (1 \u2264 i < n)1, we define the set of (linear) equalities eq(\u03b8i) = {x = size(t) | X/t \u2208 \u03b8i}. Then, we define eq(\u03c0) =\n\u22c3 1\u2264i<n eq(\u03b8i). 2\nExample 10 Consider the program P9 and the two basic cyclic paths \u03c01 = \u3008r1, r2\u3009 \u3008r2, r1\u3009 and \u03c02 = \u3008r2, r1\u3009 \u3008r1, r2\u3009 of \u2126(P9). The mgu of head(r1) and rbody(r2) is \u03b8 = {X/W, Y/Z} and thus eq(\u03c01) = {x = w, y = z}. Furthermore, the mgu of head(r2) and rbody(r1) is \u03b8 = {W/f(X), Y/f(Z)} and thus eq(\u03c02) = {w = 1 + x, y = 1 + z}. 2\n1 Note that such \u03b8i\u2019s always exist by definition of firing graph.\nDefinition 8 (Linear cycle-bounded programs) Let P be a linear program, \u03c0 = \u3008r1, r2\u3009 ... \u3008rn, r1\u3009 be a basic cyclic path of \u2126(P) and p be the predicate defined by rn. We say that \u03c0 is cycle-bounded if eq(\u03c0) is satisfiable for some non-negative value of its integer variables and there exists a vector \u03b1p \u2208 Narity(p) such that the constraint\n\u03b1p \u00b7 size(rbody(r1))\u2212 \u03b1p \u00b7 size(head(rn)) \u2265 0\nis satisfied for every non-negative value of its integer variables that satisfy eq(\u03c0). We say that P is cycle-bounded if every relevant basic cyclic path of \u2126(P) is cyclebounded. 2\nIn the definition above, we assume that distinct basic cyclic paths do not share\nany logical variable.\nExample 11 Consider again program P9 of Example 9. The program is clearly linear and \u2126(P9) has only two relevant basic cyclic paths \u03c01 = \u3008r1, r2\u3009\u3008r2, r1\u3009 and \u03c02 = \u3008r2, r1\u3009\u3008r1, r2\u3009. To check if P9 is cycle-bounded, we need to check if eq(\u03c01) = {x1 = w1, y1 = z1} and eq(\u03c02) = {w2 = 1 + x2, y2 = 1 + z2} admit a solution and if there exist \u03b1p, \u03b1q \u2208 N2 s.t. the constraints:\n\u03b1q \u00b7 (x1 + 1, y1) \u2212 \u03b1q \u00b7 (w1, z1 + 1) \u2265 0, \u03b1p \u00b7 (w2, z2) \u2212 \u03b1p \u00b7 (x2, y2) \u2265 0\nare satisfied for all x1, y1, w1, z1 \u2208 N0 and all x2, y2, w2, z2 \u2208 N0 that satisfy eq(\u03c01) and eq(\u03c02).\nBy applying the equality conditions eq(\u03c01) and eq(\u03c02) to the above constraints\nwe get the below inequalities for the basic cyclic paths \u03c01 and \u03c02:\n(\u03b1q[1], \u03b1q[2]) \u00b7 (x1 + 1, z1) \u2212 (\u03b1q[1], \u03b1q[2])) \u00b7 (x1, z1 + 1) \u2265 0, (\u03b1p[1], \u03b1p[2])) \u00b7 (x2 + 1, z2) \u2212 (\u03b1p[1], \u03b1p[2])) \u00b7 (x2, z2 + 1) \u2265 0\nIt is easy to see that the first constraint (resp. the second) is satisfied for every vector \u03b1p \u2208 N2 (resp. \u03b1q \u2208 N2) such that \u03b1p[1] \u2265 \u03b1p[2] (resp. \u03b1q[1] \u2265 \u03b1q[2]). Thus, P9 is cycle-bounded. 2\nTo prove the correctness of our approach, we introduce a simpler class of termi-\nnating programs, as we did in the case of rule-bounded programs.\nDefinition 9 (Linear cycle-size-bounded programs) Let P be a linear program. We say that P is cycle-size-bounded if for every relevant basic cyclic path \u03c0 = \u3008r1, r2\u3009 ... \u3008rn, r1\u3009 of \u2126(P), eq(\u03c0) is satisfiable for some nonnegative value of its integer variables and the constraint\ntsize(rbody(r1))\u2212 tsize(head(rn)) \u2265 0\nis satisfied for every non-negative value of its integer variables that satisfy eq(\u03c0). 2\nTheorem 4\nEvery linear cycle-size-bounded program is terminating."}, {"heading": "Proof", "text": "Let P be a cycle-size-bounded program and D a finite set of facts. Consider a relevant basic cyclic path \u03c0 = \u3008r1, r2\u3009 ... \u3008rn, r1\u3009 of \u2126(P). Let r\u20321, ..., r\u2032n be ground rules s.t. r\u2032i \u2208 ground(ri) for 1 \u2264 i \u2264 n and head(r\u2032i) = rbody(r\u2032i+1) for 1 \u2264 i < n. For 1 \u2264 i \u2264 n, let \u03b8hi be the mgu of head(ri) and head(r\u2032i), and \u03b8bi the mgu of rbody(ri) and rbody(r \u2032 i). Then, \u2022 tsize(head(r\u2032i)) can be obtained from tsize(head(ri)) by replacing every integer variable x in tsize(head(ri)) with size(t) provided that X/t \u2208 \u03b8hi , for 1 \u2264 i \u2264 n; \u2022 tsize(rbody(r\u2032i)) can be obtained from tsize(rbody(ri)) by replacing every integer variable x in tsize(rbody(ri)) with size(t) provided that X/t \u2208 \u03b8bi , for 1 \u2264 i \u2264 n; \u2022 if we replace every integer variable x in eq(\u03c0) with size(t) iff X/t belongs to \u222ani=1(\u03b8hi \u222a \u03b8bi ), then eq(\u03c0) is satisfied.\nThe items above entail that tsize(rbody(r\u20321))\u2212 tsize(head(r\u2032n)) \u2265 0. This means that we cannot derive atoms of increasing size through the cyclic application of rules and thus P \u222aD is terminating.\nTheorem 5 (Soundness) Every linear cycle-bounded program is terminating."}, {"heading": "Proof", "text": "The proof is similar to the one presented for rule-bounded programs. Given a linear cycle-bounded program P, we are going to construct an equivalent program (like P\u03c9) to P as follows: for every relevant basic cyclic path \u03c0 = \u3008r1, r2\u3009 ... \u3008rn, r1\u3009 of \u2126(P), let \u03b1p be the vector such that \u03b1p \u00b7 size(rbody(r1))\u2212\u03b1p \u00b7 size(head(rn)) \u2265 0. Then, remove rules r1 and rn from P and insert the rules head(r1)\u2190 rbody(r1)\u03b1p and head(rn)\n\u03b1p \u2190 rbody(rn) respectively. Finally, in order to preserve the activation of rules in the obtained program, for every pair of basic cyclic paths \u03c01 = \u3008r1, r2\u3009 ... \u3008rn, r1\u3009, \u03c02 = \u3008s1, s2\u3009 ... \u3008sm, s1\u3009, where p is the predicate defined by rn and sn with arity k, add to P a rule of the form A\u03b1p \u2190 A\u03b2p , where A is the atom p(X1, ..., Xk) and \u03b1p, \u03b2p are the vectors such that \u03b1p \u00b7 size(rbody(r1))\u2212 \u03b1p \u00b7 size(head(rn)) \u2265 0 and \u03b2p \u00b7 size(rbody(s1))\u2212 \u03b2p \u00b7 size(head(sm)) \u2265 0 respectively. It is not difficult to show that the obtained program is terminating iff P is terminating. Moreover, since P is cycle-bounded the new program is consequently cycle-size-bounded. From Theorem 4, we get that the new program is terminating and so it is P.\nDealing with non-linear programs. The application of the cycle-bounded cri-\nterion to arbitrary programs consists in applying the technique to a set of linear\nprograms derived from the original one. Given a rule r, the set of linear versions of r is defined as the set of rules `(r) = {head(r) \u2190 B | B \u2208 rbody(r)}. Given a program P = {r1, ..., rn}, the set of linear versions of P is defined as the set of linear programs `(P) = {{r\u20321, ..., r\u2032n} | r\u2032i \u2208 `(ri) for 1 \u2264 i \u2264 n}.\nDefinition 10 (Cycle-bounded programs) A (possibly non-linear) program P is cycle-bounded if every (linear) program in `(P) is cycle-bounded. 2\nTheorem 6\nEvery cycle-bounded program is terminating."}, {"heading": "Proof", "text": "Notice that every linear version P \u2032 \u2208 `(P) of P is such that for every set of facts D, MM(D \u222a P) \u2286MM(D \u222a P \u2032). Thus, if every linear version of P is cycle-bounded then for every set of facts D, MM(D \u222a P) is finite.\nTheorem 7 (Expressivity)\nCycle-bounded programs are incomparable with rule-bounded, argument-restricted,\nmapping-restricted and bounded programs."}, {"heading": "Proof", "text": "As shown in Example 9, program P9 is cycle-bounded, but it can be easily verified that it is neither mapping-restricted (and thus not argument-restricted) nor rulebounded. Moreover, the one rule program {p(X, Y, f(Z, W)) \u2190 p(f(Z, Y), X, W).} is cycle-bounded but it is not bounded. Conversely, the program {p(f(X)) \u2190 p(f(f(X))), p(X).} is rule-bounded, argumentrestricted (and thus mapping-restricted) and bounded but not cycle-bounded."}, {"heading": "6 Complexity", "text": "In this section, we provide upper bounds for the time complexity of checking whe-\nther a program is rule-bounded or cycle-bounded. We assume that constant space\nis used to store each constant, logical variable, function symbol, and predicate symbol. The syntactic size2 of a term t (resp. atom, rule, program), denoted by ||t||, is the number of symbols occurring in t, except for the symbols \u201c(\u201d, \u201c)\u201d, \u201c,\u201d, \u201c.\u201d, and \u201c\u2190\u201d. Thus, in this section, the complexity of a problem involving P is assumed to be w.r.t. ||P||. Obviously |P| = O(||P||).\nLemma 4 Given a program P, constructing \u2126(P) is in PTIME ."}, {"heading": "Proof", "text": "The construction of \u2126(P) requires checking, for every atom A in the head of a rule and every atom B in the body of a rule, if A and B unify. Since we need to check\n|P| \u00d7 \u2211 r\u2208P |body(r)| times if two atoms unify and checking whether two atoms A and B unify can be done in quadratic time w.r.t. ||A|| and ||B|| (Venturini Zilli 1975), then the construction of \u2126(P) is in PTIME .\nIt is worth noting that the number of SCCs is bounded by O(|P|) and that after having built \u2126(P), the cost of checking whether a SSC is trivial or nontrivial is constant, whereas the cost of checking whether a rule is relevant is bounded by O(||P||). Inequalities associated with basic cycles can be rewritten by grouping\n2 We use the name syntactic size to distinguish it from the notion of size introduced in Definition 3.\nterms with respect to integer coefficients (also called \u03b1-coefficients) or with respect\nto integer variables. Therefore, in the following we assume that inequalities grouped with respect to integer variables are of the form \u03b31 \u00b7x1,+ \u00b7 \u00b7 \u00b7+\u03b3n \u00b7xn+\u03b30 \u2265 0, where each \u03b3i, for 0 \u2264 i \u2264 n, is an arithmetic expression built by using \u03b1-coefficients and natural numbers, whereas inequalities grouped with respect to integer coefficients are of the form \u03b11 \u00b7 w1,+ \u00b7 \u00b7 \u00b7 + \u03b1m \u00b7 wm \u2265 0, where each wj , for 1 \u2264 i \u2264 m, is an arithmetic expression built by using integer variables and natural numbers.\nObviously, each \u03b3i can be considered an integer coefficient, whereas each wj can be considered an integer variable.\nLemma 5\nConsider a linear inequality of the form\n\u03b31 \u00b7 x1 + ...+ \u03b3n \u00b7 xn + \u03b30 \u2265 0\nwhere the \u03b3i\u2019s are integer coefficients and the xj \u2019s are integer variables. The inequality is satisfied for every non-negative value of the xj \u2019s iff \u03b3i \u2265 0 for every 0 \u2264 i \u2264 n."}, {"heading": "Proof", "text": "(\u21d0) Straightforward. (\u21d2) By contradiction, assume that the inequality is satisfied for every non-negative value of the integer variables occurring in it, but there exists 0 \u2264 i \u2264 n such that \u03b3i < 0. If 1 \u2264 i \u2264 n, then the inequality is not satisfied when xi = babs(\u03b3n+1/\u03b3i)c+ 1 and xj = 0 for every j 6= i. If i = 0, then the inequality is not satisfied when xj = 0 for every 1 \u2264 j \u2264 n.\nTheorem 8 Checking whether a program P is rule-bounded is in NP ."}, {"heading": "Proof", "text": "In order to check whether P is rule-bounded we need to: 1) construct the firing graph \u2126(P) of P, 2) compute the SCCs of \u2126(P), and 3) check if every non-trivial SCC is rule-bounded.\n1) The construction of the firing graph is in PTIME by Lemma 4.\n2) It is well known that computing the SCCs of a directed graph can be done in\nlinear time w.r.t. the number of nodes and edges. Since the number of nodes of \u2126(P) is |P| and the maximum number of edges of \u2126(P) is |P|2, then computing all the SCCs is clearly in PTIME . 3) Let C be a non-trivial SCC of \u2126(P), n = O(|P|) the number of relevant rules in C, v the maximum number of distinct variables occurring in the head atoms of the relevant rules in C, and a the maximum arity of the predicate symbols in pred(C). Since it is always possible to rewrite the constraints as in Definition 4 in the form presented by Lemma 5, given a fixed choice of one atom in srbody(r) for every relevant rule r of C, checking whether C is rule-bounded according to that choice can be done by solving a set of at most n \u00d7 (v + 1) linear constraints with at most 2 \u00d7 a non-negative coefficients per constraint\u2014clearly, the size of the set\nof constraints is bounded by O(||P||) and if the set of constraints admit a solution, then there is a solution where the size of the \u03b1-coefficients is polynomial in the size of ||P|| (bounded by O(v \u00d7 n \u00d7 k), where k is the maximum constant appearing in the set of inequalities). As checking if such a set of linear constraints admits a\nsolution can be done in non-deterministic polynomial time (Papadimitriou 1981),\nit follows from the above discussion that this can be checked in polynomial time.\nHence, checking whether P is rule-bounded is in NP .\nWe discuss now the complexity of checking whether a program is cycle-bounded.\nTo this aim, we first introduce a technical lemma similar to Lemma 5.\nLemma 6\nConsider a linear inequality of the form\n\u03b11 \u00b7 w1 + ...+ \u03b1n \u00b7 wn < 0 (1)\nwhere the wi\u2019s are integer variables and the \u03b1j \u2019s positive integer coefficients. The inequality is satisfied iff wi \u2264 0 for every 1 \u2264 i \u2264 n and wj < 0 for some 1 \u2264 j \u2264 n."}, {"heading": "Proof", "text": "(\u21d0) It follows straightforwardly from the fact that each \u03b1j > 0 for every j \u2208 [1, n]. (\u21d2) By contradiction, assume that (1) is satisfied for every \u03b1j > 0, where j \u2208 [1, n], but either there is i \u2208 [1, n] such that wi > 0 or wi \u2264 0 for every i \u2208 [1, n] but none of such inequalities is strict. If there is i \u2208 [1, n], (i = 1, for example) such that w1 > 0, then, since \u03b1j > 0 for each j \u2208 [1, n], any assignment of \u03b11, ..., \u03b1n > 0 such that \u03b11 > |\u03b12 \u00b7w2 + ...+\u03b1n \u00b7wn| will not satisfy (1). In the case whether no wi \u2264 0 is strict, then wi = 0 for every i \u2208 [1, n] and thus \u03b11 \u00b7w1 + ...+\u03b1n \u00b7wn will be zero, which does not satisfy (1).\nThe next result says that checking if a program P is cycle-bounded is in coNP . We recall that a given a set of linear constraints depending on some integer variables\nis satisfiable if there exist non-negative integer values of its integer variables that\nsatisfy the constraints. A solution of such linear constraints is any assignment for\ntheir integer variables to some non-negative integer values satisfying the constraints.\nTheorem 9 Checking whether a program P is cycle-bounded is in coNP ."}, {"heading": "Proof", "text": "In order to prove the claim, we focus on the complement of our problem. By definition, a program P is not cycle-bounded if there exists a linear version P \u2032 of P which is not cycle-bounded, which means that a relevant basic cyclic path \u03c0 = \u3008r1, r2\u3009...\u3008rn, r1\u3009 of \u2126(P \u2032) is such that either eq(\u03c0) is not satisfiable or there is a solution of eq(\u03c0) for which the inequality \u03b1p \u00b7size(rbody(r1))\u2212\u03b1p \u00b7size(head(rn)) \u2265 0 is false, for every \u03b1p \u2208 Narity(p). Checking the statement above can be carried out by the following non-deterministic procedure.\nGuess a linear version P \u2032 of P and a basic cyclic path \u03c0 of \u2126(P \u2032) and check If \u03c0 is relevant. if it is not, then reject (i.e., the program is cycle-bounded). Then,\ncheck if eq(\u03c0) is satisfiable, if it is not then accept (i.e., the program is not cycle-\nbounded). Now, it remains to check whether there is a solution of eq(\u03c0) such that \u03b1p \u00b7 size(rbody(r1)) \u2212 \u03b1p \u00b7 size(head(rn)) \u2265 0 is false for all \u03b1p \u2208 Narity(p). To accomplish the aforementioned task, we can check wheher \u03b1p \u00b7size(rbody(r1))\u2212\u03b1p \u00b7 size(head(rn)) < 0 is true. Moreover, isolating every term \u03b1p[i] (1 \u2264 i \u2264 arity(p)) in the inequality, we get an expression of the form \u03b1p[1] \u00b7 w1 + ... + \u03b1p[arity(p)] \u00b7 warity(p) < 0, where each wi depends only on variables occurring in eq(\u03c0). Since from Lemma 6, this is equivalent to check whether wi \u2264 0 for i \u2208 [1, n] and there is j \u2208 [1, n] such that wj < 0, checking whether there is a solution of eq(\u03c0) such that \u03b1p \u00b7 size(rbody(r1)) \u2212 \u03b1p \u00b7 size(head(rn)) \u2265 0 is false for all \u03b1p \u2208 Narity(p) is equivalent to guessing a j \u2208 [1, n] and check that the set of linear constraints eq(\u03c0)\u222a{w1 \u2264 0}\u222a \u00b7 \u00b7 \u00b7 \u222a {wj < 0}\u222a \u00b7 \u00b7 \u00b7 \u222a {wn \u2264 0} is satisfiable. The input program is not cycle-bounded iff the previous set of linear constraints is satisfiable.\nTo show the desired upper bound, note that guessing a linear version P \u2032 of P and a basic cyclic path of \u2126(P \u2032) can be done in non-deterministic polynomial time, since |P \u2032| = |P| and the maximum length of a basic cyclic path coincides with the number of edges of \u2126(P \u2032). Moreover, as previously stated, constructing the firing graph is feasible in deterministic polynomial time. Furthermore, the construction\nof eq(\u03c0) can be carried on in polynomial time too, by using a polynomially sized\nrepresentation of the mgu\u2019s of the rules occurring in \u03c0 (Venturini Zilli 1975). Finally,\nas shown in (Papadimitriou 1981), checking whether the set of linear constraints eq(\u03c0) \u222a {w1 \u2264 0} \u222a \u00b7 \u00b7 \u00b7 \u222a {wj < 0} \u222a \u00b7 \u00b7 \u00b7 \u222a {wn \u2264 0} is satisfiable is in NP ."}, {"heading": "7 Related Work", "text": "A significant body of work has been done on termination of logic programs under\ntop-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011;\nMarchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye\n2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al.\n2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009)\nand in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008;\nArts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996). Termination\nproperties of query evaluation for normal programs under tabling have been studied\nin (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).\nIn this paper, we consider logic programs with function symbols under the stable\nmodel semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall\nthat, as discussed in Section 3, our approach can be applied to programs with\ndisjunction and negation by transforming them into positive normal programs),\nand thus all the excellent works above cannot be straightforwardly applied to our\nsetting\u2014for a discussion on this see, e.g., (Calimeri et al. 2008; Alviano et al. 2010).\nIn our context, (Calimeri et al. 2008) introduced the class of finitely-ground pro-\ngrams, guaranteeing the existence of a finite set of stable models, each of finite size,\nfor programs in the class. Since membership in the class is not decidable, decidable\nsubclasses have been proposed: \u03c9-restricted programs, \u03bb-restricted programs, finite\ndomain programs, argument-restricted programs, safe programs, \u0393-acyclic programs,\nmapping-restricted programs, and bounded programs. An adornment-based approach\nthat can be used in conjunction with the techniques above to detect more programs\nas finitely-ground has been proposed in (Greco et al. 2013b). This paper refines and\nextends (Calautti et al. 2014).\nCompared with the aforementioned classes, rule- and cycle-bounded programs\nallow us to perform a more global analysis and identify many practical programs\nas terminating, such as those where terms in the body are rearranged in the head,\nwhich are not included in any of the classes above. We observe that there are also\nprograms which are not rule- or cycle-bounded but are recognized as terminating\nby some of the aforementioned techniques (see Theorems 3 and 7).\nSimilar concepts of \u201cterm size\u201d have been considered to check termination of logic\nprograms evaluated in a top-down fashion (Sohn and Gelder 1991), to check local\nstratification of logic programs (Palopoli 1992), in the context of partial evaluation\nto provide conditions for strong termination and quasi-termination (Vidal 2007;\nLeuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and\nSwift 2013; Riguzzi and Swift 2014). These approaches are geared to work under\ntop-down evaluation, looking at how terms are propagated from the head to the\nbody, while our approach is developed to work under bottom-up evaluation, looking\nat how terms are propagated from the body to the head. This gives rise to significant\ndifferences in how the program analysis is carried out, making one approach not applicable in the setting of the other. As a simple example, the rule p(X) \u2190 p(X) leads to a non-terminating top-down evaluation, while it is completely harmless\nunder bottom-up evaluation.\nWe conclude by mentioning that our work is also related to research done on ter-\nmination of the chase procedure, where existential rules are considered (Marnette\n2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be\nfound in (Greco et al. 2012). Indeed, sufficient conditions ensuring termination of\nthe bottom-up evaluation of logic programs can be directly applied to existential\nrules. Specifically, one can analyze the logic program obtained from the skolemiza-\ntion of existential rules, where existentially quantified variables are replaced with\ncomplex terms (Marnette 2009). In fact, the evaluation of such a program behaves\nas the \u201csemi-oblivious\u201d chase (Marnette 2009), whose termination guarantees the\ntermination of the standard chase (Meier 2010; Onet 2013)."}, {"heading": "8 Conclusions", "text": "As a direction for future work, we plan to investigate how our techniques can be\ncombined with current termination criteria in a uniform way. Since they look at\nprograms from radically different standpoints, an interesting issue is to study how\nthey can be integrated so that they can benefit from each other.\nTo this end, an interesting approach would be to plug termination criteria in the\ngeneric framework proposed in (Eiter et al. 2013) and study their combination in\nsuch a framework. Another intriguing issue would be to analyze the relationships\nbetween the notions of safety of (Eiter et al. 2013) and the notions of boundedness\nused by termination criteria."}], "references": [{"title": "Disjunctive ASP with functions: Decidable queries and effective computation", "author": ["M. Alviano", "W. Faber", "N. Leone"], "venue": "Theory and Practice of Logic Programming 10, 46, 497\u2013512.", "citeRegEx": "Alviano et al\\.,? 2010", "shortCiteRegEx": "Alviano et al\\.", "year": 2010}, {"title": "Termination of term rewriting using dependency pairs", "author": ["T. Arts", "J. Giesl"], "venue": "Theoretical Computer Science 236, 1-2, 133\u2013178.", "citeRegEx": "Arts and Giesl,? 2000", "shortCiteRegEx": "Arts and Giesl", "year": 2000}, {"title": "On finitely recursive programs", "author": ["S. Baselice", "P.A. Bonatti", "G. Criscuolo"], "venue": "Theory and Practice of Logic Programming 9, 2, 213\u2013238.", "citeRegEx": "Baselice et al\\.,? 2009", "shortCiteRegEx": "Baselice et al\\.", "year": 2009}, {"title": "Reasoning with infinite stable models", "author": ["P.A. Bonatti"], "venue": "Artificial Intelligence 156, 1, 75\u2013111.", "citeRegEx": "Bonatti,? 2004", "shortCiteRegEx": "Bonatti", "year": 2004}, {"title": "Termination analysis of logic programs through combination of type-based norms", "author": ["M. Bruynooghe", "M. Codish", "J.P. Gallagher", "S. Genaim", "W. Vanhoof"], "venue": "ACM Transactions on Programming Languages and Systems 29, 2.", "citeRegEx": "Bruynooghe et al\\.,? 2007", "shortCiteRegEx": "Bruynooghe et al\\.", "year": 2007}, {"title": "Checking termination of logic programs with function symbols through linear constraints", "author": ["M. Calautti", "S. Greco", "C. Molinaro", "I. Trubitsyna"], "venue": "International Web Rule Symposium. 97\u2013111.", "citeRegEx": "Calautti et al\\.,? 2014", "shortCiteRegEx": "Calautti et al\\.", "year": 2014}, {"title": "Checking termination of bottom-up evaluation of logic programs with function symbols", "author": ["M. Calautti", "S. Greco", "F. Spezzano", "I. Trubitsyna"], "venue": "Theory and Practice of Logic Programming .", "citeRegEx": "Calautti et al\\.,? 2014", "shortCiteRegEx": "Calautti et al\\.", "year": 2014}, {"title": "Detecting decidable classes of finitely ground logic programs with function symbols", "author": ["M. Calautti", "S. Greco", "I. Trubitsyna"], "venue": "Principles and Practice of Declarative Programming. 239\u2013250.", "citeRegEx": "Calautti et al\\.,? 2013", "shortCiteRegEx": "Calautti et al\\.", "year": 2013}, {"title": "Datalog+/-: A family of logical knowledge representation and query languages for new applications", "author": ["A. Cali", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris"], "venue": "Proceedings of the 25th Annual IEEE Symposium on Logic in Computer Science, LICS 2010, 11-14 July 2010, Edinburgh, United Kingdom. 228\u2013242.", "citeRegEx": "Cali et al\\.,? 2010", "shortCiteRegEx": "Cali et al\\.", "year": 2010}, {"title": "Computable functions in ASP: Theory and implementation", "author": ["F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone"], "venue": "International Conference on Logic Programming. 407\u2013424.", "citeRegEx": "Calimeri et al\\.,? 2008", "shortCiteRegEx": "Calimeri et al\\.", "year": 2008}, {"title": "Logic Programming and Databases", "author": ["S. Ceri", "G. Gottlob", "L. Tanca"], "venue": "Springer.", "citeRegEx": "Ceri et al\\.,? 1990", "shortCiteRegEx": "Ceri et al\\.", "year": 1990}, {"title": "Object-oriented knowledge bases in logic programming", "author": ["V.K. Chaudhri", "S. Heymans", "S. Tran", "M.A. Wessel"], "venue": "Theory and Practice of Logic Programming 13, 45-Online-Supplement.", "citeRegEx": "Chaudhri et al\\.,? 2013", "shortCiteRegEx": "Chaudhri et al\\.", "year": 2013}, {"title": "Testing for termination with monotonicity constraints", "author": ["M. Codish", "V. Lagoon", "P.J. Stuckey"], "venue": "International Conference on Logic Programming. 326\u2013340.", "citeRegEx": "Codish et al\\.,? 2005", "shortCiteRegEx": "Codish et al\\.", "year": 2005}, {"title": "Termination of logic programs: The neverending story", "author": ["D. De Schreye", "S. Decorte"], "venue": "Journal of Logic Programming 19/20, 199\u2013260.", "citeRegEx": "Schreye and Decorte,? 1994", "shortCiteRegEx": "Schreye and Decorte", "year": 1994}, {"title": "Liberal safety for answer set programs with external sources", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl"], "venue": "AAAI Conference on Artificial Intelligence.", "citeRegEx": "Eiter et al\\.,? 2013", "shortCiteRegEx": "Eiter et al\\.", "year": 2013}, {"title": "Matrix interpretations for proving termination of term rewriting", "author": ["J. Endrullis", "J. Waldmann", "H. Zantema"], "venue": "Journal of Automated Reasoning 40, 2-3, 195\u2013220.", "citeRegEx": "Endrullis et al\\.,? 2008", "shortCiteRegEx": "Endrullis et al\\.", "year": 2008}, {"title": "Total termination of term rewriting", "author": ["M.C.F. Ferreira", "H. Zantema"], "venue": "Applicable Algebra in Engineering, Communication and Computing 7, 2, 133\u2013162.", "citeRegEx": "Ferreira and Zantema,? 1996", "shortCiteRegEx": "Ferreira and Zantema", "year": 1996}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers.", "citeRegEx": "Gebser et al\\.,? 2012", "shortCiteRegEx": "Gebser et al\\.", "year": 2012}, {"title": "Gringo: A new grounder for answer set programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "Logic Programming and Non-Monotonic Reasoning. 266\u2013271.", "citeRegEx": "Gebser et al\\.,? 2007", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "International Conference on Logic Programming/SLP. 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 3/4, 365\u2013386.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Dynamic programming in datalog with aggregates", "author": ["S. Greco"], "venue": "IEEE Trans. Knowl. Data Eng. 11, 2, 265\u2013283.", "citeRegEx": "Greco,? 1999", "shortCiteRegEx": "Greco", "year": 1999}, {"title": "Incomplete Data and Data Dependencies in Relational Databases", "author": ["S. Greco", "C. Molinaro", "F. Spezzano"], "venue": "Synthesis Lectures on Data Management. Morgan & Claypool Publishers.", "citeRegEx": "Greco et al\\.,? 2012", "shortCiteRegEx": "Greco et al\\.", "year": 2012}, {"title": "Bounded programs: A new decidable class of logic programs with function symbols", "author": ["S. Greco", "C. Molinaro", "I. Trubitsyna"], "venue": "International Joint Conference on Artificial Intelligence. 926\u2013932.", "citeRegEx": "Greco et al\\.,? 2013a", "shortCiteRegEx": "Greco et al\\.", "year": 2013}, {"title": "Logic programming with function symbols: Checking termination of bottom-up evaluation through program adornments", "author": ["S. Greco", "C. Molinaro", "I. Trubitsyna"], "venue": "Theory and Practice of Logic Programming 13, 4-5, 737\u2013752.", "citeRegEx": "Greco et al\\.,? 2013b", "shortCiteRegEx": "Greco et al\\.", "year": 2013}, {"title": "Chase termination: A constraints rewriting approach", "author": ["S. Greco", "F. Spezzano"], "venue": "PVLDB 3, 1, 93\u2013104.", "citeRegEx": "Greco and Spezzano,? 2010", "shortCiteRegEx": "Greco and Spezzano", "year": 2010}, {"title": "Stratification criteria and rewriting techniques for checking chase termination", "author": ["S. Greco", "F. Spezzano", "I. Trubitsyna"], "venue": "PVLDB 4, 11, 1158\u20131168.", "citeRegEx": "Greco et al\\.,? 2011", "shortCiteRegEx": "Greco et al\\.", "year": 2011}, {"title": "On the termination of logic programs with function symbols", "author": ["S. Greco", "F. Spezzano", "I. Trubitsyna"], "venue": "International Conference on Logic Programming (Technical Communications). 323\u2013333.", "citeRegEx": "Greco et al\\.,? 2012", "shortCiteRegEx": "Greco et al\\.", "year": 2012}, {"title": "Greedy by choice", "author": ["S. Greco", "C. Zaniolo", "S. Ganguly"], "venue": "Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, June 2-4, 1992, San Diego, California, USA. 105\u2013113.", "citeRegEx": "Greco et al\\.,? 1992", "shortCiteRegEx": "Greco et al\\.", "year": 1992}, {"title": "Fast offline partial evaluation of logic programs", "author": ["M. Leuschel", "G. Vidal"], "venue": "Information and Computation 235, 0, 70\u201397.", "citeRegEx": "Leuschel and Vidal,? 2014", "shortCiteRegEx": "Leuschel and Vidal", "year": 2014}, {"title": "One more decidable class of finitely ground programs", "author": ["Y. Lierler", "V. Lifschitz"], "venue": "International Conference on Logic Programming. 489\u2013493.", "citeRegEx": "Lierler and Lifschitz,? 2009", "shortCiteRegEx": "Lierler and Lifschitz", "year": 2009}, {"title": "Proving existential termination of normal logic programs", "author": ["M. Marchiori"], "venue": "Algebraic Methodology and Software Technology. 375\u2013390.", "citeRegEx": "Marchiori,? 1996", "shortCiteRegEx": "Marchiori", "year": 1996}, {"title": "Generalized schema-mappings: from termination to tractability", "author": ["B. Marnette"], "venue": "PODS. 13\u201322.", "citeRegEx": "Marnette,? 2009", "shortCiteRegEx": "Marnette", "year": 2009}, {"title": "On the Termination of the Chase Algorithm", "author": ["M. Meier"], "venue": "Albert-Ludwigs-Universitat Freiburg (Germany).", "citeRegEx": "Meier,? 2010", "shortCiteRegEx": "Meier", "year": 2010}, {"title": "Termination analysis of logic programs based on dependency graphs", "author": ["M.T. Nguyen", "J. Giesl", "P. Schneider-Kamp", "D. De Schreye"], "venue": "International Symposium on Logic-based Program Synthesis and Transformation. 8\u201322.", "citeRegEx": "Nguyen et al\\.,? 2007", "shortCiteRegEx": "Nguyen et al\\.", "year": 2007}, {"title": "Termination of narrowing via termination of rewriting", "author": ["N. Nishida", "G. Vidal"], "venue": "Applicable Algebra in Engineering, Communication and Computing 21, 3, 177\u2013225.", "citeRegEx": "Nishida and Vidal,? 2010", "shortCiteRegEx": "Nishida and Vidal", "year": 2010}, {"title": "Termination of logic programs: Transformational methods revisited", "author": ["E. Ohlebusch"], "venue": "Applicable Algebra in Engineering, Communication and Computing 12, 1/2, 73\u2013116.", "citeRegEx": "Ohlebusch,? 2001", "shortCiteRegEx": "Ohlebusch", "year": 2001}, {"title": "The chase procedure and its applications in data exchange", "author": ["A. Onet"], "venue": "Data Exchange, Integration, and Streams. 1\u201337.", "citeRegEx": "Onet,? 2013", "shortCiteRegEx": "Onet", "year": 2013}, {"title": "Testing logic programs for local stratification", "author": ["L. Palopoli"], "venue": "Theor. Comput. Sci. 103, 2, 205\u2013234.", "citeRegEx": "Palopoli,? 1992", "shortCiteRegEx": "Palopoli", "year": 1992}, {"title": "On the complexity of integer programming", "author": ["C.H. Papadimitriou"], "venue": "Journal of the ACM 28, 4, 765\u2013768.", "citeRegEx": "Papadimitriou,? 1981", "shortCiteRegEx": "Papadimitriou", "year": 1981}, {"title": "Well-definedness and efficient inference for probabilistic logic programming under the distribution semantics", "author": ["F. Riguzzi", "T. Swift"], "venue": "Theory and Practice of Logic Programming 13, 2, 279\u2013302.", "citeRegEx": "Riguzzi and Swift,? 2013", "shortCiteRegEx": "Riguzzi and Swift", "year": 2013}, {"title": "Terminating evaluation of logic programs with finite three-valued models", "author": ["F. Riguzzi", "T. Swift"], "venue": "ACM Transactions on Computational Logic.", "citeRegEx": "Riguzzi and Swift,? 2014", "shortCiteRegEx": "Riguzzi and Swift", "year": 2014}, {"title": "Automated termination proofs for logic programs by term rewriting", "author": ["P. Schneider-Kamp", "J. Giesl", "A. Serebrenik", "R. Thiemann"], "venue": "ACM Transactions on Computational Logic 11, 1.", "citeRegEx": "Schneider.Kamp et al\\.,? 2009", "shortCiteRegEx": "Schneider.Kamp et al\\.", "year": 2009}, {"title": "Automated termination analysis for logic programs with cut", "author": ["P. Schneider-Kamp", "J. Giesl", "T. Str\u00f6der", "A. Serebrenik", "R. Thiemann"], "venue": "Theory and Practice of Logic Programming 10, 4-6, 365\u2013381.", "citeRegEx": "Schneider.Kamp et al\\.,? 2010", "shortCiteRegEx": "Schneider.Kamp et al\\.", "year": 2010}, {"title": "On termination of meta-programs", "author": ["A. Serebrenik", "D. De Schreye"], "venue": "Theory and Practice of Logic Programming 5, 3, 355\u2013390.", "citeRegEx": "Serebrenik and Schreye,? 2005", "shortCiteRegEx": "Serebrenik and Schreye", "year": 2005}, {"title": "Termination detection in logic programs using argument sizes", "author": ["K. Sohn", "A.V. Gelder"], "venue": "Symposium on Principles of Database Systems. 216\u2013226.", "citeRegEx": "Sohn and Gelder,? 1991", "shortCiteRegEx": "Sohn and Gelder", "year": 1991}, {"title": "Root-labeling", "author": ["C. Sternagel", "A. Middeldorp"], "venue": "Rewriting Techniques and Applications. 336\u2013350.", "citeRegEx": "Sternagel and Middeldorp,? 2008", "shortCiteRegEx": "Sternagel and Middeldorp", "year": 2008}, {"title": "Omega-restricted logic programs", "author": ["T. Syrjanen"], "venue": "Logic Programming and NonMonotonic Reasoning. 267\u2013279.", "citeRegEx": "Syrjanen,? 2001", "shortCiteRegEx": "Syrjanen", "year": 2001}, {"title": "Complexity of the unification algorithm for first-order expressions", "author": ["M. Venturini Zilli"], "venue": "CALCOLO 12, 4, 361\u2013371.", "citeRegEx": "Zilli,? 1975", "shortCiteRegEx": "Zilli", "year": 1975}, {"title": "Termination proofs for logic programs with tabling", "author": ["S. Verbaeten", "D. De Schreye", "K.F. Sagonas"], "venue": "ACM Transactions on Computational Logic 2, 1, 57\u201392.", "citeRegEx": "Verbaeten et al\\.,? 2001", "shortCiteRegEx": "Verbaeten et al\\.", "year": 2001}, {"title": "Quasi-terminating logic programs for ensuring the termination of partial evaluation", "author": ["G. Vidal"], "venue": "ACM SIGPLAN Workshop on Partial Evaluation and Semantics-based Program Manipulation. 51\u201360.", "citeRegEx": "Vidal,? 2007", "shortCiteRegEx": "Vidal", "year": 2007}, {"title": "Non-termination analysis of logic programs with integer arithmetics", "author": ["D. Voets", "D. De Schreye"], "venue": "Theory and Practice of Logic Programming 11, 4-5, 521\u2013536.", "citeRegEx": "Voets and Schreye,? 2011", "shortCiteRegEx": "Voets and Schreye", "year": 2011}, {"title": "Termination of term rewriting by semantic labelling", "author": ["H. Zantema"], "venue": "Fundamenta Informaticae 24, 1/2, 89\u2013105.", "citeRegEx": "Zantema,? 1995", "shortCiteRegEx": "Zantema", "year": 1995}], "referenceMentions": [{"referenceID": 9, "context": "Efforts in this direction are the class of finitely-ground programs (Calimeri et al. 2008) and the more general class of bounded term-size programs (Riguzzi and Swift 2013).", "startOffset": 68, "endOffset": 90}, {"referenceID": 40, "context": "2008) and the more general class of bounded term-size programs (Riguzzi and Swift 2013).", "startOffset": 63, "endOffset": 87}, {"referenceID": 47, "context": "These include the classes of \u03c9-restricted programs (Syrjanen 2001), \u03bb-restricted programs (Gebser et al.", "startOffset": 51, "endOffset": 66}, {"referenceID": 18, "context": "These include the classes of \u03c9-restricted programs (Syrjanen 2001), \u03bb-restricted programs (Gebser et al. 2007), finite domain programs (Calimeri et al.", "startOffset": 90, "endOffset": 110}, {"referenceID": 9, "context": "2007), finite domain programs (Calimeri et al. 2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and \u0393-acyclic programs (Greco et al.", "startOffset": 30, "endOffset": 52}, {"referenceID": 30, "context": "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and \u0393-acyclic programs (Greco et al.", "startOffset": 36, "endOffset": 64}, {"referenceID": 22, "context": "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and \u0393-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted programs (Calautti et al.", "startOffset": 94, "endOffset": 135}, {"referenceID": 5, "context": "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and \u0393-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted programs (Calautti et al.", "startOffset": 94, "endOffset": 135}, {"referenceID": 7, "context": "2014), mapping-restricted programs (Calautti et al. 2013), and bounded programs (Greco et al.", "startOffset": 35, "endOffset": 57}, {"referenceID": 23, "context": "2013), and bounded programs (Greco et al. 2013a).", "startOffset": 28, "endOffset": 48}, {"referenceID": 10, "context": "Classical applications need the use of structured data such as bill of materials consisting in the description of all items that compose a product, down to the lowest level of detail (Ceri et al. 1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al.", "startOffset": 183, "endOffset": 201}, {"referenceID": 8, "context": "1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al. 2010; Chaudhri et al. 2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al.", "startOffset": 122, "endOffset": 162}, {"referenceID": 11, "context": "1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al. 2010; Chaudhri et al. 2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al.", "startOffset": 122, "endOffset": 162}, {"referenceID": 28, "context": "2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al. 1992; Greco 1999).", "startOffset": 82, "endOffset": 113}, {"referenceID": 21, "context": "2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al. 1992; Greco 1999).", "startOffset": 82, "endOffset": 113}, {"referenceID": 19, "context": "This section recalls syntax and the stable model semantics of logic programs with function symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).", "startOffset": 99, "endOffset": 147}, {"referenceID": 17, "context": "This section recalls syntax and the stable model semantics of logic programs with function symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).", "startOffset": 99, "endOffset": 147}, {"referenceID": 22, "context": "In fact, the minimal model of st(P) contains every stable model of P (Greco et al. 2012)\u2014whence, the termination of st(P), which implies finiteness and computability of the minimal model will also imply that P has a finite number of stable models, each of finite size, which can be computed.", "startOffset": 69, "endOffset": 88}, {"referenceID": 39, "context": "As checking if such a set of linear constraints admits a solution can be done in non-deterministic polynomial time (Papadimitriou 1981), it follows from the above discussion that this can be checked in polynomial time.", "startOffset": 115, "endOffset": 135}, {"referenceID": 39, "context": "Finally, as shown in (Papadimitriou 1981), checking whether the set of linear constraints eq(\u03c0) \u222a {w1 \u2264 0} \u222a \u00b7 \u00b7 \u00b7 \u222a {wj < 0} \u222a \u00b7 \u00b7 \u00b7 \u222a {wn \u2264 0} is satisfiable is in NP .", "startOffset": 21, "endOffset": 41}, {"referenceID": 31, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 36, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 12, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 35, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 42, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 43, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 34, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 4, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 3, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 2, "context": "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.", "startOffset": 100, "endOffset": 400}, {"referenceID": 52, "context": "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).", "startOffset": 40, "endOffset": 156}, {"referenceID": 46, "context": "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).", "startOffset": 40, "endOffset": 156}, {"referenceID": 1, "context": "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).", "startOffset": 40, "endOffset": 156}, {"referenceID": 15, "context": "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).", "startOffset": 40, "endOffset": 156}, {"referenceID": 16, "context": "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).", "startOffset": 40, "endOffset": 156}, {"referenceID": 40, "context": "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).", "startOffset": 98, "endOffset": 169}, {"referenceID": 41, "context": "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).", "startOffset": 98, "endOffset": 169}, {"referenceID": 49, "context": "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).", "startOffset": 98, "endOffset": 169}, {"referenceID": 19, "context": "In this paper, we consider logic programs with function symbols under the stable model semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall that, as discussed in Section 3, our approach can be applied to programs with disjunction and negation by transforming them into positive normal programs), and thus all the excellent works above cannot be straightforwardly applied to our setting\u2014for a discussion on this see, e.", "startOffset": 97, "endOffset": 153}, {"referenceID": 20, "context": "In this paper, we consider logic programs with function symbols under the stable model semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall that, as discussed in Section 3, our approach can be applied to programs with disjunction and negation by transforming them into positive normal programs), and thus all the excellent works above cannot be straightforwardly applied to our setting\u2014for a discussion on this see, e.", "startOffset": 97, "endOffset": 153}, {"referenceID": 9, "context": ", (Calimeri et al. 2008; Alviano et al. 2010).", "startOffset": 2, "endOffset": 45}, {"referenceID": 0, "context": ", (Calimeri et al. 2008; Alviano et al. 2010).", "startOffset": 2, "endOffset": 45}, {"referenceID": 9, "context": "In our context, (Calimeri et al. 2008) introduced the class of finitely-ground programs, guaranteeing the existence of a finite set of stable models, each of finite size, for programs in the class.", "startOffset": 16, "endOffset": 38}, {"referenceID": 24, "context": "An adornment-based approach that can be used in conjunction with the techniques above to detect more programs as finitely-ground has been proposed in (Greco et al. 2013b).", "startOffset": 150, "endOffset": 170}, {"referenceID": 5, "context": "This paper refines and extends (Calautti et al. 2014).", "startOffset": 31, "endOffset": 53}, {"referenceID": 45, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 124, "endOffset": 146}, {"referenceID": 38, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 196, "endOffset": 211}, {"referenceID": 50, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 317, "endOffset": 354}, {"referenceID": 29, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 317, "endOffset": 354}, {"referenceID": 40, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 396, "endOffset": 444}, {"referenceID": 41, "context": "Similar concepts of \u201cterm size\u201d have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).", "startOffset": 396, "endOffset": 444}, {"referenceID": 32, "context": "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.", "startOffset": 151, "endOffset": 210}, {"referenceID": 25, "context": "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.", "startOffset": 151, "endOffset": 210}, {"referenceID": 26, "context": "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.", "startOffset": 151, "endOffset": 210}, {"referenceID": 22, "context": "2011); a survey on this topic can be found in (Greco et al. 2012).", "startOffset": 46, "endOffset": 65}, {"referenceID": 32, "context": "Specifically, one can analyze the logic program obtained from the skolemization of existential rules, where existentially quantified variables are replaced with complex terms (Marnette 2009).", "startOffset": 175, "endOffset": 190}, {"referenceID": 32, "context": "In fact, the evaluation of such a program behaves as the \u201csemi-oblivious\u201d chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).", "startOffset": 80, "endOffset": 95}, {"referenceID": 33, "context": "In fact, the evaluation of such a program behaves as the \u201csemi-oblivious\u201d chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).", "startOffset": 164, "endOffset": 187}, {"referenceID": 37, "context": "In fact, the evaluation of such a program behaves as the \u201csemi-oblivious\u201d chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).", "startOffset": 164, "endOffset": 187}, {"referenceID": 14, "context": "To this end, an interesting approach would be to plug termination criteria in the generic framework proposed in (Eiter et al. 2013) and study their combination in such a framework.", "startOffset": 112, "endOffset": 131}, {"referenceID": 14, "context": "Another intriguing issue would be to analyze the relationships between the notions of safety of (Eiter et al. 2013) and the notions of boundedness used by termination criteria.", "startOffset": 96, "endOffset": 115}], "year": 2015, "abstractText": "It is widely acknowledged that function symbols are an important feature in answer set programming, as they make modeling easier, increase the expressive power, and allow us to deal with infinite domains. The main issue with their introduction is that the evaluation of a program might not terminate and checking whether it terminates or not is undecidable. To cope with this problem, several classes of logic programs have been proposed where the use of function symbols is restricted but the program evaluation termination is guaranteed. Despite the significant body of work in this area, current approaches do not include many simple practical programs whose evaluation terminates. In this paper, we present the novel classes of rule-bounded and cycle-bounded programs, which overcome different limitations of current approaches by performing a more global analysis of how terms are propagated from the body to the head of rules. Results on the correctness, the complexity, and the expressivity of the proposed approach are provided. Under consideration in Theory and Practice of Logic Programming (TPLP).", "creator": "LaTeX with hyperref package"}}}