{"id": "1512.07430", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Dec-2015", "title": "The ERA of FOLE: Foundation", "abstract": "An ontology defines the primitives by which knowledge resources are modeled for a discourse community (Gruber 2009).These primitives, consisting of classes, relationships and properties, are represented by the entity-relationship attribute ERA data model (Chen 1976).An ontology uses formal axioms to restrict the interpretation of these primitives. In short, an ontology specifies a logical theory.This paper is the first in a series of three papers that provide a rigorous mathematical representation for the ERA data model in particular and ontologies in general within the first-order logical environment FOLE. Specifically, the first two papers show how FOLE represents the formalism and semantics of the (multi-sorted) first-order logic (OLE) in a classification form corresponding to the ideas discussed in the Information Flow Framework (IFF).Specifically, this first paper represents a basic interpretation that includes the elements of the OLE, the first-order structure and the first-order OLE.", "histories": [["v1", "Wed, 23 Dec 2015 11:00:15 GMT  (41kb)", "http://arxiv.org/abs/1512.07430v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["robert e kent"], "accepted": false, "id": "1512.07430"}, "pdf": {"name": "1512.07430.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n51 2.\n07 43\n0v 1\n[ cs\n.D B\n] 2\n3 D\nec 2\n01 5\nKeywords: entity, attribute, relationship, schema, universe, structure.\nTable of Contents\nThe ERA of FOLE: Foundation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Robert E. Kent 1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 3 ERA Data Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n3.1 Attributes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.2 Entities. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.3 Relations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 4 FOLE Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4.1 Schema. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4.2 Universe. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 4.3 Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4.4 Interpretation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 5 Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 5.1 Analogy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 5.2 Linearization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 A The Fibered Context of Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nA.1 An Exemplar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 A.2 Schema Orientation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 A.3 Universe Orientation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28"}, {"heading": "1 Introduction", "text": "The first-order logical environment FOLE (Kent [8]) is a framework for defining the semantics and formalism of logic and databases in an integrated and coherent fashion. Institutions in general, and logical environments in particular, give equivalent heterogeneous and homogeneous representations for logical systems. FOLE is an institution, since \u201csatisfaction is invariant under change of notation\u201d. FOLE is a logical environment, since \u201csatisfaction respects structure linkage\u201d. As an institution, the architecture of FOLE consists of languages as indexing components, structures to represent semantic content, specifications to represent formal content, and logics to combine formalism with semantics. FOLE structures are interpreted as relational/logical databases. This is the first of three papers, which are concerned with the presentation of FOLE: (1) the FOLE foundation, (2) the FOLE superstructure (Kent [9]), and (3) the FOLE interpretation (Kent [10]).\nThis paper, which is concerned with the FOLE foundation, is illustrated in Fig. 7 and is centered on the mathematical context of structures. 1 In \u00a7 3 and \u00a7 4 we show how the ERA data model is represented in FOLE by connecting elements of the ERA data model to components of the FOLE structure concept. \u00a7 3 discusses the direct lower-level connection between the ERA elements (attributes, entities, relations) and the FOLE components (type domains and entity classifications). 2 \u00a7 4 discusses the abstract higher-level representation of the ERA data model within the FOLE architecture. In addition, we give a rudimentary description of the interpretation of FOLE structures in \u00a7 4.4. In \u00a7 5 we connect FOLE to Sowa\u2019s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).\nThe FOLE superstructure, which is concern with the formalism and semantics of first-order logic, and the FOLE interpretation, which is concerned with database interpretation, are presented in the two papers that follow this one. Two further papers are pending on the integration of federated systems of knowledge: one discusses integration over a fixed type domain and the other discusses integration over a fixed universe.\nFig. 1 : ERA Data Model in FOLE Fig. 2 : Example Fig. 3 : Structure Fig. 4 : Interpreted Structure Fig. 5 : Structure Morphism Fig. 6 : Interpreted Structure Morphism Fig. 7 : FOLE Foundation Fig. 8 : Analogy\nTbl. 1 : FOLE-ERA Correspondence Tbl. 2 : Matrix of six central categories\nFigures and Tables\n1 Following the original discussion of FOLE (Kent [8]), we use \u201cmathematical context\u201d (Goguen [4]) for the mathematical term \u201ccategory\u201d, \u201cpassage\u201d for the term \u201cfunctor\u201d, and \u201cbridge\u201d for the term \u201cnatural transformation\u201d. 2 The theory of classifications and infomorphisms is discussed in the book Information Flow by Barwise and Seligman [1]."}, {"heading": "2 Overview", "text": "A conceptual model for a community represents the information needed by the community \u2014 the content, relationships and constraints necessary to describe the community. The content consists of things of significance to the community (entities), and characteristics of those things (attributes). The relationships are associations between those things. The entities are the core concepts that are used for representing the semantics of the community. Entities are described by attributes, which are the various properties, characteristics, modifiers, aspects or features of entities. Hence, the entity-relationship-attribute (ERA) formalism is a ternary representation for knowledge, since it uses three kinds for representation: entities, attributes and relations. In contrast, the first-order logical environment FOLE (Kent [8]) followed the knowledge representation approach of traditional many-sorted first-order logic (MSFOL). Both the original FOLE formalism and the MSFOL formalism are binary representations for knowledge, since they use two kinds for representation: entities and relations.\nRevised FOLE Terminology. However, the first-order logical environment FOLE can very naturally represent the ERA data model. The idea is that the original FOLE relation represented a nexus of roles, where the roles were played by the original FOLE entities. In order to represent the ERA data model, we think of the original FOLE relations as the new FOLE entities described by a nexus of features or aspects, where the aspects are represented by the new FOLE attributes, which replace the original FOLE entities. In the FOLE representation of the ERA data model, entities and their attributes are primary notions, whereas relationships are secondary notions that are subsumed by other constructs. Some relations (foreign keys, subtypes, sums, ...) have a special representation in FOLE; whereas, other relations can be resolved into concepts (entities) with a nexus of roles.\nTbl. 1 shows the terminological correspondence between the basic components of (old/new) FOLE and ERA. For example, the original FOLE entity type is renamed the new FOLE attribute type (sort), and this corresponds to the ERA attribute type (data type); and the original FOLE relation instance is renamed the new FOLE entity instance (key), and this corresponds to the ERA entity.\nPhilosophy: the ERA of FOLE. As commonly observed, an entity is a thing capable of an independent existence that can be uniquely identified. In natural language, an entity corresponds to a noun. A relationship links entities, and corresponds to\na verb in natural language. Entities and relationships can both have attributes. In natural language, a relational attribute corresponds to a role or case. Inclusion and subtype relationships are special kinds of relationships. A data model can be visualized in terms of entities, relationships and attributes. But in general, relationships can be conceptualized by being converted to entities.\nHence, a data model is more simply conceptualized in terms of entities and attributes. When doing so, there is an implied boundary around the visualization, which converts an entity\u2019s collection of attributes into a list (possibly infinite in size or arity); a signature is the list of attribute types (sorts) associated with an entity type, whereas a tuple is the list of attribute instances (values) associated with an entity instance (key). Entity types can be mapped to the associated signature, and entity instances (primary keys) identify and can be mapped to the associated tuple (horizontal dimension of Fig. 1). In general, types classify instances. Hence, entity types classify keys and sorts classify values (vertical dimension of Fig. 1). Implicit from the ERA data model is an entity type system and multi-sorted logic, which uses boolean operators and quantification, and is defined in terms of signature-based fibers of formulas (queries) in Kent [9].\nIn review, the simplest way to handle things is first to distinguish types from instances along the FOLE classification dimension in Fig. 1, and second to view things (either types or instances) as participating in Whitehead\u2019s fundamental prehension relationship (Sowa [11]) along the FOLE hypergraph dimension in Fig. 1, which links a prehending thing called an entity to a prehended thing called an attribute: \u201can entity has an attribute\u201d. The ERA data model of FOLE uses an inclusive prehension for things; hence, it is a mixed data model; some entities are not attributes, some attributes are not entities, and some are both. For any type in the overlap E\u2229A, any instance of that type is also in the overlap. Foreign keys are examples of things that are both entities and attributes, things in the overlap.\nE : entities A : attributes \u2727\u2726 \u2605\u2725 \u2727\u2726 \u2605\u2725\nE A E \u2229A = \u2205\n\u2727\u2726 \u2605\u2725 \u2727\u2726 \u2605\u2725 E A\nE \u2229A 6= \u2205\n\u2727\u2726 \u2605\u2725 E =A\nDisjoint Model Mixed Model Unified Model\n3 ERA Data Model"}, {"heading": "3.1 Attributes.", "text": "In the ERA data model, attributes are represented by a typed domain consisting of a collection of data types. In FOLE, a typed domain is represented by an attribute classification A = \u3008X,Y, |=A\u3009 consisting of a set of attribute types (sorts) X , a set of attribute instances (data values) Y and an attribute classification relation |=A \u2286X\u00d7Y . For each sort (attribute type) x \u2208 X , the data domain of that type is the A-extent Ax = extA(x) = {y \u2208 Y | y |=A x}. The passage X extA\u2212\u2212\u2212\u2192 \u2118Y maps a sort x\u2208X to its data domain (A-extent) Ax \u2286 Y .\nAn X-signature (header) is a sort list \u3008I, s\u3009, where I s \u2212\u2192 X is a map from an indexing set (arity) I to the set of sorts X . A more visual representation for this signature is (\u00b7 \u00b7 \u00b7 si \u00b7 \u00b7 \u00b7 | i\u2208 I). The mathematical context of X-signatures is List(X). 3 4 A Y -tuple (row) is an list of data values \u3008J, t\u3009, where J t \u2212\u2192 Y is a map from an indexing set (arity) J to the set of data values Y . A more visual representation for this tuple is (\u00b7 \u00b7 \u00b7 tj \u00b7 \u00b7 \u00b7 | j \u2208 J). The mathematical context of Y -tuples is List(Y ). The attribute list classification List(A) = \u3008List(X),List(Y ), |=List(A)\u3009 hasX-signatures as types and Y -tuples as instances, with classification by common arity and universal A-classification: a Y -tuple \u3008J, t\u3009 is classified by an X-signature \u3008I, s\u3009 when J = I and tk |=A sk for all k \u2208 J = I."}, {"heading": "3.2 Entities.", "text": "We distinguish between an entity instance and an entity type. An entity type is a category of existence; entity types classify entity instances. There might be many instances of an entity type, and an entity instance can be classified by many types. An entity instance (entity, for short) is also called an object. Every entity is uniquely identified by a key. In FOLE, entities and their types are collected together locally in an entity classification E = \u3008R,K, |=E\u3009 consisting of a set of entity types R, a set of entity instances (keys) K and an entity classification relation |=E \u2286R\u00d7K. In the database interpretation in \u00a74.4, each entity type r \u2208 R is regarded to be the name for a relation (or table) in the database: for each entity type (relation name) r \u2208 R, the set of primary keys for that type is the E-extent Er = extE(r) = {k \u2208 K | k |=E r}.\n3 List(X) is the comma context List(X) = (Set \u2193X) of X-signatures, where an\nobject \u3008I, s\u3009 is an X-signature and a morphism \u3008I \u2032, s\u2032\u3009 h \u2212\u2192 \u3008I, s\u3009 is an arity function I \u2032 h \u2212\u2192 I that preserves signatures h \u00b7 s = s\u2032; visually, (\u00b7 \u00b7 \u00b7 s\u2032i\u2032 \u00b7 \u00b7 \u00b7 | i\n\u2032 \u2208 I \u2032) = (\u00b7 \u00b7 \u00b7 sh(i\u2032) \u00b7 \u00b7 \u00b7 | i\n\u2032 \u2208 I \u2032). 4 The header for a database table is a signature (list of sorts) \u3008I, s\u3009 \u2208 List(X). Pairs (i : si) from a signature \u3008I, s\u3009 are called attributes (see \u00a7 4.1). Examples of attributes are \u2018(name : Str)\u2019, \u2018(age : Natno)\u2019."}, {"heading": "3.3 Relations.", "text": "Here we discuss how the relational aspect of the ERA data model is handled in FOLE. Some relations are special. One example is subtyping, which specifies that one category of existence is more general than another. This arises when representing the taxonomic aspect of ontologies. Subtyping is handled by the binary sequents 5 in FOLE specifications (discussed further in the (Kent [9])). Some many-to-one relationships can be represented as attributes. But in general, many-to-many relationships are represented in FOLE as entities, whose attributes, each of which plays a thematic role for the relationship, may be other entities. 6\nConsider the example (Fig. 2) of a simple entity-relationship-attribute diagram. Here we have three entities (represented by rectangles), two relationships (represented by diamonds) and numerous attributes (represented by ovals). The works on relationship is many-to-many, and so we can represent this in FOLE as an entity type Activity with four attributes: entry date of sort Date, job descr of sort String, employee of sort Employee, and project of sort Project. Note that attributes employee and project are foreign keys of the Activity entity. 7 Since the works for relationship is many-to-one without any attributes of its own, we can represent this as an attribute called dept of sort Department. This is a foreign key of the Employee entity.\n5 A sequent \u03d5 \u22a2 \u03c8 expresses interpretation widening between formulas. 6 As an example, the \u201cmarriage\u201d binary relation can be represented as a Marriage entity with wife and husband attributes that are themselves Person entities. 7 The Employee type, which plays the employee thematic role for the works on relationship, is both an entity type and an attribute type (sort); any value in the Employee data domain is a key of the Employee entity and a foreign key of the Activity entity.\n4 FOLE Components"}, {"heading": "4.1 Schema.", "text": "The type aspect of the ERA data model is gathered together into a schema. A schema S = \u3008R, \u03c3,X\u3009 consists of a set of sorts (attribute types) X , a set of entity types R and a signature map R \u03c3 \u2212\u2192 List(X). Within the schema S, we think of each r \u2208 R as being an entity type that is locally described by the associated X-signature \u03c3(r) = \u3008I, s\u3009 \u2208 List(X). 8 A more visual representation for this signature mapping is r \u03c3 7\u2212\u2192 (\u00b7 \u00b7 \u00b7 si \u00b7 \u00b7 \u00b7 | i\u2208 I). An ERA-style visualization might be r i\n\u2212\u2212\u2192 \u271e \u271d \u260e \u2706\nsi , where the box encloses the entity type r\u2208R, the oval encloses the attribute type si \u2208X , and the arrow is labeled with the index i\u2208 I. For example, Person name \u2212\u2212\u2212\u2192\n\u271e \u271d \u260e \u2706String or Employee dept \u2212\u2212\u2212\u2192 \u271e \u271d \u260e \u2706Department .\nThe entity type r in the ERA data model corresponds to the relation symbol r in FOLE/MSFOL. Either representation is a kind of nexus. A schema corresponds to a multi-sorted first-order logical language in the FOLE/MSFOL approach to knowledge representation. 9 In the database interpretation of FOLE (Kent [10]), we think of r as being a relation name with associated header \u03c3(r) = \u3008I, s\u3009.\nWe formally link schemas with morphisms. A schema morphism S2 = \u3008R2, \u03c32, X2\u3009 \u3008r,f\u3009 =\u21d2 \u3008R1, \u03c31, X1\u3009 = S1 from schema S2 to schema S1 consists of an sort function f : X2 \u2192 X1 and an entity type function r : R2 \u2192 R1, which preserve signatures by satisfying the condition r \u00b7 \u03c31 = \u03c32 \u00b7 \u2211 f .\nr2 \u2208 R2\n\u3008I, s\u3009 = (\u00b7 \u00b7 \u00b7 si \u00b7 \u00b7 \u00b7 | i\u2208 I) si \u2208X2\nr(r2) \u2208 R1\n(\u00b7 \u00b7 \u00b7 f(si) \u00b7 \u00b7 \u00b7 | i\u2208 I) = \u2211\nf (I, s)\nf(si)\u2208X1\n\u2212 \u2193\u03c32\n\u2212 \u2193 \u03c31\nr 7\u2212\u2212\u2192\n\u2211\nf 7\u2212\u2212\u2192\nS2\n   \n  \n   \n  \nS2\nLet Sch denote the mathematical context of schemas and their morphisms.\n8 There is an associated arity function R \u03b1\n\u2212\u2212\u2212\u2212\u2192 \u03c3 \u25e6 set\nSet : r \u03c3 7\u2212\u2192 \u3008I, s\u3009 set 7\u2212\u2212\u2192 I .\n9 Formulas based on relation symbols can be inductively defined, thus forming extended schemas (Kent [9]). Terms composed of function symbols can be added as constraints between formulas."}, {"heading": "4.2 Universe.", "text": "The instance aspect of the ERA data model is gathered together into a universe. A universe U = \u3008K, \u03c4, Y \u3009 consists of a set of values (attribute instances) Y , a set of keys (entity instances) K and a tuple map K \u03c4 \u2212\u2192 List(Y ). Within the universe U , we think of each key k \u2208 K as being an identifier or name for an object that is locally described by the associated tuple of values \u03c4(k) = \u3008J, t\u3009 \u2208 List(Y ). A more visual representation for this tuple mapping is k \u03c4 7\u2212\u2192 (\u00b7 \u00b7 \u00b7 tj \u00b7 \u00b7 \u00b7 | j \u2208J). Note that, no typing has been mentioned here and no typing restrictions are required. In a universe by itself, we do not require the data values tj to be members of any special data-types.\nAn element of a universe U = \u3008K, \u03c4, Y \u3009 \u2208 Univ is a key ( k \u03c4 7\u2212\u2192 \u3008J, t\u3009 ) with associated list. We can think of such universe elements as object descriptions without attached typing or as tuples untethered from a database table. They develop meaning by being classified by schema elements ( r \u03c3 7\u2212\u2192 \u3008I, s\u3009 ) in a structure (\u00a7 4.3). 10 Hence, a FOLE universe is like the key\u2212value\u00b7list store at the heart of Google\u2019s Spanner database (Google [5]):\n\u201cSpanner\u2019s data model is not purely relational, in that rows must have names. More precisely, every table is required to have an ordered set of one or more primary-key columns. This requirement is where Spanner still looks like a keyvalue store: the primary keys form the name for a row, and each table defines a mapping from the primary-key columns to the non-primary-key columns.\u201d 11\nWe semantically link universes with morphisms. A universe morphism U2 = \u3008K2, \u03c42, Y2\u3009 \u3008k,g\u3009 \u21d0=== \u3008K1, \u03c41, Y1\u3009 = U1 consists of a value (attribute instance) function Y2 g \u2190\u2212 Y1 and a key (entity instance) function K2 k \u2190\u2212 K1, which preserve tuples (instance lists) by satisfying the condition k \u00b7 \u03c42 = \u03c41 \u00b7 \u2211 g.\nk(k1) \u2208 K2\n\u2211\ng (J, t) = (\u00b7 \u00b7 \u00b7 g(tj) \u00b7 \u00b7 \u00b7 | j \u2208 J)\ng(tj)\u2208Y2\nk1 \u2208 K1\n(\u00b7 \u00b7 \u00b7 tj \u00b7 \u00b7 \u00b7 | j \u2208 J) = \u3008J, t\u3009 tj \u2208Y1\n\u2212 \u2193\u03c42\n\u2212 \u2193 \u03c41\nk \u2190\u2212 [\n\u2211\ng\n\u2190\u2212 [\nU2\n  \n  \n  \n  \nU1\nLet Univ denote the mathematical context of universes and their morphisms.\n10 They are somewhat like genes (bits of DNA) without the genomic structure that provides interpretation. 11 When the universe U is the instance aspect of a FOLE structureM with typed domain A, in the database interpretation of that structure (\u00a7 4.4 and Kent [10]), we think of the entity instance k as being a primary key that indexes a row \u03c4 (k) = \u3008I, t\u3009 in the table associated with the relation symbol r \u2208 R with associated header \u03c3(r) = \u3008I, s\u3009. A more visual representation for this tuple mapping is k\n\u03c4 7\u2212\u2192 (\u00b7 \u00b7 \u00b7 ti \u00b7 \u00b7 \u00b7 | i\u2208 I, ti \u2208Asi),\nwhere Asi is the data-type for sort si \u2208X. Here, we do require the data values ti to be members of the special data-types Asi ."}, {"heading": "4.3 Structure.", "text": "The complete ERA data model is incorporated into the notion of a (modeltheoretic) structure in the FOLE representation of knowledge.\nStructures. A FOLE structure M = \u3008E , \u03c3, \u03c4,A\u3009 is a hypergraph of classifications (Fig. 3) \u2014 a two-dimensional construct with the following components:\nattribute classification: typed domain A = attr(M) = \u3008X,Y, |=A\u3009 entity classification: E = ent(M) = \u3008R,K, |=E\u3009\ntype hypergraph: schema S = sch(M) = \u3008R, \u03c3,X\u3009 instance hypergraph: universe U = univ(M) = \u3008K, \u03c4, Y \u3009\nand a list designation \u3008\u03c3, \u03c4 \u3009 : E \u21d2 List(A) with signature map R \u03c3 \u2212\u2192 List(X) and tuple map K \u03c4 \u2212\u2192 List(Y ), whose defining condition states that: if entity k \u2208K is of type r\u2208R, then the description tuple \u03c4(k) = \u3008J, t\u3009 is the same \u201csize\u201d (J = I) as the signature \u03c3(r) = \u3008I, s\u3009 and each data value tn is of sort sn; or interpretively (\u00a7 4.4 and Kent [10]), in a database table all rows are classified by the table header. A FOLE structure embodies the idea of an ERA data model\n(compare Fig. 3 with Fig. 1). Each community of discourse that incorporates the ERA data model will have its own local FOLE structure. 12\nThe entity and attribute-list classifications E and List(A) are equivalent 13\nto their extent diagrams R extE\u2212\u2212\u2212\u2192 Set and List(X) extList(A) \u2212\u2212\u2212\u2212\u2212\u2212\u2192\ntupA Set, and the list\ndesignation is equivalent to its extent diagram morphism ext\u3008\u03c3,\u03c4\u3009 = \u3008\u03c3, \u03c4x\u3009 : \u3008R, extE\u3009 \u2192 \u3008List(X), extList(A)\u3009 consisting of the signature map R \u03c3 \u2212\u2192 List(X)\n12 In anticipation of the discussion in \u00a7 4.4, we illustrate the associated tabular interpretation (3) on the right side of Fig. 3. 13 Any classification A = \u3008X,Y, |=A\u3009 is equivalent to its extent map X extA\u2212\u2212\u2212\u2192 \u2118Y .\nand the bridge extE \u03c4x=\u21d2 \u03c3 \u25e6 extList(A), whose r th-component is the tuple function K(r) = extE(r) \u03c4r\u2212\u2192 extList(A)(\u03c3(r)) = tupA(\u03c3(r)) (see the tabular interpretation (3) in \u00a7 4.4). Hence, any structure M has the interpretive presentation in Fig. 4 (see the discussion on linearization \u00a7 5.2).\nIn the concept of a FOLE structure we have abstracted the (primary) keys from the tuples that they described. The key-embedding construction replaces keys into their tuples.\nDefinition 1. (key embedding) Any FOLE structure M = \u3008E , \u03c3, \u03c4,A\u3009 with signature map R \u03c3 \u2212\u2192 List(X) : r 7\u2192 \u3008I, s\u3009 and tuple map K \u03c4 \u2212\u2192 List(Y ) : k 7\u2192 \u3008I, t\u3009 has a companion key embedding structure M\u0307 = \u3008E , \u03c3\u0307, \u03c4\u0307 , E+A\u3009 consisting of entity classification E, parallel sum typed domain E+A = \u3008R+X,K+Y, |=E+A\u3009, 14 schema \u3008R, \u03c3\u0307, R+X\u3009 with signature map R \u03c3\u0307 \u2212\u2192 List(R+X) : r 7\u2192 \u30081, r\u3009+\u3008I, s\u3009, and universe \u3008K, \u03c4\u0307 ,K+Y \u3009 with tuple map K \u03c4\u0307 \u2212\u2192 List(K+ Y ) : k 7\u2192 \u30081, k\u3009+\u3008I, t\u3009. The signature and tuple maps are injective.\n14 We can think of the entity classification E = \u3008R,K, |=E\u3009 as a type domain. For each sort (attribute type) r \u2208 R, the data domain of that type is the E-extent\nEr = extE(r) = {k \u2208 K | k |=E r}. The passage R extE\u2212\u2212\u2212\u2192 \u2118K maps a sort r\u2208R to its data domain (E-extent) Er \u2286 K.\nStructure Morphisms. In order to allow communities of discourse to interoperate, we define the notion of a morphism between two structures that respects the ERA data model. A structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 (Fig. 5) from source\nstructure M2 = \u3008E2, \u3008\u03c32, \u03c42\u3009,A2\u3009 to target structure M1 = \u3008E1, \u3008\u03c31, \u03c41\u3009,A1\u3009 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\ntyped domain morphism A2 = attr(M2) \u3008f,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 attr(M1) = A1\nentity infomorphism E2 = ent(M2) \u3008r,k\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 ent(M1) = E1\nschema morphism S2 = sch(M2) \u3008r,f\u3009 ===\u21d2 sch(M1) = S1 universe morphism U2 = univ(M2) \u3008k,g\u3009 \u21d0=== univ(M1) = U1\nsatisfying the conditions\ntyped domain morphism g(y1) |=A2 x2 iff y1 |=A1 f(x2)\nentity infomorphism k(k1) |=E2 r2 iff k1 |=E1 r(r2) .\nschema morphism r \u00b7 \u03c31 = \u03c32 \u00b7 \u2211\nf\nuniverse morphism k \u00b7 \u03c42 = \u03c41 \u00b7 \u2211\ng\nR2 R1\nK2 K1\nr\nk\n|=E2 |=E1\n\u2732\n\u271b List(X2) List(X1)\nList(Y2) List(Y1)\n\u2211\nf\n\u2211\ng\n|=List(A2) |=List(A1)\n\u2732\n\u271b\n\u03c32 \u03c31\n\u03c42 \u03c41\n\u2746 \u2746\u276f\n\u2746 \u2746\u276f\n\u2746 \u2746\u2746\u276f\n\u2746 \u2746\u2746\u276f\nschema morphism\nsch(M2) \u3008r,f\u3009\n====\u21d2 sch(M1) \ufe37 \ufe38\ufe38 \ufe37\nE2 \u3008r,k\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 E1\nentity infomorphism\n    \n   \n    \n   \nList ( A2 \u3008f,g\u3009 \u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 A1 )\ntyped domain morphism\n\ufe38 \ufe37\ufe37 \ufe38 univ(M2) \u3008k,g\u3009\n\u21d0==== univ(M1) universe morphism\nFig. 5. Structure Morphism\nThe designation defining condition states that for any k1 \u2208K1 and r2 \u2208R2,\n( k(k1) |=E2 r2 iff k1 |=E1 r(r2) )\nimplies (\n\u03c42(k(k1)) = \u2211 g(\u03c41(k1)) |=List(A2) \u03c32(r2) iff \u03c41(k1) |=List(A1) \u2211 f (\u03c32(r2)) = \u03c31(r(r2)) ) .\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. In the appendix \u00a7 A, we develop Struc as a fibered mathematical context in two orientations: either as the Grothedieck construction of the schema indexed mathematical context of structures Schop struc \u2212\u2212\u2212\u2192 Cxt or as the Grothedieck construction of the universe indexed mathematical context of structures Univop struc \u2212\u2212\u2212\u2192 Cxt. The schema indexed mathematical context of structures is used in Kent [10] to establish the institutional aspect of FOLE.\nAny structure morphismM2 \u3008r,k,f,1Y \u3009 \u2212\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 with identity value map Y 1Y\u2212\u2212\u2192 Y\nhas the interpretive presentation in Fig. 6. 15\n15 Any infomorphism A2 \u3008f,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 A1 has the equivalent condition f \u00b7 extA1 = extA2 \u00b7 g \u22121.\nDefinition 2. (key embedding) Any structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 has\na companion key embedding structure morphism\nM\u03072 = \u3008E2, \u03c3\u03072, \u03c4\u03072, E2+A2\u3009 \u3008r,k,f,f+g\u3009 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008E1, \u03c3\u03071, \u03c4\u03071, E1+A1\u3009 = M\u03071.\nwith the following components:\ntyped domain morphism E2+A2 \u3008r+f,k+g\u3009 \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 E1+A1\nentity infomorphism E2 \u3008r,k\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 E1\nschema morphism S\u03072 = \u3008R2, \u03c3\u03072, R2+X2\u3009 \u3008r,r+f\u3009 ====\u21d2 \u3008R1, \u03c3\u03071, R1+X1\u3009 = S1 universe morphism U2 = \u3008K2, \u03c4\u03072,K2+Y2\u3009 \u3008k,k+g\u3009 \u21d0===== \u3008K1, \u03c4\u03071,K1+Y1\u3009 = U1\nProof. The following conditions must hold.\ntyped domain morphism k(k1) g(y1) |=E2+A2 r2 x2 iff k1 y1 |=E1+A1 r(r1) f(x2) )\nentity infomorphism k(k1) |=E2 r2 iff k1 |=E1 r(r2) .\nschema morphism r \u00b7 \u03c3\u03071 = \u03c3\u03072 \u00b7 \u2211\nr+f\nuniverse morphism k \u00b7 \u03c4\u03072 = \u03c4\u03071 \u00b7 \u2211\nk+g\nWe use the comparable conditions for the original structure morphismM2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212\nM1. The entity infomorphism condition is given. The type domain morphism condition is straightforward. We show the schema morphism condition. The universe morphism condition is similar. The schema morphism condition for the original structure morphism is r \u00b7 \u03c31 = \u03c32 \u00b7 \u2211\nf ; that is, for any r2 \u2208R2, if \u03c32(r2) = \u3008I2, s2\u3009 and \u03c31(r(r2)) = \u3008I1, s1\u3009, then \u3008I1, s1\u3009 = \u2211\nf (I2, s2). Hence, the schema morphism condition for the key-embedding structure morphism holds, since \u03c3\u03071(r(r2)) = \u30081, r(r2)\u3009+\u3008I1, s1\u3009 = \u2211 r(1, r2)+ \u2211 f (I2, s2)\n= \u2211\nr+f\n( \u30081, r2\u3009+\u3008I2, s2\u3009 ) = \u2211 r+f (\u03c3\u03072(r2))\nIntegrity Constraints. Integrity constraints help preserve the validity and consistency of data. Here we briefly explain how various integrity constraints are represented in the ERA data model of FOLE.\nEntity: (primary key rule) Entity integrity states that every table must have a primary key and that the column or columns chosen to be the primary key should be unique and not null. In the ERA data model of FOLE, entity integrity asserts that the universe U = \u3008K, \u03c4, Y \u3009 of a structure M is well-defined. Domain: Domain integrity specifies that all columns in a relational database must be declared upon a defined domain. In the ERA data model of FOLE, domain integrity asserts that the schema S = \u3008R, \u03c3,X\u3009 and the list designation \u3008\u03c3, \u03c4 \u3009 : E \u21d2 List(A) of a structure M are well-defined. Referential: (foreign key rule) Referential integrity states that the foreign-key value of a source table refers to a primary key value of a target table. In the ERA data model of FOLE, referential integrity asserts that the ERA data model of FOLE is a mixed data model.\nAlgebra. For simplicity of presentation, this paper and the paper on FOLE superstructure (Kent [9]) use a simplified form of FOLE, in contrast to the full form presented in Kent [8]. In this paper and Kent [9], schemas are used in place of (many-sorted) first-order logical languages. Schemas are simplified logical languages without function symbols. The main practical result is that signature morphisms \u3008I \u2032, s\u2032\u3009 h \u2212\u2192 \u3008I, s\u3009 are replaced by term vectors \u3008I \u2032, s\u2032\u3009 t \u2212\u21c1 \u3008I, s\u3009 in the full version of FOLE. Signature morphisms are simplified term vectors without function symbols. In the full version of FOLE, equations can be defined between parallel pairs of term vectors \u3008I \u2032, s\u2032\u3009 t,t\u2032\n\u2212\u2212\u21c1 \u3008I, s\u3009, thus allowing the use of equational presentations and their congruences. 16 Also in the full version of FOLE, the tuple map along signature morphisms becomes the algebraic operation along term vectors; hence, formula flow (substitution/quantification) in Kent [9] is lifted from being along signature morphisms to being along term vectors. 17\n16 The tuple relational calculus is a query language for relational databases. In order to use the tuple calculus in the FOLE, we need to enrich with many-sorted constant declarations and equational presentations. Constant declarations are first-order logical languages with sorted nullary function symbols. A constant c of sort x is an x-sorted nullary function symbol x c \u2212\u21c1 \u3008\u2205, 0X\u3009. 17 Let FOLE-ARCH denote Fig. 1. in Kent [8]. FOLE-ARCH is the 3-dimensional visualization of the fibered architecture of FOLE. The upper right quadrant of Fig. 7 corresponds to the the 2-D prism below Rel in FOLE-ARCH. As indicated in FOLE-ARCH, to move from the simple version of the FOLE foundation used here (Fig. 7) to the full version in FOLE-ARCH, we lift from sort sets to algebraic languages and from typed domains to many-sorted algebras."}, {"heading": "4.4 Interpretation.", "text": "In the model theory for traditional many-sorted first-order logic, a (possible world, model) structure corresponds to an interpretation of relation symbols (entity types) in terms of relations in a typed domain. The FOLE approach to logic replaces n-tuples with lists, defines quantification/substitution along signature morphisms (Kent [9]) (or term vectors in the full version [8]), and following databases, incorporates identifiers (keys) for data value lists (tuples) (here and in Kent [10]). The FOLE approach modifies the idea of model-theoretic interpretation as follows. 18\nWe assume that the traditional many-sorted first-order logic language is represented by the schema S = \u3008R, \u03c3,X\u3009 and that the typed domain is represented by the attribute classification A = \u3008X,Y, |=A\u3009. We further assume that these are components of a structure M = \u3008E , \u3008\u03c3, \u03c4 \u3009,A\u3009.\nTraditional: In the traditional approach, an entity type r \u2208 R is interpreted as the set of descriptors of entities in the extent of r. For X-signature \u03c3(r) = \u3008I, s\u3009 \u2208 List(X), this is the subset of Y -tuples IM(r) = \u2118\u03c4(extE(r)) \u2208 \u2118tupA(I, s) = \u2118extList(A)(I, s), an element of the fiber relational order \u3008RelA(I, s),\u2286\u3009. 19 This defines the traditional interpretation function\nR IM\u2212\u2212\u2212\u2192 Rel(A) . (1)\nFor all r \u2208 R, we have the relationships\n\u2118\u03c4(extE(r)) = IM(r) extE(r) \u2286 \u03c4\u22121(IM(r)) . (2)\nDefinition 3. The inequality extE(r) \u2286 \u03c4 \u22121(IM(r)) says that extE(r) is not the morphic closure of itself w.r.t. the tuple map K \u03c4 \u2212\u2192 List(Y ). A structure M is called extensive when the right hand expression in (2) is an equality: extE(r) = \u03c4 \u22121(IM(r)) for any entity type r \u2208 R. 20\nAny structure M with an injective tuple map K \u03c4 \u2212\u2192 List(Y ) has an associated extensive structure. An example is the key-embedding structure M\u0307.\n18 Hence, the notions of (1) a many-sorted first-order logic interpretation, (2) a FOLE structure, and (3) an ERA data model are all equivalent; and each can be implemented as a relational database with associated logic (for more on this, see Kent [10]). 19 The fibered context Rel(A) is defined in the paper on FOLE interpretation (Kent [10]). An object of Rel(A), called an A-relation, is a pair \u3008I, s, R\u3009 consisting of an indexing X-signature \u3008I, s\u3009 and a subset of A-tuples R \u2208 \u2118tupA(I, s) = \u2118extList(A)(I, s). 20 Philosophical note: In the knowledge resources for a community, the entities are of first importance. The tuples in List(Y ) are descriptors, which may or may not have an identity. An entity consists of an identifier k \u2208 K and its descriptor \u03c4 (k) \u2208 \u2118\u03c4 (K). Tuples with identity are those in \u2118\u03c4 (K) \u2286 List(Y ). Two entities that have the same descriptor are said to be \u201cdescriptor-equivalent\u201d.\nTabular: In the database approach, an entity type r \u2208 R is interpreted as a table with the entities (both the keys and their descriptors) being explicit. For X-signature \u03c3(r) = \u3008I, s\u3009 \u2208 List(X), this is the \u3008I, s\u3009-indexed A-table\nK(r) \u03c4r\u2212\u2212\u2192 tupA(I, s)\n\u03c4r(k) = \u3008I, t\u3009, I t \u2212\u2192 Y\nr\n\u3008I, s\u3009 \ufe37 \ufe38\ufe38 \ufe37\nK(r)\n  \n \n\u00b7 \u00b7 \u00b7 i :si \u00b7 \u00b7 \u00b7\nk \u00b7 \u00b7 \u00b7 ti \u00b7 \u00b7 \u00b7\nTM(r) = \u3008K(r), \u03c4r\u3009 (visualized above) consisting of the key set K(r) = extE(r) \u2208 \u2118K and the (descriptor) tuple function K(r) \u03c4r\u2212\u2192 tupA(I, s), a restriction of the tuple function K \u03c4 \u2212\u2192 List(Y ) for the universe U = \u3008K, \u03c4, Y \u3009. The tuple function factors through the traditional interpretation \u03c4r : K(r) \u2192 IM(r) \u2192\u0592 tupA(I, s). This defines the tabular interpretation function\nR TM\u2212\u2212\u2212\u2192 Tbl(A) . 21 (3)\nThe companion key-embedding structure M\u0307 (Def. 1) is most easily understood from its interpretation tables (visualized below).\nK(r) \u03c4\u0307r\u2212\u2212\u2192 tupE+A(1+I, r+s)\n\u03c4\u0307r(k) = \u30081+ I, k+t\u3009, 1 k \u2212\u2192 K, I t \u2212\u2192 Y\n\u30081+I, r+s\u3009 \ufe37 \ufe38\ufe38 \ufe37\nK(r)\n  \n \nr\nk\n\u00b7 :r \u00b7 \u00b7 \u00b7 i :si \u00b7 \u00b7 \u00b7\nk \u00b7 \u00b7 \u00b7 ti \u00b7 \u00b7 \u00b7\n21 The fibered context Tbl(A) is defined in the paper on FOLE interpretation (Kent [10]). An object of Tbl(A), which is called an A-table, is a triple \u3008I, s,K, t\u3009 consisting of an X-signature \u3008I, s\u3009, a set of entities (keys) K, and a tuple function\nK t \u2212\u2192 tupA(I, s) mapping each entity in K to its descriptor A-tuple."}, {"heading": "5 Connections", "text": ""}, {"heading": "5.1 Analogy.", "text": "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE. We recast that here in terms of the FOLE approach to the ERA data model. The analogy between the Sowa hierarchy and FOLE is illustrated graphically in Fig. 8. The twelve categories displayed in the hierarchy (we do not concern ourselves here with the temporal dimension given by the continuent-occurent distinction) and the primitives from which they are generated are arranged in the matrix of Tbl. 2 with the corresponding FOLE terminology in parentheses.\nThe physical-abstract distinction, which corresponds to the Heraclitus distinction physis-logos, is represented by the FOLE classification dimension, a connection between FOLE schemas and FOLE universes. The abstract category corresponds to FOLE types, either entities or attributes. The physical category corresponds to FOLE instances, either entities or attributes. The independent-relativemediating triad is represented by the FOLE hypergraph dimension, a connection between FOLE entities and FOLE attributes. The independent category (firstness) corresponds to FOLE entities that are not attributes. The relative category (secondness) corresponds to FOLE attributes that are not entities. The mediating category (thirdness) corresponds to FOLE list maps between entities and attributes. The triads actuality-prehension-nexus and form-proposition-intention correspond to Whitehead\u2019s categories of existence.\nHere we explain this in more detail. As discussed in \u00a7 4.3, a FOLE structure is a two-dimensional combination of a classification and a hypergraph. The entire hierarchy of the top-level ontological categories is represented by\na FOLE (model-theoretic) structure M = \u3008E , \u3008\u03c3, \u03c4 \u3009,A\u3009. This is appropriate, since a (model-theoretic) structure represents the knowledge in the local world of a community of discourse. The form-proposition-intention triad is represented by a FOLE schema S = \u3008R, \u03c3,X\u3009 with signature function R \u03c3 \u2212\u2192 List(X). The actualityprehension-nexus triad is represented by a FOLE universe U = \u3008K, \u03c4, Y \u3009with tuple function K \u03c4 \u2212\u2192 List(Y ). The firstness subgraph of independent(actuality,form) is represented by a FOLE entity classification E = \u3008R,K, |=E\u3009 between entity instances (keys) and entity types (or a classification between keys and logical formula, more generally; see Kent [9]). The secondness subgraph of relative(prehension,proposition) is represented by a FOLE attribute classification A = \u3008X,Y, |=A\u3009 between attribute instances (data values) and attribute types (sorts). The thirdness subgraph of mediating(nexus,intention) is represented by a FOLE list designation \u3008\u03c3, \u03c4 \u3009 : E \u21d2 List(A). A FOLE entity type loosely corresponds to a form = independent\u2227 abstract. A FOLE entity (key) loosely corresponds to an actuality = independent\u2227 physical. A FOLE sort (attribute type), which is not necessariy linked from a FOLE entity, loosely corresponds to a proposition = relative\u2227 abstract. A FOLE data value (attribute instance) loosely corresponds to a prehension = relative\u2227 physical."}, {"heading": "5.2 Linearization.", "text": "The \u201contology log\u201d Olog formalism (Spivak and Kent [12]) is a category-theoretic model for knowledge representation. As we indicate below, there is a sense in which the FOLE representation subsumes the Olog representation (and viceversa). 22 Let M be a FOLE structure with schema S = \u3008R, \u03c3,X\u3009, universe U = \u3008K, \u03c4, Y \u3009, type domain A = \u3008X,Y, |=A\u3009, entity classification E = \u3008R,K, |=E\u3009, and list designation \u3008\u03c3, \u03c4 \u3009 : E \u21d2 List(A).\n22 This section is closely related to the discussion of the sketch and interpretation associated with a unified relational database in \u00a7 4 of Kent [7]. FOLE structures are adjointly related to relational databases, as shown in the paper on FOLE interpretation (Kent [10]).\nBy using the extent operator (\u00a7 4.3), the following classifications and sets are informationally equivalent.\nclassification set E \u2210\nextE = {(r, k) | r \u2208 R, k \u2208 K, k |=E r}\nA \u2210\nextA = {(x, y) | x \u2208 X, y \u2208 Y, y |=A x}\nList(A) \u2210\nextList(A) = {(I, s, t) | (I, s) \u2208 List(X), (I, t) \u2208 List(Y ), (I, t) |=List(A) (I, s)}\nThe designation property defines a function \u2210\nextE\n\u2210 ext\u3008\u03c3,\u03c4\u3009\n\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u2210\nextList(A), which is the sum of the extent diagrammorphism ext\u3008\u03c3,\u03c4\u3009 = \u3008\u03c3, \u03c4x\u3009 : \u3008R, extE\u3009 \u2192 \u3008List(X), extList(A)\u3009 (Fig. 4 of \u00a7 4.3). By flattening the resulting lists, for each (r, k)\u2208 \u2210 extE , we know that (si, ti)\u2208 \u2210 extA for each index i \u2208 \u03b1(r) = I in the common arity. Hence, the following linearization set 23 is equivalent in information to the structure M:\nlin(M) = {\n\u3008(r, k) \ufe38 \ufe37\ufe37 \ufe38 ent , i, (si, ti) \ufe38 \ufe37\ufe37 \ufe38 attr\n\u3009 | (r, k)\u2208 \u2210 extE , \u03c3(r) = \u3008I, s\u3009, \u03c4 (k) = \u3008I, t\u3009, i\u2208 I } .\nThe FOLE representation is binary, since it has two kinds of type, sorts (attribute types) and entity types. The Olog representation is unary, since it has only one kind of type, the abstract concept. 24 However, the FOLE representation can be transformed to the Olog representation by the process of linearization. If we restrict FOLE to the unified model, identifying entities with attributes E = A, by separating the type/instance information in the linearization set lin(M) via the extent operator along the classification dimension (Fig. 1), we get the basis for the Olog data model, consisting of three notions: types, aspects, and facts. Types, which represent things, are depicted by nodes in Olog; aspects, which represent functional relationships between things, are depicted by edges in Olog; and facts, which represent assertions, are depicted by path equations in Olog.\nOlog types and aspects are covered by the linearization process discussed here. Olog facts correspond to the formalism discussed (indirectly) in the FOLE superstructure (Kent [9]) and (more directly) in the full form of FOLE (Kent [8]).\nr typ\n(r,i) \u2212\u2212\u2212\u2192 si\ntyp\n}\nS a schema context\n\u2744 ext\n\u2744 M an interpretation passage\nM (r) ext(r) M (i) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03c4r \u00b7 tup(\u03c0i) M (si) ext(si)\n}\nSet the context of sets\nk 7\u2212\u2212\u2192 ti\n23 The linearization set lin(M) loosely corresponds to the following: (1) the table used in the entity-attribute-value (EAV) data model, where data is recorded in three columns: the entity component is a foreign key into an object information table, the attribute component is a foreign key into an attribute definition table, and the value component is the value of the attribute; and (2) the labelled directed graph used in the resource description framework (RDF) data model, where each subject-predicateobject triple is regarded as an edge in the graph. 24 See \u00a7 4.4 of [12] for further discussion of binary/unary knowledge representations.\nOlog Database Schema S: By projecting the type components out of the linearization set lin(M), define a graph G whose node set is R = X and whose edge set is \u2210\nr\u2208R=X \u03b1(r). Picture the graph G as follows:\nG = { r (r,i) \u2212\u2212\u2212\u2192 si \u2223 \u2223 \u2223 \u03c3(r) = \u3008I, s\u3009, i\u2208 I, with r, si \u2208 R = X } .\nThe schema mathematical context S = G\u2217 is the path context of graph G. The graph G corresponds to a many-sorted unary algebraic language O = \u3008X,\u2126\u3009, where \u2126 is essentially the opposite of G: the collection of sets of function (operator) symbols \u2126 = {\u2126si,\u30081,r\u3009 | sort si \u2208 X, unary signature \u30081, r\u3009 \u2208 List(X)} with each (r, i) \u2208 \u2126si,\u30081,r\u3009 being an si-sorted r = \u30081, r\u3009-ary function symbol si (r,i) \u2212\u2212\u2212\u21c1 r = \u30081, r\u3009. 25 The opposite of the schema context is a subcontext (no cotupling) of the term context TermO inc \u2190\u2212\u2212\u0593 Sop. An Olog fact corresponds to a linear O-equation (t= t\u0302) : \u30081, s\u3009\u21c1 \u30081, s\u2032\u3009.\nOlog Database Instance M : Using extent, define a passage S = G\u2217 M \u2212\u2192 Set\nwhich maps a node r in S to the extent M (r) = K(r) = ext(r) and maps an edge r (r,i) \u2212\u2212\u2212\u2192 si in S to the function M (r)\nM (r,i) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 \u03c4r \u00b7 tup(\u03c0i) M (si). 26 The\nfunctional language O = \u3008X,\u2126\u3009 mentioned above has an O-algebra \u3008A, \u03b4\u3009 consisting of the X-sorted collection of extents {Ax = ext(x) \u2286 Y | x \u2208 X},\nwhere \u03b4 assigns the \u30081, r\u3009-ary si-sorted function M (r) = Ar = A \u30081,r\u3009 \u03b4(r,i) \u2212\u2212\u2212\u2212\u2192 M (r,i) Asi = M (si) to each function symbol si (r,i) \u2212\u2212\u2212\u21c1 r = \u30081, r\u3009. 27 The interpretation passage TermopO A \u2212\u2192 Set inductively define by this O-algebra contains the database instance as a subfunctorM = incop\u25e6 A. Any equation satisfied by the Olog database interpretation M is also satisfied by the interpretation passage A. 28\n25 Define \u3008X,\u2126\u3009-term \u3008I, s\u3009 r \u2212\u21c1 \u30081, r\u3009 = r as the cotupling of {si (r,i) \u2212\u2212\u2212\u21c1 r = \u30081, r\u3009 | i\u2208 I},\nso that si (r,i) \u2212\u2212\u2212\u21c1 r = \u30081, r\u3009 is the composite si \u03c0i\u2212\u21c1 \u3008I, s\u3009 r \u2212\u21c1 \u30081, r\u3009 = r.\n26 A projection M (r) = ext(r) \u03c4r\u2212\u2192 tup(I, s) tup(\u03c0i)\u2212\u2212\u2212\u2212\u2192 tup(1, si) = ext(si) = M (si) of the tabular interpretation in \u00a7 4.4. 27 \u03b4 assigns the table M (r) = ext(r) \u03b4r\u2212\u2192 \u03c4r tup(I, s) = \u220f i\u2208 I Asi = \u220f i\u2208 I M (si) (a\ntupling) to the cotupling \u3008I, s\u3009 r \u2212\u21c1 r.\n28 The interpretation passage satisfies an O-equation (t= t\u0302) : \u3008I, s\u3009\u21c1 \u3008I \u2032, s\u2032\u3009 when the operations coincide A(t) = A(t\u0302) : A(I, s) \u2190 A(I \u2032, s\u2032) in Set (see Kent [8])."}, {"heading": "6 Conclusion", "text": "The ERA data model describes the conceptual model for a community of discourse, which can be used as the foundation for designing relational databases. The first-order logical environment FOLE provides a rigorous and principled approach to distributed inter-operable first-order information systems, which integrates ontologies and databases into a unified framework. In this paper, we have discussed in detail the representation of elements of the ERA data model with components of the FOLE logical environment, described interpretation basics, and illustrated the connections between FOLE and other data models in knowledge representation. In the near future, we will complete the presentation of the FOLE logical environment by discussing the formalism and semantics of many-sorted logic in the paper Kent [9] and database interpretation in the paper Kent [10]. After this, two papers are pending on the integration of federated systems of knowledge, either over a fixed type domain or over a fixed universe."}, {"heading": "A The Fibered Context of Structures.", "text": "In order to allow communities of discourse to interoperate, we define the notion of a morphism between two structures that respects the ERA data model. This describes the mathematical context of structures Struc as a fibered mathematical context in two orientations: the Grothedieck construction of the schema indexed mathematical context Schop strucf \u2212\u2212\u2212\u2212\u2212\u2192Cxt or the Grothedieck construction of the universe indexed mathematical context Univop strucg\n\u2212\u2212\u2212\u2212\u2212\u2192Cxt. The schema indexed mathematical context of structures is used in the paper [9] on FOLE superstructure to establish the institutional aspect of the FOLE. Each orientation is developed in three steps: the structure fiber context for a single indexing object, the structure fiber passage along an indexing morphism, the fibered mathematical context Struc of structures and structure morphisms as the Grothedieck construction for this orientation. This dual development of the mathematical context of structures Struc (Prop. 2) is based upon and mirrors a dual development of the mathematical context of classifications Cls (Prop. 1).\nA.1 An Exemplar.\nThe mathematical context of classifications Cls is a fibered mathematical context in two orientations: the Grothedieck construction of the type set indexed mathematical context Setop clsf \u2212\u2212\u2212\u2192Cxt or the Grothedieck construction of the instance set indexed mathematical context Setop clsg \u2212\u2212\u2212\u2192Cxt.\nProposition 1. Any infomorphism C2 = \u3008X2, Y2, |=2\u3009 \u3008f,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008X1, Y1, |=1\u3009 = C1\nin the mathematical context of classifications Cls, with type function projection X2 f \u2212\u2192 X1 and instance function projection Y2 g \u2190\u2212 Y1, has dual factorizations\nCls(X2) \ufe37 \ufe38\ufe38 \ufe37\n\ufe38 \ufe37\ufe37 \ufe38\nCls(Y1)\nC2 cls f f (C1) = \u3008X2, Y1, |=f \u3009\nC1\u3008X2, Y1, |=g\u3009 = cls g g (C2)\ng \u30081X2 , g\u3009\nf\n\u3008f, 1Y1 \u3009\ng\n\u30081X2 , g\u3009\nf \u3008f, 1Y1 \u3009\n\u2212\u2212\u2212\u21c0\u21bd \u2212\n\u2212\u2212\u2212\u21c0\u21bd \u2212\n\u21bf\u21c2\u21bf\u21c2\nwhere clsff (C1) = f \u22121(C1) = \u3008X2, Y1, |=f \u3009 = \u3008X2, Y1, |=g\u3009 = g \u22121(C2) = cls g g (C2).\nProof. y1 |=g x2 iff g(y1) |=C2 x2 iff y1 |=C1 f(x2) iff y1 |=f x2.\nThe top-right factorization consists of a Cls(X2)-morphism C2 g\n\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u30081X2 ,g\u3009 clsff (C1)\nand the Cth1 component cls f f (C1) f\n\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008f,1Y1\u3009 C1 of a bridge cls f\nf \u25e6 incX2 \u03c7\u0300f ==\u21d2\nincX1 . This factors through theX2-classification cls f f (C1), which is the fiber passage image along the type function X2 f \u2212\u2192 X1 of the the X1-classification C1. The left-bottom factorization consists of the Cth2 component C2 g\n\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u30081X2 ,g\u3009 clsgg (C2) of\na bridge clsgg \u25e6 incY1 \u03c7\u0301g \u21d0== incY2 and a Cls(Y1)-morphism cls g g (C2) f\n\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008f,1Y1 \u3009 C1.\nThis factors through the Y1-classification cls g g (C2), which is the fiber passage image along the instance function Y2 g \u2190\u2212 Y1 of the the Y2-classification C2.\nA.2 Schema Orientation.\nThe fibered mathematical context Struc of structures and structure morphisms can be developed as the Grothedieck construction of a schema indexed mathematical context. This approach using schema indexing corresponds to the use of type-set indexing in \u00a7 A.1, and was the approach used in the paper (Kent [8]).\n1. For a fixed schema S, we define the structure fiber context Struc(S). 2. For a schema morphism S2 \u3008r,f\u3009 ===\u21d2 S1, we define the structure fiber passage\nStruc(S2) strucf\u3008r,f\u3009 \u2190\u2212\u2212\u2212\u2212\u2212\u2212 Struc(S1).\n3. We define the fibered mathematical context Struc of structures and structure morphisms to be the Grothedieck construction of the schema indexed\nmathematical context Schop strucf \u2212\u2212\u2212\u2212\u2192 Cxt.\nFixed Schema. Let S = \u3008R, \u03c3,X\u3009 \u2208 Sch be a fixed schema. We define the notion of a morphism between two (fixed schema) S-structures that respects the ERA data model. In these morphisms, the schema remains fixed, but the attribute and entity instances (data values and keys) are formally linked by maps that respect universe tuple, typed domain extent and entity interpretation. An S-structure morphism M2 \u3008k,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 M1 over a fixed schema S = \u3008R, \u03c3,X\u3009 is a universe mor-\nphism univ(M2) \u3008k,g\u3009 \u21d0=== univ(M1), where attr(M2) \u30081X ,g\u3009 \u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 attr(M1) is an\ninfomorphism in Cls(X) over the sort set X , and ent(M2) \u30081R,k\u3009 \u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 ent(M1) is an infomorphism in Cls(R) over the entity type set R. 29 S-structure morphisms compose component-wise. Let Struc(S) denote the fiber context of structures over the fixed schema S.\nStructure Fiber Passage. We define the indexed context Schop strucf\n\u2212\u2212\u2212\u2212\u2192 Cxt. Given a schema S, there is a fiber context of structures Struc(S) with that schema. Given a schema morphism S2 \u3008r,f\u3009 ===\u21d2 S1, there is a fiber passage of structures Struc(S2) strucf\u3008r,f\u3009 \u2190\u2212\u2212\u2212\u2212\u2212\u2212 Struc(S1): a structure M1 = \u3008E1, \u3008\u03c31, \u03c41\u3009,A1\u3009 \u2208 Struc(S1) is mapped to a structureM2 = struc f \u3008r,f\u3009(M1) = \u3008r \u22121(E1), \u3008\u03c32, \u03c41\u3009, f \u22121(A1)\u3009 \u2208 Struc(S2). M2 is called the reduct of M1 and M1 is called the expansion of\nM2. The two are linked struc f \u3008r,f\u3009(M1) \u03c7\u0300M1\u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008r,f\u3009 M1 by a structure morphism,\nwhich is the Mth1 component of a bridge struc f \u3008r,f\u3009 \u25e6 incS2 \u03c7\u0300\u3008r,f\u3009 ====\u21d2 incS1 .\n29 Hence, the target type domain is the inverse image of the source type domain attr(M1) = g \u22121(attr(M2)) = cls g\ng (attr(M2)) and the target entity classification is the inverse image of the source entity classification ent(M1) = k\u22121(ent(M2)) = cls g\nk (ent(M2)). By combining entity/attribute inverse image classifications, the target structure M1 is the inverse image struc g \u3008k,g\u3009(M2) = \u3008k\u22121(ent(M2)), \u3008\u03c3, \u03c41\u3009, g \u22121(attr(M2))\u3009 of the source structure M2 (\u00a7 A.3). The two are bridged M2 \u3008k,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 struc g \u3008k,g\u3009(M2) = M1 by the structure morphism.\nStruc(S2) Struc(S1)\nStruc\nstrucf\u3008r,f\u3009\nincS2 incS1\n\u03c7\u0300\u3008r,f\u3009 ===\u21d2\n\u271b\n\u274f \u274f \u274f\u274f\u276b\n\u2721 \u2721\n\u2721\u2721\u2722\nr\u22121(E1)\n\u2211\u22121 f (List(A1)) = List(f \u22121(A1))\n\u3008\u03c32, \u03c41\u3009\nE1\nList(A1)\n\u3008\u03c32, \u03c42\u3009\n\u3008r,1K1 \u3009\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212\nList(f, 1Y1 )\n\u2212\u21c0\u21bd\u2212\n\ufe38 \ufe37\ufe37 \ufe38\nstrucf\u3008r,f\u3009(M1) (\u03c7\u0300\u3008r,f\u3009)M1\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008r,1K1 ,f,1Y1 \u3009 M1\nMultiple Universes. The Grothedieck construction of the schema indexed mathematical context Schop strucf\n\u2212\u2212\u2212\u2212\u2192 Cxt is the fibered mathematical context Struc of structures and structure morphisms. A structure M is as described in \u00a7 4.3 (Fig. 3). A structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 from source structure M2 to\ntarget structure M1 consists of a schema morphism S2 \u3008r,f\u3009 ===\u21d2 S1 from source schema S2 to target structure S1 and a morphism\nM2 = \u3008E2, \u3008\u03c32, \u03c42\u3009,A2\u3009 \u3008k,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008r \u22121(E1), \u3008\u03c32, \u03c41\u3009, f \u22121(A1)\u3009 = struc f \u3008r,f\u3009(M1)\nin the fiber mathematical context of structures Struc(S2). Hence, a structure morphism satisfies the following conditions.\nlist preservation\nr \u00b7 \u03c31 = \u03c32 \u00b7 \u2211\nf\nk \u00b7 \u03c42 = \u03c41 \u00b7 \u2211\ng\ninfomorphisms\nk1 |=E1 r(r2) iff k(k1) |=E2 r2 y1 |=A1 f(x2) iff g(y1) |=A2 x2\nThus, a structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 (Fig. 5 in \u00a7 4.3) from source\nstructure M2 = \u3008E2, \u3008\u03c32, \u03c42\u3009,A2\u3009 to target structure M1 = \u3008E1, \u3008\u03c31, \u03c41\u3009,A1\u3009 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\nuniverse morphism U2 = univ(M2) \u3008k,g\u3009 ===\u21d2 univ(M1) = U1\nschema morphism S2 = sch(M2) \u3008r,f\u3009 ===\u21d2 sch(M1) = S1\ntyped domain morphism A2 = attr(M2) \u3008f,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 attr(M1) = A1\nentity infomorphism E2 = ent(M2) \u3008r,k\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 ent(M1) = E1\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. (Fig. 7 in \u00a7 4.3)\nA.3 Universe Orientation.\nAs evident from the type-instance duality in Fig. 3 and Fig. 5 of \u00a7 4, the fibered mathematical context Struc of structures and structure morphisms can be developed from the dual standpoint \u2014 the Grothedieck construction of a universe indexed mathematical context. This approach using universe indexing corresponds to the use of instance-set indexing in \u00a7 A.1.\n1. For a fixed universe U , we define the structure fiber context Struc(U). 2. For a universe morphism U2 \u3008k,g\u3009 \u21d0=== U1, we define the structure fiber passage\nStruc(U2) strucg\u3008k,g\u3009 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 Struc(U1).\n3. We define the fibered mathematical context Struc of structures and structure morphisms to be the Grothedieck construction of the universe indexed\nmathematical context Univop strucg \u2212\u2212\u2212\u2212\u2192 Cxt\nFixed Universe. Let U = \u3008K, \u03c4, Y \u3009 \u2208 Univ be a fixed universe. We define the notion of a morphism between two (fixed universe) U-structures that respects the ERA data model. In these morphisms, the universe remains fixed, but the attribute types (sorts) and entity types are formally linked by maps that respect schema signature, typed domain extent and entity interpretation. A U-structure morphism M2 \u3008r,f\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 M1 over a fixed universe U = \u3008K, \u03c4, Y \u3009 is a schema mor-\nphism sch(M2) \u3008r,f\u3009 ===\u21d2 sch(M1), where attr(M2) \u3008f,1Y \u3009 \u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 attr(M1) is an in-\nfomorphism in Cls(Y ) over the value set Y , and ent(M2) \u3008r,1K\u3009 \u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 ent(M1) is an infomorphism in Cls(K) over the key set K. 30 Here, M2 is called the reduct of M1 and M1 is called the expansion of M2. The two are bridged\nM2 = struc f \u3008r,f\u3009(M1) \u3008r,f\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 M1 by the structure morphism. 31 U-structure morphisms compose component-wise. Let Struc(U) denote the fiber context of structures over the fixed universe U .\nStructure Fiber Passage. We define the indexed context Univop strucg\n\u2212\u2212\u2212\u2212\u2192 Cxt. Given a universe U , there is a fiber context of structures Struc(U) with that universe. Given a universe morphism U2 \u3008k,g\u3009 \u21d0=== U1, there is a fiber passage of structures Struc(U2) strucg\u3008k,g\u3009 \u2212\u2212\u2212\u2212\u2212\u2212\u2192 Struc(U1): a structureM2 = \u3008E2, \u3008\u03c32, \u03c42\u3009,A2\u3009 \u2208\n30 Hence, the source type domain is the inverse image of the target type domain attr(M2) = f \u22121(attr(M1)) = cls f\nf (attr(M1)) and the source entity classification is the inverse image of the target entity classification ent(M2) = r\u22121(ent(M1)) = cls f\nr (ent(M1)). By combining entity/attribute inverse image classifications, the source structure M2 is the inverse image struc f \u3008r,f\u3009(M1) = \u3008r\u22121(ent(M1)), \u3008\u03c32, \u03c4\u3009, f \u22121(attr(M1))\u3009 of the target structure M1 (\u00a7 A.2). 31 When this definition is extended to formulas, one gets the notion of an interpretation of first-order logic (extended to the many-sorted case) given in (Barwise and Selman [1]).\nStruc(U2) is mapped to a structureM1 = struc g \u3008k,g\u3009(M2) = \u3008k \u22121(E2), \u3008\u03c32, \u03c41\u3009, g \u22121(A2)\u3009 \u2208 Struc(U1). The two are linked M2 \u03c7\u0301M2 \u21bc\u2212\u2212\u2212\u2212 \u21c1 \u3008k,g\u3009 strucg\u3008k,g\u3009(M2) by a structure morphism, which is theMth2 component of a bridge incU2 \u03c7\u0301\u3008k,g\u3009 ====\u21d2 strucg\u3008k,g\u3009 \u25e6 incU1 .\nStruc(U2) Struc(U1)\nStruc\nstrucg\u3008k,g\u3009\nincU2 incU1\n\u03c7\u0301\u3008k,g\u3009 ====\u21d2\n\u2732\n\u274f \u274f \u274f\u274f\u276b\n\u2721 \u2721\n\u2721\u2721\u2722\nk\u22121(E2)\n\u2211\u22121 g (List(A2)) = List(g \u22121(A2))\n\u3008\u03c32, \u03c41\u3009\nE2\nList(A2)\n\u3008\u03c32, \u03c42\u3009\n\u30081R2 ,k\u3009 \u21bc\u2212\u2212\u2212\u2212\u2212\u2212 \u21c1\nList(1X2 , g)\n\u21cc\n\ufe38 \ufe37\ufe37 \ufe38\nstrucg\u3008k,g\u3009(M2) (\u03c7\u0301\u3008k,g\u3009)M2\n\u21bc\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212 \u21c1 \u30081R2 ,k,1X2 ,g\u3009 M2\nMultiple Universes. The Grothedieck construction of the universe indexed mathematical context Univop strucg\n\u2212\u2212\u2212\u2212\u2192 Cxt is the fibered mathematical context Struc of structures and structure morphisms. A structure M is as described in \u00a7 4.3 (Fig. 3). A structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 from source structure M2\nto target structure M1 consists of a universe morphism U2 \u3008k,g\u3009 \u21d0=== U1 to target structure U2 from source structure U1 and a morphism\nstrucg\u3008k,g\u3009(M2) = \u3008k \u22121(E2), \u3008\u03c32, \u03c41\u3009, g \u22121(A2)\u3009 \u3008r,f\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 \u3008E1, \u3008\u03c31, \u03c41\u3009,A1\u3009 = M1\nin the fiber mathematical context of structures Struc(U1). Hence, a structure morphism satisfies the following conditions.\nlist preservation\nr \u00b7 \u03c31 = \u03c32 \u00b7 \u2211\nf\nk \u00b7 \u03c42 = \u03c41 \u00b7 \u2211\ng\ninfomorphisms\nk1 |=E1 r(r2) iff k(k1) |=E2 r2 y1 |=A1 f(x2) iff g(y1) |=A2 x2\nThus, a structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1 (Fig. 5 in \u00a7 4.3) from source\nstructure M2 = \u3008E2, \u3008\u03c32, \u03c42\u3009,A2\u3009 to target structure M1 = \u3008E1, \u3008\u03c31, \u03c41\u3009,A1\u3009 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\nuniverse morphism U2 = univ(M2) \u3008k,g\u3009 ===\u21d2 univ(M1) = U1\nschema morphism S2 = sch(M2) \u3008r,f\u3009 ===\u21d2 sch(M1) = S1\ntyped domain morphism A2 = attr(M2) \u3008f,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 attr(M1) = A1\nentity infomorphism E2 = ent(M2) \u3008r,k\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 ent(M1) = E1\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. (Fig. 7 in \u00a7 4.3)\nProposition 2. (compare Prop. 1) Any structure morphism M2 \u3008r,k,f,g\u3009 \u2212\u2212\u2212\u2212\u2212\u21c0\u21bd \u2212 M1,\nwith schema morphism projection S2 \u3008r,f\u3009 ===\u21d2 S1 and universe morphism projection U2 \u3008k,g\u3009 \u21d0=== U1, has dual factorizations (see the diagram below).\nStruc(S2) \ufe37 \ufe38\ufe38 \ufe37\n\ufe38 \ufe37\ufe37 \ufe38\nStruc(U1)\nM2 struc f \u3008r,f\u3009(M1)\nM1struc g \u3008k,g\u3009(M2)\n\u3008k, g\u3009\n\u3008r, f\u3009\n\u3008k, g\u3009\n\u3008r, f\u3009\n\u2212\u2212\u2212\u21c0\u21bd \u2212\n\u2212\u2212\u2212\u21c0\u21bd \u2212\n\u21bf\u21c2\u21bf\u21c2\nThe top-right factorization (corresponding to the schema orientation of \u00a7 A.2) consists of a Struc(S2)-morphism M2 \u3008k,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 strucf\u3008r,f\u3009(M1) and the M th 1 component strucf\u3008r,f\u3009(M1) \u3008r,f\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 M1 of a bridge struc f \u3008r,f\u3009 \u25e6 incS2 \u03c7\u0300\u3008r,f\u3009 ====\u21d2 incS1 . The left-bottom factorization (corresponding to the universe orientation of \u00a7 A.3) consists of the Mth2 component M2 \u3008k,g\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 strucg\u3008k,g\u3009(M2) of a bridge incU2 \u03c7\u0301\u3008k,g\u3009 ====\u21d2\nstrucg\u3008k,g\u3009 \u25e6 incU1 and a Struc(U1)-morphism struc g \u3008k,g\u3009(M2) \u3008r,f\u3009 \u2212\u2212\u2212\u21c0\u21bd \u2212 M1."}], "references": [{"title": "Information Flow: The Logic of Distributed Systems.+", "author": ["J. Barwise", "J. Seligman"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1997}, {"title": "Formal Concept Analysis: Mathematical Foundations", "author": ["B. Ganter", "R. Wille"], "venue": "Springer, New York", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1999}, {"title": "A categorical manifesto", "author": ["J. Goguen"], "venue": "Mathematical Structures in Computer Science 1, 49\u201367", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1991}, {"title": "Ling Liu and M", "author": ["Gruber", "T. \u201cOntology\u201d. In"], "venue": "Tamer \u00d6zsu (eds.) The Encyclopedia of Database Systems, Springer-Verlag", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2009}, {"title": "Database Semantics", "author": ["R.E. Kent"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "The First-order Logical Environment", "author": ["R.E. Kent"], "venue": "Pfeiffer, H.D., Ignatov, D.I., Poelmans, J., and Nagarjuna G. (eds.) Conceptual Structures in Research and Education, LNCS vol. 7735, pp. 210\u2013230. Springer, Heidelberg", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "Knowledge Representation: Logical, Philosophical, and Computational Foundations", "author": ["J.F. Sowa"], "venue": "Brookes/Coles", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2000}, {"title": "Ologs: a categorical framework for knowledge representation", "author": ["D.I. Spivak", "R.E. Kent"], "venue": "PLoS ONE 7(1): e24274. doi:10.1371/journal.pone.0024274.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 5, "context": "This paper discusses the representation of ontologies in the first-order logical environment FOLE (Kent [8]).", "startOffset": 104, "endOffset": 107}, {"referenceID": 3, "context": "An ontology defines the primitives with which to model the knowledge resources for a community of discourse (Gruber [6]).", "startOffset": 116, "endOffset": 119}, {"referenceID": 5, "context": "The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]).", "startOffset": 128, "endOffset": 131}, {"referenceID": 4, "context": "The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]).", "startOffset": 323, "endOffset": 326}, {"referenceID": 1, "context": "The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).", "startOffset": 143, "endOffset": 146}, {"referenceID": 0, "context": "The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).", "startOffset": 191, "endOffset": 194}, {"referenceID": 5, "context": "The first-order logical environment FOLE (Kent [8]) is a framework for defining the semantics and formalism of logic and databases in an integrated and coherent fashion.", "startOffset": 47, "endOffset": 50}, {"referenceID": 6, "context": "In \u00a7 5 we connect FOLE to Sowa\u2019s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).", "startOffset": 74, "endOffset": 78}, {"referenceID": 7, "context": "In \u00a7 5 we connect FOLE to Sowa\u2019s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).", "startOffset": 146, "endOffset": 150}, {"referenceID": 5, "context": "1 Following the original discussion of FOLE (Kent [8]), we use \u201cmathematical context\u201d (Goguen [4]) for the mathematical term \u201ccategory\u201d, \u201cpassage\u201d for the term \u201cfunctor\u201d, and \u201cbridge\u201d for the term \u201cnatural transformation\u201d.", "startOffset": 50, "endOffset": 53}, {"referenceID": 2, "context": "1 Following the original discussion of FOLE (Kent [8]), we use \u201cmathematical context\u201d (Goguen [4]) for the mathematical term \u201ccategory\u201d, \u201cpassage\u201d for the term \u201cfunctor\u201d, and \u201cbridge\u201d for the term \u201cnatural transformation\u201d.", "startOffset": 94, "endOffset": 97}, {"referenceID": 0, "context": "2 The theory of classifications and infomorphisms is discussed in the book Information Flow by Barwise and Seligman [1].", "startOffset": 116, "endOffset": 119}, {"referenceID": 5, "context": "In contrast, the first-order logical environment FOLE (Kent [8]) followed the knowledge representation approach of traditional many-sorted first-order logic (MSFOL).", "startOffset": 60, "endOffset": 63}, {"referenceID": 6, "context": "1, and second to view things (either types or instances) as participating in Whitehead\u2019s fundamental prehension relationship (Sowa [11]) along the FOLE hypergraph dimension in Fig.", "startOffset": 131, "endOffset": 135}, {"referenceID": 5, "context": "For simplicity of presentation, this paper and the paper on FOLE superstructure (Kent [9]) use a simplified form of FOLE, in contrast to the full form presented in Kent [8].", "startOffset": 169, "endOffset": 172}, {"referenceID": 5, "context": "in Kent [8].", "startOffset": 8, "endOffset": 11}, {"referenceID": 5, "context": "The FOLE approach to logic replaces n-tuples with lists, defines quantification/substitution along signature morphisms (Kent [9]) (or term vectors in the full version [8]), and following databases, incorporates identifiers (keys) for data value lists (tuples) (here and in Kent [10]).", "startOffset": 167, "endOffset": 170}, {"referenceID": 5, "context": "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE.", "startOffset": 28, "endOffset": 31}, {"referenceID": 6, "context": "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE.", "startOffset": 171, "endOffset": 175}, {"referenceID": 7, "context": "The \u201contology log\u201d Olog formalism (Spivak and Kent [12]) is a category-theoretic model for knowledge representation.", "startOffset": 51, "endOffset": 55}, {"referenceID": 4, "context": "22 This section is closely related to the discussion of the sketch and interpretation associated with a unified relational database in \u00a7 4 of Kent [7].", "startOffset": 147, "endOffset": 150}, {"referenceID": 5, "context": "Olog facts correspond to the formalism discussed (indirectly) in the FOLE superstructure (Kent [9]) and (more directly) in the full form of FOLE (Kent [8]).", "startOffset": 151, "endOffset": 154}, {"referenceID": 7, "context": "4 of [12] for further discussion of binary/unary knowledge representations.", "startOffset": 5, "endOffset": 9}, {"referenceID": 5, "context": "28 The interpretation passage satisfies an O-equation (t= t\u0302) : \u3008I, s\u3009\u21c1 \u3008I , s\u3009 when the operations coincide A(t) = A(t\u0302) : A(I, s) \u2190 A(I , s) in Set (see Kent [8]).", "startOffset": 160, "endOffset": 163}, {"referenceID": 5, "context": "1, and was the approach used in the paper (Kent [8]).", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "31 When this definition is extended to formulas, one gets the notion of an interpretation of first-order logic (extended to the many-sorted case) given in (Barwise and Selman [1]).", "startOffset": 175, "endOffset": 178}], "year": 2015, "abstractText": "This paper discusses the representation of ontologies in the first-order logical environment FOLE (Kent [8]). An ontology defines the primitives with which to model the knowledge resources for a community of discourse (Gruber [6]). These primitives, consisting of classes, relationships and properties, are represented by the entity-relationshipattribute ERA data model (Chen [2]). An ontology uses formal axioms to constrain the interpretation of these primitives. In short, an ontology specifies a logical theory. This paper is the first in a series of three papers that provide a rigorous mathematical representation for the ERA data model in particular, and ontologies in general, within the first-order logical environment FOLE. The first two papers show how FOLE represents the formalism and semantics of (many-sorted) first-order logic in a classification form corresponding to ideas discussed in the Information Flow Framework (IFF [13]). In particular, this first paper provides a foundation that connects elements of the ERA data model with components of the first-order logical environment FOLE, and the second paper (Kent [9]) provides a superstructure that extends FOLE to the formalisms of firstorder logic. The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]). The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).", "creator": "LaTeX with hyperref package"}}}