{"id": "1602.04473", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2016", "title": "Large-Scale Reasoning with OWL", "abstract": "As the semantic web grows in size and importance, more and more knowledge is stored in machine-readable formats such as the Web Ontology Language OWL. This paper outlines common approaches to efficient reasoning on large amounts of data, consisting of billions ($10 ^ 9) of triples. Therefore, OWL and its sublanguages, forward and backward chaining techniques, the WebPIE argumentator is discussed extensively as an example of forward concatenation using MapReduce for materialization, the QueryPIE argumentator is presented as a backward chaining / hybrid approach using query rewriting, and an overview of other argumentators such as OWLIM and TrOWL is given.", "histories": [["v1", "Sun, 14 Feb 2016 16:18:32 GMT  (291kb,D)", "http://arxiv.org/abs/1602.04473v1", "Part of the \"Knowledge Representation in the Semantic Web\" Seminar by Matthias Thimm, Koblenz 2015"]], "COMMENTS": "Part of the \"Knowledge Representation in the Semantic Web\" Seminar by Matthias Thimm, Koblenz 2015", "reviews": [], "SUBJECTS": "cs.AI cs.DB", "authors": ["michael ruster"], "accepted": false, "id": "1602.04473"}, "pdf": {"name": "1602.04473.pdf", "metadata": {"source": "META", "title": "Large-Scale Reasoning with OWL", "authors": ["Michael Ruster"], "emails": [], "sections": [{"heading": null, "text": "Large-Scale Reasoning with OWL\nMichael Ruster\nUniversity of Koblenz-Landau, Campus Koblenz"}, {"heading": "1 Introduction", "text": "In recent years, the Semantic Web has grown in size and importance. More and more knowledge is stored in machine-readable formats like RDFS or OWL. For many applications, knowledge extraction and reasoning is one of the core requirements. Through reasoning, knowledge can be logically derived that is not explicitly present in the data. Due to the complexity and amount of knowledge on the Semantic Web, this can easily become a difficult task. The bottlenecks are the time used for processing a query as well as the memory needed while reasoning.\nThis paper outlines common approaches for efficient reasoning on large-scale data. It therefore presents techniques implemented in reasoners, which are able to process billions (109) of triples. The paper focuses on OWL because it is widely used as a knowledge representation ontology language on the Semantic Web and because it is rich in features. First of all, a brief introduction to the Semantic Web is given in Section 2. For this, common properties of it are highlighted which may influence the choice of language selection for knowledge representation. Subsequently, Section 3 will give an overview of OWL and some of its sublanguages. The choice of sublanguages is shortly explained based on the requirements of modelling knowledge on the Semantic Web. Section 4 illustrates two main techniques for large-scale reasoning. Differences between the approaches are being highlighted. Furthermore, for both techniques, one example reasoner is presented together with some optimisation strategies they implement. Finally, Section 5 summarises this paper."}, {"heading": "2 Semantic Web and Language Features", "text": "This section focuses on the Semantic Web and some of its most important properties. Thereby, it introduces the various important terms which are used throughout this paper. Furthermore, this section describes two different logics that can be of use for modelling Semantic Web data.\nThe Semantic Web\u2019s purpose is to extend the World Wide Web by encoding its information in machine-parseable ways [3]. As a result, it should be possible for machines to easily extract a Web page\u2019s \u201cmeaning\u201d [31]. The Semantic Web is built using various technologies like ontologies to achieve this. Ontologies are conceptual models, encoding a set of terms and relationships between them [3]. This enables the organisation and exchange of information as well as reasoning\nar X\niv :1\n60 2.\n04 47\n3v 1\n[ cs\n.A I]\n1 4\nFe b\n20 16\n2 on it. Formal descriptions of ontologies are given through ontology languages. Ontology languages are using logics to express knowledge. OWL is built around description logics to which an overview is given in Section 4. Its statements can be expressed through a subject-predicate-object structure which are called triples. All statements that describe the taxonomy of the domain by expressing terminological knowledge are called the TBox of the ontology [2]. Likewise, all statements describing assertions about instances like their properties and relations to other instances are called the ABox [2].\nSemantic Web data may originate from many diverse fields such as biology, medicine [31] or journalism like the New York Times1. Hence, the knowledge to be represented is heterogeneous and may require different statement capabilities of its ontology language. A richer amount of features may also mean a higher complexity while reasoning [cf. 22]. Nevertheless, depending on the domain to model, more features might be needed. For example, generally, every statement is either true or false. But modelling uncertainty or imprecision is then not possible e.g. in classical description logic, a statement cannot express that a paper is \u201calmost\u201d finished. A solution for this is to introduce a finer range of truth values. This can be done e.g. with fuzzy logic by assigning such an additional truth value in the range of [0, 1] to each triple [46].\nSimilarly, reasoning over incomplete and conflicting knowledge can be problematic for instance when trying to calculate a transitive closure over multiple triples. A common example expresses that birds can fly and that penguins are birds. But penguins form an exception regarding the capability of flight while most birds are actually able to fly. Defeasible logic [27] allows expressing sentences like \u201cgenerally, birds can fly\u201d while also modelling that penguins cannot although they are birds [cf. 24]. This logic introduces three main elements [27]:\nStrict rules model knowledge that is true in all cases like \u201cswallows are birds\u201d. Defeasible rules express that something \u201ctypically\u201d holds like \u201cbirds can fly\u201d.\nThey can be defeated by other defeasible or strict rules. Rules can be assigned priorities to determine which rule may defeat another one [27, 11]. Undercutting defeaters formulate possible exceptions to defeasible rules without them being expressive enough to allow any concrete inference. For example, \u201can injured bird might not be able to fly\u201d would not allow an inference that all injured birds are unable to fly. Instead, it highlights that there might be exceptions which would make an inference impossible.\nFuzzy logic and defeasible logic may seem similar at first but are indeed different. As Covington [7] notes, fuzzy logic allows reasoning with a certain level of uncertainty or imprecision. Whereas defeasible logic ignores these degrees of truths and instead expresses that some rules may be overridden by others.\nBoth embody interesting concepts for the Semantic Web. Fuzzy logic can be used to express various level of trust in certain sources. For example, an article by a renowned newspaper will often be more trustworthy than one by a rather unknown personal blogger. Defeasible logic helps modelling conflicting knowledge\n1 http://data.nytimes.com/ \u2014 last accessed 25 March 2015, 11:00"}, {"heading": "3. OWL AND ITS SUBLANGUAGES 3", "text": "in a different way. In the example before, the information by the blogger can be defeated by the one published by the newspaper. It remains unclear how much more credible the newspaper is compared to the blogger. Yet, the information from the newspaper article can be seen as truth instead of only information closer to the actual truth. This allows modelling of incomplete knowledge with knowledge capturing typical states and being defeated by more specific rules. Hence, when knowledge changes would appear that are expressed through defeasible rules, these defeasible rules could immediately be added without entailing further processing [11].\nIt depends on the ontology developers whether they see a need for these logics to describe their data. In some contexts, it can be useful. However, it always adds complexity to the reasoning process. In the next section, sublanguages of OWL are discussed to illustrate possible choices in expressiveness that are already provided by OWL without any further extensions."}, {"heading": "3 OWL and its Sublanguages", "text": "This section gives a quick introduction to OWL and its sublanguages in terms of their features. The purpose of this section is to illustrate that the choice of an ontology language is an important decision for reasoning on big data. For this purpose, reasoning complexities of most languages are given. Their most important properties are presented and thus it should be understood, why some languages are commonly used for this type of reasoning.\nThe Web Ontology Language (short: OWL) is a specification by the W3C with the purpose of representing knowledge in machine-parsable ways. In the OWL 1 Web Ontology Language Guide [33], the W3C explains that OWL 1 can be divided into its three sublanguages OWL 1 Full, OWL 1 Lite and OWL 1 DL. These sublanguages themselves can be further divided and differ in their expressiveness with OWL 1 Full being the feature-richest. It can be seen as an extension of RDF, which includes meta-modelling capabilities of RDF Schema (short: RDFS ) [25]. OWL 1 Lite and OWL 1 DL on the other hand can be understood as extensions of a subset of RDF [25]. Ontologies created using OWL 1 Lite are subsets of those built with OWL 1 DL which themselves are subsets of OWL 1 Full ontologies. Detailed differences can be taken from the OWL 1 semantics specification [29].\nWith rising amount of features, the complexity of reasoning increases as well: Reasoning in OWL 1 Lite is complete for ExpTime, in OWL 1 DL for NexpTime and OWL 1 Full is even undecidable [17]. The revision of OWL 1, called OWL 2, even extends the feature set of the sublanguages, resulting e.g. in a reasoning complexity of 2NexpTime for OWL 2 DL [13]. Thus, especially when reasoning on billions of triples, it is important to decide on using the least complex sublanguage that offers all needed features for the given modelling purpose.\nCommonly used for modelling knowledge while keeping reasoning feasible are sublanguages of OWL 2 DL, also referred to as profiles. These profiles are characterised by further restricting the feature set and hence making reasoning"}, {"heading": "3. OWL AND ITS SUBLANGUAGES 4", "text": "more feasible [18, 22]. Hereby, these ontology languages also become simpler to implement, extend and easier to understand [22]. The W3C distinguishes three OWL 2 profiles, namely OWL 2 QL, OWL 2 RL and OWL 2 EL [26]. These profiles have a reduced reasoning complexity of as low as PTime for OWL 2 RL [cf. 26, 6]. One of the restrictions that all the profiles share is that for axioms which define subclass inclusion, they disallow unions of classes. Otherwise, reasoning on these ontology languages would become NP-hard already. Similarly, all profiles forbid the use of negations and universal quantifiers on the left-hand side. Their concrete restrictions are explained in the OWL 2 profile specification [26] and are outside of this paper\u2019s scope. However, Kro\u0308tzsch [22] summarises their most important characteristics as follows:\nOWL 2 QL was designed as a query language to ease information retrieval from ontologies as a database. Hence, queries may extract matching data together with facts inferred from it in LSpace [26]. This sublanguage\u2019s design enables query rewriting, where the query is rewritten e.g. into an SQL query that can be directly executed on an SQL database [4]. The technique of query rewriting is discussed in more detail in Section 4.2 with an approach being presented where the query is split up into related rules that eventually may return instances.\nOWL 2 RL is often applied to contexts where the TBox is notably smaller than the ABox, which is common for the Semantic Web. It was developed as a scalable solution and allows querying on big datasets while retaining most of OWL 2 DL\u2019s expressiveness [26].\nOWL 2 EL is likewise aimed at scenarios with big ABoxes [26]. Thus, it is used e.g. for biomedical ontologies like Systematized Nomenclature of Medicine Clinical Terms2 (short: SNOMED CT ), which gathers information about human diseases. It is the most restricted profile and therefore the least expressive.\nBesides the OWL 2 profiles, OWL pD* (also known as OWL Horst) is also often used for reasoning on huge amounts of data. It is an extension of RDFS combined with a subset of OWL 1 [18]. As a result, it becomes more expressive than RDFS while remaining less computationally complex than OWL 1 Full [40]. Reasoning in OWL pD* has a complexity of NP and P for some special cases [18]. Urbani et al. [40] describe it as \u201ca de facto standard for scalable OWL reasoning\u201d [40, p.216]. The development of OWL 2 RL was partly influenced by OWL pD* [26]. Thus, both are frequently used for large-scale reasoning [e.g. 4, 15].\nRegardless of the revision of OWL, it can be said that OWL Lite is not expressive enough for modelling most knowledge on the Semantic Web. OWL DL and OWL Full however are not tractable for reasoning on huge datasets. Therefore, restricted sublanguages are selected for knowledge modelling and reasoning on the Semantic Web. OWL pD* and OWL 2 RL are the languages most commonly applied to this task, often using a materialisation strategy presented later in Section 4.1. Nevertheless, other profiles such as OWL 2 QL are also used in some reasoners following a query rewriting strategy as further explained in Section 4.2.\n2 http://www.ihtsdo.org/ \u2014 last accessed 06 March 2015, 16:30"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 5", "text": ""}, {"heading": "4 Approaches for Large-Scale OWL Reasoning", "text": "First of all, this section gives an overview of description logics, focussing on one concrete language as an example. The description logics syntax and semantic will be used when subsequently presenting the two inference methods forward chaining and backward chaining. The later sections go into detail about implementations of these methods. Section 4.3 will furthermore give an overview of a selection of OWL and/or Semantic Web reasoners.\nDescription logics are a first-order logic subset and allow the modelling of knowledge [2]. They are the foundation of OWL and other ontologies. A common example of description logics is the Attributive Language with Complements (short: ALC) [30] It consists of concepts, individuals and roles. A concept can e.g. be a Human or Building. Individuals can be seen as elements of concepts e.g. Peter or EiffelTower. A function\u2014also called an interpretation\u2014associates the individuals with concepts, so that for example Peter : Human expresses that the individual Peter satisfies the Human concept. Examples for roles are hasChild or builtBy.\nTo link these elements with each other, ALC introduces connectives. One such connective is the concept inclusion \u201cv\u201d, which allows expressing that one concept is more general than the other. For example Woman v Human may model that the gender neutral concept of a human includes women. Like in set theory, concepts can also be unified so that e.g. Woman t Man v Human. The intersection of concepts indicated by \u201cu\u201d is included analogously. There is also a top concept \u201c>\u201d which is the most universal concept and thus subsumes all others. Likewise, the bottom concept \u201c\u22a5\u201d models the concept of nothingness. An example, using the negation connective \u201c\u00ac\u201d, would be Woman u \u00acWoman v \u22a5. Existential and universal quantifiers\u2014\u201c\u2203\u201d and \u201c\u2200\u201d respectively\u2014 allow expressing knowledge including roles. For example, \u201ca building is built only by humans or no one\u201d can be modelled as Building v \u2200builtBy.Human. Similarly, modelling a parent as someone who has had a child can be expressed with Parent v \u2203hasChild.>. The given introduction to ALC and description logics in general is incomplete and the interested reader may consult Schmidt-Schau\u00df and Smolka [30] and Baader [2] respectively.\nForward and backward chaining differ in the \u201cdirection\u201d of reasoning. Reasoning is used to derive implicit knowledge from ontologies by applying terminological knowledge to the explicitly modelled data [2]. Forward chaining is data-driven meaning that reasoning will start from existing data and infer new knowledge as long as it is possible [32]. Given are two example class subsumption rules in Equation 1 and 2.\nX v P (1)\nZ t P v Y (2)\nA forward chaining approach searches for rules with matching antecedents and then assumes true consequents. Equation 3 shows how example data may express"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 6", "text": "a being of class Z and X. Next, it can be matched against the antecedents of the example rules and hence reasoned to being of class Y .\na : Z t a : X (1)=\u21d2 a : Z t a : P (2)=\u21d2 a : Y (3)\nBackward chaining on the other hand is goal-driven [32]. It divides a goal into smaller subgoals and tries to resolve those. By matching rules for true consequents and then assuming true antecedents, backward chaining reasons for data matching the initial goal. Likewise, Equation 4 illustrates a backward chaining application assuming a being of class Y .\na : Y (2) =\u21d2 a : Z t a : P (1)=\u21d2 a : Z t a : X (4)\nThe following sections explain how the approaches can be used for Semantic Web reasoning and what advantages they have over the other. Section 4.1 presents a common way to use forward chaining for this task by also presenting a typical programming model and an overview of an implemented reasoner. Subsequently, Section 4.2 discusses the application of backward chaining to reasoning on billions of triples. Analogously, the main properties and approaches of an implementation are shown."}, {"heading": "4.1 Materialisation", "text": "Materialisation is a forward chaining approach [21]. The idea behind is to compute all inferences prior to reasoning and storing them for later querying [32]. In this section, after discussing the most important advantages and disadvantages to this technique, a common programming model called MapReduce is explained. Furthermore, a reasoner using MapReduce is presented.\nComputing all inferences first once, allows fast query answering as it is comparable to lookups in a database. On the other hand, the initial materialisation process is time and memory consuming. As an example, owl:sameAs is one of the most commonly found axioms according to Hogan et al. [14]. It is used to express equivalent individuals. If a reasoner would be na\u0308\u0131vely implemented, a full closure would be in O(n2). On a corpus containing 33, 052 equivalent individuals, Hogan et al. [16] prospected 1, 092, 434, 704 triples and an additional two billion for those individuals being included in other statements. Another downside is that materialisation must be done anew every time the data is updated. Due to the nature of the Semantic Web, data may change frequently and hence regular updates are necessary to ensure recent results.\nMapReduce MapReduce is a programming model developed by Dean and Ghemawat [8] for Google Inc. with the goal to process big amounts of data efficiently. It tries to achieve this by allowing distributed and parallel data processing and thus reducing the load on single machines/cores. The most frequently used implementation is Apache Hadoop3. MapReduce can also be\n3 https://hadoop.apache.org/ \u2014 last accessed March 08 2015, 17:30"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 7", "text": "used for reasoning on Semantic Web data [cf. 36, 42] for which it then becomes a forward chaining approach. The process is split into three consecutive steps as described by Dean and Ghemawat [8]:\n1. Map is the first phase and describes the act of pre-processing input data as a list of key-value pairs. The result of every processed key-value pair is immediately emitted. Thus, this process may be parallelised and can hence speed up data processing. Its method signature can be given as:\nMap (k1, v1) \u2192 list (k2, v2) The different indices express potentially different datatypes.\n2. Shuffle collects all results of the first phase and groups them by their key. Hence, the datatypes remain the same and a method signature can be given as: Shuffle (list (k2, v2)) \u2192 list (k2, list (v2)) 3. Reduce is the phase in which the values with the same key are being\nprocessed. Values are being merged together and returned as a smaller result set. To avoid having to load the complete data into memory, the reduce phase is only given an iterator over the values. The list of returned values is of the same datatype as the intermediate values returned by the mapping phase. Its signature can be given as:\nReduce (k2, list (v2)) \u2192 list (v2) However, the commonly used implementation Apache Hadoop is more liberal concerning the domain of return values, by having the following method signature [1]:\nReduce (k2, list (v2)) \u2192 list (k3, v3) Similar to the map phase, the reduce phase is generally executable in parallel.\nFigure 1 illustrates a MapReduce application on an ontological rule. In this example, the two triples of the rule\u2019s antecedent share the common variable x. Hence, it is selected as key for the map phase. After this pre-processing, the shuffling groups all results by key. The reduce phase then produces the output drawn from the intermediate results matched against the consequent. At this"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 8", "text": "point, the full reasoning process may not already be finished. The reason for this is that the inferred knowledge matches part of the rule\u2019s antecedent anew.\nMapReduce applied to reasoning is not a trivial task which needs only one run as illustrated by the rule in Figure 1. Instead, there are multiple difficulties when trying to implement this approach in a way that is relatively light on space and time consumption. A few of these are presented in the next section together with an example MapReduce algorithm.\nWebPIE as an Example Implementation of MapReduce Urbani et al. [41] employ MapReduce in their reasoner Web-scale Inference Engine (short: WebPIE ) for reasoning on OWL pD* rules. The authors discuss the shown problem as a fixed-point iteration, expressing that the MapReduce process must be repeated until no more new triples are returned. This results in an additional problem as duplicates may be generated by having to apply some rules multiple times. Besides trying to generate as few duplicates as possible throughout the reduce phase, an additional MapReduce step is added that solely matches duplicates and removes them [39]. In the map phase, the step iterates over all triples and returns these triples as key, which removes duplicates in the succeeding shuffle phase. Then, in the reduce phase, triples are only emitted if they were inferred to distinguish them from the original input triples.\nIn general, Urbani et al. [42] try to execute as few MapReduce steps as possible. Yet, the processing of some rules together with others is either not possible or would have a heavy impact on performance. Thus, the authors implement various MapReduce steps which focus on certain rules.\nOne, which will be discussed as an example, is the algorithm shown in Listing 1.1. It calculates subclass relations and is separated into a map and a reduce method as shown in Line 1 and Line 10 respectively. The algorithm operates on triples having either rdf:type or rdfs:subClassOf as predicate. Depending on their predicate, the map phase uses different flags as keys\u2014in this case either 0 or 1\u2014together with the triple\u2019s subject. The value associated with the key is the input triple\u2019s object. Considering an example input triple x rdfs:subClassOf y, then the output\u2019s key flag will be 1, its subject x and the value y.\nThe reduce method first removes all duplicates within the values. For the sake of simplicity, these values will be referred to as classes. In Lines 14 and 15 all TBox triples matching the classes as a subject are loaded into memory. These correspond to all the classes\u2019 superclasses. Continuing the earlier example, having a triple y rdfs:subClassOf z in the TBox results in z being added to the list of superclasses.\nThe reduce method distinguishes the input values based on their formerly associated predicate in the original triple as indicated by the key\u2019s flag. In both cases, the method iterates over all superclasses. It checks that the currently processed superclass is not already contained in the set of classes to prevent duplicates. Whenever this is ensured, the method returns a new triple associated with a key. As the key is irrelevant in this scenario, the pseudocode reduce method"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 9", "text": "returns null. The triple models that the original input\u2019s subject is either of the same type as a matching superclass or also a subclass of that superclass. Thus, inferred triples will be returned that respect the class hierarchy. In the formerly given example, this would be x rdfs:subClassOf z.\n1 map( key , va lue ) : 2 // key : source o f the t r i p l e ( i r r e l e v a n t ) 3 // va lue : t r i p l e 4 i f ( va lue . p r e d i c a t e = \u201d rd f : type \u201d ) : 5 key . f l a g = 0 6 i f ( va lue . p r e d i c a t e = \u201d r d f s : subClassOf \u201d ) : 7 key . f l a g = 1 8 key . s u b j e c t = value . s ub j e c t 9 emit ( key , va lue . ob j e c t )\n10 reduce ( key , i t e r a t o r va lue s ) : 11 // key : f l a g + t r i p l e . s u b j e c t 12 // i t e r a t o r : l i s t o f c l a s s e s 13 va lue s = va lues . unique // f i l t e r d u p l i c a t e va l u e s\n14 for ( c l a s s in va lue s ) : 15 s u p e r c l a s s e s . add ( subc lass schema . g e t S u p e r c l a s s e s ( c l a s s ) )\n16 switch ( key . f l a g ) : 17 case 0 : // we \u2019 re doing rd f : type 18 for ( s u p e r c l a s s in s u p e r c l a s s e s ) : 19 i f ! va lue s . conta in s ( s u p e r c l a s s ) : 20 emit ( nu l l , new Tr ip l e ( key . subject , \u201d rd f : type \u201d , \u2190\u21a9 \u21aa\u2192 s u p e r c l a s s ) ) 21 case 1 : // we \u2019 re doing r d f s : subClassOf 22 for ( s u p e r c l a s s in s u p e r c l a s s e s ) : 23 i f ! va lue s . conta in s ( s u p e r c l a s s ) : 24 emit ( nu l l , new Tr ip l e ( key . subject , \u2190\u21a9\n\u21aa\u2192 \u201d r d f s : subClassOf \u201d , s u p e r c l a s s ) )\nListing 1.1. The algorithm to do RDFS subclass reasoning initially presented by Urbani et al. [42]. This listing features a corrected and simplified version including changes from Urbani [39].\nUrbani et al. [41] present approaches for tackling the difficulties they faced throughout building WebPIE. However, their solutions are mostly tightly coupled with the ruleset of OWL pD*. Nevertheless, they also propose two more generic optimisation strategies.\nAs the TBoxes are commonly a lot smaller than the ABoxes when reasoning with data from the Semantic Web, the TBoxes can often times be fully loaded into memory. This was also done in the algorithm shown in Listing 1.1. The resulting advantage is that then the triples of instances can be streamed and thus directly processed. But, Urbani et al. [41] note that this is not possible for"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 10", "text": "rules which require joins between multiple instance triples in their antecedent. Equation 5 shows such a rule from the OWL pD* ruleset.\nv owl : sameAs w, w owl : sameAs u \u21d2 v owl : sameAs u (5)\nThere, for both triples in the antecedent, matching instances in the ABox must be looked up each. Again, the authors propose a solution concretely fit to the affected OWL pD* rules.\nHowever, they also describe a common technique for reducing the overhead created by rules considering the owl:sameAs axiom as in Equation 5. The input is modified so that synonymous instances are replaced by a unique identifier representing an entire equivalence class each [e.g. 40, 5]. As a result, the required space and computation time are both reduced drastically [23].\nAlthough having only highlighted a few bottlenecks, it should have become clear that applying MapReduce to reasoning on billions of triples is a complex task. Albeit there being some reoccurring problems shared by most OWL sublanguages, many optimisation approaches are tailored to concrete rules. Therefore, there is a lack of efficient universal solutions."}, {"heading": "4.2 Backward Chaining", "text": "With backward chaining, reasoning is done at runtime, once the query is posed. Hence, no prior computation is needed.\nBackward chaining has two advantages over materialisation as described by Urbani et al. [44]. First, there is no need for precomputation due to the runtime reasoning. Neither is there generally a need for computing a full closure because any reasoning solely needs to be done as far as it is required to answer the query. As one result, an application exclusively using backward chaining may instantly be usable without prior time- and space-consuming computation.\nSecond, the results to a query consider recent data modifications. That is, when changes happen to the data such as deletions or additions, they are instantly retrievable through the reasoning done by query rewriting. Furthermore, this means that after changes have been applied to the data, no computationally and memory-intense recomputation has to be done.\nHowever, backward chaining also faces a great disadvantage compared with materialisation. As reasoning must be done with every new query, answering these is often time-consuming. Whereas for materialisation query matching instances may directly be returned from the fully reasoned knowledge base.\nQuery Rewriting When using backward chaining for reasoning on ontologies, some form of query rewriting is used. The concept of query rewriting is to reformulate the query into a query that respects the ontology\u2019s terminological axioms and retrieves the matching instances [19]. There are various options concerning how a query can be transformed such as logical rewriting [12] or even concrete SQL query rewriting [4]. Both are actively used in the context of ontology-based data access (short: OBDA)."}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 11", "text": "OBDA describes the idea of storing ABoxes in traditional databases like relational database management systems while allowing the use of ontologic constraints [12]. Here, OWL 2 QL is often the preferred language as it was designed implicitly with OBDA as intended purpose [26, 20]. With OBDA, data access is offered through the ontology as an intermediate layer so that the queries are independent from the actual data storage [45]. This allows a unified semantical access to different data sources. Therefore, scalable, OBDA-enabled reasoning may become of special interest for Semantic Web reasoning due to its data being highly diverse.\nDespite the existing potential, there are yet only few reasoners using query rewriting while scaling up to billions of triples. There is especially a lack of reasoners that focus on implementing the concept of OBDA and pertain this scalability. Thus, the subsequent section presents a reasoner that is not build around OBDA but instead uses an illustrative query rewriting approach while supporting reasoning on billions of triples.\nQueryPIE There is no prevalently used programming model for query rewriting like there is MapReduce for materialisation. Urbani et al. [44] do query rewriting for OWL pD* by building a reasoning tree with the query being its root and the matching data its leaves. In backward chaining fashion, the query\u2014an input triple pattern\u2014is matched against rule consequents and their antecedents will then be used as new query triples. Figure 2 depicts a reasoning tree built from an example query ?S rdf:type Person. The branches containing rules are connected by"}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 12", "text": "logical ORs whereas the triples are connected with ANDs. This way, all instances from leaves may be returned that match the rule of their parent node. However, it is not necessary for instance triples to match the rules of other branch nodes. Thus all matching triples may be returned, disregarding through which rules they can be inferred. In the given example, the consequents of Equations 6 and 7 match the input query.\ns rdf : type x, x rdfs : subClassOf y \u21d2 s rdf : type y (6)\ns p o, p rdfs : subPropertyOf q \u21d2 s q o (7)\nTheir antecedents are bound accordingly, substituting all variables where possible. In the antecedent s p o of Equation 7 for example, o is bound to Person. This allows to apply Equation 8 so that all variables from its antecedents are bound and reasoning can be continued on these.\np rdf : type owl : SymmetricProperty, v p u \u21d2 u p v (8)\nThe tree building finishes when each branch has been built. A branch is built as deep as there are yet rules applicable or matching instances can be retrieved from the knowledge base. This process may consume a lot of time and also space. Thus, Urbani et al. [44] propose two optimisation strategies:\nPrecomputation of frequently appearing branches. Tree-pruning describes the early discovery of branches which will not return any results and hence stopping to further follow them.\nWhen implementing precomputation, its effectiveness is defined by how regular the selected branches appear. Urbani et al. [44] focus their optimisation on what they call terminological triple patterns. They define them as triple patterns whose object or predicate is a term from the RDFS or OWL vocabulary that they operate on. An example is given in Equation 9.\n?X rdfs : subPropertyOf rdf : type (9)\nDue to the commonly smaller TBox in Semantic Web data, there are few such terminological triple patterns. Yet, they affect many queries. As using forward chaining for precomputing would require the calculation of a full closure, backward chaining is applied on the selected terminological triple patterns. For this, a tree is built bottom up by iterative backward chaining as illustrated in more detail in [44].\nThe advantage of exclusively reasoning at runtime, is lost when using precomputation. However, it is still a much faster process than full materialisation. It especially remains fast enough to allow for frequent updates as typically found in Semantic Web data. However, this approach can hence no longer be classified as pure query rewriting but is actually a hybrid approach [43]."}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 13", "text": ""}, {"heading": "1 reason ( pattern ) :", "text": ""}, {"heading": "2 // Get r u l e s where the query pa t t e rn i s more s p e c i f i c \u2190\u21a9", "text": "\u21aa\u2192 than the ru l e \u2019 s consequent : 3 Rules app l i c ab l eRu l e s = r u l e S e t . a p p l i c a b l e ( pattern )"}, {"heading": "4 Resu l t s r e s u l t s = {}", "text": "5 for ( r u l e in app l i c ab l eRu l e s ) : 6 antecedents = r u l e . i n s t an t i a t eAnte c eden t s ( pattern ) 7 // Perform reasoning to f e t c h a l l an teceden t s : 8 for ( antecedent in antecedents ) : 9 i f ( antecedent != t e r m i n o l o g i c a l )\n10 // Recurs ive c a l l to the reasoner : 11 antecedents . add ( reason ( antecedent ) ) 12 antecedents . add ( KnowledgeBase . read ( antecedent ) ) 13 // Apply the ru l e us ing the an teceden t s t r i p l e s : 14 r e s u l t s += r u l e . applyRule ( antecedents )\n15 return r e s u l t s\nListing 1.2. The reasoner which operates on the precomputed terminological triple patterns as given by Urbani et al. [44] with small modifications to match this paper\u2019s pseudocode style.\nListing 1.2 shows the algorithm in pseudocode used by Urbani et al. [44] to reason after precomputing has been completed. Hence, they call it the terminological independent reasoner. In the first step, all rules are retrieved whose consequent is more general than the query pattern. This corresponds to the OR-levels of the reasoning tree. While iterating over all rules, each rule\u2019s variables are subsequently bound to any matches from the query pattern as shown in Line 6. In the second loop all antecedents of a rule are processed which corresponds to the AND-levels of the reasoning tree. For this, the terminological independent reasoner is recursively called to further construct the branch. Due to precomputing, this step is only needed if the currently processed antecedent is not terminological as checked in Line 9. Next, a lookup in the knowledge base is done which also includes the already computed terminological triple patterns. After every branch of a rule have been computed, the rule is applied with all the previously computed antecedents. In the end, all applied rules will be returned, meaning that all of their variables are bound to match the query pattern.\nAs a second optimisation strategy, tree-pruning is used. It is built upon the formerly precomputed terminological triple patterns. Whilst backward chaining, rules, whose antecedent matches such terminological triple patterns, are prioritised. If these patterns do not return any instances, the rule will not be applied as they are more specific than the patterns. The processing of branches that are known not to return any results, will therefore be stopped early. Thus, a lot of unnecessary reasoning can be prevented.\nIn the next section, a selection of reasoners using forward and/or backward chaining is presented. However, all of the reasoners using backward chaining approaches either do not scale well or only partially support an OWL sublanguage."}, {"heading": "4. APPROACHES FOR LARGE-SCALE OWL REASONING 14", "text": "QueryPIE is likely to be the first reasoner scaling to billions of triples while reasoning at runtime [43]."}, {"heading": "4.3 Other Reasoners", "text": "Besides WebPIE and QueryPIE, there are several other reasoners using forward and/or backward chaining. This section gives an overview to a selection of available reasoners.\nOWLIM [21] is a semantic repository allowing the storage of and reasoning on knowledge bases by employing full materialisation. Bishop and Bojanov [4] state that OWLIM is capable to work on various rulesets including OWL pD* and OWL 2 QL as well as OWL 2 RL. OWLIM is divided into the free-for-use SwiftOWLIM and the commercial BigOWLIM [5]. Bishop et al. [5] state that SwiftOWLIM was developed for in-memory reasoning with smaller datasets. According to the authors, BigOWLIM on the other hand was developed for reasoning on billions of triples. For this, various optimisations were needed of which one is a special treatment of the owl:sameAs axiom. BigOWLIM uses a canonical representation for each equivalence class [5] similar to WebPIE\u2019s approach. Furthermore, it employs a backward chaining approach on data deletion to prevent a new full materialisation [5]. According to Bishop et al. [5], its use allows BigOWLIM to be applicable to frequently updated data as is typical for data from the Semantic Web.\nAnother, yet non-commercial, reasoner supporting multiple profiles is TrOWL [38]. It is an interface for multiple reasoners such as Quill or Pellet. Besides the support of OWL 2 QL and OWL 2 EL there is also partial support for tractable reasoning with OWL 2 DL [28]. Using reasoners like Pellet allows full OWL 2 DL reasoning support but reasoning is then no longer in polynomial time [9]. Reasoning of OWL 2 QL is done by using backward chaining, namely query rewriting [38]. OWL 2 EL on the other hand is reasoned in a forward chaining manner [28].\nTachmazidis et al. [36] presented a reasoner which employs Apache Hadoop for materialisation of knowledge that uses rulesets implementing defeasible logic. Their motivation for developing a reasoner on defeasible logic was to create inconsistency-tolerant reasoning that was able to deal with data of poor quality. Although the reasoner does not operate on OWL but on RDF data, this concept may have a high relevance for the Semantic Web as data from different sources are likely to be of different quality. Making use of parallelisation through MapReduce, Tachmazidis et al. [35] were able to build a reasoner scaling to billions of triples.\nStoilos et al. [34] developed a reasoner for an extension of OWL pD* that supports fuzzy logic. This allows expressing vagueness as already described in Section 2. Their work also uses the MapReduce implementation of Apache Hadoop. The authors followed the optimisation strategies of WebPIE and adapted them whenever necessary to support fuzzy logic. As a result, Stoilos et al. [34] claim to have created a fuzzy reasoner with a performance comparable to WebPIE."}, {"heading": "5. CONCLUSION 15", "text": "Virtuoso Universal Server4 is a Web server and triple store. It is furthermore an OWL reasoner which allows backward as well as forward chaining [32, 37]. But, its support is restricted to a subset of OWL 2 RL [43]. Moreover, except for an RDF reasoner implementation [10], there do not seem to be any implementations targeting Web-scale triples.\nApache Jena5 is a framework written in Java to support building Semantic Web applications. Its included OWL reasoner supports forward and backward chaining as well as a hybrid between the two [32]. However, throughout the research for this paper, no implementation using the Jena reasoner could be found which would scale to allow reasoning on billions of triples.\nAnother reasoner is F-OWL [47] which primarily uses backward chaining. The authors call their speed-up strategy tabling. Their approach is to store the results of already reasoned triples and look them up whenever possible. As a result, the first queries are processed slowly but the system becomes increasingly faster on average for subsequent queries. However, it only supports OWL Full while neither being complete nor decidable. According to its website6, F-OWL has not been updated since 2003. Additionally, according to its authors [47] it does not scale and is thus unsuitable for reasoning on billions of triples."}, {"heading": "5 Conclusion", "text": "The grand challenge of large-scale reasoning is to effectively use and reduce the time and space consumption. Essentially, the approaches do not differ from regular reasoning methods. Yet, the performance optimisation is crucial.\nAdditionally, the choice of ontology language may have heavy impact on the complexity of reasoning. OWL pD* and OWL 2 RL are commonly used for forward chaining approaches whereas OWL 2 QL is mainly used in backward chaining reasoners. Furthermore, when reasoning on the Semantic Web, extensions of the languages can be of interest. For example, using defeasible logic may allow reasoning with data of poor quality from different sources. Likewise, OBDA may be a suitable technology for working and reasoning on Semantic Web data.\nReasoning on big knowledge bases modelled in OWL is still rarely done using backward chaining. Instead, materialisation is the most common approach. However, materialisation alone cannot fit the Semantic Web\u2019s quickly changing nature. Thus, future research should consider large-scale reasoning using a hybrid approach of backward and forward chaining. Moreover, a requirement analysis of features needed for properly modelling and reasoning on Semantic Web data could be helpful. Due to the diversity of data, a prior separation by topics would probably be beneficial.\n4 http://virtuoso.openlinksw.com/ \u2014 last accessed 18 March, 22:00 5 https://jena.apache.org/index.html \u2014 last accessed 18 March, 08:30 6 http://fowl.sourceforge.net/ \u2014 last accessed 17 March 2015, 22:00"}], "references": [{"title": "OWL Web Ontology Language Overview", "author": ["D.L. McGuinnes", "F. van Harmelen"], "venue": "W3c Recommendation", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2004}, {"title": "OWL 2 Web Ontology Language: Profiles (Second Edition)", "author": ["B. Motik", "B.C. Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2012}, {"title": "Defeasible logic. In: Web knowledge management and decision support, pp. 151\u2013169", "author": ["D. Nute"], "venue": "http://link.springer.com/chapter/", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2003}, {"title": "Reasoning the FMA Ontologies with TrOWL", "author": ["J.Z. Pan", "Y. Ren", "N. Jekjantuk", "J. Garcia"], "venue": "ORE. pp", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2013}, {"title": "OWL Web Ontology Language Semantics and Abstract Syntax", "author": ["P.F. Patel-Schneider", "P. Hayes", "I. Horrocks"], "venue": "W3c Recommendation", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2004}, {"title": "Attributive concept descriptions with complements", "author": ["M. Schmidt-Schau\u00df", "G. Smolka"], "venue": "Artificial intelligence 48(1),", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1991}, {"title": "The semantic web revisited", "author": ["N. Shadbolt", "W. Hall", "T. Berners-Lee"], "venue": "Intelligent Systems, IEEE 21(3),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2006}, {"title": "A Scalable Backward Chaining-based Reasoner for a Semantic Web", "author": ["H. Shi", "K. Maly", "S. Zeil"], "venue": "International Journal On Advances in Intelligent Systems 7(1", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2014}, {"title": "Fuzzy OWL: Uncertainty and the semantic web", "author": ["G. Stoilos", "G.B. Stamou", "V. Tzouvaras", "J.Z. Pan", "I. Horrocks"], "venue": "OWLED", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2005}, {"title": "Scalable nonmonotonic reasoning over RDF data using MapReduce", "author": ["I. Tachmazidis", "G. Antoniou", "G. Flouris", "S. Kotoulas"], "venue": "Proceedings of the Joint Workshop on Scalable and High-Performance Semantic Web Systems. pp", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2012}, {"title": "Large-scale parallel stratified defeasible reasoning (2012), http://eprints", "author": ["I. Tachmazidis", "G. Antoniou", "G. Flouris", "S. Kotoulas", "T.L. McCluskey"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2012}, {"title": "TrOWL: Tractable OWL 2 reasoning infrastructure", "author": ["E. Thomas", "J.Z. Pan", "Y. Ren"], "venue": "The Semantic Web: Research and Applications,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2010}, {"title": "Scalable Distributed RDFS/OWL Reasoning using MapReduce", "author": ["J. Urbani"], "venue": "Master thesis,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2009}, {"title": "OWL reasoning with WebPIE: calculating the closure of 100 billion triples", "author": ["J. Urbani", "S. Kotoulas", "J. Maassen", "F. Van Harmelen", "H. Bal"], "venue": "The Semantic Web: Research and Applications,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2010}, {"title": "WebPIE: A Web-scale parallel inference engine using MapReduce", "author": ["J. Urbani", "S. Kotoulas", "J. Maassen", "F. Van Harmelen", "H. Bal"], "venue": "Web Semantics: Science, Services and Agents on the World Wide Web 10,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2012}, {"title": "Scalable distributed reasoning using MapReduce", "author": ["J. Urbani", "S. Kotoulas", "E. Oren", "F. Van Harmelen"], "venue": "http://link.springer.com/", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2009}, {"title": "Hybrid reasoning on OWL RL", "author": ["J. Urbani", "R. Piro", "F. van Harmelen", "H. Bal"], "venue": "Semantic Web", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2014}, {"title": "QueryPIE: Backward reasoning for OWL horst over very large knowledge bases", "author": ["J. Urbani", "F. Van Harmelen", "S. Schlobach", "H. Bal"], "venue": "The Semantic Web\u2013ISWC", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2011}, {"title": "Rules and ontology based data access", "author": ["G. Xiao", "M. Rezk", "M. Rod\u0155\u0131guez-Muro", "D. Calvanese"], "venue": "Web Reasoning and Rule Systems,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2014}, {"title": "Fuzzy sets. Information and Control", "author": ["L.A. Zadeh"], "venue": "(Jun", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1965}, {"title": "F-owl: An inference engine for semantic web. In: Formal Approaches to Agent-Based Systems, pp. 238\u2013248", "author": ["Y. Zou", "T. Finin", "H. Chen"], "venue": null, "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2005}], "referenceMentions": [], "year": 2016, "abstractText": "In recent years, the Semantic Web has grown in size and importance. More and more knowledge is stored in machine-readable formats like RDFS or OWL. For many applications, knowledge extraction and reasoning is one of the core requirements. Through reasoning, knowledge can be logically derived that is not explicitly present in the data. Due to the complexity and amount of knowledge on the Semantic Web, this can easily become a difficult task. The bottlenecks are the time used for processing a query as well as the memory needed while reasoning. This paper outlines common approaches for efficient reasoning on large-scale data. It therefore presents techniques implemented in reasoners, which are able to process billions (10) of triples. The paper focuses on OWL because it is widely used as a knowledge representation ontology language on the Semantic Web and because it is rich in features. First of all, a brief introduction to the Semantic Web is given in Section 2. For this, common properties of it are highlighted which may influence the choice of language selection for knowledge representation. Subsequently, Section 3 will give an overview of OWL and some of its sublanguages. The choice of sublanguages is shortly explained based on the requirements of modelling knowledge on the Semantic Web. Section 4 illustrates two main techniques for large-scale reasoning. Differences between the approaches are being highlighted. Furthermore, for both techniques, one example reasoner is presented together with some optimisation strategies they implement. Finally, Section 5 summarises this paper.", "creator": "LaTeX with hyperref package"}}}