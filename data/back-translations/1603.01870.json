{"id": "1603.01870", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Mar-2016", "title": "Personalized Advertisement Recommendation: A Ranking Approach to Address the Ubiquitous Click Sparsity Problem", "abstract": "We investigate the problem of personalized ad recommendation (PAR), which consists of a user visiting a system (website) and displaying to the user one of the $K $ads. The system uses an internal ad recommendation policy to map the user's profile (context) to one of the ads. The user clicks or ignores the ad and accordingly the system updates its recommendation policy. The PAR problem is usually solved by scalable\\ emph {Contextual Bandit} algorithms, where policies are generally based on classifiers. A practical problem in PAR is extreme click economy, as very few users actually click on ads. We systematically investigate the disadvantages of using contextual bandit algorithms based on classifier-based policies in the face of extreme click economy. We then propose an alternative policy based on rank-based rankings that can be achieved by optimizing the ranking loss in the Under the Curve section of data (which is clearly illustrated by the problem of three click policy).", "histories": [["v1", "Sun, 6 Mar 2016 20:26:41 GMT  (240kb,D)", "http://arxiv.org/abs/1603.01870v1", "Under review"]], "COMMENTS": "Under review", "reviews": [], "SUBJECTS": "cs.LG cs.IR", "authors": ["sougata chaudhuri", "georgios theocharous", "mohammad ghavamzadeh"], "accepted": false, "id": "1603.01870"}, "pdf": {"name": "1603.01870.pdf", "metadata": {"source": "CRF", "title": "Personalized Advertisement Recommendation: A Ranking Approach to Address the Ubiquitous Click Sparsity Problem", "authors": ["Sougata Chaudhuri", "Ann Arbor", "Georgios Theocharous", "Mohammad Ghavamzadeh"], "emails": [], "sections": [{"heading": "Introduction", "text": "Personalized advertisement recommendation (PAR) system is intrinsic to many major tech companies like Google, Yahoo, Facebook and others. The particular PAR setting we study here consists of a policy that displays one of the K possible ads/offers, when a user visits the system. The user\u2019s profile is represented as a context vector, consisting of relevant information like demographics, geo-location, frequency of visits, etc. Depending on whether user clicks on the ad, the system gets a reward of value 1, which in practice translates to dollar revenue. The policy is (continuously) updated from historical data, which consist of tuples of the form {user context, displayed ad, reward}. We will, in this paper, concern ourselves with PAR systems that are geared towards maximizing total number of clicks.\nThe plethora of papers written on the PAR problem makes it impossible to provide an exhaustive list. Interested read-\ners may refer to a recent paper by a team of researchers in Google [McMahan and others, 2013] and references therein. While the techniques in different papers differ in their details, the majority of them can be be analyzed under the umbrella framework of contextual bandits [Langford and Zhang, 2008]. The term bandit refers to the fact that the system only gets to see the user\u2019s feedback on the ad that was displayed, and not on any other ad. Bandit information leads to difficulty in estimating the expected reward of a new or a relatively unexplored ad (the cold start problem). Thus, contextual bandit algorithms, during prediction, usually balance between exploitation and exploration. Exploitation consists of predicting according to the current recommendation policy, which usually selects the ad with the maximum estimated reward, and exploration consists of systematically choosing some other ad to display, to gather more information about it.\nMost contextual bandit algorithms aim to learn a policy that is essentially some form of multi-class classifier. For example, one important class of contextual bandit algorithms learn a classifier per ad from the batch of data [Richardson, Dominowska, and Ragno, 2007; McMahan and others, 2013; He and others, 2014] and convert it into a policy, that displays the ad with the highest classifier score to the user (exploitation). Some exploration techniques, like explicit - greedy [Koh and Gupta, 2014; Theocharous, Thomas, and Ghavamzadeh, 2015] or implicit Bayesian type sampling from the posterior distribution maintained on classifier parameters [Chapelle and Li, 2011] are sometimes combined with this exploitation strategy. Other, more theoretically sophisticated online bandit algorithms, essentially learn a costsensitive multi-class classifier by updating after every round of user-system interaction [Dudik et al., 2011; Agarwal et al., 2014].\nDespite the fact that PAR has always been mentioned as one of the main applications of CB algorithms, there has not been much investigation into the practical issues raised in using classifier-based policies for PAR. The potential difficulty in using such policies in PAR stems from the problem of click sparsity, i.e., very few users actually ever click on online ads and this lack of positive feedback makes it difficult to learn good classifiers. Our main objective here is to study this important practical issue and we list our contributions:\n\u2022 We detail the framework of contextual bandit algorithms and discuss the problem associated with click sparsity.\nar X\niv :1\n60 3.\n01 87\n0v 1\n[ cs\n.L G\n] 6\nM ar\n2 01\n6\n\u2022 We suggest a simple ranker-based policy to overcome the click sparsity problem. The rankers are learnt by optimizing the Area Under Curve (AUC) ranking loss via stochastic gradient descent (SGD) [Shamir and Zhang, 2013], leading to a highly scalable algorithm. The rankers are then combined to create a recommendation policy.\n\u2022 We conduct extensive experiments to illustrate the improvement provided by our suggested method over both linear and ensemble classifier-based policies for the PAR problem. Our first set of experiments compare deterministic policies on publicly available classification datasets, that are converted to bandit datasets following standard techniques. Our second set of experiments compare stochastic policies on three proprietary bandit datasets, for which we employ a high confidence offline contextual bandit evaluation technique."}, {"heading": "Contextual Bandit (CB) Approach to PAR", "text": "The main contextual bandit algorithms can be largely divided into two classes: those that make specific parametric assumption about the reward generation process and those that simply assume that context and rewards are generated i.i.d. from some distribution. The two major algorithms in the first domain are LinUCB [Chu et al., 2011] and Thompson sampling [Agrawal and Goyal, 2013]. Both algorithms assume that the reward of each ad (arm) is a continuous linear function of some unknown parameter, which is not a suitable assumption for click-based binary reward in PAR. Moreover, both algorithms assume that there is context information available for each ad, while we assume availability of only user context in our setting. Thus, from now on, we focus on the second class of the contextual bandit algorithms. We provide a formal description of the framework of contextual bandits suited to the PAR setting, and then discuss the problem that arises due to click sparsity.\nLet X \u2286 Rd and [K] = {1, 2, . . . ,K} denote the user context space and K different ads/arms. At each round, it is assumed that a pair (x, r) is drawn i.i.d. from some unknown joint distribution D over X \u00d7 {0, 1}K . Here, x \u2208 X and r \u2208 {0, 1}K represent the user context vector and the full reward vector, i.e., the user\u2019s true preference for all the ads (the full reward vector is unknown to the algorithm). \u03a0 is the space of policies such that for any \u03c0 \u2208 \u03a0, \u03c0 : X 7\u2192 [K]. Contextual bandit algorithms have the following steps:\n\u2022 At each round t, the context vector xt is revealed, i.e., a user visits the system.\n\u2022 The system selects ad at according to the current policy \u03c0t \u2208 \u03a0 (exploitation strategy). Optionally, an exploration strategy is sometimes added, creating a distribution pt(\u00b7) over the ads and at is drawn from pt(\u00b7). Policy \u03c0t and distribution pt are sometimes used synonymously by considering \u03c0t to be a stochastic policy.\n\u2022 Reward rt,at is revealed and the new policy \u03c0t+1 \u2208 \u03a0 is computed, using information {xt, at, rt,at}. We emphasize that the system does not get to know rt,a\u2032 , \u2200 a\u2032 6= at.\nAssuming the user-system interaction happens over T rounds, the objective of the system is to maximize its cumulative reward, i.e., \u2211T t=1 rt,at . Note that since rewards are assumed to\nbe binary, \u2211T t=1 rt,at is precisely the total number of clicks\nand \u2211T t=1 rt,at T is the overall CTR of the recommendation algorithm. Theoretically, performance of a bandit algorithm is analyzed via the concept of regret, i.e., Regret(T) = T\u2211 t=1\nrt,\u03c0\u2217(xt)\ufe38 \ufe37\ufe37 \ufe38 optimal policy\u2019s cumulative reward\n\u2212 T\u2211 t=1\nrt,at\ufe38 \ufe37\ufe37 \ufe38 algorithm\u2019s cumulative reward\nwhere \u03c0\u2217 = argmax \u03c0\u2208\u03a0\n\u2211T t=1 rt,\u03c0(xt). The desired property\nof any contextual bandit algorithm is to have a sublinear (in T ) bound on Regret(T) (in expectation or high probability), i.e., Regret(T) \u2264 o(T). This guarantees that, at least, the algorithm converges to the optimal policy \u03c0\u2217 asymptotically.\nPractical Issues with CB Policy Space Policy space \u03a0 considered for major contextual bandit algorithms are based on classifiers. They can be tuples of binary classifiers, with one classifier per ad, or global cost-sensitive multi-class classifier, depending on the nature of the bandit algorithm. Since clicks on the ads are rare and small improvement in click-through rate can lead to significant reward, it is vital for the policy space to have good policies that can identify the correct ads for the rare users who are highly likely to click on them. Extreme click sparsity makes it very practically challenging to design a classifier-based policy space, where policies can identify the correct ads for rare users. Crucially, contextual bandit algorithms are only concerned with converging as fast as possible to the best policy \u03c0\u2217 in the policy space \u03a0 and do not take into account the nature of the policies. Hence, if the optimal policy in the policy space does a poor job in identifying correct ads, then the bandit algorithm will have very low cumulative reward, regardless of its sophistication. We discuss how click sparsity hinders in the design of different types of classifier-based policies."}, {"heading": "Binary Classifier Based Policies", "text": "Contextual bandit algorithms are traditionally presented as online algorithms, with continuous update of policies. Usually, in industrial PAR systems, it is highly impractical to update policies continuously, due to thousands of users visiting a system in a small time frame. Thus, policy update happens, i.e. new policy is learnt, after intervals of time, using the bandit data produced from the interaction between the current policy and users, collected in batch. It is convenient to learn a binary classifier per ad in such a setting. To explain the process concisely, we note that the bandit data consists of tuples of the form {x, a, ra}. For each ad a, the users who had not clicked on the ad (ra=0) would be considered as negative examples and the users who had clicked on the ad (ra=1) would be considered as positive examples, creating a binary training set for ad a. The K binary classifiers are converted into a recommendation policy using a \u201cone-vs-all\u201d method [Rifkin and\nKlautau, 2004]. Thus, each policy in policy space \u03a0 can be considered to be a tuple of K binary classifiers. A number of research publications show that researchers consider binary linear classifiers, that are learnt by optimizing the logistic loss [Richardson, Dominowska, and Ragno, 2007], while ensemble classifiers, like random forests, are also becoming popular [Koh and Gupta, 2014]. We note that the majority of the papers that learn a logistic linear classifier focus on feature selection [He and others, 2014], novel regularizations to tackle high-dimensional context vectors [McMahan and others, 2013], or propose clever combinations of logistic classifiers [Agarwal et al., 2009]. Click sparsity poses difficulty in design of accurate binary classifiers in the following way: for an ad a, there will be very few clicks on the ad as compared to the number of users who did not click on the ad. A binary classifier learnt in such setting will almost always predict that its corresponding ad will not be clicked by a user, failing to identify the rare, but very important, users who are likely to click on the ad. This is colloquially referred to as \u201cclass imbalance problem\u201d in binary classification [Japkowicz and Stephen, 2002]. Due to the extreme nature of the imbalance problem, tricks like under-sampling of negative examples or oversampling of positive examples [Chawla, Japkowicz, and Kotcz, 2004] are not very useful. More sophisticated techniques like cost-sensitive svms require prior knowledge about importance of each class, which is not generally available in the PAR setting. Note- Some of the referenced papers do not have explicit mention of CBs because the focus in those papers is on the issues related to classifier learning process, involving type of regularization, overcoming curse of dimensionality, scalability etc. The important issue of extreme class imbalance has not received sufficient attention (Sec 6.2, [He and others, 2014]). When the classifiers are used to predict ads, the technique is a particular CB algorithm (the exact exploration+ exploitation mix is often not revealed)."}, {"heading": "Cost Sensitive Multi-Class Classifier Based Policies", "text": "Another type of policy space consist of cost-sensitive multiclass classifiers [Langford and Zhang, 2008; Dudik et al., 2011; Agarwal et al., 2014]. They can be cost-sensitive multiclass svms [Cao, Zhao, and Zaiane, 2013], multi-class logistic classifiers or filter trees [Beygelzimer, Langford, and Ravikumar, 2007]. Click sparsity poses slightly different kind of problem in practically designing a policy space of such classifiers. Cost sensitive multi-class classifier works as follows: assume a context-reward vector pair (x,r) is generated as described in the PAR setting. The classifier will try to select a class (ad) a such that the reward ra is maximum among all choices of ra\u2032 , \u2200 a\u2032 \u2208 [K] (we consider reward maximizing classifiers, instead of cost minimizing classifiers). Unlike in traditional multi-class classification, where one entry of r is 1 and all other entries are 0; in cost sensitive classification, r can have any combination of 1 and 0. Now consider the reward vectors rts generated over T rounds. A poor quality classifier \u03c0p, which fails to identify the correct ad for most users xt,\nwill have very low average reward, i.e., \u2211T t=1 rt,\u03c0p(xt)\nT \u223c O( ), with \u223c 0. From the model perspective, extreme click spar-\nsity translates to almost all reward vectors rt being ~0. Thus, even a very good classifier \u03c0g , which can identify the correct ad at for almost all users, will have very low average reward,\ni.e., \u2211T t=1 rt,\u03c0g(xt)\nT \u223c O( ). From a practical perspective, it is difficult to distinguish between the performance of a good and poor classifier, in face of extreme sparsity, and thus, cost sensitive multi-class classifiers are not ideal policies for contextual bandits addressing the PAR problem."}, {"heading": "AUC Optimized Ranker", "text": "We propose a ranking-based alternative to learning a classifier per ad, in the offline setting, that is capable of overcoming the click sparsity problem. We learn a ranker per ad by optimizing the Area Under the Curve (AUC) loss, and use a ranking score normalization technique to create a policy mapping context to ad. We note that AUC is a popular measure used to evaluate a classifier on an imbalanced dataset. However, our objective is to explicitly use the loss to learn a ranker that overcomes the imbalance problem and then create a context to ad mapping policy. Ranker Learning Technique: For an ad a, let S+ = {x : ra = 1} and S\u2212 = {x : ra = 0} be the set of positive and negative instances, respectively. Let fw be a linear ranking function parameterized by w \u2208 Rd, i.e., fw(x) = w \u00b7 x (inner product). AUC-based loss (AUCL) is a ranking loss that is minimized when positive instances get higher scores than negative instances, i.e., the positive instances are ranked higher than the negatives when instances are sorted in descending order of their scores [Cortes and Mohri, 2004]. Formally, we define empirical AUCL for function fw(\u00b7)\nAUCL = 1 |S+||S\u2212| \u2211\nx+\u2208S+ \u2211 x\u2212\u2208S\u2212 1(fw(x +)\u2212 fw(x\u2212)\ufe38 \ufe37\ufe37 \ufe38\nt\n< 0).\nDirect optimization of AUCL is a NP-hard problem, since AUCL is sum of discontinuous indicator functions. To make the objective function computationally tractable, the indicator functions are replaced by a continuous, convex surrogate `(t). Examples include hinge `(t) = [1 \u2212 t]+ and logistic `(t) = log(1 + exp(\u2212t)) surrogates. Thus, the final objective function to optimize is\nL(w) = 1 |S+||S\u2212| \u2211\nx+\u2208S+ \u2211 x\u2212\u2208S\u2212 `(fw(x +)\u2212 fw(x\u2212)\ufe38 \ufe37\ufe37 \ufe38\nt\n). (1)\nNote: Since AUCL is a ranking loss, the concept of class imbalance ceases to be a problem. Irrespective of the number of positive and negative instances in the training set, the position of a positive instance w.r.t to a negative instance in the final ranked list is the only matter of concern in AUCL calculation.\nOptimization Procedure The objective function (1) is a convex function and can be efficiently optimized by stochastic gradient descent (SGD) procedure [Shamir and Zhang, 2013]. One computational issue associated with AUCL is that it pairs every positive and negative instance, effectively squaring the training set size.The SGD procedure easily overcomes this computational issue.\nAt every step of SGD, a positive and a negative instance are randomly selected from the training set, followed by a gradient descent step. This makes the training procedure memoryefficient and mimics full gradient descent optimization on the entire loss. We also note that the rankers for the ads can be trained in parallel and any regularizer like \u2016w\u20161 and \u2016w\u20162 can be added to (1), to introduce sparsity or avoid overfitting. Lastly, powerful non-linear kernel ranking functions can be learnt in place of linear ranking functions, but at the cost of memory efficiency, and the rankers can even be learnt online, from streaming data [Zhao et al., 2011]."}, {"heading": "Constructing Policy from Rankers", "text": "Similar to learning a classifier per ad, a separate ranking function fwa(\u00b7) is learnt for each ad a from the bandit batch data. Then the following technique is used to convert the K separate ranking functions into a recommendation policy. First, a threshold score sa is learnt for each action a \u2208 [K] separately (see the details below), and then for a new user x, the combined policy \u03c0 works as follows:\n\u03c0(x) = argmax a\u2208[K] (fwa(x)\u2212 sa). (2)\nThus, \u03c0 maps x to ad a with maximum \u201cnormalized score\u201d. This normalization negates the inherent scoring bias that might exist for each ranking function. That is, a ranking function for an action a \u2208 [K] might learn to score all instances (both positive and negative) higher than a ranking function for an action b \u2208 [K]. Therefore, for a new instance x, ranking function for awill always give a higher score than the ranking function for b, leading to possible incorrect predictions.\nLearning Threshold Score sa: After learning the ranking function fwa(\u00b7) from the training data, the threshold score sa is learnt by maximizing some classification measure like precision, recall, or F-score on the same training set. That is, score of each (positive or negative) instance in the training set is calculated and the classification measure corresponding to different thresholds are compared. The threshold that gives the maximum measure value is assigned to sa."}, {"heading": "Competing Policies and Evaluation Techniques", "text": "To support our hypothesis that ranker based policies address the click-sparsity problem better than classifier based policies, we set up two sets of experiments. We a) compared deterministic policies (only \u201cexploitation\u201d) on full information (classification) datasets and b) compared stochastic policies (\u201cexploitation + exploration\u201d) on bandit datasets, with a specific offline evaluation technique. Both of our experiments were designed for batch learning setting, with policies constructed from separate classifiers/rankers per ad. The classifiers considered were linear and ensemble RandomForest classifiers and ranker considered was the AUC optimized ranker.\nDeterministic Policies: Policies from the trained classifiers were constructed using the \u201cone-vs-all\u201d technique, i.e., for a new user x, the ad with the maximum score according to the classifiers was predicted. For the policy constructed\nfrom rankers, the ad with the maximum shifted score according to the rankers was predicted, using Eq. 2. Deterministic policies are \u201cexploit only\u201d policies.\nStochastic Policies: Stochastic policies were constructed from deterministic policies by adding an -greedy exploration technique on top. Briefly, let one of the stochastic policies be denoted by \u03c0e and let \u2208 [0, 1]. For a context x in the test set, \u03c0e(a|x) = 1 \u2212 , if a was the offer with the maximum score according to the underlying deterministic policy, and \u03c0e(a|x) = K\u22121 , otherwise (K is the total number of offers). Thus, \u03c0e is a probability distribution over the offers. Stochastic policies are \u201cexploit+ explore\u201d policies."}, {"heading": "Evaluation on Full Information Classification Data", "text": "Benchmark bandit data are usually hard to obtain in public domains. So, we compared the deterministic policies on benchmark K-class classification data, converted to K-class bandit data, using the technique in [Langford, Li, and Dudik, 2011]. Briefly, the standard conversion technique is as follows: A K-class dataset is randomly split into training set Xtrain and test set Xtest (in our experiments, we used 70\u2212 30 split). Only the labeled training set is converted into bandit data, as per procedure. Let {x, a} be an instance and the corresponding class in the training set. A class a\u2032 \u2208 [K] is selected uniformly at random. If a = a\u2032, a reward of 1 is assigned to x; otherwise, a reward of 0 is assigned. The new bandit instance is of the form {x, a\u2032, 1} or {x, a\u2032, 0}, and the true class a is hidden. The bandit data is then divided into K separate binary class training sets, as detailed in the section \u201cBinary Classifier based Policies\u201d. Evaluation Technique: We compared the deterministic policies by calculating the CTR of each policy. For a policy \u03c0, CTR on a test set of cardinality n is measured as:\n1\nn \u2211 (x,a)\u2208test set 1(\u03c0(x) = a) (3)\nNote that we can calculate the true CTR of a policy \u03c0 because the correct class a for an instance x is known in the test set."}, {"heading": "Evaluation on Bandit Information Data", "text": "Bandit datasets have both training and test sets in bandit form, and datasets we use are industry proprietary in nature. Evaluation Technique: We compared the stochastic policies on bandit datasets. Comparison of policies on bandit test set comes with the following unique challenge: for a stochastic policy \u03c0, the expected reward is \u03c1(\u03c0) = Ea\u223c\u03c0(\u00b7|x)ra =\u2211 a ra\u03c0(a|x), for a test context x (with the true CTR of \u03c0 being average of expected reward over entire test set). Since the bandit form of test data does not give any information about rewards for offers which were not displayed, it is not possible to calculate the expected reward!\nWe evaluated the policies using a particular offline contextual bandit policy evaluation technique. There exist various such evaluation techniques in the literature, with adequate discussion about the process [Li et al., 2011]. We used one of the importance weighted techniques as described in Theocharous et al. [2015]. The reason was that we could give\nhigh confidence lower bound on the performance of the policies. We provide the mathematical details of the technique.\nThe bandit test data was logged from the interaction between users and a fully random policy \u03c0u, over an interaction window. The random policy produced the following distribution over offers: \u03c0u(a|x) = 1K , \u2200 a \u2208 [K]. For an instance {x, a\u2032, ra\u2032} in the test set, the importance weighted reward of evaluation policy \u03c0 is computed as \u03c1\u0302(\u03c0) = ra\u2032 \u03c0(a\u2032|x) \u03c0u(a\u2032|x) . The importance weighted reward is an unbiased estimator of the true expected reward of \u03c0, i.e., Ea\u2032\u223c\u03c0u(\u00b7|x)\u03c1\u0302(\u03c0) = \u03c1(\u03c0).\nLet the cardinality of the test set be n. The importance weighted CTR of \u03c0 is defined as\n1\nn n\u2211 i=1 rai \u03c0(ai|xi) \u03c0u(ai|xi)\n(4)\nSince (x, r) are assumed to be generated i.i.d., the importance weighted CTR is an unbiased estimator of the true CTR of \u03c0. Moreover, it is possible to construct a t-test based lower confidence bound on the expected reward, using the unbiased estimator, as follows: let Xi = rai \u03c0(ai|xi) \u03c0u(ai|xi) ,\nX\u0302 = 1\nn n\u2211 i=1 Xi, and \u03c3 =\n\u221a 1\nn\u2212 1 n\u2211 i=1 (Xi \u2212 X\u0302)2. Then,\nX\u0302 = importance weighted CTR and\nX\u0302 \u2212 \u03c3\u221a n t1\u2212\u03b4,n\u22121 (5)\nis a 1 \u2212 \u03b4 lower confidence bound on the true CTR. Thus, during evaluation, we plotted the importance weighted CTR and lower confidence bounds for the competing policies."}, {"heading": "Empirical Results", "text": "We detail the parameters and results of our experiments. Linear Classifiers and Ranker: For each ad a, a linear classifier was learnt by optimizing the logistic surrogate, while a linear ranker was learnt by optimizing the objective function (1), with `(\u00b7) being the logistic surrogate. Since we did not have the problem of sparse high-dimensional features in our datasets, we added an `2 regularizer instead of `1 regularizer. We applied SGD with1 million iterations; varied the parameter \u03bb of the `2 regularizer in the set {0.01, 0.1, 1, 10} and recorded the best result. Ensemble Classifiers: We learnt a RandomForest classifier for each ad a. The RandomForests were composed of 200 trees, both for computational feasibility and for the more theoretical reason outlined in [Koh and Gupta, 2014]."}, {"heading": "Comparison of Deterministic Policies", "text": "Datasets: The multi-class datasets are detailed in Table 1.\nEvaluation: To compare the deterministic policies , we conducted two sets of experiments; one without undersampling of negative classes during training (i.e., no class balancing) and another with heavy under-sampling of negative classes (artificial class balancing). Training and testing were repeated 10 times for each dataset to account for the randomness introduced during conversion of classification training\ndata to bandit training data, and the average accuracy over the runs are reported. Figure 1 top and bottom show performance of various policies learnt without and with undersampling during training, respectively. Under-sampling was done to make positive:negative ratio as 1:2 for every class (this basically means that Avg % positive was 33%). The ratio of 1:2 generally gave the best results.\nObservations: a) With heavy under-sampling, the performance of classifier-based policies improve significantly during training. Ranker-based policy is not affected, validating that class imbalance does not affect ranking loss, b) The linear ranker-based policy performs uniformly better than the linear classifier-based policy, with or without undersampling. This shows that restricting to same class of functions (linear), rankers handles class-imbalance much better than classifiers c) The linear ranker-based policy does better than more complex RandomForest (RF) based policy, when no under-sampling is done during training, and is competitive when under-sampling is done, and d) Complex classifiers like RFs are relatively robust to moderate class imbalance. However, as we will see in real datasets, when class imbalance is extreme, gain from using a ranker-based policy becomes prominent. Moreover, growing big forests may be infeasible due to memory constraints,"}, {"heading": "Comparison of Stochastic Policies", "text": "Our next set of experiments were conducted on three different datasets that are property of a major technology company.\nDatasets: Two of the datasets were collected from campaigns run by two major banks and another from campaign\nTable 1: All datasets were obtained from UCI repository (https://archive.ics.uci.edu/ml/). Five different datasets were selected. In the table, size represents the number of examples in the complete dataset. Features indicate the dimension of the instances. Avg. % positive gives the number of positive instances per class, divided by the total number of instances for that class, in the bandit training set, averaged over all classes. The lower the value, the more is the imbalance per class during training.\nOptDigits Isolet Letter PenDigits Movementlibras Size 5620 7797 20000 10992 360\nFeatures 64 617 16 16 91 Classes 10 26 26 10 15\nAvg. % positive 10 4 4 10 7\nrun by a major hotel chain. When a user visited the campaign website, she was either assigned to a targeted policy or a purely random policy. The targeted policy was some specific ad serving policy, particular to the campaign. The data was collected in the form {x, a, ra}, where x denotes the user con-\ntext, a denotes the offer displayed, and ra \u2208 {0, 1} denotes the reward received. We trained our competing policies on data collected from the targeted policy and testing was done on the data collected from the random policy. We focused on the top-5 offers by number of impressions in the training set. Table 2 provides information about the training sets collected from the hotel and one of the bank\u2019s campaigns. The second bank\u2019s campaign has similar training set as the first one. As can be clearly observed, each offer in the bank\u2019s campaign suffers from extreme click sparsity.\nFeature Selection: We used a feature selection strategy to select around 20% of the users\u2019 features, as some of the features were of poor quality and led to difficulty in learning. We used the information gain criteria to select features [Cheng, Wang, and Bryant, 2012].\nResults: Figures 2(a), 2(b), and 2(c) show the results of our experiments. We used heavy under-sampling of negative examples, at the ratio 1:1 for positive:negative examples per offer, while training the classifiers. During evaluation, = 0.2 was used as exploration parameter. Taking < 0.2, meaning more exploitation, did not yield better results.\nObservations: a) The ranker-based policy generally performed better than the classifier-based policies. b) For the bank campaigns, where the click sparsity problem is extremely severe, it can be stated with high confidence that the ranker-based policy performed significantly better than classifier based policies. This shows that the ranker-based policy can handle class imbalance better than the classifier policies."}], "references": [{"title": "Translating relevance scores to probabilities for contextual advertising", "author": ["Agarwal et al", "2009] Agarwal", "E. Gabrilovich", "R. Hall", "V. Josifovski", "R. Khanna"], "venue": "In Proceedings of the 18th ACM conference on Information and knowledge management,", "citeRegEx": "D. et al\\.,? \\Q2009\\E", "shortCiteRegEx": "D. et al\\.", "year": 2009}, {"title": "Taming the monster: A fast and simple algorithm for contextual bandits", "author": ["Agarwal et al", "2014] Agarwal", "D. Hsu", "S. Kale", "J. Langford", "L. Li", "R. Schapire"], "venue": "In Proceedings of the 31st International Conference on Machine Learning,", "citeRegEx": "A. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "A. et al\\.", "year": 2014}, {"title": "and Goyal", "author": ["S. Agrawal"], "venue": "N.", "citeRegEx": "Agrawal and Goyal. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Multiclass classification with filter trees", "author": ["Langford Beygelzimer", "Ravikumar", "2007] Beygelzimer", "J. Langford", "P. Ravikumar"], "venue": null, "citeRegEx": "Beygelzimer et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Beygelzimer et al\\.", "year": 2007}, {"title": "S", "author": ["T. Calders", "Jaroszewicz"], "venue": "2007. Efficient AUC optimization for classification. In Knowledge Discovery in Databases: PKDD", "citeRegEx": "Calders and Jaroszewicz. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "An optimized cost-sensitive svm for imbalanced data learning", "author": ["Zhao Cao", "Zaiane", "2013] Cao", "D. Zhao", "O. Zaiane"], "venue": "In Advances in Knowledge Discovery and Data", "citeRegEx": "Cao et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Cao et al\\.", "year": 2013}, {"title": "and Li", "author": ["O. Chapelle"], "venue": "L.", "citeRegEx": "Chapelle and Li. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Editorial: special issue on learning from imbalanced data sets", "author": ["Japkowicz Chawla", "Kotcz", "2004] Chawla", "N. Japkowicz", "A. Kotcz"], "venue": "ACM Sigkdd Explorations Newsletter", "citeRegEx": "Chawla et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Chawla et al\\.", "year": 2004}, {"title": "FSelector: a ruby gem for feature selection. Bioinformatics 28(21):2851\u20132852", "author": ["Wang Cheng", "Bryant", "2012] Cheng", "Y. Wang", "S. Bryant"], "venue": null, "citeRegEx": "Cheng et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Cheng et al\\.", "year": 2012}, {"title": "Contextual bandits with linear payoff functions", "author": ["Chu et al", "2011] Chu", "L. Li", "L. Reyzin", "R. Schapire"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "W. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "W. et al\\.", "year": 2011}, {"title": "and Mohri", "author": ["C. Cortes"], "venue": "M.", "citeRegEx": "Cortes and Mohri. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "T", "author": ["M. Dudik", "D. Hsu", "S. Kale", "N. Karampatziakis", "J. Langford", "L. Reyzin", "Zhang"], "venue": "2011. Efficient optimal learning for contextual bandits. Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "Dudik et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Practical lessons from predicting clicks on ads at facebook", "author": ["X He"], "venue": "[He and others,", "citeRegEx": "He,? \\Q2014\\E", "shortCiteRegEx": "He", "year": 2014}, {"title": "and Stephen", "author": ["N. Japkowicz"], "venue": "S.", "citeRegEx": "Japkowicz and Stephen. 2002", "shortCiteRegEx": null, "year": 2002}, {"title": "and Gupta", "author": ["E. Koh"], "venue": "N.", "citeRegEx": "Koh and Gupta. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "and Zhang", "author": ["J. Langford"], "venue": "T.", "citeRegEx": "Langford and Zhang. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "Doubly robust policy evaluation and learning", "author": ["Li Langford", "Dudik", "2011] Langford", "L. Li", "M. Dudik"], "venue": "In Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "Langford et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Langford et al\\.", "year": 2011}, {"title": "Unbiased offline evaluation of contextual-banditbased news article recommendation algorithms", "author": ["Li et al", "2011] Li", "W. Chu", "J. Langford", "X. Wang"], "venue": "In Proceedings of the fourth ACM international conference on Web search and data mining,", "citeRegEx": "L. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "L. et al\\.", "year": 2011}, {"title": "Ad click prediction: a view from the trenches", "author": ["H McMahan"], "venue": "[McMahan and others,", "citeRegEx": "McMahan,? \\Q2013\\E", "shortCiteRegEx": "McMahan", "year": 2013}, {"title": "Predicting clicks: estimating the click-through rate for new ads", "author": ["Dominowska Richardson", "Ragno", "2007] Richardson", "E. Dominowska", "R. Ragno"], "venue": "In Proceedings of the 16th international conference on World Wide Web,", "citeRegEx": "Richardson et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Richardson et al\\.", "year": 2007}, {"title": "and Klautau", "author": ["R. Rifkin"], "venue": "A.", "citeRegEx": "Rifkin and Klautau. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "and Zhang", "author": ["O. Shamir"], "venue": "T.", "citeRegEx": "Shamir and Zhang. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Ad recommendation systems for life-time value optimization", "author": ["Thomas Theocharous", "Ghavamzadeh", "2015] Theocharous", "P. Thomas", "M. Ghavamzadeh"], "venue": "In Proceedings of the 24th International Conference on World Wide Web Companion,", "citeRegEx": "Theocharous et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Theocharous et al\\.", "year": 2015}, {"title": "High confidence off-policy evaluation", "author": ["Theocharous Thomas", "Ghavamzadeh", "2015] Thomas", "G. Theocharous", "M. Ghavamzadeh"], "venue": "In Proceedings of the Twenty-Ninth Conference on Artificial Intelligence", "citeRegEx": "Thomas et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Thomas et al\\.", "year": 2015}, {"title": "S", "author": ["P. Zhao", "R. Jin", "T. Yang", "Hoi"], "venue": "C.", "citeRegEx": "Zhao et al.. 2011", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 15, "context": "While the techniques in different papers differ in their details, the majority of them can be be analyzed under the umbrella framework of contextual bandits [Langford and Zhang, 2008].", "startOffset": 157, "endOffset": 183}, {"referenceID": 14, "context": "Some exploration techniques, like explicit greedy [Koh and Gupta, 2014; Theocharous, Thomas, and Ghavamzadeh, 2015] or implicit Bayesian type sampling from the posterior distribution maintained on classifier parameters [Chapelle and Li, 2011] are sometimes combined with this exploitation strategy.", "startOffset": 50, "endOffset": 115}, {"referenceID": 6, "context": "Some exploration techniques, like explicit greedy [Koh and Gupta, 2014; Theocharous, Thomas, and Ghavamzadeh, 2015] or implicit Bayesian type sampling from the posterior distribution maintained on classifier parameters [Chapelle and Li, 2011] are sometimes combined with this exploitation strategy.", "startOffset": 219, "endOffset": 242}, {"referenceID": 11, "context": "Other, more theoretically sophisticated online bandit algorithms, essentially learn a costsensitive multi-class classifier by updating after every round of user-system interaction [Dudik et al., 2011; Agarwal et al., 2014].", "startOffset": 180, "endOffset": 222}, {"referenceID": 21, "context": "The rankers are learnt by optimizing the Area Under Curve (AUC) ranking loss via stochastic gradient descent (SGD) [Shamir and Zhang, 2013], leading to a highly scalable algorithm.", "startOffset": 115, "endOffset": 139}, {"referenceID": 2, "context": ", 2011] and Thompson sampling [Agrawal and Goyal, 2013].", "startOffset": 30, "endOffset": 55}, {"referenceID": 14, "context": "A number of research publications show that researchers consider binary linear classifiers, that are learnt by optimizing the logistic loss [Richardson, Dominowska, and Ragno, 2007], while ensemble classifiers, like random forests, are also becoming popular [Koh and Gupta, 2014].", "startOffset": 258, "endOffset": 279}, {"referenceID": 13, "context": "This is colloquially referred to as \u201cclass imbalance problem\u201d in binary classification [Japkowicz and Stephen, 2002].", "startOffset": 87, "endOffset": 116}, {"referenceID": 15, "context": "Another type of policy space consist of cost-sensitive multiclass classifiers [Langford and Zhang, 2008; Dudik et al., 2011; Agarwal et al., 2014].", "startOffset": 78, "endOffset": 146}, {"referenceID": 11, "context": "Another type of policy space consist of cost-sensitive multiclass classifiers [Langford and Zhang, 2008; Dudik et al., 2011; Agarwal et al., 2014].", "startOffset": 78, "endOffset": 146}, {"referenceID": 10, "context": ", the positive instances are ranked higher than the negatives when instances are sorted in descending order of their scores [Cortes and Mohri, 2004].", "startOffset": 124, "endOffset": 148}, {"referenceID": 21, "context": "The objective function (1) is a convex function and can be efficiently optimized by stochastic gradient descent (SGD) procedure [Shamir and Zhang, 2013].", "startOffset": 128, "endOffset": 152}, {"referenceID": 24, "context": "Lastly, powerful non-linear kernel ranking functions can be learnt in place of linear ranking functions, but at the cost of memory efficiency, and the rankers can even be learnt online, from streaming data [Zhao et al., 2011].", "startOffset": 206, "endOffset": 225}, {"referenceID": 17, "context": "There exist various such evaluation techniques in the literature, with adequate discussion about the process [Li et al., 2011].", "startOffset": 109, "endOffset": 126}, {"referenceID": 14, "context": "The RandomForests were composed of 200 trees, both for computational feasibility and for the more theoretical reason outlined in [Koh and Gupta, 2014].", "startOffset": 129, "endOffset": 150}], "year": 2016, "abstractText": "We study the problem of personalized advertisement recommendation (PAR), which consist of a user visiting a system (website) and the system displaying one of K ads to the user. The system uses an internal ad recommendation policy to map the user\u2019s profile (context) to one of the ads. The user either clicks or ignores the ad and correspondingly, the system updates its recommendation policy. PAR problem is usually tackled by scalable contextual bandit algorithms, where the policies are generally based on classifiers. A practical problem in PAR is extreme click sparsity, due to very few users actually clicking on ads. We systematically study the drawback of using contextual bandit algorithms based on classifier-based policies, in face of extreme click sparsity. We then suggest an alternate policy, based on rankers, learnt by optimizing the Area Under the Curve (AUC) ranking loss, which can significantly alleviate the problem of click sparsity. We conduct extensive experiments on public datasets, as well as three industry proprietary datasets, to illustrate the improvement in click-through-rate (CTR) obtained by using the ranker-based policy over classifier-based policies.", "creator": "LaTeX with hyperref package"}}}