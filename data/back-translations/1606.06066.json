{"id": "1606.06066", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Jun-2016", "title": "Mining Local Process Models", "abstract": "In this paper, we describe a method for discovering common behavioral patterns in event logs. We express these patterns as\\ emph {local process models}. Local process model mining can be positioned between process discovery and episode / sequential pattern mining. However, the technique presented in this article is capable of learning behavioral patterns that include sequential composition, contemporaneity, selection, and loop, as in process mining. However, we do not consider start-to-end models that distinguish our approach from process discovery and establish a link to episode / sequential pattern mining. We propose an incremental process for creating local process models that capture common patterns based on so-called process trees. We propose five quality dimensions and corresponding metrics for local process models, with an event log predetermined. We suggest monotonicity properties for some quality dimensions that allow rapid discovery of process patterns only by demonstrating local process pattern degradation through a regular pattern degradation at the beginning.", "histories": [["v1", "Mon, 20 Jun 2016 11:28:26 GMT  (202kb,D)", "https://arxiv.org/abs/1606.06066v1", null], ["v2", "Tue, 16 May 2017 17:23:10 GMT  (1923kb)", "http://arxiv.org/abs/1606.06066v2", "Published in Elsevier's Journal of Innovation in Digital Ecosystems, Special Issue on Data Mining"]], "reviews": [], "SUBJECTS": "cs.DB cs.LG", "authors": ["niek tax", "natalia sidorova", "reinder haakma", "wil m p van der aalst"], "accepted": false, "id": "1606.06066"}, "pdf": {"name": "1606.06066.pdf", "metadata": {"source": "CRF", "title": "Mining Local Process Models", "authors": ["Niek Tax", "Natalia Sidorova", "Reinder Haakma", "Wil M. P. van der Aalst"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 6.\n06 06\n6v 2\n[ cs\n.D B\n] 1\n6 M\nay 2\nIn this paper we describe a method to discover frequent behavioral patterns in event logs. We express these patterns as local process models. Local process model mining can be positioned in-between process discovery and episode / sequential pattern mining. The technique presented in this paper is able to learn behavioral patterns involving sequential composition, concurrency, choice and loop, like in process mining. However, we do not look at start-to-end models, which distinguishes our approach from process discovery and creates a link to episode / sequential pattern mining. We propose an incremental procedure for building local process models capturing frequent patterns based on so-called process trees. We propose five quality dimensions and corresponding metrics for local process models, given an event log. We show monotonicity properties for some quality dimensions, enabling a speedup of local process model discovery through pruning. We demonstrate through a real life case study that mining local patterns allows us to get insights in processes where regular start-to-end process discovery techniques are only able to learn unstructured, flower-like, models.\nKeywords: Process mining, Knowledge discovery, Data mining"}, {"heading": "1. Introduction", "text": "Process mining aims to extract novel insight from event data [1]. Process discovery, the task of discovering a process model that is representative for the set of event sequences in terms of start-to-end behavior, i.e. from the start of a case till its termination, plays a prominent role in process mining. Many process discovery algorithms have been proposed and applied to a variety of real life cases (see [1] for an overview). A different perspective on mining patterns in event sequences can be found in the data mining field, where the episode mining [2] and sequential pattern mining [3] subfields focus on finding frequent patterns that are local, not necessarily describing the whole event sequences from start to end. Episode mining and sequential pattern mining have e.g. been used to analyze telecommunication networks [2], web navigational logs [2, 4], and retail sales transactions [5].\nPreprint submitted to Journal of Innovation in Digital Ecosystems May 17, 2017\nSequential pattern mining and episode mining are limited to the discovery of sequential orderings or partially ordered sets of events, while process discovery methods aim to discover a larger set of event relations, including sequential orderings, (exclusive) choice relations, concurrency, and loops, represented in process models such as Petri nets [6], BPMN [7], and process trees [8]. Process models that can be discovered with process discovery methods distinguish themselves from more traditional sequence mining methods like Hidden Markov Models [9] and Recurrent Neural Networks [10, 11] in that process models can be visually represented and their visual representation can be used for communication between process stakeholders. However, process discovery is normally limited to the discovery of a model capturing the behavior of process instances as a whole, and not local patterns within instances. Our goal is to develop methods allowing to mine local process models positioned in-between simple patterns (e.g. subsequences) and start-to-end models. Local process models focus on a subset of the process activities and describe some behavioral pattern that occurs frequently within event sequences. Such local process models cannot be discovered by using standard techniques.\nImagine a sales department where multiple sales officers perform four types of activities: (A) register a call for bids, (B) investigate a call for bids from the business perspective, (C) investigate a call for bids from the legal perspective, and (D) decide on participation in the call for bid. The event sequences (Figure 1a) contain the activities performed by one sales officer throughout the day. The sales officer works on different calls for bids and not necessarily performs all activities for a particular call himself. Applying discovery algorithms, like the Inductive Miner [12], yields models allowing for any sequence of events (Figure 1c). Such \u201dflower-like\u201d models do not give any insight in typical behavioral patterns. When we apply any sequential pattern mining algorithm using a threshold of six occurrences, we obtain the seven length-three sequential patterns depicted in Figure 1d (results obtained using the SPMF [14] implementation of the PrefixSpan algorithm [13]). However, the data contains a frequent non-sequential pattern where a sales officer first performs A, followed by B and a C in arbitrary order (Figure 1b). This pattern cannot be found with existing process discovery and sequential pattern mining techniques. The two numbers\nshown in the transitions (i.e., rectangles) represent (1) the number of events of this type in the event log that fit this local process model and (2) the total number of events of this type in the event log. For example, 13 out of 19 events of type C in the event log fit transition C, which are indicated in bold in the log in Figure 1a. Underlined sequences indicate non-continuous instances, i.e. instances with non-fitting events in-between the events forming the instance of the local process model.\nIn this paper we describe a method to extract frequently occurring local process models, allowing for choice, concurrency, loops, and sequence relations. We leverage process trees [15] to search for local process models, and describe a way to recursively explore candidate process trees up to a certain model size. For convenience, we often use the Petri net representations for process trees. In fact, results can also be visualized as BPMN [7], EPC [16], UML activity diagram [17], or UML statechart diagram [17]. We define five quality dimensions that express the degree of representativeness of a local process model with regard to an event log: support, confidence, language fit, coverage, and determinism. Based on quality metrics, we describe monotonicity properties over some quality dimensions and show how they can be used to make the recursive search over process trees more efficient.\nThe paper is organized as follows. Section 2 introduces the basic concepts used in this paper. Section 3 describes related work in the fields of process discovery and sequential pattern mining. Section 4 describes our local process model mining approach. Section 5 introduces quality dimensions and metrics for local process models and discusses monotonicity properties. Section 6 describes a local process model evaluation approach based on alignments. Section 7 shows the relevance of the proposed technique using two real life data sets and compares the results with the results obtained with several related techniques. Section 8 concludes the paper."}, {"heading": "2. Preliminaries", "text": "In this section we introduce process modeling notations, including Petri nets, process trees, which are used in later sections of this paper.\nX\u2217 denotes the set of all sequences over a set X and \u03c3 = \u3008a1, a2, . . . , an\u3009 a sequence of length n; \u3008\u3009 is the empty sequence and \u03c31 \u00b7 \u03c32 is the concatenation of sequences \u03c31, \u03c32. \u03c3 \u21be Q is the projection of \u03c3 on Q, e.g. \u3008a, b, c, a, b, c\u3009 \u21be{a,c}= \u3008a, c, a, c\u3009. #a(\u03c3) denotes the number of occurrences of element a in sequence \u03c3, e.g. #a(\u3008a, b, c, a\u3009) = 2.\nDefinition 1 (Applying Functions to Sequences). A partial function f \u2208 X 9 Y can be lifted to sequences over X using the following recursive definition: (1) f(\u3008\u3009) = \u3008\u3009; (2) for any \u03c3 \u2208 X\u2217 and x \u2208 X:\nf(\u03c3 \u00b7 \u3008x\u3009) =\n{\nf(\u03c3) if x /\u2208 dom(f), f(\u03c3) \u00b7 \u3008f(x)\u3009 if x \u2208 dom(f).\nWe assume the set of all process activities \u03a3L to be given. An event e is the occurrence of an activity e \u2208 \u03a3L. We call a sequence of events t \u2208 \u03a3L \u2217 a trace. An event log L \u2208 N\u03a3L \u2217\nis a finite multiset of traces. For example, the event log L = [\u3008a, b, c\u30092, \u3008b, a, c\u30093] consists of 2 occurrences of trace \u3008a, b, c\u3009 and three occurrences of trace \u3008b, a, c\u3009. We lift the sequence projection to the multisets of sequences in the standard way. For example, for the log L given above L \u21be{a,c}= [\u3008a, c\u3009\n5]. We lift the number of occurrences in a sequence to multisets of sequences in the standard way, for example, #a(L) = 5.\nPetri nets are directed bipartite graphs consisting of transitions and places, connected by arcs. Transitions represent activities, while places represent the enabling conditions of transitions. Labels are assigned to transitions to indicate the type of activity that they model. A special label \u03c4 is used to represent invisible transitions, which are only used for routing purposes and not recorded in the execution log.\nDefinition 2 (Labeled Petri net). A labeled Petri net N = \u3008P, T, F,\u03a3M , \u2113\u3009 is a tuple where P is a finite set of places, T is a finite set of transitions such that P \u2229 T = \u2205, F \u2286 (P \u00d7 T ) \u222a (T \u00d7 P ) is a set of directed arcs, called the flow relation, \u03a3M is a finite set of labels representing activities, with \u03c4 /\u2208 \u03a3M being a label representing invisible events, and \u2113 : T \u2192 \u03a3M \u222a {\u03c4} is a labeling function that assigns a label to each transition.\nFor a node n \u2208 (P \u222a T ) we use \u2022n and n\u2022 to denote the set of input and output nodes of n, defined as \u2022n = {n\u2032|(n\u2032, n) \u2208 F} and n\u2022 = {n|(n, n\u2032) \u2208 F} .\nA state of a Petri net is defined by its marking M \u2208 NP being a multiset of places. A marking is graphically denoted by putting M(p) tokens on each place p \u2208 P . A pair (N,M) is called a marked Petri net. State changes occur through transition firings. A transition t is enabled (can fire) in a given marking M if each input place p \u2208 \u2022t contains at least one token. Once a transition fires, one token is removed from each input place of t and one token is added to each output place of t, leading to a new marking M \u2032 defined as M \u2032 = M \u2212 \u2022t + t\u2022. A firing of a transition t leading from marking M to marking M \u2032 is denoted as M l(t) \u2212\u2192 M \u2032. M1 l(\u03c3) \u2212\u2192 M2 indicates that M2 can be reached from M1 through a firing sequence \u03c3\u2032 \u2208 \u03a3M \u2217.\nOften it is useful to consider a Petri net in combination with an initial marking and a set of possible final markings. This allows us to define the language accepted by the Petri net and to check whether some behavior is part of the behavior of the Petri net (can be replayed on it).\nDefinition 3 (Accepting Petri net). An accepting Petri net is a triple APN = (N,M0,MF ), where N is a labeled Petri net, M0 \u2208 Np is its initial marking, and MF \u2286 Np is its set of possible final markings, such that \u2200M1,M2\u2208MF M1 * M2. A sequence \u03c3 \u2208 T \u2217 is called a trace of an accepting Petri net APN if M0 \u03c3 \u2212\u2192 Mf for some final marking Mf \u2208 MF. The language L(APN) of APN is the set of all its traces.\nFigure 2 shows an example of an accepting Petri net. Circles represent places and rectangles represent transitions. Invisible transitions (labeled \u03c4) are depicted as black rectangles. Places that belong to the initial marking contain a token and places belonging to a final marking contain a bottom right label fi with i a final marking identifier, or are simply marked as in case of a single final marking. The language of this accepting Petri net is {\u3008A,B,C\u3009, \u3008A,C,B\u3009}.\nA different process representation is a process tree [15]. Process trees can only model sound (deadlock-free and livelock-free) processes. The recursive definition of process trees make them a convenient representation to iteratively expand process models into larger process models.\nDefinition 4 (Process tree). Let A \u2208 \u03a3M be a finite set of activities with \u03c4 /\u2208 \u03a3M . \u2295 = {\u2192,\u00d7,\u2227, } is the set of process tree operators.\n\u2022 if a \u2208 \u03a3M \u222a {\u03c4} then Q = a is a process tree.\n\u2022 if Q1, Q2 are process trees, and \u2295 \u2208 \u2295\n, then Q = \u2295(Q1, Q2) is a process tree.\nA process tree is a tree structure consisting of operator and activity nodes, such that each leaf node is an activity node and each non-leaf node is an operator node.\nThe loop operator ( ) has two child nodes, with the first child the \u201ddo\u201d part and the second child the \u201dredo\u201d child. Process tree p1 = (a, b) accepts language L(p1) = {\u3008a\u3009, \u3008a, b, a, \u3009, \u3008a, b, a, b, a\u3009, . . .}.\nThe sequence operator (\u2192) has two children, such that the first child is executed prior to execution of the second child. The language of process tree p2 = \u2192 (a, b) is L(p2) = {\u3008a, b\u3009}.\nThe exclusive choice operator (\u00d7) has two children, indicating that either the first or the second child will be executed, but not both. The language of process tree p3 = \u00d7(a, b) is L(p3) = {\u3008a\u3009, \u3008b\u3009}.\nThe concurrency operator (\u2227) has two children, indicating that the both children will be executed in parallel. Process tree p4 = \u2227(\u2192 (a, b),\u2192 (c, d)) accepts language L(p4) = {\u3008a, b, c, d\u3009, \u3008a, c, b, d\u3009, \u3008a, c, d, b\u3009, \u3008c, a, b, d\u3009, \u3008c, a, d, b\u3009, \u3008c, d, a, b\u3009}.\nLet p5 = \u00d7( (a, b),\u2227(c, d)). Figure 3 shows the graphical representation of p5. Because the do and redo children of a loop operator can be executed an arbitrary number of times, process trees containing a loop operator have a language of infinite size.\nWe define n-restricted language, consisting of all language traces of at most length n \u2208 N, as Ln = {t \u2208 L | |t| \u2264 n}. The n-restricted language is guaranteed to be of finite size, independent of the operators in the process tree. The 5-restricted language of the process tree p5 is L5(p5) = {\u3008a\u3009, \u3008a, b, a\u3009, \u3008a, b, a, b, a\u3009, \u3008c, d\u3009, \u3008d, c\u3009}."}, {"heading": "3. Related Work", "text": "ProM\u2019s Episode Miner [18] is a method that can be considered to be inbetween episode mining and process mining, as it discovers a collection of patterns from an event log where each pattern consists of partial order constructs. However, contrary to the technique that we describe in this paper, ProM\u2019s Episode Miner does not support loop and exclusive choice constructs and is not easily extensible to include new types of constructs.\nLu et al. propose a method called Post Sequential Patterns Mining (PSPM) [19] that takes a input a set of sequential patterns and post-processes them into a single graph consisting of sequential and exclusive choice constructs, which they call a Sequential Pattern Graph (SGP) [20]. A later extension by Lu et al. adds the capability to mine concurrency relations [21]. An SGP can be discovered from an event log by first applying any existing sequential pattern mining algorithm followed by PSPM on the discovered set of sequential patterns. The reliance of PSPMmethods on the output of sequential pattern mining techniques can also be considered to be a drawback of the approach. When two activities A and B are in parallel then both the orderings \u3008A,B\u3009 and \u3008B,A\u3009 will be present in the complete log. However, if one of the two orderings is more frequent than the other due to chance, one of the two orderings might not reach the support set in the sequential pattern mining, making it impossible for PSPM methods to discover the concurrency of A and B. A more fundamental distinction between PSPM and Local Process Model (LPM) discovery is that PSPM merges all relations into one single pattern while LPM discovery aims at discovering a collection of patterns. Merging separate patterns into a single graph could result in one single overgeneralizing graph. For example in the case of log L = [\u3008b, a, c\u3009100, \u3008d, a, e\u3009100], sequential pattern mining techniques will find two sequential patterns: b, a, c and d, a, e. Merging them into a single graph where a is\nfollowed by either c or e and is preceded by either b or d results in the loss the long term dependency where b already determines the occurrence of a c after the a.\nJung et al. [22] describe a method to mine frequent patterns from a collection of process models by transforming each business process to a vector format and then applying agglomerative clustering. Diamantini et al. [23, 24] take a similar approach, but apply graph clustering techniques instead of a traditional clustering approach. These techniques differ from LPM discovery as they take as input a set of process models instead of an event log. However, in many situations there are no existing process models available and, as shown in the introduction, it is not always possible to mine structured process models from an event log using process discovery techniques.\nIn later work, Diamantini et al. [25] describe a method to mine frequent patterns in process model notation through a two step approach. First each trace from the event log is transformed into a so called instance graph [26], which is graph representation of a trace that shows which steps in the trace are performed sequentially and which steps are performed in parallel (i.e. overlapping in time). In the second step they apply a graph clustering technique to obtain frequent subgraphs from this set of instance graphs. However, since instance graphs are limited to sequential and parallel constructs, other process constructs, such as choices and loops, cannot be discovered with the approach described in Diamantini et al. [25], while they can be discovered with LPM discovery.\nThe techniques developed in the area of trace clustering [27, 28, 29, 30] are related to LPM discovery in the sense that both aim to enable extraction of process insight from event logs where the process is too unstructured for existing process discovery techniques to find a structured process model. Trace clustering techniques aim to solve this by clustering similar traces together to prevent mixing different usage scenarios into one single unstructured process model. Trace clustering techniques work well when the original event log does not originate from one single process, but in fact originates from multiple processes. However, not in all types of complex and flexible event data there is a cluster tendency in the data. An example for such non-clusterable event data can be found in the log shown in Figure 1a, where no clustering over the traces would enable the discovery of the frequent pattern shown in Figure 1b. The traces in the log have large parts of randomness within the traces, while trace clustering helps for cases where there is a large degree of variety between traces.\nDeclarative process models, such as Declare [31], define the allowed behavior through constraints that must be respected while carrying out the process. This contrasts procedural process models, which are dominant in the process discovery field and specify all possible orderings of events explicitly. Two examples of process discovery approaches that generate declarative process models are the DPIL Miner [32] and the Declare Miner [33]. Both approaches specify a set of rule templates that consists of two activity variables and their relation. An example of such a template is sequence(a, b), indicating that some activity a is followed by b. Concrete rules are extracted from the event log based on this template-based search. However, since the rule templates are limited to relations\nbetween two activities, more complex relations between three or more activities cannot be discovered. Imagine that for some event log a declarative process discovery method finds two relations: sequence(a, b) and sequence(b, c), indicating that both the occurrences of activity b after a and the occurrences of activity c after b meet some support threshold. The binary relations sequence(a, b) and sequence(b, c) combined do not imply a tertiary relation equivalent to process tree \u2192 (a,\u2192 (b, c)), since it could be the case that specifically those occurrences of b that are preceded by a are rarely followed by c. The LPM discovery approach discussed in this paper enables discovery of relations between three or more activities.\nHybrid process discovery [34] aims at discovering a process model that consists partially of procedural process model constructs and partially of declarative process model constructs. Existing hybrid process discovery approaches consist of a first step where activities are separated into a group of structured activities and a group of unstructured activities, based on the number of unique predecessors and successors of an activity. However, some activities, such as activity a in the event log of Figure 1a, are part of a frequent pattern, but also to occur as noise at random point in the traces. Such activities would be classified as noisy activities by existing hybrid process discovery approaches, resulting in this activity being modeled with binary declarative constructs.\nThe Fuzzy Miner [35] is a process discovery technique developed to deal with complex and flexible process models. It connects nodes that represent activities with edges indicating follows relations, taking into account the relative significance of follows/precedes relations and allowing the user to filter out edges using a slider. However, the process models obtained using the Fuzzy Miner lack formal semantics, e.g. when a node has two or more outgoing edges, it is undefined whether this represents a choice, an exclusive choice, or parallel execution of the connected nodes.\nWe have described several techniques that are related in that sense that i) they aim to enable mining of process insight from less structured processes on which traditional process discovery methods fail, or ii) they aim to extract a collection of process models that each represent some subprocess. However, none of the existing techniques in category (i) is able to deal with event logs where some frequent patterns are surrounded by random events, as is the case in the event log in Figure 1a, and all of the existing methods in category (ii) either require a completely different type of input (a collection of graphs), or they support only a part of the constructs supported by the LPM discovery approach."}, {"heading": "4. Local Process Model Discovery Approach", "text": "A local process model (LPM) aims to describe frequent behavior in an event log in local, i.e. smaller, patterns, typically between three and five activity nodes. A LPM does not aim to describe all behavior in a trace completely, but instead aims to describe traces partially, focusing on frequently occurring patterns. A LPM LN represents behavior over \u03a3M and accepts language L(LN).\nThe closure of the accepting language with respect to alphabet \u03a3L is defined as L(LN ,\u03a3L) = {\u03c3 \u2208 \u03a3L \u2217| \u03c3 \u21be\u03a3M\u2208 L(LN )}.\nHere, we introduce a local process model discovery approach that consists of four main steps:\n1) Generation Generate the initial set CM1 (so i = 1) of candidate LPM in the form of process trees consisting of one leaf for each activity a \u2208 \u03a3L. Figure 4 shows this set of elementary process trees for an event log over alphabet \u03a3L = {a, b, . . . , z}. Create selected set of selected LPMs SM = \u2205.\n2) Evaluation Evaluate LPMs in current candidate set CMi based on a set of quality criteria.\n3) Selection Based on evaluation results, a set SCMi \u2286 CMi of candidate LPMs are selected. SM = SM\u222aSCMi. If SCMi = \u2205 or i \u2265 max iterations: stop.\n4) Expansion Expand SCMi into a set of larger, expanded, candidate process models, CMi+1. Goto step 2 using the newly created candidate set CMi+1.\nExpansion consists of the replacement of one of the leaf activity nodes a of the process tree by an operator node of one of the operator types, where one of the child nodes is the replaced activity node a and the other is a new activity node representing one of the activities b \u2208 \u03a3L. Figure 5 shows the set of expansion operations to leaf node a, consisting of six possible expansions. Two types of expansion operations are defined for the sequence (\u2192) and the loop ( ) operator types, as \u2192 (a, b) 6\u2261 \u2192 (b, a) and (a, b) 6\u2261 (b, a). However, only one expansion operation is needed for the \u2227 and \u00d7 operators because of their symmetry (\u2227(a, b) \u2261 \u2227(b, a) and \u00d7(a, b) \u2261 \u00d7(b, a)). We call \u2227 and \u00d7 symmetrical operators.\n\u00d7\n\u00d7\na c\nb \u2261\n\u00d7\na \u00d7\nb c Expanding the first leaf node (a) of process tree\u00d7(a, b) with the \u00d7 operator and some activity c \u2208 \u03a3L results in the leftmost process tree depicted on the right, while applying the same expansion the second leaf node (b) of the same process tree results in a behaviorally equivalent process tree (as shown on the right). The same holds for expansion of \u2227(a, b) with the \u2227 operator. Therefore, the number of expansions can be reduced further by restricting expansion of a leaf node that has a symmetrical operator as parent with the same symmetrical operator only to the\nrightmost child. This prevents unnecessary computation by generating both of the behaviorally equivalent trees shown on the right.\nThe number of possible expansion operations for a process tree P grows with the size of the alphabet of the event log |\u03a3L| and the number of activity nodes in P . This is easy to see, as each type of expansion operation can be applied to each activity node in P , leading to 6 \u00d7 |\u03a3L| expansion operations per activity node. At every point in the expansion process, the number of activity nodes in the tree is equal to the number of expansion operations performed plus one, as each expansion operation adds one activity node to the process tree.\nThe local process model discovery procedure stops when no process tree in the current set of candidate process models meets the quality criteria, or, to guarantee termination, when a maximum number of expansion steps, max iterations, is reached.\nThe approach of iteratively expanding, selecting, and expanding process trees described above is not theoretically limited to the set of operator nodes described above, and can easily be extended to other operators, such as an inclusive choice operator or a long-term dependency operator. Adding extra operators, however, comes with the price of increased computational complexity as it increases the number of ways to expand a process tree."}, {"heading": "5. Quality Criteria & Metrics", "text": "Assume for now that we have an oracle function \u03bbLN that generates a segmentation of a given trace \u03c3: \u03bbLN (\u03c3) = \u03b30\u03be1\u03b31\u03be2 . . . \u03bek\u03b3k, with \u03bei \u2208 L(LN ) and \u03b3i /\u2208 L(LN ), such that the number of events in {\u03be1, . . . , \u03bek} is maximized: the higher the number of events in \u03bei \u2208 L(LN ) segments, the larger the share of trace \u03c3 explained by the LPM. A higher value k indicates more frequent presence of LPM execution traces in \u03c3. \u03bbkLN (\u03c3) denotes the number of \u03be \u2208 L(LN ) segments in \u03bbLN (\u03c3). \u03bb \u03be LN (\u03c3) denotes the multiset of segments \u03bei \u2208 L(LN ). Here we discuss a number of quality criteria for LPM with regard to an event log.\nSupport Relates to the number of fragments in the event log that can be considered to be an instance of the LPM under evaluation. The rationale behind this quality dimension: an LPM whose execution traces are observed more frequently in the event log represents it better. We transform the count of pattern instances of LN in L into a [0, 1)-interval number through the following transformation:\nsupport(LN , L) = \u2211 \u03c3\u2208L \u03bbkLN (\u03c3)\n( \u2211\n\u03c3\u2208L \u03bbk LN (\u03c3))+1\nConfidence An event fits an LPM when it is part of a segment \u03be \u2208 L(LN). The confidence of event type e \u2208 \u03a3M in LPM LN given event log L, is the ratio of events of type a in L that fit LN :\nconfidence(a, L) = \u2211 \u03c3\u2208L #a(\u03bb \u03be LN (\u03c3))\n#a(L)\nWe use the harmonic mean to aggregate confidence values for individual activities to a single metric, as it is more sensitive to a single lower-than-average value than the geometric mean. We define the confidence of an LPM LN given an event log L to be the harmonic mean of the individual confidence scores of the event types of LN :\nconfidence(LN , L) = |\u03a3M |\u2211 a\u2208\u03a3M 1 confidence(a,L)\nLanguage Fit Language fit expresses the ratio of the behavior allowed by the LPM that is observed in the event log. LPMs that allow for much more behavior than what is observed are likely to overgeneralize and therefore do not describe the behavior in the event log well. The language fit of an LPM LN given log L is:\nlanguage fit(LN , L) = |{\u03c6\u2208L(LN )|\u2203\u03c3\u2208L:\u03c6\u2208\u03bb\u03be LN (\u03c3)}|\n|L(LN)|\nSince |L(LN )| = \u221e in case LN contains a loop, language fit(LN , L) = 0 for any LN containing a loop. Restricting the language and the LPM instances to sequences of a bounded length allows us to approximate language fit for models with infinite size language. Language fit restricted to bound n \u2208 N is defined as:\nlanguage fitn(LN , L) = |{\u03c6\u2208Ln(LN)|\u2203\u03c3\u2208L:\u03c6\u2208\u03bb\n\u03be LN (\u03c3)}|\n|Ln(LN )|\n\u00d7\na \u00d7\nb \u00d7\nc d Determinism Flower-like process trees, like the one shown on the right, are not desirable as they provide little insight in what behavior we are likely to observe. Deterministic LPMs have more predictive value in with regard to future behavior. When the language of LPM LN contains traces if type \u03c3a\u03b31 and \u03c3b\u03b32, the continuation of the trace after observing prefix \u03c3 can be either a or b, leaving some uncertainty. LPMs with a high degree of certainty are preferable over LPMs with a low degree of certainty. A metric for the determinism quality dimension is dependent on the process model and not only on its language. Let R(LN ) be a set of reachable states of an LPM LN . WL : R(LN ) \u2192 N represents a function assigning the number of times a state is reached while replaying the fitting segments of log L on LN . D : R(LN ) \u2192 N represents a function assigning the number of transitions enabled in a certain state in LN . Determinism is defined as:\ndeterminism(LN , L) = \u2211\nm\u2208R(LN ) WL(m)\u2211 m\u2208R(LN ) WL(m)\u00b7D(m)\nCoverage Let LN be an LPM and L be an event log. Let #\u2217(L) denote the total number of events of event log L. Coverage is defined as the ratio of the number of events in the log after projecting the event log on the labels of LN\nto the number of all events in the log:\ncoverage(LN , L) = #\u2217(L\u21be\u03a3M )\n#\u2217(L)"}, {"heading": "5.1. Local Process Model Selection & Ranking", "text": "The quality dimensions and metrics defined are used to select and rank local process models generated through the recursive process tree exploration approach. Often, one is interested in multiple quality criteria at the same time. A high-support local process model that has a low determinism score (e.g., a small flower pattern) does not generate much process insight, while a deterministic pattern that has low support does not describe the behavior in the log very well. So it is possible to set thresholds per dimension. It is also useful to rank patterns according to a weighted average over the quality criteria. The appropriate weighting of the quality dimensions depends on the business questions and the situation at hand."}, {"heading": "5.2. Monotonicity Properties & Pruning", "text": "Often one is not interested in local process models with a low support, confidence, or determinism. Setting a minimum threshold for these quality criteria allows us to prune away those parts of the search space where we know that expansions of a candidate local process model can never meet the criteria because of monotonicity, resulting in a speedup of the proposed recursive process tree exploration procedure. Pruning based on monotonicity is similar to the pruning performed in the well-known Apriori algorithm [36], and other algorithms inspired by the Apriori algorithm, such as [3].\nAny expansion of process tree P where a leaf node a \u2208 P is replaced by subtree \u2192 (a, b), \u2192 (b, a), \u2227(a, b), or (a, b) for any b \u2208 \u03a3L is guaranteed to be less frequent, i.e. has lower support, than P . The intuition behind this is that expansion put additional requirements of the alignments, possibly causing some fitting segments for a trace \u03c3 obtained by \u03bb\u03beP (\u03c3) to not fit the expansion of P . Therefore, when P does not meet support threshold minsup, its expansions of any activity node a into \u2192 (a, b), \u2192 (b, a), \u2227(a, b), and (a, b) can be pruned from the search space.\nProcess tree P is guaranteed to be at least as deterministic as its expansion where activity node a \u2208 P is replaced by subtree \u00d7(a, b) or \u2227(a, b) for any b \u2208 \u03a3L. Therefore, when P does not meet determinism threshold mindet, its expansions of any activity node a into \u00d7(a, b), and \u2227(a, b) can be pruned from the search space."}, {"heading": "6. Alignment-Based Evaluation of Local Process Models", "text": "We now describe a way to define function \u03bbLN . We evaluate LPMs using Petri nets because of the rich set of analysis techniques available for Petri nets. Important for the definition of \u03bbLN is the notion of alignments [37], which aims to find a sequence of model firings starting at the initial marking and ending in a final marking that is an optimal approximation of the behavior in the event\nlog. Alignments relate model traces and event log traces through a series of three types of moves: synchronous moves, moves on model, and moves on log. When an event in the event log trace can be performed in the process model, log and model can move synchronously. However, when a trace of the log does not fit the model, log and model cannot move synchronously from the start to the end of the trace. A move on model corresponds to a firing of a transition in the model that cannot be mapped to an event in the log. A move on log corresponds to an event in the log that cannot be mapped to a transition firing in the model. Since both moves on model and moves on log are suboptimal behavior, they are often assigned certain costs such that the alignment will only chose to do moves on model or moves on log when these moves are unavoidable. Moves on model enable the unwanted behavior that a partial execution of the LPM can be identified as an LPM execution trace. To avoid this behavior, we use a version of alignments where moves on model on non-silent transitions are prohibited (infinite costs).\nAlignments aim to match an event log trace with a single execution of a process model. However, an event log trace can contain more than one execution trace of an LPM. We modify the Petri net representation of the LPM such that we connect each final marking to the initial marking through a silent transition, allowing the alignment to relate a single trace to multiple executions of the model. Figure 6a shows an example LPM and Figure 6b shows the corresponding Petri net after transformation. We transform LPM LN (N,M0,MF ) with N = (P, T, F,\u03a3M , \u2113) into LNBL(NBL,M0, {M0}) with NBL = (P, TBL, FBL,\u03a3M , \u2113BL), such that:\n\u2022 TBL = T \u222a {tblM |M \u2208 MF},\n\u2022 FBL = F \u222a {(p, tblM )|M \u2208 MF \u2227 p \u2208 M} \u222a {tblM |M \u2208 MF \u2227 p \u2208 M0},\n\u2022 \u2113BL \u2208 TBL \u2192 \u03a3M \u222a {\u03c4} with:\n\u2113BL =\n{\n\u2113(T ), if t \u2208 T,\n\u03c4, otherwise.\nLNBL contains a set of added silent transitions, {tblM |M \u2208 MF}, consisting of one silent transition for each final marking M \u2208 MF . Backloop : MF \u2192 Tbl is a bijective mapping from a final marking M \u2208 MF to a silent transition tblM . A silent transition tblM has all places in final marking M as input and place M0 as output. The number of executions of backloop transitions {tblM |M \u2208 MF} in the alignments of L on LN indicates the number of executions of traces of LN in L. Note that alignments require the model to be in a marking M \u2208 MF at the end of the alignment. This is impossible to obtain when pattern LN is absent in log L. Therefore, we set the final marking to {M0}, allowing the alignments to make a complete sequence of moves on log, resulting in zero executions of the model.\nFigure 6c illustrates the concept of alignments through an example, showing the alignment of the non-fitting trace \u3008A,A,C,B,A,A,C,B,B,C\u3009 on the model of Figure 6b. The top row of the alignments represents the behavior of the log,\nwhile the middle row and the bottom row represent the behavior of the model. \u226b indicates no move, with a \u226b in the top row indicating a move on model and in the middle row indicating a move on log. The model is able to mimic the first event of the trace by executing t1 with label A, but is not able to mimic the second A in the log, resulting in a move on log. The C and B in the log can be mimicked (by t3 and t2 respectively). Next event A in the log can only be mimicked by the model by first firing tbl1 , resulting in a move on model, represented by the \u226b in the log. Afterwards, A can be mimicked and another move on log is needed for the second A. C and B can again be mimicked, after which a move on log is again needed as the log cannot mimic tbl1 . Would we not have prohibited moves on models on non-silent transition, the alignment could now have executed a move on model on A, enabling synchronous moves on both B and C, falsely giving the impression that the LPM would have a third occurrence in the trace. As we prohibited the model move on A, the only option is to decide a move on log on B and C, thereby not counting the incomplete occurrence of the pattern.\nLPM LN is evaluated on event log L by projecting L on the set of labels of LN , L\u2032 = L \u21be\u03a3M . The middle row of the alignment of L \u2032 on LNBL represents the segmentation \u03bb\u03beLN , where \u03c4 moves on a transition tbli \u2208 {tblm|M \u2208 MF} indicates the start of a new segment. The alignment in Figure 6c shows that \u03bb\u03beLN (\u3008A,A,C,B,A,A,C,B,B,C\u3009) = [\u3008A,C,B\u3009 2]."}, {"heading": "6.1. Determinism on Petri nets", "text": "We now explain through an example how to calculate determinism for Petri nets. Each transition firing in a Petri net corresponds to a change in the marking of the net. Table 1 shows the transitions fired in the alignment of Figure 6c. The bottom row represents the number of transitions that were enabled in the Petri net when the transition fired. When t3 fired, the Petri net was in a marking where both t2 and t3 were enabled. The determinism of the net corresponds to one divided by the average number of enabled transitions during replay. In the example, determinism(LN , L) = 1012 ."}, {"heading": "7. Case Studies", "text": "We now evaluate the proposed local process model mining method on two real life data sets."}, {"heading": "7.1. BPIC \u201912 Data Set", "text": "The Business Process Intelligence Challenge (BPIC)\u201912 data set originates from a personal loan or overdraft application process in a global financial institution. We transformed the event log to obtain traces of all activities in a single day performed by one specific resource (bank employee). This resource was selected randomly to be resource id 10939. The event log for this specific resource contains 49 cases (working days), 2763 events, and 14 activities. Discovering the local process models with the approach described in this paper took 34 seconds on a machine with a 4-core 2.4 GHz processor using a support threshold of 0.7.\nFigure 7 shows the Petri net discovered for resource 10939 with the Inductive Miner infrequent with a noise threshold of 20%. The discovered model only contains 13 non-silent transitions, as the activity W valideren aanvraag is filtered\nout by the Inductive Miner because of its low frequency. The process model in Figure 7 is very close to a \u201dflower model\u201d, which is the model that allows all behavior over its activities. The Inductive Miner without noise filtering returns exactly the flower model over the 14 activities in the log. The discovered process is unstructured because of a high degree of variance of the event log, which is caused by 1) the resource performing work on multiple applications interleaved, and 2) the resource only performing only a subset of the process steps for each application, and which process steps he performs might differ per application. For such a high-variance event log, it is likely that no start-to-end process model exists that accurately describes the behavior in the event log.\nFigure 8 shows five local process models discovered with the approach described in this paper, which give process insights that cannot be obtained from the start-to-end process model in Figure 7. Local process model (a) shows that all occurrences of events of type O SELECTED, O CREATED, and O SENT, occur in this exact order. Figure 7 overgeneralizes by suggesting that for example O SELECTED can be followed by three skip (black) transitions, after which another O SELECTED or a A ACCEPTED can be performed, which never happens in reality. O SELECTED and O CREATED in 7 can be sepa-\nrated by A FINALIZED, which makes the dependency between O SELECTED and O CREATED a long-term dependency, of which discovery is still one of the open problems in process mining [38] The local process model discovery method does find this long term dependency, because each local process model candidate is evaluated on a version of the event log that is projected on the set of labels of candidate under evaluation.\nLPM (b) is an extension of LPM (a) as the last three activities in the sequence are the same, therefore, each occurrence of LPM (b) in the log will also be an occurrence of (a). LPM (b) starts with an additional activity A ACCEPTED of which 103 out of 104 events follow this sequential pattern. The confidence of LPM (b) is lower than the confidence of (a), because only 103 out of 124 events of the last three activities of the sequence in LPM (b) can be explained by the model while each event of these activities is explained by LPM (a). From this we can conclude that there are 21 occurrences of the sequence O SELECTED, O CREATED, O SENT that are not preceded by A ACCEPTED. Partly this can be explained by A ACCEPTED only occurring 104 times, however, the model also shows that there is one A ACCEPTED event that is not followed by O SELECTED, O CREATED, and O SENT. It might be the case that this A ACCEPTED event does not fit the regular workflow, or alternatively it might be the case that the other process steps of after A ACCEPTED were executed by a different resource. Note that the determinism of LPMs (a) and (b) is 1.0, since both LPMs are sequential. Language fit of both LPMs is also 1.0, since both allow for only one execution path, which is observed in the log.\nLocal process model (c) shows that all instances of A FINALIZED are in parallel with O SELECTED, and ultimately followed by O CREATED and O SENT. This is more informative than Figure 7, which allows for much more behavior over activities A FINALIZED, O SELECTED, O CREATED, and O SENT.\nLocal process model (d) shows that each O CREATED and O SENT is preceded by either O CANCELED (29 times) or A FINALIZED (95 times). Also most of the O CANCELED events (29 out of 34) and most of the A FINALIZED events (95 out of 104) are followed by O CREATED and O SENT. Figure 7 does not provide the insight that O CANCELED is followed by O CREATED and O SENT. Note that the determinism of LPM (d) is lower than the determinism of LPM (c). This is in agreement with the intuition of determinism, as the concurrency at the start of LPM (c) can be regarded as a choice between two activities followed by a deterministic step of executing the other activity, while LPM (d) starts with a choice between two activities. After the concurrency in LPM (c) and the choice in LPM (d) respectively, the two models proceed identically. Local process model (d) has higher confidence than LPMs (b) and (c) as only five of the O CANCELED and nine of the A FINALIZED events cannot be explained by the model. LPM (d) has a higher confidence than LPM (c), mostly because all occurrences of O CREATED and O SENT could be aligned in LPM (d) while only 104 out of 124 could be aligned in LPM (c).\nNotice that the number of events that were aligned on A FINALIZED is lower in LPM (d) than in LPM (c). This indicates that there are six occur-\nrences where the alignments aligned on O CANCELED while it was possible as well to align on A FINALIZED (as both occurred). Therefore, an inclusive choice construct would have been a more correct representation than the exclusive choice that is currently included in the LPM. Note that our process tree based discovery approach allows for easy extension with additional operators, like e.g. an inclusive choice operator.\nLPM (e) shows an example of a weaker local process model that performs lower on some quality metrics but can still be discovered with the described approach. The coverage of LPM (e) is much higher than the other models as W Nabellen offertes (Dutch for \u201cCalling after call for bids\u201d) is a frequently occurring event in the log. The confidence of LPM (e) is however much lower it explains only a fraction of the W Nabellen offertes events."}, {"heading": "7.2. Comparison with Related Techniques", "text": "In this section we apply some of the related techniques described in Section 3 to the event log of BPI\u201912 resource 10939 and compare the insights that can be obtained with those methods with the insights that we obtained with LPM discovery.\nWe start with the Declare miner [33], which mines a set of binary constraints from the data based on a set of constraint templates. Figure 9b shows the result of the Declare miner [33] on the BPI\u201912 resource 10939 event log with a support threshold of 90%, requiring that the constraints hold in 90% of the cases. The model shows that a choice constraint holds between O SELECTED and W Nabellen offertes, indicating that on each working day either at least one event of type O SELECTED or W Nabellen offertes occurs. The same can be said about the pairs of event W Nabellen offertes and O SENT, W Nabellen offertes and O CREATED, and W Nabellen offertes and O Completeren aanvraag. Furthermore a not chain succession constraint is discovered between W Nabellen offertes and O SENT, indicating that W Nabellen offertes and O SENT never directly follow each other. Not chain succession constraints are also discovered between W Nabellen offertes and O SELECTED, and between W Nabellen offertes and O CREATED. Note that the none of the insights that we obtained from the LPMs in Figure 8 could be obtained from this Declare model.\nBy lowering the support threshold parameter of the Declare miner to 80%, we obtain a larger set of constraints. An exclusive choice constraint is found between W Valideren aanvraag and W Nabellen offertes, indicating that 80% of the cases contain one of the two activities but not both. The same type of constraint is found between W Valideren aanvraag and W Completeren aanvraag. The rest of the constraints found are not chain succession constraints.\nTo find constraints that can be deduced from the LPMs of Figure 8, such as the sequential ordering between O SELECTED and O CREATED from LPM (a), the support threshold would need to be lowered even further, leading to an overload of constraints being found by the Declare miner. Declare miner evaluates the constraints based on the ratio of cases in which the constraint holds. However, when activities are often repeated within cases, this is not\na useful evaluation criterion. Employee 10939 performs most of the activities multiple times during a working day, therefore, to assess whether an activity a is generally followed by an activity b it is more useful to count the ratio of occurrences of activity a that are followed by b as in LPM discovery, instead of the number of cases that contain an a event that is followed by a b event.\nEven more important is the fact that Declare miner is limited to binary constraints while LPM discovery mines n-ary relations. That is likely to be the cause of Declare mining not finding any of the LPM relations found in Figure 8. At the same time this difference provides an explanation why Declare mining finds so many uninteresting not chain succession constraints between activities: when there are multiple a events in a trace, you are likely to find at least one a that is in a not chain succession relation with some activity b, leading to a high ratio of traces that fulfill such a not chain succession constraint.\nFigure 10 shows the result of the Fuzzy miner on the BPI\u201912 resource 10939 event log with default parameters. The discovered Fuzzy model does contain a path from O SELECTED through O CREATED to O SENT, which were shown to be in a sequential relation by LPM (a). However, the Fuzzy model allows for many more paths, therefore the sequential relation between those three activities cannot be inferred from the Fuzzy model. LPM (c) showed a sequential path between O CREATED and O SENT that is preceded by an arbitrary ordering of activities O SELECTED and A FINALIZED. The Fuzzy model also shows arrows from both O SELECTED and A FINALIZED to O CREATED, however, as a Fuzzy model does not make a distinction between parallelism, inclusive choice constructs and exclusive choice constructs, it does not answer the question whether O SELECTED is preceded by both O SELECTED and A FINALIZED, or just by one of the two.\nFigure 11 shows the first four episodes found with ProM\u2019s Episode Miner on the BPI\u201912 resource 10939 event log. The first two episodes show the same sequential ordering from O SELECTED, O CREATED, and O SENT that is represented by LPM (a). The first episode suggests that the O CREATED event is optional, and can be skipped. LPM (a) however shows that all of the O SELECTED events are followed by an O CREATED event, therefore it is never skipped. Episode (c) indicates that O SELECTED and O CREATED can happen in any order, but both of them have to occur before O SENT occurs\nand episode (d) indicates that O SELECTED has to happen before O SENT and O CREATED can occur. Episodes (a), (c) and (d) can be considered to be less specific versions of episode (b). ProM\u2019s Episode Miner is not able to discover patterns with choice constructs like LPM (d), or patterns with loops.\n7.3. Gazelle Data Set\nThe Gazelle data set is a real life data set used in the KDD-CUP\u20192000 and contains customers\u2019 web click-stream data provided by the Blue Martini Software company. The Gazelle data set has been frequently used for evaluating sequential pattern mining algorithms. For each customer there is a series of page views, in which each page view is treated as an event. The data set contains 29369 sequences (customers), 87546 events (page views), and 1423 distinct event types (web pages). The average sequence length is three events. More detailed information on the Gazelle data set can be found in [39]. We compare the local process models found on this data set with the sequential patterns obtained with the well-known sequential pattern mining algorithm PrefixSpan [13] as implemented in the SPMF [14] sequential pattern mining library. We set the minimal support parameter of the sequential pattern mining algorithms to 10% of the number of input sequences. All obtained sequential patterns were also discovered by the local process model miner. Additionally, several non-sequential patterns were discovered that cannot be discovered with sequential pattern mining techniques, an example of which is shown in Figure 12. This shows that this well-known sequential pattern mining evaluation data set contains frequent and high-confidence patterns that cannot be found with sequential pattern mining approaches, but can be found with the local process model discovery approach. This indicates the applicability of local process model discovery to the field of pattern mining."}, {"heading": "8. Conclusion & Future Work", "text": "This paper presents a method to discover local process models that can express the same rich set of relations between activities as business process models, but describe frequent fragments instead of complete start-to-end processes. We presented five quality criteria and corresponding metrics quantifying the degree of representativeness of a local process model for an event log. We describe monotonicity properties of quality metrics that can be used to prune the search space and speed up computation. We illustrate through two case studies on\nreal-life data sets that the proposed method enables the user to obtain process insight in the form of valuable patterns when the degree of randomness/variance of the event data prevents traditional process discovery techniques to discover a structured start-to-end process model. Furthermore, the proposed local process model discovery approach is able to discover long-term dependencies, which most process discovery approaches have difficulties with, as a result of evaluating the local process models on a projected version of the event log.\nThe computational time involved in discovering local process models rapidly grows with the number of activities in the event log. Therefore, we consider automatic discovery of projections on the event log (limiting search to a promising subset of the activities) to be an important area of future work, as it would enable the discovery of local process models on logs with larger numbers of activities. An alternative approach to deal with larger numbers of activities that is to be explored is the use of meta-heuristic search methods, e.g. simulated annealing, which allows partial exploration of the search space.\nFinally, we consider it to be a relevant future direction of research to enhance local process models with guards, time information, and resource information."}], "references": [{"title": "Discovery of frequent episodes in event sequences", "author": ["H. Mannila", "H. Toivonen", "A.I. Verkamo"], "venue": "Data Mining and Knowledge Discovery 1 (3) ", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1997}, {"title": "Mining sequential patterns", "author": ["R. Agrawal", "R. Srikant"], "venue": "in: Proceedings of the 11th International Conference on Data Engineering (ICDE), IEEE", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1995}, {"title": "Discovering unbounded episodes in sequential data", "author": ["G. Casas-Garriga"], "venue": "in: Proceedings of the 7th European Conference on Principles and Practice of Knowledge Discovery in Databases (PKDD), Vol. 7, Springer Science & Business Media", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "Detection of significant sets of episodes in event sequences", "author": ["M. Atallah", "W. Szpankowski", "R. Gwadera"], "venue": "in: Proceedings of the 4th IEEE International Conference on Data Mining (ICDM), IEEE", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2004}, {"title": "Petri nets: an introduction", "author": ["W. Reisig"], "venue": "Vol. 4, Springer Science & Business Media", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "Flexible evolutionary algorithms for mining structured process models", "author": ["J.C.A.M. Buijs"], "venue": "Ph.D. thesis, PhD thesis. Eindhoven, The Netherlands: Technische Universiteit Eindhoven, 2014 ", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2014}, {"title": "A tutorial on hidden markov models and selected applications in speech recognition", "author": ["L.R. Rabiner"], "venue": "Proceedings of the IEEE 77 (2) ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1989}, {"title": "Learning task-dependent distributed representations by backpropagation through structure", "author": ["C. Goller", "A. Kuchler"], "venue": "in: Neural Networks, 1996., IEEE International Conference on, Vol. 1, IEEE", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1996}, {"title": "Long short-term memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural computation 9 (8) ", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1997}, {"title": "W", "author": ["S.J.J. Leemans", "D. Fahland"], "venue": "M. P. van der Aalst, Discovering blockstructured process models from event logs - a constructive approach, in: Application and Theory of Petri Nets and Concurrency, Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "PrefixSpan: mining sequential patterns efficiently by prefix-projected pattern growth", "author": ["J. Pei", "J. Han", "B. Mortazavi-Asl", "H. Pinto", "Q. Chen", "U. Dayal", "M.-C. Hsu"], "venue": "in: Proceedings of the 17th International Conference on Data Engineering (ICDE), IEEE", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2001}, {"title": "SPMF: a java open-source pattern mining library", "author": ["P. Fournier-Viger", "A. Gomariz", "T. Gueniche", "A. Soltani", "C.-W. Wu", "V.S. Tseng"], "venue": "The Journal of Machine Learning Research 15 (1) ", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2014}, {"title": "B", "author": ["J.C.A.M. Buijs"], "venue": "F. van Dongen, W. M. P. van der Aalst, A genetic algorithm for discovering process trees, in: Proceedings of the 2012 IEEE Congress on Evolutionary Computation (CEC), IEEE", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Semantische Proze\u00dfmodellierung auf der Grundlage\u201d Ereignisgesteuerter Proze\u00dfketten (EPK)", "author": ["G. Keller", "A.-W. Scheer", "M. N\u00fcttgens"], "venue": "Institut f\u00fcr Wirtschaftsinformatik", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1992}, {"title": "W", "author": ["M. Leemans"], "venue": "M. P. van der Aalst, Discovery of frequent episodes in event logs, in: Data-Driven Process Discovery and Analysis, Springer", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2014}, {"title": "Sequential patterns postprocessing for structural relation patterns mining", "author": ["J. Lu", "W. Chen", "O. Adjei", "M. Keech"], "venue": "Strategic Advancements in Utilizing Data Mining and Warehousing Technologies: New Concepts and Developments ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "Sequential patterns graph and its construction algorithm", "author": ["J. Lu", "X.-F. Wang", "O. Adjei", "F. Hussain"], "venue": "Chinese Journal of Computers 27 (6) ", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2004}, {"title": "Graph-based modelling of concurrent sequential patterns", "author": ["J. Lu", "W. Chen", "M. Keech"], "venue": "Exploring Advances in Interdisciplinary Data Mining and Analytics: New Trends ", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Hierarchical business process clustering", "author": ["J.-Y. Jung", "J. Bae", "L. Liu"], "venue": "in: Proceedings of the 2008 IEEE International Conference on Services Computing (SCC), Vol. 2, IEEE", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2008}, {"title": "Mining usage patterns from a repository of scientific workflows", "author": ["C. Diamantini", "D. Potena", "E. Storti"], "venue": "in: Proceedings of the 27th Annual ACM Symposium on Applied Computing (SAC), ACM", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2012}, {"title": "Pattern discovery from innovation processes", "author": ["C. Diamantini", "L. Genga", "D. Potena", "E. Storti"], "venue": "in: Proceedings of the 2013 International Conference on Collaboration Technologies and Systems (CTS), IEEE", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2013}, {"title": "Behavioral process mining for unstructured processes", "author": ["C. Diamantini", "L. Genga", "D. Potena"], "venue": "Journal of Intelligent Information Systems ", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2016}, {"title": "W", "author": ["B.F. Van Dongen"], "venue": "M. P. Van der Aalst, Multi-phase process mining: Building instance graphs, in: International Conference on Conceptual Modeling, Springer", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2004}, {"title": "W", "author": ["M. Song", "C.W. G\u00fcnther"], "venue": "M. P. Van der Aalst, Trace clustering in process mining, in: Business Process Management Workshops, Springer", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "Context aware trace clustering: Towards improving process mining results", "author": ["R.P. Jagadeesh Chandra Bose", "W.M.P. van der Aalst"], "venue": "in: Proceedings of the 2009 SIAM International Conference on Data Mining,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "Mining usage scenarios in business processes: Outlier-aware discovery and run-time prediction", "author": ["F. Folino", "G. Greco", "A. Guzzo", "L. Pontieri"], "venue": "Data & Knowledge Engineering 70 (12) ", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "W", "author": ["M. Pesic", "H. Schonenberg"], "venue": "M. P. Van der Aalst, Declare: Full support for loosely-structured processes, in: Enterprise Distributed Object Computing Conference, 2007. EDOC 2007. 11th IEEE International, IEEE", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2007}, {"title": "Mining the organisational perspective in agile business processes", "author": ["S. Sch\u00f6nig", "C. Cabanillas", "S. Jablonski", "J. Mendling"], "venue": "in: Enterprise, Business- Process and Information Systems Modeling, Springer", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2015}, {"title": "W", "author": ["F.M. Maggi", "A.J. Mooij"], "venue": "M. P. Van der Aalst, User-guided discovery of declarative process models, in: Computational Intelligence and Data Mining (CIDM), 2011 IEEE Symposium on, IEEE", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2011}, {"title": "The automated discovery of hybrid processes", "author": ["F.M. Maggi", "T. Slaats", "H.A. Reijers"], "venue": "in: Business Process Management, Springer", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2014}, {"title": "W", "author": ["C.W. G\u00fcnther"], "venue": "M. P. Van Der Aalst, Fuzzy mining\u2013adaptive process simplification based on multi-perspective metrics, in: Business Process Management, Springer", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2007}, {"title": "R", "author": ["R. Agrawal"], "venue": "Srikant, et al., Fast algorithms for mining association rules, in: Proceedings of the 20th International Conference on Very Large Data Bases (VLDB), Vol. 1215, Morgan Kaufmann", "citeRegEx": "36", "shortCiteRegEx": null, "year": 1994}, {"title": "Replaying history on process models for conformance checking and performance analysis, Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery", "author": ["W.M.P. van der Aalst", "A. Adriansyah", "B.F. van Dongen"], "venue": null, "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2012}, {"title": "KDD-cup 2000 organizers\u2019 report: Peeling the onion", "author": ["R. Kohavi", "C.E. Brodley", "B. Frasca", "L. Mason", "Z. Zheng"], "venue": "ACM SIGKDD Explorations Newsletter 2 (2) ", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 0, "context": "A different perspective on mining patterns in event sequences can be found in the data mining field, where the episode mining [2] and sequential pattern mining [3] subfields focus on finding frequent patterns that are local, not necessarily describing the whole event sequences from start to end.", "startOffset": 126, "endOffset": 129}, {"referenceID": 1, "context": "A different perspective on mining patterns in event sequences can be found in the data mining field, where the episode mining [2] and sequential pattern mining [3] subfields focus on finding frequent patterns that are local, not necessarily describing the whole event sequences from start to end.", "startOffset": 160, "endOffset": 163}, {"referenceID": 0, "context": "been used to analyze telecommunication networks [2], web navigational logs [2, 4], and retail sales transactions [5].", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "been used to analyze telecommunication networks [2], web navigational logs [2, 4], and retail sales transactions [5].", "startOffset": 75, "endOffset": 81}, {"referenceID": 2, "context": "been used to analyze telecommunication networks [2], web navigational logs [2, 4], and retail sales transactions [5].", "startOffset": 75, "endOffset": 81}, {"referenceID": 3, "context": "been used to analyze telecommunication networks [2], web navigational logs [2, 4], and retail sales transactions [5].", "startOffset": 113, "endOffset": 116}, {"referenceID": 9, "context": "(c) The Petri net discovered on L with the Inductive Miner algorithm [12].", "startOffset": 69, "endOffset": 73}, {"referenceID": 10, "context": "(d) The sequential patterns discovered on L with the PrefixSpan algorithm [13].", "startOffset": 74, "endOffset": 78}, {"referenceID": 4, "context": "Sequential pattern mining and episode mining are limited to the discovery of sequential orderings or partially ordered sets of events, while process discovery methods aim to discover a larger set of event relations, including sequential orderings, (exclusive) choice relations, concurrency, and loops, represented in process models such as Petri nets [6], BPMN [7], and process trees [8].", "startOffset": 351, "endOffset": 354}, {"referenceID": 5, "context": "Sequential pattern mining and episode mining are limited to the discovery of sequential orderings or partially ordered sets of events, while process discovery methods aim to discover a larger set of event relations, including sequential orderings, (exclusive) choice relations, concurrency, and loops, represented in process models such as Petri nets [6], BPMN [7], and process trees [8].", "startOffset": 384, "endOffset": 387}, {"referenceID": 6, "context": "Process models that can be discovered with process discovery methods distinguish themselves from more traditional sequence mining methods like Hidden Markov Models [9] and Recurrent Neural Networks [10, 11] in that process models can be visually represented and their visual representation can be used for communication between process stakeholders.", "startOffset": 164, "endOffset": 167}, {"referenceID": 7, "context": "Process models that can be discovered with process discovery methods distinguish themselves from more traditional sequence mining methods like Hidden Markov Models [9] and Recurrent Neural Networks [10, 11] in that process models can be visually represented and their visual representation can be used for communication between process stakeholders.", "startOffset": 198, "endOffset": 206}, {"referenceID": 8, "context": "Process models that can be discovered with process discovery methods distinguish themselves from more traditional sequence mining methods like Hidden Markov Models [9] and Recurrent Neural Networks [10, 11] in that process models can be visually represented and their visual representation can be used for communication between process stakeholders.", "startOffset": 198, "endOffset": 206}, {"referenceID": 9, "context": "Applying discovery algorithms, like the Inductive Miner [12], yields models allowing for any sequence of events (Figure 1c).", "startOffset": 56, "endOffset": 60}, {"referenceID": 11, "context": "When we apply any sequential pattern mining algorithm using a threshold of six occurrences, we obtain the seven length-three sequential patterns depicted in Figure 1d (results obtained using the SPMF [14] implementation of the PrefixSpan algorithm [13]).", "startOffset": 200, "endOffset": 204}, {"referenceID": 10, "context": "When we apply any sequential pattern mining algorithm using a threshold of six occurrences, we obtain the seven length-three sequential patterns depicted in Figure 1d (results obtained using the SPMF [14] implementation of the PrefixSpan algorithm [13]).", "startOffset": 248, "endOffset": 252}, {"referenceID": 12, "context": "We leverage process trees [15] to search for local process models, and describe a way to recursively explore candidate process trees up to a certain model size.", "startOffset": 26, "endOffset": 30}, {"referenceID": 13, "context": "In fact, results can also be visualized as BPMN [7], EPC [16], UML activity diagram [17], or UML statechart diagram [17].", "startOffset": 57, "endOffset": 61}, {"referenceID": 12, "context": "A different process representation is a process tree [15].", "startOffset": 53, "endOffset": 57}, {"referenceID": 14, "context": "ProM\u2019s Episode Miner [18] is a method that can be considered to be inbetween episode mining and process mining, as it discovers a collection of patterns from an event log where each pattern consists of partial order constructs.", "startOffset": 21, "endOffset": 25}, {"referenceID": 15, "context": "propose a method called Post Sequential Patterns Mining (PSPM) [19] that takes a input a set of sequential patterns and post-processes them into a single graph consisting of sequential and exclusive choice constructs, which they call a Sequential Pattern Graph (SGP) [20].", "startOffset": 63, "endOffset": 67}, {"referenceID": 16, "context": "propose a method called Post Sequential Patterns Mining (PSPM) [19] that takes a input a set of sequential patterns and post-processes them into a single graph consisting of sequential and exclusive choice constructs, which they call a Sequential Pattern Graph (SGP) [20].", "startOffset": 267, "endOffset": 271}, {"referenceID": 17, "context": "adds the capability to mine concurrency relations [21].", "startOffset": 50, "endOffset": 54}, {"referenceID": 18, "context": "[22] describe a method to mine frequent patterns from a collection of process models by transforming each business process to a vector format and then applying agglomerative clustering.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[23, 24] take a similar approach, but apply graph clustering techniques instead of a traditional clustering approach.", "startOffset": 0, "endOffset": 8}, {"referenceID": 20, "context": "[23, 24] take a similar approach, but apply graph clustering techniques instead of a traditional clustering approach.", "startOffset": 0, "endOffset": 8}, {"referenceID": 21, "context": "[25] describe a method to mine frequent patterns in process model notation through a two step approach.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "First each trace from the event log is transformed into a so called instance graph [26], which is graph representation of a trace that shows which steps in the trace are performed sequentially and which steps are performed in parallel (i.", "startOffset": 83, "endOffset": 87}, {"referenceID": 21, "context": "[25], while they can be discovered with LPM discovery.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "The techniques developed in the area of trace clustering [27, 28, 29, 30] are related to LPM discovery in the sense that both aim to enable extraction of process insight from event logs where the process is too unstructured for existing process discovery techniques to find a structured process model.", "startOffset": 57, "endOffset": 73}, {"referenceID": 24, "context": "The techniques developed in the area of trace clustering [27, 28, 29, 30] are related to LPM discovery in the sense that both aim to enable extraction of process insight from event logs where the process is too unstructured for existing process discovery techniques to find a structured process model.", "startOffset": 57, "endOffset": 73}, {"referenceID": 25, "context": "The techniques developed in the area of trace clustering [27, 28, 29, 30] are related to LPM discovery in the sense that both aim to enable extraction of process insight from event logs where the process is too unstructured for existing process discovery techniques to find a structured process model.", "startOffset": 57, "endOffset": 73}, {"referenceID": 26, "context": "Declarative process models, such as Declare [31], define the allowed behavior through constraints that must be respected while carrying out the process.", "startOffset": 44, "endOffset": 48}, {"referenceID": 27, "context": "Two examples of process discovery approaches that generate declarative process models are the DPIL Miner [32] and the Declare Miner [33].", "startOffset": 105, "endOffset": 109}, {"referenceID": 28, "context": "Two examples of process discovery approaches that generate declarative process models are the DPIL Miner [32] and the Declare Miner [33].", "startOffset": 132, "endOffset": 136}, {"referenceID": 29, "context": "Hybrid process discovery [34] aims at discovering a process model that consists partially of procedural process model constructs and partially of declarative process model constructs.", "startOffset": 25, "endOffset": 29}, {"referenceID": 30, "context": "The Fuzzy Miner [35] is a process discovery technique developed to deal with complex and flexible process models.", "startOffset": 16, "endOffset": 20}, {"referenceID": 31, "context": "Pruning based on monotonicity is similar to the pruning performed in the well-known Apriori algorithm [36], and other algorithms inspired by the Apriori algorithm, such as [3].", "startOffset": 102, "endOffset": 106}, {"referenceID": 1, "context": "Pruning based on monotonicity is similar to the pruning performed in the well-known Apriori algorithm [36], and other algorithms inspired by the Apriori algorithm, such as [3].", "startOffset": 172, "endOffset": 175}, {"referenceID": 32, "context": "Important for the definition of \u03bbLN is the notion of alignments [37], which aims to find a sequence of model firings starting at the initial marking and ending in a final marking that is an optimal approximation of the behavior in the event", "startOffset": 64, "endOffset": 68}, {"referenceID": 28, "context": "We start with the Declare miner [33], which mines a set of binary constraints from the data based on a set of constraint templates.", "startOffset": 32, "endOffset": 36}, {"referenceID": 28, "context": "Figure 9b shows the result of the Declare miner [33] on the BPI\u201912 resource 10939 event log with a support threshold of 90%, requiring that the constraints hold in 90% of the cases.", "startOffset": 48, "endOffset": 52}, {"referenceID": 28, "context": "Figure 9: (a) The result of the Declare miner [33] with a support threshold of 80% on the BPI\u201912 resource 10939 event log.", "startOffset": 46, "endOffset": 50}, {"referenceID": 30, "context": "Figure 10: Result of the Fuzzy miner [35] with default parameters on the BPI\u201912 resource 10939 event log.", "startOffset": 37, "endOffset": 41}, {"referenceID": 14, "context": "Figure 11: The first four episodes discovered by ProM\u2019s Episode Miner [18] on the BPI\u201912 resource 10939 event log.", "startOffset": 70, "endOffset": 74}, {"referenceID": 33, "context": "More detailed information on the Gazelle data set can be found in [39].", "startOffset": 66, "endOffset": 70}, {"referenceID": 10, "context": "We compare the local process models found on this data set with the sequential patterns obtained with the well-known sequential pattern mining algorithm PrefixSpan [13] as implemented in the SPMF [14] sequential pattern mining library.", "startOffset": 164, "endOffset": 168}, {"referenceID": 11, "context": "We compare the local process models found on this data set with the sequential patterns obtained with the well-known sequential pattern mining algorithm PrefixSpan [13] as implemented in the SPMF [14] sequential pattern mining library.", "startOffset": 196, "endOffset": 200}], "year": 2017, "abstractText": "In this paper we describe a method to discover frequent behavioral patterns in event logs. We express these patterns as local process models. Local process model mining can be positioned in-between process discovery and episode / sequential pattern mining. The technique presented in this paper is able to learn behavioral patterns involving sequential composition, concurrency, choice and loop, like in process mining. However, we do not look at start-to-end models, which distinguishes our approach from process discovery and creates a link to episode / sequential pattern mining. We propose an incremental procedure for building local process models capturing frequent patterns based on so-called process trees. We propose five quality dimensions and corresponding metrics for local process models, given an event log. We show monotonicity properties for some quality dimensions, enabling a speedup of local process model discovery through pruning. We demonstrate through a real life case study that mining local patterns allows us to get insights in processes where regular start-to-end process discovery techniques are only able to learn unstructured, flower-like, models.", "creator": "LaTeX with hyperref package"}}}