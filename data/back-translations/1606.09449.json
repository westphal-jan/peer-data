{"id": "1606.09449", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2016", "title": "Clique-Width and Directed Width Measures for Answer-Set Programming", "abstract": "Disjunctive Answer Set Programming (ASP) is a powerful paradigm of declarative programming, whose main decision-making problems are located at the second level of the polynomial hierarchy. Identifying fragments and developing efficient algorithms for such fragments are therefore important objectives to supplement the complex ASP systems available to date. Hard problems can become tractable if a problem parameter is limited by a fixed constant; such problems are then referred to as tractable fixed parameters (FPTs). Although there are several FPT results for ASP, parameters relating to directed or signed graphs representing the present program have been neglected so far. In this paper, we first present some negative observations showing that directed widths on the dependency curve of a program do not lead to FPT results. Subsequently, we consider the graph parameters of the signed clique width and present a novel dynamic programming algorithm best suited to FPT beyond the first known problems of our knowledge algorithm.", "histories": [["v1", "Thu, 30 Jun 2016 12:14:33 GMT  (40kb)", "https://arxiv.org/abs/1606.09449v1", "A short version of this paper has been accepted to ECAI 2016"], ["v2", "Fri, 30 Dec 2016 12:00:28 GMT  (40kb)", "http://arxiv.org/abs/1606.09449v2", "A short version of this paper has been accepted to ECAI 2016 and TAASP 2016"]], "COMMENTS": "A short version of this paper has been accepted to ECAI 2016", "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.DS", "authors": ["bernhard bliem", "sebastian ordyniak", "stefan woltran"], "accepted": false, "id": "1606.09449"}, "pdf": {"name": "1606.09449.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["(bliem@dbai.tuwien.ac.at)", "(sordyniak@gmail.com)", "(woltran@dbai.tuwien.ac.at)"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 6.\n09 44\n9v 2\n[ cs\n.A I]\n3 0\nD ec\n2 01"}, {"heading": "1 Introduction", "text": "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems. Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].\nSince the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems. An interesting approach to dealing with intractable problems comes from parameterized complexity theory [22] and is based on the fact that many hard problems become polynomial-time tractable if some problem parameter is bounded by a fixed constant. If the order of the polynomial bound on the runtime is independent of the parameter, one speaks of fixed-parameter tractability (FPT). Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors). Also related is the parameterized complexity analysis of reasoning under subset-minimal models, see, e.g., [41].\nAs many prominent representations of logic programs are given in terms of directed graphs (consider, e.g., the dependency graph), it is natural to investigate parameters for ASP that apply to directed graphs. Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50]. These are typically smaller than, e.g., the popular parameter of treewidth [7]. In particular, all these measures are zero on directed acyclic graphs (DAGs), but the treewidth of DAGs can be arbitrarily high. Moreover, since these measures are based on some notion of \u201ccloseness\u201d to acyclicity and the complexity of ASP is closely related to the \u201ccyclicity\u201d of the rules in a program, such measures seem promising for obtaining efficient algorithms for ASP. Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].\nAnother graph parameter for capturing the structural complexity of a graph is clique-width [15\u201317]. It applies to directed and undirected graphs, and in its general form (known as signed clique-width) to edge-labeled graphs. It is defined via graph construction where only a limited number of vertex labels is available; vertices that share\nthe same label at a certain point of the construction process must be treated uniformly in subsequent steps. Constructions can be given by expressions in a graph grammar (so-called cwd-expressions) and the minimal number of labels required for constructing a graph G is the clique-width of G. While clique-width is in a certain way orthogonal to other directed width measures, it is more general than treewidth; there are classes of graphs with constant clique-width but arbitrarily high treewidth (e.g., complete graphs). In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].\nBy means of a meta-theorem due to Courcelle, Makowsky, and Rotics [18], one can solve any graph problem that can be expressed in Monadic Second-Order Logic with quantification on vertex sets (MSO1) in linear time for graphs of bounded clique-width. This result is similar to Courcelle\u2019s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.r.t. treewidth [31]. There, the incidence graph of a program is used as an underlying graph structure (i.e., the graph containing a vertex for each atom a and rule r of the program, with an edge between a and r whenever a appears in r). Since the formula given in [31] is in MSO1, the FPT result for ASP applies also to signed clique-width.\nClique-width is NP-hard to compute [25], which might be considered as an obstacle toward practical applications. However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47]. (These algorithms involve an additive approximation error that is bounded in terms of k). Recently, SAT solvers have been used to obtain sequences of vertex partitions that correspond to cwd-expressions [34] for a given graph. For some applications, it might not even be necessary to compute clique-width and the underlying cwd-expression: As mentioned in [27, Section 1.4], applications from the area of verification are supposed to already come with such an expression. Moreover, it might even be possible to partially obtain cwd-expressions during the grounding process of ASP.\nThis all calls for dedicated algorithms for solving ASP for programs of bounded clique-width. In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width. In fact, we are not aware of any FPT algorithm for bounded clique-width for a reasoning problem located on the second level of the polynomial hierarchy (except [23] from the area of abstract argumentation).\nThe main contributions of this paper are as follows. First, we show some negative results for several directed width measures, indicating that the structure of the dependency graph and of various natural directed versions of the signed incidence graph does not adequately measure the complexity of evaluating the corresponding program.\nSecond, concerning signed clique-width, we give a novel dynamic programming algorithm that runs in polynomial time for programs where this parameter is bounded on their incidence graphs. We do so by suitably generalizing the seminal approach of [27] for the SAT problem. We also give a preliminary analysis how many signs are required in order to obtain FPT."}, {"heading": "2 Preliminaries", "text": "Graphs. We use standard graph terminology, see for instance the handbook [21]. All our graphs are simple. An undirected graph G is a tuple (V,E), where V or V (G) is the vertex set and E or E(G) is the edge set. For a subset V \u2032 \u2286 V (G), we denote by G[V \u2032], the induced subgraph of G induced by the vertices in V \u2032, i.e., G[V \u2032] has vertices V \u2032 and edges { {u, v} \u2208 E(G) | u, v \u2208 V \u2032 }. We also denote by G \\ V \u2032 the graph G[V (G) \\ V \u2032]. Similarly to undirected graphs, a digraph D is a tuple (V,A), where V or V (D) is the vertex set and A or A(D) is the arc set. A strongly connected component of a digraph D is a maximal subgraph Z of D that is strongly connected, i.e., Z contains a directed path between each pair of vertices in Z . We denote by UND(D) the symmetric closure of D, i.e., the graph with vertex set V (D) and arc set { (u, v), (v, u) | (u, v) \u2208 A(D) }. Finally, for a directed graph D, we denote by DI(G), the undirected graph with vertex set V (G) and edge set { {u, v} | (u, v) \u2208 A(D) }.\nParameterized Complexity. In parameterized algorithmics [22] the runtime of an algorithm is studied with respect to a parameter k \u2208 N and input size n. The most favorable class is FPT (fixed-parameter tractable) which contains all problems that can be decided by an algorithm running in time f(k) \u00b7 nO(1), where f is a computable function. We also call such an algorithm fixed-parameter tractable, or FPT for short. Formally, a\nparameterized problem is a subset of \u03a3\u2217 \u00d7N, where \u03a3 is the input alphabet. Let L1 \u2286 \u03a3\u22171 \u00d7N and L2 \u2286 \u03a3 \u2217 2 \u00d7N be two parameterized problems. A parameterized reduction (or FPT-reduction) from L1 to L2 is a mapping P : \u03a3\u22171 \u00d7 N \u2192 \u03a3 \u2217 2 \u00d7 N such that: (1) (x, k) \u2208 L1 iff P (x, k) \u2208 L2, (2) the mapping can be computed by an FPT-algorithm w.r.t. parameter k, and (3) there is a computable function g such that k\u2032 \u2264 g(k), where (x\u2032, k\u2032) = P (x, k). The class W[1] captures parameterized intractability and contains all problems that are FPTreducible to PARTITIONED CLIQUE when parameterized by the size of the solution. Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].\nAnswer Set Programming. A program \u03a0 consists of a set A(\u03a0) of propositional atoms and a set R(\u03a0) of rules of the form\na1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 al \u2190 al+1, . . . , am,\u00acam+1, . . . ,\u00acan,\nwhere n \u2265 m \u2265 l and ai \u2208 A(\u03a0) for 1 \u2264 i \u2264 n. Each rule r \u2208 R(\u03a0) consists of a head h(r) = {a1, . . . , al} and a body given by p(r) = {al+1, . . . , am} and n(r) = {am+1, . . . , an}. A set M \u2286 A(\u03a0) is a called a model of r if p(r) \u2286 M and n(r) \u2229M = \u2205 imply h(r) \u2229M 6= \u2205. We denote the set of models of r by Mods(r) and the models of \u03a0 are given by Mods(\u03a0) = \u22c2\nr\u2208R(\u03a0)Mods(r).\nThe reduct \u03a0I of a program \u03a0 with respect to a set of atoms I \u2286 A(\u03a0) is the program \u03a0I with A(\u03a0I) = A(\u03a0) and R(\u03a0I) = {r+ | r \u2208 R(\u03a0), n(r) \u2229 I = \u2205)}, where r+ denotes rule r without negative body, i.e., h(r+) = h(r), p(r+) = p(r), and n(r+) = \u2205. Following [29], M \u2286 A(\u03a0) is an answer set of \u03a0 if M \u2208 Mods(\u03a0) and for no N ( M , we have N \u2208 Mods(\u03a0M ). In what follows, we consider the problem of ASP consistency, i.e., the problem of deciding whether a given program has at least one answer set. As shown by Eiter and Gottlob, this problem is \u03a3P2 -complete [24].\nGraphical Representations of ASP. Let \u03a0 be a program. The dependency graph of \u03a0, denoted by DEP(\u03a0), is the directed graph with vertex set A(\u03a0) and that contains an arc (x, y) if there is a rule r \u2208 R(\u03a0) such that either x \u2208 h(r) and y \u2208 p(r) \u222a n(r) or x, y \u2208 h(r) [26]. Note that there are other notions of dependency graphs used in the literature, most of them, however, are given as subgraphs of DEP(\u03a0). As we will see later, our definition of dependency graphs allows us to draw immediate conclusions for such other notions.\nThe incidence graph of \u03a0, denoted by INC(\u03a0), is the undirected graph with vertices A(\u03a0) \u222a R(\u03a0) that contains an edge between a rule vertex r \u2208 R(\u03a0) and a atom vertex a \u2208 A(\u03a0) whenever a \u2208 h(r)\u222a p(r)\u222an(r). The signed incidence graph of \u03a0, denoted by SINC(\u03a0), is the graph INC(\u03a0), where addionally every edge of INC(\u03a0) between an atom a and a rule r is annotated with a label from {h, p, n} depending on whether a occurs in h(r), p(r), or n(r)."}, {"heading": "3 Directed Width Measures", "text": "Since many representations of ASP programs are in terms of directed graphs, it is natural to consider parameters for ASP that are tailor-made for directed graphs. Over the past two decades various width measures for directed graphs have been introduced, which are better suited for directed graphs than treewidth, on which they are based. The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]). Since these width measures are usually smaller on directed graphs than treewidth, it is worth considering them for problems that have already been shown to be fixed-parameter tractable parameterized by treewidth. In particular, all of these measures are zero on directed acyclic graphs (DAGs), but the treewidth of DAGs can be arbitrary high. Moreover, since these measures are based on some notion of \u201ccloseness\u201d to acyclicity and the complexity of ASP is closely related to the \u201ccyclicity\u201d of the logical rules, one would consider such measures as promising for obtaining efficient algorithms for ASP.\nIn this section, we give results for directed width measures when applied to dependency graphs as defined in Section 2. To state our results in the most general manner, we will employ the parameter cycle-rank [11]. Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.\nDefinition 1. Let D = (V,A) be a directed graph. The cycle-rank of D, denoted by cr(D), is inductively defined as follows: if D is acyclic, then cr(D) = 0. Moreover, if D is strongly connected, then cr(D) = 1 + minv\u2208V cr(D \\ {v}). Otherwise the cycle-rank of D is the maximum cycle-rank of any strongly connected component of D.\nWe will also consider a natural \u201cundirected version\u201d of the cycle-rank for directed graphs, i.e., we define the undirected cycle-rank of a directed graph D, denoted by cr\u2194(D), to be the cycle-rank of UND(D). It is also well known (see, e.g., [30]) that the cycle-rank of UND(D) is equal to the treedepth of DI(D), i.e., the underlying undirected graph of D, and that the treedepth is always an upper bound for the pathwidth and the treewidth of an undirected graph [8]. Putting these facts together implies that any hardness result obtained for the undirected cycle-rank implies hardness for pathwidth, treewidth, treedepth as well as the aforementioned directed width measures. See also Figure 1 for an illustration how hardness results for the considered width measures propagate.\nFinally, we would like to remark that both the cycle-rank and the undirected cycle-rank are easily seen to be closed under taking subgraphs, i.e., the (undirected) cycle-rank of a graph is always larger or equal to the (undirected) cycle-rank of every subgraph of the graph.\nHardness Results\nWe show that ASP consistency remains as hard as in the general setting even for instances that have a dependency graph of constant width in terms of any of the directed width measures introduced.\nFor our hardness results, we employ the reduction given in [24] showing that ASP consistency is \u03a3P2 -hard in general. The reduction is given from the validity problem for quantified Boolean formulas (QBF) of the form: \u03a6 := \u2203x1 \u00b7 \u00b7 \u00b7 \u2203xn\u2200y1 \u00b7 \u00b7 \u00b7 \u2200ym \u2228r\nj=1 Dj where each Dj is a conjunction of at most three literals over the variables x1, . . . , xn and y1, . . . , ym. We will denote the set of all QBF formulas of the above form in the following by QBFDNF2,\u2203 .\nGiven \u03a6 \u2208 QBFDNF2,\u2203 , a program \u03a0(\u03a6) is constructed as follows. The atoms of \u03a0(\u03a6) are x1, v1, . . . , xn, vn, y1, z1, . . . , ym, zm, and w and \u03a0(\u03a6) contains the following rules:\n\u2022 for every i with 1 \u2264 i \u2264 n, the rule xi \u2228 vi \u2190,\n\u2022 for every i with 1 \u2264 i \u2264 m, the rules yi \u2228 zi \u2190, yi \u2190 w, zi \u2190 w, and w \u2190 yi, zi,\n\u2022 for every j with 1 \u2264 j \u2264 r, the rule w \u2190 \u03c3(Lj,1), \u03c3(Lj,2), \u03c3(Lj,3), where Lj,l (for l \u2208 {1, 2, 3}) is the l-th literal that occurs in Dj (if |Dj | < 3, the respective parts are omitted) and the function \u03c3 is defined by setting \u03c3(L) to vi if L = \u00acxi, to zi if L = \u00acyi, and to L otherwise.\n\u2022 the rule \u2190 \u00acw (i.e., with an empty disjunction in the head).\nIt has been shown [24, Theorem 38] that a QBFDNF2,\u2203 formula \u03a6 is valid iff \u03a0(\u03a6) has an answer set. As checking validity of QBFDNF2,\u2203 formulas is \u03a3 P 2 -complete [53], this reduction shows that ASP is \u03a3 P 2 -hard.\nLemma 1. Let \u03a6 be a QBFDNF2,\u2203 , then cr \u2194(DEP(\u03a0(\u03a6))) \u2264 2.\nProof. Figure 2 illustrates the symmetric closure of DEP(\u03a0(\u03a6)) for a simple QBFDNF2,\u2203 formula\u03a6. As this example illustrates, the only arcs in UND(DEP(\u03a0(\u03a6))) not incident to w are the arcs incident to xi and vi and the arcs incident to yj and zj , for 1 \u2264 i \u2264 n and 1 \u2264 j \u2264 m. Hence, after removing w from UND(DEP(\u03a0(\u03a6))), every strongly connected component of the remaining graph contains at most two vertices and each of those has hence cycle-rank at most one. It follows that the cycle-rank of UND(DEP(\u03a0(\u03a6))) and hence the undirected cycle-rank of DEP(\u03a0(\u03a6)) is at most two.\nTogether with our considerations from above, we obtain:\nTheorem 1. ASP consistency is \u03a3P2 -complete even for instances whose dependency graph has width at most two for any of the following width measures: undirected cycle-rank, pathwidth, treewidth, treedepth, cycle-rank, directed treewidth, directed pathwidth, DAG-width, Kelly-width, and D-width.\nObserve that because the undirected cycle-rank is closed under taking subgraphs and we chose the \u201crichest\u201d variant of the dependency graph, the above result carries over to the other notions of dependency graphs of ASP programs considered in the literature.\nThe above result draws a very negative picture of the complexity of ASP w.r.t. restrictions on the dependency graph. In particular, not even structural restrictions of the dependency graph by the usually very successful parameter treewidth can be employed for ASP. This is in contrast to our second graphical representation of ASP, the incidence graph, for which it is known that ASP is fixed-parameter tractable parameterized by the treewidth [36]. It is hence natural to ask whether the same still holds under restrictions provided by one of the directed width measures under consideration. We first need to discuss how to obtain a directed version of the usually undirected incidence graph. For this, observe that the incidence graph, unlike the signed incidence graph, provides merely an incomplete model of the underlying ASP instance. Namely, it misses the information about how atoms occur in rules, i.e., whether they occur in the head, in the positive body, or in the negative body of a rule. A directed version of the incidence graph should therefore use the additional expressiveness provided by the direction of the arcs to incorporate the information given by the labels of the signed incidence graph. For instance, a natural directed version of the incidence graph could orient the edges depending on whether an atom occurs in the head or in the body of a rule. Clearly, there are many ways to orient the edges and it is not a priori clear which of those orientations leads to a directed version of the incidence graph that is best suited for an application of the directed width measures. Every orientation should, however, be consistent with the labels of the signed incidence graph, i.e., whenever two atoms are connected to a rule via edges having the same label, their arcs should be oriented in the same way. We call such an orientation of the incidence graph a homogeneous orientation.\nLemma 2. Let \u03a6 be a QBFDNF2,\u2203 , then the cycle-rank of any homogeneous orientation of the incidence graph of \u03a0(\u03a6) is at most one.\nProof. Let D be a homogeneous orientation of INC(\u03a0(\u03a6)) and let G = SINC(\u03a0(\u03a6). First observe that in G \\ {w} every rule vertex is either only incident to edges with label h or to edges of label p. Hence, as D is a homogeneous orientation, we obtain that every rule vertex of D \\ {w} is either a source vertex (i.e., having only outgoing arcs) or a sink vertex (i.e., having only incoming arcs). So D \\ {w} cannot contain a cycle through a rule vertex. However, since there are no arcs between atom vertices in D, we obtain that D \\ {w} is acyclic, which shows that the cycle-rank of D is at most one.\nWe can thus state the following result:\nTheorem 2. ASP consistency is \u03a3P2 -complete even for instances whose directed incidence graph has width at most one for any of the following width measures: cycle-rank, directed treewidth, directed pathwidth, DAG-width, Kelly-width, and D-width."}, {"heading": "4 Clique-Width", "text": "The results in [31] imply that bounding the clique-width of the signed incidence graph of a program leads to tractability.\nProposition 1. For a program\u03a0 such that the clique-width of its signed incidence graph is bounded by a constant, we can decide in linear time whether \u03a0 has an answer set.\nThis result has been established via a formulation of ASP consistency as an MSO1 formula. Formulating a problem in this logic automatically gives us an FPT algorithm. However, such algorithms are primarily of theoretical interest due to huge constant factors, and for actually solving problems, it is preferable to explicitly design dynamic programming algorithms [19].\nSince our main tractability result considers the clique-width of an edge-labeled graph, i.e., the signed incidence graph, we will introduce clique-width for edge-labeled graphs. This definition also applies to graphs without edge-labels by considering all edges to be labeled with the same label. A k-graph, for k > 0, is a graph whose vertices are labeled by integers from {1, . . . , k} =: [k]. Additionally, we also allow for the edges of a k-graph to be labeled by some arbitrary but finite set of labels (in our case the labels will correspond to the signs of the signed incidence graph). The labeling of the vertices of a graph G = (V,E) is formally denoted by a function L : V \u2192 [k]. We consider an arbitrary graph as a k-graph with all vertices labeled by 1. We call the k-graph consisting of exactly one vertex v (say, labeled by i \u2208 [k]) an initial k-graph and denote it by i(v).\nGraphs can be constructed from initial k-graphs by means of repeated application of the following three operations.\n\u2022 Disjoint union (denoted by \u2295);\n\u2022 Relabeling: changing all labels i to j (denoted by \u03c1i\u2192j);\n\u2022 Edge insertion: connecting all vertices labeled by i with all vertices labeled by j via an edge with label \u2113 (denoted by \u03b7\u2113i,j); i 6= j; already existing edges are not doubled.\nA construction of a k-graph G using the above operations can be represented by an algebraic term composed of i(v), \u2295, \u03c1i\u2192j , and \u03b7\u2113i,j , (i, j \u2208 [k], and v a vertex). Such a term is then called a cwd-expression defining G. For any cwd-expression \u03c3, we use L\u03c3 : V \u2192 [k] to denote the labeling of the graph defined by \u03c3. A k-expression is a cwd-expression in which at most k different labels occur. The set of all k-expressions is denoted by CWk.\nAs an example consider the complete bipartite graph Kn,n with bipartition A = {a1, . . . , an} and B = {b1, . . . , bn} and assume that all edges of Kn,n are labeled with the label \u2113. A cwd-expression of Kn,n using at most two labels is given by the following steps: (1) introduce all vertices in A using label 1, (2) introduce all vertices in B using label 2, (3) take the disjoint union of all these vertices, and (4) add all edges between vertices with label 1 and vertices with label 2, i.e., such a cwd-expression is given by \u03b7\u21131,2(1(a1)\u2295 \u00b7 \u00b7 \u00b7 \u2295 1(an)\u2295 2(b1)\u2295 \u00b7 \u00b7 \u00b7 \u2295 2(bn)). As a second example consider the complete graph Kn on n vertices, where all edges are labeled with label \u2113. A cwd-expression for Kn using at most two labels can be obtained by the following iterative process: Given a cwd-expression \u03c3n\u22121 for Kn\u22121, where every vertex is labeled with label 1, one takes the disjoint union\nof \u03c3n\u22121 and 2(v) (where v is the vertex only contained in Kn but not in Kn\u22121), adds all edges between vertices with label 1 and vertices with label 2, and then relabels label 2 to label 1. Formally, the cwd-expression \u03c3n for Kn is given by (\u03c12\u21921(\u03b7\u21131,2(\u03c3n\u22121 \u2295 2(v2))).\nDefinition 2. The clique-width of a graph G, cwd(G), is the smallest integer k such that G can be defined by a k-expression.\nOur discussion above thus witnesses that complete (bipartite) graphs have clique-width 2. Furthermore, cographs also have clique-width 2 (co-graphs are exactly given by the graphs which are P4-free, i.e., whenever there is a path (a, b, c, d) in the graph then {a, c}, {a, d} or {b, d} is also an edge of the graph) and trees have clique-width 3.\nWe have already introduced the notion of incidence graphs (resp. signed incidence graphs) of a program in Section 2. We thus can use cwd-expressions to represent programs.\nExample 1. Let \u03a0 be the program with A(\u03a0) = {x, y} and R(\u03a0) = {r, s}, where r is the rule x \u2190 \u00acy and s is the rule \u2190 x,\u00acy. Its signed incidence graph SINC(\u03a0) can be constructed by the 3-expression\n\u03b7n3,2\n(\n\u03c13\u21922 ( \u03b7p1,3(\u03b7 h 1,2(1(x)\u2295 2(r))\u2295 3(s)) )\n\u2295 3(y) ) , as depicted in Figure 3.\nSince every k-expression of the signed incidence graph can be transformed into a k-expression of the unsigned incidence graph (by replacing all operations of the form \u03b7\u2113i,j with \u03b7 \u03b1 i,j , where \u03b1 is new label), it holds that cwd(INC(\u03a0)) \u2264 cwd(SINC(\u03a0)).\nProposition 2. Let \u03a0 be a program. It holds that cwd(INC(\u03a0)) \u2264 cwd(SINC(\u03a0)), and there is a class C of programs such that, for each \u03a0 \u2208 C, cwd(INC(\u03a0)) = 2 but cwd(SINC(\u03a0)) is unbounded.\nFor showing the second statement of the above proposition, consider a program \u03a0n that has n2 atoms and n2 rules (for some n \u2208 N), such that every atom occurs in every rule of \u03a0n. Because the incidence graph is a complete bipartite graph it has clique-width two and moreover it contains a grid G of size n \u00d7 n as a subgraph. Assume that \u03a0n is defined in such a way that an atom a occurring in a rule r is in the head of r if the edge between a and r occurs in the grid G and otherwise a is in the (positive) body of r. Then, the clique-width of SINC(\u03a0n) is at least the clique-width of the n \u00d7 n grid G, which grows with n [39]. Hence, the class C containing \u03a0n for every n \u2208 N shows the second statement of the above proposition."}, {"heading": "4.1 Algorithms", "text": "In this section, we provide our dynamic programming algorithms for deciding existence of an answer set. We start with the classical semantics for programs, where it is sufficient to just slightly adapt (a simplified version of) the algorithm for SAT by [27]. For answer-set semantics, we then extend this algorithm in order to deal with the intrinsic higher complexity of this semantics.\nBoth algorithms follow the same basic principles by making use of a k-expression \u03c3 defining a program \u03a0 via its signed incidence graph in the following way: We assign certain objects to each subexpression of \u03c3 and manipulate these objects in a bottom-up traversal of the parse tree of the k-expression such that the objects in the root of the parse tree then provide the necessary information to decide the problem under consideration. The size of these objects is bounded in terms of k (and independent of the size of \u03a0) and the number of such objects required is linear in the size of \u03a0. Most importantly, we will show that these objects can also be efficiently computed for bounded k. Thus, we will obtain the desired linear running time."}, {"heading": "4.1.1 Classical Semantics", "text": "Definition 3. A tuple Q = (T, F, U) with T, F, U \u2286 [k] is called a k-triple, and we refer to its parts using QT = T , QF = F , and QU = U . The set of all k-triples is given by Qk.\nThe intuition of a triple (T, F, U) is to characterize a set of interpretations I in the following way:\n\u2022 For each i \u2208 T , at least one atom with label i is true in I;\n\u2022 for each i \u2208 F , at least one atom with label i is false in I;\n\u2022 for each i \u2208 U , there is at least one rule with label i that is \u201cnot satisfied yet\u201d.\nFormally, the \u201csemantics\u201d of a k-triple Q with respect to a given program \u03a0 is given as follows.\nDefinition 4. Let Q \u2208 Qk and \u03a0 be a program whose signed incidence graph (V,E) is labeled by L : V \u2192 [k]. A \u03a0-interpretation of Q is a set I \u2286 A(\u03a0) that satisfies\nQT = {L(a) | a \u2208 I},\nQF = {L(a) | a \u2208 A(\u03a0) \\ I}, and\nQU = {L(r) | r \u2208 R(\u03a0), I /\u2208 Mods(r)}.\nExample 2. Consider again program \u03a0 from Example 1 and the 3-expression \u03c3 from Figure 3. Let Q be the 3-triple ({1}, {3}, {2}). Observe that {x} is a \u03a0-interpretation of Q: It sets x to true and y to false, and L\u03c3(x) \u2208 QT and L\u03c3(y) \u2208 QF hold as required; the rule s is not satisfied by {x}, and indeed L\u03c3(s) \u2208 QU . We can easily verify that no other subset of A(\u03a0) is a \u03a0-interpretation of Q: Each \u03a0-interpretation of Q must set x to true and y to false, as these are the only atoms labeled with 1 and 3, respectively.\nWe use the following notation for k-triples Q, Q\u2032, and set S \u2286 [k].\n\u2022 Q\u2295Q\u2032 = (QT \u222aQ\u2032T , QF \u222aQ \u2032 F , QU \u222aQ \u2032 U )\n\u2022 Qi\u2192j = (Qi\u2192jT , Q i\u2192j F , Q i\u2192j U ) where for S \u2286 [k],\nSi\u2192j = S \\ {i} \u222a {j} if i \u2208 S and Si\u2192j = S otherwise.\n\u2022 QS,i,j = (QT , QF , QU \\ {j}) if i \u2208 S; QS,i,j = Q otherwise.\nUsing these abbreviations, we define our dynamic programming algorithm: We assign to each subexpression \u03c3 of a given k-expression a set of triples by recursively defining a function f , which associates to \u03c3 a set of k-triples as follows.\nDefinition 5. The function f : CWk \u2192 2Qk is recursively defined along the structure of k-expressions as follows.\n\u2022 f(i(v)) =\n{\n{( {i}, \u2205, \u2205 ) , ( \u2205, {i}, \u2205 )}\nif v is an atom node {(\n\u2205, \u2205, {i} )}\nif v is a rule node\n\u2022 f(\u03c31 \u2295 \u03c32) = {Q\u2295Q\u2032 | Q \u2208 f(\u03c31), Q\u2032 \u2208 f(\u03c32)}\n\u2022 f(\u03c1i\u2192j(\u03c3)) = {Qi\u2192j | Q \u2208 f(\u03c3)}\n\u2022 f(\u03b7hi,j(\u03c3)) = f(\u03b7 n i,j(\u03c3)) = {Q QT ,i,j | Q \u2208 f(\u03c3)}\n\u2022 f(\u03b7pi,j(\u03c3)) = {Q QF ,i,j | Q \u2208 f(\u03c3)}\nExample 3. Consider again program\u03a0 from Example 1 and the 3-expression depicted in Figure 3. To break down the structure of \u03c3, let \u03c31, . . . , \u03c36 be subexpressions of \u03c3 such that \u03c3 = \u03b7n3,2(\u03c31), \u03c31 = \u03c32\u22953(y), \u03c32 = \u03c13\u21922(\u03c33), \u03c33 = \u03b7 p 1,3(\u03c34), \u03c34 = \u03c35\u22953(s), \u03c35 = \u03b7 h 1,2(\u03c36) and \u03c36 = 1(x)\u22952(r). We get f(1(x)) = { ({1}, \u2205, \u2205), (\u2205, {1}, \u2205) } and f(2(r)) = { (\u2205, \u2205, {2}) } . These sets are then combined to f(\u03c36) = { ({1}, \u2205, {2}), (\u2205, {1}, {2}) }\n. The program defined by \u03c36 consists of atom x and rule r, but x does not occur in r yet. Accordingly, the k-triple ({1}, \u2205, {2}) models the situation where x is set to true, which does not satisfy r (since the head and body of r are still empty), hence the label of r is in the last component; the 3-triple (\u2205, {1}, {2}) represents x being set to false, which does not satisfy r either. Next, \u03c35 causes all atoms with label 1 (i.e., just x) to be inserted into the head of all rules with label 2 (i.e., just r), and we get f(\u03c35) = { ({1}, \u2205, \u2205), (\u2205, {1}, {2}) }\n. We obtain the first element ({1}, \u2205, \u2205) = QQT ,1,2 from Q = ({1}, \u2205, {2}) by removing the label 2 from QU because 1 \u2208 QT . The idea is that the heads of all rules labeled with 2 now contain all atoms labeled with 1, so these rules become satisfied by every interpretation that sets some atom labeled with 1 to true. Next, \u03c34 adds the rule s with label 3 and we get f(\u03c34) = { ({1}, \u2205, {3}), (\u2205, {1}, {2, 3}) }\n. The edge added by \u03c33 adds all atoms with label 1 (i.e., just x) into the positive body of all rules with label 3 (i.e., just s), which results in f(\u03c33) = { ({1}, \u2205, {3}), (\u2205, {1}, {2}) }\n. Observe that the last component of the second element no longer contains 3, i.e., setting x to false makes s true. Now the label 3 is renamed to 2, and we get f(\u03c32) = { ({1}, \u2205, {2}), (\u2205, {1}, {2}) }\n. Note that now r and s are no longer distinguishable since they now share the same label. Hence all operations that add edges to r will also add edges to s and vice versa. In \u03c31, atom y is added with label 3 and we get four 3-triples in f(\u03c31): From ({1}, \u2205, {2}) in f(\u03c32) we obtain ({1, 3}, \u2205, {2}) and ({1}, {3}, {2}), and from (\u2205, {1}, {2}) in f(\u03c32) we get ({3}, {1}, {2}) and (\u2205, {1, 3}, {2}). In \u03c3, we add a negative edge from all atoms labeled with 3 (i.e., just y) to all rules labeled with 2 (both r and s). From ({1, 3}, \u2205, {2}) in f(\u03c31) we now get ({1, 3}, \u2205, \u2205), from ({3}, {1}, {2}) we get ({3}, {1}, \u2205), and the 3-triples ({1}, {3}, {2}) and (\u2205, {1, 3}, {2}) from f(\u03c31) occur unmodified in f(\u03c3). As we will prove shortly, for each k-triple Q in f(\u03c3), there is a \u03a0-interpretation of Q. So if there is a k-triple Q in f(\u03c3) such that QU = \u2205, then \u03a0 has a classical model due to the definition of QU . For instance, ({1, 3}, \u2205, \u2205) has a \u03a0-interpretation {x, y}, which is obviously a model of \u03a0.\nWe now prove correctness of our algorithm:\nLemma 3. Let \u03a0 be a program and \u03b8 be a k-expression for SINC(\u03a0). For every set I \u2286 A(\u03a0), there is a k-triple Q \u2208 f(\u03b8) such that I is a \u03a0-interpretation of Q, and for every k-triple Q \u2208 f(\u03b8) there is a set I \u2286 A(\u03a0) such that I is a \u03a0-interpretation of Q.\nProof. We prove the first statement by induction on the structure of a k-expression \u03b8 defining \u03a0. Let \u03c3 be a subexpression of \u03b8, let \u03a0\u03c3 denote the program defined by \u03c3, and let I \u2286 A(\u03a0\u03c3).\nIf \u03c3 = i(r), for r \u2208 R(\u03a0), then A(\u03a0\u03c3) = \u2205, so I = \u2205. Moreover, R(\u03a0\u03c3) consists of an unsatisfiable rule (its head and body are empty). Hence I is a \u03a0\u03c3-interpretation of (\u2205, \u2205, {i}) in f(\u03c3).\nIf \u03c3 = i(a), for a \u2208 A(\u03a0), then A(\u03a0\u03c3) = {a} and R(\u03a0\u03c3) = \u2205. If I = \u2205, then I is a \u03a0\u03c3-interpretation of the k-triple (\u2205, {i}, \u2205) in f(\u03c3). Otherwise I = {a} and I is a \u03a0\u03c3-interpretation of the k-triple ({i}, \u2205, \u2205) in f(\u03c3).\nIf \u03c3 = \u03c31\u2295\u03c32, let i \u2208 {1, 2}, \u03a0i = \u03a0\u03c3i and Ii = I \u2229A(\u03a0i). By definition of \u03a0i, it holds that A(\u03a0) = A(\u03a01)\u222a A(\u03a02), R(\u03a0) = R(\u03a01) \u222aR(\u03a02) and I = I1 \u222a I2. By induction hypothesis, Ii is a \u03a0i-interpretation of some ktriple Qi in f(\u03c3i). By definition of f , there is a k-triple Q in f(\u03c3) with QT = Q1T \u222aQ2T , QF = Q1F \u222aQ2F and QU = Q1U \u222a Q2U . This allows us to easily verify that I is a \u03a0\u03c3-interpretation of Q by checking the conditions in Definition 4.\nIf \u03c3 = \u03c1i\u2192j(\u03c3\u2032), then \u03a0\u03c3 = \u03a0\u03c3\u2032 and, by induction hypothesis, I is a \u03a0\u03c3\u2032 -interpretation of some k-triple Q in f(\u03c3\u2032). By definition of f , the k-triple Qi\u2192j in f(\u03c3) is the result of replacing i by j in each of QT , QF and QU . Hence we can easily verify that I satisfies all conditions for being a \u03a0\u03c3-interpretation of Qi\u2192j .\nIf \u03c3 = \u03b7\u2113i,j(\u03c3 \u2032), for \u2113 \u2208 {h, n}, then A(\u03a0\u03c3) = A(\u03a0\u03c3\u2032 ). Hence, by induction hypothesis, I is a \u03a0\u03c3\u2032 -interpretation of some k-triple Q\u2032 in f(\u03c3\u2032). We use Q to denote the k-triple Q\u2032Q \u2032\nT ,i,j , which is in f(\u03c3). Since QT = Q\u2032T ,\nQF = Q \u2032 F and L\u03c3 = L\u03c3\u2032 , I satisfies the first two conditions for being a \u03a0\u03c3-interpretation of Q. It remains to check the third condition. For every j\u2032 \u2208 [k] \\ {j} it holds that j\u2032 \u2208 QU if and only if j\u2032 \u2208 Q\u2032U . By induction hypothesis, the latter is the case if and only if there is a rule r\u2032 \u2208 R(\u03a0\u03c3\u2032 ) such that L\u03c3\u2032 (r\u2032) = j\u2032 and I /\u2208 Mods(r\u2032). This is equivalent\nto the existence of a rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j\u2032, h(r) = h(r\u2032), p(r) = p(r\u2032), n(r) = n(r\u2032) and I /\u2208 Mods(r), since SINC(\u03a0\u03c3) only differs from SINC(\u03a0\u03c3\u2032) by additional edges that are not incident to r due to j\u2032 6= j.\nIt remains to check that j \u2208 QU if and only if there is a rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j and I /\u2208 Mods(r). First suppose toward a contradiction that j \u2208 QU while I is a model of every rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j. Since QU \u2286 Q\u2032U , also j \u2208 Q \u2032 U and by induction hypothesis there is a rule r\n\u2032 \u2208 R(\u03a0\u03c3\u2032 ) such that L\u03c3\u2032(r\u2032) = j and I is not a model of r\u2032. There is a corresponding rule r \u2208 R(\u03a0\u03c3), for which L\u03c3(r) = j, h(r\u2032) \u2286 h(r), n(r\u2032) \u2286 n(r) and p(r\u2032) = p(r) hold. Since I is a model of r but not of r\u2032, I contains some atom labeled with i (by both L\u03c3\u2032 and L\u03c3) because all atoms in h(r) \\ h(r\u2032) and n(r) \\ n(r\u2032) are labeled with i. By induction hypothesis, this implies i \u2208 Q\u2032T , which leads to the contradiction j /\u2208 QU by construction of f .\nFinally, suppose toward a contradiction that j /\u2208 QU and there is a rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j and I /\u2208 Mods(r). The rule r\u2032 corresponding to r in \u03a0\u03c3\u2032 with L\u03c3\u2032 (r\u2032) = j is not satisfied by I either, since h(r\u2032) \u2286 h(r), n(r\u2032) \u2286 n(r) and p(r\u2032) = p(r). By induction hypothesis, this entails j \u2208 Q\u2032U . Due to j /\u2208 QU , it holds that i \u2208 Q\u2032T , so there is an a \u2208 I with L\u03c3\u2032 (a) = L\u03c3(a) = i. Due to the new edge from a to r, either a \u2208 h(r) or a \u2208 n(r). This yields the contradiction that I is a model of r.\nThe case \u03c3 = \u03b7pi,j(\u03c3 \u2032) is symmetric.\nThe proof of the second statement is similar.\nWe can now state our FPT result for classical models:\nTheorem 3. Let k be an integer and \u03a0 be a program. Given a k-expression for the signed incidence graph of \u03a0, we can decide in linear time whether \u03a0 has a model.\nProof. Let k be a constant, \u03a0 be a program and \u03c3 be a k-expression of SINC(\u03a0). We show that there is a model of \u03a0 if and only if there is a k-triple Q in f(\u03c3) with QU = \u2205: If \u03a0 has a model I , then I is a \u03a0-interpretation of a k-triple Q in f(\u03c3), by Lemma 3, and QU = \u2205 by Definition 4. Conversely, if there is a k-triple Q in f(\u03c3) with QU = \u2205, then there is a \u03a0-interpretation I of Q, by Lemma 3, and QU = \u2205 implies that I is a model of \u03a0 by Definition 4. Finally, it is easy to see that f(\u03c3) can be computed in linear time."}, {"heading": "4.1.2 Answer-Set Semantics", "text": "For full disjunctive ASP we need a more involved data structure.\nDefinition 6. A pair (Q,\u0393) with with Q \u2208 Qk and \u0393 \u2286 Qk is called a k-pair. The set of all k-pairs is given by Pk.\nGiven a k-pair (Q,\u0393), the purpose of Q is, as for classical semantics, to represent \u03a0-interpretations I (that in the end correspond to models). Every k-triple in \u0393 represents sets J of atoms such that J \u2282 I . If, in the end, there is such a set J that still satisfies every rule in the reduct w.r.t. I , then we conclude that I is not an answer set.\nDefinition 7. Let Q \u2208 Qk, let \u03a0 be a program whose signed incidence graph (V,E) is labeled by L : V \u2192 [k], and let I \u2286 A(\u03a0). A \u03a0I -interpretation of Q is a set J \u2286 A(\u03a0) such that\nQT = {L(a) | a \u2208 J},\nQF = {L(a) | a \u2208 A(\u03a0) \\ J}, and\nQU = {L(r) | r \u2208 R(\u03a0), n(r) \u2229 I = \u2205, J /\u2208 Mods(r +)}.\nWe can now define our dynamic programming algorithm for ASP:\nDefinition 8. The function g : CWk \u2192 2Pk is recursively defined along the structure of k-expressions as follows.\n\u2022 g(i(v)) = { ( ({i}, \u2205, \u2205), { (\u2205, {i}, \u2205) }) , ( (\u2205, {i}, \u2205), \u2205 ) } if v is at atom node\n\u2022 g(i(v)) = { ( (\u2205, \u2205, {i}), \u2205 ) } if v is a rule node\n\u2022 g(\u03c31 \u2295 \u03c32) = { ( Q1 \u2295 Q2, RQ1,Q2,\u03931,\u03932 | (Qi,\u0393i) \u2208 g(\u03c3i) ) }, where RQ1,Q2,\u03931,\u03932 = { S1 \u2295 S2 | Si \u2208\n\u0393i } \u222a { Q1 \u2295 S | S \u2208 \u03932 } \u222a { S \u2295Q2 | S \u2208 \u03931 })\n\u2022 g(\u03c1i\u2192j(\u03c3)) = { ( (Qi\u2192j , {Ri\u2192j | R \u2208 \u0393} ) | (Q,\u0393) \u2208 g(\u03c3)}\n\u2022 g(\u03b7hi,j(\u03c3)) = { ( QQT ,i,j , {RRT ,i,j | R \u2208 \u0393} ) | (Q,\u0393) \u2208 g(\u03c3)}\n\u2022 g(\u03b7pi,j(\u03c3)) = { ( QQF ,i,j , {RRF ,i,j | R \u2208 \u0393} ) | (Q,\u0393) \u2208 g(\u03c3)}\n\u2022 g(\u03b7ni,j(\u03c3)) = { ( QQT ,i,j , {RQT ,i,j | R \u2208 \u0393} ) | (Q,\u0393) \u2208 g(\u03c3)}\nNote the use of QT in RQT ,i,j in the definition of g(\u03b7ni,j(\u03c3)): Whenever an interpretation I represented by Q sets an atom from the negative body of a rule r to true, the rule r has no counterpart in the reduct w.r.t. I , so, for each subset J of I , we remove r from the set of rules whose counterpart in the reduct is not yet satisfied by J .\nExample 4. Let \u03a0 be the program consisting of a single rule \u2190 \u00acx, which we denote by r, and let \u03c3 = \u03b7n1,2(1(x) \u2295 2(r)). Let (Q,\u0393) be the k-pair in g(1(x)) with Q = ({1}, \u2205, \u2205) and \u0393 = {(\u2205, {1}, \u2205)}. The k-triple Q represents the set of atoms {x}. Since this set has the proper subset \u2205, there is a k-triple in \u0393 that indeed corresponds to this subset. Now let (Q,\u0393) = ((\u2205, {1}, \u2205), \u2205) be the other k-pair in g(1(x)). Here Q represents the empty set of atoms, which has no proper subsets, hence \u0393 is empty. For the single k-pair ((\u2205, \u2205, {2}), \u2205) in g(2(r)), the situation is similar. Next, at g(1(x) \u2295 2(r)), we combine every k-pair (Q1,\u03931) from g(1(x)) with every k-pair (Q2,\u03932) from g(2(r)) to a new k-pair. For instance, consider Q1 = ({1}, \u2205, \u2205) and \u03931 = {S}, where S = (\u2205, {1}, \u2205), as well as Q2 = (\u2205, \u2205, {2}) and \u03932 = \u2205. By definition of g, we obtain a new k-pair (Q,\u0393), where Q = Q1 \u2295Q2 = ({1}, \u2205, {2}), and \u0393 contains the single element Q2 \u2295 S = (\u2205, {1}, {2}). Recall that the purpose of Q is to represent sets of atoms I , and each element of \u0393 shall represent proper subsets of I; in this case, Q represents {x}, and the element Q2 \u2295 S in \u0393 represents the proper subset \u2205. Next, at g(\u03c3) we introduce a negative edge from x to r. From the k-pair (Q, {S}) in g(1(x)\u2295 2(r)), where Q = ({1}, \u2205, {2}) and S = (\u2205, {1}, {2}), we obtain the k-pair (Q\u2032, {S\u2032}) in g(\u03c3), where Q\u2032 = QQT ,i,j = ({1}, \u2205, \u2205) (i.e., the label 2 from QU has disappeared) and S\u2032 = SQT ,i,j = (\u2205, {1}, \u2205). Here 2 has disappeared from SU because the reduct w.r.t. all sets of atoms represented by Q\u2032 no longer contains any rule labeled with 2. Note that the classical model {x} represented by Q\u2032 is no answer set even though Q\u2032U = \u2205. The reason is that S\n\u2032 witnesses (by S\u2032U = \u2205) that \u2205 \u2208 Mods(\u03a0{x}).\nWe now prove correctness of the algorithm from Definition 8.\nLemma 4. Let \u03a0 be a program and \u03b8 be a k-expression for SINC(\u03a0). For every set I \u2286 A(\u03a0) there is a k-pair (Q,\u0393) \u2208 g(\u03b8) such that (i) I is a \u03a0-interpretation of Q and (ii) for every set J \u2282 I there is a k-triple R \u2208 \u0393 such that J is a \u03a0I -interpretation of R. Moreover, for every k-pair (Q,\u0393) \u2208 g(\u03b8) there is a set I \u2286 A(\u03a0) such that (i\u2019) I is a \u03a0-interpretation of Q and (ii\u2019) for each k-triple R \u2208 \u0393, there is a set J \u2282 I such that J is a \u03a0I -interpretation of R.\nProof. Observe that for each (Q,\u0393) in g(\u03b8) it holds that Q \u2208 f(\u03b8), and for each Q in f(\u03b8) there is some (Q,\u0393) in g(\u03b8). Hence we can apply the same arguments as in the proof of Lemma 3 for (i) and (i\u2019). In addition, similar arguments can be used within each of the distinguished cases for (ii) and (ii\u2019). We use induction on the structure of a k-expression \u03b8 defining \u03a0. Let \u03c3 be a subexpression of \u03b8, let \u03a0\u03c3 denote the program defined by \u03c3, and let I \u2286 A(\u03a0\u03c3).\nIf \u03c3 = i(r), for r \u2208 R(\u03a0), then A(\u03a0\u03c3) = \u2205, so I = \u2205. As in the proof of Lemma 3, we can show that I is a \u03a0\u03c3-interpretation of the k-triple Q = (\u2205, \u2205, {i}). Since I has no proper subsets, condition (ii) holds trivially for the k-pair (Q, \u2205) in g(\u03c3).\nIf \u03c3 = i(a), for a \u2208 A(\u03a0), then A(\u03a0\u03c3) = {a} and R(\u03a0\u03c3) = \u2205. If I = \u2205, then I is a \u03a0\u03c3-interpretation of the k-triple Q = (\u2205, {i}, \u2205) and (ii) holds trivially for the k-pair (Q, \u2205) in g(\u03c3). Otherwise I = {a} holds. Let (Q,\u0393) be the k-pair in g(\u03c3) for which Q = ({i}, \u2205, \u2205) and \u0393 = {(\u2205, {i}, \u2205)} hold. Clearly I is a \u03a0\u03c3-interpretation of Q. The only proper subset of I is \u2205, which is a \u03a0I\u03c3-interpretation of the only element of \u0393.\nIf \u03c3 = \u03c31 \u2295 \u03c32, let \u03a0i = \u03a0\u03c3i and Ii = I \u2229 A(\u03a0i), for any i \u2208 {1, 2}. By definition of \u03a0i, it holds that A(\u03a0) = A(\u03a01) \u222a A(\u03a02), R(\u03a0) = R(\u03a01) \u222a R(\u03a02) and I = I1 \u222a I2. Let J \u2282 I and, for i \u2208 {1, 2}, let\nJi = J \u2229 A(\u03a0i). Observe that J1 \u2286 I1 and J2 \u2286 I2, and at least one inclusion is proper. We distinguish three cases:\n\u2022 If J1 \u2282 I1 and J2 \u2282 I2, then, by induction hypothesis, for any i \u2208 {1, 2} there is a k-pair (Qi,\u0393i) in g(\u03c3i) such that Ii is a \u03a0i-interpretation of Qi and there is a k-triple Ri \u2208 \u0393i such that Ji is a \u03a0 Ii i -interpretation of Ri.\nBy definition of g, there is a k-pair (Q,\u0393) in g(\u03c3) such that Q = Q1 \u2295 Q2 and there is a k-triple R in \u0393 such that R = R1 \u2295 R2. We can easily check that I is a \u03a0\u03c3-interpretation of Q and that J is a \u03a0I\u03c3-interpretation of R.\n\u2022 If J1 \u2282 I1 and J2 = I2, then, by induction hypothesis, there is a k-pair (Q1,\u03931) in g(\u03c31) such that I1 is a \u03a01-interpretation of Q1 and there is a k-triple R1 \u2208 \u03931 such that J1 is a \u03a0 I1 1 -interpretation of R1. Also, there is\na k-pair (Q2,\u03932) in g(\u03c32) such that I2 is a \u03a02-interpretation of Q2. By definition of g, there is a k-pair (Q,\u0393) in g(\u03c3) such that Q = Q1 \u2295Q2 and there is a k-triple R in \u0393 such that R = R1 \u2295Q2. We can easily check that I is a \u03a0\u03c3-interpretation of Q and that J is a \u03a0I\u03c3-interpretation of R.\n\u2022 The case J1 = I1, J2 \u2282 I2 is symmetric.\nWe omit the cases \u03c3 = \u03c1i\u2192j(\u03c3\u2032), \u03c3 = \u03b7hi,j(\u03c3 \u2032) and \u03c3 = \u03b7pi,j(\u03c3 \u2032), as they are do not offer much additional insight, given the proof of Lemma 3 and the following case.\nIf \u03c3 = \u03b7ni,j(\u03c3 \u2032), then there is again a k-pair (Q\u2032,\u0393\u2032) in g(\u03c3\u2032) such that (i) I is a \u03a0\u03c3\u2032 -interpretation of Q\u2032 and (ii) for each J \u2282 I there is a k-triple R in \u0393\u2032 such that J is a \u03a0I\u03c3\u2032 -interpretation of R. Let (Q,\u0393) be the k-pair in g(\u03c3) for which Q = Q\u2032Q \u2032 T ,i,j and \u0393 = {RQ \u2032 T ,i,j | R \u2208 \u0393\u2032} hold. As before, I is a \u03a0\u03c3-interpretation of Q. Let J \u2282 I , let R\u2032 be the k-triple in \u0393\u2032 such that J is a \u03a0I\u03c3\u2032 -interpretation of R \u2032, and let R = R\u2032Q \u2032 T ,i,j . As before, J satisfies the first two conditions for being a \u03a0I\u03c3-interpretation of R. It remains to check the third condition. For all labels except j, we proceed as before. We now check that j \u2208 RU if and only if there is a rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j, n(r) \u2229 I = \u2205 and J /\u2208 Mods(r+). First suppose toward a contradiction that j \u2208 RU while J \u2208 Mods(r+) for each r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j and n(r) \u2229 I = \u2205. Since RU \u2286 R\u2032U , also j \u2208 R\u2032U and by induction hypothesis there is a rule r\n\u2032 \u2208 R(\u03a0\u03c3\u2032 ) such that L\u03c3\u2032 (r\u2032) = j, n(r\u2032) \u2229 I = \u2205 and J is not a model of r\u2032+. There is a corresponding rule r \u2208 R(\u03a0\u03c3), for which L\u03c3(r) = j, h(r\u2032) = h(r), p(r\u2032) = p(r) and n(r\u2032) \u2286 n(r) hold. Since J is a model of r+ but not of r\u2032+ (and these rules are identical), there is an a \u2208 n(r) \u2229 I with L\u03c3(a) = i. From a \u2208 I it follows by induction hypothesis that i \u2208 Q\u2032T , but this leads to the contradiction j /\u2208 RU .\nFinally, suppose toward a contradiction that j /\u2208 RU and there is a rule r \u2208 R(\u03a0\u03c3) such that L\u03c3(r) = j, n(r) \u2229 I = \u2205 and J /\u2208 Mods(r+). Let r\u2032 be the rule corresponding to r in \u03a0\u03c3\u2032 . For this rule it holds that L\u03c3\u2032(r\u2032) = j and n(r\u2032) \u2286 n(r), so n(r\u2032)\u2229 I = \u2205. The set J does not satisfy r\u2032+ either, since h(r\u2032+) = h(r+) and p(r\u2032+) = p(r+). By induction hypothesis, this entails j \u2208 R\u2032U . Due to j /\u2208 RU , it holds that i \u2208 Q \u2032 T , so there is an atom a \u2208 I such that L\u03c3\u2032 = L\u03c3(a) = i. Due to the new edge from a to r, a \u2208 n(r) holds, which contradicts n(r) \u2229 I = \u2205.\nThe other direction is similar.\nHence we get an FPT result for answer-set semantics:\nTheorem 4. Let k be a constant and \u03a0 be a program. Given a k-expression for the signed incidence graph of \u03a0, we can decide in linear time whether \u03a0 has an answer set.\nProof. Let k be a constant, \u03a0 be a program and \u03c3 be a k-expression of SINC(\u03a0). Using the same ideas as for Theorem 3, we can easily show that there is an answer set of \u03a0 if and only if there is a k-pair (Q,\u0393) in g(\u03c3) such that QU = \u2205 and RU 6= \u2205 for every R \u2208 \u0393. Again, it is easy to see that g(\u03c3) can be computed in linear time."}, {"heading": "4.2 The Role of Signs for Results on Clique-Width", "text": "We have shown that ASP parameterized by the clique-width of the signed incidence graph is FPT. Because the clique-width of the (unsigned) incidence graph is usually smaller than (and always at most as high as) the clique-width of the signed incidence graph (Proposition 2), an FPT result w.r.t. the clique-width of the (unsigned)\nincidence graph would be a significantly stronger result. It is therefore natural to ask whether ASP is already FPT w.r.t the clique-width of the unsigned incidence graph. A similar situation is known for the satisfiability problem of propositional formulas (SAT), which was first shown in [27] to be FPT parameterized by the clique-width of the signed incidence graph, and the authors conjectured that the same should hold already for the unsigned version. Surprisingly, this turned out not to be the case [46]. In comparison to SAT, the situation for ASP is similar but slightly more involved. Whereas there are only two potential signs for SAT (signaling whether a variable occurs positively or negatively in a clause), ASP has three signs (h, p, n). So how many signs are necessary to obtain tractability for ASP? To settle this question, let SINCL(\u03a0), for L \u2286 {h, p, n}, be the (\u201csemi-signed\u201d) incidence graph obtained from SINC(\u03a0) by joining all labels in L, i.e., every label in L is renamed to a new label, which we denote by \u03b1. We will show below that joining any set L of labels other than {h, n} leads to intractability for ASP parameterized by the clique-width of SINCL(\u03a0). Together with our tractability result w.r.t. the clique-width of SINC(\u03a0) (Theorem 4), this provides an almost complete picture of the complexity of ASP parameterized by clique-width. We leave it as an open question whether ASP parameterized by the clique-width of SINC{h,n}(\u03a0) is FPT.\nTheorem 5. Let L \u2286 {h, p, n} with |L| > 1 and L 6= {h, n}, then ASP is W[1]-hard parameterized by the clique-width of SINCL(\u03a0).\nProof. We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].\nInstance: A k-partite graph G = (V,E) with partition V1, . . . , Vk where |Vi| = |Vj | for every i, j with 1 \u2264 i, j \u2264 k.\nParameter: The integer k.\nQuestion: Does G have a clique of size k?\nRecall that a k-partite graph is a graph whose vertex set can be partitioned into k sets such that there are no edges between vertices contained in the same set. To prove the theorem it is sufficient to show that the result holds for L being any combination of two labels other than {h, n}. In other words, it suffices to show the result for L = {h, p} and L = {p, n}. Because the reduction for the case that L = {h, p} is very similar to the reduction from PARTITIONED CLIQUE to SAT given in [46, Corollary 1], we omit its proof here and only give the proof for the case that L = {p, n}. Let L = {p, n} and G, k, V1, . . . , Vk be as in the definition of PARTITIONED CLIQUE and assume that the vertices of G are labeled such that vji is the i-th vertex contained in Vj . We will construct a program \u03a0 in polynomial-time such that G has a clique of size k if and only if \u03a0 has an answer set, and the clique-width of SINCL(\u03a0) is at most k\u2032 = 2k + k2.\nThe program \u03a0 contains one atom vji for every vertex v j i of G, and the following rules:\n(R1) For every j with 1 \u2264 j \u2264 k, the rule: vj1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 v j n \u2190. (R2) The rule:\n\u2190 vj1i1 , v j2 i2 ,\u00acvj11 , . . . ,\u00acv j1 i1\u22121 ,\u00acvj1i1+1, . . . ,\u00acv j1 n ,\n\u00acvj21 , . . . ,\u00acv j2 i2\u22121 ,\u00acvj2i2+1, . . . ,\u00acv j2 n\nfor every {vj1i1 , v j2 i2 } /\u2208 E(G) with 1 \u2264 j1, j2 \u2264 k and 1 \u2264 i1, i2 \u2264 n.\nWe first show that G has a clique of size k if and only if \u03a0 has an answer set. Toward showing the forward direction, let C be a clique of size k of G. We claim that C is also an answer set of \u03a0 and first show that C is indeed a model of \u03a0. Because C contains exactly one vertex from every Vi, all rules of type (R1) are satisfied by C. Moreover, the same holds for all rules of type (R2), because there is no pair u, v \u2208 C with {u, v} /\u2208 E(G) and hence the body of every such rule is always falsified. This shows that C is a model of \u03a0. Finally, because all the rules of type (R1) are also contained in the reduct \u03a0C of \u03a0, we obtain that C is an answer set of \u03a0.\nToward showing the reverse direction, let C be an answer set of \u03a0. We claim that C is also a clique of G of size k and first show that C contains exactly one variable from every Vi. Because of the rules of type (R1) (which will also remain in the reduct \u03a0C ), it holds that C contains at least one variable corresponding to a vertex of Vi for every i with 1 \u2264 i \u2264 k. Assume for a contradiction that C contains more than one variable from some Vi. Then for every j with j 6= i, C has to contain at least three variables from Vi \u222a Vj . Consequently, every rule of type (R2) corresponding to a non-edge of G incident to a vertex in Vi does not appear in the reduct \u03a0C of \u03a0,\nwhich shows that C is not an answer set (minimal model) of \u03a0C . This shows that C contains exactly one variable from every Vi. Now, suppose for a contradiction that C is not a clique of G of size k. Then there are u and w in C with u \u2208 Vi and w \u2208 Vj such that {u,w} /\u2208 E(G). Hence, there is a rule of type (R2) (corresponding to the non-edge {u, v}), which is violated by C, a contradiction to our assumption that C is model of \u03a0.\nIt remains to show that the clique-width of SINCL(\u03a0) is at most k\u2032 = 2k + k2. We show this by providing a k\u2032-expression for SINCL(\u03a0). We start by giving the terms that introduce the vertices of SINCL(\u03a0): (1) We introduce every atom vertex vji of SINCL(\u03a0) with the term j(v j i ). (2) For every rule vertex r of the form (R1) corresponding to a rule vj1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 v j n \u2190, we introduce the term l(r) where l = k + j. (3) For every rule vertex r of the form (R2) corresponding to a non-edge between Vi and Vj with 1 \u2264 i < j \u2264 k, we introduce the term l(r), where l = 2k + k(i \u2212 1) + j. We then combine all these terms using the disjoint union operator \u2295. Now it only remains to show how the edges between the rule and the atom vertices of SINCL(\u03a0) are added: First, for every j with 1 \u2264 j \u2264 k, we add the edges between the rule vertices of the form (R1) and the atom vertices contained in those rules using the operator \u03b7\u2113j,k+j , where \u2113 = h. Second, for every i and j with 1 \u2264 i < j \u2264 k, we add the edges between the rule vertices of the form (R2) and the atom vertices contained in those rules using the operators \u03b7\u03b1i,2k+k(i\u22121)+j and \u03b7 \u03b1 j,2k+k(i\u22121)+j ."}, {"heading": "5 Conclusion", "text": "In this paper, we have contributed to the parameterized complexity analysis of ASP. We first gave some negative observations showing that most directed width measures (applied to the dependency graph or incidence graph of a program) do not lead to FPT results. On the other hand, we turned a theoretical tractability result (which implicitly follows from previous work [31]) for the parameter clique-width (applied to the signed incidence graph of a program) into a novel dynamic programming algorithm. The algorithm is applicable to arbitrary programs, whenever a defining k-expression is given. The algorithm is expected to run efficiently in particular for small k, i.e., programs for which the signed incidence graph has low clique-width.\nFuture work includes solving the remaining question whether ASP parameterized by the clique-width of SINC{h,n}(\u03a0) is FPT or not. Another open question is whether ASP parameterized by the clique-width of the unsigned incidence graph is in the class XP (as is the case for SAT [51]).\nAcknowledgments. This work was supported by the Austrian Science Fund (FWF) projects P25518 and Y698."}], "references": [{"title": "A trichotomy for regular simple path queries on graphs", "author": ["G. Bagan", "A. Bonifati", "B. Groz"], "venue": "Proc. PODS, pages 261\u2013272. ACM,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2013}, {"title": "Answer set based design of knowledge systems", "author": ["M. Balduccini", "M. Gelfond", "M. Nogueira"], "venue": "Ann. Math. Artif. Intell., 47(1-2):183\u2013219,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2006}, {"title": "Directed path-width and monotonicity in digraph searching", "author": ["J. Bar\u00e1t"], "venue": "Graphs and Combinatorics, 22(2): 161\u2013172,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2006}, {"title": "A hierarchy of tractable subsets for computing stable models", "author": ["R. Ben-Eliyahu"], "venue": "J. Artif. Intell. Res. (JAIR), 5:27\u201352,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1996}, {"title": "Propositional semantics for disjunctive logic programs", "author": ["R. Ben-Eliyahu", "R. Dechter"], "venue": "Ann. Math. Artif. Intell., 12(1-2):53\u201387,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1994}, {"title": "The dag-width of directed graphs", "author": ["D. Berwanger", "A. Dawar", "P. Hunter", "S. Kreutzer", "J. Obdrz\u00e1lek"], "venue": "Journal of Combinatorial Theory, Series B, 102(4):900\u2013923,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "A tourist guide through treewidth", "author": ["H.L. Bodlaender"], "venue": "Acta Cybernetica, 11:1\u201321,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1993}, {"title": "Approximating treewidth, pathwidth, frontsize, and shortest elimination tree", "author": ["H.L. Bodlaender", "J.R. Gilbert", "H. Hafsteinsson", "T. Kloks"], "venue": "J. Algorithms, 18(2):238\u2013255,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1995}, {"title": "Decomposition theorems and model-checking for the modal \u03bc-calculus", "author": ["M. Boja\u0144czyk", "C. Dittmann", "S. Kreutzer"], "venue": "Proc. CLS/LICS, pages 17:1\u201317:10. ACM,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2014}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Comm. ACM, 54(12): 92\u2013103,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2011}, {"title": "Transition graphs and the star height problem", "author": ["R.S. Cohen"], "venue": "Proc. of the 9th Annual Symposium on Switching and Automata Theory, pages 383\u2013394. IEEE Computer Society,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1968}, {"title": "On the relationship between clique-width and treewidth", "author": ["D.G. Corneil", "U. Rotics"], "venue": "SIAM J. Comput., 34(4):825\u2013847,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}, {"title": "Recognizability and second-order definability for sets of finite graphs", "author": ["B. Courcelle"], "venue": "Technical Report I-8634, Universit\u00e9 de Bordeaux,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1987}, {"title": "Graph rewriting: an algebraic and logic approach", "author": ["B. Courcelle"], "venue": "Handbook of theoretical computer science, Vol. B, pages 193\u2013242. Elsevier Science Publishers, North-Holland, Amsterdam,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1990}, {"title": "Upper bounds to the clique-width of graphs", "author": ["B. Courcelle", "S. Olariu"], "venue": "Discr. Appl. Math., 101(1-3): 77\u2013114,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2000}, {"title": "Context-free handle-rewriting hypergraph grammars", "author": ["B. Courcelle", "J. Engelfriet", "G. Rozenberg"], "venue": "Proc. Graph-Grammars, volume 532 of LNCS, pages 253\u2013268,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1991}, {"title": "Handle-rewriting hypergraph grammars", "author": ["B. Courcelle", "J. Engelfriet", "G. Rozenberg"], "venue": "JCSS, 46(2):218\u2013 270,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1993}, {"title": "Linear time solvable optimization problems on graphs of bounded clique-width", "author": ["B. Courcelle", "J.A. Makowsky", "U. Rotics"], "venue": "Theory Comput. Syst., 33(2):125\u2013150,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2000}, {"title": "Parameterized Algorithms", "author": ["M. Cygan", "F.V. Fomin", "L. Kowalik", "D. Lokshtanov", "D. Marx", "M. Pilipczuk", "M. Pilipczuk", "S. Saurabh"], "venue": "Springer,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Quantitative Graph Theory, chapter Width-Measures for Directed Graphs and Algorithmic Applications", "author": ["M. Dehmer", "F. Emmert-Streib", "editors"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2014}, {"title": "Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics", "author": ["R. Diestel"], "venue": "Springer,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2012}, {"title": "Fundamentals of Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Texts in Computer Science. Springer,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Reasoning in argumentation frameworks of bounded cliquewidth", "author": ["W. Dvor\u00e1k", "S. Szeider", "S. Woltran"], "venue": "Proc. COMMA, volume 216 of Frontiers in Artificial Intelligence and Applications, pages 219\u2013230. IOS Press,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2010}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Ann. Math. Artif. Intell., 15(3\u20134):289\u2013323,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1995}, {"title": "Clique-width is NP-complete", "author": ["M.R. Fellows", "F.A. Rosamond", "U. Rotics", "S. Szeider"], "venue": "SIAM J. Discrete Math., 23(2):909\u2013939,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2009}, {"title": "Backdoors to tractable answer set programming", "author": ["J. Fichte", "S. Szeider"], "venue": "Artif. Intell., 220:64\u2013103,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "Counting truth assignments of formulas of bounded tree-width or clique-width", "author": ["E. Fischer", "J.A. Makowsky", "E.R. Ravve"], "venue": "Discr. Appl. Math., 156(4):511\u2013529,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "Answer Set Solving in Practice", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub"], "venue": "Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2012}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Comput., 9(3/4):365\u2013386,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1991}, {"title": "LIFO-search: A min-max theorem and a searching game for cycle-rank and tree-depth", "author": ["A.C. Giannopoulou", "P. Hunter", "D.M. Thilikos"], "venue": "Discrete Applied Mathematics, 160(15):2089\u20132097,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}, {"title": "Bounded treewidth as a key to tractability of knowledge representation and reasoning", "author": ["G. Gottlob", "R. Pichler", "F. Wei"], "venue": "Artif. Intell., 174(1):105\u2013132,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2010}, {"title": "Digraph complexity measures and applications in formal language theory", "author": ["H. Gruber"], "venue": "Discrete Mathematics & Theoretical Computer Science, 14(2):189\u2013204,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2012}, {"title": "Exhaustively characterizing feasible logic models of a signaling network using answer set programming", "author": ["C. Guziolowski", "S. Videla", "F. Eduati", "S. Thiele", "T. Cokelaer", "A. Siegel", "J. Saez-Rodriguez"], "venue": "Bioinformatics, 29(18):2320\u20132326, 2013. doi: 10.1093/bioinformatics/btt393. Erratum see Bioinformatics 30, 13,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 1942}, {"title": "A SAT approach to clique-width", "author": ["M. Heule", "S. Szeider"], "venue": "ACM Trans. Comput. Log., 16(3):24,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2015}, {"title": "Digraph measures: Kelly decompositions, games, and orderings", "author": ["P. Hunter", "S. Kreutzer"], "venue": "TCS, 399(3): 206\u2013219,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2008}, {"title": "Answer-set programming with bounded treewidth", "author": ["M. Jakl", "R. Pichler", "S. Woltran"], "venue": "Proc. IJCAI, pages 816\u2013822,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2009}, {"title": "Directed tree-width", "author": ["T. Johnson", "N. Robertson", "P.D. Seymour", "R. Thomas"], "venue": "Journal of Combinatorial Theory, Series B, 82(1):138\u2013154,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2001}, {"title": "Directed width measures and monotonicity of directed graph searching", "author": ["L. Kaiser", "S. Kreutzer", "R. Rabinovich", "S. Siebertz"], "venue": "CoRR, abs/1408.4745,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2014}, {"title": "Recent developments on graphs of bounded clique-width", "author": ["M. Kaminski", "V.V. Lozin", "M. Milanic"], "venue": "Discrete Applied Mathematics, 157(12):2747\u20132761,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2009}, {"title": "The rank-width of directed graphs", "author": ["M.M. Kant\u00e9"], "venue": "CoRR, abs/0709.1433,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2007}, {"title": "Fixed-parameter algorithms for finding minimal models", "author": ["M. Lackner", "A. Pfandler"], "venue": "Proc. KR, pages 85\u201395. AAAI Press,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2012}, {"title": "On odd and even cycles in normal logic programs", "author": ["F. Lin", "X. Zhao"], "venue": "Proc. AAAI, pages 80\u201385. AAAI Press / The MIT Press,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2004}, {"title": "Fixed-parameter complexity of semantics for logic programs", "author": ["Z. Lonc", "M. Truszczy\u0144ski"], "venue": "ACM Trans. Comput. Log., 4(1):91\u2013119,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2003}, {"title": "Stable Models and an Alternative Logic Programming Paradigm", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "The Logic Programming Paradigm \u2013 A 25-Year Perspective, pages 375\u2013398. Springer Verlag,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 1999}, {"title": "A dynamic-programming based ASP-solver", "author": ["M. Morak", "R. Pichler", "S. R\u00fcmmele", "S. Woltran"], "venue": "Proc. JELIA\u201910, pages 369\u2013372,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2010}, {"title": "Satisfiability of acyclic and almost acyclic CNF formulas", "author": ["S. Ordyniak", "D. Paulusma", "S. Szeider"], "venue": "TCS, 481:85\u201399,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2013}, {"title": "Approximating clique-width and branch-width", "author": ["S. Oum", "P. Seymour"], "venue": "J. Combin. Theory Ser. B, 96(4): 514\u2013528,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2006}, {"title": "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems", "author": ["K. Pietrzak"], "venue": "JCSS, 67(4):757\u2013771,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2003}, {"title": "Team-building with answer set programming in the Gioia-Tauro seaport", "author": ["F. Ricca", "G. Grasso", "M. Alviano", "M. Manna", "V. Lio", "S. Iiritano", "N. Leone"], "venue": "TPLP, 12:361\u2013381, 4", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2012}, {"title": "D-width: A more natural measure for directed tree width", "author": ["M.A. Safari"], "venue": "Proc. MFCS, volume 3618 of LNCS, pages 745\u2013756. Springer,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2005}, {"title": "Model counting for formulas of bounded clique-width", "author": ["F. Slivovsky", "S. Szeider"], "venue": "Proc. ISAAC, volume 8283 of LNCS, pages 677\u2013687. Springer,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2013}, {"title": "Developing a declarative rule language for applications in product configuration", "author": ["T. Soininen", "I. Niemel\u00e4"], "venue": "Proc. PADL, volume 1551 of LNCS, pages 305\u2013319. Springer Verlag,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 1998}, {"title": "Word problems requiring exponential time", "author": ["L.J. Stockmeyer", "A.R. Meyer"], "venue": "Proc. Theory of Computing, pages 1\u20139. ACM,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 1973}, {"title": "Trichotomy and dichotomy results on the complexity of reasoning with disjunctive logic programs", "author": ["M. Truszczy\u0144ski"], "venue": "TPLP, 11(6):881\u2013904,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 9, "context": "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.", "startOffset": 41, "endOffset": 53}, {"referenceID": 28, "context": "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.", "startOffset": 41, "endOffset": 53}, {"referenceID": 43, "context": "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.", "startOffset": 41, "endOffset": 53}, {"referenceID": 27, "context": "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].", "startOffset": 52, "endOffset": 56}, {"referenceID": 51, "context": "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].", "startOffset": 141, "endOffset": 145}, {"referenceID": 1, "context": "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].", "startOffset": 201, "endOffset": 204}, {"referenceID": 48, "context": "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].", "startOffset": 222, "endOffset": 226}, {"referenceID": 32, "context": "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].", "startOffset": 248, "endOffset": 252}, {"referenceID": 23, "context": "Since the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems.", "startOffset": 114, "endOffset": 122}, {"referenceID": 53, "context": "Since the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems.", "startOffset": 114, "endOffset": 122}, {"referenceID": 21, "context": "An interesting approach to dealing with intractable problems comes from parameterized complexity theory [22] and is based on the fact that many hard problems become polynomial-time tractable if some problem parameter is bounded by a fixed constant.", "startOffset": 104, "endOffset": 108}, {"referenceID": 42, "context": "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).", "startOffset": 53, "endOffset": 57}, {"referenceID": 41, "context": "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).", "startOffset": 92, "endOffset": 96}, {"referenceID": 4, "context": "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).", "startOffset": 117, "endOffset": 120}, {"referenceID": 3, "context": "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).", "startOffset": 149, "endOffset": 152}, {"referenceID": 25, "context": "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).", "startOffset": 185, "endOffset": 189}, {"referenceID": 40, "context": ", [41].", "startOffset": 2, "endOffset": 6}, {"referenceID": 2, "context": "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].", "startOffset": 91, "endOffset": 109}, {"referenceID": 5, "context": "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].", "startOffset": 91, "endOffset": 109}, {"referenceID": 34, "context": "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].", "startOffset": 91, "endOffset": 109}, {"referenceID": 36, "context": "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].", "startOffset": 91, "endOffset": 109}, {"referenceID": 49, "context": "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].", "startOffset": 91, "endOffset": 109}, {"referenceID": 6, "context": ", the popular parameter of treewidth [7].", "startOffset": 37, "endOffset": 40}, {"referenceID": 36, "context": "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].", "startOffset": 86, "endOffset": 90}, {"referenceID": 0, "context": "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].", "startOffset": 128, "endOffset": 131}, {"referenceID": 8, "context": "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].", "startOffset": 152, "endOffset": 155}, {"referenceID": 14, "context": "Another graph parameter for capturing the structural complexity of a graph is clique-width [15\u201317].", "startOffset": 91, "endOffset": 98}, {"referenceID": 15, "context": "Another graph parameter for capturing the structural complexity of a graph is clique-width [15\u201317].", "startOffset": 91, "endOffset": 98}, {"referenceID": 16, "context": "Another graph parameter for capturing the structural complexity of a graph is clique-width [15\u201317].", "startOffset": 91, "endOffset": 98}, {"referenceID": 11, "context": "In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].", "startOffset": 74, "endOffset": 82}, {"referenceID": 14, "context": "In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].", "startOffset": 74, "endOffset": 82}, {"referenceID": 17, "context": "By means of a meta-theorem due to Courcelle, Makowsky, and Rotics [18], one can solve any graph problem that can be expressed in Monadic Second-Order Logic with quantification on vertex sets (MSO1) in linear time for graphs of bounded clique-width.", "startOffset": 66, "endOffset": 70}, {"referenceID": 12, "context": "This result is similar to Courcelle\u2019s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.", "startOffset": 46, "endOffset": 54}, {"referenceID": 13, "context": "This result is similar to Courcelle\u2019s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.", "startOffset": 46, "endOffset": 54}, {"referenceID": 30, "context": "treewidth [31].", "startOffset": 10, "endOffset": 14}, {"referenceID": 30, "context": "Since the formula given in [31] is in MSO1, the FPT result for ASP applies also to signed clique-width.", "startOffset": 27, "endOffset": 31}, {"referenceID": 24, "context": "Clique-width is NP-hard to compute [25], which might be considered as an obstacle toward practical applications.", "startOffset": 35, "endOffset": 39}, {"referenceID": 39, "context": "However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47].", "startOffset": 95, "endOffset": 103}, {"referenceID": 46, "context": "However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47].", "startOffset": 95, "endOffset": 103}, {"referenceID": 33, "context": "Recently, SAT solvers have been used to obtain sequences of vertex partitions that correspond to cwd-expressions [34] for a given graph.", "startOffset": 113, "endOffset": 117}, {"referenceID": 30, "context": "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.", "startOffset": 51, "endOffset": 55}, {"referenceID": 35, "context": "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.", "startOffset": 84, "endOffset": 88}, {"referenceID": 44, "context": "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.", "startOffset": 106, "endOffset": 110}, {"referenceID": 22, "context": "In fact, we are not aware of any FPT algorithm for bounded clique-width for a reasoning problem located on the second level of the polynomial hierarchy (except [23] from the area of abstract argumentation).", "startOffset": 160, "endOffset": 164}, {"referenceID": 26, "context": "We do so by suitably generalizing the seminal approach of [27] for the SAT problem.", "startOffset": 58, "endOffset": 62}, {"referenceID": 20, "context": "We use standard graph terminology, see for instance the handbook [21].", "startOffset": 65, "endOffset": 69}, {"referenceID": 21, "context": "In parameterized algorithmics [22] the runtime of an algorithm is studied with respect to a parameter k \u2208 N and input size n.", "startOffset": 30, "endOffset": 34}, {"referenceID": 0, "context": "The class W[1] captures parameterized intractability and contains all problems that are FPTreducible to PARTITIONED CLIQUE when parameterized by the size of the solution.", "startOffset": 11, "endOffset": 14}, {"referenceID": 0, "context": "Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].", "startOffset": 9, "endOffset": 12}, {"referenceID": 0, "context": "Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].", "startOffset": 115, "endOffset": 118}, {"referenceID": 28, "context": "Following [29], M \u2286 A(\u03a0) is an answer set of \u03a0 if M \u2208 Mods(\u03a0) and for no N ( M , we have N \u2208 Mods(\u03a0 ).", "startOffset": 10, "endOffset": 14}, {"referenceID": 23, "context": "As shown by Eiter and Gottlob, this problem is \u03a32 -complete [24].", "startOffset": 60, "endOffset": 64}, {"referenceID": 25, "context": "The dependency graph of \u03a0, denoted by DEP(\u03a0), is the directed graph with vertex set A(\u03a0) and that contains an arc (x, y) if there is a rule r \u2208 R(\u03a0) such that either x \u2208 h(r) and y \u2208 p(r) \u222a n(r) or x, y \u2208 h(r) [26].", "startOffset": 210, "endOffset": 214}, {"referenceID": 36, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 51, "endOffset": 55}, {"referenceID": 2, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 91, "endOffset": 94}, {"referenceID": 34, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 107, "endOffset": 111}, {"referenceID": 49, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 125, "endOffset": 129}, {"referenceID": 19, "context": "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).", "startOffset": 140, "endOffset": 144}, {"referenceID": 10, "context": "To state our results in the most general manner, we will employ the parameter cycle-rank [11].", "startOffset": 89, "endOffset": 93}, {"referenceID": 31, "context": "Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.", "startOffset": 102, "endOffset": 110}, {"referenceID": 37, "context": "Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.", "startOffset": 102, "endOffset": 110}, {"referenceID": 29, "context": ", [30]) that the cycle-rank of UND(D) is equal to the treedepth of DI(D), i.", "startOffset": 2, "endOffset": 6}, {"referenceID": 7, "context": ", the underlying undirected graph of D, and that the treedepth is always an upper bound for the pathwidth and the treewidth of an undirected graph [8].", "startOffset": 147, "endOffset": 150}, {"referenceID": 23, "context": "For our hardness results, we employ the reduction given in [24] showing that ASP consistency is \u03a32 -hard in general.", "startOffset": 59, "endOffset": 63}, {"referenceID": 52, "context": "As checking validity of QBF 2,\u2203 formulas is \u03a3 P 2 -complete [53], this reduction shows that ASP is \u03a3 P 2 -hard.", "startOffset": 60, "endOffset": 64}, {"referenceID": 35, "context": "This is in contrast to our second graphical representation of ASP, the incidence graph, for which it is known that ASP is fixed-parameter tractable parameterized by the treewidth [36].", "startOffset": 179, "endOffset": 183}, {"referenceID": 30, "context": "The results in [31] imply that bounding the clique-width of the signed incidence graph of a program leads to tractability.", "startOffset": 15, "endOffset": 19}, {"referenceID": 18, "context": "However, such algorithms are primarily of theoretical interest due to huge constant factors, and for actually solving problems, it is preferable to explicitly design dynamic programming algorithms [19].", "startOffset": 197, "endOffset": 201}, {"referenceID": 38, "context": "Then, the clique-width of SINC(\u03a0n) is at least the clique-width of the n \u00d7 n grid G, which grows with n [39].", "startOffset": 104, "endOffset": 108}, {"referenceID": 26, "context": "We start with the classical semantics for programs, where it is sufficient to just slightly adapt (a simplified version of) the algorithm for SAT by [27].", "startOffset": 149, "endOffset": 153}, {"referenceID": 26, "context": "A similar situation is known for the satisfiability problem of propositional formulas (SAT), which was first shown in [27] to be FPT parameterized by the clique-width of the signed incidence graph, and the authors conjectured that the same should hold already for the unsigned version.", "startOffset": 118, "endOffset": 122}, {"referenceID": 45, "context": "Surprisingly, this turned out not to be the case [46].", "startOffset": 49, "endOffset": 53}, {"referenceID": 0, "context": "Let L \u2286 {h, p, n} with |L| > 1 and L 6= {h, n}, then ASP is W[1]-hard parameterized by the clique-width of SINCL(\u03a0).", "startOffset": 61, "endOffset": 64}, {"referenceID": 0, "context": "We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].", "startOffset": 59, "endOffset": 62}, {"referenceID": 47, "context": "We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].", "startOffset": 99, "endOffset": 103}, {"referenceID": 30, "context": "On the other hand, we turned a theoretical tractability result (which implicitly follows from previous work [31]) for the parameter clique-width (applied to the signed incidence graph of a program) into a novel dynamic programming algorithm.", "startOffset": 108, "endOffset": 112}, {"referenceID": 50, "context": "Another open question is whether ASP parameterized by the clique-width of the unsigned incidence graph is in the class XP (as is the case for SAT [51]).", "startOffset": 146, "endOffset": 150}], "year": 2017, "abstractText": "Disjunctive Answer Set Programming (ASP) is a powerful declarative programming paradigm whose main decision problems are located on the second level of the polynomial hierarchy. Identifying tractable fragments and developing efficient algorithms for such fragments are thus important objectives in order to complement the sophisticated ASP systems available to date. Hard problems can become tractable if some problem parameter is bounded by a fixed constant; such problems are then called fixed-parameter tractable (FPT). While several FPT results for ASP exist, parameters that relate to directed or signed graphs representing the program at hand have been neglected so far. In this paper, we first give some negative observations showing that directed width measures on the dependency graph of a program do not lead to FPT results. We then consider the graph parameter of signed clique-width and present a novel dynamic programming algorithm that is FPT w.r.t. this parameter. Clique-width is more general than the well-known treewidth, and, to the best of our knowledge, ours is the first FPT algorithm for bounded clique-width for reasoning problems beyond SAT.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}