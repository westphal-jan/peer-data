{"id": "1609.06694", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Sep-2016", "title": "PixelNet: Towards a General Pixel-level Architecture", "abstract": "We study architectures for general prediction problems at the pixel level, from low-level edge detection to normal mid-level surface estimation to high-level semantic segmentation. Convolutionary predictions such as the Fully Convolutionary Network (FCN) have achieved remarkable success by exploiting the spatial redundancy of adjacent pixels through revolutionary processing. Although computationally efficient, we note that such approaches to learning are not statistically efficient, because spatial redundancy limits the information obtained from adjacent pixels. Finally, we show that (1) layered sampling allows us to add diversity during batch updates, and (2) sampled multi-scale features allow us to explore non-linear predictions (multiple fully connected layers followed by ReLU) that improve overall accuracy. Finally, our goal is to show how an architecture can achieve a performance better than that produced by AST (or the architecture of interest to AST) for specific architectures.", "histories": [["v1", "Wed, 21 Sep 2016 19:32:46 GMT  (2485kb,D)", "http://arxiv.org/abs/1609.06694v1", null]], "reviews": [], "SUBJECTS": "cs.CV cs.LG", "authors": ["aayush bansal", "xinlei chen", "bryan russell", "abhinav gupta", "deva ramanan"], "accepted": false, "id": "1609.06694"}, "pdf": {"name": "1609.06694.pdf", "metadata": {"source": "CRF", "title": "PixelNet: Towards a General Pixel-Level Architecture", "authors": ["Aayush Bansal", "Xinlei Chen", "Bryan Russell", "Abhinav Gupta", "Deva Ramanan"], "emails": [], "sections": [{"heading": null, "text": "We explore architectures for general pixel-level prediction problems, from low-level edge detection to mid-level surface normal estimation [4] to high-level semantic segmentation. Convolutional predictors, such as the fullyconvolutional network (FCN), have achieved remarkable success by exploiting the spatial redundancy of neighboring pixels through convolutional processing. Though computationally efficient, we point out that such approaches are not statistically efficient during learning precisely because spatial redundancy limits the information learned from neighboring pixels. We demonstrate that (1) stratified sampling allows us to add diversity during batch updates and (2) sampled multi-scale features allow us to explore more nonlinear predictors (multiple fully-connected layers followed by ReLU) that improve overall accuracy. Finally, our objective is to show how a architecture can get performance better than (or comparable to) the architectures designed for a particular task. Interestingly, our single architecture produces state-of-the-art results for semantic segmentation on PASCAL-Context, surface normal estimation [4] on NYUDv2 dataset, and edge detection on BSDS without contextual post-processing.\n* indicates equal contribution; first two authors listed in alphabetical order."}, {"heading": "1. Introduction", "text": "Simplicity is the ultimate sophistication.\nLeonardo da Vinci\nA surprising number of computer vision problems can be formulated as a dense pixel-wise prediction problem. These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].\nThough such a formulation is attractive because of its generality, one obvious difficulty is the enormous associated output space. For example, a 100\u00d7 100 image with 10 discrete class labels per pixel yields an output label space of size 105. One strategy is to treat this as a spatially-invariant label prediction problem, where one predicts a separate label per pixel using a convolutional architecture. Neural networks with convolutional output predictions, also called Fully Convolutional Networks (FCNs) [13, 48, 51, 57], appear to be a promising architecture in this direction.\nBut is this the ideal formulation of dense pixel-labeling? While computationally efficient for generating predictions at test time, we argue that it is not statistically efficient for gradient-based learning. Stochastic gradient descent\n1\nar X\niv :1\n60 9.\n06 69\n4v 1\n[ cs\n(SGD) assumes that training data are sampled independently and from an identical distribution (i.i.d.) [9]. Indeed, a commonly-used heuristic to ensure approximately i.i.d. samples is random permutation of the training data, which can significantly improve learnability [43]. It is well known that pixels in a given image are highly correlated and not independent [35]. Following this observation, one might be tempted to randomly permute pixels during learning, but this destroys the spatial regularity that convolutional architectures so cleverly exploit! In this paper, we explore the tradeoff between statistical and computational efficiency for convolutional learning, and investigate simply sampling a modest number of pixels across a small number of images for each SGD batch update, exploiting convolutional processing where possible. Contributions: We experimentally validate that, thanks to spatial correlations between pixels, just sampling a small number of pixels per image is sufficient for learning. More importantly, sampling allows us to explore several avenues for improving both the efficiency and performance of FCNbased architectures.\n1. While most existing methods require up-sampling spatially-coarse predictions to the resolution of the original image pixel grid (e.g. with deconvolution [48, 71] or interpolation [13]), sampling only requires ondemand computation of a sparse set of sampled features, therefore saving time and space during training (see Section 3).\n2. The reduction in space and time allows us to explore more advanced architectures than prior work [31, 48], which tend to use pixel-wise linear predictors defined over multi-scale \u201chypercolumn\u201d features extracted from multiple layers of the network. Instead, we show that nonlinear predictors of hypercolumn features, implemented through multiple fully-connected layers followed by ReLU, significantly improve accuracy. We find a good tradeoff for learnability is convolutional processing for the lower-layers and ondemand sparse sampling of nonlinear pixel predictions.\n3. In the case of skewed class label distribution, sampling offers the flexibility to let the model focus more on the rare classes. A good example is edge detection, where only 10% of the ground truth are positive [71]. Inspired by [27], we demonstrate that a biased sample toward positives can greatly help the performance.\n4. We show state-of-the-art results for edge detection on BSDS [2], out-performing the holistically-nested edge detection (HED) system of Xie et al. [71]. We also show competitive results for semantic segmentation on the PASCAL VOC-2012 [21], and more challenging\nPASCAL Context dataset where we achieve state of the art performance without contextual post processing [13]. Finally, [4] showed state-of-the-art performance for surface normal estimation using the same architecture."}, {"heading": "2. Background", "text": "In this section, we review related work by making use of a unified notation that will be used to describe our architecture. We address the pixel-wise prediction problem where, given an input image X , we seek to predict outputs Y . For pixel location p, the output can be binary Yp \u2208 {0, 1} (e.g., edge detection), multi-class Yp \u2208 {1, . . . ,K} (e.g., semantic segmentation), or real-valued Yp \u2208 RN (e.g., surface normal prediction). There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).\nConvolutional prediction: We explore spatiallyinvariant predictors f\u03b8,p(X) that are end-to-end trainable over model parameters \u03b8. The family of fully-convolutional and skip networks [51, 57] are illustrative examples that have been successfully applied to, e.g., edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56]. Because such architectures still produce separate predictions for each pixel, numerous approaches have explored post-processing steps that enforce spatial consistency across labels via e.g., bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70]. In contrast, our work does not make use of such contextual post-processing, in an effort to see how far a pure \u201cpixel-level\u201d architecture can be pushed.\nMultiscale features: Higher convolutional layers are typically associated with larger receptive fields that capture high-level global context. Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68]. Hariharan et al [31] use the evocative term \u201chypercolumns\u201d to refer to features extracted from multiple layers that correspond to the same pixel. Let\nhp(X) = [c1(p), c2(p), . . . , cM (p)]\ndenote the multi-scale hypercolumn feature computed for pixel p, where ci(p) denotes the feature vector of convolutional responses from layer i centered at pixel p (and where we drop the explicit dependance on X to reduce clutter). Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme a\u0300 trous [49]), and deconvolution/unpooling [24, 48, 55]. We similarly make use\nof multiscale features, but make use of sparse on-demand upsampling of filter responses, with the goal of reducing memory footprints during learning.\nPixel-prediction: One may cast the pixel-wise prediction problem as operating over the hypercolumn features where, for pixel p, the final prediction is given by\nf\u03b8,p(X) = g(hp(X)).\nWe write \u03b8 to denote both parameters of the hypercolumn features h and the pixel-wise predictor g. Training involves back-propagating gradients via SGD to update \u03b8. Prior work has explored different designs for h and g. A dominant trend is defining a linear predictor on hypercolumn features, e.g., g = w \u00b7 hp. FCNs [48] point out that linear prediction can be efficiently implemented in a coarse-to-fine manner by upsampling coarse predictions (with deconvolution) rather than upsampling coarse features. DeepLab [13] incorporates filter dilation and applies similar deconvolution and linear-weighted fusion, in addition to reducing the dimensionality of the fully-connected layers to reduce memory footprint. ParseNet [46] added spatial context for a layer\u2019s responses by average pooling the feature responses, followed by normalization and concatenation. HED [71] output edge predictions from intermediates layers, which are deeply supervised, and fuses the predictions by linear weighting. Importantly, [52] and [22] are noteable exceptions to the linear trend in that non-linear predictors g are used. This does pose difficulties during learning - [52] precomputes and stores superpixel feature map due to memory constraints, and so cannot be trained end-to-end. Our work demonstrates that sparse sampling of hypercolumn features allows for exploration of highly nonlinear g, which in turn significantly boosts performance.\nAccelerating SGD: There exists a large literature on accelerating stochastic gradient descent. We refer the reader to [9] for an excellent introduction. Though naturally a sequential algorithm that processes one data example at a time, much recent work focuses on mini-batch methods that can exploit parallelism in GPU architectures [14] or clusters [14]. One general theme is efficient online approximation of second-order methods [8], which can model correlations between input features. Batch normalization [36] computes correlation statistics between samples in a batch, producing noticeable improvements in convergence speed. Our work builds similar insights directly into convolutional networks without explicit second-order statistics."}, {"heading": "3. Approach", "text": "This section describes our approach for pixel-wise prediction, making use of the notation introduced in the previous section. We first formalize our pixelwise prediction architecture, and then discuss statistically efficient mini-batch training.\nArchitecture: As in past work, our architecture makes use of multiscale convolutional features, which we write as a hypercolumn descriptor:\nhp = [c1(p), c2(p), . . . , cM (p)]\nWe learn a nonlinear predictor f\u03b8,p = g(hp) implemented as a multi-layer perception (MLP) [7] defined over hypercolumn features. We use a MLP with ReLU activation functions, which can be implemented as a series of \u201cfullyconnected\u201d layers. Importantly, the last layer must be of size K, the number of class labels or real valued outputs being predicted. We visualize our network in Figure 2.\nDense predictions: We now describe an efficient method for generating dense pixel predictions with our network, which will be used at test-time. Dense prediction proceeds by (1) feedforward computation of convolutional responses at all layers {ci} and (2) bilinear interpolation (through \u201cdeconvolution\u201d) of each response map to the original pixel resolution. This produces a dense grid of hypercolumn features, which are then (3) processed by pixelwise MLPs implemented as 1x1 filters (representing each fully-connected layer). The memory intensive portion of this computation is the dense grid of hypercolumn features. This memory footprint is reasonable at test time because a single image can be processed at a time, but at train-time, we would like to train on batches containing many images as possible (to ensure diversity).\nSparse predictions: We now describe an efficient method for generating sparse pixel predictions, which will be used at train-time (for efficient mini-batch generation). Assume that we are given an image X and a sparse set of (sampled) pixel locations {pj}. We efficiently generate a sparse set of predictions at those pixels {f\u03b8,pj} as follows: we follow step (1) from above, but replace (2) with a sparse on-demand computation of hypercolumn features vectors at positions {hpj}. To compute this set, we introduce a new multi-scale sampling layer (in Caffe [38]) that directly extracts the 4 convolutional features corresponding to the 4 discrete locations in ci closest to pixel position pj , and then computes ci(pj) via bilinear interpolation \u201con the fly\u201d. This avoids the computation of a dense grid of hypercolumn features. Finally, step (3) can be implemented as a simple matrix-vector multiplication (by re-arranging the set of hypercolumn vectors {hpj} into a matrix). We experimentally demonstrate that this approach offers an excellent tradeoff between amortized computation and reduced storage, given that a modest number of pixels are sampled per image. If the number of samples is very small (\u20181\u2019 in the extreme case), one can further reduce computation with sparse convolutions (implemented say, by cropping the input image around the sample). Finally, we note that our multi-scale sampling layers simply acts as a selection operation, for which a (sub) gradient can easily be defined.\nThis means that backprop can also take advantage of sparse computations for nonlinear MLP layers and convolutional processing for the lower layers.\nMini-batch sampling: At each iteration of SGD training, the true gradient over the model parameters \u03b8 is approximated by computing the gradient over a relatively small set of samples from the training set. Approaches based on FCN [48] include features for all pixels from an image in a mini-batch. As nearby pixels in an image are highly correlated, sampling them may potentially hurt learning. For instance, correlated samples may overfit to earlier images and require the use of lower learning rates, which slows convergence. To ensure a diverse set of pixels (while still enjoying the amortized benefits of convolutional processing), we settled on the following strategy: rather than using all pixels from a single image, we use a modest number of pixels (\u223c2, 000) per image, but sample many images per batch. Naive computation of dense grid of hypercolumn descriptors takes almost all of the (GPU) memory, while 2, 000 samples takes a small amount using our sparse sampling layer. This allows us to explore more images per batch, significantly increasing sample diversity (as our experiments show, Sec. 4). We explore the precise tradeoff between sampling size, number of images, and overall batch size in our experiments.\nOne might be tempted to think about naive \u201cstraightforward\u201d ways of sub-sampling with the existing architectures. One easy way to sub-sampling is to simply mask out pixel-level outputs. Naively computing a dense grid of hypercolumn descriptors and processing them with a nonlinear MLP would take more than 20X memory compared to our approach. Slightly better would be masking the hypercolumn descriptors before MLP processing, which is still 16X more expensive. We believe such \u201cimplementation details\u201d are crucial for large-scale learning in today\u2019s world of SGD-based CNN optimization (c.f. batch normalization [36], residual learning [32], etc).\nComparison with prior art: Unlike previous approaches (such as hypercolumns [31] and FCN [48]), our\napproach sub-samples hypercolumn features from convolutional layers without any up-sampling. Sub-sampling allows for the use of nonlinear functions (MLP) on such multiscale features, which in turn makes the architecture more generic (eliminating the need for task-specific normalization, scaling, or hand-tuning). As evidence, we use the same settings for three completely different problems (semantic sgmentation, surface normal estimation, and edge detection). For contrast, Xie and Tu [71] required significant modifications (such as deep supervision) to make FCNs applicable for low-level edge detection.\nLong et al. [48] argued against sampling and showed how the convergence is slowed when sampling few pixels. While they experiment with 25 \u2212 50% sampled pixels, we sample only 2% of total pixels in an image. We observed the similar behaviour when using a linear predictor (See Table 1 for more details) but this issue of convergence goes away with the use of MLP. Not only the convergence, a linear predictor may require normalization/scaling, and careful hand-tuning for different tasks (as done in [31, 48]) as features across different convolutional layers lie in different dynamic ranges. On the contrary, our nonlinear MLP can learn to automatically take care of such issues."}, {"heading": "4. Experiments", "text": "In this section we describe our experimental evaluation. We apply our architecture (with minor modifications) to the high-level task of semantic segmentation, and the low-level task of edge detection. We show state-of-the-art1 results on PASCAL-Context [53] (without requiring contextual postprocessing), competitive performance on PASCAL VOC 2012 [21], and advance the state of the art on the BSDS benchmark [2]. We also perform a diagnostic evaluation of the effect of sampling and other hyperparameters/design choices.\nDefault network: As with other methods [13, 48, 71], we fine-tune a VGG-16 network [63]. VGG-16 has 13 con-\n1We briefly present the results of surface normal estimation here in this paper. Refer to [4] for more details.\nvolutional layers and three fully-connected (fc) layers. The convolutional layers are denoted as {11, 12, 21, 22, 31, 32, 33, 41, 42, 43, 51, 52, 53}. Following [48], we transform the last two fc layers to convolutional filters2, and add them to the set of convolutional features that can be aggregated into our multi-scale hypercolumn descriptor. To avoid confusion with the fc layers in our MLP, we will henceforth denote the fc layers of VGG-16 as conv-6 and conv-7. We use the following network architecture (unless otherwise specified): we extract hypercolumn features from conv-{12, 22, 33, 43, 53}with on-demand interpolation. We define a MLP over hypercolumn features with 3 fully-connected (fc) layers of size 4, 096 followed by ReLU [41] activations, where the last layer outputs predictions for K classes (with a softmax/cross-entropy loss).\nDefault training: For all the experiments we used the publicly available Caffe library [38]. All trained models and code will be released. We make use of ImageNet-pretrained values for all convolutional layers, but train our MLP layers \u201cfrom scratch\u201d with Gaussian initialization (\u03c3 = 10\u22123) and dropout [64]. We fix momentum 0.9 and weight decay 0.0005 throughout the fine-tuning process. We use the following update schedule (unless otherwise specified): we tune the network for 80 epochs with a fixed learning rate (10\u22123), reducing the rate by 10\u00d7 twice every 8 epochs until we reach 10\u22125."}, {"heading": "4.1. Semantic Segmentation", "text": "Dataset. The PASCAL-Context dataset [2] augments the original sparse set of PASCAL VOC 2010 segmentation annotations [21] (defined for 20 categories) to pixel labels for the whole scene. While this requires more than 400 categories, we followed standard protocol and evaluate on the 59-class and 33-class subsets. Though all the analysis in this paper are shown on PASCAL Context dataset [2], we also evaluated our approach on the standard PASCAL VOC-2012 dataset [21] to compare with a wide variety of approaches. Qualitative Results. We show qualitative outputs in Figure 3 and compare against FCN-8s [48]. Notice that we capture fine-scale details, such as the leg of birds (row 2) and plant leaves (row 3). Evaluation Metrics. We report results on the standard metrics of pixel accuracy (AC) and region intersection over union (IU ) averaged over classes (higher is better). Both are calculated with DeepLab evaluation tools3. Analysis-1: Number of MLP fc Layers. We evaluate performance as a function of the number of MLP fc layers. Our baseline system has two 4, 096-dimensional hidden layers\n2For alignment purposes, we made a small change by adding a spatial padding of 3 cells for the convolutional counterpart of fc6 since the kernel size is 7\u00d7 7.\n3https://bitbucket.org/deeplab/deeplab-public/\n(fc-3). We consider a linear predictor (fc-1) (implemented as a single layer) and a single 4, 096-dimensional hidden layer (fc-2). Most existing architectures combining different conv layers [31, 48] are equivalent to a linear model (fc1), while networks that operate on modified features (e.g. normalization [46], rescaling [6]) can be viewed as employing a single (designed) intermediate layer.\nWe found it difficult to ensure convergence for singlelayer predictors with the initial learning rate of 10\u22123, so we reduced it to 10\u22127. The results of the networks using the 59-class setup can be found in Table 1 (middle rows). Everything else is kept identical during the fine-tuning process. The results are striking - models trained with fewer than 3 fc layers perform quite poorly: fc-2 constantly predicts the biggest class (\u201csky\u201d) as the class label, while fc-1 behaves similarly, with some additional \u201cbackground\u201d and \u201cperson\u201d pixels. This is consistent with [48]\u2019s observation that random sampling of patches during training can slow convergence. We posit that such careful initialization and training schemes (like stage-wise training [48], `2 normalization [46] or deep supervision [71]) are needed to train such networks. It is suprising that simply adding two hidden fc layers appears to significantly simplify training. Past work [46] argues that convolutional features from different\nlayers should be normalized before concatenation. We posit that two hidden fc layers can learn such normalizations automatically, though further investigation is needed. Analysis-2: Dimension of MLP fc Layers. Here we analyze performance as a function of the size of the MLP fc layers. We experimented the following dimensions for our fc layers: 1, 024, 2, 048, 4, 096 (baseline) and 6, 144. Table 1 (left, bottom rows) lists the results. We can see that with more dimensions the network tends to learn better, potentially because it can capture more information (and with drop-out alleviating over-fitting [64]). In the following experiments we fix the size to 4, 096, a good trade-off between performance and speed. Analysis-3: Number of Mini-batch Samples. One of the critical questions regarding random sampling is the number of required sample. We plot performance as a function of the number of sampled pixels per image. In the first sampling experiment, we fix the batch size to 5 images and sample 500, 1000, 2000 (baseline) and 4000 pixels from each\nimage. The results are shown in Table 2 (middle rows). We observe that: 1) even sampling only 500 pixels per image (on average 2% of the \u223c20, 000 pixels in an image) produces reasonable performance after just 96 epochs. 2) performance is roughly constant as we increase the number of samples.\nWe now perform experiments where the samples are drawn from the same image. When sampling 2000 pixels from a single image (comparable in size to batch of 500 pixels sampled from 5 images), performance dramatically drops. This phenomena consistently holds for additional pixels (Table 2, bottom rows), verifying our central thesis that statistical diversity of samples can trump the computational savings of convolutional processing during learning. Adding conv-7. While our diagnostics reveal the importance of architecture design and sampling, our best results still do not quite reach the state-of-the-art. For example, a single-scale FCN-32s [48], without any low-level layers, can already achieve 35.1. This suggests that their penulti-\nmate conv-7 layer does capture cues relevant for pixel-level prediction. In practice, we find that simply concatenating conv-7 significantly improves performance.\nFollowing the same training process, the results of our model with conv-7 features are shown in Table 3. From this we can see that conv-7 is greatly helping the performance of semantic segmentation. Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74]. For fair comparison, we also experimented with single scale training with 1) half scale 0.5\u00d7, and 2) full scale 1.0\u00d7 images. We find the results are better without 0.25\u00d7 training, reaching 37.4% and 37.6% IU , respectively, even closer to the FCN-8s performance (37.8% IU ). For the 33-class setting, we are already doing better with the baseline model plus conv-7. Analysis-4: Multi-scale. All previous experiments process test images at a single scale (0.25\u00d7 or 0.5\u00d7 its original size), whereas most prior work [13, 46, 48, 74] use multiple scales from full-resolution images. A smaller scale allows the model to access more context when making a prediction, but this can hurt performance on small objects. Following past work, we explore test-time averaging of predictions across multiple scales. We tested combinations of 0.25\u00d7, 0.5\u00d7 and 1\u00d7. For efficiency, we just fine-tune the model trained on small scales (right before reducing the learning rate for the first time) with an initial learning rate of 10\u22123 and step size of 8 epochs, and end training after 24 epochs. The results are also reported in Table 3. Multi-scale prediction generalizes much better (41.0% IU ). Note our pixel-wise predictions do not make use of contextual postprocessing (even outperforming some methods that post-\nprocesses FCNs to do so [12, 74]). Efficiency. We compared our speed, model size, and memory usage of our network to FCN [48] (same architecture) in\nTable 4. Removing the deconvolution layer reduces memory consumption.\nPASCAL VOC-2012. Finally we use the same settings and evaluate our approach on PASCAL VOC-2012. Our approach achieves mAP of 69.7%4. This is much better than previous approaches, e.g. 62.7% for Hypercolumns [31], 62% for FCN [48], 67% for DeepLab (without CRF) [13] etc. Our performance on VOC-2012 is similar to Mostajabi et al [52] despite the fact we use information from only 6 layers while they used information from all the layers. In addition, they use a rectangular region of 256\u00d7256 (called sub-scene) around the super-pixels. We posit that fine-tuning (or back-propagating gradients to conv-layers) enables efficient and better learning with even lesser layers, and without extra sub-scene information in an end-to-end framework. Finally, the use of super-pixels in [52] inhibit capturing detailed segmentation mask (and rather gives \u201cblobby\u201d output), and it is computationally less-tractable to use their approach for per-pixel optimization as information for each pixel would be required to be stored on disk."}, {"heading": "4.2. Surface Normal Estimation", "text": "PixelNet architecture was first proposed in our work [4] on 2D-to-3D model alignment via surface normal estimation. Here we extract some of the results from [4] to show the effectiveness of this architecture for the mid-level task of\n4Per-class performance is available at http://host.robots.ox. ac.uk:8080/anonymous/PZH9WH.html.\nsurface normal estimation. The NYU Depth v2 dataset [62] is used to evaluate the surface normal maps. The criteria introduced by Fouhey et al. [25] is used to compare our approach [4] against prior work [19, 25]. Six statistics are computed over the angular error between the predicted normals and depth-based normals \u2013 Mean, Median, RMSE, 11.25\u25e6, 22.5\u25e6, and 30\u25e6 \u2013 using the normals of Ladicky et al. [42] as ground truth (Note that these normals are computed from depth data obtained using kinect). The first three criteria capture the mean, median, and RMSE of angular error, where lower is better. The last three criteria capture the percentage of pixels within a given angular error, where higher is better. Table 5 compares our approach [4] with previous state-of-the-art approaches. Please refer to [4] for more details on surface normal estimation.\nUnlike the task of semantic segmentation and edge detection, we use a single scale for estimating surface normal maps. We will release the results of using multi-scale approach for surface normal estimation in a future version."}, {"heading": "4.3. Edge Detection", "text": "In this section, we demonstrate that our same architecture can produce state-of-the-art results for low-level edge detection. The standard dataset for edge detection is BSDS500 [2], which consists of 200 training, 100 validation, and 200 testing images. Each image is annotated by\u223c5 humans to mark out the contours. We use the same augmented data (rotation, flipping, totaling 9600 images without resizing) used to train the state-of-the-art Holistically-nested edge detector (HED) [71]. We report numbers on the testing images. During training, we follow HED and only use positive labels where a consensus (\u2265 3 out of 5) of humans agreed. Baseline. We use the same baseline network that was defined for semantic segmentation, only making use of pretrained conv layers. A sigmoid cross-entropy loss is used to determine the whether a pixel is belonging to an edge or\nnot. Due to the highly skewed class distribution, we also normalized the gradients for positives and negatives in each batch (as in [71]). Training. We use our previous training strategy, consisting of batches of 5 images with a total sample size of 10, 000 pixels. Each image is randomly resized to half its scale (so 0.5 and 1.0 times) during learning. The initial learning rate is again set to 10\u22123. However, since the training data is already augmented, we found the network converges much faster than when training for segmentation. To avoid overtraining and over-fitting, we reduce the learning rate at 15 epochs and 20 epochs (by a factor of 10) and end training at 25 epochs. Baseline Results. The results on BSDS, along with other concurrent methods, are reported in Table 7. We apply standard non-maximal suppression and thinning technique using the code provided by [16]. We evaluate the detection performance using three standard measures: fixed contour threshold (ODS), per-image best threshold (OIS), and average precision (AP). Analysis-1: Sampling. Whereas uniform sampling sufficed for semantic segmentation [48], we found the extreme rarity of positive pixels in edge detection required focused sampling of positives. We compare different strategies for sampling a fixed number (2000 pixels per image) training examples in Table 6. Two obvious approaches are uniform and balanced sampling with an equal ratio of positives and negatives (shown to be useful for object detection [26]). We tried ratios of 0.25, 0.5 and 0.75, and found that balancing\nconsistently improved performance5. Analysis-2: conv-7. We previously found that adding features from higher layers is helpful for semantic segmentation. Are such high-level features also helpful for edge detection, generally regarded as a low-level task? To answer this question, we again concatenated conv-7 features with other conv layers { 12, 22, 33, 43, 53 }. Please refer to the results at Table 7, using the second sampling strategy. We find it still helps performance a bit, but not as significantly for semantic segmentation (clearly a high-level task). Our final results as a single output classifier are very competitive to the state-of-the-art.\nQualitatively, we find our network tends to have better results for semantic-contours (e.g. around an object), particularly after including conv-7 features. Figure 5 shows some qualitative results comparing our network with the HED model. Interestingly, our model explicitly removed the edges inside the zebra, but when the model cannot recognize it (e.g. its head is out of the picture), it still marks the edges on the black-and-white stripes. Our model appears to be making use of much higher-level information than past work on edge detection."}, {"heading": "5. Discussion", "text": "We have described a convolutional pixel-level architecture that, with minor modifications, produces state-of-the-\n5Note that simple class balancing [71] in each batch is already used, so the performance gain is unlikely from label re-balancing.\nart accuracy on diverse high-level, mid-level [4], and lowlevel tasks. We demonstrate impressive results6 on highlybenchmarked semantic segmentation, surface normal esti-\n6We ran a vanilla version of our approach for depth estimation, and achieved near state-of-the-art performance (on NYU-v2 depth dataset) with a simple scale-invariant loss function [20]. We will add the results of depth estimation after more careful analysis in a later version.\nmation [4], and edge datasets. Our results are made possible by careful analysis of computational and statistical considerations associated convolutional predictors. Convolution exploits spatial redundancy of pixel neighborhoods for efficient computation, but this redundancy also impedes learning. We propose a simple solution based on stratified sampling that injects diversity while taking advantage of amor-\ntized convolutional processing. Finally, our efficient learning scheme allow us to explore nonlinear functions of multiscale features that encode both high-level context and lowlevel spatial detail, which appears relevant for most pixel prediction tasks. Acknowledgements: This work was in part supported by NSF Grants IIS 0954083, IIS 1618903, and support from Google and Facebook. AB and XC would like to thank Abhinav Shrivastava and Saining Xie for useful discussion."}], "references": [{"title": "Semantic segmentation using regions and parts", "author": ["P. Arbel\u00e1ez", "B. Hariharan", "C. Gu", "S. Gupta", "L. Bourdev", "J. Malik"], "venue": "CVPR. IEEE,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Contour detection and hierarchical image segmentation", "author": ["P. Arbelaez", "M. Maire", "C. Fowlkes", "J. Malik"], "venue": "TPAMI,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "A database and evaluation methodology for optical flow", "author": ["S. Baker", "D. Scharstein", "J. Lewis", "S. Roth", "M.J. Black", "R. Szeliski"], "venue": "IJCV, 92(1),", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Marr Revisited: 2D-3D model alignment via surface normal prediction", "author": ["A. Bansal", "B. Russell", "A. Gupta"], "venue": "CVPR,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2016}, {"title": "The fast bilateral solver", "author": ["J.T. Barron", "B. Poole"], "venue": "CoRR, abs/1511.03296,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2015}, {"title": "Insideoutside net: Detecting objects in context with skip pooling and recurrent neural networks", "author": ["S. Bell", "C.L. Zitnick", "K. Bala", "R. Girshick"], "venue": "arXiv preprint arXiv:1512.04143,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2015}, {"title": "Neural networks for pattern recognition", "author": ["C.M. Bishop"], "venue": "Oxford university press,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1995}, {"title": "Sgd-qn: Careful quasi-newton stochastic gradient descent", "author": ["A. Bordes", "L. Bottou", "P. Gallinari"], "venue": "JMLR, 10,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2009}, {"title": "Large-scale machine learning with stochastic gradient descent", "author": ["L. Bottou"], "venue": "Proceedings of COMPSTAT\u20192010, pages 177\u2013186. Springer,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Scene labeling with lstm recurrent neural networks", "author": ["W. Byeon", "T.M. Breuel", "F. Raue", "M. Liwicki"], "venue": "CVPR,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2015}, {"title": "Semantic segmentation with second-order pooling", "author": ["J. Carreira", "R. Caseiro", "J. Batista", "C. Sminchisescu"], "venue": "ECCV.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Deeplab: Semantic image segmentation with deep convolutional nets, atrous convolution, and fully connected crfs", "author": ["L. Chen", "G. Papandreou", "I. Kokkinos", "K. Murphy", "A.L. Yuille"], "venue": "CoRR, abs/1606.00915,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2016}, {"title": "Semantic image segmentation with deep convolutional nets and fully connected CRFs", "author": ["L.-C. Chen", "G. Papandreou", "I. Kokkinos", "K. Murphy", "A.L. Yuille"], "venue": "ICLR,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2015}, {"title": "Large scale distributed deep networks", "author": ["J. Dean", "G. Corrado", "R. Monga", "K. Chen", "M. Devin", "M. Mao", "A. Senior", "P. Tucker", "K. Yang", "Q.V. Le"], "venue": "In NIPS,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Deep generative image models using a laplacian pyramid of adversarial networks", "author": ["E.L. Denton", "S. Chintala", "R. Fergus"], "venue": "In NIPS,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "Structured forests for fast edge detection", "author": ["P. Doll\u00e1r", "C. Zitnick"], "venue": "ICCV,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "Fast edge detection using structured forests", "author": ["P. Doll\u00e1r", "C.L. Zitnick"], "venue": "TPAMI, 37(8),", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "Flownet: Learning optical flow with convolutional networks", "author": ["A. Dosovitskiy", "P. Fischer", "E. Ilg", "P. H\u00e4usser", "C. Hazrba", "V. Golkov", "P. v.d. Smagt", "D. Cremers", "T. Brox"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Predicting depth, surface normals and semantic labels with a common multi-scale convolutional architecture", "author": ["D. Eigen", "R. Fergus"], "venue": "ICCV,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Depth map prediction from a single image using a multi-scale deep network", "author": ["D. Eigen", "C. Puhrsch", "R. Fergus"], "venue": "NIPS,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2014}, {"title": "The PASCAL Visual Object Classes (VOC) Challenge", "author": ["M. Everingham", "L. Van Gool", "C.K.I. Williams", "J. Winn", "A. Zisserman"], "venue": "IJCV,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2010}, {"title": "Learning hierarchical features for scene labeling", "author": ["C. Farabet", "C. Couprie", "L. Najman", "Y. LeCun"], "venue": "TPAMI, 35(8),", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Efficient graphbased image segmentation", "author": ["P.F. Felzenszwalb", "D.P. Huttenlocher"], "venue": "IJCV, 59(2),", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "Flownet: Learning optical flow with convolutional networks", "author": ["P. Fischer", "A. Dosovitskiy", "E. Ilg", "P. H\u00e4usser", "C. Haz\u0131rba\u015f", "V. Golkov", "P. van der Smagt", "D. Cremers", "T. Brox"], "venue": "arXiv preprint arXiv:1504.06852,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2015}, {"title": "Data-driven 3D primitives for single image understanding", "author": ["D.F. Fouhey", "A. Gupta", "M. Hebert"], "venue": "ICCV,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Fast r-cnn", "author": ["R. Girshick"], "venue": "ICCV,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2015}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["R. Girshick", "J. Donahue", "T. Darrell", "J. Malik"], "venue": "CVPR,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2014}, {"title": "Using k-poselets for detecting people and localizing their keypoints", "author": ["G. Gkioxari", "B. Hariharan", "R. Girshick", "J. Malik"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2014}, {"title": "Decomposing a scene into geometric and semantically consistent regions", "author": ["S. Gould", "R. Fulton", "D. Koller"], "venue": "ICCV. IEEE,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2009}, {"title": "Oriented edge forests for boundary detection", "author": ["S. Hallman", "C.C. Fowlkes"], "venue": "CVPR,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "Hypercolumns for object segmentation and fine-grained localization", "author": ["B. Hariharan", "P. Arbel\u00e1ez", "R. Girshick", "J. Malik"], "venue": "CVPR,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2015}, {"title": "Deep residual learning for image recognition", "author": ["K. He", "X. Zhang", "S. Ren", "J. Sun"], "venue": "arXiv preprint arXiv:1512.03385,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2015}, {"title": "Densebox: Unifying landmark localization with end to end object detection", "author": ["L. Huang", "Y. Yang", "Y. Deng", "Y. Yu"], "venue": "arXiv preprint arXiv:1509.04874,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2015}, {"title": "Pixel-wise deep learning for contour detection", "author": ["J.-J. Hwang", "T.-L. Liu"], "venue": "arXiv preprint arXiv:1504.01989,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2015}, {"title": "Natural Image Statistics: A Probabilistic Approach to Early Computational Vision., volume 39", "author": ["A. Hyv\u00e4rinen", "J. Hurri", "P.O. Hoyer"], "venue": "Springer Science & Business Media,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2009}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["S. Ioffe", "C. Szegedy"], "venue": "D. Blei and F. Bach, editors, Proceedings of the 32nd International Conference on Machine Learning (ICML-15), pages 448\u2013456. JMLR Workshop and Conference Proceedings,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2015}, {"title": "Crisp boundary detection using pointwise mutual information", "author": ["P. Isola", "D. Zoran", "D. Krishnan", "E.H. Adelson"], "venue": "Computer Vision\u2013ECCV 2014, pages 799\u2013814. Springer,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2014}, {"title": "Caffe: Convolutional architecture for fast feature embedding", "author": ["Y. Jia", "E. Shelhamer", "J. Donahue", "S. Karayev", "J. Long", "R. Girshick", "S. Guadarrama", "T. Darrell"], "venue": "ACMMM,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2014}, {"title": "Visual boundary prediction: A deep neural prediction network and quality dissection", "author": ["J.J. Kivinen", "C.K. Williams", "N. Heess", "D. Technologies"], "venue": "AISTATS, volume 1, page 9,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2014}, {"title": "Efficient inference in fully connected crfs with gaussian edge potentials", "author": ["P. Kr\u00e4henb\u00fchl", "V. Koltun"], "venue": "NIPS,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2011}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "NIPS,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2012}, {"title": "Discriminatively trained dense surface normal estimation", "author": ["L. Ladicky", "B. Zeisl", "M. Pollefeys"], "venue": "ECCV,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2014}, {"title": "Efficient backprop", "author": ["Y.A. LeCun", "L. Bottou", "G.B. Orr", "K.-R. M\u00fcller"], "venue": "Neural networks: Tricks of the trade, pages 9\u201348. Springer,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2012}, {"title": "Sketch tokens: A learned mid-level representation for contour and object detection", "author": ["J. Lim", "C. Zitnick", "P. Doll\u00e1r"], "venue": "CVPR,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2013}, {"title": "Nonparametric scene parsing via label transfer", "author": ["C. Liu", "J. Yuen", "A. Torralba"], "venue": "TPAMI, 33(12),", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2011}, {"title": "Parsenet: Looking wider to see better", "author": ["W. Liu", "A. Rabinovich", "A.C. Berg"], "venue": "arXiv preprint arXiv:1506.04579,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2015}, {"title": "Fully convolutional networks for semantic segmentation", "author": ["J. Long", "E. Shelhamer", "T. Darrell"], "venue": "CoRR, abs/1411.4038,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2014}, {"title": "Fully convolutional models for semantic segmentation", "author": ["J. Long", "E. Shelhamer", "T. Darrell"], "venue": "CVPR,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2015}, {"title": "A real-time algorithm for signal analysis with the help of the wavelet transform", "author": ["J.M.M. Holschneider", "R. Kronland-Martinet", "P. Tchamitchian"], "venue": "Wavelets, Time-Frequency Methods and Phase Space, pages 289\u2013297,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 1989}, {"title": "Learning to detect natural image boundaries using local brightness, color, and texture cues", "author": ["D.R. Martin", "C.C. Fowlkes", "J. Malik"], "venue": "TPAMI, 26(5),", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2004}, {"title": "Multidigit recognition using a space displacement neural network", "author": ["O. Matan", "C.J. Burges", "Y. LeCun", "J.S. Denker"], "venue": "NIPS, pages 488\u2013495,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 1991}, {"title": "Feedforward semantic segmentation with zoom-out features", "author": ["M. Mostajabi", "P. Yadollahpour", "G. Shakhnarovich"], "venue": "CVPR, pages 3376\u20133385,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2015}, {"title": "The role of context for object detection and semantic segmentation in the wild", "author": ["R. Mottaghi", "X. Chen", "X. Liu", "N.-G. Cho", "S.-W. Lee", "S. Fidler", "R. Urtasun", "A. Yuille"], "venue": "CVPR,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2014}, {"title": "Stacked hierarchical labeling", "author": ["D. Munoz", "J.A. Bagnell", "M. Hebert"], "venue": "Computer Vision\u2013ECCV 2010, pages 57\u201370. Springer,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2010}, {"title": "Learning deconvolution network for semantic segmentation", "author": ["H. Noh", "S. Hong", "B. Han"], "venue": "ICCV,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2015}, {"title": "Recurrent convolutional neural networks for scene parsing", "author": ["P.H. Pinheiro", "R. Collobert"], "venue": "ICML,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2014}, {"title": "Postal address block location using a convolutional locator network", "author": ["J.C. Platt", "R. Wolf"], "venue": "NIPS,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 1993}, {"title": "Learning to parse images of articulated bodies", "author": ["D. Ramanan"], "venue": "NIPS.", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2007}, {"title": "Associative hierarchical crfs for object class image segmentation", "author": ["C. Russell", "P. Kohli", "P.H. Torr"], "venue": "In ICCV. IEEE,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2009}, {"title": "3-d depth reconstruction from a single still image", "author": ["A. Saxena", "S.H. Chung", "A.Y. Ng"], "venue": "IJCV, 76(1),", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2008}, {"title": "Textonboost for image understanding: Multi-class object recognition and segmentation by jointly modeling texture, layout, and context", "author": ["J. Shotton", "J. Winn", "C. Rother", "A. Criminisi"], "venue": "Int. Journal of Computer Vision (IJCV), January", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2009}, {"title": "Indoor segmentation and support inference from rgbd images", "author": ["N. Silberman", "D. Hoiem", "P. Kohli", "R. Fergus"], "venue": "ECCV,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2012}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["K. Simonyan", "A. Zisserman"], "venue": "CoRR, abs/1409.1556,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 2014}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["N. Srivastava", "G. Hinton", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": "JMLR, 15(1),", "citeRegEx": "64", "shortCiteRegEx": null, "year": 2014}, {"title": "Superparsing: scalable nonparametric image parsing with superpixels", "author": ["J. Tighe", "S. Lazebnik"], "venue": "Computer Vision\u2013 ECCV 2010, pages 352\u2013365. Springer,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2010}, {"title": "Auto-context and its application to highlevel vision tasks and 3d brain image segmentation", "author": ["Z. Tu", "X. Bai"], "venue": "TPAMI, 32(10),", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2010}, {"title": "Visual tracking with fully convolutional networks", "author": ["L. Wang", "W. Ouyang", "X. Wang", "H. Lu"], "venue": "ICCV,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2015}, {"title": "Designing deep networks for surface normal estimation", "author": ["X. Wang", "D. Fouhey", "A. Gupta"], "venue": "CVPR,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2015}, {"title": "Discriminatively trained sparse code gradients for contour detection", "author": ["R. Xiaofeng", "L. Bo"], "venue": "NIPS,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2012}, {"title": "Convolutional pseudo-prior for structured labeling", "author": ["S. Xie", "X. Huang", "Z. Tu"], "venue": "arXiv preprint arXiv:1511.07409,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2015}, {"title": "Holistically-nested edge detection", "author": ["S. Xie", "Z. Tu"], "venue": "ICCV,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2015}, {"title": "Describing the scene as a whole: Joint object detection, scene classification and semantic segmentation", "author": ["J. Yao", "S. Fidler", "R. Urtasun"], "venue": "CVPR. IEEE,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 2012}, {"title": "Multi-scale context aggregation by dilated convolutions", "author": ["F. Yu", "V. Koltun"], "venue": "ICLR,", "citeRegEx": "73", "shortCiteRegEx": null, "year": 2016}, {"title": "Conditional random fields as recurrent neural networks", "author": ["S. Zheng", "S. Jayasumana", "B. Romera-Paredes", "V. Vineet", "Z. Su", "D. Du", "C. Huang", "P.H. Torr"], "venue": "ICCV,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 70, "context": "Note how our approach recovers the fine details missing in the ground truth segmentation (left), and achieves state-of-the-art on edge detection [71].", "startOffset": 145, "endOffset": 149}, {"referenceID": 3, "context": "We explore architectures for general pixel-level prediction problems, from low-level edge detection to mid-level surface normal estimation [4] to high-level semantic segmentation.", "startOffset": 139, "endOffset": 142}, {"referenceID": 3, "context": "Interestingly, our single architecture produces state-of-the-art results for semantic segmentation on PASCAL-Context, surface normal estimation [4] on NYUDv2 dataset, and edge detection on BSDS without contextual post-processing.", "startOffset": 144, "endOffset": 147}, {"referenceID": 15, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 53, "endOffset": 65}, {"referenceID": 49, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 53, "endOffset": 65}, {"referenceID": 70, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 53, "endOffset": 65}, {"referenceID": 2, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 83, "endOffset": 90}, {"referenceID": 17, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 83, "endOffset": 90}, {"referenceID": 3, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 138, "endOffset": 157}, {"referenceID": 18, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 138, "endOffset": 157}, {"referenceID": 19, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 138, "endOffset": 157}, {"referenceID": 59, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 138, "endOffset": 157}, {"referenceID": 67, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 138, "endOffset": 157}, {"referenceID": 27, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 208, "endOffset": 216}, {"referenceID": 57, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 208, "endOffset": 216}, {"referenceID": 32, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 235, "endOffset": 239}, {"referenceID": 12, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 21, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 30, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 47, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 51, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 60, "context": "These include low-level tasks such as edge detection [16, 50, 71] and optical flow [3, 18], mid-level tasks such as depth/normal recovery [4, 19, 20, 60, 68], and high-level tasks such as keypoint prediction [28, 58], object detection [33], and semantic segmentation [13, 22, 31, 48, 52, 61].", "startOffset": 267, "endOffset": 291}, {"referenceID": 12, "context": "Neural networks with convolutional output predictions, also called Fully Convolutional Networks (FCNs) [13, 48, 51, 57], appear to be a promising architecture in this direction.", "startOffset": 103, "endOffset": 119}, {"referenceID": 47, "context": "Neural networks with convolutional output predictions, also called Fully Convolutional Networks (FCNs) [13, 48, 51, 57], appear to be a promising architecture in this direction.", "startOffset": 103, "endOffset": 119}, {"referenceID": 50, "context": "Neural networks with convolutional output predictions, also called Fully Convolutional Networks (FCNs) [13, 48, 51, 57], appear to be a promising architecture in this direction.", "startOffset": 103, "endOffset": 119}, {"referenceID": 56, "context": "Neural networks with convolutional output predictions, also called Fully Convolutional Networks (FCNs) [13, 48, 51, 57], appear to be a promising architecture in this direction.", "startOffset": 103, "endOffset": 119}, {"referenceID": 8, "context": ") [9].", "startOffset": 2, "endOffset": 5}, {"referenceID": 42, "context": "samples is random permutation of the training data, which can significantly improve learnability [43].", "startOffset": 97, "endOffset": 101}, {"referenceID": 34, "context": "It is well known that pixels in a given image are highly correlated and not independent [35].", "startOffset": 88, "endOffset": 92}, {"referenceID": 47, "context": "with deconvolution [48, 71] or interpolation [13]), sampling only requires ondemand computation of a sparse set of sampled features, therefore saving time and space during training (see Section 3).", "startOffset": 19, "endOffset": 27}, {"referenceID": 70, "context": "with deconvolution [48, 71] or interpolation [13]), sampling only requires ondemand computation of a sparse set of sampled features, therefore saving time and space during training (see Section 3).", "startOffset": 19, "endOffset": 27}, {"referenceID": 12, "context": "with deconvolution [48, 71] or interpolation [13]), sampling only requires ondemand computation of a sparse set of sampled features, therefore saving time and space during training (see Section 3).", "startOffset": 45, "endOffset": 49}, {"referenceID": 30, "context": "The reduction in space and time allows us to explore more advanced architectures than prior work [31, 48], which tend to use pixel-wise linear predictors defined over multi-scale \u201chypercolumn\u201d features extracted from multiple layers of the network.", "startOffset": 97, "endOffset": 105}, {"referenceID": 47, "context": "The reduction in space and time allows us to explore more advanced architectures than prior work [31, 48], which tend to use pixel-wise linear predictors defined over multi-scale \u201chypercolumn\u201d features extracted from multiple layers of the network.", "startOffset": 97, "endOffset": 105}, {"referenceID": 70, "context": "A good example is edge detection, where only 10% of the ground truth are positive [71].", "startOffset": 82, "endOffset": 86}, {"referenceID": 26, "context": "Inspired by [27], we demonstrate that a biased sample toward positives can greatly help the performance.", "startOffset": 12, "endOffset": 16}, {"referenceID": 1, "context": "We show state-of-the-art results for edge detection on BSDS [2], out-performing the holistically-nested edge detection (HED) system of Xie et al.", "startOffset": 60, "endOffset": 63}, {"referenceID": 70, "context": "[71].", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "We also show competitive results for semantic segmentation on the PASCAL VOC-2012 [21], and more challenging PASCAL Context dataset where we achieve state of the art performance without contextual post processing [13].", "startOffset": 82, "endOffset": 86}, {"referenceID": 12, "context": "We also show competitive results for semantic segmentation on the PASCAL VOC-2012 [21], and more challenging PASCAL Context dataset where we achieve state of the art performance without contextual post processing [13].", "startOffset": 213, "endOffset": 217}, {"referenceID": 3, "context": "Finally, [4] showed state-of-the-art performance for surface normal estimation using the same architecture.", "startOffset": 9, "endOffset": 12}, {"referenceID": 0, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 10, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 15, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 28, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 44, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 53, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 58, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 60, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 64, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 65, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 71, "context": "There is rich prior art in modeling this prediction problem using hand-designed features (representative examples include [1, 11, 16, 29, 45, 54, 59, 61, 65, 66, 72]).", "startOffset": 122, "endOffset": 165}, {"referenceID": 50, "context": "The family of fully-convolutional and skip networks [51, 57] are illustrative examples that have been successfully applied to, e.", "startOffset": 52, "endOffset": 60}, {"referenceID": 56, "context": "The family of fully-convolutional and skip networks [51, 57] are illustrative examples that have been successfully applied to, e.", "startOffset": 52, "endOffset": 60}, {"referenceID": 70, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 17, "endOffset": 21}, {"referenceID": 9, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 12, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 21, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 23, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 47, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 45, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 51, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 54, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 55, "context": ", edge detection [71] and semantic segmentation [10, 13, 22, 24, 48, 46, 52, 55, 56].", "startOffset": 48, "endOffset": 84}, {"referenceID": 12, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 57, "endOffset": 69}, {"referenceID": 39, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 57, "endOffset": 69}, {"referenceID": 73, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 57, "endOffset": 69}, {"referenceID": 4, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 91, "endOffset": 94}, {"referenceID": 72, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 125, "endOffset": 129}, {"referenceID": 9, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 137, "endOffset": 141}, {"referenceID": 69, "context": ", bilateral smoothing with fully-connected Gaussian CRFs [13, 40, 74] or bilateral solvers [5], dilated spatial convolutions [73], LSTMs [10], and convolutional pseudo priors [70].", "startOffset": 175, "endOffset": 179}, {"referenceID": 14, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 18, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 19, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 21, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 55, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 67, "context": "Because such features may miss low-level details, numerous approaches have built predictors based on multiscale features extracted from multiple layers of a CNN [15, 19, 20, 22, 56, 68].", "startOffset": 161, "endOffset": 185}, {"referenceID": 30, "context": "Hariharan et al [31] use the evocative term \u201chypercolumns\u201d to refer to features extracted from multiple layers that correspond to the same pixel.", "startOffset": 16, "endOffset": 20}, {"referenceID": 47, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 58, "endOffset": 62}, {"referenceID": 12, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 120, "endOffset": 124}, {"referenceID": 48, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 161, "endOffset": 165}, {"referenceID": 23, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 196, "endOffset": 208}, {"referenceID": 47, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 196, "endOffset": 208}, {"referenceID": 54, "context": "Prior techniques for up-sampling include shift and stitch [48], converting convolutional filters to dilation operations [13] (inspired by the algorithme \u00e0 trous [49]), and deconvolution/unpooling [24, 48, 55].", "startOffset": 196, "endOffset": 208}, {"referenceID": 47, "context": "FCNs [48] point out that linear prediction can be efficiently implemented in a coarse-to-fine manner by upsampling coarse predictions (with deconvolution) rather than upsampling coarse features.", "startOffset": 5, "endOffset": 9}, {"referenceID": 12, "context": "DeepLab [13] incorporates filter dilation and applies similar deconvolution and linear-weighted fusion, in addition to reducing the dimensionality of the fully-connected layers to reduce memory footprint.", "startOffset": 8, "endOffset": 12}, {"referenceID": 45, "context": "ParseNet [46] added spatial context for a layer\u2019s responses by average pooling the feature responses, followed by normalization and concatenation.", "startOffset": 9, "endOffset": 13}, {"referenceID": 70, "context": "HED [71] output edge predictions from intermediates layers, which are deeply supervised, and fuses the predictions by linear weighting.", "startOffset": 4, "endOffset": 8}, {"referenceID": 51, "context": "Importantly, [52] and [22] are noteable exceptions to the linear trend in that non-linear predictors g are used.", "startOffset": 13, "endOffset": 17}, {"referenceID": 21, "context": "Importantly, [52] and [22] are noteable exceptions to the linear trend in that non-linear predictors g are used.", "startOffset": 22, "endOffset": 26}, {"referenceID": 51, "context": "This does pose difficulties during learning - [52] precomputes and stores superpixel feature map due to memory constraints, and so cannot be trained end-to-end.", "startOffset": 46, "endOffset": 50}, {"referenceID": 8, "context": "We refer the reader to [9] for an excellent introduction.", "startOffset": 23, "endOffset": 26}, {"referenceID": 13, "context": "Though naturally a sequential algorithm that processes one data example at a time, much recent work focuses on mini-batch methods that can exploit parallelism in GPU architectures [14] or clusters [14].", "startOffset": 180, "endOffset": 184}, {"referenceID": 13, "context": "Though naturally a sequential algorithm that processes one data example at a time, much recent work focuses on mini-batch methods that can exploit parallelism in GPU architectures [14] or clusters [14].", "startOffset": 197, "endOffset": 201}, {"referenceID": 7, "context": "One general theme is efficient online approximation of second-order methods [8], which can model correlations between input features.", "startOffset": 76, "endOffset": 79}, {"referenceID": 35, "context": "Batch normalization [36] computes correlation statistics between samples in a batch, producing noticeable improvements in convergence speed.", "startOffset": 20, "endOffset": 24}, {"referenceID": 6, "context": "We learn a nonlinear predictor f\u03b8,p = g(hp) implemented as a multi-layer perception (MLP) [7] defined over hypercolumn features.", "startOffset": 90, "endOffset": 93}, {"referenceID": 37, "context": "To compute this set, we introduce a new multi-scale sampling layer (in Caffe [38]) that directly extracts the 4 convolutional features corresponding to the 4 discrete locations in ci closest to pixel position pj , and then computes ci(pj) via bilinear interpolation \u201con the fly\u201d.", "startOffset": 77, "endOffset": 81}, {"referenceID": 47, "context": "Approaches based on FCN [48] include features for all pixels from an image in a mini-batch.", "startOffset": 24, "endOffset": 28}, {"referenceID": 35, "context": "batch normalization [36], residual learning [32], etc).", "startOffset": 20, "endOffset": 24}, {"referenceID": 31, "context": "batch normalization [36], residual learning [32], etc).", "startOffset": 44, "endOffset": 48}, {"referenceID": 30, "context": "Comparison with prior art: Unlike previous approaches (such as hypercolumns [31] and FCN [48]), our approach sub-samples hypercolumn features from convolutional layers without any up-sampling.", "startOffset": 76, "endOffset": 80}, {"referenceID": 47, "context": "Comparison with prior art: Unlike previous approaches (such as hypercolumns [31] and FCN [48]), our approach sub-samples hypercolumn features from convolutional layers without any up-sampling.", "startOffset": 89, "endOffset": 93}, {"referenceID": 70, "context": "For contrast, Xie and Tu [71] required significant modifications (such as deep supervision) to make FCNs applicable for low-level edge detection.", "startOffset": 25, "endOffset": 29}, {"referenceID": 47, "context": "[48] argued against sampling and showed how the convergence is slowed when sampling few pixels.", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "Not only the convergence, a linear predictor may require normalization/scaling, and careful hand-tuning for different tasks (as done in [31, 48]) as features across different convolutional layers lie in different dynamic ranges.", "startOffset": 136, "endOffset": 144}, {"referenceID": 47, "context": "Not only the convergence, a linear predictor may require normalization/scaling, and careful hand-tuning for different tasks (as done in [31, 48]) as features across different convolutional layers lie in different dynamic ranges.", "startOffset": 136, "endOffset": 144}, {"referenceID": 52, "context": "We show state-of-the-art1 results on PASCAL-Context [53] (without requiring contextual postprocessing), competitive performance on PASCAL VOC 2012 [21], and advance the state of the art on the BSDS benchmark [2].", "startOffset": 52, "endOffset": 56}, {"referenceID": 20, "context": "We show state-of-the-art1 results on PASCAL-Context [53] (without requiring contextual postprocessing), competitive performance on PASCAL VOC 2012 [21], and advance the state of the art on the BSDS benchmark [2].", "startOffset": 147, "endOffset": 151}, {"referenceID": 1, "context": "We show state-of-the-art1 results on PASCAL-Context [53] (without requiring contextual postprocessing), competitive performance on PASCAL VOC 2012 [21], and advance the state of the art on the BSDS benchmark [2].", "startOffset": 208, "endOffset": 211}, {"referenceID": 12, "context": "Default network: As with other methods [13, 48, 71], we fine-tune a VGG-16 network [63].", "startOffset": 39, "endOffset": 51}, {"referenceID": 47, "context": "Default network: As with other methods [13, 48, 71], we fine-tune a VGG-16 network [63].", "startOffset": 39, "endOffset": 51}, {"referenceID": 70, "context": "Default network: As with other methods [13, 48, 71], we fine-tune a VGG-16 network [63].", "startOffset": 39, "endOffset": 51}, {"referenceID": 62, "context": "Default network: As with other methods [13, 48, 71], we fine-tune a VGG-16 network [63].", "startOffset": 83, "endOffset": 87}, {"referenceID": 3, "context": "Refer to [4] for more details.", "startOffset": 9, "endOffset": 12}, {"referenceID": 47, "context": "Following [48], we transform the last two fc layers to convolutional filters2, and add them to the set of convolutional features that can be aggregated into our multi-scale hypercolumn descriptor.", "startOffset": 10, "endOffset": 14}, {"referenceID": 40, "context": "We define a MLP over hypercolumn features with 3 fully-connected (fc) layers of size 4, 096 followed by ReLU [41] activations, where the last layer outputs predictions for K classes (with a softmax/cross-entropy loss).", "startOffset": 109, "endOffset": 113}, {"referenceID": 37, "context": "Default training: For all the experiments we used the publicly available Caffe library [38].", "startOffset": 87, "endOffset": 91}, {"referenceID": 63, "context": "We make use of ImageNet-pretrained values for all convolutional layers, but train our MLP layers \u201cfrom scratch\u201d with Gaussian initialization (\u03c3 = 10\u22123) and dropout [64].", "startOffset": 164, "endOffset": 168}, {"referenceID": 1, "context": "The PASCAL-Context dataset [2] augments the original sparse set of PASCAL VOC 2010 segmentation annotations [21] (defined for 20 categories) to pixel labels for the whole scene.", "startOffset": 27, "endOffset": 30}, {"referenceID": 20, "context": "The PASCAL-Context dataset [2] augments the original sparse set of PASCAL VOC 2010 segmentation annotations [21] (defined for 20 categories) to pixel labels for the whole scene.", "startOffset": 108, "endOffset": 112}, {"referenceID": 1, "context": "Though all the analysis in this paper are shown on PASCAL Context dataset [2], we also evaluated our approach on the standard PASCAL VOC-2012 dataset [21] to compare with a wide variety of approaches.", "startOffset": 74, "endOffset": 77}, {"referenceID": 20, "context": "Though all the analysis in this paper are shown on PASCAL Context dataset [2], we also evaluated our approach on the standard PASCAL VOC-2012 dataset [21] to compare with a wide variety of approaches.", "startOffset": 150, "endOffset": 154}, {"referenceID": 47, "context": "We show qualitative outputs in Figure 3 and compare against FCN-8s [48].", "startOffset": 67, "endOffset": 71}, {"referenceID": 30, "context": "Most existing architectures combining different conv layers [31, 48] are equivalent to a linear model (fc1), while networks that operate on modified features (e.", "startOffset": 60, "endOffset": 68}, {"referenceID": 47, "context": "Most existing architectures combining different conv layers [31, 48] are equivalent to a linear model (fc1), while networks that operate on modified features (e.", "startOffset": 60, "endOffset": 68}, {"referenceID": 45, "context": "normalization [46], rescaling [6]) can be viewed as employing a single (designed) intermediate layer.", "startOffset": 14, "endOffset": 18}, {"referenceID": 5, "context": "normalization [46], rescaling [6]) can be viewed as employing a single (designed) intermediate layer.", "startOffset": 30, "endOffset": 33}, {"referenceID": 47, "context": "This is consistent with [48]\u2019s observation that random sampling of patches during training can slow convergence.", "startOffset": 24, "endOffset": 28}, {"referenceID": 47, "context": "We posit that such careful initialization and training schemes (like stage-wise training [48], `2 normalization [46] or deep supervision [71]) are needed to train such networks.", "startOffset": 89, "endOffset": 93}, {"referenceID": 45, "context": "We posit that such careful initialization and training schemes (like stage-wise training [48], `2 normalization [46] or deep supervision [71]) are needed to train such networks.", "startOffset": 112, "endOffset": 116}, {"referenceID": 70, "context": "We posit that such careful initialization and training schemes (like stage-wise training [48], `2 normalization [46] or deep supervision [71]) are needed to train such networks.", "startOffset": 137, "endOffset": 141}, {"referenceID": 45, "context": "Past work [46] argues that convolutional features from different", "startOffset": 10, "endOffset": 14}, {"referenceID": 63, "context": "We can see that with more dimensions the network tends to learn better, potentially because it can capture more information (and with drop-out alleviating over-fitting [64]).", "startOffset": 168, "endOffset": 172}, {"referenceID": 47, "context": "For example, a single-scale FCN-32s [48], without any low-level layers, can already achieve 35.", "startOffset": 36, "endOffset": 40}, {"referenceID": 46, "context": "FCN-8s [47] 46.", "startOffset": 7, "endOffset": 11}, {"referenceID": 47, "context": "5 FCN-8s [48] 50.", "startOffset": 9, "endOffset": 13}, {"referenceID": 11, "context": "8 DeepLab (v2 [12]) - 37.", "startOffset": 14, "endOffset": 18}, {"referenceID": 11, "context": "DeepLab (v2) + CRF [12] - 39.", "startOffset": 19, "endOffset": 23}, {"referenceID": 73, "context": "6 CRF-RNN [74] - 39.", "startOffset": 10, "endOffset": 14}, {"referenceID": 45, "context": "3 ParseNet [46] - 40.", "startOffset": 11, "endOffset": 15}, {"referenceID": 69, "context": "4 ConvPP-8 [70] - 41.", "startOffset": 11, "endOffset": 15}, {"referenceID": 11, "context": "Note that while most recent approaches spatial context postprocessing [12, 46, 70, 74], we focus on the FCN [48] per-pixel predictor as most approaches are its descendants.", "startOffset": 70, "endOffset": 86}, {"referenceID": 45, "context": "Note that while most recent approaches spatial context postprocessing [12, 46, 70, 74], we focus on the FCN [48] per-pixel predictor as most approaches are its descendants.", "startOffset": 70, "endOffset": 86}, {"referenceID": 69, "context": "Note that while most recent approaches spatial context postprocessing [12, 46, 70, 74], we focus on the FCN [48] per-pixel predictor as most approaches are its descendants.", "startOffset": 70, "endOffset": 86}, {"referenceID": 73, "context": "Note that while most recent approaches spatial context postprocessing [12, 46, 70, 74], we focus on the FCN [48] per-pixel predictor as most approaches are its descendants.", "startOffset": 70, "endOffset": 86}, {"referenceID": 47, "context": "Note that while most recent approaches spatial context postprocessing [12, 46, 70, 74], we focus on the FCN [48] per-pixel predictor as most approaches are its descendants.", "startOffset": 108, "endOffset": 112}, {"referenceID": 47, "context": "Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74].", "startOffset": 79, "endOffset": 83}, {"referenceID": 12, "context": "Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74].", "startOffset": 123, "endOffset": 139}, {"referenceID": 45, "context": "Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74].", "startOffset": 123, "endOffset": 139}, {"referenceID": 69, "context": "Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74].", "startOffset": 123, "endOffset": 139}, {"referenceID": 73, "context": "Even with reduced scale, we are able to obtain a similar IU achieved by FCN-8s [48], without any extra modeling of context [13, 46, 70, 74].", "startOffset": 123, "endOffset": 139}, {"referenceID": 12, "context": "5\u00d7 its original size), whereas most prior work [13, 46, 48, 74] use multiple scales from full-resolution images.", "startOffset": 47, "endOffset": 63}, {"referenceID": 45, "context": "5\u00d7 its original size), whereas most prior work [13, 46, 48, 74] use multiple scales from full-resolution images.", "startOffset": 47, "endOffset": 63}, {"referenceID": 47, "context": "5\u00d7 its original size), whereas most prior work [13, 46, 48, 74] use multiple scales from full-resolution images.", "startOffset": 47, "endOffset": 63}, {"referenceID": 73, "context": "5\u00d7 its original size), whereas most prior work [13, 46, 48, 74] use multiple scales from full-resolution images.", "startOffset": 47, "endOffset": 63}, {"referenceID": 11, "context": "Note our pixel-wise predictions do not make use of contextual postprocessing (even outperforming some methods that postprocesses FCNs to do so [12, 74]).", "startOffset": 143, "endOffset": 151}, {"referenceID": 73, "context": "Note our pixel-wise predictions do not make use of contextual postprocessing (even outperforming some methods that postprocesses FCNs to do so [12, 74]).", "startOffset": 143, "endOffset": 151}, {"referenceID": 47, "context": "We compared our speed, model size, and memory usage of our network to FCN [48] (same architecture) in Table 4.", "startOffset": 74, "endOffset": 78}, {"referenceID": 30, "context": "7% for Hypercolumns [31], 62% for FCN [48], 67% for DeepLab (without CRF) [13] etc.", "startOffset": 20, "endOffset": 24}, {"referenceID": 47, "context": "7% for Hypercolumns [31], 62% for FCN [48], 67% for DeepLab (without CRF) [13] etc.", "startOffset": 38, "endOffset": 42}, {"referenceID": 12, "context": "7% for Hypercolumns [31], 62% for FCN [48], 67% for DeepLab (without CRF) [13] etc.", "startOffset": 74, "endOffset": 78}, {"referenceID": 51, "context": "Our performance on VOC-2012 is similar to Mostajabi et al [52] despite the fact we use information from only 6 layers while they used information from all the layers.", "startOffset": 58, "endOffset": 62}, {"referenceID": 51, "context": "Finally, the use of super-pixels in [52] inhibit capturing detailed segmentation mask (and rather gives \u201cblobby\u201d output), and it is computationally less-tractable to use their approach for per-pixel optimization as information for each pixel would be required to be stored on disk.", "startOffset": 36, "endOffset": 40}, {"referenceID": 3, "context": "PixelNet architecture was first proposed in our work [4] on 2D-to-3D model alignment via surface normal estimation.", "startOffset": 53, "endOffset": 56}, {"referenceID": 3, "context": "Here we extract some of the results from [4] to show the effectiveness of this architecture for the mid-level task of", "startOffset": 41, "endOffset": 44}, {"referenceID": 47, "context": "FCN-32s [48] 4,096 1 50,176 2,056 570 20.", "startOffset": 8, "endOffset": 12}, {"referenceID": 47, "context": "0 FCN-8s [48] 4,864 1 50,176 2,010 518 19.", "startOffset": 9, "endOffset": 13}, {"referenceID": 47, "context": "We compared our network with FCN [48] where a deconvolution layer is used to upsample the result in various settings.", "startOffset": 33, "endOffset": 37}, {"referenceID": 47, "context": "Note that besides FCN-8s and FCN-32s here we first compute the upsampled feature map, then apply the classifiers for FCN [48] due to the additional fc layers.", "startOffset": 121, "endOffset": 125}, {"referenceID": 24, "context": "[25] 35.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "E-F (AlexNet) [19] 23.", "startOffset": 14, "endOffset": 18}, {"referenceID": 18, "context": "E-F (VGG-16) [19] 20.", "startOffset": 13, "endOffset": 17}, {"referenceID": 3, "context": "Ours [4] 19.", "startOffset": 5, "endOffset": 8}, {"referenceID": 3, "context": "NYUv2 surface normal prediction from [4].", "startOffset": 37, "endOffset": 40}, {"referenceID": 61, "context": "The NYU Depth v2 dataset [62] is used to evaluate the surface normal maps.", "startOffset": 25, "endOffset": 29}, {"referenceID": 24, "context": "[25] is used to compare our approach [4] against prior work [19, 25].", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[25] is used to compare our approach [4] against prior work [19, 25].", "startOffset": 37, "endOffset": 40}, {"referenceID": 18, "context": "[25] is used to compare our approach [4] against prior work [19, 25].", "startOffset": 60, "endOffset": 68}, {"referenceID": 24, "context": "[25] is used to compare our approach [4] against prior work [19, 25].", "startOffset": 60, "endOffset": 68}, {"referenceID": 41, "context": "[42] as ground truth (Note that these normals are computed from depth data obtained using kinect).", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "Table 5 compares our approach [4] with previous state-of-the-art approaches.", "startOffset": 30, "endOffset": 33}, {"referenceID": 3, "context": "Please refer to [4] for more details on surface normal estimation.", "startOffset": 16, "endOffset": 19}, {"referenceID": 1, "context": "The standard dataset for edge detection is BSDS500 [2], which consists of 200 training, 100 validation, and 200 testing images.", "startOffset": 51, "endOffset": 54}, {"referenceID": 70, "context": "We use the same augmented data (rotation, flipping, totaling 9600 images without resizing) used to train the state-of-the-art Holistically-nested edge detector (HED) [71].", "startOffset": 166, "endOffset": 170}, {"referenceID": 1, "context": "Human [2] .", "startOffset": 6, "endOffset": 9}, {"referenceID": 22, "context": "580 Felz-Hutt [23] .", "startOffset": 14, "endOffset": 18}, {"referenceID": 1, "context": "gPb-owt-ucm [2] .", "startOffset": 12, "endOffset": 15}, {"referenceID": 43, "context": "696 Sketch Tokens [44] .", "startOffset": 18, "endOffset": 22}, {"referenceID": 68, "context": "780 SCG [69] .", "startOffset": 8, "endOffset": 12}, {"referenceID": 36, "context": "PMI [37] .", "startOffset": 4, "endOffset": 8}, {"referenceID": 16, "context": "SE-Var [17] .", "startOffset": 7, "endOffset": 11}, {"referenceID": 29, "context": "803 OEF [30] .", "startOffset": 8, "endOffset": 12}, {"referenceID": 38, "context": "DeepNets [39] .", "startOffset": 9, "endOffset": 13}, {"referenceID": 33, "context": "758 CSCNN [34] .", "startOffset": 10, "endOffset": 14}, {"referenceID": 70, "context": "798 HED [71] .", "startOffset": 8, "endOffset": 12}, {"referenceID": 70, "context": "833 HED [71] (Updated version) .", "startOffset": 8, "endOffset": 12}, {"referenceID": 70, "context": "811 HED merging [71] (Updated version) .", "startOffset": 16, "endOffset": 20}, {"referenceID": 1, "context": "Evaluation on BSDS [2].", "startOffset": 19, "endOffset": 22}, {"referenceID": 70, "context": "Due to the highly skewed class distribution, we also normalized the gradients for positives and negatives in each batch (as in [71]).", "startOffset": 127, "endOffset": 131}, {"referenceID": 15, "context": "We apply standard non-maximal suppression and thinning technique using the code provided by [16].", "startOffset": 92, "endOffset": 96}, {"referenceID": 47, "context": "Whereas uniform sampling sufficed for semantic segmentation [48], we found the extreme rarity of positive pixels in edge detection required focused sampling of positives.", "startOffset": 60, "endOffset": 64}, {"referenceID": 25, "context": "Two obvious approaches are uniform and balanced sampling with an equal ratio of positives and negatives (shown to be useful for object detection [26]).", "startOffset": 145, "endOffset": 149}, {"referenceID": 1, "context": "Results on BSDS [2].", "startOffset": 16, "endOffset": 19}, {"referenceID": 70, "context": "5Note that simple class balancing [71] in each batch is already used, so the performance gain is unlikely from label re-balancing.", "startOffset": 34, "endOffset": 38}, {"referenceID": 70, "context": "Notice that our approach generates more semantic edges for zebra, eagle, and giraffe compared to HED [71].", "startOffset": 101, "endOffset": 105}, {"referenceID": 3, "context": "art accuracy on diverse high-level, mid-level [4], and lowlevel tasks.", "startOffset": 46, "endOffset": 49}, {"referenceID": 19, "context": "6We ran a vanilla version of our approach for depth estimation, and achieved near state-of-the-art performance (on NYU-v2 depth dataset) with a simple scale-invariant loss function [20].", "startOffset": 181, "endOffset": 185}, {"referenceID": 3, "context": "mation [4], and edge datasets.", "startOffset": 7, "endOffset": 10}], "year": 2016, "abstractText": "We explore architectures for general pixel-level prediction problems, from low-level edge detection to mid-level surface normal estimation [4] to high-level semantic segmentation. Convolutional predictors, such as the fullyconvolutional network (FCN), have achieved remarkable success by exploiting the spatial redundancy of neighboring pixels through convolutional processing. Though computationally efficient, we point out that such approaches are not statistically efficient during learning precisely because spatial redundancy limits the information learned from neighboring pixels. We demonstrate that (1) stratified sampling allows us to add diversity during batch updates and (2) sampled multi-scale features allow us to explore more nonlinear predictors (multiple fully-connected layers followed by ReLU) that improve overall accuracy. Finally, our objective is to show how a architecture can get performance better than (or comparable to) the architectures designed for a particular task. Interestingly, our single architecture produces state-of-the-art results for semantic segmentation on PASCAL-Context, surface normal estimation [4] on NYUDv2 dataset, and edge detection on BSDS without contextual post-processing. * indicates equal contribution; first two authors listed in alphabetical order.", "creator": "LaTeX with hyperref package"}}}