{"id": "1610.06781", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Oct-2016", "title": "Modular Deep Q Networks for Sim-to-real Transfer of Visuo-motor Policies", "abstract": "In this paper, we describe a deep network architecture that maps visual input to control actions for a robotic planar achievement task with 100% reliability in the real world. Our network is trained in simulation and refined with a limited number of images from the real world. Political search is guided by a kinematics-based controller (K-GPS) that works more effectively and efficiently than $\\ varepsilon $-greedy. A critical insight into our system is the need to introduce a bottleneck in the network between the perception and control networks and first train these networks independently.", "histories": [["v1", "Fri, 21 Oct 2016 13:36:25 GMT  (7705kb,D)", "http://arxiv.org/abs/1610.06781v1", "Under review for the IEEE Robotics and Automation Letters (RA-L) with the option for the IEEE International Conference on Robotics and Automation (ICRA) 2017 (submitted on 10 Sep, 2016)"], ["v2", "Wed, 1 Mar 2017 09:59:51 GMT  (6020kb,D)", "http://arxiv.org/abs/1610.06781v2", "Under review for the IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) 2017 (submitted on 1 Mar, 2017)"], ["v3", "Mon, 17 Jul 2017 09:59:35 GMT  (2949kb,D)", "http://arxiv.org/abs/1610.06781v3", "Under review for CoRL 2017 (submitted on 28 June, 2017)"]], "COMMENTS": "Under review for the IEEE Robotics and Automation Letters (RA-L) with the option for the IEEE International Conference on Robotics and Automation (ICRA) 2017 (submitted on 10 Sep, 2016)", "reviews": [], "SUBJECTS": "cs.RO cs.AI cs.CV cs.LG cs.SY", "authors": ["fangyi zhang", "j\\\"urgen leitner", "michael milford", "peter corke"], "accepted": false, "id": "1610.06781"}, "pdf": {"name": "1610.06781.pdf", "metadata": {"source": "CRF", "title": "Vision-Based Reaching Using Modular Deep Networks: from Simulation to the Real World", "authors": ["Fangyi Zhang", "J\u00fcrgen Leitner", "Ben Upcroft", "Peter Corke"], "emails": ["fangyi.zhang@hdr.qut.edu.au"], "sections": [{"heading": null, "text": "I. INTRODUCTION\nSensor based robot tasks such as visual reaching are implemented today by human-written code. Typically a perception system will identify the target in some local or global coordinate system and the robot motion planner and joint control system will ensure that the required collision-free motion is executed. Understanding complex visual scenes has traditionally been a hard problem but in recent years deep learning techniques have led to significant improvements in robustness and performance [1]. Motion planning is normally implemented using classical algorithmic approaches, and joint control implemented using classical control engineering techniques.\nInspired by the success of deep learning in computer vision, some pioneers have used deep neural networks to perform robotic tasks based directly on image data, such as object grasping and bottle cap screwing [2], [3], [4], [5]. However, most existing works achieved a good but not perfect performance by collecting large-scale datasets or adding constraints for optimization. To reduce the cost of collecting large-scale real datasets for robotic applications we propose to train in simulation and then transfer to a real world robotic setup.\nOur work is inspired by the Deepmind\u2019s Deep Q-Network approach [6], which showed that a deep learnt system was able to take images and directly synthesise control actions for Atari video games, albeit all in simulation. While this result is an important and exciting breakthrough we have found that it does not transfer directly to robotics application in a naive way, as the trained deep network\u2019s perception is quite brittle when dealing with real cameras observing real scenes [7]. In this paper, we conduct some further\n*This research was conducted by the Australian Research Council Centre of Excellence for Robotic Vision (project number CE140100016). Computational resources & services used in this work were partially provided by the HPC and Research Support Group, Queensland University of Technology.\n1The authors are with the Australian Centre for Robotic Vision (ACRV), Queensland University of Technology (QUT), Brisbane, Australia fangyi.zhang@hdr.qut.edu.au\ninvestigations on perception adaptation and policy search for vision-based target reaching on a robotic arm, with the aim of adapting pre-trained networks for real-world applications in a feasible and low-cost way. In particular, we\n\u2022 propose a low-cost way of adapting visuomotor policies from simulation to real world robotic settings using modular neural networks, where we separate perception and control by adding a bottleneck (Fig. 1A). \u2022 introduce a new policy search method for Q-learning, using a kinematics-based controller to guide the search for a feasible policy. The guidance from a conventional controller makes it possible and quicker to obtain feasible policies for a robotic planar reaching task where \u03b5-Greedy works poorly. \u2022 demonstrate learning of a robotic planar reaching task in simulation (Fig. 1B) and transfer to a real world setup using about 1000 real images, and achieve a success rate of 100% in 20 reaching tests on Baxter (Fig. 1C)."}, {"heading": "II. RELATED WORK", "text": "Inspired by the success of deep learning in computer vision, deep learning is becoming more prominent in robotics research. Especially, the Atari game playing DeepQ-Network (DQN) [6] has inspired robotics researchers to look at deep learning for tasks that require a close interaction\nar X\niv :1\n61 0.\n06 78\n1v 1\n[ cs\n.R O\n] 2\n1 O\nct 2\n01 6\nbetween vision and action. It showed that visual inputs \u2013 taken from a game emulator \u2013 can be directly mapped to the best action to take \u2013 button to press \u2013 with a deep neural network. The network successfully learned to play 49 different games solely based on the reward provided by the game score. This is done by using Q-learning [8], a form of reinforcement learning, which aims to maximise the future expected reward given a current state s and a policy \u03c0:\nQ(s, a) = max \u03c0\nE[rt + \u03b3rt+1 + \u03b32rt+2 + . . . |\u03c0], (1)\nIt is the maximum sum of rewards rt discounted by \u03b3 at each time-step t, achievable by a behaviour policy \u03c0 = P (a|s) in state s and taking an action a. The novelty of DQN is that it allows the state to be represented by a highdimensional input, a computer screen image. This is possible by using convolutional network layers to extract the relevant features [1]. Once the function is learned, the action with the maximum Q-value for a given input image will be performed.\nInspired by the DQN, we implemented a simple simulator for robotic planar reaching, providing a virtual environment for a DQN to learn, as shown in Fig. 1B. Through the simulator, a DQN agent learned to control the 3-joint arm to reach towards a blue-circle target [7]. However, we found that a deep network trained in simulation was not directly transferable into the real world even though configuration and sensing noise was added in the training to make it as robust as possible.\nSome other works are also aiming to use deep learning for robotic applications, and have achieved a promising performance. A convolutional neural network (CNN) was trained to cope with obstacle avoidance problem for mobile robots [9]. A CNN based policy representation architecture (deep visuomotor policies) and its guided policy search (GPS) method were introduced [2]. The deep visuomotor policies map joint angles and camera images directly to joint torques, achieving a good performance in the tasks of hanging a coat hanger, inserting a block into a kids toy, and tightening a bottle cap.\nBy using a large-scale dataset with 800,000 grasp attempts, a CNN was trained to predict the success probability of a sequence of motions aiming at grasping on a 7 DoF robotic manipulator with a 2-finger gripper [3]. Combined with a simple derivative-free optimization algorithm (CEM [10]) the grasping system achieved a success rate of 80%. Another example of deep learning for grasping is self-supervised grasping learning in the real world where force sensors were used to autonomously label samples [4]. After trained with 50K trials using a staged leaning method, a CNN achieved a grasping success rate around 70%.\nRecurrent neural networks (RNNs) have also been used to learn manipulation tasks such as cutting objects, e.g., by combining RNN and model predictive control (DeepMPC) [5]. It achieved a state-of-the-art performance in experiments on a large-scale dataset of 1488 material cuts for 20 diverse classes, and in 450 real-world robotic experiments.\nThese works show that, with appropriate network architectures and effective training methods, deep learning\nis feasible in robotic manipulation and brings benefits in performance improvements. However, they are either too expensive in terms of time and resources for large-scale datasets collection, or not robust enough for global solutions, very few of them are focused on transferring skills from simulation to the real world.\nTransfer learning (TL) attempts to develop methods to transfer knowledge between tasks (i.e., transfer knowledge learned in one or more sources tasks to a related target task) [11]. Many TL methods have been introduced in the areas of data mining [12] and reinforcement learning [13]. Progressive neural networks were developed for both leveraging transfer and avoiding catastrophic forgetting to enable the learning of complex sequences of tasks, whose effectiveness has been validated on a wide variety of reinforcement learning tasks such as Atari and 3D maze games [14].\nHowever, TL methods for robotic applications are still very limited. Most methods need manually designed task mapping information, such as a similarity-based approach to skill transfer for robots [15]. To reduce the number of real-world images for pose CNN training in GPS [2], a method of adapting visual representations from simulated to real environments was proposed. The method achieved a success rate of 79.2% in a \u201chook loop\u201d task, with 10 times less real-world images [16].\nPreviously it was shown that a DQN trained in simulation had a poor performance in real-world reaching, due to the brittleness of the transferred perception [7]. Adapting a neural network from simulation to the real world necessitates an extra fine-tuning step. However, fine-tuning directly on a real robot is expensive in terms of resources and time."}, {"heading": "III. PROBLEM FORMULATION", "text": "A canonical problem in robotics is to reach for the object to be interacted with. This target reaching task is defined as controlling a robot arm, such that its end-effector is reaching a specific target in operational space. A n-DOF robot movement is represented in joint or configuration space C \u2208 Sn; joint angles define the robot pose q \u2208 C. A controller then reduces the error between the robot\u2019s current and to-bereached pose q\u2217. We consider the case when the robot only has visual perception. In this case the target T is represented by its image coordinates (Tx, Ty).\nThe setup consists of a Baxter robot which aims to reach an arbitrary placed, blue target in a 2D vertical plane, with three joints of its left arm (Fig. 1C). The robot\u2019s perception is limited to raw-pixel images I from an external monocular camera. A single coloured, blue circle is used as a target.\nWe limit the robots actions a to 9 discrete options \u2013 the buttons in the Atari scenario. Each action is either rotating clockwise, counter-clockwise or halting a specific joint qi of a 3 DoF arm. The rotation actions are fixed to 0.04 radian per execution. Only a single action ai is executed at any given time step.\nAs deep learning approaches require considerable number of input images, purely learning in the real world is infeasible with current techniques. Inspired by the Atari games, a\nsimulator is developed to provide a virtual environment for the robot to learn reaching (Fig. 1B). The simulated arm consists of four links and three joints, whose configurations are consistent to the specifications of a Baxter arm, including joint constraints. The target to reach is represented by a blue circle with a radius of 0.05m. A reach is deemed successful if the robot reaches and keeps its end-effector within 0.09m to the centre of the target for four consecutive actions, which is equivalent to about 4 pixels in the input image to a neural network. Although the simulator is low-fidelity, our experimental results show that it is sufficient to learn and transfer reaching skills to a real robot (see Section V)."}, {"heading": "IV. METHODOLOGY", "text": "A DQN trained in simulation does not transfer naively to real-world reaching, due to the brittle perception [7]. To adapt the perception in a low-cost way, we propose a modular deep learning architecture that can learn robotic reaching from visual inputs only, inspired by the Deepmind\u2019s DQN system."}, {"heading": "A. Modular neural networks", "text": "The modularity stems from the well-established approach in robotics to connect perception with control via a very strict, well-defined interface. The advantage of a separate perception module is that a small number of real-world samples is enough to fine-tune it for a real-world setup after training in simulation.\nThe original Deepmind DQN uses three convolutional (conv) layers, followed by two fully-connected (FC) layers (Fig. 2(left)). The intuition is that the conv part is focusing on the perception, i.e., extracing the relevant information from the visual intput, and the FC part performs the robot control. We verify this by separating the network into perception and control modules. To create a useful interface, we propose a bottleneck layer (BN) which represents the minimal description of the scene \u2013 herein a combination of the robot\u2019s state q and the target location (Tx, Ty) (Fig. 2(right)).\nBased on the physical representation that is contained in the bottleneck, we can train and assess the performance of the perception and control modules independently."}, {"heading": "B. Perception module", "text": "The perception module learns how to extract the scene configuration \u03b8 from raw-pixel images I .\n1) Architecture: Compared to the original DQN, instead of using 4 consecutive images we use a single grey-scale image as input which is sufficient for the planar reaching in stepping position control mode where no temporal information is necessary. Before input to the perception module, images from the simulator (RGB, 160\u00d7 210) are converted to grey-scale and scaled to 84\u00d7 84. To be able to train the module based on our physical intuition in the bottleneck, a FC layer is added to map high-dimensional features from Conv3 to the scene configuration \u03b8.\nThe network is initialized with random weights, apart from the first conv layer. Conv1 is initialized with the weights from a GoogLeNet [17] pre-trained on the ImageNet dataset [18]. A weight conversion, based on standard RGB to grey-scale methods, is necessary as GoogLeNet has three input channels (RGB) compared to our grey-scale channel.\n2) Training method: The perception is trained using supervised learning. The training is first conducted in simulation, then fine-tuned with a small number of real samples to enable the transfer to the real robot setup. Each sample contains an image It \u2013 from either the simulator or the real setup \u2013 and its ground-truth scene configuration \u03b8t. In the training, the weights are updated through backpropagation [19] using the quadratic cost function\nCi = 1\n2m m\u2211 t=1 \u2225\u2225y(It)i \u2212 \u03b8it\u2225\u22252 , (2) where Ci is the cost for \u03b8it, an element in \u03b8t; m is the number of samples; y(It)i is the prediction of \u03b8it for It."}, {"heading": "C. Control module", "text": "The control module decides which action a to take based on the current state of the scene \u03b8.\n1) Architecture: The control module has 3 FC layers, with 400 and 300 units in the two hidden layers (FC_c1 and FC_c2), as shown in Fig. 2(right). The input to the control\nAlgorithm 1: DQN with K-GPS 1 Initialize replay memory D 2 Initialize Q-function Q(\u03b8, a) with random weights 3 for iteration=1,K do 4 if previous trial finished then 5 Start a new trial: 6 Randomly generate two arm poses q and q\u2217 7 Get the end-effector position (Tx, Ty) for the pose q\u2217 8 Use (Tx, Ty) as the target in this trial; and q as the beginning pose\n9 end 10 With probability \u03b5 select an action at by\nargmin a \u2016q(a)\u2212 q\u2217\u2016\n11 otherwise select at = maxa Q(\u03b8t, a) 12 Execute at and observe reward rt and state \u03b8t+1 13 Add the new sample (\u03b8t, at, rt, \u03b8t+1) into D 14 Sample a random minibatch from D 15 Update (Q(\u03b8, a)) using the minibatch 16 end\nmodule is the scene configuration \u03b8. Its output is the Q-values for the 9 possible actions. Our experiments in Section V-B show that too few layers or units in each layer will make a network sensitive to training parameters.\n2) Training method: The control module is trained in simulation to learn a policy using Q-learning. We propose a FC network to approximate an optimal Q-value function as defined in Eq. 1, where the action with the maximum activation will be executed. Here, the state s is represented by \u03b8, i.e., Q(\u03b8, a). The implementation is based on Deepmind\u2019s DQN, where a replay memory and target Q network are used to stabilize the training [6].\nThe reward r of each action is determined according to the Euclidean distance between the end-effector and the centre of a target (d), as shown in equation\nr = \u03bb(\u03b4/d\u2212 1) if d > \u03b40 if d 6 \u03b4, n < 4 1 if d 6 \u03b4, n > 4 , (3)\nwhere \u03b4 is a threshold for reaching a target (\u03b4 = 0.05m); \u03bb is a constant discount factor (\u03bb = 10\u22123); n represents the times of d being consecutively smaller than \u03b4.\nWith this reward function, an agent will receive negative rewards before getting close enough to a target. The presence of negative rewards can result in policies with fewer steps to reach a target. Such a reward function helps an agent to take into account temporal costs during policy search, i.e., fewer steps is better. By setting it to give a positive reward only when d is smaller than the threshold (\u03b4) for more than 4 consecutive times, the reward function will guide an agent to stay close to a target rather than just going through it. Designing a good reward function is an active topic in the field of reinforcement learning. This reward function allows an agent to learn planar reaching, but we do not claim\noptimality. In Q-learning, \u03b5-Greedy is usually used for policy search, which is used in the original DQN. However, experiments show that the \u03b5-Greedy method works poorly in our planar reaching task (Section V-B). Therefore, we introduce a kinematics-based controller to guide the policy search (KGPS) to cope with this problem. The guidance controller selects actions by doing the following optimization:\nargmin a \u2016q(a)\u2212 q\u2217\u2016 , (4)\nwhere a is any option from the 9 available actions, q(a) is the resulted pose by taking action a in current pose, and q\u2217 is the desired pose. Our DQN with K-GPS algorithm is shown in Algorithm 1. When training, a replay memory D which is used to store samples of (\u03b8t, at, rt, \u03b8t+1) will first be initialized. The control module which works as a Q-function Q(\u03b8, a) will be initialized with random weights. At the beginning of each trial, the starting arm pose and target position are randomly generated. To guarantee a random target (Tx, Ty) is reachable by the arm, we first randomly select an arm pose q\u2217, and use the position of its end-effector as the target position. Then q\u2217 is used as the desired pose to guide the policy search. In each iteration, the action will be selected by the kinematicsbased controller with a probability of \u03b5, otherwise selected by the control module. In the training, \u03b5 decreases linearly from 1 to 0.1, i.e., the guidance gets weaker in the process. After action execution, a new sample of (\u03b8t, at, rt, \u03b8t+1) will be added into D. The control module is updated using a minibatch with random samples from D."}, {"heading": "V. EXPERIMENTS AND RESULTS", "text": "We first assessed the accuracy of perception modules trained under different conditions; then evaluated the performance of control modules and analyzed the benefits of using K-GPS; at last tested the performance of a network composed by perception and control modules in real-world end-to-end reaching."}, {"heading": "A. Perception training and fine-tuning", "text": "1) Experimental setup: To see the benefit of fine-tuning perception with real images, we trained 6 different agents using different methods, as shown in Table I. SIM was trained from scratch purely in simulation; RW was trained from scratch using real images; FT25\u2013100 were trained by fine-tuning SIM with different percentage of real images. Pleased be noted that the percentage of real or simulated images is that in a minibatch for weights updating, not that in a training set.\nWhen training in simulation, images were generated by the simulator and labelled with ground-truth scene configuration \u03b8. When training or fine-tuning with real images, 1418 images were used with their ground-truth scene configuration. The real images were collected in the real-world setup (Fig. 1C), with different arm poses uniformly distributed in the joint space. For convenience, instead of using a real target, a blue circle was painted on each real image as a\nvirtual target using the simulator. Fig. 3 shows how a real image was collected. Fig. 3B is an examplary real image with a virtual target. As introduced in Section IV-B, before input to a perception module, Fig. 3B will be converted to Fig. 3C. To yield more robust results, the real data was augmented by transforming the images with variations in rotation, translation, noise, and brightness (as done for CNN training in computer vision).\nIn both training and fine-tuning, we used a minibatch size of 128 and a learning rate between 0.1 and 0.01. RmsProp [20] was also adopted. The modules trained from scratch converged after 4 million updating steps (about 6 days on a Tesla K40 GPU). Those fine-tuned from SIM converged after 2 million updating steps (about 3 days). These results show that fine-tuning is helpful to reduce the training time.\nThe performance was evaluated using perception error which is defined as the Euclidean norm e between the predicted \u03b8\u0302 and ground truth \u03b8\u2217 scene configuration, e =\u2225\u2225\u2225\u03b8\u0302 \u2212 \u03b8\u2217\u2225\u2225\u2225. Usually, a smaller e means smaller errors in both joint angle and target coordinate recognition.\nThe evaluation was conducted in three different scenarios: \u201cSimulation\u201d, \u201cReal\u201d and \u201cLive on Baxter\u201d. In \u201cSimulation\u201d, 400 images were used for evaluation. The 400 images are uniformly distributed in scene configuration space. Similarly, 400 real-world images were collected for evaluation (\u201cReal\u201d). Please be noted that the 400 real-world images are different from those for training/fine-tuning, although collected at the same time. To make the test as close as possible to the real application scenario (Fig. 1C), we also conducted a live evaluation directly on Baxter (\u201cLive on Baxter\u201d), where 40 different scene configurations were tested.\n2) Quantitative results: The evaluation results are shown in Table II where e\u00b5 and e\u03c3 represent the mean and standard deviation of e. As expected, the perception modules performed well in the scenarios that they were trianed/finetuned for, but poorly otherwise. This can be observed from the results of e\u00b5 in Table II. The module trained with only simulated images (SIM) had a small error in simulation (\u201cSimulation\u201d) but very poor performance in real environ-\nments (\u201cReal\u201d and \u201cLive on Baxter\u201d). Similarly, the module trained (RW) or fine-tuned (FT100) with only real-world images performed fine in real environments but poorly in simulation. In contrast, the modules fine-tuned with both simulated and real images can cope with both scenarios.\nThe results for FT25\u2013100 show that the percentage of real world images in a minibatch plays a role in balancing the performance in real and simulated environments, which can be observed more obviously in Fig. 4, a boxplot for the results of FT25\u2013100 in \u201cSimulation\u201d and \u201cLive on Baxter\u201d. The more real images were presented in a minibatch during training the smaller the error in the real world became. Similarly for the performance in simulation: more simulated images yielded a smaller error. In particular, FT25 had the smallest e\u00b5 in \u201cSimulation\u201d; FT100 had the smallest e\u00b5 in \u201cReal\u201d and \u201cLive on Baxter\u201d. However, when balancing e\u00b5 and e\u03c3 , FT75 had the best performance in \u201cLive on Baxter\u201d,\nwhich is more obviously indicated in Fig. 4. By comparing SIM with FT25\u2013100 in Table II, we can see that the modules fine-tuned with less than 50% simulated images (FT75 and FT100) obtained a bigger error than SIM in \u201cSimulation\u201d. This indicates that fine-tuning needs at least 50% simulated samples in a minibatch to prevent a network from forgetting pre-mastered skills (scene configuration recognition in simulation). We can also observe that, a network fine-tuned using real images (FT100) had a smaller error than a network trained from scratch (RW) in the real setup. This indicates that fine-tuning from a pre-trained network is helpful to obtain a better performance not just reduce the training time.\nIn Table II, the results of \u201cLive on Baxter\u201d were similar to those for \u201cReal\u201d, but with bigger errors. Since the pose of the external camera that observed the scene was not fixed, tiny variations were to be expected between different setups. This explains the bigger errors in the setup for \u201cLive on Baxter\u201d. This performance drop was already significantly reduced thanks to the addition of translations and rotations on real images in data augmentation. For comparison, we tested a perception module trained without image translation and rotation under the scenario of \u201cLive on Baxter\u201d, and achieved a very poor performance (e\u00b5=0.7303,e\u03c3=0.1013). In the future, this kind of camera pose variance can be avoided by using an on-board camera.\n3) Qualitative results: In addition to the quantitative results, we also got some qualitative results from the tests on Baxter. When no target presented in the scene, constant values (with small variance) will be output by the perception network. When two targets presented, neither target was recognized accurately; the target recognition outputs were inconsistent. Yet in both cases, joint angles were recognized accurately. When part of the robot body or arm was occluded by a white T-shirt, the arm poses were still recognized but with a slightly bigger error in most cases. These qualitative results show that the fine-tuned networks were robust to small-range disturbances in perception."}, {"heading": "B. Control training", "text": "1) \u03b5-Greedy VS K-GPS: To understand the benefit of using K-GPS for Q-learning, we trained 6 control modules for the planar reaching task with different degrees of freedom (1, 2 and 3 DoF) using \u03b5-Greedy or K-GPS for comparison. In the 1 DoF case, only q2 was rotatable; 2 DoF with q2 and q3; and 3 DoF with all three joints. In training, we used a learning rate between 0.1 and 0.01, and a minibatch of 64. The \u03b5 probability decreased from 1 to 0.1 within 1 million training steps for 1 DoF reaching, 2 million steps for 2 DoF, and 3 million steps for 3 DoF. \u03b5-Greedy and K-GPS used the same settings for \u03b5.\nFig. 5 shows the learning curves for all 6 modules, which indicates the success rate of a module after a certain number of training steps. As introduced in Section III, when counting the success rate, a reach is deemed successful if the endeffector reaches and keeps within 0.09m (about 4 pixels in the input image to a network) to the centre of a target for four\nconsecutive actions. In the learning curve, the success rate was collected using 200 reaching tests. In the test, the target positions and starting arm poses were uniformly distributed in the scene configuration space.\nFrom Fig. 5, we can find that, in 1 DoF reaching, modules trained using K-GPS and \u03b5-Greedy both converged to a success rate of 100% after around 1 million steps (4 hours on one 2.66GHz 64bit Intel Xeon processor core). In 2 DoF reaching, K-GPS converged to almost 100% after 2 million steps (8 hours); \u03b5-Greedy converged to around 80% after 4 million steps (16 hours). In 3 DoF reaching, KGPS converged to almost 100% after 4 million steps (16 hours); \u03b5-Greedy converged to about 40% after 6 million steps (24 hours). The learning curves show that K-GPS was feasible for all degrees of freedom, but \u03b5-Greedy worked only in 1 DoF reaching, it got worse when degrees of freedom increased.\nTo further analyze the modules trained using K-GPS and \u03b5-Greedy, we evaluated the converged modules in simulation using the metrics of error distance d and also success rate \u03b1. d is the closest Euclidean distance between the end-effector and the target reached by a control module. Here, to get a more accurate indication on the performance 400 reaching\ntests were used. The results are shown in Table III. The success rate results in Table III are consistent to what we found from Fig. 5. The error distance results show that, KGPS achieved a smaller error distance than \u03b5-Greedy in all degrees of freedom.\nOther than the evaluation in simulation, we also tested the network trained using K-GPS for 3 DoF reaching (Network C) in real environments, where joint angles were from encoders, target coordinates were from simulator (virtual targets). In the test, the joint angles from encoders had an averaging error of 0.0015 radian with a standard deviation of 0.0015 radian. Network C achieved a success rate of 100% in 20 reaching tests, with an averaging distance of 0.0337m, as shown in Table V (Net C). The good performance in the real world indicates that the control module is robust to smallrange sensing noise.\nIn addition to the comparison between K-GPS and \u03b5Greedy, we also compared K-GPS with the guidance controller in terms of policy efficiency. 200 successful trials were picked out to evaluate their averaging completion steps. The completion steps are how many actions one network took to reach a target. The results are shown in Table IV from which we can see that the policies learned by K-GPS needed fewer completion steps than the guidance controller (Guidance). The more degrees of freedom, the more obvious it was. This is because the guidance controller selects an action by doing an optimization in joint space for each step, rather than aiming for a maximum accumulative reward which is the Q-learning cares. This indicates that, with an appropriate reward function, the policies learned by Q-learning with KGPS are able to surpass the guidance controller.\n2) Qualitative results for architecture comparison: We also tested different FC networks with different numbers of hidden layers and units in each layer. The qualitative results show that a network with only one hidden layer was enough for 1 DoF reaching but insufficient for 2 and 3 DoF cases. The number of units in each layer also influenced the performance. For the 3 DoF reaching, the architecture introduced in Section IV-C worked the best; and at least two hidden layers with 200 and 150 units were needed, otherwise it would be very sensitive to training parameters."}, {"heading": "C. End-to-end reaching", "text": "To test the performance of a network composed by perception and control modules in the real world, we conducted an\nevaluation for end-to-end reaching where inputs were rawpixel images, and outputs were actions. For comparison, we evaluated two networks: one was composed by SIM and C (EE1); the other was composed by FT75 and C (EE2). SIM was trained purely in simulation; FT75 achieved the best performance in the real world.\nSimilar to the settings in Section V-B, the performance was evaluated using the metrics of success rate \u03b1 and error distance d. Each network was evaluated with 20 reaching tests in the real world. As mentioned in Section V-B, we used virtual targets for more convenient quantitative results collection. The results are shown in Table V where d\u00b5 and d\u03c3 are the mean and standard deviation d\u03c3 of error distances. The error distance in pixel level in the input image (84\u00d784) is also listed in the table.\nFrom Table V, we can see that, as expected, EE1 worked poorly in the real world, since SIM was not fine-tuned for real environments. In contrast, EE2 worked well and achieved a success rate of 100%.\nBy comparing EE2 with C, we can find that, the endto-end performance was a bit worse than the control module itself in terms of error distance. The averaging error distance of C was 0.0337m and 1.4141 pixels, but that of EE2 was 0.0612m and 2.5680 pixels. The factors resulting in the bigger error came from the perception. The low resolution of the input images and the filter size and stride settings in FT75 limited the accuracy of perception. The perception accuracy can be improved by increasing the input image resolution and optimizing the settings for filter size and stride in conv layers. An extra end-to-end fine-tuning might also be helpful to improve the performance [2].\nIn addition to the quantitative results, we also tested EE2 with real targets and even occlusions on the robot body, and got some qualitative results. In the test, a printed blue circle was used as a target, a white T-shirt was used to collide part of the Baxter body, as shown in Fig. 6. In the case without\nocclusion (A), real targets can always be reached. In Case B, C and E, most targets can be reached with a bigger error distance than Case A. In Case D, only a few targets can be reached with the biggest error among all the five cases. The qualitative results indicate that EE2 did have some robustness to occlusions, although the occlusions did not appear in the training. A video showing the end-to-end reaching tests can be found at https://wiki.qut.edu.au/x/WQM9DQ."}, {"heading": "VI. CONCLUSION AND DISCUSSION", "text": "Herein we proposed a method to transfer learnt visionbased reaching from simulation to a real-world setup. The proposed modular deep network architecture presents a feasible and fast way to transfer. The method can be used to separate a task into a number of sub-tasks, making it tractable to learn and transfer complex skills.\nThe physical intuition in the target reaching task that one part of the network performs visual perception while the other part performs control was verified by the introduction of a bottleneck layer. This bottleneck represents the scene configuration which is the robot pose and target position.\nA kinematics-based guided policy search (K-GPS) method was also introduced, which is more effective and efficient than \u03b5-Greedy in the robotic planar reaching task. The KGPS method assumes that we have already got enough knowledge on the task to learn, and had a model for that. It can be applied to some other robotic applications where kinematics models are available, but not suitable for some challenging tasks that lacks models.\nThe time-cost for training a perception network was reduced by fine-tuning from pre-trained networks. The timecost can be further reduced by optimizing the network architecture and training methods, as well as fine-tuning from a more generalized pre-trained model. With the development of deep learning in robotics, we will get more and better pretrained models, then the fine-tuning method will be more practical and efficient.\nResults in the real planar reaching setup where a Baxter robot only had an external viewpoint of itself and the target, show 100% success rate in 20 trials, with an averaging error distance of 2.5680 pixels. The modular networks trained using our method were robust to small-range disturbances, although those disturbances did not appear in the training.\nTo further validate the method, more investigations are necessary for more complicated tasks such as 7 DoF target reaching in a real 3D space using continuous control."}], "references": [{"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "Advances in Neural Information Processing Systems (NIPS), 2012, pp. 1097\u20131105.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "End-to-end training of deep visuomotor policies", "author": ["S. Levine", "C. Finn", "T. Darrell", "P. Abbeel"], "venue": "Journal of Machine Learning Research, vol. 17, no. 39, pp. 1\u201340, 2016.", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2016}, {"title": "Learning hand-eye coordination for robotic grasping with deep learning and large-scale data collection", "author": ["S. Levine", "P.P. Sampedro", "A. Krizhevsky", "D. Quillen"], "venue": "International Symposium on Experimental Robotics (ISER), 2016.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2016}, {"title": "Supersizing self-supervision: Learning to grasp from 50k tries and 700 robot hours", "author": ["L. Pinto", "A. Gupta"], "venue": "IEEE International Conference on Robotics and Automation (ICRA), 2016, pp. 3406\u2013 3413.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2016}, {"title": "Deepmpc: Learning deep latent features for model predictive control", "author": ["I. Lenz", "R. Knepper", "A. Saxena"], "venue": "Robotics: Science and Systems (RSS), 2015.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2015}, {"title": "Human-level control through deep reinforcement learning", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski"], "venue": "Nature, vol. 518, no. 7540, pp. 529\u2013533, 2015.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2015}, {"title": "Towards vision-based deep reinforcement learning for robotic motion control", "author": ["F. Zhang", "J. Leitner", "M. Milford", "B. Upcroft", "P. Corke"], "venue": "Australasian Conference on Robotics and Automation (ACRA), 2015.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2015}, {"title": "Reinforcement learning: An introduction", "author": ["A.G. Barto"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1998}, {"title": "A deep-network solution towards modelless obstacle avoidance", "author": ["L. Tai", "S. Li", "M. Liu"], "venue": "IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2016.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2016}, {"title": "The Cross-Entropy Method: A Unified Approach to Combinatorial Optimization, Monte-Carlo Simulation, and Machine Learning", "author": ["R.Y. Rubinstein", "D.P. Kroese"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2004}, {"title": "Transfer learning", "author": ["L. Torrey", "J. Shavlik"], "venue": "Handbook of Research on Machine Learning Applications and Trends: Algorithms, Methods, and Techniques, E. S. Olivas, J. D. M. Guerrero, M. M. Sober, J. R. M. Benedito, and A. J. S. Lopez, Eds. Hershey, PA, USA: IGI Global, 2009, ch. 11, pp. 242\u2013264.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "A survey on transfer learning", "author": ["S.J. Pan", "Q. Yang"], "venue": "IEEE Transactions on Knowledge and Data Engineering, vol. 22, no. 10, pp. 1345\u20131359, 2010.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Transfer learning for reinforcement learning domains: A survey", "author": ["M.E. Taylor", "P. Stone"], "venue": "The Journal of Machine Learning Research, vol. 10, pp. 1633\u20131685, 2009.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2009}, {"title": "Progressive neural networks", "author": ["A.A. Rusu", "N.C. Rabinowitz", "G. Desjardins", "H. Soyer", "J. Kirkpatrick", "K. Kavukcuoglu", "R. Pascanu", "R. Hadsell"], "venue": "arXiv preprint arXiv:1606.04671, 2016.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "A similarity-based approach to skill transfer", "author": ["T. Fitzgerald", "A. Goel", "A. Thomaz"], "venue": "Women in Robotics Workshop at Robotics: Science and Systems Conference (RSS), 2015.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2015}, {"title": "Towards adapting deep visuomotor representations from simulated to real environments", "author": ["E. Tzeng", "C. Devin", "J. Hoffman", "C. Finn", "X. Peng", "S. Levine", "K. Saenko", "T. Darrell"], "venue": "arXiv preprint arXiv:1511.07111, 2015.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2015}, {"title": "Going deeper with convolutions", "author": ["C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich"], "venue": "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2015, pp. 1\u20139.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "Imagenet: A large-scale hierarchical image database", "author": ["J. Deng", "W. Dong", "R. Socher", "L.-J. Li", "K. Li", "L. Fei-Fei"], "venue": "IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2009, pp. 248\u2013 255.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2009}, {"title": "Learning representations by backpropagating errors", "author": ["D.E. Rumelhart", "G.E. Hinton", "R.J. Williams"], "venue": "Nature, vol. 323, pp. 533\u2013 536, 1986.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1986}, {"title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude", "author": ["T. Tieleman", "G. Hinton"], "venue": "COURSERA: Neural Networks for Machine Learning, vol. 4, no. 2, 2012.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 0, "context": "Understanding complex visual scenes has traditionally been a hard problem but in recent years deep learning techniques have led to significant improvements in robustness and performance [1].", "startOffset": 186, "endOffset": 189}, {"referenceID": 1, "context": "Inspired by the success of deep learning in computer vision, some pioneers have used deep neural networks to perform robotic tasks based directly on image data, such as object grasping and bottle cap screwing [2], [3], [4], [5].", "startOffset": 209, "endOffset": 212}, {"referenceID": 2, "context": "Inspired by the success of deep learning in computer vision, some pioneers have used deep neural networks to perform robotic tasks based directly on image data, such as object grasping and bottle cap screwing [2], [3], [4], [5].", "startOffset": 214, "endOffset": 217}, {"referenceID": 3, "context": "Inspired by the success of deep learning in computer vision, some pioneers have used deep neural networks to perform robotic tasks based directly on image data, such as object grasping and bottle cap screwing [2], [3], [4], [5].", "startOffset": 219, "endOffset": 222}, {"referenceID": 4, "context": "Inspired by the success of deep learning in computer vision, some pioneers have used deep neural networks to perform robotic tasks based directly on image data, such as object grasping and bottle cap screwing [2], [3], [4], [5].", "startOffset": 224, "endOffset": 227}, {"referenceID": 5, "context": "Our work is inspired by the Deepmind\u2019s Deep Q-Network approach [6], which showed that a deep learnt system was able to take images and directly synthesise control actions for Atari video games, albeit all in simulation.", "startOffset": 63, "endOffset": 66}, {"referenceID": 6, "context": "While this result is an important and exciting breakthrough we have found that it does not transfer directly to robotics application in a naive way, as the trained deep network\u2019s perception is quite brittle when dealing with real cameras observing real scenes [7].", "startOffset": 260, "endOffset": 263}, {"referenceID": 5, "context": "Especially, the Atari game playing DeepQ-Network (DQN) [6] has inspired robotics researchers to look at deep learning for tasks that require a close interaction ar X iv :1 61 0.", "startOffset": 55, "endOffset": 58}, {"referenceID": 7, "context": "This is done by using Q-learning [8], a form of reinforcement learning, which aims to maximise the future expected reward given a current state s and a policy \u03c0:", "startOffset": 33, "endOffset": 36}, {"referenceID": 0, "context": "This is possible by using convolutional network layers to extract the relevant features [1].", "startOffset": 88, "endOffset": 91}, {"referenceID": 6, "context": "Through the simulator, a DQN agent learned to control the 3-joint arm to reach towards a blue-circle target [7].", "startOffset": 108, "endOffset": 111}, {"referenceID": 8, "context": "A convolutional neural network (CNN) was trained to cope with obstacle avoidance problem for mobile robots [9].", "startOffset": 107, "endOffset": 110}, {"referenceID": 1, "context": "A CNN based policy representation architecture (deep visuomotor policies) and its guided policy search (GPS) method were introduced [2].", "startOffset": 132, "endOffset": 135}, {"referenceID": 2, "context": "By using a large-scale dataset with 800,000 grasp attempts, a CNN was trained to predict the success probability of a sequence of motions aiming at grasping on a 7 DoF robotic manipulator with a 2-finger gripper [3].", "startOffset": 212, "endOffset": 215}, {"referenceID": 9, "context": "simple derivative-free optimization algorithm (CEM [10]) the grasping system achieved a success rate of 80%.", "startOffset": 51, "endOffset": 55}, {"referenceID": 3, "context": "Another example of deep learning for grasping is self-supervised grasping learning in the real world where force sensors were used to autonomously label samples [4].", "startOffset": 161, "endOffset": 164}, {"referenceID": 4, "context": ", by combining RNN and model predictive control (DeepMPC) [5].", "startOffset": 58, "endOffset": 61}, {"referenceID": 10, "context": ", transfer knowledge learned in one or more sources tasks to a related target task) [11].", "startOffset": 84, "endOffset": 88}, {"referenceID": 11, "context": "Many TL methods have been introduced in the areas of data mining [12] and reinforcement learning [13].", "startOffset": 65, "endOffset": 69}, {"referenceID": 12, "context": "Many TL methods have been introduced in the areas of data mining [12] and reinforcement learning [13].", "startOffset": 97, "endOffset": 101}, {"referenceID": 13, "context": "Progressive neural networks were developed for both leveraging transfer and avoiding catastrophic forgetting to enable the learning of complex sequences of tasks, whose effectiveness has been validated on a wide variety of reinforcement learning tasks such as Atari and 3D maze games [14].", "startOffset": 284, "endOffset": 288}, {"referenceID": 14, "context": "Most methods need manually designed task mapping information, such as a similarity-based approach to skill transfer for robots [15].", "startOffset": 127, "endOffset": 131}, {"referenceID": 1, "context": "To reduce the number of real-world images for pose CNN training in GPS [2], a method of adapting visual representations from simulated to real environments was proposed.", "startOffset": 71, "endOffset": 74}, {"referenceID": 15, "context": "2% in a \u201chook loop\u201d task, with 10 times less real-world images [16].", "startOffset": 63, "endOffset": 67}, {"referenceID": 6, "context": "Previously it was shown that a DQN trained in simulation had a poor performance in real-world reaching, due to the brittleness of the transferred perception [7].", "startOffset": 157, "endOffset": 160}, {"referenceID": 6, "context": "A DQN trained in simulation does not transfer naively to real-world reaching, due to the brittle perception [7].", "startOffset": 108, "endOffset": 111}, {"referenceID": 16, "context": "Conv1 is initialized with the weights from a GoogLeNet [17] pre-trained on the ImageNet dataset [18].", "startOffset": 55, "endOffset": 59}, {"referenceID": 17, "context": "Conv1 is initialized with the weights from a GoogLeNet [17] pre-trained on the ImageNet dataset [18].", "startOffset": 96, "endOffset": 100}, {"referenceID": 18, "context": "In the training, the weights are updated through backpropagation [19] using the quadratic cost function", "startOffset": 65, "endOffset": 69}, {"referenceID": 5, "context": "The implementation is based on Deepmind\u2019s DQN, where a replay memory and target Q network are used to stabilize the training [6].", "startOffset": 125, "endOffset": 128}, {"referenceID": 19, "context": "RmsProp [20] was also adopted.", "startOffset": 8, "endOffset": 12}, {"referenceID": 1, "context": "An extra end-to-end fine-tuning might also be helpful to improve the performance [2].", "startOffset": 81, "endOffset": 84}], "year": 2016, "abstractText": "In this paper we describe a deep network architecture that maps visual input to control actions for a robotic planar reaching task with 100% reliability in real-world trials. Our network is trained in simulation and fine-tuned with a limited number of real-world images. The policy search is guided by a kinematics-based controller (K-GPS), which works more effectively and efficiently than \u03b5-Greedy. A critical insight in our system is the need to introduce a bottleneck in the network between the perception and control networks, and to initially train these networks independently.", "creator": "LaTeX with hyperref package"}}}