{"id": "1610.07563", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Oct-2016", "title": "On Multiplicative Multitask Feature Learning", "abstract": "We are examining a general framework of multitask feature learning that breaks down the model parameters of each task into a multiplication of two components, one of which is used for all tasks and the other component is task specific. Several previous methods have been suggested as special cases of our framework. We are examining the theoretical properties of this framework when different regularization conditions are applied to the two decomposed components. We are demonstrating that this framework is mathematically equivalent to the widely used multi-task feature learning methods, which are based on a common regularization of all model parameters but with a more general form of regularizers. We are also deriving an analytical formula for the multi-task component, which relates to the task-specific component for all of these regularizers, leading to a better understanding of the shrinkage effect. Studying this framework motivates new multi-task learning algorithms. We are proposing two new learning formulations to relativize the parameters of the two new ones we have proposed in the framework.", "histories": [["v1", "Mon, 24 Oct 2016 19:27:52 GMT  (7145kb,D)", "http://arxiv.org/abs/1610.07563v1", "Advances in Neural Information Processing Systems 2014"]], "COMMENTS": "Advances in Neural Information Processing Systems 2014", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["xin wang 0023", "jinbo bi", "shipeng yu", "jiangwen sun"], "accepted": true, "id": "1610.07563"}, "pdf": {"name": "1610.07563.pdf", "metadata": {"source": "CRF", "title": "On Multiplicative Multitask Feature Learning", "authors": ["Xin Wang", "Jinbo Bi", "Shipeng Yu", "Jiangwen Sun"], "emails": ["wangxin@engr.uconn.edu", "jinbo@engr.uconn.edu", "javon@engr.uconn.edu", "shipeng.yu@siemens.com"], "sections": [{"heading": "1 Introduction", "text": "Multitask learning (MTL) captures and exploits the relationship among multiple related tasks and has been empirically and theoretically shown to be more effective than learning each task independently. Multitask feature learning (MTFL) investigates a basic assumption that different tasks may share a common representation in the feature space. Either the task parameters can be projected to explore the latent common substructure [18], or a shared low-dimensional representation of data can be formed by feature learning [10]. Recent methods either explore the latent basis that is used to develop the entire set of tasks, or learn how to group the tasks [16, 11], or identify if certain tasks are outliers to other tasks [6].\nA widely used MTFL strategy is to impose a blockwise joint regularization of all task parameters to shrink the effects of features for the tasks. These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix. Regularizers based on the `1,p norms encourage row sparsity. If rows represent features and columns represent tasks, they shrink the entire rows of the matrix to have zero entries. Typical choices for p are 2 [15, 4] and\u221e [20] which are used in the very early MTFL methods. Effective algorithms have since then been developed for the `1,2 [13] and `1,\u221e [17] regularization. Later, the `1,p norm is generalized to include 1 < p \u2264 \u221e with a probabilistic interpretation that the resultant MTFL method solves a relaxed optimization problem with a generalized normal prior for all tasks [22]. Recent research applies the capped `1,1 norm as a nonconvex joint regularizer [5]. The major limitation of joint regularized MTFL is that it either selects a feature as relevant to all tasks or excludes it from all models, which is very restrictive in practice where tasks may share some features but may have their own specific features as well.\nar X\niv :1\n61 0.\n07 56\n3v 1\n[ cs\n.L G\n] 2\n4 O\nct 2\nTo overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components. One regularizer is used to take care of cross-task similarities and the other for cross-feature sparsity. Specifically, for the methods that decompose the parameter matrix into summation of two matrices, the dirty model in [9] employs `1,1 and `1,\u221e regularizers to the two components. A robust MTFL method in [3] uses the trace norm on one component for mining a low-rank structure shared by tasks and a column-wise `1,2-norm on the other component for identifying task outliers. Another method applies the `1,2-norm both row-wisely to one component and column-wisely to the other [6].\nFor the methods that work with multiplicative decompositions, the parameter vector of each task is decomposed into an element-wise product of two vectors where one is used across tasks and the other is task-specific. These methods either use the `2-norm penalty on both of the component vectors [2], or the sparse `1-norm on the two components (i.e., multi-level LASSO) [14]. The multi-level LASSO method has been analytically compared to the dirty model [14], showing that the multiplicative decomposition creates better shrinkage on the global and task-specific parameters. The across-task component can screen out the features irrelevant to all tasks. To exclude a feature from a task, the additive decomposition requires the corresponding entries in both components to be zero whereas the multiplicative decomposition only requires one of the components to have a zero entry. Although there are different ways to regularize the two components in the product, no systematic work has been done to analyze the algorithmic and statistical properties of the different regularizers. It is insightful to answer the questions such as how these learning formulations differ from the early methods based on blockwise joint regularization, how the optimal solutions of the two components look like, and how the resultant solutions are compared with those of other methods that also learn both shared and task-specific features.\nIn this paper, we investigate a general framework of the multiplicative decomposition that enables a variety of regularizers to be applied. This general form includes all early methods that represent model parameters as a product of two components [2, 14]. Our theoretical analysis has revealed that this family of methods is actually equivalent to the joint regularization based approach but with a more general form of regularizers, including those that do not correspond to a matrix norm. The optimal solution of the across-task component can be analytically computed by a formula of the optimal task-specific parameters, showing the different shrinkage effects. Statistical justification and efficient algorithms are derived for this family of formulations. Motivated by the analysis, we propose two new MTFL formulations. Unlike the existing methods [2, 14] where the same kind of vector norm is applied to both components, the shrinkage of the global and task-specific parameters differ in the new formulations. Hence, one component is regularized by the `2-norm and the other is by the `1-norm, which aims to reflect the degree of sparsity of the task-specific parameters relative to the sparsity of the across-task parameters. In empirical experiments, simulations have been designed to examine the various feature sharing patterns where a specific choice of regularizer may be preferred. Empirical results on benchmark data are also discussed."}, {"heading": "2 The Proposed Multiplicative MTFL", "text": "Given T tasks in total, for each task t, t \u2208 {1, \u00b7 \u00b7 \u00b7 , T}, we have sample set (Xt \u2208 R`t\u00d7d,yt \u2208 R`t). The data set of Xt has `t examples, where the i-th row corresponds to the i-th example xti of task t, i \u2208 {1, \u00b7 \u00b7 \u00b7 , `t}, and each column represents a feature. The vector yt contains yti , the label of the i-th example of task t. We consider functions of the linear form Xt\u03b1t where \u03b1t \u2208 Rd. We define the parameter matrix or weight matrix A = [\u03b11, \u00b7 \u00b7 \u00b7 ,\u03b1T ] and \u03b1j are the rows, j \u2208 {1, \u00b7 \u00b7 \u00b7 , d}. A family of multiplicative MTFL methods can be derived by rewriting \u03b1t = diag(c)\u03b2t where diag(c) is a diagonal matrix with its diagonal elements composing a vector c. The c vector is used across all tasks, indicating if a feature is useful for any of the tasks, and the vector \u03b2t is only for task t. Let j index the entries in these vectors. We have \u03b1tj = cj\u03b2 t j . Typically c comprises binary entries that are equal to 0 or 1, but the integer constraint is often relaxed to require just non-negativity. We minimize a regularized loss function as follows for the best c and \u03b2t:t=1,\u00b7\u00b7\u00b7 ,T :\nmin \u03b2t,c\u22650 T\u2211 t=1 L(c,\u03b2t,Xt,yt) + \u03b31 T\u2211 t=1 ||\u03b2t||pp + \u03b32||c||kk (1)\nwhere L(\u00b7) is a loss function, e.g., the least squares loss for regression problems or the logistic loss for classification problems, ||\u03b2t||pp = \u2211d j=1 |\u03b2tj |p and ||c||kk = \u2211d j=1(cj)\nk, which are the `p-norm of \u03b2t to the power of p and the `k-norm of c to the power of k if p and k are positive integers. The tuning parameters \u03b31, \u03b32 are used to balance the empirical loss and regularizers. At optimality, if cj = 0, the j-th variable is removed for all tasks, and the corresponding row vector \u03b1j = 0; otherwise the j-th variable is selected for use in at least one of the \u03b1\u2019s. Then, a specific \u03b2t can rule out the j-th variable from task t if \u03b2tj = 0.\nIn particular, if both p = k = 2, Problem (1) becomes the formulation in [2] and if p = k = 1, Problem (1) becomes the formulation in [14]. Any other choices of p and k will derive into new formulations for MTFL. We first examine the theoretical properties of this entire family of methods, and then empirically study two new formulations by varying p and k."}, {"heading": "3 Theoretical Analysis", "text": "The joint `1,p regularized MTFL method minimizes \u2211T t=1 L(\u03b1t,Xt,yt) + \u03bb \u2211d j=1 ||\u03b1j ||p for the best \u03b1t:t=1,\u00b7\u00b7\u00b7 ,T where \u03bb is a tuning parameter. We now extend this formulation to allow more choices of regularizers. We introduce a new notation that is an operator applied to a vector, such\nas \u03b1j . The operator ||\u03b1j ||p/q = q \u221a\u2211T\nt=1 |\u03b1tj |p, p, q \u2265 0, which corresponds to the `p norm if p = q and both are positive integers. A joint regularized MTFL approach can solve the following optimization problem with pre-specified values of p, q and \u03bb, for the best parameters \u03b1t:t=1,\u00b7\u00b7\u00b7 ,T :\nmin \u03b1t T\u2211 t=1 L(\u03b1t,Xt,yt) + \u03bb d\u2211 j=1 \u221a ||\u03b1j ||p/q. (2)\nOur main result of this paper is (i) a theorem that establishes the equivalence between the models derived from solving Problem (1) and Problem (2) for properly chosen values of \u03bb, q, k, \u03b31 and \u03b32; and (ii) an analytical solution of Problem (1) for c which shows how the sparsity of the across-task component is relative to the sparsity of task-specific components.\nTheorem 1 Let \u03b1\u0302t be the optimal solution to Problem (2) and (\u03b2\u0302t, c\u0302) be the optimal solution to Problem (1). Then \u03b1\u0302t = diag(c\u0302)\u03b2\u0302t when \u03bb = 2 \u221a \u03b3 2\u2212 pkq 1 \u03b3 p kq 2 and q = k+p 2k (or k = p 2q\u22121 ).\nProof. The theorem holds by proving the following two Lemmas. The first lemma proves that the solution \u03b1\u0302t of Problem (2) also minimizes the following optimization problem:\nmin\u03b1t,\u03c3\u22650 \u2211T t=1 L(\u03b1t,Xt,yt) + \u00b51 \u2211d j=1 \u03c3 \u22121 j ||\u03b1j ||p/q + \u00b52 \u2211d j=1 \u03c3j , (3)\nand the optimal solution of Problem (3) also minimizes Problem (2) when proper values of \u03bb, \u00b51 and \u00b52 are chosen. The second lemma connects Problem (3) to our formulation (1). We show that the optimal \u03c3\u0302j is equal to (c\u0302j)k, and then the optimal \u03b2\u0302 can be computed from the optimal \u03b1\u0302.\nLemma 1 The solution sets of Problem (2) and Problem (3) are identical when \u03bb = 2\u221a\u00b51\u00b52.\nProof. First, we show that when \u03bb = 2\u221a\u00b51\u00b52, the optimal solution \u03b1\u0302tj of Problem (2) minimizes\nProblem (3) and the optimal \u03c3\u0302j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1\u0302j ||p/q . By the Cauchy-Schwarz inequality, the following inequality holds\n\u00b51 d\u2211 j=1 \u03c3\u22121j ||\u03b1 j ||p/q + \u00b52 d\u2211 j=1 \u03c3j \u2265 2 \u221a \u00b51\u00b52 d\u2211 j=1 \u221a ||\u03b1j ||p/q\nwhere the equality holds if and only if \u03c3j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1j ||p/q . Since Problems (3) and (2) use the exactly same loss function, when we set \u03c3\u0302j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1\u0302j ||p/q , Problems (3) and (2) have identical objective function if \u03bb = 2 \u221a \u00b51\u00b52. Hence the pair (A\u0302 = (\u03b1\u0302tj)jt, \u03c3\u0302 = (\u03c3\u0302j)j=1,\u00b7\u00b7\u00b7 ,d) minimizes Problem (3) as it entails the objective function to reach its lower bound.\nSecond, it can be proved that if the pair (A\u0302, \u03c3\u0302) minimizes Problem (3), then A\u0302 also minimizes Problem (2) by proof of contradiction. Suppose that A\u0302 does not minimize Problem (2), which means that there exists \u03b1\u0303j ( 6= \u03b1\u0302j for some j) that is an optimal solution to Problem (2) and achieves a lower objective value than \u03b1\u0302j . We set \u03c3\u0303j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1\u0303j ||p/q . The pair (A\u0303, \u03c3\u0303) is an optimal solution\nof Problem (3) as proved in the first paragraph. Then (A\u0303, \u03c3\u0303) will bring the objective function of Problem (3) to a lower value than that of (A\u0302, \u03c3\u0302), contradicting to the assumption that (A\u0302, \u03c3\u0302) be optimal to Problem (3). Hence, we have proved that Problems (3) and (2) have identical solutions when \u03bb = 2 \u221a \u00b51\u00b52.\nFrom the proof of Lemma (1), we also see that the optimal objective value of Problem (2) gives a lower bound to the objective of Problem (3). Let \u03c3j = (cj)k, k \u2208 R, k 6= 0 and \u03b1tj = cj\u03b2tj , an equivalent objective function of Problem (3) can be derived.\nLemma 2 The optimal solution (A\u0302, \u03c3\u0302) of Problem (3) is equivalent to the optimal solution (B\u0302, c\u0302) of\nProblem (1) where \u03b1\u0302tj = c\u0302j \u03b2\u0302 t j and \u03c3\u0302j = (c\u0302j) k when \u03b31 = \u00b5 kq 2kq\u2212p 1 \u00b5 kq\u2212p 2kq\u2212p 2 , \u03b32 = \u00b52, and k = p 2q\u22121 .\nProof. First, by proof of contradiction, we show that if \u03b1\u0302tj and \u03c3\u0302j optimize Problem (3), then c\u0302j = k \u221a \u03c3\u0302j and \u03b2\u0302tj = \u03b1\u0302tj c\u0302j optimize Problem (1). Denote the objectives of (1) and (3) by J (1) and J (3). Substituting \u03b2\u0302tj , c\u0302j for \u03b1\u0302 t j , \u03c3\u0302j in J (3) yields an objective function L(c\u0302, \u03b2\u0302t,Xt,yt) +\n\u00b51 \u2211d j=1 ||\u03b2\u0302 j ||p/q c\u0302(p\u2212kq)/qj + \u00b52 \u2211d j=1(c\u0302j) k. By the proof of Lemma 1, \u03c3\u0302j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1\u0302j ||p/q .\nHence, c\u0302j = ( \u00b51\u00b5 \u22121 2 ||\u03b2\u0302 j ||p/q ) q 2kq\u2212p . Applying the formula of c\u0302j and substituting \u00b51 and \u00b52 by\n\u03b31 and \u03b32 yield an objective identical to J (1). Suppose \u2203(\u03b2\u0303tj , c\u0303j)(6= (\u03b2\u0302tj , c\u0302j)) that minimize (1), and J (1)(\u03b2\u0303tj , c\u0303j) < J (1)(\u03b2\u0302tj , c\u0302j). Let \u03b1\u0303 t j = c\u0303j \u03b2\u0303 t j and substitute \u03b2\u0303 t j by \u03b1\u0303 t j/c\u0303j in J (1). By Cauchy-Schwarz\ninequality, we similarly have c\u0303j = (\u03b31\u03b3\u221212 \u2211T t=1(\u03b1\u0303 t j) p) 1 p+k . Thus, J (1)(\u03b1\u0303tj , c\u0303j) can be derived into"}, {"heading": "J (3)(\u03b1\u0303tj , c\u0303j). Let \u03c3\u0303j = (c\u0303j)", "text": "k, and we have J (3)(\u03b1\u0303tj , \u03c3\u0303j) < J\n(3)(\u03b1\u0302tj , \u03c3\u0302j), which contradicts with the optimality of (\u03b1\u0302tj , \u03c3\u0302j). Second, we similarly prove that if \u03b2\u0302 t j and c\u0302j optimize Problem (1), then \u03b1\u0302tj = c\u0302j \u03b2\u0302 t j and \u03c3\u0302j = (c\u0302j) k optimize Problem (3).\nNow, combining the results from the two Lemmas, we can derive that when \u03bb = 2 \u221a \u03b3 2\u2212 pkq 1 \u03b3 p kq\n2 and q = k+p2k , the optimal solutions to Problems (1) and (2) are equivalent. Solving Problem (1) will yield an optimal solution \u03b1\u0302 to Problem (2) and vice versa.\nTheorem 2 Let \u03b2\u0302t, t = 1, \u00b7 \u00b7 \u00b7 , T, be the optimal solutions of Problem (1), Let B\u0302 = [\u03b2\u03021, \u00b7 \u00b7 \u00b7 , \u03b2\u0302T ] and \u03b2\u0302 j denote the j-th row of the matrix B\u0302. Then,\nc\u0302j = (\u03b31/\u03b32) 1 k ||\u03b2\u0302 j || p 2kq\u2212p , (4)\nfor all j = 1, \u00b7 \u00b7 \u00b7 , d, is optimal to Problem (1).\nProof. This analytical formula can be directly derived from Lemma 1 and Lemma 2. When we set\n\u03c3\u0302j = (c\u0302j) k and \u03b1\u0302tj = c\u0302j \u03b2\u0302 t j in Problem (3), we obtain c\u0302j = ( \u00b51\u00b5 \u22121 2 ||\u03b2\u0302 j ||p/q ) q 2kq\u2212p . In the proof of Lemma 2, we obtain that \u00b51 = \u03b3 2kq\u2212p kq 1 \u03b3 p\u2212kq kq\n2 and \u00b52 = \u03b32. Substituting these formula into the formula of c yields the formula (4).\nBased on the derivation, for each pair of {p, q} and \u03bb in Problem (2), there exists an equivalent problem (1) with determined values of k, \u03b31 and \u03b32, and vice versa. Note that if q = p/2, the regularization term on \u03b1j in Problem (2) becomes the standard p-norm. In particular, if {p, q} = {2, 1} in Problem (2) as used in the methods of [15] and [1], the `2-norm regularizer is applied to \u03b1j . Then, this problem is equivalent to Problem (1) when k = 2 and \u03bb = 2 \u221a \u03b31\u03b32, the same formulation in [2]. If {p, q} = {1, 1}, the square root of `1-norm regularizer is applied to \u03b1j . Our theorem 1 shows that this problem is equivalent to the multi-level LASSO MTFL formulation [14] which is Problem (1) with k = 1 and \u03bb = 2 \u221a \u03b31\u03b32."}, {"heading": "4 Probabilistic Interpretation", "text": "In this section we show the proposed multiplicative formalism is related to the maximum a posteriori (MAP) solution of a probabilistic model. Let p(A|\u2206) be the prior distribution of the weight matrix A = [\u03b11, . . . ,\u03b1T ] = [\u03b11>, . . . ,\u03b1d>]> \u2208 Rd\u00d7T , where \u2206 denote the parameter of the prior. Then the a posteriori distribution of A can be calculated via Bayes rule as p(A|X,y,\u2206) \u221d p(A|\u2206) \u220fT t=1 p(yt|Xt,\u03b1t). Denote z \u223c GN (\u00b5, \u03c1, q) the univariate generalized normal distribution, with the density function p(z) = 12\u03c1\u0393(1+1/q) exp(\u2212 |z\u2212\u00b5|q \u03c1q ), in which \u03c1 > 0, q > 0, and \u0393(\u00b7) is the Gamma function [7]. Now let each element of A, \u03b1tj , follow a generalized normal prior, \u03b1tj \u223c GN (0, \u03b4j , q). Then with the i.i.d. assumption, the prior takes the form (also refer to [22] for a similar treatment)\np(A|\u2206) \u221d d\u220f j=1 T\u220f t=1 1 \u03b4j exp ( \u2212 |\u03b1tj |q \u03b4qj ) = d\u220f j=1 1 \u03b4Tj exp ( \u2212 \u2016\u03b1j\u2016qq \u03b4qj ) , (5)\nwhere \u2016\u00b7\u2016q denote vector q-norm. With an appropriately chosen likelihood function p(yt|Xt,\u03b1t) \u221d exp(\u2212L(\u03b1t,Xt,yt)), finding the MAP solution is equivalent to solving the following problem: minA,\u2206 J = \u2211T t=1 L(\u03b1t,Xt,yt) + \u2211d j=1 ( \u2016\u03b1j\u2016qq \u03b4qj +T ln \u03b4j ) . By setting the derivative of J with respect to \u03b4j to zero, we obtain:\nmin A\nJ = \u2211T\nt=1 L(\u03b1t,Xt,yt) + T \u2211d j=1 ln \u2016\u03b1j\u2016q. (6)\nNow let us look at the multiplicative nature of \u03b1tj with different q \u2208 [1,\u221e]. When q = 1, we have:\nd\u2211 j=1 ln \u2016\u03b1j\u20161 = d\u2211 j=1 ln ( T\u2211 t=1 |\u03b1tj | ) = d\u2211 j=1 ln ( T\u2211 t=1 |cj\u03b2tj | ) = d\u2211 j=1 ( ln |cj |+ ln T\u2211 t=1 |\u03b2tj | ) . (7)\nBecause of ln z \u2264 z \u2212 1 for any z > 0, we can optimize an upper bound of J in (6). We then have minA J1 = \u2211T t=1 L(\u03b1t,Xt,yt) + T \u2211d j=1 |cj | + T \u2211d j=1 \u2211T t=1 |\u03b2tj |, which is equivalent to the multiplicative formulation (1) where {p, k} = {1, 1}. For q > 1, we have: d\u2211 j=1 ln \u2016\u03b1j\u2016q = 1 q d\u2211 j=1 ln ( T\u2211 t=1 |cj\u03b2tj |q ) \u2264 1 q d\u2211 j=1 ln ( max{|c1|, . . . , |cd|}q \u00b7 T\u2211 t=1 |\u03b2tj |q ) (8)\n= d\u2211 j=1 ln \u2016c\u2016\u221e + 1 q d\u2211 j=1 ln T\u2211 t=1 |\u03b2tj |q \u2264 d\u2016c\u2016\u221e + 1 q T\u2211 t=1 \u2016\u03b2t\u2016qq \u2212 (d+ d q ). (9)\nSince vector norms satisfy \u2016z\u2016\u221e \u2264 \u2016z\u2016k for any vector z and k \u2265 1, these inequalities lead to an upper bound of J in (6), i.e., minA Jq,k = \u2211T t=1 L(\u03b1t,Xt,yt) + Td\u2016c\u2016k + T q \u2211T t=1 \u2016\u03b2t\u2016qq , which is equivalent to the general multiplicative formulation in (1)."}, {"heading": "5 Optimization Algorithm", "text": "Alternating optimization algorithms have been used in both of the early methods [2, 14] to solve Problem (1) which alternate between solving two subproblems: solve for \u03b2t with fixed c; solve for c with fixed \u03b2t. The convergence property of such an alternating algorithm has been analyzed in [2] that it converges to a local minimizer. However, both subproblems in the existing methods can only be solved using iterative algorithms such as gradient descent, linear or quadratic program solvers. We design a new alternating optimization algorithm that utilizes the property that both Problems (1) and (2) are equivalent to Problem (3) used in our proof and we derive a closed-form solution for c for the second subproblem. The following theorem characterizes this result.\nTheorem 3 For any given values of \u03b1t:t=1,\u00b7\u00b7\u00b7 ,T , the optimal \u03c3 of Problem (3) when \u03b1t:t=1,\u00b7\u00b7\u00b7 ,T are fixed to the given values can be computed by \u03c3j = \u03b3 1\u2212 p2kq 1 \u03b3 1 2\u2212 p 2kp 2 2q \u221a\u2211T t=1(\u03b1 t j) p, j = 1, \u00b7 \u00b7 \u00b7 , d.\nProof. By the Cauchy-Schwarz inequality and the same argument used in the proof of Lemma 1, we obtain that the best \u03c3 for a given set of \u03b1t:t=1,\u00b7\u00b7\u00b7 ,T is \u03c3j = \u00b5 1 2 1 \u00b5 \u2212 12 2 \u221a ||\u03b1j ||p/q . We also know that \u00b51 and \u00b52 are chosen in such a way that \u03b31 = \u00b5 kq 2kq\u2212p 1 \u00b5 kq\u2212p 2kq\u2212p 2 and \u03b32 = \u00b52. This is equivalent to have \u00b51 = \u03b3 2kq\u2212p kq 1 \u03b3 p\u2212kq kq 2 and \u00b52 = \u03b32. Substituting them into the formula of \u03c3 yields the result.\nNow, in the algorithm to solve Problem (1), we solve the first subproblem to obtain a new iterate \u03b2newt , then we use the current value of c, c old, to compute the value of \u03b1newt = diag(c old)\u03b2newt , which is then used to compute \u03c3j according to the formula in Theorem 3. Then, c is computed as cj = k \u221a \u03c3j , j = 1, \u00b7 \u00b7 \u00b7 , d. The overall procedure is summarized in Algorithm 1.\nAlgorithm 1 Alternating optimization for multiplicative MTFL Input: Xt, yt, t = 1, \u00b7 \u00b7 \u00b7 , T , as well as \u03b31, \u03b32, p and k Initialize: cj = 1, \u2200j = 1, \u00b7 \u00b7 \u00b7 , d repeat\n1. Convert Xtdiag(cs\u22121)\u2192 X\u0303t, \u2200 t = 1, \u00b7 \u00b7 \u00b7 , T for t = 1, \u00b7 \u00b7 \u00b7 , T do\nSolve min\u03b2t L(\u03b2t, X\u0303t,yt) + \u03b31||\u03b2t|| p p for \u03b2 s t\nend for 2. Compute \u03b1st = diag(c(s\u22121))\u03b2 s t , and compute c s as csj = k \u221a \u03c3j where \u03c3j is computed\naccording to the formula in Theorem 3. until max(|(\u03b1tj)s \u2212 (\u03b1tj)s\u22121|) < Output: \u03b1t, c and \u03b2t, t = 1, \u00b7 \u00b7 \u00b7 , T\nAlgorithm 1 can be used to solve the entire family of methods characterized by Problem (1). The first subproblem involves convex optimization if a convex loss function is chosen and p \u2265 1, and can be solved separately for individual tasks using single task learning. The second subproblem is analytically solved by a formula that guarantees that Problem (1) reaches a lower bound for the current \u03b1t. In this paper, the least squares and logistic regression losses are used and both of them are convex and differentiable loss functions. When convex and differentiable losses are used, theoretical results in [19] can be used to prove the convergence of the proposed algorithm. We choose to monitor the maximum norm of the A matrix to terminate the process, but it can be replaced by any other suitable termination criterion. Initialization can be important for this algorithm, and we suggest starting with c = 1, which considers all features initially in the learning process."}, {"heading": "6 Two New Formulations", "text": "The two existing methods discussed in [2, 14] use p = k in their formulations, which renders \u03b2tj and cj the same amount of shrinkage. To explore other feature sharing patterns among tasks, we propose two new formulations where p 6= k. For the common choices of p and k, the relation between the optimal c and \u03b2 can be computed according to Theorem 2, and is summarized in Table 1.\n1. When the majority of the features is not relevant to any of the tasks, it requires a sparsityinducing norm on c. However, within the relevant features, many features are shared between tasks. In other words, the features used in each task are not sparse relative to all the features selected by c, which requires a non-sparsity-inducing norm on \u03b2. Hence, we use `1 norm on c and `2 norm on all \u03b2\u2019s in Formulation (1). This formulation is equivalent to the joint regularization method of\nmin\u03b1t \u2211T t=1 L(\u03b1t,Xt,yt) + \u03bb \u2211d j=1 3 \u221a\u2211T t=1(\u03b1 t j) 2 where \u03bb = 2\u03b3 1 3 1 \u03b3 2 3 2 .\n2. When many or all features are relevant to the given tasks, it may prefer the `2 norm penalty on c. However, only a limited number of features are shared between tasks, i.e., the features used by individual tasks are sparse with respect to the features selected as useful across tasks by c. We can impose the `1 norm penalty on \u03b2. This formulation is equivalent to the joint regularization method\nof min\u03b1t \u2211T t=1 L(\u03b1t,Xt,yt) + \u03bb \u2211d j=1 3 \u221a(\u2211T t=1 |\u03b1tj | )2 where \u03bb = 2\u03b3 2 3 1 \u03b3 1 3 2 ."}, {"heading": "7 Experiments", "text": "In this section, we empirically evaluate the performance of the proposed multiplicative MTFL with the four parameter settings listed in Table 1 on synthetic and real-world data for both classification and regression problems. The first two settings (p, k) = (2, 2), (1, 1) give the same methods respectively in [2, 14], and the last two settings correspond to our new formulations. The least squares and logistic regression losses are used, respectively, for regression and classification problems. We focus on the understanding of the shrinkage effects created by the different choices of regularizers in multiplicative MTFL. These methods are referred to as MMTFL and are compared with the dirty model (DMTL) [9] and robust MTFL (rMTFL) [6] that use the additive decomposition.\nThe first subproblem of Algorithm 1 was solved using CPLEX solvers and single task learning in the initial first subproblem served as baseline. We used respectively 25%, 33% and 50% of the available data in each data set for training and the rest data for test. We repeated the random split 15 times and reported the averaged performance. For each split, the regularization parameters of each method were tuned by a 3-fold cross validation within the training data. The regression performance was measured by the coefficient of determination, denoted as R2, which was computed as 1 minus the ratio of the sum of squared residuals and the total sum of squares. The classification performance was measured by the F1 score, which was the harmonic mean of precision and recall.\nSynthetic Data. We created two synthetic data sets which included 10 and 20 tasks, respectively. For each task, we created 200 examples using 100 features with pre-defined combination weights \u03b1. Each feature was generated following the N(0,1) distribution. We added noise and computed yt = Xt\u03b1t + t for each task t where the noise followed a distribution N(0, 1). We put the different tasks\u2019 \u03b1\u2019s together as rows in Figure 1. The values of \u03b1\u2019s were specified in such a way for us to explore how the structure of feature sharing influences the multitask learning models when various regularizers are used. In particular, we illustrate the cases where the two newly proposed formulations outperformed other methods.\nSynthetic Data 1 (D1). As shown in Figure 1a, 40% of components in all \u03b1\u2019s were set to 0, and these features were irrelevant to all tasks. The rest features were used in every task\u2019s model and hence these models were sparse with respect to all of the features, but not sparse with respect to the selected features. This was the assumption for the early joint regularized methods to work. To learn this feature sharing structure, however, we observed that the amount of shrinkage needed would be different for c and \u03b2. This case might be in favor of the `1 norm penalty on c.\nSynthetic Data 2 (D2). The designed parameter matrix is shown in Figure 1b where tasks were split into 6 groups. Five features were irrelevant to all tasks, 10 features were used by all tasks, and each\nof the remaining 85 features was used by only 1 or 2 groups. The neighboring groups of tasks in Figure 1b shared only 7 features besides those 10 common features. Non-neighboring tasks did not share additional features. We expected c to be non-sparse. However, each task only used very few features with respect to all available features, and hence each \u03b2 should be sparse.\nFigure 1 shows the parameter matrices (with columns representing features for illustrative convenience) learned by different methods using 33% of the available examples in each data set. We can clearly see that MMTFL(2,1) performs the best for Synthetic data D1. This result suggests that the classic choices of using `2 or `1 penalty on both c and \u03b2 (corresponding to early joint regularized methods) might not always be optimal. MMTFL(1,2) is superior for Synthetic data D2, where each model shows strong feature sparsity but few features can be removed if all tasks are considered. Table 2 summarizes the performance comparison where the best performance is highlighted in bold font. Note that the feature sharing patterns may not be revealed by the recent methods on clustered multitask learning that cluster tasks into groups [10, 8, 23] because no cluster structure is present in Figure 1b, for instance. Rather, the sharing pattern in Figure 1b is in the shape of staircase.\nReal-world Data. Two benchmark data sets, the Sarcos [1] and the USPS data sets [10], were used for regression and classification tests respectively. The Sarcos data set has 48,933 observations and each observation (example) has 21 features. Each task is to map from the 21 features to one of the 7 consecutive torques of the Sarcos robot arm. We randomly selected 2000 examples for use in each task. USPS handwritten digits data set has 2000 examples and 10 classes as the digits from 0 to 9. We first used principle component analysis to reduce the feature dimension to 87. To create binary classification tasks, we randomly chose images from the other 9 classes to be the negative examples. Table 2 provides the performance of the different methods on these two data sets, which shows the effectiveness of MMTFL(2,1) and MMTFL(1,2)."}, {"heading": "8 Conclusion", "text": "In this paper, we study a general framework of multiplicative multitask feature learning. By decomposing the model parameter of each task into a product of two components: the across-task feature indicator and task-specific parameters, and applying different regularizers to the two components, we can select features for individual tasks and also search for the shared features among tasks. We have studied the theoretical properties of this framework when different regularizers are applied and found that this family of methods creates models equivalent to those of the joint regularized MTL methods but with a more general form of regularization. Further, an analytical formula is derived for the across-task component as related to the task-specific component, which shed light on the different shrinkage effects in the various regularizers. An efficient algorithm is derived to solve the entire family of methods and also tested in our experiments. Empirical results on synthetic data clearly show that there may not be a particular choice of regularizers that is universally better than other choices. We empirically show a few feature sharing patterns that are in favor of two newly-proposed choices of regularizers, which is confirmed on both synthetic and real-world data sets."}, {"heading": "Acknowledgements", "text": "Jinbo Bi and her students Xin Wang and Jiangwen Sun were supported by NSF grants IIS-1320586, DBI-1356655, IIS-1407205, and IIS-1447711."}], "references": [{"title": "Multi-task feature learning", "author": ["A. Argyriou", "T. Evgeniou", "M. Pontil"], "venue": "In Proceedings of NIPS\u201907,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2007}, {"title": "An improved multi-task learning approach with applications in medical diagnosis", "author": ["J. Bi", "T. Xiong", "S. Yu", "M. Dundar", "R.B. Rao"], "venue": "In Proceedings of ECML\u201908,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2008}, {"title": "Integrating low-rank and group-sparse structures for robust multitask learning", "author": ["J. Chen", "J. Zhou", "J. Ye"], "venue": "In Proceedings of KDD\u201911,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Regularized multi\u2013task learning", "author": ["T. Evgeniou", "M. Pontil"], "venue": "In Proceedings of KDD\u201904,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2004}, {"title": "Multi-stage multi-task feature learning", "author": ["P. Gong", "J. Ye", "C. Zhang"], "venue": "In Proceedings of NIPS\u201912,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Robust multi-task feature learning", "author": ["P. Gong", "J. Ye", "C. Zhang"], "venue": "In Proceedings of KDD\u201912,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Multivariate \u03b8-generalized normal distributions", "author": ["I.R. Goodman", "S. Kotz"], "venue": "Journal of Multivariate Analysis,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1973}, {"title": "Clustered multi-task learning: a convex formulation", "author": ["L. Jacob", "B. Francis", "J.-P. Vert"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2008}, {"title": "A dirty model for multi-task learning", "author": ["A. Jalali", "S. Sanghavi", "C. Ruan", "P.K. Ravikumar"], "venue": "In Proceedings of NIPS\u201910,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2010}, {"title": "Learning with whom to share in multi-task feature learning", "author": ["Z. Kang", "K. Grauman", "F. Sha"], "venue": "In Proceedings of ICML\u201911,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Learning task grouping and overlap in multi-task learning", "author": ["A. Kumar", "H. Daume III"], "venue": "In Proceedings of ICML\u201912,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Adaptive multi-task lasso: with application to eQTL detection", "author": ["S. Lee", "J. Zhu", "E. Xing"], "venue": "In Proceedings of NIPS\u201910,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Multi-task feature learning via efficient `1,2-norm minimization", "author": ["J. Liu", "S. Ji", "J. Ye"], "venue": "In Proceedings of UAI\u201909,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2009}, {"title": "Multi-level lasso for sparse multi-task regression", "author": ["A. Lozano", "G. Swirszcz"], "venue": "In Proceedings of ICML\u201912,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Multi-task feature selection", "author": ["G. Obozinski", "B. Taskar"], "venue": "Technical report, Statistics Department, UC Berkeley,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2006}, {"title": "Flexible modeling of latent task structures in multitask learning", "author": ["A. Passos", "P. Rai", "J. Wainer", "H. Daume III"], "venue": "In Proceedings of ICML\u201912,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "An efficient projection for l1,infinity regularization", "author": ["A. Quattoni", "X. Carreras", "M. Collins", "T. Darrell"], "venue": "In Proceedings of ICML\u201909,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Infinite predictor subspace models for multitask learning", "author": ["P. Rai", "H. Daume"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2010}, {"title": "Convergence of a block coordinate descent method for nondifferentiable minimization", "author": ["P. Tseng"], "venue": "Journal Optimization Theory Applications,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Simultaneous variable selection", "author": ["B.A. Turlach", "W.N. Wenables", "S.J. Wright"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2005}, {"title": "Probabilistic joint feature selection for multi-task learning", "author": ["T. Xiong", "J. Bi", "B. Rao", "V. Cherkassky"], "venue": "In Proceedings of SIAM International Conference on Data Mining (SDM),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2006}, {"title": "Probabilistic multi-task feature selection", "author": ["Y. Zhang", "D.-Y. Yeung", "Q. Xu"], "venue": "In Proceedings of NIPS\u201910,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2010}, {"title": "Clustered multi-task learning via alternating structure optimization", "author": ["J. Zhou", "J. Chen", "J. Ye"], "venue": "In Proceedings of NIPS\u201911,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}, {"title": "Exclusive lasso for multi-task feature selection", "author": ["Y. Zhou", "R. Jin", "S.C. Hoi"], "venue": "In Proceedings of UAI\u201910,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2010}], "referenceMentions": [{"referenceID": 17, "context": "Either the task parameters can be projected to explore the latent common substructure [18], or a shared low-dimensional representation of data can be formed by feature learning [10].", "startOffset": 86, "endOffset": 90}, {"referenceID": 9, "context": "Either the task parameters can be projected to explore the latent common substructure [18], or a shared low-dimensional representation of data can be formed by feature learning [10].", "startOffset": 177, "endOffset": 181}, {"referenceID": 15, "context": "Recent methods either explore the latent basis that is used to develop the entire set of tasks, or learn how to group the tasks [16, 11], or identify if certain tasks are outliers to other tasks [6].", "startOffset": 128, "endOffset": 136}, {"referenceID": 10, "context": "Recent methods either explore the latent basis that is used to develop the entire set of tasks, or learn how to group the tasks [16, 11], or identify if certain tasks are outliers to other tasks [6].", "startOffset": 128, "endOffset": 136}, {"referenceID": 5, "context": "Recent methods either explore the latent basis that is used to develop the entire set of tasks, or learn how to group the tasks [16, 11], or identify if certain tasks are outliers to other tasks [6].", "startOffset": 195, "endOffset": 198}, {"referenceID": 11, "context": "These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix.", "startOffset": 75, "endOffset": 95}, {"referenceID": 12, "context": "These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix.", "startOffset": 75, "endOffset": 95}, {"referenceID": 14, "context": "These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix.", "startOffset": 75, "endOffset": 95}, {"referenceID": 21, "context": "These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix.", "startOffset": 75, "endOffset": 95}, {"referenceID": 23, "context": "These methods employ a regularizer based on the so-called `1,p matrix norm [12, 13, 15, 22, 24] that is the sum of the `p norms of the rows in a matrix.", "startOffset": 75, "endOffset": 95}, {"referenceID": 14, "context": "Typical choices for p are 2 [15, 4] and\u221e [20] which are used in the very early MTFL methods.", "startOffset": 28, "endOffset": 35}, {"referenceID": 3, "context": "Typical choices for p are 2 [15, 4] and\u221e [20] which are used in the very early MTFL methods.", "startOffset": 28, "endOffset": 35}, {"referenceID": 19, "context": "Typical choices for p are 2 [15, 4] and\u221e [20] which are used in the very early MTFL methods.", "startOffset": 41, "endOffset": 45}, {"referenceID": 12, "context": "Effective algorithms have since then been developed for the `1,2 [13] and `1,\u221e [17] regularization.", "startOffset": 65, "endOffset": 69}, {"referenceID": 16, "context": "Effective algorithms have since then been developed for the `1,2 [13] and `1,\u221e [17] regularization.", "startOffset": 79, "endOffset": 83}, {"referenceID": 21, "context": "Later, the `1,p norm is generalized to include 1 < p \u2264 \u221e with a probabilistic interpretation that the resultant MTFL method solves a relaxed optimization problem with a generalized normal prior for all tasks [22].", "startOffset": 208, "endOffset": 212}, {"referenceID": 4, "context": "Recent research applies the capped `1,1 norm as a nonconvex joint regularizer [5].", "startOffset": 78, "endOffset": 81}, {"referenceID": 8, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 125, "endOffset": 134}, {"referenceID": 2, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 125, "endOffset": 134}, {"referenceID": 5, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 125, "endOffset": 134}, {"referenceID": 20, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 153, "endOffset": 164}, {"referenceID": 1, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 153, "endOffset": 164}, {"referenceID": 13, "context": "To overcome this limitation, one of the most effective strategies is to decompose the model parameters into either summation [9, 3, 6] or multiplication [21, 2, 14] of two components with different regularizers applied to the two components.", "startOffset": 153, "endOffset": 164}, {"referenceID": 8, "context": "Specifically, for the methods that decompose the parameter matrix into summation of two matrices, the dirty model in [9] employs `1,1 and `1,\u221e regularizers to the two components.", "startOffset": 117, "endOffset": 120}, {"referenceID": 2, "context": "A robust MTFL method in [3] uses the trace norm on one component for mining a low-rank structure shared by tasks and a column-wise `1,2-norm on the other component for identifying task outliers.", "startOffset": 24, "endOffset": 27}, {"referenceID": 5, "context": "Another method applies the `1,2-norm both row-wisely to one component and column-wisely to the other [6].", "startOffset": 101, "endOffset": 104}, {"referenceID": 1, "context": "These methods either use the `2-norm penalty on both of the component vectors [2], or the sparse `1-norm on the two components (i.", "startOffset": 78, "endOffset": 81}, {"referenceID": 13, "context": ", multi-level LASSO) [14].", "startOffset": 21, "endOffset": 25}, {"referenceID": 13, "context": "The multi-level LASSO method has been analytically compared to the dirty model [14], showing that the multiplicative decomposition creates better shrinkage on the global and task-specific parameters.", "startOffset": 79, "endOffset": 83}, {"referenceID": 1, "context": "This general form includes all early methods that represent model parameters as a product of two components [2, 14].", "startOffset": 108, "endOffset": 115}, {"referenceID": 13, "context": "This general form includes all early methods that represent model parameters as a product of two components [2, 14].", "startOffset": 108, "endOffset": 115}, {"referenceID": 1, "context": "Unlike the existing methods [2, 14] where the same kind of vector norm is applied to both components, the shrinkage of the global and task-specific parameters differ in the new formulations.", "startOffset": 28, "endOffset": 35}, {"referenceID": 13, "context": "Unlike the existing methods [2, 14] where the same kind of vector norm is applied to both components, the shrinkage of the global and task-specific parameters differ in the new formulations.", "startOffset": 28, "endOffset": 35}, {"referenceID": 1, "context": "In particular, if both p = k = 2, Problem (1) becomes the formulation in [2] and if p = k = 1, Problem (1) becomes the formulation in [14].", "startOffset": 73, "endOffset": 76}, {"referenceID": 13, "context": "In particular, if both p = k = 2, Problem (1) becomes the formulation in [2] and if p = k = 1, Problem (1) becomes the formulation in [14].", "startOffset": 134, "endOffset": 138}, {"referenceID": 14, "context": "In particular, if {p, q} = {2, 1} in Problem (2) as used in the methods of [15] and [1], the `2-norm regularizer is applied to \u03b1 .", "startOffset": 75, "endOffset": 79}, {"referenceID": 0, "context": "In particular, if {p, q} = {2, 1} in Problem (2) as used in the methods of [15] and [1], the `2-norm regularizer is applied to \u03b1 .", "startOffset": 84, "endOffset": 87}, {"referenceID": 1, "context": "Then, this problem is equivalent to Problem (1) when k = 2 and \u03bb = 2 \u221a \u03b31\u03b32, the same formulation in [2].", "startOffset": 101, "endOffset": 104}, {"referenceID": 13, "context": "Our theorem 1 shows that this problem is equivalent to the multi-level LASSO MTFL formulation [14] which is Problem (1) with k = 1 and \u03bb = 2 \u221a \u03b31\u03b32.", "startOffset": 94, "endOffset": 98}, {"referenceID": 6, "context": "Denote z \u223c GN (\u03bc, \u03c1, q) the univariate generalized normal distribution, with the density function p(z) = 1 2\u03c1\u0393(1+1/q) exp(\u2212 |z\u2212\u03bc| \u03c1q ), in which \u03c1 > 0, q > 0, and \u0393(\u00b7) is the Gamma function [7].", "startOffset": 190, "endOffset": 193}, {"referenceID": 21, "context": "assumption, the prior takes the form (also refer to [22] for a similar treatment)", "startOffset": 52, "endOffset": 56}, {"referenceID": 1, "context": "Alternating optimization algorithms have been used in both of the early methods [2, 14] to solve Problem (1) which alternate between solving two subproblems: solve for \u03b2t with fixed c; solve for c with fixed \u03b2t.", "startOffset": 80, "endOffset": 87}, {"referenceID": 13, "context": "Alternating optimization algorithms have been used in both of the early methods [2, 14] to solve Problem (1) which alternate between solving two subproblems: solve for \u03b2t with fixed c; solve for c with fixed \u03b2t.", "startOffset": 80, "endOffset": 87}, {"referenceID": 1, "context": "The convergence property of such an alternating algorithm has been analyzed in [2] that it converges to a local minimizer.", "startOffset": 79, "endOffset": 82}, {"referenceID": 18, "context": "When convex and differentiable losses are used, theoretical results in [19] can be used to prove the convergence of the proposed algorithm.", "startOffset": 71, "endOffset": 75}, {"referenceID": 1, "context": "The two existing methods discussed in [2, 14] use p = k in their formulations, which renders \u03b2 j and cj the same amount of shrinkage.", "startOffset": 38, "endOffset": 45}, {"referenceID": 13, "context": "The two existing methods discussed in [2, 14] use p = k in their formulations, which renders \u03b2 j and cj the same amount of shrinkage.", "startOffset": 38, "endOffset": 45}, {"referenceID": 1, "context": "The first two settings (p, k) = (2, 2), (1, 1) give the same methods respectively in [2, 14], and the last two settings correspond to our new formulations.", "startOffset": 85, "endOffset": 92}, {"referenceID": 13, "context": "The first two settings (p, k) = (2, 2), (1, 1) give the same methods respectively in [2, 14], and the last two settings correspond to our new formulations.", "startOffset": 85, "endOffset": 92}, {"referenceID": 8, "context": "These methods are referred to as MMTFL and are compared with the dirty model (DMTL) [9] and robust MTFL (rMTFL) [6] that use the additive decomposition.", "startOffset": 84, "endOffset": 87}, {"referenceID": 5, "context": "These methods are referred to as MMTFL and are compared with the dirty model (DMTL) [9] and robust MTFL (rMTFL) [6] that use the additive decomposition.", "startOffset": 112, "endOffset": 115}, {"referenceID": 9, "context": "Note that the feature sharing patterns may not be revealed by the recent methods on clustered multitask learning that cluster tasks into groups [10, 8, 23] because no cluster structure is present in Figure 1b, for instance.", "startOffset": 144, "endOffset": 155}, {"referenceID": 7, "context": "Note that the feature sharing patterns may not be revealed by the recent methods on clustered multitask learning that cluster tasks into groups [10, 8, 23] because no cluster structure is present in Figure 1b, for instance.", "startOffset": 144, "endOffset": 155}, {"referenceID": 22, "context": "Note that the feature sharing patterns may not be revealed by the recent methods on clustered multitask learning that cluster tasks into groups [10, 8, 23] because no cluster structure is present in Figure 1b, for instance.", "startOffset": 144, "endOffset": 155}, {"referenceID": 0, "context": "Two benchmark data sets, the Sarcos [1] and the USPS data sets [10], were used for regression and classification tests respectively.", "startOffset": 36, "endOffset": 39}, {"referenceID": 9, "context": "Two benchmark data sets, the Sarcos [1] and the USPS data sets [10], were used for regression and classification tests respectively.", "startOffset": 63, "endOffset": 67}], "year": 2016, "abstractText": "We investigate a general framework of multiplicative multitask feature learning which decomposes each task\u2019s model parameters into a multiplication of two components. One of the components is used across all tasks and the other component is task-specific. Several previous methods have been proposed as special cases of our framework. We study the theoretical properties of this framework when different regularization conditions are applied to the two decomposed components. We prove that this framework is mathematically equivalent to the widely used multitask feature learning methods that are based on a joint regularization of all model parameters, but with a more general form of regularizers. Further, an analytical formula is derived for the across-task component as related to the taskspecific component for all these regularizers, leading to a better understanding of the shrinkage effect. Study of this framework motivates new multitask learning algorithms. We propose two new learning formulations by varying the parameters in the proposed framework. Empirical studies have revealed the relative advantages of the two new formulations by comparing with the state of the art, which provides instructive insights into the feature learning problem with multiple tasks.", "creator": "LaTeX with hyperref package"}}}