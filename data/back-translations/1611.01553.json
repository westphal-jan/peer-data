{"id": "1611.01553", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Nov-2016", "title": "QBF Solving by Counterexample-guided Expansion", "abstract": "We are introducing a novel generalization of Counterexample-Guided Inductive Synthesis (CEGIS) and instantiating it to obtain a novel, competitive algorithm for solving quantified Boolean formulas (QBF). Current QBF solvers, based on contrast-based expansion, use a recursive approach that is poorly scaled with the number of quantifier changes. Our generalization of CEGIS eliminates the need for this recursive approach, and we instantiate it to obtain a simple and efficient algorithm for the QBF solution. Finally, this research is supported by a competitive but simple implementation of the algorithm that allows us to study the practical implications of our algorithm design decisions along with various optimizations.", "histories": [["v1", "Fri, 4 Nov 2016 22:08:40 GMT  (68kb,D)", "https://arxiv.org/abs/1611.01553v1", "pre-print, submitted at TACAS 2017"], ["v2", "Tue, 8 Nov 2016 15:26:12 GMT  (68kb,D)", "http://arxiv.org/abs/1611.01553v2", "pre-print, submitted at TACAS 2017, source code available atthis https URL"], ["v3", "Fri, 25 Nov 2016 17:48:36 GMT  (74kb,D)", "http://arxiv.org/abs/1611.01553v3", "pre-print, submitted at TACAS 2017, source code available atthis https URL"]], "COMMENTS": "pre-print, submitted at TACAS 2017", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["roderick bloem", "nicolas braud-santoni", "vedad hadzic"], "accepted": false, "id": "1611.01553"}, "pdf": {"name": "1611.01553.pdf", "metadata": {"source": "CRF", "title": "QBF Solving by Counterexample-guided Expansion", "authors": ["Roderick Bloem", "Nicolas Braud-Santoni", "Vedad Hadzic"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Quantified Boolean Formulas (QBFs) are propositional logic formulas with existential and universal quantification. We consider QBF written in the prenex normal form \u2203x0.\u2200y0. . . .\u2200yn.\u2203xn+1.Q(x0, . . . , xn+1, y0, . . . , yn), with xi and yi representing disjoint sets of Boolean variables, and Q a propositional formula; any QBF formula can be easily and efficiently converted to prenex normal form.\nJust as deciding satisfiability of a propositional-logic formula is the prototypical NP-complete problem, QBF satisfiability is the prototypical PSPACE-complete problem. Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16]. Research into engineering QBF solvers has seen considerable progress since initial work in the mid-nineties [10,22], with most solvers either implementing a quantified version of CDCL (e.g., [11,24,33]) or an expansion-based approach (e.g. [4]).\nSince the first complete solver in 1998, based on DPLL [10], an incredible amount of work has gone into QBF: an analogue of propositional CDCL was discovered in 2002 [17, 23], the very same year as expansion-based solving [2] was discovered. Expansion-based solving has known tremendous success, and is the basis for counterexample-guided methods such as RAReQS [20], a state-of-the-art expansionbased solver. In 2016, a completely new approach to QBF solving, based on Skolem\n? This work was supported by the Austrian Science Fund (FWF) through the Logic in Computer Science doctoral college (W1255-N23) and project RiSE (S11406-N23).\nar X\niv :1\n61 1.\n01 55\n3v 3\n[ cs\n.L O\n] 2\n5 N\nov 2\n01 6\nfunction computation, was introduced [28]. Still, expansion-based methods remain prevalent.\nIn this paper, we follow an expansion-based approach to solving QBFs that is inspired by counterexample-guided inductive synthesis (CEGIS) [1, 32]. CEGIS attempts to learn an input-output relation using a learning algorithm interacting with a verification oracle. It keeps a database of examples of input-output pairs. The learning algorithm proposes a candidate relation that is consistent with the examples in the database and sends it to the oracle (or gives up if no such relation can be found). The oracle adds counterexample to the candidate to the database (or declares that the proposed relation is correct).\nWe describe a novel relaxation of CEGIS that relies on an approximate verifier, i.e. a verifier which may produce spurious counterexamples: this makes the verifier simpler and faster. In exchange, the learner must provide values which prove that the candidate solution fulfils all the counterexamples produced so far.\nThe advantage of our approach is two-fold. First, it is extremely simple: the description of the algorithm is extremely small, and so is its proof of correctness. Second, it is efficient: our prototype implementation does not rely on any formula optimisation or implementation technique not described in this paper, yet it is competitive with state-of-the-art QBF solvers.\nOur approach is similar to the one implemented in the very successful solver RAReQS [20], which instantiates the outer existential quantifiers using a counterexampleguided approach. When solving a formula of the form \u2203x0\u2200y0 . . . \u2200yn\u2203xn+1.Q, RAReQS obtains the counterexample using a recursive call for \u2203y0\u2200x1 . . . \u2203yn\u2200xn+1.\u00acQ. To show that our approach is not simply a reformulation of RAReQS, we introduce in Section 4.3 a class of simple formulas on which RAReQS needs an exponential number of SAT queries while our approach needs only a small, constant number.\nWe have implemented our approach in a tool called alejtehad . We show that alejtehad is competitive with RAReQS, one of the best current QBF solvers, and that it is significantly outperforms RAReQS in some classes of benchmarks, especially those with high quantifier alternation depth."}, {"heading": "2 Counterexample-Guided Inductive Synthesis (CEGIS)", "text": ""}, {"heading": "2.1 Concepts", "text": "Counterexample-guided inductive synthesis (CEGIS) is a generic framework, initially devised in the context of syntax-guided synthesis [1], involving iterations between two components:\n\u2013 The verifier provides, given a candidate solution, a counterexample that disproves it, or (correctly) proves the solution to be valid. \u2013 The learner generates candidate solutions that are consistent with all counterexamples provided so far, or provides a (correct) unrealisability answer.\nAlthough the worst-case complexity guarantees usually devolve to the size of the set of counterexamples or of candidate solution, this approach has been wildly successful in practice [20,29,32].\nIn a QBF setting, the standard approach is to consider that the solutions to be learned are values for the first quantifier; they must make the formula true, if the quantifier is \u2203, or falsify it in the case of the \u2200 quantifier.\nHowever, one issue surfaces immediately when dealing with problems involving multiple quantifier alternations: the problem solved by the verifier is only marginally easier than the original one in practice.\nFor example, \u2203x. \u2200y.\u2203z.Q(x, y, z) is a type of QBF problem that occurs in synthesis of resilient systems, program diagnosis and repair, finite-state games, ... There, the verifier\u2019s problem is almost as hard as the original problem:\n\u2203y.\u2200z.\u00acQ(x, y, z)\nOne of the earliest applications of CEGIS1 to QBF solving, RAReQS [20], introduced a recursive approach where the whole solver is used as a verifier, each nested solver dealing with one block of quantifiers.\nThere has been many refinements of this technique since RAReQS, from RAReQS\u2019 recent reimplementation from scratch for 2-QBF [3] to the clause abstraction performed by CAQE [29]. However, all of those share RAReQS\u2019 recursive approach to deal with quantifier alternation. This is an issue for efficiency, for multiple reasons:\n\u2013 Performance degrades quickly as the quantifier depth increases, even on trivial instances, as shown in Section 4.3 and Section 5. \u2013 Incremental solving, where SAT problems are constructed lazily by adding new conjuncts and solved without starting from scratch, becomes exceedingly difficult when sub-formulas change based on decisions made at arbitrary depths in the nested solvers. \u2013 The solver does not share information deduced at different quantifier depths, resulting in duplicate work. \u2013 The solver is forced, at any given point, to make decisions on variables belonging to a specific quantifier depth; we exploit this in Theorem 3 to highlight algorithmic differences between our approach and RAReQS.\nAlternatively, the candidate solutions that are being discovered could be Skolem functions describing the values taken by the existentially-quantified variables. In that case, the natural form for counterexamples are traces: assignment of values to the universally-quantified variables that falsify the formula (under a given choice of Skolem functions).\nHowever, this introduces a major difficulty: synthesis of Boolean (Skolem) functions is a hard problem on its own, that in general cannot be efficiently reduced to SAT (or a similarly-efficient decision procedure). Moreover, this would replace a situation where the learning is easy and the verification hard, with a problem where the learning is hard and the verification easy.\n1 Many of those are described in terms of Counterexample-Guided Abstraction Refinement (CEGAR), despite CEGIS being a closer fit to the algorithms."}, {"heading": "2.2 Contribution", "text": "We take a slightly different, but related, approach: a candidate is a set E of witnesses, i.e. assignments to the existentially quantified variables; the learner\u2019s claim is that for any counterexample (i.e. any assignment of the universally quantified variables), the formula can be made true by instantiating the existentially-quantified variables to some element of E. Conversely, the database of counterexamples is a set A of assignments to all universally-quantified variables.\nThis means that the algorithm is symmetric between the universal and the existential variables: in order to find a new set of counterexamples (resp. candidate solution), we expand the formula using the candidate (resp. set of counterexamples) and call a SAT solver to find an assignment to the universal (resp. existential) variables. If the formula can be decided using a small set of candidates or a small set of counterexamples, this approach is fast.\nThis can be thought of as a relaxation of CEGIS in the sense that we allow an approximate verifier, i.e. a verifier which might produce spurious counterexamples. To appropriately deal with this, we must require that the learner not only produces a solution (an assignment to the outermost quantifier), but also auxiliary values (the witnesses) that prove that the proposed solution is consistent with the known counterexamples.\nMore explicitly, in the previous example (\u2203x. \u2200y.\u2203z.Q(x, y, z)) the learner\u2019s problem becomes, at the nth iteration\n\u2203x, z1 . . . zn. \u2227ni=1 Q(x, yi, zi)\nwhile the verifier\u2019s problem becomes\n\u2203yn+1. \u2227ni=1 \u00acQ(x, yn+1, zi)\nWhile this enables us to iterate more rapidly between two simpler components, this comes at a cost: the solver may iterate over a correct value for x several times before providing enough witnesses for the verifier to determine that the solution is correct.\nWe show in Section 5 that, in practice, we outperform \u201ctraditional\u201d CEGIS approaches on certain classes of problems, while being slower on others. This shows that this is a very promising approach: our algorithm is extremely simple and so are the associated proofs; yet the prototype implementation, written in less than 2 months, can compete with state-of-the-art solvers and outperforms them in some classes of problems, without using any optimisation not described in this paper."}, {"heading": "3 A novel algorithm for QBF solving", "text": "We give a particular instantiation of this approach for QBF solving. We indifferently call our algorithm and its prototype implementation alejtehad , after the eponymous concept in Islamic philosophy: it refers both to the argumentation\nprocess through which case law is produced, and to the state of knowing that one knows nothing.\nThis hints at the minimalistic nature of the algorithm: alejtehad is simple, in the sense that it is concise to describe and has few prerequisites, both in the theory and in its implementation. It relies on an iterative process, in which arguments and counterarguments are produced until a solution is found.\nBeyond the novelty and simplicity of its solving algorithm, alejtehad is unusual in that it efficient as described, without relying on complex formula optimisations or implementation strategies not described in Section 3.3."}, {"heading": "3.1 Notation", "text": "In the entirety of this paper, \u03a6 will denote a QBF formula and Q the matrix (i.e. the propositional body) of a QBF formula. We consider, without loss of generality, prenex formulas where each quantifier ranges over a single bitvector:\n\u03a6 := \u2203x0.\u2200y0. . . .\u2200yn.\u2203xn+1. Q (x0, . . . xn+1, y0 . . . yn)\nWe denote a single bitvector by zi, a tuple of bitvectors by Z, and their assigned values (in a given model) by zi and Z. Under this notation, we can now precisely define witnesses and counterexamples:\n\u2013 Witnesses are tuples X := (x0, . . . ,xn+1) of concrete values for the existentiallyquantified variables. X is said to be a witness for a counterexample Y if Q (X,Y) holds. \u2013 Counterexamples are tuples Y := (y0, . . . ,yn) of concrete values for the universally-quantified variables. Y is a counterexample of a witness X if \u00acQ(X,Y) holds.\n\u2013 Witness variables are tuples XY := ( x0, x y0 1 , x y0y1 2 , . . . x y0...yn n+1 ) associated\nto a given counterexample Y. Given a model, XY denotes its concrete value (in a given model), i.e. a witness. \u2013 Counterexample variables are likewise defined, denoted Y X, and their concrete values, denoted YX, are counterexamples.\nFor example, for the QBF \u03a6 := \u2200y.\u2203x.Q(x, y) with Q(x, y) := x = y+ 1 (interpreting x and y as n-bit integers), the counterexample 0 has a corresponding witness variable x0. By solving2 Q(x0, 0) (i.e. x0 = 1), a matching witness x0 = 1 is discovered, and has a corresponding counterexample variable y1. Solving the SAT instance \u00acQ(x0, yx0) then yields a new counterexample y1.\nIf a prenex QBF formula as defined above is true, it has an associated Skolem model [31]: functions fxi+1(y0 . . . yi) such that, for any counterexample Y, (fx0(), fx1(y0), . . .) is a matching witness. Conversely, false formulas have Herbrand models [18]: functions fyi(x0 . . . xi) such that for any witness X, (fy0(x0), fy1(x0,x1) . . .) is a matching counterexample.\nThinking of the QBF formula as a 2-players game, a Skolem (resp. Herbrand) model is a winning strategy for the existential (resp. universal) player. We use the\n2 This is a propositional SAT problem.\nnotions of Skolem and Herbrand models later, in Section 4, while proving that alejtehad is sound.\n3.2 The alejtehad algorithm\nAs described previously, our algorithm is composed of a learner and an approximate verifier. It maintains a database of counterexamples (denotedA) and a database of witnesses (denoted E).\nAt each iteration, the learner produces witnesses for all counterexamples observed so far, at which time the verifier responds with counterexamples for all witnesses; both consist of a single query to Boolean SAT. The solver keeps iterating until the learner or the verifier returns UNSAT, at which point the solver returns either a value for x0, if there are no counterexamples, or false if there are no satisfying witnesses.\nA more precise description is provided in Algorithm 1, while Section 3.3 exposes the differences between this description and an efficient implementation."}, {"heading": "3.3 Implementation concerns", "text": "Obviously, Algorithm 1 only gives a high-level description of the solving algorithm, which isn\u2019t quite the description of a fast implementation. Here are notable aspects of our implementation that makes it perform well:\n\u2013 At each iteration, new propositional conjuncts are introduced in \u03d5 and \u03c8: we systematically use incremental SAT solving.\n\u2013 Existing clauses aren\u2019t introduced in duplicate in \u03d5 or \u03c8. \u2013 Likewise, when converting \u00acQ to CNF, naively using Tseitin\u2019s results in a\nlarge (though linear) blowup: instead, we maintain a cache that associates to each clause a Tseitin variable; when a clause is encountered was already processed, no new clauses are added to \u03c8 and the existing Tseitin variable is reused.\nWhile RAReQS, against which we compare our implementation in Section 5 uses similar techniques in its implementation, it also includes optimisations performed on the QBF formula, both before and during solving, that we do not implement: unit propagation, pure literals elimination, universal reduction and blocking clauses. Indeed, alejtehad does not consider explicitly QBF subproblems, so it is unclear whether existing QBF simplification techniques can be applied thorough the execution of the algorithm."}, {"heading": "4 Formal arguments", "text": "As mentioned earlier, Algorithm 1 is very simple and so are its termination and soundness arguments. We provide no complexity guarantees beyond the immediate upper-bound that follows from the termination argument (Theorem 1): while counterexample-guided methods perform well in practice, they do so at the cost of worst-case bounds.\nHowever, we exhibit certain classes of problems that alejtehad can deal within 3 SAT queries, whereas existing CEGIS-based methods, represented by RAReQS, require exponentially many."}, {"heading": "4.1 Termination", "text": "Lemma 1. At every iteration of Algorithm 1, A increases strictly (with regards to set inclusion).\nProof. The only operation affecting A is adding to it, so A increases. Hence, it is sufficient to prove that at least one new counterexample is produced at each iteration. For a given A, if \u03a6 := \u2227 Y\u2208AQ ( XY,Y ) is satisfiable, Q(XY,Y) holds in the resulting model, for each counterexample Y \u2208 A. Hence, \u03c8 := \u2227X\u2208E\u00acQ ( X, Y X ) cannot be satisfied using only existing counterexamples (concrete values that are already in A): either \u03c8 is unsatisfiable (and the algorithm terminates) or the produced model contains new values that are added to A, which thus grows (strictly) larger.\nQ.e.d.\nTheorem 1. Algorithm 1 terminates after at most 21+ \u2211n i=0|yi| SAT queries.\nProof. The set of all possible counter-examples, a superset of A, is finite and of size 2 \u2211n i=0|yi|.\nFrom Lemma 1, at least one new counterexample is produced at each iteration: there are at most 2 \u2211n i=0|yi| iterations.\nLastly, two SAT queries are performed at each iteration, except for the last which may perform one or two queries.\nQ.e.d."}, {"heading": "4.2 Soundness", "text": "Lemma 2. If the QBF formula \u03a6 is true, Algorithm 1 returns some x0 such that \u03a6 admits a Skolem model of the formula where the value of x0 is x0.\nProof. If the original formula is true, there is a Skolem model [31] for it:\nfx0(), fx1(\u00b7), . . . fxn+1(\u00b7) such that \u2200y0. . . . yn. Q (fx0(), y0, fx1(y0), . . . yn\u22121, fxn(y0, . . . yn))\nThen, \u03d5 := \u2227 Y\u2208AQ ( XY,Y ) is always satisfiable: xy0...yii+1 := fxi+1(y0, . . .yi) (for each (y0, . . .yn) \u2208 A) is a satisfying model. Hence, Algorithm 1 cannot return false, and it terminates (Theorem 1), so it must returns some x0.\nLet us consider the following formula:\n\u2200y0.\u2203x1 \u2200y1. . . .\u2203xn+1. Q(fx0 , x1, . . . xn+1, Y )\nIf this formula is true, then adding x0 := fx0 to one of its Skolem models yields a Skolem model of the original QBF with the desired property. If it is false, then a model for \u03c8 := \u2227 X\u2208E \u00acQ ( X, Y X ) can be constructed from its Herbrand model, using the same construction as in Lemma 3; thus, \u03c8 is satisfiable and the algorithm cannot have returned at that point.\nQ.e.d.\nLemma 3. If the QBF formula is false, Algorithm 1 returns false.\nProof. If the original QBF is false, it has a Herbrand model [18]: fy0(\u00b7) . . . fyn(\u00b7) such that, for each x1 . . . xn+1, \u00acQ (x0, fy0(x0), . . . xn, fyn(x0 . . . xn), xn+1)\nHence, \u03c8 has a satisfying model, yx0...xii := fyi(x0 . . .xi) (for each (x0, . . .xn+1) \u2208 A), so Algorithm 1 cannot return some x0.\nSince it must return (Theorem 1), it must then return false. Q.e.d.\nThe soundness result follows immediately:\nTheorem 2. The result returned by Algorithm 1 is consistent with the value of the input.."}, {"heading": "4.3 Distinguishability from RAReQS", "text": "As mentioned earlier, counterexample-guided methods usually an have exponential worst-case complexity, which is disconnected from their performance in practice. This makes it difficult to study those methods through the lens of complexity theory.\nHowever, we can give here a family of examples which highlights the algorithmic differences between our approach and \u201ctraditional\u201d CEGIS-based solvers, such as RAReQS.\nNote that we compare against the algorithmic description of RAReQS, without considering additional optimizations, especially in-processing, which are not described in the RAReQS paper.\nTheorem 3. There exists an infinite family of QBF terms such that ijtihad performs O (1) SAT queries solving them, whereas RAReQS\u2019 algorithm performs \u2126 (2n) queries.\nWe define those formulas to have the following structure, with QXn satisfiable and QYn falsifiable, X being (x0, . . . xn+1) and Y being (y0, . . . yn):\n\u03a6n := \u2203x0.\u2200y0. . . .\u2200yn.\u2203xn+1. QXn (X) \u2227QYn (Y )\nLemma 4. ijtihad performs either 1 or 3 SAT queries to solve \u03a6n, for any n.\nProof. 1. Y0 is taken arbitrarily. 2. A first SAT call is performed to obtain a witness X0.\n\u2013 If Y0 falsifies Q Y n , the result is UNSAT, and ijtihad returns. \u2013 Otherwise, X0 is such that Q X n (X1) holds.\n3. Since QXn (X0) holds, the counterexample Y1 must falsify Q Y n . 4. The next SAT call is guaranteed to yield UNSAT, as no witness exists. Q.e.d.\nFor convenience, we define auxiliary families of formulas:\n\u03a6(x0,y0,...xi,yi)n := \u2203xi+1.\u2200yi+1.\u2203xi+2 . . . \u2203xn+1. QXn (x0, . . .xi, xi+1, . . . xn+1) \u2227QYn (y0, . . .yi, yi+1, . . . yn)\n\u03a6(x0,y0,...xi)n := \u2203yi.\u2200xi+1.\u2203yi+1 . . . \u2200xn+1. \u00acQXn (x0, . . .xi, xi+1, . . . xn+1) \u2228 \u00acQYn (y0, . . .yi\u22121, yi, . . . yn)\nNote that \u03a6n = \u03a6 () n and \u00ac\u03a6(x0,y0,...xi,yi)n = \u2200xi+1.\u03a6x0,y0,...xi,yi,xi+1n .\nLemma 5. RAReQS\u2019 algorithm performs \u2126 ( 2n\u2212i ) SAT queries when called on \u03a6 (x0,y0,...xi,yi) n .\nProof. The execution of RAReQS on \u03a6 (X,Y) n results in a single SAT call, as there is only a single quantifier.\nThe execution of RAReQS on \u03a6 (x0,y0,...xi,yi) n goes as follows [20]: 1. An arbitrary value xi+1 is picked. Let us assume 3 that is leaves QXn sat-\nisfiable. 2. RAReQS is recursively called on \u03a6 (x0,y0,...xi,yi,xi+1) n\n3 This is the best case for RAReQS, but it doesn\u2019t matter for the sake of our argument.\n(a) An arbitrary value yi+1 is picked. Let us assume it leaves Q Y n not\nfalsifiable. (b) RAReQS is recursively called on \u03a6 (x0,y0,...xi,yi,xi+1,yi+1) n , yielding xi+1. (c) RAReQS is recursively called on \u2203yi+1.\u00ac\u03a6(x0,y0,...xi,yi,xi+1,yi+1)n , yielding yi+1 such that Q Y n is refutable. (d) RAReQS is called on \u03a6 (x0,y0,...xi,yi,xi+1,yi+1) n , yielding false. (e) yi+1 is returned from the recursive RAReQS call.\n3. The execution of RAReQS on \u03a6 (x0,y0,...xi,yi) n resumes. RAReQS performs, while solving \u03a6 (x0,y0,...xi,yi) n , at least two recursive calls\non \u03a6 (x0,y0,...xi+1,yi+1) n with different values of yi+1: it follows that \u2126 ( 2n\u2212i ) SAT calls are performed. Q.e.d."}, {"heading": "5 Experimental results", "text": "In this section we look at the performance of alejtehad against RAReQS, which won several recent QBF competitions. We also point out different families of problems where we do better, as well as those where we do very poorly. Furthermore, we point out the impact of various formula parameters on our solving time."}, {"heading": "5.1 Experimental setting", "text": "The optimised alejtehad algorithm is implemented in C++ and uses MiniSat [12\u2013 14] as its backing SAT solver. The code is based on RAReQS\u2019, so as to minimise the differences (data structures, cache optimisations, ...) that could explain performance differences, aside from the implemented algorithm. It is available, under a free software licence (GPLv3), at our laboratory\u2019s source code repository4.\nThe input QBF is given in the standard QDIMACS format. All experiments were run on a dedicated Nehalem machine with 192GB of RAM and 24 CPU threads, running at 2.8GHz each. Each execution was allocated a single virtual core and 10 minutes per problem, while the machine was otherwise unused.\nRAReQS was run using its default configuration, whereas our solver does not have tweakable parameters."}, {"heading": "5.2 Performance on Application Benchmarks", "text": "We ran both solvers on the 825 benchmarks from the main track of the QBFEval\u2019165 competition. We also evaluated the impact of the preprocessor Bloqqer [6,19], which yields an overall performance increase for both solvers but is more helpful to RAReQS, as seen in Table 1.\nWe then analysed how the number of quantifiers affects the performance of the solvers, which can be seen in Figure 2. It becomes clear that alejtehad tends\n4 https://extgit.iaik.tugraz.at/scos/ijtihad 5 Available on http://www.qbflib.org/eval16.html at the time of writing.\nto have an advantage over RAReQS for QBFs with more quantifier alternations. Using Bloqqer, however, generally decreases the number of quantifiers [6], which explains why preprocessing helps RAReQS more.\nThe biggest difference in performance can be seen on the benchmark families described by Pan and Vardi [27], and those described by Mneimneh and Sakallah [26]. As shown in Figure 3 and Table 2, alejtehad is faster on the Pan family, which has higher quantifier depth. On the other hand, RAReQS outperforms it on the Mneimneh-Sakallah family, which exhibits many variables and low quantification depth. In fact, one could argue that the Mneimneh-Sakallah QBF family is the main reason RAReQS\u2019 results seem better in Table 1, as alejtehad almost always runs into a timeout in this specific class, which is overrepresented, accounting for approximately 12% of the entire set of benchmarks.\n6 Only quantifier depths with more than one test case are shown in order to reduce noise."}, {"heading": "5.3 Performance on Random QBFs with a fixed structure", "text": "Experimental evidence shown in [9] suggests that there is a crossover point in the size of random QBF problems, where the formula is equally likely to be SAT and UNSAT, and where verifying or falsifying it becomes as hard as possible. We use this to argue that alejtehad and RAReQS scale differently as quantifier depth increases.\nIn order to further support the claim that alejtehad outperforms RAReQS on QBFs with many quantifier alternations, we ran both solvers without external preprocessing7 on hard random QBFs. All examined QBFs were generated by BlocksQBF [8] and had a fixed structure in which each clause of the quantified CNF had one variable from every quantified variable vector.\nWe produced benchmarks with increasing numbers of variables under each quantifier until both solvers ran into timeouts, and then compared the overall results. Figure 4 shows the performance of the solvers for the number of variables which produced the biggest difference in behaviour, for a given number of quantifiers.\nAs can be observed, on problems with more than 4 quantifiers, we consistently solve more problems than RAReQS, and faster. One important thing to note is that timeouts weight in the solving time, with no particular penalty beyond the timeout value; this explains that our speedup seems to taper off at quantification depths 12 to 14: alejtehad takes more time to solve instances, and so seems closer to RAReQS despite the fact that it doesn\u2019t solve any instances at all.\n7 The number of quantifiers is important and Bloqqer would change it\nConclusion\nTo summarise our contribution, we provide a new perspective on CounterexampleGuided Inductive Synthesis (CEGIS), which yields a novel QBF-solving algorithm, which is both extremely simple to describe and prove correct, and which our experiments show to be efficient.\nThose findings are supported by an implementation of this algorithm, alejtehad , using no optimisation or implementation techniques not described in the paper. This implementation is competitive with RAReQS, a state-of-the-art solver which won recent QBF competitions. In particular, Section 5 shows that our approach outperforms RAReQS in problems involving more than 4 nested quantifiers.\nOn the other hand, our approach shares a weakness with other expansionbased methods (including RAReQS): very simple formulas like \u2200x.\u2203y. y = x take 2n steps to enumerate the (x, y) pairs [28], with x and y being vectors of n Boolean variables. Alternative approaches may not suffer from this specific issue. Most notably, Rabe et al. have been investigating synthesising directly Skolem functions [28,29], which can efficiently deal with this kind of QBF instances.\nThere are many venues of research this opens for future work:\n\u2013 Are there commonplace QBF optimisations that are applicable here, and do they improve the performance of alejtehad? \u2013 Preprocessors such as Bloqqer are designed for solvers for which deeper quantification is problematic. As exhibited in Section 5.3, current preprocessors do not benefit alejtehad as much as other solver: can Bloqqer be tuned or improved to better support our approach? \u2013 Can our approach be combined with Skolem function synthesis [28] so as to handle problems where the Skolem or Herbrand models contain many concrete values? \u2013 Outputting small certificates is a known challenge for counterexample-guided methods. More generally, can we extract small Skolem and Herbrand models? \u2013 Can we generalise our implementation to NNF (Negation Normal Form) without losing efficiency? NNF is interesting, especially for QBF, as encoding problems into NNF does not require introducing new variables, and so does negating NNF formulas. \u2013 How does search-based solving compare to our approach? Can we combine both approaches? \u2013 The alejtehad algorithm is intrinsically sequential, due to its data dependencies. Can we find a variation on it that can be efficiently parallelised?"}, {"heading": "Acknowledgements", "text": "We would like to thank very warmly Armin Biere, Florian Lonsing and Martina Seidl, with whom we cooperate through the LogiCS doctoral college and the RiSE project, for their patient support and willingness to share their expertise in QBF\nsolving. Moreover, Martina Seidl and Uwe Egly deserve very special thanks for their expert and thorough review of the paper.\nOur understanding of our relaxation of CEGIS also benefited from fruitful discussions at CAV\u201916 with Armando Solar-Lezama, the original discoverer of CEGIS."}], "references": [{"title": "Syntax-guided synthesis", "author": ["R. Alur", "R. Bod\u0301\u0131k", "E. Dallal", "D. Fisman", "P. Garg", "G. Juniwal", "H. KressGazit", "P. Madhusudan", "M.M.K. Martin", "M. Raghothaman", "S. Saha", "S.A. Seshia", "R. Singh", "A. Solar-Lezama", "E. Torlak", "A. Udupa"], "venue": "In Dependable Software Systems Engineering,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2015}, {"title": "Qubos: Deciding Quantified Boolean Logic Using Propositional Satisfiability Solvers", "author": ["A. Ayari", "D. Basin"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2002}, {"title": "2QBF: Challenges and Solutions", "author": ["V. Balabanov", "Jiang", "J.-H. R", "C. Scholl", "A. Mishchenko", "R.K. Brayton"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2016}, {"title": "Resolve and expand", "author": ["A. Biere"], "venue": "In Theory and Applications of Satisfiability Testing, 7th International Conference,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2004}, {"title": "Blocked Clause Elimination for QBF", "author": ["A. Biere", "F. Lonsing", "M. Seidl"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Satbased methods for circuit synthesis", "author": ["R. Bloem", "U. Egly", "P. Klampfl", "R. K\u00f6nighofer", "F. Lonsing"], "venue": "In Formal Methods in Computer-Aided Design,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2014}, {"title": "Automated testing and debugging of sat and qbf solvers", "author": ["R. Brummayer", "F. Lonsing", "A. Biere"], "venue": "In In Proc. of SAT 2010,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "Experimental analysis of the computational cost of evaluating quantified boolean formulae", "author": ["M. Cadoli", "A. Giovanardi", "M. Schaerf"], "venue": "In In: AI*IA", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1997}, {"title": "An algorithm to evaluate quantified boolean formulae", "author": ["M. Cadoli", "A. Giovanardi", "M. Schaerf"], "venue": "AAAI/IAAI", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1998}, {"title": "An algorithm to evaluate quantified boolean formulae and its experimental evaluation", "author": ["M. Cadoli", "M. Schaerf", "A. Giovanardi", "M. Giovanardi"], "venue": "J. Autom. Reasoning 28,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2002}, {"title": "Effective preprocessing in sat through variable and clause elimination", "author": ["N. E\u00e9n", "A. Biere"], "venue": "In Proceedings of the 8th International Conference on Theory and Applications of Satisfiability Testing (Berlin, Heidelberg,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2005}, {"title": "Applying logic synthesis for speeding up SAT", "author": ["N. E\u00e9n", "A. Mishchenko", "N. S\u00f6rensson"], "venue": "In Theory and Applications of Satisfiability Testing - SAT 2007,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2007}, {"title": "An Extensible SAT-solver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2004}, {"title": "Detecting unrealizability of distributed faulttolerant systems", "author": ["B. Finkbeiner", "L. Tentrup"], "venue": "Logical Methods in Computer Science 11,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2015}, {"title": "A synthesized algorithm for interactive consistency", "author": ["A. Gasc\u00f3n", "A. Tiwari"], "venue": "In NASA Formal Methods Symposium", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2014}, {"title": "Learning for quantified boolean logic satisfiability", "author": ["E. Giunchiglia", "M. Narizzano", "A Tacchella"], "venue": "AAAI/IAAI", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "Investigations in proof theory: The properties of true propositions. in van heijenoort", "author": ["J. Herbrand"], "venue": "j., editor. From Frege to Go\u0308del", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1967}, {"title": "Clause elimination for sat and qsat", "author": ["M. Heule", "M. J\u00e4rvisalo", "F. Lonsing", "M. Seidl", "A Biere"], "venue": "JAIR", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Solving QBF with counterexample guided refinement", "author": ["M. Janota", "W. Klieber", "J. Marques-Silva", "E.M. Clarke"], "venue": "Artif. Intell", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2016}, {"title": "Compressing BMC encodings with QBF", "author": ["T. Jussila", "A. Biere"], "venue": "Electr. Notes Theor. Comput. Sci. 174,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "Resolution for quantified boolean formulas", "author": ["H. Kleine B\u00fcning", "M. Karpinski", "A. Fl\u00f6gel"], "venue": "Inf. Comput. 117,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1995}, {"title": "Lemma and model caching in decision procedures for quantified boolean formulas", "author": ["R. Letz"], "venue": "In Proceedings of the International Conference on Automated Reasoning with Analytic Tableaux and Related Methods (London, UK, UK,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}, {"title": "Incrementally computing minimal unsatisfiable cores of qbfs via a clause group solver API", "author": ["F. Lonsing", "U. Egly"], "venue": "In Theory and Applications of Satisfiability Testing - SAT 2015 - 18th International Conference,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2015}, {"title": "Robust qbf encodings for sequential circuits with applications to verification, debug, and test", "author": ["H. Mangassarian", "A. Veneris", "M. Benedetti"], "venue": "IEEE Transactions on Computers 59,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2010}, {"title": "Computing vertex eccentricity in exponentially large graphs: Qbf formulation and solution", "author": ["M. Mneimneh", "K. Sakallah"], "venue": "Proc. 6th Intl. Conf. on Theory and Applications of Satisfiability Testing (SAT03),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2003}, {"title": "Optimizing a bdd-based modal solver", "author": ["G. Pan", "M.Y. Vardi"], "venue": "Proceedings of the 19th International Conference on Automated Deduction", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2003}, {"title": "Incremental Determinization", "author": ["M.N. Rabe", "S.A. Seshia"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2016}, {"title": "Caqe: A certifying qbf solver", "author": ["M.N. Rabe", "L. Tentrup"], "venue": "In Proceedings of the 15th Conference on Formal Methods in Computer-Aided Design (Austin, TX,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2015}, {"title": "Constructing conditional plans by a theorem-prover", "author": ["J. Rintanen"], "venue": "J. Artif. Intell. Res. (JAIR)", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1999}, {"title": "Logico-combinatorial investigations in the satisfiability or provability of mathematical propositions: a simplified proof of a theorem by l. l\u00f6wenheim and generalizations of the theorem. From Frege to G\u00f6del", "author": ["T. Skolem"], "venue": "A Source Book in Mathematical Logic", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1931}, {"title": "Program sketching", "author": ["A. Solar-Lezama"], "venue": "STTT 15,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2013}, {"title": "Towards a Symmetric Treatment of Satisfaction and Conflicts in Quantified Boolean Formula Evaluation", "author": ["L. Zhang", "S. Malik"], "venue": null, "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2002}], "referenceMentions": [{"referenceID": 28, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 151, "endOffset": 155}, {"referenceID": 19, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 172, "endOffset": 176}, {"referenceID": 23, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 193, "endOffset": 197}, {"referenceID": 5, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 212, "endOffset": 218}, {"referenceID": 30, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 212, "endOffset": 218}, {"referenceID": 13, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 267, "endOffset": 274}, {"referenceID": 14, "context": "Improvements in QBF solving will thus have a strong impact in many application domains with problems that can be translated to QBF, including planning [30], model checking [21], circuit design [25] and synthesis [7,32], in particular synthesis of distributed systems [15,16].", "startOffset": 267, "endOffset": 274}, {"referenceID": 8, "context": "Research into engineering QBF solvers has seen considerable progress since initial work in the mid-nineties [10,22], with most solvers either implementing a quantified version of CDCL (e.", "startOffset": 108, "endOffset": 115}, {"referenceID": 20, "context": "Research into engineering QBF solvers has seen considerable progress since initial work in the mid-nineties [10,22], with most solvers either implementing a quantified version of CDCL (e.", "startOffset": 108, "endOffset": 115}, {"referenceID": 9, "context": ", [11,24,33]) or an expansion-based approach (e.", "startOffset": 2, "endOffset": 12}, {"referenceID": 22, "context": ", [11,24,33]) or an expansion-based approach (e.", "startOffset": 2, "endOffset": 12}, {"referenceID": 31, "context": ", [11,24,33]) or an expansion-based approach (e.", "startOffset": 2, "endOffset": 12}, {"referenceID": 3, "context": "[4]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "Since the first complete solver in 1998, based on DPLL [10], an incredible amount of work has gone into QBF: an analogue of propositional CDCL was discovered in 2002 [17, 23], the very same year as expansion-based solving [2] was discovered.", "startOffset": 55, "endOffset": 59}, {"referenceID": 15, "context": "Since the first complete solver in 1998, based on DPLL [10], an incredible amount of work has gone into QBF: an analogue of propositional CDCL was discovered in 2002 [17, 23], the very same year as expansion-based solving [2] was discovered.", "startOffset": 166, "endOffset": 174}, {"referenceID": 21, "context": "Since the first complete solver in 1998, based on DPLL [10], an incredible amount of work has gone into QBF: an analogue of propositional CDCL was discovered in 2002 [17, 23], the very same year as expansion-based solving [2] was discovered.", "startOffset": 166, "endOffset": 174}, {"referenceID": 1, "context": "Since the first complete solver in 1998, based on DPLL [10], an incredible amount of work has gone into QBF: an analogue of propositional CDCL was discovered in 2002 [17, 23], the very same year as expansion-based solving [2] was discovered.", "startOffset": 222, "endOffset": 225}, {"referenceID": 18, "context": "Expansion-based solving has known tremendous success, and is the basis for counterexample-guided methods such as RAReQS [20], a state-of-the-art expansionbased solver.", "startOffset": 120, "endOffset": 124}, {"referenceID": 26, "context": "function computation, was introduced [28].", "startOffset": 37, "endOffset": 41}, {"referenceID": 0, "context": "In this paper, we follow an expansion-based approach to solving QBFs that is inspired by counterexample-guided inductive synthesis (CEGIS) [1, 32].", "startOffset": 139, "endOffset": 146}, {"referenceID": 30, "context": "In this paper, we follow an expansion-based approach to solving QBFs that is inspired by counterexample-guided inductive synthesis (CEGIS) [1, 32].", "startOffset": 139, "endOffset": 146}, {"referenceID": 18, "context": "Our approach is similar to the one implemented in the very successful solver RAReQS [20], which instantiates the outer existential quantifiers using a counterexampleguided approach.", "startOffset": 84, "endOffset": 88}, {"referenceID": 0, "context": "Counterexample-guided inductive synthesis (CEGIS) is a generic framework, initially devised in the context of syntax-guided synthesis [1], involving iterations between two components:", "startOffset": 134, "endOffset": 137}, {"referenceID": 18, "context": "Although the worst-case complexity guarantees usually devolve to the size of the set of counterexamples or of candidate solution, this approach has been wildly successful in practice [20,29,32].", "startOffset": 183, "endOffset": 193}, {"referenceID": 27, "context": "Although the worst-case complexity guarantees usually devolve to the size of the set of counterexamples or of candidate solution, this approach has been wildly successful in practice [20,29,32].", "startOffset": 183, "endOffset": 193}, {"referenceID": 30, "context": "Although the worst-case complexity guarantees usually devolve to the size of the set of counterexamples or of candidate solution, this approach has been wildly successful in practice [20,29,32].", "startOffset": 183, "endOffset": 193}, {"referenceID": 18, "context": "One of the earliest applications of CEGIS to QBF solving, RAReQS [20], introduced a recursive approach where the whole solver is used as a verifier, each nested solver dealing with one block of quantifiers.", "startOffset": 65, "endOffset": 69}, {"referenceID": 2, "context": "There has been many refinements of this technique since RAReQS, from RAReQS\u2019 recent reimplementation from scratch for 2-QBF [3] to the clause abstraction performed by CAQE [29].", "startOffset": 124, "endOffset": 127}, {"referenceID": 27, "context": "There has been many refinements of this technique since RAReQS, from RAReQS\u2019 recent reimplementation from scratch for 2-QBF [3] to the clause abstraction performed by CAQE [29].", "startOffset": 172, "endOffset": 176}, {"referenceID": 29, "context": "If a prenex QBF formula as defined above is true, it has an associated Skolem model [31]: functions fxi+1(y0 .", "startOffset": 84, "endOffset": 88}, {"referenceID": 16, "context": "Conversely, false formulas have Herbrand models [18]: functions fyi(x0 .", "startOffset": 48, "endOffset": 52}, {"referenceID": 29, "context": "If the original formula is true, there is a Skolem model [31] for it:", "startOffset": 57, "endOffset": 61}, {"referenceID": 16, "context": "If the original QBF is false, it has a Herbrand model [18]: fy0(\u00b7) .", "startOffset": 54, "endOffset": 58}, {"referenceID": 18, "context": "xi,yi) n goes as follows [20]:", "startOffset": 25, "endOffset": 29}, {"referenceID": 12, "context": "The optimised alejtehad algorithm is implemented in C++ and uses MiniSat [12\u2013 14] as its backing SAT solver.", "startOffset": 73, "endOffset": 81}, {"referenceID": 4, "context": "We also evaluated the impact of the preprocessor Bloqqer [6,19], which yields an overall performance increase for both solvers but is more helpful to RAReQS, as seen in Table 1.", "startOffset": 57, "endOffset": 63}, {"referenceID": 17, "context": "We also evaluated the impact of the preprocessor Bloqqer [6,19], which yields an overall performance increase for both solvers but is more helpful to RAReQS, as seen in Table 1.", "startOffset": 57, "endOffset": 63}, {"referenceID": 4, "context": "Using Bloqqer, however, generally decreases the number of quantifiers [6], which explains why preprocessing helps RAReQS more.", "startOffset": 70, "endOffset": 73}, {"referenceID": 25, "context": "The biggest difference in performance can be seen on the benchmark families described by Pan and Vardi [27], and those described by Mneimneh and Sakallah [26].", "startOffset": 103, "endOffset": 107}, {"referenceID": 24, "context": "The biggest difference in performance can be seen on the benchmark families described by Pan and Vardi [27], and those described by Mneimneh and Sakallah [26].", "startOffset": 154, "endOffset": 158}, {"referenceID": 7, "context": "Experimental evidence shown in [9] suggests that there is a crossover point in the size of random QBF problems, where the formula is equally likely to be SAT and UNSAT, and where verifying or falsifying it becomes as hard as possible.", "startOffset": 31, "endOffset": 34}, {"referenceID": 6, "context": "All examined QBFs were generated by BlocksQBF [8] and had a fixed structure in which each clause of the quantified CNF had one variable from every quantified variable vector.", "startOffset": 46, "endOffset": 49}, {"referenceID": 26, "context": "y = x take 2 steps to enumerate the (x, y) pairs [28], with x and y being vectors of n Boolean variables.", "startOffset": 49, "endOffset": 53}, {"referenceID": 26, "context": "have been investigating synthesising directly Skolem functions [28,29], which can efficiently deal with this kind of QBF instances.", "startOffset": 63, "endOffset": 70}, {"referenceID": 27, "context": "have been investigating synthesising directly Skolem functions [28,29], which can efficiently deal with this kind of QBF instances.", "startOffset": 63, "endOffset": 70}, {"referenceID": 26, "context": "3, current preprocessors do not benefit alejtehad as much as other solver: can Bloqqer be tuned or improved to better support our approach? \u2013 Can our approach be combined with Skolem function synthesis [28] so as to handle problems where the Skolem or Herbrand models contain many concrete values? \u2013 Outputting small certificates is a known challenge for counterexample-guided methods.", "startOffset": 202, "endOffset": 206}], "year": 2016, "abstractText": "We introduce a novel generalization of Counterexample-Guided Inductive Synthesis (CEGIS) and instantiate it to yield a novel, competitive algorithm for solving Quantified Boolean Formulas (QBF). Current QBF solvers based on counterexample-guided expansion use a recursive approach which scales poorly with the number of quantifier alternations. Our generalization of CEGIS removes the need for this recursive approach, and we instantiate it to yield a simple and efficient algorithm for QBF solving. Lastly, this research is supported by a competitive, though straightforward, implementation of the algorithm, making it possible to study the practical impact of our algorithm design decisions.", "creator": "LaTeX with hyperref package"}}}