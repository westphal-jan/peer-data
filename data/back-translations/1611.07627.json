{"id": "1611.07627", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Nov-2016", "title": "SyGuS-Comp 2016: Results and Analysis", "abstract": "Syntax-Guided Synthesis (SyGuS) is the arithmetical problem of finding an implementation problem f that corresponds to both a semantic constraint given by a logical formula $\\ varphi $in a background theory T and a syntactic constraint given by a grammar G that specifies the allowable number of candidate implementations.", "histories": [["v1", "Wed, 23 Nov 2016 03:17:40 GMT  (1336kb,D)", "http://arxiv.org/abs/1611.07627v1", "In Proceedings SYNT 2016,arXiv:1611.07178. arXiv admin note: text overlap witharXiv:1602.01170"]], "COMMENTS": "In Proceedings SYNT 2016,arXiv:1611.07178. arXiv admin note: text overlap witharXiv:1602.01170", "reviews": [], "SUBJECTS": "cs.SE cs.LG cs.LO", "authors": ["rajeev alur", "dana fisman", "rishabh singh", "armando solar-lezama"], "accepted": false, "id": "1611.07627"}, "pdf": {"name": "1611.07627.pdf", "metadata": {"source": "CRF", "title": "SyGuS-Comp 2016: Results and Analysis", "authors": ["Rajeev Alur", "Dana Fisman", "Rishabh Singh", "Armando Solar-Lezama"], "emails": [], "sections": [{"heading": null, "text": "Dimitrova, Piskac (Eds.): Fifth Workshop on Synthesis (SYNT 2016) EPTCS 229, 2016, pp. 178\u2013202, doi:10.4204/EPTCS.229.13\nc\u00a9 R. Alur, D. Fisman, R. Singh & A. Solar-Lezama This work is licensed under the Creative Commons Attribution License.\nSyGuS-Comp 2016: Results and Analysis\nRajeev Alur University of Pennsylvania\nDana Fisman Ben-Gurion University\nRishabh Singh Microsoft Research, Redmond\nArmando Solar-Lezama Massachusetts Institute of Technology\nSyntax-Guided Synthesis (SyGuS) is the computational problem of finding an implementation f that meets both a semantic constraint given by a logical formula \u03d5 in a background theory T , and a syntactic constraint given by a grammar G, which specifies the allowed set of candidate implementations. Such a synthesis problem can be formally defined in SyGuS-IF, a language that is built on top of SMT-LIB.\nThe Syntax-Guided Synthesis Competition (SyGuS-Comp) is an effort to facilitate, bring together and accelerate research and development of efficient solvers for SyGuS by providing a platform for evaluating different synthesis techniques on a comprehensive set of benchmarks. In this year\u2019s competition we added a new track devoted to programming by examples. This track consisted of two categories, one using the theory of bit-vectors and one using the theory of strings. This paper presents and analyses the results of SyGuS-Comp\u201916."}, {"heading": "1 Introduction", "text": "The Syntax-Guided Synthesis Competition (SyGuS-Comp) was originally developed as a community effort in order to provide an objective basis to compare different approaches to solving the SyntaxGuided Synthesis problem. In this style of synthesis, the user provides a specification in the form of a logical formula \u03d5 in a background theory T , and a space of programs given as a grammar G; the goal of the synthesizer is to find a program in the space that satisfies the given specification. Concretely, if the specification uses an unknown function f , the goal is to find a function fimp that is expressible in the grammar G and such that the formula \u03d5[ f/ fimp] is valid for all values of its free variables.\nOne of the achievements of the community effort behind SyGuS-Comp has been the development of a standard format for benchmarks. The SyGuS format is detailed in other publications [7, 2],[22, 5, 6], but at a high-level, the SyGuS format is based on the popular SMT-LIB format for defining SMT problems and is extended to support the description of function grammars. The SyGuS format has been extended over the last two years to provide special support for important classes of problems such as Invariant Synthesis, or problems involving expressions in integer linear arithmetic [5]. In its 2016 iteration, the format was also extended to support Programming by Example problems [6], which are becoming an important area of study in the synthesis community.\nIn the short time that the formalism has been in public circulation, it has already performed well in its goal of facilitating research in synthesis while providing a basis for objective comparison of different algorithms. For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12]. Beyond synthesizer developers, there is a growing community of users that is coalescing around the formalism.\nSyGuS has found various interesting applications among which are motion planning [8], compiler optimizations, and cybersecurity [9]. Remarkably, Eldib et al. report that a circuit for mitigating time-\ndelay attacks generated via SyGuS is much smaller than a handcrafted circuit mitigating the same attack, as well as the original circuit (which is vulnerable to that attack). The SyGuS generated circuit used 13 gates compared to 41 of the handcrafted circuit and 21 of the original, and has a shorter critical path: 3 unit delay vs. 6 unit delay of the mitigated and original circuits."}, {"heading": "1.1 The General Track", "text": "We now illustrate the key ideas behind the main formalism and the extensions that have been added in the last two years through a series of illustrative examples.\nExample We illustrate the general SyGuS-Comp formalism with this simple example from one of the competition benchmarks. This example is taken from an implementation of a quantum control computer (QCC).1 The QCC uses expressions from the following grammar:\ng ::= c | g+g | g\u2212g | g?g\nwhere c is any integer constant, + is addition, \u2212 is substraction, and a?b stands for \u201cif a\u2265 0 then a else b\u201d. This minimal set of instruction is used to enable a fast implementation. High level commands should be translated to this grammar using a minimal number of operations, since these operations participate in a pipeline, thus every unnecessary delay multiplies. The goal in the following benchmark is to find two functions qm-inner-loop and qm-outer-loop that decrement an inner and outer loop (the inner from 7 to 0, the outer from 3 to 0) formally defined as follows for x\u2265 0 and y\u2265 0.\nqm-inner-loop(x) = {\n7 if x = 0 x\u22121 if otherwise\nqm-outer-loop(x,y) =  3 if x = 0 \u2227 y = 0 y\u22121 if x = 0 \u2227 y 6= 0 y otherwise\nThese constraints can be succinctly expressed in the SyGuS format as shown below.\n(set-logic LIA)\n(define-fun qm ((a Int) (b Int)) Int\n(ite (< a 0) b a))\n(synth-fun qm-inner-loop ((x Int)) Int\n((Start Int (x\n0\n1\n7\n(- Start Start)\n(+ Start Start)\n(qm Start Start)))))\n1We thank Nissim Ofek (Yale) for contributing these benchmarks.\n(synth-fun qm-outer-loop ((x Int) (y Int)) Int\n((Start Int (x\ny\n0\n1\n3\n(- Start Start)\n(+ Start Start)\n(qm Start Start)))))\n(declare-var x Int)\n(declare-var y Int)\n(constraint (or (< x 0))\n(= (qm-inner-loop x)\n(ite (= x 0) 7 (- x 1))))\n(constraint (or (or (< x 0) (< y 0))\n(= (qm-outer-loop x y)\n(ite (= x 0) (ite (= y 0) 3 (- y 1))\ny))))\n(check-synth)\nThe define-fun command provides the description of the \u2018?\u2019 or qm primitive function: qm(a,b) = {\na if a\u2265 0 b otherwise\nThe set-logic directive indicates that the constraints should be interpreted in terms of the theory of linear integer arithmetic. The directive declare-var is used to declare x and y as universally quantified integer variables. The constraints are introduced with the directive constraint, and check-synth marks the end of the problem and prompts the synthesizer to solve for the missing function. Crucially, in order for the synthesizer to generate qm-inner-loop and qm-outer-loop, it needs a grammar, which is provided as part of the synth-fun directive. The specified grammar provides exactly the set of allowed operations for the QCC."}, {"heading": "1.2 Conditional Linear Integer Arithmetic Track", "text": "For problems where the grammar consists of the set of all possible integer linear arithmetic terms, it is sometimes possible to apply specialized solution techniques that exploit the information that decision procedures for integer linear arithmetic are able to produce. The 2015 SyGuS competition included a separate track where the grammar for all the unknown functions was assumed to be the entire theory of Integer Linear Arithmetic with ITE conditionals.\nExample As a simple example, consider the problem of synthesizing a function abs that produces the absolute value of an integer. The problem can be specified with the constraint below:\n(set-logic LIA)\n(synth-fun abs ((x Int)) Int)\n(declare-var x Int)\n(constraint (>= (abs x) 0))\n(constraint (or (= x (abs x)) (or (= (- x) (abs x)))))\n(check-synth)\nNote that the definition of the unknown function abs does not include a grammar this time, but because the problem is defined in the theory of linear integer arithmetic (LIA), the default grammar consists of all the operations available in the theory."}, {"heading": "1.3 Invariant Synthesis Track", "text": "One of the main applications of SyGuS is invariant synthesis. For this problem, the goal is to discover an invariant that makes the verification condition for a given loop valid. Such a problem can be easily encoded in SyGuS, but invariant synthesis problems have structure that some solution algorithms are able to exploit and that can be lost when encoding it into SyGuS. Like the 2015 competition, the 2016 competition also included a separate track for invariant synthesis problems where the additional structure is made apparent. In the invariant synthesis version of the SyGuS format, the constraints are separated into pre-condition, post-condition and transition relation, and the grammar for the unknown invariant is assumed to be the same as that for the conditional linear arithmetic track. We illustrate this format with an example from last year\u2019s report [7].\nExample For example, consider the following simple loop.\nPre: i >= 0 and j=j0 and i=i0;\nwhile(i > 0){\ni = i - 1;\nj = j + 1;\n}\nPost: j = j0 + i0;\nSuppose we want to prove that the value of j at the end of the loop equals the value of i + j at the beginning of the loop. The verification condition for this loop would check that (a) the precondition implies the invariant, (b) that the invariant is inductive, so if it holds before an iteration and the loop condition is true, then it will hold after that iteration, and (c) that the invariant together with the negation of the loop condition implies the postcondition. All of these constraints can be expressed in the standard SyGuS format, but they can be expressed more concisely using the extensions explicitly defined for this purpose. Specifically, the encoding will be as follows.\n(set-logic LIA)\n(synth-inv inv-f ((i Int) (j Int) (i0 Int) (j0 Int)))\n(declare-primed-var i0 Int)\n(declare-primed-var j0 Int)\n(declare-primed-var i Int)\n(declare-primed-var j Int)\n(define-fun pre-f ((i Int) (j Int) (i0 Int) (j0 Int)) Bool\n(and (>= i 0) (and (= i i0) (= j j0))))\n(define-fun trans-f ((i Int) (j Int) (i0 Int) (j0 Int)\n(i! Int) (j! Int) (i0! Int) (j0! Int)) Bool\n(and (and (= i! (- i 1)) (= j! (+ j 1)))\n(and (= i0! i0) (= j0! j0))))\n(define-fun post-f ((i Int) (j Int) (i0 Int) (j0 Int)) Bool\n(= j (+ j0 i0)))\n(inv-constraint inv-f pre-f trans-f post-f)\n(check-synth)\nThe directive (declare-primed-var i) is equivalent to separately declaring i and i!, where the primed version of the variables is used to distinguish their value before and after the loop body. Just like in the earlier example, the function to be synthesized inv_f does not include a grammar, so the entire LIA grammar is assumed. The constraint inv-constraint is syntactic sugar for the full verification condition involving the invariant, precondition, postcondition and transition function."}, {"heading": "1.4 Programming By Example Track", "text": "There has been a lot of recent interest in the synthesis community for learning programs from examples. Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23]. The 2016 competition included a new separate track for Programming by Examples. The grammar for benchmarks in this track is specified using a context-free grammar similar to the general SyGuS track, but the specification constraints can only be specified using input-output examples. The benchmarks in this track included theory of integers, bit-vectors, and strings.\nExample Consider the following task taken from FlashFill [13, 14] that requires learning a string transformation program that constructs the initials of the first and last names.\nThe encoding of this problem in the PBE track is as follows:\n(set-logic SLIA)\n(synth-fun f ((name String)) String\n((Start String (ntString))\n(ntString String (name \" \" \".\"\n(str.++ ntString ntString)\n(str.replace ntString ntString ntString)\n(str.at ntString ntInt)\n(int.to.str ntInt)\n(str.substr ntString ntInt ntInt)))\n(ntInt Int (0 1 2\n(+ ntInt ntInt)\n(- ntInt ntInt)\n(str.len ntString)\n(str.to.int ntString)\n(str.indexof ntString ntString ntInt)))\n(ntBool Bool (true false\n(str.prefixof ntString ntString)\n(str.suffixof ntString ntString)\n(str.contains ntString ntString)))))\n(declare-var name String)\n(constraint (= (f \"Nancy FreeHafer\") \"N.F.\"))\n(constraint (= (f \"Andrew Cencici\") \"A.C.\"))\n(constraint (= (f \"Jan Kotas\") \"J.K.\"))\n(constraint (= (f \"Mariya Sergienko\") \"M.S.\"))\n(check-synth)\nThe benchmark uses SMT-LIB\u2019s SLIA theory that encodes several string functions such as str.len, str.indexof, str.contains etc. All the constant strings that are needed to perform the transformation are also provided as part of the grammar."}, {"heading": "1.5 SyGuS-Comp\u201914 summary", "text": "The first SyGuS competition, SyGuS-Comp\u201914 consisted of a single track \u2014 the general track \u2014 in which the benchmark provides the grammar describing the desired syntactic restrictions for that benchmark. The background theory could be either linear interger arithmetic or bitvectors. Five solvers competed in SyGuS-Comp\u201914. The solver who won the first place was the ENUMERATIVE solver which solved 126 out of 241 benchmarks."}, {"heading": "1.6 SyGuS-Comp\u201915 summary", "text": "The 2015 instance of SyGuS-Comp was the second iteration of the competition and the first iteration to include the separate conditional linear integer arithmetic and invariant synthesis tracks. There were a\ntotal of eight solvers submitted to the competition which represented a range of solution strategies. The CVC4-1.5 solver won the general track and the conditional linear integer arithmetic tracks, whereas the ICE DT solver won the invariant synthesis track."}, {"heading": "1.7 SyGuS-Comp\u201916 summary", "text": "The 2016 instance of SyGuS-Comp was the third iteration of the competition and included an additional track on Programming By Examples (PBE). In addition to the previous solvers, there were two new solver submitted this year: CVC4-1.5.1 and EUSolver. In the rest of the paper, we describe the details of the benchmarks, new solver strategies, and the results of the competition on different benchmark categories."}, {"heading": "2 Competition Settings", "text": ""}, {"heading": "2.1 Participating Benchmarks", "text": "In addition to last year\u2019s competition benchmarks, we had 858 new benchmarks for the Programming By Example (PBE) track. For other tracks, we had the same benchmarks as of last year: General Track (309), CLIA Track (73), and Invariant Synthesis Track (67).\nThe benchmarks in the PBE track can be classified into two categories:\n\u2022 String Transformations: The 108 string transformation tasks are taken from public benchmarks of FlashFill [13, 14] and BlinkFill [28]. The transformations are defined using a Domain-specific language of string transformations that involve concatenation of substrings of input strings and constant strings, where the substring expressions involve learning positions corresponding to kth\noccurrence of a constant string in the inputs.\n\u2022 Bitvector Transformations: The 450 bitvector transformation benchmarks were obtained from the 2013 ICFP Programming Competition2 [1]. The programs for the benchmarks were sampled from a bitvector DSL using a strategy of construction k-nuggets (programs of size k that are minimal) and then composing them to generate larger programs. An additional 300 bitvector benchmarks using the same grammar were submitted by Arjun Radhakrishna.\nString Benchmarks The string benchmarks were taken from the public string transformation benchmarks in FlashFill and BlinkFill. These benchmarks correspond to common data cleaning tasks faced by spreadsheet users. The hypothesis space of possible transformations is defined by a DSL that is expressive enough to encode majority of common tasks but at the same time amenable for efficient learning. A subset of the DSL that was encoded in SyGuS benchmark is shown in Figure 1. Note that the SyGuS grammar for these benchmarks currently does not contain loops (Kleene star) and regular expression based position expressions.\nThe grammar at the top-level consists of string concatenation (str.++) expressions involving constant strings and substring expressions. The constant strings needed for each benchmark are also provided in each benchmark (c1, c2, etc.). For some of the string transformation benchmarks, we created two additional class of benchmarks with the suffix -long and -repeat. The -long benchmarks had 100 input-output examples, whereas the -repeat benchmarks consisted of several input-output examples that were repeated in the constraint. The goal of these additional benchmark categories was to see\n2http://icfpc2013.cloudapp.net/\n(synth-fun f ((x String) (y String)) String\nhow increasing the number of examples affects the solver performance, and if solving algorithms can avoid reasoning about repeated input-output examples.\nBitvector Benchmarks The bitvector benchmarks were taken from the 2013 ICFP programming contest and the DSL encoded as a SyGuS grammar for the benchmarks is shown in Figure 2. Similar to the string transformation DSL, the constants needed for the desired transformation are provided in the grammar.\nThe benchmarks for this category were generated from the DSL by first sampling k-nuggest from the DSL and then composing them to obtain larger programs. A k-nugget is a program expression in the DSL of size k such that no other expression in the DSL of size less than k is equivalent with it. The idea in using the k-nuggets for program generation is that the composed programs would lead to more challenging programs that will be less likely to be solved by synthesizing a small equivalent program in the DSL."}, {"heading": "2.2 Participating Solvers", "text": "In addition to 7 solvers from last year\u2019s competition, we had two new solver submissions for the 2016 competition: i) CVC4 1.5.1 and ii) EUSolver. Table 2 summarizes which solver participated in which track. The two new solvers participated in all 4 tracks. A total of 6 solvers participated in the General track, 5 in the invariant synthesis track, and 5 in the Conditional Linear arithmetic track. Figure 2 lists the submitted solvers together with their authors.\nThe CVC4-1.5.1 solver employs a refutation-based synthesis approach [24]. Instead of solving an exists-forall synthesis formula, it first negates the formula to obtain a forall-exists problem and tries to show it is unsatisfiable. It eliminates the forall quantification over unknown function in two ways: i) if the function is always called with the same parameters in the formula, it skolemizes it with a first-\n(define-fun shr1 ((x (BitVec 64))) (BitVec 64) (bvlshr x #x0000000000000001))\n(define-fun shr4 ((x (BitVec 64))) (BitVec 64) (bvlshr x #x0000000000000004))\n(define-fun shr16 ((x (BitVec 64))) (BitVec 64) (bvlshr x #x0000000000000010))\n(define-fun shl1 ((x (BitVec 64))) (BitVec 64) (bvshl x #x0000000000000001))\n(define-fun if0 ((x (BitVec 64)) (y (BitVec 64)) (z (BitVec 64))) (BitVec 64)\n(ite (= x #x0000000000000001) y z))\n(synth-fun f ( (x (BitVec 64))) (BitVec 64)\norder variable (single invocation case), ii) otherwise if the single invocation property does not hold in the formula, it uses a syntax-guided approach for restricting the space of functions using the grammar. This year\u2019s submission had new improvements in both of these two ways. For the single invocation case, the solver has a termination guarantee for LIA and supports newer ways to recognize when a property can be rewritten as single invocation. For the syntax-guided case, it supports an improved symmetry breaking and adds optimizations for unfolding of evaluation functions. For the invariant track, it fixes templates for unknown invariants to improve scalability of the solving algorithm.\nThe EUSOLVER combines enumeration with unification to learn complex functions from a grammar that satisfy the specification. It first learns small terms from the function grammar using enumeration such that the learnt terms cover the set of all points. It then synthesizes larger expressions by enumerating predicates and combining them with the learnt terms using a decision tree learning algorithm. It supports multiple sophisticated algorithms for term generation, predicate generation, and unification to compose larger expressions for different categories of benchmarks."}, {"heading": "2.3 Experimental Setup", "text": "The solvers were run on the StarExec platform [34] with a dedicated cluster of 12 nodes, where each node consisted of two 4-core 2.4GHz Intel processors with 256GB RAM and a 1TB hard drive. The memory usage limit of each solver run was set to 128GB. The wallclock time unit was set to 3600 seconds (thus, a solver that used all cores could consume at most 14400 seconds cpu time).\nThe solution that the solvers produce are being checked for both syntactic and semantic correctness. That is, a first post-processor checks that the produced expression adheres to the grammar specified in the given benchmark, and if this check passes, a second post-processor checks that the solution adheres to semantic constraints given in the benchmark (by invoking an SMT solver)."}, {"heading": "3 Competition Results and Analysis", "text": ""}, {"heading": "3.1 Results Overview", "text": "The combined results for all tracks for each benchmark is shown in Figure 4. The figure shows the sum of percentages of benchmarks solved by the solvers for each category. We can observe that the EUSOLVER solves the highest percentage of benchmarks in the combined tracks, whereas the CVC4-1.5.1 solver solves the second most percentage of benchmarks.\nThe primary criterion for winning a track was the number of benchmarks solved, but we also analyzed the time to solve and the the size of the generated expressions. Both where classified using a pseudo-logarithmic scale as follows. For time to solve the scale is [0,1), [1,3), [3,10), [10,30),[30, 100), [100,300), [300, 1000), [1000,3600), >3600. That is the first \u201cbucket\u201d refers to termination in less than one second, the second to termination in one to three second and so on. We say that a solver solved a certain benchmark among the fastest if the time it took to solve that benchmark was on the same bucket as that of the solver who solved that benchmark the fastest. For the expression sizes the pseudo-logarithmic scale we used is [1,10), [10,30), [30,100), [100,300), [300,1000), >1000 where expression size is the number of nodes in the SyGuS parse-tree. We also report on the number of benchmarks solved uniquely by a solver (meaning the number of benchmark that solver was the single solver that managed to solve them).\nGeneral Track The percentage of benchmarks solved by each solver in the General track is shown in Figure 5 on the top left. The EUSOLVER solves the maximum number of benchmarks 206 out of 309. The CVC4-1.5.1 solver solves 195 benchmarks, whereas the last year\u2019s winner in this category CVC4-1.5 solved 179 benchmarks. The EUSOLVER solved 59 benchmarks uniquely and CVC4-1.5.1 solved 22 benchmarks uniquely. With regard to time to solve, the CVC4-1.5.1 solvers solved 161 benchmarks among the fastest whereas the EUSOLVER solved 127 benchmarks among the fastest. For details on the expression size see Figures 6 to 9.\nConditional Linear ArithmeticTrack The percentage of benchmarks solved by the solvers in the Conditional Linear Integer Arithmetic track is shown in Figure 5 on the top right. The CVC4-1.5.1 solver solved all 73 benchmarks in this category, whereas the EUSOLVER solved 72 out of the 73 benchmarks. Last year\u2019s winner in this category, CVC4-1.5, solved 70 benchmarks. One benchmark was solved uniquely, by CVC4-1.5.1. The CVC4-1.5.1 solver solved 72 benchmarks among the fastest and EUSOLVER solved 33 among the fastest.\nInvariant Synthesis Track The result for the invariant synthesis track is shown in Figure 5 on the bottom left. In this track, the ICE-DT solver (also last year\u2019s track winner) solves the maximum number of benchmarks 57 out of 67. The CVC4-1.5.1 solver solves 56 benchmarks, whereas the ALCHEMIST-CSDT solver solves 52 benchmarks. Two benchmarks were solved uniquely, the two by ICE-DT. In terms of time to solve CVC4-1.5.1 preformed best, solving 50 bechmarks among the fastest. This is an impressive improvement from last years\u2019 version CVC4-1.5 which solved 10 benchmarks among the fastest. The ICE-DT solver solved 44 benchmarks among the fastest and the ALCHEMIST-CSDT solver solved 37 benchmarks among the fastest.\nProgramming By Example Track The results for the new Programming By Example (PBE) track is shown in Figure 5 on the bottom right. Unlike other tracks, we see a dramatic difference in the performance of the solvers for the benchmarks in the PBE track. The EUSOLVER remarkably solves 787 benchmarks out of 858 (742 out of 745 in the bit-vectors category and 45 out of 108 in the strings category), whereas the second best solver CVC4-1.5.1 solves 39 benchmarks (21 in the bit-vectors category and 18 in the strings category). No other solver solved more than 1 problem in this track.\nThe EUSOLVER solved 751 benchmarks uniquely (720 in the bit-vectors category and 31 in the strings category), and CVC4-1.5.1 solved 4 benchmarks uniquely (all in the strings category)."}, {"heading": "3.2 Detailed Results", "text": "In the following section we show the results of the competition from the benchmark\u2019s perspective. For a given benchmark we would like to know: how many solvers solved it, what is the min and max time to solve, what are the min and max size of the expressions produced, which solver solved the benchmark the fastest, and which solver produced the smallest expression.\nWe represents the results per benchmarks in groups organized per tracks and categories. For instance, Fig. 6 at the top presents details of the compiler optimization benchmarks. The black bars show the range of the time to solve among the different solvers in pseudo logarithmic scale (as indicated on the upper part of the y-axis). Inspect for instance benchmark qm_choose_01.sl. The black bar indicates that the fastest solver to solve it used less than 1 second, and the slowest used between 100 to 300 seconds. The black number above the black bar indicates the exact number of seconds (floor-rounded to the nearest second) it took the slowest solver to solve a benchmark (and \u221e if at least one solver exceeded the time bound). Thus, we can see that the slowest solver to solve qm_choose_01.sl took 199 seconds to solve it. The white number at the lower part of the bar indicates the time of the fastest solver to solve that benchmark. Thus, we can see that the fastest solver to solve qm_choose_01.sl required less than 1 second to do so. The colored squares/rectangles next to the lower part of the black bar, indicate which solvers were the fastest to solve that benchmark (according to the solvers\u2019 legend at the top). Here, fastest means in the same logarithmic scale as the absolute fastest solver. For instance, we can see that ENUMERATIVE, STOCHASTIC, and EUSOLVER were the fastest to solve qm_choose_01.sl, solving it in less than a second and that among the 2 solvers that solved MPwoL_d5s3.sl only ENUMERATIVE\nCompiler Optimizations and Bitvectors Category\nsolved it in less than 3 seconds. Similarly, the gray bars indicate the range of expression sizes in pseudo logarithmic scales (as indicated on the lower part of the y-axis), where the size of an expression is determined by the number of nodes in its parse tree. The black number at the bottom of the gray bar indicates the exact size expression of the largest solution (or \u221e if it exceeded 1000), and the white number at the top of the gray bar indicates the exact size expression of the smallest solution. The colored squares/rectangles next to the upper part of the gray bar indicates which solvers (according to the legend) produced the smallest expression (where smallest means in the same logarithmic scale as the absolute smallest expression). For instance, for qm_choose_01.sl the smallest expression produced had size 7, and 4 solvers out of the 5 who solved it managed to produce an expression of size less than 10.\nFinally, at the top of the figure above each benchmark there is a number indicating the number of solvers that solved that benchmark. For instance, one solver solved qm_max3.sl, two solvers solved qm_neg2.sl, three solvers solved qm_loop2.sl, and no solver solved qm_max4.sl or twolets10.sl. Note that the reason twolest10.sl has 20 as the lower time bound, is that that is the time to terminate rather than the time to solve. Thus, one of the solvers has terminated within 20 seconds, but either it did not produce a result, or it produced an incorrect result. When no solver produced a correct result, there will be no colored squares/rectangles next to the lower parts of the bars."}, {"heading": "3.3 Observations", "text": "Analyzing the results of the general track per category (see Figure 13), along the number of benchmarks solved, the number of benchmarks solved uniquely and the number of benchmarks solved among the fastest, we can see that each category of the general track has a clear winner: \u2022 CVC4-1.5.1 won 4 categories: Arrays, Let & Motion Planning, Hackers\u2019 Delight and Integers. \u2022 ENUMERATIVE won 3 categories: Compiler-Optimizations, Invariant Generation and Invariant\nGeneration with unbounded integers.\n\u2022 EUSOLVER won 3 categories: Multiple Functions and ICFP. If we disregard the partition to categories we can make the following observations: \u2022 EUSOLVER solved more benchmarks of the general track than all other solvers\n\u2013 EUSOLVER solved 206/309, \u2013 CVC4-1.5.1 solved 195/306, and \u2013 ENUMERATIVE solved 139/309.\n\u2022 In terms of time to solve, CVC4-1.5.1 solved more benchmarks among the fastest \u2013 CVC4-1.5.1 solved 157 among fastest, \u2013 EUSOLVER solved 123 among fastest, and \u2013 ENUMERATIVE solved 114 among fastest.\nWith regard to expression sizes, we see that in average CVC4-1.5.1 and EUSOLVER generate large expressions. The average expression size for CVC4-1.5.1 is 31580.5 and for EUSOLVER it is 30595.7 whereas the average sizes of ENUMERATIVE, SKETCH-AC and STOCHASTIC are between 11.9 to 17.1. This comparison is not particularly fair, since both CVC4-1.5.1 and EUSOLVER solved more benchmarks in general, so that might be the reason. For this reason we give the exact size expression per benchmark in the detailed evaluation figures (Figs. 6 to 9). Looking at these figures we can see that in many instances where the benchmark was solved by both CVC4-1.5.1 and EUSOLVER, the size of the expression generated by EUSOLVER was in a smaller bucket according to our pseudo-logarithmic scale, see for instance the array_search* benchmarks and the fg_max* benchmarks.\nInvaraint Generation with Bounded Integers\nMultiple Functions Category\nHackers Delight Category\nCLIA Track Part1\nInv Track Part1\nPBE Strings Part1"}, {"heading": "4 Discussion", "text": "We present a few interesting dimensions in which the SyGuS competition has evolved over the past 3 years. The timeline for the tracks and the solvers submitted for each competition is shown in Figure 14. The first competition in 2014 had a single General track, and 5 solvers competed in the competition that included enumerative, stochastic, symbolic, and machine learning-based synthesis algorithms. The second competition introduced two new tracks: conditional linear integer arithmetic track and the invariant synthesis track. There were 7 new solver submissions that implemented SMT-based quantifier instantiation, adaptive concretization of unknowns, BDD-based symbolic algorithms, and geometric optimization based synthesis algorithms. In the 2016 competition, we introduced another new track, the PBE track, and two new solvers EUSOLVER and CVC4-1.5.1 participated in the competition.\nThe percentage of benchmarks in the General track solved by the solvers participating in the first competition as compared to the solvers in the third competition is shown in Figure 15. As we can observe, a much higher fraction of benchmarks are solved by solvers in the third competition as compared to the solvers from the first competition. The successful and challenging classes of benchmarks from each competition is shown in Figure 16. We can observe that many of the challenging benchmarks from the previous competition are tackled by the solvers in the newer competition."}, {"heading": "Acknowledgments", "text": "We would like to thank the following people for various interesting discussions related to the competition, its tracks, the SyGuS format and various other topics related to syntax-guided synthesis: Viktor Kuncak, Arjun Radhakrishna, and Andrew Reynolds.\nWe would like to thanks the StarExec [34] team, and especially Aaron Stump, for allowing us to use their platform and for their remarkable support for SyGuS-Comp\u2019s special needs.\nThis research was supported by US NSF grant CCF-1138996 (ExCAPE)."}], "references": [{"title": "Calibrating Research in Program Synthesis Using 72,000 Hours of Programmer Time", "author": ["Takuya Akiba", "Kentaro Imajo", "Hiroaki Iwami", "Yoichi Iwata", "Toshiki Kataoka", "Naohiro Takahashi", "Micha Moskal", "Nikhil Swamy"], "venue": "SyGuS-Comp", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2014}, {"title": "Syntax-guided synthesis. In: Formal Methods in Computer-Aided Design, FMCAD", "author": ["Rajeev Alur", "Rastislav Bod\u0131\u0301k", "Garvit Juniwal", "Milo M.K. Martin", "Mukund Raghothaman", "Sanjit A. Seshia", "Rishabh Singh", "Armando Solar-Lezama", "Emina Torlak", "Abhishek Udupa"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2013}, {"title": "Synthesis Through Unification", "author": ["Rajeev Alur", "Pavol Cern\u00fd", "Arjun Radhakrishna"], "venue": "Computer Aided Verification - 27th International Conference,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "Results and Analysis of SyGuS- Comp\u201915", "author": ["Rajeev Alur", "Dana Fisman", "Rishabh Singh", "Armando Solar-Lezama"], "venue": "SYNT, EPTCS,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Using SyGuS to Synthesize Reactive Motion Plans", "author": ["Sarah Chasins", "Julie Newcomb"], "venue": "Workshop on Synthesis, SYNT 2016,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2016}, {"title": "Synthesis of Fault-Attack Countermeasures for Cryptographic Circuits", "author": ["Hassan Eldib", "Meng Wu", "Chao Wang"], "venue": "Computer Aided Verification - 28th International Conference,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2016}, {"title": "Synthesizing data structure transformations from input-output examples", "author": ["John K. Feser", "Swarat Chaudhuri", "Isil Dillig"], "venue": "In: PLDI,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "ICE: A Robust Framework for Learning Invariants", "author": ["Pranav Garg", "Christof L\u00f6ding", "P. Madhusudan", "Daniel Neider"], "venue": "Computer Aided Verification - 26th International Conference,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2014}, {"title": "Learning invariants using decision trees and implication counterexamples", "author": ["Pranav Garg", "Daniel Neider", "P. Madhusudan", "Dan Roth"], "venue": "Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2016}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["Sumit Gulwani"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2011}, {"title": "Spreadsheet data manipulation using examples", "author": ["Sumit Gulwani", "William R. Harris", "Rishabh Singh"], "venue": "Commun. ACM 55(8),", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Oracle-guided Component-based Program Synthesis", "author": ["Susmit Jha", "Sumit Gulwani", "Sanjit A. Seshia", "Ashish Tiwari"], "venue": "Proceedings of the 32Nd ACM/IEEE International Conference on Software Engineering - Volume 1,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "Interactive parser synthesis by example", "author": ["Alan Leung", "John Sarracino", "Sorin Lerner"], "venue": "In: PLDI,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2015}, {"title": "Alloy*: A General-Purpose Higher-Order Relational Constraint Solver", "author": ["Aleksandar Milicevic", "Joseph P. Near", "Eunsuk Kang", "Daniel Jackson"], "venue": "IEEE/ACM International Conference on Software Engineering, ICSE 2015, Florence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "ICE DT: Learning Invariants using Decision Trees and Implication Counterexamples", "author": ["Daniel Neider", "P. Madhusudan", "Pranav Garg"], "venue": "Private Communication", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Alchemist CS: An SMT-based synthesizer for Functions in Linear Integer Arithmetic", "author": ["Daniel Neider", "Shambwaditya Saha", "P. Madhusudan"], "venue": "Private Communication", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2015}, {"title": "Type-and-example-directed program synthesis", "author": ["Peter-Michael Osera", "Steve Zdancewic"], "venue": "PLDI, pp. 619\u2013630,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2015}, {"title": "Language to Specify Syntax-Guided Synthesis Problems", "author": ["Mukund Raghothaman", "Abhishek Udupa"], "venue": "CoRR abs/1405.5590", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2014}, {"title": "Refactoring with synthesis", "author": ["Veselin Raychev", "Max Sch\u00e4fer", "Manu Sridharan", "Martin T. Vechev"], "venue": "In: OOPSLA,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2013}, {"title": "Counterexample-Guided Quantifier Instantiation for Synthesis in SMT", "author": ["Andrew Reynolds", "Morgan Deters", "Viktor Kuncak", "Cesare Tinelli", "Clark W. Barrett"], "venue": "Computer Aided Verification - 27th International Conference,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2015}, {"title": "absTract sOlution Analyzing Synthesis Tool (System Description)", "author": ["Heinz Riener", "Rudiger Ehlers"], "venue": "Private Communication", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2015}, {"title": "Alchemist: Learning Guarded Affine Functions", "author": ["Shambwaditya Saha", "Pranav Garg", "P. Madhusudan"], "venue": "Computer Aided Verification - 27th International Conference,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2015}, {"title": "Alchemist CS DT: Synthesizing Guarded Affine Functions using Constraint Solving and Decision-tree Learning", "author": ["Shambwaditya Saha", "Daniel Neider", "P. Madhusudan"], "venue": "Private Communication", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2015}, {"title": "BlinkFill: Semi-supervised Programming By Example for Syntactic String Transformations", "author": ["Rishabh Singh"], "venue": "PVLDB 9(10),", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2016}, {"title": "Synthesizing data structure manipulations from storyboards", "author": ["Rishabh Singh", "Armando Solar-Lezama"], "venue": "FSE, pp. 289\u2013299,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2011}, {"title": "SPT: Storyboard Programming Tool", "author": ["Rishabh Singh", "Armando Solar-Lezama"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2012}, {"title": "Programming by sketching for bit-streaming programs", "author": ["Armando Solar-Lezama", "Rodric M. Rabbah", "Rastislav Bod\u0131\u0301k", "Kemal Ebcioglu"], "venue": "Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2005}, {"title": "Combinatorial sketching for finite programs", "author": ["Armando Solar-Lezama", "Liviu Tancau", "Rastislav Bod\u0131\u0301k", "Sanjit A. Seshia", "Vijay A. Saraswat"], "venue": "Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2006}, {"title": "StarExec: A Cross-Community Infrastructure for Logic Solving", "author": ["Aaron Stump", "Geoff Sutcliffe", "Cesare Tinelli"], "venue": "Proceedings, pp. 367\u2013373,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2014}, {"title": "A lightweight symbolic virtual machine for solver-aided host", "author": ["Emina Torlak", "Rastislav"], "venue": "Bod\u0131\u0301k", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2014}], "referenceMentions": [{"referenceID": 3, "context": "The SyGuS format is detailed in other publications [7, 2],[22, 5, 6], but at a high-level, the SyGuS format is based on the popular SMT-LIB format for defining SMT problems and is extended to support the description of function grammars.", "startOffset": 51, "endOffset": 57}, {"referenceID": 17, "context": "The SyGuS format is detailed in other publications [7, 2],[22, 5, 6], but at a high-level, the SyGuS format is based on the popular SMT-LIB format for defining SMT problems and is extended to support the description of function grammars.", "startOffset": 58, "endOffset": 68}, {"referenceID": 1, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 110, "endOffset": 119}, {"referenceID": 3, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 110, "endOffset": 119}, {"referenceID": 7, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 19, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 21, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 13, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 2, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 8, "context": "For example, the competition has provided important insights into the relative merits of different algorithms [3, 2, 7] which have been exploited to help develop and evaluate new algorithms [11, 15, 24, 26, 18, 4, 12].", "startOffset": 190, "endOffset": 217}, {"referenceID": 4, "context": "SyGuS has found various interesting applications among which are motion planning [8], compiler optimizations, and cybersecurity [9].", "startOffset": 81, "endOffset": 84}, {"referenceID": 5, "context": "SyGuS has found various interesting applications among which are motion planning [8], compiler optimizations, and cybersecurity [9].", "startOffset": 128, "endOffset": 131}, {"referenceID": 3, "context": "We illustrate this format with an example from last year\u2019s report [7].", "startOffset": 66, "endOffset": 69}, {"referenceID": 9, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 108, "endOffset": 120}, {"referenceID": 10, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 108, "endOffset": 120}, {"referenceID": 23, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 108, "endOffset": 120}, {"referenceID": 24, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 151, "endOffset": 159}, {"referenceID": 25, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 151, "endOffset": 159}, {"referenceID": 12, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 190, "endOffset": 194}, {"referenceID": 16, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 255, "endOffset": 263}, {"referenceID": 6, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 255, "endOffset": 263}, {"referenceID": 18, "context": "Programming By Examples (PBE) systems have been developed for many domains including string transformations [13, 14, 28], data structure manipulations [29, 30], interactive parser synthesis [17], higher-order functional programs over recursive data types [21, 10], and program refactorings [23].", "startOffset": 290, "endOffset": 294}, {"referenceID": 9, "context": "Example Consider the following task taken from FlashFill [13, 14] that requires learning a string transformation program that constructs the initials of the first and last names.", "startOffset": 57, "endOffset": 65}, {"referenceID": 10, "context": "Example Consider the following task taken from FlashFill [13, 14] that requires learning a string transformation program that constructs the initials of the first and last names.", "startOffset": 57, "endOffset": 65}, {"referenceID": 9, "context": "The benchmarks in the PBE track can be classified into two categories: \u2022 String Transformations: The 108 string transformation tasks are taken from public benchmarks of FlashFill [13, 14] and BlinkFill [28].", "startOffset": 179, "endOffset": 187}, {"referenceID": 10, "context": "The benchmarks in the PBE track can be classified into two categories: \u2022 String Transformations: The 108 string transformation tasks are taken from public benchmarks of FlashFill [13, 14] and BlinkFill [28].", "startOffset": 179, "endOffset": 187}, {"referenceID": 23, "context": "The benchmarks in the PBE track can be classified into two categories: \u2022 String Transformations: The 108 string transformation tasks are taken from public benchmarks of FlashFill [13, 14] and BlinkFill [28].", "startOffset": 202, "endOffset": 206}, {"referenceID": 0, "context": "\u2022 Bitvector Transformations: The 450 bitvector transformation benchmarks were obtained from the 2013 ICFP Programming Competition2 [1].", "startOffset": 131, "endOffset": 134}, {"referenceID": 19, "context": "1 solver employs a refutation-based synthesis approach [24].", "startOffset": 55, "endOffset": 59}, {"referenceID": 28, "context": "3 Experimental Setup The solvers were run on the StarExec platform [34] with a dedicated cluster of 12 nodes, where each node consisted of two 4-core 2.", "startOffset": 67, "endOffset": 71}], "year": 2016, "abstractText": "Syntax-Guided Synthesis (SyGuS) is the computational problem of finding an implementation f that meets both a semantic constraint given by a logical formula \u03c6 in a background theory T , and a syntactic constraint given by a grammar G, which specifies the allowed set of candidate implementations. Such a synthesis problem can be formally defined in SyGuS-IF, a language that is built on top of SMT-LIB. The Syntax-Guided Synthesis Competition (SyGuS-Comp) is an effort to facilitate, bring together and accelerate research and development of efficient solvers for SyGuS by providing a platform for evaluating different synthesis techniques on a comprehensive set of benchmarks. In this year\u2019s competition we added a new track devoted to programming by examples. This track consisted of two categories, one using the theory of bit-vectors and one using the theory of strings. This paper presents and analyses the results of SyGuS-Comp\u201916.", "creator": "LaTeX with hyperref package"}}}