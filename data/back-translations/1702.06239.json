{"id": "1702.06239", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Feb-2017", "title": "Reinforcement Learning Based Argument Component Detection", "abstract": "The recognition of argumentation components (Argument Component Detection, ACD) is an important sub-task in argumentation mining. ACD aims to identify and classify various argument components in texts with natural language. Historical annotations (HAs) are important features that human annotators take into account when performing the ACD task manually. However, HAs are largely ignored by existing automatic ACD techniques. Reinforcement Learning (RL) has proven to be an effective method of using HAs in some tasks for processing natural language. In this paper, we propose an RL-based ACD technique and evaluate their performance based on two well-annotated corpora. Results suggest that HAs-augmented RL outperforms pure RL in terms of classification accuracy by no more than 17.85% and outperforms the state-of-the-art supervised learning algorithm by no more than 11.94%.", "histories": [["v1", "Tue, 21 Feb 2017 02:18:38 GMT  (329kb,D)", "http://arxiv.org/abs/1702.06239v1", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["yang gao", "hao wang", "chen zhang", "wei wang"], "accepted": false, "id": "1702.06239"}, "pdf": {"name": "1702.06239.pdf", "metadata": {"source": "CRF", "title": "Reinforcement Learning Based Argument Component Detection", "authors": ["Yang Gao", "Hao Wang", "Chen Zhang", "Wei Wang"], "emails": ["wangwei2014}@iscas.ac.cn"], "sections": [{"heading": "1 Introduction", "text": "The automatic extraction of arguments from natural language texts, also known as argumentation mining, has recently become a hot topic in artificial intelligence (c.f. [Lippi and Torroni, 2015a]). An argument is a basic unit people use to persuade their audiences to accept a particular state of affairs [Eckle-Kohler et al., 2015], and it usually consists of a claim and some premises offered in support of the claim. As a concrete example, consider the following texts extracted from a hotel review posted on Tripadvisor.com:\nExample 1: 1\u00a9 Appalling in room television/radio/technology. 2\u00a9 There was an old, small, black, CRT TV. 3\u00a9 The channel selection was minimal, 4\u00a9 picture quality average, and 5\u00a9 movie options unimpressive.\nThe review excerpt in Example 1 can be viewed as an argument: clause 1\u00a9 is the claim of the argument, and the other four clauses are premises supporting the claim. Argumentation mining consists of three sub-tasks i) segmenting clauses, ii) distinguishing different argument components (e.g. claims, premises) from non-argumentative clauses, and iii) predicting the relations between argument components\n(e.g. support/attack). In this work, we term the second subtask in argumentation mining argument component detection (ACD), and it is the focus of many existing argumentation mining papers and this work alike. Motivation. When human annotators manually perform the ACD task, they decide the label of a clause not only based on the clause\u2019s own linguistic features, but also on its context. For instance, consider again Example 1: if we consider clause 2\u00a9 alone and ignore its surrounding clauses, we are very likely to label it as a claim; however, if we additionally consider the content and label of 1\u00a9, we may instead label 2\u00a9 as a premise. To obtain the contextual information, human annotators usually need to read and label a document for multiple rounds [Stab and Gurevych, 2014a]. However, despite the importance of contextual information, it is ignored by most existing automatic ACD methods. In this work, we consider a specific form of contextual information called historical annotations (HAs), and investigate how to effectively use it in ACD.\nIn particular, given a target clause to be annotated, human annotators may consider two types of HAs during their multiround annotating process: type-L (L stands for \u2019last round\u2019): labels of some clauses surrounding the target clause, made in the previous round of annotating; and type-C (C stands for \u2019current round\u2019): labels of some clauses preceding the target clause, made in the current round of annotating. Fig. 1 illustrates these two types of HAs. We consider HAs rather than other types of contextual information (e.g. the topic of a document, linguistic features of some surrounding clauses, etc.) for two reasons: i) HAs take only a few bits to encode in vectorised representations; and ii) HAs have been widely used in some NLP tasks, e.g. text summarisation [Rioux et al., 2014] and dialogue generation [Pietquin et al., 2011]. To the best of our knowledge, this is the first work that studies the usage and influence of HAs in the ACD task. Objectives. Our first objective is to present the design and implementation of the first reinforcement learning (RL) based ACD technique. When HAs are used in the annotating process, the label of the current clause is part of the contextual information of surrounding clauses (see Fig. 1); thus, the annotating process can be modelled as a sequential decision making problem, as the current decision (i.e. label for the current clause) influences the future decisions. We formally formulate ACD as a sequential decision making problem, and ar X iv :1 70 2.\n06 23\n9v 1\n[ cs\n.C L\n] 2\n1 Fe\nb 20\n17\nselect suitable RL algorithms to solve it. Our second objective is to study the influences of HAs on different ACD methods. We evaluate the performances of both RL-based ACD and some state-of-the-art supervisedlearning (SL) based ACD on two corpora; results suggest that, using HAs results in no significant performance changes for SL-based ACD tools, but leads to significant performance improvements for RL-based ACD; in particular, by using appropriate HAs, RL\u2019s accuracy is improved by 8.90% and 17.85% in the two test corpora. In addition, HAs-augmented RL significantly outperforms (in terms of accuracy) the state-of-theart SL algorithm by 5.56% and 11.94% in two test corpora."}, {"heading": "2 Related Work", "text": "Works on ACD. Most existing automatic ACD methods model ACD as a classification task, and their focuses are mostly on designing useful features to represent clauses, and selecting appropriate SL-based classifiers. Widely used features include structural, lexical, syntactic and contextual features, and popular classifiers include SVM, naive Bayes, decision tree and random forest. For well-structured documents, using these SL classifiers and conventional features leads to relatively good performances: for example, SVM achieves .726 and .741 macro-F1 in corpora consisting of persuasive essays [Stab and Gurevych, 2014a; Stab and Gurevych, 2014b] and legal documents [Palau and Moens, 2009], resp. However, for some less well-structured texts, e.g. Wikipedia articles, these methods have significantly poorer performances: [Levy et al., 2014; Lippi and Torroni, 2015b] report that in the task for detecting claims from Wikipedia articles, only around .17 F1 is achieved, although they have tried different features (topic-dependent features and partial constituency trees, resp.) and different classifiers (logistic regression and SVM, resp.).\nSome works are devoted to using unsupervised-learning techniques to extract features. [Lawrence et al., 2014] assume that clauses belonging to the same argument are likely\nto share the same topic; thus, they employ the LDA-based topic modelling technique [Blei et al., 2003] to extract each clause\u2019s topics and use these topics as features. [Nguyen and Litman, 2015] use LDA to extract the argument words (i.e. words used as argument indicators, e.g. \u2018think\u2019, \u2018reason\u2019) and domain words (i.e. terminologies commonly used within a certain topic, e.g. \u2018education\u2019, \u2019art\u2019), and add indicator features for these words. However, these features have only been tested on small corpora constructed from well-structured documents (the former is tested on documents obtained from a 19th century philosophical book, while the later is tested on the persuasive essay corpus proposed in [Stab and Gurevych, 2014a]), and the computational expense of LDA is high.\nWorks on contextual information in ACD. HAs have been implicitly used in some SL-based ACD tools. In [Habernal and Gurevych, 2015], ACD is modelled as a sequence tagging problem, and SVM-HMM [Altun et al., 2003] is used to solve this problem; SVM-HMM implicitly considers type-C HAs during the labelling process. Their technique achieves macro-F1 between .185 and .304 in debate portal documents. Type-C HAs are arguably the de facto features used by RLbased NLP tools. In RL-based text summarisation techniques [Ryang and Abekawa, 2012; Rioux et al., 2014], annotations of all preceding sentences, made in the current round of scanning, are included in the feature vector; in RL-based dialogue generation systems, e.g. [Pietquin et al., 2011; Williams and Young, 2007], the full history of dialogue acts in the current dialogue is used in the state representation. However, all these works do not compare the performances of HAs-augmented and HAs-free versions of their techniques, thus fail to investigate to what extent the usage of HAs can improve performance.\nAs for other forms of contextual information, in [Levy et al., 2014], the topic of a document is used to build features to identify claims. To be more specific, given a clause, the similarity between this clause and the topic sentence is used to decide whether this clause is a claim or not. However, the importance of the topic information is questionable, as [Lippi and Torroni, 2015b] report that similar performances can be obtained without using the topic information."}, {"heading": "3 Formulating ACD as a Sequential Decision Making Problem", "text": "Markov decision processes (MDPs) are widely used mathematical models for formulating sequential decision making problems. In this work, we consider ACD formally as episodic MDPs. An episodic MDP is a tuple (S,A, P,R, T ). S is the set of states; a state is a representation of the current status of the problem at hand. A is the set of actions. By performing an action a in state s, the agent is transited to some new state s\u2032 and receives a numerical reward R(s, a), where R : S \u00d7 A \u2192 R is the reward function. P (s\u2032|s, a) \u2208 [0, 1] is the transition function: it gives the probability of moving from state s to s\u2032 by performing action a. T \u2286 S is the set of terminal states: when the agent is transited to a state s \u2208 T , the current episode ends. The components of our MDP-based ACD formulation are as follows:\nState set S. Each state s represents a clause to be anno-\ntated. Thus, we let s be a feature vector, which includes not only the current clause\u2019s linguistic features, but may also include type-L and type-C HAs. We let Na denote the length of the conventional linguistic features, Nl and Nc denote the window sizes for type-L and type-C HAs, resp., andN denote the length of the state vector; thus, N = Na +Nl +Nc.\nAction set A. Given a state s, performing action a on s means labelling the corresponding clause of s as type a. Thus, each action in A corresponds to a type of label.\nTransition probability P . Given the above formulations of S andA, P (s\u2032|s, a) gives the next clause s\u2032 to be annotated after the current clause\u2019s labelling finishes. In other words, P decides the sequence of labelling. As such, we can use a short-hand notation P (s) = s\u2032 to indicate that, after s is annotated, no matter what its annotation is, the next clause to be annotated is s\u2032; in this work, for simplicity, we let s\u2032 be the clause ensuing s; investigating the effectiveness of other sequences of labelling is left as a future work.\nReward function R. R(s, a) evaluates the goodness of annotating s as type a. Thus, we let R(s, a) be positive (negative, resp.) if a is (not, resp.) the same to the gold-standard annotation of s. Note that function R is known during the training phase but is unknown in the test phase.\nTerminal states set T . We view labelling a document for one round as an episode. Thus, s \u2208 T if and only if s corresponds to the last clause in a document.\nA policy \u03c0 : S \u2192 A specifies the action to take in each state. RL amounts to algorithms for obtaining the (near)optimal policies for MDPs, even some components (e.g. function R) of the MDP are unknown. To obtain the optimal policy, RL maintains a Q-function, which provides a quantitative evaluation of the current policy being used. Specifically, given a policy \u03c0, its Q-functionQ\u03c0(s, a) gives the discounted sum of rewards that will be received by performing action a in state s and following policy \u03c0 thereafter:\nQ\u03c0(s, a) = E\u03c0[r0 + \u03b3r1 + \u03b3 2r2 + \u00b7 \u00b7 \u00b7 ], (1)\nwhere rt is the immediate reward received in time step t, E\u03c0 is the expectation operator with respect to policy \u03c0, and \u03b3 \u2208 [0, 1] is a real-valued parameter known as the discount factor.\nIn the ACD task, the RL agent proceeds as follows to obtain the optimal policy: the RL agent first uses some random policy to annotate the input documents for one round, and collects the rewards (produced by reward function R) during the labelling process; then the RL agent uses these rewards to build the Q-function of the policy, so as to evaluate the goodness of the current policy and derive an improved policy. The newly-obtained policy is used to label the input documents for another round, and the improvement cycle repeats until the policy converges (i.e. two consecutive policies are the same). Most RL algorithms ensure that the converged policy is optimal. Fig. 2 illustrates the workflow of RL-based ACD."}, {"heading": "4 RL-based ACD Framework", "text": "To select suitable RL algorithms for a MDP is not a trivial task, as RL algorithms fall into many different categories, each suitable for certain types of MDPs. We consider the following two factors when we select RL algorithms for our MDP-based ACD formulation presented in Sect. 3:\nAlgorithm 1 The RL-based ACD method (one fold in the cross-validation).\n1: GIVEN: 2: the training set Dtrain, test set Dtest, discount factor \u03b3,\nepisode round K, maximum scan round J 3: TRAIN: 4: for document d in Dtrain do 5: for each episode (K episodes in total) do 6: invoke LSPI in each learning step, so as to evaluate and improve the current policy 7: end for 8: end for 9: output the learnt policy \u03c0\u2217 10: TEST: 11: for document d in Dtest do 12: initialise LastRoundAnnList as an empty list 13: for each round of scan (J rounds at most) do 14: produce AnnList for clauses in d, using \u03c0\u2217 and considering LastRoundAnnList 15: break if LastRoundAnnList == AnnList 16: LastRoundAnnList\u2190 AnnList 17: end for 18: output and evaluate AnnList 19: end for\n\u2022 Data efficiency. Since there exist few high-quality and large-scale ACD corpora (c.f. [Lippi and Torroni, 2015a]), we need to select RL algorithms with strong generalisation capabilities, so as to learn the optimal policies with limited amount of training data.\n\u2022 Computational efficiency. Obtaining the optimal policy usually requires many rounds of policy improvement. Thus, the computational expense for each round of improvement should be small enough.\nTo strike a trade-off between the above two factors, we decide to use the least square policy iteration (LSPI) [Lagoudakis and Parr, 2003] algorithm to solve our MDPbased ACD. LSPI is a model-based RL algorithm, which can efficiently use the training data. The computational complexity of LSPI increases linearly with the growth of the sample size, and some works have been proposed to further reduce its complexity (e.g. [Geramifard et al., 2006; Sutton et al., 2009]).\nThe LSPI-based ACD framework is presented in Alg. 1. In the training phase (lines 4-8), the RL agent labels each document for K rounds so as to obtain the optimal policy; each round of labelling is called an episode (line 5). The obtained policy is output after the training phase finishes (line 9).\nIn the test phase (lines 11-19), since type-L HAs are used in the state representation (see Sect. 3), the feature vector for the same clause can be different in different rounds (see Fig. 1); as a result, the algorithm needs to label the same document for multiple rounds until the annotations converge, i.e. the annotations in the current round (stored in list AnnList, line 14) are the same to those made in the last round (stored in LastRoundAnnList). Once the annotations converge, the algorithm breaks the loop (line 15) and begins to label the next test document; else, if annotations fail to converge in J (an positive integer provided a priori; see line 2) rounds of labelling, the algorithm outputs the annotations obtained in the final round (line 18).\nNow we discuss the computational complexity of LSPIbased ACD. Suppose there are M clauses in the training set, and each document is labelled for K rounds; also remind that the state vector size is N (see Sect. 3). As such, the complexity of each episode (line 6) using LSPI is O(N2), and the complexity for obtaining the final policy (line 9) is O(N3) [Lagoudakis and Parr, 2003]; thus, the overall complexity in the training phase is O(KMN2 +N3).\nAs for the complexity of SVM-based ACD, again, we suppose that there are M clauses in the training set and each document is labelled for K rounds. For each clause, as its annotation can be different in different rounds of labelling (see Fig. 1), each clause has K different vector representations. Thus, there are in total KM input vectors in the training phase. In line with most existing SL-based ACD (see Sect. 2), we select SVM with RBF kernel as the classifier, and its complexity in the training phase is between O(N(KM)2) and O(N(KM)3) (using LIBSVM [Chang and Lin, 2011]). As for SVM-HMM [Altun et al., 2003], its complexity is no cheaper than standard SVM. To summarise, the training complexity of SVM/SVM-HMM is (at least) quadratic with the number of samples, while the complexity of LSPI is linear with the number of samples; thus, LSPI-based ACD scales better when applied to large-scale corpora, and is more suitable for applications with short feature vectors.\nIn the test phase, the complexity for computing the annotation for one clause is O(N \u00b7 |A|) when using LSPI, but is approximately O(N2) [Claesen et al., 2014] when using SVM and SVM-HMM (with RBF kernel). Since the number of annotation types |A| is usually much smaller than the vector length N , the computational complexity of LSPI is usually lower in the test phase."}, {"heading": "5 Datasets", "text": "When selecting corpora for testing our methods, we primarily consider the labelling quality of the corpora, because the corpora\u2019s quality heavily influences the quality of the ACD tools trained on them [Habernal and Gurevych, 2015]. The inter-rater agreement (IRA) score is a widely used metric to evaluate the reliability of annotations and quality of corpora.\nFleiss\u2019 kappa [Fleiss, 1971] is among the most widely used IRA metrics, because it can compute the agreement between two or more raters, and it considers the possibility of the agreement occurring by chance, thus giving more \u201crobust\u201d measure than simple percentage agreement. If the Fleiss\u2019 kappa score equals 1, it suggests the raters have \u201cperfect agreement\u201d; the lower the score, the poorer the agreement. In this work, all IRA scores reported are Fleiss\u2019 kappa values.\nSince there exist few well-annotated and publicly available argumentation corpora, we create our own argumentation corpus.1 We randomly sampled 200 hotel reviews of appropriate length (50 - 200 words) in the hotel review dataset provided by [Wachsmuth et al., 2014]. We presented these hotel reviews on a crowdsourcing platform, and asked five workers to independently annotate each review. Similar to [Wachsmuth et al., 2015], we viewed each sub-sentence as a clause. We asked the workers to label each clause as one of the following six categories: \u2022 major claim: summarises the main opinion of a review; \u2022 claim: an opinion on a certain aspect of a hotel; \u2022 premise: a reason/evidence supporting a claim; \u2022 background: an objective description that does not give\ndirect opinions but provides some background information; for example \u201cthis is my second staying at this hotel\u201d, \u201cwe arrived at at midnight\u201d; \u2022 recommendation: a positive or negative recommenda-\ntion for the hotel, e.g. \u201cdo not come to this place if you want a luxury hotel\u201d, \u2018I would definitely come to this hotel again the next time I visit London\u2019; and \u2022 others, for all the other clauses.\nA detailed annotation guide and some examples were presented to the workers before they started their labelling. We asked the workers to give one and only one major claim for each hotel review, and informed them that a claim can have no premises, but each premise must support some claim. The annotating process lasts for 4 weeks, with 216 workers in total participated. We removed the annotations with obvious mistakes, and finally obtained annotations for 105 hotel reviews. In total, the corpus contains 1575 sub-sentences and 14756 tokens; some statistics are given in Table 1. Since the IRA for type others is lower than 0.5, we manually checked and calibrated all others annotations. Except for type others, all types have IRA scores above 0.6, suggesting that the agreement is substantial [Landis and Koch, 1977].\nAnother corpus we used to test our approach is the persuasive essays corpus proposed in [Stab and Gurevych, 2016]. This corpus contains 402 essays on a variety of different topics, and it has three argument component types: major claim,\n1Details of the creation of our hotel corpus is presented in a separate paper, which is currently under review.\nclaim and premise; the IRA scores for these three argumentative types are 0.88, 0.64 and 0.83, resp.; however, the IRA for type others is not reported.\nTo the best of our knowledge, these two corpora are among the most well-annotated argumentation corpora (in terms of IRA scores). Some larger corpora, e.g. the one in [Levy et al., 2014], have much lower IRA scores (.39); the legal texts corpus proposed in [Palau and Moens, 2009] is not publicly available, and the web texts corpus proposed in [Habernal et al., 2014] has relatively low IRA (below .50) for most argument component types."}, {"heading": "6 Experimental Settings and Results", "text": "In this section, we denote a HAs combination with type-L window size i and type-C window size j as a pair (i, j). Under each HAs combination setting, we used a repeated 10- fold cross-validation setup and ensured that clauses from the same document are not distributed over the train and test sets; in addition, we repeated the cross-validation 10 times, which yields a total of 100 folds. All results presented are average values over the 100 folds. We let the significance level be 0.05. As for the conventional linguistic features (see Sect. 3), we used exactly the same features to those in [Stab and Gurevych, 2014b]. For model selection and hyper-parameter tuning, we randomly sampled 25% documents (from both corpora) and performed 5-fold cross-validation."}, {"heading": "6.1 Baselines", "text": "We select SVM and SVM-HMM as our baselines, because these two algorithms are among the most widely used and best-performing algorithms to build ACD tools (see Sect. 2). As for the algorithm implementations, we used LIBSVM [Chang and Lin, 2011] for SVM and a revision of SVMstruct [Joachims et al., 2009] for SVM-HMM.\nAlthough SVM-HMM considers type-C HAs, it ignores type-L HAs and it does not consider HAs explicitly. For these reasons, and also for ensuring the fairness of comparison between SL- and RL-based ACD tools, we also test the performances of SVM and SVM-HMM using the HAs-augmented features. We try all HAs combinations from (0,0) to (9,5) in both baseline algorithms, and find that using HAs-augmented features does not result in significant changes on the performances of SVM and SVM-HMM in both corpora. We have tried using HAs-augmented features in some other SL algorithms (J48 decision tree, naive Bayes and random forest provided in WEKA [Hall et al., 2009]), and we make similar observations. These results suggest that, most existing SL-based ACD tools can hardly take advantage of HAs to improve their performances, either through the implicit way (e.g. SVMHMM, which implicitly considers type-C HAs) or the explicit way (i.e. directly augmenting HAs into the feature vector).\nAs for the relative goodness of SVM and SVM-HMM, these two baseline approaches have comparable performances in both corpora: consider the best performances achieved by SVM and SVM-HMM (presented in the first two rows in Table 2); in both corpora, although macro-F1 of SVM-HMM is marginally higher than those of SVM, the accuracy of SVM is higher than that of SVM-HMM, and the\nM acro-F1\ngaps between their accuracy and macro-F1 scores are all insignificant."}, {"heading": "6.2 Results", "text": "First, we study the influences of HAs on RL-based ACD. The performances of RL-based ACD using different HAs combinations are presented in Fig. 3. We can see that, in both corpora, the worst performances are obtained when no HAs are used, and the performances increase almost linearly with the growth of the type-L and type-C window sizes. To evaluate the significance of the improvement, we performed ttests between performances at (0, 0) (no HAs are used), (7, 0) (type-L is used to the maximum and no type-C is used), (0, 5) (type-C is used to the maximum and no type-L is used) and (7, 5) (both types of HAs are fully used); results suggest that the performance at (0, 0) is significantly inferior than the performances obtained in the other three settings, and the performance at (7, 5) is significantly superior than all the other performances. These observations indicate that, both typeL and type-C can significantly improve RL\u2019s performance in the ACD task, and the two types of HAs can be used together. As for the relative importance of type-L and type-C, since the performances\u2019 growth rate along the type-L and type-C dimensions are almost the same, we believe that the relative importance of these two types of HAs are comparable and their influences on the performances are independent.\nSecond, we compare the performances of RL-based ACD and the baseline approaches. Main results are presented in Table 2. The results for HAs-augmented RL (the last row in the table) are obtained using the HAs combination (7, 5). We make two key observations from these results: \u2022 HAs-free RL underperforms the baseline approaches\nin both corpora, but the performance gaps are mostly marginal and insignificant. To be more specific, except for the gap between the macro-F1 score of HAs-free RL (.521) and SVM-HMM (.582) in the hotel corpus, all other gaps between HAs-free RL\u2019s performance (namely accuracy and macro-F1) and those of the baseline approaches are not statistically significant. \u2022 HAs-augmented RL outperforms the baseline ap-\nproaches in both corpora, and the performance gaps are mostly substantial and significant. Specifically, except for the gap between the macro-F1 score of HAsaugmented RL (.696) and SVM-HMM (.683) in the essay corpus, all other gaps between HAs-augmented RL\u2019s\nperformance (accuracy and macro-F1) and those of the baseline approaches are significant.\nThe reason that HAs-free RL underperforms SVM/SVMHMM is because the RL algorithm we use (namely the LSPI algorithm; see Sect. 4 and Alg. 1) has much weaker \u201cexpressiveness\u201d than SVM/SVM-HMM: LSPI employs a linear function to evaluate Q-function (see Sect. 3 and Eq. (1)) thus, when the Q-function is complex, LSPI can hardly provide a precise estimation of the Q-function; since Q-function is used to derive annotation policies, the poor estimation of Q-function harms RL\u2019s performance. In contrast, SVM and SVM-HMM use RBF kernels to perform the classification, which has much stronger expressiveness than LSPI\u2019s linear function. Thus, we believe that by using more sophisticated RL algorithms, e.g. the kernel-based RL algorithms [Taylor and Parr, 2009; Ormoneit and Sen, 2002] and the recently proposed deep RL [Mnih et al., 2015], the performance of RL-based ACD can be substantially improved (at the price of higher computational complexity though)."}, {"heading": "6.3 Discussion and Error Analysis", "text": "To obtain further insights into how the usage of HAs improves the performance of RL, we look into the confusion matrices of each algorithm and manually investigate some misclassified cases. In both corpora, we find the biggest error source is the misclassification between premises and claims: for example, in the essay corpus, 607 out of 1506 claims are mis-classified as premises by SVM-HMM; in the hotel corpus, 88 out of 180 premises are mis-classified as claims by HAs-free RL. Similar observations are also reported in [Stab and Gurevych, 2014b], and we believe that ignoring contextual information (including HAs) is a major factor leading to these misclassifications, as illustrated in Example 1.We find that this problem is considerably mitigated by HAsaugmented RL: from Table 2 we can see that, in the essay corpus, HAs-augmented RL\u2019s performance for type premises leads baselines\u2019 performances by around 8%; in the hotel corpus, HAs-augmented RL\u2019s performance for type claim outperforms baselines\u2019 performances by over 10%. As a concrete example, HAs-augmented RL correctly labels 2\u00a9 to 5\u00a9 in Example 1 as premises, while the other approaches fail.\nIn the hotel corpus, another major error source is the misclassification of type others: from the right-most column in Table 2 we can see that the F1 score for type others is the lowest among all types\u2019 performances. We believe the reason is that, it is even challenging for human annotators to identify clauses of type others; this can be seen from the fact that the\nIRA score for others is the lowest (0.35; see Table 1). As a concrete example, consider the following review excerpt in our hotel corpus:\nExample 2: 1\u00a9 The rooms come in different sizes. 2\u00a9 The two other families we were traveling with had larger rooms \u2013 3\u00a9 see if you can book something larger (especially if traveling with kids).\nIn the crowdsourcing platform, 3 workers labelled 3\u00a9 as others while the other 2 workers labelled it as recommendations. We think the reason is that, when considering 3\u00a9 alone, it looks like a recommendation; but when considering all the three clauses, 3\u00a9 is more like others. Thus, HAs are important for identifying type others, and this may explain why HAsaugmented RL outperforms the other three ACD techniques by such a big margin for type others: when we let both typeL and type-C windows larger than 3, HAs-augmented RL can successfully label 3\u00a9 as others, while the other approaches label it as recommendation."}, {"heading": "7 Conclusion", "text": "In this work, we novelly propose a RL-based ACD technique, and study the influences of HAs therein. Empirical results on two corpora suggest that, using HAs can significantly improve RL-based ACD\u2019s performance, and the HAsaugmented RL\u2019s performance is significantly superior than those of the state-of-the-art SL-based ACD techniques. To the best of our knowledge, this is the first work systemically studying the influences of HAs and the applicability of RL in the ACD task. Future work includes studying the influences of some other contextual information, e.g. linguistic features of surrounding clauses, in SL- and RL-based ACD methods, and studying the applicability of RL for some other sub-tasks in argumentation mining, e.g. argument relation prediction."}], "references": [{"title": "et al", "author": ["Y. Altun", "I. Tsochantaridis", "T. Hofmann"], "venue": "Hidden Markov support vector machines. In Proc. of ICML", "citeRegEx": "Altun et al.. 2003", "shortCiteRegEx": null, "year": 2003}, {"title": "Latent dirichlet allocation", "author": ["D.M. Blei", "A.Y. Ng", "M.I. Jordan"], "venue": "JMLR, 3", "citeRegEx": "Blei et al.. 2003", "shortCiteRegEx": null, "year": 2003}, {"title": "LIBSVM: a library for support vector machines", "author": ["C.-C. Chang", "C.-J. Lin"], "venue": "ACM Transactions on Intelligent Systems and Technology (TIST), 2(3)", "citeRegEx": "Chang and Lin. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Fast prediction with SVM models containing RBF kernels", "author": ["M. Claesen", "F. De Smet", "J. Suykens", "B. De Moor"], "venue": "arXiv preprint arXiv:1403.0736", "citeRegEx": "Claesen et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "On the role of discourse markers for discriminating claims and premises in argumentative discourse", "author": ["J. Eckle-Kohler", "R. Kluge", "I. Gurevych"], "venue": "Proc. of EMNLP", "citeRegEx": "Eckle.Kohler et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Measuring nominal scale agreement among many raters", "author": ["J.L. Fleiss"], "venue": "Psychological Bulletin, 76(5):378\u2013382", "citeRegEx": "Fleiss. 1971", "shortCiteRegEx": null, "year": 1971}, {"title": "Incremental least-squares temporal difference learning", "author": ["A. Geramifard", "M. Bowling", "R.S. Sutton"], "venue": "Proc. of AAAI", "citeRegEx": "Geramifard et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Exploiting debate portals for semisupervised argumentation mining in user-generated web discourse", "author": ["I. Habernal", "I. Gurevych"], "venue": "Proc. of EMNLP", "citeRegEx": "Habernal and Gurevych. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Argumentation mining on the web from information seeking perspective", "author": ["I. Habernal", "J. Eckle-Kohler", "I. Gurevych"], "venue": "Proc. of the Workshop on Frontiers and Connections between Argumentation Theory and Natural Language Processing", "citeRegEx": "Habernal et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "The WEKA data mining software: an update", "author": ["M. Hall", "E. Frank", "G. Holmes", "B. Pfahringer", "P. Reutemann", "I.H. Witten"], "venue": "ACM SIGKDD explorations newsletter, 11(1):10\u201318", "citeRegEx": "Hall et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Cutting-plane training of structural SVMs", "author": ["T. Joachims", "T. Finley", "C.-N. Yu"], "venue": "Machine Learning, 77(1)", "citeRegEx": "Joachims et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "JMLR", "author": ["Michail G Lagoudakis", "Ronald Parr. Least-squares policy iteration"], "venue": "4:1107\u20131149,", "citeRegEx": "Lagoudakis and Parr. 2003", "shortCiteRegEx": null, "year": 2003}, {"title": "The measurement of observer agreement for categorical data", "author": ["J.R. Landis", "G.G. Koch"], "venue": "Biometrics, 33(1):159\u2013174", "citeRegEx": "Landis and Koch. 1977", "shortCiteRegEx": null, "year": 1977}, {"title": "Mining arguments from 19th century philosophical texts using topic based modelling", "author": ["J. Lawrence", "C. Ree", "A. Colin", "S. MacAlister", "A. Ravenscroft", "D. Bourget"], "venue": "Proc. of Workshop on Argumentation Mining", "citeRegEx": "Lawrence et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Context dependent claim detection", "author": ["R. Levy", "Y. Bilu", "D. Hershcovich", "E. Aharoni", "N. Slonim"], "venue": "Proc. of COLING", "citeRegEx": "Levy et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Argumentation mining: State of the art and emerging trends", "author": ["M. Lippi", "P. Torroni"], "venue": "ACM Transactions on Internet Technology", "citeRegEx": "Lippi and Torroni. 2015a", "shortCiteRegEx": null, "year": 2015}, {"title": "Context-independent claim detection for argument mining", "author": ["M. Lippi", "P. Torroni"], "venue": "Proc. of IJCAI", "citeRegEx": "Lippi and Torroni. 2015b", "shortCiteRegEx": null, "year": 2015}, {"title": "et al", "author": ["V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G. Ostrovski"], "venue": "Human-level control through deep reinforcement learning. Nature, 518(7540):529\u2013533", "citeRegEx": "Mnih et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Extracting argument and domain words for identifying argument components in texts", "author": ["H.V. Nguyen", "D.J. Litman"], "venue": "Proc. of Workshop on Argumentation Mining", "citeRegEx": "Nguyen and Litman. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Kernelbased reinforcement learning", "author": ["D. Ormoneit", "\u015a. Sen"], "venue": "MACH LEARN, 49(23):161\u2013178", "citeRegEx": "Ormoneit and Sen. 2002", "shortCiteRegEx": null, "year": 2002}, {"title": "Argumentation mining: the detection", "author": ["R.M. Palau", "M.-F. Moens"], "venue": "classification and structure of arguments in text. In Proc. of ICAIL", "citeRegEx": "Palau and Moens. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Sample efficient on-line learning of optimal dialogue policies with Kalman temporal differences", "author": ["O. Pietquin", "M. Geist", "S. Chandramohan"], "venue": "Proc. of IJCAI", "citeRegEx": "Pietquin et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Fear the REAPER: A system for automatic multidocument summarization with reinforcement learning", "author": ["C. Rioux", "S.A. Hasan", "Y. Chali"], "venue": "Proc. of EMNLP", "citeRegEx": "Rioux et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Framework of automatic text summarization using reinforcement learning", "author": ["S. Ryang", "T. Abekawa"], "venue": "Proc. of EMNLP", "citeRegEx": "Ryang and Abekawa. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "Annotating argument components and relations in persuasive essays", "author": ["C. Stab", "I. Gurevych"], "venue": "Proc. of COLING", "citeRegEx": "Stab and Gurevych. 2014a", "shortCiteRegEx": null, "year": 2014}, {"title": "Identifying argumentative discourse structures in persuasive essays", "author": ["C. Stab", "I. Gurevych"], "venue": "Proc. of EMNLP", "citeRegEx": "Stab and Gurevych. 2014b", "shortCiteRegEx": null, "year": 2014}, {"title": "Parsing argumentation structures in persuasive essays", "author": ["C. Stab", "I. Gurevych"], "venue": "arXiv preprint, arXiv:1604.07370", "citeRegEx": "Stab and Gurevych. 2016", "shortCiteRegEx": null, "year": 2016}, {"title": "Fast gradient-descent methods for temporal-difference learning with linear function approximation", "author": ["R.S. Sutton", "H.R. Maei", "D. Precup", "S. Bhatnagar", "D. Silver", "C. Szepesv\u00e1ri", "E. Wiewiora"], "venue": "Proc. of ICML. ACM", "citeRegEx": "Sutton et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Kernelized value function approximation for reinforcement learning", "author": ["G. Taylor", "R. Parr"], "venue": "Proc. of ICML, pages 1017\u20131024. ACM", "citeRegEx": "Taylor and Parr. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "A review corpus for argumentation analysis", "author": ["H. Wachsmuth", "M. Trenkmann", "B. Stein", "G. Engels", "T. Palakarska"], "venue": "Computational Linguistics and Intelligent Text Processing, pages 115\u2013127. Springer", "citeRegEx": "Wachsmuth et al.. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Sentiment flow\u2013a general model of web review argumentation", "author": ["Henning Wachsmuth", "Johannes Kiesel", "Benno Stein"], "venue": "Proc. of EMNLP,", "citeRegEx": "Wachsmuth et al.. 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "Partially observable Markov decision processes for spoken dialog systems", "author": ["J.D. Williams", "S. Young"], "venue": "Computer Speech & Language, 21(2)", "citeRegEx": "Williams and Young. 2007", "shortCiteRegEx": null, "year": 2007}], "referenceMentions": [{"referenceID": 15, "context": "[Lippi and Torroni, 2015a]).", "startOffset": 0, "endOffset": 26}, {"referenceID": 4, "context": "An argument is a basic unit people use to persuade their audiences to accept a particular state of affairs [Eckle-Kohler et al., 2015], and it usually consists of a claim and some premises offered in support of the claim.", "startOffset": 107, "endOffset": 134}, {"referenceID": 24, "context": "To obtain the contextual information, human annotators usually need to read and label a document for multiple rounds [Stab and Gurevych, 2014a].", "startOffset": 117, "endOffset": 143}, {"referenceID": 22, "context": "text summarisation [Rioux et al., 2014] and dialogue generation [Pietquin et al.", "startOffset": 19, "endOffset": 39}, {"referenceID": 21, "context": ", 2014] and dialogue generation [Pietquin et al., 2011].", "startOffset": 32, "endOffset": 55}, {"referenceID": 24, "context": "741 macro-F1 in corpora consisting of persuasive essays [Stab and Gurevych, 2014a; Stab and Gurevych, 2014b] and legal documents [Palau and Moens, 2009], resp.", "startOffset": 56, "endOffset": 108}, {"referenceID": 25, "context": "741 macro-F1 in corpora consisting of persuasive essays [Stab and Gurevych, 2014a; Stab and Gurevych, 2014b] and legal documents [Palau and Moens, 2009], resp.", "startOffset": 56, "endOffset": 108}, {"referenceID": 20, "context": "741 macro-F1 in corpora consisting of persuasive essays [Stab and Gurevych, 2014a; Stab and Gurevych, 2014b] and legal documents [Palau and Moens, 2009], resp.", "startOffset": 129, "endOffset": 152}, {"referenceID": 14, "context": "Wikipedia articles, these methods have significantly poorer performances: [Levy et al., 2014; Lippi and Torroni, 2015b] report that in the task for detecting claims from Wikipedia articles, only around .", "startOffset": 74, "endOffset": 119}, {"referenceID": 16, "context": "Wikipedia articles, these methods have significantly poorer performances: [Levy et al., 2014; Lippi and Torroni, 2015b] report that in the task for detecting claims from Wikipedia articles, only around .", "startOffset": 74, "endOffset": 119}, {"referenceID": 13, "context": "[Lawrence et al., 2014] as-", "startOffset": 0, "endOffset": 23}, {"referenceID": 1, "context": "sume that clauses belonging to the same argument are likely to share the same topic; thus, they employ the LDA-based topic modelling technique [Blei et al., 2003] to extract each clause\u2019s topics and use these topics as features.", "startOffset": 143, "endOffset": 162}, {"referenceID": 18, "context": "[Nguyen and Litman, 2015] use LDA to extract the argument words (i.", "startOffset": 0, "endOffset": 25}, {"referenceID": 24, "context": "However, these features have only been tested on small corpora constructed from well-structured documents (the former is tested on documents obtained from a 19th century philosophical book, while the later is tested on the persuasive essay corpus proposed in [Stab and Gurevych, 2014a]), and the computational expense of LDA is high.", "startOffset": 259, "endOffset": 285}, {"referenceID": 7, "context": "In [Habernal and Gurevych, 2015], ACD is modelled as a sequence tagging problem, and SVM-HMM [Altun et al.", "startOffset": 3, "endOffset": 32}, {"referenceID": 0, "context": "In [Habernal and Gurevych, 2015], ACD is modelled as a sequence tagging problem, and SVM-HMM [Altun et al., 2003] is used to solve this problem; SVM-HMM implicitly considers type-C HAs during the labelling process.", "startOffset": 93, "endOffset": 113}, {"referenceID": 23, "context": "In RL-based text summarisation techniques [Ryang and Abekawa, 2012; Rioux et al., 2014], annotations of all preceding sentences, made in the current round of scanning, are included in the feature vector; in RL-based dialogue generation systems, e.", "startOffset": 42, "endOffset": 87}, {"referenceID": 22, "context": "In RL-based text summarisation techniques [Ryang and Abekawa, 2012; Rioux et al., 2014], annotations of all preceding sentences, made in the current round of scanning, are included in the feature vector; in RL-based dialogue generation systems, e.", "startOffset": 42, "endOffset": 87}, {"referenceID": 21, "context": "[Pietquin et al., 2011; Williams and Young, 2007], the full history of dialogue acts in the current dialogue is used in the state representation.", "startOffset": 0, "endOffset": 49}, {"referenceID": 31, "context": "[Pietquin et al., 2011; Williams and Young, 2007], the full history of dialogue acts in the current dialogue is used in the state representation.", "startOffset": 0, "endOffset": 49}, {"referenceID": 14, "context": "As for other forms of contextual information, in [Levy et al., 2014], the topic of a document is used to build features to identify claims.", "startOffset": 49, "endOffset": 68}, {"referenceID": 16, "context": "However, the importance of the topic information is questionable, as [Lippi and Torroni, 2015b] report that similar performances can be obtained without using the topic information.", "startOffset": 69, "endOffset": 95}, {"referenceID": 15, "context": "[Lippi and Torroni, 2015a]), we need to select RL algorithms with strong generalisation capabilities, so as to learn the optimal policies with limited amount of training data.", "startOffset": 0, "endOffset": 26}, {"referenceID": 11, "context": "To strike a trade-off between the above two factors, we decide to use the least square policy iteration (LSPI) [Lagoudakis and Parr, 2003] algorithm to solve our MDPbased ACD.", "startOffset": 111, "endOffset": 138}, {"referenceID": 6, "context": "[Geramifard et al., 2006; Sutton et al., 2009]).", "startOffset": 0, "endOffset": 46}, {"referenceID": 27, "context": "[Geramifard et al., 2006; Sutton et al., 2009]).", "startOffset": 0, "endOffset": 46}, {"referenceID": 11, "context": "As such, the complexity of each episode (line 6) using LSPI is O(N), and the complexity for obtaining the final policy (line 9) is O(N) [Lagoudakis and Parr, 2003]; thus, the overall complexity in the training phase is O(KMN +N).", "startOffset": 136, "endOffset": 163}, {"referenceID": 2, "context": "2), we select SVM with RBF kernel as the classifier, and its complexity in the training phase is between O(N(KM)) and O(N(KM)) (using LIBSVM [Chang and Lin, 2011]).", "startOffset": 141, "endOffset": 162}, {"referenceID": 0, "context": "As for SVM-HMM [Altun et al., 2003], its complexity is no cheaper than standard SVM.", "startOffset": 15, "endOffset": 35}, {"referenceID": 3, "context": "In the test phase, the complexity for computing the annotation for one clause is O(N \u00b7 |A|) when using LSPI, but is approximately O(N) [Claesen et al., 2014] when using SVM and SVM-HMM (with RBF kernel).", "startOffset": 135, "endOffset": 157}, {"referenceID": 7, "context": "When selecting corpora for testing our methods, we primarily consider the labelling quality of the corpora, because the corpora\u2019s quality heavily influences the quality of the ACD tools trained on them [Habernal and Gurevych, 2015].", "startOffset": 202, "endOffset": 231}, {"referenceID": 5, "context": "Fleiss\u2019 kappa [Fleiss, 1971] is among the most widely used IRA metrics, because it can compute the agreement between two or more raters, and it considers the possibility of the agreement occurring by chance, thus giving more \u201crobust\u201d measure than simple percentage agreement.", "startOffset": 14, "endOffset": 28}, {"referenceID": 29, "context": "1 We randomly sampled 200 hotel reviews of appropriate length (50 - 200 words) in the hotel review dataset provided by [Wachsmuth et al., 2014].", "startOffset": 119, "endOffset": 143}, {"referenceID": 30, "context": "Similar to [Wachsmuth et al., 2015], we viewed each sub-sentence as a clause.", "startOffset": 11, "endOffset": 35}, {"referenceID": 12, "context": "6, suggesting that the agreement is substantial [Landis and Koch, 1977].", "startOffset": 48, "endOffset": 71}, {"referenceID": 26, "context": "Another corpus we used to test our approach is the persuasive essays corpus proposed in [Stab and Gurevych, 2016].", "startOffset": 88, "endOffset": 113}, {"referenceID": 14, "context": "the one in [Levy et al., 2014], have much lower IRA scores (.", "startOffset": 11, "endOffset": 30}, {"referenceID": 20, "context": "39); the legal texts corpus proposed in [Palau and Moens, 2009] is not publicly available, and the web texts corpus proposed in [Habernal et al.", "startOffset": 40, "endOffset": 63}, {"referenceID": 8, "context": "39); the legal texts corpus proposed in [Palau and Moens, 2009] is not publicly available, and the web texts corpus proposed in [Habernal et al., 2014] has relatively low IRA (below .", "startOffset": 128, "endOffset": 151}, {"referenceID": 25, "context": "3), we used exactly the same features to those in [Stab and Gurevych, 2014b].", "startOffset": 50, "endOffset": 76}, {"referenceID": 2, "context": "As for the algorithm implementations, we used LIBSVM [Chang and Lin, 2011] for SVM and a revision of SVM [Joachims et al.", "startOffset": 53, "endOffset": 74}, {"referenceID": 10, "context": "As for the algorithm implementations, we used LIBSVM [Chang and Lin, 2011] for SVM and a revision of SVM [Joachims et al., 2009] for SVM-HMM.", "startOffset": 105, "endOffset": 128}, {"referenceID": 9, "context": "rithms (J48 decision tree, naive Bayes and random forest provided in WEKA [Hall et al., 2009]), and we make similar observations.", "startOffset": 74, "endOffset": 93}, {"referenceID": 28, "context": "the kernel-based RL algorithms [Taylor and Parr, 2009; Ormoneit and Sen, 2002] and the recently proposed deep RL [Mnih et al.", "startOffset": 31, "endOffset": 78}, {"referenceID": 19, "context": "the kernel-based RL algorithms [Taylor and Parr, 2009; Ormoneit and Sen, 2002] and the recently proposed deep RL [Mnih et al.", "startOffset": 31, "endOffset": 78}, {"referenceID": 17, "context": "the kernel-based RL algorithms [Taylor and Parr, 2009; Ormoneit and Sen, 2002] and the recently proposed deep RL [Mnih et al., 2015], the performance of RL-based ACD can be substantially improved (at the price of higher computational complexity though).", "startOffset": 113, "endOffset": 132}, {"referenceID": 25, "context": "Similar observations are also reported in [Stab and Gurevych, 2014b], and we believe that ignoring contextual information (including HAs) is a major factor leading to these misclassifications, as illustrated in Example 1.", "startOffset": 42, "endOffset": 68}], "year": 2017, "abstractText": "Argument component detection (ACD) is an important sub-task in argumentation mining. ACD aims at detecting and classifying different argument components in natural language texts. Historical annotations (HAs) are important features the human annotators consider when they manually perform the ACD task. However, HAs are largely ignored by existing automatic ACD techniques. Reinforcement learning (RL) has proven to be an effective method for using HAs in some natural language processing tasks. In this work, we propose a RL-based ACD technique, and evaluate its performance on two well-annotated corpora. Results suggest that, in terms of classification accuracy, HAsaugmented RL outperforms plain RL by at most 17.85%, and outperforms the state-of-the-art supervised learning algorithm by at most 11.94%.", "creator": "LaTeX with hyperref package"}}}