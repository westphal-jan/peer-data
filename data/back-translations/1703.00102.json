{"id": "1703.00102", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Mar-2017", "title": "SARAH: A Novel Method for Machine Learning Problems Using Stochastic Recursive Gradient", "abstract": "In this paper, we propose a StochAstic Recursive grAdient algoritHm (SARAH) and its practical variant SARAH + as a novel approach to minimizing finite sums. Unlike vanilla SGD and other modern stochastic methods such as SVRG, S2GD, SAG and SAGA, SARAH allows a simple recursive framework for updating stochastic gradient estimates; compared to SAG / SAGA, SARAH does not require storage of past gradients. SARAH's linear convergence rate is demonstrated under the assumption of strong convexity. We also demonstrate a linear convergence rate (in the strongly convex case) for an inner loop of SARAH, the property SVRG does not possess. Numerical experiments demonstrate the efficiency of our algorithm.", "histories": [["v1", "Wed, 1 Mar 2017 02:08:32 GMT  (1589kb)", "https://arxiv.org/abs/1703.00102v1", null], ["v2", "Sat, 3 Jun 2017 07:30:20 GMT  (1862kb)", "http://arxiv.org/abs/1703.00102v2", null]], "reviews": [], "SUBJECTS": "stat.ML cs.LG math.OC", "authors": ["lam m nguyen", "jie liu", "katya scheinberg", "martin tak\u00e1c"], "accepted": true, "id": "1703.00102"}, "pdf": {"name": "1703.00102.pdf", "metadata": {"source": "META", "title": "SARAH: A Novel Method for Machine Learning Problems  Using Stochastic Recursive Gradient", "authors": ["LamM. Nguyen", "Jie Liu", "Katya Scheinberg", "Martin Tak\u00e1\u010d"], "emails": ["guyen.mltd@gmail.com>,", "<jie.liu.2018@gmail.com>,", "<katyas@lehigh.edu>,", "<Takac.MT@gmail.com>."], "sections": [{"heading": null, "text": "ar X\niv :1\n70 3.\n00 10\n2v 2\n[ st\nat .M\nL ]\n3 J\nun 2\n01 7\nsive grAdient algoritHm (SARAH), as well as its practical variant SARAH+, as a novel approach to the finite-sum minimization problems. Different from the vanilla SGD and other modern stochastic methods such as SVRG, S2GD, SAG and SAGA, SARAH admits a simple recursive framework for updating stochastic gradient estimates; when comparing to SAG/SAGA, SARAH does not require a storage of past gradients. The linear convergence rate of SARAH is proven under strong convexity assumption. We also prove a linear convergence rate (in the strongly convex case) for an inner loop of SARAH, the property that SVRG does not possess. Numerical experiments demonstrate the efficiency of our algorithm."}, {"heading": "1. Introduction", "text": "We are interested in solving a problem of the form\nmin w\u2208Rd\n\n\n\nP (w) def =\n1\nn\n\u2211\ni\u2208[n]\nfi(w)\n\n\n\n, (1)\nwhere each fi, i \u2208 [n] def= {1, . . . , n}, is convex with a Lipschitz continuous gradient. Throughout the paper, we assume that there exists an optimal solution w\u2217 of (1).\n1Department of Industrial and Systems Engineering, Lehigh University, USA. 2On leave at The University of Oxford, UK. All authors were supported by NSF Grant CCF-1618717. Katya Scheinberg was partially supported by NSF Grants DMS 13-19356, CCF-1320137 and CCF1618717. Correspondence to: Lam M. Nguyen <lamnguyen.mltd@gmail.com>, Jie Liu <jie.liu.2018@gmail.com>, Katya Scheinberg <katyas@lehigh.edu>, Martin Taka\u0301c\u030c <Takac.MT@gmail.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nProblems of this type arise frequently in supervised learning applications (Hastie et al., 2009). Given a training set {(xi, yi)}ni=1 with xi \u2208 Rd, yi \u2208 R, the least squares regression model, for example, is written as (1) with fi(w) def = (xTi w\u2212yi)2+ \u03bb2 \u2016w\u20162, where \u2016\u00b7\u2016 denotes the \u21132-norm. The \u21132-regularized logistic regression for binary classification is written with fi(w) def = log(1 + exp(\u2212yixTi w)) + \u03bb2 \u2016w\u20162 (yi \u2208 {\u22121, 1}). In recent years, many advanced optimization methods have been developed for problem (1). While the objective function is smooth and convex, the traditional optimization methods, such as gradient descent (GD) or Newton method are often impractical for this problem, when n \u2013 the number of training samples and hence the number of fi\u2019s \u2013 is very large. In particular, GD updates iterates as follows\nwt+1 = wt \u2212 \u03b7t\u2207P (wt), t = 0, 1, 2, . . . .\nUnder strong convexity assumption on P and with appropriate choice of \u03b7t, GD converges at a linear rate in terms of objective function valuesP (wt). However, when n is large, computing\u2207P (wt) at each iteration can be prohibitive. As an alternative, stochastic gradient descent (SGD)1, originating from the seminal work of Robbins and Monro in 1951 (Robbins & Monro, 1951), has become the method of choice for solving (1). At each step, SGD picks an index i \u2208 [n] uniformly at random, and updates the iterate as wt+1 = wt \u2212 \u03b7t\u2207fi(wt), which is up-to n times cheaper than an iteration of a full gradient method. The convergence rate of SGD is slower than that of GD, in particular, it is sublinear in the strongly convex case. The tradeoff, however, is advantageous due to the tremendous per-iteration savings and the fact that low accuracy solutions are sufficient. This trade-off has been thoroughly analyzed in (Bottou, 1998). Unfortunately, in practice SGD method is often too slow and its performance is too sensitive to the variance in the sample gradients \u2207fi(wt). Use of mini-batches (averaging multiple sample gradients \u2207fi(wt)) was used in (Shalev-Shwartz et al., 2007; 1We mark here that even though stochastic gradient is referred to as SG in literature, the term stochastic gradient descent (SGD) has been widely used in many important works of large-scale learning, including SAG/SAGA, SDCA, SVRG and MISO.\nCotter et al., 2011; Taka\u0301c\u030c et al., 2013) to reduce the variance and improve convergence rate by constant factors. Using diminishing sequence {\u03b7t} is used to control the variance (Shalev-Shwartz et al., 2011; Bottou et al., 2016), but the practical convergence of SGD is known to be very sensitive to the choice of this sequence, which needs to be hand-picked.\nRecently, a class of more sophisticated algorithms have emerged, which use the specific finite-sum form of (1) and combine some deterministic and stochastic aspects to reduce variance of the steps. The examples of these methods are SAG/SAGA (Le Roux et al., 2012; Defazio et al., 2014), SDCA (Shalev-Shwartz & Zhang, 2013), SVRG (Johnson & Zhang, 2013; Xiao & Zhang, 2014), DIAG (Mokhtari et al., 2017), MISO (Mairal, 2013) and S2GD (Konec\u030cny\u0301 & Richta\u0301rik, 2013), all of which enjoy faster convergence rate than that of SGD and use a fixed learning rate parameter \u03b7. In this paper we introduce a new method in this category, SARAH, which further improves several aspects of the existing methods. In Table 1 we summarize complexity and some other properties of the existing methods and SARAH when applied to strongly convex problems. Although SVRG and SARAH have the same convergence rate, we introduce a practical variant of SARAH that outperforms SVRG in our experiments.\nIn addition, theoretical results for complexity of the methods or their variants when applied to general convex functions have been derived (Schmidt et al., 2016; Defazio et al., 2014; Reddi et al., 2016; Allen-Zhu & Yuan, 2016; Allen-Zhu, 2017). In Table 2 we summarize the key complexity results, noting that convergence rate is now sublinear.\nOur Contributions. In this paper, we propose a novel algorithm which combines some of the good properties of existing algorithms, such as SAGA and SVRG, while aiming to improve on both of these methods. In particular, our algorithm does not take steps along a stochastic gradient direction, but rather along an accumulated direction using past stochastic gradient information (as in SAGA) and occasional exact gradient information (as in SVRG). We summarize the key properties of the proposed algorithm below.\n\u2022 Similarly to SVRG, SARAH\u2019s iterations are divided into the outer loop where a full gradient is computed\nand the inner loop where only stochastic gradient is computed. Unlike the case of SVRG, the steps of the inner loop of SARAH are based on accumulated stochastic information. \u2022 Like SAG/SAGA and SVRG, SARAH has a sublinear rate of convergence for general convex functions,\nand a linear rate of convergence for strongly convex functions. \u2022 SARAH uses a constant learning rate, whose size is larger than that of SVRG. We analyze and discuss the\noptimal choice of the learning rate and the number of inner loop steps. However, unlike SAG/SAGA but similar to SVRG, SARAH does not require a storage\nof n past stochastic gradients. \u2022 We also prove a linear convergence rate (in the strongly convex case) for the inner loop of SARAH,\nthe property that SVRG does not possess. We show that the variance of the steps inside the inner loop goes to zero, thus SARAH is theoretically more stable and reliable than SVRG. \u2022 We provide a practical variant of SARAH based on the convergence properties of the inner loop, where\nthe simple stable stopping criterion for the inner loop is used (see Section 4 for more details). This variant shows how SARAH can be made more stable than SVRG in practice."}, {"heading": "2. Stochastic Recursive Gradient Algorithm", "text": "Now we are ready to present our SARAH (Algorithm 1).\nThe key step of the algorithm is a recursive update of the stochastic gradient estimate (SARAH update)\nvt = \u2207fit(wt)\u2212\u2207fit(wt\u22121) + vt\u22121, (2)\nfollowed by the iterate update:\nwt+1 = wt \u2212 \u03b7vt. (3)\nFor comparison, SVRG update can be written in a similar way as\nvt = \u2207fit(wt)\u2212\u2207fit(w0) + v0. (4)\nAlgorithm 1 SARAH\nParameters: the learning rate \u03b7 > 0 and the inner loop size m. Initialize: w\u03030 Iterate: for s = 1, 2, . . . do w0 = w\u0303s\u22121 v0 = 1 n \u2211n i=1 \u2207fi(w0)\nw1 = w0 \u2212 \u03b7v0 Iterate: for t = 1, . . . ,m\u2212 1 do Sample it uniformly at random from [n] vt = \u2207fit(wt)\u2212\u2207fit(wt\u22121) + vt\u22121 wt+1 = wt \u2212 \u03b7vt end for Set w\u0303s = wt with t chosen uniformly at random from {0, 1, . . . ,m}\nend for\nObserve that in SVRG, vt is an unbiased estimator of the gradient, while it is not true for SARAH. Specifically, 2\nE[vt|Ft] = \u2207P (wt)\u2212\u2207P (wt\u22121)+vt\u22121 6= \u2207P (wt), (5)\nwhere 3 Ft = \u03c3(w0, i1, i2, . . . , it\u22121) is the \u03c3-algebra generated by w0, i1, i2, . . . , it\u22121; F0 = F1 = \u03c3(w0). Hence, SARAH is different from SGD and SVRG type of methods, however, the following total expectation holds, E[vt] = E[\u2207P (wt)], differentiating SARAH from SAG/SAGA. SARAH is similar to SVRG since they both contain outer loops which require one full gradient evaluation per outer iteration followed by one full gradient descent step with a given learning rate. The difference lies in the inner loop, where SARAH updates the stochastic step direction vt recursively by adding and subtracting component gradients to and from the previous vt\u22121 (t \u2265 1) in (2). Each inner iteration evaluates 2 stochastic gradients and hence the total work per outer iteration isO(n+m) in terms of the number of gradient evaluations. Note that due to its nature, without running the inner loop, i.e.,m = 1, SARAH reduces to the GD algorithm."}, {"heading": "3. Theoretical Analysis", "text": "To proceed with the analysis of the proposed algorithm, we will make the following common assumptions.\nAssumption 1 (L-smooth). Each fi : R d \u2192 R, i \u2208 [n], is L-smooth, i.e., there exists a constant L > 0 such that\n\u2016\u2207fi(w) \u2212\u2207fi(w\u2032)\u2016 \u2264 L\u2016w \u2212 w\u2032\u2016, \u2200w,w\u2032 \u2208 Rd. 2 E[\u00b7|Ft] = Eit [\u00b7], which is expectation with respect to the random choice of index it (conditioned on w0, i1, i2, . . . , it\u22121). 3Ft also contains all the information of w0, . . . , wt as well as v0, . . . , vt\u22121.\nNote that this assumption implies that P (w) = 1 n \u2211n i=1 fi(w) is also L-smooth. The following strong convexity assumption will be made for the appropriate parts of the analysis, otherwise, it would be dropped.\nAssumption 2a (\u00b5-strongly convex). The function P : R\nd \u2192 R, is \u00b5-strongly convex, i.e., there exists a constant \u00b5 > 0 such that \u2200w,w\u2032 \u2208 Rd,\nP (w) \u2265 P (w\u2032) +\u2207P (w\u2032)T (w \u2212 w\u2032) + \u00b52 \u2016w \u2212 w \u2032\u20162.\nAnother, stronger, assumption of \u00b5-strong convexity for (1) will also be imposed when required in our analysis. Note that Assumption 2b implies Assumption 2a but not vice versa.\nAssumption 2b. Each function fi : R d \u2192 R, i \u2208 [n], is strongly convex with \u00b5 > 0.\nUnder Assumption 2a, let us define the (unique) optimal solution of (1) as w\u2217, Then strong convexity of P implies that\n2\u00b5[P (w)\u2212 P (w\u2217)] \u2264 \u2016\u2207P (w)\u20162, \u2200w \u2208 Rd. (6)\nWe note here, for future use, that for strongly convex functions of the form (1), arising in machine learning applications, the condition number is defined as \u03ba def = L/\u00b5. Furthermore, we should also notice that Assumptions 2a and 2b both cover a wide range of problems, e.g. l2-regularized empirical risk minimization problems with convex losses.\nFinally, as a special case of the strong convexity of all fi\u2019s with \u00b5 = 0, we state the general convexity assumption, which we will use for convergence analysis.\nAssumption 3. Each function fi : R d \u2192 R, i \u2208 [n], is convex, i.e.,\nfi(w) \u2265 fi(w\u2032) +\u2207fi(w\u2032)T (w \u2212 w\u2032), \u2200i \u2208 [n].\nAgain, we note that Assumption 2b implies Assumption 3, but Assumption 2a does not. Hence in our analysis, depending on the result we aim at, we will require Assumption 3 to hold by itself, or Assumption 2a and Assumption 3 to hold together, or Assumption 2b to hold by itself. We will always use Assumption 1.\nOur iteration complexity analysis aims to bound the number of outer iterations T (or total number of stochastic gradient evaluations) which is needed to guarantee that \u2016\u2207P (wT )\u20162 \u2264 \u01eb. In this case we will say that wT is an \u01eb-accurate solution. However, as is common practice for stochastic gradient algorithms, we aim to obtain the bound on the number of iterations, which is required to guarantee the bound on the expected squared norm of a gradient, i.e.,\nE[\u2016\u2207P (wT )\u20162] \u2264 \u01eb. (7)"}, {"heading": "3.1. Linearly Diminishing Step-Size in a Single Inner Loop", "text": "The most important property of the SVRG algorithm is the variance reduction of the steps. This property holds as the number of outer iteration grows, but it does not hold, if only the number of inner iterations increases. In other words, if we simply run the inner loop for many iterations (without executing additional outer loops), the variance of the steps does not reduce in the case of SVRG, while it goes to zero in the case of SARAH. To illustrate this effect, let us take a look at Figures 1 and 2.\nIn Figure 1, we applied one outer loop of SVRG and SARAH to a sum of 5 quadratic functions in a twodimensional space, where the optimal solution is at the origin, the black lines and black dots indicate the trajectory of each algorithm and the red point indicates the final iterate. Initially, both SVRG and SARAH take steps along stochastic gradient directions towards the optimal solution. However, later iterations of SVRG wander randomly around the origin with large deviation from it, while SARAH follows a much more stable convergent trajectory, with a final iterate falling in a small neighborhood of the optimal solution.\nIn Figure 2, the x-axis denotes the number of effective passes which is equivalent to the number of passes through all of the data in the dataset, the cost of each pass being equal to the cost of one full gradient evaluation; and y-axis represents \u2016vt\u20162. Figure 2 shows the evolution of \u2016vt\u20162 for SARAH, SVRG, SGD+ (SGD with decreas-\ning learning rate) and FISTA (an accelerated version of GD (Beck & Teboulle, 2009)) withm = 4n, where the left plot shows the trend over multiple outer iterations and the right plot shows a single outer iteration4. We can see that for SVRG, \u2016vt\u20162 decreases over the outer iterations, while it has an increasing trend or oscillating trend for each inner loop. In contrast, SARAH enjoys decreasing trends both in the outer and the inner loop iterations.\nWe will now show that the stochastic steps computed by SARAH converge linearly in the inner loop. We present two linear convergence results based on our two different assumptions of \u00b5-strong convexity. These results substantiate our conclusion that SARAH uses more stable stochastic gradient estimates than SVRG. The following theorem is our first result to demonstrate the linear convergence of our stochastic recursive step vt.\nTheorem 1a. Suppose that Assumptions 1, 2a and 3 hold. Consider vt defined by (2) in SARAH (Algorithm 1) with \u03b7 < 2/L. Then, for any t \u2265 1,\nE[\u2016vt\u20162] \u2264 [ 1\u2212 ( 2 \u03b7L \u2212 1 ) \u00b52\u03b72 ] E[\u2016vt\u22121\u20162]\n\u2264 [ 1\u2212 (\n2 \u03b7L \u2212 1\n) \u00b52\u03b72 ]t E[\u2016\u2207P (w0)\u20162].\nThis result implies that by choosing \u03b7 = O(1/L), we obtain the linear convergence of \u2016vt\u20162 in expectation with the rate (1 \u2212 1/\u03ba2). Below we show that a better convergence rate can be obtained under a stronger convexity assumption.\nTheorem 1b. Suppose that Assumptions 1 and 2b hold. Consider vt defined by (2) in SARAH (Algorithm 1) with \u03b7 \u2264 2/(\u00b5+ L). Then the following bound holds, \u2200 t \u2265 1,\nE[\u2016vt\u20162] \u2264 ( 1\u2212 2\u00b5L\u03b7\u00b5+L ) E[\u2016vt\u22121\u20162]\n\u2264 ( 1\u2212 2\u00b5L\u03b7\u00b5+L )t E[\u2016\u2207P (w0)\u20162].\nAgain, by setting \u03b7 = O(1/L), we derive the linear convergence with the rate of (1 \u2212 1/\u03ba), which is a significant improvement over the result of Theorem 1a, when the problem is severely ill-conditioned."}, {"heading": "3.2. Convergence Analysis", "text": "In this section, we derive the general convergence rate results for Algorithm 1. First, we present two important Lemmas as the foundation of our theory. Then, we proceed to prove sublinear convergence rate of a single outer iteration when applied to general convex functions. In the end, we prove that the algorithm with multiple outer iterations has linear convergence rate in the strongly convex case.\n4In the plots of Figure 2, since the data for SVRG is noisy, we smooth it by using moving average filters with spans 100 for the left plot and 10 for the right one.\nWe begin with proving two useful lemmas that do not require any convexity assumption. The first Lemma 1 bounds the sum of expected values of \u2016\u2207P (wt)\u20162. The second, Lemma 2, bounds E[\u2016\u2207P (wt)\u2212 vt\u20162]. Lemma 1. Suppose that Assumption 1 holds. Consider SARAH (Algorithm 1). Then, we have\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u20162] \u2264 2\n\u03b7 E[P (w0)\u2212 P (w\u2217)] (8)\n+\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u2212 vt\u20162]\u2212 (1\u2212 L\u03b7) m \u2211\nt=0\nE[\u2016vt\u20162].\nLemma 2. Suppose that Assumption 1 holds. Consider vt defined by (2) in SARAH (Algorithm 1). Then for any t \u2265 1,\nE[\u2016\u2207P (wt)\u2212 vt\u20162] = t \u2211\nj=1\nE[\u2016vj \u2212 vj\u22121\u20162]\n\u2212 t \u2211\nj=1\nE[\u2016\u2207P (wj)\u2212\u2207P (wj\u22121)\u20162].\nNow we are ready to provide our main theoretical results."}, {"heading": "3.2.1. GENERAL CONVEX CASE", "text": "Following from Lemma 2, we can obtain the following upper bound for E[\u2016\u2207P (wt) \u2212 vt\u20162] for convex functions fi, i \u2208 [n]. Lemma 3. Suppose that Assumptions 1 and 3 hold. Consider vt defined as (2) in SARAH (Algorithm 1) with \u03b7 < 2/L. Then we have that for any t \u2265 1,\nE[\u2016\u2207P (wt)\u2212 vt\u20162] \u2264 \u03b7L 2\u2212 \u03b7L [ E[\u2016v0\u20162]\u2212 E[\u2016vt\u20162] ]\n\u2264 \u03b7L 2\u2212 \u03b7LE[\u2016v0\u2016 2]. (9)\nUsing the above lemmas, we can state and prove one of our core theorems as follows.\nTheorem 2. Suppose that Assumptions 1 and 3 hold. Consider SARAH (Algorithm 1) with \u03b7 \u2264 1/L. Then for any s \u2265 1, we have\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 2\n\u03b7(m+ 1) E[P (w\u0303s\u22121)\u2212 P (w\u2217)]\n+ \u03b7L\n2\u2212 \u03b7LE[\u2016\u2207P (w\u0303s\u22121)\u2016 2]. (10)\nProof. Since v0 = \u2207P (w0) implies \u2016\u2207P (w0)\u2212 v0\u20162 = 0 then by Lemma 3, we can write\n\u2211m t=0E[\u2016\u2207P (wt)\u2212 vt\u20162] \u2264 m\u03b7L2\u2212\u03b7LE[\u2016v0\u20162]. (11)\nHence, by Lemma 1 with \u03b7 \u2264 1/L, we have \u2211m\nt=0E[\u2016\u2207P (wt)\u20162] \u2264 2\u03b7E[P (w0)\u2212 P (w \u2217)] + \u2211m\nt=0E[\u2016\u2207P (wt)\u2212 vt\u20162] (11) \u2264 2\u03b7E[P (w0)\u2212 P (w \u2217)] + m\u03b7L2\u2212\u03b7LE[\u2016v0\u2016 2]. (12) Since we are considering one outer iteration, with s \u2265 1, then we have v0 = \u2207P (w0) = \u2207P (w\u0303s\u22121) (since w0 = w\u0303s\u22121), and w\u0303s = wt, where t is picked uniformly at random from {0, 1, . . . ,m}. Therefore, the following holds,\nE[\u2016\u2207P (w\u0303s)\u20162] = 1m+1 \u2211m t=0E[\u2016\u2207P (wt)\u20162] (12)\n\u2264 2\u03b7(m+1)E[P (w\u0303s\u22121)\u2212 P (w \u2217)]\n+ \u03b7L2\u2212\u03b7LE[\u2016\u2207P (w\u0303s\u22121)\u2016 2].\nTheorem 2, in the case when \u03b7 \u2264 1/L implies that\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 2\u03b7(m+1)E[P (w\u0303s\u22121)\u2212 P (w \u2217)]\n+ \u03b7LE[\u2016\u2207P (w\u0303s\u22121)\u20162].\nBy choosing the learning rate \u03b7 = \u221a\n2 L(m+1) (withm such\nthat \u221a\n2 L(m+1) \u2264 1/L) we can derive the following con-\nvergence result,\nE[\u2016\u2207P (w\u0303s)\u20162]\n\u2264 \u221a\n2L m+1E[P (w\u0303s\u22121)\u2212 P (w\u2217) + \u2016\u2207P (w\u0303s\u22121)\u20162].\nClearly, this result shows a sublinear convergence rate for SARAH under general convexity assumption within a single inner loop, with increasing m, and consequently, we have the following result for complexity bound.\nCorollary 1. Suppose that Assumptions 1 and 3 hold. Consider SARAH (Algorithm 1) within a single outer iteration with the learning rate \u03b7 = \u221a\n2 L(m+1) wherem \u2265 2L\u22121 is\nthe total number of iterations, then \u2016\u2207P (wt)\u20162 converges sublinearly in expectation with a rate of \u221a\n2L m+1 , and there-\nfore, the total complexity to achieve an \u01eb-accurate solution defined in (7) is O(n+ 1/\u01eb2).\nWe now turn to estimating convergence of SARAH with multiple outer steps. Simply using Theorem 2 for each of the outer steps we have the following result.\nTheorem 3. Suppose that Assumptions 1 and 3 hold. Consider SARAH (Algorithm 1) and define\n\u03b4k = 2 \u03b7(m+1)E[P (w\u0303k)\u2212 P (w \u2217)], k = 0, 1, . . . , s\u2212 1,\nand \u03b4 = max0\u2264k\u2264s\u22121 \u03b4k. Then we have\nE[\u2016\u2207P (w\u0303s)\u20162]\u2212\u2206 \u2264 \u03b1s(\u2016\u2207P (w\u03030)\u20162 \u2212\u2206), (13)\nwhere \u2206 = \u03b4 (\n1 + \u03b7L2(1\u2212\u03b7L)\n)\n, and \u03b1 = \u03b7L2\u2212\u03b7L .\nBased on Theorem 3, we have the following total complexity for SARAH in the general convex case.\nCorollary 2. Let us choose \u2206 = \u01eb/4, \u03b1 = 1/2 (with \u03b7 = 2/(3L)), and m = O(1/\u01eb) in Theorem 3. Then, the total complexity to achieve an \u01eb-accuracy solution defined in (7) is O((n+ (1/\u01eb)) log(1/\u01eb))."}, {"heading": "3.2.2. STRONGLY CONVEX CASE", "text": "We now turn to the discussion of the linear convergence rate of SARAH under the strong convexity assumption on P . From Theorem 2, for any s \u2265 1, using property (6) of the \u00b5-strongly convex P , we have\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 2\u03b7(m+1)E[P (w\u0303s\u22121)\u2212 P (w \u2217)]\n+ \u03b7L2\u2212\u03b7LE[\u2016\u2207P (w\u0303s\u22121)\u2016 2]\n(6) \u2264 (\n1 \u00b5\u03b7(m+1) + \u03b7L 2\u2212\u03b7L\n)\nE[\u2016\u2207P (w\u0303s\u22121)\u20162],\nand equivalently,\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 \u03c3m E[\u2016\u2207P (w\u0303s\u22121)\u20162]. (14)\nLet us define \u03c3m def = 1\u00b5\u03b7(m+1) + \u03b7L 2\u2212\u03b7L . Then by choosing \u03b7 and m such that \u03c3m < 1, and applying (14) recursively, we are able to reach the following convergence result.\nTheorem 4. Suppose that Assumptions 1, 2a and 3 hold. Consider SARAH (Algorithm 1) with the choice of \u03b7 andm such that\n\u03c3m def =\n1\n\u00b5\u03b7(m+ 1) +\n\u03b7L\n2\u2212 \u03b7L < 1. (15)\nThen, we have\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 (\u03c3m)s\u2016\u2207P (w\u03030)\u20162.\nRemark 1. Theorem 4 implies that any \u03b7 < 1/L will work for SARAH. Let us compare our convergence rate to that of SVRG. The linear rate of SVRG, as presented in (Johnson & Zhang, 2013), is given by\n\u03b1m = 1 \u00b5\u03b7(1\u22122L\u03b7)m + 2\u03b7L 1\u22122\u03b7L < 1.\nWe observe that it implies that the learning rate has to satisfy \u03b7 < 1/(4L), which is a tighter restriction than\n\u03b7 < 1/L required by SARAH. In addition, with the same values of m and \u03b7, the rate or convergence of (the outer iterations) of SARAH is always smaller than that of SVRG.\n\u03c3m = 1 \u00b5\u03b7(m+1) + \u03b7L 2\u2212\u03b7L = 1 \u00b5\u03b7(m+1) + 1 2/(\u03b7L)\u22121\n< 1\u00b5\u03b7(1\u22122L\u03b7)m + 1 0.5/(\u03b7L)\u22121 = \u03b1m.\nRemark 2. To further demonstrate the better convergence properties of SARAH, let us consider following optimization problem\nmin 0<\u03b7<1/L \u03c3m, min 0<\u03b7<1/4L \u03b1m,\nwhich can be interpreted as the best convergence rates for different values of m, for both SARAH and SVRG. After simple calculations, we plot both learning rates and the corresponding theoretical rates of convergence, as shown in Figure 3, where the right plot is a zoom-in on a part of the middle plot. The left plot shows that the optimal learning rate for SARAH is significantly larger than that of SVRG, while the other two plots show significant improvement upon outer iteration convergence rates for SARAH over SVRG.\nBased on Theorem 4, we are able to derive the following total complexity for SARAH in the strongly convex case.\nCorollary 3. Fix \u01eb \u2208 (0, 1), and let us run SARAH with \u03b7 = 1/(2L) and m = 4.5\u03ba for T iterations where T = \u2308log(\u2016\u2207P (w\u03030)\u20162/\u01eb)/ log(9/7)\u2309, then we can derive an \u01eb-accuracy solution defined in (7). Furthermore, we can obtain the total complexity of SARAH, to achieve the \u01eb-accuracy solution, as O ((n+ \u03ba) log(1/\u01eb)) ."}, {"heading": "4. A Practical Variant", "text": "While SVRG is an efficient variance-reducing stochastic gradient method, one of its main drawbacks is the sensitivity of the practical performance with respect to the choice of m. It is know that m should be around O(\u03ba),5 while it still remains unknown that what the exact best choice is. In this section, we propose a practical variant of SARAH as\n5 In practice, when n is large, P (w) is often considered as a regularized Empirical Loss Minimization problem with regularization parameter \u03bb = 1\nn , then \u03ba \u223c O(n).\nSARAH+ (Algorithm 2), which provides an automatic and adaptive choice of the inner loop sizem. Guided by the linear convergenceof the steps in the inner loop, demonstrated in Figure 2, we introduce a stopping criterion based on the values of \u2016vt\u20162 while upper-bounding the total number of steps by a large enoughm for robustness. The other modification compared to SARAH (Algorithm 1) is the more practical choice w\u0303s = wt, where t is the last index of the particular inner loop, instead of randomly selected intermediate index.\nAlgorithm 2 SARAH+\nParameters: the learning rate \u03b7 > 0, 0 < \u03b3 \u2264 1 and the maximum inner loop size m. Initialize: w\u03030 Iterate: for s = 1, 2, . . . do w0 = w\u0303s\u22121 v0 = 1 n \u2211n i=1 \u2207fi(w0)\nw1 = w0 \u2212 \u03b7v0 t = 1 while \u2016vt\u22121\u20162 > \u03b3\u2016v0\u20162 and t < m do Sample it uniformly at random from [n] vt = \u2207fit(wt)\u2212\u2207fit(wt\u22121) + vt\u22121 wt+1 = wt \u2212 \u03b7vt t = t+ 1 end while\nSet w\u0303s = wt end for\nDifferent from SARAH, SARAH+ provides a possibility of earlier termination and unnecessary careful choices of m, and it also covers the classical gradient descent when we set \u03b3 = 1 (since the while loop does not proceed). In Figure 4 we present the numerical performance of SARAH+ with different \u03b3s on rcv1 and news20 datasets. The size of the inner loop provides a trade-off between the fast sublinear convergence in the inner loop and linear convergence in the outer loop. From the results, it appears that \u03b3 = 1/8 is the optimal choice. With a larger \u03b3, i.e. \u03b3 > 1/8, the iterates in the inner loop do not provide sufficient reduction, before another full gradient computation is required, while with \u03b3 < 1/8 an unnecessary number of inner steps is performed without gaining substantial progress. Clearly \u03b3 is another parameter that requires tuning, however, in our experiments, the performance of SARAH+ has been very robust with respect to the choices of \u03b3 and did not vary much from one data set to another.\nSimilarly to SVRG, \u2016vt\u20162 decreases in the outer iterations of SARAH+. However, unlike SVRG, SARAH+ also inherits from SARAH the consistent decrease of \u2016vt\u20162 in expectation in the inner loops. It is not possible to apply the same idea of adaptively terminating the inner loop of\nSVRG based on the reduction in \u2016vt\u20162, as \u2016vt\u20162 may have side fluctuations as shown in Figure 2."}, {"heading": "5. Numerical Experiments", "text": "To support the theoretical analyses and insights, we present our empirical experiments, comparing SARAH and SARAH+ with the state-of-the-art first-order methods for \u21132-regularized logistic regression problems with\nfi(w) = log(1 + exp(\u2212yixTi w)) + \u03bb2 \u2016w\u2016 2,\non datasets covtype, ijcnn1, news20 and rcv1 6. For ijcnn1 and rcv1 we use the predefined testing and training sets, while covtype and news20 do not have test data, hence we randomly split the datasets with 70% for training and 30% for testing. Some statistics of the datasets are summarized in Table 3.\nThe penalty parameter \u03bb is set to 1/n as is common practice (Le Roux et al., 2012). Note that like SVRG/S2GD and SAG/SAGA, SARAH also allows an efficient sparse implementation named \u201clazy updates\u201d (Konec\u030cny\u0301 et al., 2016). We conduct and compare numerical results of SARAH with SVRG, SAG, SGD+ and FISTA. SVRG (Johnson & Zhang, 2013) and SAG (Le Roux et al., 2012) are classic modern stochastic methods. SGD+ is SGD with decreasing learning rate \u03b7 = \u03b70/(k + 1) where k is the number of effective passes and \u03b70 is some initial constant learning rate. FISTA (Beck & Teboulle, 2009) is the Fast Iterative Shrinkage-ThresholdingAlgorithm, wellknown as an efficient accelerated version of the gradient descent. Even though for each method, there is a theoretical safe learning rate, we compare the results for the best learning rates in hindsight.\nFigure 5 shows numerical results in terms of loss residuals\n6All datasets are available at http://www.csie.ntu. edu.tw/\u02dccjlin/libsvmtools/datasets/.\n(top) and test errors (bottom) on the four datasets, SARAH is sometimes comparable or a little worse than other methods at the beginning. However, it quickly catches up to or surpasses all other methods, demonstrating a faster rate of decrease across all experiments. We observe that on covtype and rcv1, SARAH, SVRG and SAG are comparable with some advantage of SARAH on covtype. On ijcnn1 and news20, SARAH and SVRG consistently surpass the other methods.\nIn particular, to validate the efficiency of our practical variant SARAH+, we provide an insight into how important the choices of m and \u03b7 are for SVRG and SARAH in Table 4 and Figure 6. Table 4 presents the optimal choices of m and \u03b7 for each of the algorithm, while Figure 6 shows the behaviors of SVRG and SARAH with different choices of m for covtype and ijcnn1, where m\u2217s denote the best choices. In Table 4, the optimal learning rates of SARAH vary less among different datasets compared to all the other methods and they approximate the theoretical upper bound for SARAH (1/L); on the contrary, for the other methods the empirical optimal rates can exceed their theoretical limits (SVRG with 1/(4L), SAG with 1/(16L), FISTA with 1/L). This empirical studies suggest that it is much easier to tune and find the ideal learning rate for SARAH. As observed in Figure 6, the behaviors of both SARAH and SVRG are quite sensitive to the choices ofm. With improper choices of m, the loss residuals can be increased considerably from 10\u221215 to 10\u22123 on both covtype in 40 effective passes and ijcnn1 in 17 effective passes for"}, {"heading": "SARAH/SVRG.", "text": ""}, {"heading": "6. Conclusion", "text": "We propose a new variance reducing stochastic recursive gradient algorithm SARAH, which combines some of the properties of well known existing algorithms, such as SAGA and SVRG. For smooth convex functions, we show a sublinear convergence rate, while for strongly convex cases, we prove the linear convergence rate and the computational complexity as those of SVRG and SAG. However, compared to SVRG, SARAH\u2019s convergence rate constant is smaller and the algorithms is more stable both theoretically and numerically. Additionally, we prove the linear convergence for inner loops of SARAH which support the claim of stability. Based on this convergence we derive a practical version of SARAH, with a simple stopping criterion for the inner loops."}, {"heading": "Acknowledgements", "text": "The authors would like to thank the reviewers for useful suggestions which helped to improve the exposition in the paper."}, {"heading": "A. Technical Results", "text": "Lemma 4 (Theorem 2.1.5 in (Nesterov, 2004)). Suppose that f is convex and L-smooth. Then, for any w, w\u2032 \u2208 Rd,\nf(w) \u2264 f(w\u2032) +\u2207f(w\u2032)T (w \u2212 w\u2032) + L 2 \u2016w \u2212 w\u2032\u20162, (16)\nf(w) \u2265 f(w\u2032) +\u2207f(w\u2032)T (w \u2212 w\u2032) + 1 2L \u2016\u2207f(w)\u2212\u2207f(w\u2032)\u20162, (17)\n(\u2207f(w) \u2212\u2207f(w\u2032))T (w \u2212 w\u2032) \u2265 1 L \u2016\u2207f(w)\u2212\u2207f(w\u2032)\u20162. (18)\nNote that (16) does not require the convexity of f .\nLemma 5 (Theorem 2.1.11 in (Nesterov, 2004)). Suppose that f is \u00b5-strongly convex and L-smooth. Then, for any w, w\u2032 \u2208 Rd,\n(\u2207f(w)\u2212\u2207f(w\u2032))T (w \u2212 w\u2032) \u2265 \u00b5L \u00b5+ L \u2016w \u2212 w\u2032\u20162 + 1 \u00b5+ L \u2016\u2207f(w)\u2212\u2207f(w\u2032)\u20162. (19)\nLemma 6 (Choices ofm and \u03b7). Consider the rate of convergence \u03c3m in Theorem 4. If we choose \u03b7 = 1/(\u03b8L) with \u03b8 > 1 and fix \u03c3m, then the best choice ofm is\nm\u2217 = 1\n2 (2\u03b8\u2217 \u2212 1)2\u03ba\u2212 1,\nwhere \u03ba def = L/\u00b5, with \u03b8\u2217 calculated as:\n\u03b8\u2217 = \u03c3m + 1 +\n\u221a \u03c3m + 1\n2\u03c3m .\nFurthermore, we require \u03b8\u2217 > 1 + \u221a 2/2 for \u03c3m < 1."}, {"heading": "B. Proofs", "text": ""}, {"heading": "B.1. Proof of Lemma 1", "text": "By Assumption 1 and wt+1 = wt \u2212 \u03b7vt, we have\nE[P (wt+1)] (16) \u2264 E[P (wt)]\u2212 \u03b7E[\u2207P (wt)T vt] + L\u03b72\n2 E[\u2016vt\u20162]\n= E[P (wt)]\u2212 \u03b7\n2 E[\u2016\u2207P (wt)\u20162] +\n\u03b7 2 E[\u2016\u2207P (wt)\u2212 vt\u20162]\u2212\n(\n\u03b7 2 \u2212 L\u03b7\n2\n2\n)\nE[\u2016vt\u20162],\nwhere the last equality follows from the fact aT b = 12 [ \u2016a\u20162 + \u2016b\u20162 \u2212 \u2016a\u2212 b\u20162 ] .\nBy summing over t = 0, . . . ,m, we have\nE[P (wm+1)] \u2264 E[P (w0)]\u2212 \u03b7\n2\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u20162] + \u03b7\n2\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u2212 vt\u20162]\u2212 ( \u03b7 2 \u2212 L\u03b7 2 2\n) m \u2211\nt=0\nE[\u2016vt\u20162],\nwhich is equivalent to (\u03b7 > 0):\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u20162] \u2264 2\n\u03b7 E[P (w0)\u2212 P (wm+1)] +\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u2212 vt\u20162]\u2212 (1\u2212 L\u03b7) m \u2211\nt=0\nE[\u2016vt\u20162]\n\u2264 2 \u03b7 E[P (w0)\u2212 P (w\u2217)] +\nm \u2211\nt=0\nE[\u2016\u2207P (wt)\u2212 vt\u20162]\u2212 (1 \u2212 L\u03b7) m \u2211\nt=0\nE[\u2016vt\u20162],\nwhere the last inequality follows since w\u2217 is a global minimizer of P ."}, {"heading": "B.2. Proof of Lemma 2", "text": "Note that Fj contains all the information of w0, . . . , wj as well as v0, . . . , vj\u22121. For j \u2265 1, we have\nE[\u2016\u2207P (wj)\u2212 vj\u20162|Fj ] = E[\u2016[\u2207P (wj\u22121)\u2212 vj\u22121] + [\u2207P (wj)\u2212\u2207P (wj\u22121)]\u2212 [vj \u2212 vj\u22121]\u20162|Fj ] = \u2016\u2207P (wj\u22121)\u2212 vj\u22121\u20162 + \u2016\u2207P (wj)\u2212\u2207P (wj\u22121)\u20162 + E[\u2016vj \u2212 vj\u22121\u20162|Fj] + 2(\u2207P (wj\u22121)\u2212 vj\u22121)T (\u2207P (wj)\u2212\u2207P (wj\u22121)) \u2212 2(\u2207P (wj\u22121)\u2212 vj\u22121)TE[vj \u2212 vj\u22121|Fj] \u2212 2(\u2207P (wj)\u2212\u2207P (wj\u22121))TE[vj \u2212 vj\u22121|Fj ]\n= \u2016\u2207P (wj\u22121)\u2212 vj\u22121\u20162 \u2212 \u2016\u2207P (wj)\u2212\u2207P (wj\u22121)\u20162 + E[\u2016vj \u2212 vj\u22121\u20162|Fj],\nwhere the last equality follows from\nE[vj \u2212 vj\u22121|Fj ] (2)= E[\u2207fij (wj)\u2212\u2207fij (wj\u22121)|Fj ] = \u2207P (wj)\u2212\u2207P (wj\u22121).\nBy taking expectation for the above equation, we have\nE[\u2016\u2207P (wj)\u2212 vj\u20162] = E[\u2016\u2207P (wj\u22121)\u2212 vj\u22121\u20162]\u2212 E[\u2016\u2207P (wj)\u2212\u2207P (wj\u22121)\u20162] + E[\u2016vj \u2212 vj\u22121\u20162].\nNote that \u2016\u2207P (w0)\u2212 v0\u20162 = 0. By summing over j = 1, . . . , t (t \u2265 1), we have\nE[\u2016\u2207P (wt)\u2212 vt\u20162] = t \u2211\nj=1\nE[\u2016vj \u2212 vj\u22121\u20162]\u2212 t \u2211\nj=1\nE[\u2016\u2207P (wj)\u2212\u2207P (wj\u22121)\u20162]."}, {"heading": "B.3. Proof of Lemma 3", "text": "For j \u2265 1, we have\nE[\u2016vj\u20162|Fj] = E[\u2016vj\u22121 \u2212 (\u2207fij (wj\u22121)\u2212\u2207fij (wj))\u20162|Fj]\n= \u2016vj\u22121\u20162 + E [ \u2016\u2207fij (wj\u22121)\u2212\u2207fij (wj)\u20162 \u2212 2\u03b7 (\u2207fij (wj\u22121)\u2212\u2207fij (wj)) T (wj\u22121 \u2212 wj)|Fj ]\n(18) \u2264 \u2016vj\u22121\u20162 + E [ \u2016\u2207fij (wj\u22121)\u2212\u2207fij (wj)\u20162 \u2212 2L\u03b7\u2016\u2207fij (wj\u22121)\u2212\u2207fij (wj)\u2016 2|Fj ] = \u2016vj\u22121\u20162 + ( 1\u2212 2\u03b7L )\nE[\u2016\u2207fij (wj\u22121)\u2212\u2207fij (wj)\u20162|Fj ] (2) = \u2016vj\u22121\u20162 + ( 1\u2212 2\u03b7L ) E[\u2016vj \u2212 vj\u22121\u20162|Fj],\nwhich, if we take expectation, implies that\nE[\u2016vj \u2212 vj\u22121\u20162] \u2264 \u03b7L 2\u2212 \u03b7L [ E[\u2016vj\u22121\u20162]\u2212 E[\u2016vj\u20162] ] ,\nwhen \u03b7 < 2/L.\nBy summing the above inequality over j = 1, . . . , t (t \u2265 1), we have t\n\u2211\nj=1\nE[\u2016vj \u2212 vj\u22121\u20162] \u2264 \u03b7L 2\u2212 \u03b7L [ E[\u2016v0\u20162]\u2212 E[\u2016vt\u20162] ] . (20)\nBy Lemma 2, we have\nE[\u2016\u2207P (wt)\u2212 vt\u20162] \u2264 t \u2211\nj=1\nE[\u2016vj \u2212 vj\u22121\u20162] (20) \u2264 \u03b7L 2\u2212 \u03b7L [ E[\u2016v0\u20162]\u2212 E[\u2016vt\u20162] ] ."}, {"heading": "B.4. Proof of Lemma 6", "text": "With \u03b7 = 1/(\u03b8L) and \u03ba = L/\u00b5, the rate of convergence \u03b1m can be written as\n\u03c3m (15) =\n1\n\u00b5\u03b7(m+ 1) +\n\u03b7L 2\u2212 \u03b7L = \u03b8L \u00b5(m+ 1) + 1/\u03b8 2\u2212 1/\u03b8 = ( \u03ba m+ 1 ) \u03b8 + 1 2\u03b8 \u2212 1 ,\nwhich is equivalent to\nm(\u03b8) def = m = \u03b8(2\u03b8 \u2212 1) \u03c3m(2\u03b8 \u2212 1)\u2212 1 \u03ba\u2212 1.\nSince \u03c3m is considered fixed, then the optimal choice of m in terms of \u03b8 can be solved from min\u03b8 m(\u03b8), or equivalently, 0 = (\u2202m)/(\u2202\u03b8) = m\u2032(\u03b8), and therefore we have the equation with the optimal \u03b8 satisfying\n\u03c3m = (4\u03b8 \u2217 \u2212 1)/(2\u03b8\u2217 \u2212 1)2, (21)\nand by plugging it intom(\u03b8) we conclude the optimalm:\nm\u2217 = m(K\u2217) = 1\n2 (2K\u2217 \u2212 1)2\u03ba\u2212 1,\nwhile by solving for \u03b8\u2217 in (21) and taking into account that \u03b8 > 1, we have the optimal choice of \u03b8:\n\u03b8\u2217 = \u03c3m + 1 +\n\u221a \u03c3m + 1\n2\u03c3m .\nObviously, for \u03c3m < 1, we require \u03b8 \u2217 > 1 + \u221a 2/2."}, {"heading": "B.5. Proof of Theorem 1a", "text": "For t \u2265 1, we have\n\u2016\u2207P (wt)\u2212\u2207P (wt\u22121)\u20162 = \u2225 \u2225 \u2225 1\nn\nn \u2211\ni=1\n[\u2207fi(wt)\u2212\u2207fi(wt\u22121)] \u2225 \u2225 \u2225 2\n\u2264 1 n\nn \u2211\ni=1\n\u2016\u2207fi(wt)\u2212\u2207fi(wt\u22121)\u20162\n= E[\u2016\u2207fit(wt)\u2212\u2207fit(wt\u22121)\u20162|Ft]. (22)\nUsing the proof of Lemma 3, for t \u2265 1, we have\nE[\u2016vt\u20162|Ft] \u2264 \u2016vt\u22121\u20162 + ( 1\u2212 2\u03b7L )\nE[\u2016\u2207fit(wt\u22121)\u2212\u2207fit(wt)\u20162|Ft] (22) \u2264 \u2016vt\u22121\u20162 + ( 1\u2212 2\u03b7L ) \u2016\u2207P (wt)\u2212\u2207P (wt\u22121)\u20162 \u2264 \u2016vt\u22121\u20162 + ( 1\u2212 2\u03b7L ) \u00b52\u03b72\u2016vt\u22121\u20162.\nNote that 1 \u2212 2\u03b7L < 0 since \u03b7 < 2/L. The last inequality follows by the strong convexity of P , that is, \u00b5\u2016wt \u2212 wt\u22121\u2016 \u2264 \u2016\u2207P (wt) \u2212 \u2207P (wt\u22121)\u2016 and the fact that wt = wt\u22121 \u2212 \u03b7vt\u22121. By taking the expectation and applying recursively, we have\nE[\u2016vt\u20162] \u2264 [ 1\u2212 ( 2 \u03b7L \u2212 1 ) \u00b52\u03b72 ] E[\u2016vt\u22121\u20162]\n\u2264 [ 1\u2212 (\n2 \u03b7L \u2212 1\n) \u00b52\u03b72 ]t E[\u2016v0\u20162]\n= [ 1\u2212 (\n2 \u03b7L \u2212 1\n) \u00b52\u03b72 ]t E[\u2016\u2207P (w0)\u20162]."}, {"heading": "B.6. Proof of Theorem 1b", "text": "We obviously have E[\u2016v0\u20162|F0] = \u2016\u2207P (w0)\u20162. For t \u2265 1, we have\nE[\u2016vt\u20162|Ft] (2)= E[\u2016vt\u22121 \u2212 (\u2207fit(wt\u22121)\u2212\u2207fit(wt))\u20162|Ft] (3) = \u2016vt\u22121\u20162 + E[\u2016\u2207fit(wt\u22121)\u2212\u2207fit(wt)\u20162 \u2212 2\u03b7 (\u2207fit(wt\u22121)\u2212\u2207fit(wt))\nT (wt\u22121 \u2212 wt)|Ft] (19) \u2264 \u2016vt\u22121\u20162 \u2212 2\u00b5L\u03b7\u00b5+L \u2016vt\u22121\u2016 2 + E[\u2016\u2207fit(wt\u22121)\u2212\u2207fit(wt)\u20162|Ft]\u2212 2\u03b7 \u00b7 1\u00b5+LE[\u2016\u2207fit(wt\u22121)\u2212\u2207fit(wt)\u2016\n2|Ft] = (1\u2212 2\u00b5L\u03b7\u00b5+L )\u2016vt\u22121\u2016 2 + (1\u2212 2\u03b7 \u00b7 1\u00b5+L )E[\u2016\u2207fit(wt\u22121)\u2212\u2207fit(wt)\u2016 2|Ft] \u2264 (\n1\u2212 2\u00b5L\u03b7\u00b5+L ) \u2016vt\u22121\u20162, (23)\nwhere in last inequality we have used that \u03b7 \u2264 2/(\u00b5+ L). By taking the expectation and applying recursively, the desired result is achieved."}, {"heading": "B.7. Proof of Theorem 3", "text": "By Theorem 2, we have\nE[\u2016\u2207P (w\u0303s)\u20162] \u2264 2\n\u03b7(m+ 1) E[P (w\u0303s\u22121)\u2212 P (w\u2217)] +\n\u03b7L\n2\u2212 \u03b7LE[\u2016\u2207P (w\u0303s\u22121)\u2016 2]\n= \u03b4s\u22121 + \u03b1E[\u2016\u2207P (w\u0303s\u22121)\u20162] \u2264 \u03b4s\u22121 + \u03b1\u03b4s\u22122 + \u00b7 \u00b7 \u00b7+ \u03b1s\u22121\u03b40 + \u03b1s\u2016\u2207P (w\u03030)\u20162 \u2264 \u03b4 + \u03b1\u03b4 + \u00b7 \u00b7 \u00b7+ \u03b1s\u22121\u03b4 + \u03b1s\u2016\u2207P (w\u03030)\u20162 \u2264 \u03b4 1\u2212 \u03b1 s\n1\u2212 \u03b1 + \u03b1 s\u2016\u2207P (w\u03030)\u20162\n= \u2206(1 \u2212 \u03b1s) + \u03b1s\u2016\u2207P (w\u03030)\u20162 = \u2206+ \u03b1s(\u2016\u2207P (w\u03030)\u20162 \u2212\u2206),\nwhere the second last equality follows since\n\u03b4 1\u2212 \u03b1 = \u03b4 ( 2\u2212 \u03b7L 2\u2212 2\u03b7L ) = \u03b4 ( 1 + \u03b7L 2(1\u2212 \u03b7L) ) = \u2206.\nHence, the desired result is achieved."}, {"heading": "B.8. Proof of Corollary 2", "text": "Based on Theorem 3, if we would aim for an \u01eb-accuracy solution, we can choose\u2206 = \u01eb/4 and \u03b1 = 1/2 (with \u03b7 = 2/(3L)). To obtain the convergence to an \u01eb-accuracy solution, we need to have \u03b4 = O(\u01eb), or equivalently, m = O(1/\u01eb). Then we\nhave\nE[\u2016\u2207P (w\u0303s)\u20162] (13) \u2264 \u2206 2 + 1 2 E[\u2016\u2207P (w\u0303s\u22121)\u20162]\n\u2264 \u2206 2 + \u2206 22 + 1 22 E[\u2016\u2207P (w\u0303s\u22122)\u20162] \u2264 \u2206 ( 1\n2 +\n1 22 + \u00b7 \u00b7 \u00b7+ 1 2s\n)\n+ 1\n2s \u2016\u2207P (w\u03030)\u20162\n\u2264 \u2206+ 1 2s \u2016\u2207P (w\u03030)\u20162.\nTo guarantee that E[\u2016\u2207P (w\u0303s)\u20162] \u2264 \u01eb, it is sufficient to make 12s \u2016\u2207P (w\u03030)\u20162 \u2264 34\u01eb, or s = O(log(1/\u01eb)). This implies the total complexity to achieve an \u01eb-accuracy solution is (n+ 2m)s = O((n+ (1/\u01eb)) log(1/\u01eb))."}, {"heading": "B.9. Proof of Corollary 3", "text": "Based on Lemma 6 and Theorem 4, let us pick \u03b8\u2217 = 2, i.e, then we have m\u2217 = 4.5\u03ba \u2212 1. So let us run SARAH with \u03b7 = 1/(2L) andm = 4.5\u03ba, then we can calculate \u03c3m in (15) as\n\u03c3m = 1\n\u00b5\u03b7(m+ 1) +\n\u03b7L 2\u2212 \u03b7L = 1 [\u00b5/(2L)](4.5\u03ba+ 1) + 1/2 2\u2212 1/2 < 4 9 + 1 3 = 7 9 .\nAccording to Theorem 4, if we run SARAH for T iterations where\nT = \u2308log(\u2016\u2207P (w\u03030)\u20162/\u01eb)/ log(9/7)\u2309 = \u2308log7/9(\u01eb/\u2016\u2207P (w\u03030)\u20162)\u2309 \u2265 log7/9(\u01eb/\u2016\u2207P (w\u03030)\u20162),\nthen we have\nE[\u2016\u2207P (w\u0303T )\u20162] \u2264 (\u03c3m)T \u2016\u2207P (w\u03030)\u20162 < (7/9)T \u2016\u2207P (w\u03030)\u20162 \u2264 (7/9)log7/9(\u01eb/\u2016\u2207P (w\u03030)\u2016 2)\u2016\u2207P (w\u03030)\u20162 = \u01eb,\nthus we can derive (7). If we consider the number of gradient evaluations as the main computational complexity, then the total complexity can be obtained as\n(n+ 2m)T = O ((n+ \u03ba) log(1/\u01eb)) ."}], "references": [{"title": "Katyusha: The First Direct Acceleration of Stochastic Gradient Methods", "author": ["Allen-Zhu", "Zeyuan"], "venue": "Proceedings of the 49th Annual ACM on Symposium on Theory of Computing (to appear),", "citeRegEx": "Allen.Zhu and Zeyuan.,? \\Q2017\\E", "shortCiteRegEx": "Allen.Zhu and Zeyuan.", "year": 2017}, {"title": "Improved SVRG for Non-Strongly-Convex or Sum-of-Non-Convex Objectives", "author": ["Allen-Zhu", "Zeyuan", "Yuan", "Yang"], "venue": "In ICML,", "citeRegEx": "Allen.Zhu et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Allen.Zhu et al\\.", "year": 2016}, {"title": "A fast iterative shrinkagethresholding algorithm for linear inverse problems", "author": ["Beck", "Amir", "Teboulle", "Marc"], "venue": "SIAM J. Imaging Sciences,", "citeRegEx": "Beck et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Beck et al\\.", "year": 2009}, {"title": "Online learning and stochastic approximations", "author": ["Bottou", "L\u00e9on"], "venue": null, "citeRegEx": "Bottou and L\u00e9on.,? \\Q1998\\E", "shortCiteRegEx": "Bottou and L\u00e9on.", "year": 1998}, {"title": "Optimization methods for large-scale machine learning", "author": ["Bottou", "L\u00e9on", "Curtis", "Frank E", "Nocedal", "Jorge"], "venue": null, "citeRegEx": "Bottou et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Bottou et al\\.", "year": 2016}, {"title": "Better mini-batch algorithms via accelerated gradient methods", "author": ["Cotter", "Andrew", "Shamir", "Ohad", "Srebro", "Nati", "Sridharan", "Karthik"], "venue": "In NIPS, pp", "citeRegEx": "Cotter et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Cotter et al\\.", "year": 2011}, {"title": "SAGA: A fast incremental gradient method with support for non-strongly convex composite objectives", "author": ["Defazio", "Aaron", "Bach", "Francis", "Lacoste-Julien", "Simon"], "venue": "In NIPS,", "citeRegEx": "Defazio et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Defazio et al\\.", "year": 2014}, {"title": "The Elements of Statistical Learning: Data Mining, Inference, and Prediction", "author": ["Hastie", "Trevor", "Tibshirani", "Robert", "Friedman", "Jerome"], "venue": "Springer Series in Statistics,", "citeRegEx": "Hastie et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hastie et al\\.", "year": 2009}, {"title": "Accelerating stochastic gradient descent using predictive variance reduction", "author": ["Johnson", "Rie", "Zhang", "Tong"], "venue": "In NIPS, pp", "citeRegEx": "Johnson et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Johnson et al\\.", "year": 2013}, {"title": "Mini-batch semi-stochastic gradient descent in the proximal setting", "author": ["Kone\u010dn\u00fd", "Jakub", "Liu", "Jie", "Richt\u00e1rik", "Peter", "Tak\u00e1\u010d", "Martin"], "venue": "IEEE Journal of Selected Topics in Signal Processing,", "citeRegEx": "Kone\u010dn\u00fd et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Kone\u010dn\u00fd et al\\.", "year": 2016}, {"title": "Semi-stochastic gradient descent methods", "author": ["Kone\u010dn\u00fd", "Jakub", "Richt\u00e1rik", "Peter"], "venue": null, "citeRegEx": "Kone\u010dn\u00fd et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Kone\u010dn\u00fd et al\\.", "year": 2013}, {"title": "A stochastic gradient method with an exponential convergence rate for finite training sets", "author": ["Le Roux", "Nicolas", "Schmidt", "Mark", "Bach", "Francis"], "venue": "In NIPS,", "citeRegEx": "Roux et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Roux et al\\.", "year": 2012}, {"title": "Optimization with first-order surrogate functions", "author": ["Mairal", "Julien"], "venue": "In ICML, pp", "citeRegEx": "Mairal and Julien.,? \\Q2013\\E", "shortCiteRegEx": "Mairal and Julien.", "year": 2013}, {"title": "Introductory lectures on convex optimization : a basic course", "author": ["Nesterov", "Yurii"], "venue": null, "citeRegEx": "Nesterov and Yurii.,? \\Q2004\\E", "shortCiteRegEx": "Nesterov and Yurii.", "year": 2004}, {"title": "Stochastic variance reduction for nonconvex optimization", "author": ["Reddi", "Sashank J", "Hefny", "Ahmed", "Sra", "Suvrit", "P\u00f3czos", "Barnab\u00e1s", "Smola", "Alexander J"], "venue": "In ICML,", "citeRegEx": "Reddi et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Reddi et al\\.", "year": 2016}, {"title": "A stochastic approximation method", "author": ["Robbins", "Herbert", "Monro", "Sutton"], "venue": "The Annals of Mathematical Statistics,", "citeRegEx": "Robbins et al\\.,? \\Q1951\\E", "shortCiteRegEx": "Robbins et al\\.", "year": 1951}, {"title": "Minimizing finite sums with the stochastic average gradient", "author": ["Schmidt", "Mark", "Le Roux", "Nicolas", "Bach", "Francis"], "venue": "Mathematical Programming,", "citeRegEx": "Schmidt et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Schmidt et al\\.", "year": 2016}, {"title": "Stochastic dual coordinate ascent methods for regularized loss", "author": ["Shalev-Shwartz", "Shai", "Zhang", "Tong"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2013}, {"title": "Pegasos: Primal estimated sub-gradient solver for SVM", "author": ["Shalev-Shwartz", "Shai", "Singer", "Yoram", "Srebro", "Nathan"], "venue": "In ICML, pp", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2007}, {"title": "Pegasos: Primal estimated sub-gradient solver for SVM", "author": ["Shalev-Shwartz", "Shai", "Singer", "Yoram", "Srebro", "Nathan", "Cotter", "Andrew"], "venue": "Mathematical Programming,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2011}, {"title": "Mini-batch primal and dual methods for SVMs", "author": ["Tak\u00e1\u010d", "Martin", "Bijral", "Avleen Singh", "Richt\u00e1rik", "Peter", "Srebro", "Nathan"], "venue": "In ICML,", "citeRegEx": "Tak\u00e1\u010d et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Tak\u00e1\u010d et al\\.", "year": 2013}, {"title": "A proximal stochastic gradient method with progressive variance reduction", "author": ["Xiao", "Lin", "Zhang", "Tong"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "Xiao et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Xiao et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 7, "context": "Problems of this type arise frequently in supervised learning applications (Hastie et al., 2009).", "startOffset": 75, "endOffset": 96}, {"referenceID": 19, "context": "Using diminishing sequence {\u03b7t} is used to control the variance (Shalev-Shwartz et al., 2011; Bottou et al., 2016), but the practical convergence of SGD is known to be very sensitive to the choice of this sequence, which needs to be hand-picked.", "startOffset": 64, "endOffset": 114}, {"referenceID": 4, "context": "Using diminishing sequence {\u03b7t} is used to control the variance (Shalev-Shwartz et al., 2011; Bottou et al., 2016), but the practical convergence of SGD is known to be very sensitive to the choice of this sequence, which needs to be hand-picked.", "startOffset": 64, "endOffset": 114}, {"referenceID": 6, "context": "The examples of these methods are SAG/SAGA (Le Roux et al., 2012; Defazio et al., 2014), SDCA (Shalev-Shwartz & Zhang, 2013), SVRG (Johnson & Zhang, 2013; Xiao & Zhang, 2014), DIAG (Mokhtari et al.", "startOffset": 43, "endOffset": 87}, {"referenceID": 16, "context": "In addition, theoretical results for complexity of the methods or their variants when applied to general convex functions have been derived (Schmidt et al., 2016; Defazio et al., 2014; Reddi et al., 2016; Allen-Zhu & Yuan, 2016; Allen-Zhu, 2017).", "startOffset": 140, "endOffset": 245}, {"referenceID": 6, "context": "In addition, theoretical results for complexity of the methods or their variants when applied to general convex functions have been derived (Schmidt et al., 2016; Defazio et al., 2014; Reddi et al., 2016; Allen-Zhu & Yuan, 2016; Allen-Zhu, 2017).", "startOffset": 140, "endOffset": 245}, {"referenceID": 14, "context": "In addition, theoretical results for complexity of the methods or their variants when applied to general convex functions have been derived (Schmidt et al., 2016; Defazio et al., 2014; Reddi et al., 2016; Allen-Zhu & Yuan, 2016; Allen-Zhu, 2017).", "startOffset": 140, "endOffset": 245}, {"referenceID": 9, "context": "Note that like SVRG/S2GD and SAG/SAGA, SARAH also allows an efficient sparse implementation named \u201clazy updates\u201d (Kone\u010dn\u00fd et al., 2016).", "startOffset": 113, "endOffset": 135}], "year": 2017, "abstractText": "In this paper, we propose a StochAstic Recursive grAdient algoritHm (SARAH), as well as its practical variant SARAH+, as a novel approach to the finite-sum minimization problems. Different from the vanilla SGD and other modern stochastic methods such as SVRG, S2GD, SAG and SAGA, SARAH admits a simple recursive framework for updating stochastic gradient estimates; when comparing to SAG/SAGA, SARAH does not require a storage of past gradients. The linear convergence rate of SARAH is proven under strong convexity assumption. We also prove a linear convergence rate (in the strongly convex case) for an inner loop of SARAH, the property that SVRG does not possess. Numerical experiments demonstrate the efficiency of our algorithm.", "creator": "LaTeX with hyperref package"}}}