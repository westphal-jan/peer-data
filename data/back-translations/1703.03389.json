{"id": "1703.03389", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "9-Mar-2017", "title": "Faster Greedy MAP Inference for Determinantal Point Processes", "abstract": "In this paper, we develop fast algorithms to find the most likely configuration (MAP) of large DPPs, which is generally NP-hard. Due to the submodular nature of the MAP object, greedy algorithms have been used with empirical success. Greedy implementations require the calculation of log determinants, matrix inverts, or solving linear systems at each iteration. We present faster implementations of greedy algorithms by taking advantage of the complementary advantages of two log-determined approximation schemes: (a) first-order expansions to the log-determining function of the matrix, and (b) high-order expansions to the scalar log function with stochastic trace estimators. In our experiments, our algorithms are orders of magnitude faster than their competitors while exhibiting marginal accuracy.", "histories": [["v1", "Thu, 9 Mar 2017 18:43:11 GMT  (1386kb,D)", "http://arxiv.org/abs/1703.03389v1", null], ["v2", "Wed, 14 Jun 2017 02:48:18 GMT  (1320kb,D)", "http://arxiv.org/abs/1703.03389v2", null]], "reviews": [], "SUBJECTS": "cs.DM cs.LG", "authors": ["insu han", "prabhanjan kambadur", "kyoungsoo park", "jinwoo shin"], "accepted": true, "id": "1703.03389"}, "pdf": {"name": "1703.03389.pdf", "metadata": {"source": "CRF", "title": "Faster Greedy MAP Inference for Determinantal Point Processes", "authors": ["Insu Han", "Prabhanjan Kambadur", "Kyoungsoo Park", "Jinwoo Shin"], "emails": ["hawki17@kaist.ac.kr", "badur@gmail.com", "soo@kaist.ac.kr", "woos@kaist.ac.kr"], "sections": [{"heading": "1 Introduction", "text": "Determinantal point processes (DPPs) are elegant probabilistic models, first introduced by [24], who called them \u2018fermion processes\u2019. Since then, DPPs have been extensively studied in the fields of quantum physics and random matrices, giving rise to a beautiful theory [5]. The characteristic of a DPP is to repel, which makes DPPs useful for modeling diversity. Recently, they have been applied in many machine learning tasks such as summarization [9], human pose detection [19], clustering [15] and tweet time-line generation [35]. In particular, their computational advantage compared to other probabilistic models is that many important inference tasks are computationally tractable. For example, conditioning, sampling [15] and marginalization of DPPs admit polynomialtime/efficient algorithms, while those on popular graphical models [14] do not, i.e., they are NPhard. One exception is the MAP inference (finding the most likely configuration), which is our main interest; this is known to be NP-hard even for DPPs [19]. \u2217School of Electrical Engineering, Korea Advanced Institute of Science and Technology, Korea. Emails: hawki17@kaist.ac.kr \u2020Business Analytics and Mathematical Sciences, Natural Language Processing, Bloomberg LP. Email: prabhanjankambadur@gmail.com \u2021School of Electrical Engineering, Korea Advanced Institute of Science and Technology, Korea. Email: kyoungsoo@kaist.ac.kr \u00a7School of Electrical Engineering, Korea Advanced Institute of Science and Technology, Korea. Email: jinwoos@kaist.ac.kr\nar X\niv :1\n70 3.\n03 38\n9v 1\n[ cs\n.D M\n] 9\nM ar\nThe distribution of diverse sets under DPPs is characterized by determinants of a kernel matrix based on their features, and the corresponding MAP inference reduces to finding a sub-matrix that maximizes its determinant. It is well known that the matrix log-determinant is a submodular function; that is, the MAP inference of DPPs is a special instance of submodular maximization. Greedy algorithms have been shown to have the best worst-case approximation guarantees for many instances of submodular maximization; for example, (1\u2212 1/e)-approximation for monotone functions. Furthermore, it has been often empirically observed that greedy algorithms provide near optimal solutions [17]. Hence, greedy algorithms have been also applied for the DPP task [19, 35, 36]. Known implementations of greedy selection on DPP require computation of log-determinants, matrix inversions [19] or solving linear systems [22]. Consequently, they run in \u2126(d4) time where d is the total number of items (see Section 2.3). In this paper, we propose faster greedy implementations that run in O(d3) time."}, {"heading": "1.1 Contribution", "text": "Our high-level idea is to amortize greedy operations by utilizing log-determinant approximation schemes. A greedy selection requires computation of marginal gains of log-determinants; we consider their first-order (linear) approximations. We observe that the computation of multiple marginal gains can be amortized into a single run of a linear solver, in addition to multiple vector inner products. We choose the popular conjugate gradient descent (CG) [32] as a linear solver. In addition, for improving the quality of first-order approximations, we partition remaining items into p \u2265 1 sets (via some clustering algorithm), and apply the first-order approximations in each partition. The resulting approximate computation of multiple marginal gains at each greedy selection requires 2p runs of CG under the Schur complement, and the overall running time of the proposed greedy algorithm becomes O(d3) under the choice of p = O(1) (see Section 3).\nNext, we develop an even faster greedy algorithm using a batch strategy for larger-scale DPPs. In addition to using the first-order approximations of log-determinants under a partitioning scheme, we add k > 1 elements instead of a single element to the current set, where we sample some candidates among all possible k elements to relax the expensive cost of computing all marginal gains. Intuitively, the batch selection makes the algorithm k times faster, while potentially reducing the approximation quality. Now, we suggest running the recent fast log-determinant approximation scheme (LDAS) [11] p times, instead of running CG pk times under the Schur complement, where LDAS utilizes high-order, i.e., polynomial, approximations to the scalar log function with stochastic trace estimators. Since the complexities of running LDAS and CG are comparable, running the former p times is faster than running the latter pk times if k > 1. Finally, we discovered a novel scheme for boosting the approximation quality by sharing random vectors among many runs of LDAS, and also establish theoretical justification why this helps.\nIn our experiments on both synthetic and real-world datasets, the proposed algorithms are orders of magnitude faster than competitors, while losing only 0.01-approximation ratio."}, {"heading": "1.2 Related work", "text": "To the best of our knowledge, this is the first work that aims for developing faster greedy algorithms specialized for the MAP inference of DPP, while there has been several efforts on those for general submodular maximization. An accelerated greedy algorithm was first proposed by [26] which\nmaintains the upper bounds on the marginal gains instead of recomputing exact values. In each iteration, only the elements with the maximal bound compute the exact gain, which still bounds on the exact value due to submodularity. However, we found that the approximation quality of this algorithm is extremely bad for the DPP case (see Section 5). Another natural approach is on stochastic greedy selections computing marginal gains of randomly selected elements. Its worst-case approximation guarantee was also studied [27], under the standard, non-batch, greedy algorithm. The idea of stochastic selections can be also applied to our algorithms, where we indeed apply it for designing our faster batch greedy algorithm as mentioned earlier. Recently, [4] proposed a \u2018one-pass\u2019 greedy algorithm where each greedy selection requires computing only a single marginal gain, i.e., the number of marginal gains necessary to compute can be significantly reduced. However, this algorithm is attractive only for the case when evaluating a marginal gain does not increase with respect to the size of the current set, which does not hold for the DPP case. As reported in Section 5, it performs significantly worse than our algorithms in both their approximation qualities and running times. There have been also several efforts to design parallel/distributed implementations of greedy algorithms: [30] use parallel strategies for the above one-pass greedy algorithm and [20] adapt a MapReduce paradigm for implementing greedy algorithms in distributed settings. One can also parallelize our algorithms easily since they require independent runs of matrix-vector (or vector inner) products, but we do not explore this aspect in this paper. Finally, we remark that a non-greedy algorithm was studied in [8] for better MAP qualities of DPP, but it is much slower than ours as reported in Section 5."}, {"heading": "1.3 Organization", "text": "We introduce the necessary background in Section 2, and present the proposed algorithms in Section 3 and Section 4. Experimental results are reported in Section 5."}, {"heading": "2 Preliminaries", "text": "We start by defining a necessary notation. Our algorithms for determinantal point processes (DPPs) select elements from the ground set of d items Y = [d] := {1, 2, . . . , d} and denote the set of all subsets of Y by 2Y . For any positive semidefinite matrix L \u2208 Rd\u00d7d, we denote \u03bbmin and \u03bbmax to be the smallest and the largest eigenvalues of L. Given subset X,Y \u2286 Y , we use LX,Y to denote the submatrix of L obtained by entries in rows and columns indexed by X and Y , respectively. For notational simplicity, we let LX,X = LX and LX,{i} = LX,i for i \u2208 Y . In addition, LX is defined as the average of LX\u222a{i} for i \u2208 Y \\ X . Finally, \u3008\u00b7, \u00b7\u3009 means the matrix/vector inner product or element-wise product sum.\nIn Section 2.1, we introduce the maximum a posteriori (MAP) inference of DPP, then the standard greedy optimization scheme and its na\u0131\u0308ve implementations are described in Section 2.2 and Section 2.3, respectively."}, {"heading": "2.1 Determinantal Point Processes", "text": "DPPs are probabilistic models for subset selection of a finite ground set Y = [d] that captures both quality and diversity. Formally, it defines the following distribution on 2Y : for X \u2286 Y ,\nPr [X \u2286 Y] \u221d det (LX) ,\nwhere L \u2208 Rd\u00d7d is a positive definite matrix called an L-ensemble kernel. Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9]. In particular, we are interested in the MAP inference, i.e., finding the most diverse subset Y of Y that achieves the highest probability, i.e., arg maxY\u2286Y det(LY ), possibly under some constraints on Y . Unlike other inference tasks on DPP, it is known that MAP is a NP-hard problem [19]."}, {"heading": "2.2 Greedy Submodular Maximization", "text": "A set function f : 2Y \u2192 R is submodular if its marginal gains are decreasing, i.e.,\nf(X \u222a {i})\u2212 f(X) \u2265 f(Y \u222a {i})\u2212 f(Y ),\nfor every X \u2286 Y \u2282 Y and every i \u2208 Y \\ Y . We say f is monotone if f(X) \u2264 f(Y ) for every X \u2286 Y . It is well known that DPP has the submodular structure, i.e., f = log det is submodular.\nThe submodular maximization task is to find a subset maximizing a submodular function f , which corresponds to the MAP inference task in the DPP case. Hence, it is NP-hard and a popular approximate scheme is the following greedy procedure [28]: initially, X \u2190 \u2205 and iteratively update X \u2190 X \u222a {imax} for\nimax = argmax i\u2208Y\\X\nf(X \u222a {i})\u2212 f(X), (1)\nas long as f(X \u222a {imax}) > f(X). For the monotone case, it guarantees (1\u2212 1/e)-approximation [28]. Under some modifications of the standard greedy procedure, 2/5-approximation can be guaranteed even for non-monotone functions [7]. Irrespectively of such theoretical guarantees, it has been empirically observed that greedy selection (1) provides near optimal solutions in practice [17, 33, 35, 36]."}, {"heading": "2.3 Na\u0131\u0308ve Implementations of Greedy Algorithm", "text": "Log-determinant or related computations, which are at the heart of greedy algorithms for MAP inference of DPPs, are critical to compute the marginal gain log detLX\u222a{i} \u2212 log detLX . Since exact computations of log-determinants might be slow, requiringO(d3) time even for d-dimensional sparse matrices, we introduce recent efficient log-determinant approximation schemes (LDAS). The log-determinant of a symmetric positive definite matrix A can be approximated by combining (a) Chebyshev polynomial expansion of the scalar log function and (b) matrix trace estimators via Monte Carlo methods:\nlog detA = tr (logA) (a) \u2248 tr (pn(A)) (b) \u2248 1 m m\u2211 t=1 v(t)>pn(A)v (t).\nHere, pn(x) is a polynomial expansion of degree n approximating log x and v(1), . . . ,v(m) are random vectors used for estimating the trace of pn(A). In literature, several polynomial expansions, including Taylor [3], Chebyshev [11] and Legendre [31] have been used. For trace estimation, several random vectors have been also studied [1], e.g., the Hutchinson method [13] chooses elements\nof v as i.i.d. random numbers in {\u22121,+1} so that E [ v>Av ] = tr (A). In this paper, we use LDAS using the Chebyshev polynomial and Hutchinson method [11], but one can also use other alternatives.\nLog-determinant Approximation Scheme (LDAS) [11]\nInput: symmetric matrix A \u2208 Rd\u00d7d with eigenvalues in [\u03b4, 1 \u2212 \u03b4], sampling number m and polynomial degree n Initialize: \u0393\u2190 0 cj \u2190 j-th coefficient of Chebyshev expansion of log x on [\u03b4, 1\u2212 \u03b4] for 0 \u2264 j \u2264 n. for i = 1 to m do\nDraw a random vector v(i) \u2208 {\u22121,+1}d whose entries are uniformly distributed. w\n(i) 0 \u2190 v(i) and w (i) 1 \u2190 21\u22122\u03b4Av (i) \u2212 11\u22122\u03b4v (i)\nu\u2190 c0w(i)0 + c1w (i) 1 for j = 2 to n do w\n(i) 2 \u2190 41\u22122\u03b4Aw (i) 1 \u2212 21\u22122\u03b4w (i) 1 \u2212w (i) 0\nu\u2190 u + cj w(i)2 w\n(i) 0 \u2190 w (i) 1 and w (i) 1 \u2190 w (i) 2\nend for \u0393\u2190 \u0393 + v(i)>u/m\nend for Output: \u0393\nObserve that LDAS only requires matrix-vector multiplications and its running time is \u0398 ( d2 )\nfor constants m,n = O(1). One can directly use LDAS for computing (1) and the resulting greedy algorithm runs in \u0398(d \u00b7 T 3GR) time if the number of greedy updates on the current set X is TGR. For example, if TGR = \u2126(d), the complexity is simply \u0398(d4). An alternative way to achieve the same complexity is to use the Schur complement [29]:\nlog detLX\u222a{i} \u2212 log detLX = log ( Li,i \u2212 Li,XL\u22121X LX,i ) . (2)\nThis requires a linear solver to compute L\u22121X LX,i; conjugate gradient descent (CG) [10] is a popular choice in practice. Hence, if one applies CG to compute the max-marginal gain (1), the resulting greedy algorithm runs in \u0398(d \u00b7 T 3GR \u00b7 TCG) time, where TCG denotes the number of iterations of each CG run. In the worst case, CG converges to the exact solution when TCG grows with the matrix dimension, but for practical purposes, it typically provides a very accurate solution in few iterations, i.e., TCG = O(1). Recently, Gauss quadrature via Lanczos iteration is used for efficient computing of Li,XL \u22121 X LX,i [22]. Although it guarantees rigorous upper/lower bounds, CG is faster and accurate enough for practical purposes.\nIn summary, the greedy MAP inference of DPP can be implemented efficiently via LDAS or CG. The faster implementations proposed in this paper smartly employ both of them as key components utilizing their complementary benefits."}, {"heading": "3 Faster Greedy DPP Inference", "text": "In this section, we provide a faster greedy submodular maximization scheme for the MAP inference of DPP. We explain our key ideas in Section 3.1 and then, provide the formal algorithm description\nin Section 3.2."}, {"heading": "3.1 Key Ideas", "text": "First-order approximation of log-determinant. The main computational bottleneck of a greedy algorithm is to evaluate the marginal gain (1) for every element not in the current set. To reduce the time complexity, we consider the following first-order, i.e., linear, approximation of log-determinant as:1\nargmax i\u2208Y\\X\nlog detLX\u222a{i} \u2212 log detLX\n= argmax i\u2208Y\\X\nlog detLX\u222a{i} \u2212 log detLX\n\u2248 argmax i\u2208Y\\X\n\u2329 L \u22121 X , LX\u222a{i} \u2212 LX \u232a , (3)\nwhere recall that LX is the average of LX\u222a{i}. Observe that computing (3) requires the vector inner product of a single column (or row) of L \u22121 X and LX\u222a{i}\u2212LX because LX\u222a{i} and LX share almost all entries except a single row and a column.\nTo obtain a single column of L \u22121 X , one can solve a linear system using the CG algorithm. More importantly, it suffices to run CG once for computing (3), while the na\u0131\u0308ve greedy implementation described in Section 2.3 has to run CG |Y \\X| times. As we mentioned earlier, after obtaining the single column of L \u22121 X using CG, one has to perform |Y \\ X| vector inner products in (3), but it is much cheaper than |Y \\X| CG runs requiring matrix-vector multiplications.\nPartitioning. In order to further improve the quality of first-order approximation (3), we partition Y \\X into p distinct subsets so that\n\u2016LX\u222a{i} \u2212 LX\u2016F \u2016LX\u222a{i} \u2212 L (j) X \u2016F ,\nwhere an element i is in the partition j \u2208 [p], L(j)X is the average of LX\u222a{i} for i in the partition j, and \u2016\u00b7\u2016F is the Frobenius norm. Since LX\u222a{i} becomes closer to the average L (j)\nX , one can expect that the first-order approximation quality in (3) is improved. But, we now need a more expensive procedure to approximate the marginal gain:\nlog detLX\u222a{i} \u2212 log detLX = ( log detLX\u222a{i} \u2212 log detL (j) X ) + ( log detL (j) X \u2212 log detLX )\n\u2248 \u2329( L (j)\nX )\u22121 , LX\u222a{i} \u2212 L (j) X \u232a \ufe38 \ufe37\ufe37 \ufe38\n(a)\n+ ( log detL (j) X \u2212 log detLX )\n\ufe38 \ufe37\ufe37 \ufe38 (b) .\nThe first term (a) can be computed efficiently as we explained earlier, but we have to run CG p times for computing single columns of L (1)\nX , . . . , L (p)\nX . The second term (b) can be also computed using CG similarly to (2) under the Schur complement. Hence, one has to run CG 2p times in total. If p is\n1 \u2207X log detX = ( X\u22121 )>\nlarge, the overall complexity becomes larger, but the approximation quality improves as well. We also note that one can try various clustering algorithms, e.g., k-means or Gaussian mixture. Instead, we use a simple random partitioning scheme because it is not only the fastest method but it also works well in our experiments."}, {"heading": "3.2 Algorithm Description and Guarantee", "text": "The formal description of the proposed algorithm is described in Algorithm 1.\nAlgorithm 1 Faster Greedy DPP Inference\n1: Input: kernel matrix L \u2208 Rd\u00d7d and number of partitions p 2: Initialize: X \u2190 \u2205 3: while Y \\X 6= \u2205 do 4: Partition Y \\X randomly into p subsets. 5: for j = 1 to p do 6: L (j)\nX \u2190 average of LX\u222a{i} for i in the partition j 7: z(j) \u2190 (|X|+ 1)-th column of ( L (j)\nX )\u22121 8: \u03b4j \u2190 log detL (j)\nX \u2212 log detLX 9: end for\n10: for i \u2208 Y \\X do 11: \u2206i \u2190 \u2329 LX\u222a{i} \u2212 L (j) X , Mat ( z(j) )\u232a 2 + \u03b4j where element i is included in partition j. 12: end for 13: imax \u2190 argmaxi\u2208Y\\X \u2206i 14: if log detLX\u222a{imax} \u2212 log detLX < 0 then 15: return X 16: end if 17: X \u2190 X \u222a {imax} 18: end while\nAs we explained in Section 3.1, the lines 7, 8 require to run CG. Hence, the overall complexity becomes \u0398(T 3GR \u00b7 TCG \u00b7 p + d \u00b7 T 2GR) = \u0398(T 3GR + d \u00b7 T 2GR), where we choose p, TCG = O(1), TGR is the number of greedy updates on the current set X and TCG is the number of iterations of each CG run. For example, if TGR = \u2126(d), it is simply \u0398(d3). It is much better than the complexity \u0398(d4) of the na\u0131\u0308ve implementations described in Section 2.3. In particular, if kernel matrix L is sparse, i.e., number of non-zeros of each column/row is O(1), ours has the complexity \u0398(T 2GR + d \u00b7 TGR) while the na\u0131\u0308ve approaches are still worse having the complexity \u0398(d \u00b7 T 2GR).\nWe also provide the following approximation guarantee of Algorithm 1 for the monotone case. Theorem 1. Suppose the smallest eigenvalue of L is greater than 1. Theh, it holds that\nlog detLX \u2265 (1\u2212 1/e) max Z\u2286Y,|Z|=|X| log detLZ \u2212 2|X|\u03b5.\n2For Z \u2208 Rd\u00d7k , Mat(Z) \u2208 Rd\u00d7d is defined whose the last k columns and rows are equal to Z and Z>, respectively, and other entries set to 0.\nwhere\n\u03b5 = max X\u2286Y,i\u2208Y\\X\nj\u2208[p]\n\u2223\u2223\u2223\u2223\u2223log detLX\u222a{i}detL(j)X \u2212 \u2329( L (j) X )\u22121 , LX\u222a{i} \u2212 L (j) X \u232a\u2223\u2223\u2223\u2223\u2223 and X is the output of Algorithm 1.\nThe above theorem captures the relation between the first-order approximation error \u03b5 in (3) and the worst-case approximation ratio of the algorithm."}, {"heading": "4 Faster Batch-Greedy DPP Inference", "text": "In this section, we present an even faster greedy algorithm for the MAP inference task of DPP, in particular for large-scale tasks. On top of ideas described in Section 3.1, we use a batch strategy, i.e., add k elements instead of a single element to the current set, where LDAS in Section 2.3 is now used as a key component. The batch strategy accelerates our algorithm. We first provide the formal description of the batch greedy algorithm in Section 4.1. In Section 4.2, we describe additional ideas on applying LDAS as a subroutine of the proposed batch algorithm."}, {"heading": "4.1 Algorithm Description", "text": "Algorithm 2 Faster Batch-Greedy DPP Inference\n1: Input: kernel matrix L \u2208 Rd\u00d7d, number of partitions p, batch size k and the number of batch samples s 2: Initialize: X \u2190 \u2205 3: while Y \\X is not empty do 4: Ii \u2190 Randomly draw a batch of size k for i \u2208 [s]. 5: Partition [s] randomly into p subsets. 6: for j = 1 to p do 7: L (j)\nX \u2190 average of LX\u222aIi for i in the partition j 8: Z(j) \u2190 (|X|+ 1) to (|X|+ k)-th columns of ( L (j)\nX )\u22121 9: \u03b4j \u2190 log detL (j)\nX using LDAS. 10: end for 11: for i = 1 to s do 12: \u2206Batchi \u2190 \u2329 LX\u222aIi \u2212 L (j) X , Mat ( Z(j) )\u232a 2 + \u03b4j\nwhere a batch index i is included in j-th partition. 13: end for 14: imax \u2190 argmaxi\u2208[s] \u2206Batchi 15: if log detLX\u222aIimax \u2212 log detLX < 0 then 16: return X 17: end if 18: X \u2190 X \u222a Iimax 19: end while\nThe formal description of the proposed algorithm is described in Algorithm 2. Similar to the line 7 in Algorithm 1, the line 8 of Algorithm 2 can be solved by the CG algorithms. However, in the line 9 of Algorithm 2, we use LDAS and be reminded that it runs in \u0398(d2) time. In addition, the line 12 requires the vector inner products k \u00b7 s times. Thus, the total complexity becomes \u0398 ( T 3GR \u00b7 ( TCG + mn k ) \u00b7 p+ s \u00b7 T 2GR ) = \u0398(T 3GR) where TGR is the number of greedy updates on the current set X and we choose all parameters p, TCG, k, s,m, n = O(1). We note that Algorithm 2 is expected to perform faster than Algorithm 1 when TGR, d are large. This is primarily because the size of the current set X increases by k > 1 for each greedy iteration. A larger choice of k speeds up the algorithm up to k times, but it might hurt its output quality. We explain more details of key components of the batch algorithm below.\nBatch selection. The essence of Algorithm 2 is adding k > 1 elements, called batch, simultaneously to the current set with an improved marginal gain. Formally, it starts from the empty set and recursively updates X \u2190 X \u222a Imax for\nImax = argmax I\u2286Y\\X,|I|=k log detLX\u222aI . (4)\nuntil no gain is attained. The non-batch greedy procedure (1) corresponds to k = 1. Such batch greedy algorithms have been also studied for submodular maximization [28, 12] and recently, [23] studied their theoretical guarantees showing that they can be better than their non-batch counterparts under some conditions. The main drawback of the standard batch greedy algorithms is that finding the optimal batch of size k requires computing too many marginal gains of (|Y\\X| k ) subsets.\nTo address the issue, we sample s (|Y\\X|\nk\n) bunches of batch subsets randomly and compute\napproximate batch marginal gains using them. [27] first propose an uniformly random sampling to the standard non-batch greedy algorithm. The authors show that it guarantees (1 \u2212 1/e \u2212 O(e\u2212s)) approximation ratio in expectation and report that it performs well in many applications. In our experiments, we choose s = 500 batch samples.\nHigh-order approximation of log-determinant. Recall that for Algorithm 1, we suggest using the CG algorithm under the Schur complement for computing\nlog detL (j)\nX \u2212 log detLX . (5)\nOne can apply the same strategy for Algorithm 2, which requires running the CG algorithm k times for (5). Instead, we suggest running LDAS (using polynomial/high-order approximations of the scalar log function) only once, i.e., the line 9, which is much faster if k is large. We remind that the asymptotic complexities of both CG and LDAS are the same as \u0398(d2)."}, {"heading": "4.2 Sharing Randomness in Trace Estimators", "text": "To improve the approximation quality of Algorithm 2, we further suggest running LDAS using the same random vectors v(1), . . . ,v(m) across j \u2208 [p]. This is because we are interested in relative values log detL (j)\nX for j \u2208 [p] instead of their absolute ones. Our intuition is that different random vectors have different bias, which hurt the comparison task. Figure 1 demonstrates an experiment on the estimation of log detL (j)\nX when random vectors are shared and independent, respectively. This implies that sharing random vectors might be worse for estimating the absolute values of logdeterminants, but better for comparing them.\nWe also formally justify the idea of sharing random vectors as stated in the follows theorem.\nTheorem 2. Suppose A,B are positive definite matrices whose eigenvalues are in [\u03b4, 1\u2212 \u03b4] for \u03b4 > 0. Let \u0393A,\u0393B be the estimations of log detA, log detB by LDAS using the same random vectors v(1), . . . ,v(m) for both. Then, it holds that\nVar [\u0393A \u2212 \u0393B ] \u2264 32M2\u03c12 (\u03c1+ 1)\n2\nm (\u03c1\u2212 1)6 (1\u2212 2\u03b4)2 \u2016A\u2212B\u20162F\nwhere M = 5 log (2/\u03b4) and \u03c1 = 1 + 2\u221a 2/\u03b4\u22121\u22121 .\nWithout sharing random vectors, the variance should grow linearly with respect to \u2016A\u20162F + \u2016B\u2016 2 F . In our case, matrices A and B correspond to some of L (j)\nX , and \u2016A \u2212 B\u20162F is significantly smaller than \u2016A\u20162F + \u2016B\u2016 2 F . We believe that our idea of sharing randomness might be of broader interest in many applications of LDAS or its variants, requiring multiple log-determinant computations."}, {"heading": "5 Experimental Results", "text": "In this section, we evaluate our proposed algorithms for the MAP inference on synthetic and realworld DPP instances.\nSetups. The experiments are performed using a machine with a hexa-core Intel CPU (Core i75930K, 3.5 GHz) and 32 GB RAM. We compare our algorithms with following competitors: the standard greedy algorithm (GREEDY) [28], stochastic greedy algorithm (STOCH) [27], double greedy algorithm (DOUBLE) [4] and softmax extension (SOFTMAX) [8].3 We implement GREEDY using DPP marginalization requiring matrix inversion [19], which is a bit faster (preserving the same accuracy) than its na\u0131\u0308ive implementation described in Section 2.3. We use 100 samples in STOCH, regardless of matrix dimension, where a larger number of samples makes it more accurate, but slower. Unless stated otherwise, we choose parameters of p = 10, k = 10, s = 500, TCG = 30, m = 30 and n = 20, regardless matrix dimension, for our algorithms.\nAdditional tricks for boosting accuracy. For boosting approximation qualities of our algorithms, we use the simple trick in our experiments: recompute top ` marginal gains exactly (using CG)\n3We also run the accelerated greedy algorithm [26] for general submodular maximization, but do not report its performance since its approximation quality is extremely bad for the DPP case.\nwhere they are selected based on estimated marginal gains, i.e., \u2206i for Algorithm 1 and \u2206Batchi for Algorithm 2. Then, our algorithms choose the best element among ` candidates, based on their exact marginal gains. Since we choose small ` = 20 in our experiments, this additional process increases the running times of our algorithms marginally, but makes them more accurate. In fact, the trick is inspired by [26] where the authors also recompute the exact marginal gain of a single element. In addition, for boosting further approximation qualities of Algorithm 2, we also run Algorithm 1 in parallel and choose the largest one among {\u2206i,\u2206Batchi } given the current set. Hence, at most iterations, the batch with the maximal \u2206Batchi is chosen and increases the current set size by k (i.e., making speed-up) as like Algorithm 2, and the non-batch with the maximal \u2206i is chosen at very last iterations, which fine-tunes the solution quality. We still call the synthesized algorithm by Algorithm 2 in this section.\nPerformance metrics. For the performance measure on approximation qualities of algorithms, we use the following ratio of log-probabilities:\nlog detLX/log detLXGREEDY .\nwhere X and XGREEDY are the outputs of an algorithm and GREEDY, respectively. Namely, we compare outputs of algorithms with that of GREEDY since the exact optimum is hard to compute. Similarly, we report the running time speedup of each algorithm over GREEDY."}, {"heading": "5.1 Synthetic Dataset", "text": "In this section, we use synthetic DPP datasets generated as follows. As [18, 19] proposed, a kernel matrix L for DPP can be re-parameterized as\nLi,j = qi\u03c6 > i \u03c6jqj ,\nwhere qi \u2208 R+ is considered as the quality of item i and \u03c6i \u2208 Rd is the normalized feature vector of item i so that \u03c6>i \u03c6j measures the similarity between i and j. We use qi = exp (\u03b2xi) for the quality measurement xi \u2208 R and choose \u03b2 = 0.1. We choose each entry of \u03c6i and xi drawn from the normal distribution N (0, 1) for all i \u2208 [d], and then normalize \u03c6i so that \u2016\u03c6i\u20162 = 1.\nWe first show how much the number of clusters p and the batch size k are sensitive for Algorithm 1 and Algorithm 2, respectively. Figure 3(a) shows the accuracy of Algorithm 1 with different numbers of clusters. It indeed confirms that a larger cluster improves its accuracy since it makes first-order approximations tighter. Figure 3(b) shows the performance trend of Algorithm 2 as the batch size k increases, which shows that a larger batch might hurt its accuracy. Based on these experiments, we choose p = k = 10 in order to target 0.01 approximation ratio loss compared to GREEDY.\nWe generate synthetic kernel matrices with varying dimension d up to 5, 000, and the performances of tested algorithms are reported in Figure 2(a). One can observe that GREEDY seems to be nearoptimal, where only SOFTMAX often provides marginally larger log-probabilities than GREEDY under small dimensions. Interestingly, we found that DOUBLE has the strong theoretical guarantee for general submodular maximization [4], but its practical performance for DPP is bad. It is faster than GREEDY, but much slower than ours. STOCH is the fastest one among our competitors, but ours outperform it with respect to running time given accuracy. In overall, our algorithms are at orders of magnitude faster than GREEDY, STOCH and SOFTMAX, while loosing 0.01-approximation ratio. For example, Algorithm 2 is 140 times faster than GREEDY for d = 5, 000, and the gap should increase for larger dimension d."}, {"heading": "5.2 Real Dataset", "text": "We use real-world datasets of the following two tasks of matched and video summarizations.\nMatched summarization. We evaluate our proposed algorithms for matched summarization that is first proposed by [8]. This task gives useful information for comparing the texts addressed at different times by the same speaker. Suppose we have two different documents and each one consists of several statements. The goal is to apply DPP for finding statement pairs that are similar to each other, while they summarize (i.e., diverse) well the two documents. We use transcripts of debates in 2016 US Republican party presidential primaries speeched by following 8 participates: Bush, Carson, Christie, Kasich, Paul, Trump, Cruz and Rubio.4\nWe follow similar pre-processing steps of [8]. First, every sentence is parsed and only nouns except the stopwords are extracted via NLTK [2]. Then, we remove the \u2018rare\u2019 words occurring less than 10% of the whole debates, and then ignore each statement which contains more \u2018rare\u2019 words than \u2019frequent\u2019 ones in it. This gives us a dataset containing 3, 406 distinct \u2018frequent\u2019 words and 1, 157 statements. For each statement pair (i, j), feature vector \u03c6(i,j) = wi + wj \u2208 R3406 where wi is generated as a frequency of words in the statement i. Then, we normalize \u03c6(i,j). The match quality x(i,j) is measured as the cosine similarity between two statements i and j, i.e., x(i,j) = w>i wj , and we remove statement pairs (i, j) such that its match quailty x(i,j) is smaller than 15% of the maximum one. Finally, by choosing q(i,j) = exp ( 0.1 \u00b7 x(i,j) ) , we obtain ( 8 2 ) = 28 kernel matrices of dimension d from 516 to 4, 000.\nFigure 4 reports log-probability ratios and speedups of Algorithm 2 under the 28 kernels. We observe that Algorithm 2 looses 0.01-approximation ratio on average, compared to GREEDY, under the real-world kernels. Interestingly, SOFTMAX runs much slower than even GREEDY, while our algorithm runs significantly faster than GREEDY for large dimension, e.g., 147 times faster for d = 4, 000 corresponding to transcripts of Bush and Rubio.\nVideo summarization. We evaluate our proposed algorithms video summarization. We use 39 videos from a Youtube dataset [6], and the trained DPP kernels from [9]. Under the kernels, we found that the numbers of selected elements from algorithms are typically small (less than 10), and\n4Details of the primaries are provided in http://www.presidency.ucsb.edu/debates.php.\nhence we use Algorithm 1 instead of its batch version Algorithm 2. For performance evaluation, we use an F-score based on five sets of user summaries where it measures the quality across two summaries.\nFigure 5(a) illustrates F-score for GREEDY and Algorithm 1 and Figure 5(b) reports its speedup. Our algorithm achieves over 30 times speedup in this case, while it produces F-scores that are very similar to those of GREEDY. For some video, it achieves even better F-score, as illustrated in 5(c)."}, {"heading": "6 Conclusion", "text": "We have presented fast algorithms for the MAP inference task of large-scale DPPs. Our main idea is to amortize common determinant computations via linear algebraic techniques and recent logdeterminant approximation methods. Although we primarily focus on a special matrix optimization, we expect that several ideas developed in this paper would be useful for other related matrix computational problems, in particular, involving multiple determinant computations."}, {"heading": "A Proof of Theorem 1", "text": "For given X \u2286 Y , we denote that the true marginal gain \u039bi and the approximated gain \u2206i (used in Algorithm 1) as\n\u039bi := log detLX\u222a{i} \u2212 log detLX\n\u2206i :=\n\u2329( L (j)\nX )\u22121 , LX\u222a{i} \u2212 L (j) X \u232a + ( log detL (j) X \u2212 log detLX )\nwhere an item i \u2208 Y \\ X is in the partition j. We also use iOPT = argmaxi \u039bi and imax = argmaxi \u2206i. Then, we have\n\u039bimax\u2265\u2206imax \u2212 \u03b5 \u2265\u2206iOPT \u2212 \u03b5 \u2265 \u039biOPT \u2212 2\u03b5\nwhere the first and third inequalities are from the definition of \u03b5, i.e., |\u039bi \u2212\u2206i| \u2264 \u03b5, and the second inequality holds by the optimality of imax. In addition, when the smallest eigenvalue of L is greater than 1, log detLX is monotone and non-negative [33]. To complete the proof, we introduce following approximation guarantee of the greedy algorithm with a \u2018noise\u2019 during the selection [34]. Theorem. (Noisy greedy algorithm) Suppose a submodular function f defined on ground set Y is monotone and non-negative. Let X0 = \u2205 and Xk = Xk\u22121 \u222a {imax} such that\nf(Xk\u22121 \u222a {imax})\u2212 f(Xk\u22121) \u2265 max i\u2208Y\\Xk\u22121 (f(Xk\u22121 \u222a {i})\u2212 f(Xk\u22121))\u2212 \u03b5k\nfor some \u03b5k \u2265 0. Then,\nf(Xk) \u2265 (1\u2212 1/e) max X\u2286Y,|X|\u2264k f(X)\u2212 k\u2211 i=1 \u03b5i\nTheorem 1 is straightforward by substituting 2\u03b5 into \u03b5k. This completes the proof of Theorem 1."}, {"heading": "B Proof of Theorem 2", "text": "As we explained in Section 2.3, Chebyshev expansion of log x in [\u03b4, 1\u2212 \u03b4] with degree n is defined as pn (x). This can be written as\npn (x) = n\u2211 k=0 ckTk ( 2 1\u2212 2\u03b4 x\u2212 1 1\u2212 2\u03b4 ) (6)\nwhere the coefficient ck and the k-th Chebyshev polynomial Tk(x) are defined as\nck =  1 n+ 1 n\u2211 j=0 f ( 1\u2212 2\u03b4 2 xj + 1 2 ) T0(xj) if k = 0 2\nn+ 1 n\u2211 j=0 f ( 1\u2212 2\u03b4 2 xj + 1 2 ) Tk(xj) otherwise\n(7) Tk+1(x) = 2xTk(x)\u2212 Tk\u22121(x) for k \u2265 1 (8)\nwhere xj = cos ( \u03c0(j+1/2) n+1 ) for j = 0, 1, . . . , n and T0(x) = 1, T1(x) = x [25]. For simplicity, we now use H := pn (A) \u2212 pn (B) and denote A\u0303 = 21\u22122\u03b4A \u2212 1\n1\u22122\u03b4 I where I is identity matrix with same dimension of A and same for B\u0303.\nWe estimate the log-determinant difference while random vectors are shared, i.e.,\nlog detA\u2212 log detB \u2248 1 m m\u2211 i=1 v(i)>Hv(i).\nTo show that the variance of v(i)>Hv(i) is small as \u2016A\u2212B\u2016F , we provide that\nVar\n[ 1\nm m\u2211 i=1 v(i)>Hv(i)\n] = 1\nm Var\n[ v>Hv ] \u2264 2 m \u2016H\u20162F = 2 m \u2016pn (A)\u2212 pn (B)\u20162F\n\u2264 2 m ( n\u2211 k=0 |ck| \u2225\u2225\u2225Tk (A\u0303)\u2212 Tk (B\u0303)\u2225\u2225\u2225 F )2 where the first inequality holds from [1] and the second is from combining (6) with the triangle inequality. To complete the proof, we use following two lemmas. Lemma 3. Let Tk (\u00b7) be Chebyshev polynomial with k-degree and symmetric matricesB,E satisfied with \u2016B\u20162 \u2264 1, \u2016B + E\u20162 \u2264 1. Then, for k \u2265 0,\n\u2016Tk (B + E)\u2212 Tk (B)\u2016F \u2264 k 2 \u2016E\u2016F .\nLemma 4. Let ck be the k-th coefficient of Chebyshev expansion for f (x). Suppose f is analytic with |f (z)| \u2264 M in the region bounded by the ellipse with foci \u00b11 and the length of major and minor semiaxis summing to \u03c1 > 1. Then,\nn\u2211 k=0 k2 |ck| \u2264 2M\u03c1 (\u03c1+ 1) (\u03c1\u2212 1)3 .\nIn order to apply Lemma 4, we should consider f(x) = log ( 1\u22122\u03b4\n2 x+ 1 2\n) . Then it can be easily\nobtained M = 5 log (2/\u03b4) and \u03c1 = 1 + 2\u221a 2/\u03b4\u22121\u22121 as provided in [11].\nUsing Lemma 3 and 4, we can write\nVar\n[ 1\nm m\u2211 i=1 v(i)>Hv(i) ] \u2264 2 m ( n\u2211 k=0 |ck| \u2225\u2225\u2225Tk (A\u0303)\u2212 Tk (B\u0303)\u2225\u2225\u2225 F )2\n\u2264 2 m ( n\u2211 k=0 |ck| k2 \u2225\u2225\u2225A\u0303\u2212 B\u0303\u2225\u2225\u2225 F )2\n\u2264 2 m\n( 2M\u03c1 (\u03c1+ 1)\n(\u03c1\u2212 1)3\n)2( 2\n1\u2212 2\u03b4 \u2016A\u2212B\u2016F )2 = 32M2\u03c12 (\u03c1+ 1) 2\nm (\u03c1\u2212 1)6 (1\u2212 2\u03b4)2 \u2016A\u2212B\u20162F\nwhere the second inequality holds from Lemma 3 and the thrid is from Lemma 4. This completes the proof of Theorem 2.\nB.1 Proof of Lemma 3\nDenote Rk := Tk (B + E) \u2212 Tk (B). From the recurrence of Chebyshev polynomial (8), Rk has following\nRk+1 = 2 (B + E)Rk \u2212Rk\u22121 + 2E Tk (B) (9)\nfor k \u2265 1 where R1 = E, R0 = 0 where 0 is defined as zero matrix with the same dimension of B. Solving this, we obtain that\nRk+1 = gk+1 (B + E)E + k\u2211 i=0 hi (B + E)E Tk+1\u2212i (B) (10)\nfor k \u2265 1 where both gk (\u00b7) and hk (\u00b7) are polynomials with degree k and they have following recurrences\ngk+1 (x) = 2xgk (x)\u2212 gk\u22121 (x) , g1 (x) = 1, g0 (x) = 0, hk+1 (x) = 2xhk (x)\u2212 hk\u22121 (x) , h1 (x) = 2, h0 (x) = 0.\nIn addition, we can easily verify that\n2 max x\u2208[\u22121,1] |gk (x)| = max x\u2208[\u22121,1] |hk (x)| = 2k.\nPutting all together, we conclude that\n\u2016Rk+1\u2016F \u2264 \u2016gk+1 (B + E)E\u2016F + \u2225\u2225\u2225\u2225\u2225 k\u2211 i=0 hi (B + E)E Tk+1\u2212i (B) \u2225\u2225\u2225\u2225\u2225 F\n\u2264 \u2016gk+1 (B + E)\u20162 \u2016E\u2016F + k\u2211 i=0 \u2016hi (B + E)\u20162 \u2016E\u2016F \u2016 Tk+1\u2212i (B)\u20162\n\u2264 ( \u2016gk+1 (B + E)\u20162 + k\u2211 i=0 \u2016hi (B + E)\u20162 ) \u2016E\u2016F\n\u2264 ( k + 1 +\nk\u2211 i=0 2i ) \u2016E\u2016F\n= (k + 1) 2 \u2016E\u2016F\nwhere the second inequality holds from \u2016Y X\u2016F = \u2016XY \u2016F \u2264 \u2016X\u20162 \u2016Y \u2016F for matrix X,Y and the third inequality uses that |Tk (x)| \u2264 1 for all k \u2265 0. This completes the proof of Lemma 3.\nB.2 Proof of Lemma 4\nFor general analytic function f , Chebyshev series of f is defined as\nf (x) = a0 2 + \u221e\u2211 k=1 akTk (x) , ak = 2 \u03c0 \u222b 1 \u22121 f (x)Tk (x)\u221a 1\u2212 x2 dx.\nand from [25] it is known that\nck \u2212 ak = \u221e\u2211 j=1 (\u22121)j ( a2j(n+1)\u2212k + a2j(n+1)+k ) and |ak| \u2264 2M\u03c1k for 0 \u2264 k \u2264 n. We remind that ck is defined in (7). Using this facts, we get\nk2 |ck| \u2264 k2 |ak|+ \u221e\u2211\nj=1\n\u2223\u2223a2j(n+1)\u2212k\u2223\u2223+ \u2223\u2223a2j(n+1)+k\u2223\u2223 \n\u2264 k2 |ak|+ \u221e\u2211 j=1 k2 \u2223\u2223a2j(n+1)\u2212k\u2223\u2223+ k2 \u2223\u2223a2j(n+1)+k\u2223\u2223\n\u2264 k2 |ak|+ \u221e\u2211 j=1 (2j(n+ 1)\u2212 k)2 \u2223\u2223a2j(n+1)\u2212k\u2223\u2223+ (2j(n+ 1) + k)2 \u2223\u2223a2j(n+1)+k\u2223\u2223\nTherefore, we have n\u2211 k=0 k2 |ck| \u2264 n\u2211 k=0 k2 |ak|+ \u221e\u2211 k=n+1 k2 |ak|\n\u2264 \u221e\u2211 k=0 k2 |ak| \u2264 \u221e\u2211 k=0 k2 2M \u03c1k = 2M\u03c1 (\u03c1+ 1) (\u03c1\u2212 1)3\nThis completes the proof of Lemma 4."}], "references": [{"title": "Randomized algorithms for estimating the trace of an implicit symmetric positive semi-definite matrix", "author": ["H. Avron", "S. Toledo"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "Nltk: the natural language toolkit", "author": ["S. Bird"], "venue": "In Proceedings of the COLING/ACL on Interactive presentation sessions,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2006}, {"title": "A randomized algorithm for approximating the log determinant of a symmetric positive definite matrix. arXiv preprint arXiv:1503.00374", "author": ["C. Boutsidis", "P. Drineas", "P. Kambadur", "A. Zouzias"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2015}, {"title": "A tight linear time (1/2)approximation for unconstrained submodular maximization", "author": ["N. Buchbinder", "M. Feldman", "J. Seffi", "R. Schwartz"], "venue": "SIAM Journal on Computing,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2015}, {"title": "An introduction to the theory of point processes: volume II: general theory and structure", "author": ["D.J. Daley", "D. Vere-Jones"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "Vsumm: A mechanism designed to produce static video summaries and a novel evaluation method", "author": ["S.E.F. De Avila", "A.P.B. Lopes", "A. da Luz", "A. de Albuquerque Ara\u00fajo"], "venue": "Pattern Recognition Letters,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Maximizing non-monotone submodular functions", "author": ["U. Feige", "V.S. Mirrokni", "J. Vondrak"], "venue": "SIAM Journal on Computing,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Near-optimal map inference for determinantal point processes", "author": ["J. Gillenwater", "A. Kulesza", "B. Taskar"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "Diverse sequential subset selection for supervised video summarization", "author": ["B. Gong", "Chao", "W.-L", "K. Grauman", "F. Sha"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "Iterative methods for solving linear systems", "author": ["A. Greenbaum"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1997}, {"title": "Large-scale log-determinant computation through stochastic chebyshev expansions", "author": ["I. Han", "D. Malioutov", "J. Shin"], "venue": "In ICML,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2015}, {"title": "Worst case analysis of greedy type algorithms for independence systems", "author": ["D. Hausmann", "B. Korte", "T. Jenkyns"], "venue": "In Combinatorial Optimization,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1980}, {"title": "A stochastic estimator of the trace of the influence matrix for laplacian smoothing splines", "author": ["M.F. Hutchinson"], "venue": "Communications in Statistics-Simulation and Computation,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1990}, {"title": "Learning in graphical models, volume 89", "author": ["M.I. Jordan"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1998}, {"title": "Fast determinantal point process sampling with application to clustering", "author": ["B. Kang"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "On sampling and greedy map inference of constrained determinantal point processes", "author": ["T. Kathuria", "A. Deshpande"], "venue": "arXiv preprint arXiv:1607.01551", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2016}, {"title": "Near-optimal sensor placements in gaussian processes: Theory, efficient algorithms and empirical studies", "author": ["A. Krause", "A. Singh", "C. Guestrin"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Learning determinantal point processes", "author": ["A. Kulesza", "B. Taskar"], "venue": "Proceedings of UAI. Citeseer", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2011}, {"title": "Determinantal point processes for machine learning", "author": ["A. Kulesza", "B Taskar"], "venue": "Foundations and Trends R  \u00a9 in Machine Learning,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "Fast greedy algorithms in mapreduce and streaming", "author": ["R. Kumar", "B. Moseley", "S. Vassilvitskii", "A. Vattani"], "venue": "ACM Transactions on Parallel Computing,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2015}, {"title": "Efficient sampling for k-determinantal point processes", "author": ["C. Li", "S. Jegelka", "S. Sra"], "venue": "In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2016}, {"title": "Gaussian quadrature for matrix inverse forms with applications", "author": ["C. Li", "S. Sra", "S. Jegelka"], "venue": "In Proceedings of The 33rd International Conference on Machine Learning,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2016}, {"title": "Performance bounds for the kbatch greedy strategy in optimization problems with curvature", "author": ["Y. Liu", "Z. Zhang", "E.K. Chong", "A. Pezeshki"], "venue": "In American Control Conference (ACC),", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2016}, {"title": "The coincidence approach to stochastic point processes", "author": ["O. Macchi"], "venue": "Advances in Applied Probability,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1975}, {"title": "Accelerated greedy algorithms for maximizing submodular set functions", "author": ["M. Minoux"], "venue": "In Optimization Techniques,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1978}, {"title": "Lazier than lazy greedy", "author": ["B. Mirzasoleiman", "A. Badanidiyuru", "A. Karbasi", "J. Vondr\u00e1k", "A. Krause"], "venue": "arXiv preprint arXiv:1409.7938", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2014}, {"title": "An analysis of approximations for maximizing submodular set functionsi", "author": ["G.L. Nemhauser", "L.A. Wolsey", "M.L. Fisher"], "venue": "Mathematical Programming,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1978}, {"title": "Schur complements and statistics", "author": ["D.V. Ouellette"], "venue": "Linear Algebra and its Applications,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1981}, {"title": "Parallel double greedy submodular maximization", "author": ["X. Pan", "S. Jegelka", "J.E. Gonzalez", "J.K. Bradley", "M.I. Jordan"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2014}, {"title": "Large-scale log-determinant computation via weighted l 2 polynomial approximation with prior distribution of eigenvalues", "author": ["W. Peng", "H. Wang"], "venue": "In International Conference on High Performance Computing and Applications,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2015}, {"title": "Iterative methods for sparse linear systems", "author": ["Y. Saad"], "venue": null, "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2003}, {"title": "On greedy maximization of entropy", "author": ["D. Sharma", "A. Kapoor", "A. Deshpande"], "venue": "In ICML, pages 1330\u20131338", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2015}, {"title": "An online algorithm for maximizing submodular functions", "author": ["M. Streeter", "D. Golovin"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2009}, {"title": "Tweet timeline generation with determinantal point processes", "author": ["Yao", "J.-g", "F. Fan", "W.X. Zhao", "X. Wan", "E. Chang", "J. Xiao"], "venue": "In Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2016}], "referenceMentions": [{"referenceID": 23, "context": "Determinantal point processes (DPPs) are elegant probabilistic models, first introduced by [24], who called them \u2018fermion processes\u2019.", "startOffset": 91, "endOffset": 95}, {"referenceID": 4, "context": "Since then, DPPs have been extensively studied in the fields of quantum physics and random matrices, giving rise to a beautiful theory [5].", "startOffset": 135, "endOffset": 138}, {"referenceID": 8, "context": "Recently, they have been applied in many machine learning tasks such as summarization [9], human pose detection [19], clustering [15] and tweet time-line generation [35].", "startOffset": 86, "endOffset": 89}, {"referenceID": 18, "context": "Recently, they have been applied in many machine learning tasks such as summarization [9], human pose detection [19], clustering [15] and tweet time-line generation [35].", "startOffset": 112, "endOffset": 116}, {"referenceID": 14, "context": "Recently, they have been applied in many machine learning tasks such as summarization [9], human pose detection [19], clustering [15] and tweet time-line generation [35].", "startOffset": 129, "endOffset": 133}, {"referenceID": 33, "context": "Recently, they have been applied in many machine learning tasks such as summarization [9], human pose detection [19], clustering [15] and tweet time-line generation [35].", "startOffset": 165, "endOffset": 169}, {"referenceID": 14, "context": "For example, conditioning, sampling [15] and marginalization of DPPs admit polynomialtime/efficient algorithms, while those on popular graphical models [14] do not, i.", "startOffset": 36, "endOffset": 40}, {"referenceID": 13, "context": "For example, conditioning, sampling [15] and marginalization of DPPs admit polynomialtime/efficient algorithms, while those on popular graphical models [14] do not, i.", "startOffset": 152, "endOffset": 156}, {"referenceID": 18, "context": "One exception is the MAP inference (finding the most likely configuration), which is our main interest; this is known to be NP-hard even for DPPs [19].", "startOffset": 146, "endOffset": 150}, {"referenceID": 16, "context": "Furthermore, it has been often empirically observed that greedy algorithms provide near optimal solutions [17].", "startOffset": 106, "endOffset": 110}, {"referenceID": 18, "context": "Hence, greedy algorithms have been also applied for the DPP task [19, 35, 36].", "startOffset": 65, "endOffset": 77}, {"referenceID": 33, "context": "Hence, greedy algorithms have been also applied for the DPP task [19, 35, 36].", "startOffset": 65, "endOffset": 77}, {"referenceID": 18, "context": "Known implementations of greedy selection on DPP require computation of log-determinants, matrix inversions [19] or solving linear systems [22].", "startOffset": 108, "endOffset": 112}, {"referenceID": 21, "context": "Known implementations of greedy selection on DPP require computation of log-determinants, matrix inversions [19] or solving linear systems [22].", "startOffset": 139, "endOffset": 143}, {"referenceID": 30, "context": "We choose the popular conjugate gradient descent (CG) [32] as a linear solver.", "startOffset": 54, "endOffset": 58}, {"referenceID": 10, "context": "Now, we suggest running the recent fast log-determinant approximation scheme (LDAS) [11] p times, instead of running CG pk times under the Schur complement, where LDAS utilizes high-order, i.", "startOffset": 84, "endOffset": 88}, {"referenceID": 24, "context": "An accelerated greedy algorithm was first proposed by [26] which", "startOffset": 54, "endOffset": 58}, {"referenceID": 25, "context": "Its worst-case approximation guarantee was also studied [27], under the standard, non-batch, greedy algorithm.", "startOffset": 56, "endOffset": 60}, {"referenceID": 3, "context": "Recently, [4] proposed a \u2018one-pass\u2019 greedy algorithm where each greedy selection requires computing only a single marginal gain, i.", "startOffset": 10, "endOffset": 13}, {"referenceID": 28, "context": "There have been also several efforts to design parallel/distributed implementations of greedy algorithms: [30] use parallel strategies for the above one-pass greedy algorithm and [20] adapt a MapReduce paradigm for implementing greedy algorithms in distributed settings.", "startOffset": 106, "endOffset": 110}, {"referenceID": 19, "context": "There have been also several efforts to design parallel/distributed implementations of greedy algorithms: [30] use parallel strategies for the above one-pass greedy algorithm and [20] adapt a MapReduce paradigm for implementing greedy algorithms in distributed settings.", "startOffset": 179, "endOffset": 183}, {"referenceID": 7, "context": "Finally, we remark that a non-greedy algorithm was studied in [8] for better MAP qualities of DPP, but it is much slower than ours as reported in Section 5.", "startOffset": 62, "endOffset": 65}, {"referenceID": 8, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 118, "endOffset": 128}, {"referenceID": 7, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 118, "endOffset": 128}, {"referenceID": 33, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 118, "endOffset": 128}, {"referenceID": 15, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 139, "endOffset": 151}, {"referenceID": 14, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 139, "endOffset": 151}, {"referenceID": 20, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 139, "endOffset": 151}, {"referenceID": 8, "context": "Under the distribution, several probabilistic inference tasks are required for real-world applications, including MAP [9, 8, 35], sampling [16, 15, 21], marginalization and conditioning [9].", "startOffset": 186, "endOffset": 189}, {"referenceID": 18, "context": "Unlike other inference tasks on DPP, it is known that MAP is a NP-hard problem [19].", "startOffset": 79, "endOffset": 83}, {"referenceID": 26, "context": "Hence, it is NP-hard and a popular approximate scheme is the following greedy procedure [28]: initially, X \u2190 \u2205 and iteratively update X \u2190 X \u222a {imax} for imax = argmax i\u2208Y\\X f(X \u222a {i})\u2212 f(X), (1)", "startOffset": 88, "endOffset": 92}, {"referenceID": 26, "context": "For the monotone case, it guarantees (1\u2212 1/e)-approximation [28].", "startOffset": 60, "endOffset": 64}, {"referenceID": 6, "context": "Under some modifications of the standard greedy procedure, 2/5-approximation can be guaranteed even for non-monotone functions [7].", "startOffset": 127, "endOffset": 130}, {"referenceID": 16, "context": "Irrespectively of such theoretical guarantees, it has been empirically observed that greedy selection (1) provides near optimal solutions in practice [17, 33, 35, 36].", "startOffset": 150, "endOffset": 166}, {"referenceID": 31, "context": "Irrespectively of such theoretical guarantees, it has been empirically observed that greedy selection (1) provides near optimal solutions in practice [17, 33, 35, 36].", "startOffset": 150, "endOffset": 166}, {"referenceID": 33, "context": "Irrespectively of such theoretical guarantees, it has been empirically observed that greedy selection (1) provides near optimal solutions in practice [17, 33, 35, 36].", "startOffset": 150, "endOffset": 166}, {"referenceID": 2, "context": "In literature, several polynomial expansions, including Taylor [3], Chebyshev [11] and Legendre [31] have been used.", "startOffset": 63, "endOffset": 66}, {"referenceID": 10, "context": "In literature, several polynomial expansions, including Taylor [3], Chebyshev [11] and Legendre [31] have been used.", "startOffset": 78, "endOffset": 82}, {"referenceID": 29, "context": "In literature, several polynomial expansions, including Taylor [3], Chebyshev [11] and Legendre [31] have been used.", "startOffset": 96, "endOffset": 100}, {"referenceID": 0, "context": "For trace estimation, several random vectors have been also studied [1], e.", "startOffset": 68, "endOffset": 71}, {"referenceID": 12, "context": ", the Hutchinson method [13] chooses elements", "startOffset": 24, "endOffset": 28}, {"referenceID": 10, "context": "In this paper, we use LDAS using the Chebyshev polynomial and Hutchinson method [11], but one can also use other alternatives.", "startOffset": 80, "endOffset": 84}, {"referenceID": 10, "context": "Log-determinant Approximation Scheme (LDAS) [11] Input: symmetric matrix A \u2208 Rd\u00d7d with eigenvalues in [\u03b4, 1 \u2212 \u03b4], sampling number m and polynomial degree n Initialize: \u0393\u2190 0 cj \u2190 j-th coefficient of Chebyshev expansion of log x on [\u03b4, 1\u2212 \u03b4] for 0 \u2264 j \u2264 n.", "startOffset": 44, "endOffset": 48}, {"referenceID": 27, "context": "An alternative way to achieve the same complexity is to use the Schur complement [29]: log detLX\u222a{i} \u2212 log detLX = log ( Li,i \u2212 Li,XL X LX,i ) .", "startOffset": 81, "endOffset": 85}, {"referenceID": 9, "context": "(2) This requires a linear solver to compute L\u22121 X LX,i; conjugate gradient descent (CG) [10] is a popular choice in practice.", "startOffset": 89, "endOffset": 93}, {"referenceID": 21, "context": "Recently, Gauss quadrature via Lanczos iteration is used for efficient computing of Li,XL \u22121 X LX,i [22].", "startOffset": 100, "endOffset": 104}, {"referenceID": 26, "context": "Such batch greedy algorithms have been also studied for submodular maximization [28, 12] and recently, [23] studied their theoretical guarantees showing that they can be better than their non-batch counterparts under some conditions.", "startOffset": 80, "endOffset": 88}, {"referenceID": 11, "context": "Such batch greedy algorithms have been also studied for submodular maximization [28, 12] and recently, [23] studied their theoretical guarantees showing that they can be better than their non-batch counterparts under some conditions.", "startOffset": 80, "endOffset": 88}, {"referenceID": 22, "context": "Such batch greedy algorithms have been also studied for submodular maximization [28, 12] and recently, [23] studied their theoretical guarantees showing that they can be better than their non-batch counterparts under some conditions.", "startOffset": 103, "endOffset": 107}, {"referenceID": 25, "context": "[27] first propose an uniformly random sampling to the standard non-batch greedy algorithm.", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "We compare our algorithms with following competitors: the standard greedy algorithm (GREEDY) [28], stochastic greedy algorithm (STOCH) [27], double greedy algorithm (DOUBLE) [4] and softmax extension (SOFTMAX) [8].", "startOffset": 93, "endOffset": 97}, {"referenceID": 25, "context": "We compare our algorithms with following competitors: the standard greedy algorithm (GREEDY) [28], stochastic greedy algorithm (STOCH) [27], double greedy algorithm (DOUBLE) [4] and softmax extension (SOFTMAX) [8].", "startOffset": 135, "endOffset": 139}, {"referenceID": 3, "context": "We compare our algorithms with following competitors: the standard greedy algorithm (GREEDY) [28], stochastic greedy algorithm (STOCH) [27], double greedy algorithm (DOUBLE) [4] and softmax extension (SOFTMAX) [8].", "startOffset": 174, "endOffset": 177}, {"referenceID": 7, "context": "We compare our algorithms with following competitors: the standard greedy algorithm (GREEDY) [28], stochastic greedy algorithm (STOCH) [27], double greedy algorithm (DOUBLE) [4] and softmax extension (SOFTMAX) [8].", "startOffset": 210, "endOffset": 213}, {"referenceID": 18, "context": "3 We implement GREEDY using DPP marginalization requiring matrix inversion [19], which is a bit faster (preserving the same accuracy) than its na\u0131\u0308ive implementation described in Section 2.", "startOffset": 75, "endOffset": 79}, {"referenceID": 24, "context": "For boosting approximation qualities of our algorithms, we use the simple trick in our experiments: recompute top ` marginal gains exactly (using CG) 3We also run the accelerated greedy algorithm [26] for general submodular maximization, but do not report its performance since its approximation quality is extremely bad for the DPP case.", "startOffset": 196, "endOffset": 200}, {"referenceID": 24, "context": "In fact, the trick is inspired by [26] where the authors also recompute the exact marginal gain of a single element.", "startOffset": 34, "endOffset": 38}, {"referenceID": 17, "context": "As [18, 19] proposed, a kernel matrix L for DPP can be re-parameterized as Li,j = qi\u03c6 > i \u03c6jqj , where qi \u2208 R is considered as the quality of item i and \u03c6i \u2208 R is the normalized feature vector of item i so that \u03c6i \u03c6j measures the similarity between i and j.", "startOffset": 3, "endOffset": 11}, {"referenceID": 18, "context": "As [18, 19] proposed, a kernel matrix L for DPP can be re-parameterized as Li,j = qi\u03c6 > i \u03c6jqj , where qi \u2208 R is considered as the quality of item i and \u03c6i \u2208 R is the normalized feature vector of item i so that \u03c6i \u03c6j measures the similarity between i and j.", "startOffset": 3, "endOffset": 11}, {"referenceID": 3, "context": "Interestingly, we found that DOUBLE has the strong theoretical guarantee for general submodular maximization [4], but its practical performance for DPP is bad.", "startOffset": 109, "endOffset": 112}, {"referenceID": 7, "context": "We evaluate our proposed algorithms for matched summarization that is first proposed by [8].", "startOffset": 88, "endOffset": 91}, {"referenceID": 7, "context": "4 We follow similar pre-processing steps of [8].", "startOffset": 44, "endOffset": 47}, {"referenceID": 1, "context": "First, every sentence is parsed and only nouns except the stopwords are extracted via NLTK [2].", "startOffset": 91, "endOffset": 94}, {"referenceID": 5, "context": "We use 39 videos from a Youtube dataset [6], and the trained DPP kernels from [9].", "startOffset": 40, "endOffset": 43}, {"referenceID": 8, "context": "We use 39 videos from a Youtube dataset [6], and the trained DPP kernels from [9].", "startOffset": 78, "endOffset": 81}], "year": 2017, "abstractText": "Determinantal point processes (DPPs) are popular probabilistic models that arise in many machine learning tasks, where distributions of diverse sets are characterized by matrix determinants. In this paper, we develop fast algorithms to find the most likely configuration (MAP) of large-scale DPPs, which is NP-hard in general. Due to the submodular nature of the MAP objective, greedy algorithms have been used with empirical success. Greedy implementations require computation of log-determinants, matrix inverses or solving linear systems at each iteration. We present faster implementations of the greedy algorithms by utilizing the complementary benefits of two log-determinant approximation schemes: (a) first-order expansions to the matrix log-determinant function and (b) high-order expansions to the scalar log function with stochastic trace estimators. In our experiments, our algorithms are orders of magnitude faster than their competitors, while sacrificing marginal accuracy.", "creator": "LaTeX with hyperref package"}}}