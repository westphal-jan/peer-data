{"id": "1706.04582", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Jun-2017", "title": "The Opacity of Backbones and Backdoors Under a Weak Assumption", "abstract": "Backdoors and backbone of Boolean formulas are hidden structural properties that are relevant for analyzing the hardness of instances of the SAT problem. Therefore, developing and analyzing algorithms to find and use these properties is useful to improve the performance of modern solvers and our general understanding of SAT. In this work, we show that under the assumption that P $\\ neq $NP, there are easily identifiable sets of Boolean formulas where it is difficult to determine whether they have a backbone. We also show that under the same assumption, there are easily identifiable families of Boolean formulas with strong backdoors that are easy to find, where it is difficult to determine whether they are satisfactory or not.", "histories": [["v1", "Wed, 14 Jun 2017 16:46:01 GMT  (9kb)", "http://arxiv.org/abs/1706.04582v1", null], ["v2", "Wed, 6 Sep 2017 21:45:55 GMT  (10kb)", "http://arxiv.org/abs/1706.04582v2", null], ["v3", "Fri, 13 Oct 2017 17:54:53 GMT  (11kb)", "http://arxiv.org/abs/1706.04582v3", null], ["v4", "Tue, 24 Oct 2017 15:51:57 GMT  (14kb)", "http://arxiv.org/abs/1706.04582v4", null]], "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.LO", "authors": ["lane a hemaspaandra", "david e narv\\'aez"], "accepted": false, "id": "1706.04582"}, "pdf": {"name": "1706.04582.pdf", "metadata": {"source": "CRF", "title": "The Opacity of Backbones and Backdoors Under a Weak Assumption", "authors": ["Lane A. Hemaspaandra", "David E. Narv\u00e1ez"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n70 6.\n04 58\n2v 1\n[ cs\n.A I]\nBackdoors and backbones of Boolean formulas are hidden structural properties that are relevant to the analysis of the hardness of instances of the SAT problem. The development and analysis of algorithms to find and make use of these properties is thus useful to improve the performance of modern solvers and our general understanding of SAT. In this work we show that, under the assumption that P 6= NP, there are easily-recognizable sets of Boolean formulas for which it is hard to determine whether they have a backbone. We also show that, under the same assumption, there are easily-recognizable families of Boolean formulas with strong backdoors that are easy to find, for which it is hard to determine whether they are satisfiable or not."}, {"heading": "1 Introduction", "text": "Many algorithms for the Boolean satisfiability problem exploit hidden structural properties of formulas in order to find a satisfying assignment or prove that no such assignment exists. These structural properties are called hidden because they are not explicit in the input formula. A natural question that arises then is what is the computational complexity associated with these hidden structures. In this paper we focus on two hidden structures: backbones and strong backdoors [WGS03].\nThe complexity of decision problems associated with backbones and backdoors has been studied by Kilby, Slaney, Thie\u0301baux, and Walsh [KSTW05] and Dilkina, Gomes, and Sabharwal [DGS14], among others.\nHemaspaandra and Narva\u0301ez [HN17] show a separation between the complexity of finding backbones and that of finding the values to which the backbone variables must be set to under the assumption that P 6= NP \u2229 coNP. In the present paper, we add to this line of research by showing that, under the assumption that P 6= NP, there are families of formulas that are easy to recognize (i.e., can be recognized by polynomial-time algorithms) but no polynomial-time algorithm can decide whether a formula in these families has a backbone. We also show that, under the same assumption, there are easily-recognizable families of formulas with backdoors that are easy to find, yet the problem of determining whether these formulas are satisfiable or not remains hard.\nThe rest of this paper is organized as follows. Section 2 defines the notation we will use throughout this paper. Sections 3 and 4 contain our results related to backbones and backdoors respectively. Finally, Section 5 adds some concluding remarks."}, {"heading": "2 Definitions and Notations", "text": "For a Boolean formula F , we denote by V (F ) the set of variables of F . A partial assignment of F is a function aS : S \u2192 {True,False} that assigns Boolean values to the variables in a set S \u2286 V (F ). For a Boolean value v \u2208 {True,False} and a variable x \u2208 V (F ), the notation F [v/x] denotes the formula F after replacing every occurrence of x by v and simplifying. This extends to partial assignments in the natural way.\nIn theorems about the frequency of hardness of the sets we define in this paper, we will refer to input strings of length at most n. For an alphabet \u03a3, in a slight abuse of notation we denote by \u03a3\u2264n the set of strings over \u03a3 whose length is less than or equal to n."}, {"heading": "3 Results on Backbones", "text": "For the sake of completeness, we start this section by restating the definition of backbones as presented by Williams, Gomes, and Selman [WGS03]. We restrict ourselves to the Boolean domain, since we only deal with Boolean formulas in this paper.\nDefinition 3.1 (Backbone [WGS03]). For a Boolean formula F , a subset S of its variables is a backbone if there is a unique partial assignment aS such that F [aS ] is satisfiable.\nThe size of a backdoor S is the number of variables in S. One can readily see from Definition 3.1 that all satisfiable formulas have at least one backbone, namely, the empty set. This backbone is called the trivial backbone, while backbones of size at least one are called nontrivial backbones. Another conclusion one can derive from Definition 3.1 is that unsatisfiable formulas do not have backbones. This will be a key observation in our results related to backbones. Notice, however, that the original paper by Monasson et al. introducing the concept of backbones [MZK+99] defines a backbone as a set of variables that are \u201cfully constrained\u201d by the formula, a definition that does not require the formula to be satisfiable.\nOur first result states that if P 6= NP then there are families of Boolean formulas that are easy to recognize, with the property that deciding whether or not a formula in these families has a nontrivial backbone is hard.\nTheorem 3.2. If P 6= NP then for any real number 0 < \u03b2 < 1, there is a set A \u2208 P of Boolean formulas such that the language\nLA = {G | G \u2208 A and G has a nontrivial backbone S with |S| \u2265 \u03b2 |V (G)|}\nis not in P.\nProof. For a Boolean formula F , let q (F ) = \u2308\n\u03b2|V (F )| 1\u2212\u03b2\n\u2309\n. Define\nA = { F \u2227 ( new1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(F ) ) | F is a boolean formula } ,\nwhere we define newi as the i-th (in lexicographical order) legal variable name that does not appear in F . For instance, if F contains literals x1, x2, x3, and x3, and if our legal variable universe is x1, x2, x3, x4, . . ., then new1 would be x4. Note that new1\u2227new2\u2227\u00b7 \u00b7 \u00b7\u2227newq(F ) is a backbone if and only if F \u2208 SAT, thus under the assumption that P 6= NP, no polynomial-time algorithm can decide LA. The size of this backbone is q (F ) > 0 which, by definition, satisfies q (F ) \u2265 \u03b2 (|V (F )|+ q (F )).\nAs in Hemaspaandra and Narva\u0301ez [HN17], we address the concern that the hard instances for the decision problems we just introduced may be so infrequent that the relevance of Theorem 3.2 is undercut. The following theorem argues against that possibility by proving that, unless all NP sets are very frequently easy, some sets of our form are not frequently easy.\nTheorem 3.3. If h is any nondecreasing function and for some set B \u2208 NP it holds that each polynomial-time algorithm for membership testing in B errs, at infinitely many lengths n (resp., almost everywhere), on at least h (n) of the inputs up to that length, then there will exist an \u01eb > 0 and a set A \u2208 P of Boolean formulas satisfying the conditions of Theorem 3.2, yet being such that each polynomial-time algorithm g, at infinitely many lengths n (resp., almost everywhere), will fail to correctly determine membership in LA for at least h (n \u01eb) inputs of length at most n.\nProof. Let rB be a polynomial-time function that transforms inputs to B (viewed as a membershiptesting problem) into Boolean formulas, such that rB (x) \u2208 SAT if and only if x \u2208 B, and rB is one-to-one (we show an explicit construction of such a function in Appendix A of [HN16]). As in Theorem 3.2, we define q (F ) = \u2308\n\u03b2|V (F )| 1\u2212\u03b2\n\u2309\nfor any Boolean formula F and\nA = { rB (x) \u2227 ( new1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(rB(x)) ) | x \u2208 \u03a3\u2217 } .\nBecause rB is computable in polynomial time, there is a polynomial b of degree k such that for every input x of length at most n, the length of rB (x) is at most b (n). Also, since the length of rB (x) is at least a constant times the number of its variables, there is a constant c such that \u2223 \u2223\nnew1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(rB(x)) \u2223 \u2223 \u2264 c \u00b7 b (n). Let N be a natural number such that, for all n \u2265 N\nand for every input x, |x| \u2264 n implies \u2223 \u2223rB (x) \u2227 ( new1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(rB(x)) ) \u2223 \u2223 \u2264 nk+1. Let g be a polynomial-time heuristic for LA. Notice that g \u25e6 rB is a polynomial-time heuristic for B since rB (x)\u2227 ( new1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(rB(x)) )\n\u2208 LA \u21d4 rB (x) \u2208 SAT \u21d4 x \u2208 B. Let nB \u2265 N be such that there is a set of strings SnB \u2286 \u03a3\n\u2264nB , |SnB | \u2265 h (nB), having the property that for all x \u2208 SnB , g \u25e6rB fails to determine the membership of x in B. Consequently, there is a set of strings TnB \u2286 \u03a3 \u2264nk+1 B , |TnB | \u2265 h (nB), such that for all x \u2208 TnB , g fails to determine the membership of x in LA, namely, the set\nTnB = { rB (x) \u2227 ( new1 \u2227 new2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 newq(rB(x)) ) |x \u2208 SnB } .\nUsing a variable renaming nA = n k+1 B , we have proved that every length nB \u2265 N at which g \u25e6 rB (a heuristic for B) errs in at least h (nB) inputs of length up to nB has a corresponding length nA\nat which g (a heuristic for LA) errs in at least h\n(\nn 1 k+1\nA\n)\ninputs of length up to nA. Our hypothesis\nguarantees the existence of infinitely many such nB \u2265 N (resp., almost all n \u2265 N can take the role of nB), each with a corresponding nA. Setting \u01eb = 1 k+1 then proves our theorem."}, {"heading": "4 Results on Backdoors to CNF Formulas", "text": "In this section we focus on Boolean formulas in conjunctive normal form, or CNF. A CNF formula is a conjunction of disjunctions, and the disjunctions are called the clauses of the formula. Following Dilkina, Gomes, and Sabharwal [DGS14], we define satisfiability of CNF formulas using the language of set theory. We do this by formalizing the intuition that, in order for an assignment to satisfy a CNF formula, it must set at least one literal in every clause to True. We can then define a CNF formula F to be a collection of clauses, each clause being a set of literals. F \u2208 SAT if and only if there exists an assignment aV (F ) such that for all clauses C \u2208 F there exists a literal l \u2208 C such\nthat aV (F ) assigns l to True. Under this formalization, two trivial cases arise: F is trivially in SAT if F is empty, and F is trivially not in SAT if \u2205 \u2208 F . We can also formalize simplification using this notation: after assigning a variable x to True (resp., False), the formula is simplified by removing all clauses that contain the literal x (resp., x) and removing the literal x (resp., x) from the remaining clauses. This formalization extends to simplification of a formula over a partial assignment in the natural way.\nSince CNFSAT (the satisfiability problem restricted to CNF formulas) is well-known to be NPcomplete, a polynomial-time algorithm to determine the satisfiability of CNF formulas is unlikely to exist. Nevertheless, there are several subclasses of CNF formulas for which satisfiability can be decided in polynomial time. When a formula does not belong to any of these subclasses, it may have a set of variables that, once the formula is simplified over a partial assignment of these variables, the resulting formula belongs to one of these tractable subclasses. A formalization of this idea is the concept of backdoors.\nDefinition 4.1 (Subsolver [WGS03]). An algorithm A is a subsolver if, for an input formula F , it satisfies all the following conditions.\n1. A either rejects the input F or \u201cdetermines\u201d F correctly (returning a solution if satisfiable).\n2. A runs in polynomial time.\n3. A can determine if F is trivially True or trivially False.\n4. If A determines F , then for any variable x and value v, A determines F [v/x].\nDefinition 4.2 (Strong Backdoor [WGS03]). For a Boolean formula F , a nonempty subset S of its variables is a strong backdoor for a subsolver A if, for all partial assignments aS, A returns a satisfying assignment or concludes unsatisfiability of F [aS ].\nMany examples of subsolvers can be found in the literature (for instance, in Table 1 of [DGS14]). The subsolver that is of particular relevance to this paper is the unit propagation subsolver, which operates over unit clauses. Unit clauses are clauses with just one literal. They play an important role in the process of finding models because the literal in that clause must be set to True in order to find a satisfying assignment. The process of finding a model by searching for a unit clause, fixing the value of the variable in the unit clause, and simplifying the formula resulting from that assignment is known in the SAT literature as unit propagation. Unit propagation is an important building block in the seminal DPLL algorithm for SAT [DP60, DLL62]. Notice that CNF formulas for which a model can be found by just applying unit propagation iteratively constitute a tractable subclass of SAT. The unit propagation subsolver attempts to decide the satisfiability of an input formula by using only unit propagation and empty clause detection. If a model cannot be found this way, the subsolver rejects the input formula. Szeider [Sze05] classified the parameterized complexity of finding backdoors with respect to the unit propagation subsolver.\nWe are now ready to prove our main result about backdoors: that under the assumption that P 6= NP, there are families of Boolean formulas that are easy to recognize and have strong unit propagation backdoors that are easy to find, yet deciding whether the formulas in these families are satisfiable or not remains NP-complete.\nTheorem 4.3. If P 6= NP, for each k \u2208 {1, 2, 3, . . .} there is a set A of Boolean formulas such that all the following hold.\n1. A \u2208 P and A \u2229 SAT is NP-complete.\n2. Each formula G in A has a strong backdoor S with respect to the unit propagation subsolver,\nwith |S| \u2264 |V (G)| 1 k .\n3. Indeed, there even is a polynomial-time algorithm that, given G \u2208 A, finds a strong backdoor having property 2.\nProof. Consider\nA = { F \u2227 (\nnew1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 new|V (F )|k\u2212|V (F )|\n) | F is a CNF formula }\nwhere, as in the proof of Theorem 3.2, newi is the i-th variable that does not appear in F . The backdoor is the set of variables of F , which can be found in polynomial time by parsing. It is clear that the formula resulting from simplification after assigning values to all the variables of F only has unit clauses and potentially an empty clause, so satisfiability for this formula can be decided by the unit propagation subsolver. Finally, it is easy to see that F \u2227 (\nnew1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 new|V (F )|k\u2212|V (F )|\n)\n\u2208\nSAT \u21d4 F \u2208 SAT so under the assumption that P 6= NP, deciding satisfiability for the formulas in A is hard.\nAs before, we address the frequency of hardness of the sets we define in Theorem 4.3.\nTheorem 4.4. If h is any nondecreasing function and for some set B \u2208 NP it holds that each polynomial-time algorithm for membership testing in B errs, at infinitely many lengths n (resp., almost everywhere), on at least h (n) of the inputs up to that length, then there will exist an \u01eb > 0 and a set A \u2208 P of Boolean formulas satisfying Theorem 4.3\u2019s conditions, yet being such that each polynomial-time algorithm g, at infinitely many lengths n (resp., almost everywhere), will fail to determine membership in A \u2229 SAT for at least h (n\u01eb) inputs of length at most n.\nProof. We define rB as in Theorem 3.3 with the additional condition that the formula output by rB is in conjunctive normal form. For a given k, we define\nA = { rB (x) \u2227 (\nnew1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 new|V (rB(x))|k\u2212|V (rB(x))|\n) | x \u2208 \u03a3\u2217 }\nand since rB (x) \u2227 (\nnew1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 new|V (rB(x))|k\u2212|V (rB(x))|\n)\n\u2208 SAT \u21d4 rB (x) \u2208 SAT \u21d4 x \u2208 B, we can\nnow proceed as in the proof of Theorem 3.3."}, {"heading": "5 Conclusions", "text": "We described easily-recognizable families of Boolean formulas that provide hard instances for decision problems related to backbones and backdoors under the assumption that P 6= NP. We did this by exploiting the fact that, under such assumption, SAT \u2208 NP\u2212P. In the particular case of backbones our proof hinges on the fact that unsatisfiable formulas, by definition, do not have backbones. We have also shown that if any problem in NP is frequently hard, then the families of Boolean formulas we describe are frequently hard as well."}], "references": [{"title": "Tradeoffs in the complexity of backdoors to satisfiability: dynamic sub-solvers and learning during search", "author": ["B. Dilkina", "C. Gomes", "A. Sabharwal"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Dilkina et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Dilkina et al\\.", "year": 2014}, {"title": "A machine program for theorem-proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "A computing procedure for quantification theory", "author": ["M. Davis", "H. Putnam"], "venue": "Journal of the ACM,", "citeRegEx": "Davis and Putnam.,? \\Q1960\\E", "shortCiteRegEx": "Davis and Putnam.", "year": 1960}, {"title": "The opacity of backbones", "author": ["L. Hemaspaandra", "D. Narv\u00e1ez"], "venue": "Technical Report arXiv:1606.03634 [cs.AI],", "citeRegEx": "Hemaspaandra and Narv\u00e1ez.,? \\Q2017\\E", "shortCiteRegEx": "Hemaspaandra and Narv\u00e1ez.", "year": 2017}, {"title": "The opacity of backbones", "author": ["L. Hemaspaandra", "D. Narv\u00e1ez"], "venue": "In Proceedings of the 31st AAAI Conference on Artificial Intelligence,", "citeRegEx": "Hemaspaandra and Narv\u00e1ez.,? \\Q2017\\E", "shortCiteRegEx": "Hemaspaandra and Narv\u00e1ez.", "year": 2017}, {"title": "Backbones and backdoors in satisfiability", "author": ["P. Kilby", "J. Slaney", "S. Thi\u00e9baux", "T. Walsh"], "venue": "In Proceedings of the 20th National Conference on Artificial Intelligence,", "citeRegEx": "Kilby et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kilby et al\\.", "year": 2005}, {"title": "Determining computational complexity from characteristic \u2018phase transitions", "author": ["R. Monasson", "R. Zecchina", "S. Kirkpatrick", "B. Selman", "L. Troyansky"], "venue": "Nature, 400:133\u2013137,", "citeRegEx": "Monasson et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Monasson et al\\.", "year": 1999}, {"title": "Backdoor sets for DLL subsolvers", "author": ["S. Szeider"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Szeider.,? \\Q2005\\E", "shortCiteRegEx": "Szeider.", "year": 2005}, {"title": "Backdoors to typical case complexity", "author": ["R. Willams", "C. Gomes", "B. Selman"], "venue": "In Proceedings of the 18th International Joint Conference on Artificial Intelligence,", "citeRegEx": "Willams et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Willams et al\\.", "year": 2003}], "referenceMentions": [], "year": 2017, "abstractText": "Backdoors and backbones of Boolean formulas are hidden structural properties that are relevant to the analysis of the hardness of instances of the SAT problem. The development and analysis of algorithms to find and make use of these properties is thus useful to improve the performance of modern solvers and our general understanding of SAT. In this work we show that, under the assumption that P 6= NP, there are easily-recognizable sets of Boolean formulas for which it is hard to determine whether they have a backbone. We also show that, under the same assumption, there are easily-recognizable families of Boolean formulas with strong backdoors that are easy to find, for which it is hard to determine whether they are satisfiable or not.", "creator": "LaTeX with hyperref package"}}}