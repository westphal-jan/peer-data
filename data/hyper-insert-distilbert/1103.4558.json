{"id": "1103.4558", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2011", "title": "Representing First-Order Causal Theories by Logic Programs", "abstract": "essentially nonmonotonic bounded causal consequence logic, introduced also by norman mccain richardson and hudson henry turner, became into a influential basis for formulation the semantics of of several expressive category action testing languages. mccain's later embedding of generalized definite propositional fuzzy causal theories into logic based programming paved, the way to the use of answer set solvers for fully answering queries about actions now described mainly in arbitrary such languages. in this 1994 paper we extend this embedding semantics to nondefinite quantum theories and to secure first - odd order causal logic.", "histories": [["v1", "Wed, 23 Mar 2011 15:48:44 GMT  (46kb)", "http://arxiv.org/abs/1103.4558v1", "29 pages. To appear in Theory and Practice of Logic Programming (TPLP); Theory and Practice of Logic Programming, May, 2011"]], "COMMENTS": "29 pages. To appear in Theory and Practice of Logic Programming (TPLP); Theory and Practice of Logic Programming, May, 2011", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["paolo ferraris", "joohyung lee", "yuliya lierler", "vladimir lifschitz", "fangkai yang"], "accepted": false, "id": "1103.4558"}, "pdf": {"name": "1103.4558.pdf", "metadata": {"source": "CRF", "title": "Representing First-Order Causal Theories by Logic Programs", "authors": ["Paolo Ferraris", "Joohyung Lee", "Yuliya Lierler", "Fangkai Yang"], "emails": ["otto@cs.utexas.edu)", "joolee@asu.edu)", "yuliya@cs.utexas.edu)", "vl@cs.utexas.edu)", "fkyang@cs.utexas.edu)"], "sections": [{"heading": null, "text": "ar X\niv :1\na basis for the semantics of several expressive action languages. McCain\u2019s embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.\nKEYWORDS: reasoning about actions, nonmonotonic causal logic, answer set programming"}, {"heading": "1 Introduction", "text": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009). The Causal Calculator (CCalc)1 is a partial\n1 http://www.cs.utexas.edu/users/tag/ccalc/\nimplementation of this logic that allows us to automate some kinds of reasoning and planning in action domains described in such languages. It has been used to solve several challenging commonsense reasoning problems, including problems of nontrivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).\nAn important theorem due to Norman McCain (McCain 1997, Proposition 6.7) shows how to embed a fragment of propositional causal logic into the language of logic programming under the answer set semantics (Gelfond and Lifschitz 1991). This result, reviewed below, paved the way to the development of an attractive alternative to CCalc\u2014the software system coala (Gebser et al. 2010) that uses answer set programming (Marek and Truszczyn\u0301ski 1999; Niemela\u0308 1999; Lifschitz 2008) for answering queries about actions described in causal logic.\nA causal theory in the sense of (McCain and Turner 1997) is a set of \u201ccausal rules\u201d of the form F \u21d0 G, where F and G are propositional formulas (the head and the body of the rule). The rule reads \u201cF is caused if G is true.\u201d Distinguishing between being true and having a cause turned out to be essential for the study of commonsense reasoning. The assertion \u201cif the light is on at time 0 and you toggle the switch then the light will be off at time 1\u201d can be written as an implication:\non0 \u2227 toggle \u2192 \u00acon1\u00b7\nIn causal logic, on the other hand, we can express that under the same assumption there is a cause for the light to be off at time 1:\n\u00acon1 \u21d0 on0 \u2227 toggle\u00b7\n(Performing the toggle action is the cause.) McCain and Turner showed that distinctions like this help us solve the frame problem (see Example 5 in Section 5.2) and overcome other difficulties arising in the theory of reasoning about actions.\nThe semantics of theories of this kind defines when a propositional interpretation (truth assignment) is a model of the given theory (is \u201ccausally explained\u201d by the theory, in the terminology of McCain and Turner). We do not reproduce the definition here, because a more general semantics is described below in Section 3. But here is an example: the causal theory\np \u21d0 \u00acq\n\u00acq \u21d0 p (1)\nhas one model, according to the semantics from (McCain and Turner 1997). In this model, p is true and q is false. (Since the bodies of both rules are true in this model, both rules \u201cfire\u201d; consequently the heads of the rules are \u201ccaused\u201d; consequently the truth values of both atoms are \u201ccausally explained.\u201d This will be discussed formally in Section 3.)\nMcCain\u2019s translation is applicable to a propositional causal theory T if the head\nof each rule of T is a literal, and the body is a conjunction of literals:\nL \u21d0 A1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Am \u2227 \u00acAm+1 \u2227 \u00b7 \u00b7 \u00b7 \u00acAn \u00b7 (2)\nThe corresponding logic program consists of the logic programming rules\nL \u2190 not \u00acA1, . . . , not \u00acAm , not Am+1, . . . , not An (3)\nfor all rules (2) of T . This program involves two kinds of negation: negation as failure (not) and strong, or classical, negation (\u00ac). According to Proposition 6.7 from (McCain 1997), complete answer sets of this logic program are identical to the models of T . (A set of literals is complete if it contains exactly one member of each complementary pair of literals A,\u00acA. We identify a complete set of literals with the corresponding truth assignment.)\nFor instance, McCain\u2019s translation turns causal theory (1) into\np \u2190 not q\n\u00acq \u2190 not \u00acp\u00b7 (4)\nThe only answer set of this program is {p,\u00acq}. It is complete, and it corresponds to the model of causal theory (1).\nIn this paper we generalize McCain\u2019s translation in several ways. First, we discard the requirement that the bodies of the given causal rules be conjunctions of literals. Second, instead of requiring that the head of each causal rule be a literal, we allow the heads to be disjunctions of literals. In this more general setting, the logic program corresponding to the given causal theory becomes disjunctive as well.\nThird, we study causal rules with heads of the form L1 \u2194 L2, where L1 and L2 are literals. Such a rule says that there is a cause for L1 and L2 to be equivalent (\u201csynonymous\u201d) under some condition, expressed by the body of the rule. Synonymity rules play an important role in the theory of commonsense reasoning in view of the fact that humans often explain the meaning of words by referring to their synonyms. A synonymity rule\nL1 \u2194 L2 \u21d0 G (5)\ncan be translated into logic programming by rewriting it as the pair of rules\nL1 \u2228 L2 \u21d0 G L1 \u2228 L2 \u21d0 G\n(L stands for the literal complementary to L) and then using our extension of McCain\u2019s translation to rules with disjunctive heads. It turns out, however, that there is no need to use disjunctive logic programs in the case of synonymity rules. If, for instance, G in (5) is a literal then the following group of nondisjunctive rules will do:\nL1 \u2190 L2, not G L2 \u2190 L1, not G L1 \u2190 L2, not G L2 \u2190 L1, not G \u00b7\nFinally, we extend the translation from propositional causal rules to first-order causal rules in the sense of (Lifschitz 1997). This version of causal logic is useful for defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).\nAs part of motivation for our approach to transforming causal theories into logic\nprograms, we start with a few additional comments on McCain\u2019s translation (Section 2). After reviewing the semantics of causal theories and logic programs in Sections 3 and 4, we describe four kinds of causal rules that we are interested in and show how to turn a theory consisting of such rules into a logic program (Section 5). This translation is related to answer set programming in Section 6, and its soundness is proved in Section 7.\nPreliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010). Some results appear here for the first time, including the soundness of a representation of a synonymity rule with variables by a nondisjunctive logic program."}, {"heading": "2 McCain\u2019s Translation Revisited", "text": ""}, {"heading": "2.1 Incorporating Constraints", "text": "In causal logic, a constraint is a rule with the head \u22a5 (falsity). McCain\u2019s translation can be easily extended to constraints with a conjunction of literals in the body\u2014 causal rules of the form\n\u22a5 \u21d0 A1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Am \u2227 \u00acAm+1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acAn \u00b7 (6)\nIn the language of logic programming, (6) can be represented by a rule similar to (3):\n\u22a5 \u2190 not \u00acA1, . . . , not \u00acAm , not Am+1, . . . , not An \u00b7 (7)\nFurthermore, each of the combinations not \u00ac in (7) can be dropped without destroying the validity of the translation; that is to say, the rule\n\u22a5 \u2190 A1, . . . ,Am , not Am+1, . . . , not An (8)\ncan be used instead of (7)."}, {"heading": "2.2 Eliminating Strong Negation", "text": "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms. Denote the new atom representing a negative literal \u00acA by A\u0302. Then (3) will become\nA0 \u2190 not A\u03021, . . . , not A\u0302m , not Am+1, . . . , not An (9)\nif L is a positive literal A0, and\nA\u03020 \u2190 not A\u03021, . . . , not A\u0302m , not Am+1, . . . , not An (10)\nif L is a negative literal \u00acA0. The modified McCain translation of a causal theory T consisting of rules of the forms (2) and (6) includes\n\u2022 rules (8) corresponding to the constraints (6) of T , \u2022 rules (9), (10) corresponding to the other rules of T , and\n\u2022 the completeness constraints\n\u2190 A, A\u0302 \u2190 not A, not A\u0302 (11)\nfor all atoms A.\nFor instance, the modified McCain translation of (1) is\np \u2190 not q q\u0302 \u2190 not p\u0302\n\u2190 p, p\u0302 \u2190 not p, not p\u0302 \u2190 q, q\u0302 \u2190 not q, not q\u0302 \u00b7\n(12)\nThe only answer set (stable model2) of this program is {p, q\u0302}.\nThis modification is useful to us in view of the fact that eliminating strong negation in favor of aditional atoms is part of the definition of a stable model proposed in (Ferraris et al. 2011, Section 8)."}, {"heading": "2.3 Rules as Formulas", "text": "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas. For instance, rules (9) and (10), rewritten as propositional formulas, become\n\u00acA\u03021 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u0302m \u2227 \u00acAm+1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acAn \u2192 A0 (13)\nand\n\u00acA\u03021 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u0302m \u2227 \u00acAm+1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acAn \u2192 A\u03020\u00b7 (14)\nRule (8) can be identified with the formula\nA1 \u2227 \u00b7 \u00b7 \u00b7 \u2227Am \u2227 \u00acAm+1 \u2227 . . . \u2227 \u00acAn \u2192 \u22a5 (15)\nor, alternatively, with\n\u00ac(A1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 Am \u2227 \u00acAm+1 \u2227 . . . \u2227 \u00acAn)\u00b7 (16)\nThe completeness constraints for an atom A turn into the formulas\n\u00ac(A \u2227 A\u0302) \u00ac(\u00acA \u2227 \u00acA\u0302)\u00b7 (17)\n2 The term \u201cstable model\u201d was introduced in (Gelfond and Lifschitz 1988) to describe the meaning of logic programs with negation as failure but without strong negation. When the stable model semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the term \u201canswer set\u201d was proposed as a replacement.\nHere is program (12) rewritten in the syntax of propositional logic:\n\u00acq \u2192 p \u00acp\u0302 \u2192 q\u0302 \u00ac(p \u2227 p\u0302) \u00ac(\u00acp \u2227 \u00acp\u0302) \u00ac(q \u2227 q\u0302) \u00ac(\u00acq \u2227 \u00acq\u0302)\u00b7\n(18)\nNote that the process of rewriting a rule as a formula is applicable only when the rule does not contain strong negation; the symbol \u00ac in the resulting formula corresponds to the negation as failure symbol (not) in the rule.\nOne of the advantages of writing rules as formulas is that it allows us to relate properties of stable models to subsystems of classical logic. We know, for instance, that if the equivalence of two sentences can be proved in intuitionistic logic (or even in the stronger logic of here-and-there) then these sentences have the same stable models (Ferraris et al. 2011, Theorem 5). This fact will be used here many times."}, {"heading": "2.4 Translating Arbitrary Definite Theories", "text": "The requirement, in the definition of McCain\u2019s translation, that the bodies of all causal rules should be conjunctions of literals can be lifted by slightly modifying the translation process. Take any set T of causal rules of the forms\nA \u21d0 G, (19)\n\u00acA \u21d0 G, (20)\n\u22a5 \u21d0 G, (21)\nwhere A is an atom and G is an arbitrary propositional formula (rules of these forms are called definite). For each rule (19), take the formula \u00ac\u00acG \u2192 A; for each rule (20), the formula \u00ac\u00acG \u2192 A\u0302; for each rule (21), the formula \u00acG. Then add completeness constraints (17) for all atoms A. Answer sets of this collection of propositional formulas correspond to the models of T .\nIn application to example (1), this modification of McCain\u2019s translation gives\n\u00ac\u00ac\u00acq \u2192 p \u00ac\u00acp \u2192 q\u0302 \u00ac(p \u2227 p\u0302) \u00ac(\u00acp \u2227 \u00acp\u0302) \u00ac(q \u2227 q\u0302) \u00ac(\u00acq \u2227 \u00acq\u0302)\u00b7\n(22)\nIt is not surprising that (22) has the same answer set as (18): the two collections of formulas are intuitionistically equivalent to each other.3\n3 Indeed, \u00ac\u00ac\u00acq is intuitionistically equivalent to \u00acq ; the equivalence between \u00ac\u00acp and \u00acp\u0302 is intuitionistically entailed by the formulas \u00ac(p \u2227 p\u0302) and \u00ac(\u00acp \u2227 \u00acp\u0302), which belong both to (18) and to (22)."}, {"heading": "3 Review: First-Order Causal Theories", "text": "According to (Lifschitz 1997), a first-order causal theory T is defined by\n\u2022 a list p of distinct predicate constants,4 called the explainable symbols of T ,5\nand\n\u2022 a finite set of causal rules of the form F \u21d0 G, where F and G are first-order\nformulas.\nThe semantics of first-order causal theories can be described as follows. For each p \u2208 p, choose a new predicate variable \u03c5p of the same arity, and let \u03c5p stand for the list of all these variables. By T \u2020(\u03c5p) we denote the conjunction of the formulas\n\u2200x(G \u2192 Fp \u03c5p ) (23)\nfor all rules F \u21d0 G of T , where x is the list of all free variables of F , G. (The expression Fp \u03c5p denotes the result of substituting the variables \u03c5p for the corresponding constants p in F .)\nWe view T as shorthand for the sentence\n\u2200\u03c5p(T \u2020(\u03c5p) \u2194 (\u03c5p = p))\u00b7 (24)\n(By \u03c5p = p we denote the conjunction of the formulas \u2200x(\u03c5p(x) \u2194 p(x)) for all p \u2208 p, where x is a tuple of distinct object variables.) Accordingly, by a model of T we understand a model of (24) in the sense of classical logic. The models of T are characterized, informally speaking, by the fact that the interpretation of the explainable symbols p in the model is the only interpretation of these symbols that is \u201ccausally explained\u201d by the rules of T .\nIn the definite case (see Section 2.4) second-order formula (24) can be replaced by an equivalent first-order formula using a process similar to Clark\u2019s completion (Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997, Section 5). This process is used in the operation of CCalc.\nExample 1. Let T be causal theory (1) with both p and q explainable. Then T \u2020(\u03c5p, \u03c5q) is\n(\u00acq \u2192 \u03c5p) \u2227 (p \u2192 \u00ac\u03c5q)\n(\u03c5p, \u03c5q are propositional variables), so that T is understood as shorthand for the second-order propositional formula (\u201cQBF\u201d)\n\u2200(\u03c5p)(\u03c5q)((\u00acq \u2192 \u03c5p) \u2227 (p \u2192 \u00ac\u03c5q) \u2194 (\u03c5p \u2194 p) \u2227 (\u03c5q \u2194 q))\u00b7 (25)\nThis formula is equivalent to p \u2227 \u00acq.6\n4 We view propositional symbols as predicate constants of arity 0, so that they are allowed in p. Equality, on the other hand, may not be declared explainable. 5 To be precise, the definition in (Lifschitz 1997) is more general: object and function constants can be treated as explainable as well. 6 This fact can be verified by replacing the universal quantifier in (25) with the conjunction of the four propositional formulas obtained by substituting all possible combinations of values for the variables \u03c5p, \u03c5q , and simplifying the result. Alternatively, one can apply literal completion to rules (1) and simplify the result.\nExample 2. Let T be the causal theory consisting of two rules:\np(a) \u21d0 \u22a4\n(here \u22a4 is the logical constant true) and\n\u00acp(x ) \u21d0 \u00acp(x ),\nwith the explainable symbol p. The first rule says that there is a cause for a to have property p. The second rule says that if an object does not have property p then there is a cause for that; including this rule in a causal theory has, informally speaking, the same effect as saying that p is false by default (Lifschitz 1997, Section 3). In this case, T \u2020(\u03c5p) is\n\u03c5p(a) \u2227 \u2200x (\u00acp(x ) \u2192 \u00ac\u03c5p(x )),\nso that T is understood as shorthand for the sentence\n\u2200\u03c5p(\u03c5p(a) \u2227 \u2200x (\u00acp(x ) \u2192 \u00ac\u03c5p(x )) \u2194 \u2200x (\u03c5p(x ) \u2194 p(x )))\u00b7\nThis sentence is equivalent to the first-order formula\n\u2200x (p(x ) \u2194 x = a), (26)\nas can be verified by applying literal completion to the rules of T ."}, {"heading": "4 Review: Stable Models", "text": "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectives are treated as primitives, and which are viewed as abbreviations. The convention there is to take the 0-place connective \u22a5 and the binary connectives \u2227, \u2228, \u2192 as primitives; \u00acF is shorthand for F \u2192 \u22a5.\nIn this paper we adopt the view that first-order formulas are formed using a\nslightly larger set of propositional connectives:\n\u22a4, \u22a5, \u00ac, \u2227, \u2228, \u2192\n(as well as the quantifiers \u2200, \u2203). On the other hand, stable models are only defined here for sentences of a special syntactic form. A first-order sentence is a rule7 if it has the form \u2200\u0303(F \u2192 G) and has no occurrences of \u2192 other than the one explicitly shown.8 If a sentence F does not contain implication then we will identify it with the rule \u22a4 \u2192 F . For instance, propositional formulas (13)\u2013(18) are rules. A logic program is a conjunction of rules. The definition of a stable model below is more limited than the definition from (Ferraris et al. 2011) because it is only applicable to programs, not to arbitrary sentences. For instance, it does not cover the formulas (p \u2192 q) \u2192 r and (p \u2192 q) \u2228 r . On the other hand, it is simpler than the general definition, and it is sufficient for our present purposes.\n7 Or program rule, to distinguish it from causal rules in the sense of Section 3. 8 \u2200\u0303F stands for the universal closure of F .\nWe need the following notation from (Lifschitz 1994). If p and q are predicate\nconstants of the same arity then p \u2264 q stands for the formula\n\u2200x(p(x) \u2192 q(x)),\nwhere x is a tuple of distinct object variables. If p and q are tuples p1, . . . , pn and q1, . . . , qn of predicate constants then p \u2264 q stands for the conjunction\n(p1 \u2264 q1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 (pn \u2264 qn),\nand p < q stands for (p \u2264 q)\u2227\u00ac(q \u2264 p). In second-order logic, we apply the same notation to tuples of predicate variables.\nLet p be a list of distinct predicate constants; members of p will be called intensional predicates.9 For each p \u2208 p, choose a predicate variable \u03c5p of the same arity, and let \u03c5p stand for the list of all these variables. For any logic program F , by SMp[F ] we denote the second-order sentence\nF \u2227 \u00ac\u2203\u03c5p((\u03c5p < p) \u2227 F \u22c4(\u03c5p)), (27)\nwhere F \u22c4(\u03c5p) is the formula obtained from F by replacing, for every p \u2208 p, each occurrence of p that is not in the scope of negation with \u03c5p. A model of F is stable (relative to the set p of intensional predicates) if it satisfies SMp[F ]. 10\nExample 3. Let F be the propositional formula \u00acp \u2192 q (the one-rule program q \u2190 not p, in traditional notation). If both p and q are intensional then F \u22c4(\u03c5p, \u03c5q) is\n\u00acp \u2192 \u03c5q,\nso that SMpq [F ] is\n(\u00acp \u2192 q) \u2227 \u00ac\u2203(\u03c5p)(\u03c5q)(((\u03c5p, \u03c5q) < (p, q)) \u2227 (\u00acp \u2192 \u03c5q))\u00b7\nThis formula is equivalent to \u00acp \u2227 q.11 Consequently F has one stable model: p is false and q is true.\nExample 4. Let F be the formula\n\u2200x (\u00acp(x ) \u2192 (q(x ) \u2228 \u00acq(x ))) (28)\n(it can be thought of as a formula representation of the lparse choice rule\n9 This list usually consists of all predicate symbols occurring in the heads of rules; those are the predicates that we \u201cintend to characterize\u201d by the rules of the program. The original definition of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional. 10 We can make two comments about the relation of this treatment of stable models to earlier work. First, if we drop from the definition of SM the words \u201cthat is not in the scope of negation\u201d then it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985). It follows that if a logic program does not contain negation then the class of its stable models is identical to the class of its minimal models. The stipulation in the description of F\u22c4(\u03c5p) that intensional predicates in the scope of negation are not replaced by variables is a reflection of the idea of negation as failure. Second, the operator of SM as defined in (Ferraris et al. 2011) produces, in application to a logic program, a second-order formula that is usually more complex than (27) but is equivalent to it. 11 Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al. 2011).\n{q(X)} :- not p(X)).12 If we take q to be the only intensional predicate then F \u22c4(\u03c5q) is\n\u2200x (\u00acp(x ) \u2192 (\u03c5q(x ) \u2228 \u00acq(x )))\u00b7\nConsequently SMq [F ] is\n\u2200x (\u00acp(x ) \u2192 (q(x ) \u2228 \u00acq(x ))) \u2227 \u00ac\u2203\u03c5q((\u03c5q < q) \u2227 \u2200x (\u00acp(x ) \u2192 (\u03c5q(x ) \u2228 \u00acq(x ))))\u00b7\nThe first conjunctive term here is logically valid and can be dropped. The second is equivalent to the first-order formula \u00ac\u2203x (p(x ) \u2227 q(x )), which reflects the intuitive meaning of the choice rule above: q is an arbitrary set disjoint from p.\nThe relationship between the definition of a stable model given above and the\noperation of answer set solvers is discussed in Section 6.\nIf programs F and G are intuitionistically equivalent then SMp[F ] is equivalent to SMp[G], that is to say, F and G have the same stable models. Moreover, for establishing that F and G have the same stable models we only need to derive F \u2194 G intuitionistically from the excluded middle formulas \u2200\u0303(H \u2228 \u00acH ) for some formulas H that do not contain intensional predicates. This fact follows from (Ferraris et al. 2011, Theorem 5)."}, {"heading": "5 Turning a Causal Theory into a Logic Program", "text": ""}, {"heading": "5.1 Four Types of Causal Rules", "text": "In the rest of the paper, we assume that the bodies of causal rules do not contain implication. This is not an essential limitation, because in classical logic \u2192 can be expressed in terms of other connectives, and the meaning of a causal rule does not change if we replace its body (or head) by a classically equivalent formula.\nHere are four types of rules that we are going to consider, in the order of increasing\ncomplexity of their heads:\n\u2022 The head is \u22a5, that is, the rule is a constraint. Such causal rules will be also\ncalled C-rules.\n\u2022 The head is a literal containing an explainable predicate symbol. These are\nL-rules.\n\u2022 The head has the form L1 \u2194 L2, where each Li is a literal containing an\nexplainable predicate symbol. These are synonymity rules, or S-rules.\n\u2022 The head has the form L1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ln (n \u2265 0), where each Li is a literal\ncontaining an explainable predicate symbol. These are D-rules.\nAll C-rules and L-rules can be viewed also as D-rules, and any S-rule can be replaced with an equivalent pair of D-rules (see Lemma 11 in Section 7.2). Nevertheless, we give special attention here to rules of the first three types, and the reason is that our translation handles such rules in special ways. It appears that\n12 This rule would not be accepted by lparse, however, because it is \u201cnonrestricted.\u201d For a description of the language of lparse see http://www.tcs.hut.fi/Software/ smodels/lparse.ps.\ncausal rules of types C, L, and S will be more important than general D-rules in applications of this work to the automation of reasoning about actions.\nOn the other hand, the possibility of reducing types C, L, and S to type D plays an important role in the proof of the soundness of our translation (Section 7). This is one of the reasons why we are interested in general D-rules.\nThe requirement, in the definitions of types L, S and D, that the literals in the head of the rule contain explainable predicate symbols is not an essential limitation. If, for instance, the predicate symbol in the head of L \u21d0 G is not explainable then this rule can be equivalently replaced by the C-rule \u22a5 \u21d0 G \u2227 L. If a rule has the form\nL1 \u2194 L2 \u21d0 G\nand the predicate symbol in L1 is not explainable then the rule can be replaced by\nL2 \u21d0 G \u2227 L1, L2 \u21d0 G \u2227 L1\u00b7\nIf a rule has the form\nL1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ln \u21d0 G\nand the predicate symbol in L1 is not explainable then the rule can be replaced by\nL2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 Ln \u21d0 G \u2227 L1\u00b7"}, {"heading": "5.2 Translating C-Rules and L-Rules", "text": "The transformation described in this section generalizes McCain\u2019s translation, in the form described in Section 2.4, to first-order causal theories.\nThe operator Trc , which transforms any C-rule into a program rule, is defined\nby the formula\nTrc [\u22a5 \u21d0 G] = \u2200\u0303\u00acG\u00b7\nThe operator Trl , which transforms any L-rule into a program rule, is defined by\nthe formulas\nTrl [p(t) \u21d0 G] = \u2200\u0303(\u00ac\u00acG \u2192 p(t)),\nTrl [\u00acp(t) \u21d0 G] = \u2200\u0303(\u00ac\u00acG \u2192 p\u0302(t))\n(t is a tuple of terms).\nIf T is a causal theory consisting of C-rules and L-rules then its translation Tr[T ]\nis the logic program obtained by conjoining\n\u2022 the rules obtained by applying Trc to the C-rules of T , \u2022 the rules obtained by applying Trl to the L-rules of T , and \u2022 the completeness constraints\n\u2200x\u00ac(p(x) \u2227 p\u0302(x)), \u2200x\u00ac(\u00acp(x) \u2227 \u00acp\u0302(x)) (29)\n(x is a tuple of distinct object variables) for all explainable predicate symbols p of T .\nLet p be the list of explainable predicate symbols p of T , and let p\u0302 be the list of the corresponding predicate symbols p\u0302. Take the union of p and p\u0302 to be the set of intensional predicates. Then the stable models of the logic program Tr[T ] are \u201calmost identical\u201d to the models of T ; the difference is due to the fact that the language of T does not contain the symbols p\u0302. Let CC be the conjunction of all completeness constraints (29). Then the relationship between T and Tr[T ] can be described as follows:\nSMpp\u0302[Tr[T ]] is equivalent to T \u2227CC \u00b7 (30)\nThis claim, expressing the soundness of our translation, is extended in Sections 5.3 and 5.4 to causal theories containing S-rules and D-rules, and its proof is given in Section 7.\nSince the conjunction of formulas (29) is classically equivalent to\n\u2200x(p\u0302(x) \u2194 \u00acp(x)), (31)\nsentence CC can be viewed as the conjunction of explicit definitions of the predicates p\u0302 in terms of the predicates p. Consequently the relationship (30) shows that SMpp\u0302[Tr[T ]] is a definitional extension of T . The models of Tr[T ] that are stable relative to pp\u0302 can be characterized as the models of T extended by the interpretations of the predicates p\u0302 that are provided by definitions (31).\nExample 1, continued. If T is causal theory (1) with both p and q explainable then Tr[T ] is the conjunction of formulas (22). The result of applying the operator SMpqp\u0302q\u0302 to this conjunction is equivalent to\np \u2227 \u00acq \u2227 \u00acp\u0302 \u2227 q\u0302\u00b7\nRecall that T is equivalent to the first half of this conjunction (Section 3). The second half tells us that the truth values of p\u0302, q\u0302 are opposite to the truth values of p, q. In the only stable model of (22), p and q\u0302 are true, and p\u0302 and q are false; if we \u201cforget\u201d the truth values of p\u0302 and q\u0302 then we will arrive at the model of (1).\nExample 2, continued. Our translation turns the causal theory from Example 2 into the conjunction of the rules\n\u00ac\u00ac\u22a4 \u2192 p(a), \u2200x (\u00ac\u00ac\u00acp(x ) \u2192 p\u0302(x )), \u2200x\u00ac(p(x ) \u2227 p\u0302(x )), \u2200x\u00ac(\u00acp(x ) \u2227 \u00acp\u0302(x )),\nor, after intuitionistically equivalent transformations,\np(a), \u2200x (\u00acp(x ) \u2192 p\u0302(x )), \u2200x\u00ac(p(x ) \u2227 p\u0302(x )), \u2200x\u00ac(\u00acp(x ) \u2227 \u00acp\u0302(x ))\u00b7\nThe result of applying SMpp\u0302 to the conjunction of these formulas is equivalent to the conjunction of (26) with the formula \u2200x (p\u0302(x ) \u2194 \u00acp(x )), which says that p\u0302 is the complement of p.\nExample 5. Consider the following causal rules:\non1(x ) \u21d0 toggle(x ) \u2227 \u00acon0(x ),\n\u00acon1(x ) \u21d0 toggle(x ) \u2227 on0(x ),\non1(x ) \u21d0 on0(x ) \u2227 on1(x ),\n\u00acon1(x ) \u21d0 \u00acon0(x ) \u2227 \u00acon1(x )\u00b7\n(32)\nThe first pair of rules describes the effect of toggling a switch x : this action causes the fluent on(x ) at time 1 to take the value opposite to its value at time 0. The second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by postulating that if the value of that fluent at time 1 is equal to its previous value then there is a cause for this. (Inertia, in the sense of commonsense reasoning, is the cause.) Let T be the causal theory with rules (32) and with on1 as the only explainable symbol. Using literal completion, we can check that T is equivalent to\n\u2200x (on1(x ) \u2194 ((on0(x ) \u2227 \u00actoggle(x )) \u2228 (\u00acon0(x ) \u2227 toggle(x ))))\u00b7 (33)\nOur translation turns T into the conjunction of the rules\n\u2200x (\u00ac\u00ac(toggle(x ) \u2227 \u00acon0(x )) \u2192 on1(x )), \u2200x (\u00ac\u00ac(toggle(x ) \u2227 on0(x )) \u2192 o\u0302n1(x )), \u2200x (\u00ac\u00ac(on0(x ) \u2227 on1(x )) \u2192 on1(x )), \u2200x (\u00ac\u00ac(\u00acon0(x ) \u2227 \u00acon1(x )) \u2192 o\u0302n1(x )), \u2200x\u00ac(on1(x ) \u2227 o\u0302n1(x )), \u2200x\u00ac(\u00acon1(x ) \u2227 \u00aco\u0302n1(x )),\n(34)\nor, equivalently,13\n\u2200x (toggle(x ) \u2227 \u00acon0(x ) \u2192 on1(x )), \u2200x (toggle(x ) \u2227 on0(x ) \u2192 o\u0302n1(x )), \u2200x (on0(x ) \u2227 \u00aco\u0302n1(x ) \u2192 on1(x )), \u2200x (\u00acon0(x ) \u2227 \u00acon1(x ) \u2192 o\u0302n1(x )), \u2200x\u00ac(on1(x ) \u2227 o\u0302n1(x )), \u2200x\u00ac(\u00acon1(x ) \u2227 \u00aco\u0302n1(x ))\u00b7\n(35)\nThe result of applying SMon1o\u0302n1 to this program is equivalent to the conjunction of (33) with the formula \u2200x (o\u0302n1(x ) \u2194 \u00acon1(x )), which says that o\u0302n1 is the complement of on1.\nExample 6. The constraint\n\u22a5 \u21d0 toggle(badswitch)\nexpresses that badswitch is stuck: the action of toggling it is not executable. If we add this constraint to the causal theory from Example 5 then the rule\n\u00actoggle(badswitch)\n13 Removing the double negations in the first two lines of (34) is possible because neither toggle nor on0 is intensional (see the comment on equivalent transformations of logic programs at the end of Section 4). In a similar way, the antecedent of the third impication in (34) can be replaced by on0(x) \u2227 \u00ac\u00acon1(x); the equivalence between \u00ac\u00acon1(x) and \u00aco\u0302n1(x) is intuitionistically entailed by the last two lines of (34). The fourth line of (34) is simplified in a similar way.\nwill be added to its translation (35).\nThe bodies of causal rules in Examples 5 and 6 are syntactically simple: they are conjunctions of literals. The general definitions of a C-rule and an L-rule do not impose any restrictions on the form of the body, and in applications of causal logic to formalizing commonsense knowledge this generality is often essential. For instance, the statement \u201ceach position must have at least one neighbor\u201d in the landscape structure of the Zoo World14 would be represented in causal logic by a C-rule with a quantifier in the body."}, {"heading": "5.3 Translating S-Rules", "text": "We will turn now to translating synonymity rules (Section 5.1). The operator Trs , transforming any such rule into a logic program, is defined by the formulas\nTrs [p1(t 1) \u2194 p2(t2) \u21d0 G] = Trs [\u00acp1(t1) \u2194 \u00acp2(t2) \u21d0 G]\n= \u2200\u0303(\u00ac\u00acG \u2227 p1(t1) \u2192 p2(t2)) \u2227 \u2200\u0303(\u00ac\u00acG \u2227 p2(t2) \u2192 p1(t1))\u2227\n\u2200\u0303(\u00ac\u00acG \u2227 p\u03021(t1) \u2192 p\u03022(t2)) \u2227 \u2200\u0303(\u00ac\u00acG \u2227 p\u03022(t2) \u2192 p\u03021(t1)),\nTrs [\u00acp1(t1) \u2194 p2(t2) \u21d0 G] = Trs [p1(t1) \u2194 \u00acp2(t2) \u21d0 G]\n= \u2200\u0303(\u00ac\u00acG \u2227 p\u03021(t1) \u2192 p2(t2)) \u2227 \u2200\u0303(\u00ac\u00acG \u2227 p2(t2) \u2192 p\u03021(t1))\u2227\n\u2200\u0303(\u00ac\u00acG \u2227 p1(t1) \u2192 p\u03022(t2)) \u2227 \u2200\u0303(\u00ac\u00acG \u2227 p\u03022(t2) \u2192 p1(t1))\n(t1, t2 are tuples of terms). The definition of program Tr[T ] from Section 5.2 is extended to causal theories that may contain S-rules, besides C-rules and L-rules, by adding that Tr[T ] includes also\n\u2022 the rules obtained by applying Trs to the S-rules of T .\nExample 7. Extend the theory from Example 5 by the rule\ndark \u2194 \u00acon1(myswitch) \u21d0 \u22a4, (36)\nwhere dark is explainable. The corresponding logic program is obtained from (35) by adding the rules\nd\u0302ark \u2192 on1(myswitch), on1(myswitch) \u2192 d\u0302ark , dark \u2192 o\u0302n1(myswitch), o\u0302n1(myswitch) \u2192 dark , \u00ac(dark \u2227 d\u0302ark ),\n\u00ac(\u00acdark \u2227 \u00acd\u0302ark )\u00b7\n(37)\nWe will see that the soundness property (30) holds for arbitary causal theories\nconsisting of rules of types C, L, and S.\n14 The challenge of formalizing the Zoo World was proposed as part of the Logic Modelling Workshop (http:/www/ida.liu.se/ext/etai/lmw/). The possibility of addressing this challenge using CCalc is discussed in (Akman et al. 2004, Section 4)."}, {"heading": "5.4 Translating D-Rules", "text": "A D-rule (Section 5.1) has the form\n\u2228\nA\u2208Pos\nA \u2228 \u2228\nA\u2208Neg\n\u00acA \u21d0 G (38)\nfor some sets Pos, Neg of atomic formulas.\nIf A is an atomic formula p(t), where p \u2208 p and t is a tuple of terms, then by A\u0302 we will denote the formula p\u0302(t). The operator Trd transforms D-rule (38) into the program rule\n\u2200\u0303  \u00ac\u00acG \u2227 \u2227\nA\u2208Pos\n(A\u0302 \u2228 \u00acA\u0302) \u2227 \u2227\nA\u2208Neg\n(A \u2228 \u00acA) \u2192 \u2228\nA\u2208Pos\nA \u2228 \u2228\nA\u2208Neg\nA\u0302   \u00b7 (39)\nExample 8. The result of applying Trd to the D-rule\np \u2228 \u00acq \u2228 \u00acr \u21d0 s\nis\n\u00ac\u00acs \u2227 (p\u0302 \u2228 \u00acp\u0302) \u2227 (q \u2228 \u00acq) \u2227 (r \u2228 \u00acr) \u2192 p \u2228 q\u0302 \u2228 r\u0302 \u00b7\nThe number of \u201cexcluded middle formulas\u201d conjoined with \u00ac\u00acG in (39) equals the number of disjunctive terms in the head of D-rule (38). In particular, if (38) is an L-rule then the antecedent of (39) contains one such formula. For instance, in application to the first rule of (1) Trd produces the program rule\n\u00ac\u00ac\u00acq \u2227 (p\u0302 \u2228 \u00acp\u0302) \u2192 p,\nwhich is more complex than the first rule of (22).\nFor a fixed collection p of explainable symbols, let C , L, S , and D be finite sets of causal rules of types C, L, S, and D respectively. By Tr[C ,L, S ,D ] we denote the logic program obtained by conjoining\n\u2022 the rules obtained by applying Trc to all rules from C , \u2022 the rules obtained by applying Trl to all rules from L, \u2022 the programs obtained by applying Trs to all rules from S , \u2022 the rules obtained by applying Trd to all rules from D , \u2022 the completeness constraints (29) for all explainable symbols p.\nOur most general form of the soundness theorem, proved in Section 7, asserts that\nSMpp\u0302[Tr[C ,L, S ,D ]] is equivalent to T \u2227 CC (40)\nfor the causal theory T with the set of rules C\u222aL\u222aS\u222aD . In the special case when D is empty this theorem turns into the assertion stated at the end of Section 5.3."}, {"heading": "6 Using Answer Set Solvers to Generate Models of a Causal Theory", "text": "The discussion of answer set solvers in this section, as almost any discussion of software, is somewhat informal. We assume here that the first-order language under consideration does not contain function constants of nonzero arity.\nAn answer set solver can be viewed as a system for generating stable models in the sense of Section 4, with three caveats. First, currently available solvers require that the input program have a syntactic form that is much more restrictive than the syntax of first-order logic.15 Preprocessing based on intuitionistically equivalent transformations often helps us alleviate this difficulty. There exists a tool, called f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general kind into logic programs accepted by lparse. The rules produced by the process described in the previous section have no existential quantifiers in their heads, and all quantifiers in their bodies are in the scope of negation. Consequently, these rules satisfy a syntactic condition that guarantees the correctness of the translation implemented in f2lp.\nSecond, answer set solvers represent stable models by sets of ground atoms. To introduce such a representation, we usually choose a finite set of object constants that includes all object constants occurring in the program, and restrict attention to Herbrand interpretations of the extended language. The #domain construct of lparse16 can be used to specify the object constants constituting the domain of the variables in the program.\nThird, most existing answer set solvers are unaware of the possibility of nonintensional (or extensional) predicates. Treating a predicate constant as extensional can be simulated using a choice rule (Ferraris et al. 2011, Theorem 2). There is also another approach to overcoming this limitation. Take a conjunction E of some ground atoms containing extensional predicates, and assume that we are interested in the Herbrand stable models of a program F that interpret the extensional predicates in accordance with E (every atom from E is true; all other atoms containing extensional predicates are false). Under some syntactic conditions,17 these stable models are identical to the Herbrand stable models of F \u2227 E with all predicate constants treated as intensional. This can be proved using the splitting theorem from (Ferraris et al. 2009).\nExample 4, continued. We would like to find the stable models of (28), with q intensional, that have the universe {a, b, c, d} and make p true on a, b and false on c, d . This is the same as to look for the Herbrand stable models of the formula\n\u2200x (\u00acp(x ) \u2192 (q(x ) \u2228 \u00acq(x ))) \u2227 p(a) \u2227 p(b),\nwith c and d viewed as object constants of the language along with a and b, and with both p and q taken to be intensional.\n15 They also require that the input satisfy some safety conditions. See, for instance, Chapter 3 of the dlv manual, http://www.dbai.tuwien.ac.at/proj/dlv/man/. 16 See Footnote (12). 17 Specifically, under the assumption that every occurrence of every extensional predicate in F is\nin the scope of negation or in the antecedent of an implication.\nA representation of this example in the language of lparse is shown in Figure 1. The auxiliary predicate u describes the universe of the interpretations that we are interested in. The first line is shorthand for\nu(a). u(b). u(c). u(d).\nand the last line is understood by lparse in a similar way.\nGiven this input, the answer set solver smodels generates 4 stable models, rep-\nresenting the subsets of {a, b, c, d} that are disjoint from {a, b}:\nAnswer: 1 Stable Model: p(b) p(a) u(d) u(c) u(b) u(a) Answer: 2 Stable Model: p(b) p(a) q(d) u(d) u(c) u(b) u(a) Answer: 3 Stable Model: p(b) p(a) q(c) u(d) u(c) u(b) u(a) Answer: 4 Stable Model: p(b) p(a) q(d) q(c) u(d) u(c) u(b) u(a)\nIn application to the logic program obtained from a causal theory T as described in Section 5, this process often allows us to find the models of T with a given universe and given extents of extensional predicates.\nExample 7, continued. There are two switches, myswitch and hisswitch . It is dark in my room at time 1 if and only if myswitch is not on at time 1. At time 0, both switches are on; then hisswitch is toggled, and myswitch is not. Is it dark in my room at time 1? We would like to answer this question using answer set programming.\nThis example of commonsense reasoning involves inertia (the value of the fluent on(myswitch) does not change because this fluent is not affected by the action that is executed) and indirect effects of actions: whether or not it is dark in the room at time 1 after performing some actions is determined by the effect of these actions on the fluent on(myswitch).\nMathematically, we are talking here about the causal theory T with rules (32) and (36), with the object constant hisswitch added to the language, and with the explainable symbols on1 and dark . We are interested in the Herbrand models of T in which the extents of the extensional predicates are described by the atoms\non0(myswitch), on0(hisswitch), toggle(hisswitch)\u00b7\nAs we have seen, the logic program Tr[T ] is equivalent to the conjunction of\nrules (35) and (37). The corresponding lparse input file is shown in Figure 2. In this file, the \u201ctrue negation\u201d symbol - is used in the ASCII representations of the symbols o\u0302n1 and d\u0302ark ; the lparse counterparts of the rules\n\u2200x\u00ac(on1(x ) \u2227 o\u0302n1(x )), \u00ac(dark \u2227 d\u0302ark )\nare dropped, because such \u201ccoherence\u201d conditions are verified by the system automatically.\nGiven this input, smodels generates the only model of T satisfying the given\nconditions:\nAnswer: 1 Stable Model: -on1(hisswitch) on1(myswitch) -dark toggle(hisswitch) on0(hisswitch) on0(myswitch) u(hisswitch) u(myswitch)\nThe presence of -dark in this model tells us that it is not dark in the room at time 1.\nThe example above is an example of \u201cone-step temporal projection\u201d\u2014predicting the value of a fluent after performing a single action in a given state. Some other kinds of temporal reasoning and planning can be performed by generating models of simple modifications of the given causal theory (Giunchiglia et al. 2004, Section 3.3); this is one of the ideas behind the design of CCalc and coala. McCain\u2019s translation reviewed in the introduction and its generalization presented in Section 5 allow us to solve such problems automatically using an answer set solver."}, {"heading": "7 Proof of Soundness", "text": "To prove claim (40), which expresses the soundness of our translation, we will first establish it for the case when C = L = S = \u2205 (Section 7.1). In this \u201cleading special case\u201d all rules of the given causal theory are D-rules, and they are converted to program rules using the translation Trd . Then we will derive the soundness theorem in full generality (Section 7.2)."}, {"heading": "7.1 Leading Special Case", "text": "Let T be a finite set of causal rules of the form (38). Let \u03a0 be the conjunction of the corresponding program rules (39), and let CC , as before, stand for the conjunction of the completeness constraints (29) for all explainable symbols p of T . We want to show that\nSMpp\u0302[\u03a0 \u2227 CC ] is equivalent to T \u2227 CC \u00b7 (41)\nThe key steps in the proof below are Lemma 5 (one half of the equivalence) and\nLemma 8 (the other half).\nIn the statement of the following lemma, \u00acp stands for the list of predicate expressions18 \u03bbx\u00acp(x), where x is a list of distinct object variables, for all p from p. By \u03c5p, \u03c5p\u0302 we denote the lists of predicate variables used in the second-order formula SMpp\u0302[\u03a0 \u2227 CC ] (see Section 4).\nLemma 1 Formula (\u03c5p, \u03c5p\u0302) < (p,\u00acp) is equivalent to \u2228\np\u2208p\n(((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u2203x(\u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x)))\u00b7"}, {"heading": "Proof", "text": "Note first that\n(\u03c5p, \u03c5p\u0302) < (p,\u00acp)\n\u21d4 ((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac ((p,\u00acp) \u2264 (\u03c5p, \u03c5p\u0302)) \u21d4 ((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u2228\np\u2208p \u2203x((p(x) \u2227 \u00ac\u03c5p(x)) \u2228 (\u00acp(x) \u2227 \u00ac\u03c5p\u0302(x)))\n\u21d4 \u2228\np\u2208p(((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u2203x((p(x) \u2227 \u00ac\u03c5p(x)) \u2228 (\u00acp(x) \u2227 \u00ac\u03c5p\u0302(x))))\u00b7\nThe disjunction after \u2203x is equivalent to\n(p(x) \u2228 \u00ac\u03c5p\u0302(x)) \u2227 (\u00ac\u03c5p(x) \u2228 \u00acp(x)) \u2227 (\u00ac\u03c5p(x) \u2228 \u00ac\u03c5p\u0302(x))\u00b7 (42)\nSince (\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp) entails\n\u03c5p(x) \u2192 p(x) and \u03c5p\u0302(x) \u2192 \u00acp(x),\nthe first conjunctive term of (42) can be rewritten as \u00ac\u03c5p\u0302(x), and the second term as \u00ac\u03c5p(x), so that (42) will turn into \u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x).\n18 See (Lifschitz 1994, Section 3.1).\nFor any formula F , by F\u03a31 we denote the formula\nF (\u03c5p)(\u03c5p\u0302) (\u03c5p\u2227p)(\u00ac\u03c5p\u2227\u00acp)\nwhere \u03c5p \u2227 p is understood as the list of predicate expressions\n\u03bbx(\u03c5p(x) \u2227 p(x))\nfor all p \u2208 p, and \u00ac\u03c5p \u2227 \u00acp is understood in a similar way.19\nLemma 2 Formula\n((\u03c5p, \u03c5p\u0302) < (p,\u00acp))\u03a31\nis equivalent to \u03c5p 6= p."}, {"heading": "Proof", "text": "In view of Lemma 1, ((\u03c5p, \u03c5p\u0302) < (p,\u00acp))\u03a31 is equivalent to the disjunction of the formulas(\u2227 p\u2208p \u2200x(\u03c5p(x) \u2192 p(x))\u03a31 ) \u2227 (\u2227 p\u2208p \u2200x(\u03c5p\u0302(x) \u2192 \u00acp(x))\u03a31 )\n\u2227 \u2203x(\u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x))\u03a31 (43)\nfor all p \u2208 p. It is easy to verify that\n(\u03c5p(x) \u2192 p(x))\u03a31 = (\u03c5p(x) \u2227 p(x) \u2192 p(x)) \u21d4 \u22a4 ,\n(\u03c5p\u0302(x) \u2192 \u00acp(x))\u03a31 = (\u00ac\u03c5p(x) \u2227 \u00acp(x) \u2192 \u00acp(x)) \u21d4 \u22a4,\n(\u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x))\u03a31 \u21d4 ((\u00ac\u03c5p(x) \u2228 \u00acp(x)) \u2227 \u00ac(\u00ac\u03c5p(x) \u2227 \u00acp(x)))\n\u21d4 (\u03c5p(x) \u2194 \u00acp(x)) \u21d4 \u00ac(\u03c5p(x) \u2194 p(x))\u00b7\nTherefore (43) is equivalent to \u2203x\u00ac(\u03c5p(x) \u2194 p(x)), so that the disjunction of all formulas (43) is equivalent to \u03c5p 6= p.\nIf A is an atomic formula p(t), where p \u2208 p and t is a tuple of terms, then we will write \u03c5A for \u03c5p(t), and A\u0302 for \u03c5p\u0302(t). By \u2200\u0303objF we denote the formula \u2200xF , where x is list of all free object variables of F (\u201cobject-level universal closure\u201d).\nDefine H (\u03c5p, \u03c5p\u0302) to be the conjunction of the implications\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n((\u03c5A\u0302 \u2228 A) \u2192 \u03c5A) \u2228 \u2228\nA\u2208Neg\n((\u03c5A \u2228 \u00acA) \u2192 \u03c5A\u0302)   (44)\nfor all rules (38) in T .\nLemma 3 Formula SMpp\u0302[\u03a0 \u2227 CC ] is equivalent to\n\u03a0 \u2227 CC \u2227 \u2200(\u03c5p)(\u03c5p\u0302)(((\u03c5p, \u03c5p\u0302) < (p,\u00acp)) \u2192 \u00acH (\u03c5p, \u03c5p\u0302))\u00b7 (45)\n19 For the definition of F p\n\u03c5p see Section 3."}, {"heading": "Proof", "text": "Every occurrence of every intensional predicate in CC is in the scope of a negation. Consequently SMpp\u0302[\u03a0 \u2227 CC ] is\n\u03a0 \u2227 CC \u2227 \u00ac\u2203(\u03c5p)(\u03c5p\u0302)(((\u03c5p, \u03c5p\u0302) < (p, p\u0302)) \u2227 \u03a0\u22c4(\u03c5p, \u03c5p\u0302) \u2227 CC ),\nwhich is equivalent to\n\u03a0 \u2227 CC \u2227 \u2200(\u03c5p)(\u03c5p\u0302)(((\u03c5p, \u03c5p\u0302) < (p,\u00acp)) \u2192 \u00ac\u03a0\u22c4(\u03c5p, \u03c5p\u0302))\u00b7\nWe will conclude the proof by showing that CC entails\n\u03a0\u22c4(\u03c5p, \u03c5p\u0302) \u2194 H (\u03c5p, \u03c5p\u0302)\u00b7\nThe left-hand side of this equivalence is the conjunction of the formulas\n\u2200\u0303obj\n \u00ac\u00acG \u2227 \u2227\nA\u2208Pos\n(\u03c5A\u0302 \u2228 \u00acA\u0302) \u2227 \u2227\nA\u2208Neg\n(\u03c5A \u2228 \u00acA) \u2192 \u2228\nA\u2208Pos\n\u03c5A \u2228 \u2228\nA\u2208Neg\n\u03c5A\u0302\n \nfor all rules (38) in T . Under the assumption CC this formula can be rewritten as\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n\u00ac(\u03c5A\u0302 \u2228A) \u2228 \u2228\nA\u2208Neg\n\u00ac(\u03c5A \u2228 \u00acA) \u2228 \u2228\nA\u2208Pos\n\u03c5A \u2228 \u2228\nA\u2208Neg\n\u03c5A\u0302   \u00b7\nThe last formula is equivalent to\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n(\u00ac(\u03c5A\u0302 \u2228 A) \u2228 \u03c5A) \u2228 \u2228\nA\u2208Neg\n(\u00ac(\u03c5A \u2228 \u00acA) \u2228 \u03c5A\u0302)   \u00b7\nand consequently to (44).\nLemma 4 T \u2020(\u03c5p) is equivalent to H (\u03c5p, \u03c5p\u0302)\u03a31."}, {"heading": "Proof", "text": "Formula T \u2020(\u03c5p) is the conjunction of the formulas\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n\u03c5A \u2228 \u2228\nA\u2208Neg\n\u00ac\u03c5A   (46)\nfor all rules (38) in T . On the other hand, H (\u03c5p, \u03c5p\u0302)\u03a31 is the conjunction of the formulas\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n((\u03c5A\u0302 \u2228 A) \u2192 \u03c5A)\u03a31 \u2228 \u2228\nA\u2208Neg\n((\u03c5A \u2228 \u00acA) \u2192 \u03c5A\u0302)\u03a31\n  (47)\nfor all rules (38) in T . It remains to observe that\n((\u03c5A\u0302 \u2228 A) \u2192 \u03c5A)\u03a31 = (\u00ac\u03c5A \u2227 \u00acA) \u2228 A \u2192 \u03c5A \u2227A\n\u21d4 \u00ac\u03c5A \u2228 A \u2192 \u03c5A \u2227 A \u21d4 (\u03c5A \u2227 \u00acA) \u2228 (\u03c5A \u2227 A) \u21d4 \u03c5A,\nand that, similarly, ((\u03c5A \u2228 \u00acA) \u2192 \u03c5A\u0302)\u03a31 is equivalent to \u00ac\u03c5A.\nLemma 5 SMpp\u0302[\u03a0 \u2227 CC ] |= T \u2227 CC ."}, {"heading": "Proof", "text": "Recall that, according to Lemma 3, SMpp\u0302[\u03a0\u2227CC ] is equivalent to (45). The second conjunctive term of (45) is CC . The first conjunctive term is equivalent to T \u2020(p). From the other two terms we conclude:\n\u2200\u03c5p(((\u03c5p, \u03c5p\u0302) < (p, p\u0302))\u03a31 \u2192 \u00acH (\u03c5p, \u03c5p\u0302)\u03a31)\u00b7\nBy Lemma 2 and Lemma 4, this formula is equivalent to\n\u2200\u03c5p((\u03c5p 6= p) \u2192 \u00acT \u2020(\u03c5p)),\nand consequently to\n\u2200\u03c5p(T \u2020(\u03c5p) \u2192 (\u03c5p = p))\u00b7\nThe conjunction of the last formula with T \u2020(p) is equivalent to (24).\nFor any formula F , by F\u03a32 we denote the formula\nF\u03c5p(((\u03c5p,\u03c5p\u0302)\u2264(p,\u00acp))\u2227\u00ac\u03c5p\u2227\u00ac\u03c5p\u0302)\u2194\u00acp\nwhere the subscript\n(((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac\u03c5p \u2227 \u00ac\u03c5p\u0302) \u2194 \u00acp\nis understood as the list of predicate expressions\n\u03bbx((((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x)) \u2194 \u00acp(x))\nfor all p \u2208 p.\nLemma 6 Formula\n(\u03c5p 6= p)\u03a32\nis equivalent to (\u03c5p, \u03c5p\u0302) < (p,\u00acp)."}, {"heading": "Proof", "text": "Formula (\u03c5p 6= p)\u03a32 is equivalent to\n\u2228\np\u2208p\n\u2203x(\u03c5p(x) \u2194 \u00acp(x))\u03a32\nthat is, \u2228\np\u2208p\n\u2203x((((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x) \u2194 \u00acp(x)) \u2194 \u00acp(x))\u00b7\nThis formula can be equivalently rewritten as \u2228\np\u2208p\n(((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u2203x(\u00ac\u03c5p(x) \u2227 \u00ac\u03c5p\u0302(x))),\nwhich is equivalent to (\u03c5p, \u03c5p\u0302) < (p,\u00acp) by Lemma 1.\nLemma 7 The implication\n(\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp) \u2192 (T \u2020(\u03c5p)\u03a32 \u2194 H (\u03c5p, \u03c5p\u0302))\nis logically valid."}, {"heading": "Proof", "text": "Recall that T \u2020(\u03c5p) is the conjunction of implications (46) for all rules (38) in T . Consequently T \u2020(\u03c5p)\u03a32 is the conjunction of the formulas\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n(\u03c5A)\u03a32 \u2228 \u2228\nA\u2208Neg\n\u00ac(\u03c5A)\u03a32\n  ,\nthat is to say,\n\u2200\u0303obj (G \u2192 \u2228\nA\u2208Pos((((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac\u03c5A \u2227 \u00ac\u03c5A\u0302) \u2194 \u00acA)\u2228\u2228 A\u2208Neg \u00ac((((\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp)) \u2227 \u00ac\u03c5A \u2227 \u00ac\u03c5A\u0302) \u2194 \u00acA)\u00b7\nUnder the assumption\n(\u03c5p, \u03c5p\u0302) \u2264 (p,\u00acp) (48)\nthe last formula can be equivalently rewritten as\n\u2200\u0303obj\n G \u2192 \u2228\nA\u2208Pos\n((\u03c5A \u2228 \u03c5A\u0302) \u2194 A) \u2228 \u2228\nA\u2208Neg\n((\u03c5A \u2228 \u03c5A\u0302) \u2194 \u00acA)   \u00b7\nIt remains to check that, under assumption (48),\n(\u03c5A \u2228 \u03c5A\u0302) \u2194 A (49)\ncan be equivalently rewritten as\n\u03c5A\u0302 \u2228 A \u2192 \u03c5A, (50)\nand\n\u03c5A \u2228 \u03c5A\u0302 \u2194 \u00acA (51)\ncan be rewritten as\n\u03c5A \u2228 \u00acA \u2192 \u03c5A\u0302\u00b7 (52)\nFormula (49) is equivalent to\n(\u03c5A \u2192 A) \u2227 (\u03c5A\u0302 \u2192 A) \u2227 (A \u2192 \u03c5A \u2228 \u03c5A\u0302)\u00b7 (53)\nSince assumption (48) entails \u03c5A \u2192 A and \u03c5A\u0302 \u2192 \u00acA, formula (53) can be rewritten as\n\u00ac\u03c5A\u0302 \u2227 (A \u2192 \u03c5A)\u00b7 (54)\nOn the other hand, formula (50) is equivalent to\n(\u03c5A\u0302 \u2192 \u03c5A) \u2227 (A \u2192 \u03c5A),\nwhich, under assumption (48), can be rewritten as (54) as well. In a similar way, each of the formulas (51), (52) can be transformed into\n\u00ac\u03c5A \u2227 (\u00acA \u2192 \u03c5A\u0302) \u00b7\nLemma 8 T \u2227CC |= SMpp\u0302[\u03a0 \u2227 CC ]."}, {"heading": "Proof", "text": "Recall that T is equivalent to\nT \u2020(p) \u2227 \u2200\u03c5p(T \u2020(\u03c5p) \u2192 (\u03c5p = p))\u00b7 (55)\nSince the first conjunctive term is equivalent to \u03a0, T \u2227 CC entails\n\u03a0 \u2227 CC \u00b7 (56)\nFrom the second conjunctive term of (55) we conclude\nT \u2020(\u03c5p)\u03a32 \u2192 (\u03c5p = p)\u03a32\nand consequently\n\u2200(\u03c5p)(\u03c5p\u0302)((\u03c5p 6= p)\u03a32 \u2192 \u00acT \u2020(\u03c5p)\u03a32)\u00b7\nBy Lemma 6, this is equivalent to\n\u2200(\u03c5p)(\u03c5p\u0302)(((\u03c5p, \u03c5p\u0302) < (p,\u00acp)) \u2192 \u00acT \u2020(\u03c5p)\u03a32)\nand, by Lemma 7, to\n\u2200(\u03c5p)(\u03c5p\u0302)(((\u03c5p, \u03c5p\u0302) < (p,\u00acp)) \u2192 \u00acH (\u03c5p, \u03c5p\u0302))\u00b7\nBy Lemma 3, the conjunction of this formula with (56) is equivalent to sentence SMpp\u0302[\u03a0 \u2227 CC ].\nAssertion (41) follows from Lemmas 5 and 8.\n7.2 General Case\nLemma 9 For any C-rule R, Trc [R] is intuitionistically equivalent to Trd [R]."}, {"heading": "Proof", "text": "If R is \u22a5 \u21d0 G then Trc [R] is \u2200\u0303\u00acG, and Trd [R] is \u2200\u0303(\u00ac\u00acG \u2192 \u22a5).\nLemma 10 For any L-rule R, the conjunction CC of completeness constraints intuitionistically entails\nTrl [R] \u2194 Trd [R]\u00b7"}, {"heading": "Proof", "text": "If R is p(t) \u21d0 G then Trl [R] is\n\u2200\u0303(\u00ac\u00acG \u2192 p(t)),\nand Trd [R] is\n\u2200\u0303(\u00ac\u00acG \u2227 (p\u0302(t) \u2228 \u00acp\u0302(t)) \u2192 p(t))\u00b7\nSince CC intuitionistically entails\n\u00ac(p(t) \u2194 p\u0302(t)), (57)\nit is sufficient to check that p(t) can be derived from (57) and\np\u0302(t) \u2228 \u00acp\u0302(t) \u2192 p(t) (58)\nby the deductive means of intuitionistic propositional logic. Since (58) is equivalent to p(t) in classical propositional logic, it is easy to see that \u00acp\u0302(t) can be derived from (57) and (58) in classical propositional logic. By Glivenko\u2019s theorem,20 it follows that it can be derived intuitionistically as well. Since p(t) is intuitionistically derivable from (58) and \u00acp\u0302(t), we can conclude that p(t) is intuitionistically derivable from (57) and (58).\nThe case when R is \u00acp(t) \u21d0 G is similar.\nLemma 11 If R is an S-rule\nL1 \u2194 L2 \u21d0 G (59)\nand R1, R2 are the D-rules\nL1 \u2228 L2 \u21d0 G and L1 \u2228 L2 \u21d0 G (60)\nthen the conjunction CC of completeness constraints intuitionistically entails\nTrs [R] \u2194 Trd [R1] \u2227Trd [R2]\u00b7"}, {"heading": "Proof", "text": "If each of the literals Li is an atom Ai then Trs [R] is the conjunction of the formulas\n\u2200\u0303(\u00ac\u00acG \u2227A1 \u2192 A2), \u2200\u0303(\u00ac\u00acG \u2227A2 \u2192 A1), \u2200\u0303(\u00ac\u00acG \u2227 A\u03021 \u2192 A\u03022), \u2200\u0303(\u00ac\u00acG \u2227 A\u03022 \u2192 A\u03021),\n(61)\nTrd [R1] is\n\u2200\u0303(\u00ac\u00acG \u2227 (A\u03021 \u2228 \u00acA\u03021) \u2227 (A2 \u2228 \u00acA2) \u2192 A1 \u2228 A\u03022), (62)\n20 This theorem (Glivenko 1929), (Mints 2000, Theorem 3.1) asserts that if a formula beginning with negation can be derived from a set \u0393 of formulas in classical propositional logic then it can be derived from \u0393 in intuitionistic propositional logic as well.\nand Trd [R2] is\n\u2200\u0303(\u00ac\u00acG \u2227 (A1 \u2228 \u00acA1) \u2227 (A\u03022 \u2228 \u00acA\u03022) \u2192 A\u03021 \u2228 A2)\u00b7 (63)\nWe need to show that CC intuitionistically entails the equivalence between the conjunction of formulas (61) and the conjunction of formulas (62), (63). Since CC intuitionistically entails\n\u00ac(A1 \u2194 A\u03021) (64)\nand\n\u00ac(A2 \u2194 A\u03022), (65)\nit is sufficient to check that the conjunction of formulas (64), (65),\nA1 \u2194 A2 (66)\nand\nA\u03021 \u2194 A\u03022 (67)\nis equivalent in intuitionistic propositional logic to the conjunction of formulas (64), (65),\n(A\u03021 \u2228 \u00acA\u03021) \u2227 (A2 \u2228 \u00acA2) \u2192 A1 \u2228 A\u03022 (68)\nand\n(A1 \u2228 \u00acA1) \u2227 (A\u03022 \u2228 \u00acA\u03022) \u2192 A\u03021 \u2228 A2\u00b7 (69)\nLeft-to-right: Assume (64)\u2013(67) and\n(A\u03021 \u2228 \u00acA\u03021) \u2227 (A2 \u2228 \u00acA2); (70)\nour goal is to derive intuitionistically A1 \u2228 A\u03022. Consider two cases, in accordance with the first disjunction in (70). Case 1: A\u03021. Then, by (67), A\u03022, and consequently A1\u2228A\u03022. Case 2: \u00acA\u03021. Consider two cases, in accordance with the second disjunction in (70). Case 2.1: A2. Then, by (66), A1, and consequently A1\u2228 A\u03022. Case 2.2: \u00acA2. Then, by (66), \u00acA1, which contradicts (64).\nThus we proved that (68) is intuitionistically derivable from (64)\u2013(67). The proof\nfor (69) is similar.\nRight-to-left: Let \u0393 be the set consisting of formulas (64), (65), (68), (69) and A1. We claim that A2 can be derived from \u0393 in intuitionistic propositional logic. Note that, classically,\n\u2022 Formula (64) is equivalent to A1 \u2194 \u00acA\u03021, \u2022 Formula (65) is equivalent to A2 \u2194 \u00acA\u03022, and \u2022 Formula (69) is equivalent to A\u03021 \u2228 A2.\nIt follows that \u00acA\u03022 is derivable from \u0393 in classical propositional logic. By Glivenko\u2019s theorem, it follows that \u00acA\u03022 is derivable from \u0393 intuitionistically as well. Hence the antecedent of (69) is an intuitionistic consequence of \u0393, and so is the consequent A\u03021 \u2228 A2. In combination with A1 and (64), this gives us A2.\nWe conclude that A1 \u2192 A2 is intuitionsistically derivable from (64), (65), (68)\nand (69). The derivability of the implication A2 \u2192 A1 from these formulas can be proved in a similar way. Thus (66) is an intuitionistic consequence of (64), (65), (68), and (69).\nThe derivability of (67) from these formulas in propositional intuitionistic logic\nis proved in a similar way.\nThe cases when the literals Li are negative, or when one of them is positive and\nthe other is negative, are similar.\nProof of the soundness property (40). Let C , L, S , and D be sets of causal rules of types C, L, S, and D respectively, and let T be the causal theory with the set of rules C \u222a L \u222a S \u222aD . Consider the causal theory T \u2032 obtained from T by replacing each rule (59) from S with the corresponding rules (60). According to the result (41) of Section 7.1,\nSMpp\u0302[\u03a0 \u2227 CC ] is equivalent to T \u2032 \u2227 CC ,\nwhere \u03a0 is the conjunction of the program rules Trd [R] for all rules R of T \u2032. It is clear that \u03a0 \u2227 CC is Tr[T \u2032], and that T \u2032 is equivalent to T . Consequently\nSMpp\u0302[Tr[T \u2032]] is equivalent to T \u2227CC \u00b7 (71)\nOn the other hand, Lemmas 9, 10 and 11 show that the formulas Tr[T \u2032] and Tr[C ,L, S ,D ] are intuitionistically equivalent to each other, because each of them contains CC as a conjunctive term. It follows that\nSMpp\u0302[Tr[T \u2032]] is equivalent to SMpp\u0302[Tr[C ,L, S ,D ]]\u00b7 (72)\nAssertion (40) follows from (71) and (72)."}, {"heading": "8 Conclusion", "text": "In this paper we generalized McCain\u2019s embedding of definite causal theories into logic programming. We expect that this work will provide a theoretical basis for extending the system coala to more expressive action languages, including the modular action language MAD (Ren 2009). It is essential, from this perspective, that our translation is applicable to synonymity rules, because such rules are closely related to the main new feature of MAD, its import construct.\nOur translation is not applicable to causal rules with quantifiers in the head. It may be possible to extend it to positive occurrences of existential quantifiers, since an existentially quantified formula can be thought of as an infinite disjunction. But the translation would be a formula with positive occurrences of existential quantifiers as well, and it is not clear how to turn such a formula into executable code.\nIn the future, we would like to extend the translation described above to causal theories with explainable function symbols, which correspond to non-Boolean fluents in action languages. Since the definition of a stable model does not allow function symbols to be intensional, such a generalization would have to involve extending the language by auxiliary predicate symbols."}, {"heading": "Acknowledgements", "text": "We are grateful to the anonymous referees for useful comments. Joohyung Lee was partially supported by the National Science Foundation under grant IIS-0916116 and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), through US Army. Yuliya Lierler was supported by a 2010 Computing Innovation Fellowship. Vladimir Lifschitz and Fangkai Yang were supported by the National Science Foundation under grant IIS0712113. All statements of fact, opinion or conclusions contained herein are those of the authors and should not be construed as representing the official views or policies of IARPA, the ODNI or the U.S. Government."}], "references": [{"title": "Representing the Zoo World and the Traffic World in the language of the Causal Calculator", "author": ["V. Akman", "S. Erdo\u011fan", "J. Lee", "V. Lifschitz", "H. Turner"], "venue": "Artificial Intelligence 153(1\u20132), 105\u2013140.", "citeRegEx": "Akman et al\\.,? 2004", "shortCiteRegEx": "Akman et al\\.", "year": 2004}, {"title": "Formal specification and automatic analysis of business processes under authorization constraints: an actionbased approach", "author": ["A. Armando", "E. Giunchiglia", "S.E. Ponta"], "venue": "Proceedings of the 6th International Conference on Trust, Privacy and Security in Digital Business (TrustBus\u201909).", "citeRegEx": "Armando et al\\.,? 2009", "shortCiteRegEx": "Armando et al\\.", "year": 2009}, {"title": "Specifying norm-governed computational societies", "author": ["A. Artikis", "M. Sergot", "J. Pitt"], "venue": "ACM Transactions on Computational Logic 9, 1.", "citeRegEx": "Artikis et al\\.,? 2009", "shortCiteRegEx": "Artikis et al\\.", "year": 2009}, {"title": "Bridging the gap between high-level reasoning and low-level control", "author": ["O. Caldiran", "K. Haspalamutgil", "A. Ok", "C. Palaz", "E. Erdem", "V. Patoglu"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 242\u2013354. Clark, K. 1978. Negation as failure. In Logic and Data Bases, H. Gallaire and J. Minker,", "citeRegEx": "Caldiran et al\\.,? 2009", "shortCiteRegEx": "Caldiran et al\\.", "year": 2009}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 119\u2013131. Ferraris, P. 2006. Causal theories as logic programs. In Proceedings of Workshop on Logic Programming (WLP). 35\u201344. Ferraris, P. 2007. A logic program characterization of causal theories. In Proceedings", "citeRegEx": "Ferraris,? 2005", "shortCiteRegEx": "Ferraris", "year": 2005}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence 175, 236\u2013263.", "citeRegEx": "Ferraris et al\\.,? 2011", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 797\u2013803.", "citeRegEx": "Ferraris et al\\.,? 2009", "shortCiteRegEx": "Ferraris et al\\.", "year": 2009}, {"title": "Coala: a compiler from action languages to ASP", "author": ["M. Gebser", "T. Grote", "T. Schaub"], "venue": "Proceedings of European Conference on Logics in Artificial Intelligence (JELIA). 169\u2013181.", "citeRegEx": "Gebser et al\\.,? 2010", "shortCiteRegEx": "Gebser et al\\.", "year": 2010}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing 9, 365\u2013385.", "citeRegEx": "Gelfond and Lifschitz,? 1991", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Nonmonotonic causal theories", "author": ["E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner"], "venue": "Artificial Intelligence 153(1\u20132), 49\u2013104.", "citeRegEx": "Giunchiglia et al\\.,? 2004", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2004}, {"title": "An action language based on causal explanation: Preliminary report", "author": ["E. Giunchiglia", "V. Lifschitz"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). AAAI Press, 623\u2013630. Glivenko, V. 1929. Sur quelques points de la logique de M. Brouwer. Acad\u00e9mie Royale de Belgique. Bulletins de la Classe des Sciences, se\u2019rie 5 15, 183\u2013188.", "citeRegEx": "Giunchiglia and Lifschitz,? 1998", "shortCiteRegEx": "Giunchiglia and Lifschitz", "year": 1998}, {"title": "Representing synonymity in causal logic and in logic programming", "author": ["J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang"], "venue": "Proceedings of International Workshop on Nonmonotonic Reasoning (NMR).", "citeRegEx": "Lee et al\\.,? 2010", "shortCiteRegEx": "Lee et al\\.", "year": 2010}, {"title": "System F2LP \u2014 computing answer sets of first-order formulas", "author": ["J. Lee", "R. Palla"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). 515\u2013521. Lifschitz, V. 1985. Computing circumscription. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). 121\u2013127.", "citeRegEx": "Lee and Palla,? 2009", "shortCiteRegEx": "Lee and Palla", "year": 2009}, {"title": "Circumscription", "author": ["V. Lifschitz"], "venue": "Handbook of Logic in AI and Logic Programming, D. Gabbay, C. Hogger, and J. Robinson, Eds. Vol. 3. Oxford University Press, 298\u2013352.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "On the logic of causal explanation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence 96, 451\u2013465. Lifschitz, V. 2008. What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence. MIT Press, 1594\u20131597. Lifschitz, V. and Ren, W. 2006. A modular action description language. In Proceedings of National Conference on Artificial Intelligence (AAAI). 853\u2013859.", "citeRegEx": "Lifschitz,? 1997", "shortCiteRegEx": "Lifschitz", "year": 1997}, {"title": "The semantics of variables in action descriptions", "author": ["V. Lifschitz", "W. Ren"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). 1025\u20131030.", "citeRegEx": "Lifschitz and Ren,? 2007", "shortCiteRegEx": "Lifschitz and Ren", "year": 2007}, {"title": "Translating first-order causal theories into answer set programming", "author": ["V. Lifschitz", "F. Yang"], "venue": "Proceedings of the European Conference on Logics in Artificial Intelligence (JELIA). 247\u2013259.", "citeRegEx": "Lifschitz and Yang,? 2010", "shortCiteRegEx": "Lifschitz and Yang", "year": 2010}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375\u2013398. McCain, N. 1997. Causality in commonsense reasoning about actions. Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1999", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Causal theories of action and change", "author": ["N. McCain", "H. Turner"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). 460\u2013465.", "citeRegEx": "McCain and Turner,? 1997", "shortCiteRegEx": "McCain and Turner", "year": 1997}, {"title": "Applications of circumscription to formalizing common sense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence 26, 3, 89\u2013116. Mints, G. 2000. A Short Introduction to Intuitionistic Logic. Kluwer.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273. Ren, W. 2009. A modular language for describing actions . Ph.D. thesis, University of Texas at Austin.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "Solving the Frame Problem: A Mathematical Investigation of the Common Sense Law of Inertia", "author": ["M. Shanahan"], "venue": "MIT Press.", "citeRegEx": "Shanahan,? 1997", "shortCiteRegEx": "Shanahan", "year": 1997}], "referenceMentions": [{"referenceID": 19, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al.", "startOffset": 40, "endOffset": 64}, {"referenceID": 11, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 10, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 16, "context": "Propositional nonmonotonic causal logic (McCain and Turner 1997) and its generalizations became a basis for the semantics of several expressive action languages (Giunchiglia and Lifschitz 1998; Giunchiglia et al. 2004; Lifschitz and Ren 2006; Lifschitz and Ren 2007; Ren 2009).", "startOffset": 161, "endOffset": 276}, {"referenceID": 0, "context": "It has been used to solve several challenging commonsense reasoning problems, including problems of nontrivial size (Akman et al. 2004), to provide a group of robots with high-level reasoning (Caldiran et al.", "startOffset": 116, "endOffset": 135}, {"referenceID": 3, "context": "2004), to provide a group of robots with high-level reasoning (Caldiran et al. 2009), to give executable specifications of norm-governed computational societies (Artikis et al.", "startOffset": 62, "endOffset": 84}, {"referenceID": 2, "context": "2009), to give executable specifications of norm-governed computational societies (Artikis et al. 2009), and to automate the analysis of business processes under authorization constraints (Armando et al.", "startOffset": 82, "endOffset": 103}, {"referenceID": 1, "context": "2009), and to automate the analysis of business processes under authorization constraints (Armando et al. 2009).", "startOffset": 90, "endOffset": 111}, {"referenceID": 9, "context": "7) shows how to embed a fragment of propositional causal logic into the language of logic programming under the answer set semantics (Gelfond and Lifschitz 1991).", "startOffset": 133, "endOffset": 161}, {"referenceID": 7, "context": "This result, reviewed below, paved the way to the development of an attractive alternative to CCalc\u2014the software system coala (Gebser et al. 2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 126, "endOffset": 146}, {"referenceID": 18, "context": "2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 39, "endOffset": 98}, {"referenceID": 21, "context": "2010) that uses answer set programming (Marek and Truszczy\u0144ski 1999; Niemel\u00e4 1999; Lifschitz 2008) for answering queries about actions described in causal logic.", "startOffset": 39, "endOffset": 98}, {"referenceID": 19, "context": "A causal theory in the sense of (McCain and Turner 1997) is a set of \u201ccausal rules\u201d of the form F \u21d0 G, where F and G are propositional formulas (the head and the body of the rule).", "startOffset": 32, "endOffset": 56}, {"referenceID": 19, "context": "has one model, according to the semantics from (McCain and Turner 1997).", "startOffset": 47, "endOffset": 71}, {"referenceID": 15, "context": "If, for instance, G in (5) is a literal then the following group of nondisjunctive rules will do: L1 \u2190 L2, not G L2 \u2190 L1, not G L1 \u2190 L2, not G L2 \u2190 L1, not G \u00b7 Finally, we extend the translation from propositional causal rules to first-order causal rules in the sense of (Lifschitz 1997).", "startOffset": 271, "endOffset": 287}, {"referenceID": 16, "context": "This version of causal logic is useful for defining the semantics of variables in action descriptions (Lifschitz and Ren 2007).", "startOffset": 102, "endOffset": 126}, {"referenceID": 12, "context": "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).", "startOffset": 50, "endOffset": 122}, {"referenceID": 17, "context": "Preliminary reports on this work are published in (Ferraris 2006; Ferraris 2007; Lee et al. 2010; Lifschitz and Yang 2010).", "startOffset": 50, "endOffset": 122}, {"referenceID": 9, "context": "As observed in (Gelfond and Lifschitz 1991), strong negation can be eliminated from a logic program in favor of additional atoms.", "startOffset": 15, "endOffset": 43}, {"referenceID": 4, "context": "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al.", "startOffset": 69, "endOffset": 84}, {"referenceID": 5, "context": "The definition of a stable model for propositional formulas given in (Ferraris 2005) and the definition of a stable model for first-order sentences proposed in (Ferraris et al. 2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.", "startOffset": 160, "endOffset": 182}, {"referenceID": 8, "context": "2011) become generalizations of the original definition (Gelfond and Lifschitz 1988) when we rewrite rules as logical formulas.", "startOffset": 56, "endOffset": 84}, {"referenceID": 8, "context": "2 The term \u201cstable model\u201d was introduced in (Gelfond and Lifschitz 1988) to describe the meaning of logic programs with negation as failure but without strong negation.", "startOffset": 44, "endOffset": 72}, {"referenceID": 9, "context": "When the stable model semantics was extended to programs with strong negation in (Gelfond and Lifschitz 1991), the term \u201canswer set\u201d was proposed as a replacement.", "startOffset": 81, "endOffset": 109}, {"referenceID": 15, "context": "According to (Lifschitz 1997), a first-order causal theory T is defined by \u2022 a list p of distinct predicate constants, called the explainable symbols of T , and \u2022 a finite set of causal rules of the form F \u21d0 G, where F and G are first-order formulas.", "startOffset": 13, "endOffset": 29}, {"referenceID": 19, "context": "4) second-order formula (24) can be replaced by an equivalent first-order formula using a process similar to Clark\u2019s completion (Clark 1978), called literal completion (McCain and Turner 1997), (Lifschitz 1997, Section 5).", "startOffset": 168, "endOffset": 192}, {"referenceID": 15, "context": "5 To be precise, the definition in (Lifschitz 1997) is more general: object and function constants can be treated as explainable as well.", "startOffset": 35, "endOffset": 51}, {"referenceID": 5, "context": "Some details of the definition of a stable model proposed in (Ferraris et al. 2011) depend on which propositional connectives are treated as primitives, and which are viewed as abbreviations.", "startOffset": 61, "endOffset": 83}, {"referenceID": 5, "context": "The definition of a stable model below is more limited than the definition from (Ferraris et al. 2011) because it is only applicable to programs, not to arbitrary sentences.", "startOffset": 80, "endOffset": 102}, {"referenceID": 14, "context": "We need the following notation from (Lifschitz 1994).", "startOffset": 36, "endOffset": 52}, {"referenceID": 8, "context": "The original definition of a stable model (Gelfond and Lifschitz 1988) treats all predicates as intensional.", "startOffset": 42, "endOffset": 70}, {"referenceID": 20, "context": "First, if we drop from the definition of SM the words \u201cthat is not in the scope of negation\u201d then it will turn into the definition of parallel circumscription (McCarthy 1986; Lifschitz 1985).", "startOffset": 159, "endOffset": 190}, {"referenceID": 5, "context": "Second, the operator of SM as defined in (Ferraris et al. 2011) produces, in application to a logic program, a second-order formula that is usually more complex than (27) but is equivalent to it.", "startOffset": 41, "endOffset": 63}, {"referenceID": 5, "context": "11 Methods for simplifying the result of applying the operator SM are discussed in (Ferraris et al. 2011).", "startOffset": 83, "endOffset": 105}, {"referenceID": 22, "context": "The second pair solves the frame problem (Shanahan 1997) for the fluent on(x ) by postulating that if the value of that fluent at time 1 is equal to its previous value then there is a cause for this.", "startOffset": 41, "endOffset": 56}, {"referenceID": 13, "context": "There exists a tool, called f2lp (Lee and Palla 2009), that converts first-order formulas of a rather general kind into logic programs accepted by lparse.", "startOffset": 33, "endOffset": 53}, {"referenceID": 6, "context": "This can be proved using the splitting theorem from (Ferraris et al. 2009).", "startOffset": 52, "endOffset": 74}], "year": 2011, "abstractText": "Nonmonotonic causal logic, introduced by Norman McCain and Hudson Turner, became a basis for the semantics of several expressive action languages. McCain\u2019s embedding of definite propositional causal theories into logic programming paved the way to the use of answer set solvers for answering queries about actions described in such languages. In this paper we extend this embedding to nondefinite theories and to first-order causal logic.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}