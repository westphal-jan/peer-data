{"id": "1207.0166", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2012", "title": "On Multilabel Classification and Ranking with Partial Feedback", "abstract": "we simply present a genuinely novel multilabel / ranking algorithm working in partial information settings. the algorithm is ideally based on the 2nd - derivatives order algebraic descent computing methods, and relies on upper - confidence bounds to trade - pass off exploration routing and exploitation. mostly we analyze mostly this matching algorithm purely in a suitable partial identity adversarial setting, scenarios where covariates can be consistently adversarial, but numerical multilabel probabilities are ruled directly by ( using generalized ) linear residual models. we easily show computed o ( t ^ { 1 / \u2265 2 } of log t ) local regret bounds, which improve in this several particular ways on the existing baseline results. we next test double the effectiveness criterion of our upper - term confidence deviation scheme approximation by best contrasting against full - mesh information size baselines on real - blown world multilabel filter datasets, those often well obtaining comparable mathematical performance.", "histories": [["v1", "Sat, 30 Jun 2012 23:07:03 GMT  (127kb,D)", "https://arxiv.org/abs/1207.0166v1", null], ["v2", "Tue, 20 Nov 2012 16:48:22 GMT  (128kb,D)", "http://arxiv.org/abs/1207.0166v2", null], ["v3", "Wed, 16 Jan 2013 19:19:34 GMT  (133kb,D)", "http://arxiv.org/abs/1207.0166v3", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["claudio gentile", "francesco orabona"], "accepted": true, "id": "1207.0166"}, "pdf": {"name": "1207.0166.pdf", "metadata": {"source": "CRF", "title": "On Multilabel Classification and Ranking with Partial Feedback, Ver. 3", "authors": ["Claudio Gentile"], "emails": ["claudio.gentile@uninsubria.it", "francesco@orabona.com"], "sections": [{"heading": "1 Introduction", "text": "Consider a book recommendation system. Given a customer\u2019s profile, the system recommends a few possible books to the user by means of, e.g., a limited number of banners placed at different positions on a webpage. The system\u2019s goal is to select books that the user likes and possibly purchases. Typical feedback in such systems is the actual action of the user or, in particular, what books he has bought/preferred, if any. The system cannot observe what would have been the user\u2019s actions had other books got recommended, or had the same book ads been placed in a different order within the webpage.\nSuch problems are collectively referred to as learning with partial feedback. As opposed to the full information case, where the system (the learning algorithm) knows the outcome of each possible response (e.g., the user\u2019s action for each and every possible book recommendation placed in the largest banner ad), in the partial feedback setting, the system only observes the response to very limited options and, specifically, the option that was actually recommended.\nar X\niv :1\n20 7.\n01 66\nv3 [\ncs .L\nIn this and many other examples of this sort, it is reasonable to assume that recommended options are not given the same treatment by the system, e.g., large banners which are displayed on top of the page should somehow be more committing as a recommendation than smaller ones placed elsewhere. Moreover, it is often plausible to interpret the user feedback as a preference (if any) restricted to the displayed alternatives.\nIn this paper, we consider instantiations of this problem in the multilabel and learning-to-rank settings. Learning proceeds in rounds, in each time step t the algorithm receives an instance xt and outputs an ordered subset Y\u0302t of labels from a finite set of possible labels [K] = {1, 2, . . . , K}. Restrictions might apply to the size of Y\u0302t (due, e.g., to the number of available slots in the webpage). The set Y\u0302t corresponds to the aforementioned recommendations, and is intended to approximate the true set of preferences associated with xt. However, the latter set is never observed. In its stead, the algorithm receives Yt \u2229 Y\u0302t, where Yt \u2286 [K] is a noisy version of the true set of user preferences on xt. When we are restricted to |Y\u0302t| = 1 for all t, this becomes a multiclass classification problem with bandit feedback \u2013 see below."}, {"heading": "1.1 Related work", "text": "This paper lies at the intersection between online learning with partial feedback and multilabel classification/ranking. Both fields include a substantial amount of work, so we can hardly do it justice here. In the sequel, we outline some of the main contributions in the two fields, with an emphasis on those we believe are the most related to this paper.\nA well-known tool for facing the problem of partial feedback in online learning is to trade off exploration and exploitation through upper confidence bounds. This technique has been introduced by [28], and can by now be considered a standard tool. In the so-called bandit setting with contextual information (sometimes called bandits with side information or bandits with covariates, e.g., [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.g., a label), whose goodness is quantified by a predefined loss function. Full information about the loss function (one that would perhaps allow to minimizes the total loss over the contexts seen so far) is not available. The specifics of the interaction model determines which pieces of loss will be observed by the algorithm, e.g., the actual value of the loss on the chosen action, some information on more profitable directions on the action space, noisy versions thereof, etc. The overall goal is to compete against classes of functions that map contexts to (expected) losses in a regret sense, that is, to obtain sublinear cumulative regret bounds.\nAll these algorithms share the common need to somehow trade off an exploratory attitude for gathering loss information on unchosen directions of the context-action space, and an exploitatory attitude for choosing actions that are deemed best according to the available data. For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features. They all obtain T 1/2-like regret bounds, where T is the time horizon. This is extended by [27], where the loss function is modeled as a sample from a Gaussian process over the joint context-action space. We are using a similar (generalized) linear modeling here. An earlier (but somehow more general) setting that models such mappings by VC-classes is considered by [29], where a T 2/3 regret bound has been proven under i.i.d. assumptions. Linear multiclass classification problems with bandit feedback\nare considered by, e.g., [25, 11, 20], where either T 2/3 or T 1/2 or even logarithmic regret bounds are proven, depending on the noise model and the underlying loss functions.\nAll the above papers do not consider structured action spaces, where the learner is afforded to select sets of actions, which is more suitable to multilabel and ranking problems. Along these lines are [19, 37, 26, 35, 33, 2]. The general problem of online minimization of a submodular loss function under both full and bandit information without covariates is considered by [19], achieving a regret T 2/3 in the bandit case. [37] consider the problem of online learning of assignments, where at each round an algorithm is requested to assign positions (e.g., rankings) to sets of items (e.g., ads) with given constraints on the set of items that can be placed in each position. Their problem shares similar motivations as ours but, again, the bandit version of their algorithm does not explicitly take side information into account, and leads to a T 2/3 regret bound. Another paper with similar goals but a different mathematical model is by [26], where the aim is to learn a suitable ordering (an \u201cordered slate\u201d) of the available actions. Among other things, the authors prove a T 1/2 regret bound in the bandit setting with a multiplicative weight updating scheme. Yet, no contextual information is incorporated. [35] motivate the ability of selecting sets of actions by a problem of diverse retrieval in large document collections which are meant to live in a general metric space. In contrast to our paper, that approach does not lead to strong regret guarantees for specific (e.g., smooth) loss functions. [33] use a simple linear model for the hidden utility function of users interacting with a web system and providing partial feedback in any form that allows the system to make significant progress in learning this function (this is called an \u03b1-informative feedback by the authors). Under these assumptions, a regret bound of T 1/2 is again provided that depends on the degree of informativeness of the feedback, as measured by the progress made during the learning process. It is experimentally argued that this feedback is typically made available by a user that clicks on relevant URLs out of a list presented by a search engine. Despite the neatness of the argument, no formal effort is put into relating this information to the context information at hand or, more generally, to the way data are generated. The recent paper [2] investigates classes of graphical models for contextual bandit settings that afford richer interaction between contexts and actions leading again to a T 2/3 regret bound.\nFinally, a very interesting recent work that came to our attention at the time of writing this extended version of our conference paper [18] is [5]. In that paper, the authors provide sufficient conditions that insure rates of the form T 1/2 in partial monitoring games with side information. Partial monitoring is an attempt to formalize through a unifying language the partial information settings where the algorithm is observing only partial information about the loss of its action, in the form of some kind of feedback or \u201csignal\u201d. The results presented by [5] do not seem to conveniently extend to the structured action space setting we are interested in (or, if they do, we do not see it in the current version of their paper). Moreover, being very general in scope, that paper is missing a tight dependence of the regret bound on the number of available actions, which can be very large in structured action spaces.\nThe literature on multilabel learning and learning to rank is overwhelming. The wide attention this literature attracts is often motivated by its web-search-engine or recommender-system applications, and many of the papers are experimental in nature. Relevant references include [38, 17, 14], along with references therein. Moreover, when dealing with multilabel, the typical assumption is full supervision, an important concern being modeling correlations among classes. In contrast to that, the specific setting we are considering here need not face such a modeling [14]. The more\nrecent work [39] reduces any online algorithm working on pairwise loss functions (like a ranking loss) to a batch algorithm with generalization bound guarantees. But, again, only fully supervised settings are considered. Other related references are [22, 16], where learning is by pairs of examples. Yet, these approaches need i.i.d. assumptions on the data, and typically deliver batch learning procedures.\nTo summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33]."}, {"heading": "1.2 Our results", "text": "We investigate the multilabel and learning-to-rank problems in a partial feedback scenario with contextual information, where we assume a probabilistic linear model over the labels, although the contexts can be chosen by an adaptive adversary. We consider two families of loss functions, one is a cost-sensitive multilabel loss that generalizes the standard Hamming loss in several respects, the other is a kind of (unnormalized) ranking loss. In both cases, the learning algorithm is maintaining a (generalized) linear predictor for the probability that a given label occurs, the ranking being produced by upper confidence-corrected estimated probabilities. In such settings, we prove T 1/2 log T cumulative regret bounds, which are essentially optimal (up to log factors) in some cases. A distinguishing feature of our user feedback model is that, unlike previous papers (e.g., [19, 37, 1, 27]), we are not assuming the algorithm is observing a noisy version of the risk function on the currently selected action. In fact, when a generalized linear model is adopted, the mapping context-to-risk turns out to be nonconvex in the parameter space. Furthermore, when operating on structured action spaces this more traditional form of bandit model does not seem appropriate to capture the typical user preference feedback. Our approach is based on having the loss decouple from the label generating model, the user feedback being a noisy version of the gradient of a surrogate convex loss associated with the model itself. As a consequence, the algorithm is not directly dealing with the original loss when making exploration. In this sense, we are more similar to the multiclass bandit algorithm by [11]. Yet, our work is a substantial departure from [11]\u2019s in that we lift their machinery to nontrivial structured action spaces, and we do so by means of generalized linear models. On one hand, these extensions pose several extra technical challenges; on the other, they provide additional modeling power and practical advantage.\nThough the emphasis is on theoretical results, we also validate our algorithms on two realworld multilabel datasets w.r.t. a number of loss functions, showing good comparative performance against simple multilabel/ranking baselines that operate with full information."}, {"heading": "1.3 Structure of the paper", "text": "The paper is organized as follows. In Section 2 we introduce our learning model, our first loss function, the label generation model, and some preliminary results and notation used throughout the rest of the paper. In Section 3 we describe our partial feedback algorithm working under the loss function introduced in Section 2, along with the associated regret analysis. In Section 4 we show that a very similar machinery applies to ranking with partial feedback, where the loss function is a kind of pairwise ranking loss (with partial feedback). Similar regret bounds are then presented that work under additional modeling restrictions. In Section 5 we provide our experimental evidence\ncomparing our method with its immediate full information counterpart. Section 6 gives proof ideas and technical details. The paper is concluded with Section 7, where possible directions for future research are mentioned."}, {"heading": "2 Model and preliminaries", "text": "We consider a setting where the algorithm receives at time t the side information vector xt \u2208 Rd, is allowed to output a (possibly ordered) subset1 Y\u0302t \u2286 [K] of the set of possible labels, then the subset of labels Yt \u2286 [K] associated with xt is generated, and the algorithm gets as feedback Y\u0302t\u2229Yt. The loss suffered by the algorithm may take into account several things: the distance between Yt and Y\u0302t (both viewed as sets), as well as the cost for playing Y\u0302t. The cost c(Y\u0302t) associated with Y\u0302t might be given by the sum of costs suffered on each class i \u2208 Y\u0302t, where we possibly take into account the order in which i occurs within Y\u0302t (viewed as an ordered list of labels). Specifically, given constant a \u2208 [0, 1] and costs c = {c(i, s), i = 1, . . . , s, s \u2208 [K]}, such that 1 \u2265 c(1, s) \u2265 c(2, s) \u2265 . . . c(s, s) \u2265 0, for all s \u2208 [K], we consider the loss function\n`a,c(Yt, Y\u0302t) = a |Yt \\ Y\u0302t|+ (1\u2212 a) \u2211\ni\u2208Y\u0302t\\Yt\nc(ji, |Y\u0302t|),\nwhere ji is the position of class i in Y\u0302t, and c(ji, \u00b7) depends on Y\u0302t only through its size |Y\u0302t|. In the above, the first term accounts for the false negative mistakes, hence there is no specific ordering of labels therein. The second term collects the loss contribution provided by all false positive classes, taking into account through the costs c(ji, |Y\u0302t|) the order in which labels occur in Y\u0302t. The constant a serves as weighting the relative importance of false positive vs. false negative mistakes2. As a specific example, suppose that K = 10, the costs c(i, s) are given by c(i, s) = (s \u2212 i + 1)/s, i = 1, . . . , s, the algorithm plays Y\u0302t = (4, 3, 6), but Yt is {1, 3, 8}. In this case, |Yt \\ Y\u0302t| = 2, and\u2211\ni\u2208Y\u0302t\\Yt c(ji, |Y\u0302t|) = 3/3 + 1/3, i.e., the cost for mistakingly playing class 4 in the top slot of Y\u0302t is more damaging than mistakingly playing class 6 in the third slot. In the special case when all costs are unitary, there is no longer need to view Y\u0302t as an ordered collection, and the above loss reduces to a standard Hamming-like loss between sets Yt and Y\u0302t, i.e., a |Yt \\ Y\u0302t|+ (1\u2212 a) |Y\u0302t \\ Yt|. Notice that the partial feedback Y\u0302t\u2229Yt allows the algorithm to know which of the chosen classes in Y\u0302t are good or bad (and to what extent, because of the selected ordering within Y\u0302t). Yet, the algorithm does not observe the value of `a,c(Yt, Y\u0302t) bacause Yt \\ Y\u0302t remains hidden.\nThe reader should also observe the asymmetry between the label set Y\u0302t produced by the algorithm and the true label set Yt: The algorithm predicts an ordered set of labels, but the true set of labels is unordered. In fact, it is often the case in, e.g., recommender system practice, that the user feedback does not contain preference information in the form of an ordered set of items. Still, in such systems we would like to get back to the user with an appropriate ranking over the items.\nWorking with the above loss function makes the algorithm\u2019s output Y\u0302t become a ranked list of classes, where ranking is restricted to the deemed relevant classes only. In this sense, the above problem can be seen as a partial information version of the multilabel ranking problem (see [17],\n1 An ordered subset is like a list with no repeated items. 2Notice that a is not redundant here, since the costs c(i, s) have been normalized to [0,1].\nand references therein). In a standard multilabel ranking problem a classifier has to provide for any given instance xt, both a separation between relevant and irrelevant classes and a ranking of the classes within the two sets (or, perhaps, over the whole set of classes, as long as ranking is consistent with the relevance separation). In our setting, instead, ranking applies to the selected classes only, but the information gathered by the algorithm while training is partial. That is, only a relevance feedback among the selected classes is observed (the set Yt \u2229 Y\u0302t), but no supervised ranking information (e.g., in the form of pairwise preferences) is provided to the algorithm within this set. Alternatively, we can think of a ranking framework where restrictions on the size of Y\u0302t are set by an exogenous (and possibly time-varying) parameter of the problem, and the algorithm is required to provide a ranking complying with these restrictions.\nAnother important concern we would like to address with our loss function `a,c is to avoid combinatorial explosions due to the exponential number of possible choices for Y\u0302t. As we shall see below, this is guaranteed by the chosen structure for costs c(i, s). Another loss function providing similar guarantees (though with additional modeling restrictions) is the (pairwise) ranking loss considered in Section 4, where more on the connection to the ranking setting with partial feedback is given.\nThe problem arises as to which noise model we should adopt so as to encompass significant real-world settings while at the same time affording efficient implementation of the resulting algorithms. For any subset Yt \u2286 [K], we let (y1,t, . . . , yK,t) \u2208 {0, 1}K be the corresponding indicator vector. Then it is easy to see that\n`a,c(Yt, Y\u0302t) = a \u2211 i/\u2208Y\u0302t yi,t + (1\u2212 a) \u2211 i\u2208Y\u0302t c(ji, |Y\u0302t|) (1\u2212 yi,t)\n= a K\u2211 i=1 yi,t + (1\u2212 a) \u2211 i\u2208Y\u0302t ( c(ji, |Y\u0302t|)\u2212 ( a 1\u2212a + c(ji, |Y\u0302t|) ) yi,t ) .\nMoreover, because the first sum does not depend on Y\u0302t, for the sake of optimizing over Y\u0302t (but also for the sake of defining the regret RT \u2013 see below) we can equivalently define\n`a,c(Yt, Y\u0302t) = (1\u2212 a) \u2211 i\u2208Y\u0302t ( c(ji, |Y\u0302t|)\u2212 ( a 1\u2212a + c(ji, |Y\u0302t|) ) yi,t ) . (1)\nLet Pt(\u00b7) be a shorthand for the conditional probability Pt(\u00b7 |xt), where the side information vector xt can in principle be generated by an adaptive adversary as a function of the past. Then\nPt(y1,t, . . . , yK,t) = P(y1,t, . . . , yK,t |xt),\nwhere the marginals Pt(yi,t = 1) satisfy3\nPt(yi,t = 1) = g(\u2212u>i xt)\ng(u>i xt) + g(\u2212u>i xt) , i = 1, . . . , K, (2)\n3 The reader familiar with generalized linear models will recognize the derivative of the function p(\u2206) = g(\u2212\u2206)\ng(\u2206)+g(\u2212\u2206) as the (inverse) link function of the associated canonical exponential family of distributions [30].\nfor some K vectors u1, . . . ,uK \u2208 Rd and some (known) function g : D \u2286 R \u2192 R+. The model is well defined if u>i x \u2208 D for all i and all x \u2208 Rd chosen by the adversary. We assume for the sake of simplicity that ||xt|| = 1 for all t. Notice that here the variables yi,t need not be conditionally independent. We are only definining a family of allowed joint distributions Pt(y1,t, . . . , yK,t) through the properties of their marginals Pt(yi,t). A classical result in the theory of copulas [34] makes one derive all allowed joint distributions starting from the corresponding one-dimensional marginals.\nThe function g above will be instantiated to the negative derivative of a suitable convex and nonincreasing loss function L which our algorithm will be based upon. For instance, if L is the square loss L(\u2206) = (1 \u2212\u2206)2/2, then g(\u2206) = 1 \u2212\u2206, resulting in Pt(yi,t = 1) = (1 + u>i xt)/2, under the assumptionD = [\u22121, 1]. If L is the logistic loss L(\u2206) = ln(1+e\u2212\u2206), then g(\u2206) = 1\ne\u2206+1 ,\nand Pt(yi,t = 1) = eu > i xt/(eu > i xt +1), with domainD = R. Observe that in both cases Pt(yi,t = 1) is an increasing function of u>i xt. This will be true in general. Set for brevity \u2206i,t = u>i xt. Taking into account (1), this model allows us to write the (conditional) expected loss of the algorithm playing Y\u0302t as\nEt[`a,c(Yt, Y\u0302t)] = (1\u2212 a) \u2211 i\u2208Y\u0302t ( c(ji, |Y\u0302t|)\u2212 ( a 1\u2212a + c(ji, |Y\u0302t|) ) pi,t ) , (3)\nwhere we introduced the shorthands\npi,t = p(\u2206i,t), p(\u2206) = g(\u2212\u2206)\ng(\u2206) + g(\u2212\u2206) ,\nand the expectation Et in (3) is w.r.t. the generation of labels Yt, conditioned on both xt, and all previous x and Y .\nA key aspect of this formalization is that the Bayes optimal ordered subset\nY \u2217t = argminY=(j1,j2,...,j|Y |)\u2286[K]Et[`a,c(Yt, Y )]\ncan be computed efficiently when knowing \u22061,t, . . . ,\u2206K,t. This is handled by the next lemma. In words, this lemma says that, in order to minimize (3), it suffices to try out all possible sizes s = 0, 1, . . . , K for Y \u2217t and, for each such value, determine the sequence Y \u2217 s,t that minimizes (3) over all sequences of size s. In turn, Y \u2217s,t can be computed just by sorting classes i \u2208 [K] in decreasing order of pi,t, sequence Y \u2217s,t being given by the first s classes in this sorted list.\nLemma 1. With the notation introduced so far, let pi1,t \u2265 pi2,t \u2265 . . . piK ,t be the sequence of pi,t sorted in nonincreasing order. Then we have that\nY \u2217t = argmins=0,1,...KEt[`a,c(Yt, Y \u2217s,t)] ,\nwhere Y \u2217s,t = (i1, i2, . . . , is), and Y \u2217 0,t = \u2205.\nProof: First observe that, for any given size s, the sequence Y \u2217s,t must contain the s top-ranked classes in the sorted order of pi,t. This is because, for any candidate sequence Ys = {j1, j2, . . . , js}, we have Et[`a,c(Y \u2217t , Ys)] = (1\u2212 a) \u2211 i\u2208Ys ( c(ji, s)\u2212 ( a 1\u2212a + c(ji, s) ) pi,t ) . If there exists i \u2208 Ys which is not among the s-top ranked ones, then we could replace class i in position ji within Ys with class k /\u2208 Ys such that pk,t > pi,t obtaining a smaller loss.\nNext, we show that the optimal ordering within Y \u2217s,t is precisely ruled by the nonicreasing order of pi,t. By the sake of contradiction, assume there are i and k in Y \u2217s,t such that i preceeds k in Y \u2217 s,t but pk,t > pi,t. Specifically, let i be in position j1 and k be in position j2 with j1 < j2 and such that c(j1, s) > c(j2, s). Then, disregarding the common (1 \u2212 a)-factor, switching the two classes within Y \u2217s,t yields an expected loss difference of\nc(j1, s)\u2212 ( a 1\u2212a + c(j1, s) ) pi,t + c(j2, s)\u2212 ( a 1\u2212a + c(j2, s) ) pk,t\n\u2212 ( c(j1, s)\u2212 ( a 1\u2212a + c(j1, s) ) pk,t ) \u2212 ( c(j2, s)\u2212 ( a 1\u2212a + c(j2, s) ) pi,t ) = (pk,t \u2212 pi,t) (c(j1, s)\u2212 c(j2, s)) > 0 ,\nsince pk,t > pi,t and c(j1, s) > c(j2, s). Hence switching would get a smaller loss which leads as a consequence to Y \u2217s,t = (i1, i2, . . . , is).\nNotice the way costs c(i, s) influence the Bayes optimal computation. We see from (3) that placing class i within Y\u0302t in position ji is beneficial (i.e., it leads to a reduction of loss) if and only if pi,t > c(ji, |Y\u0302t|)/( a1\u2212a + c(ji, |Y\u0302t|)). Hence, the higher is the slot ij in Y\u0302t the larger should be pi,t in order for this inclusion to be convenient.4\nIt is Y \u2217t above that we interpret as the true set of user preferences on xt. We would like to compete against Y \u2217t in a cumulative regret sense, i.e., we would like to bound\nRT = T\u2211 t=1 Et[`a,c(Yt, Y\u0302t)]\u2212 Et[`a,c(Yt, Y \u2217t )]\nwith high probability. We use a similar but largely more general analysis than [11]\u2019s to devise an online second-order descent algorithm whose updating rule makes the comparison vector U = (u1, . . . ,uK) \u2208 RdK defined through (2) be Bayes optimal w.r.t. a surrogate convex loss L(\u00b7) such that g(\u2206) = \u2212L\u2032(\u2206). Observe that the expected loss function defined in (3) is, generally speaking, nonconvex in the margins \u2206i,t (consider, for instance the logistic case g(\u2206) = 1e\u2206+1 ). Thus, we cannot directly minimize this expected loss."}, {"heading": "3 Algorithm and regret bounds", "text": "In Figure 1 is our bandit algorithm for (ordered) multiple labels. The algorithm is based on replacing the unknown model vectors u1, . . . ,uK with prototype vectors w\u20321,t, . . . ,w \u2032 K,t, being w \u2032 i,t the time-t approximation to ui, satisying similar constraints we set for the ui vectors. For the sake of brevity, we let \u2206\u0302\u2032i,t = x > t w \u2032 i,t, and \u2206i,t = u > i xt, i \u2208 [K].\n4 Notice that this depends on the actual size of Y\u0302t, so we cannot decompose this problem into K independent problems. The decomposition does occur if the costs c(i, s) are constants, independent of i and s, the criterion for inclusion becoming pi,t \u2265 \u03b8, for some constant threshold \u03b8.\nThe algorithm uses \u2206\u0302\u2032i,t as proxies for the underlying \u2206i,t according to the (upper confidence)\napproximation scheme \u2206i,t \u2248 [\u2206\u0302\u2032i,t + i,t]D, where i,t \u2265 0 is a suitable upper-confidence level for class i at time t, and [\u00b7]D denotes the clipping-to-D operation: If D = [\u2212R,R], then\n[x]D =  R if x > R x if \u2212R \u2264 x \u2264 R \u2212R if x < \u2212R .\nThe algorithm\u2019s prediction at time t has the same form as the computation of the Bayes optimal sequence Y \u2217t , where we replace the true (and unknown) pi,t = p(\u2206i,t) with the corresponding upper confidence proxy\np\u0302i,t = p([\u2206\u0302 \u2032 i,t + i,t]D) .\nbeing\nY\u0302t = argminY=(j1,j2,...j|Y |)\u2286[K] (\u2211 i\u2208Y ( c(ji, |Y |)\u2212 ( a 1\u2212a + c(ji, |Y |) ) p\u0302i,t )) .\nComputing Y\u0302t above can be done by mimicking the computation of the Bayes optimal ordered subset Y \u2217t (just replace pi,t by p\u0302i,t). From a computational viewpoint, this essentially amounts to sorting classes i \u2208 [K] in decreasing value of p\u0302i,t, i.e., order of K logK running time per prediction. Thus the algorithm is producing a ranked list of relevant classes based on upper-confidence-corrected scores p\u0302i,t. Class i is deemed relevant and ranked high among the relevant ones when either \u2206\u0302\u2032i,t is a good approximation to \u2206i,t and pi,t is large, or when the algorithm is not very confident on its own approximation about i (that is, the upper confidence level i,t is large).\nThe algorithm in Figure 1 receives in input the loss parameters a and c(i, s), the model function g(\u00b7) and the associated margin domain D = [\u2212R,R], and maintains both K positive definite matrices Ai,t of dimension d (initially set to the d \u00d7 d identity matrix), and K weight vector wi,t \u2208 Rd (initially set to the zero vector). At each time step t, upon receiving the d-dimensional instance vector xt the algorithm uses the weight vectors wi,t to compute the prediction vectors w\u2032i,t. These vectors can easily be seen as the result of projecting wi,t onto interval D = [\u2212R,R] w.r.t. the distance function di,t\u22121, i.e.,\nw\u2032i,t = argminw\u2208Rd :w>xt\u2208D di,t\u22121(w,wi,t), i \u2208 [K],\nwhere di,t(u,w) = (u\u2212w)>Ai,t (u\u2212w) .\nVectors w\u2032i,t are then used to produce prediction values \u2206\u0302 \u2032 i,t involved in the upper-confidence calculation of the predicted ordered subset Y\u0302t \u2286 [K]. Next, the feedback Yt \u2229 Y\u0302t is observed, and the algorithm in Figure 1 promotes all classes i \u2208 Yt\u2229 Y\u0302t (sign si,t = 1), demotes all classes i \u2208 Y\u0302t \\Yt (sign si,t = \u22121), and leaves all remaining classes i /\u2208 Y\u0302t unchanged (sign si,t = 0). Promotion of class i on xt implies that if the new vector xt+1 is close to xt then i will be ranked higher on xt+1. The update w\u2032i,t \u2192 wi,t+1 is based on the gradients \u2207i,t of a loss function L(\u00b7) satisfying L\u2032(\u2206) = \u2212g(\u2206). On the other hand, the update Ai,t\u22121 \u2192 Ai,t uses the rank one matrix5 xtx>t .\n5 The rank-one update is based on xtx>t rather than\u2207i,t\u2207>i,t, as in, e.g., [21]. This is due to technical reasons that will be made clear in Section 6. This feature tells this algorithm slightly apart from the Online Newton step algorithm [21], which is the starting point of our analysis.\nIn both the update of w\u2032i,t and the one involving Ai,t\u22121, the reader should observe the role played by the signs si,t. Finally, the constants c\u2032L and c \u2032\u2032 L occurring in the expression for 2 i,t are related to smoothness properties of L(\u00b7), as explained in the next theorem.6\nTheorem 2. Let L : D = [\u2212R,R] \u2286 R \u2192 R+ be a C2(D) convex and nonincreasing function of its argument, (u1, . . . ,uK) \u2208 RdK be defined in (2) with g(\u2206) = \u2212L\u2032(\u2206) for all \u2206 \u2208 D, and such that \u2016ui\u2016 \u2264 U for all i \u2208 [K]. Assume there are positive constants cL, c\u2032L and c\u2032\u2032L such that:\ni. L \u2032(\u2206)L\u2032\u2032(\u2212\u2206)+L\u2032\u2032(\u2206)L\u2032(\u2212\u2206)\n(L\u2032(\u2206)+L\u2032(\u2212\u2206))2 \u2265 \u2212cL,\nii. (L\u2032(\u2206))2 \u2264 c\u2032L,\niii. L\u2032\u2032(\u2206) \u2265 c\u2032\u2032L simultaneously hold for all \u2206 \u2208 D. Then the cumulative regret RT of the algorithm in Figure 1 satisfies, with probability at least 1\u2212 \u03b4,\nRT = O ( (1\u2212 a) cLK \u221a T C d ln ( 1 + T\nd\n)) ,\nwhere\nC = O ( U2 +\nd c\u2032L (c\u2032\u2032L) 2 ln\n( 1 + T\nd\n) + ( c\u2032L\n(c\u2032\u2032L) 2 + L(\u2212R) c\u2032\u2032L\n) ln KT\n\u03b4\n) .\nIt is easy to see that when L(\u00b7) is the square loss L(\u2206) = (1 \u2212 \u2206)2/2 and D = [\u22121, 1], we have cL = 1/2, c\u2032L = 4 and c \u2032\u2032 L = 1; when L(\u00b7) is the logistic loss L(\u2206) = ln(1 + e\u2212\u2206) and D = [\u2212R,R], we have cL = 1/4, c\u2032L \u2264 1 and c\u2032\u2032L = 12(1+cosh(R)) , where cosh(x) = ex+e\u2212x 2 .\nThe following remarks are in order at this point.\nRemark 1. A drawback of Theorem 2 is that, in order to properly set the upper confidence levels i,t, we assume prior knowledge of the norm upper bound U . Because this information is often unavailable, we present here a simple modification to the algorithm that copes with this limitation. We change the definition of 2i,t in Figure 1 to\n2i,t = max { x>A\u22121i,t\u22121x ( 2 d c\u2032L (c\u2032\u2032L) 2 ln ( 1 + t\u2212 1 d ) + 12 c\u2032\u2032L ( c\u2032L c\u2032\u2032L + 3L(\u2212R) ) ln K(t+ 4) \u03b4 ) , 4R2 } .\nthat is, we substitute U2 by d c \u2032 L\n(c\u2032\u2032L) 2 ln\n( 1 + t\u22121\nd\n) , and cap the maximal value of 2i,t to 4R\n2. This immediately leads to the following result.7\nTheorem 3. With the same assumptions and notation as in Theorem 2, if we replace 2i,t as explained above we have that, with probability at least 1\u2212 \u03b4, RT satisfies\nRT = O ( (1\u2212 a) cLK \u221a T C d ln ( 1 + T\nd\n) + (1\u2212 a) cLK Rd ( exp ( (c\u2032\u2032L) 2 U2\nc\u2032L d\n) \u2212 1 )) .\n6 The proof is given in Section 6. 7 The proof is deferred to Section 6.\nRemark 2. From a computational standpoint, the most demanding operation in Figure 1 is computing the upper confidence levels i,t involving the inverse matrices A\u22121i,t\u22121, i \u2208 [K]. This can be done incrementally inO(K d2) time per round, which makes it hardly practical if both d andK are large. In practice (as explained, e.g., by [11]), one can use a version of the algorithm which maintains diagonal matrices Ai,t instead of full ones. All the steps remain the same except Step 5 of Algorithm 1 where one defines the rth diagonal element of matrix Ai,t as (Ai,t)r,r = (Ai,t\u22121)r,r +x2r,t, being xt = (x1,t, x2,t, . . . , xr,t, . . . , xK,t)>. The resulting running time per round (including prediction and update) becomes O(dK + K logK). In fact, when a limitation on the size of Y\u0302t is given, the running time may be further reduced, see Remark 3."}, {"heading": "4 On ranking with partial feedback", "text": "As Lemma 1 points out, when the cost values c(i, s) in the loss function `a,c are stricly decreasing i.e., c(1, s) > c(2, s) > . . . > c(s, s), for all s \u2208 [K], then the Bayes optimal ordered sequence Y \u2217t on xt is unique can be obtained by sorting classes in decreasing values of pi,t, and then decide on a cutoff point8 induced by the loss parameters, so as to tell relevant classes apart from irrelevant ones. In turn, because p(\u2206) = g(\u2212\u2206)\ng(\u2206)+g(\u2212\u2206) is increasing in \u2206, this ordering corresponds to sorting classes in decreasing values of \u2206i,t. Now, if parameter a in `a,c is very close9 to 1, then |Y \u2217t | = K, and the algorithm itself will produce ordered subsets Y\u0302t such that |Y\u0302t| = K. Moreover, it does so by receiving full feedback on the relevant classes at time t (since Yt \u2229 Y\u0302t = Yt). As is customary (e.g., [14]), one can view any multilabel assignment Y = (y1, . . . , yK) \u2208 {0, 1}K as a ranking among the K classes in the most natural way: i preceeds j if and only if yi > yj . The (unnormalized) ranking loss function `rank(Y, f) between the multilabel Y and a ranking function f : Rd \u2192 RK , representing degrees of class relevance sorted in a decreasing order fj1(xt) \u2265 fj2(xt) \u2265 . . . \u2265 fjK (xt) \u2265 0, counts the number of class pairs that disagree in the two rankings:\n`rank(Y, f) = \u2211\ni,j\u2208[K] : yi>yj\n( {fi(xt) < fj(xt)}+ 12 {fi(xt) = fj(xt)} ) ,\nwhere {. . .} is the indicator function of the predicate at argument. As pointed out by [14], the ranking function f(xt) = (p1,t, . . . , pK,t) is also Bayes optimal w.r.t. `rank(Y, f), no matter if the class labels yi are conditionally independent or not. Hence we can use the algorithm in Figure 1 with a close to 1 for tackling ranking problems derived from multilabel ones, when the measure of choice is `rank and the feedback is full.\nWe now consider a partial information version of the above ranking problem. Suppose that at each time t, the environment discloses both xt and a maximal size St for the ordered subset Y\u0302t = (j1, j2, . . . , j|Y\u0302t|) (both xt and St can be chosen adaptively by an adversary). Here St might be the number of available slots in a webpage or the number of URLs returned by a search engine in response to query xt. Then it is plausible to compete in a regret sense against the best time-t offline ranking of the form\nf \u2217(xt) = f \u2217(xt;St) = (f \u2217 1 (xt), f \u2217 2 (xt), . . . , f \u2217 K(xt)),\n8 This is called the zero point by [17]. 9 If a = 1, the algorithm only cares about false negative mistakes, the best strategy being always predicting\nY\u0302t = [K]. Unsurprisingly, this yields zero regret in both Theorems 2 and 3.\nwhere the number of strictly positive f \u2217i (xt) values is at most St. Further, the ranking loss could be reasonably restricted to count the number of class pairs disagreeing within Y\u0302t plus a quantity related to the number of false negative mistakes. If Y\u0302t is the sequence of length St associated with ranking function f , we consider the loss function `p\u2212rank,t (\u201cpartial information `rank at time t\u201d)\n`p\u2212rank,t(Y, f) = \u2211\ni,j\u2208Y\u0302t : yi>yj\n( {fi(xt) < fj(xt)}+ 12 {fi(xt) = fj(xt)} ) + St |Yt \\ Y\u0302t| .\nIn this loss function, the factor St multiplying |Yt \\ Y\u0302t| serves as balancing the contribution of the double sum \u2211 i,j\u2208Y\u0302t : yi>yj with the contribution of false negative mistakes |Yt\\Y\u0302t|. For convenience, we will interchangeably use the notations `p\u2212rank,t(Y, f) and `p\u2212rank,t(Y, Y\u0302t), whenever it is clear from the surrounding context that Y\u0302t is the sequence corresponding to f .\nThe next lemma10 is the ranking counterpart to Lemma 1. It shows that the Bayes optimal ranking for `p\u2212rank,t is given by\nf \u2217(xt;St) = (p \u2032 1,t, p \u2032 2,t, . . . , p \u2032 K,t),\nwhere p\u2032j,t = pj,t if pj,t is among the St largest values in the sequence (p1,t, . . . , pK,t), and 0 otherwise. That is, f \u2217(xt;St) is the function that ranks classes according to decreasing values of pi,t and cuts off exactly at position St. In order for this result to go through we need to restrict model (2) to the case of conditionally independent classes, i.e., to the case when\nPt(y1,t, . . . , yK,t) = \u220f i\u2208[K] pi,t . (4)\nThis is in striking contrast to the full information setting, where the Bayes optimal ranking only depends on the marginal distribution values pi,t [14]. Due to the interaction between the two terms in the definition of `p\u2212rank,t, the Bayes optimal ranking for `p\u2212rank,t turns out to depend on both marginal and pairwise correlation values of the joint class distribution. This would force us to maintain O(K2) upper confidence values i,j , one for each pair (i, j), i < j, leading to an extra computational burder which can also become prohibitive when the number of classes K is large.\nLemma 4. With the notation introduced so far, let the joint distribution Pt(y1,t, . . . , yK,t) factorize as in (4). Then f \u2217(xt;St) introduced above satisfies\nf \u2217(xt;St) = argminY=(i1,i2,...ih) ,h\u2264StEt[`p\u2212rank,t(Yt, Y )] .\nIf we add to the argmin of our algorithm (Step 3 in Figure 1) the further constraint |Y | \u2264 St (notice that the resulting computation is still about sorting classes according to decreasing values of p\u0302i,t), we are defining a partial information ranking algorithm that ranks classes according to decreasing values of p\u0302i,t up to position St (i.e., |Y\u0302t| = St). Let f\u0302(xt, St) be the resulting ranking. We can then define the cumulative regret RT w.r.t. `p\u2212rank,t as\nRT = T\u2211 t=1 Et[`p\u2212rank,t(Yt, f\u0302(xt, St))]\u2212 Et[`p\u2212rank,t(Yt, f \u2217(xt, St)], (5)\n10 We postpone the lengthy proof to Section 6.\nthat is, the amount to which the conditional `p\u2212rank,t-risk of f\u0302(xt, St) exceeds the one of the Bayes optimal ranking f \u2217(xt;St), cumulated over time.\nWe have the following ranking counterpart to Theorem 2.\nTheorem 5. With the same assumptions and notation as in Theorem 2, combined with the independence assumption (4), let the cumulative regret RT w.r.t. `p\u2212rank,t be defined as in (5). Then, with probability at least 1\u2212 \u03b4, we have that the algorithm in Figure 1 working with a\u2192 1 and strictly decreasing cost values c(i, s) (i.e., the one computing in round t the ranking function f\u0302(xt, St)) achieves\nRT = O ( cL \u221a S K T C d ln ( 1 + T\nd\n)) ,\nwhere S = maxt=1,...,T St.\nThe proof (see Section 6) is very similar to the one of Theorem 2. This suggests that, to some extent, we are decoupling the label generating model from the loss function ` under consideration.\nRemark 3. As is typical in many multilabel classification settings, the number of classes K can either be very large or have an inner structure (e.g., a hierarchical or DAG-like structure). It is often the case that in such a large label space, many classes are relatively rare. This has lead researchers to consider methods that are specifically taylored to leverage the label sparsity of the chosen classifier (e.g., [23] and references therein) and/or the specific structure of the set of labels (e.g., [9, 6], and references therein). Though our algorithm is not designed to exploit the label structure, we would like to stress that the restriction |Y\u0302t| \u2264 St \u2264 S in Theorem 5 allows us to replace the linear dependence on the total number of classes K (which is often much larger than S) by \u221a SK. It is very easy to see that this restriction would bring similar benefits to Theorem 2.\nThe above restriction is not only beneficial from a \u201cstatistical\u201d point of view, but also from a computational one. In fact, as is by now standard, algorithms like the one in Figure 1 can easily be cast in dual variables (i.e., in a RKHS). This comes with at least two consequences:\n1. We can depart from the (generalized) linear modeling assumption (2), and allow for more general nonlinear dependences of pi,t on the input vectors xt.\n2. We can maintain a dual variable representation for margins \u2206\u0302\u2032i,t and quadratic forms x > t A \u22121 i,t\u22121xt,\nso that computing each one of them takesO(N2i,t\u22121) inner products, whereNi,t is the number of times class i has been updated up to time t, each inner product being O(d). Now, each of the (at most St \u2264 S) updates is O(N2i,t\u22121). Hence, the overall running time in round t is coarsely overapproximated by O(d \u2211 i\u2208[K] N 2 i,T + K logK). From \u2211 i\u2208[K] Ni,T \u2264 ST , we see that when S is small compared to K, then Ni,t\u22121 tends to be small as well. For instance, if S \u2264 \u221a K this leads to a running time per round of the form SdT 2, which can be smaller than Kd2 mentioned in Remark 2.\nFinally, observe that one can also combine Theorem 5 with the argument contained in Remark 1."}, {"heading": "5 Experiments", "text": "The experiments we report here are meant to validate the exploration-exploitation tradeoff implemented by our algorithm under different conditions (restricted vs. nonrestricted number of classes),\nloss measures (`a,c, `rank,t, and Hamming loss) and model/parameter settings (L = square loss, L = logistic loss, with varying R). Datasets. We used two multilabel datasets. The first one, called Mediamill, was introduced in a video annotation challenge [36]. It comprises 30,993 training samples and 12,914 test ones. The number of features d is 120, and the number of classes K is 101. The second dataset is Sony CSL Paris [31], made up of 16,452 train samples and 16,519 test samples, each sample being described by d = 98 features. The number of classes K is 632. In both cases, feature vectors have been normalized to unit L2 norm. Parameter setting and loss measures. We used the algorithm in Figure 1 with two different loss functions, the square loss and the logistic loss, and varied the parameter R for the latter. The setting of the cost function c(i, s) depends on the task at hand, and for this preliminary experiments we decided to evaluate two possible settings only. The first one, denoted by \u201cdecreasing c\u201d is c(i, s) = s\u2212i+1\ns , i = 1, . . . , s, the second one, denoted by \u201cconstant c\u201d, is c(i, s) = 1, for all i and\ns. In all experiments, the a parameter was set to 0.5, so that `a,c with constant c reduces to half the Hamming loss. In the decreasing c scenario, we evaluated the performance of the algorithm on the loss `a,c that the algorithm is minimizing, but also its ability to produce meaningful (partial) rankings through `rank,t. On the constant c setting, we evaluated the Hamming loss. As is typical of multilabel problems, the label density, i.e., the average fraction of labels associated with the examples, is quite small. For instance, on Mediamill this is 4.3%. Hence, it is clearly beneficial to impose an upper bound S on |Y\u0302t|. For the constant c and ranking loss experiments we tried out different values of S, and reported the final performance. Baseline. As baseline, we considered a full information version of Algorithm 1 using the square loss, that receives after each prediction the full array of true labels Yt for each sample. We call this algorithm OBR (Online Binary Relevance), because it is a natural online adaptation of the binary relevance algorithm, widely used as a baseline in the multilabel literature. Comparing to OBR stresses the effectiveness of the exploration/exploitation rule above and beyond the details of underlying generalized linear predictor. OBR was used to produce subsets (as in the Hamming loss case), and restricted rankings (as in the case of `rank,t). Results. Our results are summarized in Figures 2 and 3. The algorithms have been trained by sweeping only once over the training data. Though preliminary in nature, these experiments allow us to draw a few conclusions. Our results for the avarage `a,c(Yt, Y\u0302t) with decreasing c are contained in the two left plots. We can see that the performance is improving over time on both datasets, as predicted by Theorem 2. In the middle plots are the final cumulative Hamming losses with constant c divided by the number of training samples, as a function of S. Similar plots are on the right with the final average ranking losses `rank,t divided by S. In both cases we see that there is an optimal value of S that allows to balance the exploration and the exploitation of the algorithm. Moreover the performance of our algorithm is always pretty close to the performance of OBR, even if our algorithm is receiving only partial feedback. In many experiments the square loss seems to give better results. Exception is the ranking loss on the Mediamill dataset (Figure 3, right)."}, {"heading": "6 Technical details", "text": "This section contains all proofs missing from the main text, along with ancillary results and comments.\nThe algorithm in Figure 1 works by updating through the gradients \u2207i,t of a modular marginbased loss function \u2211K i=1 L(w > i x) associated with the label generation model (2), i.e., associated with function g, so as to make the parameters (u1, . . . ,uK) \u2208 RdK therein achieve the Bayes optimality condition\n(u1, . . . ,uK) = arg min w1,...,wK :w > i xt\u2208D\nEt [ K\u2211 i=1 L(si,tw > i xt) ] , (6)\nwhere Et[\u00b7] above is over the generation of Yt in producing the sign value si,t \u2208 {\u22121, 0,+1}, conditioned on the past (in particular, conditioned on Y\u0302t). The requirement in (6) is akin to the classical construction of proper scoring rules in the statistical literature (e.g., [32]).\nThe above is combined with the ability of the algorithm to guarantee the high probability convergence of the prototype vectors w\u2032i,t to the corresponding ui (Lemma 10). The rate of convergence is ruled by the fact that the associated upper confidence values i,t shrink to zero as 1\u221at when t grows large. In order for this convergence to take place, it is important to insure that the algorithm is observing informative feedback (either \u201ccorrect\u201d, i.e., si,t = 1, or \u201cmistaken\u201d, i.e., si,t = \u22121) for each class i contained in the selected Y\u0302t. This in turn implies regret bounds for both `a,c (Lemma 8) and `rank,t (Lemma 9).\nThe following lemma faces the problem of hand-crafting a convenient loss function L(\u00b7) such that (6) holds.\nLemma 6. Let w1, . . . ,wK \u2208 RdK be arbitrary weight vectors such that w>i xt \u2208 D, i \u2208 [K], (u1, . . . ,uK) \u2208 RdK be defined in (2), si,t be the updating signs computed by the algorithm at the end (Step 5) of time t, L : D = [\u2212R,R] \u2286 R \u2192 R+ be a convex and differentiable function of its argument, with g(\u2206) = \u2212L\u2032(\u2206). Then for any t we have\nEt [ K\u2211 i=1 L(si,tw > i xt) ] \u2265 Et [ K\u2211 i=1 L(si,t u > i xt) ] ,\ni.e., (6) holds.\nProof: Let us introduce the shorthands \u2206i = u>i xt, \u2206\u0302i = w>i,txt, si = si,t, and pi = P(yi,t = 1 |xt) = L \u2032(\u2212\u2206i) L\u2032(\u2206i)+L\u2032(\u2212\u2206i) . Moreover, let Pt(\u00b7) be an abbreviation for the conditional probability P(\u00b7 | (y1,x1), . . . , (yt\u22121,xt\u22121),xt). Recalling the way si,t is constructed (Figure 1), we can write\nEt [ K\u2211 i=1 L(si,t \u2206\u0302i) ] = \u2211 i\u2208Y\u0302t ( Pt(si,t = 1)L(\u2206\u0302i) + Pt(si,t = \u22121)L(\u2212\u2206\u0302i) ) + (K \u2212 |Y\u0302t|)L(0)\n= \u2211 i\u2208Y\u0302t ( pi L(\u2206\u0302i) + (1\u2212 pi)L(\u2212\u2206\u0302i) ) + (K \u2212 |Y\u0302t|)L(0) ,\nFor similar reasons,\nEt [ K\u2211 i=1 L(si,t \u2206i) ] = \u2211 i\u2208Y\u0302t (pi L(\u2206i) + (1\u2212 pi)L(\u2212\u2206i)) + (K \u2212 |Y\u0302t|)L(0) .\nSince L(\u00b7) is convex, so is Et [\u2211K i=1 L(si,t \u2206\u0302i) ] when viewed as a function of the \u2206\u0302i. We have\nthat \u2202 Et[ \u2211K i=1 L(si,t \u2206\u0302i)] \u2202\u2206\u0302i = 0 if and only if for all i \u2208 Y\u0302t we have that \u2206\u0302i satisfies\npi = L\u2032(\u2212\u2206\u0302i)\nL\u2032(\u2206\u0302i) + L\u2032(\u2212\u2206\u0302i) .\nSince pi = L\u2032(\u2212\u2206i) L\u2032(\u2206i)+L\u2032(\u2212\u2206i) , we have that Et [\u2211K i=1 L(si,t \u2206\u0302i) ]\nis minimized when \u2206\u0302i = \u2206i for all i \u2208 [K]. The claimed result immediately follows.\nLet now V art(\u00b7) be a shorthand for V ar(\u00b7 | (y1,x1), . . . , (yt\u22121,xt\u22121),xt). The following lemma shows that under additional assumptions on the loss L(\u00b7), we are afforded to bound the variance of a difference of losses L(\u00b7) by the expectation of this difference. This will be key to proving the fast rates of convergence contained in the subsequent Lemma 10.\nLemma 7. Let (w\u20321,t, . . . ,w\u2032K,t) \u2208 RdK be the weight vectors computed by the algorithm in Figure 1 at the beginning (Step 2) of time t, si,t be the updating signs computed at the end (Step 5) of time t, and (u1, . . . ,uK) \u2208 RdK be the comparison vectors defined through (2). Let L : D = [\u2212R,R] \u2286\nR \u2192 R+ be a C2(D) convex function of its argument, with g(\u2206) = \u2212L\u2032(\u2206) and such that there are positive constants c\u2032L and c \u2032\u2032 L with (L\n\u2032(\u2206))2 \u2264 c\u2032L and L\u2032\u2032(\u2206) \u2265 c\u2032\u2032L for all \u2206 \u2208 D. Then for any i \u2208 Y\u0302t\n0 \u2264 V art ( L(si,t x > t w \u2032 i,t)\u2212 L(si,t u>i xt) ) \u2264 2c \u2032 L c\u2032\u2032L Et [ L(si,t x > t w \u2032 i,t)\u2212 L(si,t u>i xt) ] .\nProof: Let us introduce the shorthands \u2206i = x>t ui, \u2206\u0302i = x>t w\u2032i,t, si = si,t, and recall that pi = P(yi,t = 1 |xt) = L \u2032(\u2212\u2206i) L\u2032(\u2206i)+L\u2032(\u2212\u2206i) . Then, for any i \u2208 [K],\nV art ( L(si,t x > t w \u2032 i,t)\u2212 L(si,t u>i xt) ) \u2264 Et (( L(si \u2206\u0302i)\u2212 L(si \u2206i) )2) \u2264 c\u2032L (\u2206\u0302i \u2212\u2206i)2 . (7)\nMoreover, for any i \u2208 Y\u0302t we can write Et [ L(si \u2206\u0302i)\u2212 L(si \u2206i) ] = pi (L(\u2206\u0302i)\u2212 L(\u2206i)) + (1\u2212 pi) (L(\u2212\u2206\u0302i)\u2212 L(\u2212\u2206i))\n\u2265 pi ( L\u2032(\u2206i)(\u2206\u0302i \u2212\u2206i) +\nc\u2032\u2032L 2\n(\u2206\u0302i \u2212\u2206i)2 )\n+ (1\u2212 pi) ( L\u2032(\u2212\u2206i)(\u2206i \u2212 \u2206\u0302) +\nc\u2032\u2032L 2\n(\u2206\u0302i \u2212\u2206i)2 )\n= pi c\u2032\u2032L 2 (\u2206\u0302i \u2212\u2206i)2 + (1\u2212 pi) c\u2032\u2032L 2 (\u2206\u0302i \u2212\u2206i)2 = c\u2032\u2032L 2 (\u2206\u0302i \u2212\u2206i)2, (8)\nwhere the second equality uses the definition of pi. Combining (7) with (8) gives the desired bound. We continue by showing a one-step regret bound for our original loss `a,c. The precise connection to loss L(\u00b7) will be established with the help of a later lemma (Lemma 10).\nLemma 8. LetL : D = [\u2212R,R] \u2286 R \u2192 R+ be a convex, twice differentiable, and nonincreasing function of its argument. Let (u1, . . . ,uK) \u2208 RdK be defined in (2) with g(\u2206) = \u2212L\u2032(\u2206) for all \u2206 \u2208 D. Let also cL be a positive constant such that\nL\u2032(\u2206)L\u2032\u2032(\u2212\u2206) + L\u2032\u2032(\u2206)L\u2032(\u2212\u2206) (L\u2032(\u2206) + L\u2032(\u2212\u2206))2 \u2265 \u2212cL\nholds for all \u2206 \u2208 D. Finally, let \u2206i,t denote u>i xt, and \u2206\u0302\u2032i,t denote x>t w\u2032i,t, where w\u2032i,t is the i-the weight vector computed by the algorithm at the beginning (Step 2) of time t. If time t is such that |\u2206i,t \u2212 \u2206\u0302\u2032i,t| \u2264 i,t for all i \u2208 [K], then\nEt[`a,c(Yt, Y\u0302t)]\u2212 Et[`a,c(Yt, Y \u2217t )] \u2264 2 (1\u2212 a) cL \u2211 i\u2208Y\u0302t i,t .\nProof: Recall the shorthand notation p(\u2206) = g(\u2212\u2206) g(\u2206)+g(\u2212\u2206) . We can write\nEt[`a,c(Yt, Y\u0302t)]\u2212 Et[`a,c(Yt, Y \u2217t )] = (1\u2212 a) \u2211 i\u2208Y\u0302t ( c(j\u0302i, |Y\u0302t|)\u2212 ( a 1\u2212a + c(j\u0302i, |Y\u0302t|) ) p(\u2206i,t) ) \u2212 (1\u2212 a)\n\u2211 i\u2208Y \u2217t ( c(j\u2217i , |Y \u2217t |)\u2212 ( a 1\u2212a + c(j \u2217 i , |Y \u2217t |) ) p(\u2206i,t) ) ,\nwhere j\u0302i denotes the position of class i in Y\u0302t and j\u2217i is the position of class i in Y \u2217 t . Now,\np\u2032(\u2206) = \u2212g\u2032(\u2212\u2206) g(\u2206)\u2212 g\u2032(\u2206) g(\u2212\u2206) (g(\u2206) + g(\u2212\u2206))2 = \u2212L\u2032(\u2206)L\u2032\u2032(\u2212\u2206)\u2212 L\u2032(\u2212\u2206)L\u2032\u2032(\u2206) (L\u2032(\u2206) + L\u2032(\u2212\u2206))2 \u2265 0\nsince g(\u2206) = \u2212L\u2032(\u2206), and L(\u00b7) is convex and nonincreasing. Hence p(\u2206) is itself a nondecreasing function of \u2206. Moreover, the extra condition on L involving L\u2032 and L\u2032\u2032 is a Lipschitz condition on p(\u2206) via a uniform bound on p\u2032(\u2206). Hence, from |\u2206i,t \u2212 \u2206\u0302\u2032i,t| \u2264 i,t and the definition of Y\u0302t we can write\nEt[`a,c(Yt, Y\u0302t)]\u2212 Et[`a,c(Yt, Y \u2217t )] \u2264 (1\u2212 a) \u2211 i\u2208Y\u0302t ( c(j\u0302i, |Y\u0302t|)\u2212 ( a 1\u2212a + c(j\u0302i, |Y\u0302t|) ) p([\u2206\u0302\u2032i,t \u2212 i,t]D) ) \u2212 (1\u2212 a)\n\u2211 i\u2208Y \u2217t ( c(j\u2217i , |Y \u2217t |)\u2212 ( a 1\u2212a + c(j \u2217 i , |Y \u2217t |) ) p([\u2206\u0302\u2032i,t + i,t]D) ) \u2264 (1\u2212 a)\n\u2211 i\u2208Y\u0302t ( c(j\u0302i, |Y\u0302t|)\u2212 ( a 1\u2212a + c(j\u0302i, |Y\u0302t|) ) p([\u2206\u0302\u2032i,t \u2212 i,t]D) ) \u2212 (1\u2212 a)\n\u2211 i\u2208Y\u0302t ( c(j\u0302i, |Y\u0302t|)\u2212 ( a 1\u2212a + c(j\u0302i, |Y\u0302t|) ) p([\u2206\u0302\u2032i,t + i,t]D) ) = (1\u2212 a)\n\u2211 i\u2208Y\u0302t ( c(j\u0302i, |Y\u0302t|) ( p([\u2206\u0302\u2032i,t + i,t]D)\u2212 p([\u2206\u0302\u2032i,t \u2212 i,t]D) )) \u2264 2 (1\u2212 a) cL\n\u2211 i\u2208Y\u0302t i,t ,\nthe last inequality deriving from c(i, s) \u2264 1 for all i \u2264 s \u2264 K, and\np([\u2206\u0302\u2032i,t + i,t]D)\u2212 p([\u2206\u0302\u2032i,t \u2212 i,t]D) \u2264 cL ( [\u2206\u0302\u2032i,t + i,t]D \u2212 [\u2206\u0302\u2032i,t \u2212 i,t]D ) \u2264 2 cL i,t.\nNow, we first give a proof of Lemma 4, and then provide a one step regret for the partial information ranking loss. Proof: [Lemma 4] Recall the notation Pt(\u00b7) = P(\u00b7 |xt), and pi,t = p(\u2206i,t) = g(\u2212\u2206i,t)g(\u2206i,t)+g(\u2212\u2206i,t) . For notational convenience, in this proof we drop subscript t from pi,t, St, yi,t, Y\u0302t, and `p\u2212rank,t. A simple adaptation of [14] (proof of Theorem 1 therein) shows that for a generic sequence a\u0302 =\n(a\u03021, . . . , a\u0302K) with at most S nonzero values a\u0302i and associated set of indices Y\u0302 , one has\nEt[`p\u2212rank(Yt, a\u0302)] = \u2211\ni,j\u2208Y\u0302 , i<j\n(r\u0302i,j + r\u0302j,i) + S \u2211 i\u2208[K] pi \u2212 \u2211 i\u2208Y\u0302 pi  where\nr\u0302i,j = r\u0302i,j(a\u0302) = Pt(yi > yj) ( {a\u0302i < a\u0302j}+ 12 {a\u0302i = a\u0302j} ) .\nMoreover, if p\u2217 denotes the sequence made up of at most S nonzero values taken from {pi , i \u2208 [K]}, where i ranges again in Y\u0302 , we have\nEt[`p\u2212rank(Yt, p\u2217)] = \u2211\ni,j\u2208Y\u0302 , i<j\n(ri,j + rj,i) + S \u2211 i\u2208[K] pi \u2212 \u2211 i\u2208Y\u0302 pi  with\nri,j = ri,j(p \u2217) = Pt(yi > yj) ( {pi < pj}+ 12 {pi = pj} ) .\nHence Et[`p\u2212rank(Yt, a\u0302)]\u2212 Et[`p\u2212rank(Yt, p\u2217)] = \u2211 i,j\u2208Y\u0302 , i<j (r\u0302i,j \u2212 ri,j + r\u0302j,i \u2212 rj,i) .\nSince Pt(yi > yj)\u2212 Pt(yj > yi) = Pt(yi = 1)\u2212 Pt(yj = 1) = pi \u2212 pj,\na simple (but lengthy) case analysis reveals that\nr\u0302i,j \u2212 ri,j + r\u0302j,i \u2212 rj,i =  1 2 (pi \u2212 pj) If a\u0302i < a\u0302j, pi = pj or a\u0302i = a\u0302j, pi > pj 1 2\n(pj \u2212 pi) If a\u0302i = a\u0302j, pi < pj or a\u0302i > a\u0302j, pi = pj pi \u2212 pj If a\u0302i < a\u0302j, pi > pj pj \u2212 pi If a\u0302i > a\u0302j, pi < pj .\nNotice that the above quantity is always nonnegative, and is strictly positive if the pi are all different. The nonnegativity implies that whatever set of indices Y\u0302 we select, the best way to sort them within Y\u0302 in order to minimize Et[`p\u2212rank(Yt, \u00b7)] is by following the ordering of the corresponding pi.\nWe are left to show that the best choice for Y\u0302 is to collect the S largest11 values in {pi , i \u2208 [K]}. To this effect, consider again Et[`p\u2212rank(Yt, p\u2217)] = Et[`p\u2212rank(Yt, Y\u0302 )], and introduce the shorthand pi,j = pi pj = pi\u2212Pt(yi > yj). Disregarding the term S \u2211 i\u2208[K] pi, which is independent of Y\u0302 , we\n11 It is at this point that we need the conditional independence assumption over the classes.\ncan write Et[`p\u2212rank(Yt, Y\u0302 )] = \u2211\ni,j\u2208Y\u0302 , i<j\nPt(yi > yj) ( {pi < pj}+ 12 {pi = pj} ) +\n\u2211 i,j\u2208Y\u0302 , i<j Pt(yj > yi) ( {pj < pi}+ 12 {pj = pi} ) \u2212 S \u2211 i\u2208Y\u0302 pi\n= \u2211\ni,j\u2208Y\u0302 , i<j\n(pi \u2212 pi,j){pi < pj}+ (pi \u2212 pi,j)12 {pi = pj}\n+ \u2211\ni,j\u2208Y\u0302 , i<j (pj \u2212 pi,j){pj < pi}+ (pj \u2212 pi,j)12 {pj = pi} \u2212 S \u2211 i\u2208Y\u0302 pi\n= \u2211\ni,j\u2208Y\u0302 , i<j (pi \u2212 pj){pi < pj}+ 12 (pi \u2212 pj) {pi = pj}+ pj \u2212 pi,j \u2212 S \u2211 i\u2208Y\u0302 pi\n= \u2211\ni,j\u2208Y\u0302 , i<j (min{pi, pj} \u2212 pipj)\u2212 S \u2211 i\u2208Y\u0302 pi\nwhich can be finally seen to be equal to\n\u2212 \u2211 i\u2208Y\u0302 (S + 1\u2212 j\u0302i) pi \u2212 \u2211 i,j\u2208Y\u0302 , i<j pi pj , (9)\nwhere j\u0302i is the position of class i within Y\u0302t in decreasing order of pi. Now, rename the indices in Y\u0302 as 1, 2, . . . , S, in such a way that p1 > p2 > . . . > pS (so that j\u0302i = i), and consider the way to increase (9) by adding to Y\u0302 item k /\u2208 Y\u0302 such that pS > pk and removing from Y\u0302 the item in position `. Denote the resulting sequence by Y\u0302 \u2032. From (9), it is not hard to see that\nEt[`p\u2212rank(Yt, Y\u0302 )]\u2212 Et[`p\u2212rank(Yt, Y\u0302 \u2032)]\n= (`\u2212 1) p` + S\u2211\ni=`+1 pi \u2212 `\u22121\u2211 i=1 pi p` \u2212 S\u2211 i=`+1 p` pi \u2212 (S \u2212 1) pk + S\u2211 i=1,i 6=` pi pk \u2212 S(p` \u2212 pk)\n= (`\u2212 1) p` + S\u2211\ni=`+1\npi \u2212 (p` \u2212 pk) S\u2211\ni=1,i 6=`\npi \u2212 (S \u2212 1) pk \u2212 S(p` \u2212 pk)\n\u2264 (S \u2212 1) p` \u2212 (p` \u2212 pk) S\u2211\ni=1,i 6=`\npi \u2212 (S \u2212 1) pk \u2212 S(p` \u2212 pk)\n= (pk \u2212 p`) ( 1 +\nS\u2211 i=1,i 6=` pi\n) (10)\nwhich is smaller than zero since, by assumption, p` > pk. Reversing the direction, if we maintain a sequence Y\u0302 of size S, we can always reduce (9) by removing its the last element and replacing it with a larger element outside the sequence. We continue until no element outside the current\nsequence exists which is larger than the smallest one in the sequence. Clearly, we end up collecting the S largest elements in {pi , i \u2208 [K]}.\nFinally, from (9) it is very clear that removing an element from a sequence Y\u0302 with length h \u2264 S can only increase the value of (9). Since this holds for an arbitrary Y\u0302 , and an arbitrary h \u2264 S this shows, that no matter which set Y\u0302 we start off from, we always converge to the same set containing exaclty the S largest elements in {pi , i \u2208 [K]}. This concludes the proof.\nLemma 9. Under the same assumptions and notation as in Lemma 8, combined with the independence assumption (4), let the Algorithm in Figure 1 be working with a\u2192 1 and strictly decreasing cost values c(i, s), i.e., the algorithm is computing in round t the ranking function f\u0302(xt;St) defined in Section 4. Let w\u2032i,t be the i-th weight vector computed by this algorithm at the beginning (Step 2) of time t. If time t is such that |\u2206i,t \u2212 \u2206\u0302\u2032i,t| \u2264 i,t for all i \u2208 [K], then\nEt[`rank,t(Yt, f\u0302(xt;St)]\u2212 Et[`rank,t(Yt, f \u2217(xt;St)] \u2264 4St cL \u2211 i\u2208Y\u0302t i,t .\nProof: We use the same notation as in the proof of Lemma 4, where a\u0302 is now Y\u0302t, the sequence produced by ranking f\u0302(xt;St) operating on p\u0302i,t. Denote by Y \u2217t the sequences determined by f \u2217(xt;St), and let j\u0302i and j\u2217i be the position of class i in decreasing order of pi,t within Y\u0302t and Y \u2217t , respectively.\nProceeding as in Lemma 8 and recalling (9) we can write\nEt[`p\u2212rank,t(Yt, f\u0302(xt;St))]\u2212 Et[`p\u2212rank,t(Yt, f \u2217(xt;St)] = \u2211 i\u2208Y \u2217t (St + 1\u2212 j\u2217i ) pi + \u2211 i,j\u2208Y \u2217t , i<j pi pj \u2212 \u2211 i\u2208Y\u0302t (St + 1\u2212 j\u0302i) pi \u2212 \u2211 i,j\u2208Y\u0302t, i<j pi pj\n\u2264 \u2211 i\u2208Y \u2217t (St + 1\u2212 j\u2217i ) p([\u2206\u0302\u2032i,t + i,t]D) + \u2211 i,j\u2208Y \u2217t , i<j p([\u2206\u0302\u2032i,t + i,t]D) p([\u2206\u0302 \u2032 j,t + j,t]D)\n\u2212 \u2211 i\u2208Y\u0302t (St + 1\u2212 j\u0302i) p([\u2206\u0302\u2032i,t \u2212 i,t]D)\u2212 \u2211 i,j\u2208Y\u0302t, i<j p([\u2206\u0302\u2032i,t \u2212 i,t]D) p([\u2206\u0302\u2032j,t \u2212 j,t]D)\n\u2264 \u2211 i\u2208Y\u0302t (St + 1\u2212 j\u0302i) ( p([\u2206\u0302\u2032i,t + i,t]D)\u2212 p([\u2206\u0302\u2032i,t \u2212 i,t]D) ) +\n\u2211 i,j\u2208Y\u0302t, i<j ( p([\u2206\u0302\u2032i,t + i,t]D) p([\u2206\u0302 \u2032 j,t + j,t]D)\u2212 p([\u2206\u0302\u2032i,t \u2212 i,t]D) p([\u2206\u0302\u2032j,t \u2212 j,t]D) ) \u2264 2StcL\n\u2211 i\u2208Y\u0302t i,t + \u2211 i,j\u2208Y\u0302t, i<j 2cL ( i,t + j,t)\n= 2St cL \u2211 i\u2208Y\u0302t i,t + 2 (St \u2212 1) cL \u2211 i\u2208Y\u0302t i,t\n< 4St cL \u2211 i\u2208Y\u0302t i,t ,\nas claimed.\nLemma 10. Let L : D = [\u2212R,R] \u2286 R \u2192 R+ be a C2(D) convex and nonincreasing function of its argument, (u1, . . . ,uK) \u2208 RdK be defined in (2) with g(\u2206) = \u2212L\u2032(\u2206) for all \u2206 \u2208 D, and such that \u2016ui\u2016 \u2264 U for all i \u2208 [K]. Assume there are positive constants c\u2032L and c\u2032\u2032L with (L\u2032(\u2206))2 \u2264 c\u2032L and L\u2032\u2032(\u2206) \u2265 c\u2032\u2032L for all \u2206 \u2208 D. With the notation introduced in Figure 1, we have that\n(x>w\u2032i,t \u2212 u>i x)2 \u2264 x>A\u22121i,t\u22121x ( U2 +\nd c\u2032L (c\u2032\u2032L) 2 ln\n( 1 +\nt\u2212 1 d\n) + 12\nc\u2032\u2032L ( c\u2032L c\u2032\u2032L + 3L(\u2212R) ) ln K(t+ 4) \u03b4 ) holds with probability at least 1 \u2212 \u03b4 for any \u03b4 < 1/e, uniformly over i \u2208 [K], t = 1, 2, . . . , and x \u2208 Rd.\nProof: For any given class i, the time-t update rule w\u2032i,t \u2192 wi,t+1 \u2192 w\u2032i,t+1 in Figure 1 allows us to start off from [21] (proof of Theorem 2 therein), from which one can extract the following inequality\ndi,t\u22121(ui,w \u2032 i,t)\n\u2264 U2 + 1 (c\u2032\u2032L) 2 t\u22121\u2211 k=1 ri,k \u2212 2 c\u2032\u2032L t\u22121\u2211 k=1 ( \u2207>i,k(w\u2032i,k \u2212 ui)\u2212 c\u2032\u2032L 2 ( si,k x > k (w \u2032 i,k \u2212 ui) )2) , (11)\nwhere we set ri,k = \u2207>i,k A\u22121i,k \u2207i,k. Using the lower bound on the second derivative of L we have\nL(si,k x > kw \u2032 i,k)\u2212 L(si,k u>i xk)\n\u2264 L\u2032(si,k x>kw\u2032i,k)(si,kx>kw\u2032i,k \u2212 si,k u>i xk)\u2212 c\u2032\u2032L 2 (si,k x > kw \u2032 i,k \u2212 si,k u>i xk)2 = \u2207>i,k(w\u2032i,k \u2212 ui)\u2212 c\u2032\u2032L 2 ( si,k x > k (w \u2032 i,k \u2212 ui) )2 .\nPlugging back into (11) yields\ndi,t\u22121(ui,w \u2032 i,t) \u2264 U2 +\n1\n(c\u2032\u2032L) 2 t\u22121\u2211 k=1 ri,k \u2212 2 c\u2032\u2032L t\u22121\u2211 k=1 ( L(si,k x > kw \u2032 i,k)\u2212 L(si,k u>i xk) ) (12)\nWe now borrow a proof technique from [13] (see also [11, 1] and references therein). Define\nLi,k = L(si,k x > kw \u2032 i,k)\u2212 L(si,k u>i xk)\nand L\u2032i,k = Ek[Li,k] \u2212 Li,k. Notice that the sequence of random variables L\u2032i,1, L\u2032i,2, . . . , forms a martingale difference sequence such that, for any i \u2208 Y\u0302k:\ni. Ek[Li,k] \u2265 0, by Lemma 7;\nii. |L\u2032i,k| \u2264 2L(\u2212R), since L(\u00b7) is nonincreasing over D, and si,k x>kw\u2032i,k, si,k u>i xk \u2208 D;\niii. V ark(L\u2032i,k) = V ark(Li,k) \u2264 2c\u2032L c\u2032\u2032L Ek[Li,k] (again, because of Lemma 7).\nOn the other hand, when i /\u2208 Y\u0302k then si,k = 0, and the above three properties are trivally satisfied. Under the above conditions, we are in a position to apply any fast concentration result for bounded martingale difference sequences. For instance, setting for brevity B = B(t, \u03b4) = 3 ln K(t+4)\n\u03b4 , a\nresult contained in [24] allows us derive the inequality\nt\u22121\u2211 k=1 Ek[Li,k]\u2212 t\u22121\u2211 k=1 Li,k \u2265 max  \u221a\u221a\u221a\u221a8c\u2032L c\u2032\u2032L B t\u22121\u2211 k=1 Ek[Li,k], 6L(\u2212R)B  , that holds with probability at most \u03b4\nKt(t+1) for any t \u2265 1. We use the inequality\n\u221a cb \u2264 1\n2 (c + b)\nwith c = 4c \u2032 L\nc\u2032\u2032L B, and b = 2\n\u2211t\u22121 k=1 Ek[Li,k], and simplify. This gives\n\u2212 t\u22121\u2211 k=1 Li,k \u2264 ( 2c\u2032L c\u2032\u2032L + 6L(\u2212R) ) B\nwith probability at least 1\u2212 \u03b4 Kt(t+1) . Using the Cauchy-Schwarz inequality\n(x>w\u2032i,t \u2212 u>i x)2 \u2264 x>A\u22121i,t\u22121 x di,t\u22121(ui,w\u2032i,t)\nholding for any x \u2208 Rd, and replacing back into (12) allows us to conclude that\n(x>w\u2032i,t \u2212 u>i x)2 \u2264 x>A\u22121i,t\u22121x\n( U2 + 1\n(c\u2032\u2032L) 2 t\u22121\u2211 k=1 ri,k + 12 c\u2032\u2032L ( c\u2032L c\u2032\u2032L + 3L(\u2212R) ) ln K(t+ 4) \u03b4 ) (13)\nholds with probability at least 1\u2212 \u03b4 Kt(t+1) , uniformly over x \u2208 Rd. The bounds on \u2211t\u22121 k=1 ri,k can be obtained in a standard way. Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L\u2032(si,k x>kw\u2032i,k) si,kxk we have12\nt\u22121\u2211 k=1 ri,k = t\u22121\u2211 k=1 |si,j| (L\u2032(si,k x>kw\u2032i,k))2 x>k A\u22121i,kxk\n\u2264 c\u2032L t\u22121\u2211 k=1 |si,k|x>k A\u22121i,kxk\n\u2264 c\u2032L t\u22121\u2211 k=1 ln |Ai,k| |Ai,k\u22121| = c\u2032L ln |Ai,t\u22121| |Ai,0|\n\u2264 d c\u2032L ln (\n1 + t\u2212 1 d\n) .\n12 It is in this chain of inequalities that we exploit the rank-one update ofAi,t\u22121 based on xtx>t rather than\u2207i,t\u2207>i,t. Notice that using the latter (as in the worst-case analysis by [21]), does not guarantee a significant progress in the positive definiteness of Ai,t. This is due to the presence of the multiplicative factor g(si,t\u2206\u0302\u2032i,t) (Step 5 in Figure 1) which can be arbitrarily small.\nCombining as in (13) and stratifying over t = 1, 2, . . ., and i \u2208 [K] concludes the proof. We are now ready to put all pieces together. Proof: [Theorem 2] From Lemma 8 and Lemma 10, we see that with probability at least 1\u2212 \u03b4,\nRT \u2264 2 (1\u2212 a) cL T\u2211 t=1 \u2211 i\u2208Y\u0302t i,t , (14)\nwhen 2i,t is the one given in Figure 1. We continue by proving a pointwise upper bound on the sum in the RHS. More in detail, we will find an upper bound on \u2211T t=1 \u2211 i\u2208Y\u0302t 2 i,t, and then derive a resulting upper bound on the RHS of (14). From Lemma 10 and the update rule (Step 5) of the algorithm we can write\n2i,t \u2264 C x>t A\u22121i,t\u22121xt\n= C x>t (Ai,t\u22121 + |si,t|xtx>t )\u22121xt\n1\u2212 |si,t|x>t (Ai,t\u22121 + |si,t|xtx>t )\u22121xt\n= C x>t A \u22121 i,t xt\n1\u2212 |si,t|x>t (Ai,t\u22121 + |si,t|xtx>t )\u22121xt\n\u2264 C x>t A \u22121 i,t xt\n1\u2212 |si,t|x>t (A0 + |si,t|xtx>t )\u22121xt\n= C x>t A \u22121 i,t xt\n1\u2212 1 2\n= 2C x>t A \u22121 i,t xt .\nHence, if we set ri,t = x>t A \u22121 i,t xt and proceed as in the proof of Lemma 10, we end up with the upper bound \u2211T\nt=1 2 i,t \u2264 2C d ln\n( 1 + T\nd\n) , holding for all i \u2208 [K]. Denoting by M the quantity\n2C d ln ( 1 + T\nd\n) , we conclude from (14) that\nRT \u2264 2 (1\u2212 a) cL max \u2211 i\u2208[K] T\u2211 t=1 i,t \u2223\u2223\u2223 T\u2211 t=1 2i,t \u2264M, i \u2208 [K]  = 2 (1\u2212 a) cLK\u221aT M , as claimed. Proof: [Theorem 3] As we said, we change the definition of 2i,t in the Algorithm in Figure 1 to\n2i,t =\nmax { x>A\u22121i,t\u22121x ( 2 d c\u2032L (c\u2032\u2032L) 2 ln ( 1 + t\u2212 1 d ) + 12 c\u2032\u2032L ( c\u2032L c\u2032\u2032L + 3L(\u2212R) ) ln K(t+ 4) \u03b4 ) , 4R2 } .\nFirst, notice that the 4R2 cap seamlessly applies, since (x>w\u2032i,t \u2212 u>i x)2 in Lemma 10 is bounded by 4R2 anyway. With this modification, we have that Theorem 2 only holds for t such that d c \u2032 L\n(c\u2032\u2032L) 2 ln\n( 1 + t\u22121\nd\n) \u2265 U2, i.e., for t \u2265 d ( exp ( (c\u2032\u2032L) 2 U2\nc\u2032L d\n) \u2212 1 ) + 1, while for t <\nd ( exp ( (c\u2032\u2032L) 2 U2\nc\u2032L d\n) \u2212 1 ) + 1 we have in the worst-case scenario the maximum amount of regret\nat each step. From Lemma 8 we see that this maximum amount (the cap on 2i,t is needed here) can be bounded by 4 (1\u2212 a) cL |Y\u0302t|R \u2264 4 (1\u2212 a) cLK R.\nProof: [Theorem 5] We start from the one step-regret delivered by Lemma 9, and proceed as in the proof of Theorem 2. This yields\nRT \u2264 4 cL T\u2211 t=1 St \u2211 i\u2208Y\u0302t i,t\n\u2264 4S cL T\u2211 t=1 \u2211 i\u2208Y\u0302t i,t\n\u2264 4S cL T\u2211 t=1 \u2211 i\u2208[K] i,t\n= 4S cL \u2211 i\u2208[K] T\u2211 t=1 i,t ,\nwith probability at least 1\u2212 \u03b4, where 2i,t is the one given in Figure 1. Let M be as in the proof of Theorem 2. If Ni,T denotes the total number of times class i occurs in Y\u0302t, we have that \u2211T t=1 2 i,t \u2264\nM , implying \u2211T t=1 i,t \u2264 \u221a Ni,T M for all i \u2208 [K]. Moreover, \u2211 i\u2208[K] Ni,T \u2264 ST . Hence\nRT \u2264 4S cL \u2211 i\u2208K] \u221a Ni,T M \u2264 4 cL \u221a M SK T ,\nas claimed."}, {"heading": "7 Conclusions", "text": "We have used generalized linear models to formalize the exploration-exploitation tradeoff in a multilabel/ranking setting with partial feedback, providing T 1/2-like regret bounds under semiadversarial settings. Our analysis decouples the multilabel/ranking loss at hand from the labelgeneration model. Thanks to the usage of calibrated score values p\u0302i,t, our algorithm is capable of automatically inferring where to split the ranking between relevant and nonrelevant classes [17], the split being clearly induced by the loss parameters in `a,c. We are planning on using more general label models that explicitly capture label correlations to be applied to other loss functions (e.g., F-measure, 0/1, average precision, etc.). We are also planning on carrying out a more thorough experimental comparison, especially to full information multilabel methods that take such correlations into account. Finally, we are currenty working on extending our framework to structured output tasks, like (multilabel) hierarchical classification."}], "references": [{"title": "Improved algorithms for linear stochastic bandits", "author": ["Y. Abbasi-Yadkori", "D. Pal", "C. Szepesv\u00e1ri"], "venue": "In Proc. of the 25th NIPS,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "Graphical models for bandit problems", "author": ["K. Amin", "M. Kearns", "U. Syed"], "venue": "In Proc. of UAI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "Using confidence bounds for exploitation-exploration", "author": ["P. Auer"], "venue": "trade-offs. JMLR,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2003}, {"title": "Relative loss bounds for online density estimation with the exponential family of distributions", "author": ["K.S. Azoury", "M.K. Warmuth"], "venue": "Machine Learning,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2001}, {"title": "Partial monitoring with side information", "author": ["G. Bart\u00f3k", "C. Szepesv\u00e1ri"], "venue": "In Proc. 23rd Alt,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Multi-label classification on tree- and dag-structured hierarchies", "author": ["W. Bi", "J. Kwok"], "venue": "In Proc. 28th ICML,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Learning noisy linear classifiers via adaptive and selective sampling", "author": ["G. Cavallanti", "N. Cesa-Bianchi", "C. Gentile"], "venue": "Machine Learning,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "A second-order perceptron algorithm", "author": ["N. Cesa-Bianchi", "A. Conconi", "C. Gentile"], "venue": "In Proc. of the 15th Annual Conference on Computational Learning Theory (COLT", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2002}, {"title": "Incremental algorithms for hierarchical classification", "author": ["N. Cesa-Bianchi", "C. Gentile", "L. Zaniboni"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "Robust bounds for classification via selective sampling", "author": ["N. Cesa-Bianchi", "C. Gentile", "F. Orabona"], "venue": "In Proc. of the 26th International Conference on Machine Learning", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2009}, {"title": "Multiclass classification with bandit feedback using adaptive regularization", "author": ["K. Crammer", "C. Gentile"], "venue": "In Proc. of the 29th International Conference on Machine Learning", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Stochastic linear optimization under bandit feedback", "author": ["V. Dani", "T. Hayes", "S. Kakade"], "venue": "In Proc. of the 21th annual conference on Learning Theory (COLT", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Selective sampling and active learning from single and multiple teachers", "author": ["O. Dekel", "C. Gentile", "K. Sridharan"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "On label dependence and loss minimization in multi-label classification", "author": ["K. Dembczynski", "W. Waegeman", "W. Cheng", "E. Hullermeier"], "venue": "Machine Learning,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2012}, {"title": "Parametric bandits: The generalized linear case", "author": ["S. Filippi", "O. Capp\u00e9", "A. Garivier", "C. Szepesv\u00e1ri"], "venue": "In Proc. NIPS,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "An efficient boosting algorithm for combining preferences", "author": ["Y. Freund", "R.D. Iyer", "R.E. Schapire", "Y. Singer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2003}, {"title": "Multilabel classification via calibrated label ranking", "author": ["J. Furnkranz", "E. Hullermeier", "E. Loza Menca", "K. Brinker"], "venue": "Machine Learning,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "On multilabel classification and ranking with partial feedback", "author": ["C. Gentile", "F. Orabona"], "venue": "In Proc. NIPS 2012,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "Online submodular minimization", "author": ["E. Hazan", "S. Kale"], "venue": "In Proc. NIPS 22,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2009}, {"title": "Newtron: an efficient bandit algorithm for online multiclass prediction", "author": ["E. Hazan", "S. Kale"], "venue": "In NIPS,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2011}, {"title": "Logarithmic regret algorithms for online convex optimization", "author": ["E. Hazan", "A. Agarwal", "S. Kale"], "venue": "Machine Learning,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "Large margin rank boundaries for ordinal regression", "author": ["R. Herbrich", "T. Graepel", "K. Obermayer"], "venue": "In Advances in Large Margin Classifiers,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2000}, {"title": "Multi-label prediction via compressed sensing", "author": ["D. Hsu", "S. Kakade", "J. Langford", "T. Zhang"], "venue": "In Proc. 23rd NIPS,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2009}, {"title": "On the generalization ability of online strongly convex programming", "author": ["S. Kakade", "A. Tewari"], "venue": "In Nips,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2008}, {"title": "Efficient bandit algorithms for online multiclass prediction", "author": ["S. Kakade", "S. Shalev-Shwartz", "A. Tewari"], "venue": "In Proc. 25th ICML,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Non-stochastic bandit slate problems", "author": ["S. Kale", "L. Reyzin", "R. Schapire"], "venue": "In 24th NIPS,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2010}, {"title": "Contextual gaussian process bandit optimization", "author": ["A. Krause", "C.S. Ong"], "venue": "In 25th NIPS,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2011}, {"title": "Asymptotically efficient adaptive allocation rules", "author": ["T.H. Lai", "H. Robbins"], "venue": "Adv. Appl. Math.,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1985}, {"title": "The epoch-greedy algorithm for contextual multi-armed bandits", "author": ["J. Langford", "T. Zhang"], "venue": "Nips", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}, {"title": "Generalized linear models", "author": ["P. McCullagh", "J.A. Nelder"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1989}, {"title": "Improving multilabel analysis of music titles: A large-scale validation of the correction approach", "author": ["F. Pachet", "P. Roy"], "venue": "IEEE Trans. on Audio, Speech, and Lang. Proc.,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2009}, {"title": "Elicitation of personal probabilities and expectations", "author": ["L.J. Savage"], "venue": "Journal of the American Statistical Association,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1973}, {"title": "Online structured prediction via coactive learning", "author": ["P. Shivaswamy", "T. Joachims"], "venue": "In Proc. 29th ICML,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2012}, {"title": "Fonctions de rpartition n dimensions et leurs marges", "author": ["A. Sklar"], "venue": "Publ. Inst. Statist. Univ. Paris,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1959}, {"title": "Learning optimally diverse rankings over large document collections", "author": ["A. Slivkins", "F. Radlinski", "S. Gollapudi"], "venue": "In Proc. of the 27th ICML,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2010}, {"title": "The challenge problem for automated detection of 101 semantic concepts in multimedia", "author": ["C.G.M. Snoek", "M. Worring", "J.C. van Gemert", "J.-M. Geusebroek", "A.W.M. Smeulders"], "venue": "In Proc. of the 14th ACM international conference on Multimedia,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2006}, {"title": "Online learning of assignments", "author": ["M. Streeter", "D. Golovin", "A. Krause"], "venue": "In Proc. of the 23rd NIPS,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2009}, {"title": "Random k-labelsets for multilabel classification", "author": ["G. Tsoumakas", "I. Katakis", "I. Vlahavas"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2011}, {"title": "Generalization bounds for online learning algorithms with pairwise loss functions", "author": ["Y. Wang", "R. Khardon", "D. Pechyony", "R. Jones"], "venue": "In Proc. of the 25th Conference on Learning Theory (COLT),", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2012}], "referenceMentions": [{"referenceID": 27, "context": "This technique has been introduced by [28], and can by now be considered a standard tool.", "startOffset": 38, "endOffset": 42}, {"referenceID": 2, "context": ", [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.", "startOffset": 2, "endOffset": 21}, {"referenceID": 11, "context": ", [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.", "startOffset": 2, "endOffset": 21}, {"referenceID": 14, "context": ", [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.", "startOffset": 2, "endOffset": 21}, {"referenceID": 10, "context": ", [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.", "startOffset": 2, "endOffset": 21}, {"referenceID": 26, "context": ", [3, 12, 15, 11, 27], and references therein) an online algorithm receives at each time step a context (typically, in the form of a feature vector x) and is compelled to select an action (e.", "startOffset": 2, "endOffset": 21}, {"referenceID": 2, "context": "For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features.", "startOffset": 14, "endOffset": 28}, {"referenceID": 11, "context": "For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features.", "startOffset": 14, "endOffset": 28}, {"referenceID": 14, "context": "For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features.", "startOffset": 14, "endOffset": 28}, {"referenceID": 0, "context": "For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features.", "startOffset": 14, "endOffset": 28}, {"referenceID": 14, "context": "For instance, [3, 12, 15, 1] work in a finite action space where the mappings context-to-loss for each action are linear (or generalized linear, as [15]\u2019s) functions of the features.", "startOffset": 148, "endOffset": 152}, {"referenceID": 26, "context": "This is extended by [27], where the loss function is modeled as a sample from a Gaussian process over the joint context-action space.", "startOffset": 20, "endOffset": 24}, {"referenceID": 28, "context": "An earlier (but somehow more general) setting that models such mappings by VC-classes is considered by [29], where a T 2/3 regret bound has been proven under i.", "startOffset": 103, "endOffset": 107}, {"referenceID": 24, "context": ", [25, 11, 20], where either T 2/3 or T 1/2 or even logarithmic regret bounds are proven, depending on the noise model and the underlying loss functions.", "startOffset": 2, "endOffset": 14}, {"referenceID": 10, "context": ", [25, 11, 20], where either T 2/3 or T 1/2 or even logarithmic regret bounds are proven, depending on the noise model and the underlying loss functions.", "startOffset": 2, "endOffset": 14}, {"referenceID": 19, "context": ", [25, 11, 20], where either T 2/3 or T 1/2 or even logarithmic regret bounds are proven, depending on the noise model and the underlying loss functions.", "startOffset": 2, "endOffset": 14}, {"referenceID": 18, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 36, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 25, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 34, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 32, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 1, "context": "Along these lines are [19, 37, 26, 35, 33, 2].", "startOffset": 22, "endOffset": 45}, {"referenceID": 18, "context": "The general problem of online minimization of a submodular loss function under both full and bandit information without covariates is considered by [19], achieving a regret T 2/3 in the bandit case.", "startOffset": 148, "endOffset": 152}, {"referenceID": 36, "context": "[37] consider the problem of online learning of assignments, where at each round an algorithm is requested to assign positions (e.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "Another paper with similar goals but a different mathematical model is by [26], where the aim is to learn a suitable ordering (an \u201cordered slate\u201d) of the available actions.", "startOffset": 74, "endOffset": 78}, {"referenceID": 34, "context": "[35] motivate the ability of selecting sets of actions by a problem of diverse retrieval in large document collections which are meant to live in a general metric space.", "startOffset": 0, "endOffset": 4}, {"referenceID": 32, "context": "[33] use a simple linear model for the hidden utility function of users interacting with a web system and providing partial feedback in any form that allows the system to make significant progress in learning this function (this is called an \u03b1-informative feedback by the authors).", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "The recent paper [2] investigates classes of graphical models for contextual bandit settings that afford richer interaction between contexts and actions leading again to a T 2/3 regret bound.", "startOffset": 17, "endOffset": 20}, {"referenceID": 17, "context": "Finally, a very interesting recent work that came to our attention at the time of writing this extended version of our conference paper [18] is [5].", "startOffset": 136, "endOffset": 140}, {"referenceID": 4, "context": "Finally, a very interesting recent work that came to our attention at the time of writing this extended version of our conference paper [18] is [5].", "startOffset": 144, "endOffset": 147}, {"referenceID": 4, "context": "The results presented by [5] do not seem to conveniently extend to the structured action space setting we are interested in (or, if they do, we do not see it in the current version of their paper).", "startOffset": 25, "endOffset": 28}, {"referenceID": 37, "context": "Relevant references include [38, 17, 14], along with references therein.", "startOffset": 28, "endOffset": 40}, {"referenceID": 16, "context": "Relevant references include [38, 17, 14], along with references therein.", "startOffset": 28, "endOffset": 40}, {"referenceID": 13, "context": "Relevant references include [38, 17, 14], along with references therein.", "startOffset": 28, "endOffset": 40}, {"referenceID": 13, "context": "In contrast to that, the specific setting we are considering here need not face such a modeling [14].", "startOffset": 96, "endOffset": 100}, {"referenceID": 38, "context": "recent work [39] reduces any online algorithm working on pairwise loss functions (like a ranking loss) to a batch algorithm with generalization bound guarantees.", "startOffset": 12, "endOffset": 16}, {"referenceID": 21, "context": "Other related references are [22, 16], where learning is by pairs of examples.", "startOffset": 29, "endOffset": 37}, {"referenceID": 15, "context": "Other related references are [22, 16], where learning is by pairs of examples.", "startOffset": 29, "endOffset": 37}, {"referenceID": 2, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 11, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 12, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 10, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 14, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 0, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 26, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 4, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 85, "endOffset": 114}, {"referenceID": 36, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 173, "endOffset": 185}, {"referenceID": 25, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 173, "endOffset": 185}, {"referenceID": 32, "context": "To summarize, whereas we are technically closer to the linear modeling approaches by [3, 12, 13, 11, 15, 1, 27, 5], from a motivational standpoint we are perhaps closest to [37, 26, 33].", "startOffset": 173, "endOffset": 185}, {"referenceID": 18, "context": ", [19, 37, 1, 27]), we are not assuming the algorithm is observing a noisy version of the risk function on the currently selected action.", "startOffset": 2, "endOffset": 17}, {"referenceID": 36, "context": ", [19, 37, 1, 27]), we are not assuming the algorithm is observing a noisy version of the risk function on the currently selected action.", "startOffset": 2, "endOffset": 17}, {"referenceID": 0, "context": ", [19, 37, 1, 27]), we are not assuming the algorithm is observing a noisy version of the risk function on the currently selected action.", "startOffset": 2, "endOffset": 17}, {"referenceID": 26, "context": ", [19, 37, 1, 27]), we are not assuming the algorithm is observing a noisy version of the risk function on the currently selected action.", "startOffset": 2, "endOffset": 17}, {"referenceID": 10, "context": "In this sense, we are more similar to the multiclass bandit algorithm by [11].", "startOffset": 73, "endOffset": 77}, {"referenceID": 10, "context": "Yet, our work is a substantial departure from [11]\u2019s in that we lift their machinery to nontrivial structured action spaces, and we do so by means of generalized linear models.", "startOffset": 46, "endOffset": 50}, {"referenceID": 0, "context": "Specifically, given constant a \u2208 [0, 1] and costs c = {c(i, s), i = 1, .", "startOffset": 33, "endOffset": 39}, {"referenceID": 16, "context": "In this sense, the above problem can be seen as a partial information version of the multilabel ranking problem (see [17], 1 An ordered subset is like a list with no repeated items.", "startOffset": 117, "endOffset": 121}, {"referenceID": 0, "context": "2Notice that a is not redundant here, since the costs c(i, s) have been normalized to [0,1].", "startOffset": 86, "endOffset": 91}, {"referenceID": 29, "context": "3 The reader familiar with generalized linear models will recognize the derivative of the function p(\u2206) = g(\u2212\u2206) g(\u2206)+g(\u2212\u2206) as the (inverse) link function of the associated canonical exponential family of distributions [30].", "startOffset": 218, "endOffset": 222}, {"referenceID": 33, "context": "A classical result in the theory of copulas [34] makes one derive all allowed joint distributions starting from the corresponding one-dimensional marginals.", "startOffset": 44, "endOffset": 48}, {"referenceID": 10, "context": "We use a similar but largely more general analysis than [11]\u2019s to devise an online second-order descent algorithm whose updating rule makes the comparison vector U = (u1, .", "startOffset": 56, "endOffset": 60}, {"referenceID": 0, "context": "Parameters: loss parameters a \u2208 [0, 1], cost values c(i, s), interval D = [\u2212R,R], function g : D \u2192 R, confidence level \u03b4 \u2208 [0, 1].", "startOffset": 32, "endOffset": 38}, {"referenceID": 0, "context": "Parameters: loss parameters a \u2208 [0, 1], cost values c(i, s), interval D = [\u2212R,R], function g : D \u2192 R, confidence level \u03b4 \u2208 [0, 1].", "startOffset": 123, "endOffset": 129}, {"referenceID": 20, "context": ", [21].", "startOffset": 2, "endOffset": 6}, {"referenceID": 20, "context": "This feature tells this algorithm slightly apart from the Online Newton step algorithm [21], which is the starting point of our analysis.", "startOffset": 87, "endOffset": 91}, {"referenceID": 10, "context": ", by [11]), one can use a version of the algorithm which maintains diagonal matrices Ai,t instead of full ones.", "startOffset": 5, "endOffset": 9}, {"referenceID": 13, "context": ", [14]), one can view any multilabel assignment Y = (y1, .", "startOffset": 2, "endOffset": 6}, {"referenceID": 13, "context": "As pointed out by [14], the ranking function f(xt) = (p1,t, .", "startOffset": 18, "endOffset": 22}, {"referenceID": 16, "context": ", f \u2217 K(xt)), 8 This is called the zero point by [17].", "startOffset": 49, "endOffset": 53}, {"referenceID": 13, "context": "This is in striking contrast to the full information setting, where the Bayes optimal ranking only depends on the marginal distribution values pi,t [14].", "startOffset": 148, "endOffset": 152}, {"referenceID": 22, "context": ", [23] and references therein) and/or the specific structure of the set of labels (e.", "startOffset": 2, "endOffset": 6}, {"referenceID": 8, "context": ", [9, 6], and references therein).", "startOffset": 2, "endOffset": 8}, {"referenceID": 5, "context": ", [9, 6], and references therein).", "startOffset": 2, "endOffset": 8}, {"referenceID": 35, "context": "The first one, called Mediamill, was introduced in a video annotation challenge [36].", "startOffset": 80, "endOffset": 84}, {"referenceID": 30, "context": "The second dataset is Sony CSL Paris [31], made up of 16,452 train samples and 16,519 test samples, each sample being described by d = 98 features.", "startOffset": 37, "endOffset": 41}, {"referenceID": 31, "context": ", [32]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 13, "context": "A simple adaptation of [14] (proof of Theorem 1 therein) shows that for a generic sequence \u00e2 =", "startOffset": 23, "endOffset": 27}, {"referenceID": 20, "context": "Proof: For any given class i, the time-t update rule wi,t \u2192 wi,t+1 \u2192 wi,t+1 in Figure 1 allows us to start off from [21] (proof of Theorem 2 therein), from which one can extract the following inequality di,t\u22121(ui,w \u2032 i,t) \u2264 U + 1 (c\u2032\u2032 L) 2 t\u22121 \u2211", "startOffset": 116, "endOffset": 120}, {"referenceID": 12, "context": "We now borrow a proof technique from [13] (see also [11, 1] and references therein).", "startOffset": 37, "endOffset": 41}, {"referenceID": 10, "context": "We now borrow a proof technique from [13] (see also [11, 1] and references therein).", "startOffset": 52, "endOffset": 59}, {"referenceID": 0, "context": "We now borrow a proof technique from [13] (see also [11, 1] and references therein).", "startOffset": 52, "endOffset": 59}, {"referenceID": 23, "context": "For instance, setting for brevity B = B(t, \u03b4) = 3 ln K(t+4) \u03b4 , a result contained in [24] allows us derive the inequality", "startOffset": 86, "endOffset": 90}, {"referenceID": 3, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 7, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 9, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 6, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 20, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 12, "context": "Applying known inequalities [4, 8, 10, 7, 21, 13], and using the fact that\u2207i,k = L(si,k xkwi,k) si,kxk we have12 t\u22121 \u2211", "startOffset": 28, "endOffset": 49}, {"referenceID": 20, "context": "Notice that using the latter (as in the worst-case analysis by [21]), does not guarantee a significant progress in the positive definiteness of Ai,t.", "startOffset": 63, "endOffset": 67}, {"referenceID": 16, "context": "Thanks to the usage of calibrated score values p\u0302i,t, our algorithm is capable of automatically inferring where to split the ranking between relevant and nonrelevant classes [17], the split being clearly induced by the loss parameters in `a,c.", "startOffset": 174, "endOffset": 178}], "year": 2013, "abstractText": "We present a novel multilabel/ranking algorithm working in partial information settings. The algorithm is based on 2nd-order descent methods, and relies on upper-confidence bounds to trade-off exploration and exploitation. We analyze this algorithm in a partial adversarial setting, where covariates can be adversarial, but multilabel probabilities are ruled by (generalized) linear models. We show O(T 1/2 log T ) regret bounds, which improve in several ways on the existing results. We test the effectiveness of our upper-confidence scheme by contrasting against full-information baselines on real-world multilabel datasets, often obtaining comparable performance.", "creator": "LaTeX with hyperref package"}}}