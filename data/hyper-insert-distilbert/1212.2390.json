{"id": "1212.2390", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Dec-2012", "title": "On the complexity of learning a language: An improvement of Block's algorithm", "abstract": "language computational learning is originally thought basically to be a highly complex process. often one of essentially the hurdles covered in continually learning a mathematical language is to learn the rules interpretation of natural syntax of managing the programmed language. rules of a syntax generally are often therefore ordered internally in that before one rule can already applied whilst one operator must apply another. traditionally it has been thought that to learn among the order one of 43 n rules theoretically one must go through all n! } permutations. thus writing to learn the order 2 of 27 rules coding would require 27! steps _ or 1. 08889x10 ^ { 28 } steps. this extra number is becoming much probably greater accomplishment than maintaining the number of seconds since the numerical beginning of compiling the universe! in an insightful analysis the linguist block ( [ [UNK] block 86 ], # pp. 62 - volume 63, p. 58 238 ) showed basically that with essentially the sophisticated assumption of transitivity to this unusually vast number of learning steps reduces mathematics to a great mere 377 successive steps. we present a mathematical analysis of the complexity of editing block's algorithm. the algorithm has a complexity of order n ^ log 2 given n _ rules. ^ in addition, we essentially improve managing block's coding results here exponentially, aided by theoretically introducing approximately an internal algorithm component that rapidly has complexity of order n less than n \u2010 log % n.", "histories": [["v1", "Tue, 11 Dec 2012 11:35:30 GMT  (4kb)", "http://arxiv.org/abs/1212.2390v1", "7 pages. Key Words: Language learning, rules of language, complexity, learning algorithms, evolution of language"]], "COMMENTS": "7 pages. Key Words: Language learning, rules of language, complexity, learning algorithms, evolution of language", "reviews": [], "SUBJECTS": "cs.CL cs.LG", "authors": ["eric werner"], "accepted": false, "id": "1212.2390"}, "pdf": {"name": "1212.2390.pdf", "metadata": {"source": "CRF", "title": "On the complexity of learning a language: An improvement of Block\u2019s algorithm", "authors": ["Eric Werner"], "emails": ["eric.werner@dpag.ox.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n21 2.\nLanguage learning is thought to be a highly complex process. One of the hurdles in learning a language is to learn the rules of syntax of the language. Rules of syntax are often ordered in that before one rule can applied one must apply another. It has been thought that to learn the order of n rules one must go through all n! permutations. Thus to learn the order of 27 rules would require 27! steps or 1.08889x1028 steps. This number is much greater than the number of seconds since the beginning of the universe! In an insightful analysis the linguist Block ([Block 86], pp. 62-63, p.238) showed that with the assumption of transitivity this vast number of learning steps reduces to a mere 377 steps. We present a mathematical analysis of the complexity of Block\u2019s algorithm. The algorithm has a complexity of order n2 given n rules. In addition, we improve Block\u2019s results exponentially, by introducing an algorithm that has complexity of order less than n log n.\nKey Words: Language learning, rules of language, complexity, learning algorithms, evolution of language.\n\u2217Balliol Graduate Centre, Oxford Advanced Research Foundation (http://oarf.org). c\u00a9Eric Werner 2012. All rights reserved.\n1\nContents"}, {"heading": "1 Introduction 2", "text": ""}, {"heading": "2 Block\u2019s algorithm 3", "text": "2.1 Complexity of Block\u2019s algorithm . . . . . . . . . . . . . . . . . . . . . . . 3\n2.2 A simpler formula measuring Block\u2019s algorithm\u2019s complexity . . . . . . . 3"}, {"heading": "3 A fast algorithm to learn the order of n rules 4", "text": "3.1 A faster rule ordering algorithm . . . . . . . . . . . . . . . . . . . . . . . 4\n3.2 Complexity of the fast rule ordering algorithm . . . . . . . . . . . . . . . 5\n3.3 An shorter but less accurate complexity function . . . . . . . . . . . . . . 5"}, {"heading": "4 Examples comparing the performance of the algorithms 6", "text": ""}, {"heading": "1 Introduction", "text": "Language learning is thought to be a highly complex process. One of the hurdles in learning a language is to learn the rules of syntax of the language. Rules of syntax are often ordered in that before one can apply one rule one must apply another. It has been thought that to learn the order of n rules one must go through all n! permutations. Thus to learn the order of 27 rules would require 27! steps or 1.08889x1028 steps. This number is much greater than the number of seconds since the beginning of the universe! In a brilliant analysis the linguist Block ([Block 86], pp. 62-63, p.238) showed that with the assumption of transitivity this vast number of learning steps reduces to a mere 377 steps.\nWe present a mathematical analysis of the complexity of Block\u2019s algorithm. The algorithm has a complexity of order n2 given n rules. In addition, we improve on Block\u2019s algorithm, by introducing an algorithm that has complexity of order less than n logn. For example, given 27 rules our method requires 104 steps."}, {"heading": "2 Block\u2019s algorithm", "text": "Given n rules R1 . . . Rn we are to guess (learn) an unknown ordering of these rules. Starting with any given rule Y , we are to position a rule X . To do this we test (query, learn) if X is before Y , if so we place it before Y to give the sequence XY , else we place it after Y resulting in Y X . Now, assume we have ordered i rules Y1 . . . Yi and we have to a new place rule X , Block suggests we test for each j if X < Yj, if so all we need do is to place X before Yj in our sequence Y1 . . . Yj . . . Yi to give Y1 . . .XYj . . . Yi. The reason we can do this is because the rules are linearly ordered and hence by transitivity we know X is less than all rules beyond Yj. Hence, we need test no further. If X is not less than Yj we continue until we find such a j. If we don\u2019t find such a j, then we know that X is greater than all all the given rules and we place X at the end to give Y1 . . . YiX . Thus starting with one rule we gradually build up our knowledge about the order of the rules."}, {"heading": "2.1 Complexity of Block\u2019s algorithm", "text": "At any stage, given we know the order of rules Y1 . . . Yi , it takes at most i comparisons to place our new rule X . Hence, to learn the total rule set R1 . . . Rn it takes at most 1 + 2 + . . .+ i+ . . . + n steps. This worst case is how computer scientists measure the complexity of an algorithm.\nS(n) = n\u2211\ni=1\ni\u2212 1 = n\u2211\ni=2\ni (1)\nWe subtract 1 (or equivalently start with 2) because the first rule does not have to be tested or compared. Thus, we have a measure of the complexity of Block\u2019s algorithm in defined in terms of the number of queries or steps needed to order n rules."}, {"heading": "2.2 A simpler formula measuring Block\u2019s algorithm\u2019s complex-", "text": "ity\nThere is a simpler and shorter formula that eliminates the need to sum up the steps and thereby can easily be done on a calculator. It gives an exact characterization of the steps needed to order n rules:\nExact complexity of Block\u2019s algorithm\nS(n) = (n2 \u2212 n)\n2 + n\u2212 1 (2)\nSince, the exponent of 2 ultimately overpowers any addition or division by a constant, the complexity of Block\u2019s algorithm is O(n2).\nFor example, for 27 rules it takes at most \u2211 27\ni=1 i = 27+26+ . . .+2 = 377 This is, of course, a very modest number when compared to the estimates of 27! = 1.08889x1028 steps by some linguists. For practical, purposes one would think this is enough and we should be satisfied with such an astounding reduction of steps needed to learn some 27 rules.\nHowever, if we increase the number of rules to hundreds, we quickly face numbers that may again seem insurmountable for the developing brain of a child. The method we present here improves on Blocks algorithm significantly since it is exponentially more efficient. As a result, even the ordering of thousands of rules can be learned relatively quickly.\nFor example, for one thousand rules, the number of steps required to determine the ordering of the rules using Block\u2019s algorithm is 500, 499 steps. Below we will show that for this case we can improve this to less than 8, 977 steps which is about 55 times faster."}, {"heading": "3 A fast algorithm to learn the order of n rules", "text": "Block\u2019s algorithm moves linearly from start to end to find and test if the rule is before or after the given rule. Instead we will adapt binary search to start at the middle of the sequence of rules and test the rule there. This will give us an exponential improvement over Block\u2019s method."}, {"heading": "3.1 A faster rule ordering algorithm", "text": "Given n rules and a rule X that needs to be placed in its proper order, choose the middle rule, call it Y . This can be done since the rules are linearly ordered. Test to see if the rule is applied before Y if so test the middle rule between Y and the first rule, else test the middle rule between the end rule and rule Y . Repeat until done."}, {"heading": "3.2 Complexity of the fast rule ordering algorithm", "text": "In effect we use binary search to find the proper place to insert our new rule Y given n rules. And, this process takes at most n logn steps. Hence, given we have n rules to insert into at most n rules, we have at most n log n steps to find the completely ordered sequence of n rules.\nActually, the process takes fewer steps. Since, work incrementally starting with n = 1, call this one rule Y and one rule X to insert we just have to make one test to see if X < Y or not. If it is less than Y we insert X before Y giving XY else we insert it after Y resulting in the partial sequence Y X . We then pick the next rule Z and insert it. Given a sequence of n rules we insert X at each stage according to the binary search algorithm above.\nHence, for n rules we require at most\nB(n) = \u2308log(n)\u2309 + \u2308log(n\u2212 1)\u2309+ \u2308log(n\u2212 2)\u2309+ . . .+ \u2308log(n\u2212 (n\u2212 1))\u2309 (3)\nsteps to order them.\nNotation Throughout this article we use log to mean the logarithm base 2. The notation, \u2308\u03b1\u2309 denotes the smallest integer i greater than or equal to the number \u03b1. The log of a number will in general not be an integer. This promotes a real (floating point) number to the next integer since we are counting steps in an algorithm and they are discrete.\nExpressed more succinctly we have:\nComplexity of the fast algorithm\nB(n) = n\u22121\u2211\ni=0\n\u2308log(n\u2212 i)\u2309 (4)\nNote, that B(n) < n logn. Thus, the complexity is less than O(nlogn)."}, {"heading": "3.3 An shorter but less accurate complexity function", "text": "Looking at it from a different perspective, we can shorten the description of the complexity function by using factorial.\nn\u22121\u2211\ni=0\nlog(n\u2212 i) = log(n) + log(n\u2212 1) + log(n\u2212 2) + . . .+ log(n\u2212 (n\u2212 1))\n= log(n(n\u2212 1)(n\u2212 2) . . . (n\u2212 (n\u2212 1))) = log(n!)\nThus, we can get an approximation to the function B(n) in equation 4 using the following:\nBf (n) = \u2308log(n!)\u2309 (5)\nHowever, this formulation has the disadvantage that the size of the factorial quickly expands to be computationally impractical. In addition, the result is not as accurate in that it underestimates the complexity because the log is used instead of \u2308log\u2309 when log(n!) is calculated. If we add n to the result, giving log(n!)+n we get an overestimate. Thus,\nlog(n!) < B(n) < log(n!) + n (6)"}, {"heading": "4 Examples comparing the performance of the al-", "text": "gorithms\nFor example, for 27 rules Block\u2019s algorithm requires 377 steps. We need only 104 steps which is which is 3.6 times faster. However, since there is an exponential improvement using the fast algorithm, the differences become more dramatic the larger the number of rules that are to be ordered. For example, for 1, 000 rules, some linguists would tell us we need to search through 1000! possible combinations. Using Block\u2019s algorithm, we need only 500, 499 steps, a much much smaller number. With our improved fast algorithm we need less than 8, 977 steps which is more than 55 times faster (smaller) in this case. So, for instance, if a child would learn to order two rules per day (into its given set of learned rules), it would take 685 years to learn the ordering of 1,000 rules using Block\u2019s method. With our fast method it would take about 12 years.\nThere is the question to what extent such considerations are relevant to learning a language. The above presupposed that the rules are linearly ordered. That means each rule stands in a unique linear relationship to all the other rules. Partially ordered rules are yet another matter."}], "references": [{"title": "Revolution und Revision in der generativen Theoriebildung", "author": ["R.L. Block"], "venue": "Gunter Narr Verlag, Tuebingen,", "citeRegEx": "Block,? \\Q1986\\E", "shortCiteRegEx": "Block", "year": 1986}], "referenceMentions": [], "year": 2012, "abstractText": "Language learning is thought to be a highly complex process. One of the hurdles in learning a language is to learn the rules of syntax of the language. Rules of syntax are often ordered in that before one rule can applied one must apply another. It has been thought that to learn the order of n rules one must go through all n! permutations. Thus to learn the order of 27 rules would require 27! steps or 1.08889x10 steps. This number is much greater than the number of seconds since the beginning of the universe! In an insightful analysis the linguist Block ([Block 86], pp. 62-63, p.238) showed that with the assumption of transitivity this vast number of learning steps reduces to a mere 377 steps. We present a mathematical analysis of the complexity of Block\u2019s algorithm. The algorithm has a complexity of order n given n rules. In addition, we improve Block\u2019s results exponentially, by introducing an algorithm that has complexity of order less than n log n.", "creator": "LaTeX with hyperref package"}}}