{"id": "1301.1391", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Backdoors to Normality for Disjunctive Logic Programs", "abstract": "over precisely the last two straight decades, propositional satisfiability ( sat ) technique has become technically one domain of the most successful fundamental and continuously widely applied approach techniques for locating the solution of np - complete problems. the aim of following this briefing paper really is to investigate theoretically predict how different sat algorithms can sometimes be utilized for the commercially efficient constraint solution of problems that are harder than an np or co - intuitive np. in particular, we consider the essentially fundamental reasoning solution problems implemented in propositional disjunctive weighted answer test set programming ( asp ), theoretical brave reasoning applications and cautious reasoning, which ask on whether a given turing atom is contained in at physically least rank one one or in all answer sets, respectively. both problems are located entirely at the only second level of the partial polynomial hierarchy and thus here assumed to certainly be harder than np itself or naturally co - inaccessible np. we fundamentally cannot transform these two fuzzy reasoning computational problems to sat effective in sufficiently polynomial distribution time, unless the polynomial utility hierarchy collapses.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:37 GMT  (156kb,D)", "https://arxiv.org/abs/1301.1391v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"], ["v2", "Thu, 2 May 2013 17:17:43 GMT  (30kb)", "http://arxiv.org/abs/1301.1391v2", "A short version will appear in the Proceedings of the Proceedings of the 27th AAAI Conference on Artificial Intelligence (AAAI'13). A preliminary version of the paper was presented on the workshop Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.CC", "authors": ["johannes klaus fichte", "stefan szeider"], "accepted": true, "id": "1301.1391"}, "pdf": {"name": "1301.1391.pdf", "metadata": {"source": "CRF", "title": "Backdoors to Normality for Disjunctive Logic Programs", "authors": ["Johannes Klaus Fichte"], "emails": ["fichte@kr.tuwien.ac.at,", "stefan@szeider.net"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 1.\n13 91\nv2 [\ncs .L\nO ]\n2 M\nay 2\nWe show that certain structural aspects of disjunctive logic programs can be utilized to break through this complexity barrier, using new techniques from Parameterized Complexity. In particular, we exhibit transformations from Brave and Skeptical Reasoning to Sat that run in time O(2kn2) where k is a structural parameter of the instance and n the input size. In other words, the reduction is fixed-parameter tractable for parameter k. As the parameter k we take the size of a smallest backdoor with respect to the class of normal (i.e., disjunction-free) programs. Such a backdoor is a set of atoms that when deleted makes the program normal. In consequence, the combinatorial explosion, which is expected when transforming a problem from the second level of the Polynomial Hierarchy to the first level, can now be confined to the parameter k, while the running time of the reduction is polynomial in the input size n, where the order of the polynomial is independent of k. We show that such a transformation is not possible if we consider backdoors with respect to tightness instead of normality.\nWe think that our approach is applicable to many other hard combinatorial problems that lie beyond NP or co-NP, and thus significantly enlarge the applicability of Sat."}, {"heading": "1 Introduction", "text": "Over the last two decades, propositional satisfiability (Sat) has become one of the most successful and widely applied techniques for the solution of NP-complete problems. Today\u2019s Sat-solvers are extremely efficient and robust, instances with hundreds of thousands of variables and clauses can be solved routinely. In fact, due to the success of Sat, NP-complete problems have lost their scariness, as in many cases one can efficiently encode NP-complete problems to Sat and solve them by means of a Sat-solver [Gomes et al., 2008; Biere et al., 2009].\nWe investigate transformations into Sat for problems that are harder than NP or co-NP. In particular, we consider various search problems that arise in disjunctive answer set programming\n\u2217Research supported by the ERC, Grant COMPLEX REASON 239962. \u2020This is the author\u2019s self-archived copy including detailed proofs. A preliminary version of the paper was presented on\nthe workshop ASPOCP\u201912.\n(Asp). With Asp one can describe a problem by means of rules that form a disjunctive logic program, whose solutions are answer sets. Many important problems of AI and reasoning can be represented in terms of the search for answer sets [Brewka et al., 2011; Marek and Truszczynski, 1999; Niemela\u0308, 1999]. Two of the most fundamental Asp problems are Brave Reasoning (is a certain atom contained in at least one answer set?) and Skeptical Reasoning (is a certain atom contained in all answer sets?). Both problems are located at the second level of the Polynomial Hierarchy [Eiter and Gottlob, 1995] and thus assumed to be harder than NP or co-NP. It would be desirable to utilize Sat-solvers for these problems. However, we cannot transform these two reasoning problems into Sat in polynomial time, unless the Polynomial Hierarchy collapses, which is believed to be unlikely.\nNew Contribution In this work we show how to utilize certain structural aspects of disjunctive logic programs to transform the two Asp reasoning problems into Sat. In particular, we exhibit a transformation to Sat that runs in time O(2kn2) where k is a structural parameter of the instance and n is the input size of the instance. Thus the combinatorial explosion, which is expected when transforming problems from the second level of the Polynomial Hierarchy to the first level, is confined to the parameter k, while the running time is polynomial in the input size n and the order of the polynomial is independent of k. Such transformations are known as \u201cfpt-transformations\u201d and form the base of the completeness theory of Parameterized Complexity [Downey and Fellows, 1999; Flum and Grohe, 2006]. Our reductions break complexity barriers as they move problems form the second to the first level of the Polynomial Hierarchy.\nIt is known that the two reasoning problems, when restricted to so-called normal programs, drop to NP and co-NP [Bido\u0301\u0131t and Froidevaux, 1991; Marek and Truszczynski, 1991a; Marek and Truszczyn\u0301ski, 1991b], respectively. Hence, it is natural to consider a structural parameter k as the distance of a given program from being normal. We measure the distance in terms of the smallest number of atoms that need to be deleted to make the program normal. Following Williams et al. [2003] we call such a set of deleted atoms a backdoor. We show that in time O(2kn2) we can solve both of the following two tasks for a given program P of input size n and an atom a\u2217:\nBackdoor Detection: Find a backdoor of size at most k of the given program P , or decide that a backdoor of size k does not exist.\nBackdoor Evaluation: Transform the program P into two propositional formulas FBrave(a \u2217) and\nFSkept(a \u2217) such that (i) FBrave(a \u2217) is satisfiable if and only if a\u2217 is in some answer set of P , and (ii) FSkept(a\n\u2217) is unsatisfiable if and only if a\u2217 is in all answer sets of P . Tightness is a property of disjunctive logic programs that, similar to normality, lets the complexities of Brave and Skeptical Reasoning drop to NP and co-NP, respectively [Clark, 1978; Fages, 1994]. Consequently, one could also consider backdoors to tightness. We show, however, that the reasoning problems already reach their full complexities (i.e., completeness for the second level of the Polynomial Hierarchy) with programs of distance one from being tight. Hence, an fpt-transformation into Sat for programs of distance k > 0 from being tight is not possible unless the Polynomial Hierarchy collapses.\nRelated Work Williams, Gomes, and Selman [2003] introduced the notion of backdoors to explain favorable running times and the heavy-tailed behavior of Sat and CSP solvers on practical instances. The parameterized complexity of finding small backdoors was initiated by Nishimura, Ragde, and Szeider [2004]. For further results regarding the parameterized complexity of problems related to backdoors for Sat, we refer to a recent survey paper [Gaspers and Szeider, 2012]. Fichte and Szeider [2012] formulated a backdoor approach for Asp problems, and obtained complexity results with respect to the target class of Horn programs and various target classes based on acyclicity; some results could be generalized [Fichte, 2012]. Both papers are limited to target classes where we can enumerate the set of all answer sets in polynomial time. The results do not carry over to the present work since here we consider target classes where the problem of determining an answer set is already NP-hard.\nTranslations from Asp problems to Sat have been explored by several authors; existing research mainly focuses on transforming programs for which the reasoning problems already belong to NP or co-NP. In particular, translations have been considered for head cycle free programs [Ben-Eliyahu and\nDechter, 1994], tight programs [Fages, 1994], and normal programs [Lin and Zhao, 2004; Janhunen, 2006].\nSome authors have generalized the above translations to capture programs for which the reasoning problems are outside NP and co-NP. Janhunen et al. [2006] considered programs where the number of disjunctions in the heads of rules is bounded. They provided a translation that allows a Sat encoding of the test whether a candidate set of atoms is indeed an answer set of the input program. Lee and Lifschitz [2003] considered programs with a bounded number of cycles in the positive dependency graph. They suggested a translation that, similar to ours, transforms the input program into an exponentially larger propositional formula whose satisfying assignments correspond to answer sets of the program. As pointed out by Lifschitz and Razborov [2006], this translation produces an exponential blowup already for normal programs (we note that by way of contrast, our translation is in fact quadratic for normal programs).\nOver the last few years, several Sat techniques have been integrated into practical Asp solvers. In particular, solvers for normal programs (Cmodels [Giunchiglia et al., 2006], ASSAT [Lin and Zhao, 2004], Clasp [Gebser et al., 2007a]) use certain extensions of Clark\u2019s completion and then utilize either black box Sat solvers or integrate conflict analysis, backjumping, and other techniques within the Asp context. ClaspD [Drescher et al., 2008] is a disjunctive Asp-solver that utilizes nogoods based on the logical characterizations of loop formulas [Lee, 2005]."}, {"heading": "2 Preliminaries", "text": "Answer set programs We consider a universe of propositional atoms. A disjunctive logic program (or simply a program) P is a set of rules of the form x1\u2228. . .\u2228xl \u2190 y1, . . . , yn,\u00acz1, . . . ,\u00aczm where x1, . . . , xl, y1, . . . , yn, z1, . . . , zm are atoms and l, n,m are non-negative integers. We writeH(r) = {x1, . . . , xl} (the head of r), B+(r) = {y1, . . . , yn} (the positive body of r), and B\n\u2212(r) = {z1, . . . , zm} (the negative body of r). We denote the sets of atoms occurring in a rule r or in a program P by at(r) = H(r)\u222aB+(r)\u222aB\u2212(r) and at(P ) = \u22c3\nr\u2208P at(r), respectively. We abbreviate the number of rules of P by |P | = |{ r | r \u2208 P }|. A rule r is negation-free if B\u2212(r) = \u2205, r is normal if |H(r)| \u2264 1, r is a constraint if |H(r)| = 0, r is constraint-free if |H(r)| > 0, r is Horn if it is negation-free and normal, r is positive if it is Horn and constraint-free, and r is tautological if B+(r)\u2229(H(r)\u222aB\u2212(r)) 6= \u2205. We say that a program has a certain property if all its rules have the property. We denote the class of all normal programs by Normal and the class of all Horn programs by Horn. In the following, we restrict ourselves to programs that do not contain any tautological rules. This restriction is not significant as tautological rules can be omitted from a program without changing its answer sets [Brass and Dix, 1998]. Note that we state explicitly the differences regarding tautologies in the proofs.\nA set M of atoms satisfies a rule r if (H(r)\u222aB\u2212(r))\u2229M 6= \u2205 or B+(r) \\M 6= \u2205. M is a model of P if it satisfies all rules of P . The GL reduct of a program P under a set M of atoms is the program PM obtained from P by first, removing all rules r with B\u2212(r) \u2229M 6= \u2205 and second, removing all \u00acz where z \u2208 B\u2212(r) from all remaining rules r [Gelfond and Lifschitz, 1991]. M is an answer set (or stable set) of a program P if M is a minimal model of PM . The Emden-Kowalski operator of a program P and a subset A of atoms of P is the set TP (A) := { a | a \u2208 H(r), B\n+(r) \u2286 A, r \u2208 P }. The least model LM(P ) is the least fixed point of TP (A) [Van Emden and Kowalski, 1976]. Note that every positive program P has a unique minimal model which equals the least model LM(P ) [Gelfond and Lifschitz, 1988].\nExample 1. Consider the program\nP = {a \u2228 c \u2190 b; b \u2190 c,\u00acg; c \u2190 a;\nb \u2228 c \u2190 e; h \u2228 i \u2190 g,\u00acc; a \u2228 b;\ng \u2190 \u00aci; c }.\nThe set A = {b, c, g} is an answer set of P since PA = { a \u2228 c \u2190 b; c \u2190 a; b \u2228 c \u2190 e; a \u2228 b; g; c } and the minimal models of PA are {b, c, g} and {a, c, g}.\nThe main reasoning problems for Asp are Brave Reasoning (given a program P and an atom a \u2208 at(P ), is a contained in some answer set of P?) and Skeptical Reasoning (given a program P and an atom a \u2208 at(P ), is a contained in all answer sets of P?). Brave Reasoning is \u03a3P2 -complete, Skeptical Reasoning is \u03a0P2 -complete [Eiter and Gottlob, 1995].\nParameterized Complexity We give some basic background on parameterized complexity. For more detailed information we refer to other sources [Downey and Fellows, 1999; Flum and Grohe, 2006; Gottlob and Szeider, 2008; Niedermeier, 2006]. A parameterized problem L is a subset of \u03a3\u2217 \u00d7 N for some finite alphabet \u03a3. For an instance (I, k) \u2208 \u03a3\u2217 \u00d7 N we call I the main part and k the parameter. L is fixed-parameter tractable if there exists a computable function f and a constant c such that there exists an algorithm that decides whether (I, k) \u2208 L in time O(f(k)\u2016I\u2016c) where \u2016I\u2016 denotes the size of I. Such an algorithm is called an fpt-algorithm. FPT is the class of all fixed-parameter tractable decision problems.\nLet L \u2286 \u03a3\u2217 \u00d7 N and L\u2032 \u2286 \u03a3\u2032\u2217 \u00d7 N be two parameterized problems for some finite alphabets \u03a3 and \u03a3\u2032. An fpt-reduction r from L to L\u2032 is a many-to-one reduction from \u03a3\u2217\u00d7N to \u03a3\u2032\u2217\u00d7N such that for all I \u2208 \u03a3\u2217 we have (I, k) \u2208 L if and only if r(I, k) = (I \u2032, k\u2032) \u2208 L\u2032 such that k\u2032 \u2264 g(k) for a fixed computable function g : N \u2192 N and there is a computable function f and a constant c such that r is computable in time O(f(k)\u2016I\u2016c) where \u2016I\u2016 denotes the size of I [Flum and Grohe, 2006]. Thus, an fpt-reduction is, in particular, an fpt-algorithm. It is easy to see that the class FPT is closed under fpt-reductions. We would like to note that the theory of fixed-parameter intractability is based on fpt-reductions [Downey and Fellows, 1999; Flum and Grohe, 2006].\nPropositional satisfiability A truth assignment is a mapping \u03c4 : X \u2192 {0, 1} defined for a set X of atoms. For x \u2208 X we put \u03c4(\u00acx) = 1 \u2212 \u03c4(x). By ta(X) we denote the set of all truth assignments \u03c4 : X \u2192 {0, 1}. We usually say variable instead of atom in the context of formulas. Given a propositional formula F , the problem Sat asks whether F is satisfiable. We can consider Sat as a parameterized problem by simply associating with every formula the parameter 0."}, {"heading": "3 Backdoors of Programs", "text": "In the following we give the main notions concerning backdoors for answer set programming, as introduced by Fichte and Szeider [2012]. Let P be a program, X a set of atoms, and \u03c4 \u2208 ta(X). The truth assignment reduct of P under \u03c4 is the logic program P\u03c4 obtained from P by removing all rules r for which at least one of the following holds: (i) H(r)\u2229\u03c4\u22121(1) 6= \u2205, (ii) H(r) \u2286 X , (iii) B+(r)\u2229\u03c4\u22121(0) 6= \u2205, and (iv) B\u2212(r) \u2229 \u03c4\u22121(1) 6= \u2205, and then removing from the heads and bodies of the remaining rules all literals v,\u00acv with v \u2208 X . In the following, let C be a class of programs. We call C to be rule induced if for each P \u2208 C, P \u2032 \u2286 P implies P \u2032 \u2208 C. A set X of atoms is a strong C-backdoor of a program P if P\u03c4 \u2208 C for all truth assignments \u03c4 \u2208 ta(X). Given a strong C-backdoor X of a program P , the answer sets of P are among the answer sets we obtain from the truth assignment reducts P\u03c4 where \u03c4 \u2208 X , more formally AS(P ) \u2286 {M \u222a \u03c4\u22121(1) | \u03c4 \u2208 ta(X \u2229 at(P )),M \u2208 AS(P\u03c4 ) } where AS(P ) denotes the set of all answer sets of P . For a program P and a set X of atoms we define P \u2212X as the program obtained from P by deleting all atoms contained in X and their negations from the heads and bodies of all the rules of P . A set X of atoms is a deletion C-backdoor of a program P if P \u2212X \u2208 C.\nExample 2. Consider the program P from Example 1. The set X = {b, c, h} is a strong Normal-backdoor since the truth assignment reducts Pb=0,c=0,h=0 = P000 = { i \u2190 g; a; g \u2190 \u00aci }, P001 = P010 = P011 = P101 = { a; g \u2190 \u00aci }, P100 = { a; i \u2190 g; g \u2190 \u00aci }, and P110 = P111 = { g \u2190 \u00aci } are in the class Normal.\nIn the following we refer to C as the target class of the backdoor. For most target classes C, deletion C-backdoors are strong C-backdoors. For C = Normal even the opposite direction is true.\nProposition 1 (Fichte and Szeider, 2012). If C is rule induced, then every deletion C-backdoor is a strong C-backdoor.\nLemma 1. Let P be a program. A set X is a strong Normal-backdoor of a program P if and only if it is a deletion Normal-backdoor of P .\nProof. We observe that the class of all normal programs is rule-induced. Thus the if direction holds by Proposition 1. We proceed to show the only-if direction. Assume X is a strong Normal-backdoor of P . Consider a rule r\u2032 \u2208 P \u2212X which is not tautological. Let r \u2208 P be a rule from which r\u2032 was obtained in forming P \u2212X . We define \u03c4 \u2208 ta(X) by setting all atoms in H(r) \u222aB\u2212(r) to 0, all atoms in B+(r) to 1, and all remaining atoms in X \\ at(r) arbitrarily to 0 or 1. Since r is not tautological, this definition of \u03c4 is sound. It remains to observe that r\u2032 \u2208 P\u03c4 . Since X is a strong Normal-backdoor of P , the rule r\u2032 is normal. Hence, the lemma follows.\nEach target class C gives rise to the following problems:\nC-Backdoor-Asp-Check\nGiven: A program P , a strong C-backdoor X of P , a set M \u2286 at(P ), and the size of the backdoor k = |X |.\nParameter: The integer k.\nQuestion: Is M an answer set of P?\nC-Backdoor-Brave-Reasoning\nGiven: A program P , a strong C-backdoor X of P , an atom a\u2217 \u2208 at(P ), and the size of the backdoor k = |X |.\nParameter: The integer k. Question: Does a\u2217 belong to some answer set of P?\nC-Backdoor-Skeptical-Reasoning\nGiven: A program P , a strong C-backdoor X of P , an atom a\u2217 \u2208 at(P ), and the size of the backdoor k = |X |.\nParameter: The integer k. Question: Does a\u2217 belong to all answer sets of P?\nProblems for deletion C-backdoors can be defined similarly."}, {"heading": "4 Using Backdoors", "text": "In this section, we show results regarding the use of backdoors with respect to the target class Normal.\nTheorem 1. The problem Normal-Backdoor-Asp-Check is fixed-parameter tractable. More specifically, given a program P of input size n, a strong Normal-backdoor N of P of size k, and a set M \u2286 at(P ) of atoms, we can check in time O(2kn) whether M is an answer set of P .\nThe most important part for establishing Theorem 1 is to check whether a model is a minimal model. In general, this is a co-NP-complete task, but in the context of Theorem 1 we can achieve fixed-parameter tractability based on the following construction and lemma.\nLet P be a given program,X a strongNormal-backdoor of P of size k, and let M \u2286 at(P ). For a set X1 \u2286 M \u2229X we construct a program PX1\u2286X as follows: (i) remove all rules r for which H(r) \u2229X1 6= \u2205 and (ii) replace for all remaining rules r the head H(r) with H(r) \\ X and the positive body B+(r) with B+(r) \\X1.\nRecall that by definition we exclude programs with tautological rules. SinceX is a strongNormal-backdoor of P , it is also a deletion Normal-backdoor of P by Lemma 1. Hence P \u2212 X is normal. Let r be an arbitrarily chosen rule in P . Then there is a corresponding rule r\u2032 \u2208 P \u2212X and a corresponding rule r\u2032\u2032 \u2208 PX1\u2286X . Since we remove in both constructions exactly the same literals from the head of every rule, H(r\u2032) = H(r\u2032\u2032) holds. Consequently, PX1\u2286X is normal and P M X1\u2286X\nis Horn (here PMX1\u2286X denotes the GL-reduct of PX1\u2286X under M).\nFor any program P \u2032 let Constr(P \u2032) denote the set of constrains of P \u2032 and Pos(P \u2032) = P \u2032 \\Constr(P \u2032). If P \u2032 is Horn, Pos(P \u2032) has a least model L and P \u2032 has a model if and only if L is a model of Constr(P \u2032) [Dowling and Gallier, 1984].\nLet X be a strong Normal-backdoor of P and X1 \u2286 X . Given M \u2286 at(P ), the algorithm MinCheck(X1) below performs the following steps:\n1. Return True if X1 is not a subset of M . 2. Compute the Horn program PMX1\u2286X . 3. Compute the least model L of Pos(PMX1\u2286X). 4. Return True if at least one of the following conditions holds:\n(a) L is not a model of Constr(PMX1\u2286X). (b) L is not a subset of X ,\n(c) L \u222aX1 is not a proper subset of M , (d) L \u222aX1 is not a model of PM .\n5. Otherwise return False.\nLemma 2. Let X be a strong Normal-backdoor. A model M \u2286 at(P ) of PM is a minimal model of PM if and only if MinCheck(X1) returns True for each set X1 \u2286 X.\nProof. (\u21d2). Assume that M is a minimal model of PM , and suppose to the contrary that there is some X1 \u2286 M \u2229X for which the algorithm returns False. Consequently, none of the conditions in Step 4 of the algorithms holds. That means, the least model L of PMX1\u2286X satisfies Constr(P M X1\u2286X ) and is therefore a model of PMX1\u2286X . Moreover, since L\u222aX1 * M and L\u222aX1 is a model of P M , M cannot be a minimal model of PM , a contradiction to our assumption. So we conclude that the algorithm succeeds and the only-if direction of the lemma is shown.\n(\u21d0). Assume that the algorithm returns True for each X1 \u2286 M \u2229X . We show that M is a minimal model of PM . Suppose to the contrary that PM has a model M \u2032 ( M .\nWe run the algorithm for X1 := M \u2032 \u2229X . Let L be the least model of Pos(PMX1\u2286X). By assumption, the algorithm returns True, hence some of the conditions of Step 4 of the algorithm must hold for L. We will show, however, that none of the conditions can hold, which will yield to a contradiction, and so establish the if direction of the lemma, and thus completes its proof.\nFirst we show that M \u2032 \\X is a model of PMX1\u2286X . Consider a rule r \u2032 \u2208 PMX1\u2286X and let r \u2208 P M such that r\u2032 is obtained form r by removing X from H(r) and by removing X1 from B +(r). Since M \u2032 is a model of PM , we have (i) B+(r) \\M \u2032 6= \u2205 or (ii) H(r) \u2229M \u2032 6= \u2205. Moreover, since B+(r\u2032) = B+(r) \\X1 and X1 = M\n\u2032 \u2229X , (i) implies \u2205 6= B+(r) \\M \u2032 = B+(r) \\X1 \\M \u2032 = B+(r\u2032) \\M \u2032 \u2286 B+(r\u2032) \\ (M \u2032 \\X), and since H(r) \u2229 X1 = \u2205, (ii) implies \u2205 6= H(r) \u2229 M \u2032 = H(r) \u2229 (M \u2032 \\ X1) = H(r) \u2229 (M \u2032 \\ X) = (H(r) \\X) \u2229 (M \u2032 \\X) = H(r\u2032) \u2229 (M \u2032 \\X). Hence M \u2032 \\X satisfies r\u2032. Since r\u2032 \u2208 PMX1\u2286X was chosen arbitrarily, we conclude that M \u2032 \\X is a model of PMX1\u2286X .\nSince PMX1\u2286X has some model (namely M \u2032 \\X), the least model L of Pos(PMX1\u2286X) must be a model\nof PMX1\u2286X , thus Condition (a) cannot hold for L.\nNext we show that the other conditions cannot hold either. Since M \u2032 \\X is a model of PMX1\u2286X , as shown above, we have L \u2286 M \u2032 \\X . We obtain L \u2286 M \\X since M \u2032 \\X \u2286 M \\X . Further, we obtain L\u222aX1 ( M since L\u222aX1 \u2286 (M \u2032 \\X)\u222aX1 = (M \u2032 \\X)\u222a (M \u2032 \u2229X) = M \u2032 ( M . Hence we have excluded Conditions (b) and (c), and it remains to exclude Condition (d).\nConsider a rule r \u2208 PM . If X1\u2229H(r) 6= \u2205, then L\u222aX1 satisfies r; thus it remains to consider the case X1\u2229H(r) = \u2205. In this case there is a rule r\u2032 \u2208 PMX1\u2286X with H(r \u2032) = H(r)\\X and B+(r\u2032) = B+(r)\\X1. Since L is a model of PMX1\u2286X , L satisfies r \u2032. Hence (i) B+(r\u2032) \\ L 6= \u2205 or (ii) H(r\u2032) \u2229 L 6= \u2205. Since B+(r\u2032) = B+(r) \\X1, (i) implies that B+(r) \\ (L \u222aX1) 6= \u2205; and since H(r\u2032) \u2286 H(r), (ii) implies that H(r) \u2229 (L \u222aX1) 6= \u2205. Thus L \u222aX1 satisfies r. Since r \u2208 PM was chosen arbitrarily, we conclude that L \u222aX1 is a model of PM , which excludes also the last Condition (d).\nWe are now in a position to establish Theorem 1.\nProof of Theorem 1. First we check whether M is a model of PM . If M is not a model of PM then it is not an answer set of P , and we can neglect it. Hence assume that M is a model of PM . Now we run the algorithm MinCheck. By Lemma 2 the algorithm decides whether M is an answer set of P .\nIn order to complete the proof, it remains to bound the running time. The check whether M is a model of PM can clearly be carried out in linear time. For each set X1 \u2286 M \u2229 X the algorithm MinCheck runs in linear time. This follows directly from the fact that we can compute the least model of a Horn program in linear time [Dowling and Gallier, 1984]. As there are at most 2k sets X1 to consider, the total running time is O(2kn) where n denotes the input size of P and k = |X |. Thus, in particular, the decision is fixed-parameter tractable for parameter k.\nExample 3. Consider the program P from Example 1 and the backdoor X = {b, c, h} from Example 2. Let N = {a, b, c, g} \u2286 at(P ). Obviously N is a model of P . We apply the algorithm MinCheck for each X1 of {b, c}. For X1 = \u2205 we obtain PNX1\u2286X = { a \u2190 b; \u2190 a; \u2190 e; a; g \u2190 \u00aci } and the least model L = {a, g} of Pos(PN\u2205\u2286X). Since Condition 4a holds (L is not a model of Constr(P N X1\u2286X )), the algorithm returns True. For X2 = {b} we have P N X2\u2286X = { a; \u2190 a; g } and L = {g} is the least model of Pos(PNX2\u2286X). Since Condition 4a holds (L is not a model of Constr(P N X2\u2286X )), the algorithm returns True for X2. For X3 = {c} we obtain PNX3\u2286X = { a; g }. The set L = {a, g} is the least model of Pos(PNX3\u2286X). Since none of the Conditions 4a\u2013d hold, more precisely L is a model of Constr(P N X1\u2286X ), L is a subset of X, L\u222aX1 is a proper subset of N , and L\u222aX1 is a model of PN . Hence, the algorithm returns False. Thus MinCheck does not succeed, and M is not a minimal model of PM .\nExample 4. Again, consider the program P from Example 1 and the backdoor X = {b, c, h} from Example 2. Let M = {b, c, g} \u2286 at(P ). Since M satisfies all rules in P , the set M is a model of P . We apply the algorithm MinCheck for each subset of {b, c, h}. For X1 = \u2205 we obtain PMX1\u2286X = { a \u2190 b; \u2190 a; \u2190 e; a; g }. The set L = {a, g} is the least model of Pos(PMX1\u2286X). Since Condition 4a holds, the algorithm returns True for X1. For X2 = {b} we have PMX2\u2286X = { a; \u2190 a; g; \u2190} and the least model L = {a, g} of Pos(PMX2\u2286X). Since Condition 4a holds, MinCheck returns True for X2. For X3 = {c} we gain PMX3\u2286X = { a; g } and the least model L = {a, g} of Pos(P M X3\u2286X ). Since Condition 4c holds, the algorithm returns True for X3. For X4 = {b, c} we obtain PMX4\u2286X = {g}. The set L = {g} is the least model of Pos(PMX4\u2286X). Since Condition 4c holds, the algorithm returns True for X4. For all remaining subsets of X the Algorithm MinCheck returns True according to Condition 1. Consequently, M is a minimal model of PM and thus an answer set of P .\nNext, we state and prove that there are fpt-reductions from Normal-Backdoor-Brave-Reasoning and Normal-Backdoor-Skeptical-Reasoning to Sat which is the main result of this paper.\nTheorem 2. Given a disjunctive logic program P of input size n, a strong Normal-backdoor X of P of size k, and an atom a\u2217 \u2208 at(P ), we can produce in time O(2kn2) propositional formulas FBrave(a\u2217) and FSkept(a \u2217) such that (i) FBrave(a \u2217) is satisfiable if and only if a\u2217 is in some answer set of P , and (ii) FSkept(a \u2217) is unsatisfiable if and only if a\u2217 is in all answer sets of P .\nProof. We would like to use a similar approach as in the proof of Theorem 1. However, we cannot consider all possible models M one by one, as there could be too many of them. Instead, we will show that it is possible to implement MinCheck(X1) for each set X1 \u2286 X nondeterministically in such a way that we do not need to know M in advance. Possible sets M will be represented by the truth values of certain variables, and since the truth values do not need to be known in advance, this will allow us to consider all possible sets M without enumerating them.\nNext, we describe the construction of the formulas FBrave(a \u2217) and FSkept(a \u2217) in detail. Among the variables of our formulas will be a set V := { v[a] | a \u2208 at(P ) } containing a variable for each atom of P . The truth values of the variables in V represent a subset M \u2286 at(P ), such that v[a] is true if and only if a \u2208 M .\nWe define\nFBrave(a \u2217) := Fmod \u2227 Fmin \u2227 v[a\u2217] and\nFSkept(a \u2217) := Fmod \u2227 Fmin \u2227 \u00acv[a\u2217],\nwhere Fmod and Fmin are formulas, defined below, that check whether the truth values of the variables in V represent a model M of PM , and whether M is a minimal model of PM , respectively.\nThe definition of Fmod is easy:\nFmod := \u2227\nr\u2208P\n(\n\u2227\nb\u2208B\u2212(r)\n\u00acv[b] \u2192 (\n\u2228\nb\u2208B+(r)\n\u00acv[b] \u2228 \u2228\nb\u2208H(r)\nv[b] )\n)\n.\nThe definition of Fmin is more involved. First we define:\nFmin := \u2227\n1\u2264i\u22642k\nFmini ,\nwhere Fmini , defined below, encodes the Algorithm MinCheck(Xi) for each set Xi where X1, . . . , X2k is an enumeration of all the subsets of X .\nThe formula Fmini will contain, in addition to the variables in V , p distinct variables for each atom of P , p := min{|P |, |at(P )|}. In particular, the set of variables of Fmini is the disjoint union of V and Ui where Ui := { u j i [a] | a \u2208 at(P ), 1 \u2264 j \u2264 p }. We write U j i for the subset of Ui containing all the variables uji [a]. We assume that for i 6= i \u2032 the sets Ui and Ui\u2032 are disjoint. For each a \u2208 at(P ) we also use the propositional constants X(a) and X1(a) that are true if and only if a \u2208 X and a \u2208 X1, respectively.\nThe truth values of the variables in Upi represent the unique minimal model of Pos(P M Xs\u2286X ). We define the formula Fmini by means of the following auxiliary formulas. The first auxiliary formula checks whether the truth values of the variables in V represent a set M\nthat contains Xi:\nF \u2286 i :=\n\u2227\na\u2208X\nXi(a) \u2192 v[a].\nThe next auxiliary formula encodes the computation of the least model (\u201clm\u201d) L of Pos(PMXi\u2286X) where M and L are represented by the truth values of the variables in V and Upi , respectively.\nF lmi := \u2227\na\u2208at(P ),0\u2264i\u2264p\nF (a,i) i , where\nF (a,0) i := u 0 i [a] \u2194 false,\nF (a,j) i := u j i [a] \u2194 [ u j\u22121 i [a] \u2228\n\u2228\nr\u2208PXi\u2286X ,a\u2208H(r)\n( \u2227\nb\u2208B+(r)\nu j\u22121 i [b] \u2227\n\u2227\nb\u2208B\u2212(r)\n\u00acv[b]) ]\n(for 1 \u2264 j \u2264 p\u2212 1).\nThe idea behind the construction of F lmi is to simulate the linear-time algorithm of Dowling and Gallier [1984]. Initially, all variables are set to false. This is represented by variables u0i [a]. Now we flip a variable from false to true if and only if there is a Horn rule where all the variables in the rule body are true. We iterate this process until a fixed-point is reached, then we have the least model. The flipping is represented in our formula by setting a variable uji [a] to true if and only if either u j\u22121 i [a] is true, or there is a rule r \u2208 Pos(PMXi\u2286X) such that H(r) = {a} and u j i [b] is true for all b \u2208 B +(r). The truth values of the variables upi now represent the least model of Pos(P M Xi\u2286X\n). The next four auxiliary formulas check whether the respective condition (a)\u2013(d) of algorithm\nMinCheck(Xi) does not hold for L.\nF (a) i expresses that there is a rule in Constr(P M Xi\u2286X ) that is not satisfied by L:\nF (a) i :=\n\u2228\nr\u2208PXi\u2286X ,H(r)\u2286X\n( \u2227\nb\u2208B\u2212(r)\n\u00acv[b] \u2227 \u2227\nb\u2208B+(r)\nu p i [b]).\nF (b) i expresses that L contains an atom that is not in M \\X :\nF (b) i :=\n\u2228\na\u2208at(P )\\X\n(\u00acv[a] \u2227 upi [a]).\nF (c) i expresses that L \u222aXi equals M or L \u222aXi contains an atom that is not in M :\nF (c) i :=\n\n\n\u2227\na\u2208at(P )\nv[a] \u2194 (upi [a] \u2228Xi(a))\n\n \u2228\n\n\n\u2228\na\u2208at(P )\n(upi [a] \u2228Xi(a)) \u2227 \u00acv[a]\n\n .\nF (d) i expresses that P M contains a rule that is not satisfied by L \u222aXi:\nF (d) i :=\n\u2228\nr\u2208P\n[ \u2227\na\u2208B\u2212(r)\n\u00acv[a] \u2227 \u2227\na\u2208H(r)\n(\u00acupi [a] \u2227 \u00acXi(a)) \u2227 \u2227\nb\u2208B+(r)\n(upi [b] \u2228Xi(b))].\nNow we can put the auxiliary formulas together and obtain\nFmini := \u00acF \u2286 i \u2228 (F lm i \u2227 (F (a) i \u2228 F (b) i \u2228 F (c) i \u2228 F (d) i )).\nIt follows by Lemma 2 and by the construction of the auxiliary formulas that (i) FBrave(a \u2217) is satisfiable if and only if a\u2217 is in some answer set of P , and (ii) FSkept(a \u2217) is unsatisfiable if and only if a\u2217 is in all answer sets of P . Hence, it remains to observe that for each i \u2264 2k the auxiliary formula F lmi can be constructed in quadratic time, whereas the auxiliary formulas F\u2286i and F (a) i \u2228 F (b) i \u2228 F (c) i \u2228 F (d)\ni can be constructed in linear time. Since |X | = k by assumption, we need to construct O(2k) auxiliary formulas in order to obtain FSkept(a \u2217) and FBrave(a \u2217). Hence, the running time as claimed in Theorem 2 follows and the theorem is established.\nWe would like to note that Theorem 2 remains true if we require that the formulas FSkept(a \u2217) and FBrave(a \u2217) are in Conjunctive Normal Form (CNF), as we can transform in linear time any propositional formula into a satisfiability-equivalent formula in CNF, e.g., using the well-known transformation due to Tseitin [1968], see also [Kleine Bu\u0308ning and Lettman, 1999]. This transformation produces for a given propositional formula F \u2032 in linear time a CNF formula F such that both formulas are equivalent with respect to their satisfiability, and the length of F is linear in the length of F \u2032.\nFurthermore, the SAT encoding can be improved. For instance, one could share parts between the formulas Fmini or replace the quadratic formula F lm i for the computation of least models with a smaller and more sophisticated Sat encoding [Janhunen, 2004] or a Sat(Dl) encoding [Janhunen et al., 2009] for the Smt framework which combines propositional logic and linear constraints. We would like to point out that our approach directly extends to more general problems, when we look for answer sets that satisfy a certain global property which can be expressed by a propositional formula F prop on the variables in V . We just check the satisfiability of Fmod \u2227 Fmin \u2227 F prop.\nExample 5. Consider the program P from Example 1 and the strong Normal-backdoor X = {b, c, h} of P from Example 2. We ask whether the atom b is contained in at least one answer set. To decide the question, we check that Fbrave(b) is satisfiable and we answer the question positively. Since M = {b, c, g} is model of PM we can satisfy Fmod with a truth assignment \u03c4 that maps 1 to each variable v[x] where x \u2208 {b, c, g} and 0 to each variable v[x] where x \u2208 at(P ) \\ {b, c, g}. For i = 1 let X1 = \u2205. Then we have for the constants X1(x) = 0 where x \u2208 {b, c, h}. Observe that \u03c4 already satisfies F \u2286 i and that F lmi encodes the computation of the least model L of Pos(P M X1\u2286X ) where L is represented by the truth values of the variables in UPi = { u p i [x] | x \u2208 at(P ) }. Thus \u03c4 also satisfies F lm i if \u03c4 maps u p i [a] to 1, upi [g] to 1, and u p i [x] to 0 where x \u2208 at(P ) \\ {a, g}. As \u03c4 satisfies F (a)\n1 , the truth assignment \u03c4 satisfies the formula Fmin1 . It is not hard to see that F min i is satisfiable for other values of i. Hence the formula Fbrave(b) is satisfiable and b is contained in at least one answer set.\nCompleteness for paraNP and co-paraNP\nThe parameterized complexity class paraNP contains all parameterized decision problems L such that (I, k) \u2208 L can be decided nondeterministically in time O(f(k)\u2016I\u2016c), for some computable function f and constant c [Flum and Grohe, 2006]. By co-paraNP we denote the class of all parameterized decision problems whose complement (the same problem with yes and no answers swapped) is in paraNP.\nIf a non-parameterized problem is NP-complete, then adding a parameter that makes it paraNP-complete does not provide any gain, as this holds even true if the parameter is the constant 0. Therefore a paraNP-completeness result for a problem that without parameterization is in NP, is usually considered as an utterly negative result. However, if the considered problem without parameter is outside NP, and we can show that with a suitable parameter the problem becomes paraNP-complete, this is in fact a positive result. Indeed, we get such a positive result as a corollary to Theorem 2.\nCorollary 1. Normal-Backdoor-Brave-Reasoning is paraNP-complete, and Normal-BackdoorSkeptical-Reasoning is co-paraNP-complete.\nProof. If a parameterized problem L is NP-hard when we fix the parameter to a constant, then L is paraNP-hard (Flum and Grohe, 2006, Th. 2.14). As Normal-Backdoor-Brave-Reasoning is\nNP-hard for backdoor size 0, we conclude that Normal-Backdoor-Brave-Reasoning is paraNPhard. A similar argument shows that Normal-Backdoor-Skeptical-Reasoning is co-paraNP-hard. Sat, considered as a parameterized problem with constant parameter 0, is clearly paraNP-complete, this also follows from the mentioned result of Flum and Grohe [2006]; hence UnSat is co-paraNP-complete. As Theorem 2 provides fpt-reductions from Normal-Backdoor-Brave-Reasoning to Sat, and from Normal-Backdoor-Skeptical-Reasoning to UnSat, we conclude that Normal-BackdoorBrave-Reasoning is in paraNP, and Normal-Backdoor-Skeptical-Reasoning is in co-paraNP."}, {"heading": "5 Finding Backdoors", "text": "In this section, we study the problem of finding backdoors, formalized in terms of the following parameterized problem:\nStrong C-Backdoor-Detection\nGiven: A (disjunctive) program P , and an integer k.\nParameter: The integer k.\nQuestion: Find a strong C-backdoor X of P of size at most k, or report that such X does not exist.\nWe also consider the problem Deletion C-Backdoor-Detection, defined similarly. Let P be a program. Let the head dependency graph UHP be the undirected graph U H P = (V,E) defined on the set V = at(P ) of atoms of the given program P , where two atoms x, y are joined by an edge xy \u2208 E if and only if P contains a non-tautological rule r with x, y \u2208 H(r). A vertex cover of a graph G = (V,E) is a set X \u2286 V such that for every edge uv \u2208 E we have {u, v} \u2229X 6= \u2205.\nLemma 3. Let P be a program. A set X \u2286 at(P ) is a deletion Normal-backdoor of P if and only if X is a vertex cover of UHP .\nProof. Let X be a deletion Normal-backdoor of P . Consider an edge uv of UHP , then there is a rule r \u2208 P with u, v \u2208 H(r) and u 6= v. Since X is a deletion Normal-backdoor set of P , we have {u, v} \u2229X 6= \u2205. We conclude that X is a vertex cover of UHP .\nConversely, assume that X is a vertex cover of UHP . Consider a rule r \u2208 P \u2212 X for proof by contradiction. If |H(r)| \u2265 2 then there are two variables u, v \u2208 H(r) and an edge uv of UHP such that {u, v} \u2229X = \u2205, contradicting the assumption that X is a vertex cover. Hence the lemma prevails.\nTheorem 3. The problems Strong Normal-Backdoor-Detection and Deletion Normal-Backdoor-Detection are fixed-parameter tractable. In particular, given a program P of input size n, and an integer k, we can find in time O(1.2738k + kn) a strong Normal-backdoor of P with a size \u2264 k or decide that no such backdoor exists.\nProof. In order to find a deletion Normal-backdoor of a given program P , we use Lemma 3 and find a vertex cover of size at most k in the head dependency graph UDP . A vertex cover of size k, if it exists, can be found in time O(1.2738k + kn) [Chen et al., 2006]. Thus the theorem holds for deletion Normal-backdoors. Lemma 1 states that the strong Normal-backdoors of P are exactly the deletion Normal-backdoors of P (as we assume that P does not contain any tautological rules). The theorem follows.\nIn Theorem 2 we assume that a strong Normal-backdoor of size at most k is given when solving the problems Strong Normal-Backdoor-Brave-Reasoning and Skeptical-Reasoning. As a direct consequence of Theorem 3, this assumption can be dropped, and we obtain the following corollary.\nCorollary 2. The results of Theorem 2 and Corollary 1 still hold if the backdoor is not given as part of the input."}, {"heading": "6 Backdoors to Tightness", "text": "We associate with each program P its positive dependency graph D+P . It has the atoms of P as vertices and a directed edge (x, y) between any two atoms x, y \u2208 at(P ) for which there is a rule r \u2208 P with x \u2208 H(r) and y \u2208 B+(r). A program is called tight if D+P is acyclic [Lee and Lifschitz, 2003]. We denote the class of all tight programs by Tight.\nIt is well known that the main Asp reasoning problems are in NP and co-NP for tight programs; in fact, a reduction to Sat based on the concept of loop formulas has been proposed by Lin and Zhao [2004]. This was then generalized by Lee and Lifschitz [2003] with a reduction that takes as input a disjunctive normal program P together with the set S of all directed cycles in the positive dependency graph of P , and produces a CNF formula F such that answer sets of P correspond to the satisfying assignments of F . This provides an fpt-reduction from the problems Brave Reasoning and Skeptical Reasoning to Sat, when parameterized by the number of all cycles in the positive dependency graph of a given program P , assuming that these cycles are given as part of the input.\nThe number of cycles does not seem to be a very practical parameter, as this number can quickly become very large even for very simple programs. Lifschitz and Razborov [2006] have shown that already for normal programs an exponential blowup may occur, since the number of cycles in a normal program can be arbitrarily large. Hence, it would be interesting to generalize the result of Lee and Lifschitz [2003] to a more powerful parameter. In fact, the size k of a deletion Tight-backdoor would be a candidate for such a parameter, as it is easy to see, it is at most as large as the number of cycles, but can be exponentially smaller. This is a direct consequence of the following two observations: (i) If a program P has exactly k cycles in D+P , we can construct a deletion Tight-backdoor X of P by taking one element from each cycle into X . (ii) If a program P has a deletion Tight-backdoor of size 1, it can have arbitrarily many cycles that run through the atom in the backdoor.\nIn the following, we show that this parameter k is of little use, as the reasoning problems already reach their full complexity for programs with a deletion Tight-backdoor of size 1.\nTheorem 4. The problems Tight-Backdoor-Brave-Reasoning and Tight-BackdoorSkeptical-Reasoning are \u03a3P2 -hard and \u03a0 P 2 -hard, respectively, even for programs that admit a strong Tight-backdoor of size 1, and the backdoor is provided with the input. The problems remain hard when we consider a deletion Tight-backdoor instead of a strong Tight-backdoor.\nProof. Consider the reduction from Eiter and Gottlob [Eiter and Gottlob, 1995] which reduces the \u03a3P2 -hard problem \u2203\u2200-QBF Model Checking to the problem Consistency (which decides whether given a program P has an answer set). A \u2203\u2200 quantified boolean formula (QBF) has the form \u2203x1 \u00b7 \u00b7 \u00b7 \u2203xn\u2200y1 \u00b7 \u00b7 \u00b7 \u2200ymD1 \u2228 . . . \u2228 Dr where each Di = li,1 \u2227 li,2 \u2227 li,3 and li,j is either an atom x1, . . . , xn, y1, . . . , ym or its negation. Their construction yields a program P := {xi \u2228 vi; yi \u2228 zj ; yj \u2190 w; zj \u2190 w; w \u2190 yj , zj; w \u2190 g(lk,1), g(lk,2), g(lk,3); w \u2190 \u00acw} for each i \u2208 {1, . . . , n}, j \u2208 {1, . . . ,m}, k \u2208 {1, . . . , r}, and g maps as follows g(\u00acxi) = vi, g(\u00acyj) = zj , and otherwise g(l) = l. Since Pw=0 = {xi\u2228vi \u2190; yj \u2228zj} and Pw=1 = {xi\u2228vi; yj \u2228zj ; yj; zj ; } are both in Tight, the set X = {w} is a strong Tight-backdoor of P of size 1. Thus the restriction does not yield tractability. The intractability of Skeptical Reasoning follows directly by the reduction of Eiter and Gottlob [Eiter and Gottlob, 1995] from the problem Consistency. Hardness of the other problems can be observed easily. Since P \u2212 {w} := {xi \u2228 vi; yi \u2228 zj ; yj ; zj ; \u2190 yj, zj ; \u2190 g(lk,1), g(lk,2), g(lk,3); } for each i \u2208 {1, . . . , n}, j \u2208 {1, . . . ,m}, k \u2208 {1, . . . , r} is tight, we obtain a deletion Tight-backdoor of size 1. In consequence we established the theorem."}, {"heading": "7 Experiments", "text": "Although our main results are theoretical, we have performed first experiments to determine the size of smallest strong Normal-backdoors for answer set programs representing structured and random sets of instances. Our experimental results summarized in Table 1 indicate, as expected, that structured instances have smaller backdoors than random instances. As instances from ConformantPlanning\nhave rather small backdoors our translation seems to be feasible for these instances. Furthermore, we have compared the size of a smallest strong Normal-backdoor with the size of a smallest strong Horn-backdoor [Fichte and Szeider, 2012] for selected sets. It turns out that for ConformantPlanning smallest strong Normal-backdoors are significantly smaller (0.7% vs. 8.8% of the total number of atoms)."}, {"heading": "8 Conclusion", "text": "We have shown that backdoors of small size capture structural properties of disjunctive Asp instances that yield to a reduction of problem complexity. In particular, small backdoors to normality admit an fpttranslation from Asp to Sat and thus reduce the complexity of the fundamental Asp problems from the second level of the Polynomial Hierarchy to the first level. Thus, the size of a smallestNormal-backdoor is a structural parameter that admits a fixed-parameter tractable complexity reduction without making the problem itself fixed-parameter tractable.\nOur complexity barrier breaking reductions provide a new way of using fixed-parameter tractability and enlarges its applicability. In fact, our approach as exemplified above for Asp is very general and might be applicable to a wide range of other hard combinatorial problems that lie beyond NP or co-NP. We hope that our work stimulates further investigations into this direction such as the application to abduction very recently established by Pfandler et al. [2013].\nOur first empirical results suggest that with an improved SAT encoding and preprocessing techniques to reduce the size of Normal-backdoors (for instance, shifting, Janhunen et al., 2007), our approach could be of practical use, at least for certain classes of instances, and hence might fit into a portfoliobased solver."}], "references": [{"title": "editors", "author": ["Abdelwaheb Ayari", "David Basin. Bounded model construction for monadic second-order logics. In E. Emerson", "A. Sistla"], "venue": "Computer Aided Verification, volume 1855 of Lecture Notes in Computer Science, pages 99\u2013112. Springer Verlag,", "citeRegEx": "Ayari and Basin. 2000", "shortCiteRegEx": null, "year": 2000}, {"title": "Artif", "author": ["R. Ben-Eliyahu", "R. Dechter. Propositional semantics for disjunctive logic programs. Ann. Math"], "venue": "Intell., 12(1):53\u201387,", "citeRegEx": "Ben.Eliyahu and Dechter. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "Comput", "author": ["Nicole Bid\u00f3\u0131t", "Christine Froidevaux. Negation by default", "unstratifiable logic programs. Theoret"], "venue": "Sci., 78(1):85\u2013112,", "citeRegEx": "Bid\u00f3\u0131t and Froidevaux. 1991", "shortCiteRegEx": null, "year": 1991}, {"title": "editors", "author": ["Armin Biere", "Marijn Heule", "Hans van Maaren", "Toby Walsh"], "venue": "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications. IOS Press,", "citeRegEx": "Biere et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Characterizations of the disjunctive well-founded semantics: Confluent calculi and iterated GCWA", "author": ["Stefan Brass", "J\u00fcrgen Dix"], "venue": "Journal of Automated Reasoning, 20:143\u2013165,", "citeRegEx": "Brass and Dix. 1998", "shortCiteRegEx": null, "year": 1998}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Communications of the ACM, 54(12):92\u2013103", "citeRegEx": "Brewka et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "The third answer set programming competition: Preliminary report of the system competition track", "author": ["Calimeri et al", "2011] Francesco Calimeri", "Giovambattista Ianni", "Francesco Ricca", "Mario Alviano", "Annamaria Bria", "Gelsomina Catalano", "Susanna Cozza", "Wolfgang Faber", "Onofrio Febbraro", "Nicola Leone", "Marco Manna", "Alessandra Martello", "Claudio Panetta", "Simona Perri", "Kristian Reale", "Maria Santoro", "Marco Sirianni", "Giorgio Terracina", "Pierfrancesco Veltri"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}, {"title": "Logic Programming and Nonmonotonic Reasoning, volume 6645 of Lecture Notes in Computer Science, pages 388\u2013403", "author": ["Faber", "editors"], "venue": null, "citeRegEx": "Faber and editors,? \\Q2011\\E", "shortCiteRegEx": "Faber and editors", "year": 2011}, {"title": "editors", "author": ["Hubie Chen", "Yannet Interian. A model for generating random quantified boolean formulas. In Leslie Pack Kaelbling", "Alessandro Saffiotti"], "venue": "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905), volume 19, pages 66\u201371, Edinburgh, Scotland, August", "citeRegEx": "Chen and Interian. 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "Improved parameterized upper bounds for vertex cover", "author": ["J. Chen", "I. Kanj", "G. Xia"], "venue": "Proceedings of the 31st International Symposium on Mathematical Foundations of Computer Science (MFCS\u201906), pages 238\u2013249. Springer Verlag", "citeRegEx": "Chen et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Logic and Data Bases", "author": ["Keith L. Clark. Negation as failure"], "venue": "1:293\u2013322,", "citeRegEx": "Clark. 1978", "shortCiteRegEx": null, "year": 1978}, {"title": "Logic Programming", "author": ["William F. Dowling", "Jean H. Gallier. Linear-time algorithms for testing the satisfiability of propositional horn formulae. J"], "venue": "1(3):267\u2013284,", "citeRegEx": "Dowling and Gallier. 1984", "shortCiteRegEx": null, "year": 1984}, {"title": "Springer Verlag", "author": ["Rod G. Downey", "Michael R. Fellows. Parameterized Complexity. Monographs in Computer Science"], "venue": "New York,", "citeRegEx": "Downey and Fellows. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "editors", "author": ["Christian Drescher", "Martin Gebser", "Torsten Grote", "Benjamin Kaufmann", "Arne K\u00f6nig", "Max Ostrowski", "Torsten Schaub. Conflict-driven disjunctive answer set solving. In Gerhard Brewka", "J\u00e9r\u00f4me Lang"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR\u201908), pages 422\u2013432. AAAI Press,", "citeRegEx": "Drescher et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["Thomas Eiter", "Georg Gottlob"], "venue": "Ann. Math. Artif. Intell., 15(3\u20134):289\u2013323,", "citeRegEx": "Eiter and Gottlob. 1995", "shortCiteRegEx": null, "year": 1995}, {"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["Francois Fages"], "venue": "Journal of Methods of Logic in Computer Science, 1(1):51\u201360,", "citeRegEx": "Fages. 1994", "shortCiteRegEx": null, "year": 1994}, {"title": "Technical report", "author": ["Johannes Klaus Fichte", "Stefan Szeider. Backdoors to tractable answerset programming"], "venue": "arXiv:1104.2788,", "citeRegEx": "Fichte and Szeider. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "the bad", "author": ["Johannes Fichte. The good"], "venue": "and the odd: Cycles in answer-set programs. In Daniel Lassiter and Marija Slavkovik, editors, New Directions in Logic, Language and Computation, volume 7415 of Lecture Notes in Computer Science, pages 78\u201390. Springer Verlag,", "citeRegEx": "Fichte. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "volume XIV of Theoret", "author": ["J\u00f6rg Flum", "Martin Grohe. Parameterized Complexity Theory"], "venue": "Comput. Sci. Springer Verlag, Berlin,", "citeRegEx": "Flum and Grohe. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "editors", "author": ["Serge Gaspers", "Stefan Szeider. Backdoors to satisfaction. In Hans Bodlaender", "Rod Downey", "Fedor Fomin", "D\u00e1niel Marx"], "venue": "The Multivariate Algorithmic Revolution and Beyond, volume 7370 of Lecture Notes in Computer Science, pages 287\u2013317. Springer Verlag,", "citeRegEx": "Gaspers and Szeider. 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "editor", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub. Conflict-driven answer set solving. In Manuela M. Veloso"], "venue": "Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907), pages 386\u2013392, Hyderabad, India, January", "citeRegEx": "Gebser et al.. 2007a", "shortCiteRegEx": null, "year": 2007}, {"title": "editors", "author": ["Martin Gebser", "Lengning Liu", "Gayathri Namasivayam", "Andr\u00e9 Neumann", "Torsten Schaub", "Miros law Truszczy\u0144ski. The first answer set programming system competition. In Chitta Baral", "Gerhard Brewka", "John Schlipf"], "venue": "Proceedings of the 9th Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907), volume 4483 of Lecture Notes in Computer Science, pages 3\u201317. Springer Verlag,", "citeRegEx": "Gebser et al.. 2007b", "shortCiteRegEx": null, "year": 2007}, {"title": "editors", "author": ["Martin Gebser", "Torsten Schaub", "Sven Thiele", "Bj\u00f6rn Usadel", "Philippe Veber. Detecting inconsistencies in large biological networks with answer set programming. In Maria Garcia de la Banda", "Enrico Pontelli"], "venue": "Logic Programming, volume 5366 of Lecture Notes in Computer Science, pages 130\u2013144. Springer Verlag,", "citeRegEx": "Gebser et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "editors", "author": ["Michael Gelfond", "Vladimir Lifschitz. The stable model semantics for logic programming. In Robert A. Kowalski", "Kenneth A. Bowen"], "venue": "Proceedings of the 5th International Conference and Symposium (ICLP/SLP\u201988), volume 2, pages 1070\u20131080. MIT Press,", "citeRegEx": "Gelfond and Lifschitz. 1988", "shortCiteRegEx": null, "year": 1988}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "New Generation Comput., 9(3/4):365\u2013386,", "citeRegEx": "Gelfond and Lifschitz. 1991", "shortCiteRegEx": null, "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning, 36(4):345\u2013377", "citeRegEx": "Giunchiglia et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Chapter 2 satisfiability solvers", "author": ["Carla P. Gomes", "Henry Kautz", "Ashish Sabharwal", "Bart Selman"], "venue": "Vladimir Lifschitz Frank van Harmelen and Bruce Porter, editors, Handbook of Knowledge Representation, volume 3 of Foundations of Artificial Intelligence, pages 89 \u2013 134. Elsevier Science Publishers, North-Holland,", "citeRegEx": "Gomes et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "Fixed-parameter algorithms for artificial intelligence", "author": ["G. Gottlob", "S. Szeider"], "venue": "constraint satisfaction and database problems. The Computer Journal, 51(3):303\u2013325", "citeRegEx": "Gottlob and Szeider. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "Unfolding partiality and disjunctions in stable model semantics", "author": ["T. Janhunen", "I. Niemel\u00e4", "D. Seipel", "P. Simons", "J.H. You"], "venue": "ACM Trans. Comput. Log., 7(1):1\u201337", "citeRegEx": "Janhunen et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "editors", "author": ["Tomi Janhunen", "Emilia Oikarinen", "Hans Tompits", "Stefan Woltran. Modularity aspects of disjunctive stable models. In Chitta Baral", "Gerhard Brewka", "John S. Schlipf"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201907), volume 4483 of Lecture Notes in Computer Science, pages 175\u2013187, Berlin, Heidelberg,", "citeRegEx": "Janhunen et al.. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "editors", "author": ["Tomi Janhunen", "Ilkka Niemela", "Mark Sevalnev. Computing stable models via reductions to difference logic. In Esra Erdem", "Fangzhen Lin", "Torsten Schaub"], "venue": "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR \u201909), volume 5753 of Lecture Notes in Computer Science, pages 142\u2013154. Springer Verlag,", "citeRegEx": "Janhunen et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "editors", "author": ["Tomi Janhunen. Representing normal programs with clauses. In Ramon L\u00f3pez de M\u00e1ntaras", "Ramon Saitta"], "venue": "Proceedings of the 16th Eureopean Conference on Artificial Intelligence (ECAI\u201904), volume 16, pages 358\u2013362. IOS Press,", "citeRegEx": "Janhunen. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "Some (in)translatability results for normal logic programs and propositional theories", "author": ["Tomi Janhunen"], "venue": "Journal of Applied Non-Classical Logics, 16(1-2):35\u201386,", "citeRegEx": "Janhunen. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "editors", "author": ["Mikol\u00e1\u0161 Janota", "Joao Marques-Silva. A tool for circumscriptionbased mus membership testing. In James Delgrande", "Wolfgang Faber"], "venue": "Logic Programming and Nonmonotonic Reasoning, volume 6645 of Lecture Notes in Computer Science, pages 266\u2013271. Springer Verlag,", "citeRegEx": "Janota and Marques.Silva. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Propositional logic: deduction and algorithms", "author": ["Hans Kleine B\u00fcning", "Theodor Lettman"], "venue": "Cambridge University Press, Cambridge,", "citeRegEx": "Kleine B\u00fcning and Lettman. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "editor", "author": ["Joohyung Lee", "Vladimir Lifschitz. Loop formulas for disjunctive logic programs. In Catuscia Palamidessi"], "venue": "Logic Programming, volume 2916 of Lecture Notes in Computer Science, pages 451\u2013465. Springer Verlag,", "citeRegEx": "Lee and Lifschitz. 2003", "shortCiteRegEx": null, "year": 2003}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Leslie Pack Kaelbling and Alessandro Saffiotti, editors, Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI\u201905), volume 19, pages 503\u2013508. Professional Book Center", "citeRegEx": "Lee. 2005", "shortCiteRegEx": null, "year": 2005}, {"title": "Why are there so many loop formulas? ACM Transactions on Computational Logic (TOCL)", "author": ["V. Lifschitz", "A. Razborov"], "venue": "7(2):261\u2013268", "citeRegEx": "Lifschitz and Razborov. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence, 157(1-2):115\u2013137", "citeRegEx": "Lin and Zhao. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "Look-back techniques and heuristics in dlv: Implementation", "author": ["Marco Maratea", "Francesco Ricca", "Wolfgang Faber", "Nicola Leone"], "venue": "evaluation, and comparison to qbf solvers. Journal of Algorithms, 63(1-3):70 \u2013 89,", "citeRegEx": "Maratea et al.. 2008", "shortCiteRegEx": null, "year": 2008}, {"title": "In Proceedings of the 1st International Conference on Logic Programming and Nonmonotonic Reassoning (LPNMR\u201991)", "author": ["Wiktor Marek", "M. Truszczynski. Computing intersection of autoepistemic expansions"], "venue": "pages 37\u201350. MIT Press,", "citeRegEx": "Marek and Truszczynski. 1991a", "shortCiteRegEx": null, "year": 1991}, {"title": "ACM", "author": ["Wiktor Marek", "Miros law Truszczy\u0144ski. Autoepistemic logic. J"], "venue": "38(3):588\u2013619,", "citeRegEx": "Marek and Truszczy\u0144ski. 1991b", "shortCiteRegEx": null, "year": 1991}, {"title": "editors", "author": ["Victor W. Marek", "Miroslaw Truszczynski. Stable models", "an alternative logic programming paradigm. In Krzysztof R. Apt", "Victor W. Marek", "Miroslaw Truszczynski", "David S. Warren"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective, pages 375\u2013398. Springer Verlag, September", "citeRegEx": "Marek and Truszczynski. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "Oxford Lecture Series in Mathematics and its Applications", "author": ["Rolf Niedermeier. Invitation to Fixed-Parameter Algorithms"], "venue": "Oxford University Press,", "citeRegEx": "Niedermeier. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Artif", "author": ["Ilkka Niemel\u00e4. Logic programs with stable model semantics as a constraint programming paradigm. Ann. Math"], "venue": "Intell., 25(3):241\u2013273,", "citeRegEx": "Niemel\u00e4. 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "editors", "author": ["Naomi Nishimura", "Prabhakar Ragde", "Stefan Szeider. Detecting backdoor sets with respect to Horn", "binary clauses. In Holger H. Hoos", "David G. Mitchell"], "venue": "Proceedings of the 17th International Conference on Theory and Applications of Satisfiability Testing (SAT\u201904), volume 3542 of Lecture Notes in Computer Science, pages 96\u2013103, Vancouver, BC, Canada, May", "citeRegEx": "Nishimura et al.. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "In Proceedings of the 23nd International Joint Conference on Artificial Intelligence (IJCAI\u201913)", "author": ["A. Pfandler", "S. R\u00fcmmele", "S. Szeider. Backdoors to abduction"], "venue": "AAAI Press/IJCAI,", "citeRegEx": "Pfandler et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "editors", "author": ["S.T. To", "E. Pontelli", "T.C. Son. A conformant planner with explicit disjunctive representation of belief states. In Alfonso Gerevini", "Adele E. Howe", "Amedeo Cesta", "Ioannis Refanidis"], "venue": "Proceedings of the 19th International Conference on Automated Planning and Scheduling (ICAPS\u201909), pages 305\u2013312, Thessaloniki, Greece, September", "citeRegEx": "To et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "On the complexity of derivation in propositional calculus", "author": ["G.S. Tseitin"], "venue": "Zap. Nauchn. Sem. Leningrad Otd. Mat. Inst. Akad. Nauk SSSR, 8:23\u201341, 1968. Russian. English translation in J. Siekmann and G. Wrightson (eds.) Automation of Reasoning. Classical Papers on Computer Science 1967\u20131970, Springer Verlag, 466\u2013483", "citeRegEx": "Tseitin. 1968", "shortCiteRegEx": null, "year": 1983}, {"title": "23:733\u2013742", "author": ["M.H. Van Emden", "R.A. Kowalski. The semantics of predicate logic as a programming language. J. ACM"], "venue": "October", "citeRegEx": "Van Emden and Kowalski. 1976", "shortCiteRegEx": null, "year": 1976}, {"title": "editors", "author": ["Ryan Williams", "Carla Gomes", "Bart Selman. Backdoors to typical case complexity. In Georg Gottlob", "Toby Walsh"], "venue": "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI\u201903), pages 1173\u20131178, Acapulco, Mexico, August", "citeRegEx": "Williams et al.. 2003", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 26, "context": "In fact, due to the success of Sat, NP-complete problems have lost their scariness, as in many cases one can efficiently encode NP-complete problems to Sat and solve them by means of a Sat-solver [Gomes et al., 2008; Biere et al., 2009].", "startOffset": 196, "endOffset": 236}, {"referenceID": 3, "context": "In fact, due to the success of Sat, NP-complete problems have lost their scariness, as in many cases one can efficiently encode NP-complete problems to Sat and solve them by means of a Sat-solver [Gomes et al., 2008; Biere et al., 2009].", "startOffset": 196, "endOffset": 236}, {"referenceID": 5, "context": "Many important problems of AI and reasoning can be represented in terms of the search for answer sets [Brewka et al., 2011; Marek and Truszczynski, 1999; Niemel\u00e4, 1999].", "startOffset": 102, "endOffset": 168}, {"referenceID": 42, "context": "Many important problems of AI and reasoning can be represented in terms of the search for answer sets [Brewka et al., 2011; Marek and Truszczynski, 1999; Niemel\u00e4, 1999].", "startOffset": 102, "endOffset": 168}, {"referenceID": 44, "context": "Many important problems of AI and reasoning can be represented in terms of the search for answer sets [Brewka et al., 2011; Marek and Truszczynski, 1999; Niemel\u00e4, 1999].", "startOffset": 102, "endOffset": 168}, {"referenceID": 14, "context": "Both problems are located at the second level of the Polynomial Hierarchy [Eiter and Gottlob, 1995] and thus assumed to be harder than NP or co-NP.", "startOffset": 74, "endOffset": 99}, {"referenceID": 12, "context": "Such transformations are known as \u201cfpt-transformations\u201d and form the base of the completeness theory of Parameterized Complexity [Downey and Fellows, 1999; Flum and Grohe, 2006].", "startOffset": 129, "endOffset": 177}, {"referenceID": 18, "context": "Such transformations are known as \u201cfpt-transformations\u201d and form the base of the completeness theory of Parameterized Complexity [Downey and Fellows, 1999; Flum and Grohe, 2006].", "startOffset": 129, "endOffset": 177}, {"referenceID": 2, "context": "It is known that the two reasoning problems, when restricted to so-called normal programs, drop to NP and co-NP [Bid\u00f3\u0131t and Froidevaux, 1991; Marek and Truszczynski, 1991a; Marek and Truszczy\u0144ski, 1991b], respectively.", "startOffset": 112, "endOffset": 203}, {"referenceID": 40, "context": "It is known that the two reasoning problems, when restricted to so-called normal programs, drop to NP and co-NP [Bid\u00f3\u0131t and Froidevaux, 1991; Marek and Truszczynski, 1991a; Marek and Truszczy\u0144ski, 1991b], respectively.", "startOffset": 112, "endOffset": 203}, {"referenceID": 41, "context": "It is known that the two reasoning problems, when restricted to so-called normal programs, drop to NP and co-NP [Bid\u00f3\u0131t and Froidevaux, 1991; Marek and Truszczynski, 1991a; Marek and Truszczy\u0144ski, 1991b], respectively.", "startOffset": 112, "endOffset": 203}, {"referenceID": 10, "context": "Tightness is a property of disjunctive logic programs that, similar to normality, lets the complexities of Brave and Skeptical Reasoning drop to NP and co-NP, respectively [Clark, 1978; Fages, 1994].", "startOffset": 172, "endOffset": 198}, {"referenceID": 15, "context": "Tightness is a property of disjunctive logic programs that, similar to normality, lets the complexities of Brave and Skeptical Reasoning drop to NP and co-NP, respectively [Clark, 1978; Fages, 1994].", "startOffset": 172, "endOffset": 198}, {"referenceID": 19, "context": "For further results regarding the parameterized complexity of problems related to backdoors for Sat, we refer to a recent survey paper [Gaspers and Szeider, 2012].", "startOffset": 135, "endOffset": 162}, {"referenceID": 17, "context": "Fichte and Szeider [2012] formulated a backdoor approach for Asp problems, and obtained complexity results with respect to the target class of Horn programs and various target classes based on acyclicity; some results could be generalized [Fichte, 2012].", "startOffset": 239, "endOffset": 253}, {"referenceID": 15, "context": "Dechter, 1994], tight programs [Fages, 1994], and normal programs [Lin and Zhao, 2004; Janhunen, 2006].", "startOffset": 31, "endOffset": 44}, {"referenceID": 38, "context": "Dechter, 1994], tight programs [Fages, 1994], and normal programs [Lin and Zhao, 2004; Janhunen, 2006].", "startOffset": 66, "endOffset": 102}, {"referenceID": 32, "context": "Dechter, 1994], tight programs [Fages, 1994], and normal programs [Lin and Zhao, 2004; Janhunen, 2006].", "startOffset": 66, "endOffset": 102}, {"referenceID": 25, "context": "In particular, solvers for normal programs (Cmodels [Giunchiglia et al., 2006], ASSAT [Lin and Zhao, 2004], Clasp [Gebser et al.", "startOffset": 52, "endOffset": 78}, {"referenceID": 38, "context": ", 2006], ASSAT [Lin and Zhao, 2004], Clasp [Gebser et al.", "startOffset": 15, "endOffset": 35}, {"referenceID": 20, "context": ", 2006], ASSAT [Lin and Zhao, 2004], Clasp [Gebser et al., 2007a]) use certain extensions of Clark\u2019s completion and then utilize either black box Sat solvers or integrate conflict analysis, backjumping, and other techniques within the Asp context.", "startOffset": 43, "endOffset": 65}, {"referenceID": 13, "context": "ClaspD [Drescher et al., 2008] is a disjunctive Asp-solver that utilizes nogoods based on the logical characterizations of loop formulas [Lee, 2005].", "startOffset": 7, "endOffset": 30}, {"referenceID": 36, "context": ", 2008] is a disjunctive Asp-solver that utilizes nogoods based on the logical characterizations of loop formulas [Lee, 2005].", "startOffset": 114, "endOffset": 125}, {"referenceID": 4, "context": "This restriction is not significant as tautological rules can be omitted from a program without changing its answer sets [Brass and Dix, 1998].", "startOffset": 121, "endOffset": 142}, {"referenceID": 24, "context": "The GL reduct of a program P under a set M of atoms is the program P obtained from P by first, removing all rules r with B(r) \u2229M 6= \u2205 and second, removing all \u00acz where z \u2208 B(r) from all remaining rules r [Gelfond and Lifschitz, 1991].", "startOffset": 204, "endOffset": 233}, {"referenceID": 49, "context": "The least model LM(P ) is the least fixed point of TP (A) [Van Emden and Kowalski, 1976].", "startOffset": 58, "endOffset": 88}, {"referenceID": 23, "context": "Note that every positive program P has a unique minimal model which equals the least model LM(P ) [Gelfond and Lifschitz, 1988].", "startOffset": 98, "endOffset": 127}, {"referenceID": 14, "context": "Brave Reasoning is \u03a32 -complete, Skeptical Reasoning is \u03a02 -complete [Eiter and Gottlob, 1995].", "startOffset": 69, "endOffset": 94}, {"referenceID": 12, "context": "For more detailed information we refer to other sources [Downey and Fellows, 1999; Flum and Grohe, 2006; Gottlob and Szeider, 2008; Niedermeier, 2006].", "startOffset": 56, "endOffset": 150}, {"referenceID": 18, "context": "For more detailed information we refer to other sources [Downey and Fellows, 1999; Flum and Grohe, 2006; Gottlob and Szeider, 2008; Niedermeier, 2006].", "startOffset": 56, "endOffset": 150}, {"referenceID": 27, "context": "For more detailed information we refer to other sources [Downey and Fellows, 1999; Flum and Grohe, 2006; Gottlob and Szeider, 2008; Niedermeier, 2006].", "startOffset": 56, "endOffset": 150}, {"referenceID": 43, "context": "For more detailed information we refer to other sources [Downey and Fellows, 1999; Flum and Grohe, 2006; Gottlob and Szeider, 2008; Niedermeier, 2006].", "startOffset": 56, "endOffset": 150}, {"referenceID": 18, "context": "An fpt-reduction r from L to L is a many-to-one reduction from \u03a3\u00d7N to \u03a3\u00d7N such that for all I \u2208 \u03a3 we have (I, k) \u2208 L if and only if r(I, k) = (I , k) \u2208 L such that k \u2264 g(k) for a fixed computable function g : N \u2192 N and there is a computable function f and a constant c such that r is computable in time O(f(k)\u2016I\u2016) where \u2016I\u2016 denotes the size of I [Flum and Grohe, 2006].", "startOffset": 346, "endOffset": 368}, {"referenceID": 12, "context": "We would like to note that the theory of fixed-parameter intractability is based on fpt-reductions [Downey and Fellows, 1999; Flum and Grohe, 2006].", "startOffset": 99, "endOffset": 147}, {"referenceID": 18, "context": "We would like to note that the theory of fixed-parameter intractability is based on fpt-reductions [Downey and Fellows, 1999; Flum and Grohe, 2006].", "startOffset": 99, "endOffset": 147}, {"referenceID": 11, "context": "If P \u2032 is Horn, Pos(P ) has a least model L and P \u2032 has a model if and only if L is a model of Constr(P ) [Dowling and Gallier, 1984].", "startOffset": 106, "endOffset": 133}, {"referenceID": 11, "context": "This follows directly from the fact that we can compute the least model of a Horn program in linear time [Dowling and Gallier, 1984].", "startOffset": 105, "endOffset": 132}, {"referenceID": 34, "context": ", using the well-known transformation due to Tseitin [1968], see also [Kleine B\u00fcning and Lettman, 1999].", "startOffset": 70, "endOffset": 103}, {"referenceID": 31, "context": "For instance, one could share parts between the formulas F i or replace the quadratic formula F lm i for the computation of least models with a smaller and more sophisticated Sat encoding [Janhunen, 2004] or a Sat(Dl) encoding [Janhunen et al.", "startOffset": 188, "endOffset": 204}, {"referenceID": 30, "context": "For instance, one could share parts between the formulas F i or replace the quadratic formula F lm i for the computation of least models with a smaller and more sophisticated Sat encoding [Janhunen, 2004] or a Sat(Dl) encoding [Janhunen et al., 2009] for the Smt framework which combines propositional logic and linear constraints.", "startOffset": 227, "endOffset": 250}, {"referenceID": 18, "context": "Completeness for paraNP and co-paraNP The parameterized complexity class paraNP contains all parameterized decision problems L such that (I, k) \u2208 L can be decided nondeterministically in time O(f(k)\u2016I\u2016), for some computable function f and constant c [Flum and Grohe, 2006].", "startOffset": 250, "endOffset": 272}, {"referenceID": 9, "context": "2738 + kn) [Chen et al., 2006].", "startOffset": 11, "endOffset": 30}, {"referenceID": 35, "context": "A program is called tight if D P is acyclic [Lee and Lifschitz, 2003].", "startOffset": 44, "endOffset": 69}, {"referenceID": 14, "context": "Consider the reduction from Eiter and Gottlob [Eiter and Gottlob, 1995] which reduces the \u03a32 -hard problem \u2203\u2200-QBF Model Checking to the problem Consistency (which decides whether given a program P has an answer set).", "startOffset": 46, "endOffset": 71}, {"referenceID": 14, "context": "The intractability of Skeptical Reasoning follows directly by the reduction of Eiter and Gottlob [Eiter and Gottlob, 1995] from the problem Consistency.", "startOffset": 97, "endOffset": 122}, {"referenceID": 47, "context": "ConformantPlanning: secure planning under incomplete initial states [To et al., 2009] encodings provided by Gebser and Kaminski [2012].", "startOffset": 68, "endOffset": 85}, {"referenceID": 22, "context": "MinimalDiagnosis: an application in systems biology [Gebser et al., 2008] instances provided by Calimeri et al.", "startOffset": 52, "endOffset": 73}, {"referenceID": 33, "context": "MUS: problem whether a clause belongs to some minimal unsatisfiable subset [Janota and Marques-Silva, 2011] encoding provided by Gebser and Kaminski [2012].", "startOffset": 75, "endOffset": 107}, {"referenceID": 21, "context": "StrategicCompanies: encoding the \u03a3P2 -complete problem of producing and owning companies and strategic sets between the companies [Gebser et al., 2007b].", "startOffset": 130, "endOffset": 152}, {"referenceID": 16, "context": "Furthermore, we have compared the size of a smallest strong Normal-backdoor with the size of a smallest strong Horn-backdoor [Fichte and Szeider, 2012] for selected sets.", "startOffset": 125, "endOffset": 151}], "year": 2013, "abstractText": "Over the last two decades, propositional satisfiability (Sat) has become one of the most successful and widely applied techniques for the solution of NP-complete problems. The aim of this paper is to investigate theoretically how Sat can be utilized for the efficient solution of problems that are harder than NP or co-NP. In particular, we consider the fundamental reasoning problems in propositional disjunctive answer set programming (Asp), Brave Reasoning and Skeptical Reasoning, which ask whether a given atom is contained in at least one or in all answer sets, respectively. Both problems are located at the second level of the Polynomial Hierarchy and thus assumed to be harder than NP or co-NP. One cannot transform these two reasoning problems into Sat in polynomial time, unless the Polynomial Hierarchy collapses. We show that certain structural aspects of disjunctive logic programs can be utilized to break through this complexity barrier, using new techniques from Parameterized Complexity. In particular, we exhibit transformations from Brave and Skeptical Reasoning to Sat that run in time O(2n) where k is a structural parameter of the instance and n the input size. In other words, the reduction is fixed-parameter tractable for parameter k. As the parameter k we take the size of a smallest backdoor with respect to the class of normal (i.e., disjunction-free) programs. Such a backdoor is a set of atoms that when deleted makes the program normal. In consequence, the combinatorial explosion, which is expected when transforming a problem from the second level of the Polynomial Hierarchy to the first level, can now be confined to the parameter k, while the running time of the reduction is polynomial in the input size n, where the order of the polynomial is independent of k. We show that such a transformation is not possible if we consider backdoors with respect to tightness instead of normality. We think that our approach is applicable to many other hard combinatorial problems that lie beyond NP or co-NP, and thus significantly enlarge the applicability of Sat.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}