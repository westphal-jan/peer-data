{"id": "1308.0183", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Aug-2013", "title": "An n-ary Constraint for the Stable Marriage Problem", "abstract": "we present an unspecified n - weighted ary constraint for the stable rigid marriage constraints problem. hence this constraint acts between we two sets of integer variables alike where the domains representations of those numerical variables represent preferences. locally our constraint enforces lattice stability laws and disallows bigamy. solve for a stable strong marriage instance with $ n $ int men _ and $ @ n $ the women ] we require only assume one of these minimum constraints, therefore and the complexity construct of tightly enforcing arc - specific consistency is $ o ( n ^ \u03b4 2 ) $ which efficiently is optimal solely in the size nature of input. our experimental computational studies show that our nonlinear n - ary constraint is significantly - faster for and more space handling efficient than the encodings presented online in \\ cite { p cp01 }. subsequently we also introduce from a generic new marital problem central to the constraint community, hence the sex - equal stable no marriage problem.", "histories": [["v1", "Thu, 1 Aug 2013 12:56:47 GMT  (27kb)", "http://arxiv.org/abs/1308.0183v1", "7 pages. The Fifth Workshop on Modelling and Solving Problems with Constraints, held at the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005)"]], "COMMENTS": "7 pages. The Fifth Workshop on Modelling and Solving Problems with Constraints, held at the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005)", "reviews": [], "SUBJECTS": "cs.DS cs.AI", "authors": ["chris unsworth", "patrick prosser"], "accepted": false, "id": "1308.0183"}, "pdf": {"name": "1308.0183.pdf", "metadata": {"source": "CRF", "title": "An n-ary Constraint for the Stable Marriage Problem", "authors": ["Chris Unsworth", "Patrick Prosser"], "emails": ["chrisu@dcs.gla.ac.uk", "pat@dcs.gla.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 8.\n01 83\nv1 [\ncs .D\nS] 1\nA ug\n2 01"}, {"heading": "1 Introduction", "text": "In the Stable Marriage problem (SM) [2; 5] we have n men and n women. Each man ranks the n women into a preference list, as do the women. The problem is then to produce a matching of men to women such that it is stable. By a matching we mean that there is a bijection from men to women, and by stable we mean that there is no incentive for partners to divorce and elope. A matching is unstable if there are two couples (mi, wj) and (mk, wl) such that mi prefers wl to his current partner wj , and wl prefers mi to her current partner mk.\nFigure 1 is an instance of the stable marriage problem, and has 6 men and 6 women. Figure 1 shows the problem initially, with each man and woman\u2019s preference list. Figure 2 shows the intersection of the male and female-oriented GaleShapley lists (GS-lists) [5], where the GS-lists are reduced preference lists. A man-optimal (woman-pessimal) stable matching can now be found by marrying men (women) to their most (least) preferred choices in there GS-lists. Conversely, we can produce a woman-optimal (man-pessimal) matching by marrying women (men) to their most (least) preferred choice in their GS-lists. An instance of SM admits at least one stable matching and this can be found via the Extended Gale-Shapley algorithm in time O(n2), where there are n men and n women.\n\u2217The first author is supported by EPSRC. Software support was given by an ILOG SA\u2019s academic grant.\nWe present a simple constraint encoding for the stable marriage problem. We introduce a specialised n-ary constraint with only three methods, where each method is no more than six lines of code. We show how enforcing arc-consistency in this encoding results in the male-oriented Gale-Shapley lists. This minimal encoding cannot be used in search and only achieves directed arc-consistency, from men to women. We then go on to show how we can extend this encoding by introducing a modest amount of additional code, such that the encoding can be used in search, can be embedded in richer impure problems where the stability of marriages is only part of a larger problem, and the male and female oriented GS-lists are produced. Our empirical results suggest, that although our encodings has O(n2) time complexity, the same as the optimal encoding proposed in [3], our constraint significantly outperforms this encoding in both space and time."}, {"heading": "2 The Extended Gale-Shapley Algorithm (EGS)", "text": "We now describe the male-oriented Extended Gale-Shapley (EGS) algorithm (shown in Figure 3). In particular, we explain what is meant by a proposal, an engagement, and for a man to become free. We will use this later to show that this\nalgorithm and our constraint encoding are equivalent. The EGS algorithm [5] produces a stable matching between men m1 to mn and women w1 to wn, where each man (woman) ranks each of the women (men) into preference order. Via a process of proposals from men to women the algorithm delivers reduced preference lists, called GS-lists (GaleShapley lists), such that if each man (woman) is paired with his (her) best (worst) partner in their GS-list the marriages will be stable.1\n1 assign each person to be free 2 WHILE (some man m is free) 3 DO BEGIN 4 w := first woman on m\u2019s list 5 IF (some man p is engaged to w) 6 THEN assign p to be free 7 assign m and w to be engaged 8 FOR (each successor p of m on w\u2019s list) 9 DO BEGIN\nWe will assume that we have an instance I of the stable marriage problem, and that for any person q in I , PL(q) is the ordered list of persons in the original preference list of q and GS(q) is the ordered list of people in the GS-list for q, and initially GS(q) equals PL(q). In a proposal from man m to woman w, w will be at the head of the man\u2019s GS-list GS(m). This leads to an engagement where m is no longer free and all men that w prefers less than m are removed from her GS-list, i.e. the last entry in GS(w) becomes m. Further, when a man p is removed from GS(w) that woman is also removed from his GS-list, i.e. w is removed from GS(p), consequently bigamy is disallowed. Therefore m and w are engaged when m is no longer free, w is head of GS(m), and m is at the tail of GS(w). A man p becomes free when p was engaged to w (i.e. the head of GS(p) is w) and w receives a proposal from man m that she prefers to p. On becoming free, p is added to the list of free men and w is removed from GS(p).\nThe algorithm starts with all men free and placed on a list (line 1). The algorithm then performs a sequence of proposals (lines 2 to 13). A man m is selected from the free list (line 2), and his most preferred woman w is selected (line 4). If w is engaged, then her partner p becomes free. The pair m and w then become engaged (lines 7 to 12)."}, {"heading": "3 Preliminaries", "text": "We assume that the men and women\u2019s preference lists have been read into two 2-dimensional integer arrays mpl and wpl respectively. mpl[i] is the preference list for the ith man\n1Strictly speaking, the given algorithm produces MGS-lists, the male GS-lists. But for the sake of brevity we will refer to them as GS-lists.\nwhere mpl[i][j] is the ith man\u2019s jth preference, and similarly wpl[j] is the preference list for the jth woman. Using our problem in Figure 1, if we consider our 3d man he will have a preference list mpl[3] = (1, 4, 5, 3, 6, 2).\nWe also assume we have the inverse of the preference lists, i.e. mPw and wPm, where mPw[i][j] is the ith man\u2019s preference for the jth woman and wPm[k][l] is the kth woman\u2019s preference for the lth man. Again, considering the 3d man in Figure 1, his inverse preference list will be mPw[3] = (1, 6, 4, 2, 3, 5), mPw[3][2] is his preference for the 2nd woman, and that is 6, i.e. woman 2 is in the 6th position of man 3\u2019s preference list.2\nWe associate a constrained integer variable with each man and each woman, such that x[i] is a constrained integer variable representing the ith man mi in stable marriage instance I and has a domain dom(x[i]) initially of 1 to n. Similarly, we have an array of constrained integer variables for women, such that y[j] represents the jth woman wj in I . The values in the domain of a variable correspond to preferences, such that if variable x[i] is assigned the value a this corresponds to mi being married to his ath choice of woman, and this will be woman mpl[i][a]. For example, if x[2] (in Figure 1) is set to 3 then this corresponds to m2 marrying his 3d choice, w1 (and conversely y[1] would then have to be assigned the value 5). Again referring to Figure 1 our 6th man\u2019s domain is dom(x[6]) = (1, 2, 3, 4, 5, 6), as is everyone else\u2019s, and in Figure 2 dom(x[6]) = (1, 4, 5). We also assume that we have the following functions, each being of O(1) complexity, that operate over constrained integer variables:\n\u2022 getMin(v) delivers the smallest value in dom(v).\n\u2022 getMax(v) delivers the largest value in dom(v).\n\u2022 getV al(v) delivers the instantiated value of v.\n\u2022 setMax(v, a) sets the maximum value in dom(v) to be min(getMax(v), a).\n\u2022 setV al(v, a) instantiates the variable v to the value a.\n\u2022 remV al(v, a) removes the value a from dom(v).\nWe assume that constraints are processed by an arcconsistency algorithm such as AC5 [9] or AC3 [7]. That is, the algorithm has a stack of constraints that are awaiting revision and if a variable loses values then all the constraints that the variable is involved in are added to the stack along with the method that must be applied to those constraints, i.e. the stack contains methods and their arguments. Furthermore, we also assume that a call to a method, with its arguments, is only added to the stack if it is not already on the stack. We\u2019ll refer to this stack as the call stack."}, {"heading": "4 An n-ary Stable Marriage Constraint (SM2N)", "text": "We now give a description of our n-ary stable marriage constraint, where arc-consistency on such an encoding is equivalent to an application of the male-oriented EGS algorithm.\n2The inverse of the preference lists can be created when reading in the preference lists such that mPw[i][mpl[i][j]] = j, and this does not affect the overall complexity of constructing our model.\nNote that the constraint as described minimally cannot be used within a search process, however we will later show how this can be done. Our constraint is n-ary in that it constrains n men and n women such that stability is maintained and bigamy is disallowed, although it achieves only 2-consistency.3 In a stable marriage problem with n men and n women we will then require only one of these constraints. We now start by describing the attributes of the constraint and the three methods that act upon it. We will use a javalike pseudo-code such that the . (dot) operator is an attribute selector, such that a.b delivers the b attribute of a."}, {"heading": "4.1 The attributes", "text": "A n-ary stable marriage constraint (SM2N) is an object that acts between n men and n women, and has the following attributes:\n\u2022 x and y are constrained integer variable arrays representing the men and women that are constrained, such that x[i] is the constrained integer variable corresponding to mi and y[j] corresponds to wj .\n\u2022 xpl and ypl are 2-dimensional integer arrays which contain the male and female preference lists respectively, such that xpl[i] equals PL(mi) and xpl[i][j] contains mi\u2019s jth choice woman.\n\u2022 xPy and yPx are 2-dimensional integer arrays which contain the male and female inverse preference lists respectively, such that xPy[i][j] contains man i\u2019s preference for wj .\n\u2022 yub is an array of integer variables which contain the previous upper bounds of all y variables. All are set to n at the start of search and are updated by the deltaMax(i) method detailed below."}, {"heading": "4.2 The propagation methods", "text": "We now describe three methods that achieve male-oriented arc-consistency.\ndeltaMin(i) This method is called when the lower bound of dom(x[i]) increases. The lower bound of dom(x[i]) increasing signifies that mi has been rejected by his favourite choice of partner and thus must propose to his new favourite available partner. To do this we first find mi\u2019s favourite available partner wj (line 2), then remove all men from the list of wj she likes less than mi (line 3).\n1. deltaMin(i) 2. j = xPy[i][getMin(x[i])] 3. setMax(y[j],yPx[j][i])\ndeltaMax(j) This method is called when the upper bound of dom(y[j]) is reduced. To maintain consistency wj needs to be removed from the domains of all men that have been removed from her domain. This is done by looping once for each value that has been removed from the tail of dom(y[j]) since the last call\n3A detailed explanation of just what we mean by 2-consistency in this model is given in section 6.\nto deltaMax(j) (line 2). Within the loop a mi that has been removed from dom(y[j]) is selected (line 3) and then wj is removed from dom(x[i]). When all relevant men have had their domains\u2019 altered (line 5) yub is updated (line 6).\n1. deltaMax(j) 2. FOR (k = getMax(y[j])+1 to yub[j]) 3. i = yPx[j][k] 4. remVal(x[i],xPy[i][j]) 5. END FOR LOOP 6. yub[j] = getMax(y[j])\ninit() The init method is called when the constraint is created, and is simply a call to deltaMin for each of the n men variables.\n1. init() 2. FOR (i = 1 to n) 3. deltaMin(i) 4. END FOR LOOP"}, {"heading": "5 Comparison to EGS", "text": "We now compare the behaviour of our n-ary constraint model (SM2N) to the male-oriented EGS algorithm. In our comparison we will describe steps in the EGS algorithm in italics and the SM2N constraint encoding in normal font. Sometimes we will use m and w as a particular person (rather than mi and wj), and x and y as particular variables (rather than x[i] and y[j]) for sake of brevity. Additionally, we assume we have the function fiance(y[i]) and that it delivers the integer k where k = wpl[i][max(dom(y[i])], i.e. x[k] is the least preferred partner of y[i].\n\u2022 Initially the EGS algorithm sets all men to be free by adding them to the free list (line 1). Equivalently, when propagation starts the call to init() will cause the set of calls {deltaMin(i)|1 \u2264 i \u2264 n} to be added to the empty call stack.\n\u2022 EGS picks a man m from the free list and he then proposes to his first choice woman w (lines 4 to 7). Initially the call stack will contain n calls to the deltaMin method, called directly via init. When executing the call deltaMin(i), man x[i] will make the equivalent of a proposal to his first choice woman (as described next).\n\u2022 When m makes a proposal to w all values that appear in GS(w) after the proposing man are removed (lines 8 to 10), i.e. they become engaged. When the call deltaMin(i) is made, where y[j] is x[i]\u2032s favourite, the maximum of dom(y[j]) is set to y[j]\u2032s preference for x[i], therefore removing all less preferred men. Effectively, x[i] and y[j] become engaged.\n\u2022 To maintain monogamy EGS removes the newly engaged woman from the GS-lists of all men that have just been removed from her preference list (line 11). From the action above, the maximum of dom(y[j]) has been lowered, consequently a call to deltaMax(j) will be added to the call stack. In that call to deltaMax(j), y[j] is removed from dom(x[k]) for all k where k has been removed from the tail of dom(y[j]). Therefore, x[k] and y[j] can never be married.\n\u2022 In EGS, if m makes a proposal to w, who is already engaged to p, then w\u2032s previous fiance p is assigned to be free and added to the free list (lines 5 and 6.) On initiating the call deltaMin(i) where y[j] is x[i]\u2032s favourite available woman, y[j]\u2032s fiance corresponds to the maximum value in dom(y[j]), because all less preferred men will have been removed (as above). Therefore if y[j] receives a proposal from x[i] via the call deltaMin(i), and y[j] prefers x[i] to her current fiance x[k] (where k = fiance(y)) the maximum of dom(y[j]) will be set lower than her preference for x[k] and therefore her preference for x[k] will be removed from dom(y[j]). Consequently, the call deltaMax(j) will then be put on the call stack, which will remove x[k]\u2032s preference for y[j] from dom(x[k]). Because y[j] was x[k]\u2032s previous favourite, x[k]\u2032s preference for y[j] would have been min(dom(x[k])). Therefore removing that value will increase x[k]\u2032s domain minimum, and the call deltaMin(k) will then be added to the stack. And this effectively assigns man x[k] to be free."}, {"heading": "6 Arc-consistency in the Model", "text": "On the completion of arc-consistency processing, the variable domains can be considered as GS \u2212 domains. That is, a \u2208 dom(x[i]) \u2194 wj \u2208 GS(mi) \u2227 j = mpl[i][a]. Furthermore, b \u2208 dom(y[j]) \u2194 mi \u2208 GS(wj) \u2227 i = wpl[j][b].\nThe GS-domains are 2-consistent such that if man mi is married to a woman wj (i.e. x[i] = a \u2227 a \u2208 dom(x[i]) \u2227 j = mpl[i][a]) then any woman wl can then marry some man mk without forming a blocking pair or a bigamous relationship. That is, for an arbitrary woman wl there exists a value b \u2208 dom(y[l]) such that k = wpl[l][b] \u2227 (mPw[i][j] < mPw[i][l] \u2228 wPm[l][k] < wPm[l][i]) \u2227 i 6= k \u2227 j 6= l. Furthermore if a man mi is married to a woman wj then any other man mk can then marry some woman wl, where l 6= j.\nIt is important to note, that although our constraint is n-ary it only achieves 2-consistency. It is our opinion that the cost of achieving a higher level of consistency would be of little advantage. This is so because by maintaining 2-consistency, and using a suitable value ordering heuristic in the model during search we are guaranteed failure-free enumeration of all solutions [3].\nIn [5] Theorem 1.2.2 it is proved that all possible executions of the Gale-Shapley algorithm (with men as proposers) yield the same stable matchings. Our encoding mimics the EGS algorithm (as shown in section 5) and we claim (without proof) that the encoding reaches the same fixed point for all ordering of the revision methods on the call stack."}, {"heading": "7 Complexity of the model", "text": "In [5] section 1.2.3 it is shown in the worst case there is at most n(n \u2212 1) + 1 proposals that can be made by the EGS algorithm, and that the complexity is then O(n2). We argue that the complexity of our SM2N encoding is also O(n2). First we claim that the call to our method deltaMin() is of complexity O(1). The deltaMax() method is of complexity O(r), where r is the number of values removed from the tail of variable since the last call to deltaMax() for this variable.\nBecause there are n values in the domain of variable y the worse case complexity for all possible calls to deltaMax(j) is O(n). Equally there are n values in the domain of variable x and thus the worse case complexity for all possible calls to deltaMin(i) is O(n). Therefore because there are n y variables and n x variables, the total worst case complexity for all possible calls to deltaMin(i) and deltaMax(j) is O(n2)."}, {"heading": "8 Enhancing the model", "text": "The full GS-Lists are the union of the male and female GaleShapley lists remaining after executing male and female oriented versions of EGS. It has been proven that the same lists can be produced by running the female orientated version of EGS on the male-oriented GS-lists [5]. Because SM2N produces the same results as EGS the full GS-Lists can be produced in the same way. But because of the structure of this specialised constraint it is also possible to combine the male and female orientated versions of SM2N into one constraint. This combined gender free version of SM2N will then produce the full GS-List with only one run of the arc-consistency algorithm. To create the gender free version all of the methods presented in this paper must then be symmetrically implemented from the male and female orientations.\nThe SM2N constraint as presented so far has only considered domain values being removed by the constraint\u2019s own methods. If we were to use the constraint to find all possible stable matchings, unless arc consistency reduces all variable domains to a singleton, it will be necessary to assign and remove values from variable domains as part of a search process. Therefore, we need to add code to SM2N to maintain consistency and stability in the event that domain values are removed by methods other than those within SM2N. It is important to note that these external domain reductions could also be caused by side constraints as well as a search process.\nThere are four types of domain reduction that external events could cause: a variable is instantiated; a variable\u2019s minimum domain value is increased; a variable\u2019s maximum domain value is reduced; one or more values are removed from the interior of a variable\u2019s domain. We now describe two additional methods, inst and removeV alue, and the enhancements required for deltaMin. We note that deltaMax does not need to change, and describe the required enhancements for incomplete preference lists.\ninst(i) The method inst(i) is called when a variable x[i] is instantiated.\n1. inst(i) 2. For (k = 0 to getVal(x[i])-1) 3. j = xPy[i][k] 4. setMax(y[j],yPx[j][i]-1) 5. END FOR LOOP 6. j = xPy[i][getVal(x[i])] 7. setVal(y[j],yPx[j][i]) 8. For (k = getVal(x[i])+1 to n) 9. j = xPy[i][k]\n10. remVal(y[j],yPx[j][i]) 11. END FOR LOOP\nThis method removes all values from the set of y variables to prevent variable x[i] being involved in a blocking pair or\ninconsistency. To prevent x[i] from creating a blocking pair, all the values that corresponds to men less preferred than x[i], are removed from the domains of all women that x[i] prefers to his assigned partner (lines 2-5). Since x[i] is matched to y[j], y[j] must now be matched to x[i] (lines 6,7). To maintain consistency x[i] is removed from the domains of all other women (lines 8-11)). The complexity of this method is O(n) and because there are n x variables and each can only be instantiated once during propagation, the total time complexity of all possible calls to inst(i) is O(n2).\nremoveValue(i,a) This method is called when the integer value a is removed from dom(x[i]), and this value is neither the largest nor smallest in dom(x[i]).\n1. removeValue(i,a) 2. j = xPy[i][a] 3. remVal(y[j],yPx[j][i])\nThe woman the value a corresponds to is found (line 2) then x[i] is removed from her domain (line 3), and this must be done to prevent bigamy.\nEnhancements to deltaMin(i) Up till now we have assumed that all values removed from the head of dom(x[i]) are as a result of mi being rejected by some wj . We now drop this assumption in the following enhanced version. In this method we add a new variable array named xlb, and this is similar to the yub array except it holds the previous lower bound of x. All elements in xlb are initialised to 1 and are updated and used only by the deltaMin method.\n1. deltaMin(i) 2. j = xPy[i][getMin(x[i])] 3. setMax(y[j],yPx[j][i]) 4. FOR (k = xlb[i] to getMin(x[i])-1) 5. j = xPy[i][k] 6. setMax(y[j],yPx[j][i]-1) 7. END FOR LOOP 8. xlb[i] = getMin(x[i])\nLines 1 to 3 are as the original. The next four lines (lines 4- 7) cycle through each of the values that have been removed from the head of dom(x[i]) since the last call to deltaMin(i) (line 4). y[j], which the removed value corresponds to, is then found (line 5), and then all values that are not strictly greater than her preference for x[i] are removed from dom(y[j]) (line 6). The lower bound of the man variable x[i] is then updated (line 8)."}, {"heading": "No enhancements to deltaMax(j)", "text": "We now consider the situation where some process, other than a proposal, removes values from the tail of dom(y[j]), i.e. when the maximum value of dom(y[j]) changes. The deltaMax method will be called, and the instance continues to be stable as all values remaining in dom(y[j]) corresponding to men wj prefers to the removed values. However, we need to prevent bigamy, by removing wj from the corresponding dom(x) variables removed from the tail of dom(y[j]), and this is just what deltaMax does. Therefore, no enhancement is required.\nIncomplete Lists (SMI) The encoding can also deal with incomplete preference lists, i.e. instances of the stable marriage problems with incomplete lists (SMI). For a SM instance of size n we introduce the value n+1. The value n+1 must appear in the preference lists mpl[i] and wpl[j] as a punctuation mark, such that any people after n+1 are considered unacceptable. For example, if we had an instance of size 3 and a preference list PL(mi) = (3,2) we would construct mpl[i] = (3, 2, 4, 1) and this would result in the inverse mPw[i] = (4, 2, 1, 3). Consequently x[i] would always prefer to be unmatched (assigned the value 4) than to be married to y[1]. We now need to modify the init method such that it sets the maximum value in dom(x[i]) to be mPw[i][n+1]. These modifications will only work in the full implementation (i.e. it requires the above enhancements).\nReversible integers In this encoding we have used two variable arrays which contain dynamic data. yub and xlb are initialised to n and 1 respectively, but these values will be updated as the problem is being made arc-consistent. If we are only looking for the first solution then we need only use normal integers to hold these values. However, when the constraint solver backtracks and values that had been removed from the domain of a variable are reintroduced then the values held in yub and xlb will no longer be correct. To fix this problem we have to tell the solver that when it backtracks it needs to reverse the changes to yub and xlb as well as the variables domains. This is done by using a reversible integer variable. This class should be supplied in the constraint solver toolkit. The solver will then store the values of each of the reversible variables at each choice point and restore them on backtracking."}, {"heading": "9 Computational Experience", "text": "We implemented our encodings using the JSolver toolkit [1], i.e. the Java version of ILOG Solver. In a previous paper [8] we presented a specialised binary constraint (SM2) for the stable marriage problem, and presented some results comparing the SM2 constraint with the two constraint encoding in [3]. Here we show a chopped down version of those results, with the results obtained by running SM2N on the same set of test data included. The other model shown in the results table is the optimal boolean encoding (Bool) as presented in [3]. Our experiments were run on a Pentium 4 2.8Ghz processor with 512 Mbytes of random access memory, running Microsoft Windows XP Professional and Java2 SDK 1.4.2.6 with an increased heap size of 512 Mbytes.\nOur first experiment measures the time taken to generate a model of a given SM instance and make that model arcconsistent, i.e. to produce the GS-lists. Table 1 shows the average time taken to produce the GS-lists for ten randomly generated instances of size 100 up to 1000. Time is measured in seconds, and an entry ME means that an out of memory error occurred. We can see that the SM2N constraint dominates the other models.\nThis second experiment measures the time taken to generate a model and find all possible stable matchings. Table 2 shows the average time taken to find all solutions on the same randomly generated instances used in the first experiment. Again it can be seen that the SM2N model dominates the other models. In summary, when the boolean encoding solves a problem the n-ary constraint does so nearly 100 times faster, and the n-ary constraint can model significantly larger problems than the boolean encoding.\nTables 1 and 2 raise the following question, if the Bool encoding is optimal then why is it dominated by the SM2 encoding, when SM2 is O(n3) time and the Bool encoding is O(n2) time? The main reason for this is that there is no significant difference in the space required to represent variables with significant differences in domain size, because domains are represented as intervals when values are consecutive. Considering only the variables, the Bool encoding uses O(n2) space whereas the SM2 model uses O(n) space. For example, with n = 1300 the Bool encoding runs out of memory just by creating the 2.13002 variables whereas the SM2 model takes less than 0.25 seconds to generate the required 2600 variables each with a domain of 1 to 1300. Theoretically the space complexity of the constraints used by SM2 and Bool are the same. In practise this is not the case as SM2 requires exactly n2 constraints to solve a problem of size n whereas Bool requires 2n + 6n2 constraints. Therefore the Bool encoding requires more variables and more constraints, resulting in a prohibitively large model. The same argument also applies to the performance of the SM2N constraint, i.e. the n-ary constraint is more space efficient that the Bool encoding, is of the same time complexity, and this results in superior performance. The space and time complexities of these models are tabulated below. Note that the O(n2) constraint-space for SM2N is a consequence of the storage of the preference lists and their inverses.\nThis Third experiment shows how SM2N can handle larger problems. Table 4 shows the average time taken to both produce the GS-Lists and find all solutions for one hundred randomly generated instances of size 1000 up to 2000, again the times are in seconds."}, {"heading": "10 Sex equal optimisation", "text": "The sex equal stable marriage problem (SESMP) as posed in [5] as an open problem, is essentially an optimisation problem. A male optimal solution to an SMP is where all men get there best possible choices from all possible stable matchings (and all women get there worst), and in a woman optimal solution all women are matched to there best possible choices (and all men to there worst). A sex equal matching is where both the men and the women are equally well matched. This problem has been proven to be NP-Hard [6].\nIn a SESMP all men will have a score for each woman and all women will have a score for each man, man mi\u2019s score for womanwj is mScore[i][j] and womanwj \u2019s score for man mi is wScore[j][i]. In an unweighted SESMP all scores will be the same as the preferences, so mScore[i][j] would equal mPw[i][j] and wScore[j][i] would equal wPm[j][i]. In a weighted SESMP this is not so, but the same ordering must be maintained meaning mScore[i][j] < mScore[i][k] iff mPw[i][j] < mPw[i][k]. For any matching M all men and women will score the matching determined by which partner they are match to in M . If man mi is matched to woman wj in matching M then mi will give that matching a score of mScore[i][j] and woman wj will give it a score of wScore[j][i]. The sum of all scores given by men for a matching M equals sumM(M) and the sum of the women\u2019s scores is sumW (M). A matching M for an instance I of the stable marriage problem is sex equal iff there exists no matching M such that the absolute difference between the sumM(M) and sumW (M) is less than the absolute difference between sumM(M) and sumW (M).\nBecause the values in the domains of the x and y variables are preferences, it makes finding an unweighted sex equal matching with SM2N simple. All that is required is to add a search goal to minimise the absolute difference between the sum of all x variables and the sum of all y variables. We tested this using the same test data as in Table 4 and the results are tabulated below. These results can be compared to those in Figure 6 of [8], where the Bool encoding failed to model problems with 300 or more men and women, and at n = 1000 the SM2 model was more than 15 times slower than the SM2N model. We believe that this demonstrates the\nversatility of our constraint, in that we can easily use the constraint as part of a richer problem."}, {"heading": "11 Implementation", "text": "The SM2N constraint was originally developed using the choco constraints tool kit, and the way the constraint has been introduced reflects that. In choco to implement a user defined constraint, the abstractLargeIntConstraint class is extended. This class contains the methods awake, awakeOnInf , awakeOnSup, awakeOnRem and awakeOnInst. These methods are the equivalent of the ones used to introduce the constraint. awake is the same as init, awakeOnInf and awakeOnSup are the same as deltaMin and deltaMax and awakeOnInst is the same as inst. To implement a constraint in Ilog JSolver we first state when the constraint needs to be propagated, i.e. when a domain value is removed, when the range changes (meaning the upper or lower bound changes) or just when a variable is instantiated. We then need to define a method that will handle propagation when such an event occurs. For the SM2N constraint we stated it was to be propagated every time the range of a variable changed. We then used conditional statements to ascertain which bound had changed, and used the methods as presented above to handle the propagation."}, {"heading": "12 Conclusion", "text": "We have presented a specialised n-ary constraint for the stable marriage problem, possibly with incomplete lists. The constraint can be used when stable marriage is just a part of a larger, richer problem. Our experience has shown that this constraint can be implemented in a variety of constraint programming toolkits, such as JSolver, JChoco, and Koalog. The complexity of the constraint is O(n2). Although this is theoretically equal to the optimal O(n2) complexity of the Boolean encoding in [3], our constraint is more practical, typically being able to solve larger problems faster. For example, we have been able to enumerate all solutions to instances of size 2000 in seconds, whereas in [4] the largest problems investigated were of size 60. We have also presented the first study of SESMP using a constraint solution, i.e. where the stable matching constraints are part of a richer problem."}, {"heading": "Acknowledgements", "text": "We are grateful to ILOG SA for providing us with the JSolver toolkit via an Academic Grant licence. We would also like to thank our four reviewers."}], "references": [{"title": "College admissions and the stability of marriage", "author": ["D. Gale", "L.S. Shapley"], "venue": "American Mathematical Monthly,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1962}, {"title": "A constraint programming approach to the stable marriage problem", "author": ["I.P. Gent", "R.W. Irving", "D.F. Manlove", "P. Prosser", "B.M. Smith"], "venue": "In CP\u201901,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "An empirical study of the stable marriage problem with ties and incomplete lists", "author": ["I.P. Gent", "P. Prosser"], "venue": "In ECAI\u201902,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2002}, {"title": "The Stable Marriage Problem: Structure and Algorithms", "author": ["D. Gusfield", "R.W. Irving"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1989}, {"title": "Complexity of the sex-equal stable marriage problem", "author": ["Akiko Kato"], "venue": "Japan Journal of Industrial and Applied Mathematics (JJIAM),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1993}, {"title": "Consistency in networks of relations", "author": ["A.K. Mackworth"], "venue": "Artificial Intelligence,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1977}, {"title": "A specialised binary constraint for the stable marriage problem", "author": ["C. Unsworth", "P. Prosser"], "venue": "In SARA05,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "A generic arc-consistency algorithm and its specializations", "author": ["Pascal van Hentenryck", "Yves Deville", "Choh-Man Teng"], "venue": "Artificial Intelligence,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1992}], "referenceMentions": [{"referenceID": 1, "context": "Our computational studies show that our n-ary constraint is significantly faster and more space efficient than the encodings presented in [3].", "startOffset": 138, "endOffset": 141}, {"referenceID": 3, "context": "Figure 2 shows the intersection of the male and female-oriented GaleShapley lists (GS-lists) [5], where the GS-lists are reduced preference lists.", "startOffset": 93, "endOffset": 96}, {"referenceID": 1, "context": "Our empirical results suggest, that although our encodings has O(n) time complexity, the same as the optimal encoding proposed in [3], our constraint significantly outperforms this encoding in both space and time.", "startOffset": 130, "endOffset": 133}, {"referenceID": 3, "context": "The EGS algorithm [5] produces a stable matching between men m1 to mn and women w1 to wn, where each man (woman) ranks each of the women (men) into preference order.", "startOffset": 18, "endOffset": 21}, {"referenceID": 1, "context": "Using our problem in Figure 1, if we consider our 3 man he will have a preference list mpl[3] = (1, 4, 5, 3, 6, 2).", "startOffset": 90, "endOffset": 93}, {"referenceID": 1, "context": "Again, considering the 3 man in Figure 1, his inverse preference list will be mPw[3] = (1, 6, 4, 2, 3, 5), mPw[3][2] is his preference for the 2 woman, and that is 6, i.", "startOffset": 81, "endOffset": 84}, {"referenceID": 1, "context": "Again, considering the 3 man in Figure 1, his inverse preference list will be mPw[3] = (1, 6, 4, 2, 3, 5), mPw[3][2] is his preference for the 2 woman, and that is 6, i.", "startOffset": 110, "endOffset": 113}, {"referenceID": 0, "context": "Again, considering the 3 man in Figure 1, his inverse preference list will be mPw[3] = (1, 6, 4, 2, 3, 5), mPw[3][2] is his preference for the 2 woman, and that is 6, i.", "startOffset": 113, "endOffset": 116}, {"referenceID": 0, "context": "For example, if x[2] (in Figure 1) is set to 3 then this corresponds to m2 marrying his 3 choice, w1 (and conversely y[1] would then have to be assigned the value 5).", "startOffset": 17, "endOffset": 20}, {"referenceID": 4, "context": "Again referring to Figure 1 our 6 man\u2019s domain is dom(x[6]) = (1, 2, 3, 4, 5, 6), as is everyone else\u2019s, and in Figure 2 dom(x[6]) = (1, 4, 5).", "startOffset": 55, "endOffset": 58}, {"referenceID": 4, "context": "Again referring to Figure 1 our 6 man\u2019s domain is dom(x[6]) = (1, 2, 3, 4, 5, 6), as is everyone else\u2019s, and in Figure 2 dom(x[6]) = (1, 4, 5).", "startOffset": 126, "endOffset": 129}, {"referenceID": 7, "context": "We assume that constraints are processed by an arcconsistency algorithm such as AC5 [9] or AC3 [7].", "startOffset": 84, "endOffset": 87}, {"referenceID": 5, "context": "We assume that constraints are processed by an arcconsistency algorithm such as AC5 [9] or AC3 [7].", "startOffset": 95, "endOffset": 98}, {"referenceID": 1, "context": "This is so because by maintaining 2-consistency, and using a suitable value ordering heuristic in the model during search we are guaranteed failure-free enumeration of all solutions [3].", "startOffset": 182, "endOffset": 185}, {"referenceID": 3, "context": "In [5] Theorem 1.", "startOffset": 3, "endOffset": 6}, {"referenceID": 3, "context": "In [5] section 1.", "startOffset": 3, "endOffset": 6}, {"referenceID": 3, "context": "It has been proven that the same lists can be produced by running the female orientated version of EGS on the male-oriented GS-lists [5].", "startOffset": 133, "endOffset": 136}, {"referenceID": 6, "context": "In a previous paper [8] we presented a specialised binary constraint (SM2) for the stable marriage problem, and presented some results comparing the SM2 constraint with the two constraint encoding in [3].", "startOffset": 20, "endOffset": 23}, {"referenceID": 1, "context": "In a previous paper [8] we presented a specialised binary constraint (SM2) for the stable marriage problem, and presented some results comparing the SM2 constraint with the two constraint encoding in [3].", "startOffset": 200, "endOffset": 203}, {"referenceID": 1, "context": "The other model shown in the results table is the optimal boolean encoding (Bool) as presented in [3].", "startOffset": 98, "endOffset": 101}, {"referenceID": 3, "context": "The sex equal stable marriage problem (SESMP) as posed in [5] as an open problem, is essentially an optimisation problem.", "startOffset": 58, "endOffset": 61}, {"referenceID": 4, "context": "This problem has been proven to be NP-Hard [6].", "startOffset": 43, "endOffset": 46}, {"referenceID": 6, "context": "These results can be compared to those in Figure 6 of [8], where the Bool encoding failed to model problems with 300 or more men and women, and at n = 1000 the SM2 model was more than 15 times slower than the SM2N model.", "startOffset": 54, "endOffset": 57}, {"referenceID": 1, "context": "Although this is theoretically equal to the optimal O(n) complexity of the Boolean encoding in [3], our constraint is more practical, typically being able to solve larger problems faster.", "startOffset": 95, "endOffset": 98}, {"referenceID": 2, "context": "For example, we have been able to enumerate all solutions to instances of size 2000 in seconds, whereas in [4] the largest problems investigated were of size 60.", "startOffset": 107, "endOffset": 110}], "year": 2013, "abstractText": "We present an n-ary constraint for the stable marriage problem. This constraint acts between two sets of integer variables where the domains of those variables represent preferences. Our constraint enforces stability and disallows bigamy. For a stable marriage instance with n men and n women we require only one of these constraints, and the complexity of enforcing arc-consistency is O(n) which is optimal in the size of input. Our computational studies show that our n-ary constraint is significantly faster and more space efficient than the encodings presented in [3]. We also introduce a new problem to the constraint community, the sexequal stable marriage problem.", "creator": "LaTeX with hyperref package"}}}