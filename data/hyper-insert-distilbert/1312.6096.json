{"id": "1312.6096", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "Properties of Answer Set Programming with Convex Generalized Atoms", "abstract": "in recent years, combining answer set procedure programming ( asp ), logic object programming also under the new stable lattice model or answer set semantics, has practically seen exactly several potential extensions by initially generalizing the complex notion of presenting an internal atom in these programs : be it complex aggregate atoms, hex lattice atoms, generalized quantifiers, or even abstract algebra constraints, the idea is to have more complicated dynamic satisfaction patterns in the lattice system of jc herbrand interpretations than traditional, simple construct atoms. in this main paper we refer to any of these constructs as simple generalized atoms. several arbitrary semantics with many differing characteristics have been proposed for achieving these extensions, rendering using the experimental big picture taxonomy somewhat blurry. in getting this paper, therefore we analyze the peculiar class logic of fuzzy programs that have weakly convex generalized empirical atoms ( originally incorrectly proposed outright by liu and truszczynski stated in [ pages 10 ] ) in rule bodies and tests show that for this evolving class many characteristics of the others proposed procedural semantics coincide. this is usually an interesting result, since recently enough it has been been shown that this unique class is establishing the additional precise lattice complexity processing boundary for performing the classical flp analytical semantics. indeed we additionally investigate whether similar results also together hold similarities for other abstract semantics, and do discuss the implications of our findings.", "histories": [["v1", "Fri, 20 Dec 2013 20:18:04 GMT  (16kb,D)", "http://arxiv.org/abs/1312.6096v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["mario alviano", "wolfgang faber"], "accepted": false, "id": "1312.6096"}, "pdf": {"name": "1312.6096.pdf", "metadata": {"source": "CRF", "title": "Properties of Answer Set Programming with Convex Generalized Atoms", "authors": ["Mario Alviano", "Wolfgang Faber"], "emails": ["alviano@mat.unical.it", "faber@mat.unical.it"], "sections": [{"heading": "1 Introduction", "text": "Various extensions of the basic Answer Set Programming language have been proposed by allowing more general atoms in rule bodies, for example aggregate atoms, HEX atoms, dl-atoms, generalized quantifiers, or abstract constraints. A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17]. All of these semantics coincide with traditional ASP semantics when no generalized atoms are present. Moreover, they coincide on programs that have atomic rule heads and contain only monotonic generalized atoms. In [9] it is furthermore hinted that the semantics also coincide on programs that have atomic rule heads and contain only convex generalized atoms. However, no formal proof is available for this claim, and the informal explanation given in [9] is not as general as it could be, as we will show.\nIn this paper, we undertake a deeper investigation on the similarities and differences between the FLP and PSP semantics. In order to do this, we consider a simplified, yet expressive propositional language: sets of rules with atomic heads and bodies that are formed of a single \u201cstructure,\u201d which are functions mapping interpretations to Boolean values1. Clearly, structures encompass atoms, literals, and conjunctions thereof, but can\n1 Note that (apart from the name) there is no connection to structures in first-order logic.\nar X\niv :1\n31 2.\n60 96\nv1 [\ncs .A\nI] 2\n0 D\nec 2\nrepresent any propositional formula, generalized atom, or conjunctions of generalized atoms. Each structure has an associated domain, which is the set of propositional atoms on which the structure\u2019s truth valuation depends. We can then classify the structures by their semantic properties, in particular, we will focus on the class of convex structures, which have single contiguous areas of truth in the lattice of interpretations. Convex structures include atoms and literals, and they are closed under conjunction (but not under negation or disjunction).\nWe first formally prove the claim that the FLP and PSP semantics coincide on programs with convex structures, as originally reported in [9]. We will then move on to the main focus of this paper, trying to understand whether there is any larger class for which the semantics coincide. It is known that for programs with general structures all PSP answer sets are FLP answer sets, but not all FLP answer sets are PSP answer sets. The precise boundary for exhibiting the semantic difference is instead unknown.\nWe will approach this question using complexity arguments. Recently, we could show that convex structures form the precise boundary for a complexity jump in the polynomial hierarchy on cautious reasoning (but most other decision problems as well) for the FLP semantics. Cautious reasoning is\u03a0P2 -complete for the FLP semantics when allowing any non-convex structure and its variants (renaming atoms) in the input program, but it is coNP -complete for convex structures. When considering the PSP semantics, cautious reasoning is also \u03a0P2 -complete when allowing any kind of structures in the input. This follows from a result in [13], and we provide an alternative proof in this paper. Analyzing this proof, it becomes clear that there is a different source of complexity for PSP than for FLP.\nWe then show that this different source of complexity also yields a different shape of the boundary for the complexity jump in PSP. Indeed, we first show that for a simple non-convex structure, cautious reasoning is still in coNP for the PSP semantics, while the problem is \u03a0P2 -hard in the presence of this structure for the FLP semantics. It turns out that the same argument works for many non-convex structures, in particular, for all structures with a domain size bounded by a constant. The domain size therefore serves as a parameter that simplifies the complexity of the problem for the PSP semantics (unless the polynomial hierarchy collapses to its first level). This also means that the complexity boundary for PSP has a non-uniform shape, in the sense that an infinite number of different non-convex structures must be available for obtaining\u03a0P2 -hardness for cautious reasoning. This is in contrast to the FLP semantics, where the presence of a single non-convex structure is sufficient."}, {"heading": "2 Syntax and Semantics", "text": "In this section we first introduce the syntax used in the paper. This is mainly based on the notion of structures, i.e., functions mapping interpretations into Boolean truth values. Then, we introduce few semantic notions and in particular we characterize structures in terms of monotonicity. Finally, we define the two semantics analyzed in this paper, namely FLP and PSP."}, {"heading": "2.1 Syntax", "text": "Let U be a fixed, countable set of propositional atoms. An interpretation I is a subset of U . A structure S on U is a mapping of interpretations into Boolean truth values. Each structure S has an associated, finite domain DS \u2282 U , indicating those atoms that are relevant to the structure.\nExample 1. A structure S1 modeling a conjunction a1, . . . , an (n \u2265 0) of propositional atoms is such that DS1 = {a1, . . . , an} and, for every interpretation I , S1 maps I to true if and only if DS1 \u2286 I .\nA structure S2 modeling a conjunction a1, . . . , am, not am+1, . . . , not an (n \u2265 m \u2265 0) of literals, where a1, . . . , an are propositional atoms and not denotes negation as failure, is such that DS2 = {a1, . . . , an} and, for every interpretation I , S2 maps I to true if and only if {a1, . . . , am} \u2286 I and {am+1, . . . , an} \u2229 I = \u2205.\nA structure S3 modeling an aggregate COUNT ({a1, . . . , an}) 6= k (n \u2265 k \u2265 0), where a1, . . . , an are propositional atoms, is such that DS3 = {a1, . . . , an} and, for every interpretation I , S3 maps I to true if and only if |DS3 \u2229 I| 6= k.\nA general rule r is of the following form:\nH(r)\u2190 B(r) (1)\nwhere H(r) is a propositional atom in U referred as the head of r, and B(r) is a structure on U called the body of r. A general program P is a set of general rules.\nExample 2. Let S4 map to true any interpretation I such that I \u2229 {a, b} 6= {b}, and let S5 map to true any interpretation I such that I \u2229 {a, b} 6= {a}. Hence, program P1 = {a\u2190 S4; b\u2190 S5} is equivalent to the following program with aggregates:\na\u2190 SUM ({a = 1, b = \u22121}) \u2265 0 b\u2190 SUM ({a = \u22121, b = 1}) \u2265 0\nNote that no particular assumption is made on the syntax of rule bodies; in the case of normal propositional logic programs these structures are conjunctions of literals. We assume that structures are closed under propositional variants, that is, if S is a structure, for any bijection \u03c3 : U \u2192 U , also S\u03c3 is a structure, and the associated domain is DS\u03c3 = {\u03c3(a) | a \u2208 DS}.\nExample 3. Consider S4 and S5 from Example 2, and a bijection \u03c31 such that \u03c31(a) = b. Hence, S5 = S4\u03c31, that is, S5 is a variant of S4.\nGiven a set of structures S, by datalogS we refer to the class of programs that may contain only the following rule bodies: structures corresponding to conjunctions of atoms, any structure S \u2208 S, or any of its variants S\u03c3.\nExample 4. For every n \u2265 m \u2265 0, let Sm,n denote the structure S2 from Example 1. The class of normal datalog programs is datalog{S m,n|n\u2265m\u22650}.\nNote that this syntax does not explicitly allow for negated structures. One can, however, choose the complementary structure for simulating negation. This would be akin to the \u201cnegation as complement\u201d interpretation of negated aggregates that is prevalent in the literature."}, {"heading": "2.2 Semantics", "text": "Let I \u2286 U be an interpretation. I is a model for a structure S, denoted I |= S, if S maps I to true. Otherwise, if S maps I to false, I is not a model of S, denoted I 6|= S. We require that atoms outside the domain of S are irrelevant for modelhood, that is, for any interpretation I and X \u2286 U \\ DS it holds that I |= S if and only if I \u222a X |= S. Moreover, for any bijection \u03c3 : U \u2192 U , let I\u03c3 = {\u03c3(a) | a \u2208 I}, and we require that I\u03c3 |= S\u03c3 if and only if I |= S. I is a model of a rule r of the form (1), denoted I |= r, if H(r) \u2208 I whenever I |= B(r). I is a model of a program P , denoted I |= P , if I |= r for every rule r \u2208 P .\nExample 5. Consider program P1 from Example 2. It can be observed that \u2205 6|= P1 and {a, b} 6|= P1 (both rules have true bodies but false heads), while {a} |= P1 and {b} |= P1.\nStructures can be characterized in terms of monotonicity as follows.\nDefinition 1 (Monotone Structures). A structure S is monotonic if for all pairs X,Y of interpretations such that X \u2282 Y , X |= S implies Y |= S.\nDefinition 2 (Antimonotone Structures). A structure S is antimonotonic if for all pairs Y, Z of interpretations such that Y \u2282 Z, Z |= S implies Y |= S.\nDefinition 3 (Convex Structures). A structure S is convex if for all triples X,Y, Z of interpretations such that X \u2282 Y \u2282 Z, X |= S and Z |= S implies Y |= S.\nNote that monotonic and antimonotonic structures are convex. Moreover, note that convex structures are closed under conjunction (but not under disjunction or negation).\nExample 6. Structure Sm,n from Example 4 is convex in general; it is monotonic if m = n, and antimonotonic if m = 0. Structure S3 from Example 1, instead, is nonconvex if n > k > 0; it is monotonic if k = 0, and antimonotonic if n = k.\nWe first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].\nDefinition 4 (FLP Reduct). The FLP reduct P I of a program P with respect to I is defined as the set {r \u2208 P | I |= B(r)}.\nDefinition 5 (FLP Answer Sets). I is an FLP answer set of P if I |= P I and for each J \u2282 I it holds that J 6|= P I .\nExample 7. Consider program P1 from Example 2 and the interpretation {a}. The reduct P {a}1 is {a \u2190 S4}. Since {a} is a minimal model of the reduct, {a} is an FLP answer set of P1. Similarly, it can be observed that {b} is another FLP answer set. Actually, these are the only FLP answer sets of the program.\nWe will next describe a different semantics, using the definition of [17], called \u201cfixpoint answer set\u201d in that paper. Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14]. We will refer to it as PSP to abbreviate Pelov/Son/Pontelli, the names most frequently associated with this semantics.\nDefinition 6 (Conditional Satisfaction). A structure S on U is conditionally satisfied by a pair of interpretations (I,M), denoted (I,M) |= S, if J |= S for each J such that I \u2286 J \u2286M .\nDefinition 7 (PSP Answer Sets). An interpretation M is a PSP answer set if M is the least fixpoint of the following operator:\nKPM (I) = {H(r) | r \u2208 P \u2227 (I,M) |= B(r)}. (2)\nExample 8. Consider program P1 from Example 2 and the interpretation {a}. The least fixpoint of KP1{a} is {a}. In fact, \u2205 |= S4 and {a} |= S4, hence (\u2205, {a}) |= S4, while {a} 6|= S5 and thus (\u2205, {a}) 6|= S5 and ({a}, {a}) 6|= S5. Therefore, {a} is a PSP answer set. Also {b} is a PSP answer set.\nOn programs considered in this paper, PSP answer sets also coincide with \u201canswer sets\u201d defined in [18] (by virtue of Proposition 10 in [18]) and \u201cwell-justified FLP answer sets\u201d of [15] (by virtue of Theorem 5 in [15]). The latter is particularly interesting, as it is defined by first forming the FLP reduct. Indeed, as shown in [15], the operator KPM can be equivalently defined as follows:\nKPM (I) = {H(r) | r \u2208 PM \u2227 (I,M) |= B(r)}. (3)\nThere are several other semantic definitions on programs that have some restrictions on the admissible structures, which also coincide with the PSP semantics on programs as defined in this paper with the respective structure restriction. Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).\nIn this paper we are mainly interested in cautious reasoning, defined next.\nDefinition 8 (Cautious Reasoning). A propositional atom a is a cautious consequence of a program P under FLP (resp. PSP) semantics, denoted P |=FLPc a (resp. P |=PSPc a), if a belongs to all FLP (resp. PSP) answer set of P .\nExample 9. Consider program P1 from Example 2. We have P1 6|=FLPc a and P1 6|=FLPc b, and similar for PSP semantics. If we add a\u2190 b and b\u2190 a to the program, then there is only one FLP answer set, namely {a, b}, and no PSP answer sets. In this case a and b are cautious consequences of the program (under both semantics).\n2 There is an even closer relationship, as the operator KPM (I) of [17] coincides with \u03c6aggr,1P (I,M) defined in [13], as shown in the appendix of [17]"}, {"heading": "3 Exploring the Relationship between the FLP and PSP Semantics", "text": "In this section, we examine in detail how the FLP and PSP semantics relate. We shall proceed in three steps. First, we formally prove that FLP and PSP semantics coincide on programs with convex structures in Section 3.1. Next, we turn towards complexity as a tool to understand whether there can be any larger class of coinciding programs. We start in Section 3.2 with a result that shows that programs without restrictions exhibit the same complexity under both FLP and PSP semantics. However, it is known that the semantics do not coincide for programs without restrictions, and we examine the complexity proofs to highlight the different complexity sources. These findings are then applied in Section 3.3 in order to identify programs with bounded non-convex structures, on which the complexities for FLP and PSP semantics differ. Under usual complexity assumptions, this also implies that programs with convex aggregates is the largest class of programs on which FLP and PSP coincide."}, {"heading": "3.1 Unison: Convex Structures", "text": "In this section we show that for programs with convex aggregates the FLP and PSP semantics coincide. In [9] it is stated that many semantics (and in particular, FLP and PSP) \u201cagree on [...] programs with convex aggregates\u201d because \u201cthey can be regarded as special programs with monotone constraints.\u201d However, the comment on regarding convex aggregates as monotone constraints relies on a transformation described in [10] that transforms convex structures into conjunctions of positive and negated monotone constraints. Since our language does not explicitly allow negation, and in particular since convex structures are not closed under negation, we next prove in a more direct manner that the FLP and PSP semantics coincide on convex structures.\nOne direction of the proof relies on the well-known more general fact that each PSP answer set is also an FLP answer set. This has been stated as Theorem 2 in [17] and Proposition 8.1 in [14].\nTheorem 1. Let P be program whose body structures are convex, and let M be an interpretation. M is an FLP answer set of P if and only if M is an PSP answer set of P .\nProof. The left implication follows from Theorem 2 in [17]. For the right implication, let M be an FLP answer set of P . Let K0 := \u2205, Ki+1 := KPM (Ki) for i \u2265 0, and let K be the fixpoint of this sequence. Since M is a minimal model of PM by definition of FLP answer set, we can prove the claim by showing (i) K |= PM and (ii) K \u2286M .\n(i) Consider a rule r \u2208 PM such that K |= B(r). We have to show H(r) \u2208 K. Since r \u2208 PM , M |= B(r) holds. Thus, (K,M) |= B(r) and therefore H(r) \u2208 K.\n(ii) We prove Ki \u2286 M for each i \u2265 0. We use induction on i. The base case is trivially true as K0 = \u2205 \u2286 M . Suppose Ki \u2286 M for some i \u2265 0 in order to prove Ki+1 \u2286 M . By definition of KPM , for each a \u2208 Ki+1 there is r \u2208 PM such that H(r) = a and (Ki,M) |= B(r). Thus, M |= B(r), which implies a \u2208M . ut\nTherefore, programs with convex structures form a class of programs for which the FLP and PSP semantics coincide. In the following, we will show that it is likely also the largest class for which this holds."}, {"heading": "3.2 Consonance: Complexity of Unrestricted Structures", "text": "In this section we will examine the computational impact of allowing non-convex structures. We will limit ourselves to structures for which the truth value with respect to an interpretation can be determined in polynomial time. Moreover, we will focus on cautious reasoning, but similar considerations apply also to related problems such as brave reasoning, answer set existence, or answer set checking.\nIt is known that cautious reasoning over programs with arbitrary structures under the FLP semantics is \u03a0P2 -complete in general, as shown in [7]. Pelov has shown \u03a3 P 2 - completeness for deciding the existence of PSP answer sets in [13], from which \u03a0P2 - completeness for cautious reasoning under the PSP semantics can be derived. We formally state this result now and provide a different proof than Pelov\u2019s that will more directly lead to the subsequent considerations.\nTheorem 2. Cautious reasoning under PSP semantics is \u03a0P2 -complete.\nProof. Membership follows by Corollary 1 of [17]. For the hardness, we provide a reduction from 2-QBF\u2200. Let \u03a8 = \u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u2203y1 \u00b7 \u00b7 \u00b7 \u2203yn E, where E is in 3CNF. Formula \u03a8 is equivalent to \u00ac\u03a8 \u2032, where \u03a8 \u2032 = \u2203x1 \u00b7 \u00b7 \u00b7 \u2203xm\u2200y1 \u00b7 \u00b7 \u00b7 \u2200yn E\u2032, and E\u2032 is a 3DNF equivalent to \u00acE and obtained by applying De Morgan\u2019s laws. To prove the claim we construct a program P\u03a8 such that P\u03a8 |=PSPc w (w a fresh atom) if and only if \u03a8 is valid, i.e., iff \u03a8 \u2032 is invalid.\nLet E\u2032 = (l1,1 \u2227 l1,2 \u2227 l1,3)\u2228 \u00b7 \u00b7 \u00b7 \u2228 (lk,1 \u2227 lk,2 \u2227 lk,3), for some k \u2265 1. Program P\u03a8 is the following:\nxTi \u2190 not xFi xFi \u2190 not xTi i \u2208 {1, . . . ,m} (4) yTi \u2190 not yFi yFi \u2190 not yTi i \u2208 {1, . . . , n} (5) yTi \u2190 sat yFi \u2190 sat i \u2208 {1, . . . , n} (6) sat \u2190 \u00b5(E\u2032) (7) w \u2190 not sat (8)\nwhere \u00b5 is defined recursively as follows:\n\u2013 \u00b5(E\u2032) := (\u00b5(l1,1) \u2227 \u00b5(l1,2) \u2227 \u00b5(l1,3)) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (\u00b5(lk,1) \u2227 \u00b5(lk,2) \u2227 \u00b5(lk,3)); \u2013 \u00b5(xi) := xTi and \u00b5(\u00ac xi) := xFi for all i = 1, . . . ,m; \u2013 \u00b5(yi) := yTi and \u00b5(\u00ac yi) := yFi for all i = 1, . . . , n.\nNote that structure \u00b5(E\u2032) can also be encoded by means of a sum aggregate as shown in [1].\nRules (4)\u2013(5) force each PSP answer set of P\u03a8 to contain at least one of xTi , x F i (i \u2208 {1, . . . ,m}), and one of yTj , yFj (j \u2208 {1, . . . ,m}), respectively, encoding an assignment of the propositional variables in \u03a8 \u2032. Rules (6) are used to simulate universality of the y variables, as described later. Having an assignment, rule (7) derives sat if the assignment satisfies some disjunct of E\u2032 (and hence also E\u2032 itself). Finally, rule (8) derives w if sat is false.\nWe first show that \u03a8 not valid implies P\u03a8 6|=PSPc w. If \u03a8 is not valid, \u03a8 \u2032 is valid. Hence, there is an assignment \u03bd for x1, . . . , xm such that no extension to y1, . . . , yn satisfiesE, i.e., all these extensions satisfyE\u2032. Let us consider the following interpretation\n(which is also a model of P\u03a8 ):\nM = {xTi | \u03bd(xi) = 1, i = 1, . . . ,m} \u222a {xFi | \u03bd(xi) = 0, i = 1, . . . ,m} \u222a {yTi , yFi | i = 1, . . . , n} \u222a {sat}\nWe claim that M is a PSP answer set of P\u03a8 . In fact, KP\u03a8M (\u2205) \u2287 {xTi | \u03bd(xi) = 1, i = 1, . . . ,m} \u222a {xFi | \u03bd(xi) = 0, i = 1, . . . ,m} because of rules (4) in PM\u03a8 . Since any assignment for the ys satisfies at least a disjunct of E\u2032, from rule (7) we derive sat \u2208 KP\u03a8M (K P\u03a8 M (\u2205)). Hence, rules (6) force all y atoms to belong to K P\u03a8 M (K P\u03a8 M (K P\u03a8 M (\u2205))), which is thus the least fixpoint of KP\u03a8M and coincides with M . Now we show that P\u03a8 6|=PSPc w implies that \u03a8 is not valid. To this end, let M be a PSP answer set of P\u03a8 such that w /\u2208 M . Hence, by rule (8) we have that M |= sat . From sat \u2208 M and rules (6), we have yTi , yFi \u2208 M for all i = 1, . . . , n. And M contains either xTi or x F i for i = 1, . . . ,m because of rules (4). Suppose by contradiction that \u03a8 is valid. Thus, for all assignments of x1, . . . , xm, there is an assignment for y1, . . . , yn such that E is true, i.e., E\u2032 is false. We can show that the least fixpoint of KP\u03a8M is K P\u03a8 M (\u2205) = {xTi | \u03bd(xi) = 1, i = 1, . . . ,m} \u222a {xFi | \u03bd(xi) = 0, i = 1, . . . ,m}. In fact, sat cannot be derived because KP\u03a8M (\u2205) 6|= \u00b5(E\u2032). We thus have a contradiction with the assumption that M is a PSP answer set of P\u03a8 . ut\nIt is also known that the complexity drops to coNP if structures in body rules are constrained to be convex. This appears to be \u201cfolklore\u201d knowledge and can be argued to follow from results in [10]. An easy way to see membership in coNP is that all convex structures can be decomposed into a conjunction of a monotonic and an antimonotonic structure, for which membership in coNP has been shown in [7].\nIt is instructive to note a crucial difference between the \u03a0P2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the \u03a3P2 result for PSP in [13].\nThe fundamental tool in the FLP hardness proofs is the availability of structures S1, S2 that allow for encoding \u201cneed to have either atom xT or xF , or both of them, but the latter only upon forcing the truth of both atoms.\u201d S1, S2 have domains DS1 = DS2 = {xT , xF } and the following satisfaction patterns:\n\u2205 |= S1 {xT } |= S1 {xF } 6|= S1 {xT , xF } |= S1 \u2205 |= S2 {xT } 6|= S2 {xF } |= S2 {xT , xF } |= S2\nThe reductions then use these structures in a similar way than disjunction is used in the classic \u03a3P2 -hardness proofs in [3]. In particular, the same structures are used for all instances to be reduced.\nOn the other hand, in the PSP hardness proofs, one dedicated structure is used for each instance of the problem reduced from (2QBF in Theorem 2). Indeed, a construction using structures S1, S2 as described earlier is not feasible for PSP, because (\u2205, {xT , xF }) 6|= S1 and (\u2205, {xT , xF }) 6|= S2. This is because there is one satisfaction \u201chole\u201d between \u2205 and {xT , xF } for both S1 and S2. In the next section, we will exploit this difference."}, {"heading": "3.3 Dissonance: Complexity of Non-convex Structures with Bounded Domains", "text": "In this section, we look more carefully at programs with non-convex structures and identify computational differences between the FLP and PSP semantics. In [2] it has been shown that any non-convex structure (plus all of its variants) can be used in order to implement S1 and S2. This result makes it clear that the presence of any non-convex structure that is closed under variants causes a complexity increase for the FLP semantics (unless the polynomial hierarchy collapses). From the above considerations, it is immediately clear that the same construction is not feasible for PSP. It turns out that also no alternative way exists to obtain a similar result, and that the difference in the \u03a0P2 -hardness proofs for FLP and PSP is intrinsic.\nWe start by considering a simple non-convex structure A\u030a with DA\u030a = {x, y} and I |= A\u030a if and only if |I \u2229 DA\u030a| 6= 1. Therefore, A\u030a behaves like a cardinality constraint COUNT ({x, y}) 6= 1.\nProposition 1. Deciding whether an interpretationM is a PSP answer set of a datalog{A\u030a} program P is feasible in polynomial time, in particular DTIME(m2), where m is the number of rules in P .\nProof. For any interpretation, testing whether (I,M) |= A\u030a\u03c3 (for a variant A\u030a\u03c3 of A\u030a) can be done by examining |I \u2229DA\u030a\u03c3| = i and |M \u2229DA\u030a\u03c3| = j and returning false if either one of i, j is 1, or if i = 0 and j = 2. Alternatively, in a less syntax dependent way, one can test whether M |= A\u030a\u03c3 and (I \u222a J) |= A\u030a\u03c3 for each J \u2286 (M \u2229DA\u030a\u03c3) \\ (I \u2229DA\u030a\u03c3). Since there are at most 4 different J for each I , either method is feasible in constant time.\nFor determining whether M is a PSP answer set of P , we can check whether it is the least fixpoint of KPM . Computing the least fixpoint takes at most m applications of KPM (where m is the number of rules in P ). Each application of K P M involves in turn at most m tests for (I,M) |= A\u030a\u03c3. ut\nGiven Proposition 1 it follows that cautious reasoning is still in coNP for datalog{A\u030a}\nprograms under the PSP semantics.\nProposition 2. Given a datalog{A\u030a} program P and an atom a, deciding P |=PSPc a is in coNP .\nProof. The complement has an immediate nondeterministic polynomial time algorithm: guess an interpretation M and verify in polynomial time that a 6\u2208 M and that M is a PSP answer set of P (by virtue of Proposition 1). ut\nIt follows that for datalog{A\u030a} cautious reasoning (and also answer set existence and brave reasoning) is more complex for the FLP semantics than for the PSP semantics (unless the polynomial hierarchy collapses to its first level).\nExamining this result and its proof carefully, we can see that it depends on the fact that each DA\u030a\u03c3 contains 2 elements and therefore at most 4 satisfaction tests are needed to determine (I,M) |= A\u030a\u03c3. Indeed, we can apply similar reasoning whenever the domains of involved structures are smaller than a given bound.\nTheorem 3. Let P be a program. If k is an upper bound for the domain size of any structure occurring in P , then checking whether a given interpretation M is a PSP answer set of P is decidable in DTIME(2km2p(n)), where m is the number of rules in P and p(n) is the polynomial function (in terms of the input size n) bounding determining satisfaction of any aggregate in P .\nProof. We show that the least fixpoint of KPM can be computed in time O(2 km2p(n)). In the worst case, each application of the operator derives at most one new atom, and thus the fixpoint is reached after at mostm applications of the operator. Each application requires at most the evaluation of all rules of P , and thus at most m2 rule evaluations are sufficient. To evaluate a rule, the truth of the body has to be checked w.r.t. at most 2k interpretations (similar to Proposition 1, in which k = 2), each requiring p(n) time. We thus obtain the bound O(2km2p(n)). ut\nThis means that actually most languages with non-convex structures exhibit a complexity gap between the FLP and PSP semantics. There is a uniformity issue here, which we informally noted earlier when examining the \u03a0P2 -hardness proof for cautious reasoning under PSP. We can now formalize this, as it follows from Theorem 3 that we need an infinite number of inherently different non-convex structures in order to obtain \u03a0P2 hardness.\nCorollary 1. Let S be any finite set of structures, possibly including non-convex structures. Cautious reasoning over datalogS is in coNP under the PSP semantics.\nThis means that there is also a clear difference in uniformity between the complexity boundary of the FLP and the PSP semantics, respectively. It also means that it is impossible to simulate the FLP semantics in a compact way using the PSP semantics on the class of programs with bounded domain structures, unless the polynomial hierarchy collapses to its first level. The general picture of our complexity results is shown in Figure 1. We can see that the complexity transition from coNP to \u03a0P2 is different for the FLP and PSP semantics, respectively. The solid line between convex and non-convex structures denotes a crisp transition for FLP, while the dashed line between bounded non-convex and unbounded non-convex structures is a rougher transition."}, {"heading": "4 Discussion", "text": "Looking at Figure 1, the transition from coNP to \u03a0P2 appears somewhat irregular for PSP, as the availability of single non-convex structures does not cause the transition, but only their union. However, in practice the availability of an infinite number of different structures is not unusual: indeed, if aggregates are considered, the presence of one aggregate function and suitable comparison relations usually gives rise to such an infinite repertoire of structures.\nExample 10. Consider the availability of COUNT over any set of atoms and the comparison relation 6=. The structures generated by aggregates of the form COUNT (S) 6= i do not have a bound on the domains of non-convex aggregates. Indeed, for any structure COUNT ({a1, . . . , ak}) 6= 1, which is non-convex and for which the domain size is k,\none can formulate also COUNT ({a1, . . . , ak+1}) 6= 1, which is also non-convex and has a larger domain.\nHowever, as noted earlier, for expressing \u03a0P2 -hard problems, one needs a nonuniform approach for PSP, in the sense that a dedicated aggregate has to be formulated for each problem instance, whereas for FLP one can re-use the same aggregates for all problem instances.\nIn practical terms, our results imply that for programs containing only convex structures, techniques as those presented in [1] for FLP can be used for computing answer sets also for PSP, and techniques presented for PSP can be used for FLP in turn. It also means that this is the largest class for which this can be done with currently available methods in an efficient way. There are several examples for convex structures that are easy to identify syntactically: count aggregates with equality guards, sum aggregates with positive summands and equality guards, dl-atoms that do not involve \u2229\u2212 and rely on a tractable Description Logic [4]. However many others are in general not convex, for example sum aggregates that involve both positive and negative summands, times aggregates that involve the factor 0, average aggregates, dl-atoms with\u2229\u2212, and so on. It is still possible to find special cases of such structures that are convex, but that requires deeper analyses.\nThe results also immediately imply impossibility and possibility results for rewritability: unless the polynomial hierarchy collapses to its first level, it is not possible in the FLP semantics to rewrite a program with non-convex structures into one containing only convex structures (for example, a program not containing any generalized atoms), unless disjunction or similar constructs are allowed in rule heads. On the other hand, such rewritings are possible for the PSP semantics if the non-convex structures are guaranteed to have bounded domains. This seems to be most important for dl-programs, where such rewritings are sought after.\nThe semantics considered in this paper encompass several approaches suggested for programs that couple answer set programming with description logics. The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]\nis shown to be equivalent to the PSP semantics. There are other proposals, such as [4], which appears to be different from both FLP and PSP already on convex structure. In future work we plan to relate also these other semantics with FLP and PSP and attempt to identify the largest coinciding classes of programs."}], "references": [{"title": "Unfounded Sets and Well-Founded Semantics of Answer Set Programs with Aggregates", "author": ["M. Alviano", "F. Calimeri", "W. Faber", "N. Leone", "S. Perri"], "venue": "Journal of Artificial Intelligence Research 42, 487\u2013527", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "The complexity boundary of answer set programming with generalized atoms under the flp semantics", "author": ["M. Alviano", "W. Faber"], "venue": "Cabalar, P., Tran, S.C. (eds.) Logic Programming and Nonmonotonic Reasoning \u2014 12th International Conference", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "On the Computational Cost of Disjunctive Logic Programming: Propositional Case", "author": ["T. Eiter", "G. Gottlob"], "venue": "Annals of Mathematics and Artificial Intelligence 15(3/4), 289\u2013323", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1995}, {"title": "Combining answer set programming with description logics for the semantic web", "author": ["T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits"], "venue": "Artif. Intell. 172(12\u201313), 1495\u2013 1539", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer Set Programming", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "International Joint Conference on Artificial Intelligence (IJCAI) 2005. pp. 90\u201396. Edinburgh, UK", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2005}, {"title": "Recursive aggregates in disjunctive logic programs: Semantics and complexity", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Alferes, J.J., Leite, J. (eds.) Proceedings of the 9th European Conference on Artificial Intelligence (JELIA 2004). Lecture Notes in AI (LNAI), vol. 3229, pp. 200\u2013212. Springer Verlag", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2004}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Artificial Intelligence 175(1),", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "Answer Sets for Propositional Theories", "author": ["P. Ferraris"], "venue": "Baral, C., Greco, G., Leone, N., Terracina, G. (eds.) Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference, LPNMR\u201905, Diamante, Italy, September 2005, Proceedings. Lecture Notes in Computer Science, vol. 3662, pp. 119\u2013131. Springer Verlag", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Logic programs with abstract constraint atoms: The role of computations", "author": ["L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczy\u0144ski"], "venue": "Artificial Intelligence 174(3\u20134), 295\u2013315", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Properties and applications of programs with monotone and convex constraints", "author": ["L. Liu", "M. Truszczy\u0144ski"], "venue": "Journal of Artificial Intelligence Research 27, 299\u2013334", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2006}, {"title": "A novel combination of answer set programming with description logics for the semantic web", "author": ["T. Lukasiewicz"], "venue": "IEEE Transactions on Knowledge and Data Engineering 22(11), 1577\u2013 1592", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "Logic Programming with Monotone Cardinality Atom", "author": ["V.W. Marek", "I. Niemel\u00e4", "M. Truszczy\u0144ski"], "venue": "Lifschitz, V., Niemel\u00e4, I. (eds.) Proceedings of the 7th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-7). LNAI, vol. 2923, pp. 154\u2013166. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Semantics of Logic Programs with Aggregates", "author": ["N. Pelov"], "venue": "Ph.D. thesis, Katholieke Universiteit Leuven, Leuven, Belgium", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2004}, {"title": "Well-founded and Stable Semantics of Logic Programs with Aggregates", "author": ["N. Pelov", "M. Denecker", "M. Bruynooghe"], "venue": "Theory and Practice of Logic Programming 7(3), 301\u2013353", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "FLP semantics without circular justifications for general logic programs", "author": ["Y.D. Shen", "K. Wang"], "venue": "Hoffmann, J., Selman, B. (eds.) Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI-12)", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artificial Intelligence 138, 181\u2013234", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2002}, {"title": "A Constructive Semantic Characterization of Aggregates in ASP", "author": ["T.C. Son", "E. Pontelli"], "venue": "Theory and Practice of Logic Programming 7, 355\u2013375", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2007}, {"title": "Answer Sets for Logic Programs with Arbitrary Abstract Constraint Atoms", "author": ["T.C. Son", "E. Pontelli", "P.H. Tu"], "venue": "Journal of Artificial Intelligence Research 29, 353\u2013389", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}], "referenceMentions": [{"referenceID": 9, "context": "In this paper, we analyze the class of programs that have convex generalized atoms (originally proposed by Liu and Truszczy\u0144ski in [10]) in rule bodies and show that for this class many of the proposed semantics coincide.", "startOffset": 131, "endOffset": 135}, {"referenceID": 6, "context": "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].", "startOffset": 91, "endOffset": 94}, {"referenceID": 12, "context": "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].", "startOffset": 216, "endOffset": 223}, {"referenceID": 16, "context": "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].", "startOffset": 216, "endOffset": 223}, {"referenceID": 8, "context": "In [9] it is furthermore hinted that the semantics also coincide on programs that have atomic rule heads and contain only convex generalized atoms.", "startOffset": 3, "endOffset": 6}, {"referenceID": 8, "context": "However, no formal proof is available for this claim, and the informal explanation given in [9] is not as general as it could be, as we will show.", "startOffset": 92, "endOffset": 95}, {"referenceID": 8, "context": "We first formally prove the claim that the FLP and PSP semantics coincide on programs with convex structures, as originally reported in [9].", "startOffset": 136, "endOffset": 139}, {"referenceID": 12, "context": "This follows from a result in [13], and we provide an alternative proof in this paper.", "startOffset": 30, "endOffset": 34}, {"referenceID": 5, "context": "We first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].", "startOffset": 113, "endOffset": 118}, {"referenceID": 6, "context": "We first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].", "startOffset": 113, "endOffset": 118}, {"referenceID": 16, "context": "We will next describe a different semantics, using the definition of [17], called \u201cfixpoint answer set\u201d in that paper.", "startOffset": 69, "endOffset": 73}, {"referenceID": 16, "context": "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].", "startOffset": 13, "endOffset": 17}, {"referenceID": 12, "context": "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].", "startOffset": 134, "endOffset": 138}, {"referenceID": 13, "context": "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].", "startOffset": 230, "endOffset": 234}, {"referenceID": 17, "context": "On programs considered in this paper, PSP answer sets also coincide with \u201canswer sets\u201d defined in [18] (by virtue of Proposition 10 in [18]) and \u201cwell-justified FLP answer sets\u201d of [15] (by virtue of Theorem 5 in [15]).", "startOffset": 98, "endOffset": 102}, {"referenceID": 17, "context": "On programs considered in this paper, PSP answer sets also coincide with \u201canswer sets\u201d defined in [18] (by virtue of Proposition 10 in [18]) and \u201cwell-justified FLP answer sets\u201d of [15] (by virtue of Theorem 5 in [15]).", "startOffset": 135, "endOffset": 139}, {"referenceID": 14, "context": "On programs considered in this paper, PSP answer sets also coincide with \u201canswer sets\u201d defined in [18] (by virtue of Proposition 10 in [18]) and \u201cwell-justified FLP answer sets\u201d of [15] (by virtue of Theorem 5 in [15]).", "startOffset": 181, "endOffset": 185}, {"referenceID": 14, "context": "On programs considered in this paper, PSP answer sets also coincide with \u201canswer sets\u201d defined in [18] (by virtue of Proposition 10 in [18]) and \u201cwell-justified FLP answer sets\u201d of [15] (by virtue of Theorem 5 in [15]).", "startOffset": 213, "endOffset": 217}, {"referenceID": 14, "context": "Indeed, as shown in [15], the operator K M can be equivalently defined as follows:", "startOffset": 20, "endOffset": 24}, {"referenceID": 11, "context": "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).", "startOffset": 13, "endOffset": 17}, {"referenceID": 15, "context": "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).", "startOffset": 108, "endOffset": 112}, {"referenceID": 12, "context": "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).", "startOffset": 241, "endOffset": 245}, {"referenceID": 16, "context": "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with \u03c6 P (I,M) defined in [13], as shown in the appendix of [17]", "startOffset": 67, "endOffset": 71}, {"referenceID": 12, "context": "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with \u03c6 P (I,M) defined in [13], as shown in the appendix of [17]", "startOffset": 108, "endOffset": 112}, {"referenceID": 16, "context": "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with \u03c6 P (I,M) defined in [13], as shown in the appendix of [17]", "startOffset": 142, "endOffset": 146}, {"referenceID": 8, "context": "In [9] it is stated that many semantics (and in particular, FLP and PSP) \u201cagree on [.", "startOffset": 3, "endOffset": 6}, {"referenceID": 9, "context": "\u201d However, the comment on regarding convex aggregates as monotone constraints relies on a transformation described in [10] that transforms convex structures into conjunctions of positive and negated monotone constraints.", "startOffset": 118, "endOffset": 122}, {"referenceID": 16, "context": "This has been stated as Theorem 2 in [17] and Proposition 8.", "startOffset": 37, "endOffset": 41}, {"referenceID": 13, "context": "1 in [14].", "startOffset": 5, "endOffset": 9}, {"referenceID": 16, "context": "The left implication follows from Theorem 2 in [17].", "startOffset": 47, "endOffset": 51}, {"referenceID": 6, "context": "It is known that cautious reasoning over programs with arbitrary structures under the FLP semantics is \u03a0 2 -complete in general, as shown in [7].", "startOffset": 141, "endOffset": 144}, {"referenceID": 12, "context": "Pelov has shown \u03a3 P 2 completeness for deciding the existence of PSP answer sets in [13], from which \u03a0 2 completeness for cautious reasoning under the PSP semantics can be derived.", "startOffset": 84, "endOffset": 88}, {"referenceID": 16, "context": "Membership follows by Corollary 1 of [17].", "startOffset": 37, "endOffset": 41}, {"referenceID": 0, "context": "Note that structure \u03bc(E\u2032) can also be encoded by means of a sum aggregate as shown in [1].", "startOffset": 86, "endOffset": 89}, {"referenceID": 9, "context": "This appears to be \u201cfolklore\u201d knowledge and can be argued to follow from results in [10].", "startOffset": 84, "endOffset": 88}, {"referenceID": 6, "context": "An easy way to see membership in coNP is that all convex structures can be decomposed into a conjunction of a monotonic and an antimonotonic structure, for which membership in coNP has been shown in [7].", "startOffset": 199, "endOffset": 202}, {"referenceID": 6, "context": "It is instructive to note a crucial difference between the \u03a0 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the \u03a3 2 result for PSP in [13].", "startOffset": 83, "endOffset": 86}, {"referenceID": 7, "context": "It is instructive to note a crucial difference between the \u03a0 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the \u03a3 2 result for PSP in [13].", "startOffset": 109, "endOffset": 112}, {"referenceID": 12, "context": "It is instructive to note a crucial difference between the \u03a0 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the \u03a3 2 result for PSP in [13].", "startOffset": 173, "endOffset": 177}, {"referenceID": 2, "context": "The reductions then use these structures in a similar way than disjunction is used in the classic \u03a3 2 -hardness proofs in [3].", "startOffset": 122, "endOffset": 125}, {"referenceID": 1, "context": "In [2] it has been shown that any non-convex structure (plus all of its variants) can be used in order to implement S1 and S2.", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "In practical terms, our results imply that for programs containing only convex structures, techniques as those presented in [1] for FLP can be used for computing answer sets also for PSP, and techniques presented for PSP can be used for FLP in turn.", "startOffset": 124, "endOffset": 127}, {"referenceID": 3, "context": "There are several examples for convex structures that are easy to identify syntactically: count aggregates with equality guards, sum aggregates with positive summands and equality guards, dl-atoms that do not involve \u2229\u2212 and rely on a tractable Description Logic [4].", "startOffset": 262, "endOffset": 265}, {"referenceID": 4, "context": "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]", "startOffset": 28, "endOffset": 31}, {"referenceID": 10, "context": "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]", "startOffset": 36, "endOffset": 40}, {"referenceID": 14, "context": "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]", "startOffset": 98, "endOffset": 102}, {"referenceID": 3, "context": "There are other proposals, such as [4], which appears to be different from both FLP and PSP already on convex structure.", "startOffset": 35, "endOffset": 38}], "year": 2013, "abstractText": "In recent years, Answer Set Programming (ASP), logic programming under the stable model or answer set semantics, has seen several extensions by generalizing the notion of an atom in these programs: be it aggregate atoms, HEX atoms, generalized quantifiers, or abstract constraints, the idea is to have more complicated satisfaction patterns in the lattice of Herbrand interpretations than traditional, simple atoms. In this paper we refer to any of these constructs as generalized atoms. Several semantics with differing characteristics have been proposed for these extensions, rendering the big picture somewhat blurry. In this paper, we analyze the class of programs that have convex generalized atoms (originally proposed by Liu and Truszczy\u0144ski in [10]) in rule bodies and show that for this class many of the proposed semantics coincide. This is an interesting result, since recently it has been shown that this class is the precise complexity boundary for the FLP semantics. We investigate whether similar results also hold for other semantics, and discuss the implications of our findings.", "creator": "LaTeX with hyperref package"}}}