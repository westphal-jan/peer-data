{"id": "1312.6130", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "A Functional View of Strong Negation in Answer Set Programming", "abstract": "nonetheless the crucial distinction between basic strong negation and default negation has been primarily useful critically in answer tight set programming. we present an alternative account of strong mood negation, which lets than us essentially view strong negation in sensible terms of the functional stable model semantics by bartholomew and lee. quite more specifically, firstly we show us that, under complete standard interpretations, potentially minimizing both positive and low negative function literals embedded in the traditional secure answer set semantics is essentially physically the same as ensuring the uniqueness required of primitive boolean function data values under the functional stable model formal semantics. the same account lets yet us view alexander lifschitz's dual two - valued logic programs as a valid special exceptional case of the functional still stable model scenario semantics. in addition, we moreover show how non - compliant boolean intensional truth functions each can theoretically be eliminated in default favor of boolean intensional functions, languages and semantics furthermore can hence be still represented using strong context negation, specifically which provides a cheaper way to compute safely the functional relatively stable parameter model syntax semantics potentially using existing strong asp solvers. obviously we also note subsequently that that similar derived results hold parallels with realism the functional yet stable set model semantics by cabalar.", "histories": [["v1", "Fri, 20 Dec 2013 21:01:32 GMT  (23kb,D)", "http://arxiv.org/abs/1312.6130v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["michael bartholomew", "joohyung lee"], "accepted": false, "id": "1312.6130"}, "pdf": {"name": "1312.6130.pdf", "metadata": {"source": "CRF", "title": "A Functional View of Strong Negation in Answer Set Programming", "authors": ["Michael Bartholomew", "Joohyung Lee"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "The distinction between default negation and strong negation has been useful in answer set programming. In particular, it yields an elegant solution to the frame problem. The fact that block b stays at the same location l by inertia can be described by the rule\n\u0131On(b, l, t+1) \u2190 \u0131On(b, l, t), \u0131not \u223c\u0131On(b, l, t+1) (1)\nalong with the rule that describes the uniqueness of location values [Lifschitz, 2002],\n\u223c\u0131On(b, l1, t) \u2190 \u0131On(b, l, t), l 6= l1 . (2)\nHere \u2018\u223c\u2019 is the symbol for strong negation that represents explicit falsity while \u2018\u0131not\u2019 is the symbol for default negation (negation as failure). Rule (1) asserts that without explicit evidence to the contrary, block b remains at location l. If we are given explicit conflicting information about the location of b at time t+1 then this conclusion will be defeated by rule (2), which asserts the uniqueness of location values.\nAn alternative representation of inertia, which uses choice rules instead of strong negation, was recently presented by Bartholomew and Lee [2012]. Instead of rule (1), they use the choice rule\n{\u0131On(b, l, t+1)} \u2190 \u0131On(b, l, t) , (3)\nwhich states that \u201cif b is at l at time t, then decide arbitrarily whether to assert that b is at l at time t+1.\u201d Instead of rule (2), they write weaker rules for describing the functional\nar X\niv :1\n31 2.\n61 30\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nproperty of \u0131On:\n\u2190 {\u0131On(b, l, t) : Location(l)}0 (existence of location) (4) \u2190 2{\u0131On(b, l, t) : Location(l)} (uniqueness of location), (5)\nwhich can be also combined into one rule: \u2190 \u0131not 1{\u0131On(b, l, t) : Location(l)}1 . In the absence of additional information about the location of block b at time t+1, asserting \u0131On(b, l, t+1) is the only option, in view of the existence of location constraint (4). But if we are given conflicting information about the location of b at time t+1 then not asserting \u0131On(b, l, t+1) is the only option, in view of the uniqueness of location constraint (5).\nRules (3), (4), and (5) together can be more succinctly represented in the language of [Bartholomew and Lee, 2012] by means of intensional functions. That is, the three rules can be replaced by one rule\n{\u0131Loc(b, t+1) = l} \u2190 \u0131Loc(b, t) = l , (6)\nwhere \u0131Loc is an intensional function constant (the rule reads, \u201cif block b is at location l at time t, by default, the block is at l at time t+1\u201d). In fact, Corollary 2 of [Bartholomew and Lee, 2012] tells us how to eliminate intensional functions in favor of intensional predicates, justifying the equivalence between (6) and the set of rules (3), (4), and (5). The translation allows us to compute the language of [Bartholomew and Lee, 2012] using existing ASP solvers, such as SMODELS and GRINGO. However, DLV cannot be used because it does not accept choice rules. On the other hand, all these solvers accept rules (1) and (2), which contain strong negation.\nThe two representations of inertia involving intensional predicate \u0131On do not result in the same answer sets. In the first representation, which uses strong negation, each answer set contains only one atom of the form \u0131On(b, l, t) for each block b and each time t; for all other locations l\u2032, negative literals \u223c\u0131On(b, l\u2032, t) belong to the answer set. On the other hand, such negative literals do not occur in the answer sets of a program that follows the second representation, which yields fewer ground atoms. This difference can be well explained by the difference between the symmetric and the asymmetric views of predicates that Lifschitz described in his message to Texas Action Group, titled \u201cChoice Rules and the Belief-Based View of ASP\u201d: 1\nThe way I see it, in ASP programs we use predicates of two kinds, let\u2019s call them \u201csymmetric\u201d and \u201casymmetric.\u201d The fact that an object a does not have a property p is reflected by the presence of \u223cp(a) in the answer set if p is \u201csymmetric,\u201d and by the absence of p(a) if p is \u201casymmetric.\u201d In the second case, the strong negation of p is not used in the program at all.\nAccording to these terminologies, predicate \u0131On is symmetric in the first representation, and asymmetric in the second representation.\nThis paper presents several technical results that help us understand the relationship between these two views. In this regard, it helps us to understand strong negation as a way of expressing intensional Boolean functions.\n1 http://www.cs.utexas.edu/users/vl/tag/choice discussion\n\u2013 Our first result provides an alternative account of strong negation in terms of Boolean intensional functions. For instance, (1) can be identified with\n\u0131On(b, l, t+1)= TRUE \u2190 \u0131On(b, l, t)= TRUE \u2227 \u00ac(\u0131On(b, l, t+1)= FALSE) ,\nand (2) can be identified with\n\u0131On(b, l1, t)= FALSE \u2190 \u0131On(b, l, t)= TRUE \u2227 l 6= l1 .\nUnder complete interpretations, we show that minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. In this sense, strong negation can be viewed as a mere disguise of Boolean functions.2 \u2013 We show how non-Boolean intensional functions can be eliminated in favor of Boolean functions. Combined with the result in the first bullet, this tells us a new way of turning the language of [Bartholomew and Lee, 2012] into traditional answer set programs with strong negation, so that system DLV, as well as SMODELS and GRINGO, can be used for computing the language of [Bartholomew and Lee, 2012]. As an example, it tells us how to turn (6) into the set of rules (1) and (2). \u2013 Lifschitz [2012] recently proposed \u201ctwo-valued logic programs,\u201d which modifies the traditional stable model semantics to represent complete information without distinguishing between strong negation and default negation. Using our result that views strong negation in terms of Boolean functions, we show that two-valued logic programs are in fact a special case of the functional stable model semantics in which every function is Boolean.\nWhile the main results are stated for the language of [Bartholomew and Lee, 2012], similar results hold with the language of [Cabalar, 2011] based on the relationship between the two languages studied in [Bartholomew and Lee, 2013]. Furthermore, we note that the complete interpretation assumption in the first bullet can be dropped if we instead refer to the language of [Cabalar, 2011], at the price of introducing partial interpretations.\nThe paper is organized as follows. In Section 2 we review the two versions of the stable model semantics, one that allows strong negation, but is limited to express intensional predicates only, and the other that allows both intensional predicates and intensional functions. As a special case of the latter we also present multi-valued propositional formulas under the stable model semantics. Section 3 shows how strong negation can be viewed in terms of Boolean functions. Section 4 shows how non-Boolean functions can be eliminated in favor of Boolean functions. Section 5 shows how Lifschitz\u2019s two-valued logic programs can be viewed as a special case of the functional stable model semantics. Section 6 shows how strong negation can be represented in the language of [Cabalar, 2011]."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Review: First-Order Stable Model Semantics and Strong Negation", "text": "This review follows [Ferraris et al., 2011]. A signature is defined as in first-order logic, consisting of function constants and predicate constants. Function constants of arity 0\n2 It is also well-known that strong negation can be also viewed in terms of auxiliary predicate constants [Gelfond and Lifschitz, 1991].\nare also called object constants. We assume the following set of primitive propositional connectives and quantifiers:\u22a5 (falsity), \u2227, \u2228, \u2192, \u2200, \u2203. The syntax of a formula is defined as in first-order logic. We understand \u00acF as an abbreviation of F \u2192 \u22a5.\nThe stable models of a sentence F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ;p]. Let u be a list of distinct predicate variables u1, . . . , un of the same length as p. By u = p we denote the conjunction of the formulas \u2200x(ui(x) \u2194 pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u \u2264 p we denote the conjunction of the formulas \u2200x(ui(x)\u2192 pi(x)) for all i = 1, . . . , n, and u < p stands for (u \u2264 p) \u2227 \u00ac(u = p). For any first-order sentence F , expression SM[F ;p] stands for the second-order sentence\nF \u2227 \u00ac\u2203u((u < p) \u2227 F \u2217(u)),\nwhere F \u2217(u) is defined recursively:\n\u2013 pi(t)\u2217 = ui(t) for any list t of terms; \u2013 F \u2217 = F for any atomic formula F (including \u22a5 and equality) that does not contain\nmembers of p; \u2013 (F \u2227G)\u2217 = F \u2217 \u2227G\u2217; (F \u2228G)\u2217 = F \u2217 \u2228G\u2217; \u2013 (F \u2192 G)\u2217 = (F \u2217 \u2192 G\u2217) \u2227 (F \u2192 G); \u2013 (\u2200xF )\u2217 = \u2200xF \u2217; (\u2203xF )\u2217 = \u2203xF \u2217.\nA model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ;p].\nThe traditional stable models of a logic program\u03a0 are identical to the Herbrand stable models of the FOL-representation of \u03a0 (i.e., the conjunction of the universal closures of implications corresponding to the rules).\nFerraris et al. [2011] incorporate strong negation into the stable model semantics by distinguishing between intensional predicates of two kinds, positive and negative. Each negative intensional predicate has the form \u223cp, where p is a positive intensional predicate and \u2018\u223c\u2019 is a symbol for strong negation. In this sense, syntactically \u223c is not a logical connective, as it can appear only as a part of a predicate constant. An interpretation of the underlying signature is coherent if it satisfies the formula \u00ac\u2203x(p(x)\u2227 \u223cp(x)), where x is a list of distinct object variables, for each negative predicate \u223cp. We consider coherent interpretations only.\nExample 1 The following is a representation of the Blocks World in the syntax of logic programs:\n\u22a5 \u2190 \u0131On(b1, b, t), \u0131On(b2, b, t) (b1 6= b2) \u0131On(b, l, t + 1) \u2190 \u0131Move(b, l, t)\n\u22a5 \u2190 \u0131Move(b, l, t), \u0131On(b1, b, t) \u22a5 \u2190 \u0131Move(b, b1, t), \u0131Move(b1, l, t)\n\u0131On(b, l, 0) \u2190 \u0131not \u223c\u0131On(b, l, 0) \u223c\u0131On(b, l, 0) \u2190 \u0131not \u0131On(b, l, 0)\n\u0131Move(b, l, t) \u2190 \u0131not \u223c\u0131Move(b, l, t) \u223c\u0131Move(b, l, t) \u2190 \u0131not \u0131Move(b, l, t) \u0131On(b, l, t + 1) \u2190 \u0131On(b, l, t), \u0131not \u223c\u0131On(b, l, t + 1) \u223c\u0131On(b, l, t) \u2190 \u0131On(b, l1, t) (l 6= l1) .\n(7)\nHere \u0131On and \u0131Move are intensional predicate constants, b, b1, b2 are variables ranging over the blocks, l, l1 are variables ranging over the locations (blocks and the table), and t is a variable ranging over the timepoints. The first rule asserts that at most one block can be on another block. The next three rules describe the effect and preconditions of action \u0131Move. The next four rules describe that fluent \u0131On is initially exogenous, and action \u0131Move is exogenous at each time. The next rule describes inertia, and the last rule asserts that a block can be at most at one location."}, {"heading": "2.2 Review: The Functional Stable Model Semantics", "text": "The functional stable model semantics is defined by modifying the semantics in the previous section to allow \u201cintensional\u201d functions [Bartholomew and Lee, 2012]. For predicate symbols (constants or variables) u and c, we define u \u2264 c as \u2200x(u(x)\u2192 c(x)). We define u = c as \u2200x(u(x)\u2194 c(x)) if u and c are predicate symbols, and \u2200x(u(x) = c(x)) if they are function symbols.\nLet c be a list of distinct predicate and function constants and let c\u0302 be a list of distinct predicate and function variables corresponding to c. We call members of c intensional constants. By cpred we mean the list of the predicate constants in c, and by c\u0302pred the list of the corresponding predicate variables in c\u0302. We define c\u0302 < c as (c\u0302pred \u2264 cpred)\u2227\u00ac(c\u0302 = c) and SM[F ; c] as\nF \u2227 \u00ac\u2203c\u0302(c\u0302 < c \u2227 F \u2217(c\u0302)),\nwhere F \u2217(c\u0302) is defined the same as the one in Section 2.1 except for the base case:\n\u2013 When F is an atomic formula, F \u2217 is F \u2032\u2227F , where F \u2032 is obtained from F by replacing all intensional (function and predicate) constants in it with the corresponding (function and predicate) variables.\nIf c contains predicate constants only, this definition of a stable model reduces to the one in [Ferraris et al., 2011], also reviewed in Section 2.1.\nAccording to [Bartholomew and Lee, 2012], a choice formula {F} is an abbreviation of the formula F \u2228 \u00acF , which is also strongly equivalent to \u00ac\u00acF \u2192 F . A formula {t = t\u2032}, where t contains an intensional function constant and t\u2032 does not, represents that t takes the value t\u2032 by default, as the following example demonstrates.\nExample 2 Let F1 be {f = 1}, which stands for (f = 1) \u2228 \u00ac(f = 1), and I1 be an interpretation such that I1(f) = 1. Let\u2019s assume that we consider only interpretations that map numbers to themselves. I1 is an f -stable model of F1: F \u22171 (f\u0302) is equivalent to ((f\u0302=1)\u2227(f=1))\u2228\u00ac(f=1),3 which is further equivalent to (f\u0302=1) under the assumption I1. It is not possible to satisfy this formula by assigning f\u0302 a different value from I1(f). On the other hand, I2 such that I2(f) = 2 is not f -stable since F \u22171 (f\u0302) is equivalent to > under I2, so that it is possible to satisfy this formula by assigning f\u0302 a different value from I2(f). If we let F2 be {f = 1} \u2227 (f = 2), then I2 is a f -stable of F2, but I1 is not: F \u22172 (f\u0302) is equivalent to f\u0302=2 under I2, so that f\u0302 has to map to 2 as well. This example illustrates the nonmonotonicity of the semantics.\n3 It holds that (\u00acF )\u2217 is equivalent to \u00acF .\nExample 3 The Blocks World can be described in this language as follows. For readability, we write in a logic program like syntax:\n\u22a5 \u2190 \u0131Loc(b1, t)=b \u2227 \u0131Loc(b2, t)=b \u2227 (b1 6= b2) \u0131Loc(b, t+1)= l \u2190 \u0131Move(b, l, t)\n\u22a5 \u2190 \u0131Move(b, l, t) \u2227 \u0131Loc(b1, t)=b \u22a5 \u2190 \u0131Move(b, b1, t) \u2227 \u0131Move(b1, l, t)\n{\u0131Loc(b, 0)= l} {\u0131Move(b, l, t)}\n{\u0131Loc(b, t+1)= l} \u2190 \u0131Loc(b, t)= l .\nHere \u0131Loc is a function constant. The last rule is a default formula that describes the commonsense law of inertia. The stable models of this program are the models of SM[F ; \u0131Loc, \u0131Move], where F is the FOL-representation of the program."}, {"heading": "2.3 Review: Stable Models of Multi-Valued Propositional Formulas", "text": "The following is a review of the stable model semantics of multi-valued propositional formulas from [Bartholomew and Lee, 2012], which can be viewed as a special case of the functional stable model semantics in the previous section.\nThe syntax of multi-valued propositional formulas is given in [Ferraris et al., 2011]. A multi-valued propositional signature is a set \u03c3 of symbols called constants, along with a nonempty finite set \u0131Dom(c) of symbols, disjoint from \u03c3, assigned to each constant c. We call \u0131Dom(c) the domain of c. A Boolean constant is one whose domain is the set {TRUE, FALSE}. An atom of a signature \u03c3 is an expression of the form c=v (\u201cthe value of c is v\u201d) where c \u2208 \u03c3 and v \u2208 \u0131Dom(c). A (multi-valued propositional) formula of \u03c3 is a propositional combination of atoms.\nA (multi-valued propositional) interpretation of \u03c3 is a function that maps every element of \u03c3 to an element of its domain. An interpretation I satisfies an atom c=v (symbolically, I |= c=v) if I(c) = v. The satisfaction relation is extended from atoms to arbitrary formulas according to the usual truth tables for the propositional connectives. I is a model of a formula if it satisfies the formula.\nThe reduct F I of a multi-valued propositional formula F relative to a multi-valued propositional interpretation I is the formula obtained from F by replacing each maximal subformula that is not satisfied by I with \u22a5. Interpretation I is a stable model of F if I is the only interpretation satisfying F I .\nExample 4 Similar to Example 2, consider the signature \u03c3 = {f} such that \u0131Dom(c) = {1, 2, 3}. Let I1 be an interpretation such that I1(c) = 1, and I2 be such that I2(c) = 2. Recall that {f=1} is shorthand for (f=1)\u2228\u00ac(f=1). The reduct of this formula relative to I1 is (f =1) \u2228 \u22a5, and I1 is the only model of the reduct. On the other hand, the reduct of {f = 1} relative to I2 is (\u22a5 \u2228 \u00ac\u22a5) and I2 is not its unique model. Also, the reduct of {f = 1} \u2227 (f = 2) relative to I1 is (\u22a5 \u2228 \u00ac\u22a5) \u2227 \u22a5 and I1 is not a model. The reduct of {f = 1} \u2227 (f = 2) relative to I2 is (\u22a5 \u2228 \u00ac\u22a5) \u2227 (f = 2), and I2 is the only model of the reduct."}, {"heading": "3 Relating Strong Negation to Boolean Functions", "text": ""}, {"heading": "3.1 Representing Strong Negation in Multi-Valued Propositional Formulas", "text": "Given a traditional propositional logic program\u03a0 of a signature \u03c3 [Gelfond and Lifschitz, 1991], we identify \u03c3 with the multi-valued propositional signature whose constants are the\nsame symbols from \u03c3 and every constant is Boolean. By \u03a0mv we mean the multi-valued propositional formula that is obtained from \u03a0 by replacing negative literals of the form \u223cp with p = FALSE and positive literals of the form p with p = TRUE.\nWe say that a set X of literals from \u03c3 is complete if, for each atom a \u2208 \u03c3, either a or \u223ca is in X . We identify a complete set of literals from \u03c3 with the corresponding multi-valued propositional interpretation.\nTheorem 1 A complete set of literals is an answer set of \u03a0 in the sense of [Gelfond and Lifschitz, 1991] iff it is a stable model of \u03a0mv in the sense of [Bartholomew and Lee, 2012].\nThe theorem tells us that checking the minimality of positive and negative literals under the traditional stable model semantics is essentially the same as checking the uniqueness of corresponding function values under the stable model semantics from [Bartholomew and Lee, 2012].\nExample 5 Consider the program that describes a simple transition system consisting of two states depending on whether fluent p is true or false, and an action that makes p true (subscripts 0 and 1 represent time stamps).\np0 \u2190 \u0131not \u223cp0 p1 \u2190 a \u223cp0 \u2190 \u0131not p0\np1 \u2190 p0, \u0131not \u223cp1 a \u2190 \u0131not \u223ca \u223cp1 \u2190 \u223cp0, \u0131not p1 . \u223ca \u2190 \u0131not a\n(8)\nThe program has four answer sets, each of which corresponds to one of the four edges of the transition system. For instance, {\u223cp0, a, p1} is an answer set. This program can be encoded in the input languages of GRINGO and DLV. In the input language of DLV, which allows disjunctions in the head of a rule, the four rules in the first column can be succinctly replaced by\np0\u2228 \u223cp0 a\u2228 \u223ca . According to Theorem 1, the stable models of this program are the same as the stable models of the following multi-valued propositional formula (written in a logic program style syntax; \u2018\u00ac\u2019 represents default negation):\np0 = TRUE \u2190 \u00ac(p0 = FALSE) p0 = FALSE \u2190 \u00ac(p0 = TRUE)\na= TRUE \u2190 \u00ac(a= FALSE) a= FALSE \u2190 \u00ac(a= TRUE)\np1 = TRUE \u2190 a= TRUE\np1 = TRUE \u2190 p0 = TRUE \u2227 \u00ac(p1 = FALSE) p1 = FALSE \u2190 p0 = FALSE \u2227 \u00ac(p1 = TRUE) ."}, {"heading": "3.2 Relation among Strong Negation, Default Negation, Choice Rules and Boolean Functions", "text": "In certain cases, strong negation can be replaced by default negation, and furthermore the expression can be rewritten in terms of choice rules, which often yields a succinct representation.\nThe following theorem, which extends the Theorem on Double Negation from [Ferraris et al., 2009] to allow intensional functions, presents a condition under which equivalent transformations in classical logic preserve stable models.\nTheorem 2 Let F be a sentence, let c be a list of predicate and function constants, and let I be a (coherent) interpretation. Let F \u2032 be the sentence obtained from F by replacing a subformula \u00acH with \u00acH \u2032 such that I |= \u2200\u0303(H \u2194 H \u2032). Then\nI |= SM[F ; c] iff I |= SM[F \u2032; c] .\nWe say that an interpretation is complete on a predicate p if it satisfies \u2200x(p(x)\u2228 \u223cp(x)). It is clear that, for any complete interpretation I , we have I |= \u223cp(t) iff I |= \u00acp(t). This fact allows us to use Theorem 2 to replace strong negation occurring in H with default negation.\nExample 5 continued Each answer set of the first program in Example 5 is complete. In view of Theorem 2, the first two rules can be rewritten as p0 \u2190 \u0131not \u0131not p0 and \u223c p0 \u2190 \u0131not \u0131not \u223c p0, which can be further abbreviated as choice rules {p0} and {\u223cp0}. Consequently, the whole program can be rewritten using choice rules as\n{p0} {\u223cp0}\n{a} {\u223ca}\np1 \u2190 a\n{p1} \u2190 p0 {\u223cp1} \u2190 \u223cp0 .\nSimilarly, since I |= (p0 = FALSE) iff I |= \u00ac(p0 = TRUE), in view of Theorem 2, the first rule of the second program in Example 5 can be rewritten as p0 = TRUE \u2190 \u00ac\u00ac(p0 = TRUE) and further as {p0 = TRUE}. This transformation allows us to rewrite the whole program as\n{p0 =B} {a=B}\np1 = TRUE \u2190 a= TRUE {p1 =B} \u2190 p0 =B ,\nwhere B ranges over {TRUE, FALSE}. This program represents the transition system more succinctly than program (8)."}, {"heading": "3.3 Representing Strong Negation by Boolean Functions in the First-Order Case", "text": "Theorem 1 can be extended to the first-order case as follows. Let f be a function constant. A first-order formula is called f -plain if each atomic formula\n\u2013 does not contain f , or \u2013 is of the form f(t) = u where t is a tuple of terms not containing f , and u is a term\nnot containing f .\nFor example, f=1 is f -plain, but each of p(f), g(f) = 1, and 1=f is not f -plain. For a list c of predicate and function constants, we say that a first-order formula F is c-plain if F is f -plain for each function constant f in c. Roughly speaking, c-plain formulas do not allow the functions in c to be nested in another predicate or function, and at most one function in c is allowed in each atomic formula. For example, f = g is not (f, g)-plain, and neither is f(g) = 1\u2192 g = 1.\nLet F be a formula whose signature contains both positive and negative predicate constants p and \u223cp. Formula F (p,\u223cp)b is obtained from F as follows:\n\u2013 in the signature of F , replace p and \u223cp with a new intensional function constant b of arity n, where n is the arity of p (or\u223cp), and add two non-intensional object constants TRUE and FALSE; \u2013 replace every occurrence of \u223cp(t), where t is a list of terms, with b(t) = FALSE, and then replace every occurrence of p(t) with b(t) = TRUE.\nBy \u0131BCb (\u201cBoolean Constraint on b\u201d) we denote the conjunction of the following formulas, which asserts that b is a Boolean function:\nTRUE 6= FALSE , (9)\n\u00ac\u00ac\u2200x(b(x) = TRUE \u2228 b(x) = FALSE) ,\nwhere x is a list of distinct object variables.\nTheorem 3 Let c be a set of predicate and function constants, and let F be a c-plain formula. Formulas\n\u2200x((p(x)\u2194 b(x)= TRUE) \u2227 (\u223cp(x)\u2194 b(x)= FALSE)), (10)\nand \u0131BCb entail SM[F ; p,\u223cp, c]\u2194 SM[F (p,\u223cp)b ; b, c] .\nIf we drop the requirement that F be c-plain, the statement does not hold as in the following example demonstrates.\nExample 6 Take c as (f, g) and let F be p(f)\u2227 \u223c p(g). F (p,\u223cp)b is b(f) = TRUE \u2227 b(g) = FALSE. Consider the interpretation I whose universe is {1, 2} such that I contains p(1),\u223cp(2) and with the mappings bI(1) = TRUE, bI(2) = FALSE, f I = 1, gI = 2. I certainly satisfies \u0131BCb and (10). I also satisfies SM[F ; p,\u223cp, f, g] but does not satisfy SM[F (p,\u223cp)b ; b, f, g]: we can let I be b\u0302\nI(1) = FALSE, b\u0302I(2) = TRUE, f\u0302 I = 2, g\u0302I = 1 to satisfy both (\u0302b, f\u0302 , g\u0302) < (b, f, g) and (F (p,\u223cp)b ) \u2217(\u0302b, f\u0302 , g\u0302), which is\nb(f) = TRUE \u2227 b\u0302(f\u0302) = TRUE \u2227 b(g) = FALSE \u2227 b\u0302(g\u0302) = FALSE.\nNote that any interpretation that satisfies both (10) and \u0131BCb is complete on p. Theorem 3 tells us that, for any interpretation I that is complete on p, minimizing the extents of both p and \u223cp has the same effect as ensuring that the corresponding Boolean function b have a unique value.\nThe following corollary shows that there is a 1\u20131 correspondence between the stable models of F and the stable models of F (p,\u223cp)b . For any interpretation I of the signature of F that is complete on p, by I(p,\u223cp)b we denote the interpretation of the signature of F (p,\u223cp) b obtained from I by replacing the relation pI with function bI such that\nbI(\u03be1, . . . , \u03ben) = TRUE I if pI(\u03be1, . . . , \u03ben) = TRUE; bI(\u03be1, . . . , \u03ben) = FALSE I if (\u223cp)I(\u03be1, . . . , \u03ben) = TRUE .\n(Notice that we overloaded the symbols TRUE and FALSE: object constants on one hand, and truth values on the other hand.) Since I is complete on p and coherent, bI is welldefined. We also require that I(p,\u223cp)b satisfy (9). Consequently, I (p,\u223cp) b satisfies \u0131BCb.\nCorollary 1 Let c be a set of predicate and function constants, and let F be a c-plain sentence. (I) An interpretation I of the signature of F that is complete on p is a model of SM[F ; p,\u223cp, c] iff I(p,\u223cp)b is a model of SM[F (p,\u223cp) b ; b, c]. (II) An interpretation J of the signature of F (p,\u223cp)b is a model of SM[F (p,\u223cp) b \u2227 \u0131BCb; b, c] iff J = I (p,\u223cp) b for some model I of SM[F ; p,\u223cp, c].\nThe other direction, eliminating Boolean intensional functions in favor of symmetric predicates, is similar as we show in the following.\nLet F be a (b, c)-plain formula such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE, where t is any list of terms (not containing members from (b, c)). Formula F b(p,\u223cp) is obtained from F as follows:\n\u2013 in the signature of F , replace b with predicate constants p and \u223cp, whose arities are the same as that of b; \u2013 replace every occurrence of b(t) = TRUE, where t is any list of terms, with p(t), and b(t) = FALSE with \u223cp(t).\nTheorem 4 Let c be a set of predicate and function constants, let b be a function constant, and let F be a (b, c)-plain formula such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE. Formulas (10) and \u0131BCb entail\nSM[F ; b, c]\u2194 SM[F b(p,\u223cp); p,\u223cp, c] .\nThe following corollary shows that there is a 1\u20131 correspondence between the stable models of F and the stable models of F b(p,\u223cp). For any interpretation I of the signature of F that satisfies \u0131BCb, by I b(p,\u223cp) we denote the interpretation of the signature of F b (p,\u223cp) obtained from I by replacing the function bI with predicate pI such that\npI(\u03be1, . . . , \u03ben) = TRUE iff bI(\u03be1, . . . , \u03ben) = TRUEI ; (\u223cp)I(\u03be1, . . . , \u03ben) = TRUE iff bI(\u03be1, . . . , \u03ben) = FALSEI .\nCorollary 2 Let c be a set of predicate and function constants, let b be a function constant, and let F be a (b, c)-plain sentence such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE. (I) An interpretation I of the signature of F is a model of SM[F \u2227 \u0131BCb; b, c] iff I b(p,\u223cp) is a model of SM[F b (p,\u223cp); p,\u223cp, c]. (II) An interpretation J of the signature of F b(p,\u223cp) is a model of SM[F b\n(p,\u223cp); p,\u223cp, c] iff J = I b(p,\u223cp) for some model I of SM[F \u2227 \u0131BCb; b, c].\nAn example of this corollary is shown in the next section."}, {"heading": "4 Representing Non-Boolean Functions Using Strong Negation", "text": "In this section, we show how to eliminate non-Boolean intensional functions in favor of Boolean intensional functions. Combined with the method in the previous section, it gives us a systematic method of representing non-Boolean intensional functions using strong negation."}, {"heading": "4.1 Eliminating non-Boolean Functions in Favor of Boolean Functions", "text": "Let F be an f -plain formula. Formula F fb is obtained from F as follows:\n\u2013 in the signature of F , replace f with a new boolean intensional function b of arity n+ 1 where n is the arity of f ; \u2013 replace each subformula f(t) = c with b(t, c) = TRUE.\nBy \u0131UEb, we denote the following formulas that preserve the functional property:\n\u2200xyz(y 6= z \u2227 b(x, y) = TRUE \u2192 b(x, z) = FALSE),\n\u00ac\u00ac\u2200x\u2203y(b(x, y) = TRUE),\nwhere x is a n-tuple of variables and all variables in x, y, and z are pairwise distinct.\nTheorem 5 For any f -plain formula F ,\n\u2200xy ( (f(x) = y \u2194 b(x, y)= TRUE) \u2227 (f(x) 6= y \u2194 b(x, y)= FALSE) ) and \u2203xy(x 6= y) entail\nSM[F ; f, c] \u2194 SM[F fb \u2227 \u0131UEb; b, c] .\nBy Ifb , we denote the interpretation of the signature of F f b obtained from I by replacing\nthe mapping f I with the mapping bI such that\nbI(\u03be1, . . . , \u03ben, \u03ben+1) = TRUE I if f I(\u03be1, . . . , \u03ben) = \u03ben+1 bI(\u03be1, . . . , \u03ben, \u03ben+1) = FALSE I otherwise.\nCorollary 3 Let F be an f -plain sentence. (I) An interpretation I of the signature of F that satisfies \u2203xy(x 6= y) is a model of SM[F ; f, c] iff Ifb is a model of SM[F f b \u2227 \u0131UEb; b, c]. (II) An interpretation J of the signature of F f b that satisfies \u2203xy(x 6= y) is a model of SM[F fb \u2227 \u0131UEb; b, c] iff J = I f b for some model I of SM[F ; f, c].\nExample 3 continued In the program in Example 3, we eliminate non-Boolean function \u0131Loc in favor of Boolean function \u0131On as follows. The last two rules are \u0131UEOn.\n\u22a5 \u2190 \u0131On(b1, b, t)= TRUE \u2227 \u0131On(b2, b, t)= TRUE \u2227 b1 6= b2 \u0131On(b, l, t + 1)= TRUE \u2190 \u0131Move(b, l, t)\n\u22a5 \u2190 \u0131Move(b, l, t) \u2227 \u0131On(b1, b, t)= TRUE \u22a5 \u2190 \u0131Move(b, b1, t) \u2227 \u0131Move(b1, l, t)\n{\u0131On(b, l, 0)= TRUE} {\u0131Move(b, l, t)}\n{\u0131On(b, l, t + 1)= TRUE} \u2190 \u0131On(b, l, t)= TRUE \u0131On(b, l, t)= FALSE \u2190 \u0131On(b, l1, t)= TRUE \u2227 l 6= l1\n\u22a5 \u2190 \u0131not \u2203l(\u0131On(b, l, t)= TRUE) .\nFor this program, it is not difficult to check that the last rule is redundant. Indeed, since the second to the last rule is the only rule that has \u0131On(b, l, t) = FALSE in the head, one can check that any model that does not satisfy \u2203l(\u0131On(b, l, t)= TRUE) is not stable even if we drop the last rule.\nCorollary 2 tells us that this program can be represented by an answer set program containing strong negation (with the redundant rule dropped).\n\u22a5 \u2190 \u0131On(b1, b, t), \u0131On(b2, b, t) (b1 6= b2) \u0131On(b, l, t + 1) \u2190 \u0131Move(b, l, t)\n\u22a5 \u2190 \u0131Move(b, l, t), \u0131On(b1, b, t) \u22a5 \u2190 \u0131Move(b, b1, t), \u0131Move(b1, l, t)\n{\u0131On(b, l, 0)} {\u0131Move(b, l, t)} {\u0131On(b, l, t + 1)} \u2190 \u0131On(b, l, t) \u223c\u0131On(b, l, t) \u2190 \u0131On(b, l1, t) (l 6= l1) .\n(11)\nLet us compare this program with program (7). Similar to the explanation in Example 5 (continued), the 5th and the 7th rules of (7) can be represented using choice rules, which are the same as the 5th and the 6th rules of (11). The 6th and the 8th rules of (7) represent the closed world assumption. We can check that adding these rules to (11) extends the answer sets of (7) in a conservative way with the definition of the negative literals. This tells us that the answer sets of the two programs are in a 1-1 correspondence.\nAs the example explains, non-Boolean functions can be represented using strong negation by composing the two translations, first eliminating non-Boolean functions in favor of Boolean functions as in Corollary 3 and then eliminating Boolean functions in favor of predicates as in Corollary 2. In the following we state this composition.\nLet F be an f -plain formula where f is an intensional function constant. Formula F fp is obtained from F as follows:\n\u2013 in the signature of F , replace f with two new intensional predicates p and \u223cp of arity n+ 1 where n is the arity of f ; \u2013 replace each subformula f(t) = c with p(t, c).\nBy \u0131UEp, we denote the following formulas that preserve the functional property:\n\u2200xyz(y 6= z \u2227 p(x, y)\u2192\u223cp(x, z)) , \u00ac\u00ac\u2200x\u2203y p(x, y) ,\nwhere x is an n-tuple of variables and all variables in x, y, z are pairwise distinct.\nTheorem 6 For any (f, c)-plain formula F , formulas\n\u2200xy(f(x) = y \u2194 p(x, y)), \u2200xy(f(x) 6= y \u2194\u223cp(x, y)), \u2203xy(x 6= y)\nentail SM[F ; f, c]\u2194 SM[F fp \u2227 \u0131UEp; p,\u223cp, c] .\nBy I f(p,\u223cp), we denote the interpretation of the signature of F f (p,\u223cp) obtained from I by replacing the function f I with the relation pI that consists of the tuples \u3008\u03be1, . . . , \u03ben, f I(\u03be1, . . . , \u03ben)\u3009 for all \u03be1, . . . , \u03ben from the universe of I . We then also add the set (\u223cp)I that consists of the tuples \u3008\u03be1, . . . , \u03ben, \u03ben+1\u3009 for all \u03be1, . . . , \u03ben, \u03ben+1 from the universe of I that do not occur in the set pI .\nCorollary 4 Let F be an (f, c)-plain sentence. (I) An interpretation I of the signature of F that satisfies \u2203xy(x 6= y) is a model of SM[F ; f, c] iff I f(p,\u223cp) is a model of SM[F fp \u2227 \u0131UEp; p,\u223cp, c]. (II) An interpretation J of the signature of F fp that satisfies \u2203xy(x 6= y) is a model of SM[F fp \u2227 \u0131UEp; p,\u223cp, c] iff J = I f (p,\u223cp) for some model I of SM[F ; f, c].\nTheorem 6 and Corollary 4 are similar to Theorem 8 and Corollary 2 from [Bartholomew and Lee, 2012]. The main difference is that the latter statements refer to the constraint called \u0131UECp that is weaker than \u0131UEp. For instance, the elimination method from [Bartholomew and Lee, 2012] turns the Blocks World in Example 3 into almost the same program as (11) except that the last rule is turned into the constraint \u0131UECOn:\n\u2190 \u0131On(b, l, t) \u2227 \u0131On(b, l1, t) \u2227 l 6= l1 . (12)\nIt is clear that the stable models of F fp \u2227\u0131UEp are under the symmetric view, and the stable models of F fp \u2227 \u0131UECp are under the asymmetric view. To see how replacing \u0131UEOn by \u0131UECOn turns the symmetric view to the asymmetric view, first observe that adding (12) to program (11) does not affect the stable models of the program. Let\u2019s call this program \u03a0 . It is easy to see that \u03a0 is a conservative extension of the program that is obtained from \u03a0 by deleting the rule with \u223c\u0131On(b, l, t) in the head."}, {"heading": "5 Relating to Lifschitz\u2019s Two-Valued Logic Programs", "text": "Lifschitz [2012] presented a high level definition of a logic program that does not contain explicit default negation, but can handle nonmonotonic reasoning in a similar style as in Reiter\u2019s default logic. In this section we show how his formalism can be viewed as a special case of multi-valued propositional formulas under the stable model semantics in which every function is Boolean."}, {"heading": "5.1 Review: Two-Valued Logic Programs", "text": "Let \u03c3 be a signature in propositional logic. A two-valued rule is an expression of the form\nL0 \u2190 L1, . . . , Ln : F (13)\nwhere L0, . . . , Ln are propositional literals formed from \u03c3 and F is a propositional formula of signature \u03c3.\nA two-valued program \u03a0 is a set of two-valued rules. An interpretation I is a function from \u03c3 to {TRUE, FALSE}. The reduct of a program \u03a0 relative to an interpretation I , denoted \u03a0I , is the set of rules L0 \u2190 L1, . . . , Ln corresponding to the rules (13) of \u03a0 for which I |= F . Interpretation I is a stable model of \u03a0 if it is a minimal model of \u03a0I .\nExample 7 a \u2190 : a, \u00aca \u2190 : \u00aca, b \u2190 a : > (14)\nThe reduct of this program relative to {a, b} consists of rules a and b \u2190 a. Interpretation {a, b} is the minimal model of the reduct, so that it is a stable model of the program.\nAs described in [Lifschitz, 2012], if F in every rule (13) has the form of conjunctions of literals, then the two-valued logic program can be turned into a traditional answer set\nprogram containing strong negation when we consider complete answer sets only. For instance, program (14) can be turned into\na \u2190 \u0131not \u223ca, \u223ca \u2190 \u0131not a, b \u2190 a .\nThis program has two answer sets, {a, b} and\u223ca, and only the complete answer set {a, b} corresponds to the stable model found in Example 7."}, {"heading": "5.2 Translation into SM with Boolean Functions", "text": "Given a two-valued logic program \u03a0 of a signature \u03c3, we identify \u03c3 with the multi-valued propositional signature whose constants are from \u03c3 and the domain of every constant is Boolean values {TRUE, FALSE}. For any propositional formula G, \u0131Tr(G) is obtained fromG by replacing every negative literal\u223cA withA= FALSE and every positive literalA with A= TRUE. By \u0131tv2sm(\u03a0) we denote the multi-valued propositional formula which is defined as the conjunction of\n\u00ac\u00ac\u0131Tr(F ) \u2227 \u0131Tr(L1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u0131Tr(Ln)\u2192 \u0131Tr(L0)\nfor each rule (13) in \u03a0 . For any interpretation I of \u03c3, we obtain the multi-valued interpretation I \u2032 from I as follows. For each atom A in \u03c3,\nI \u2032(A) = { TRUE if I |= A FALSE if I |= \u00acA\nTheorem 7 For any two-valued logic program \u03a0 , an interpretation I is a stable model of \u03a0 in the sense of [Lifschitz, 2012] iff I \u2032 is a stable model of \u0131tv2sm(\u03a0) in the sense of [Bartholomew and Lee, 2012].\nExample 7 continued For the program \u03a0 in Example 7, \u0131tv2sm(\u03a0) is the following multi-valued propositional formula:( \u00ac\u00ac(a= TRUE)\u2192 a= TRUE ) \u2227 ( \u00ac\u00ac(a= FALSE)\u2192 a= FALSE ) \u2227 ( a= TRUE \u2192 b= TRUE ) .\nAccording to [Bartholomew and Lee, 2012], this too has only one stable model in which a and b are both mapped to TRUE, corresponding to the only stable model of \u03a0 according to Lifschitz.\nConsider extending the rules (13) to contain variables. It is not difficult to see that the translation \u0131tv2sm(\u03a0) can be straightforwardly extended to non-ground programs. This accounts for providing the semantics of the first-order extension of two-valued logic programs."}, {"heading": "6 Strong Negation and the Cabalar Semantics", "text": "There are other stable model semantics of intensional functions. Theorem 5 from [Bartholomew and Lee, 2013] states that the semantics by Bartholomew and Lee [2013] coincides with the semantics by Cabalar [2011] on c-plain formulas. Thus several theorems in this note stated for the Bartholomew-Lee semantics hold also under the Cabalar semantics.\nA further result holds with the Cabalar semantics since it allows functions to be partial. This provides extensions of Theorem 3 and Corollary 1, which do not require the interpretations to be complete. Below we state this result. Due to lack of space, we refer the reader\nto [Bartholomew and Lee, 2013] for the definition of CBL, which is the second-order expression used to define the Cabalar semantics.\nSimilar to \u0131BCb in Section 3.3, by \u0131BC \u2032b we denote the conjunction of the following formulas:\nTRUE 6= FALSE, (15)\n\u00ac\u00ac\u2200x(b(x) = TRUE \u2228 b(x) = FALSE \u2228 b(x) 6= b(x)),\nwhere x is a list of distinct object variables.4\nTheorem 8 Let c be a set of predicate constants, and let F be a formula. Formulas\n\u2200x((p(x)\u2194 b(x)= TRUE)\u2227(\u223cp(x)\u2194 b(x)= FALSE)\u2227(\u00acp(x)\u2227\u00ac\u223cp(x)\u2194 b(x) 6= b(x)),\nand \u0131BC \u2032b entail 5\nSM[F ; p,\u223cp, c]\u2194 CBL[F (p,\u223cp)b ; b, c] .\nThe following corollary shows that there is a 1\u20131 correspondence between the stable models of F and the stable models of F (p,\u223cp)b .\n6 For any interpretation I of the signature of F , by I(p,\u223cp)b we denote the interpretation of the signature of F (p,\u223cp) b obtained from I by replacing the relation pI with function bI such that\nbI(\u03be) = TRUEI if pI(\u03be) = TRUE ; bI(\u03be) = FALSEI if (\u223cp)I(\u03be) = TRUE ; bI(\u03be) = u if pI(\u03be) = (\u223cp)I(\u03be) = FALSE .\nSince I is coherent, bI is well-defined. We also require that I(p,\u223cp)b satisfy (15). Consequently, I(p,\u223cp)b satisfies \u0131BC \u2032 b.\nCorollary 5 Let F be a sentence, and let c be a set of predicate constants. (I) An interpretation I of the signature of F is a model of SM[F ; p,\u223cp, c] iff I(p,\u223cp)b is a model of CBL[F (p,\u223cp)b ; b, c]. (II) An interpretation J of the signature of F (p,\u223cp) b is a model of CBL[F (p,\u223cp)b \u2227 \u0131BC \u2032 b; b, c] iff J = I (p,\u223cp) b for some model I of SM[F ; p,\u223cp, c]."}, {"heading": "7 Conclusion", "text": "In this note, we showed that, under complete interpretations, symmetric predicates using strong negation can be alternatively expressed in terms of Boolean intensional functions in the language of [Bartholomew and Lee, 2012]. They can also be expressed in terms of Boolean intensional functions in the language of [Cabalar, 2011], but without requiring the complete interpretation assumption, at the price of relying on the notion of partial interpretations.\nSystem CPLUS2ASP [Casolary and Lee, 2011; Babb and Lee, 2013] turns action language C+ into answer set programs containing asymmetric predicates. The translation in\n4 Under partial interpretations, b(t) 6= b(t) is true if b(t) is undefined. See [Cabalar, 2011; Bartholomew and Lee, 2013] for more details. 5 The entailment is under partial interpretations and satisfaction. 6 Recall the notation defined in Section 3.3.\nthis paper that eliminates intensional functions in favor of symmetric predicates provides an alternative method of computing C+ using ASP solvers.\nAcknowledgements: We are grateful to Vladimir Lifschitz for bringing attention to this subject, to Gregory Gelfond for useful discussions related to this paper, and to anonymous referees for useful comments. This work was partially supported by the National Science Foundation under Grant IIS-0916116 and by the South Korea IT R&D program MKE/KIAT 2010-TD-300404-001."}], "references": [{"title": "CPLUS2ASP: Computing action language C+ in answer set programming", "author": ["Babb", "Lee", "2013. Joseph Babb", "Joohyung Lee"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Babb et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Babb et al\\.", "year": 2013}, {"title": "Stable models of formulas with intensional functions", "author": ["Bartholomew", "Lee", "2012. Michael Bartholomew", "Joohyung Lee"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Bartholomew et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bartholomew et al\\.", "year": 2012}, {"title": "On the stable model semantics for intensional functions", "author": ["Bartholomew", "Lee", "2013. Michael Bartholomew", "Joohyung Lee"], "venue": "TPLP,", "citeRegEx": "Bartholomew et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bartholomew et al\\.", "year": 2013}, {"title": "Functional answer set programming", "author": ["Cabalar", "2011. Pedro Cabalar"], "venue": "TPLP, 11(2-3):203\u2013233,", "citeRegEx": "Cabalar and Cabalar.,? \\Q2011\\E", "shortCiteRegEx": "Cabalar and Cabalar.", "year": 2011}, {"title": "Representing the language of the causal calculator in answer set programming", "author": ["Casolary", "Lee", "2011. Michael Casolary", "Joohyung Lee"], "venue": "In ICLP (Technical Communications),", "citeRegEx": "Casolary et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Casolary et al\\.", "year": 2011}, {"title": "Symmetric splitting in the general theory of stable models", "author": ["Ferraris et al", "2009. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz", "Ravi Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "al. et al\\.,? \\Q2009\\E", "shortCiteRegEx": "al. et al\\.", "year": 2009}, {"title": "Stable models and circumscription", "author": ["Ferraris et al", "2011. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["Gelfond", "Lifschitz", "1991. Michael Gelfond", "Vladimir Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond et al\\.", "year": 1991}, {"title": "Answer set programming and plan generation", "author": ["Lifschitz", "2002. Vladimir Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Lifschitz and Lifschitz.,? \\Q2002\\E", "shortCiteRegEx": "Lifschitz and Lifschitz.", "year": 2002}, {"title": "Two-valued logic programs", "author": ["Lifschitz", "2012. Vladimir Lifschitz"], "venue": "In ICLP (Technical Communications),", "citeRegEx": "Lifschitz and Lifschitz.,? \\Q2012\\E", "shortCiteRegEx": "Lifschitz and Lifschitz.", "year": 2012}], "referenceMentions": [], "year": 2017, "abstractText": "The distinction between strong negation and default negation has been useful in answer set programming. We present an alternative account of strong negation, which lets us view strong negation in terms of the functional stable model semantics by Bartholomew and Lee. More specifically, we show that, under complete interpretations, minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. The same account lets us view Lifschitz\u2019s two-valued logic programs as a special case of the functional stable model semantics. In addition, we show how non-Boolean intensional functions can be eliminated in favor of Boolean intensional functions, and furthermore can be represented using strong negation, which provides a way to compute the functional stable model semantics using existing ASP solvers. We also note that similar results hold with the functional stable model semantics by Cabalar.", "creator": "LaTeX with hyperref package"}}}