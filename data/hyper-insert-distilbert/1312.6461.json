{"id": "1312.6461", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Dec-2013", "title": "Nonparametric Weight Initialization of Neural Networks via Integral Representation", "abstract": "proposing a new descriptive initialization derived method for hidden parameters fitting in a neural network is quickly proposed. specially derived from the discrete integral component representation of the embedded neural mesh network, a generic nonparametric uniform probability utility distribution of precisely hidden parameters is introduced. in analyzing this proposal, hidden parameters are initialized or by samples specifically drawn from this distribution, sampling and output selection parameters are fitted by ordinary finite linear regression. numerical reasoning experiments show that backpropagation with proposed initialization systematically converges somewhat faster outcomes than uniformly stationary random initialization. also it generally is therefore shown best that the proposed method achieves enough observed accuracy by itself without backpropagation estimation in sufficiently some isolated cases.", "histories": [["v1", "Mon, 23 Dec 2013 03:23:04 GMT  (348kb,D)", "https://arxiv.org/abs/1312.6461v1", "For ICLR2014"], ["v2", "Tue, 24 Dec 2013 02:54:29 GMT  (349kb,D)", "http://arxiv.org/abs/1312.6461v2", "For ICLR2014, revised into 9 pages"], ["v3", "Wed, 19 Feb 2014 20:02:05 GMT  (822kb,D)", "http://arxiv.org/abs/1312.6461v3", "For ICLR2014, revised into 9 pages; revised into 12 pages (with supplements)"]], "COMMENTS": "For ICLR2014", "reviews": [], "SUBJECTS": "cs.LG cs.NE", "authors": ["sho sonoda", "noboru murata"], "accepted": false, "id": "1312.6461"}, "pdf": {"name": "1312.6461.pdf", "metadata": {"source": "CRF", "title": "Nonparametric Weight Initialization of Neural Networks via Integral Representation", "authors": ["Sho Sonoda", "Noboru Murata"], "emails": ["s.sonoda0110@toki.waseda.jp,", "noboru.murata@eb.waseda.ac.jp"], "sections": [{"heading": "1 Introduction", "text": "In the backpropagation learning of a neural network, the initial weight parameters are crucial to its final estimates. Since hidden parameters are put inside nonlinear activation functions, simultaneous learning of all parameters by backpropagation is accompanied by a non-convex optimization problem. When the machine starts from an initial point far from the goal, the learning curve easily gets stuck in local minima or lost in plateaus, and the machine fails to provide good performance.\nRecently deep learning schemes draw tremendous attention for their overwhelming high performances for real world problems[1, 2]. Deep learning schemes consist of two stages: pre-training and fine-tuning. The pre-training stage plays an important role for the convergence of the following fine-tuning stage. In pre-training, the weight parameters are constructed layer by layer, by stacking unsupervised learning machines such as restricted Boltzmann machines[3] or denoising autoencoders[4]. Despite the brilliant progress in application fields, theoretical interpretation of the schemes is still an open question[5].\nIn this paper we introduce a new initialization/pre-training scheme which could avoid the nonconvex optimization problem. The key concept is the probability distribution of weight parameters derived from Murata\u2019s integral representation of neural networks[6]. The distribution gives an intuitive idea what the parameters represent and contains information about where efficient parameters exist. Sampling from this distribution, we can initialize weight parameters more efficiently than just sampling from a uniform distribution. In fact, for relatively simple or low dimensional problems, our method by itself attains a high accuracy solution without backpropagation.\nDe Freitas et al.[7] also introduced a series of stochastic learning methods for neural networks based on the Sequential Monte Carlo (SMC). In their methods the learning process is iterative and initial parameters are given by less informative distributions such as normal distributions. On the other hand we could draw the parameters from a data dependent distribution. Furthermore, in SMC, the number of hidden units must be determined before the learning, while it is determined naturally in our method.\nar X\niv :1\n31 2.\n64 61\nv3 [\ncs .L\nG ]\n1 9\nFe b"}, {"heading": "2 Back ground and related works", "text": "One of the most naive initialization heuristics is to draw samples uniformly from an interval [\u2212\u03b1, \u03b1]. Nguyen and Widrow[8] gave two fundamental points of view. First, since a typical activation function such as sigmoid and hyperbolic tangent is approximated as a linear function at its inflection point, one should initialize the hidden parameters in such a way that the inputs for each hidden unit are in the linear region. Second, since each hidden unit determines the slice of the Fourier transformed input space, that is, each individual hidden unit responds selectively to only the inputs whose spatial frequency is in a particular band, one should initialize hidden parameters in such a way that the corresponding frequency bands cover the possible input frequencies.\nLeCun et al.[9] also emphasized the need to preset parameters in the linear region because parameters outside the linear region have small gradients and stray into more difficult nonlinear regions. They focused on the curvature of input vectors and proposed to use \u03b1 \u221d m\u22121/2, where m is the fanin, or the dimensionality of input vectors. Shimodaira[10] proposed to initialize parameters such that corresponding activation regions to cover whole the possible inputs. Linear algebraic techniques are also employed. For example, Shepanski[11] used the pseudo inverse to determine the parameters of linear approximated neural networks, and Yam and Chow[12] used the QR decomposition.\nIntegral transform viewpoints originated from more theoretical backgrounds than linear region viewpoints: the theoretical evaluation of the approximation power of neural networks. In the earliest stage, purely functional analysis methods were employed. In 1957 Kolmogorov[13] showed that any multivariate continuous functions can be exactly represented by sums of compositions of different continuous functions of only one variable. Inspired by the Kolmogorov\u2019s theorem, HechtNielsen[14] and Ku\u030arkova\u0301[15] applied the idea to neural networks, which are sums of compositions of the same sigmoid function. Sprecher[16] gave more constructive version of the proof and later implemented the improved proof as a learning algorithm of neural networks[17].\nIn 1989 the universal approximation property of single layer neural networks has been investigated and the integral transform aspects emerged. Carroll and Dickinson[18] introduced the Radon transform and Funahashi[19] used the Fourier analysis and the Paley-Weiner theory, whereas Cybenko[20] employed the Hahn-Banach and Riesz Representation theorems. In the following years, upper bounds of the approximation error were investigated[21, 22, 6]. Barron[22] refined the Jones\u2019 result[21] using the weighted Fourier transform. Ku\u030arkova\u0301[15] later developed the general theory of integral transforms. Inspired by the Barron\u2019s result, Murata[6] introduced a family of integral transforms defined by ridge functions, which are regarded as a hybrid of the Radon and wavelet transforms. Cande\u0301s[23] inherited Murata\u2019s transforms and developed ridgelets, which was the beginning of the series of multiscale \u201c-lets\u201d analysis[24].\nThose multiscale viewpoints also inherits the selective activation properties of neural networks. Denoeux and Lengelle\u0301[25] proposed to collect K prototype vectors as initial hidden parameters. Each prototype pk is drawn from its corresponding cluster Ck, where the clusters {Ck}Kk=1 are formed in a stereographically projected input space. In this manner each prototype pk comes to selectively respond to the input vectors x which belongs to the cluster Ck.\nThis study is based on the integral transform viewpoint, and proposes a new way for practical implementation. Although integral transforms have been well studied as theoretical integral representations of neural networks, practical implementations for training have been merely done. However integral representations have big advantage over linear region viewpoints in that they can give global directions how each neural units should behave, while the latter only give local directions."}, {"heading": "3 Nonparametric weight initialization via integral transform", "text": ""}, {"heading": "3.1 Sampling based two-stage learning", "text": "Let g : Rm \u2192 R be a neural network with a single hidden layer expressed as\ng(x) = J\u2211 j=1 wj\u03c6 (aj \u00b7 x\u2212 bj) + w0, (1)\nwhere the map \u03c6 is called the activation function; aj and bj are called hidden parameters, andwj are output parameters. With an ordinary sigmoid function \u03c3(z) := 11+exp(\u2212z) , the activation function \u03c6 is supposed to be the sigmoid pair in the form\n\u03c6(z) := 1\nH {\u03c3(z + h)\u2212 \u03c3(z \u2212 h)} , (h > 0), (2)\nwhere H := \u03c3(h)\u2212 \u03c3(\u2212h) normalizes the maximum value of \u03c6 to be one. We consider an oracle distribution p(a, b) of hidden parameters. If such a distribution exists, we can sample and fix these hidden parameters according to p(a, b) first, and then we could fit the rest output parameters by ordinary linear regression. We call this two-stage framework as Sampling Regression (SR) learning.\nThe candidates of p(a, b) could be some parametric distributions such as normal distributions or uniform distributions. In the following sections we derive a data dependent distribution from an integral representation of neural networks."}, {"heading": "3.2 Integral representations of neural networks", "text": "Consider approximating a map f : Rm \u2192 R with a neural network. Murata[6] defined an integral transform T of f with respect to a decomposing kernel \u03c6d as\nT (a, b) := 1\nC \u222b Rm \u03c6d(a \u00b7 x\u2212 b)f(x)dx, (3)\nwhere C is a normalizing constant. Murata also showed that given the decomposing kernel \u03c6d, there exists the associating composing kernel \u03c6c such that for any f \u2208 L1(Rm) \u2229 Lp(Rm)(1 \u2264 p \u2264 \u221e), the inversion formula\nf(x) = lim \u21920 \u222b Rm+1 \u03c6\u2217c(a \u00b7 x\u2212 b)T (a, b)e\u2212 |a| 2 dadb in Lp, (4)\nholds (Th.1 in [6]) where \u00b7\u2217 denotes the complex conjugate. The convergence factor e\u2212 |a|2 is omitted when T \u2208 L1(Rm+1), which is attained when f is compactly supported and Cm,\u03b1-Ho\u0308lder continuous with 0 < \u03b1 \u2264 1 (Th.3 in [6]), or compactly supported and bounded Cm+1-smooth (Cor.2 in [6]).\nIn particular one can set a composing kernel \u03c6c as a sigmoid pair \u03c6 given in Eq.2 and the associating decomposing kernel as:\n\u03c6d(z) = { \u03c1(m)(z) if m is even \u03c1(m+1)(z) otherwise , (5)\nwhere \u03c1 is a nonnegativeC\u221e-smooth function whose support is in the interval [\u22121, 1]. Such a \u03c1 does exist and is known as a mollifier[26].The standard mollifier \u03c1(z) = exp ( 1\nz2\u22121\n) is a well-known\nexample.\nHereafter we assume \u03c6c is a sigmoid pair and \u03c6d is the corresponding derivative of the standard mollifier. We also assume that our target f is a bounded and compactly supported C(m+1)-smooth function. Then the integral transform T of f is absolutely integrable and the inversion formula is reduced to the direct form f(x) = \u222b Rm+1 \u03c6 \u2217 c(a \u00b7 x\u2212 b)T (a, b)dadb.\nLet \u03c4(a, b) be a probability distribution function over Rm+1 which is proportional to |T (a, b)|, and c(a, b) be satisfying c(a, b)\u03c4(a, b) = T (a, b) for all (a, b) \u2208 Rm+1. With this notations, the inversion formula is rewritten as the expectation form with respect to \u03c4(a, b), that is,\nf(x) = \u222b Rm+1 c(a, b)\u03c6c(a \u00b7 x\u2212 b)\u03c4(a, b)dadb. (6)\nThe expression implies the finite sum\ngJ(x) := 1\nJ J\u2211 j=1 c(aj , bj)\u03c6c(aj \u00b7 x\u2212 bj), (aj , bj) i.i.d.\u223c \u03c4(a, b) (7)\nconverges to f in mean square as J \u2192 \u221e, i.e. E[gJ ] = f and Var[gJ ] < \u221e holds for any J (Th.2 in [6]). Here gJ is a neural network with 2J hidden units, therefore we can regard the inversion formula as an integral representation of neural networks."}, {"heading": "3.3 Practical calculation of the integral transform", "text": "Now we attempt to make use of the integral transform |T (a, b)| as an oracle distribution p(a, b) of hidden parameters. Although the distribution is given in the explicit form as we saw in the preceding section, further refinements are required for practical calculation.\nGiven a set {(xn, yn)}Nn=1 \u2282 Rm\u00d7R of input and output pairs, T (a, b) is empirically approximated as\nT (a, b) \u2248 1 Z N\u2211 n=1 \u03c6d(a \u00b7 xn \u2212 b)yn, (8)\nwith some constant Z > 0 which is hard to calculate exactly. In fact sampling algorithms such as the acceptance-rejection method[27] and Markov chain Monte Carlo method[27] work with any unnormarized distribution because they only evaluate the ratio between probability values. Note that the approximation converges to the exact T (a, b) in probability by the law of large numbers only when the input vectors are i.i.d. samples from a uniform distribution.\nAs a decomposing kernel \u03c6d we make use of the k-th order derivative of the standard mollifier \u03c1(z) = exp 1z2\u22121 where k = m if m is even and k = m+ 1 otherwise. The k-th derivative \u03c1\n(k)(z) of the mollifier takes the form\n\u03c1(k)(z) = Pk(z)\n(z2 \u2212 1)2k \u03c1(z) (k = 0, 1, 2, \u00b7 \u00b7 \u00b7 ), (9)\nwhere Pk(z) denotes a polynomial of z which is calculated by the following recurrence formula:\nP0(z) \u2261 1 (const.), (10) Pk+1(z) = P \u2032 k(z)(z 4 \u2212 2z2 + 1) + Pk(z) { \u22124kz3 + 2(2k \u2212 1)z } . (11)\nThe higher order derivatives of a mollifier has more rapid oscillations in the neighbourhoods of both edges of its support.\nGiven a data setD := {(xn, yn)}Nn=1 \u2282 Rm\u00d7R, our Sampling Regression method is summarized as below:\n0. Preliminary stage: Calculate \u03c1(k)(z) according to Eq.9, Eq.10 and Eq.11, where k = m if m is even and k = m + 1 otherwise. Then T (a, b) is calculated by Eq.8 with setting \u03c6d = \u03c1\n(k). As we noted above, one can choose arbitrary Z > 0. 1. Sampling stage: Draw J samples {(aj , bj)}Jj=1 from the probability distribution \u03c4(a, b) \u221d |T (a, b)| by acceptance-rejection method, where J denotes the number of hidden (sigmoid pair) units. Then we obtain the hidden parameters {(aj , bj)}Jj=1.\n2. Regression stage: Let \u03c6jn := \u03c6d(aj \u00b7 xn \u2212 bj) for all j = 1, \u00b7 \u00b7 \u00b7 , J and n = 1, \u00b7 \u00b7 \u00b7 , N . Solve the system of linear equations yn = \u2211J j=1 wj\u03c6jn + w0 (n = 1 \u00b7 \u00b7 \u00b7N) with respect\nto {wj}Jj=0. Then we obtain the output parameters {wj}Jj=0."}, {"heading": "3.4 For more efficient sampling", "text": "Generally |T (a, b)| is ill-shaped and sampling from the distribution is difficult. For example in Fig.1 Left, samples drawn from |T (a, b)| of f(x) = sin 2\u03c0x with x \u2208 [\u22121, 1] is plotted. Whereas in Fig.1 Right, the same distribution is transformed to another (\u03b1, \u03b2)-coordinate system (which is explained below). The support of the distribution is reshaped into a rectangular, which implies sampling from |T (\u03b1, \u03b2)| is easier than doing from |T (a, b)|. This ill-shapeness is formulated as following proposition. Proposition 3.1. Suppose the objective function f(x) has a compact support, then the support of its transform T (a, b) is in the region \u2126 := {(a, b) | |b| \u2264M\u2016a\u2016+ 1} with M := maxx\u2208supp f \u2016x\u2016.\nProof. Recall the support of \u03c6d is included in the interval [\u22121, 1], therefore for any a, b and x, \u03c6d(a \u00b7 x \u2212 b) 6= 0 implies |a \u00b7 x \u2212 b| < 1. The latter condition is equivalently deformed to a \u00b7 x\u2212 1 < b < a \u00b7 x+ 1, which implies |b| < |a \u00b7 x|+ 1. By the compact support assumption of f ,\ntaking the maximum with respect to x leads to |b| < M\u2016a\u2016 + 1. By tracking back the inferences, for any a, b and x \u2208 supp f ,\n(a, b) /\u2208 \u2126\u21d2 \u03c6d(a \u00b7 x\u2212 b) = 0. (12)\nSince for any x /\u2208 supp f , the integrand of T (a, b) is always zero, the integration domain of T (a, b) can be restricted into supp f . Therefore by Eq.12,\nT (a, b) 6= 0\u21d2 (a, b) \u2208 \u2126 (13)\nholds, which comes to the conclusion: suppT \u2282 \u2126.\nIn a relatively high dimensional input case, sampling in the coordinate transformed (\u03b1, \u03b2)-space( a b ) = ( \u03b1 (M\u2016\u03b1\u2016+ 1)\u03b2 ) , (14)\nis more efficient than sampling in the (a, b)-space because the shape of the support of |T (a, b)| in the (\u03b1, \u03b2)-space is rectangular (see, Fig.1) and therefore the proposal distribution is expected to reduce miss proposals, out of the support.\nIn case that the coordinate transform technique is not enough, it is worth sampling from each component distribution. Namely, the empirically approximated |T (a, b)| is bounded above by a mixture distribution:\n|T (a, b)| \u2248 1 Z \u2223\u2223\u2223 N\u2211 n=1 yn\u03c6d(a \u00b7 xn \u2212 b) \u2223\u2223\u2223 \u2264 1 Z N\u2211 n=1 |yn||\u03c6d(a \u00b7 xn \u2212 b)|,\n\u221d N\u2211 n=1 \u03b7npn(a, b), (15)\nwhere pn(a, b) \u221d |\u03c6d(a\u00b7xn\u2212b)| is a component distribution and \u03b7n \u221d |yn| is a mixing probabilities. In addition, an upper bound of \u03c6d is given by the form\nlog |\u03c6d(z)| \u2264 Az2 +B, (16)\nfor some A > 0 and B."}, {"heading": "4 Experimental results", "text": "We conducted three sets of experiments comparing three types of learning methods:\nBP Whole parameters are initialized by samples from a uniform distribution, and trained by BackPropagation.\nSBP Hidden parameters are initialized by Sampling from |T (a, b)|; and the rest output parameters are initialized by samples from a uniform distribution. Then whole parameters are trained by BackPropagation.\nSR Hidden parameters are determined by Sampling from |T (a, b)|; the rest output parameters are fitted by linear Regression.\nIn order to compare the ability of the three methods, we conducted three experiments on three different problems: One-dimensional complicated curve regression, Multidimensional Boolean functions approximation and Real world data classification.\n4.1 One-dimensional complicated curve regression - Topologist\u2019s sine curve sin 2\u03c0/x\nFirst we performed one-dimensional curve regression. The objective function is a two-sided topologists\u2019s sine curve (TSC) f(x) := sin 2\u03c0/x defined on the interval [\u22121, 1] whose indefiniteness at zero is removed by defining f(0) = 0. The TSC is such a complicated curve whose spatial frequency gets arbitrary high as x tends to zero. For training, 201 points were sampled from the domain [\u22121, 1] in equidistant manner. The number of hidden parameters were fixed to 100 in each model. Note that relatively redundant quantity of parameters are needed for our sampling initialization scheme to obtain good parameters. The output function was set to linear and the batch learning was performed by BFGS quasi-Newton method. Uniformly random initialization parameters for BP and SBP were drawn from the interval [\u22121, 1]. Sampling from |T (a, b)| was performed by acceptance-rejection method.\nIn Fig.2 Left, the Root Mean Squared Error (RMSE) in training phase of three methods are shown. The solid black line corresponds to the result by SR, which by itself achieved the highest accuracy without iterative learnings. The dashed red line corresponds to the result by SBP, and it converged to lower RMSE than that of BP depicted in the dotted green line. In Fig.2 Right, fitting results of the three methods are shown. As we noted the original curve (upper left) has numerical instability\naround the origin, therefore it is difficult to fit the curve. SR (upper right) approximated the original curve well except around the origin, while other two methods, SBP (lower left) and BP (lower right) could just partly fit the original curve. In this experiment, we examined the flexibility of our method by fitting a complicated curve. The experimental result supports that the oracle distribution gave advantageous directions."}, {"heading": "4.2 Multidimensional Boolean functions approximation - Combined AND, OR and XOR", "text": "Second we performed a binary problem with twodimensional input and three-dimensional output. Output vectors are composed of three logical functions: F (x, y) := (xANDy, xORy, xXORy). Therefore the total number of data is just four: (x, y) \u2208 {(0, 0), (0, 1), (1, 0), (1, 1)}. The number of hidden units were fixed to 10. The output function was set to sigmoid and the loss function was set to cross-entropy. Uniformly random initialization parameters for BP and SBP were drawn from the interval [\u22121, 1]. Sampling from |T (a, b)| was performed by acceptance-rejection method.\nIn Fig.3 both the cross-entropy curves and classification error rates are depicted in thin and thick lines respectively. The solid black line corresponds to the results by SR, which achieved the perfectly correct answer from the beginning. The dashed red line corresponds to the results by SBP, which also attained the perfect solution faster than BP. The dotted green line corresponds to the results by BP, which cost 100 iterations of learning to give the correct answer. In this experiment we have validated that the proposed method works well with multiclass classification problems. The quick convergence of SBP indicates that\n|T (a, b)| contains advantageous information on the training examples to the uniform distribution.\n4.3 MNIST\nFinally we examined a real classification problem using the MNIST data set[28]. The data set consists of 60, 000 training examples and 10, 000 test examples. Each input vector is a 256-level gray-scaled (28 \u00d7 28 =)784-pixel image of a handwritten digit. The corresponding label is one of 10 digits. We implemented these labels as 10-dimensional binary vectors whose components are chosen randomly with equivalent probability for one and zero. We used randomly sampled 15, 000 training examples for training and whole 10, 000 testing examples for testing. The number of hidden units were fixed to 300, which is the same size as used in the previous study of LeCun et al.[29]. Note that J sigmoid pairs corresponds to 2J sigmoid units, therefore we used 150 sigmoid pairs for SR and SBP, and 300 sigmoid units for BP. The output function was set to sigmoid and the loss function was set to cross-entropy. In obedience to LeCun et al.[9], input vectors were normalized and randomly initialized parameters for BP and SBP were drawn from uniform distribution with mean zero and standard deviation 784\u22121/2 \u2248 0.0357.\nDirect sampling from |T (a, b)| is numerically difficult because the differential order of its decomposing kernel \u03c6d piles up as high as 784-th order. We abandoned rigorous sampling and tried sampling from a mixture annealed distribution. As described in Eq.15, we regarded |T (a, b)| as a mixture of |\u03c6d(a \u00b7 xn \u2212 b)|. By making use of the log boundary given by Eq.16, we numerically approximated \u03c6d(z) from above log |\u03c6d(z)| \u2264 2800z2 \u2212 800, (|z| < 1), (17) and drew samples from an easier component distribution pn(a, b) \u221d exp{2800(a \u00b7 xn \u2212 b)2 \u2212 800}. Details of the sampling technique is explained in A.2. The sampling procedure scales linearly with the dimensionality of the input space (784) and the number of required hidden units (150) respectively. In particular it scales constantly with the number of the training examples.\nThe following linear regression was conducted by singular value demcomposition (SVD), which generally costsO(mn2) operations, assumingm \u2265 n, for decomposing am\u00d7n-matrix. In our case m corresponds to the number of the training examples (15, 000) and n corresponds to the number of hidden units (300). At last backpropagation learning was performed by stochastic gradient descent (SGD) with adaptive learning rates and diagonal approximated Hessian[30]. The experiment was performed in R[31] on a Xeon X5660 2.8GHz with 50GB memory.\nIn Fig.4 the classification error rates for test examples are depicted. The black real line corresponds to the results by SR, which marked the lowest error rate (23.0%) of the three at the beginning, and finished 9.94% after 45, 000 iterations of SGD training. The training process was not monotonically decreasing in the early stage of training, it appears that the SR initialization overfitted to some extent. The red dashed line corresponds to the results by SBP, which marked the steepest error reduction in the first 5, 000 iterations of SGD training and finished 8.30%. The green dotted line corresponds to the results by BP, which declined the slowest in the early stage of training and finished 8.77%.\nIn Tab.1 the training time from initialization through SGD training is listed. The sampling step in SR ran faster than the following regression and SGD steps. In addition, the sampling time of SR and SBP was as fast as the sampling time of BP. As we expected, the regression step in SR, which scales linearly with the amount of the data, cost much more time than the sampling step did. The SGD step also cost, however each step cost around merely 0.05 seconds, and it would be shorten if the initial parameters had better accuracy.\nIn this experiment, we confirmed that the proposed method still works for real world data with the aid of an annealed sampling technique. Although SR showed an overfitting aspects, the fastest convergence of SBP supports that the oracle distribution gave meaningful parameters, and the annealed sampling technique could draw meaningful samples. Hence the overfitting of SR possibly comes from regression step, which suggests the necessity for further blushing up of regression technique. In addition, our further experiments also indicated that when the number of hidden units increased to 6, 000, the initial test error rate scored 3.66%, which is smaller than the previously reported error rates 4.7% by LeCun et al.[29] with 300 hidden units."}, {"heading": "5 Conclusion and future directions", "text": "In this paper, we introduced a two-stage weight initialization method for backpropagation: sampling hidden parameters from the oracle distribution and fitting output parameters by ordinary linear regression. Based on the integral representation of neural networks, we constructed our oracle distributions from given data in a nonparametric way. Since the shapes of those distributions are not simple in high dimensional input cases, we also discussed some numerical techniques such as the coordinate transform and the mixture approximation of the oracle distributions. We performed three numerical experiments: complicated curve regression, Boolean function approximation, and\nhandwritten digit classification. Those experiments show that our initialization method works well with backpropagation. In particular for the low dimensional problems, well-sampled parameters by themselves achieve good accuracy without any parameter updates by backpropagation. For the handwritten digit classification problem, the proposed method works better than random initialization.\nSampling learning methods inevitably come with redundant hidden units since drawing good samples usually requires a large quantity of trial. Therefore the model shrinking algorithms such as pruning, sparse regression, dimension reduction and feature selection are naturally compatible to the proposed method.\nAlthough plenty of integral transforms have been used for theoretical analysis of neural networks, numerical implementations, in particular sampling approaches are merely done. Even theoretical calculations often lack practical applicability, for example a higher order of derivative in our case, each integral representation interprets different aspects of neural networks. Further Monte Carlo discretization of other integral representations is an important future work.\nIn the deep learning context, it is said that the deep structure remedies the difficulty of a problem by multilayered superpositions of simple information transformations. We conjecture that the complexity of high dimensional oracle distributions can be decomposed into relatively simple distributions in each layer of the deep structure. Therefore, extending our method to the multilayered structure is our important future work."}, {"heading": "Acknowledgments", "text": "The authors are grateful to Hideitsu Hino for his incisive comments on the paper. They also thank to Mitsuhiro Seki for having constructive discussions with them."}, {"heading": "A Sampling recipes", "text": "Sampling hidden parameter (a, b)\u2019s from the oracle distribution p(a, b) demands a little ingenuity. In our experiments, we have implemented two sampling procedures: a rigorous but naive, computationally inefficient way and an approximative/ad hoc but quick and well-performing way. Although both work quickly and accurately in a low dimensional input problem, only the latter works in a high dimensional problem such as MNIST.\nA.1 Sampling from rigorous oracle distribution\nGiven a decomposing kernel \u03c6d(z) := \u03c1(m)(z), we employed acceptance-rejection (AR) method directly on rigorous sampling from p(a, b) On a proposal distribution q(a, b), we employed uniform distribution. We assume here that the support \u2126 of proposal distribution q(a, b) has been adjusted to cover the mass of p(a, b) as tight as possible, and the infimum k := inf p(a, b)/q(a, b) has been estimated. Then our sampling procedure is conducted according to the following Alg.1.\nNote that in a high dimensional case, the estimation accuracy of k and the tightness of \u2126 affects the sampling efficiency and accuracy materially. In fact, the expectation number of trial to obtain one sample by AR is k times, which gets exponentially large as the dimensionality increases. Since the support of the oracle distribution p(a, b) is not rectangular, sampling from coordinate transformed p(\u03b1, \u03b2) remedies the difficulty. In addition, the high order differentiation in the decomposing kernel \u03c6d cause numerical unstability.\nAlgorithm 1 Rigorous sampling according to ordinary acceptance-rejection method. repeat\ndraw proposal point (a\u2217, b\u2217) \u223c q(a, b). draw uniformly random value u from the interval [0, 1]. if u \u2264 p(a\n\u2217,b\u2217) kq(a\u2217,b\u2217) then\nreturn (a\u2217, b\u2217) {accept} else\ndo nothing {reject} end if until acceptance occurs.\nA.2 Sampling from mixture annealed distribution\nIn order to overcome the high dimensional sampling difficulty, we approximately regarded p(a, b) as a mixture distribution p(a, b) \u2248 \u2211N n=1 \u03b7npn(a, b) (as described in Eq.15) and conducted two-step sampling: first choose one component distribution pn(a, b) according to the mixing probability \u03b7n \u221d |yn|, second draw a sample (a, b) from chosen component distribution pn(a, b).\nSampling from pn(a, b) \u221d |\u03c6d(a\u00b7xn\u2212b)| holds another difficulty due to its high order differentiation in \u03c6d(z). According to its upper bound evaluation (Eq.16), a high order derivative \u03c1(m)(z)(= \u03c6d(z)) has its almost all mass around both edge of its domain interval [\u22121, 1] and almost no mass in the middle of the domain (see Fig.5 Left). Hence we approximated, or annealed, \u03c1(m)(z) by a beta distribution, which could model extreme skewness of \u03c1(m)(z) (e.g., Beta(z; 100, 3); see Fig.5 Right). Then we conducted further steps of sampling: first sample z \u2208 [\u22121, 1] according to the annealing beta distribution, then sample a and b under the restriction z = a \u00b7 xn \u2212 b.\nObviously the mixture approximation gives rise to poor restriction and virtual indefiniteness of (a, b). Since the rigorous computation establishes all relations between (a, b) and all xn\u2019s, whereas the mixture approximation does just one relation between (a, b) and one particular xn. We introduced two additional assumptions. First, a is parallel to given xn. Since a always appears in the form a \u00b7 xn, only the parallel component of a could have any effect (on one particular xn), hence we eliminated the extra freedom in the orthogonal component. Second, the norm a := \u2016a\u2016 has similar scale to the distances \u2016xn \u2212 xm\u2016 between input vectors. Since a controls the spatial frequency of a hidden unit, it determines how broad the hidden unit covers the part of the input space. Namely, a controls which input vectors are selectively responded by the unit. Therefore, in order to avoid such an isolation case that an unit responds for only one input vector, we assumed a is no smaller than the distance between input vectors. In this procedure we set a as a distance \u2016xn \u2212 xm\u2016 of randomly selected two input examples xn and xm. We denote this procedure simply by a \u223c p(\u2016x \u2212 x\u2032\u2016). Once a is fixed with these assumptions, b is determined as b = a \u00b7 xn \u2212 z.\nGiven shape parameters \u03b1, \u03b2 of the beta distribution Beta(z;\u03b1, \u03b2), one cycle of our second sampling method is summarized as Alg.2. This method consists of no more expensive steps. It scales linearly with the dimensionality of the input space and the number of required sample parameters respectively. Moreover, it does not depends on the size of the training data.\nAlgorithm 2 Quick sampling from mixture annealed distribution (for high dimensional use.) choose a suffix n of xn according to the mixing probability \u03b7n. draw \u03b6 \u223c Beta(z;\u03b1, \u03b2) and k \u223c Bernoulli(k; p = 0.5) z \u2190 (\u22121)k\u03b6 set length a \u223c p(x\u2212 x\u2032). a\u2190 axn/\u2016xn\u2016. b\u2190 a \u00b7 xn \u2212 z."}], "references": [], "referenceMentions": [], "year": 2014, "abstractText": "A new initialization method for hidden parameters in a neural network is pro-<lb>posed. Derived from the integral representation of neural networks, a nonparamet-<lb>ric probability distribution of hidden parameters is introduced. In this proposal,<lb>hidden parameters are initialized by samples drawn from this distribution, and<lb>output parameters are fitted by ordinary linear regression. Numerical experiments<lb>show that backpropagation with proposed initialization converges faster than uni-<lb>formly random initialization. Also it is shown that the proposed method achieves<lb>enough accuracy by itself without backpropagation in some cases.", "creator": "LaTeX with hyperref package"}}}