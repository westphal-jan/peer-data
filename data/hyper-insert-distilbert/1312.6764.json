{"id": "1312.6764", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Dec-2013", "title": "Bounded Recursive Self-Improvement", "abstract": "importantly we have have successfully designed a machine metaphor that becomes increasingly better at everyday behaving in underspecified circumstances, useful in developing a goal - directed way, specifically on the job, aided by actually modeling itself freely and its living environment concurrently as discrete experience accumulates. relying based on principles of model autocatalysis, complex endogeny, morphology and discrete reflectivity, the work provides an architectural blueprint mechanism for constructing systems architecture with high levels of discrete operational autonomy in relatively underspecified circumstances, already starting from there a small seed. going through value - orientation driven dynamic priority scheduling controlling along the parallel execution schedules of a vast number of external reasoning key threads, learning the system achieves recursive self - improvement after controlling it actually leaves functioning the creativity lab, within the boundaries subsequently imposed upstream by developing its designers. a prototype intelligent system has therefore been implemented swiftly and demonstrated to learn fundamentally a mentally complex ( real - run world task, real - time dynamic multimodal dialogue precisely with humans, by on - line observation. developing our research work presents solutions to offset several societal challenges that must be rapidly solved individually for achieving artificial general intelligence.", "histories": [["v1", "Tue, 24 Dec 2013 06:17:55 GMT  (1569kb)", "http://arxiv.org/abs/1312.6764v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["e nivel", "k r th\\'orisson", "b r steunebrink", "h dindo", "g pezzulo", "m rodriguez", "c hernandez", "d ognibene", "j schmidhuber", "r sanz", "h p helgason", "a chella", "g k jonsson"], "accepted": false, "id": "1312.6764"}, "pdf": {"name": "1312.6764.pdf", "metadata": {"source": "CRF", "title": "Bounded Recursive Self-Improvement", "authors": ["E. Nivel", "K. R. Th\u00f3risson", "B. R. Steunebrink", "H. Dindo", "G. Pezzulo", "M. Rodriguez", "C. Hernandez", "D. Ognibene", "J. Schmidhuber", "R. Sanz", "H. P. Helgason", "A. Chella", "G. K. Jonsson"], "emails": [], "sections": [{"heading": null, "text": "RUTR-SCS13006 2/56"}, {"heading": "1 Introduction", "text": "Engineering is essentially to couple a system, an environment and a mission to meet a predefined set of requirements (Sanz, Matia & Gal\u00e1n, 2000). Present-day control architectures solve this problem only under the following assumption: The environment is well defined and so are the ways to achieve its mission. Given an ability to impart to a machine sufficient knowledge and resources for operating in a\nRUTR-SCS13006 3/56\nfully specified environment, systems can currently be built that meet task-related goals. What this approach doesn\u2019t address at all is: (a) How to build a system that is flexible and general enough to adapt when the environment changes from its initial specification, and to redefine accordingly its ways to fulfill its mission; (b) How to make a system cope with an environment the complexity of which allows only partial descriptions (i.e. when specifications become intractable); and (c) Since any physical system is resource-bounded, how to enable such systems to continue operation and degrade gracefully when their resources become scarce, or when adaptation to any other changes becomes necessary.\nIntelligence is a technical means to the end of controlling a system\u2019s behavior so that it can survive adversity, be kept operating within its imposed and natural boundaries and still deliver the value it was intended to deliver. Our work concerns the creation of autonomous controllers that meet the unaddressed limitations of artificial intelligent systems, and this requires a re-evaluation of present engineering methodologies. First, to address the question of what a system can do after it leaves the lab, we must assume that the artificial general intelligent (AGI) systems of the future, to deserve the name, can learn complex tasks autonomously. Even tasks done routinely by 5-year olds, such as cleaning up the playroom, are beyond the capability of today's systems. As illustrated in Figure 1, current learning systems are limited to a handful of input and output parameters (Figure 1-A), typically on a single pre-defined task in a welldefined, unchanging environment. Let tski (Figure 1-B) refer to relatively non-trivial tasks such as assembling furniture and moving books, computers, tables, and chairs from one office to another, state-of-the-art machine-learning technique L0 is limited to learn only about a small subset of the various things that must be learned to achieve such a task. Being able to handle such a task in full, L1 in Figure 1-B is already more capable than most if not all advanced learning AI available today, being able to learn a single such complex task whose features were unknown prior to the system's deployment, even if it can only do so in one situation (S1). L2, L3 and L4 take successive steps up the complexity ladder beyond that, being able to learn a number of complex tasks (L2), in other situations (L3), and in a wider range of environments and mission spaces (L4). Our work aims at toward the higher end of this ladder, at systems capable of learning to perform multiple a-priori unknown tasks, in multiple apriori unknown environments.\nCurrent engineering methodologies assume that code is written by humans. Yet to design systems that exhibit even modest levels of autonomy after they leave the lab, it is clear that we cannot continue on building the whole knowledge base of such\nRUTR-SCS13006 4/56\nsystems by hand: The demanding requirements of complex environments, of these future systems' missions, and of their task-execution and problem solving skills, are pushing the development effort out of the reach of what standard software and hardware engineering practices currently are capable of supporting. To build systems of greater complexity than current ones \u2013 which any system meeting the above unaddressed requirements unavoidably will be \u2013 the methodology must bring the complexity of system development to manageable levels. Ideally we would like a system to gradually implement and improve itself by learning its own task-solving methods using its architecture-provided resources by interacting with its environment, whenever necessary. To move towards systems with higher levels of operational autonomy and increased abilities for autonomous learning, these methodological and systemic shortcomings must be addressed. But if such capabilities are out of the scope of present software development approaches, how shall we approach the engineering of a system endowed with the aforementioned qualities?\nIn Nivel and Th\u00f3risson (2009) we proposed a stringent definition of an autonomous system, as a system that is operationally and semantically closed. Operational closure characterizes a system whose internal agency is maintained \u2013 i.e. re-organized and possibly expanded \u2013 at runtime by means of its own operation. In the case of software systems, such behavior would mean that components are continually added and deleted as a side-effect of the system\u2018s normal execution: Some components are learned whereas some others are discounted as a result of their poor performance. From this perspective, such systems can be seen as autocatalytic sets 1 whose components are implemented and maintained by the system itself. Semantic closure is a system's ability to control the reorganization of its agency with a purpose: Purposeful, goal-oriented self-organization. To achieve this, a system's architecture must be represented in a semantically transparent manner \u2013 making the system reflective \u2013 to endow the system with an ability to analyze and rewrite its own structure (Nivel & Th\u00f3risson 2009, Sanz & Lopez 2000). Autonomy means being free from interference from the outside, which in the case of artificial systems means the system's designers. A system that continuously learns and re-programs itself to adapt and get better must be equipped from the outset with a \"seed\", an initial and minimal set of instructions general enough to guide the system's bootstrapping its autocatalytic operation in any instance of its broad set of target environments and tasks. Such a system is endogenous in the sense that its behavior results solely from its internal operation and goals and cannot be controlled directly by any external operator, but rather can only take indirect instruction, which it must evaluate in light of its own current knowledge, like a human would.\nThe freedom of action entailed by high levels of autonomy is however balanced by hard constraints. First, an autonomous system, to be of any value, is functionally bounded by its mission, which imposes not only the requirements the system has to meet, but also the constraints it has to respect. Second, to keep the system operating within its functional boundaries, one has to ensure that some parts of the system will never be rewritten autonomously \u2013 for example, the management of motivations shall be excluded from rewriting as this would possibly allow the transgression of the constraints imposed by the designers. In that sense, the system is also bounded, operationally, by its own architecture. Last, any implemented system is naturally bounded by the resources (CPU, time, memory, inputs) and knowledge at its disposal. For these reasons, autonomy, as we refer to it, shall therefore be understood as bounded autonomy.\nOur work described here presents evidence and arguments in support of the\n1 An autocatalytic set is a collection of entities, each of which can be created catalytically by other entities within the set, such that as a whole, the set is able to catalyze its own production. In this way the set as a whole is said to be autocatalytic.\nRUTR-SCS13006 5/56\nconclusion that the path towards building artificial general intelligence (AGI) systems can be made possible by meeting \u2013 at a minimum \u2013 these three requirements of autocatalysis, endogeny, and reflectivity (AER). These must be implemented in a unified whole, for it is the transversal application of these principles 2 in an architecture that bring their value to the system (Th\u00f3risson & Nivel 2009). Unfortunately, none of the methodologies available in the AI or CS literature are directly applicable for designing systems of this nature. For this reason we have advocated what we call a constructivist AI methodology (CAIM; Th\u00f3risson forthcoming, 2012, 2009, Nivel & Th\u00f3risson 2009, Th\u00f3risson & Nivel 2009), centered on continuous adaptation \u2013 learning that is \"always on\" and inherent in the system's core operation, and the growth of the system from a small seed. In the main, our constructivist approach has two key objectives: (a) based on the principles of AER, to achieve bounded recursive self-improvement and generality and, (b) to uncover the principles for \u2013 and to actually build \u2013 systems that, given a small set of seed information, manage the bulk of the bootstrapping work on their own, in environments and on tasks that may be new and unfamiliar.\nIn this paper we present a control architecture blueprint \u2013 called Autocatalytic Endogenous Reflective Architecture (AERA) \u2013 that aspires to enable the engineering of AGI systems. First we describe the assumptions and functional requirements that provided the ground for the design of the architecture. Then in section 3 we describe the principles which guided the design of AERA. Section 4 presents the fundamental principles that govern the execution of AERA-based systems. We provide in section 5 a detailed description of the architecture, both functionally and structurally, and explain how the aforementioned principles are brought to bear to yield higher-order cognitive functions. AERA has been implemented and used for building a prototype the evaluation of which is given in section 6. In section 7, we discuss our approach in light of related work. Finally, in section 8, we sketch out our plans for future developments."}, {"heading": "2 Assumptions & Requirements", "text": "Our objective is to design control architectures for autonomous systems meant ultimately to control machinery (like for example robots, power grids, cars, plants, etc.). All physical systems have limited resources, and the ones we intend to build are no exception: they have limited computing power, limited memory, and limited time to fulfill their mission. All physical systems also have limited knowledge about their environment and the tasks they have to perform for accomplishing their mission. Wang (2011) merged these two assumptions into one, called AIKR \u2013 the assumption of insufficient knowledge and resources \u2013 which then forms the basis of his working definition of intelligence: \u201cTo adapt with insufficient knowledge and limited resources\u201d. We have adopted this definition as one of the anchors of our work, being much in line with Simon\u2019s concept of \u201cbounded rationality\u201d (Simon 1957). This perspective means that we cannot expect any optimal behaviors from our systems since their behaviors will always be constrained by the amount and reliability of knowledge they can accumulate at any particular point in time. In other words we can only expect from these systems their displaying of a best effort strategy.\nNo system can be built (or build itself) completely from scratch and we assume that a system is given some initial \u201cinnate\u201d knowledge that allows interacting with the world \u2013 even if in a minimalistic way at first \u2013 to acquire more knowledge and improve its performance. Note that we do not consider any assumptions or requirements that pertain specifically to the biological reign. Our work is thus not \"biologically inspired\" in\n2 The principles are applied system-wide, that is, at every level of detail, to all the processes that ultimately realize the system\u2019s operation.\nRUTR-SCS13006 6/56\nany interesting or important sense of that term, and it is not our aim to mimic in some way the human mind or biological systems.\nWe assume that the domain our system operates in is rich, dynamic and open-ended. This means that the domain cannot be fully described in advance, due to its inherent complexity and because it changes continuously, possibly entering states never observed before and for these reasons unbeknown to the system and its designers. That being said, we still assume that the domain presents some regularities of course: The environment is not random and is governed by laws that maintain it in a relative state of stability, at least for long enough to allow the system observing recurrences of states and transitions thereof. However, such regularities can be expected to happen at different time scales, and they are mixed with processes that for all practical purposes can be assumed to be stochastic. The domain is at all times only partially observable: Not all possible states are observable in a given environment at any given moment.\nAnother assumption is that the kinds of systems we target are not expected to be general problem solvers in the sense of prior aspirations to this end in the world of AI (Newell 1959) and are allowed to rely on ad-hoc specific I/O devices. These devices can be for example, servo-motors, speech recognition, machine vision or inverse kinematics sub-systems, etc. In general, we will consider an I/O device any subsystem for which both its mission and environment (i.e. a sub-set of the global environment the main system operates in) can be well-defined \u2013 the rationale being that in these cases ad-hoc optimized solutions are always more efficient than general ones. We do not impose any specific way for integrating the devices into the architecture but the integration should offer various degrees of flexibility. For example, devices can implement full solutions or partial solutions (think for example of many shape recognition sub-systems, federated by the architecture itself; one can also imagine a set of redundant sub-systems with various degrees of performance and reliability). The I/O devices can be considered part of the environment a system has to control and as such the system must be able to model these devices \u2013 for example to predict or recognize sensor or actuator failures. This implies that such I/O devices must send to the main system reports of their operation \u2013 for example an actuator receiving a command from the system shall answer with the command that was actually applied (the desired and actual commands being not always necessarily the same).\nThe assumptions listed so far form the background for the functional requirements we established for our architecture \u2013 which are:\nR1. The system must fulfill its mission \u2013 the goals and constraints it has been given by its designers \u2013 with possibly several different priorities.\nFlexibility with respect to top-level goals and constraints is needed if we want the system to be able to focus on the most important tasks at hand, and discard or postpone the achievement of the rest of its primary objectives, when facing scarcity of resources. This also applies to lower-level goals /sub-goals, i.e. goals generated by the system itself to achieve the top-level goals.\nR2. The system must be designed to be operational in the long-term, without intervention of its designers after it leaves the lab, as dictated by the temporal scope of its mission.\nThis means that a system should be as autonomous as possible, to remain operational for extended periods of time without re-adjustment, re-programming, or redefinition from its designers, thus being equipped to face changes in its environment and adapt to these on its own.\nR3. The system must be domain- and task-independent \u2013 but without a strict requirement for determinism: We limit our architecture to handle\nRUTR-SCS13006 7/56\nonly missions for which rigorous determinism is not a requirement.\nThe requirement of generality also implies that a system must handle inputs coming concurrently from various arbitrary sources and modalities, in other words, no domaindependent knowledge representation schemes can be tolerated. The systems we envision are essentially non-deterministic in the sense that their behavior depends on the accumulated experience: Given a situation and a set of goals, the machine is likely to perform differently in a new occurrence of said situation from what it did in the past because it may have learned new ways to operate by having captured new knowledge between the two instances of the same situation.\nR4. The system must be able to model its environment to adapt to changes thereof.\nThis means in practice that the system must be able to learn new skills, possibly for new environments, augmenting its skill repertoire. The system also has to re-learn some skills it has already acquired in case these are not adapted to the environment anymore. Since changes in the environment are not always predictable, the system must be able to learn continually, incrementally and in real-time. The system does not only have to adapt its behavior but also has to adapt the way it generates it according to the resources at hand. In other terms, the system must be able to adapt its computation to the scarcity of its resources and degrade gracefully accordingly.\nR5. As with learning, planning must be performed continuously, incrementally and in real-time. Pursuing goals and predicting must be done concurrently.\nIn particular, the system must anticipate the environment for acting \u2013 a controller that does not anticipate its environment is poised to react after the facts, i.e. to lag behind its target. The rationale for concurrent goal pursuit and anticipation is that (a) since achieving goals needs predictions, the latter shall be up to date and thus a system cannot stop predicting because it is planning its next move and, (b) the system will not have the luxury to predict any possible state transition in its environment; the only interesting ones are those that pertain to the achievements of its goals, therefore these goals must be up to date when predictions are generated.\nR6. The system must be able to control the focus of its attention.\nAs already mentioned, the system has limited resources and the environment a high level of complexity. A system thus has to dedicate its computing power to only address the stimuli that are most relevant to its goals and discard the rest. For a discussion about the fundamental impact of attention on the control of autonomous systems, see Helgason (2013), Helgason & Th\u00f3risson (2012), and Helgason et al. (2013).\nFrom R4, R5 and R6 we can require that the three major high-level cognitive functions - learning, attentional control and planning \u2013 must be concurrent.\nThe system must be able to learn from events whenever they happen, regardless of its other activities; in a similar way, the system cannot wait for learning to terminate before acting, and attention must always and continually be directed appropriately so as to avoid wasting computing power and time, for example by learning irrelevant state transitions and planning according to irrelevant inputs and predictions.\nR7. The system must be able to model itself.\nThe system does not only have to model its environment for acting. It should also be able to model itself in the environment to be able to predict its own reactions and the success or failure thereof. Moreover a system also has to model itself for adapting its behaviors to the resources available \u2013 for example by changing the priorities of some of its goals and redirect its CPU and time budgets to the most urgent goals. Selfmodeling necessitates that part of the operation of the system is visible to the system\nRUTR-SCS13006 8/56\nitself (we call this property operational reflectivity) as internal inputs (the external inputs being the stimuli received from the environment).\nR8. The system must be able to handle incompleteness, uncertainty, and inconsistency, both in state space and in time.\nSince the environment is only partially observable, and since the system has limited resources, said system can only expect to acquire an incomplete representation of the world, possibly including inconsistencies. Therefore its knowledge shall be defeasible and can only be established to a certain degree and within a certain period of time.\nR9. The system must be able to generate abstractions from learned knowledge.\nAbstraction is a form of compression and therefore will contribute to maintain the system\u2019s operation in its prescribed envelope by reducing the amount of knowledge required to solve some tasks and consequently by reducing the time it takes to process said knowledge. In that respect, the system must be able to learn mathematical functions (a form of abstraction) \u2013 for example to predict the next position of a moving object, given its current position and speed. In the work described here we restrict this requirement to linear functions and approximate more complex functions by the recursive application of linear ones on input data."}, {"heading": "3 Design Principles", "text": "In light of our functional requirements outlined above we have established five key principles to guide the design of our architecture.\nUniform fine-grained executable knowledge. Knowledge is composed of states (be they past, present, predicted, desired or hypothetical) and of executable code (called models). Models are capable of generating such knowledge (for example, generating predictions, hypotheses or goals) and are executed by a virtual machine (in the case of AERA, its executive).\nThe granularity of such models shall be kept low for two main reasons. First, it is easier to add and replace small (low-grained) models than larger ones because the impact of their addition or replacement in the architecture will be less than replacement of large models. In other words, low model granularity is aimed at preserving system plasticity, supporting the capability of implementing small, incremental changes in the system. Second, low granularity helps compositionality and reuse; small models can only implement limited low-level functions and, if abstract enough, are more likely to be useful for implementing several higher-level functions than coarser models that implement one or more such high-level functions in one big atomic block. We have referred to this elsewhere as the principle of peewee granularity (Th\u00f3risson 2012, Nivel & Th\u00f3risson 2009, Th\u00f3risson & Nivel 2009).\nWe also need the knowledge to be uniform, that is, encoded using one single scheme regardless of the particular data semantics. This helps to allow execution, planning, and learning algorithms to be both general and commensurate in resource usage (described in more detail below).\nThe system must be capable of handling vast amounts of knowledge. The system is meant to operate in complex environments where it will be stimulated by a high number of inputs, thus increasing its need to understand them \u2013 that is, to produce a large amount of model candidates to predict these inputs. The system is to face novelty and to do so with limited prior knowledge. This means that it is not expected of the system that it is always able to identify relevant inputs; irrelevant or incorrect models shall be expected and the system shall be able to handle these. It follows that such a system has to implement a mechanism to trim down the irrelevant or faulty\nRUTR-SCS13006 9/56\nmodels, calling for a continuous process of evaluating and revising vast amounts of its acquired but possibly uncertain knowledge.\nMassive fine-grained parallelism. As we cannot assume guarantees for system down-time (after all, we are targeting high levels of operational autonomy), all activities of the system, from low-level (for example, prediction, sub-goaling) to highlevel (like learning and planning), must be performed in real-time, concurrently, and continuously. Moreover, we need these activities to be executed in a way that is flexible enough to allow the system to dynamically (re-)allocate its resources depending on the urgency of the situation it faces at any point in time (with regards to its own goals and constraints), based on the availability of these same resources, over which it may not have complete (or any) control. The approach we chose is to break all activities down into fine-grained elementary reasoning processes that are commensurable both in terms of execution time and scheduling. These reasoning processes are the execution of various kinds of inference programs (models being one), and they represent the bulk of the computing. These programs are expected to be numerous and this calls for an architecture capable of handling massive amounts of parallel tasks (thereafter referred to as reasoning jobs, or jobs for short).\nExperience-based looped-back adaptation and cognitive control. Working under an assumption of incomplete knowledge and insufficient resources means that the systems we envision are neither likely to have the time and knowledge necessary to accomplish all the jobs they ideally should, given their goals, nor to process every input available in the environment. Standard real-time control systems are designed to be deterministic: Capabilities, jobs, and inputs are predetermined, and schedulability - the pre-established proof that all jobs will be scheduled for execution - is critical. In sharp contrast, our systems are not expected to be deterministic, as their operation is grounded in their experience. Such systems must be able to react at any time, thus possibly striving to delay or, even better, discard jobs depending on (a) the urgency of the jobs with respect to current or predicted situations, (b) the estimated value 3 of the jobs for the system as a whole and, (c) the resources available. These estimates (predictions, individual job value and value for the system) are derived from experience accumulated from past operation. From the operational level perspective, a system, as we see it, will never repeat any known algorithm to process a given set of inputs as algorithms are implemented by learned models. Due to its continuous learning, the system is essentially always re-computing the way anything should be done, on the fly, thus constantly modifying its \"algorithms\", even when repeating the same task many times sequentially. From a higher (functional) level perspective however, the system is still expected to behave as deterministically as possible, i.e. to achieve its goals under its prescribed constraints consistently and reliably, adapting to the change of conditions by accumulating experience that will predictably yield more value in the future.\nA cornerstone of our approach is that cognitive control results from the continual value-driven scheduling of reasoning jobs. According to this view, high-level cognitive processes are grounded directly in the core operation of the machine resulting from two complementary control schemes. The first is top-down: Scheduling allocates resources by estimating the global value of the jobs at hand, and this judgment results directly from the products of cognition \u2013 goals and predictions. These are relevant and accurate to various extents, depending on the quality of the knowledge accumulated so far. As the latter improves over time, goals and predictions become more relevant\n3 \"Value\u201c is an assessment of \"utility\u201c, which refers to the learned, predicted achievability of all the goals the system pursues, which is ultimately sanctioned by, and grounded in, the environment. It is not the eponym concept, as widely used in the \"machine learning\" literature, which refers to some intrinsic, axiomatic, hard-coded heuristics. See section 4.3 Equation 6, for an unambiguous definition of the concept in the context of our work.\nRUTR-SCS13006 10/56\nand accurate, thus allowing the system to allocate its resources with a better judgment; the most important goals and the most useful/accurate predictions are considered first, the rest being saved for later processing or even discarded, thus saving resources. In that sense, cognition controls resource allocation. The second control scheme is bottom-up: Resource allocation controls cognition. Shall resources become scarce (which is pretty much always the case in our targeted systemenvironment-mission triples), scheduling narrows down the system\u2019s attention to the most important goals/predictions the system can handle, trading scope for efficiency and therefore survivability \u2013 the system will only pay attention to the most promising (value-wise) inputs and inference possibilities. Reciprocally, shall the resources become more abundant, the system will start considering goals and predictions that are of less immediate value, thus opening up possibilities for learning and improvement. System\u2019s resources are poised to continually oscillate between scarcity and abundance, as scarcity will push for more efficiency, which in turn releases more resources that become available for more speculative reasoning jobs, which in turn consumes more resources.\nOperational reflectivity. A system must know what it is doing, when, and at what cost. Enforcing the production of explicit traces of the system's operation allows building models of said operation, which is needed for self-control (also called metacontrol). In that respect, the functional architecture we seek shall be applicable to itself, i.e. a meta-control system for the system shall be implementable the same way the system is implemented to control itself in a domain. This principle is a prerequisite for integrated cognitive control (Sanz & Hernandez 2012).\nOur approach assumes that the system is interfaced with its environment via I/O devices, dedicated, domain-dependent sensors/effectors. Due to the assumed high ratio of available environmental data to cognitive computing resources, the devices cover only parts of the whole environment at the desired granularity, ranging from coarse-grain (like blob detection from visual data supplied via cameras) to fine-grain (e.g. edge detectors).\nThe system consists of two essential parts: A memory (white disc) and an executive. The latter executes knowledge in the form of models, based on sensory inputs and the content of the memory (experience).\nThe executive exposes several parameters and functions that can be viewed as internal effectors and traces of the system's own execution are continuously injected into its memory, in the form of internal inputs. These are processed in exactly the manner as sensory inputs. The processing of internal inputs and of the internal effectors allows \u2013 optionally - using\nRUTR-SCS13006 11/56\nan instance of AERA (on the right of the picture) to control another one (on the left), realizing integrated cognitive control (ICC).\nPervasive flexible representation of time. Representing time at several temporal scales, from the smallest levels of individual operations (e.g. producing a prediction) to a collective operation (e.g. achieving a mission) is an essential requirement for a system that must (a) perform in the real world and (b) model its own operation with regards to its expenditure of resources (as these include time). Considering time values as intervals allows encoding the variable precisions and accuracies needed to deal with the real world, for example, sensors do not always perform at fixed frame rates and so modeling their operation may be critical to ensure reliable operation of their controllers and models that depend on their input. Also, the precision for goals and predictions may vary considerably depending on both their time horizons and semantics. Last, since acquired knowledge can never be certain, one can assume that \"truth\" \u2013 asserting that a particular fact holds \u2013 can only be established for some limited time, and for varying degrees of temporal uncertainty.\nIn conclusion, these design principles can be unified under the higher-level principle of \u201cholistic design\u201d. According to this principle, robustness shall be seen as the robustness of an entire situated system as a whole, for example, allowing a whole system to carry on most of its relevant operations while facing environmental adversity without breaking down because one of its sub-parts failed. In our view there are no sub-parts, but a dynamic pool of low-level generic processes that altogether implement the necessary functions for achieving a mission. The core idea is (a) to even out the load imposed by said sub-processes among the available resources and competencies and, (b) to fail gracefully when one or more processes fail or fail to be executed due to lack of resources.\nIn our approach there are no sub-components called \u201clearning\u201d or \u201cplanner\u201d and so on. Instead, learning and planning are emergent processes that result from the same set of low-level processes: These are essentially the execution of fine-grained programs and are thus reusable and shared system-wide, collectively implementing functions that span across the entire scope of the system\u2019s operation in its environment. For example, models generate both goals and predictions, some other programs monitor their success or failure and are thus able to reinforce the system\u2019s confidence about their effectiveness. Now, if we picture a skill as a plan, that is a succession of goals, then we see that such a skill is actually implemented by a set of models. From this perspective, learning a skill results from learning models and their sequence of execution, and this results from both the assessment of the performance of said models and the detection of novelty, which in turn produces new models. Both of these activities are examples of the aforementioned generic low-level processes. High-level processes (like planning and learning) influence each other: For example, learning better models and sequences thereof improves planning; reciprocally, having good plans also means that a system will direct its attention to more (goal-)relevant states, and this means in turn that learning is more likely to be focused on changes that impact the system\u2019s mission, possibly increasing its chances of success. These high-level processes are dynamically coupled, as they both result from the execution of the same knowledge \u2013 the core of the system, its models.\nRUTR-SCS13006 12/56\nIn addition to observed states, assumptions, goals and predictions, the system\u2019s memory contains executable code (in the form of models and other programs) and as such, constitutes an active part of the system: It is actually the very core of a model-based and model-driven system. The memory is responsible for most of the computation occurring in the system. Three main cognitive processes \u2013 attention, learning and planning \u2013 are themselves implemented by programs constituting the adaptable part of the system, the fixed part being the executive. These processes are indirectly and dynamically coupled through the memory as models are added, deleted, activated or phased-out, as dictated by the context and the goals pursued by the system."}, {"heading": "4 Principles of Operation", "text": "We propose four main operational principles for an architecture intended to meet the functional requirements listed in section 2: (a) A way to represent uncertain, defeasible, time-dependent knowledge, (b) a control hierarchy constituted of executable knowledge, either given or learned, (c) a way to deliver real-time performance, anytime, based on the value of computation expenses for the predicted welfare of the system as a whole and, (d) a way to abstract knowledge to contribute to the maintenance of computation demands within a limited resource budget. These form the content of the four sub-sections in this section. In the last sub-section, on abstraction, we give a concrete example of operation that pulls together many of the key principles listed here."}, {"heading": "4.1 Knowledge Representation", "text": "Our approach to knowledge representation has its roots in a non-axiomatic term logic. This logic is non-axiomatic in the sense that knowledge is established on the basis of a system\u2019s experience, that is, truth is not absolute but rather established to a certain degree and within a certain time interval. In our approach the simplest term thus encodes an observation, and is called a fact (or a counter-fact indicating the absence of an observation). A fact carries a payload - the observed event -, a likelihood value\nRUTR-SCS13006 13/56\nin [0, 1] indicating the degree to which the fact has been ascertained and a time interval in microseconds \u2013 the period within which the fact is believed to hold (or, in the case of a counter-fact, the period during which the payload has not been observed). Facts have a limited life span, corresponding to the upper bound of their time interval. Payloads are terms of various types, some of which are built in the executive, the most important of these being atomic state, composite state, prediction, goal, command, model, success/failure, and performance measurement. Additionally, any type can be defined by the programmer, and new types can be created by I/O devices at runtime. We will look at each of these in turn:\nAtomic state. An atomic state encodes a simple relation between objects of the form \u201centity property value\u201d (for example \u201centity_12 has_color_component_blue 128\u201d, where \u201chas_color_component_blue\u201d is a domain-dependent user-defined term). A counter-evidence of this state could be for example \u201centity_12 has_color_component_blue 96\u201d, both evidences and counter-evidences are expected and AERA has been designed to handle such inconsistencies by allocating its resources based on the priorities of their respective processing (see section 4.3).\nComposite state and instantiated composite state. A composite state is a compound of abstract facts. Abstract facts are facts where some of their values have been replaced by variables. A composite state is therefore best viewed as a pattern of the conjunction of several facts. To take an example, a composite state coded as the conjunction of the facts \u201cE has_color C\u201d, \u201cE bears_number N\u201d, \u201cE bears L\u201d and \u201cN bears_number L\u201d can describe a bus, with a color, its bus line number and a license plate. When the executive observes an instance of the conjunction of facts specified by a composite state it produces an instance of said state (for instance, \u201cyellow thing1, bearing both line number 19 and thing2 bearing number PDH2O\u201d), as the payload of a new fact. This fact\u2019s likelihood is the least likelihood found among its components and its time interval is the intersection of the components\u2019 respective time intervals.\nPrediction. A prediction denotes a hypothetical future state and is encoded as a fact holding a payload (also a fact, the future state). The time interval associated with the predicted future state describes the interval within which the predicted state is expected to hold.\nGoal. Like a prediction, a goal is a fact holding a payload fact referencing the desired state. The time interval associated with the desired state describes the interval within which the state is to be achieved.\nCommand. A command is an operation which, when embedded in a goal, is to be executed by an I/O device. Issuing a command to a device triggers an answer from said device in the form of the command that has actually been executed, which is dependent on the current capabilities of the device (the answer will be less than the command when the latter exceeds the capabilities of the hardware, as expected) \u2013 this answer is thereafter called an efferent copy and is encoded as the payload of a fact, i.e. as a regular input.\nModel and instantiated model. A model encodes procedural knowledge in the form of a causal relationship between two terms. A model is built from two patterns, lefthand and right-hand. When an instance of the left-hand pattern is observed, then a prediction patterned after the right-hand pattern is produced, and reciprocally, when an instance of the right-hand pattern is observed (such an instance being a goal), then a sub-goal patterned after the left-hand pattern is produced. Each time a model predicts, the executive produces a new term, called an instantiated model that references the input, the output and the model itself. An instantiated model is thus a trace of the execution of a model and, being the payload of a fact, constitutes an (internal) input for the system. Models form the very core of an AERA system and their operation is detailed in the next sub-section.\nRUTR-SCS13006 14/56\nSuccess/failure. The assessment of the success or failure of a goal or a prediction (and therefore of the models which produced them) constitutes an (internal) input of the system. These are encoded as fact payloads.\nPerformance measurement. The system periodically assesses its processing performance in terms of the observed lag with regards to meeting its timely targets; for example, achieving goals in time, assessing the performance of its models, assessing the travel time of its jobs in the scheduler (see section 5.3). Such measurements are also internal inputs to the system. As for anything else, performance measurements are encoded as fact payloads.\nThe life cycles of models and composite states are more complex than those of facts. Essentially their life span and capacity to operate are governed by the entire architecture, based on their individual performance. Models are said to be reliable when they predict correctly and consistently so; reliable models tend to be executed more often than unreliable models, the latter being eventually discarded when their performance becomes unacceptable (see section 5.2 for details). In addition, a garbage collector deletes models and composite states that have been the least recently used."}, {"heading": "4.2 Control Hierarchy", "text": "AERA is data-driven, meaning that the execution of code is triggered by matching patterns with inputs. Code refers to models (which constitute executable knowledge), that have either been given (as part of the bootstrap code) or learned by the system. As mentioned above, models are structures composed of two terms \u2013 a left-hand term (LT) and a right-hand term (LR) \u2013 encoding a causal relationship between the two terms; an instance of LT entails the production of an instance of RT. Both of these terms are patterns, that is, terms containing variables. Models support two modes of execution. The first one, called forward chaining operates as follows: When an input term matches a LT, the executive produces an output, a prediction, patterned after the RT. In this mode, inputs can be facts holding any kind of payload, except goals. The other mode is called backward chaining: When an input goal matches a RT, an output is produced, a sub-goal, patterned after the LT. Additionally, when an input (other than a goal or a prediction) matches a RT, an assumption is produced, patterned after the LT. An assumption is a fact whose likelihood value is computed in a particular way (detailed in section 5.2.4). Notice that multiple instances of both forward and backward chaining can be executed concurrently by a given model \u2013 i.e. a model can produce several predictions from several different inputs while producing several goals and assumptions, from several other inputs at the same time. In addition to their two patterns LT and RT, models contain two sets of equations, called guards. These are equations meant to assign values to variables featured in the output, from the values held by variables in the input. One set of guards supports forward chaining, whereas the other one supports backward chaining. In our current implementation, guards are restricted to linear functions.\nThe bootstrap code - the initial resource for the system - contains (among other things) drives and top-level models. A drive is an \u201cinnate\u201d top-level goal given by the programmer, and whose semantics can also be of a constraint. A drive is essentially a goal whose payload is a fact that cannot be observed \u2013 think for example of the drive \u201ckeep operating successfully\u201d: it is very unlikely that the environment will ever produce explicit evidences of such a state. That is where top-level models come into the picture: these help a fresh AERA-based system get started learning in a new domain. More specifically, a top-level model is hand-crafted for giving the system a way to entail the success (or failure) of a drive from an observable (such an observable could be \u201cyour owner gives you a reward\u201d). As an AERA-based system is event-driven, drives and top-level models form together the system\u2019s motivation, providing a top-\nRUTR-SCS13006 15/56\ndown impetus for the system's running, while sensors provide an influx of data, driving its operation bottom-up.\nDepending on their respective patterns, models form control hierarchies based on pattern affordances: The output of one model can match a pattern of another and so on (see Figure 4). Such a hierarchy is traversed by two concurrent flows of information, bottom-up (inputs from the environment at the bottom, to the top-level models) and top-down (from the top-level models to commands).\nA hierarchy of models is depicted. Models are built from two patterns, lefthand and right-hand. These patterns are denoted using capital letters (their parameters and guards are omitted here for clarity). Top-level models are hand-crafted (as part of the bootstrap code), the vast majority of the rest of the models, which for a deployed system can run in the thousands, is learned. Motivated by drives (one is represented here as the black dot at the top), models produce sub-goals when super-goals match their right-hand pattern, and these sub-goals in turn match other models\u2019 right-hand pattern until a sub-goal produces a command for execution by I/O devices. In parallel to this top-down flow of data, the hierarchy is traversed by a bottom-up data flow, originating from inputs sensed by the I/O devices that match the left-hand patterns of models, to produce predictions that in turn match other models\u2019 left-hand patterns and produce more predictions.\nWhenever a model produces a prediction, the executive also produces a corresponding instantiated model: This is a term containing a reference to the model in question, a reference to the input that matched its LT and a reference to the resulting prediction. Such a reflection of operation constitutes a first-class input \u2013 i.e. an observable of the system\u2019s own operation - which is, as any other input, eligible for abstraction (by replacing values with variables bound together by guards) thus yielding a pattern that can be embedded in a model.\nWhen a model M0 features such an instantiated model M1 as its LT then, in essence, M0 specifies a post-condition on the execution of M1, i.e. M0 predicts an outcome that is entailed by the execution of M1. In case the LT is a counter-evidence of a model\u2019s execution (meaning that the model failed to execute because despite having matched an input, its pre-conditions were not met \u2013 pre-conditions are explained immediately here below), the post-condition is referred to as a negative post-condition, positive\nRUTR-SCS13006 16/56\notherwise. Symmetrically, when a model features an instantiated model as its RT, it essentially specifies a pre-condition on the execution of the embedded model instance, i.e. when a condition is matched (LT), the model predicts the success or failure of the execution of a target model (the one an instance of which is the RT). More specifically, what a pre-condition means is \u201cif the target model executes, it will succeed (or fail)\u201d. In case the RT is a counter-evidence of a model\u2019s successful execution (predicted failure), the pre-condition is referred to as a negative precondition, positive otherwise.\nEach time a model produces a prediction, the executive injects a trace of its execution called an instantiated model (noted iM0 for the model M0). The execution of the positive pre-condition M1 enables the execution of M0 whereas the execution of the negative pre-condition M2 inhibits it.\nThe execution of M0 is an input matching the left-hand pattern of the postcondition M3, thus triggering a prediction patterned after C, the right-hand pattern of M3. If M0 matches an instance of its left pattern A but its preconditions are not met, then the executive produces an input |iM0, which means \u201cfailure to execute\u201d. This input can match the left pattern of a model (here M4) and trigger some prediction (that would be patterned after D).\nControl with pre-conditions consists of ensuring that all negative pre-conditions and at least one positive one are satisfied before deciding to let the controlled model operate. This decision is made by comparing the greatest likelihood of the negative pre-conditions to the greatest likelihood of the positive ones."}, {"heading": "4.3 Scheduling", "text": "A job in AERA is a request for processing one input by one program (for example, a model). All jobs (like for example, forward and backward chaining) are assigned a priority that governs the point(s) in time when they may be executed. Jobs are uninterruptible but might get delayed and even eventually discarded if they become irrelevant. Jobs\u2019 priorities are continually updated, thus allowing high-value new jobs to get executed before less important jobs, and old jobs to become more valuable than newer ones as new evidences constantly accumulates. Thus a job priority depends on the utility value of the program and the expected value of the input (these values are explained below). Value-driven scheduling stands at the very heart of our design and underpins our aim of looped-back adaptation and cognition.\nChaining jobs are some of the numerous jobs AERA can schedule; we will encounter more of these below. Our present concern is to describe the operation of a model hierarchy, which is best understood by looking at the scheduling of the chained jobs.\nInputs are assigned a control value called urgency, defined as follows:\nRUTR-SCS13006 17/56\n\ud835\udc47\ud835\udc3b\ud835\udc4d(\ud835\udc65, \ud835\udc61) = { \ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52_\ud835\udc51\ud835\udc52\ud835\udc4e\ud835\udc51\ud835\udc59\ud835\udc56\ud835\udc5b\ud835\udc52(\ud835\udc65) \u2212 \ud835\udc61, \ud835\udc61 < \ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52_\ud835\udc51\ud835\udc52\ud835\udc4e\ud835\udc51\ud835\udc59\ud835\udc56\ud835\udc5b\ud835\udc52(\ud835\udc65)\n0, \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52\n\ud835\udc48\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc50\ud835\udc66(\ud835\udc65, \ud835\udc61) = 1 \u2212 \ud835\udc47\ud835\udc3b\ud835\udc4d(\ud835\udc65, \ud835\udc61)\nMax \ud835\udc56 (\ud835\udc47\ud835\udc3b\ud835\udc4d(\ud835\udc65\ud835\udc56 , \ud835\udc61)) + \ud835\udc48\nWhere \ud835\udc47\ud835\udc3b\ud835\udc4d stands for \u201ctime horizon\u201d and where \ud835\udc61 is the time of evaluation of the functions, \ud835\udc65 an input, \ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52_\ud835\udc51\ud835\udc52\ud835\udc4e\ud835\udc51\ud835\udc59\ud835\udc56\ud835\udc5b\ud835\udc52(\ud835\udc65) the upper bound of \ud835\udc65 \u2019s time interval and \ud835\udc65\ud835\udc56 all the inputs in the system. \ud835\udc48 (\ud835\udc48 > 0) is a parameter of the system meant to prevent the urgency of the input with the highest time horizon from being zero.\nEquation 1\nInputs, in case their life time expires, are not deleted if they have been scheduled for processing and the corresponding job is still in the jobs list and has not been cancelled. A model is assigned a control value, its reliability, defined as the number of times the model predicted correctly (i.e. the positive evidences of its correct operation) divided by the total number of prediction attempts (total number of evidences) plus one:\n\ud835\udc45\ud835\udc52\ud835\udc59\ud835\udc56\ud835\udc4e\ud835\udc4f\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc61) = \ud835\udc52+(\ud835\udc5a, \ud835\udc61)\n\ud835\udc52(\ud835\udc5a, \ud835\udc61) + 1\nWhere \ud835\udc5a is a model, \ud835\udc52+(\ud835\udc5a, \ud835\udc61) the number of positive evidences for the operation of \ud835\udc5a and \ud835\udc52(\ud835\udc5a, \ud835\udc61) the total number of evidences, both evaluated at time \ud835\udc61. The reliability is actually the product of the success rate of the model ( \ud835\udc46\ud835\udc62\ud835\udc50\ud835\udc50\ud835\udc52\ud835\udc60\ud835\udc60\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52(\ud835\udc5a, \ud835\udc61) = \ud835\udc52+(\ud835\udc5a,\ud835\udc61)\n\ud835\udc52(\ud835\udc5a,\ud835\udc61) ) and its experience\n(\ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc52\ud835\udc5b\ud835\udc50\ud835\udc52(\ud835\udc5a, \ud835\udc61) = \ud835\udc52(\ud835\udc5a,\ud835\udc61)\n\ud835\udc52(\ud835\udc5a,\ud835\udc61)+1 ).\nEquation 2\nThe likelihood of a goal (its likelihood to be reached) or of a prediction (its likelihood to come true) is defined as the product of the reliability of the models that were involved in the chaining having produced said goal or prediction:\n\ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61) = \u220f \ud835\udc45\ud835\udc52\ud835\udc59\ud835\udc56\ud835\udc4e\ud835\udc4f\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a\ud835\udc56(\ud835\udc65), \ud835\udc61)\n\ud835\udc56\nWhere \ud835\udc65 is a goal or a prediction, \ud835\udc5a\ud835\udc56(\ud835\udc65) are the models forming the chain that produced \ud835\udc65 from an initial input (a drive if \ud835\udc65 is a goal, a sensory or internal input if \ud835\udc65 is a prediction); \ud835\udc61 is the time at which the function is evaluated. The likelihood of a sensory/internal input is 1 whereas the one of a drive is defined by the programmer.\nEquation 3\nWe define the expected value of an input (all kinds, except goals) as the product of its urgency and its likelihood:\n\ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc52\ud835\udc51\ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52(\ud835\udc65, \ud835\udc61) = \ud835\udc48\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc50\ud835\udc66(\ud835\udc65, \ud835\udc61) \u00d7 \ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc66\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61)\nWhere \ud835\udc65 is an input and \ud835\udc61 the time the function is evaluated.\nEquation 4\nThe likelihood of a goal, as defined as above, helps the system qualify its experience as it combines the reliability of models, but another valuable source of information is conveyed by the predictions of reaching a desired state. The likelihood of a goal must therefore be redefined to combine both of these two sources of information, the\nRUTR-SCS13006 18/56\nrationale being to lower the expected value of pursuing a goal if the system is predictably more likely to reach the desired state by other means than deriving subgoals from the goal in question:\n\ud835\udc3f\ud835\udc52\ud835\udc61 \ud835\udc43(\ud835\udc65, \ud835\udc61) = Max \ud835\udc56 (\ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc5d\ud835\udc56 , \ud835\udc61))\n\ud835\udc36\ud835\udc5c\ud835\udc5a\ud835\udc4f\ud835\udc56\ud835\udc5b\ud835\udc52\ud835\udc51\ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61)\n= { \ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61), \ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61) \u2265 \ud835\udc43(\ud835\udc65, \ud835\udc61)\n1 \u2212 \ud835\udc43(\ud835\udc65, \ud835\udc61), \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52\n\ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc52\ud835\udc51\ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52(\ud835\udc65, \ud835\udc61) = \ud835\udc48\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc50\ud835\udc66(\ud835\udc65, \ud835\udc61) \u00d7 \ud835\udc36\ud835\udc5c\ud835\udc5a\ud835\udc4f\ud835\udc56\ud835\udc5b\ud835\udc52\ud835\udc51\ud835\udc3f\ud835\udc56\ud835\udc58\ud835\udc52\ud835\udc59\ud835\udc56\u210e\ud835\udc5c\ud835\udc5c\ud835\udc51(\ud835\udc65, \ud835\udc61)\nWhere \ud835\udc65 is a goal, \ud835\udc5d\ud835\udc56 the predictions of \ud835\udc65\u2019s target state and \ud835\udc61 the time the function is evaluated.\nEquation 5\nThe priority of a forward chaining job (matching an input with the LT of a model) is the product of the expected value of the input and what we call the utility of a model - that is, the (normalized) maximum of the expected values of the goals the model has produced so far and that have still not been achieved. It is worth noting that the utility of a model accounts for the value of executing the model for the system as a whole, as it combines the expected values of all the goals currently pursued by the system:\n\ud835\udc3f\ud835\udc52\ud835\udc61 \ud835\udc48\ud835\udc5b\ud835\udc5b\ud835\udc5c\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc59\ud835\udc56\ud835\udc67\ud835\udc52\ud835\udc51\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc47, \ud835\udc61) = Max \ud835\udc56 (\ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc52\ud835\udc51\ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52(\ud835\udc65\ud835\udc56(\ud835\udc47, \ud835\udc5a), \ud835\udc61))\n\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc47, \ud835\udc61) = \ud835\udc48\ud835\udc5b\ud835\udc5b\ud835\udc5c\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc59\ud835\udc56\ud835\udc67\ud835\udc52\ud835\udc51\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc47, \ud835\udc61)\nMax \ud835\udc56 (\ud835\udc48\ud835\udc5b\ud835\udc5b\ud835\udc5c\ud835\udc5f\ud835\udc5a\ud835\udc4e\ud835\udc59\ud835\udc56\ud835\udc67\ud835\udc52\ud835\udc51\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a\ud835\udc56 , \ud835\udc47, \ud835\udc61))\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc39\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51\ud835\udc36\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54(\ud835\udc65, \ud835\udc5a, \ud835\udc61) = \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc3a\ud835\udc5c\ud835\udc4e\ud835\udc59\ud835\udc60, \ud835\udc61) \u00d7 \ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc52\ud835\udc51\ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52(\ud835\udc65, \ud835\udc61)\nWhere \ud835\udc5a is a model, \ud835\udc47 a class of outputs (either Predictions or Goals), \ud835\udc65\ud835\udc56(\ud835\udc47, \ud835\udc5a) the outputs in \ud835\udc47 produced by \ud835\udc5a, \ud835\udc5a\ud835\udc56 the models in the system, \ud835\udc65 an input and \ud835\udc61 the time the function is evaluated.\nEquation 6\nThe priority of a backward chaining job is the product of the expected value of the incoming goal and the utility of the model, the latter being the (normalized) maximum expected value of the predictions produced so far by the model. As in the case of forward chaining, the utility of a model has here also a system-wide significance as it corresponds intuitively, in the present case of backward chaining, to the \u201cfocus\u201d of a system on data that may fulfill its \u201cdesires\u201d (i.e. drives and derived sub-goals); in other words the system\u2019s attention is accounted for by the utility values of all the models in the system and the expected values of its current goals (see section 5.1):\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc35\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51\ud835\udc36\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54(\ud835\udc65, \ud835\udc5a, \ud835\udc61) = \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc43\ud835\udc5f\ud835\udc52\ud835\udc51\ud835\udc56\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b\ud835\udc60, \ud835\udc61) \u00d7 \ud835\udc38\ud835\udc65\ud835\udc5d\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc52\ud835\udc51\ud835\udc49\ud835\udc4e\ud835\udc59\ud835\udc62\ud835\udc52(\ud835\udc65, \ud835\udc61)\nWhere the parameters and functions are defined as in Equation 6 above.\nEquation 7\nConceptually, the scheduler\u2019s operation can now be described as follows: It is a list of jobs and a set of worker threads (in the sense of operating system threads) which pick up the highest priority jobs for processing, as a result of which new jobs can possibly be inserted in the list. Job priorities are re-computed frequently, as they depend on time and on the current activity of the system (essentially, the assessment of the model performance, and the set of the current goals). It is worth noting that some jobs may get delayed repeatedly until their priority drops down to insignificant numbers (for\nRUTR-SCS13006 19/56\nexample when the urgency of a goal becomes zero, i.e. when its deadline has expired) and eventually get cancelled. This is likely to happen in situations where either the CPU power becomes scarce or the number of jobs exceeds the available computing power \u2013 which is the expected fate of any system limited in both knowledge and resources.\nThe matching 4 of one input and the input pattern of one program triggers the creation of a job which is inserted in the scheduling list. Worker threads extract the highest priority jobs and execute them. This results in the production of new inputs (goals, predictions, reflective inputs, etc.) and programs that fuel in turn the production of new jobs. Notice that priorities are dynamic \u2013 they depend both on time and on the everchanging utility values of all the programs in the entire system - and are thus recomputed frequently.\nSome jobs are not controlled by priorities but by time events instead (see section 5.2). The system maintains a separate list of such time-triggered jobs executed by a dedicated pool of threads (not represented here).\nIn the main, job priorities depend on the past experience of the system (the models and their reliability), the urgency of the inputs and the current activity of the system (in the form of the models\u2019 utility values). It follows that, all other values being equal, chaining jobs involving the best models will be scheduled first. Jobs involving inputs that are relevant to the system\u2019s operation will also be scheduled first. This is to highlight the fact that the plasticity of computation is achieved by (a) fine-grained jobs and (b) the current activity of the system, which, by design is (c) constrained by (practically unavoidable) limitations on knowledge (number and reliability of the models) and resources (time, memory and available inputs).\nIn addition to the aforementioned prioritization strategy, we use two ancillary control mechanisms. These come in the form of two thresholds, one on the likelihood of terms, the other on the reliability of models. When a term\u2019s likelihood gets under the first threshold, it becomes ineligible as a possible input for pattern matching; reciprocally, when the reliability of a model gets under the second threshold, it cannot process any input \u2013 it is deactivated until said second threshold is increased. These thresholds are a filtering mechanism that operates before priorities are computed (the precise operation of these is beyond the scope of the present paper). The executive exposes functions to modify these thresholds as internal commands that can be executed by models, like any other command on effectors in the environment.\n4 Matching is attempted by the executive immediately upon the generation of either a program or an input.\nRUTR-SCS13006 20/56"}, {"heading": "4.4 Abstraction", "text": "Models are fully abstracted since their patterns contain only variables. This means for example, that any particular input data matching a model\u2019s LT will trigger a prediction. A model may thus produce correct predictions for a subset of the matching inputs, and produce incorrect predictions for the rest of these inputs. Now, as we briefly mentioned in section 4.1 above, models are discarded when their predictions become too unreliable. This indicates that over-fitting the inputs can be dangerous for a model: A model that predicts correctly in some cases can still be discarded because it predicts incorrectly in some other cases.\nTo avoid over-fitting, the scope of models is restricted on a case-by-case basis, meaning that the history of relevant inputs is used to determine whether a model can be executed or not. Relevant inputs are the inputs that have been processed by a model (using forward chaining) and identified as having led to the success or the failure of said model. Case-based control is encoded using models, the only difference with the models as described so far being that they are partially instantiated: Their LT can contain values taken from the historical inputs that have been used to build them. Such partially instantiated models constitute historical preconditions on the target model (see Figure 7).\nThe history of the execution of the model M0 is captured by other models: These feature left-hand patterns that are less abstracted than the source pattern A in M0: They are the actual inputs that triggered the production of predictions by M0, some having been successful (case of a0 and a1), some not (case of a2 \u2013 recall that |iMo means \u201cfailure of M0\u201d). M1, M2 and M3 are historical pre-conditions on M0.\nUsing partially instantiated models as pre-conditions introduces too much rigidity. For example, in the case depicted in Figure 7, only inputs matching exactly a0 or a1 will allow the model M0 to be executed. This means that any other input differing ever so slightly from the known positive evidences (a0 and a1) will be ignored. If such inputs were later identified as actually leading to the success of the model, then new models would have to be acquired and added to the system, possibly leading to an undesired proliferation of models. We address this issue in the following way. As experience accumulates, the system creates new models representing abstractions of the original partially instantiated models discussed so far. These new models contain more variables than their original and thus are able to match inputs that differ to some extent from known positive evidences; in that sense they are less specified and more flexible than their originals. The construction of flexible models is triggered by the accumulation of new evidences that differ from the known ones while still agreeing on at least one value: Such a new model is copied from the original model and differences between values held by the conflicting evidences are represented by variables introduced in the new model (see Figure 8 for an illustration).\nTo illustrate the abstraction process, we will take a reasonably realistic but simplified example that explains some of the key principles described so far. Suppose an AERA-\nRUTR-SCS13006 21/56\nbased system is interested in knowing which bus to take for going to Reykjavik University. Let M0 be a model saying \u201cany bus of color C, number N and license plate L will go to the university\u201c (i.e. its left-hand pattern A has three variables C, N and L - its right-hand pattern B being irrelevant for the present discussion). Now assume the system observes four occurrences of the execution of M0, the first two being positive evidences and the last two negative ones: a0 = A(yellow, 19, SX445), a1 = A(yellow, 19, KH203), a2 = A(yellow, 14, PK238) and, a3 = A(yellow, 15, UH714); see Figure 8.\nSee text for details.\nThe success of iM0(a0) creates the historical pre-condition M1 with a0 as its left pattern. Upon the success of iM0(a1), the system attempts to match a1 against known positive evidences, here a0: One value differs (the value of variable L) and a new pre-condition is created: M2 with a left pattern a4 = A(yellow,19,L). The reliability of M2 is computed as the number of times M2 was an effective pre-condition on M0, divided by one plus the number of effective pre-conditions \u2013 here 2/3. M2, M1 and M\u20181 are now three competing pre-conditions on M0 (Figure 8-A) and their fate will depend on subsequent\nRUTR-SCS13006 22/56\nevidences: Shall the particular cases (M1 and M\u20181) turn out to be actually anecdotal (in our example, the license plate is actually irrelevant) then they will be dismissed on the basis of their relatively poor performance (or usage 5 ) and the general case (M2) will prevail \u2013 by the means of the standard operation of prediction monitors.\nSymmetrically, the failure of iM0(a2) creates the pre-condition M3 with the left pattern being a2 (Figure 8-B). Upon the failure of iM0(a3), the system attempts to match of a3 against known negative evidences (here a2): Two values differ (the values of N and L) and a new pre-condition is created with a5 = A(yellow, N, L) as its left pattern, M4, coexisting with M3 with a reliability of 2/5, calculated as in case A. The reliability of M2 is recomputed (since new evidences have been observed) and is now also 2/5. Notice that another model, M5, is created and inhibits M4: The negative evidence a5 is an abstraction of a positive one, a4, and therefore M2 shall be prevented to be considered a sub-case of M4. If reality proves that only buses of line 19 actually reach the desired location, then M3 and M3\u2019 will eventually be discarded, leaving only M4 to handle counter-evidences.\nFlexible historical pre-conditions state, essentially, that some variables are irrelevant. This finds an operational incarnation with respect to backward chaining: Sub-goals targeting atomic states containing at least one variable and derived from pairing super-goals with historical pre-conditions are given an expected value of zero \u2013 meaning that they will not trigger further chaining 6 . This translates as follows in our example: Saying the system is \u201cinterested\u201d in reaching its desired location (here, an instance of B) means operationally that it pursues a goal G patterned after A. Now, let us assume the pattern A is actually a conjunction of facts \u2013 an instance of a composite state whose components (atomic states) would be (a) an entity with a color C, (b) bearing a line number N, (c) with license plate number L. Only backward chaining jobs triggered by the sub-goals targeting (a) and (b) would draw the system\u2019s attention \u2013 goals targeting (c) would be ignored. M0 would fail to execute, but the goal G would still be achieved unexpectedly, thus triggering the acquisition of a new model M\u20190: A\u2019  B where A\u2019 would be a subset of A, featuring only the variables C and N, but not L as in M0 (Figure 8-C). Section 5.2.2 provides a description of backward chaining through composite states and section 5.2.5 a detailed description of model acquisition. A system operating as in this example with limited resources would naturally focus on the (goal-)relevant inputs and produce more efficient models: (a) M\u20190 is more focused than the models depicted in case B \u2013 it requires less computing power, inputs and time to match its LT (two variables instead of three) and, (b) we would now have only one single model instead of four (which again demands less CPU, inputs, and time).\nWe close this section on a last technical note about time. One major source of uncertainty is the time at which events occur. Too rigid a temporal prediction production scheme would result in many model failures \u2013 the world never repeats itself, at least not at the microsecond scale \u2013 and eventually, would result in the dismissal of models that, under less stringent precision constraints, would be more accurate. We address this issue in the following way: When inputs are successfully matched against abstract pre-conditions, the time guards thereof are recalculated using the average of the time intervals of the evidences. If some models eventually turn out to capture generality \u2013 meaning in this context that their predictions shall actually be robust to variations of the execution timings \u2013 then the aforementioned guard adjustment will trade precision for accuracy. Conversely, if reality calls for precision \u2013 i.e. the scope of models is temporally narrower and their predictions more brittle with respect to the execution timings \u2013 then this will be reflected in the evidences on which they were based: These will present lesser timings variations and\n5 As introduced in section 4.1, models can be dismissed when they become the least recently used. 6 Implementation-wise, such goals will not even be produced.\nRUTR-SCS13006 23/56\nthe less general models in question would remain as precise as need be, while retaining accuracy."}, {"heading": "5 Architecture", "text": "We now turn to describe the set of programs that implement the principal higher-level cognitive functions of the architecture, learning, planning, and attentional control.\nAs already described, the main components of AERA are its executive and memory, the latter containing inputs (both external and internal), predictions, goals, programs (models, monitors, etc.) and a collection of jobs. The executive uses these elements to (a) maintain and improve the system by adding/removing models to/from the memory, and by (b) controlling the priorities of all the jobs while (c) achieving the goals the system has set itself to fulfill the drives (top-level goals) given by the programmer.\nBesides low-level technical components (scheduler, threads, etc.) the executive contains (fixed) algorithms, that are parameterized by jobs, to create programs such as chaining, monitoring, and pattern extraction programs (defined in section 5.2). Models and composite states are also programs, even though they don\u2019t result from any parameterization: They are instead either given in the bootstrap code (shown here in grey), or learned. The inputs of the system consist of (a) sensory inputs, (b) goals and predictions produced by jobs and, (c) internal inputs produced by the executive (including instantiated models, instantiated composite states,\nRUTR-SCS13006 24/56\nsuccess/failure of goals and predictions, performance assessments, etc., as explained in the preceding sections). Drives also constitute inputs, and are given in the bootstrap code (in grey).\nA running AERA system faces three main challenges: (a) To update and revise its knowledge based on its experience, (b) to cope with its resource limitation while making decisions to satisfy its drives and, (c) to focus its attention on the most important inputs, discarding the rest or saving them for later processing. These three challenges are commonly addressed by, respectively, learning, planning, and controlling the attention of the system. Notice that all of these activities have an associated cost and have to be carried out concurrently. All these activities fit to some extent into the resource- and knowledge budget the system has at its disposal. That is the reason why they have been designed to result from the fine-grained interoperation of a multitude of lower-level jobs, the ordering of which is enforced by a scheduling strategy. This strategy has been designed to get the maximal global value for the system from the available inputs, knowledge, and resources, given (potentially conflicting) necessities. The list of jobs, their purpose, and scheduling priorities, is given in section 5.2.\nLearning 5.1.1\nLearning involves several phases: Acquiring new models, evaluating the performance of existing ones, and controlling the learning activity itself. Acquiring new models is referred to as pattern extraction, and consists of the identification of causal relationships between input pairs: Inputs which exhibit correlation are turned into patterns and used as the LT and RT of a new model. Model acquisition is triggered by either the unpredicted success of a goal or the failure of a prediction. In both cases AERA will consider the unpredicted outcome as the RT of new models and explore buffers of historical inputs to find suitable LTs. Once models have been produced, the system has to monitor their performance (a) to identify and delete unreliable models and, (b) to update the reliability as this control value is essential for scheduling (as described in section 4.3 above). Both these activities \u2013 model acquisition and revision \u2013 have an associated cost, and the system must allocate its limited resources to the jobs from which it expects the most value. Last but not least, the system is enticed to learn, based on its experience, about its progress in modeling inputs. The system computes and maintains the history of the success rate for classes of goals and predictions, and the priority of jobs dedicated to acquire new models is proportional to the first derivative of this success rate (this is detailed in section 5.2.5).\nPlanning 5.1.2\nPlanning concerns observing desired inputs (the states specified by goals) by acting on the environment (i.e. issuing commands) to achieve goals in due time in adversarial conditions, like for example the lack of appropriate models, underperforming models, conflicting or redundant goals, and lack of relevant inputs. Planning is initiated and sustained by the regular injection of drives (as defined by the programmer), thus putting the system under constant pressure from both its drives and its inputs. In our approach, sub-goals derived from goals are simulated, meaning that as long as time allows, the system will run \u201cwhat if\u201d scenarios to predict the outcome of the hypothetical success of these simulated goals, checking for conflicts and redundancies, eventually committing to the best goals found so far and discarding other contenders. Here again, goals are rated with respect to their expected value. Simulation and commitment operate concurrently with (and also make direct use of) forward and backward chaining.\nRUTR-SCS13006 25/56"}, {"heading": "Attentional Control 5.1.3", "text": "A cognitive system generally does not have enough time to process all the inputs it receives, whether from its sensors or in the form of internal inputs, and thus must make a choice to focus its computational resources on the most relevant ones at any point in time. The \"interest\" or importance of an input depends on the global activity of the system, that is, the set of jobs scheduled to process the input in question: Interesting inputs are the ones processed by high-priority jobs. In our approach, attentional control results directly from its scheduling mechanism, through re-ordering of jobs in accordance with their priorities. Attention, as implemented in in AERA, is transversal and job-independent: The same attention control is uniformly used for all and any kinds of jobs in the system. For example, attention is required for learning new models but also \u2013 at the same time \u2013 for planning appropriate courses of action. Attention control is not exclusively based on job priorities, as it results also from selecting proactively sources of inputs in the environment by manipulating the sensing devices. This is achieved by configuring the various sensors the systems has at its disposal by means of issuing commands, computed by backward chaining jobs that are themselves derived from the models, i.e. the procedural knowledge the system has learned (or has been given) so far. All jobs are intertwined in the scheduler\u2019s list and therefore contribute altogether to the focus of attention, via the definition of their priority values. As emphasized in section 4.3, job priorities are ultimately derived from the expected value of the system\u2019s goals, that is to say that the attentional control is explicitly goal-driven."}, {"heading": "5.2 Programs", "text": "This section presents the various types of programs that implement the cognitive functions mentioned above. As described above, a program is a small component of the architecture that specifies one or several input patterns \u2013 for example, a model is one type of program. A job results from the pairing of one input and one program: This is triggered by pattern matching, which is performed continually by the executive, each time an input or a program is injected in the system. Once created, a job awaits execution. If it is eventually executed, the resulting process cannot be interrupted nor preempted at the architecture level. 7 The execution of a job can produce new terms that constitute inputs for the system (for example, goals and predictions), thus triggering pattern matching and therefore the creation of new daughter jobs. Before being executed, a job can be cancelled for various reasons \u2013 the most frequent reasons being (a) its input is cancelled, for example, when resolving the conflict between two goals, the system will cancel one of these goals and the jobs for which it was the input, (b) the program it results from is deleted (for example, models can be deleted if their performance becomes unsatisfactory) and, (c) its priority drops down to zero.\nPrograms are created dynamically by jobs. Creating a program means parameterizing an algorithm with a specific input pattern \u2013 such algorithms are fixed and are part of the executive, with the two notable exceptions of models and composite states, which are either defined by the programmer as part of the bootstrap code, or learned. For example, when a job produces a prediction from an input and a model, a monitoring program is created to assess the outcome of that very prediction: It will react to inputs that are evidences (or counter-evidences) of the predicted fact and update the reliability of the model accordingly. Programs are deleted when they become useless; for example, monitors are deleted when the deadline of the expected fact is reached,\n7 In our current implementation the thread that a job belongs to is still subjected to the operating\nsystem\u2019s scheduling events.\nRUTR-SCS13006 26/56\nand models are deleted when they become too unreliable (see more details on this in section 5.2.3).\nThe architecture uses two kinds of jobs: priority-controlled jobs (like the ones presented in section 4.3 above) and time-triggered jobs. The execution of the latter is not governed by priorities but is triggered by time events \u2013 technically they are locked on timers. These jobs are executed immediately upon triggering and are dedicated to perform timely assessments of expected or desired states. For example, they assert the success or failure of predictions at their deadlines based on the evidences accumulated so far (see sections 5.2.3 and 5.2.4).\nModel 5.2.1\nAs already mentioned, a model is a program that, when paired with an input matching its LT, produces a forward chaining job and, when paired with an input matching its RT, produces a backward chaining job. These jobs have been introduced in section 4.3 above and are now complemented with greater details.\nForward chaining through models is the processing of one input matching the LT of a model to produce a prediction patterned after its RT. In addition to the prediction another term is produced, an instantiated model, i.e. a trace of the (forward) execution of the model thus instantiated, its input and its output. As mentioned earlier, such a trace of execution constitutes an internal input and can be abstracted to form a pattern that in turn can be embedded in any model as its pre- and post-conditions. In case a model has pre-conditions, the executive checks if these conditions are met before executing the model. If so, chaining occurs as described above, otherwise the prediction is produced in silent mode, meaning that both the model execution and the prediction itself will be invisible to other programs. The purpose of this mode is to monitor the outcome of the prediction and possibly register an unexpected success or failure of the pre-conditions, which will trigger the acquisition of new models (see section 5.2.5). For each prediction, a prediction monitoring program is created (see section 5.2.3) to assess the outcome of the prediction. The job priority for forward chaining has already been given in section 4.3, Equation 6.\nBackward chaining through models is the processing of one input matching the RT of a model to produce a sub-goal if the input is a goal or an assumption otherwise. Before committing to a particular goal the system needs to evaluate its possible outcomes to detect and resolve potential conflicts with other goals, and also to select the best next sub-goal when there are multiple ways to achieve it. When a sub-goal is produced from a super-goal it is tagged with a simulation mark until it is either cancelled (for example when it conflicts with other more important goals) or committed to. Each time a simulated goal is produced a corresponding prediction is also produced: This prediction is also marked as a simulation and is used by the system to evaluate the consequences of reaching the (simulated) goal in question. Simulated predictions do not trigger the creation of prediction monitors, as no actual event can be expected to confirm the prediction. In case a model has pre-conditions the backward chaining job is not produced before the conditions are met. For each goal a goal monitoring program is created (see section 5.2.4) to assess the outcome of that goal (whether simulated or actual). If the input of the job is not a goal, then the system will assume an instance of the LT, with a likelihood computed as for a goal (section 4.3, Equation 7)."}, {"heading": "Composite state 5.2.2", "text": "As introduced in section 4.1, a composite state encodes the conjunction of several facts, including facts whose payloads are instances of other composite states, thus allowing the creation of structural hierarchies. A composite state is a program with several input patterns, one per fact. Like models, composite states produce forward\nRUTR-SCS13006 27/56\nand backward chaining jobs when paired with some inputs.\nForward chaining through composite states is triggered by the matching of one input (any kind but goals) with one of the patterns. This in turn produces a new composite state, namely a partial composite state, copied from the original, with one input pattern less (the one that has been matched by the input, hence the term \u201cpartial\u201d) \u2013 note that the original is not deleted and remains a legitimate target for matching more inputs. When a partial composite state has only one input pattern left un-matched and matches an input with that pattern, then the executive produces an internal input, e.g. an instantiated composite state, which indicates that an instance of the conjunction of facts specified by the composite state has been observed. If one of the inputs was a prediction then the instantiated composite state becomes a prediction instead of a mere fact. The likelihood of the instantiated composite state is the lowest likelihood of all the inputs that were matched. Composite states are deleted if they have no input pattern left or if the late deadline of one of the inputs they matched has been reached. The priority of a forward chaining job through a composite state is defined as for a model (Equation 6) where the composite state is substituted for the model in the Utility function.\nBackward chaining through composite states is triggered in two conditions. First, a goal matching one input pattern of a composite state triggers the production of other goals patterned after the input patterns that have not been matched yet (even though these goals are in effect \u201cside-goals\u201d of the incoming goal, for practical reasons they are treated as sub-goals). The rationale behind this behavior is to entice the system to find situations (conjunctions of facts) that include the goal\u2019s target state: Composite states are learned as conjunctions of facts that explain unpredicted states (see section 5.2.5) so it is not a bad idea to try to replicate such a conjunction as targeting one component thereof may entail the observation of another of these components. For example, if we encode in a composite state several attributes of a given entity \u2013 say, a bus of a certain color, with a license plate and a line number \u2013 then, when trying to find one of these attributes (for example, when trying to spot a bus) uncovering its related attributes may be helpful \u2013 in this example, finding a bus will be easier when also trying to find objects with a license plate and a line number. The second case that triggers backward chaining is when a goal targets the instantiation of a composite state instead of one of the state\u2019s individual components. In that case, backward chaining occurs as in the first case and applies to the partial states corresponding to the state the system seeks to instantiate. The priority of a backward chaining job through a composite state is defined as for a model (Equation 7) where the composite state is substituted for the model in the Utility function."}, {"heading": "Prediction Monitor 5.2.3", "text": "A prediction monitor has one input pattern, the prediction it monitors. Pairing one actual input (i.e. a sensory or internal input) with the prediction monitor creates a prediction monitoring job. The priority of a prediction monitoring job is the same as the priority of its mother job (a forward chaining job). The purpose of a prediction monitor is threefold.\nFirst it accumulates evidences or counter-evidences of the predicted fact during the predicted time interval, to assess the performance of the model that made the prediction by increasing or decreasing its reliability. Among the accumulated evidences, the evidence (or counter-evidence) holding the highest likelihood value dictates the judgment. If no evidences and no counter-evidences of what was predicted have been observed, then a failure is declared. The assessment is performed by a time-triggered job \u2013 a prediction assessment job - at the late deadline of the prediction. This job produces an internal input, a fact indicating the success or failure of the model. In case of a failure, all the predictions that have been produced directly or indirectly from the failed prediction are cancelled and so are the jobs for\nRUTR-SCS13006 28/56\nwhich they are the input.\nIf the reliability of a model drops below a threshold THR1 then it is phased out: In this mode the model can only create forward chaining jobs and produce silent predictions that will not be eligible inputs to the regular models (i.e. models that are not phased out). Silent predictions are still monitored, thus giving the possibility to improve to a model that was recently getting unreliable. If the reliability of a phased out model gets above THR1, then it is not phased out anymore and resumes its standard operation. When the reliability of a phased out model drops below a second threshold THR2 (THR2 < THR1) then the model is deleted as are all the programs that were created to manage its productions; the corresponding jobs are cancelled. The way the reliability is defined (see Equation 2) brings some undesired inertia to the switching of modes of operation (phased in or phased out): The more a model has accumulated experience, the more it needs to accumulate future contrary experience to switch modes, because the environment may have changed, making a model temporarily irrelevant but not generally faulty. To address this we implemented a mechanism for reducing switching inertia: In the main, it determines the switch based on reliability computed temporarily using a reference fixed number of evidences 8 , instead of the actual and large number of evidences.\nThe second purpose of a prediction monitor is to maintain abstractions, as described in section 4.4: Upon the success or failure of a prediction produced by a model, the history of the execution of the model is updated, with the possible addition of new preconditions.\nThe third and last purpose of a prediction monitor is to produce evidences of the absence of expected facts: If, at the deadline of the prediction, no evidence of the expected fact has been observed, then the prediction assessment job produces a counter-fact holding the payload of the expected fact. The absence of evidence can result from two causes: Either the environment did not provide such evidences, or it actually did but the system failed to sense them (jobs processing such evidences were cancelled). The likelihood of the latter case is reflected by giving a likelihood value to the counter-fact computed as the utility of the model (see section 4.3, Equation 6)."}, {"heading": "Goal Monitor 5.2.4", "text": "A goal monitor has one input pattern, the goal it monitors. Pairing one input with the goal monitor creates a goal monitoring job. The priority of a goal monitoring job is the same as the one of its mother job (a backward chaining job). Goal monitors come in two variants, one that monitor actual goals (goals already committed to) and one that monitors simulated goals.\nThe purpose of an actual goal monitor is to check if the goal has been achieved or not. To do so, a goal monitor accumulates evidences or counter-evidences of the desired fact and, at the late deadline of the goal, a time-triggered job \u2013 a goal assessment job \u2013 is created to establish the outcome of the goal in the form of an internal input indicating the success or failure of the goal. The decision is based on the evidence (or counter-evidence) holding the greatest likelihood value. When a goal succeeds or fails, its sub-goals are cancelled and so are the corresponding chaining and monitoring jobs.\nIn addition to recording evidences of the success or failure of a goal, a simulated goal monitor also records evidences of the impact of the monitored goal on the success or\n8 Each time the reliability of a model changes, another temporary version of said reliability is computed, using an arbitrary evidence count (defined as a parameter of the system) and a commensurate positive evidence count.\nRUTR-SCS13006 29/56\nfailure of its super-goal. Such evidences are simulated predictions: Assuming temporarily that a goal\u2019s target is achieved, the system predicts the hypothetical outcomes using forward chaining. Simulated predictions reference the simulated goal that triggered them and are eligible inputs for actual goal monitoring as they are required for the actual goal monitor to predict the impact of simulated goals on its own outcome.\nThe decision to commit or not to a simulated goal (G) is based on predictions of its impact on actual goals and requires the super-goal (G0) to be an actual goal. The rules of commitment are (using the commit time as the evaluation time):\n- If there are no predictions of failure of an actual goal, commit to G.\n- If there is a prediction of the failure of an actual goal G1 (i.e. there is a conflict between G0 and G1), and G1 has a greater expected value than G0, then cancel G, otherwise commit to G. Notice that if all sub-goals of G0 were to be cancelled, then G0 would probably fail 9 , which would be\nexpected since it would mean that, achieving G0 using the current knowledge conflicts with more important goals.\n- If there is a prediction of the success of G0 resulting from a goal G2 that is not a sub-goal of G (G and G2 are redundant) and which has a greater expected value than G, then cancel G.\nThe decision to commit is triggered by an event described in Figure 10.\nGoals are monitored by jobs (shown as rounded rectangles) accumulating evidences (or predictions thereof) of their target states being reached (for clarity, only one job per goal is shown here). The figure depicts a path in a goal hierarchy constituted by an actual goal (g0) and three successive sub-goals, the last of which (g3) targets a command.\nA. If the model having produced g3 has no pre-conditions \u2013 or if it does, should these already have been met or predicted \u2013 an assessment job (shown in grey) is triggered at the early deadline of g3 and sends a commit signal to the first simulated goal in the path (g1).\nB. If the system commits to g1, the commit signal is propagated down the path of the hierarchy g3 belongs to. Otherwise, g1\u2019s goal monitor will attempt to commit upon the matching of relevant inputs, in addition to its standard role of accumulating evidences of the goal\u2019s achievement. This additional behavior will cease when g3 is cancelled.\n9 Unless of course an unforeseen event happens to match G0\u2019s target state, in which case G0 would succeed.\nRUTR-SCS13006 30/56\nC. If the system commit to g2, the command held by g3 is executed. Otherwise g2\u2019s goal monitor behaves as in case B."}, {"heading": "Targeted Pattern Extractor 5.2.5", "text": "A pattern extractor is a program that is generated dynamically upon the creation of a goal or a prediction. Its main activity is to produce models, i.e. explanations for the unpredicted success of a goal or the failure of a prediction: these are called the signaling events that trigger the building of models. A single targeted pattern extractor (TPX) is responsible for attempting to explain either the success of one given goal, or the failure of one given prediction. Said goal or prediction is called the TPX's target. Under our assumption of insufficient knowledge, explaining in this case is much closer to guessing than to proving, and guesses are based on the general heuristic \u201ctime precedence indicates causality\u201d. Models thus built by the TPXs are added to the memory and are subjected to evaluation by prediction monitors: Their life cycle is governed essentially by their performance.\nA TPX accumulates inputs from the target production time until the deadline of the target, at which time it analyses its buffer to produce models if needed: The TPX activity is thus composed of two phases, (a) buffering relevant inputs and, (b) extracting models from the buffer.\nDuring the first phase, pairing one input with a TPX creates a TPX-accumulation job which merely adds the input to the TPX buffer for further processing. Input relevancy is defined by its utility, computed as the greatest of the utility values of all models in the system that matched the input in question:\n\ud835\udc3c\ud835\udc5b\ud835\udc5d\ud835\udc62\ud835\udc61\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc65, \ud835\udc61) = { Max \ud835\udc56 (\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a\ud835\udc56(\ud835\udc65), \ud835\udc43\ud835\udc5f\ud835\udc52\ud835\udc51\ud835\udc56\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b\ud835\udc60, \ud835\udc61)) , if positive\n\ud835\udc48, otherwise\nWhere \ud835\udc65 is an input, \ud835\udc61 the time the function is evaluated, and \ud835\udc5a\ud835\udc56(\ud835\udc65, \ud835\udc61) all the models that matched \ud835\udc65 with their respective LTs at time \ud835\udc61 . \ud835\udc48 (\ud835\udc48 \u2208 [0,1[) is a parameter of the system meant to give a chance to inputs that don\u2019t match any model to still be considered for model building, if resources allow.\nEquation 8\nThe priority of a TPX-accumulation job is proportional to the input\u2019s utility, which means that inputs with lower utility will be less likely to be buffered and therefore, that they will be less likely considered for building models. The priority of a TPXaccumulation job also depends on the utility of the model that produced its target, of the incentive of learning said target (defined below) and of a decay function depending on the input found in the buffer. The success rate of the class of goals and predictions it produces are monitored \u2013 classes are merely abstracted instances of goals or predictions. The success rate of a class is the number of positive evidences (for goals, the number of times an instance of the goal class was achieved and for predictions, the number of times instances of the prediction class were successful), divided by the total number of evidences (the number of instances of the class). When the target is a prediction, the incentive for learning depends on the unexplained decrease of the success rate of the prediction\u2019s class:\n\ud835\udc3f\ud835\udc52\ud835\udc61 \ud835\udc46\ud835\udc62\ud835\udc50\ud835\udc50\ud835\udc52\ud835\udc60\ud835\udc60\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52(\ud835\udc50, \ud835\udc61) = \ud835\udc52+(\ud835\udc50,\ud835\udc61)\n\ud835\udc52(\ud835\udc50,\ud835\udc61) \ud835\udc4e\ud835\udc5b\ud835\udc51\n\u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61) = \ud835\udc46\ud835\udc62\ud835\udc50\ud835\udc50\ud835\udc52\ud835\udc60\ud835\udc60\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52(\ud835\udc50, \ud835\udc61) \u2212 Max \ud835\udc61\ud835\udc5f\u2264\ud835\udc61 (\ud835\udc46\ud835\udc62\ud835\udc50\ud835\udc50\ud835\udc52\ud835\udc60\ud835\udc60\ud835\udc45\ud835\udc4e\ud835\udc61\ud835\udc52(\ud835\udc50, \ud835\udc61\ud835\udc5f))\n\ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61) = { \u2212\ud835\udc3f \u00d7 \u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61), \u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61) < \u2212\ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc45\n0, \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52\nRUTR-SCS13006 31/56\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc34\ud835\udc50\ud835\udc50\ud835\udc62\ud835\udc5a\ud835\udc62\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b(\ud835\udc50, \ud835\udc65, \ud835\udc61) = \ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61) \u00d7 \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc3a\ud835\udc5c\ud835\udc4e\ud835\udc59\ud835\udc60, \ud835\udc610(\ud835\udc65)) \u00d7 \ud835\udc3c\ud835\udc5b\ud835\udc5d\ud835\udc62\ud835\udc61\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc65, \ud835\udc61)\nWhere \ud835\udc50 is a class of predictions, \ud835\udc52+(\ud835\udc50, \ud835\udc61) the number of positive evidences of \ud835\udc50 being achieved, \ud835\udc52(\ud835\udc50, \ud835\udc61) the total number of evidences both evaluated at \ud835\udc61, \ud835\udc61 being the time the function is computed, \ud835\udc65 a prediction, instance of \ud835\udc50 and \ud835\udc5a the model that produced \ud835\udc65. \ud835\udc610(\ud835\udc65) is the time when \ud835\udc65 was produced by \ud835\udc5a. \ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc45 is a threshold defined as a parameter of the system. It is necessary to keep all jobs\u00b4 priorities commensurate: \ud835\udc3f is a parameter of the system defined to set the importance of |\ud835\udc3f \u00d7 \u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61)| relatively to the \ud835\udc48\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc50\ud835\udc66 function used to compute the priorities of all non-TPX jobs.\nEquation 9\nWhen the target is a goal, the incentive for learning depends on the unexplained increase of the success rate of the goal\u2019s class:\n\ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61) = { \ud835\udc3f \u00d7 \u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61), \u2206\ud835\udc46\ud835\udc45(\ud835\udc50, \ud835\udc61) > \ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc45\n0, \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc34\ud835\udc50\ud835\udc50\ud835\udc62\ud835\udc5a\ud835\udc62\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b(\ud835\udc50, \ud835\udc65, \ud835\udc61) = \ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61)\n\u00d7 \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc43\ud835\udc5f\ud835\udc52\ud835\udc51\ud835\udc56\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b\ud835\udc60, \ud835\udc610(\ud835\udc65)) \u00d7 \ud835\udc3c\ud835\udc5b\ud835\udc5d\ud835\udc62\ud835\udc61\ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc65, \ud835\udc61)\nWhere \ud835\udc50 is a class of goals, \ud835\udc65 a goal, instance of \ud835\udc50 , and all other parameters and functions are defined as in Equation 9 above.\nEquation 10\nAt the deadline of the target, buffering stops, and the buffer is analyzed as follows, when the target is a goal (the procedure is similar for predictions, see below):\n1 If one input is the trace of the execution of one model that predicted the goal\u2019s target state, abort \u2013 this means that the success was already predicted.\n2 Remove any inputs that triggered any model execution.\n3 Remove any inputs that were assembled in composite states.\n4 Reorder the buffer according to the early deadlines of the inputs 10 .\n5 For each input remaining in the buffer create a TPX-extraction job, the purpose of which is to assemble a new model from the input and the target.\nShall the target be a prediction, on the other hand, step 1 would be:\n1 If one input is the trace of the execution of one model that predicted a counter-evidence of the prediction\u2019s target state, abort, as the failure was already predicted.\nReaching step 5 triggers the second phase of TPX activity, where models are built from inputs found in the buffer. The construction of a new model is performed - by a TPX-extraction job - as follows, when the target is a goal:\n1 The target is abstracted 11\nand forms the RT of a new model (let's call it M0). If the input assigned to the TPX-extraction job is synchronized with\n10\nThe buffering time of an input is the time at which a TPX-accumulation job was executed, which may not be the same time as the deadline of the input\n11 Here, abstraction means replacing values by variables.\nRUTR-SCS13006 32/56\nother inputs (that is, if their time intervals overlap), then all these inputs are assembled into a single new composite state: this new state is chosen as the LT of the model. Otherwise, the input is abstracted and forms the LT of the model. Notice that new states are identified when their parts are needed for the models being built (instead of resulting from blind temporal correlation): Using composite states as models\u2019 LT instead of just atomic states fosters the building of structural hierarchies.\n2 If, in a model, some variables in the RT (or in the LT) are not present in the LT (or in the RT), then the job attempts to build guards (see below) to bind these to known variables; otherwise, stop.\n3 If some variables in a model are still not bound, then if the buffer is still not exhausted, goto step 4; otherwise, goto step 5.\n4 The job considers the next older input to build another model (M1) whose RT is an instance of M0; the unbounded variables in M0 are passed from M1 to M0 as parameters of M0. The execution of M1 allows the execution of M0: M1 is a positive pre-condition on M0. Goto step 2.\n5 All models are deleted that hold variables representing deadlines that are unaccounted for, i.e. variables that cannot be computed neither from the LT or RT, nor from the model\u2019s parameters list. These models are deleted since they would produce predictions with unbound deadlines, i.e. predictions that cannot be monitored.\nIf the target was a prediction, then the signaling event would be a failure. Technically this means that M1 mentioned above would have its RT being the failure of the execution of M0, in other words, the execution of M1 would inhibit the execution of M0: M1 would then be a negative pre-condition on M0.\nAs with TPX-accumulation jobs, the priority of a TPX-extraction job is a function of the utility of the model that produced its target and of the incentive of learning said target. It also depends on a decay function. When the target is a prediction, the TPXextraction job\u2019s priority is:\n\ud835\udc3f\ud835\udc37\ud835\udc52\ud835\udc50\ud835\udc4e\ud835\udc66(\ud835\udc61, \ud835\udc65) = { \ud835\udc610(\ud835\udc65) \u2212 \ud835\udc61 \ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc4d + 1, \ud835\udc61 < \ud835\udc610(\ud835\udc65) + \ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc4d\n0, \ud835\udc5c\ud835\udc61\u210e\ud835\udc52\ud835\udc5f\ud835\udc64\ud835\udc56\ud835\udc60\ud835\udc52\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc38\ud835\udc65\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b(\ud835\udc50, \ud835\udc65, \ud835\udc61) = \ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61) \u00d7 \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc3a\ud835\udc5c\ud835\udc4e\ud835\udc59\ud835\udc60, \ud835\udc610(\ud835\udc65)) \u00d7 \ud835\udc3f\ud835\udc37\ud835\udc52\ud835\udc50\ud835\udc4e\ud835\udc66(\ud835\udc61, \ud835\udc65)\nWhere \ud835\udc50 is a class of predictions, \ud835\udc52+(\ud835\udc50, \ud835\udc61) the number of positive evidences of \ud835\udc50 being achieved, \ud835\udc52(\ud835\udc50, \ud835\udc61) the total number of evidences both evaluated at \ud835\udc61, \ud835\udc61 being the time the function is computed, \ud835\udc65 a prediction, instance of \ud835\udc50 and \ud835\udc5a the model that produced \ud835\udc65. \ud835\udc610(\ud835\udc65) is the time when \ud835\udc65 was produced by \ud835\udc5a . The \ud835\udc3f\ud835\udc37\ud835\udc52\ud835\udc50\ud835\udc4e\ud835\udc66 function depends on a system parameter,\ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc4d, and ensures the job will be cancelled after \ud835\udc610(\ud835\udc65)+ \ud835\udc3f\ud835\udc47\ud835\udc3b\ud835\udc4d.\nEquation 11\nWhen the target is a goal, the TPX-extraction job\u2019s priority is:\n\ud835\udc43\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc5f\ud835\udc56\ud835\udc61\ud835\udc66\ud835\udc38\ud835\udc65\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b(\ud835\udc50, \ud835\udc65, \ud835\udc61) = \ud835\udc3f\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54\ud835\udc3c\ud835\udc5b\ud835\udc50\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc63\ud835\udc52(\ud835\udc50, \ud835\udc61)\n\u00d7 \ud835\udc48\ud835\udc61\ud835\udc56\ud835\udc59\ud835\udc56\ud835\udc61\ud835\udc66(\ud835\udc5a, \ud835\udc43\ud835\udc5f\ud835\udc52\ud835\udc51\ud835\udc56\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b\ud835\udc60, \ud835\udc610(\ud835\udc65)) \u00d7 \ud835\udc3f\ud835\udc37\ud835\udc52\ud835\udc50\ud835\udc4e\ud835\udc66(\ud835\udc61, \ud835\udc65)\nWhere \ud835\udc50 is a class of goals, \ud835\udc65 a goal, instance of \ud835\udc50 , and all other parameters and functions are defined as in Equation 11 above.\nRUTR-SCS13006 33/56\nEquation 12\nModels contain guards (introduced in section 4.1) and these must be produced from the inputs through induction \u2013 for now we limit ourselves to the induction of invertible linear functions of the general form \ud835\udc66 = \ud835\udc4e \u00d7 \ud835\udc65 + \ud835\udc4f where \ud835\udc4e , \ud835\udc65 , and \ud835\udc4f are either variables of the model or constants. The construction of guards proceeds by attempting to match input data and some guard templates defined by the executive. We will assume that models come in the form: (\ud835\udc3f\ud835\udc47(\ud835\udc440, \ud835\udc441, \u2026 , \ud835\udc44\ud835\udc5b , \ud835\udc470, \ud835\udc471), \ud835\udc45\ud835\udc47(\ud835\udc430, \ud835\udc431, \u2026 , \ud835\udc43\ud835\udc5a , \ud835\udc472, \ud835\udc473)) where \ud835\udc44\ud835\udc56 and \ud835\udc43\ud835\udc57 are variables representing arbitrary quantities, \ud835\udc470 and \ud835\udc471 are variables that define the time interval within which L holds, and \ud835\udc472 and \ud835\udc473 variables defining the time interval for R. The templates currently implemented are given in the following list (an upper case symbol denotes a variable, whereas the same symbol in lower case indicates the value from which the variable has been abstracted; \u201cforward\u201d indicates guards controlling forward chaining; \u201cbackward\u201d indicates guards controlling backward chaining).\n\ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc34\n\ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc472 = \ud835\udc470 + \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51, \ud835\udc473 = \ud835\udc471 + \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc470 = \ud835\udc472 \u2212 \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51, \ud835\udc471 = \ud835\udc473 \u2212 \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51\nWhere \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51 = \ud835\udc612 \u2212 \ud835\udc610. \ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc35\n\ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc43\ud835\udc56 = \ud835\udc44\ud835\udc57 + \ud835\udc44\ud835\udc58 \u00d7 \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc44\ud835\udc58 = (\ud835\udc43\ud835\udc56 \u2212 \ud835\udc44\ud835\udc57)\n\ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51\nWhere \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51 is defined as above. \ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc36, \ud835\udc5c\ud835\udc5b\ud835\udc59\ud835\udc66 \ud835\udc56\ud835\udc53 \ud835\udc3f\ud835\udc47 \ud835\udc56\ud835\udc60 \ud835\udc4e \ud835\udc50\ud835\udc5c\ud835\udc5a\ud835\udc4e\ud835\udc5b\ud835\udc51 \ud835\udc64\ud835\udc56\ud835\udc61\u210e \ud835\udc5b\ud835\udc5c \ud835\udc4e\ud835\udc5f\ud835\udc54\ud835\udc62\ud835\udc5a\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc470 = \ud835\udc472 \u2212 \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51, \ud835\udc471 = \ud835\udc473 \u2212 \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51\nWhere \ud835\udc5d\ud835\udc52\ud835\udc5f\ud835\udc56\ud835\udc5c\ud835\udc51 is defined as usual (here, the period is actually the duration of the command). \ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc37, \ud835\udc5c\ud835\udc5b\ud835\udc59\ud835\udc66 \ud835\udc56\ud835\udc53 \ud835\udc3f\ud835\udc47 \ud835\udc56\ud835\udc60 \ud835\udc4e \ud835\udc50\ud835\udc5c\ud835\udc5a\ud835\udc4e\ud835\udc5b\ud835\udc51\n\ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc43\ud835\udc56 = \ud835\udc44\ud835\udc57 \u00d7 \ud835\udc44\ud835\udc58\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc44\ud835\udc58 = \ud835\udc43\ud835\udc56 \ud835\udc44\ud835\udc57\nNotice that the \ud835\udc44\ud835\udc56\ud835\udc60 are the command arguments. \ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc38, \ud835\udc5c\ud835\udc5b\ud835\udc59\ud835\udc66 \ud835\udc56\ud835\udc53 \ud835\udc3f\ud835\udc47 \ud835\udc56\ud835\udc60 \ud835\udc4e \ud835\udc50\ud835\udc5c\ud835\udc5a\ud835\udc4e\ud835\udc5b\ud835\udc51\n\ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc43\ud835\udc56 = \ud835\udc44\ud835\udc57 + \ud835\udc44\ud835\udc58\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc44\ud835\udc58 = \ud835\udc43\ud835\udc56 \u2212 \ud835\udc44\ud835\udc57\n\ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc39 \ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc43\ud835\udc56 = \ud835\udc44\ud835\udc57 \u00d7 \ud835\udc50\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc44\ud835\udc58 = \ud835\udc43\ud835\udc56 \ud835\udc50 Where \ud835\udc50 = \ud835\udc5d\ud835\udc56\n\ud835\udc5e\ud835\udc56 .\n\ud835\udc47\ud835\udc52\ud835\udc5a\ud835\udc5d\ud835\udc59\ud835\udc4e\ud835\udc61\ud835\udc52 \ud835\udc39\nRUTR-SCS13006 34/56\n\ud835\udc53\ud835\udc5c\ud835\udc5f\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc43\ud835\udc56 = \ud835\udc44\ud835\udc57 + \ud835\udc50\n\ud835\udc4f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51: \ud835\udc44\ud835\udc58 = \ud835\udc43\ud835\udc56 \u2212 \ud835\udc50 Where \ud835\udc50 = \ud835\udc5d\ud835\udc56 \u2212 \ud835\udc5e\ud835\udc56.\nEquation 13\nNotice that several templates can be used to identify the guards of a single model."}, {"heading": "5.3 Self-modeling and Self-control", "text": "Self-monitoring is the production by the system of data describing the computation of the system. These data are generated automatically by the executive; they are:\n- notifications of the productions of models,\n- success and failure of goals and predictions,\n- notifications of the data used for assembling composite states,\n- notifications of instantiated models,\n- periodic measurements of the scheduling performance. These are for example the average deadline overshoots for time-triggered jobs, the percentage of jobs cancelled over the total load, along with priority thresholds under which jobs have been cancelled, per kind of job, along with their urgency, the utility value of their program and the likelihood of their inputs.\nSuch data constitute internal inputs for the system itself and at the elementary level of modeling causal relations, allow capturing pre- and post-conditions on model execution, as introduced in section 4.2. At the higher levels of system control, these internal inputs can also constitute external inputs for meta-systems, i.e. systems in charge of controlling the former one (as introduced in section 3). Periodic measurements of the scheduling performance may indicate possible congestion, i.e. insufficient resources with regards to the jobs at hand. In this case, it is the responsibility of a meta-system (or the system itself) to take contingency measures. These are, for example:\n- increase the threshold on terms\u2019 likelihood (defined in section 4.3). Goals, predictions and assumptions will be more likely to fall under said threshold, thus limiting the depth of the chaining;\n- increase the thresholds THR1 and THR2 that control respectively the switching of phased in/out models and the deletion of the phased out ones (see section 5.2.3). This will decrease the number of models in active duty (phased in) and thus reduce the number of chaining jobs.\n- activate the LRU-based garbage collector (introduced in section 4.1). To activate the garbage collector, one specifies a threshold on the least recent time models have been used (e.g. they produced confirmed predictions). Decreasing this threshold reduces the number of models and therefore, reduces the system\u2019s load.\n- lower the priority of some drives. This will delay or cancel the achievement of the sub-goals stemming from these drives and reduce the overall workload of the system, that is, the number of all the jobs concerned with chaining, monitoring, etc.\nEven though self-modeling for meta-control has not been leveraged in our S1 demonstrator, this functionality has been implemented and is operational. As we have argued before (Steunebrink et al. 2013, Th\u00f3risson 2012) such functionality is a\nRUTR-SCS13006 35/56\nnecessity for a developmental system poised to adapt and make the best use of its resources. With it a system can, for example, model the ways it routinely adopts for achieving some particular goals: This consists of modeling sequences of model execution \u2013 these are observable in the form of internal inputs \u2013 and, by design, can be modeled using the existing learning mechanisms. The benefit of modeling sequences of execution can be, among others, to enable the system to compile such sequences so as to replace a set of models, which normally have to be interpreted by the executive, with a faster (but also more rigid) equivalent native machine code. Thus self-compilation supports a lower-level re-encoding of useful and reliable knowledge, which we expect will increase the scalability of AERA."}, {"heading": "6 Evaluation & Experimental", "text": ""}, {"heading": "Results", "text": "Two experiments are reported here. Experiment 1 (E1) was conceived as a pilot, with the aim of exploring the complexity that the system might be able to handle. In terms of what S1 must learn (described in sections 6.2.1 and 6.3.1), E1 is a strict subset of experiment 2 (E2). In both experiments two humans interact for some time, allowing S1 to observe their behavior and interaction; in both experiments S1's task is to learn how to conduct the interaction in exactly the same way as the humans do, in either role of interviewer or interviewee. The knowledge given to S1 is represented as a small set of primitive commands and categories of sensory data, along with no more than a few top-level goals such as \"pleasing the interviewer\" (operationally defined as the interviewer saying \"thank you\" or asking a new question). Details on these are given in section 6.2.\nOur results are analyzed using t-patterns (Magnusson 1996, 2000; Jonsson & Th\u00f3risson 2010; Th\u00f3risson et al. 2013), a method for extracting hierarchies of significant temporal patterns in multi-dimensional source data. Unlike more simplistic statistical measurements, the t-pattern approach we use for analyzing the results of E2 has the unusual feature of giving a rather holistic picture of the overall behavior of the system it is applied to. For readers unfamiliar with this technique we refer to Magnusson (1996, 2000) and Thorisson & Magnusson (2013). The patterns emerging in t-pattern analysis are dependent on three factors: The source material itself, how well it is coded, and the settings of particular analysis parameters. Our source material was a direct recording of the real-time events in the graphical world, i.e. a trace of the human and machine actions in the virtual world frame-by-frame; the coding of the recordings was done by coders with years of experience in this methodology. Parameter settings for all analysis were as follows: Minimum number of occurrences set at 3 and significance level set at 0.0005 unless otherwise noted; other values were set at default (see Magnusson 2006).\nFirst we describe the experimental setup and interaction scenario, then present the results of the two experiments."}, {"heading": "6.1 Experimental & Scenario Setup", "text": "In both experiments S1 observes real-time interaction between two humans in the simulated equivalent of a videoconference: The humans are represented as avatars in a virtual environment (Figure 11) \u2013 each human sees the other as an avatar on their screen. Their head and arm movements are tracked with motion-sensing technology, their speech recorded with microphones. Signals from the motion-tracking are used to update the state of their avatars in real-time, so that everything one human does is translated virtually instantly into movements of her graphical avatar on the other's screen. Between the avatars is a desk with objects on it, visible to both participants.\nRUTR-SCS13006 36/56\nOne human is assigned the role of an interviewer (Hq), the other the role of an interviewee (Ha); the goal of their interaction is collaborative dialogue involving the objects in front of them.\nDuring learning by observation S1 observes two humans interacting and subsequently replaces one of them to allow the interaction to proceed as before. The natural interaction between two human participants (H) is mediated via a video-conference virtual-world setup, where participant Hq appears on the monitor of participant Ha as an avatar (hq), and vice versa. One is an interviewer asking questions (Hq), the other an interviewee giving answers (Ha) on the subject of recycling. Their behavior is motion-tracked and used to drive the movements of their avatars; speech is collected via microphones and piped to the speaker on the other's monitor. S1 can replace either human and conduct the interaction in an identical manner.\nThe data produced during their interaction is represented as follows. Body movements is represented as coordinate changes of labeled body parts of the avatars, in {x, y, z, p, q, r} of the coordinate system of the virtual world used. Each audio signal is piped to two processes: an instance of a speech recognizer (Microsoft SAPI 5.3), and to an instance of the Prosodica prosody analyzer (Nivel & Th\u00f3risson 2008). The speech recognition is augmented with timestamps on the words produced (approximate accuracy of time-stamping typically +/-100 ms or better), and (in E2) filtered through a set of 100 allowed words (necessary due to the many false positives produced in live interaction). Words time-stamped with the estimated time-ofutterance are typically output as intermediate hypotheses between 200 and 1000 milliseconds of being uttered, with a \"final guess\" delivered for each audio segment after a 200 millisecond silence is detected. The prosody analyzer produces timestamped sound-silence boundaries (accuracy +/- 16 to 32 ms) and prosody information in the form of F0 (with update frequency of 6 Hz; approximate accuracy of 40 ms). This data is the input to S1, streamed to S1 in real-time.\nThe task assigned to the two humans in E1 is for the interviewer to ask the interviewee to pick up and move things around on the table \u2013 a kind of put-that-there scenario (cf. Roy 2005, Bolt 1980). In E1 we provide S1 with top-level goals, contained in the system's \"seed\" (see section 6.2.1). The seed for S1 in E1 includes five geometrical entities: cube and sphere of two colors \u2013 and a small related set of categories of sensory data, as described in section 6.2.1. In E1 the speech consists of fairly simple utterances which are used to get the interviewee to move the objects around (e.g. \"Take the [cube | sphere], and put it here\"; \"Put [a | the] [cube | sphere] there.\"); no speech is produced by the interviewee in E1. Also, three gestures were\nRUTR-SCS13006 37/56\nallowed: grasping/releasing an object, and pointing at a position on the table.\nThe task assigned to the two humans in E2 is for the interviewer to make the interviewee talk about some properties of objects on the table. The seed for S1 in E2 is also defined as top-level goals, but with more complex natural language, more gestures and more requirements and constraints than in E1."}, {"heading": "6.2 Experiment 1", "text": ""}, {"heading": "Experimental Goals & Hypotheses 6.2.1", "text": "The goal of E1 was to provide a multi-dimensional task to be learned by S1 through observation, while keeping the complexity of each mode (speech, gesture, semantics) to a defined subset of the complexity targeted in Experiment 2. The data recording setup for E1 was as described in section 6.1 above, with the two humans providing several minutes of interaction to allow S1 to learn how to do it. The objects that the interaction revolves around are: two blue cubes, one red cube, one red sphere, one blue sphere. The seed for S1 in E1 is described in detail in Nivel & Th\u00f3risson (2013); in short, it consists of a set of primitive commands (move hand, grab, release, point at) and a set of dimensions for the input space (object type, color, actor\u2019s role, speech). The seed also includes initial knowledge that models the consequences of invoking the primitive commands: these models are for example explaining how the position of the system\u2019s hand is affected by invoking the command move hand and how a hand and an object are linked together after invoking the command grab. The natural language used in E1 consisted of a fixed set of sentence fragments (see Table 1).\nThe words and word order used in Experiment 1. Note that a sentence starting with \"Take it ...\" is not allowed as a first sentence in an interaction, as the use of ellipsis must have a prior referent. (Silence of some measurable length is indicated as \"...\"; parenthesis means optional.)\nHuman participants in all scenarios observed by S1 are two of the system's developers, who interacted with each other according to the set of targeted behaviors (see Table 2 - What S1 should learn from observation in E1 Table 7 - High-level summary of the target tasks to be learned by S1 in E2). The sequence of actions and the use of multimodal deictics was free-form, and the interaction was real-time. The human participants tried to not make mistakes, but occasional errors were unavoidable as all sessions were live and non-scripted.\nIn E1 we hypothesized that S1 could learn at least some of the behavior patterns needed for conducting the interaction presented in the human-human scenario of E1. S1 was set up to observe the humans for as long as was required for it to predict\nRUTR-SCS13006 38/56\naccurately all major event types observed in the human-human dialogue. After this observation period S1 interacted with a human for a sufficiently long period to produce videos that could be analyzed using the t-pattern approach."}, {"heading": "Results of Experiment 1 (E1) 6.2.2", "text": "In E1 S1 only needed to observe the humans for a few minutes until its performance was error-free in both roles. Videos of S1 in both roles were then recorded, of comparable duration, for subsequent t-pattern analysis. Results show that the performance of S1 matches the human-human scenario very closely. S1 is able to proceed as the humans in this interaction scenario, without making mistakes, in either role. The main high-level results of experiment 1 are summarized in Table 3. At the lower level of implementation, the level of models, S1 learned that state transitions (like moving a hand) can be achieved by asking the interviewee to perform actions instead of performing these itself, as a new addition to its prior knowledge encoded in its seed. S1 also learned that, to enact the transition of an object\u2019s state from one location to another, one way is to grab said object first, then apply the same state transition to the hand that holds it \u2013 this was achieved by modeling pre- and postconditions on the model describing the state transition. S1 also learned the sequences of orders (\u201ctake a blue cube\u201d then \u201cput it there\u201d) to fulfill the imposed drive; it also learned to satisfy this drive twice in a row with different targets (a blue cube first, then a red sphere), as demonstrated by the human actors \u2013 this results from the hierarchization of control via model affordances. S1 identified the correlation between deictics and utterances (e.g. \u201cthere\u201d correlated with pointing gestures) \u2013 this is an example of learned structural hierarchy (in the form of composite states) -, as well as ellipsis (\u201cput it there\u201d). The pronoun \u201cit\u201d has been learned to identify the object that draws the most attention (in terms of job priority), i.e. the target of the most valuable\nRUTR-SCS13006 39/56\ngoals (picking an object is a learned pre-condition on the next step, moving it to some location, to earn the reward) \u2013 this is an example of value-driven resource allocation steering cognition and vice-versa.\nThe conclusions are based on videos of the interaction between S1 and a human, in both roles, and on the statistical t-pattern analysis presented in this section.\nIn E1 the high-level results of t-pattern analysis of S1's behavior can be summarized as follows:\n- A high number of complex turn-taking temporal patterns were detected in the individual data sets analyzed, comparable between all conditions (human-\nhuman, agent as interviewer, agent as interviewee).\n- The number, frequency, and complexity of detected patterns indicate that behavior was highly synchronized in all situations.\n- This synchrony was found to exist on all levels of temporality, with highly complex time structures that extended over considerable time spans, where some of the patterns repeated in a cyclical fashion.\nWhen looking at simple and short turn-taking patterns, similar structures are detected across all dyads in the S1 dialogue sessions (S1 as interviewer + S1 as interviewee). More complex patterns are detected in the human-human dyads than in the S1 interaction, as S1's induction process produced abstracted models of the human behavior that were simpler than the observed human behavior, yet achieved the same goals (getting the interlocutor to behave appropriately in the context of the interaction, based on its stated goals).\nA thorough inspection of the videos of S1 revealed no errors in the interaction on behalf of S1; the system had acquired and generalized the observed human-human behaviors to a sufficient level to allow it to perform error-free communication in subsequent real-time interaction with a human, under the same operating constraints as in the human-human scenario."}, {"heading": "Observation Time # Turns Observed # Errors After Observation Period", "text": "~2.5 mins ~17 0\nRUTR-SCS13006 41/56\nIn our previous results from an analysis of human-agent interaction with the Gandalf agent (Jonsson & Th\u00f3risson 2010, Th\u00f3risson 1996, 1999) the patterns seemed to be somewhat slower on average than in natural human-human interaction, which can likely be explained by a longer average duration between critical elements of the turntaking system, especially the speech recognition. Compared to Gandalf, the pace/tempo of S1's dialogue sessions is much closer to the speed of human-human dyadic interaction, especially in dyadic interaction between subjects who know each other well (e.g. friends). A closer comparison between S1 and other human-human data further suggests that the turn-taking reaches a \u201cmean level\u201d patterning quickly, as is the case in dyadic interaction between friends (Jonsson 2006).\nThese positive results allowed us to step up the complexity of the task significantly, including more complex speech and interaction, as explained in the next section."}, {"heading": "6.3 Experiment 2 (E2)", "text": ""}, {"heading": "Experimental Goals & Hypotheses 6.3.1", "text": "Given the success of E1, the goal of E2 was to provide S1 with an appropriate increase in complexity of the task. We defined a scenario that included all behavior included in E1, but with considerably increased complexity in both spatial and language behavior. The input dimensions were encoded as before, with more objects:\nRUTR-SCS13006 42/56\naluminum can, glass bottle, plastic bottle, cardboard box, newspaper and painted wooden cube. The vocabulary was 100 words with substantially more variety in sentence structures. In E2 S1 was given no grammar. The task of the participants in E2 is to talk about these objects on the desk in front of them, in particular, the interviewer's task is to ask the interviewee about the materials which the various objects are made of, and the pros, cons, cost, and methods for recycling them. As before, one participant acts as interviewer, the other as interviewee.\nThe data flow setup for E1 was as described in section 6.2.1 above, as is the seed (see also Nivel & Th\u00f3risson (2013)). In addition to models included in the seed for E1, the seed for E2 consist of models rewarding the interviewer for having the interviewee speak, and models rewarding the interviewee for speaking.\nAs in E1, in E2 human participants in all scenarios were not trained actors. They interacted according to the targeted set of behaviors (see Table 7 and Table 8). The sequence of their actions and the use of multimodal deictics was free-form and realtime, the interaction thus semi-improvised. The human participants tried to not make mistakes, but occasional errors were unavoidable as all sessions were live and nonscripted. No formal grammar definition was created for the speech in E2, and neither this, nor a list of permissible sentences, were provided to S1 by the designers before S1's observation sessions started. Due to the number of commission errors in the speech recognizer its output was restricted to the set of 100 permissible words (see Table 8).\nWe hypothesized that S1 could learn the behavioral patterns learned in E1, and in addition would learn a sufficient amount of new behaviors that were introduced in E2, to the extent that it could conduct at least some of the more complex interaction behaviors required in E2, in either role of interviewer or interviewee.\nWe had S1 observe the humans until it accurately predicted all major event types observed in the dialogue. We then had S1 interact with the humans for a sufficiently long period to produce videos that could be analyzed with the t-pattern approach; recordings of S1 interacting in either role with one of the humans (same as who participated in the human-human scenario) were tens of minutes each. This formed the basis for subsequent data analysis.\nDialog Pattern\nDetails\nExpected Behavioral Characteristics\nInterview: interleaved questions and answers In E1 S1 had successfully learned how speech and gesture is used together by the interviewer to get the interviewee to perform multimodal acts. Now, in E2, the interview includes new gestures and speech for both roles, resulting in a more complex interview structure. S1 should learn how to interleave actions and speech utterances to achieve the goals of the dialogue.\nSpatiotemporal reference through manipulation Simple manipulation is often used as a tool for disambiguating language. Here the co-incidence of speech, e.g. use of \"it\" or \"this\" and a manipulation gesture (picking up / holding an object) can be used to identify the intended reference. Synchronization of speech and object manipulation such that the latter disambiguates the former.\nLanguage: Sentence construction Sentence structure requires an appropriate order of words. Table 8 shows the sentence structures used by humans in E2. Without the use of grammar, S1 should be able to construct sentences in either role of interviewer and interviewee, based on that\nRUTR-SCS13006 43/56\nIn E2 S1 should learn everything it was seen to learn in E1 (see Table 2), but in E2 we add the additional hypotheses listed in this table.\nThe vocabulary in E2 contained 100 words (words in parenthesis can be omitted), which were combined in numerous ways by the human participants in E2. No formal grammar definition existed or was created for the speech in E2, and neither this, nor a list of permissible sentences, were provided to S1 by the designers before S1's observation sessions started.\nRUTR-SCS13006 44/56"}, {"heading": "Results of Experiment 2 (E2) 6.3.2", "text": "In E2 S1 learned everything that it observed in the human-human interactions which is necessary to conduct a similarly accurate and effective interaction. 12 The sociocommunicative repertoire acquired autonomously by S1 after an observation period of approximately 20 hours, has been correctly learned, with no mistakes in its subsequent application, including timing of all actions (Table 10). This repertoire, including skills in either role (interviewer and interviewee), consists of:\n- Correct sentence construction - correct word order.\n- Effective and appropriate manual and head deictics (gesturing towards object being talked about at the right time, gazing towards it using head direction when mentioned or pointed at).\n- Appropriate response generation; answer (as interviewee) and sequence of questions (as interviewer).\n- Proper multimodal coordination in both interpretation and production, at multiple timescales (interview, utterance, and sub-utterance levels).\n- Turn-taking skills (avoiding overlaps, avoiding long pauses), and utterance production \u2013 presentation of content (answer/question) at appropriate times with regard to the other's behavior.\n- Interview skills - doing the interview from first question to last question.\nCategory What Has Been Learned Result\nInterview\ngross structure\nAs evidenced in the videos, the interview proceeds exactly as in the human-human condition; questions are sequenced appropriately by S1 and several are posed before the interview is over. S1 also learned to use interruption to keep the interview within the allowed time limits. S1 has acquired the sociocommunicative dialogue skills to conduct a real-time multimodal interview with a human in real-time, and can correctly follow its structure as demonstrated in the humanhuman dialogue scenario.\nInterview: Interleaved questions and answers In E1 S1 learned how speech and actions are used together by the interviewer and interviewee, respectively. In E2 the interview includes gestures and speech for both roles. S1 has acquired the ability to correctly interleave questions and answers in light of the goals of the interview, in either role of interviewer and interviewee.\nTurn-taking\nWhile the turn-taking seems slightly slower-paced than typical humanhuman interaction, the style and action repertoire that S1 exhibits is precisely that observed in the human-human condition. S1 has learned basic human turn-taking skills, including as is appropriate for efficient language use.\nExplicit manual deictics S1 clearly shows proper use of deictics, both using palm as a pointing device and the index finger. Head direction is also used as a deictic device in some cases. S1 has learned to use deictics. Both the timing and form of the gestures is appropriate for the context.\nSpatio-temporal reference S1 can pick up an object when talking about it, and refer to it in language with S1 has learned the meaning of manipulation as a deictic device. The timing and use of\n12 Videos of the interaction can be found on www.humanobs.org and on youtube.com under\nCADIA's video channel CADIAvideos.\nRUTR-SCS13006 45/56\nIn E2 the observation period was 20 hours, which is dramatically higher than that required in E1 for an equivalent error-free performance. This is due to the complexity of the sentences the system had to learn in E2, which alone have dramatically greater combinatorics than all of the behaviors observed in E1.\nAs in E1, visual inspection of the resulting videos from E2 revealed no errors on behalf of S1 in either role; the system has generalized the human-human scenarios it observed to a sufficient abstraction level so as to make no mistakes when interacting with a human.\nThe t-pattern analysis bore out the conclusion that S1 had acquired all relevant behavioral skills \u2013 in fact, if it wasn't for the synthesized speech it is difficult to identify a difference in performance by S1 and the humans. The plots in Figure 13, Figure 14 Figure 16 show the most frequent patterns seen in E2, asking and replying, in all conditions.\nThe results of the t-pattern analysis mirror those obtained in E1, showing again a high number of complex turn-taking temporal patterns in the individual data sets analyzed; the number, frequency, and complexity of detected patterns indicate that behavior was highly synchronized in all situations, and synchrony was found to exist on all levels of temporality, with highly complex time structures extending over considerable time spans, and a number of the patterns occurring in a cyclical fashion, as would be expected in a structured interview.\nThe most frequent pattern is, as in E1, the ask-reply sequence, which contains similar timings across all conditions. In Figures 15, 17 and 18, more complex patterns can be seen. Simple and short turn-taking patterns display similar structures across all three conditions. Somewhat more complex patterns are seen in the human-human condition than those involving S1, due to the somewhat smaller repertoire of behavior displayed by the agent than the humans.\nRUTR-SCS13006 46/56\nNot surprisingly, the most frequent pattern occurring in the human-human condition is the question-answer sequence. (Timescale is in frames @30fps = 3.1 minutes total. For legend see Table 6.)\nJust like the human-human condition, the most frequent pattern occurring in the S1-as-interviewer condition is the question-answer sequence, in a very comparable manner. (Timescale is in frames @30fps = 3.5 minutes. For legend see Table 6.)\nRUTR-SCS13006 47/56\nJust like the human-human scenario, the most frequent pattern occurring in the human-interviews-S1 scenario is the question-answer sequence, in a very comparable manner. (Timescale is in frames @30fps = 2.9 minutes. For legend see Table 6.)\nFirst the interviewer asks a question, looks at the table, then looks back at interviewee, after which the interviewee looks at the table and begins to answer, then looking back at the interviewer. In text format, the tree is\nRUTR-SCS13006 48/56\nthe following: ((( h2_ask, h2 h_table )( h2 h_partner, h1 h_table ))( h1 reply, h1 h_partner )). (Timescale is in frames @30fps = 1 minute duration. For legend see Table 6.)\nIn text format, the tree is the following: ((( h2 h_partner, h2 at_rest ) h1 h_table )( h1,b,h_partner ( h1,b,reply,inf h2,b,ask,inf ))). Compare to human-human condition in Figure 15. (Timescale is in frames @30fps = 1 minute. For legend see Table 6.)\nRUTR-SCS13006 49/56\nIn text format, the tree is the following: (( h2 h_partner, h2 at_rest )(( h1 reply, h1 h_partner ) h2 ask )). Compare to human-human condition in Figure 20. (Timescale is in frames @30fps = 3.7 minutes. For legend see Table 6.)\nRUTR-SCS13006 50/56\nAs the humans participating in these experiments are not trained actors, and did not follow a script, other than limiting their vocabulary and action repertoire as described above, there is good reason to believe that the skills thus learned by S1 generalize to a wider audience. However, the aim of this work was not specifically to build a control system that can interact with people but rather to create a system with a demonstrated ability to learn complicated tasks \u2013 human multimodal interaction of course being an excellent example of a domain with great complexity and variety in input, and one that is highly temporal, as in fact the vast majority of all real-world tasks are.\nThe variety in inputs demonstrated to handle goes a long way towards that goal, as clearly seen when we inserted a constraint on the duration of the interview. In the latter case, S1 observed the interviewer interrupting the interviewee towards the end of the interview, as the time limit was about to be reached. When S1 was put in the role of the interviewer, the human interviewee, on purpose, took more time than usual answering the first questions (a situation S1 had never seen before), and this triggered an interrupt from S1, as it predicted the overshooting of the interview\u2019s deadline and therefore the failure of its goals."}, {"heading": "6.4 Summary of Results", "text": "The results from the two experiments E1 and E2 show without doubt that the AREAbased S1 system correctly acquired and mastered correct usage of all communication methods used by the human interviewer and interviewee in the human-human condition when conversing about the recycling of the various objects' materials. The complete absence of errors in S1's behaviors, after the observation periods in both conditions, demonstrate that very reliable models have been acquired, and that these form a hierarchy spanning at least two orders of magnitude in time. These models correctly represent the generalized relationships of a non-trivial number of entities, knowledge which had not been provided by the system beforehand by its designers and was acquired autonomously, given the bootstrap seed initially provided.\nWe set out to create a system that can learn, in a goal-directed way, how to achieve certain end-goals through generalized, autonomously acquired models that capture real cause-and-effect in the observed phenomena, providing a foundation for acquiring complex tasks through observation and reasoning. Our choice of a human interview to evaluate the system was not made on the grounds that we wanted to produce a highly human-like virtual interviewer, but was rather made purely on the grounds that it happens to meet a number of the key requirements that we have set ourselves for this work, and thus provided us a milestone of significant complexity that would test our work along several dimensions.\nThe tasks in E1 and E2 require S1 to learn and abstract temporal sequences of continuous events (utterances and multimodal behavior), as well as logical sequences and relationships (word sequences in sentences, meaning of words and gestures) between a number of observed data. These were acquired through a method of generalization using induction, abduction and deduction, allowing S1 to respond in real-time situations that differ from what it has seen before (the humans were not\nRUTR-SCS13006 51/56\ntrained actors and did not repeat exactly any of their actions in any of the scenarios).\nAs all representations in AERA are domain-independent, these results are highly encouraging, implying that S1 and its successors can be applied to a vast number of tasks and environments, taking a notable step up the hierarchy illustrated in Figure 1."}, {"heading": "7 Discussion & Related work", "text": "Most prior work on generality and life-long self-improvement differs considerably from ours in many respects, both theoretically and methodologically. Two main research paths in prior work can be discerned that can meaningfully be contrasted with ours. The first is an algorithmic approach to recursive self-improvement (cf. AIXI by Hutter 2005 and G\u00f6del Machines by Schmidhuber 2006), based primarily on the tools and methodological stance of theoretical computer science; the second is work on cognitive architectures (cf. Laird 2012, Franklin 2013, Wang 2011, 2006), which shares our aim of designing holistic, complete systems, and is closer to implementation. Of these, Wang's stands out for taking a strong experience-grounded approach that we would classify as constructivist-centric, and his is the only work that obviously shares our goal of transversal life-long adaptation under an assumption of incomplete knowledge and limited resources (Wang 2006). The literature following these paths, especially that on cognitive architectures, counts a vast number of papers, ideas, proposals, and systems, but we can only fit a few select representatives. Here we will look at the work already cited in the order mentioned.\nThe G\u00f6del Machine (GM) is a proposal to a general approach for imparting any system with recursive self-improvement and, as AIXI, remains to be implemented. Unlike AIXI, however, it is computable, and some research has suggested steps toward an actual implementation (Steunebrink & Schmidhuber 2012). However, as of yet, no such implementation does exist. A GM is composed of two main parts: an initial solver \u2013 a program that solves tasks in an environment \u2013 and a searcher \u2013 a program that searches for an improvement (a rewrite), proves its optimality, and subsequently applies it. The theory specifies the conditions under which such selfrewrites are allowed, but leaves vast problematic areas unattended. For example, designing an initial solver and its utility function that are general enough to handle non-trivial environments and tasks remains unaddressed. Moreover, designing the initial proof searcher presents an even bigger obstacle: generating suitable rewrite candidates requires either very powerful axioms (and thus tremendous foresight from the programmer) or a search that is probably so expensive as to be intractable. Indeed, the original algorithm (Schmidhuber 2006) proposes that the searcher enumerate theorems through Universal Search until it sees one which happens to contain a positive statement about self-modification. Assuming again that the search could be implemented in some practical way, we would then have to prove that a rewrite candidate will be both beneficial (with respect to the initial utility function) and better than continuing the search for other rewrites. Note that the proof will have to show that all cumulative future rewrites remain provably beneficial with respect to the initial utility function, which is extremely hard indeed. The difficulty of these fundamental remaining issues is compounded by the fact that the GM is too abstract to give \u2013 and therefore to exploit - any hints about the target of rewriting, i.e. the system itself, the very locus of construction, measurement and, eventually, improvement.\nOur approach to recursive self-improvement is very different: We specify and constrain the system\u2019s architecture so as to avoid the aforementioned intractable issues. In our approach the \"utility\" of an improvement is not sanctioned by computationally expensive search and formal proofs but is sanctioned instead by observing an improvement's effect(s) on the performance of the system in its\nRUTR-SCS13006 52/56\nenvironment \u2013 i.e. based on the system's experience over time. The spirit of this approach is more in line with other work of Schmidhuber et al. (1997), although AERA is designed to work in real-world, real-time scenarios. In AERA, finding improvements is this: When a prediction fails, or a goal succeeds unexpectedly, the system models the newly observed causal relationships and tries them out. Compared to the challenge of finding rewrites in the GM, this solution is trivial in terms of both computational cost and implementability. Unlike the GM, our system doesn't need shielding against destructive rewriting. In the AER approach, a system rewrites itself by continually adding and removing very small parts, not by modifying itself wholesale in successive, one-shot, global operations. Adding is always allowed because new code (models) is given an initial reliability that is very likely to be lower than that of established code and thus will not significantly change the operation of the system before enough positive evidences allow so; removing is also always allowed because (a) the necessity of doing so has been ascertained from having experienced some bad resulting behavior, and (b) it leads to an immediate replacement of the faulty part with several better candidates. The upshot is, we don't have to find rewrites: They are induced from observed facts, under the intrinsic necessity of improving the reliability of goals and predictions. Neither do we have to prove whether a rewrite is optimal or not: We know that the future will eliminate bad performers, so only the best available \u2013 not the best possible \u2013 will survive. Of course, such a pragmatic approach faces a potential pitfall: Shall the system have insufficient inputs (for example, in case the environment is too deceptive or adversarial), its rewrites would be useless. This is one reason why we have proposed a need for curiosity in our system, operationalized as the proactive improvement of a system's own knowledge (Steunebrink et al. 2013).\nThe GM framework arguably has a wider scope than our work is intended to have, and could possibly (in theory, at least) be applied to any system. However, it is not the generality of the approach that we are interested in, but rather the generality (and feasibility!) of the system. Because of the vast simplifications in algorithmic approaches, in that they for instance do not take into account system and resource constraints, it can ultimately be argued \u2013 without too much effort \u2013 that existing AGI work starting at the purely algorithmic end addresses a rather different problem than we do \u2013 so much so as to hardly be comparable.\nThe constraints of time and energy affect all intelligences, natural and artificial (cf. Th\u00f3risson 2013). Adaptation to constraints is key for survival and is one of the reasons why intelligent control has been deemed necessary by evolution and system engineers alike. Yet this fundamental property, adaptation, remains to be addressed in most of the work on cognitive architectures claiming biological inspiration or aiming to explain natural intelligence. Two frequently referenced architectures that aim for comprehensiveness over universality, SOAR (Laird 2012) and LIDA (Franklin et al. 2013), provide a case in point. In SOAR only one sub-state can be considered at a time, operators are not applied in parallel, and time-stamps on knowledge cannot be reasoned upon. Other critical design limitations are e.g. truth being axiomatic, and the system\u2019s operation not being considered a target for reasoning, meaning that SOARbased systems cannot support operational reflectivity. All these design choices strongly indicate that the self-management, and therefore the self-adaptation, of the cognitive load when facing limited available resources and knowledge was not on the research agenda. It is unclear how systems based on this architecture can improve over time in any goal-directed way \u2013 or why they even should. LIDA does not answer this question either, as details remain to be provided on its control strategy to explain how the system does actually allocate computational resources to the several types and instances of small code fragments, called codelets, that implement the LIDA cognitive cycle, knowing moreover that cognition in LIDA results from the parallel execution of several such cycles. Even where multi-threading is claimed to support the execution of the two cognitive architectures above, the available descriptions fall short of addressing how the allocation of threads and memory impacts the operation\nRUTR-SCS13006 53/56\nof the system \u2013 that is, how it affects cognition \u2013 and conversely, how the system learns to adapt its load to the resources at its disposal \u2013 i.e. how cognition impacts the allocation of resources and improves it. In contrast, our approach places the interdependency of cognition and adaptation at the very heart of the design of control systems.\nOf all prior work, Wang's non-axiomatic reasoning approach (Wang 2006) shares with us by far the largest set of goals and assumptions. Wang has been virtually alone in championing the assumption of incomplete knowledge and limited resources (AIKR, Wang 2011), which we have adopted. His NARS (non-axiomatic reasoning system) is based on NAL (non-axiomatic logic), a novel term logic designed to handle uncertainty and growing experience. Its nine levels of expressivity, some of which share fundamental traits with our own logic (for example, equivalents of our likelihood, experience, reliability and success rate), are described in detail in Wang (2006).\nNARS is a work in progress \u2013 an implementation already exists including NAL levels up to six. Even though NAL is quite developed, defining a richer set of inferences than we have implemented so far in AERA\u2019s S1 (e.g. analogy making, detection of equivalences, similarity), it does not include representations of time at its very core \u2013 time is only handled at the periphery (NAL level 7), which makes it difficult to control real-time systems. Equations in NARS are treated as first-class citizens, encoded as networked independent terms. While its design is in some ways quite elegant it may be overly complicated for both learning and exploitation. However, compared to NARS AERA is limited in other ways \u2013 for example, its abstraction capabilities are less developed than NARS\u2019s.\nThese differences aside, and from a broader perspective, NARS\u2019s take on cognition is very similar to ours. As in AERA, cognition in NARS can be considered a by-product of allocating resources to cognitive elementary tasks, coupling cognition and resource allocation in a mutual and continual feedback loop. Due to NARS's potential to be (fully) implemented in the coming months or years, the differences and related underlying principles of our respective approaches can potentially be compared experimentally, a much faster path than relying solely on theoretical debate. Such comparison would likely results in improvements to both approaches.\nEven if our respective agendas differ on their over-arching goals - NARS is intended to capture features of human intelligence, whereas we want to build intelligent controllers for machinery \u2013 our principles are compatible and our systems, to some extent, exhibit common properties. This indicates that perhaps an adherence to AIKR is at least as important as other considerations and methodological issues when establishing the requirements for the design of cognitive architectures."}, {"heading": "8 Conclusion & Future Work", "text": "Generality and recursive self-improvement are key capabilities for systems intended to continually maintain their effective delivering of value to their owners, despite unforeseen and possibly adversarial situations. These are fundamental challenges for artificial general intelligence to which we, going beyond prior attempts in this direction, present experimental results and demonstrable solutions.\nWe have demonstrated an implemented architecture that can learn autonomously many things in parallel, at multiple time scales. The results show that AERA system S1 can learn complex multi-dimensional tasks from observation, while provided only with a small ontology, a few drives (high-level goals), and a few initial models, from which it can autonomously bootstrap its own development. This is initial evidence that our CAIM methodology, based on the principles of AER, is a way for escaping the constraints of current computer science and engineering methodologies. Human dia-\nRUTR-SCS13006 54/56\nlogue is an excellent example of the kinds of complex tasks current systems are incapable of handling autonomously. The fact that no difference of any importance can be seen in the performance between S1 and the humans in simulated face-to-face interview is an indication that the resulting architecture holds significant potential for further advances.\nThat being said, in its current incarnation AERA is entirely dependent on observation, as learning is exclusively triggered by unexpected goal achievement, or a prediction that turns out to be wrong \u2013 i.e. by surprise. This limits the acquisition of knowledge to phenomena that are directly observable \u2013 hidden causation is difficult for the current system to figure out, as are other kinds of inexplicit relations (similarity, equivalence, etc.). Another functionality the system lacks is some form of curiosity, as it is not able to produce hypotheses and conduct related experiments to eventually learn proactively, for the system to be intrinsically motivated to fill the gaps in its (inevitably limited) knowledge. One form of this is \u201cmotor babbling\u201d, which we have experimented with in the prototype to bootstrap learning. So far this has relied on ad-hoc hand-crafted goals injected into the system at strategic times by the designers, and therefore this technique was not allowed to be used in the S1 agent presented here. The question of how to generate such goals in a principled way automatically is currently being investigated. In an extension of the AIKR assumption, we have argued that curiosity results from the need to overcome the limitations imposed by the scarcity of inputs (Steunebrink et al. 2013). We plan to expand the types of programs to implement a richer set of inferences from which curious behaviors can be devised and planned, whenever the system has resources to spare. Interestingly, when improving the capabilities of our architecture thus far we have strictly proceeded by addition rather than by modification (\u201chacking\u201d): We conjecture that our methods are amenable to significant and tractable improvement, but far from claiming its theoretical universality we bet instead on its practical scalability, which leads us to our last and final remark.\nTo support the claim of achieving bounded self-improvement in general, one has to demonstrate a fundamental property namely, scalability. This work is still too recent for making an assessment to support such a claim. One of the main directions of our planned near-future work is thus set toward building more prototypes to provide more evidence for the generality of our system and, for its scalability. This endeavor, no doubt, will make use of the advanced self-modeling and self-control facilities that have been already implemented. In particular, we will leverage the self-compilation capacity mentioned in section 5.3, as one of the main thrusts toward scaling up."}, {"heading": "Acknowledgments", "text": "This work was supported by the European Project HUMANOBS \u2013 Humanoids that Learn Socio- Communicative Skills By Observation (FP7 STREP \u2013 Cognitive Robotics - Grant number 231453), and by research grants from RANNIS, Iceland. We are grateful to Th. Bryndis Thorisdottir for the design of the interview, Gunnar S. Valgardsson and Hrafn Th. Thorisson for the design of the avatars. Last but not least, we thank Pei Wang for valuable and constructive discussions."}, {"heading": "Simon, H. (1957). A Behavioral Model of Rational Choice. In Models of Man, Social and Rational: Mathematical Essays on Rational Human Behavior in a Social Setting. New York: Wiley.", "text": "Schmidhuber, J., Zhao, J., Schraudolph, N. (1997). Reinforcement learning with selfmodifying policies. In S. Thrun and L. Pratt, eds., Learning to learn, Kluwer, pages 293-309.\nSchmidhuber, J. (2006) G\u0151del machines: Fully self-referential optimal universal selfimprovers. In B. Goertzel and C. Pennachin, editors, Artificial General Intelligence, p"}, {"heading": "199-226. Springer Verlag.", "text": "Steunebrink, B. R., Schmidhuber, J. (2012). Towards an Actual G\u00f6del Machine Implementation. In P. Wang, B. Goertzel, eds., Theoretical Foundations of Artificial General Intelligence. Springer.\nSteunebrink, B. R., Koutnik J., Th\u00f3risson K. R., Nivel E. & Schmidhuber J. (2013). Resource-Bounded Machines are Motivated to be Efficient, Effective, and Curious. In K-U K\u00fchnberger, S. Rudolph and P. Wang (eds.), Proceedings of the Sixth Conference on Artificial General Intelligence (AGI-13), 119-129, Beijing, China.\nTh\u00f3risson, K. R. & Nivel, E. (2009). Achieving Artificial General Intelligence Through Peewee Granularity. Proceedings of the Second Conference on Artificial General Intelligence, 222-223, Arlington, VA, USA, March 6-9\nTh\u00f3risson, K. R. & Nivel, E. (2009). Holistic Intelligence: Transversal Skills and Current Methodologies. Proceedings of the Second Conference on Artificial General Intelligence, 220-221, Arlington, VA, USA, March 6-9\nTh\u00f3risson, K. R. (2009). From Constructionist to Constructivist A.I. Keynote, AAAI Fall Symposium Series - Biologically Inspired Cognitive Architectures, Washington D.C., November 5-7, 175-183. AAAI Tech Report FS-09-01, AAAI press, Menlo Park, CA\nTh\u00f3risson, K. R. (2012). A New Constructivist AI: From Manual Construction to SelfConstructive Systems. In P. Wang and B. Goertzel (eds.), Theoretical Foundations of Artificial General Intelligence. Atlantis Thinking Machines, 4:145-171.\nTh\u00f3risson, K. R. & Magnusson, M. S. (2013). Evaluating AGI-Aspiring Systems Via Human-Robot Interaction Using T-Patterns. Reykjavik University School of Computer Science Technical Report, RUTR-SCS13004.\nTh\u00f3risson, K. R. (forthcoming). Methodology Matters: Constructionism Challenged, Constructivism Challenges."}, {"heading": "Veness, J., Ng K. S., Hutter. M. Uther, W. & Silver, D. (2011) A Monte-Carlo AIXI Approximation. Journal of Artificial Intelligence Research (JAIR), 2011", "text": "Wang, P. (2006). Rigid Flexibility: The Logic of Intelligence. Springer, Dordrecht. 2006.\nWang, P. (2011). The assumptions on knowledge and resources in models of rationality. International Journal of Machine Consciousness, 3(1):193-218."}], "references": [{"title": "Thorisson for the design of the avatars. Last but not least, we thank Pei Wang for valuable and constructive discussions", "author": ["gardsson", "Hrafn Th"], "venue": "Analyse de la Structure Interactionnelle et des Strate\u0301gies discursive dans un talk-show. Psychologie Francaise,", "citeRegEx": "gardsson and Th.,? \\Q1993\\E", "shortCiteRegEx": "gardsson and Th.", "year": 1993}, {"title": "2013 to appear). LIDA: A Systems-level Architecture for Cognition, Emotion, and Learning", "author": ["S. Franklin", "T. Madl", "D'Mello", "Sidney K", "J. Snaider"], "venue": "Transactions on Autonomous Mental Development", "citeRegEx": "Franklin et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Franklin et al\\.", "year": 2012}, {"title": "Attention Capabilities for AI Systems", "author": ["H.P. Helgason", "K.R. Th\u00f3risson"], "venue": "Proceedings of the ninth International Conference on Informatics in Control, Automation and Robotics,", "citeRegEx": "Helgason and Th\u00f3risson,? \\Q2012\\E", "shortCiteRegEx": "Helgason and Th\u00f3risson", "year": 2012}, {"title": "General Attention Mechanism for Artificial Intelligence Systems", "author": ["P. Helgason H"], "venue": "PhD thesis,", "citeRegEx": "H.,? \\Q2013\\E", "shortCiteRegEx": "H.", "year": 2013}, {"title": "Universal Artificial Intelligence: Sequential decisions based on algorithmic probability", "author": ["M. Hutter"], "venue": null, "citeRegEx": "Hutter,? \\Q2005\\E", "shortCiteRegEx": "Hutter", "year": 2005}, {"title": "Personnality and Self-Esteem in Social Interaction. In From Communication to Presence: Cognition, Emotions and Culture towards the Ultimate Communicative Experience", "author": ["G.K. Jonsson"], "venue": "Edited by Riva G. et al. IOS Press,", "citeRegEx": "Jonsson,? \\Q2006\\E", "shortCiteRegEx": "Jonsson", "year": 2006}, {"title": "Evaluating Multimodal Human-Robot Interaction: A Case Study of an Early Humanoid Prototype", "author": ["G.K. Jonsson", "Th\u00f3risson K. R"], "venue": "Measuring Behavior 2010: Proceedings of the 7th International Conference on Methods and Techniques in Behavioral Research,", "citeRegEx": "Jonsson and R.,? \\Q2010\\E", "shortCiteRegEx": "Jonsson and R.", "year": 2010}, {"title": "The Soar Cognitive Architecture", "author": ["J.E. Laird"], "venue": null, "citeRegEx": "Laird,? \\Q2012\\E", "shortCiteRegEx": "Laird", "year": 2012}, {"title": "Hidden Real-Time Patterns in Intra- and Inter-Individual Behavior: Description and Detection", "author": ["M.S. Magnusson"], "venue": "European Journal of Psychological Assessment,", "citeRegEx": "Magnusson,? \\Q1996\\E", "shortCiteRegEx": "Magnusson", "year": 1996}, {"title": "Discovering hidden time Patterns in Behavior: T-patterns and their detection", "author": ["M.S. Magnusson"], "venue": "Behavior Research Methods, Instruments & Computers,", "citeRegEx": "Magnusson,? \\Q2000\\E", "shortCiteRegEx": "Magnusson", "year": 2000}, {"title": "An Ethological Study of Children\u2019s Behaviour", "author": ["W.C. McGrew"], "venue": null, "citeRegEx": "McGrew,? \\Q1972\\E", "shortCiteRegEx": "McGrew", "year": 1972}, {"title": "Report on a general problem-solving program", "author": ["A. Newell", "J.C. Shaw", "H.A. Simon"], "venue": "Proceedings of the International Conference on Information Processing", "citeRegEx": "Newell et al\\.,? \\Q1959\\E", "shortCiteRegEx": "Newell et al\\.", "year": 1959}, {"title": "Self-Programming: Operationalizing Autonomy", "author": ["E. Nivel", "K.R. Th\u00f3risson"], "venue": "Proceedings of the Second Conference on Artificial General Intelligence", "citeRegEx": "Nivel and Th\u00f3risson,? \\Q2009\\E", "shortCiteRegEx": "Nivel and Th\u00f3risson", "year": 2009}, {"title": "Prosodica Real-Time Prosody Tracker", "author": ["E. Nivel", "K.R. Th\u00f3risson"], "venue": "Reykjavik University School of Computer Science Technical Report RUTR08002", "citeRegEx": "Nivel and Th\u00f3risson,? \\Q2008\\E", "shortCiteRegEx": "Nivel and Th\u00f3risson", "year": 2008}, {"title": "Seed Specification for AERA S1 in Experiments 1 & 2", "author": ["E. Nivel", "K.R. Th\u00f3risson"], "venue": "Reykjavik University School of Computer Science Technical Report,", "citeRegEx": "Nivel and Th\u00f3risson,? \\Q2013\\E", "shortCiteRegEx": "Nivel and Th\u00f3risson", "year": 2013}, {"title": "A Simplest Systematics for the Organization of Turn-Taking", "author": ["H. Sacks", "Schegloff", "E. A", "G.A. Jefferson"], "venue": "in Conversation. Language,", "citeRegEx": "Sacks et al\\.,? \\Q1974\\E", "shortCiteRegEx": "Sacks et al\\.", "year": 1974}, {"title": "Minds, MIPS and structural feedback. In Performance Metrics for Intelligent Systems, PerMIS", "author": ["R. Sanz", "I. L\u00f3pez"], "venue": null, "citeRegEx": "Sanz and L\u00f3pez,? \\Q2000\\E", "shortCiteRegEx": "Sanz and L\u00f3pez", "year": 2000}, {"title": "Fridges, elephants and the meaning of autonomy and intelligence", "author": ["R. Sanz", "F. Mat\u00eda", "S. Gal\u00e1n"], "venue": "In IEEE International Symposium on Intelligent Control,", "citeRegEx": "Sanz et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Sanz et al\\.", "year": 2000}, {"title": "An Integrated Control Model of Consciousness", "author": ["R. Sanz"], "venue": "Proceedings of the conference Toward a Science of Consciousness", "citeRegEx": "Sanz,? \\Q2002\\E", "shortCiteRegEx": "Sanz", "year": 2002}, {"title": "Towards architectural foundations for cognitive", "author": ["R. Sanz", "C. Hern\u00e1ndez"], "venue": null, "citeRegEx": "Sanz and Hern\u00e1ndez,? \\Q2012\\E", "shortCiteRegEx": "Sanz and Hern\u00e1ndez", "year": 2012}, {"title": "A Behavioral Model of Rational Choice. In Models of Man, Social and Rational: Mathematical Essays on Rational Human Behavior in a Social Setting", "author": ["H. Simon"], "venue": null, "citeRegEx": "Simon,? \\Q1957\\E", "shortCiteRegEx": "Simon", "year": 1957}, {"title": "Reinforcement learning with selfmodifying policies", "author": ["J. Schmidhuber", "J. Zhao", "N. Schraudolph"], "venue": "Learning to learn,", "citeRegEx": "Schmidhuber et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Schmidhuber et al\\.", "year": 1997}, {"title": "G\u0151del machines: Fully self-referential optimal universal selfimprovers", "author": ["J. Schmidhuber"], "venue": "Artificial General Intelligence,", "citeRegEx": "Schmidhuber,? \\Q2006\\E", "shortCiteRegEx": "Schmidhuber", "year": 2006}, {"title": "Towards an Actual G\u00f6del Machine Implementation", "author": ["B.R. Steunebrink", "J. Schmidhuber"], "venue": null, "citeRegEx": "Steunebrink and Schmidhuber,? \\Q2012\\E", "shortCiteRegEx": "Steunebrink and Schmidhuber", "year": 2012}, {"title": "Resource-Bounded Machines are Motivated to be Efficient, Effective, and Curious", "author": ["Steunebrink B. R", "J. Koutnik", "R. Th\u00f3risson K", "E. Nivel", "J. Schmidhuber"], "venue": "Proceedings of the Sixth Conference on Artificial General Intelligence", "citeRegEx": "R. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "R. et al\\.", "year": 2013}, {"title": "Achieving Artificial General Intelligence Through Peewee Granularity", "author": ["K.R. Th\u00f3risson", "E. Nivel"], "venue": "Proceedings of the Second Conference on Artificial General Intelligence,", "citeRegEx": "Th\u00f3risson and Nivel,? \\Q2009\\E", "shortCiteRegEx": "Th\u00f3risson and Nivel", "year": 2009}, {"title": "Holistic Intelligence: Transversal Skills and Current Methodologies", "author": ["K.R. Th\u00f3risson", "E. Nivel"], "venue": "Proceedings of the Second Conference on Artificial General Intelligence,", "citeRegEx": "Th\u00f3risson and Nivel,? \\Q2009\\E", "shortCiteRegEx": "Th\u00f3risson and Nivel", "year": 2009}, {"title": "From Constructionist to Constructivist A.I. Keynote, AAAI Fall Symposium Series - Biologically Inspired Cognitive Architectures, Washington D.C., November 5-7, 175-183", "author": ["K.R. Th\u00f3risson"], "venue": "AAAI Tech Report FS-09-01,", "citeRegEx": "Th\u00f3risson,? \\Q2009\\E", "shortCiteRegEx": "Th\u00f3risson", "year": 2009}, {"title": "A New Constructivist AI: From Manual Construction to SelfConstructive Systems", "author": ["K.R. Th\u00f3risson"], "venue": "Theoretical Foundations of Artificial General Intelligence. Atlantis Thinking Machines,", "citeRegEx": "Th\u00f3risson,? \\Q2012\\E", "shortCiteRegEx": "Th\u00f3risson", "year": 2012}, {"title": "Evaluating AGI-Aspiring Systems Via Human-Robot Interaction Using T-Patterns", "author": ["K.R. Th\u00f3risson", "M.S. Magnusson"], "venue": "Reykjavik University School of Computer Science Technical Report,", "citeRegEx": "Th\u00f3risson and Magnusson,? \\Q2013\\E", "shortCiteRegEx": "Th\u00f3risson and Magnusson", "year": 2013}, {"title": "A Monte-Carlo AIXI Approximation", "author": ["J. Veness", "Ng K. S", "W. Hutter. M. Uther", "D. Silver"], "venue": "Journal of Artificial Intelligence Research (JAIR),", "citeRegEx": "Veness et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Veness et al\\.", "year": 2011}, {"title": "Rigid Flexibility: The Logic of Intelligence", "author": ["P. Wang"], "venue": null, "citeRegEx": "Wang,? \\Q2006\\E", "shortCiteRegEx": "Wang", "year": 2006}, {"title": "The assumptions on knowledge and resources in models of rationality", "author": ["P. Wang"], "venue": "International Journal of Machine Consciousness,", "citeRegEx": "Wang,? \\Q2011\\E", "shortCiteRegEx": "Wang", "year": 2011}], "referenceMentions": [{"referenceID": 12, "context": "In Nivel and Th\u00f3risson (2009) we proposed a stringent definition of an autonomous system, as a system that is operationally and semantically closed.", "startOffset": 3, "endOffset": 30}, {"referenceID": 20, "context": "We have adopted this definition as one of the anchors of our work, being much in line with Simon\u2019s concept of \u201cbounded rationality\u201d (Simon 1957).", "startOffset": 132, "endOffset": 144}, {"referenceID": 30, "context": "Wang (2011) merged these two assumptions into one, called AIKR \u2013 the assumption of insufficient knowledge and resources \u2013 which then forms the basis of his working definition of intelligence: \u201cTo adapt with insufficient knowledge and limited resources\u201d.", "startOffset": 0, "endOffset": 12}, {"referenceID": 3, "context": "For a discussion about the fundamental impact of attention on the control of autonomous systems, see Helgason (2013), Helgason & Th\u00f3risson (2012), and Helgason et al.", "startOffset": 101, "endOffset": 117}, {"referenceID": 3, "context": "For a discussion about the fundamental impact of attention on the control of autonomous systems, see Helgason (2013), Helgason & Th\u00f3risson (2012), and Helgason et al.", "startOffset": 101, "endOffset": 146}, {"referenceID": 3, "context": "For a discussion about the fundamental impact of attention on the control of autonomous systems, see Helgason (2013), Helgason & Th\u00f3risson (2012), and Helgason et al. (2013).", "startOffset": 101, "endOffset": 174}, {"referenceID": 5, "context": "Our results are analyzed using t-patterns (Magnusson 1996, 2000; Jonsson & Th\u00f3risson 2010; Th\u00f3risson et al. 2013), a method for extracting hierarchies of significant temporal patterns in multi-dimensional source data. Unlike more simplistic statistical measurements, the t-pattern approach we use for analyzing the results of E2 has the unusual feature of giving a rather holistic picture of the overall behavior of the system it is applied to. For readers unfamiliar with this technique we refer to Magnusson (1996, 2000) and Thorisson & Magnusson (2013). The patterns emerging in t-pattern analysis are dependent on three factors: The source material itself, how well it is coded, and the settings of particular analysis parameters.", "startOffset": 65, "endOffset": 556}, {"referenceID": 27, "context": "The seed for S1 in E1 is described in detail in Nivel & Th\u00f3risson (2013); in short, it consists of a set of primitive commands (move hand, grab, release, point at) and a set of dimensions for the input space (object type, color, actor\u2019s role, speech).", "startOffset": 56, "endOffset": 73}, {"referenceID": 5, "context": "A closer comparison between S1 and other human-human data further suggests that the turn-taking reaches a \u201cmean level\u201d patterning quickly, as is the case in dyadic interaction between friends (Jonsson 2006).", "startOffset": 192, "endOffset": 206}, {"referenceID": 27, "context": "1 above, as is the seed (see also Nivel & Th\u00f3risson (2013)).", "startOffset": 42, "endOffset": 59}, {"referenceID": 31, "context": "Of these, Wang's stands out for taking a strong experience-grounded approach that we would classify as constructivist-centric, and his is the only work that obviously shares our goal of transversal life-long adaptation under an assumption of incomplete knowledge and limited resources (Wang 2006).", "startOffset": 285, "endOffset": 296}, {"referenceID": 22, "context": "Indeed, the original algorithm (Schmidhuber 2006) proposes that the searcher enumerate theorems through Universal Search until it sees one which happens to contain a positive statement about self-modification.", "startOffset": 31, "endOffset": 49}, {"referenceID": 21, "context": "The spirit of this approach is more in line with other work of Schmidhuber et al. (1997), although AERA is designed to work in real-world, real-time scenarios.", "startOffset": 63, "endOffset": 89}, {"referenceID": 7, "context": "Two frequently referenced architectures that aim for comprehensiveness over universality, SOAR (Laird 2012) and LIDA (Franklin et al.", "startOffset": 95, "endOffset": 107}, {"referenceID": 31, "context": "Of all prior work, Wang's non-axiomatic reasoning approach (Wang 2006) shares with us by far the largest set of goals and assumptions.", "startOffset": 59, "endOffset": 70}, {"referenceID": 3, "context": "His NARS (non-axiomatic reasoning system) is based on NAL (non-axiomatic logic), a novel term logic designed to handle uncertainty and growing experience. Its nine levels of expressivity, some of which share fundamental traits with our own logic (for example, equivalents of our likelihood, experience, reliability and success rate), are described in detail in Wang (2006).", "startOffset": 0, "endOffset": 373}], "year": 2013, "abstractText": "Four principal features of autonomous control systems are left both unaddressed and unaddressable by present-day engineering methodologies: 1. The ability to operate effectively in environments that are only partially known beforehand at design time; 2. A level of generality that allows a system to re-assess and re-define the fulfillment of its mission in light of unexpected constraints or other unforeseen changes in the environment; 3. The ability to operate effectively in environments of significant complexity; and 4. The ability to degrade gracefully \u2013 how it can continue striving to achieve its main goals when resources become scarce, or in light of other expected or unexpected constraining factors that impede its progress. We describe new methodological and engineering principles for addressing these shortcomings, that we have used to design a machine that becomes increasingly better at behaving in underspecified circumstances, in a goal-directed way, on the job, by modeling itself and its environment as experience accumulates. Based on principles of autocatalysis, endogeny, and reflectivity, the work provides an architectural blueprint for constructing systems with high levels of operational autonomy in underspecified circumstances, starting from only a small amount of designer-specified code \u2013 a seed. Using a valuedriven dynamic priority scheduling to control the parallel execution of a vast number of lines of reasoning, the system accumulates increasingly useful models of its experience, resulting in recursive self-improvement that can be autonomously sustained after the machine leaves the lab, within the boundaries imposed by its designers. A prototype system has been implemented and demonstrated to learn a complex real-world task \u2013 real-time multimodal dialogue with humans \u2013 by on-line observation. Our work presents solutions to several challenges that must be solved for achieving artificial general intelligence.", "creator": "Microsoft\u00ae Word 2010"}}}