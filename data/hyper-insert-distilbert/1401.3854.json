{"id": "1401.3854", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "A Constraint Satisfaction Framework for Executing Perceptions and Actions in Diagrammatic Reasoning", "abstract": "diagrammatic reasoning ( dr ) is pervasive in human problem solving as a powerful adjunct to symbolic reasoning based on language - like representations. the research reported in this paper is a contribution to building a general purpose dr system as an extension to a soar - like problem solving architecture. the work is in a framework in which dr is modeled as a process where subtasks are solved, as appropriate, either by inference from symbolic representations or by interaction with a diagram, i. e., perceiving specified information from a diagram or modifying / creating objects in a diagram in specified ways according to problem solving needs. the perceptions and actions in most dr systems built so far are hand - coded for the specific application, even when the rest of the system is built using the general architecture. the absence of a general framework for executing perceptions / actions poses as a major hindrance to using them opportunistically - - the essence of open - ended search in problem solving. our goal is to develop a framework for executing a wide variety of specified perceptions and actions across tasks / domains without human intervention. we observe that the domain / task - specific visual perceptions / actions can be transformed into domain / task - independent spatial problems. we specify a spatial problem as a quantified constraint satisfaction problem in the real domain using an open - ended vocabulary of properties, relations and actions involving three kinds of diagrammatic objects - - points, curves, regions. solving a spatial problem from this specification requires computing the equivalent simplified quantifier - free expression, the complexity of which md is comparatively inherently doubly exponential. we currently represent objects encoded as configuration of simple graphic elements chosen to facilitate decomposition of a complex problems broken into simpler areas and similar subproblems. yet we show further that, if developing the symbolic solution applicable to a subproblem can be expressed either concisely, quantifiers can be eliminated individually from spatial dimension problems in making low - spatial order linear polynomial time using those similar structure previously solved subproblems. executing this mapping requires essentially determining half the similarity of two problems, the existence process of such a visual mapping between them computable in polynomial bit time, and for designing a memory manifold for both storing previously solved boundary problems and so large as to equally facilitate search. the efficacy of modeling the idea is shown by time complexity analysis. simultaneously we demonstrate the proposed approach by successfully executing perceptions sequences and actions involved occurring in dr matching tasks in two semantic army framework applications.", "histories": [["v1", "Thu, 16 Jan 2014 05:00:46 GMT  (3717kb)", "http://arxiv.org/abs/1401.3854v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["bonny banerjee", "b chandrasekaran"], "accepted": false, "id": "1401.3854"}, "pdf": {"name": "1401.3854.pdf", "metadata": {"source": "CRF", "title": "A Constraint Satisfaction Framework for Executing Perceptions and Actions in Diagrammatic Reasoning", "authors": ["Bonny Banerjee", "B. Chandrasekaran"], "emails": ["banerjee.28@osu.edu", "chandra@cse.ohio-state.edu"], "sections": [{"heading": null, "text": "Our goal is to develop a framework for executing a wide variety of specified perceptions and actions across tasks/domains without human intervention. We observe that the domain/task-specific visual perceptions/actions can be transformed into domain/taskindependent spatial problems. We specify a spatial problem as a quantified constraint satisfaction problem in the real domain using an open-ended vocabulary of properties, relations and actions involving three kinds of diagrammatic objects \u2013 points, curves, regions. Solving a spatial problem from this specification requires computing the equivalent simplified quantifier-free expression, the complexity of which is inherently doubly exponential. We represent objects as configuration of simple elements to facilitate decomposition of complex problems into simpler and similar subproblems. We show that, if the symbolic solution to a subproblem can be expressed concisely, quantifiers can be eliminated from spatial problems in low-order polynomial time using similar previously solved subproblems. This requires determining the similarity of two problems, the existence of a mapping between them computable in polynomial time, and designing a memory for storing previously solved problems so as to facilitate search. The efficacy of the idea is shown by time complexity analysis. We demonstrate the proposed approach by executing perceptions and actions involved in DR tasks in two army applications."}, {"heading": "1. Introduction", "text": "The research reported in this paper is a contribution to building problem solving agents in artificial intelligence (AI) that use diagrams, much as people do, but most of AI does not, given the almost exclusive emphasis in AI on language-like or predicate-symbolic representations. Diagrammatic reasoning (DR) is an emerging area of research in a number\nc\u20dd2010 AI Access Foundation. All rights reserved.\nof fields, including AI (Glasgow, Narayanan, & Chandrasekaran, 1995; Chandrasekaran, Kurup, & Banerjee, 2005), logic (Barwise & Etchemendy, 1998; Allwein & Barwise, 1999), and psychology (Tversky, 2000; Tricket & Trafton, 2006). While all research in DR is in one way or other dealing with diagrams, different research issues are addressed by different researchers. The research reported in this paper considers DR as a problem solving activity in which an agent (human or artificial) makes use of two forms of representation \u2013 a spatial representation in the form of 2D diagrams and a symbolic representation that contains information in a predicate-symbolic form similar to logic and natural language. A schematic DR architecture, as proposed by Chandrasekaran et al. (2002, 2004, 2005), is illustrated in Figure 1."}, {"heading": "1.1 Diagrammatic Reasoning as a Problem Solving Activity", "text": "The DR architecture shares the idea of problem solving as search in problem state space (Laird, Rosenbloom, & Newell, 1986; Newell, 1990). In this approach, starting from an initial state, the agent applies operators to bring about state transitions to reach the goal state. A goal is either reached or decomposed into subgoals by the use of general and domain knowledge. Reaching a goal or subgoal requires information which is generated in the traditional problem solving architectures (e.g., soar in Laird, Newell, & Rosenbloom, 1987, act-r in Anderson, 1993) by inference using predicate-symbolic representation. In the DR architecture, the agent can extract information from diagrams by applying perceptionlike operations in addition to inference using predicate-symbolic representation to reach the goal/subgoal. The agent can also create or modify objects in a diagram that propose new states from which the goal might be reached with subsequent perceptions and inferences.\nTo illustrate our conceptualization of DR, let us consider a real-world problem. An army commander, planning strategic operations, uses a terrain map to chalk out a path for his troops to safely travel from one base camp location L1 to another L2 within a given time. The information he has is regarding the nature of the terrain (e.g., slow-go or no-go regions, altitude of different parts of the terrain, the speed at which his troops can travel in different kinds of terrain) and an estimate of the maximum firepower range of the enemy. The commander, being a veteran in the field, is well aware of the possibility that his troops might be ambushed along any path by the enemy who might be hiding in the neighboring regions. His problem solving might proceed as follows. A diagram consisting of the part of\nthe terrain map of interest for this particular problem is given, along with the peripheries of the no-go regions and the two points, L1 and L2 (see Figure 2(a)). The commander draws one of the shorter paths from L1 to L2 maintaining a maximum distance from the neighboring no-go regions (see Figure 2(b)). He knows what kinds of spatial relations between points on the route and the points where the enemy could be hiding correspond to ambush potential. He then uses that knowledge to perceive (and mark) the portions of the path that are prone to ambush due to enemies hiding behind the neighboring no-go regions (see Figure 2(c)). If no such portion is found, the path is inferred to be safe. If the length of a safe path can be traversed in the given time, it is considered a suitable path for the operation. If the path drawn is not safe or does not satisfy the time constraint, another path is drawn (see Figure 2(d)) and analyzed. This procedure continues until all paths have been exhausted. If a suitable path is still not found, the least risky path might be considered for the operation. In the worst case, the commander might infer that this operation is not possible. A problem in a similar vein, as described above, has been considered by Forbus, Usher, and Chapman (2003).\nIn the above example, it is noteworthy how the problem solver (the commander) opportunistically brings together symbolic knowledge (such as, the firepower range of enemies) and perception and action on a diagram to solve a real-world problem. Such a phenomenon is characteristic of DR whenever it is used to solve problems in different domains, such as, economics, geometry, engineering, computer-aided design, military, and so on. We observe that executing the perceptions and actions require solving purely spatial problems with no involvement of domain knowledge. These spatial problems can be described in terms of diagrammatic objects, such as, points, curves, and regions, and spatial properties (e.g., length of a curve) and relations (e.g., point on a curve) involving them. For example, perceiving the portions of a path prone to ambush due to enemies hiding behind a mountain range requires computing the set of points q on a curve (the path) c1 such that q is within a specified distance (the firepower range) d from some point p on a curve (the mountain range) c2 (see Figure 22(b)). Formally, this can be written as\nRiskyPortionsofPath(q, c1, c2, d) \u2261 On(q, c1)\u2227\u2203p,On(p, c2)\u2227DistanceLessThan(p, q, d)\nDistanceLessThan(p, q, d) \u2261 Distance(p, q) \u2264 d\nwhere p is a point. In this paper, we propose a general and efficient framework for spatial problem solving to autonomously execute perceptions and actions in DR.\n1.2 What Do We Mean by a \u201cDiagram\u201d?\nDefinition 1. Diagram. A diagram D is a set of labeled 2D objects {O1,O2, ...On} all located clearly inside (i.e., no intersection or touching) a common region (or bounding box) B. The objects are of three types \u2013 points, curves, regions.\nDefinition 2. Diagrammatic Object. A diagrammatic object O is a 3-tuple < L, T , E > where L is a label, T is a type (point, curve or region), and E is its spatial extent. The spatial extent of a diagrammatic object is the set of points constituent of the object.\nDefinition 3. Diagrammatic Image. The diagrammatic image, I, of a diagram is the set of points constituent of all objects in the diagram. Thus, if D= {O1,O2, ...On} is a diagram where Oi =<L(Oi),T (Oi),E(Oi) >, then its diagrammatic image I(D) is given by\nI(D) = n\u222a\ni\u21901 E(Oi)\nThis definition of a diagram, due to Chandrasekaran et al. (2002, 2004, 2005), supports the functional representation of a diagram in an artificial agent. A diagram on an external medium (e.g., piece of paper, computer screen) is, at one level, an image consisting of pixels with different intensities. At another level, it is an interpreted representation consisting of spatial objects in some domain of interest. The abstract diagram is ideal, i.e., the points are dimensionless, curves have no thickness, etc. In an external diagram, points and curves consist of at least one pixel with finite dimensions. We will need to interchange between the two forms of diagrams for reasoning and interaction purposes. In the rest of the paper,\nthe term \u201cdiagram\u201d will refer to an abstract diagram only, unless otherwise stated. We are interested only in diagrams that are line drawings with no color or intensity variation. Such diagrams form a substantial class of diagrams in everyday use."}, {"heading": "1.3 Perceptions and Actions in Diagrammatic Reasoning", "text": "Definition 4. Perception. A perception is an act of extracting a new piece of information from a diagram. The new piece of information satisfies constraints specified in terms of properties and relations among existing objects in the diagram and is a boolean or a real number or a diagrammatic object(s). Thus, a perception P is a mapping from a diagram D to a set of booleans {True, False} or real numbers \u211c or a set of diagrammatic objects D\u2032 satisfying constraints C.\nP : D C\u2212\u2192 {True, False} \u222a \u211c \u222a D\u2032 , I(D\u2032) \u2286 I(D)\nDefinition 5. Action. An action is an act of introducing a new object(s), or modifying or deleting an existing object(s) in a diagram satisfying constraints specified in terms of properties and relations among existing objects. Thus, an action A is a mapping from a diagram D to a new set of diagrammatic objects D\u2032 satisfying constraints C.\nA : D C\u2212\u2192D\u2032 , I(D) \u0338= I(D\u2032)\nIn the last couple of decades, numerous DR systems have been built for different applications in different domains. In the following we review some well-known DR systems where a problem solving agent reasons using diagrams. This review will help realize the role of perception and action in DR, and the spatial problems implicit in such perceptions and actions.\nSketchy (Pisan, 1995) is a computer implementation of a model of graph understanding. It recognizes the diagrammatic objects - points, lines, regions, and a vocabulary of properties and relations that includes coordinate at point, right of, above, inside, steeper, bigger, vertical, change in slope, touches, intersects, on line, on border, forms border, etc. for representing conceptual relationships in domains, such as, thermodynamics and economics. A domain translator is responsible for converting domain-specific conceptual questions into domain-independent graphical relations. Examples of perception from a supply-demand graph in economics include how price effects the supply, demand, and market price of the product, which requires solving visual problems, such as, \u201cAt what point is supply equal to demand?\u201d (corresponding spatial problem: compute the intersection of two curves), \u201cWhat is the price for the supply line when the quantity is 350?\u201d (corresponding spatial problem: compute a point on a curve whose one coordinate is given), \u201cAre the quantity and price directly proportional?\u201d (corresponding spatial problem: check whether the slope of a curve between two points is a positive constant or not), \u201cAre the quantity and price inversely proportional?\u201d (corresponding spatial problem: check whether the slope of a curve between two points is a negative constant or not), etc. Actions in this model are not required due to the nature of its task. Examples of graphs understood by sketchy are shown in Figure 3.\nThe redraw system (Tessler et al., 1995) combines diagrammatic and symbolic reasoning to qualitatively determine the deflected shape of a frame structure under a load, a structural analysis problem in civil engineering. It uses a vocabulary of properties and relations including get-angular-displacement, get-displacement, symmetrical-p, connected-to, near, left, above, rotate, bend, translate, smooth, etc. on three kinds of diagrammatic objects \u2013 lines, splines, circles. Though most properties and relations are domain-independent, some, such as, bend reflect the assumptions implicit in the domain and the task and can be defined accordingly. Perceptions and actions are called inspection and manipulation operators in the system. The underlying representation is a combination of a grid-based and Cartesian coordinates \u2013 shapes are represented using the grid where each element in the grid corresponds to a point in the diagram while lines are represented by a set of coordinate points. Examples of perception and action include deflecting a beam in the same direction as the load, checking whether a beam and column are perpendicular at a particular rigid joint, etc. which require solving visual problems, such as, \u201cBend Beam3 in the negative direction of the y-axis\u201d (corresponding spatial problem: compute a curve with a given slope at a given point), \u201cMake the angle between Beam3 and Column3 at Joint3 90 degrees without modifying Beam3\u201d (corresponding spatial problem: compute a curve such that it makes a particular angle at a given point with a given curve), \u201cGet the angle between Beam3 and Column3 at the ends connected by Joint3\u201d (corresponding spatial problem: compute the angle between two curves at a given point), etc. An example of a deflected frame analysis by redraw is shown in Figure 4.\nThe archimedes system (Lindsay, 1998) assists a human in demonstrating theorems in Euclidean geometry by modifying/creating diagrams according to his instructions and thereafter perceiving/inferencing from the diagram. It operates on two diagrammatic objects - points and line segments, and recognizes shapes, such as, square, triangle, path, etc. The underlying representation is array- or grid-based. The perceptions, called retrieval processes, are of different classes, such as, verify relationship, test for a condition, etc. The actions, called construction processes, are also of different classes, such as, create an object with certain properties, transform an object, etc. Executing the perceptions and actions require solving spatial problems, such as, create a segment parallel to a given segment through a given point, rotate an object and check whether it coincides with another object, etc. An example of a geometry theorem demonstrated by archimedes is shown in Figure 5.\nThe diamond (Jamnik, 2001), a system for proving mathematical theorems, uses a sequence of actions on diagrams assisted by a human to prove specific ground instances and then generalizes by induction. It uses a mixture of Cartesian and topological representations to represent a dot (equivalent to a point in Cartesian representation) as a diagrammatic object in the discrete space, and a line and an area (or region) as diagrammatic objects in the continuous space. Elementary shapes, such as, row, column, ell, and frame, are constructed from dots, while derived shapes, such as, square, triangle, rectangle, etc. are constructed from the elementary or other derived shapes. The vocabulary consists of atomic or onestep operations (e.g., rotate, translate, cut, join, project from 3D to 2D, remove, insert a segment, etc.). Spatial problems in this system are composite operations composed from the atomic ones, such as, draw a right-angled triangle, translate and rotate a triangle, etc. The system does not need to execute perceptions as information from a diagram is perceived by\na human who decides what actions to be applied during the proof search. An example of a mathematical theorem proven by diamond is shown in Figure 6.\nGeorep (Ferguson & Forbus, 2000) takes as input a line drawing in vector graphics representation and creates a predicate calculus representation of the drawing\u2019s spatial relations. Five primitive shape types are recognized, namely line segments, circular arcs, circles and ellipses, splines (open and closed), and positioned text. Properties and relations, such as, proximity detection, orientation detection (e.g., horizontal, vertical, above, beside), parallelism, connectivity (e.g., detecting corner, intersection, mid-connection, touch), etc. are deployed to accomplish its task. The underlying representation is vector graphics or line drawings. Systems, such as, magi (Ferguson, 1994), juxta (Ferguson & Forbus, 1998), and coadd are built using georep for symmetry detection, critiquing diagrams based on their captions, and producing a description of the units, areas, and tasks from a course of action diagram, respectively. georep, due to the limitation of its task, does not need to execute any action. Examples of visual problems in georep include figuring out which cup contains more liquid (corresponding spatial problem: compare the areas of polygons representing the cups), determine whether a figure is symmetric or not (corresponding spatial problem: check whether one polygon is congruent to the reflection of the other polygon), etc. An example of ambush analysis by georep is shown in Figure 7.\nThe preceding discussion leads to the observation that all DR systems require perceiving from and/or acting on diagrams, and that every perception/action requires solving a domain-independent spatial problem. Thus, a general-purpose DR system for solving problems for applications across multiple domains would require solving a large variety of non-trivial domain-independent spatial problems. These spatial problems can be described\nin terms of three diagrammatic objects \u2013 points, curves, regions, and spatial properties and relations involving them."}, {"heading": "1.4 The Problem", "text": "How are the perceptions and actions solved in a DR system? Typically, the human developing a DR system identifies a priori the problem solving steps including a set of perceptions and actions, and hand-codes efficient algorithms for solving each of them. If the problem solving steps need to be altered in future and as a result, a new perception arises, the developer has to write another algorithm for obtaining its solution. Thus, algorithms need to be hand-coded for each perception/action. Clearly, this is inconvenient and time consuming in developing a DR system, and does not allow fast and easy experimentation with different problem solving strategies for the same problem. These drawbacks are further magnified when the goal is to build a general-purpose DR system where a very large variety of perceptions and actions are possible which is not feasible to ascertain a priori, and develop and store algorithms for. Hence, our goal is to investigate a spatial problem solver (SPS) for efficiently solving spatial problems implicit in perceptions/actions without human intervention.1"}, {"heading": "1.5 Contributions", "text": "In this paper, we make the following contributions:\n1. We observe that the wide variety of visual perceptions/actions for DR applications can be transformed into domain/task-independent spatial problems. We developed a language for specifying spatial problems (i.e., spatial relations or actions) as quantified constraint satisfaction problems (QCSPs) in first-order logic using a fixed set of mathematical/logical operators in the real domain and an open-ended vocabulary of properties, relations and actions. Any spatial relation or action involving only points that can be expressed using those operators and real variables in first-order logic can be included in the vocabulary. Further, any spatial relation or action involving curves and/or regions that can be expressed using the relations On(p, c) and/or Inside(p, r) where p is a point, c is a curve, r is a region, and any relation/action involving only points in first-order logic can be included in our vocabulary. The vocabulary grows richer as more spatial relations and actions are specified.\n2. Any spatial relation or action that can be included in the vocabulary is solvable by our SPS. Real QCSPs are known to be computationally intractable, so a substantial part of the spatial problem solving literature concentrates on constraint satisfaction problems (CSPs). We developed a general framework for solving spatial problems specified as QCSPs. The framework bypasses the process of quantifier elimination (QE) \u2013 the computational bottleneck and a doubly exponential problem \u2013 by taking the help of previously solved similar spatial problems. We show that, if the symbolic solution to a problem can be expressed\n1. The reader should keep the DR architecture in mind. As shown in Figure 1, there are two problem solvers \u2013 the main problem solver which will be always referred to as the \u201cproblem solver\u201d (this might be a human) and the spatial problem solver which will be referred to as the \u201cSPS\u201d (this strictly has no human intervention). The problem solver is responsible for the entire problem solving strategy including converting domain-specific perceptions and actions into domain-independent spatial problems. The SPS is responsible only for solving the domain-independent spatial problems that it receives from the problem solver. It is important to not get confused between the roles played by the two.\nconcisely, quantifiers can be eliminated from spatial problems in low-order polynomial time using similar previously solved problems. The framework leaves room to be more efficient and convenient by incorporating future results in at least two possible directions \u2013 learning constraints from examples (automatic constraint acquisition) and carefully exploiting a rich portfolio of QE algorithms.\nThe rest of the paper is organized as follows. In the next section, we discuss the language for specifying a spatial problem to the SPS. Section 3 describes the SPS. Section 4 analyzes the computational complexity of the SPS. Section 5 shows how the proposed SPS can be augmented to a traditional AI problem solver (soar) for reasoning with diagrams in two real-world applications. Finally, we end with discussion and conclusion."}, {"heading": "2. Specification Language", "text": "In this section, we discuss a high-level language that is finite, extensible, human-usable, and expressive enough to describe a wide variety of 2D spatial problems relevant to DR. The problems specified in this language will be accepted as input by the SPS and solved without human intervention. The specification language is independent of the SPS, i.e., the problem specification remains unchanged even if the underlying representation and reasoning strategy of the SPS change."}, {"heading": "2.1 Diagrammatic Objects", "text": "The specification language recognizes three kinds of diagrammatic objects \u2013 points, curves, regions. Point. A point is the basic diagrammatic object. The other objects are defined in terms of a set of points. Curve. A curve is the set of points on it. We approximate a curve piecewise-linearly. Thus, if curve c is approximated by the sequence of n points {p1, p2, ...pn}, then c is the set of points that lies on its constituent line segments, i.e.\nc \u2261 {p : On(p, {p1, p2}) \u2228On(p, {p2, p3}) \u2228 ...On(p, {pn\u22121, pn})}\nwhere p \u2190 (x, y), x, y \u2208 \u211c, and {pi, pi+1} is the line segment from pi to pi+1. We call the points {p1, p2, ...pn} vertex points. For the sake of simplicity of specification, the problem solver will write the sequence of vertex points {p1, p2, ...pn} to specify a curve c. Region. A region is the set of points inside its boundary. The boundary of a region is a closed curve which is approximated piecewise-linearly. Thus, a region is a simple (convex or concave) polygon. Any simple polygon can be triangulated such that a point inside the region is inside one of the triangles. Thus, if the boundary of region r is approximated by the sequence of n points {p1, p2, ...pn}, then\nr \u2261 {p : Inside(p,\u25b3(r)[1]) \u2228 Inside(p,\u25b3(r)[2]) \u2228 ...Inside(p,\u25b3(r)[m])}\nwhere m is the number of triangles in region r after triangulation, \u25b3(r)[i] is the ith triangle of r, and p \u2190 (x, y), x, y \u2208 \u211c. For the sake of simplicity of specification, the problem solver will write the sequence of vertex points {p1, p2, ...pn} of the boundary curve to specify a\nregion r. Whether a sequence of vertex points corresponds to a curve or a region will be determined automatically by the system from the context of the property/relation predicate. More on how we define On and Inside in section 3.1.\nFurther, the SPS can be asked to recognize the kind of diagrammatic object(s) obtained as the solution to a spatial problem. This is achieved by the function Recognize(Dext) where Dext is an external diagram (i.e., constituted of pixels unlike an abstract diagram). For example, the set of all points behind a curve c with respect to a given point p can be a region object or a curve object depending on the nature of c and its location with respect to p. In order to recognize the output, the SPS colors the corresponding set of pixels on an external diagram where each pixel at some predetermined resolution corresponds to a point. The set of colored pixels are grouped such that two adjacent pixels always belong to the same group. Each group of pixels constitutes a diagrammatic object. The boundary pixels of each group is determined. If a group consists of less than three pixels, we consider it as a point object. If a group consists of more than two pixels and its width (both horizontal and vertical) is always less than three pixels, we consider it as a curve object. Otherwise, the group constitutes a region object."}, {"heading": "2.2 Vocabulary", "text": "Unlike certain well-known qualitative spatial reasoning calculi (e.g., intersection calculus in Egenhofer, 1991, cardinal direction calculus in Frank, 1991, region connection calculus in Randell, Cui, & Cohn, 1992), we are not interested in finding a minimal set of spatial relations nor is our vocabulary based on a closed set of predicates. Rather, our vocabulary is based on a closed set of operators (to be discussed shortly in section 2.3). The spatial relations and actions that can be included in our vocabulary are as follows:\n1. Any spatial relation or action involving only points that can be expressed using the fixed set of operators and real variables in first-order logic.\n2. Any spatial relation or action involving points, curves or regions that can be expressed in first-order logic using the fixed set of operators, real variables, any relation/action from #1, and the relations On(p, c) and/or Inside(p, r) where p is a point, c is a curve, r is a region.\n3. Any spatial relation or action involving points, curves or regions that can be expressed in first-order logic using the fixed set of operators, real variables, and any relation/action from #1 and #2.\nThus, our vocabulary is open-ended and addition of new properties and relations is encouraged when a problem cannot be easily expressed using the existing ones. The observation is that, a human often encounters new perceptions/actions but most of them can be specified using the already known ones. However, having a large vocabulary helps specify new ones more conveniently. From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains. The same vocabulary will be used in this paper as a starting point for specifying spatial problems. In what follows are a few examples of properties, relations and actions in our vocabulary.\nProperties. Associated with each kind of object are a few properties \u2013 location of a point; location, closedness and length of a curve; and location, area and periphery of a region, where the periphery of a region refers to its boundary curve. The user can also define particular shapes (e.g., circle, triangle, annulus, etc.) for curves and regions as appropriate for reasoning in his domain. Different shapes might have their own specific properties, such as, radius of a circle, height of a triangle, etc. which can be easily associated with the objects in our vocabulary by the user. DR also requires solving spatial problems concerning a discrete set of points. For such problems, properties, such as, Centroid(S) and V ariance(S), where S is a set of points, are included in the vocabulary.\nRelations. The vocabulary also contains a few widely used relations (or relational predicates) involving points, such as, Leftof(p1, p2), Topof(p1, p2), Collinear(p1, p2, p3), Between(p1, p2, p3) where p1, p2, p3 are points. Any other relation involving points can be included in the vocabulary as needed. On(p, c), where p is a point and c a curve, is the fundamental relation involving a curve while Inside(p, r), where p is a point and r a region, is the fundamental relation involving a region in our vocabulary as any other relation involving curves or regions uses On and/or Inside. Some of the relational predicates involving curves or regions in our vocabulary are Intersect(c1, c2), IntersectionPoints(q, c1, c2), Touches(c1, c2), Subcurveof(c1, c2) where c1, c2 are curves, and Subregionof(r1, r2) where r1, r2 are regions.\nActions. Further, there is a set of predicates for identifying emergent objects or modifications of existing objects. For example, Translate(q,O, tx, ty) returns a translation of object O for tx units along x-axis and ty units along y-axis, Rotate(q,O, c, \u03b8) returns a rotation of the object O with respect to point c as center for \u03b8 degrees in the anti-clockwise direction, Reflect(q,O, {a, b}) returns a reflection of object O with respect to the line segment {a, b} (i.e., from point a to point b), Scale(q,O, c, sx, sy) returns a scaling of the object O with respect to point c for sx units along x-axis and sy units along y-axis. When O is a curve or region, each of these predicates is defined using the corresponding action involving a point and the predicates On and/or Inside."}, {"heading": "2.3 The Language", "text": "This is the language in which the problem solver (human or artificial) specifies a spatial problem to the SPS. The internal representations of objects, properties, relations, and the problem-solving strategies are hidden from the problem solver. The specification language remains unchanged even if the underlying representation or problem-solving strategy is changed. We use first-order predicate logic as the specification language, previously reported by Banerjee and Chandrasekaran (2007).\nOperators. The language recognizes a set of boolean operators {\u2227,\u2228,\u00ac}, a set of arithmetic operators {+,\u2212,\u00d7,\u00f7}, a set of relational operators {<,>,=, \u0338=}, and the quantifiers {\u2203,\u2200}. The brackets () are used to express precedence while the brackets {} are used to express a set. In this paper, we will often use certain combination of operators, such as, \u2264, \u2265, \u21d2, etc. for the sake of brevity.\nDomain. The language allows the problem solver to specify the domain as a set from which the variables can assume values. Unless otherwise stated, the domain is the real plane \u211c2 for a point variable and the real line \u211c for a non-diagrammatic variable.\nFunctions. Further, the language recognizes two functions \u2013 Maximize(f, {x, y, ...}, C) and Minimize(f, {x, y, ...}, C), which maximizes and minimizes the function f with respect to the variables {x, y, ...} satisfying the boolean combination of constraints C (which might involve quantifiers) and returns the maximum and minimum value of f respectively along with the conditions on the variables.\nQuantified Constraint Satisfaction Problem. An instance of a constraint satisfaction problem (CSP) consists of a tuple < V, D, C > where V is a finite set of variables, D is a domain, and C= {C1, ...Ck} is a set of constraints. A constraint Ci consists of a pair < Si,Ri > where Si is a list of mi variables and Ri is a mi-ary relation over the domain D. The question is to decide whether or not there is an assignment mapping each variable to a domain element such that all the constraints are satisfied. All of the variables in a CSP can be thought of as being implicitly existentially quantified.\nA useful generalization of the CSP is the quantified constraint satisfaction problem, where variables may be both existentially and universally quantified. An instance of the QCSP consists of a quantified formula in first-order logic, which consists of an ordered list of variables with associated quantifiers along with a set of constraints. A QCSP can be expressed as follows:\n\u03d5(v1, ...vm) \u2261 Q(xn, ...x1)\u03d5\u2032(v1, ...vm, x1, ...xn) Q(xn, ...x1) \u2261 Qnxn, ...Q1x1\nwhere Qi \u2208 {\u2200,\u2203}, {x1, ...xn} is the set of quantified variables, {v1, ...vm} is the set of free variables, V= {v1, ...vm, x1, ...xn}, and \u03d5\u2032 is a quantifier-free expression called the matrix. Such representation of a quantified expression \u03d5, where it is written as a sequence of quantifiers followed by the matrix, is referred to as prenex form. Example of a QCSP is as follows:\nSubcurveof(c1, c) \u2261 \u2200p,On(p, c1) \u21d2 On(p, c)\nwhere c1, c are curves in \u211c2. In this example, there are two constraints:\n< {p, c1}, On > < {p, c}, On >\nFurther, V= {p} and D = \u211c2. The variables c, c1 are given. The question here is to decide whether there is an assignment mapping p to an element in \u211c2 such that the logical combination of constraints is not satisfied. If such an assignment exists, then c1 is not a subcurve of c; otherwise it is.\nDecision, Function and Optimization problems. In the proposed specification language, a spatial problem \u03d5 is expressed as a QCSP where V consists of variables of type point, curve or region and D = \u211c2. Solving a spatial problem involves:\n1. When there are no free variables in V (i.e., all variables in V are quantified), deciding whether or not there exists a mapping from V to D satisfying C.\n2. When there are free variables in V, computing the conditions on the free variables such that a mapping from V to D satisfying C exists.\nThus, a spatial problem can be classified as a decision or a function or an optimization problem in the real domain. The first case constitutes a decision problem and yields a True or False solution. The second case constitutes a function problem which involves computing the diagrammatic object(s) described by the conditions on the free variables. If a spatial problem requires computing the \u201cbest\u201d mapping from V to D satisfying C, it is called an optimization problem.\nLet us consider an example. Given a curve c and two points p, q, the spatial problem BehindCurve(q, c, p) is defined as deciding whether or not q is behind c with respect to p. This might be specified as deciding whether or not the curve c and line segment {p, q} intersect. Thus,\nBehindCurve(q, c, p) \u2261 Intersect(c, {p, q})\nFor particular instances of q, p, c, the solution to this problem is True or False, hence it is a decision problem (see Figure 8). For particular instances of p, c, and generalized coordinates of q i.e., q \u2190 (x, y), the solution to the same problem is a logical combination of conditions involving x and y, which when plotted constitutes a region object (see Figure 9). Hence, it is a function problem. While a decision problem merely requires checking whether or not a given instance of an object satisfies the constraints or not, a function problem requires computing all conditions for a general object to satisfy the constraints.\nAgain, given a curve c and two points p, q, the spatial problem FurthestBehindCurve(q, c, p) is defined as deciding whether or not q is the furthest point behind c with respect to p. This might be specified as deciding whether or not q lies behind c with respect to p and\ndistance between p and q is maximum. Thus,\nFurthestBehindCurve(q, c, p) \u2261 BehindCurve(q, c, p) \u2227 \u2200b,BehindCurve(b, c, p) \u21d2 CompareDistance(b, p, q, p)\nCompareDistance(a, b, c, d) \u2261 Distance(a, b) \u2264 Distance(c, d)\nFor particular instances of q, p, c, the solution to this problem is True or False, hence it is a decision problem. For particular instances of p, c, and generalized coordinates of q i.e., q \u2190 (x, y), the solution to the same problem is a logical combination of conditions involving x and y, which when plotted constitutes a single point object, assuming there is only one furthest point behind c with respect to p, which is dependent on the nature of c and how the Distance function is defined (see Figure 10).\nAn alternative way of specifying the same problem FurthestBehindCurve(q, c, p) is by explicitly asking to maximize the distance between p and q where q satisfies the constraint BehindCurve(q, c, p), written as:\nFurthestBehindCurve(q, c, p) \u2261 Maximize(Distance(q, p), {q}, BehindCurve(q, c, p))\nThis outputs the conditions involving x and y, which constitutes a single point object. The Maximize (orMinimize) function assumes the pool of candidates from which to choose the best are those that satisfy the set of constraints. This fact has to be stated explicitly if not using the Maximize (or Minimize) function which makes the specification more difficult to come up with and also cumbersome. On the flip side, the specification of a problem using the Maximize (or Minimize) function cannot be used as a decision problem. That is, whether or not a particular instance of an object is the best candidate that satisfies the\nconstraints cannot be computed from this specification, unlike the former specification. A problem of this type, which computes the best candidate out of a pool of candidates, is called an optimization problem.\nDefinition 6. Spatial Problem. A spatial problem (or problem) is a QCSP where a variable (quantified or free) can only be of type point, and the domain is \u211c2.\nThus, a spatial problem \u03d5 is a mapping from a diagram D satisfying a logical combination of constraints C to a set of booleans {True, False} or real numbers \u211c or diagrammatic objects D\u2032, i.e.,\n\u03d5 : D C\u2212\u2192{True, False} \u222a \u211c\u222aD\u2032\nSolving a spatial problem requires eliminating the quantifiers and solving algebraic equations/inequalities to arrive at the most simplified expression. The computational bottleneck in solving a spatial problem is quantifier elimination (QE) which is inherently doubly exponential (Davenport & Heintz, 1988). More recently, Brown and Davenport (2007) have shown that real QE is doubly-exponential even when there is only one free variable and all polynomials in the quantified input are linear. In this paper, we will concentrate primarily on QE as part of spatial problem solving and hence, our solution will be an equivalent quantifier-free expression but not necessarily the most simplified one. Theoretically, the best complexity for QE achieved so far is O(s(l+1)\u03a0(ki+1)d(l+1)\u03a0ki) where s is the number of polynomials, their maximum degree is d and coefficients are real, l is the number of free variables, ki is the number of variables in the i th quantifier block while k = \u2211\nki is the number of quantified variables (Basu, Pollack, & Roy, 2003). However, this algorithm is too complicated to yet have a practical implementation. The most general and elaborately implemented method for real QE is the cylindrical algebraic decomposition or CAD (Collins\n& Hong, 1991), complexity of which is (sd)O(1) k\u22121\n. Another implemented method, QE by virtual substitution (Weispfenning, 1988), is restricted to formulas in which the quantified variables occur at most quadratically. The complexity of this method is doubly exponential in the number of blocks of variables delimited by alternations of the existential and universal quantifiers. Thus, while there exist general algorithms for QE, for large real-world problems, it soon becomes too time consuming."}, {"heading": "3. Spatial Problem Solver", "text": "In this paper, we concentrate on developing an efficient SPS without sacrificing its generality. The goal of our design of the SPS is to bypass the general QE algorithms as much as possible, either by taking the help of previously solved similar problems in memory to obtain the solution or by using a set of more practical algorithms each of which is developed for a limited class of problems. Here we describe the overall control mechanism of the SPS (see Figure 11).\nIn many domains, such as, military, spatial problems involve diagrammatic objects that are arbitrary shaped (e.g., mountainous regions) and often cannot be approximated enough by well-defined shapes so that the solution can reliably depend on the specifics of the shape. For example, the solution to the problem of finding all places behind a mountain where one can hide from the enemy depends critically on the particular shape of the mountain. Due to such nature of domains, we choose to represent curves piecewise-linearly and regions as polygons. Piecewise-linear curves and polygonal regions are unions of line segments and triangular regions respectively, which facilitate decomposition of complex problems into simpler and similar subproblems. We observe that similar subproblems involving both existential and universal quantifiers occur regularly in the spatial problem solving process which are solved by one of the QE algorithms (e.g., CAD), thereby incurring doubly exponential time. We minimize this enormous computational cost by reusing the solutions of subproblems previously solved.\nGiven a spatial problem \u03d5 in the specification language, the SPS replaces numerical values in the problem by symbolic variables, and then transforms the symbolic problem from specification to a modeling language (to be described shortly) by progressively replacing objects/predicates by base objects/predicates in their internal definitions. If a definition cannot be found, it flags an error and halts till provided. As a first step, the SPS decomposes \u03d5 into disjunctions and/or conjunctions of subproblems \u03d5i in prenex form. As we will see later, all of these subproblems \u03d5i are similar to each other in that if one of them can be solved, solution to any of the others can be computed from it. Next, it searches the memory for problems similar to \u03d5i. The memory contains symbolic problems and their corresponding quantifier-free symbolic solutions. If \u03d5i can be mapped to one of these problems, its solution is readily obtained by reverse-mapping from the corresponding symbolic solution in memory. Obtaining a solution in such a way completely bypasses the QE process, which is the computational bottleneck of the SPS, thereby reducing the computational costs considerably. If SPS cannot map \u03d5i to any problem in memory, it sends \u03d5i to the problem classifier that classifies and sends it to the appropriate QE algorithm. The problem classifier and combination of QE algorithms have been borrowed from Mathematica (Wolfram, 2003). Once the SPS solves a new subproblem, the subproblem and its solution are stored\nin memory so that the solution can be used when a similar problem is encountered in future. Thus, the SPS grows more efficient as it solves more problems. Finally, the SPS computes the solution to the given problem \u03d5 by combining the solutions of all its subproblems.\nUnfortunately, for some problems, quantifiers cannot be eliminated symbolically in reasonable time. The SPS tries for a prescribed time, after which it resorts to more practical\nmethods, such as, techniques especially suited for low degree polynomials (e.g., Dolzmann, Sturm, & Weispfenning, 1998) and approximate methods for obtaining a subset of the solution sufficient for immediate purposes (e.g., Ratschan, 2006; Lasaruk & Sturm, 2006). It has been shown, in integer linear programming (e.g., Leyton-Brown, Nudelman, & Shoham, 2002) and satisfiability testing (e.g., Xu, Hutter, Hoos, & Leyton-Brown, 2008), that the best on-average solver can be out-performed by carefully exploiting a portfolio of possibly poorer on-average solvers, and accordingly, researchers have experimented with different ways of selecting a portfolio of solvers (see for example, Xu et al., 2008; Pulina & Tacchella, 2007; Sayag, Fine, & Mansour, 2006; Streeter, Golovin, & Smith, 2007; Gebruers, Hnich, Bridge, & Freuder, 2005; O\u2019Mahony, Hebrard, Holland, Nugent, & O\u2019Sullivan, 2008). As none of these work involve solving QCSPs over the real domain, they are not directly usable for our purposes and will not be further discussed in this paper. However, we do expect the same result to extend to QCSP solvers over the real domain, and building and smartly selecting from a portfolio of QCSP solvers is a promising line of future research. In our approach, once a subproblem is deemed symbolically unsolvable in the prescribed time, its specification is stored in memory so that in future, a similar problem can be directly subjected to practical methods, thereby saving the prescribed time."}, {"heading": "3.1 Modeling Language", "text": "This is the language in which a problem is described in terms of the underlying representations of objects/properties/relations in a form that can be readily subjected to algebraic manipulation. The location of a point p is represented as a pair (x, y), x, y \u2208 \u211c, as its coordinates.\nNotation. The x- and y-coordinates of a point p are denoted by p.x and p.y respectively.\nThe distance between two points, p and q, is given by Distance(p, q) \u2261 \u221a (p.x\u2212 q.x)2 + (p.y \u2212 q.y)2\nThe location of a curve c is represented by the sequence of vertex points {p1, p2, ...pn}. Notation. The number of vertex points in a curve c is denoted by #(c), the ith vertex point is denoted by c[i], and the ith line segment is denoted by {c[i], c[i+ 1]}. A line segment ls is specified by its pair of vertex (or terminal) points. The x- and y-coordinates of ls are represented parametrically as\nfx(ls, t) \u2261 ls[1].x+ t\u00d7 (ls[2].x\u2212 ls[1].x)\nfy(ls, t) \u2261 ls[1].y + t\u00d7 (ls[2].y \u2212 ls[1].y)\nwhere t is a parameter, 0 \u2264 t \u2264 1. The relation On(p, ls), where p is a point, is given by\nOn(p, ls) \u2261 \u2203t, 0 \u2264 t \u2264 1 \u2227 fx(ls, t) = p.x \u2227 fy(ls, t) = p.y\nLength of a line segment ls is given by\nLength(ls) \u2261 Distance(ls[1], ls[2])\nLength of a curve c is given by\nLength(c) \u2261 #(c)\u22121\u2211 i\u21901 Length({c[i], c[i+ 1]})\nThe location of a region r is represented by the location of its periphery which is a piecewise linear closed curve. As discussed in section 2.1, internally a region is triangulated (computable in linear time as shown in Chazelle, 1991; Seidel, 19912) with the aim of reducing and simplifying computations (more on this in section 3.2).\nNotation. On triangulation, the number of triangles in a region r is denoted by #\u25b3(r) while the ith triangle in r is denoted by \u25b3(r)[i].\nThe area of a triangle \u25b3 is given by Area(\u25b3) \u2261 12 3\u2211\ni\u21901 \u25b3[i].x\u00d7\u25b3[i\\3 + 1].y \u2212\u25b3[i\\3 + 1].x\u00d7\u25b3[i].y\nNote that the area of a triangle is positive if the sequence of vertex points on its periphery are given in a counter-clockwise direction, otherwise it is negative. Area of a region r is given by\nArea(r) \u2261 #\u25b3(r)\u2211 i\u21901 Area(\u25b3(r)[i])\nThe relation Inside(p,\u25b3), where p is a point and \u25b3 is a triangle, is given by\nInside(p,\u25b3) \u2261 \u22273i\u21901Leftof(p, {\u25b3[i],\u25b3[i\\3 + 1]})\nLeftof(p, ls) \u2261 Area({ls[1], ls[2], p}) > 0\nwhere ls is a line segment. The action Translate(q, c, tx, ty) where q \u2190 (x, y), c is a curve, and tx, ty are real numbers, is given by\nTranslate(q, p, tx, ty) \u2261 q.x = p.x+ tx \u2227 q.y = p.y + ty\nTranslate(q, c, tx, ty) \u2261 \u2200a,On(a, c) \u21d2 Translate(q, a, tx, ty)\nDefinition 7. Base Object. A base object is the simplest form of a diagrammatic object. A point is its own simplest form. A line segment is the simplest form of a curve. A triangular region is the simplest form of a region. Thus, internally, there are three base objects \u2013 point, line segment, triangle.\nDefinition 8. Base Predicate. A base predicate is a predicate which accepts only the base objects as arguments.\n2. Vik (2001) discusses an implementation in Mathematica.\nExamples of base predicates include Leftof(p1, p2), Between(p1, p2, p3), On(p, ls), Inside(p,\u25b3), where p, p1, p2, p3 are points, ls is a line segment, \u25b3 is a triangular region.\nLemma 1. On(p, c) \u2261 \u2228#(c)\u22121i\u21901 On(p, {c[i], c[i+ 1]})\nProof. The proof follows from our representation of a curve, as described in section 2.1.\nLemma 2. Inside(p, r) \u2261 \u2228#\u25b3(r)i\u21901 Inside(p,\u25b3(r)[i])\nProof. The proof follows from our representation of a region, as described in section 2.1.\nThe relations included in the vocabulary are internally defined in terms of base predicates. For example, the predicate, Intersect(c1, c2) where c1, c2 are curves, is defined in terms of base predicates as\nIntersect(c1, c2)\n\u2261 \u2203a,On(a, c1) \u2227On(a, c2)\n\u2261 \u2203a,\u2228#(c1)\u22121i\u21901 On(a, {c1[i], c1[i+ 1]}) \u2227 \u2228 #(c2)\u22121 j\u21901 On(a, {c2[j], c2[j + 1]})"}, {"heading": "3.2 Decomposing a Problem", "text": "Definition 9. Decomposition. Decomposition is the process of replacing the relational predicates, involving free variables of types curve and region, in a spatial problem (quantified expression) by conjunctions/disjunctions of base predicates and taking those conjunctions/disjunctions to the front of the expression. The expression following those conjunctions/disjunctions is a subproblem.\nExample. Decomposition of the problem Intersect(c1, c2) \u2261 \u2203a,On(a, c1) \u2227 On(a, c2) occurs as follows:\nIntersect(c1, c2) \u2261 \u2203a,On(a, c1) \u2227On(a, c2)\n\u2261 \u2203a,\u2228#(c1)\u22121i\u21901 On(a, {c1[i], c1[i+1]})\u2227\u2228 #(c2)\u22121 j\u21901 On(a, {c2[j], c2[j+1]}) (before decomposition)\n\u2192 \u2228#(c1)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 \u2203a,On(a, {c1[i], c1[i+1]})\u2227On(a, {c2[j], c2[j+1]}) (after decomposition)\n\u2261 \u2228#(c1)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 Intersect \u2032({c1[i], c1[i+ 1]}, {c2[j], c2[j + 1]})\nwhere Intersect\u2032({c1[i], c1[i+ 1]}, {c2[j], c2[j + 1]}) is a subproblem. However, the question arises \u2013 is Intersect(c1, c2) \u2261 \u2228#(c1)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 Intersect\n\u2032({c1[i], c1[i+1]}, {c2[j], c2[j+1]})? That is, can we replace the \u201c\u2192\u201d by a \u201c\u2261\u201d?\nTheorem 1. A problem is equivalent before and after decomposition if and only if it does not contain the following forms:\nF1: \u2203p,On(p, c) \u2227 \u00acInside(p, r)\nF2: \u2200p,\u00acOn(p, c) \u2228 Inside(p, r) (complement of F1)\nF3: \u2203p, Inside(p, r) \u2227 \u00acInside(p, r1)\nF4: \u2200p,\u00acInside(p, r) \u2228 Inside(p, r1) (complement of F3)\nwhere c is a curve, r, r1 are regions, and c, r, r1 are free variables.\nProof. As discussed in section 2.2, in our framework, On(p, c) and Inside(p, r) are the two fundamental relations using which any other relation involving a curve or region is specified. Also, in our framework, point is the only quantifiable variable, {\u2200,\u2203} are the only quantifiers, and {\u2227,\u2228,\u00ac} are the boolean operators sufficient to express any boolean expression. Thus, any spatial problem involving only curves (and points but no regions) is a logical combination of smaller problems of the following form:\nQp,Rel(p, c) where Q \u2208 {\u2203,\u2200}, Rel \u2208 {On,\u00acOn}\nAny spatial problem involving only regions (and points but no curves) is a logical combination of smaller problems of the following form:\nQp,Rel(p, c) where Q \u2208 {\u2203,\u2200}, Rel \u2208 {Inside,\u00acInside}\nAny spatial problem involving both curves and regions (and points) is a logical combination of smaller problems of the following form:\nQp,Rel1(p, c)\u2299Rel2(p, r) where Q \u2208 {\u2203,\u2200}, Rel1 \u2208 {On,\u00acOn}, Rel2 \u2208 {Inside,\u00acInside}, \u2299 \u2208 {\u2227,\u2228}\nAny spatial problem involving two curves, c and c1, (and points) is a logical combination of smaller problems of the following form:\nQp,Rel1(p, c)\u2299Rel2(p, c1) where Q \u2208 {\u2203,\u2200}, Rel1 \u2208 {On,\u00acOn}, Rel2 \u2208 {On,\u00acOn}, \u2299 \u2208 {\u2227,\u2228}\nAgain, any spatial problem involving two regions, r and r1, (and points) is a logical combination of smaller problems of the following form:\nQp,Rel1(p, r)\u2299Rel2(p, r1) where Q \u2208 {\u2203,\u2200}, Rel1 \u2208 {Inside,\u00acInside}, Rel2 \u2208 {Inside,\u00acInside}, \u2299 \u2208 {\u2227,\u2228}\nWe symbolically solved each of the above problems (56 total) in two ways \u2013 directly and by decomposing \u2013 for p \u2190 (x, y), c \u2190 {p1, p2, ...pn} (n \u2265 2), pi \u2190 (xpi , ypi), c1 \u2190 {a1, a2, ...au}\n(u \u2265 2), ai \u2190 (xai , yai), r \u2190 {q1, q2, ...qm} (m \u2265 3), qi \u2190 (xqi , yqi), and r1 \u2190 {b1, b2, ...bv} (v \u2265 3), bi \u2190 (xbi , ybi). It turned out that the solutions from the two ways were equivalent for all problems, except the four cases stated in the theorem statement. Note that F2 is the specification for computing whether a curve c is entirely inside a region r or not. Let lsi be the i\nth line segment of c (1 \u2264 i \u2264 n \u2212 1) and \u25b3j be the jth triangular region of r (1 \u2264 j \u2264 m\u2212 2). We found\n\u2200p,\u00acOn(p, c) \u2228 Inside(p, r)\n\u2261 \u2200p,\u00ac(\u2228n\u22121i\u21901On(p, lsi)) \u2228 (\u2228 m\u22122 j\u21901 Inside(p,\u25b3j))\n\u2261 \u2200p,\u2227n\u22121i\u21901 \u2228 m\u22122 j\u21901 (\u00acOn(p, lsi) \u2228 Inside(p,\u25b3j))\n\u0338\u2261 \u2227n\u22121i\u21901 \u2228 m\u22122 j\u21901 (\u2200p,\u00acOn(p, lsi) \u2228 Inside(p,\u25b3j))\nThat is because, for c to be entirely inside r, it is not necessary for all line segments of c to be inside a triangle of r; a line segment of c can span across multiple triangles of r and c can still be inside r. Figure 12(a) shows an example where c is inside r but a line segment of c spans across two triangles of r. In such a case, the solution to the problem will be True when computed directly but will be False when computed via decomposition. The first case F1 in the theorem statement can be explained similarly. The forms F1 and F2 can be rewritten as follows:\nF1 : \u2203p,On(p, c) \u2227 \u00acInside(p, r)\n\u2261 \u2203p,On(p, c) \u2227 Inside(p, r) where r \u2261 B \u2212 r\nF2 : \u2200p,\u00acOn(p, c) \u2228 Inside(p, r)\n\u2261 \u2200p,\u00acOn(p, c) \u2228 \u00acInside(p, r) where r \u2261 B \u2212 r\nwhere B is the rectangular region (boundary) containing the diagram as discussed in section 1.2. Note that each of the rewritten forms is equivalent before and after decomposition.\nAgain, F4 is the specification for computing whether a region r is entirely inside a region r1 or not. Let \u25b31,i be the ith triangle of r1 (1 \u2264 i \u2264 v \u2212 2) and \u25b3j be the jth triangular region of r (1 \u2264 j \u2264 m\u2212 2). We found\n\u2200p,\u00acInside(p, r) \u2228 Inside(p, r1)\n\u2261 \u2200p,\u00ac(\u2228m\u22122j\u21901 Inside(p,\u25b3j)) \u2228 (\u2228 v\u22122 i\u21901Inside(p,\u25b31,i))\n\u2261 \u2200p,\u2227m\u22122j\u21901 \u2228 v\u22122 i\u21901 (\u00acInside(p,\u25b3j) \u2228 Inside(p,\u25b31,i))\n\u0338\u2261 \u2227m\u22122j\u21901 \u2228 v\u22122 i\u21901 (\u2200p,\u00acInside(p,\u25b3j) \u2228 Inside(p,\u25b31,i))\nThat is because, for r to be entirely inside r1, it is not necessary for all triangles of r to be inside a triangle of r1; a triangle of r can span across multiple triangles of r1 and r can still be inside r1. Figure 12(b) shows an example where r is inside r1 but a triangle of r spans across two triangles of r1. In such a case, the solution to problem will be True when computed directly but will be False when computed via decomposition. The third case F3 in the theorem statement can be explained similarly. The forms F3 and F4 can be rewritten as follows:\nF3 : \u2203p, Inside(p, r) \u2227 \u00acInside(p, r1)\n\u2261 \u2203p, Inside(p, r) \u2227 Inside(p, r1) where r1 \u2261 B \u2212 r1\nF4 : \u2200p,\u00acInside(p, r) \u2228 Inside(p, r1)\n\u2261 \u2200p,\u00acInside(p, r) \u2228 \u00acInside(p, r1) where r1 \u2261 B \u2212 r1\nAgain, each of the rewritten forms is equivalent before and after decomposition.\nTheorem 2. Any subproblem resulting from decomposing a problem contains base predicates only.\nProof. A problem \u03d5 is decomposable due to the presence of relational predicates, involving free variables of types curve and region, in its specification. As stated in section 2.2, a problem involving a curve or region can be specified in our framework using a relation(s) involving only points and the relation On or Inside. Thus, a relation Rel(q, c) involving a point q and a curve c can be rewritten as:\nRel(q, c) \u2261 \u2203a,On(a, c) \u2227Rel\u2032(q, a) or\nRel(q, c) \u2261 \u2200a,On(a, c) \u21d2 Rel\u2032(q, a)\nwhere Rel\u2032 is a base predicate involving the points q and a. In both cases, the expression on the right-hand side of \u2018\u2261\u2019 contains base predicates only. Let \u03d5 be a problem involving points and curves but no regions. Let us replace in \u03d5 each occurrence of non-base predicates involving a curve, such as, Rel(q, c), by their equivalent expression consisting of On and base predicates involving points and line segments only. Then the resulting expression for \u03d5 consists of base predicates involving points only and On. By lemma 1, a non-base On can be rewritten as disjunctions of base On. Therefore, the resulting expression for \u03d5 consists of base predicates involving points only.\nSimilarly, a relation Rel(q, r) involving a point q and a region r can be rewritten as:\nRel(q, r) \u2261 \u2203a, Inside(a, r) \u2227Rel\u2032(q, a) or Rel(q, r) \u2261 \u2200a, Inside(a, r) \u21d2 Rel\u2032(q, a)\nwhere Rel\u2032 is a base predicate involving the points q and a. If \u03d5 is a problem involving points and regions but no curves, replacing each occurrence of non-base predicates involving a region, such as, Rel(q, r), by their equivalent expression consisting of Inside and base predicates involving points only, and then using lemma 2, results in an expression for \u03d5 consisting of base predicates involving points and triangular regions only. Both the above processes can be employed when \u03d5 involves both curves and regions. Thus, any subproblem resulting from decomposing a problem will contain base predicates only."}, {"heading": "3.3 Mapping to a Similar Problem", "text": "Definition 10. Similarity. We define two spatial problems (quantified expressions) to be similar if there exists a one-to-one correspondence between their variables (free and quantified).\nGiven two similar problems, \u03d51 and \u03d52, and the solution \u03c21 of \u03d51, the goal is to construct a one-to-one mapping \u0393 between the variables of \u03d51 and \u03d52 such that the solution of \u03d52 can be obtained by replacing the variables in \u03c21 by the corresponding variables, thereby completely bypassing the QE process \u2013 the computational bottleneck of SPS. The one-toone mapping exists if \u03d51 and \u03d52 are logically equivalent. However, equivalence checking for logical expressions is NP-hard (Dershowitz & Jouannaud, 1990; Goldberg & Novikov, 2003). Thus, equivalence checking cannot be used to determine similarity efficiently.\nProblem features. Let \u03d5\u2032 be the quantifier free expression when \u03d5 is expressed in prenex form, i.e.,\n\u03d5(v1, ...vm) \u2261 Q(xn, ...x1)\u03d5\u2032(v1, ...vm, x1, ...xn)\nwhere no variable xi appears more than once in Q and Q contains no redundant variables. A quantifier block qb of Q is a maximal contiguous subsequence of Q where every variable in qb has the same quantifier type. The quantifier blocks are ordered by their sequence of appearance in Q; qb1 \u2264 qb2 iff qb1 is equal to or appears before qb2 in Q. Each quantified\nvariable xi in \u03d5 \u2032 appears in some quantifier block qb(xi), and the ordering of the quantifier blocks imposes a partial order on the quantified variables. The variables in the same quantifier block are unordered.\nLet \u03d51 \u2261 Q1\u03d5\u20321 and \u03d52 \u2261 Q2\u03d5\u20322 while \u03c41 and \u03c42 be the parse trees for \u03d5\u20321 and \u03d5\u20322 respectively. For example, the matrix \u03d5\u2032 of a problem \u03d5 in conjunctive normal form might look like:\n\u03d5\u2032 \u2261 P1 \u2227 (P2 \u2228 P3) \u2227 (P4 \u2228 \u00acP5 \u2228 P6) \u2227 ...\nwhere each Pi is a predicate. If \u03d5 is a subproblem, each Pi is a base predicate. The parse tree of the above sentence is shown in Figure 13.\nTwo trees, \u03c41 and \u03c42, are isomorphic if there exists a bijection \u03c7 : \u03c41 \u2192 \u03c42 that preserves adjacency and root vertex, i.e., \u03c7(u) is adjacent to \u03c7(w) \u21d4 u is adjacent to w, and \u03c7(root(\u03c41)) = root(\u03c42). It follows that two isomorphic trees have the same maximum height and the same number of vertices at any height. Let l be the maximum height of \u03c4 and \u03bdi be the number of vertices at height i. The function \u03be, defined as\n\u03be(< \u03bb1, ...\u03bb\u03ba >) = \u03ba\u220f i\u21901 \u03c1\u03bbii\nwhere \u03bbi is an integer, <> denotes a sequence, and \u03c1i is the i th smallest prime number, maps a sequence of integers to an unique integer. From a problem \u03d5, a tuple \u03d1(\u03d5) can be constructed as follows:\n\u03d1(\u03d5) = < l, \u03be(# vertices at different heights of parse tree), # quantifier blocks, order of quantifier blocks, \u03be(# variables in different quantifier blocks) >\nDefinition 11. Structural Equivalence. Two spatial problems (quantified expressions), \u03d51 and \u03d52, are structurally equivalent if they satisfy all of the following conditions: 1. \u03d1(\u03d51) = \u03d1(\u03d52) 2. \u03c41 and \u03c42 are isomorphic to each other, where \u03c41 and \u03c42 are the parse trees of the matrices of \u03d51 and \u03d52 respectively. 3. The contents (predicate or boolean operator {\u2227,\u2228,\u00ac}) of each pair of corresponding nodes of \u03c41 and \u03c42 are identical. 4. There exists a one-to-one correspondence between the variables in the arguments of predicates contained in each pair of corresponding nodes of \u03c41 and \u03c42. Moreover, any two mappings obtained from two pairs of corresponding nodes of \u03c41 and \u03c42 do not contradict each other.\nAs we will see in section 4, structural equivalence of two problems can be computed in time linear in the size of their parse trees. Note that if two problems are structurally equivalent, they will be logically equivalent but not vice versa. For example, the expressions (P \u2227\u00acP )\u2228Q and Q, where P and Q are base predicates, are logically equivalent, but not structurally equivalent since their parse trees are not isomorphic. In general, logical equivalence does not imply structural equivalence when there are redundancies (redundant variables and/or predicates) in one or both problems. For the sake of computational efficiency, we will use structural equivalence to determine the similarity of two problems.\nTheorem 3. All subproblems obtained by decomposing a problem are always similar.\nProof. Let us assume, for a contradiction, there exists a problem \u03d5 that decomposes into subproblems such that two of them, \u03d5j and \u03d5k, are dissimilar. Without loss of generality, assume that all subproblems of \u03d5 except \u03d5k are similar to \u03d5j . Then,\n\u03d5\n\u2261 (\u2228n1i1=1 \u2227 n2 i2=1 ... \u2228npip=1 Qi1i2...ip\u03d5i1i2...ip)\u2299Qk\u03d5k, \u2299 \u2208 {\u2228,\u2227}, \u03d5j \u2208 {\u03d5i1i2...ip |0 \u2264 i1 \u2264 n1, 0 \u2264 i2 \u2264 n2, ...0 \u2264 ip \u2264 np}, Qj \u2208 {Qi1i2...ip |0 \u2264 i1 \u2264 n1, 0 \u2264 i2 \u2264 n2, ...0 \u2264 ip \u2264 np}\n\u2261 \u2228n1i1=1 \u2227 n2 i2=1 ... \u2228npip=1 (Qi1i2...ipQk)(\u03d5i1i2...ip \u2299 \u03d5k)\n\u2261 \u2228n1i1=1 \u2227 n2 i2=1 ... \u2228npip=1 Q \u2032 i1i2...ip \u03d5\u2032i1i2...ip\nThus, all subproblems of \u03d5 are similar which contradicts our assumption. Hence the proof follows.\nIntuitively, in the proposed framework, while a curve is represented by an arbitrary number of vertices, a line segment is always represented by its two end points. Similarly, while\nthe periphery of a region is represented by an arbitrary number of vertices, the periphery of a triangular region is always represented by three vertices. Hence, two line segments or triangular regions are always represented similarly and differ only in the coordinates of their constituent vertices, unlike two curves or regions. The base predicates are defined in terms of base objects \u2013 points, line segments, and triangular regions. Thus, when a predicate is defined as conjunctions or disjunctions of base predicates, the base predicates are always similar. Decomposition of a problem into subproblems merely replaces one or more of its predicates by similar base predicates. Hence, all the subproblems have to be similar."}, {"heading": "3.4 Memory Organization", "text": "Memory in the SPS is hierarchically organized and stores problems in disjoint classes based progressively on a problem\u2019s features in \u03d1 (see Figure 14). After decomposing a problem into subproblems and computing their \u03d1, if the subproblems have the same value for \u03d1, SPS checks whether or not their parse trees are isomorphic and a mapping exists between their variables. Since the memory hierarchy has a constant height, insertion of a problem or searching for a potential class of similar problems can be executed in constant time. Also, the features that classify the problems are discriminative enough to create a large number of classes (leaf nodes), each class containing only a few problems, thereby reducing search to a few problems belonging to a class."}, {"heading": "4. Computational Complexity", "text": "We will now analyze the time complexity of the algorithms used in our framework. In our implementation, a problem \u03d5 is a data structure consisting of two fields \u2013 ParseTree and Solution. The ParseTree stores the lexicographically sorted parse tree of the matrix of \u03d5 while the Solution stores the symbolic solution to \u03d5 in a concise form. A parse tree can be constructed in time O(t) where t is the number of base predicates and boolean operators {\u2227,\u2228,\u00ac} in \u03d5. The boolean operators occupy the non-leaf nodes in the parse tree while the base predicates occupy the leaf nodes. Lexicographically sorting a tree requires lexicographically sorting the contents of the children of each non-leaf node in the tree. Let t\u2032 be the number of boolean operators and t\u2032\u2032i be the number of children of the i th boolean\noperator. Thus, t\u2032\u2211\ni\u21901 t\u2032\u2032i = t \u2212 1. Note that since each base predicate is always followed by\na boolean operator, t = \u03bat\u2032 where \u03ba is a constant. Lexicographically sorting a list of the contents of the children of a node requires O(t\u2032\u2032i logt \u2032\u2032 i ) time. Thus, the total time required\nfor repeating this process for all non-leaf nodes is t\u2032\u2211 i\u21901 O(t\u2032\u2032i logt \u2032\u2032 i ). Since the average number\nof children per node is 1t\u2032 t\u2032\u2211 i\u21901 t\u2032\u2032i = t\u2212 1 t\u2032 , the total time required to lexicographically sort a\ntree is t\u2032\u2211 i\u21901 O( t\u2212 1 t\u2032 log t\u2212 1 t\u2032 ) = O(t).\nGiven two problems \u2013 \u03d51, \u03d52, the algorithm Similar(\u03d51, \u03d52) computes whether \u03d51 and \u03d52 are similar to each other or not (see Figure 15). Since computing \u03d1 requires O(t) time, line 1 requires O(t) time. Since checking whether two trees are isomorphic or not requires O(t) time (as shown in Aho, Hopcroft, & Ullman, 1974), line 6 requires O(t) time. Lines 9 through 11 requires O(t) time. Thus, the algorithm runs in O(t) time.\nGiven an unsolved problem \u03d5 and a similar solved problem \u03d5similar, the algorithm ComputeSolutionFromSimilarProblem(\u03d5, \u03d5similar) computes the solution to \u03d5 by variable mapping from \u03d5similar (see Figure 16). V ariableMap is a list where each entry is a pair < v, vsimilar >, v being a free variable in \u03d5 and vsimilar is the corresponding free variable in \u03d5similar. Let the size of V ariableMap be k\n\u2032. The lines 5 through 11 requires O(tk\u2032) time since the number of nodes in \u03d5similar is t and the number of arguments in any predicate is small. Lines 12 through 13 requires O(\u03c9k\u2032) time where \u03c9 is the size of the solution to \u03d5similar. Thus, the algorithm runs in O(tk \u2032 + \u03c9k\u2032) time.\nFinally, given an unsolved problem \u03d5 and a memory Memory that stores problems hierarchically (as described in section 3.4), the algorithm EliminateQuantifiers(\u03d5,Memory) computes the solution to \u03d5 by variable mapping from a similar problem in Memory, if such a problem exists; otherwise solves \u03d5 using a problem classifier and combination of constraint\nsolvers and QE algorithms (as described in section 3). The algorithm is shown in Figure 17.\nLet there be n subproblems to a problem. In a problem, some of the predicates are already base predicates while the rest are not which can be written as conjunctions/disjunctions of base predicates thereby leading to decomposition of a problem into subproblems. For example, in section 1.1, the problem RiskyPortionsofPath(q, c1, c2, d) is defined in terms of the base predicate DistanceLessThan(p, q, d) (i.e., Distance(p, q) \u2264 d) and the nonbase predicates On(q, c1) and On(p, c2). Each of these non-base predicates can be written as disjunctions of base predicates, such as, On(q, {c1[i], c1[i + 1]}) and On(q, {c2[j], c2[j + 1]}), respectively, thereby leading to decomposition of RiskyPortionsofPath into subproblems. Each of the subproblems inherits the base predicates from the problem (e.g., DistanceLessThan(p, q, d)) and also includes the new base predicates (e.g., On(q, {c1[i], c1[i+ 1]}), On(q, {c2[j], c2[j + 1]})) obtained from the non-base predicates. Let \u03b1 be the number of polynomials in the base predicates of a problem and \u03b2 be the number of polynomials due to the newly obtained base predicates in a subproblem. Since all subproblems are similar, each of them will have \u03b1+ \u03b2 polynomials. The total number of polynomials s in a problem is O(\u03b1+ \u03b2n).\nLet d be the maximum degree of any polynomial in a subproblem. Since all subproblems are similar, each of them will have maximum degree d. The maximum degree of polynomials in a problem will also be d if objects are represented piecewise-linearly, in which case d \u2264 2. If the objects are not represented piecewise-linearly, the degree will be much larger than two which might lead to a situation where the problem might not be solvable in reasonable time.\nLet k be the number of quantified variables in a problem. Then each subproblem also has k quantified variables. Let the computational complexity of using a general QE algorithm for solving a problem be T (n) while that for solving a subproblem is T (1), where T is a doubly exponential function, such as, when using CAD, T (n) = (sd)O(1) k\u22121\n. Note that T (n) \u226b nT (1), i.e., it is more efficient to solve each subproblem using a general QE algorithm than to solve the whole problem using the same algorithm.\nIn algorithm EliminateQuantifiers(\u03d5,Memory), lines 4 through 7 require O(n) time. Lines 8 and 9 require O(t) time each. Since line 13 requires O(t) time, lines 11 through 16 require O(mt) time. Line 18 requires time T (1) while lines 20 through 23 require O((n\u22121)(tk\u2032+\u03c9k\u2032)) time. Thus, the entire algorithm runs in O(T (1)+mt+(n\u22121)(tk\u2032+\u03c9k\u2032)) time. Note that \u03c9 is the size of the symbolic solution, and if the symbolic solution can be expressed concisely, \u03c9 is small. Since the number of boolean operators is of the order of number of base predicates and each base predicate is defined in terms of at least one polynomial, t = O(s) = O(\u03b1 + \u03b2n). Thus, the complexity of the algorithm is O(T (1) + (m+ (n\u2212 1)k\u2032)s+ (n\u2212 1)\u03c9k\u2032). It can be seen that\nnT (1) > T (1) + (m+ (n\u2212 1)k\u2032)s+ (n\u2212 1)\u03c9k\u2032\nor, ((\u03b1+ \u03b2)d)O(1) k\u22121 > ( mn\u22121 + k \u2032)(\u03b1+ \u03b2n) + \u03c9k\u2032\nis true provided \u03c9 is not large. That is, it is more efficient to solve a problem by variable mapping than to solve each subproblem using a general QE algorithm provided the size of the stored symbolic solution is not large. For every decomposable problem, the complexity of QE can be reduced as above.\nWhen a problem is encountered by the SPS for the first time, it is solved by decomposing into subproblems, solving the first subproblem using a general QE algorithm and then obtaining the solution of the rest of the subproblems by mapping their variables to the first subproblem. Since a subproblem and its solution are stored in memory, if a similar subproblem is encountered in future, the SPS bypasses the QE algorithm completely and solves it by variable mapping. In such a case, line 18 of the algorithm is never executed, and the time complexity of solving the problem is\n(m+ nk\u2032)s+ n\u03c9k\u2032\nwhich is a considerable savings compared to the complexity of solving the entire problem using a general QE algorithm (e.g., complexity of CAD is (sd)O(1) k\u22121 ), provided \u03c9 is not large. As the SPS solves more problems, the probability to encounter a similar problem in memory increases thereby leading to the above scenario which incurs a complexity of low order polynomial as compared to doubly exponential.3\nExample. To illustrate the problem solving process, let us consider the spatial problem BehindCurve(q, c, p) (described in section 2.3). For a point p \u2190 (px, py) and a curve c \u2190 {p1, p2, ...pn} where pi \u2190 (xi, yi) is a point, decomposition of the problem occurs as follows:\n\u03d5\n\u2261 BehindCurve(q, c, p)\n\u2261 Intersect(c, {p, q})\n\u2261 \u2203a,On(a, c) \u2227On(a, {p, q})\n\u2261 \u2203a, (\u2228n\u22121i=1 On(a, {pi, pi+1})) \u2227On(a, {p, q})\n\u2261 \u2228n\u22121i=1 (\u2203a,On(a, {pi, pi+1}) \u2227On(a, {p, q}))\n\u2261 \u2228n\u22121i=1 (Qi\u03d5\u2032i)\n\u2261 \u2228n\u22121i=1 \u03d5i\nThus there are (n\u2212 1) subproblems \u03d5i, where\n\u03d5\u2032i \u2261 On(a, {pi, pi+1}) \u2227On(a, {p, q})\nQi \u2261 \u2203a\n\u03d5i \u2261 \u2203a,On(a, {pi, pi+1}) \u2227On(a, {p, q})\nFrom Figure 18, \u03d1(\u03d5i) =< 2, 2 133, 1, < \u2203 >, 21 > for i = 1, 2, ...n \u2212 1. By theorem 3, all \u03d5i\u2019s are similar since they are the subproblems of the same problem. If the SPS does\n3. It should be noted that approximating a continuous curve by a sequence of line segments has its drawbacks. For example, a point p that is on a continuous curve c might not be on the piecewise-linear approximation of c. The SPS can accept a parameter that specifies the maximum length of a line segment to be used in the approximation. As of our current implementation, we leave the onus of determining this maximum length on the problem solver. In this context, it deserves mention that loss of information is inevitable in almost any kind of approximation. For example, when the space in a diagram is approximated by a finite number of pixels, as shown by Banerjee and Chandrasekaran (2010), the diagrammatic objects lose certain spatial information that might be detrimental to spatial problem solving which can be avoided by knowing the minimum allowable resolution (or maximum length of one side of a square pixel).\nnot find a problem in memory similar to the first subproblem \u03d51, it is sent to the problem classifier who sends it to the appropriate QE algorithm. The problem definition, its tuple \u03d1, parse tree, and solution are then stored in memory as follows:\n\u03d51(q, {p1, p2}, p) \u2261 \u2203a,On(a, {p1, p2}) \u2227On(a, {p, q})\n\u03d51((x, y), {(x1, y1), (x2, y2)}, (px, py))\n\u2261 (px\u2212x < 0\u2227px\u2212x1 \u2264 0\u2227x1\u2212x \u2264 0\u2227pyx1\u2212pyx+pxy\u2212x1y\u2212pxy1+xy1 = 0)\u2228(x\u2212px < 0 \u2227 x1 \u2212 px \u2264 0 \u2227 x\u2212 x1 \u2264 0 \u2227 pyx1 \u2212 pyx+ pxy \u2212 x1y \u2212 pxy1 + xy1 = 0) \u2228 ...\nwhere the arguments of \u03d51 are the free variables. The other subproblems are solved by replacing the variables in \u03d51 by the mapped variables. If a problem similar to \u03d51 is found in memory, \u03d51 will also be solved by replacing the mapped variables, just as the other subproblems.\nNote that, for example, the BehindCurve problem, in the absence of an appropriate vocabulary of properties/relations, would have been specified as (see redlog in Weispfenning, 2001):\nBehindCurve((x, y), {(p1,x, p1,y), (p2,x, p2,y), ...(pn,x, pn,y)}, (px, py))\n\u2261 \u2203ax, ay, t, 0 \u2264 t \u2264 1 \u2227 px + t(x \u2212 px) = ax \u2227 py + t(y \u2212 py) = ay \u2227 \u2228n\u22121i\u21901(\u2203ti, 0 \u2264 ti \u2264 1 \u2227 pi,x + ti(pi+1,x \u2212 pi,x) = ax \u2227 py + ti(pi+1,y \u2212 pi,y) = ay)\nHere the total number of quantifiers is n + 3, dependent on the number of line segments forming the curve which can be huge for complicated curves as in many real-world applications. In our SPS, due to appropriate decomposition of problems into subproblems, the number of quantifiers in any subproblem is always fixed (4 in this case) irrespective of the spatial complexity of the object(s) (curve in this case). The symbolic solutions of these simple subproblems can be stored for future use which is not possible in systems like redlog. Needless to say, though solving the problem using both the systems produce the same solution, ours is much faster."}, {"heading": "5. Applications", "text": "In this section, we illustrate how the SPS can be deployed in conjunction with a problem solver, human or artificial (such as, soar), for solving spatial problems without human intervention as needed for DR. Two applications will be considered \u2013 entity re-identification and ambush analysis \u2013 that are deemed very important in the military domain. The subproblems that the SPS autonomously decomposes each spatial problem into will be shown. Problems in military domain involve a wide variety of objects with arbitrary properties and relations, and hence, help to illustrate the expressiveness of the specification language and the efficiency and generality of the SPS.\nFor the implementation, we used bisoar, due to Kurup and Chandrasekaran (2007), a bimodal version of soar (Laird et al., 1987), where the problem solver uses two kinds of operators \u2013 predicate-symbolic operators that are applied on information in predicate-symbolic form and perception-like operators that are applied on a diagram \u2013 to bring about state transitions to reach the goal state from an initial state. A human is responsible for providing the broad problem solving strategy for a class of problems; given a specific problem from that class, bisoar uses the predicate-symbolic and perception-like operators accordingly. Since we have used bisoar in a number of different domains (e.g., military, Euclidean geometry, physics, civil engineering; Banerjee & Chandrasekaran, 2007 provide some examples) and still continue to do so, it knows several different problem solving strategies and operators, both predicate-symbolic and perception-like. The emphasis of this section is not on how efficiently bisoar solves problems but on how efficiently the perception-like operators can be executed without incorporating any knowledge that jeopardizes the generality of a general-purpose problem solver. For each spatial problem, we will compare the performance of our proposed SPS with the CAD algorithm in terms of actual computation time which is determined by taking the average of at least 10 runs. As we will see, the SPS excels by a significant margin in most cases."}, {"heading": "5.1 Entity Re-identification", "text": "The entity re-identification problem is a core task in the US Army\u2019s All-Source Analysis System (ASAS). ASAS receives a new report about sighting of an entity T3 of type T (e.g. tanks). The task is to decide if the new sighting is the same as any of the entities in its database of earlier sightings, or an entirely new entity. Reasoning has to dynamically integrate information from different sources \u2013 database of sightings, mobility of vehicles, sensor reports, terrain and map information \u2013 to make the decision. We will follow a novel capability using failure of expectation: If H were true, O should have been observed, but since it was not, H is likely not the case, where H and O are hypotheses and observations respectively (Josephson & Josephson, 1996; Chandrasekaran et al., 2004). In the following, we consider a simple version of the problem to illustrate how the task is solved using DR and the spatial problems involved therein.\nFigure 19(a) shows the terrain of interest \u2013 mountainous with the closed regions marking impassable areas for entities of type T (e.g., tanks). Let T3 be an entity newly sighted at time t3 located at point p3 while T1, T2 are the two entities that were located at points p1, p2 when last sighted at times t1, t2 respectively. T1 and T2 were retrieved from the database as having the potential to be T3 based on their partial identity information. Also, in the\narea of interest, there are three enemy regions or obstacles {r1, r2, r3} (as shown in Figure 19(a)) with a given firepower/sight range d of the enemy. Reasoning proceeds as follows. If T1 can reach p3 within the time t3 \u2212 t1, then T3 might be T1. Similarly for T2. Since each mountainous region (or obstacle) is a hiding place for enemies with a firepower range d, the existence of an entity shows that it most probably did not traverse through a territory within the firepower range. Further, there might be sensor fields that report to the database when they sense entities. If no entity was sensed by a sensor field between the times t1 and t3, then T1 could not have followed a path that passed through that sensor field. Such constraints have to be taken into account while reasoning. All information might not be available in the database at once. In what follows is a simple scenario and a discussion of the spatial problems as they occur.\nThe problem solver (e.g., a commander) wants to know whether there exists a contiguous safe region containing the points p1 and p3. He specifies the problem SafeRegion as follows:\nSafeRegion(q, {r1, r2, ...rn}, d)\n\u2261 \u2200a, (\u2228ni\u21901Inside(a, ri)) \u21d2 Distance(q, a) \u2265 d\n\u2261 \u2200a,\u00ac(\u2228ni\u21901 \u2228 #\u25b3(ri) j\u21901 Inside(a,\u25b3(ri)[j])) \u2228Distance(q, a) \u2265 d\n\u2261 \u2200a, (\u2227ni\u21901 \u2227 #\u25b3(ri) j\u21901 \u00acInside(a,\u25b3(ri)[j])) \u2228Distance(q, a) \u2265 d\n\u2261 \u2227ni\u21901 \u2227 #\u25b3(ri) j\u21901 \u2200a,\u00acInside(a,\u25b3(ri)[j]) \u2228Distance(q, a) \u2265 d\n\u2261 \u2227ni\u21901 \u2227 #\u25b3(ri) j\u21901 \u2200a, Inside(a,\u25b3(ri)[j]) \u21d2 Distance(q, a) \u2265 d\n\u2261 \u2227ni\u21901 \u2227 #\u25b3(ri) j\u21901 SafeRegion \u2032(q, {\u25b3(ri)[j]}, d)\nwhere q \u2190 (x, y). Decomposition of the problem by the SPS is shown above. The subproblem is symbolically solved and the solution stored in memory along with the subproblem specification. In order to compare the actual times required to solve the problem, we constructed a very simple diagram consisting of four polygonal regions depicting obstacles (see Figure 20(a)). The four regions are\nr1 \u2190 {(10, 10), (30, 10), (30, 30), (10, 30)},\nr2 \u2190 {(\u221220, 0), (0, 0), (\u221210, 20)},\nr3 \u2190 {(0, 20), (10, 40), (\u221210, 40)},\nr4 \u2190 {(50, 20), (70, 20), (80, 40), (60, 50), (40, 40)},\nwhile d \u2190 2. Triangulation of the regions produced seven triangles. Once a subproblem is symbolically solved and stored, solving the problem required 0.25 seconds while solving the same using the CAD algorithm required 5.5 seconds.\nThe diagram with the shaded safe region is input to the Recognize function which computes the vertices and boundaries of the shaded region, as shown in Figure 20(b). Next the problem solver wants to know whether there exists a path between points p1 and p3 safely avoiding the obstacles and enemy firepower range, and whether that path can be traversed in time t3 \u2212 t1. Let v be the velocity of the sighted entity \u2013 a piece of symbolic knowledge available from the database. Then, the maximum length of path traversable in the given time is L = v \u00d7 (t3 \u2212 t1). Let l \u226a L be a rational number. Then, the problem of path existence between two points s and t such that the path lies inside a region r and is less than a given length l can be specified as:\nPathExists(s, t, r, l)\n\u2261 \u2203q, Inside(q, r) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 \u2203q, (\u2228#\u25b3(r)i\u21901 Inside(q,\u25b3(r)[i])) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 \u2228#\u25b3(r)i\u21901 \u2203q, Inside(q,\u25b3(r)[i]) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 \u2228#\u25b3(r)i\u21901 PathExists\u2032(s, t,\u25b3(r)[i], l)\nDecomposition of the problem by the SPS is shown above. The subproblem is symbolically solved and stored. Again, we resort to the simple diagram in Figure 20 to compare the actual computation times for the PathExists(s, t, r, l) problem, where s \u2190 (0, 45), t \u2190 (20, 5), r \u2190 Recognize(SafeRegion((x, y), {r1, r2, ...rn}, 2)), and different sets of regions ri and different values of l. Triangulation of r produced 8, 7, 7, 9 and 24 triangles for {r1}, {r2}, {r3}, {r4} and {r1, r2, r3, r4} respectively. Once a subproblem is symbolically solved and stored, the computation times required for solving the problem using the proposed SPS is significantly less than that using the CAD algorithm (see Table 1).\n\u2261 \u2203q1, q2, ...qn, (\u2200a,On(a, {s, q1, q2, ...qn, t}) \u21d2 Inside(a, r))\u2227Length({s, q1, q2, ...qn, t}) \u2264 l\n\u2261 \u2203q1, q2, ...qn, (\u2200a,\u00acOn(a, c) \u2228 Inside(a, r)) \u2227 Length(c) \u2264 l\n\u2261 \u2203q1, q2, ...qn, (\u2200a,\u00acOn(a, c) \u2228 \u00acInside(a, r)) \u2227 Length(c) \u2264 l\n\u2261 \u2203q1, q2, ...qn, (\u2200a,\u00acOn(a, c) \u2228 \u00ac(\u2228 #\u25b3(r) k\u21901 Inside(a,\u25b3(r)[k]))) \u2227 Length(c) \u2264 l\n\u2261 \u2203q1, q2, ...qn, (\u2200a,\u00acOn(a, c) \u2228 (\u2227 #\u25b3(r) k\u21901 \u00acInside(a,\u25b3(r)[k]))) \u2227 Length(c) \u2264 l\n\u2261 \u2227#\u25b3(r)k\u21901 \u2203q1, q2, ...qn, (\u2200a,\u00acOn(a, c) \u2228 \u00acInside(a,\u25b3(r)[k])) \u2227 Length(c) \u2264 l\n\u2261 \u2227#\u25b3(r)k\u21901 PathExists \u2032(s, t,\u25b3(r)[k], l)\nwhere c \u2261 {s, q1, q2, ...qn, t} and r \u2261 B\u2212r. Note that even though c is a curve, On(a, c) cannot be decomposed since c is not a free variable (see definition of Decomposition in section 3.2). Also, note that the above problem contains the form F2 discussed in Theorem 1, so r has been used.\nIf there exists a path between points p1 and p3 safely avoiding the obstacles and enemy firepower range such that it can be traversed in time t3 \u2212 t1, then the problem solver wants to compute the path(s). The problem can be specified as:\nFindPath(q, s, t, r, l)\n\u2261 Inside(q, r) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 (\u2228#\u25b3(r)i\u21901 Inside(q,\u25b3(r)[i])) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 \u2228#\u25b3(r)i\u21901 Inside(q,\u25b3(r)[i]) \u2227Distance(s, q) +Distance(q, t) \u2264 l\n\u2261 \u2228#\u25b3(r)i\u21901 FindPath\u2032(q, s, t,\u25b3(r)[i], l)\nwhere q \u2190 (x, y). Since there are no quantifiers, solving the problem by decomposition and variable mapping does not achieve reduction in computation time by any significant amount. The region consisting of all paths that satisfy the constraints (l \u2190 \u221a 1010) is shown in Figure 20(c). The quality of the solution depends on the Recognize function. For example, the solution shown in Figure 20(d) is more accurate than in Figure 20(c) as the Recognize function failed to determine the vertices of the safe region accurately. An alternate definition of the semi-linear motion planning problem can be found in Weispfenning (2001), where a semi-linear path consists of n translations along straight lines each of which is parallel to one of the given k vectors.\nFrom the results, the problem solver infers that T3 might be T1. Next he repeats the same for entities T3 and T2, and finds that there exists a path between points p2 and p3 safely avoiding the obstacles and enemy firepower range such that it can be traversed in time t3 \u2212 t2. So T3 might be T2 as well. The sensor database informs that there are two sensor fields \u2013 SENSOR1, SENSOR2 \u2013 in the area of interest but there has been no report from them of any passing vehicle. Problem solver wants to verify whether any of the paths passes through any of the sensor fields. He specifies the problem Intersect(r1, r2) to compute the intersection of two regions r1 and r2.\nIntersectRegions(r1, r2)\n\u2261 \u2203q, Inside(q, r1) \u2227 Inside(q, r2)\n\u2261 \u2203q, (\u2228#\u25b3(r1)i\u21901 Inside(q,\u25b3(r1)[i])) \u2227 (\u2228 #\u25b3(r2) i\u21901 Inside(q,\u25b3(r2)[j]))\n\u2261 \u2228#\u25b3(r1)i\u21901 \u2228 #\u25b3(r2) j\u21901 IntersectRegions \u2032(\u25b3(r1)[i],\u25b3(r2)[j])\nHe computes the problem IntersectRegions(paths13, s1) where paths13 \u2190 Recognize(FindPath(q, p1, p3, r, l)) and s1 is the region covered by SENSOR1. In our scenario in Figure 19(c), the solution is True. Next the problem solver wants to know whether there exists a path between points p1 and p3 safely avoiding the obstacles and enemy firepower range such that it can be traversed in time t3\u2212 t1. He computes PathExists(p1, p3, r13, l), where r13 \u2190 Recognize(paths13\u2212 s1), which returns True. The inference follows that T3 might be T2. The same reasoning is repeated for T3 and T2; Intersect(paths23, s2) returns True while PathExists(p2, p3, r23, l) returns False (see Figure 19(b)). The inference follows that T3 cannot be T1. Hence, the problem solver identifies T3 as T2.\nThe entity reidentification problem could also have been solved by computing the shortest paths between the pairs p1, p3 and p2, p3 avoiding the sensors and checking whether their lengths satisfy the time constraints. That requires computing the shortest path between two points p1 and p3 safely avoiding the obstacles and enemy firepower range (i.e., lying entirely within the safe region r). Since such a path will not have any loop and will share its intermediate vertices, if any, with the vertices of r, the path can have at most #(r) intermediate vertices. Let S \u2190 r \u222a {p1, p3}, m \u2190 #(S), and c \u2190 {q1, q2, ...qm} be the shortest path, where q1 \u2261 p1, qm \u2261 p3, qi \u2208 r (2 \u2264 i \u2264 m \u2212 1). Then, the problem of computing the shortest path can be specified as\nFindShortestPath(r, c)\n\u2261 Minimize(Length(c), {c[2], c[3], ...c[m\u2212 1]}, CurveInsideRegion(c, r))\nwhere CurveInsideRegion(c, r) is the constraint that can be specified and decomposed as follows.\nCurveInsideRegion(c, r)\n\u2261 \u2200a,On(a, c) \u21d2 Inside(a, r)\n\u2261 \u2200a,\u00acOn(a, c) \u2228 Inside(a, r)\n\u2261 \u2200a,\u00acOn(a, c) \u2228 \u00acInside(a, r)\n\u2261 \u2200a,\u00ac(\u2228#(c)\u22121i\u21901 On(a, {c[i], c[i+ 1]})) \u2228 \u00ac(\u2228 #\u25b3(r) j\u21901 Inside(a,\u25b3(r)[j])))\n\u2261 \u2227#(c)\u22121i\u21901 \u2227 #\u25b3(r) j\u21901 \u2200a,\u00acOn(a, {c[i], c[i+ 1]}) \u2228 \u00acInside(a,\u25b3(r)[j])\n\u2261 \u2227#(c)\u22121i\u21901 \u2227 #\u25b3(r) j\u21901 CurveInsideRegion \u2032({c[i], c[i+ 1]},\u25b3(r)[j])\nwhere r \u2261 B\u2212r. Since the above problem is of the form F2, r had to be used. Once a subproblem is symbolically solved and stored, solving the problem CurveInsideRegion(c, r), where\nc \u2190 {(0, 45), (14, 42), (35, 42), (15, 35), (34, 32), (36, 19), (47, 15), (87, 15), (30,\u22127), (20, 5)},\nr \u2190 Recognize(SafeRegion((x, y), {r1, r2, r3, r4}, 2)),\nby SPS required 3.11 seconds while solving the same using the CAD algorithm required 175.01 seconds (see Figure 21(a)). The shortest path obtained by solving the FindShortestPath(r, c) problem is shown in Figure 21(b)."}, {"heading": "5.2 Ambush Analysis", "text": "There are two main factors \u2013 range of firepower and sight \u2013 that determine the area covered by a military unit. Presence of terrain features, such as, mountains, limit these factors and allow units to hide from opponents. These hidden units not only enjoy the advantage of concealing their resources and intentions from the opponents but can also attack the opponents catching them unawares if they are traveling along a path that is within the sight and firepower range of the hidden units, thereby ambushing them. Thus, it is of utmost importance for any military unit to a priori determine the areas or portions of a path prone to ambush before traversing them. We had already described in section 1.1 how a problem solver (e.g., an army commander) reasons using diagrams to figure out the safest path to transport his troops from one base camp to another in a given time. In this section, given a curve or region as a hiding place and the firepower and sight ranges, we show how\nthe regions and portions of path prone to ambush is efficiently computed by the proposed SPS.\nGiven a curve c and the firepower and sight range d, the spatial problem RiskyRegion(q, c, d) is defined as the set of all points covered by that range from c. Thus, the problem specification is:\nRiskyRegion(q, c, d)\n\u2261 \u2203a,On(a, c) \u2227Distance(a, q) \u2264 d\n\u2261 \u2203a, (\u2228#(c)\u22121i\u21901 On(a, {c[i], c[i+ 1]})) \u2227Distance(a, q) \u2264 d\n\u2261 \u2228#(c)\u22121i\u21901 \u2203a,On(a, {c[i], c[i+ 1]}) \u2227Distance(a, q) \u2264 d\n\u2261 \u2228#(c)\u22121i\u21901 RiskyRegion\u2032(q, {c[i], c[i+ 1]}, d)\nwhere q \u2190 (x, y). In order to compare the actual computation times required to solve the problem, we constructed a very simple diagram consisting of two curves, path and mntn, where\npath \u2190 {(\u221225,\u221210), (\u22125,\u221210), (\u22123,\u221215), (\u22127,\u221217), (\u22122,\u221218), (2,\u221218), (7,\u221215), (3,\u221212), (5,\u221210), (40,\u221210)}\nmntn \u2190 {(\u22125, 5), (\u22127, 2), (\u22129, 9), (\u22126, 12), (0, 4), (2, 3), (15, 5), (25, 12), (30, 20)}\nThe solution to the problem RiskyRegion(q,mntn, d) is the shaded region shown in Figure 22(a) where mntn is an obstacle for hiding (e.g., mountain range) and d \u2190 15. The problem RiskyRegion(q, r, d) for a region r can be specified by replacing the predicate On(p, c) by Inside(p, r).\nAgain, given a curve c1 as a path, a curve c2 for hiding, and a firepower range d, the problem RiskyPortionsofPath(q, c1, c2, d) is defined as parts of c1 covered by that range from c2. Thus,\nRiskyPortionsofPath(q, c1, c2, d)\n\u2261 On(q, c1) \u2227 \u2203p,On(p, c2) \u2227Distance(p, q) \u2264 d\n\u2261 \u2203p, (\u2228#(c1)\u22121i\u21901 On(q, {c1[i], c1[i+1]}))\u2227(\u2228 #(c2)\u22121 j\u21901 On(p, {c2[j], c2[j+1]}))\u2227Distance(p, q) \u2264 d\n\u2261 \u2228#(c1)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 \u2203p,On(q, {c1[i], c1[i+1]}))\u2227On(p, {c2[j], c2[j+1]})\u2227Distance(p, q) \u2264 d\n\u2261 \u2228#(c1)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 RiskyPortionsofPath \u2032(q, {c1[i], c1[i+ 1]}, {c2[j], c2[j + 1]}, d)\nwhere q \u2190 (x, y). Alternatively, the same problem can be specified as\nRiskyPortionsofPath(q, c1, r2, d)\n\u2261 On(q, c1) \u2227 Inside(q, r2)\n\u2261 (\u2228#(c1)\u22121i\u21901 On(q, {c1[i], c1[i+ 1]})) \u2227 (\u2228 #\u25b3(r2) j\u21901 Inside(q,\u25b3(r2)[j]))\n\u2261 \u2228#(c1)\u22121i\u21901 \u2228 #\u25b3(r2) j\u21901 On(q, {c1[i], c1[i+ 1]}) \u2227 Inside(q,\u25b3(r2)[j])\n\u2261 \u2228#(c1)\u22121i\u21901 \u2228 #\u25b3(r2) j\u21901 RiskyPortionsofPath \u2032(q, {c1[i], c1[i+ 1]},\u25b3(r2)[j], d)\nwhere r2 \u2190 Recognize(RiskyRegion((x, y), c2, d)) and q \u2190 (x, y). The solution to the problem RiskyPortionsofPath(q, path,mntn, d), where d \u2190 15, is the parts of path inside the shaded region shown in Figure 22(a). Figure 22(b) shows the risky portions of the path \u2013 rskyprtn1, rskyprtn2 \u2013 in bold as obtained from Recognize(RiskyPortionsofPath(q, c1, c2, d)).\nrskyprtn1 \u2190 {(\u221216,\u221210), (\u22125,\u221210), (\u22123.7,\u221212.6)}\nrskyprtn2 \u2190 {(3,\u221212), (5,\u221210), (16.1,\u221210)}\nNote that the latter specification is free from quantifiers while the former is not. However, the solution computed from the latter specification might have less accuracy than the same from the former due to the use of Recognize function. If the hiding place is a region r instead of the curve c2, the problem RiskyPortionsofPath(q, c1, r, d) can be specified by replacing the predicate On(p, c2) by Inside(p, r). The portions of the path marked in Figure 2(c) is computed from this specification.\nThe region behind c2 where the enemies might be hiding is the set of all points that are behind c2 with respect to each point on the risky portions of curve c1. Thus, if c is a risky portion of a path, we have\nBehindCurvewrtRiskyPath(q, c2, c)\n\u2261 \u2203a,On(a, c) \u2227BehindCurve(q, c2, a)\n\u2261 \u2203a,On(a, c) \u2227 Intersect(c2, {a, q})\n\u2261 \u2203a,On(a, c) \u2227 (\u2203b,On(b, c2) \u2227On(b, {a, q}))\n\u2261 \u2203a, b, (\u2228#(c)\u22121i\u21901 On(a, {c[i], c[i+ 1]})) \u2227 (\u2228 #(c2)\u22121 j\u21901 On(b, {c2[j], c2[j + 1]})) \u2227On(b, {a, q})\n\u2261 \u2228#(c)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 (\u2203a, b, On(a, {c[i], c[i+ 1]}) \u2227On(b, {c2[j], c2[j + 1]}) \u2227On(b, {a, q}))\n\u2261 \u2228#(c)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 BehindCurvewrtRiskyPath \u2032(q, {c2[j], c2[j + 1]}, {c[i], c[i+ 1]})\nwhere q \u2190 (x, y). The solution to the problem BehindCurvewrtRiskyPath(q,mntn, rskyprtn1)\u2228 BehindCurvewrtRiskyPath(q,mntn, rskyprtn2) is the shaded region shown in Figure 22(b). If the hiding place is a region r instead of the curve c2, the problem BehindCurvewrtRiskyPath(q, r, c) can be specified by replacing the predicate On(p, c2) by Inside(p, r).\nHowever, the enemies might be hiding not anywhere behind a mountain but within a distance from where they can ambush the friendly units. Hence, a more reasonable problem for the commander from the friendly side to compute would be BehindCurvewrtRiskyPathDistance(q, c2, c, d) where d is the distance from where the enemies can ambush them. The problem is specified as:\nBehindCurvewrtRiskyPathDistance(q, c2, c, d)\n\u2261 \u2203a,On(a, c) \u2227BehindCurve(q, c2, a) \u2227Distance(a, q) \u2264 d\n\u2261 \u2203a,On(a, c) \u2227 Intersect(c2, {a, q}) \u2227Distance(a, q) \u2264 d\n\u2261 \u2203a,On(a, c) \u2227 (\u2203b,On(b, c2) \u2227On(b, {a, q})) \u2227Distance(a, q) \u2264 d\n\u2261 \u2203a, b, (\u2228#(c)\u22121i\u21901 On(a, {c[i], c[i+ 1]})) \u2227 (\u2228 #(c2)\u22121 j\u21901 On(b, {c2[j], c2[j + 1]})) \u2227On(b, {a, q}) \u2227 Distance(a, q) \u2264 d\n\u2261 \u2228#(c)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 (\u2203a, b, On(a, {c[i], c[i + 1]}) \u2227 On(b, {c2[j], c2[j + 1]}) \u2227 On(b, {a, q})) \u2227 Distance(a, q) \u2264 d\n\u2261 \u2228#(c)\u22121i\u21901 \u2228 #(c2)\u22121 j\u21901 BehindCurvewrtRiskyPathDistance \u2032(q, {c2[j], c2[j + 1]}, {c[i], c[i + 1]}, d)\nwhere q \u2190 (x, y). The solutions to the problems BehindCurvewrtRiskyPathDistance(q,mntn, rskyprtn1, d) and BehindCurvewrtRiskyPathDistance(q,mntn, rskyprtn2, d), where d \u2190 20, are the shaded regions shown in Figure 22(c), 22(d) respectively. If the hiding place is a region r instead of the curve c2, the problem BehindCurvewrtRiskyPathDistance(q, r, c, d) can be specified by replacing the predicate On(p, c2) by Inside(p, r). A comparison between the CAD algorithm and our proposed SPS of actual times required to compute the problems relevant to ambush analysis as discussed above is shown in Table 2."}, {"heading": "6. Discussion", "text": "Spatial problem solving has been an area of active research since Sutherland\u2019s sketchpad (1963). The need to access, communicate and manipulate spatial information precisely (much as engineers and scientists do) using a high-level language (much as common people use) has been one of the frontiers in AI. It has been well-known that such capabilities are offered by first-order predicate logic and that, first-order logic is generally intractable except for limited domains. Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4- and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al., 1992; Bennett, Isli, & Cohn, 1997; Gerevini & Nebel, 2002; Cohn, Bennett, Gooday, & Gotts, 1997; Duntsch, Wang, & McCloskey, 1999; Gerevini & Renz, 1998). There are two main points of distinction between QSR and our approach to spatial problem solving as reported in this paper.\n1. The different QSR calculi emphasize different aspects of space, such as, ontological issues, topology, distance, orientation, shape, etc. Depending on the spatial aspect of interest, the calculus is based on a minimal set of spatial relations. For example, the 9-intersection calculus (Egenhofer & Franzosa, 1991) is based on nine spatial relations {r0, r1, r3, r6, r7, r10, r11, r14, r15} between two spatial regions, the double cross calculus (Freksa, 1992) is based on fifteen spatial relations {lf, lp, lc, ll, lb, sf, sp, sc, sl, sb, rf, rp, rc, rl, rb} among three points, etc. Our framework is not based on a minimal set of spatial relations; it is based on a fixed set of mathematical/logical operators (see section 2.3). Any spatial relation among points that can be expressed using real variables and the fixed set of operators in first-order logic is included in our vocabulary. Any spatial relation involving curves and/or regions that can be expressed\nin first-order logic using spatial relations among points and the relations On and Inside is included in our vocabulary.\n2. The spatial problems of interest to the QSR community are CSPs involving either points (e.g., double cross calculus) or regions (e.g., 4- and 9-intersection calculi, region connection calculi) and a closed set of their properties/relations often limited to the binary domain. A general-purpose SPS for helping a human perceive from and act on diagrams in different real-world applications will need to solve QCSPs involving points, curves and regions and an open-ended vocabulary of their properties/relations/actions over the entire real domain, which is what our framework offers. Since QE is the computational bottleneck of our SPS, we concentrate our efforts on the real QE algorithms, as discussed towards the end of section 2.3.\nNaturally, the question arises \u2013 how convenient is it for a human to specify a spatial problem as a QCSP? While we acknowledge that the process of specifying a spatial problem as a QCSP is not as effortless as explaining it to another human in a natural language, we have taken the first step in making the process less strenuous by offering a vocabulary of predicates that is open-ended. Not all QCSP-solving systems, such as, redlog (Dolzmann & Sturm, 1999) and qepcad (Brown, 2003), offer such a vocabulary for spatial problem solving which makes it difficult for a user to specify a problem as he has to dig deep into an ocean of equations and inequalities and cannot communicate naturally in terms of high-level predicates.4 We are still far from building systems that can understand communication in natural language. However, research in automatic constraint acquisition from examples is already underway. Vu and O\u2019Sullivan (2008) discuss recent advances in that direction. While we did not use any of those ideas or results in our work, it is not difficult to see how those ideas in conjunction with the work reported in this paper will be able to build a more convenient and efficient spatial problem solving framework."}, {"heading": "7. Conclusion", "text": "DR requires perceiving specified information from a diagram or modifying/creating objects in a diagram in specified ways according to problem solving needs. A number of DR systems have been built in the last couple of decades, in each of which the developers have ascertained a priori and hand-coded the required perceptions and actions. This approach of building DR systems defeats the very purpose of open-ended exploration \u2013 the essence of human-like problem solving. Our goal, in this paper, was to develop a general and efficient framework for executing perceptions and actions as relevant to reasoning with 2D diagrams across a wide variety of domains and tasks. We make two important contributions:\n1. We observe that the wide variety of visual perceptions/actions for DR applications can be transformed into domain/task-independent spatial problems. This observation makes it possible to use the well-established constraint satisfaction framework for spatial problem solving. We developed a language in which to specify spatial problems as QCSPs in the real domain using an open-ended vocabulary of properties, relations and actions involving three kinds of diagrammatic objects \u2013 points, curves, regions. Solution to a spatial problem is the equivalent simplified quantifier-free expression. That reduces the goal to developing a general and efficient SPS for solving 2D spatial problems without human intervention.\n4. To be fair, redlog and qepcad were not developed for solving only spatial problems but any QCSP.\n2. The spatial problems were specified as QCSPs in first-order logic. QE, an inherently doubly exponential problem, was the computational bottleneck of the SPS. We represented the objects (points, curves, regions) as configuration of simple elements to facilitate decomposition of complex problems into simpler and similar subproblems. We showed that, if the symbolic solution to a subproblem can be expressed concisely, QE can be achieved in low-order polynomial time by storing problems and their solutions in memory so that when a similar problem is encountered in future, it can be solved by mapping its solution from a similar previously solved problem. The SPS grows more efficient as it solves more problems. Even though we used the CAD algorithm for QE and compared the complexity results with that of CAD\u2019s, this approach is by no means limited to any particular algorithm. The complexity of any QE algorithm can be significantly improved for spatial problem solving by using the idea of problem decomposition and variable mapping, as discussed in this paper.\nThe framework leaves room to be more efficient and convenient by incorporating future results in at least two possible directions \u2013 learning constraints from examples (automatic constraint acquisition) and carefully exploiting a rich portfolio of QE algorithms for solving new problems."}, {"heading": "Acknowledgments", "text": "This research was partially supported by participation in the Advanced Decision Architectures Collaborative Technology Alliance sponsored by the U.S. Army Research Laboratory under Cooperative Agreement DAAD19-01-2-0009. We thank the anonymous reviewers for their constructive comments."}], "references": [{"title": "The Design and Analysis of Computer Algorithms", "author": ["A.V. Aho", "J.E. Hopcroft", "J.D. Ullman"], "venue": null, "citeRegEx": "Aho et al\\.,? \\Q1974\\E", "shortCiteRegEx": "Aho et al\\.", "year": 1974}, {"title": "Logical reasoning with diagrams", "author": ["G. Allwein", "J. Barwise"], "venue": "Journal of Logic, Language and Information,", "citeRegEx": "Allwein and Barwise,? \\Q1999\\E", "shortCiteRegEx": "Allwein and Barwise", "year": 1999}, {"title": "Rules of the Mind", "author": ["J.R. Anderson"], "venue": "Lawrence Erlbaum Associates, Hillsdale, NJ.", "citeRegEx": "Anderson,? 1993", "shortCiteRegEx": "Anderson", "year": 1993}, {"title": "Perceptual and action routines in diagrammatic reasoning for entity re-identification", "author": ["B. Banerjee", "B. Chandrasekaran"], "venue": "In Proc. 24th Army Science Conf.,", "citeRegEx": "Banerjee and Chandrasekaran,? \\Q2004\\E", "shortCiteRegEx": "Banerjee and Chandrasekaran", "year": 2004}, {"title": "A constraint satisfaction framework for visual problem solving", "author": ["B. Banerjee", "B. Chandrasekaran"], "venue": "Trends in Constraint Programming,", "citeRegEx": "Banerjee and Chandrasekaran,? \\Q2007\\E", "shortCiteRegEx": "Banerjee and Chandrasekaran", "year": 2007}, {"title": "A spatial search framework for executing perceptions and actions in diagrammatic reasoning", "author": ["B. Banerjee", "B. Chandrasekaran"], "venue": "Lecture Notes in AI,", "citeRegEx": "Banerjee and Chandrasekaran,? \\Q2010\\E", "shortCiteRegEx": "Banerjee and Chandrasekaran", "year": 2010}, {"title": "A computational architecture for heterogeneous reasoning", "author": ["J. Barwise", "J. Etchemendy"], "venue": "Proc. 7th Conf. Theoretical Aspects of Rationality and Knowledge,", "citeRegEx": "Barwise and Etchemendy,? \\Q1998\\E", "shortCiteRegEx": "Barwise and Etchemendy", "year": 1998}, {"title": "Algorithms in real algebraic geometry. SpringerVerlag", "author": ["S. Basu", "R. Pollack", "Roy", "M.-F"], "venue": null, "citeRegEx": "Basu et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Basu et al\\.", "year": 2003}, {"title": "Logical Representations for Automated Reasoning about Spatial Relationships", "author": ["B. Bennett"], "venue": "Ph.D. thesis, School of Computer Studies, The University of Leeds.", "citeRegEx": "Bennett,? 1997", "shortCiteRegEx": "Bennett", "year": 1997}, {"title": "When does a composition table provide a complete and tractable proof procedure for a relational constraint language", "author": ["B. Bennett", "A. Isli", "A.G. Cohn"], "venue": "In Proc. IJCAI Workshop Spatial and Temporal Reasoning,", "citeRegEx": "Bennett et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Bennett et al\\.", "year": 1997}, {"title": "QEPCAD B: A program for computing with semi-algebraic sets using cylindrical algebraic decomposition", "author": ["C.W. Brown"], "venue": "ACM SIGSAM Bulletin, 37 (4), 97\u2013108.", "citeRegEx": "Brown,? 2003", "shortCiteRegEx": "Brown", "year": 2003}, {"title": "The complexity of quantifier elimination and cylindrical algebraic decomposition", "author": ["C.W. Brown", "J.H. Davenport"], "venue": "In Proc. Intl. Symp. Symbolic and Algebraic Computation,", "citeRegEx": "Brown and Davenport,? \\Q2007\\E", "shortCiteRegEx": "Brown and Davenport", "year": 2007}, {"title": "Diagrammatic reasoning in support of situation understanding and planning", "author": ["B. Chandrasekaran", "J.R. Josephson", "B. Banerjee", "U. Kurup", "R. Winkler"], "venue": "In Proc. 23rd Army Science Conf.,", "citeRegEx": "Chandrasekaran et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Chandrasekaran et al\\.", "year": 2002}, {"title": "A diagrammatic reasoning architecture: Design, implementation and experiments", "author": ["B. Chandrasekaran", "U. Kurup", "B. Banerjee"], "venue": "In Proc. AAAI Spring Symp., Reasoning with Mental and External Diagrams: Computational Modeling and Spatial Assistance,", "citeRegEx": "Chandrasekaran et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Chandrasekaran et al\\.", "year": 2005}, {"title": "An architecture for problem solving with diagrams", "author": ["B. Chandrasekaran", "U. Kurup", "B. Banerjee", "J.R. Josephson", "R. Winkler"], "venue": "Lecture Notes in AI,", "citeRegEx": "Chandrasekaran et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Chandrasekaran et al\\.", "year": 2004}, {"title": "Triangulating a simple polygon in linear time", "author": ["B. Chazelle"], "venue": "Discrete and Computational Geometry, 6, 485\u2013524.", "citeRegEx": "Chazelle,? 1991", "shortCiteRegEx": "Chazelle", "year": 1991}, {"title": "A calculus of individuals based on \u2019connection", "author": ["B.L. Clarke"], "venue": "Notre Dame Journal of Formal Logic, 22, 204\u2013218.", "citeRegEx": "Clarke,? 1981", "shortCiteRegEx": "Clarke", "year": 1981}, {"title": "RCC: A calculus for region based qualitative spatial reasoning", "author": ["A.G. Cohn", "B. Bennett", "J.M. Gooday", "N. Gotts"], "venue": null, "citeRegEx": "Cohn et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Cohn et al\\.", "year": 1997}, {"title": "Partial cylindrical algebraic decomposition for quantifier elimination", "author": ["G.E. Collins", "H. Hong"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "Collins and Hong,? \\Q1991\\E", "shortCiteRegEx": "Collins and Hong", "year": 1991}, {"title": "Real quantifier elimination is doubly exponential", "author": ["J.H. Davenport", "J. Heintz"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "Davenport and Heintz,? \\Q1988\\E", "shortCiteRegEx": "Davenport and Heintz", "year": 1988}, {"title": "REDLOG user manual, edition 2.0 for version 2.0", "author": ["A. Dolzmann", "T. Sturm"], "venue": "Tech. rep. MIP-9905,", "citeRegEx": "Dolzmann and Sturm,? \\Q1999\\E", "shortCiteRegEx": "Dolzmann and Sturm", "year": 1999}, {"title": "Real quantifier elimination in practice", "author": ["A. Dolzmann", "T. Sturm", "V. Weispfenning"], "venue": "Algorithmic Algebra and Number Theory,", "citeRegEx": "Dolzmann et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Dolzmann et al\\.", "year": 1998}, {"title": "Relation algebras in qualitative spatial reasoning", "author": ["I. Duntsch", "H. Wang", "S. McCloskey"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Duntsch et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Duntsch et al\\.", "year": 1999}, {"title": "Exploiting qualitative spatial neighborhoods in the situation calculus", "author": ["F. Dylla", "R. Moratz"], "venue": "Spatial Cognition IV. Reasoning, Action, and Interaction,", "citeRegEx": "Dylla and Moratz,? \\Q2005\\E", "shortCiteRegEx": "Dylla and Moratz", "year": 2005}, {"title": "Reasoning about binary topological relations", "author": ["M.J. Egenhofer"], "venue": "Gunther, O., & Schek, H.-J. (Eds.), Proc. 2nd Symp. Large Spatial Databases, Vol. 525 of Lecture Notes in Computer Science, pp. 143\u2013160. Springer.", "citeRegEx": "Egenhofer,? 1991", "shortCiteRegEx": "Egenhofer", "year": 1991}, {"title": "Point set topological relations", "author": ["M.J. Egenhofer", "R.D. Franzosa"], "venue": "Intl. Journal of Geographical Information Systems,", "citeRegEx": "Egenhofer and Franzosa,? \\Q1991\\E", "shortCiteRegEx": "Egenhofer and Franzosa", "year": 1991}, {"title": "MAGI: Analogy-based encoding using symmetry and regularity", "author": ["R.W. Ferguson"], "venue": "Proc. 16th Annual Conf. Cognitive Science Society, pp. 283\u2013288, Atlanta, GA.", "citeRegEx": "Ferguson,? 1994", "shortCiteRegEx": "Ferguson", "year": 1994}, {"title": "Telling juxtapositions: Using repetition and alignable difference in diagram understanding", "author": ["R.W. Ferguson", "K.D. Forbus"], "venue": "Advances in Analogy Research,", "citeRegEx": "Ferguson and Forbus,? \\Q1998\\E", "shortCiteRegEx": "Ferguson and Forbus", "year": 1998}, {"title": "GEOREP: A flexible tool for spatial representation of line drawings", "author": ["R.W. Ferguson", "K.D. Forbus"], "venue": "In Proc. 18th Natl. Conf. AI,", "citeRegEx": "Ferguson and Forbus,? \\Q2000\\E", "shortCiteRegEx": "Ferguson and Forbus", "year": 2000}, {"title": "Qualitative spatial reasoning about sketch maps", "author": ["K.D. Forbus", "J. Usher", "V. Chapman"], "venue": "Proc. 15th Annual Conf. Innovative Applications of AI,", "citeRegEx": "Forbus et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Forbus et al\\.", "year": 2003}, {"title": "Qualitative spatial reasoning with cardinal directions", "author": ["A.U. Frank"], "venue": "Kaindl, H. (Ed.), Proc. 7th Austrian Conf. AI, Vol. 287 of Informatik-Fachberichte, pp. 157\u2013167. Springer.", "citeRegEx": "Frank,? 1991", "shortCiteRegEx": "Frank", "year": 1991}, {"title": "Qualitative spatial reasoning about distances and directions in geographic space", "author": ["A.U. Frank"], "venue": "Journal of Visual Languages and Computing, 3, 343\u2013371.", "citeRegEx": "Frank,? 1992", "shortCiteRegEx": "Frank", "year": 1992}, {"title": "Using orientation information for qualitative spatial reasoning", "author": ["C. Freksa"], "venue": "Frank, A. U., Campari, I., & Formentini, U. (Eds.), Spatio-Temporal Reasoning, Vol. 639 of Lecture Notes in Computer Science, pp. 162\u2013178. Springer.", "citeRegEx": "Freksa,? 1992", "shortCiteRegEx": "Freksa", "year": 1992}, {"title": "Using CBR to select solution strategies in constraint programming", "author": ["C. Gebruers", "B. Hnich", "D. Bridge", "E. Freuder"], "venue": "In Proc. 6th Intl. Conf. Case-based Reasoning,", "citeRegEx": "Gebruers et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Gebruers et al\\.", "year": 2005}, {"title": "Qualitative spatio-temporal reasoning with rcc-8 and allens interval calculus: Computational complexity", "author": ["A. Gerevini", "B. Nebel"], "venue": "In Proc. 15th European Conf. AI,", "citeRegEx": "Gerevini and Nebel,? \\Q2002\\E", "shortCiteRegEx": "Gerevini and Nebel", "year": 2002}, {"title": "Combining topological and qualitative size constraints for spatial reasoning", "author": ["A. Gerevini", "J. Renz"], "venue": "In Proc. 4th Intl. Conf. Principles and Practice of Constraint Programming,", "citeRegEx": "Gerevini and Renz,? \\Q1998\\E", "shortCiteRegEx": "Gerevini and Renz", "year": 1998}, {"title": "Diagrammatic Reasoning: Cognitive and Computational Perspectives", "author": ["J. Glasgow", "N.H. Narayanan", "B. Chandrasekaran"], "venue": null, "citeRegEx": "Glasgow et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Glasgow et al\\.", "year": 1995}, {"title": "On complexity of equivalence checking", "author": ["E. Goldberg", "Y. Novikov"], "venue": "Tech. rep. CDNL-TR-2003-0826, Cadence Berkeley", "citeRegEx": "Goldberg and Novikov,? \\Q2003\\E", "shortCiteRegEx": "Goldberg and Novikov", "year": 2003}, {"title": "Mathematical Reasoning with Diagrams: From Intuition to Automation", "author": ["M. Jamnik"], "venue": "CSLI Press, Stanford University, CA.", "citeRegEx": "Jamnik,? 2001", "shortCiteRegEx": "Jamnik", "year": 2001}, {"title": "Abductive Inference: Computation, Philosophy, Technology", "author": ["J.R. Josephson", "S.G. Josephson"], "venue": null, "citeRegEx": "Josephson and Josephson,? \\Q1996\\E", "shortCiteRegEx": "Josephson and Josephson", "year": 1996}, {"title": "A bimodal cognitive architecture: Explorations in architectural explanation of spatial reasoning. In AAAI Spring Symp. Control Mechanisms for Spatial Knowledge Processing in Cognitive/Intelligent", "author": ["U. Kurup", "B. Chandrasekaran"], "venue": null, "citeRegEx": "Kurup and Chandrasekaran,? \\Q2007\\E", "shortCiteRegEx": "Kurup and Chandrasekaran", "year": 2007}, {"title": "SOAR: An architecture for general intelligence", "author": ["J.E. Laird", "A. Newell", "P.S. Rosenbloom"], "venue": "Artificial Intelligence,", "citeRegEx": "Laird et al\\.,? \\Q1987\\E", "shortCiteRegEx": "Laird et al\\.", "year": 1987}, {"title": "Universal Subgoaling and Chunking", "author": ["J.E. Laird", "P.S. Rosenbloom", "A. Newell"], "venue": null, "citeRegEx": "Laird et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Laird et al\\.", "year": 1986}, {"title": "Weak quantifier elimination for the full linear theory of the integers. A uniform generalization of Presburger arithmetic", "author": ["A. Lasaruk", "T. Sturm"], "venue": "Technical report MIP-0604,", "citeRegEx": "Lasaruk and Sturm,? \\Q2006\\E", "shortCiteRegEx": "Lasaruk and Sturm", "year": 2006}, {"title": "Learning the empirical hardness of optimization problems: The case of combinatorial auctions", "author": ["K. Leyton-Brown", "E. Nudelman", "Y. Shoham"], "venue": "In Proc. 8th Intl. Conf. Principles and Practice of Constraint Programming,", "citeRegEx": "Leyton.Brown et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Leyton.Brown et al\\.", "year": 2002}, {"title": "Qualitative triangulation for spatial reasoning", "author": ["G. Ligozat"], "venue": "Frank, A. U., & Campari, I. (Eds.), Spatial Information Theory: A Theoretical Basis for GIS, Vol. 716 of Lecture Notes in Computer Science, pp. 54\u201368. Springer.", "citeRegEx": "Ligozat,? 1993", "shortCiteRegEx": "Ligozat", "year": 1993}, {"title": "Using diagrams to understand geometry", "author": ["R.K. Lindsay"], "venue": "Computational Intelligence, 14 (2), 238\u2013272.", "citeRegEx": "Lindsay,? 1998", "shortCiteRegEx": "Lindsay", "year": 1998}, {"title": "Qualitative spatial reasoning about line segments", "author": ["R. Moratz", "J. Renz", "D. Wolter"], "venue": "In Proc. 14th European Conf. AI,", "citeRegEx": "Moratz et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Moratz et al\\.", "year": 2000}, {"title": "Proofs without Words: Exercises in Visual Thinking", "author": ["R.B. Nelson"], "venue": "The Mathematical Association of America, Washington, DC.", "citeRegEx": "Nelson,? 1993", "shortCiteRegEx": "Nelson", "year": 1993}, {"title": "Unified Theories of Cognition", "author": ["A. Newell"], "venue": "Harvard University Press, Cambridge, MA.", "citeRegEx": "Newell,? 1990", "shortCiteRegEx": "Newell", "year": 1990}, {"title": "Using casebased reasoning in an algorithm portfolio for constraint solving", "author": ["E. O\u2019Mahony", "E. Hebrard", "A. Holland", "C. Nugent", "B. O\u2019Sullivan"], "venue": "Proc. 3rd Intl. CSP Solver Competition,", "citeRegEx": "O.Mahony et al\\.,? \\Q2008\\E", "shortCiteRegEx": "O.Mahony et al\\.", "year": 2008}, {"title": "Visual reasoning with graphs", "author": ["Y. Pisan"], "venue": "8th Intl. Workshop Qualitative Reasoning about Physical Systems, Nara, Japan.", "citeRegEx": "Pisan,? 1994", "shortCiteRegEx": "Pisan", "year": 1994}, {"title": "A visual routines based model of graph understanding", "author": ["Y. Pisan"], "venue": "Proc. 17th Annual Conf. Cognitive Science Society, pp. 692\u2013697, Pittsburgh. Lawrence Erlbaum Associates. ISBN: 0-8058-2159-7.", "citeRegEx": "Pisan,? 1995", "shortCiteRegEx": "Pisan", "year": 1995}, {"title": "A multi-engine solver for quantified boolean formulas", "author": ["L. Pulina", "A. Tacchella"], "venue": "In Proc. 13th Intl. Conf. Principles and Practice of Constraint Programming,", "citeRegEx": "Pulina and Tacchella,? \\Q2007\\E", "shortCiteRegEx": "Pulina and Tacchella", "year": 2007}, {"title": "A spatial logic based on regions and connection", "author": ["D.A. Randell", "Z. Cui", "A.G. Cohn"], "venue": "Proc. 3rd Intl. Conf. Principles of Knowledge Representation and Reasoning,", "citeRegEx": "Randell et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Randell et al\\.", "year": 1992}, {"title": "Efficient solving of quantified inequality constraints over the real numbers", "author": ["S. Ratschan"], "venue": "ACM Trans. Computational Logic, 7 (4), 723\u2013748.", "citeRegEx": "Ratschan,? 2006", "shortCiteRegEx": "Ratschan", "year": 2006}, {"title": "Combining multiple heuristics", "author": ["T. Sayag", "S. Fine", "Y. Mansour"], "venue": "In Proc. 23rd Intl. Symp. Theoretical Aspects of Computer Science,", "citeRegEx": "Sayag et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Sayag et al\\.", "year": 2006}, {"title": "Reasoning about ordering", "author": ["C. Schlieder"], "venue": "Frank, A. U., & Kuhn, W. (Eds.), Spatial Information Theory: A Theoretical Basis for GIS, Vol. 988 of Lecture Notes in Computer Science, pp. 341\u2013349. Springer.", "citeRegEx": "Schlieder,? 1995", "shortCiteRegEx": "Schlieder", "year": 1995}, {"title": "A simple and fast incremental randomized algorithm for computing trapezoidal decompositions and for triangulating polygons", "author": ["R. Seidel"], "venue": "Computational Geometry: Theory and Applications, 1 (1), 51\u201364.", "citeRegEx": "Seidel,? 1991", "shortCiteRegEx": "Seidel", "year": 1991}, {"title": "Composing cardinal direction relations", "author": ["S. Skiadopoulos", "M. Koubarakis"], "venue": "Artificial Intelligence,", "citeRegEx": "Skiadopoulos and Koubarakis,? \\Q2004\\E", "shortCiteRegEx": "Skiadopoulos and Koubarakis", "year": 2004}, {"title": "Combining multiple heuristics online", "author": ["M.J. Streeter", "D. Golovin", "S.F. Smith"], "venue": "In Proc. 22nd Conf. AI,", "citeRegEx": "Streeter et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Streeter et al\\.", "year": 2007}, {"title": "Sketchpad: A man-machine graphical communication system", "author": ["I.E. Sutherland"], "venue": "Proc. Spring Joint Computer Conf., pp. 329\u2013346.", "citeRegEx": "Sutherland,? 1963", "shortCiteRegEx": "Sutherland", "year": 1963}, {"title": "Qualitative structural analysis using diagrammatic reasoning", "author": ["S. Tessler", "Y. Iwasaki", "K. Law"], "venue": "Diagrammatic Reasoning: Cognitive and Computational Perspectives,", "citeRegEx": "Tessler et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Tessler et al\\.", "year": 1995}, {"title": "Toward a comprehensive model of graph comprehension: Making the case for spatial cognition", "author": ["S.B. Tricket", "J.G. Trafton"], "venue": "Lecture Notes in AI,", "citeRegEx": "Tricket and Trafton,? \\Q2006\\E", "shortCiteRegEx": "Tricket and Trafton", "year": 2006}, {"title": "Some ways that maps and diagrams communicate", "author": ["B. Tversky"], "venue": "Freksa, C., Brauer, W., Habel, C., & Wender, K. F. (Eds.), Spatial Cognition II: Integrating Abstract Theories, Empirical Studies, Formal Methods, and Practical Applications, Vol. 1849 of Lecture Notes in Computer Science, pp. 72\u201379. Berlin: Springer-Verlag.", "citeRegEx": "Tversky,? 2000", "shortCiteRegEx": "Tversky", "year": 2000}, {"title": "An implementation of a near-linear polygon triangulation algorithm for general polygons", "author": ["S. Vik"], "venue": "Senior thesis at Macalester College, St. Paul, Minnesota. Available online at http://sigbjorn.vik.name/projects/Triangulation.pdf.", "citeRegEx": "Vik,? 2001", "shortCiteRegEx": "Vik", "year": 2001}, {"title": "A unifying framework for generalized constraint acquisition", "author": ["X.H. Vu", "B. O\u2019Sullivan"], "venue": "Intl. Journal on AI Tools,", "citeRegEx": "Vu and O.Sullivan,? \\Q2008\\E", "shortCiteRegEx": "Vu and O.Sullivan", "year": 2008}, {"title": "The complexity of linear problems in fields", "author": ["V. Weispfenning"], "venue": "Journal of Symbolic Computation, 5 (1\u20132), 3\u201327.", "citeRegEx": "Weispfenning,? 1988", "shortCiteRegEx": "Weispfenning", "year": 1988}, {"title": "Semilinear motion planning in REDLOG", "author": ["V. Weispfenning"], "venue": "Applicable Algebra in Engineering, Communication and Computing, 12, 455\u2013475.", "citeRegEx": "Weispfenning,? 2001", "shortCiteRegEx": "Weispfenning", "year": 2001}, {"title": "The Mathematica Book (5th edition)", "author": ["S. Wolfram"], "venue": "Available online at http://documents.wolfram.com/.", "citeRegEx": "Wolfram,? 2003", "shortCiteRegEx": "Wolfram", "year": 2003}, {"title": "SATzilla: Portfolio-based algorithm selection for SAT", "author": ["L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Xu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Xu et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 64, "context": "of fields, including AI (Glasgow, Narayanan, & Chandrasekaran, 1995; Chandrasekaran, Kurup, & Banerjee, 2005), logic (Barwise & Etchemendy, 1998; Allwein & Barwise, 1999), and psychology (Tversky, 2000; Tricket & Trafton, 2006).", "startOffset": 187, "endOffset": 227}, {"referenceID": 49, "context": "The DR architecture shares the idea of problem solving as search in problem state space (Laird, Rosenbloom, & Newell, 1986; Newell, 1990).", "startOffset": 88, "endOffset": 137}, {"referenceID": 52, "context": "Sketchy (Pisan, 1995) is a computer implementation of a model of graph understanding.", "startOffset": 8, "endOffset": 21}, {"referenceID": 51, "context": "Reproduced with permission from Pisan (1994).", "startOffset": 32, "endOffset": 45}, {"referenceID": 62, "context": "Reproduced with permission from Tessler et al. (1995).", "startOffset": 32, "endOffset": 54}, {"referenceID": 62, "context": "The redraw system (Tessler et al., 1995) combines diagrammatic and symbolic reasoning to qualitatively determine the deflected shape of a frame structure under a load, a structural analysis problem in civil engineering.", "startOffset": 18, "endOffset": 40}, {"referenceID": 46, "context": "The archimedes system (Lindsay, 1998) assists a human in demonstrating theorems in Euclidean geometry by modifying/creating diagrams according to his instructions and thereafter perceiving/inferencing from the diagram.", "startOffset": 22, "endOffset": 37}, {"referenceID": 38, "context": "The diamond (Jamnik, 2001), a system for proving mathematical theorems, uses a sequence of actions on diagrams assisted by a human to prove specific ground instances and then generalizes by induction.", "startOffset": 12, "endOffset": 26}, {"referenceID": 48, "context": "The theorem is after Nelson (1993).", "startOffset": 21, "endOffset": 35}, {"referenceID": 26, "context": "Systems, such as, magi (Ferguson, 1994), juxta (Ferguson & Forbus, 1998), and coadd are built using georep for symmetry detection, critiquing diagrams based on their captions, and producing a description of the units, areas, and tasks from a course of action diagram, respectively.", "startOffset": 23, "endOffset": 39}, {"referenceID": 29, "context": "Reproduced with permission from Forbus et al. (2003).", "startOffset": 32, "endOffset": 53}, {"referenceID": 52, "context": "From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains.", "startOffset": 23, "endOffset": 174}, {"referenceID": 62, "context": "From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains.", "startOffset": 23, "endOffset": 174}, {"referenceID": 46, "context": "From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains.", "startOffset": 23, "endOffset": 174}, {"referenceID": 38, "context": "From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains.", "startOffset": 23, "endOffset": 174}, {"referenceID": 14, "context": "From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee & Chandrasekaran, 2004), we have identified a vocabulary of properties, relations and actions based on their wide usage for expressing a variety of real-world spatial problems in different domains.", "startOffset": 23, "endOffset": 174}, {"referenceID": 3, "context": "We use first-order predicate logic as the specification language, previously reported by Banerjee and Chandrasekaran (2007).", "startOffset": 89, "endOffset": 124}, {"referenceID": 10, "context": "More recently, Brown and Davenport (2007) have shown that real QE is doubly-exponential even when there is only one free variable and all polynomials in the quantified input are linear.", "startOffset": 15, "endOffset": 42}, {"referenceID": 67, "context": "Another implemented method, QE by virtual substitution (Weispfenning, 1988), is restricted to formulas in which the quantified variables occur at most quadratically.", "startOffset": 55, "endOffset": 75}, {"referenceID": 69, "context": "The problem classifier and combination of QE algorithms have been borrowed from Mathematica (Wolfram, 2003).", "startOffset": 92, "endOffset": 107}, {"referenceID": 65, "context": "Vik (2001) discusses an implementation in Mathematica.", "startOffset": 0, "endOffset": 11}, {"referenceID": 3, "context": "For example, when the space in a diagram is approximated by a finite number of pixels, as shown by Banerjee and Chandrasekaran (2010), the diagrammatic objects lose certain spatial information that might be detrimental to spatial problem solving which can be avoided by knowing the minimum allowable resolution (or maximum length of one side of a square pixel).", "startOffset": 99, "endOffset": 134}, {"referenceID": 41, "context": "For the implementation, we used bisoar, due to Kurup and Chandrasekaran (2007), a bimodal version of soar (Laird et al., 1987), where the problem solver uses two kinds of operators \u2013 predicate-symbolic operators that are applied on information in predicate-symbolic form and perception-like operators that are applied on a diagram \u2013 to bring about state transitions to reach the goal state from an initial state.", "startOffset": 106, "endOffset": 126}, {"referenceID": 40, "context": "For the implementation, we used bisoar, due to Kurup and Chandrasekaran (2007), a bimodal version of soar (Laird et al.", "startOffset": 47, "endOffset": 79}, {"referenceID": 14, "context": "We will follow a novel capability using failure of expectation: If H were true, O should have been observed, but since it was not, H is likely not the case, where H and O are hypotheses and observations respectively (Josephson & Josephson, 1996; Chandrasekaran et al., 2004).", "startOffset": 216, "endOffset": 274}, {"referenceID": 67, "context": "An alternate definition of the semi-linear motion planning problem can be found in Weispfenning (2001), where a semi-linear path consists of n translations along straight lines each of which is parallel to one of the given k vectors.", "startOffset": 83, "endOffset": 103}, {"referenceID": 16, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 177, "endOffset": 206}, {"referenceID": 8, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 177, "endOffset": 206}, {"referenceID": 32, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 312, "endOffset": 326}, {"referenceID": 24, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 356, "endOffset": 401}, {"referenceID": 45, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 422, "endOffset": 437}, {"referenceID": 57, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al.", "startOffset": 455, "endOffset": 524}, {"referenceID": 54, "context": "Under the umbrella of Qualitative Spatial Reasoning (QSR), researchers have investigated a plethora of spatial calculi, the most prominent of which are mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank, 1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), flip-flop calculus (Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla & Moratz, 2005), and the various region connection calculi (Randell et al., 1992; Bennett, Isli, & Cohn, 1997; Gerevini & Nebel, 2002; Cohn, Bennett, Gooday, & Gotts, 1997; Duntsch, Wang, & McCloskey, 1999; Gerevini & Renz, 1998).", "startOffset": 568, "endOffset": 738}, {"referenceID": 32, "context": "For example, the 9-intersection calculus (Egenhofer & Franzosa, 1991) is based on nine spatial relations {r0, r1, r3, r6, r7, r10, r11, r14, r15} between two spatial regions, the double cross calculus (Freksa, 1992) is based on fifteen spatial relations {lf, lp, lc, ll, lb, sf, sp, sc, sl, sb, rf, rp, rc, rl, rb} among three points, etc.", "startOffset": 201, "endOffset": 215}, {"referenceID": 52, "context": "Spatial problem solving has been an area of active research since Sutherland\u2019s sketchpad (1963). The need to access, communicate and manipulate spatial information precisely (much as engineers and scientists do) using a high-level language (much as common people use) has been one of the frontiers in AI.", "startOffset": 66, "endOffset": 96}, {"referenceID": 10, "context": "Not all QCSP-solving systems, such as, redlog (Dolzmann & Sturm, 1999) and qepcad (Brown, 2003), offer such a vocabulary for spatial problem solving which makes it difficult for a user to specify a problem as he has to dig deep into an ocean of equations and inequalities and cannot communicate naturally in terms of high-level predicates.", "startOffset": 82, "endOffset": 95}, {"referenceID": 10, "context": "Not all QCSP-solving systems, such as, redlog (Dolzmann & Sturm, 1999) and qepcad (Brown, 2003), offer such a vocabulary for spatial problem solving which makes it difficult for a user to specify a problem as he has to dig deep into an ocean of equations and inequalities and cannot communicate naturally in terms of high-level predicates.4 We are still far from building systems that can understand communication in natural language. However, research in automatic constraint acquisition from examples is already underway. Vu and O\u2019Sullivan (2008) discuss recent advances in that direction.", "startOffset": 83, "endOffset": 549}], "year": 2010, "abstractText": "Diagrammatic reasoning (DR) is pervasive in human problem solving as a powerful adjunct to symbolic reasoning based on language-like representations. The research reported in this paper is a contribution to building a general purpose DR system as an extension to a soar-like problem solving architecture. The work is in a framework in which DR is modeled as a process where subtasks are solved, as appropriate, either by inference from symbolic representations or by interaction with a diagram, i.e., perceiving specified information from a diagram or modifying/creating objects in a diagram in specified ways according to problem solving needs. The perceptions and actions in most DR systems built so far are hand-coded for the specific application, even when the rest of the system is built using the general architecture. The absence of a general framework for executing perceptions/actions poses as a major hindrance to using them opportunistically \u2013 the essence of open-ended search in problem solving. Our goal is to develop a framework for executing a wide variety of specified perceptions and actions across tasks/domains without human intervention. We observe that the domain/task-specific visual perceptions/actions can be transformed into domain/taskindependent spatial problems. We specify a spatial problem as a quantified constraint satisfaction problem in the real domain using an open-ended vocabulary of properties, relations and actions involving three kinds of diagrammatic objects \u2013 points, curves, regions. Solving a spatial problem from this specification requires computing the equivalent simplified quantifier-free expression, the complexity of which is inherently doubly exponential. We represent objects as configuration of simple elements to facilitate decomposition of complex problems into simpler and similar subproblems. We show that, if the symbolic solution to a subproblem can be expressed concisely, quantifiers can be eliminated from spatial problems in low-order polynomial time using similar previously solved subproblems. This requires determining the similarity of two problems, the existence of a mapping between them computable in polynomial time, and designing a memory for storing previously solved problems so as to facilitate search. The efficacy of the idea is shown by time complexity analysis. We demonstrate the proposed approach by executing perceptions and actions involved in DR tasks in two army applications.", "creator": " TeX output 2010.10.01:2345"}}}