{"id": "1401.3868", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Clause-Learning Algorithms with Many Restarts and Bounded-Width Resolution", "abstract": "we offer we a few new understanding of some functional aspects of practical sat - solvers that are based on dpll networks with sophisticated unit - resolution clause propagation, clause - learning, and tree restarts. we do consider so by analyzing a certain concrete algorithm which means we obviously claim simply is faithful to documenting what practical sequential solvers otherwise do. in particular, well before making landfall any unexpectedly new decision or sequential restart, similarly the naive solver repeatedly constantly applies the appropriate unit - constraint resolution rule until saturation, and leaves altogether no recognizable component to the mercy of non - determinism \u2013 except for some unexpected internal root randomness. we prove the perhaps surprising fact difference that, although the intermediate solver is not explicitly externally designed for it, even with reasonably high probability estimates it ends up systematically behaving as width - n k resolution loser after introducing no bit more than three o ( n ^ # 2k + digit 2 ) conflicts and restarts, roughly where suppose n is the iteration number comparison of variables. in other descriptive words, a width - k resolution can be fully thought either of as o ( n ^ 2k + - 2 ) quickly restarts procedure of modifying the unit - resolution replay rule accomplished with learning.", "histories": [["v1", "Thu, 16 Jan 2014 05:07:08 GMT  (326kb)", "http://arxiv.org/abs/1401.3868v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["albert atserias", "johannes klaus fichte", "marc thurley"], "accepted": false, "id": "1401.3868"}, "pdf": {"name": "1401.3868.pdf", "metadata": {"source": "CRF", "title": "Clause-Learning Algorithms with Many Restarts and Bounded-Width Resolution", "authors": ["Albert Atserias", "Johannes Klaus Fichte", "Marc Thurley"], "emails": ["atserias@lsi.upc.edu", "fichte@kr.tuwien.ac.at", "marc.thurley@googlemail.com"], "sections": [{"heading": "1. Introduction", "text": "The discovery of a method to introduce practically feasible clause learning and non-chronological backtracking to DPLL-based solvers layed the foundation of what is sometimes called \u201cmodern\u201d SAT-solving (Silva & Sakallah, 1996; Bayardo & Schrag, 1997). These methods set the ground for new effective implementations (Moskewicz, Madigan, Zhao, Zhang, & Malik, 2001) that spawned tremendous gains in the efficiency of SAT-solvers with many practical applications. Such great and somewhat unexpected success seemed to contradict the widely assumed intractability of SAT, and at the same time uncovered the need for a formal understanding of the capabilities and limitations underlying these methods.\nSeveral different approaches have been suggested in the literature for developing a rigorous understanding. Among these we find the proof-complexity approach, which captures the power of SAT-solvers in terms of propositional proof systems (Beame, Kautz, & Sabharwal, 2003, 2004; Hertel, Bacchus, Pitassi, & Gelder, 2008; Pipatsrisawat & Darwiche, 2009), and the rewriting approach, which provides a useful handle to reason about the properties of the underlying algorithms and their correctness (Nieuwenhuis, Oliveras, & Tinelli, 2006). In both approaches, SAT-solvers are viewed as algorithms that search for proofs in some underlying proof system for propositional logic. With this view in mind, it was illuminating to understand that the proof system underlying modern solvers is always\nc\u00a92011 AI Access Foundation. All rights reserved.\na subsystem of resolution (Beame et al., 2003). In particular, this means that their performance can never beat resolution lower bounds, and at the same time it provides many explicit examples where SAT-solvers require exponential time. Complementing this is the result that an idealized SAT-solver that relies on non-determinism to apply the techniques in the best possible way will be able to perform as good as general resolution (weak forms of this statement were first established in Beame et al., 2003, 2004; Hertel et al., 2008, and in the current form in Pipatsrisawat & Darwiche, 2009). As Beame et al. (2004) put it, the negative proof complexity results uncover examples of inherent intractability even under perfect choice strategies, while the positive proof complexity results give hope of finding a good choice strategy.\nIn this work we add a new perspective to this kind of rigorous result. We try to avoid non-deterministic choices on all components of our abstract solver and still get positive proof complexity results. Our main finding is that a concrete family of SAT-solvers that do not rely on non-determinism besides mild randomness is at least as powerful as bounded-width resolution. The precise proof-complexity result is that under the unit-propagation rule and a standard learning scheme considered by state-of-the-art solvers, the totally random decision strategy needs no more than O(k2 ln(kn)n2k+1) conflicts and deterministic restarts to detect the unsatisfiability of any CNF formula on n variables having a width-k resolution refutation, with probability at least 1/2. Remarkably, the analysis will provide an exact expression for this upper bound that holds for all values of n and k and in particular the bound we get is not asymptotic. Another remarkable feature is that our analysis is insensitive to whether the algorithm implements non-chronological backtracking or heuristic-based decisions provided it restarts often enough, and provided it performs totally random decisions often enough. Further details about this are given in Section 2.\nBy itself this result has some nice theoretical consequences, which we shall sketch briefly. First, although not explicitly designed for that purpose, SAT-solvers are able to solve instances of 2-SAT in polynomial time since every unsatisfiable 2-CNF formula has a resolution refutation of width two. More strongly, our result can be interpreted as showing that widthk resolution can be simulated by O(k2 ln(kn)n2k+1) rounds of unit-clause propagation. To our knowledge, such a tight connection between width-k resolution and repeated application of \u201cwidth-one\u201d methods was unknown before. Another consequence is that SAT-solvers are able to solve formulas of bounded branch-width (and hence bounded treewidth) in polynomial time. We elaborate on this later in the paper. Finally, from the partial automatizability results of Ben-Sasson and Wigderson (1999), it follows that SAT-solvers are able to solve formulas having polynomial-size tree-like resolution proofs in quasipolynomial time, and formulas having polynomial-size general resolution proofs in subexponential time.\nConcerning our techniques, it is perhaps surprising that the proof of our main result does not proceed by showing that the width-k refutation is learned by the algorithm. For all we know the produced proof has much larger width. The only thing we show is that every width-k clause in the refutation is absorbed by the algorithm, which means that it behaves as if it had been learned, even though it might not. In particular, if a literal and its complement are both absorbed, the algorithm correctly declares that the formula is unsatisfiable. This sort of analysis is the main technical contribution of this paper."}, {"heading": "1.1 Related Work", "text": "The first attempt to compare the power of SAT-solvers with the power of resolution as a proof system was made by Beame et al. (2003, 2004). The main positive result from their work is that clause learning with a specific learning scheme and without restarts can provide exponentially shorter proofs than proper refinements of resolution such as tree, or regular, or positive resolution. Furthermore, they show that the modification of a standard solver to allow multiple assignments on the same variable would be able to simulate general resolution efficiently, assuming an ideal decision strategy. Following work showed that the requirement for multiple assignments on the same variable is a technical issue that can be avoided if the given CNF formula is pre-processed appropriately (Hertel et al., 2008). In our work we avoid these two maneuvers by introducing the concept of clause-absorption to help us analyze the standard algorithms directly.\nInterestingly, for clauses that are logical consequences of the input formulas, our concept of clause-absorption turns out to be dual to the concept of 1-empowerment introduced independently by Pipatsrisawat and Darwiche (2009)1. They used 1-empowerment to show that SAT-solvers without any conceptual modification in their operation are able to simulate general resolution efficiently, again assuming an ideal decision strategy. For comparison, our goal settles for a weaker simulation result, bounded-width resolution instead of general resolution, but does not rely on the non-determinism of ideal decision. We show that the totally random decision strategy is good enough for this purpose, provided we restart often enough. To complete this point, it is worth noting that the non-automatizability results of Alekhnovich and Razborov (2008) indicate that we cannot expect an efficient simulation of general resolution and completely avoid non-determinism at the same time.\nThe fact that both concepts were discovered independently adds confidence to our belief that they will play a role in subsequent studies of the power of SAT-solvers. Indeed, our techniques were recently extended to show that SAT-solvers with a totally random decision strategy are able to efficiently simulate local consistency techniques for general constraint satisfaction problems (Jeavons & Petke, 2010)."}, {"heading": "1.2 Organization", "text": "In Section 2 we introduce basic notation and we define the algorithm we analyze. We also discuss the dependence of our results on our choice of the learning scheme, the restart policy and the decision strategy used by the algorithm. Section 3 starts with some elementary facts about the runs of the algorithm, continues with the key definitions of absorption and beneficial rounds, and then with the analysis of the running time of the algorithm. Section 4 contains a discussion of the consequences, including the implications for formulas of bounded treewidth."}, {"heading": "2. Clause Learning Algorithms", "text": "In this section we will define the algorithm and discuss our choice of its components. We start with some preliminary definitions.\n1. Note that, originally, a weaker version of 1-empowerment was introduced by Pipatsrisawat and Darwiche (2008)."}, {"heading": "2.1 Preliminaries", "text": "Let V = {v1, . . . , vn} be a fixed set of propositional variables. A literal is a propositional variable x or its negation x\u0304. We use the notation x0 for x\u0304 and x1 for x. Note that xa is defined in such a way that the assignment x = a satisfies it. For a \u2208 {0, 1}, we also use a\u0304 for 1 \u2212 a, and for a literal ` = xa we use \u00af\u0300 for x1\u2212a. A clause is a set of literals, and a formula in conjunctive normal form (CNF-formula) is a set of clauses. The width of a clause is the number of literals in it. In the following, all formulas are over the same set of variables V and every clause contains only literals on variables from V .\nFor two clauses A = {x, `1, . . . , `r} and B = {x\u0304, `\u20321, . . . , `\u2032s} we define the resolvent of A and B on x by Res(A,B, x) = {`1, . . . , `r, `\u20321, . . . , `\u2032s}. If the variable we resolve on, x, is implicit we simply write Res(A,B). A clause may contain a literal and its negation. Note that the resolvent Res(A,B, x) of A and B on x is still well-defined in this case. A resolution refutation of a CNF formula F is a sequence of clauses C1, . . . , Cm such that Cm = \u2205 and each clause Ci in the sequence either belongs to F or is a resolvent of previous clauses in the sequence. The length of a refutation is the number m of clauses in the sequence. For a clause C, a variable x, and a truth value a \u2208 {0, 1}, the restriction of C on x = a is the constant 1 if the literal xa belongs to C, and C \\ {x1\u2212a} otherwise. We write C|x=a for the restriction of C on x = a.\nA partial assignment is a sequence of assignments (x1 = a1, . . . , xr = ar) with all variables distinct. Let \u03b1 be a partial assignment. We say that \u03b1 satisfies a literal xa if it contains x = a. We say that \u03b1 falsifies it if it contains x = 1 \u2212 a. If C is a clause, we let C|\u03b1 be the result of applying the restrictions x1 = a1, . . . , xr = ar to C. Clearly the order does not matter. We say that \u03b1 satisfies C if it satisfies at least one of its literals; i.e., if C|\u03b1 = 1. We say that \u03b1 falsifies C if it falsifies all its literals; i.e., if C|\u03b1 = \u2205. If D is a set of clauses, we let D|\u03b1 denote the result of applying the restriction \u03b1 to each clause in D, and removing the resulting 1\u2019s. We call D|\u03b1 the residual set of clauses."}, {"heading": "2.2 Definition of the Algorithm", "text": "A state is a sequence of assignments (x1 = a1, . . . , xr = ar) in which all variables are distinct and some assignments are marked as decisions. We use the notation xi d = ai to denote that the assignment xi = ai is a decision assignment. In this case xi is called a decision variable. The rest of assignments are called implied assignments. We use S and T to denote states. The empty state is the one without any assignments. Define the decision level of an assignment xi = ai as the number of decision assignments in (x1 = a1, . . . , xi = ai). When convenient, we identify a state with the underlying partial assignment where all decision marks are ignored."}, {"heading": "2.2.1 Operation", "text": "The algorithm maintains a current state S and a current set of clauses D. There are four modes of operation DEFAULT, CONFLICT, UNIT, and DECISION. The algorithm starts in DEFAULT mode with the empty state as the current state and the given CNF formula as the current set of clauses:\n\u2022 DEFAULT. If S sets all variables in D and satisfies all clauses in D, stop and output SAT together with the current state S. Otherwise, if D|S contains the empty clause, move to CONFLICT mode. Otherwise, if D|S contains a unit clause, move to UNIT mode. Finally, if control reaches this point, move to DECISION mode.\n\u2022 CONFLICT. Apply the learning scheme to add a new clause C to D. If C is the empty clause, stop and output UNSAT. Otherwise, apply the restart policy to decide whether to continue further or to restart in DEFAULT mode with the currentD and S initialized to the empty state. In case we continue further, repeatedly remove assignments from the tail of S as long as C|S = \u2205, and then go to UNIT mode.\n\u2022 UNIT. For any unit clause {xa} in D|S , add x = a to S and go back to DEFAULT mode.\n\u2022 DECISION. Apply the decision strategy to determine a decision x d= a to be added to S and go back to DEFAULT mode.\nTo guarantee correctness and termination, the learning scheme will always add a clause C that is a logical consequence of D, for which C|S = \u2205 holds at the time it is added, and that contains at most one variable of maximum decision level. It is not hard to see that these properties prevent such a clause from being learned twice, and since the number of clauses on the variables of D is finite, this implies termination. Clauses with these characteristics always exist as they include the asserting clauses (Zhang, Madigan, Moskewicz, & Malik, 2001) that will be discussed in Section 2.3.3.\nThe well-known DPLL-procedure is a precursor of this algorithm where, in CONFLICT mode, the learning scheme never adds any new clause, the restart policy does not dictate any restart at all, and assignments are removed from the tail of S up to the latest decision assignment, say x d = a, which is replaced by x d = 1 \u2212 a. We say that the DPLL-procedure backtracks on the latest decision. In contrast, modern SAT-solvers implement learning schemes and backtrack on a literal, as determined by the learned clause, which is not necessarily the latest decision. This is called non-chronological backtracking. Besides learning schemes and non-chronological backtracking, modern SAT-solvers also implement restart policies and appropriate decision strategies. We discuss our choice of these components of the algorithm in Section 2.3."}, {"heading": "2.2.2 Runs of the Algorithm", "text": "Consider a run of the algorithm started in DEFAULT mode with the empty state and initial set of clauses D, until either a clause is falsified or all variables are set. Such a run is called a complete round started with D and we represent it by the sequence of states S0, . . . , Sm that the algorithm goes through, where S0 is the empty state and Sm is the state where either all variables are set, or the falsified clause is found. More generally, a round is an initial segment S0, . . . , Sr of a complete round up to a state where either D|Sr contains the empty clause or D|Sr does not contain any unit clause. If D|Sr contains the empty clause we say that the round is conclusive. If a round is not conclusive we call it inconclusive. The\nterm inconclusive means to reflect the fact that no clause can be learned from such a round. In particular, a (complete) round that ends in a satisfying assignment is inconclusive2.\nFor a round S0, . . . , Sr, note that for i \u2208 {1, . . . , r}, the state Si extends Si\u22121 by exactly one assignment of the form xi = ai or xi d = ai depending on whether UNIT or DECISION is executed at that iteration; no other mode assigns variables. When this does not lead to confusion, we identify a round with its last state interpreted as a partial assignment. In particular, we say that the round satisfies a clause C if C|Sr = 1, and that it falsifies it if C|Sr = \u2205."}, {"heading": "2.3 Restart Policy, Learning Scheme, and Decision Strategy", "text": "In the following we will discuss our choice of the learning scheme, the restart policy and the decision strategy used by the algorithm. Our discussion will particularly focus on the dependence of our results on this choice."}, {"heading": "2.3.1 Restart Policy", "text": "The restart policy determines whether to restart the search after a clause is learned. The only important characteristic that we need from the restart policy is that it should dictate restarts often enough. In particular, our analysis will work equally well for the most aggressive of the restart policies, the one that dictates a restart after every conflict, as for a less aggressive strategy that allows any bounded number of conflicts between restarts. The fact that our analysis is insensitive to this will follow from a monotonicity property of the performance of the algorithm that we will prove in Lemma 5. More precisely, it will follow from the monotonicity lemma that if we decide to use a policy that allows c > 1 conflicts before a restart, then the upper bound on the number of required restarts can only decrease (or stay the same). Only the upper bound on the number of conflicts would appear multiplied by a factor of c, even though the truth might be that even those decrease as well. For simplicity of exposition, for the rest of the paper we assume that the restart policy dictates a restart after every conflict."}, {"heading": "2.3.2 Decision Strategy", "text": "The decision strategy determines which variable is assigned next, and to what value. Again, the only important characteristic that we need from the decision strategy is that it should allow a round of totally random decisions often enough. Here, a totally random decision is defined as follows: if the current state of the algorithm is S, we choose a variable x uniformly at random among the variables from V that do not appear in S, and a value a in {0, 1} also uniformly at random and independently of the choice of x. Thus, our analysis actually applies to any decision strategy that allows any bounded number of rounds with heuristic-based decisions between totally random ones. More precisely, if we allow say c > 1 rounds of non-random decisions between random ones, then the number of required restarts and conflicts would appear multiplied by a factor of c. Again this will follow from the\n2. Let us note that the definitions of round, conclusive round and inconclusive round differ slightly from those given in the conference version of this paper (Atserias, Fichte, & Thurley, 2009). The current definitions make the concepts more robust.\nmonotonicity lemma referred to above. That said, for simplicity of exposition we assume in the following that every decision is totally random."}, {"heading": "2.3.3 Learning Scheme", "text": "The learning scheme determines which clause will be added to the set of clauses when a conflict occurs. Let S0, . . . , Sr be a conclusive round started with the set of clauses D that ends up falsifying some clause of D. Let xi = ai or xi d = ai be the i-th assignment of the round. We annotate each Si by a clause Ai by reverse induction on i \u2208 {1, . . . , r}:\n1. Let Ar+1 be any clause in D that is falsified by Sr.\n2. For i \u2264 r for which xi d = ai is a decision, let Ai = Ai+1.\n3. For i \u2264 r for which xi = ai is implied, let Bi be any clause in D such that Bi|Si\u22121 is the unit clause {xaii }, and let Ai = Res(Ai+1, Bi, xi) if these clauses are resolvable on xi, and let Ai = Ai+1 otherwise.\nIt is quite clear from the construction that each Ai has a resolution proof from the clauses in D. In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause. If d denotes the maximum decision level of the assignments in Sr, a conflict clause is called an asserting clause if it contains exactly one variable of decision level d. Asserting clauses, originally defined by Zhang et al. (2001), capture the properties of conflict clauses learned by virtually any modern SAT-solver. For brevity, we describe only two concrete learning schemes in detail. For other schemes see the work of Zhang et al. (2001).\nThe Decision learning scheme adds clause A1 to the current set of clauses after each conflict. It is not hard to check that A1 is an asserting clause. Furthermore, every literal in A1 is the negation of some decision literal in Sr; this will be important later on. The 1UIP learning scheme, which stands for 1st Unique Implication Point, is the one that adds a clause Ai such that i \u2264 r is maximal subject to the condition that Ai is an asserting clause.\nIn the following we will assume, tacitly, that the algorithm employs some asserting learning scheme, that is, one whose learned clauses are always asserting, except for the empty clause."}, {"heading": "2.3.4 Clause Bookkeeping", "text": "It should be mentioned that our analysis relies crucially on the assumption that the learned clauses are never removed from the current set of clauses. However, practical SAT-solvers periodically delete some of the learned clauses to save memory and to avoid the overhead they introduce. Thus an interesting question is whether our results can be made to work without the assumption. In this respect, the strong proof-complexity results of Nordstro\u0308m (2009) showing that not every small-width resolution refutation can be made to work in small clause-space seems to indicate that an assumption similar to ours is indeed needed.\nAnother remark worth making at this point concerns the width of the learned clauses. Since our goal is to show that the algorithm can simulate small-width resolution, it seems natural to ask whether we can restrict the learning scheme to learn clauses of small width\nonly. As mentioned in the introduction, our analysis does not seem to allow it. Moreover, recent results by Ben-Sasson and Johannsen (2010) show that, in general, learning short clauses only is a provably weaker scheme than learning arbitrarily long clauses. Thus, while the examples of Ben-Sasson and Johannsen (2010) do not have small-width resolution refutations and therefore do not show that keeping long clauses is actually required in this case, it is conceivable that it might."}, {"heading": "3. Analysis of the Algorithm", "text": "In this section we will analyze the running time of the algorithm. Before we can do this, however, we will have to introduce our key technical concepts of absorption and beneficial rounds, and study some of their most important properties."}, {"heading": "3.1 Runs of the Algorithm", "text": "Let R and R\u2032 be rounds, and let C be a clause. We say that R\u2032 subsumes R if, up to decision marks, every assignment in R appears also in R\u2032. We say that R and R\u2032 agree on C if the restrictions of R and R\u2032 to variables in C are equal: every variable in C is either unassigned in both, or assigned to the same value in both. We say that R branches in C if all decision variables of R are variables in C. Note that the properties agree on C and branches in C depend only on the set of variables of C. We define them for clauses to simplify notation later on.\nWe prove two rather technical lemmas. The goal is to show that inconclusive rounds are robust with respect to the order in which assignments are made. For example, the first lemma shows that any inconclusive round subsumes any other round that agrees with it on its decisions. In fact we will need a slightly stronger claim that involves rounds from two different sets of clauses.\nLemma 1. Let D and D\u2032 be sets of clauses with D \u2286 D\u2032, let C be a clause, and let R\u2032 be an inconclusive round started with D\u2032. Then, for every round R started with D that branches in C and agrees with R\u2032 on C, it holds that R\u2032 subsumes R.\nProof. Let R = (S0, . . . , Sr). By induction on i, we prove that for every i \u2208 {0, . . . , r}, every assignment in Si is also made in R\n\u2032. For i = 0 there is nothing to prove since S0 = \u2205. Let i > 0 and assume that every assignment in Si\u22121 is also made in R \u2032. Let x = a or x d = a be the last assignment in Si. Since R and R \u2032 agree on C and R branches in C, every decision assignment made in R is also made in R\u2032. This takes care of the case x d = a. Suppose then that the last assignment x = a in Si is implied. This means that there exists a clause A in D such that A|Si\u22121 = {xa}. Since D \u2286 D\u2032 and every assignment made in Si\u22121 is also made in R\u2032, necessarily x = a appears in R\u2032 because R\u2032 is inconclusive and cannot leave unit clauses unset.\nThe next lemma shows that the universal quantifier in the conclusion of the previous lemma is not void. In addition, the round can be chosen inconclusive.\nLemma 2. Let D and D\u2032 be sets of clauses with D \u2286 D\u2032, let C be a clause, and let R\u2032 be an inconclusive round started with D\u2032. Then, there exists an inconclusive round R started with D that branches in C and agrees with R\u2032 on C, and such that R\u2032 subsumes R.\nProof. Let R\u2032 = (T0, . . . , Tt). Define I \u2286 {0, . . . , t} as the set of indices i such that the i-th assignment of R\u2032 assigns some variable in C. For i \u2208 I, let xi = ai or xi d = ai be the i-th assignment in R\u2032.\nWe will construct a round R = (S0, . . . , Ss) started with D inductively. Associated with each Sj is the set Ij \u2286 I of indices i such that xi is left unassigned in Sj . Recall that S0 is the empty state by definition. Hence I0 = I. We define the following process:\n1. If Sj falsifies some clause in D or it sets all variables in V then set s = j and stop.\n2. Otherwise, if there is a unit clause {xa} in D|Sj then let Sj+1 be Sj plus x = a.\n3. Otherwise, if Ij is non-empty, let i be the minimum element of Ij , and let Sj+1 be\nobtained by adding the decision xi d = ai to Sj .\nIf none of the above cases applies set s = j and stop the process.\nBy construction R is a valid round started with D. Let us see that R\u2032 subsumes R: let A be the set of literals made true by decisions in R. By construction, R and R\u2032 agree on A and hence R\u2032 subsumes R by Lemma 1. Furthermore, R is inconclusive: By D \u2286 D\u2032 and R\u2032 being inconclusive, D|R\u2032 does not contain the empty clause, and as R\u2032 subsumes R, also D|R does not contain the empty clause. Further, as every variable in C belongs to V and R is inconclusive, the process stops with Is = \u2205. Together with the fact that R\u2032 subsumes R, this shows that R and R\u2032 agree on C. Note finally that R branches in C by construction."}, {"heading": "3.2 Absorption", "text": "One key feature of the definition of a round is that if it is inconclusive, then the residual set of clauses does not contain unit clauses and, in particular, it is closed under unit propagation. This means that for an inconclusive round R started with D, if A is a clause in D and R falsifies all its literals but one, then R must satisfy the remaining literal, and hence A as well. Besides those in D, other clauses may have this property, which is important enough to deserve a definition:\nDefinition 3 (Absorption). Let D be a set of clauses, let A be a non-empty clause and let xa be a literal in A. We say that D absorbs A at xa if every inconclusive round started with D that falsifies A \\ {xa} assigns x to a. We say that D absorbs A if D absorbs A at every literal in A.\nNaturally, when D absorbs A at xa we also say that A is absorbed by D at xa.\nIntuitively, one way to think of absorbed clauses is as being learned implicitly. The rest of this section is devoted to make this intuition precise. For now, let us note that if there are no inconclusive rounds started with D, then every clause is absorbed. This agrees with the given intuition since the absence of inconclusive rounds means that unit-clause propagation applied on D produces the empty clause. In this section we also show that the notion of clause-absorption is tightly connected to the concept of 1-empowerment independently introduced by Pipatsrisawat and Darwiche (2009)."}, {"heading": "3.2.1 Properties of Absorption", "text": "Before we continue, let us discuss some key properties of absorption. We argued already that every clause in D is absorbed by D. We give an example showing that D may absorb other clauses. Let D be the set consisting of the three clauses\na \u2228 b\u0304 b \u2228 c a\u0304 \u2228 b\u0304 \u2228 d \u2228 e.\nIn this example, the clause a\u2228 c does not belong to D but is absorbed by D since every inconclusive round that sets a = 0 must set c = 1 by unit-propagation, and every inconclusive round that sets c = 0 must set a = 1 also by unit-propagation. While D may absorb other clauses as we just saw, we note that every non-empty clause absorbed by D is a logical consequence of D. We write D |= C, if every satisfying assignment of D satisfies C.\nLemma 4. Let D be a set of clauses and let C be a non-empty clause. If D absorbs C, then D |= C.\nProof. Let S be a full assignment that satisfies all clauses in D. We want to show that S satisfies C as well. Let R = (S0, . . . , Sr) be a complete round of the algorithm started with D that sets all its decision variables as they are set in S. By induction on i \u2208 {0, . . . , r}, we will show that Si \u2286 S and it will follow that R is not stopped by a conflict and therefore Sr = S. In particular R is inconclusive, and if it falsifies all literals of C but one, it must satisfy the remaining one because C is absorbed. Since R sets all variables in C and Sr = S, this means that S satisfies C.\nIt remains to show that Si \u2286 S for every i. For i = 0 there is nothing to show since S0 = \u2205. Fix i > 0 and assume that Si\u22121 \u2286 S. Let x = a or x d = a be the last assignment in Si. The case x d = a is taken care by the assumption that all decision variables of R are set as in S. Suppose then that the last assignment x = a is implied. This means that there exists a clause A in D such that A|Si\u22121 = {xa}. Since S satisfies D and Si\u22121 \u2286 S, necessarily x is set to a in S.\nNext, let us see that the converse of the above lemma does not hold; namely, we see that not every implied clause is absorbed. In the previous example, for instance, note that b\u0304\u2228d\u2228e is a consequence of D (resolve the first and the third clause on a) but is not absorbed by D (consider the inconclusive round d d = 0, e d = 0).\nOne interesting property that is illustrated by this example is that if C is the resolvent of two absorbed clauses A and B, and C is not absorbed at some literal `, then ` appears in both A and B. In the example above, D does not absorb b\u0304\u2228 d\u2228 e at b\u0304, and b\u0304 appears in the clauses a \u2228 b\u0304 and a\u0304 \u2228 b\u0304 \u2228 d \u2228 e from D, whose resolvent is precisely b\u0304 \u2228 d \u2228 e. We will prove this general fact in the next section where the objects of study will be non-absorbed resolvents of absorbed clauses.\nNext we show three key monotonicity properties of clause-absorption, where the first is the one that motivated its definition.\nLemma 5. Let D and E be sets of clauses and let A and B be non-empty clauses. The following hold:\n1. if A belongs to D, then D absorbs A,\n2. if A \u2286 B and D absorbs A, then D absorbs B, 3. if D \u2286 E and D absorbs A, then E absorbs A.\nProof. To prove 1. assume for contradiction that there is a literal ` in A and an inconclusive round S0, . . . , Sr started with D which falsifies A\\{`} but does not satisfy A. As the round is inconclusive, we cannot have A|Sr = \u2205, which means then that A|Sr = {`}, in contradiction to the definition of round.\nFor the proof of 2. let ` be a literal of B and define B\u2032 = B \\ {`}. We consider two different cases. If ` /\u2208 A then A \u2286 B\u2032 and, as A is absorbed by D, there is no inconclusive round which falsifies B\u2032. Thus B is absorbed in this case. If ` \u2208 A, let A\u2032 = A \\ {`} and let S0, . . . , Sr be an inconclusive round started with D which falsifies B \u2032. Then it falsifies A\u2032 and satisfies A by absorption. Thus it satisfies B, and B is absorbed in this case as well. It remains to prove 3. Let ` be some literal in A and A\u2032 = A \\ {`}. Let R\u2032 be an inconclusive round started with E which falsifies A\u2032. By Lemma 2, there is an inconclusive round R started with D which falsifies A\u2032 and which is subsumed by R\u2032. As A is absorbed by D, we see that R (and hence R\u2032) satisfies A."}, {"heading": "3.2.2 Absorption and Empowerment", "text": "Our next goal is to show that absorption and empowerment are dual notions. For assignments \u03b1, \u03b2 we write \u03b1 \u2286 \u03b2 if every assignment in \u03b1 is also in \u03b2. Let us reproduce the definition of 1-empowerment in the work of Pipatsrisawat and Darwiche (2009), slightly adapted to better suit our notation and terminology.\nDefinition 6 (1-Empowerment in Pipatsrisawat & Darwiche, 2009). Let D be a set of clauses, let C be a non-empty clause and let xa be a literal in C. Let \u03b1 be the assignment that sets y = 1\u2212 b for every literal yb in C \\ {xa}. We say that C is 1-empowering via xa with respect to D, if the following three conditions are met:\n1. C is a logical consequence of D; i.e. D |= C, 2. repeated applications of unit-clause propagation on D|\u03b1 do not yield the empty clause, 3. repeated applications of unit-clause propagation on D|\u03b1 do not assign x to a.\nWe also say that xa is an empowering literal of C. We say that C is 1-empowering if it is 1-empowering via some literal in C.\nA preliminary version of this definition was given by Pipatsrisawat and Darwiche (2008) where the second of the three conditions was not required.\nBy the definition of absorption, we see that if some non-empty clause A is not absorbed by a set of clauses D, then there is an inconclusive round R started with D and a literal xa in A such that R falsifies A \\ {xa} but does not satisfy {xa}. When A is a logical consequence of D, this witnesses precisely the fact that A is 1-empowering via xa. We show that the converse is also true:\nLemma 7. Let D be a set of clauses, let C be a non-empty clause such that D |= C, and let xa be a literal in C. Then, C is 1-empowering via xa with respect to D if and only if D does not absorb C at xa.\nProof. Let C \u2032 = C\\{xa}. Assume first thatD does not absorb C at xa. Let R = (S0, . . . , Sr) be an inconclusive round started with D witnessing this fact, i.e. Sr falsifies C\n\u2032 and does not assign x = a. In particular \u03b1 \u2286 Sr. Furthermore, for every unit clause {yb} in D|\u03b1 we have y = b in Sr, as R is an inconclusive round. By a straightforward induction, we see that every \u03b2 obtained from \u03b1 by repeated applications of unit-clause propagation from D|\u03b1 also satisfies \u03b2 \u2286 Sr. This directly implies conditions 2. and 3. in the definition of 1-empowerment. Condition 1. is met by assumption.\nFor the converse, assume that C is 1-empowering via xa with respect to D. We have to show that there is an inconclusive round started with D that falsifies C \u2032 but does not assign x = a. Let R = (S0, . . . , Sr) be a round started with D in which every decision assignment is chosen to falsify a literal in C \u2032, and that, among all rounds with this property, assigns as many literals from C \u2032 as possible. Clearly such a maximal round exists since the one that does not make any decision meets the property.\nWe shall show that R is the round we seek. For each i \u2208 {0, . . . , r}, let \u03b1i \u2286 \u03b1 be the maximal assignment such that \u03b1i \u2286 Si, let \u03b2i be obtained from \u03b1i by repeated applications of unit-clause propagation from D|\u03b1i , and let \u03b3i be the subset of assignments in \u03b2i that are also in Si. In particular \u03b3i \u2286 Si. We shall prove, by induction on i, that Si \u2286 \u03b3i and hence Si = \u03b3i.\nThe base case i = 0 is trivial since S0 = \u2205. Assume now that i > 0 and Si\u22121 \u2286 \u03b3i\u22121. If the i-th assignment of Si is a decision assignment, then by construction it falsifies a literal in C \u2032 and hence belongs to \u03b1. But then it also belongs to \u03b1i, \u03b2i and \u03b3i as required. If the i-th assignment of Si is implied we distinguish two cases: whether it also belongs to \u03b1 or not. If the implied assignment is also in \u03b1, then it is in \u03b1i, \u03b2i and \u03b3i as required. If the implied assignment is not in \u03b1, then \u03b1i = \u03b1i\u22121 and hence \u03b2i = \u03b2i\u22121. But then, since Si\u22121 \u2286 \u03b3i\u22121 by induction hypothesis and \u03b3i\u22121 \u2286 \u03b2i\u22121, the unit clause responsible for the definition of Si appears in the process of forming \u03b2i\u22121 and hence in the process of forming \u03b2i. Therefore the assignment will also be in \u03b3i.\nThis completes the induction and shows, in particular, that Sr = \u03b3r. By point 2. in the definition of 1-empowerment, R is inconclusive. Furthermore, by point 3. in the definition of 1-empowerment, Sr does not assign x = a. It remains to show that Sr falsifies C\n\u2032. First note that, by the maximality of R and the fact that R is inconclusive, every literal in C \u2032 is assigned by R. Moreover, since the decision assignments of R are chosen to falsify the literals in C \u2032, it suffices to show that the implied assignments of R do not satisfy any literal in C \u2032. Thus, suppose for contradiction that y = b is an implied assigned in R and that yb is a literal in C \u2032. Let i \u2208 {0, . . . , r} be such that {yb} is a unit-clause in D|Si . Since Si \u2286 Sr \u2286 \u03b3r and y is assigned to 1 \u2212 b in \u03b1, the unit-clause {yb} in D|Si appears as the empty clause in the closure under unit-clause propagation of D|\u03b1; this contradicts point 2. in the definition of 1-empowerment and completes the proof.\nLet us note at this point that if condition 1. in the definition of 1-empowerment is dropped, then the hypothesis that D |= C can also be dropped from Lemma 7. This would make 1-empowerment and absorption literally dual of each other."}, {"heading": "3.3 Beneficial Rounds", "text": "We shall now study the key situation that explains how the algorithm can possibly simulate resolution proofs. Consider the resolvent C = Res(A,B) of two absorbed clauses A and B which itself, however, is not absorbed. Our goal is to study what A, B and C look like in such a case. We start by showing that if C is not absorbed at a literal ` \u2208 C, then ` appears in both A and B. This property held the key for discovering the concept of clauseabsorption and its relevance to the simulation of resolution proofs. A similar connection to clause learning was observed by Pipatsrisawat and Darwiche (2008), where it is also pointed out that the condition that some literal from C appears in both A and B is known as merge resolution (Andrews, 1968).\nLemma 8. Let D be a set of clauses, let A and B be two resolvable clauses that are absorbed by D, and let C = Res(A,B). If ` is a literal in C and D does not absorb C at `, then ` appears in both A and B.\nProof. Let y be such that C = Res(A,B, y), and let A\u2032 = A \\ {y} and B\u2032 = B \\ {y\u0304}. Let ` = xa be a literal in C and assume D does not absorb C at `. Then there exists an inconclusive round R that falsifies C \\ {xa} but does not set x to a. Since ` belongs to C and C = A\u2032 \u222a B\u2032 we have that ` belongs to A or to B, or to both. If it belongs to both, we are done. Otherwise, assume without loss of generality that it belongs to A but not to B. In this case R falsifies B \\ {y\u0304}, and since B is absorbed, y is set to 0 in R. But then R falsifies A \\ {xa}, and since A is absorbed, x is set to a in R. This contradicts the choice of R where x was not set to a.\nWe continue by showing that in the situation of interest, there always exist a beneficial round of the algorithm which predicts eventual absorption.\nDefinition 9 (Beneficial Round). Let D be a set of clauses, let A be a non-empty clause, let xa be a literal of A, and let R be an inconclusive round started with D. We say that R is beneficial for A at xa if it falsifies A \\ {xa}, branches in A \\ {xa}, leaves x unassigned, and yields a conclusive round if extended by the decision x d = a . The conclusive round obtained by extending R by x d = a is also called beneficial for A at xa. We say that R is beneficial for A if it is beneficial for A at some literal in A.\nIn other words, a round started with D that is beneficial for A at xa is a witness that D does not absorb A at xa, which is minimal with this property, and yet yields a conflict when x is set to the wrong value. Thus, informally, a beneficial round is a witness that D almost absorbs A at xa.\nLemma 10. Let D be a set of clauses, let A and B be two resolvable clauses that are absorbed by D, and let C = Res(A,B). If C is non-empty and not absorbed by D, then there is a round started with D that is beneficial for C.\nProof. We identify a literal xa in C for which we are able to build a beneficial round for C at xa.\nLet y be such that C = Res(A,B, y), and let A\u2032 = A \\ {y} and B\u2032 = B \\ {y\u0304}. As C is non-empty and not absorbed by D, there is a literal xa in C and an inconclusive round R\u2032\nstarted with D which falsifies C \u2032 = C \\ {xa} but does not set x to a. Also x is not assigned a\u0304 in R\u2032 since otherwise it would falsify C, and as C = A\u2032 \u222a B\u2032 and D absorbs both A and B, both y and y\u0304 would be satisfied by R\u2032. This shows that x is unassigned in R\u2032.\nLet R be the inconclusive round started with D which is obtained by applying Lemma 2 to C \u2032 and the given inconclusive round R\u2032. We claim that R is beneficial for C at xa: The round R falsifies C \u2032, as it agrees with R\u2032 on C \u2032. Also R branches in C \u2032 and, as R\u2032 subsumes R, leaves x unassigned. Finally, note that R and R\u2032 also agree on A \\ {y} and B \\ {y\u0304}. Hence extending the round R by a decision x d = a\u0304 yields a conclusive round; otherwise both y and y\u0304 would be satisfied since both A and B are absorbed by D."}, {"heading": "3.4 Main Technical Lemma", "text": "We will now start analyzing the number of complete rounds it takes until the resolvent of two absorbed clauses is absorbed as a function of its width. However, as this is not trivial we first have to determine the number of complete rounds it takes until a sufficient prerequisite of absorption occurs: a beneficial round.\nLemma 11. Let D be a set of clauses, and let A and B be two resolvable clauses that are absorbed by D and that have a non-empty resolvent C = Res(A,B). Let n be the total number of variables in D, and k be the width of C. For every t \u2265 1, let R0, . . . , Rt\u22121 denote the t consecutive complete rounds of the algorithm started with D, and let D0, . . . , Dt\u22121 denote the intermediate sets of clauses. Then, the probability that none of the Ri is beneficial for C and none of the Di absorbs C is at most e \u2212t/(4nk).\nProof. Let R0, . . . , Rt\u22121 denote the t consecutive complete rounds of the algorithm started with D, and let D0, . . . , Dt\u22121 be the intermediate sets of clauses. In particular D0 = D and Ri is a round started with Di. For every i \u2208 {0, . . . , t \u2212 1} let Ri be the event that Ri is not beneficial and let Di be the event that Di does not absorb C. We want to compute an upper bound for the joint probability of these events. Note that\nPr [ t\u22121\u22c2 i=0 Ri \u2229 Di ] = t\u22121\u220f j=0 Pr [ Rj \u2229 Dj \u2223\u2223\u2223 j\u22121\u22c2 i=0 Ri \u2229 Di ] \u2264 t\u22121\u220f j=0 Pr [ Rj \u2223\u2223\u2223 Dj \u2229 j\u22121\u22c2 i=0 Ri \u2229 Di ] (1)\nHence, we shall give appropriate upper bounds for the factors on the right hand side of this inequality. To do this, let us first bound Pr [ R\u0304j | Dj ,Rj\u22121,Dj\u22121, . . . ,R0,D0 ] from below. Under the conditions Dj ,Rj\u22121,Dj\u22121, . . . ,R0,D0, Lemma 10 implies that there is an inconclusive round R started with Dj which is beneficial for C at some x\na \u2208 C. The probability that Rj is beneficial for C is bounded from below by the probability that Rj is beneficial for C at xa. We will therefore bound the latter from below.\nFirst let us compute a lower bound on the probability that the first k\u22121 decisions of the decision strategy are chosen to falsify C \\{xa} and the k-th choice is x d= a\u0304. The probability that these choices are made is at least[(\nk \u2212 1 2n\n)( k \u2212 2\n2(n\u2212 1)\n) \u00b7 \u00b7 \u00b7 (\n1\n2(n\u2212 k + 2)\n)]( 1\n2(n\u2212 k + 1)\n) \u2265 (k \u2212 1)!\n2knk \u2265 1 4nk .\nNote that a round started with Dj that follows these choices may not even be able to do some of the decisions as the corresponding assignments may be implied. However, before\nthe decision x d = a\u0304 is made, a round following these choices will only perform decisions that agree with R in C \\ {xa} and therefore stay subsumed by R after every new decision, by Lemma 1. In particular, right before the decision x d = a it will be inconclusive, it will falsify C \\{xa}, and it will leave x unset. Also by Lemma 1 it has performed the same assignments as R up to order, and therefore the addition of x d = a will make it conclusive. It follows that the probability that the round will be beneficial for C at xa can only be bigger.\nConsequently, the probability ofRj conditional onDj ,Rj\u22121,Dj\u22121, . . . ,R0,D0 is bounded from above by 1\u2212 1\n4nk . Therefore, by equation (1) we have\nPr [ t\u22121\u22c2 i=0 Ri \u2229 Di ] \u2264 ( 1\u2212 1 4nk )t \u2264 e\u2212t/(4nk)\nwhere in the second inequality we used the fact that 1+x \u2264 ex for every real number x."}, {"heading": "3.5 Bounds", "text": "With the tools given above, we are now able to prove the main result of the paper: the simulation of width-k resolution by the algorithm. We shall first give the proof for the algorithm employing the Decision learning scheme. Not only is the proof easier and more instructive, but also we get slightly better bounds for this special case. Afterwards, we will see the result for asserting learning schemes in general."}, {"heading": "3.5.1 The Decision Scheme", "text": "The fact that makes Decision easier to analyze is that, for this learning scheme, the occurrence of a beneficial round immediately yields absorption at the next step. Indeed, if R is beneficial for C, then it branches in C, which means that the clause learned in this complete round is a subset of C. In particular this means that the next set of clauses will absorb a subset of C, and hence C as well by Lemma 5. We obtain the following result as a direct consequence to Lemma 11.\nLemma 12. Let D be a set of clauses, and let A and B be two resolvable clauses that are absorbed by D and that have a non-empty resolvent C = Res(A,B). Let n be the total number of variables in D and k be the width of C. Then, for all t \u2265 1, using the Decision learning scheme, the probability that C is not absorbed by the current set of clauses after t restarts is at most e\u2212t/(4n k).\nProof. Let R0, . . . , Rt\u22121 denote the t consecutive complete rounds of the algorithm started with D, and let D0, . . . , Dt be the intermediate sets of clauses. In particular D0 = D and Ri is a round started with Di. For every i \u2208 {0, . . . , t \u2212 1} let Ri be the event that Ri is not beneficial for C and let Di be the event that Di does not absorb C. If one of the Ri is beneficial for C, then Di+1 absorbs C. To see this, note that as R branches in C, the clause Ci learned from Ri satisfies Ci \u2286 C. Hence Di+1 absorbs both Ci and C by Lemma 5. Further, Dt also absorbs C, if one of the Di absorbs it again by Lemma 5. Hence, the probability that C is not absorbed by Dt is bounded from above by Pr[ \u22c2t\u22121 i=0Ri \u2229 Di]. Lemma 11 implies that this is bounded by e\u2212t/(4n k).\nTheorem 13. Let F be a set of clauses on n variables having a resolution refutation of width k and length m. With probability at least 1/2, the algorithm started with F , using the Decision learning scheme, learns the empty clause after at most 4m ln(4m)nk conflicts and restarts.\nProof. The resolution refutation must terminate with an application of the resolution rule of the form Res(x, x\u0304). We will show that for both ` = x and ` = x\u0304, the probability that {`} is not absorbed by the current set of clauses after 4m ln(4m)nk restarts is at most 1/4. Thus, both {x} and {x\u0304} will be absorbed with probability at least 1/2. If this is the case, it is straightforward that every complete round of the algorithm is conclusive. In particular, the round that does not make any decision is conclusive, and in such a case the empty clause is learned.\nLet C1, C2, . . . , Cr = {`} be the resolution proof of {`} that is included in the width-k resolution refutation of F . In particular r \u2264 m\u22121 and every Ci is non-empty and has width at most k. Let D0, D1, . . . , Ds be the sequence of clause-sets produced by the algorithm where s = rt and t = d4 ln(4r)nke. For every i \u2208 {0, . . . , r}, let Ei be the event that every clause in the initial segment C1, . . . , Ci is absorbed by Dit, and let E i be its negation. Note that Pr[ E0 ] = 1 vacuously and hence Pr[ E0 ] = 0. For i > 0, we bound the probability that Ei does not hold conditional on Ei\u22121 by cases. Let pi = Pr[ E i | Ei\u22121 ] be this probability. If Ci is a clause in F , we have pi = 0 by Lemma 5. If Ci is derived from two previous clauses, we have pi \u2264 e\u2212t/(4n k) by Lemma 12, which is at most 1/(4r) by the choice of t.\nThe law of total probability gives Pr [ E i ] = Pr [ E i | Ei\u22121 ] Pr [Ei\u22121] + Pr [ E i | E i\u22121 ] Pr [ E i\u22121 ] \u2264 Pr [ E i | Ei\u22121 ] + Pr [ E i\u22121 ] .\nAdding up over all i \u2208 {1, . . . , r}, together with Pr [ E0 ] = 0, gives Pr [ Er ] \u2264 \u2211r\ni=1 pi \u2264 r 4r = 1 4 . Since the probability that Cr is not absorbed by Drt is bounded by Pr[ Er ], the proof follows."}, {"heading": "3.5.2 Asserting Learning Schemes in General", "text": "We shall now study the algorithm applying an arbitrary asserting learning scheme. The analysis is a bit more complex than that of the Decision scheme since in general a clause learned from a complete round R cannot be assumed to be a subset of the decisions in R. Therefore we can only show that the resolvent is eventually absorbed by a little detour. We note that this proof has to overcome similar difficulties as, and is inspired by3, the proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009).\nWe need some preparation. Let C be a clause and D be a set of clauses. Let WC,D denote the set of literals ` in C such that there exists an inconclusive round started with D that is beneficial for C at `. Let u`,C,D denote the number of variables left unassigned by an inconclusive round started with D which is beneficial for C at `. If no such round exists, we define u`,C,D = 0. Note that this number is well-defined, as it follows easily from\n3. We thank an anonymous reviewer for pointing out that the original proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009) contained an error that was corrected in the version of the paper on their webpage. Our proof is not affected by this error.\nLemma 1 that every inconclusive round started with D which is beneficial for C at ` leaves the same number of variables unassigned. Further, define\nuC,D = \u2211\n`\u2208WC,D\nu`,C,D.\nNote that if C is absorbed by D, then WC,D = \u2205. Moreover, under the hypothesis of Lemma 10, the converse is also true. Analogously, if C is absorbed by D, then uC,D = 0 and, under the hypothesis of Lemma 10, the converse is also true.\nLemma 14. Let D and D\u2032 be sets of clauses with D \u2286 D\u2032. Let A and B be two resolvable clauses that are absorbed by D, and let C = Res(A,B). Then, WC,D\u2032 \u2286WC,D and u`,C,D\u2032 \u2264 u`,C,D for all ` \u2208WC,D.\nProof. If WC,D\u2032 = \u2205, nothing is to be shown. Otherwise, for xa in WC,D\u2032 , we start by showing that xa belongs to WC,D. Let R\n\u2032 be an inconclusive round started with D\u2032 which is beneficial for C at `. Application of Lemma 2 to R\u2032 and C\\{xa} yields an inconclusive round R started with D with the following properties: R\u2032 subsumes R, both agree on C \\ {xa}, and R branches in C \\ {xa}. To show that R is beneficial for C at xa, it only remains to prove that extending R by x d = a\u0304 yields a conclusive round. Let R\u2217 be a round defined by this extension. Let y be such that C = Res(A,B, y). Then R\u2217 falsifies B \\ {y\u0304} and A \\ {y}. By absorption, R\u2217 cannot be inconclusive, as otherwise, y and y\u0304 would be satisfied by R\u2217. This proves WC,D\u2032 \u2286WC,D.\nNow, we show that u`,C,D\u2032 \u2264 u`,C,D for every ` in WC,D. If ` does not belong to WC,D\u2032 nothing is to be shown since u`,C,D\u2032 = 0 in that case. Otherwise, let R\n\u2032 and R be inconclusive rounds beneficial for C at ` such that R\u2032 is started with D\u2032 and R is started with D. By Lemma 1, R\u2032 subsumes R, which finishes the proof.\nLemma 15. Let D be a set of clauses, let A and B be two resolvable clauses that are absorbed by D, and let C = Res(A,B). Let R be a conclusive round started with D and let D\u2032 be obtained from D by adding the asserting clause learned from R. If C is not empty and R is beneficial for C at some ` \u2208 C, then u`,C,D\u2032 < u`,C,D and uC,D\u2032 < uC,D.\nProof. By Lemma 14 we already know that uC,D\u2032 \u2264 uC,D and u`,C,D\u2032 \u2264 u`,C,D. Therefore, it suffices to demonstrate that, in the presence of R, the second inequality is strict.\nBy hypothesis, R is beneficial for C at `. Let C \u2032 be the asserting clause learned by R. Let R\u2217 be the unique inconclusive round contained in R which is beneficial for C at `; this is the round which does not contain the last decision made by R. By Lemma 1, the number of assignments made by any two rounds started with D and beneficial for C at ` are the same. Hence, the number of variables left unassigned by R\u2217 equals u`,C,D, and u`,C,D \u2265 1 since at least one variable is unset.\nIf u`,C,D\u2032 = 0 then already u`,C,D\u2032 < u`,C,D. Therefore, assume that u`,C,D\u2032 \u2265 1. In particular, there exists an inconclusive round R\u2032 started with D\u2032 which is beneficial for C at `. By Lemma 1 the round R\u2032 subsumes R\u2217. By the definition of asserting clauses, C \u2032|R\u2217 is a unit clause, and since C \u2032 belongs to D\u2032, it is absorbed by D\u2032 and hence R\u2032 satisfies C \u2032. This proves that R\u2032 sets at least one more variable than R\u2217 and therefore u`,C,D\u2032 < u`,C,D.\nWith these two technical lemmas in hand we are ready to state and prove the analogue of Lemma 12 for arbitrary asserting learning schemes.\nLemma 16. Let D be a set of clauses, and let A and B be two resolvable clauses that are absorbed by D and that have a non-empty resolvent C = Res(A,B). Let n be the total number of variables in D and let k be the width of C. Then, for all t \u2265 1, using an arbitrary asserting learning scheme, the probability that C is not absorbed by the current set of clauses after kn \u00b7 t restarts is at most kn \u00b7 e\u2212t/(4nk).\nProof. Let b = uC,D, and s = bt, and let D0, . . . , Ds be the sequence of sets of clauses produced by the algorithm, starting with D0 = D. For every i \u2208 {0, . . . , b}, let Xi = uC,Dit and let Ei be the event that Xi \u2264 b\u2212 i.\nWe will bound the probability that C is not absorbed by Dbt from above. Since this event implies that Xb 6= 0, it suffices to bound Pr[ Eb ]. Note that Pr[ E0 ] = 1 vacuously and hence Pr[ E0 ] = 0. For i > 0, we bound the probability that Ei does not hold. The law of total probability gives\nPr [ E i ] = Pr [ E i | Ei\u22121 ] Pr [Ei\u22121] + Pr [ E i | E i\u22121 ] Pr [ E i\u22121 ] \u2264 Pr [ E i | Ei\u22121 ] + Pr [ E i\u22121 ] .\nLet pi = Pr[ E i | Ei\u22121 ] and note that Pr[ E i | Xi\u22121 < b\u2212 i+ 1 ] = 0. Hence we have pi \u2264 Pr[ E i | Xi\u22121 = b\u2212 i+ 1 ]. Consider the sequence D(i\u22121)t+1, . . . , Dit of sets of clauses and the corresponding complete rounds of the algorithm. Conditional on Xi\u22121 = b\u2212 i+ 1, the event E i implies that Xi = Xi\u22121 6= 0 and hence none of the above sets of clauses absorbs C. Furthermore, by Lemma 15, none of the corresponding rounds is beneficial for C. Thus, by Lemma 11, we have pi \u2264 e\u2212t/(4n\nk). Adding up over all i \u2208 {1, . . . , r}, together with Pr [ E0 ] = 0, gives Pr [ Eb ] \u2264 \u2211b i=1 pi \u2264 b \u00b7 e\u2212t/(4n k). The Lemma follows as necessarily b \u2264 kn.\nWe are now able to prove the main theorem.\nTheorem 17. Let F be a set of clauses on n variables having a resolution refutation of width k and length m. With probability at least 1/2, the algorithm started with F , using an arbitrary asserting learning scheme, learns the empty clause after at most 4km ln(4knm)nk+1 conflicts and restarts.\nProof. The proof is analogous to the proof of Theorem 13 with Lemma 16 playing the role of Lemma 12, and choosing t = d4 ln(4m \u00b7 kn)nke now."}, {"heading": "4. Consequences", "text": "The total number of clauses of width k on n variables is bounded by 2k ( n k ) , which is at most 2nk for every n and k. Therefore, if F has n variables and a resolution refutation of width k, we may assume that its length is at most 4nk by the following estimate\nk\u2211 i=0 2i ( n i ) \u2264 1 + 2 k\u2211 i=1 ni = 1 + 2n \u00b7 ( nk \u2212 1 n\u2212 1 ) \u2264 4nk.\nWe obtain the following consequence to Theorem 17.\nCorollary 18. Let F be a set of clauses on n variables having a resolution refutation of width k. With probability at least 1/2, the algorithm started with F , using an arbitrary asserting learning scheme, learns the empty clause after at most 16k(k + 1) ln(16kn)n2k+1 conflicts and restarts.\nAn application of Corollary 18 is that, even though it is not explicitly defined for the purpose, the algorithm can be used to decide the satisfiability of CNF formulas of treewidth at most k in time O(k2 log(kn)n2k+3). This follows from the known fact that every unsatisfiable formula of treewidth at most k has a resolution refutation of width at most k + 1 (Alekhnovich & Razborov, 2002; Dalmau, Kolaitis, & Vardi, 2002; Atserias & Dalmau, 2008).\nIf we are interested in producing a satisfying assignment when it exists, we proceed by self-reducibility: we assign variables one at a time, running the algorithm log2(n) + 1 times after each assignment to detect if the current partial assignment cannot be extended any further, in which case we choose the complementary value for the variable. For this we use the fact that if F has treewidth at most k, then F |x=a also has treewidth at most k. For the analysis, note that since each run of the algorithm is correct with probability at least 1/2, each new assignment is correct with probability at least\n1\u2212 2\u2212(log2(n)+1) = 1\u2212 1 2n .\nThis means that all iterations are correct with probability at least (1 \u2212 12n) n \u2265 12 . The running time of this algorithm is O(k2(log(kn))2n2k+4)."}, {"heading": "Acknowledgments", "text": "We thank Martin Grohe for suggesting the problem of comparing the power of SAT-solvers with bounded-width resolution. We also thank Knot Pipatsrisawat and Adnan Darwiche for pointing out the connection between 1-empowering and absorption. Thanks also to Peter Jeavons for comments on the conference version of this paper, and to the anonymous referees for very detailed comments.\nThe first author was supported in part by CYCIT TIN2007-68005-C04-03. The second author was supported in part by the European Research Council (ERC), Grant 239962. The third author was supported in part by a fellowship within the Postdoc-Programme of the German Academic Exchange Service (DAAD). A preliminary version of this paper appeared in the Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing, SAT\u201909 (Atserias et al., 2009)."}], "references": [{"title": "Satisfiability, branch-width and Tseitin tautologies", "author": ["M. Alekhnovich", "A.A. Razborov"], "venue": "In Proceedings of the 43rd Symposium on Foundations of Computer Science (FOCS", "citeRegEx": "Alekhnovich and Razborov,? \\Q2002\\E", "shortCiteRegEx": "Alekhnovich and Razborov", "year": 2002}, {"title": "Resolution is not automatizable unless W[P] is tractable", "author": ["M. Alekhnovich", "A.A. Razborov"], "venue": "SIAM J. Comput.,", "citeRegEx": "Alekhnovich and Razborov,? \\Q2008\\E", "shortCiteRegEx": "Alekhnovich and Razborov", "year": 2008}, {"title": "Resolution with merging", "author": ["P.B. Andrews"], "venue": "J. ACM,", "citeRegEx": "Andrews,? \\Q1968\\E", "shortCiteRegEx": "Andrews", "year": 1968}, {"title": "A combinatorial characterization of resolution width", "author": ["A. Atserias", "V. Dalmau"], "venue": "J. Comput. Syst. Sci.,", "citeRegEx": "Atserias and Dalmau,? \\Q2008\\E", "shortCiteRegEx": "Atserias and Dalmau", "year": 2008}, {"title": "Clause-learning algorithms with many restarts and bounded-width resolution", "author": ["A. Atserias", "J.K. Fichte", "M. Thurley"], "venue": "Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Atserias et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Atserias et al\\.", "year": 2009}, {"title": "Using CSP look-back techniques to solve real-world SAT instances", "author": ["R.J. Bayardo", "R.C. Schrag"], "venue": "In Proceedings of the Fourtheenth National Conference on Artificial Intelligence", "citeRegEx": "Bayardo and Schrag,? \\Q1997\\E", "shortCiteRegEx": "Bayardo and Schrag", "year": 1997}, {"title": "Understanding the power of clause learning", "author": ["P. Beame", "H.A. Kautz", "A. Sabharwal"], "venue": "Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence", "citeRegEx": "Beame et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2003}, {"title": "Towards understanding and harnessing the potential of clause learning", "author": ["P. Beame", "H.A. Kautz", "A. Sabharwal"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Beame et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Beame et al\\.", "year": 2004}, {"title": "Lower bounds for width-restricted clause learning on small width formulas", "author": ["E. Ben-Sasson", "J. Johannsen"], "venue": "Proceedings of 13th International Conference on Theory and Applications of Satisfiability Testing (SAT),", "citeRegEx": "Ben.Sasson and Johannsen,? \\Q2010\\E", "shortCiteRegEx": "Ben.Sasson and Johannsen", "year": 2010}, {"title": "Short proofs are narrow - resolution made simple", "author": ["E. Ben-Sasson", "A. Wigderson"], "venue": "In Proceedings of the Thirty-First Annual ACM Symposium on Theory of Computing (STOC", "citeRegEx": "Ben.Sasson and Wigderson,? \\Q1999\\E", "shortCiteRegEx": "Ben.Sasson and Wigderson", "year": 1999}, {"title": "Constraint satisfaction, bounded treewidth, and finite-variable logics", "author": ["V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi"], "venue": "In CP \u201902: Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming,", "citeRegEx": "Dalmau et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Dalmau et al\\.", "year": 2002}, {"title": "Clause learning can effectively p-simulate general propositional resolution", "author": ["P. Hertel", "F. Bacchus", "T. Pitassi", "A.V. Gelder"], "venue": null, "citeRegEx": "Hertel et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hertel et al\\.", "year": 2008}, {"title": "Local consistency and sat-solvers", "author": ["P. Jeavons", "J. Petke"], "venue": "In Proceedings of the 16th International Conference on Principles and Practice of Constraint Programming - CP 2010,", "citeRegEx": "Jeavons and Petke,? \\Q2010\\E", "shortCiteRegEx": "Jeavons and Petke", "year": 2010}, {"title": "Chaff: Engineering an efficient SAT solver", "author": ["M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "In Proceedings of the 38th Design Automation Conference (DAC\u201901)", "citeRegEx": "Moskewicz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "Solving SAT and SAT Modulo Theories: From an abstract Davis\u2013Putnam\u2013Logemann\u2013Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM,", "citeRegEx": "Nieuwenhuis et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "Narrow proofs may be spacious: Separating space and width in resolution", "author": ["J. Nordstr\u00f6m"], "venue": "SIAM J. Comput.,", "citeRegEx": "Nordstr\u00f6m,? \\Q2009\\E", "shortCiteRegEx": "Nordstr\u00f6m", "year": 2009}, {"title": "A new clause learning scheme for efficient unsatisfiability proofs", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": null, "citeRegEx": "Pipatsrisawat and Darwiche,? \\Q2008\\E", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2008}, {"title": "On the power of clause-learning SAT solvers with restarts", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": "Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming - CP 2009,", "citeRegEx": "Pipatsrisawat and Darwiche,? \\Q2009\\E", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2009}, {"title": "Grasp - a new search algorithm for satisfiability", "author": ["J.P.M. Silva", "K.A. Sakallah"], "venue": "In Proceedings of IEEE/ACM International Conference on Computer-Aided Design,", "citeRegEx": "Silva and Sakallah,? \\Q1996\\E", "shortCiteRegEx": "Silva and Sakallah", "year": 1996}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.W. Moskewicz", "S. Malik"], "venue": "In International Conference on ComputerAided Design (ICCAD\u201901),", "citeRegEx": "Zhang et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 6, "context": "a subsystem of resolution (Beame et al., 2003).", "startOffset": 26, "endOffset": 46}, {"referenceID": 6, "context": "a subsystem of resolution (Beame et al., 2003). In particular, this means that their performance can never beat resolution lower bounds, and at the same time it provides many explicit examples where SAT-solvers require exponential time. Complementing this is the result that an idealized SAT-solver that relies on non-determinism to apply the techniques in the best possible way will be able to perform as good as general resolution (weak forms of this statement were first established in Beame et al., 2003, 2004; Hertel et al., 2008, and in the current form in Pipatsrisawat & Darwiche, 2009). As Beame et al. (2004) put it, the negative proof complexity results uncover examples of inherent intractability even under perfect choice strategies, while the positive proof complexity results give hope of finding a good choice strategy.", "startOffset": 27, "endOffset": 619}, {"referenceID": 9, "context": "Finally, from the partial automatizability results of Ben-Sasson and Wigderson (1999), it follows that SAT-solvers are able to solve formulas having polynomial-size tree-like resolution proofs in quasipolynomial time, and formulas having polynomial-size general resolution proofs in subexponential time.", "startOffset": 54, "endOffset": 86}, {"referenceID": 11, "context": "Following work showed that the requirement for multiple assignments on the same variable is a technical issue that can be avoided if the given CNF formula is pre-processed appropriately (Hertel et al., 2008).", "startOffset": 186, "endOffset": 207}, {"referenceID": 4, "context": "The first attempt to compare the power of SAT-solvers with the power of resolution as a proof system was made by Beame et al. (2003, 2004). The main positive result from their work is that clause learning with a specific learning scheme and without restarts can provide exponentially shorter proofs than proper refinements of resolution such as tree, or regular, or positive resolution. Furthermore, they show that the modification of a standard solver to allow multiple assignments on the same variable would be able to simulate general resolution efficiently, assuming an ideal decision strategy. Following work showed that the requirement for multiple assignments on the same variable is a technical issue that can be avoided if the given CNF formula is pre-processed appropriately (Hertel et al., 2008). In our work we avoid these two maneuvers by introducing the concept of clause-absorption to help us analyze the standard algorithms directly. Interestingly, for clauses that are logical consequences of the input formulas, our concept of clause-absorption turns out to be dual to the concept of 1-empowerment introduced independently by Pipatsrisawat and Darwiche (2009)1.", "startOffset": 113, "endOffset": 1178}, {"referenceID": 0, "context": "To complete this point, it is worth noting that the non-automatizability results of Alekhnovich and Razborov (2008) indicate that we cannot expect an efficient simulation of general resolution and completely avoid non-determinism at the same time.", "startOffset": 84, "endOffset": 116}, {"referenceID": 16, "context": "Note that, originally, a weaker version of 1-empowerment was introduced by Pipatsrisawat and Darwiche (2008).", "startOffset": 75, "endOffset": 109}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause.", "startOffset": 73, "endOffset": 93}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause. If d denotes the maximum decision level of the assignments in Sr, a conflict clause is called an asserting clause if it contains exactly one variable of decision level d. Asserting clauses, originally defined by Zhang et al. (2001), capture the properties of conflict clauses learned by virtually any modern SAT-solver.", "startOffset": 73, "endOffset": 368}, {"referenceID": 6, "context": "In fact, the resolution proof is linear and even trivial in the sense of Beame et al. (2004). We call each clause Ai a conflict clause. If d denotes the maximum decision level of the assignments in Sr, a conflict clause is called an asserting clause if it contains exactly one variable of decision level d. Asserting clauses, originally defined by Zhang et al. (2001), capture the properties of conflict clauses learned by virtually any modern SAT-solver. For brevity, we describe only two concrete learning schemes in detail. For other schemes see the work of Zhang et al. (2001). The Decision learning scheme adds clause A1 to the current set of clauses after each conflict.", "startOffset": 73, "endOffset": 581}, {"referenceID": 15, "context": "In this respect, the strong proof-complexity results of Nordstr\u00f6m (2009) showing that not every small-width resolution refutation can be made to work in small clause-space seems to indicate that an assumption similar to ours is indeed needed.", "startOffset": 56, "endOffset": 73}, {"referenceID": 8, "context": "Moreover, recent results by Ben-Sasson and Johannsen (2010) show that, in general, learning short clauses only is a provably weaker scheme than learning arbitrarily long clauses.", "startOffset": 28, "endOffset": 60}, {"referenceID": 8, "context": "Moreover, recent results by Ben-Sasson and Johannsen (2010) show that, in general, learning short clauses only is a provably weaker scheme than learning arbitrarily long clauses. Thus, while the examples of Ben-Sasson and Johannsen (2010) do not have small-width resolution refutations and therefore do not show that keeping long clauses is actually required in this case, it is conceivable that it might.", "startOffset": 28, "endOffset": 239}, {"referenceID": 16, "context": "In this section we also show that the notion of clause-absorption is tightly connected to the concept of 1-empowerment independently introduced by Pipatsrisawat and Darwiche (2009).", "startOffset": 147, "endOffset": 181}, {"referenceID": 16, "context": "Let us reproduce the definition of 1-empowerment in the work of Pipatsrisawat and Darwiche (2009), slightly adapted to better suit our notation and terminology.", "startOffset": 64, "endOffset": 98}, {"referenceID": 16, "context": "A preliminary version of this definition was given by Pipatsrisawat and Darwiche (2008) where the second of the three conditions was not required.", "startOffset": 54, "endOffset": 88}, {"referenceID": 2, "context": "A similar connection to clause learning was observed by Pipatsrisawat and Darwiche (2008), where it is also pointed out that the condition that some literal from C appears in both A and B is known as merge resolution (Andrews, 1968).", "startOffset": 217, "endOffset": 232}, {"referenceID": 15, "context": "A similar connection to clause learning was observed by Pipatsrisawat and Darwiche (2008), where it is also pointed out that the condition that some literal from C appears in both A and B is known as merge resolution (Andrews, 1968).", "startOffset": 56, "endOffset": 90}, {"referenceID": 16, "context": "We note that this proof has to overcome similar difficulties as, and is inspired by3, the proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009). We need some preparation.", "startOffset": 128, "endOffset": 162}, {"referenceID": 16, "context": "We thank an anonymous reviewer for pointing out that the original proof of Proposition 2 in the work of Pipatsrisawat and Darwiche (2009) contained an error that was corrected in the version of the paper on their webpage.", "startOffset": 104, "endOffset": 138}, {"referenceID": 4, "context": "A preliminary version of this paper appeared in the Proceedings of the 12th International Conference on Theory and Applications of Satisfiability Testing, SAT\u201909 (Atserias et al., 2009).", "startOffset": 162, "endOffset": 185}], "year": 2011, "abstractText": "We offer a new understanding of some aspects of practical SAT-solvers that are based on DPLL with unit-clause propagation, clause-learning, and restarts. We do so by analyzing a concrete algorithm which we claim is faithful to what practical solvers do. In particular, before making any new decision or restart, the solver repeatedly applies the unit-resolution rule until saturation, and leaves no component to the mercy of non-determinism except for some internal randomness. We prove the perhaps surprising fact that, although the solver is not explicitly designed for it, with high probability it ends up behaving as width-k resolution after no more than O(n) conflicts and restarts, where n is the number of variables. In other words, width-k resolution can be thought of as O(n) restarts of the unit-resolution rule with learning.", "creator": "TeX"}}}